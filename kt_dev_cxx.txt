*kt_dev_cxx*                                                     tw=80, utf-8

/^[#=]{
Use #{ for a group and ={ for a item


Write what you know and konw what you write. - EXC++, Herb Sutter

An expert is a man who has made all the mistakes that can be made, in a very
narrow field. -Nils Bohr


TODO:
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. CPP

#{ gcc
|kt_dev_guti_000| gnu core util sites
|kt_dev_gcc_000| gcc-compile-script
|kt_dev_gcc_001| gcc-error: two or more data types in declaration specifiers <bool> 
|kt_dev_gcc_002| gcc-error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]
*kt_dev_cxx_0000* cxx-error-invalid conversion
*kt_dev_cxx_0000* cxx-error-Wsequence-point
|kt_dev_gcc_004| error: variable-sized object 'out' may not be initialised
|kt_dev_gcc_005| error: expected '}' at end of input
|kt_dev_gcc_006| error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 
|kt_dev_gcc_007| error: expected '=', ',', ';', 'asm' or '__attribute__' before
|kt_dev_gcc_008| warn: deprecated conversion from string constant to 'char*' [-Wwrite-strings]
|kt_dev_gcc_009| gcc-error: jump to case label and crosses initialisation of 
|kt_dev_gcc_010| error: dereferencing pointer to incomplete type
*kt_dev_gcc_011* error: void value not ignored as it ought to be
*kt_dev_gcc_011* error-cpp-preprocessor
*kt_dev_gcc_011* error-invalid-storage-class
*kt_dev_gcc_012* warn: may be used uninitialized in this function -Wmaybe-uninitialized

*kt_dev_gcc_100* gcc-doc gcc-header
*kt_dev_gcc_100* cpp-standard
*kt_dev_cxx_0000* cxx-nullptr
|kt_dev_gcc_101| gcc-typeof
|kt_dev_cxx_0000| gcc-likely cxx-likely cxx-expect
|kt_dev_gcc_106| gcc: link: lrt
|kt_dev_gcc_107| gcc: link: sysroot and rpath-link
|kt_dev_gcc_111| gcc: profiling

*kt_dev_cxx_0000* cxx-cpp-defined
*kt_dev_cxx_0000* cxx-cpp-use
*kt_dev_cxx_0000* cxx-cpp-issue
*kt_dev_cxx_0000* cxx-cpp-do-while
*kt_dev_cxx_0000* cxx-cpp-stringification
*kt_dev_cxx_0000* cxx-cpp-concatenation cpp-##

#{ cxx
*kt_dev_cxx_0000* cxx-type cxx-twos-complement
*kt_dev_cxx_0000* cxx-bits cxx-builtin-type
*kt_dev_cxx_0000* cxx-bits cxx-limits
*kt_dev_cxx_0000* cxx-type cxx-32-bit cxx-64-bit
*kt_dev_cxx_0000* cxx-printf-format cxx-vaarg
*kt_dev_cxx_0000* cxx-bits cxx-bitset cxx-align
*kt_dev_cxx_0000* cxx-cast cpp-pointer-handle
*kt_dev_cxx_0000* cxx-issue-incremental-build
*kt_dev_cxx_0001* cxx-volatile
*kt_dev_cxx_0000* cxx-stream cxx-stdio
*kt_dev_cxx_0000* cxx-stream cxx-file
*kt_dev_cxx_0000* cxx-stream-cxx-stringstream
*kt_dev_cpp_0004* cxx-postfix
*kt_dev_cpp_0004* expr-chain
|kt_dev_lang_011| expr-literal
*kt_dev_cxx_0004* cxx-pointer cxx-array
*kt_dev_cpp_0004* pointer-argv
*kt_dev_cpp_0004* pointer-null
*kt_dev_cpp_0004* pointer-reading
*kt_dev_cxx_0000* cxx-cstring cxx-check cxx-sizeof
*kt_dev_cxx_0000* cxx-switch
*kt_dev_cxx_0000* cxx-loop cxx-for cxx-while cxx-side-effect
|kt_dev_cxx_0000| cxx-precedence
*kt_dev_cxx_0000* cxx-evaluation-order
*kt_dev_lang_016* expr-unary
*kt_dev_lang_016* expr-assign
*kt_dev_cxx_0000* cxx-op-conditional (the ?: operator)
*kt_dev_cxx_0000* cxx-code-style
*kt_dev_cxx_0000* cxx-code-style-bracing-allman
*kt_dev_cxx_0000* cxx-code-deep-nested-if

*kt_dev_cxx_0000* cxx-reference
*kt_dev_cxx_0000* cxx-oop
*kt_dev_cxx_0000* cxx-ctor
*kt_dev_cxx_0000* cxx-init-form
*kt_dev_cxx_0000* cxx-init-copy-form
*kt_dev_cxx_0000* cxx-init-list cxx-initializer-list
*kt_dev_cxx_0000* cxx-dtor cxx-non-virtial-destruction-problem
*kt_dev_cxx_0000* cxx-default-argument
*kt_dev_cxx_0000* cxx-copy-control
*kt_dev_cxx_0000* cxx-copy-assign-self
*kt_dev_cxx_0000* cxx-pass-by-reference cxx-reference
*kt_dev_cxx_0000* cxx-vexing-parse
*kt_dev_cxx_0000* cxx-copy-dyn-resource cxx-ex-hasptr-exmaple
*kt_dev_cxx_0000* cxx-copy-swap cxx-swap copy-and-swap-idiom
*kt_dev_cxx_0000* cxx-copy-control cxx-ex-message-example
*kt_dev_cxx_0000* cxx-move cxx-ex-strvec-example
*kt_dev_cxx_0000* cxx-move
*kt_dev_cxx_0000* cxx-ex-query-example cpp-interface
*kt_dev_cxx_0000* cxx-abc cxx-ex-quote-example cxx-refactoring
*kt_dev_cxx_0000* cxx-abc-call-in-dtor
*kt_dev_cxx_0000* cxx-copy-prevent-copies cxx-delete
|kt_dev_cxx_0000| cxx-function-matching
*kt_dev_cxx_0000* cxx-function-alias
*kt_dev_cxx_0000* cxx-namespace cxx-interface *kt_dev_cxx_0000* cxx-overload-operator
*kt_dev_cxx_0000* cxx-integer-division
*kt_dev_cxx_0000* cxx-type-conversion cxx-explicit
*kt_dev_cxx_0000* cxx-temporary
*kt_dev_cxx_0000* cxx-return-rvo cxx-rvo
*kt_dev_cxx_0000* cxx-return cxx-undefined
*kt_dev_cxx_0000* cxx-bool
*kt_dev_cxx_0000* cxx-bool-conversion-cxx-conversion-to-bool
*kt_dev_cxx_0000* cxx-const 
*kt_dev_cpp_0008* cxx-const-temporary
*kt_dev_cxx_0000* cxx-const-member-function cxx-this cxx-overload-condition
*kt_dev_cxx_0000* cxx-const-bitwise
*kt_dev_cxx_0000* cxx-const-logical
*kt_dev_cxx_0000* cxx-const-mutable cxx-mutable
*kt_dev_cxx_0000* cxx-const-read-logical-state
*kt_dev_cxx_0000* cxx-const-read-const-correctness
*kt_dev_cxx_0000* cxx-const-read-correctness
*kt_dev_cxx_0000* cxx-const-constexpr
*kt_dev_cxx_0000* cxx-inline
*kt_dev_cxx_0000* cxx-auto
*kt_dev_cxx_0000* cxx-decltype cxx-typedef cxx-struct {class-vs-struct} 
|kt_dev_cpp_016| cpp-pointer-array
*kt_dev_cxx_0000* cxx-static-members cxx-static-class-const
*kt_dev_cxx_0000* cxx-except
*kt_dev_cxx_0000* cxx-except-dtor-ctor cxx-except-stack-unwinding
*kt_dev_cxx_0000* cxx-except-noexcept
*kt_dev_cxx_0000* cxx-except-safety
*kt_dev_cpp_019* except-disable
*kt_dev_cpp_019* except-terminate-call-tree
|kt_dev_cpp_019| except-case
*kt_dev_cpp_019* except-and-finally
*kt_dev_cxx_0000* cxx-inheri
*kt_dev_cxx_0000* cxx-inheri-multiple
*kt_dev_cxx_0000* cxx-inheri-ctor-init
*kt_dev_cxx_0000* cxx-access-control
*kt_dev_cxx_0000* cxx-cast cxx-named-cast
*kt_dev_cxx_0000* cxx-rtti
*kt_dev_cxx_0000* cxx-override
*kt_dev_cxx_0000* cxx-override-ref: C++ under the hood, Scott Meyers
*kt_dev_cxx_0000* cxx-class-model
*kt_dev_cxx_0000* cxx-class-model-avoid-public cxx-pattern-strategy
*kt_dev_cxx_0000* cxx-class-model-implemented-in-terms-of
*kt_dev_cxx_0000* cxx-pattern-template-method
*kt_dev_cxx_0000* cxx-pattern-pimpl cxx-minimise-compile-time
*kt_dev_cxx_0000* cxx-pattern-interface
*kt_dev_cxx_0000* cxx-pattern-singleton
*kt_dev_cxx_0000* cxx-pattern-factory
*kt_dev_cxx_0000* cxx-pattern-observer
*kt_dev_cxx_0000* cxx-pattern-decorator
*kt_dev_cxx_0000* cxx-pattern-composite
*kt_dev_cxx_0000* cxx-pattern-chain-of-responsibility
*kt_dev_cxx_0000* cxx-incomplete-type cpp-forward-declaration cpp-layout
*kt_dev_cxx_0000* cxx-empty-base-class-optimization

*kt_dev_cxx_0000* cxx-design-defines-problem
*kt_dev_cxx_0000* cxx-design-by-contract 
*kt_dev_cxx_0000* cxx-design-define-variable
*kt_dev_cxx_0000* cxx-design-interface-first
*kt_dev_cxx_0000* cxx-design-core-guide

*kt_dev_cxx_0000* cxx-new-delete
*kt_dev_cxx_0000* cxx-allocator
*kt_dev_cxx_0000* cxx-random
*kt_dev_cxx_0000* cxx-enum
*kt_dev_cxx_0000* cxx-nested-class
*kt_dev_cxx_0000* cxx-regex

*kt_dev_cxx_0000* cxx-template-decode-error
*kt_dev_cxx_0000* cxx-template-function
*kt_dev_cxx_0000* cxx-template-class cxx-template-friend
*kt_dev_cxx_0000* cxx-template-type-member
*kt_dev_cxx_0000* cxx-template-default-argument
*kt_dev_cxx_0000* cxx-template-member
*kt_dev_cxx_0000* cxx-template-explicit-instantiation
*kt_dev_cxx_0000* cxx-template-explicit-argument
*kt_dev_cxx_0000* cxx-template-type-traits cxx-type-traits
*kt_dev_cxx_0000* cxx-template-argument-deduction std-move
*kt_dev_cxx_0000* cxx-template-forward
*kt_dev_cxx_0000* cxx-template-overload
*kt_dev_cxx_0000* cxx-template-variadic
*kt_dev_cxx_0000* cxx-template-specialization
*kt_dev_cpp_054* template-inheritance

|kt_dev_cpp_300| case: framework {tizen-case}
|kt_dev_cpp_301| case: wrapper
|kt_dev_cpp_302| case: porting layer
|kt_dev_cpp_304| case: overload

*kt_dev_cxx_0000* cxx-stl
*kt_dev_cxx_0000* cxx-pair cxx-tuple
*kt_dev_cxx_0000* cxx-minmax cxx-min cxx-max
*kt_dev_cxx_0000* cxx-ref

*kt_dev_cxx_0000* cxx-coll
*kt_dev_cxx_0000* cxx-coll-performance
*kt_dev_cxx_0000* cxx-coll-element-type
*kt_dev_cxx_0000* cxx-coll-common-operations
*kt_dev_cxx_0000* cxx-coll-insert-erase cxx-iter-invalidate
*kt_dev_cxx_0000* cxx-coll-remove cxx-remove
*kt_dev_cxx_0000* cxx-coll-sequential
*kt_dev_cxx_0000* cxx-coll-cxx-array
*kt_dev_cxx_0000* cxx-coll-cxx-vector
*kt_dev_cxx_0000* cxx-coll-cxx-vector-bool
*kt_dev_cxx_0000* cxx-coll-cxx-deque
*kt_dev_cxx_0000* cxx-coll-cxx-queue cxx-adaptor
*kt_dev_cxx_0000* cxx-coll-cxx-stack cxx-adaptor
*kt_dev_cxx_0000* cxx-coll-cxx-list
*kt_dev_cxx_0000* cxx-coll-cxx-list-forward-list

*kt_dev_cxx_0000* cxx-coll-associative
*kt_dev_cxx_0000* cxx-coll-cxx-set cxx-multiset
*kt_dev_cxx_0000* cxx-coll-cxx-map cxx-multimap cxx-size-t
*kt_dev_cxx_0000* cxx-coll-unordered
*kt_dev_cxx_0000* cxx-container-print-elements

*kt_dev_cxx_0000* cxx-iter
*kt_dev_cxx_0000* cxx-iter-case cxx-case-iter
*kt_dev_cxx_0000* cxx-iter-array
*kt_dev_cxx_0000* cxx-iter-adapters
*kt_dev_cxx_0000* cxx-iter-external-and-internal

*kt_dev_cxx_0000* cxx-fobj cxx-function-object cxx-functor
*kt_dev_cxx_0000* cxx-fobj-predicate cxx-callable
|kt_dev_cxx_0000| cxx-fobj-lambda cxx-lambda
*kt_dev_stl_063* cpp-fobj-as-argument
*kt_dev_stl_063* cpp-fobj-pass-by-reference
*kt_dev_cxx_0000* cxx-fobj-function-type cxx-function-adaptor
*kt_dev_cxx_0000* cxx-fobj-type cxx-function-pointer
*kt_dev_cxx_0000* cxx-fobj-bind cxx-bind
*kt_dev_cxx_0000* cxx-fobj-bind-member-function
*kt_dev_cxx_0000* cxx-algo
*kt_dev_cxx_0000* cxx-algo-non-modifying
*kt_dev_cxx_0000* cxx-algo-modifying
*kt_dev_cxx_0000* cxx-algo-mutating

*kt_dev_cxx_0000* cpp-stream cpp-cout cpp-cin

*kt_dev_cxx_0000* cxx-string
*kt_dev_cxx_0000* cxx-string-code
*kt_dev_cxx_0000* cxx-string-operations
*kt_dev_cxx_0000* cxx-string-find
*kt_dev_cxx_0000* cxx-string-numeric-conversion cxx-boost-lexical-cast
*kt_dev_cxx_0000* cxx-string-iterator
*kt_dev_stl_075* stl-string: seg fault
*kt_dev_cxx_0000* cxx-sp-raii cxx-raii
*kt_dev_cxx_0000* cxx-sp-shared
*kt_dev_cxx_0000* cxx-sp-weak
*kt_dev_cxx_0000* cxx-sp-exception
*kt_dev_cxx_0000* cxx-sp-unique cxx-auto-ptr
*kt_dev_cxx_0000* cxx-sp-delete sp-deleter
*kt_dev_cxx_0000* cxx-sp-read: can store unique_ptr in a container?
*kt_dev_cxx_0000* cxx-sp-issue cxx-sp-shared-from-this
*kt_dev_cxx_0000* cxx-sp-read exception safety
*kt_dev_cxx_0000* cxx-sp-read internal
*kt_dev_cxx_0000* cxx-sp-code
*kt_dev_cxx_0000* cxx-sp-thread-safety
*kt_dev_cxx_0000* cxx-sp-case-examples

*kt_dev_cxx_0000* cxx-chrono cxx-time

#{ MORE EFFECTIVE C++ 1ST, 1996, 25TH PRINTING
|kt_dev_mecpp_001| 16: 80-20 rule and profiler
|kt_dev_mecpp_002| 17: lazy evaluation
|kt_dev_mecpp_003| 18: over-eager evaluation
|kt_dev_mecpp_004| 
|kt_dev_mecpp_005| 25: reference-counting
|kt_dev_mecpp_006| 28: log entry
|kt_dev_mecpp_007| link-combine C and C++
|kt_dev_mecpp_008| 32: program in the future tense

#{ EFFECTIVE STL 3RD
|kt_dev_estl_001| design: 02: illusion of container-independent code


#{ c++ concurrent in action
*kt_dev_cxx_0000* cxx-ccon-thread-build cxx-boost-thread
*kt_dev_cxx_0000* cxx-thread
*kt_dev_cxx_0000* cxx-ccon-mutex cxx-threadsafe-stack cxx-lock-guard cxx-race
*kt_dev_cxx_0000* cxx-ccon-not-copyable
*kt_dev_cxx_0000* cxx-ccon-lock cxx-deadlock
*kt_dev_cxx_0000* cxx-ccon-lock-unique-lock
*kt_dev_cxx_0000* cxx-ccon-call-once
*kt_dev_cxx_0000* cxx-ccon-lock-shared-lock cxx-boost-shared-lock
*kt_dev_cxx_0000* cxx-ccon-lock-recursive-lock
*kt_dev_cxx_0000* cxx-condition-variable cxx-queue
*kt_dev_cxx_0000* cxx-atomic
*kt_dev_cxx_0000* cxx-wait cxx-sleep
*kt_dev_cxx_0000* cxx-ccon-task-model cxx-future cxx-async
*kt_dev_cxx_0000* cxx-ccon-promise cxx-promise
*kt_dev_cxx_0000* cxx-ccon-packaged-task
*kt_dev_cxx_0000* cxx-con-lock-based-data-structure
*kt_dev_cxx_0000* cxx-ccon-other-paradigm cxx-fsm

*kt_dev_cxx_0000* cxx-fsm-case
*kt_dev_cxx_0000* cxx-fsm-comparison

#{ BLUSHES OR BUGS
|kt_dev_blush_001| accessing neighbors in array

#{ design
|kt_dev_design_001| generic structure access

|kt_dev_uml_001| aggragation

|kt_dev_ref_002| sites


#{============================================================================
#{ GCC
={============================================================================
*kt_dev_gcc_0000* gcc-coreutils

http://www.gnu.org/software/coreutils/
git clone git://git.sv.gnu.org/coreutils coreutils


={============================================================================
*kt_dev_gcc_000* gcc-compile-script

#!/bin/bash
g++ -g -std=c++0x $1


={============================================================================
*kt_dev_gcc_001* gcc-error: two or more data types in declaration specifiers

This error happened under gcc c build when include a header having:

#ifndef __cplusplus
typedef uint8_t bool;
#endif

Thought that it means duplication defined in somewhere and tried:


<1> no error
#include <stdio.h>

typedef unsigned char bool;
typedef unsigned char bool;


<2> errors
#include <stdio.h>

typedef unsigned char bool;
typedef int bool;

testerrfunc.c:4:13: error: conflicting types for 'bool'
testerrfunc.c:3:23: note: previous declaration of 'bool' was here


<3>
#include <stdio.h>

#define bool unsigned char
typedef int bool;

c:4:13: error: two or more data types in declaration specifiers
c:4:1: warning: useless type name in empty declaration [enabled by default]

This expands to "typedef int unsigned char;" Hence error.


<4>
no error
#define bool unsigned char
#define bool unsigned char

#define MYBOOL 1
#define MYBOOL 3
sam01.cpp:6:0: warning: "MYBOOL" redefined [enabled by default]


{stdbool.h} {preprocessor-options}
Tried to preprocessor output using "-E" option but not that useful. But found
following line from the output and when followed that file, found what went
wrong:

From -E output using GCC 453.  
# 1 "/usr/lib/gcc/armv7l-tizen-linux-gnueabi/4.5.3/include/stdbool.h" 1 3 4

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */

#ifndef _STDBOOL_H
#define _STDBOOL_H

#ifndef __cplusplus

#define bool	_Bool
#define true	1
#define false	0

#else /* __cplusplus */

/* Supporting <stdbool.h> in C++ is a GCC extension.  */
#define _Bool	bool
#define bool	bool
#define false	false
#define true	true

#endif /* __cplusplus */

/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined	1
#endif	/* stdbool.h */

note: 
This header is not automatically included when use stdio.h. So what's the real
issues here?

From GCC: http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types

1.2 Keywords

Keywords are special identifiers reserved for use as part of the programming
language itself. You cannot use them for any other purpose. 

ISO C99 adds the following keywords:
     inline _Bool _Complex _Imaginary

So the issue is that "_Bool" is a keyword. Okay, why key keyword?


={============================================================================
*kt_dev_gcc_002* gcc-error: ISO C++ forbids declaration of X with no type [-fpermissive]

<1>
class UseStaic
{
  public:
    UseStatic() { std::cout << "Use staic ctor" << std::endl; }

  private:
    Sclass m_sclass;
};

Happened when made a typo in class name and meant to be class UseStatic.
Basically, not able to find UseStatic type.

<2> when missed void return.
template <typename T>
PRINT_ELEMENTS( T& coll, const string optstr="" )
{
  cout << optstr;

  for( const auto &elem : coll )
    cout << elem << " ";

  cout << endl;
}

error: ISO C++ forbids declaration of ‘PRINT_ELEMENTS’ with no type
[-fpermissive]


{fpermissive}
-fpermissive

Downgrade some diagnostics about nonconformant code from errors to warnings.
Thus, using -fpermissive allows some nonconforming code to compile. 


{when-missed-include}

<example-one>

#include < iostream>
// #include < stack>

using namespace std;

int main()
{
	int n;
	double item;
	stack<double> numbers;
	...
}

usestack.cpp:11:2: error: 'stack' was not declared in this scope
usestack.cpp:11:8: error: expected primary-expression before 'double'
usestack.cpp:11:8: error: expected ';' before 'double'


<example-two>

#include < iostream>
// #include < stack>

int main()
{
	int n;
	double item;
	std::stack<double> numbers;
	...
}

usestack.cpp:8:2: error: 'stack' is not a member of 'std'
usestack.cpp:8:13: error: expected primary-expression before 'double'
usestack.cpp:8:13: error: expected ';' before 'double'

Does it mean that it gives more reason not to use using-directive?


={============================================================================
*kt_dev_cxx_0000* cxx-error-invalid conversion

error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]

This is an error when tried convert from base to derived.

class Singleton
{
	protected:
	Singleton() {};

	public:
	virtual Singleton* Instance();

	protected:
	static Singleton* m_pins;
};

Singleton* Singleton::m_pins = 0;

Singleton* Singleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "Singleton::Instance" << std::endl;
		//m_pins = new Singleton;
	}

	return m_pins;
}

class MySingleton : public Singleton
{
	public:
	virtual MySingleton* Instance();
};

MySingleton* MySingleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "MySingleton::Instance" << std::endl;
		//_pins = new MySingleton;
	}

	return m_pins; // error
}

.cpp: In member function 'virtual MySingleton* MySingleton::Instance()':
.cpp:106:9: error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]


={============================================================================
*kt_dev_cxx_0000* cxx-error-Wsequence-point

{
  // revise reverse_bits_1()
  // Runtime: 4 ms, faster than 69.13% of C++ online submissions for Reverse Bits.
  // Memory Usage: 5.9 MB, less than 91.90% of C++ online submissions for Reverse Bits.
  uint32_t reverse_bits_3(uint32_t n)
  {
    uint32_t result{};

    for (size_t i = 0; i < 32; ++i)
    {
      // warning: operation on ‘result’ may be undefined [-Wsequence-point]
      result = ((result <<= 1) | (n & 0x1));
      n >>= 1;
    }

    return result;
  }

  // no warning
  uint32_t reverse_bits_3(uint32_t n)
  {
    uint32_t result{};

    for (size_t i = 0; i < 32; ++i)
    {
      uint32_t temp = result <<= 1;
      result = (temp | (n & 0x1));
      n >>= 1;
    }

    return result;
  }
}

note
This seems to be "false positive" since the order do not matter here:

      result = ((result <<= 1) | (n & 0x1));


https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html


https://www.ibm.com/support/knowledgecenter/SSB23S_1.1.0.2020/common/m1rhoseq.html
Problem: I received the following warning: operation on ‘vq’ may be undefined
[-Wsequence-point]

Solution: The GNU Compiler Collection (GCC) 4.6.3 issues a warning when the
sequence order of operations is ambiguous.

In the following example, the vq pointer variable is both set and compared on
the same statement. It might not be immediately clear whether the vq pointer
variable is updated first and then used in the comparison, or used in the
comparison and then updated. Because of the precedence and associativity of
operators, == has a higher order of precedence than =, so the compiler does the
comparison first and then updates the vq pointer variable. This might or might
not be what was intended. The undefined operation [-Wsequence-point] warning is
enabled by specifying the -Wall compiler option for C/C++ language.

 if ((vq = *vp->v_hashchain) == vq->v_specnext)
 {
    ... 
 }       

Rewriting the code eliminates the compiler warning. In the following example,
rewriting the code also has the advantage of removing the ambiguity.

 vq = *vp->v_hashchain;                           
 if (vq == vq->v_specnext)                        
 {     
    ...
 }                                    
   
Note
The -Wsequence-point warning can be valuable; therefore, do not suppress the
warning by using the -Wno-sequence-point compiler option unless you are sure
that your code is correct.


https://stackoverflow.com/questions/40677318/wsequence-point-warning-what-does-it-mean-and-does-it-violate-ansi-c-standard

tab[i] = tab[i+1] - tab[i] + (tab[i+1] = tab[i]);

Your code relies on behaviour that is not covered by the standard. So your code
may behave differently on different compilers, different versions of the same
compiler and even behave differently depending on the surrounding code.

The problem is that you evaluate and assign to tab[i+1] without a separating
sequence point. It may seem obvious to you that your program will perform the
calculation from left to right, but the C standard does not require this. A
compiler could compile your code as:

tab[i+1] = tab[i];
tab[i] = tab[i+1] - tab[i] + tab[i+1];


==============================================================================
*kt_dev_gcc_004*	error: variable-sized object 'out' may not be initialised

void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
	Entry out[length];			// this works fine but not inited.
	Entry out[length] = {0};	// this causes an error
	Entry out[30] = {0};			// this works
}


I am assuming that you are using a C99 compiler (with support for dynamically sized arrays). The
problem in your code is that at the time when the compilers sees your variable declaration it cannot
know how many elements there are in the array (I am also assuming here, from the compiler error that
length is not a compile time constant). 

So should use memset or alloc in a function. [KT] Think from compiler perspective.

==============================================================================
*kt_dev_gcc_005*	error: expected ‘}’ at end of input


#include <iostream>
#include "Fsm.h"

int main()
{
	std::cout << "--{ main " << std::endl;

	std::cout << "--} main " << std::endl;
}

main.cpp:9:1: error: expected ‘}’ at end of input

Have got this error and puzzled since there is not much in this file. Interestingly when remove
fsm.h include, builds. So thought it may not find this header? Spend some time to change makefile to
specify current directory in the gcc command line. This turns out that in fsm.h, there is a missing
closing brace and this cause this error.

#ifdef __cplusplus
extern "C"
{
#endif

  ...

//#ifdef __cplusplus
//}
//#endif


==============================================================================
*kt_dev_gcc_006*  error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

error: 'X' does not name a type 

This happens when there is no typedef or types declared before its use.

error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

This is the same as above but more difficult to find because it happes when include a lot of headers
and there is dependencies between them.

<buffer.h>

#include "semaphore.h" // here one of struct uses some from st.h
#include "st.h"

<buffer.c>

#include "buffer.h"
#include "st.h"

In file included from buffer.h:1, from buffer.c:4: 
semaphore.h:4: error: expected specifier-qualifier-list before 'st_cond_t'

This shows the order is important in header inclusion.

This also happens when use the same header guard for two different headers. This effectvely do not
include necessary header and hence the error.

#ifndef __MH5W_GPI_H__
#define __MH5W_GPI_H__


={============================================================================
*kt_dev_gcc_007*  error: expected '=', ',', ';', 'asm' or '__attribute__' before

<case-01>
Like this case when use CPP features in C, this is very obvious so errors are clear.

kit@kit-vb:~/work$ gcc repmanc.c 
repmanc.c:10:1: error: unknown type name 'class'
repmanc.c:11:1: error: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token

<case-02>
However, when there are many header files and they are cascaded each other, this is not obvious.
This happens because C file uses CPP header which defines classes and cannot handle class keyword.

In file included from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/OSAbstraction.h:10:0,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/app/MApp.h:26,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/main/view_main.c:28:
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/PCString.h:52:7: error: expected '=', ',',
';', 'asm' or '__attribute__' before 'PCMem'


={============================================================================
*kt_dev_gcc_008*  warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]

This happens when use string literal for char* member in GCC(g++) but it was fine before in C.

main.cpp:53:74: warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]

typedef struct fsm_instance {
   char*              name;
   ...
} fsm_instance_t;

fsm_instance_t Foo = { "Fsm", ... };

-Wwrite-strings

When compiling C, give string constants the type "const char[length]" so that copying the address of
one into a non-const char * pointer produces a warning. These warnings help you find at compile time
code that can try to 'write' into a string constant, but only if you have been very careful about
using 'const' in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not
make -Wall request these warnings.

When compiling C++, warn about the deprecated conversion from string literals to char *. This
warning is enabled by default for C++ programs. 

1) Should consider using std::string name; instead?
Not perferred since need to change other C codes to get c string. .c_str().

2) Should use const in declarations?

typedef struct fsm_instance {
   const char*              name;
   ...
} fsm_instance_t;

But this cause other warnings in other function defs using this strucrue due to const.

3) Should use char* where string literal used.
This (char*) is the easiest way.


={============================================================================
*kt_dev_gcc_009* jump to case label and crosses initialisation of

{code-example}
http://stackoverflow.com/questions/2392655/what-are-the-signs-of-crosses-initialization

<ex>
#include <iostream>
using namespace std;

int main()
{
  int x, y, i;

  cin >> x >> y >> i;

  switch(i) {
    case 1:
      // int r;         // a) okay
      // int r = x + y; // b) fail to compile
      // int r = 1;     // c) fail to compile
      cout << r;
      break;
    case 2:
      r = x - y;
      cout << r;
      break;
  };
}

:14:14: error: jump to case label   // note. this is main error.
:11:17: error:   crosses initialisation of ‘int r’

Why? Why is a) okay?

The Standard says (6.7/3):

It is possible to transfer into a block, but 'not' in a way that 'bypasses'
declarations with 'initialization'. A program that jumps 'from' a point where a
local variable with automatic storage duration is not in scope 'to' a point
where it is in scope is ill-formed unless the variable has POD type (3.9) and is
declared without an initializer (8.5).

note:
KT. from out of switch to inside of switch

1) The problem is that it is possible for r to come to scope without its
initializer being executed. The code would compile fine if you removed the
initializer completely (i.e. the line would read "int r;").

2) It will cause a "crosses initialization" error, because it is possible to
skip the initialization of r, but after that it will still be in scope, even
though it was never created in the first place. NOTE: this is not true since
switch is a single scope. see below examples.

<ex>
:281:10: error: jump to case label
:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'
:284:34: error: redeclaration of 'std::vector<unsigned char> abortCode'
:260:34: error: 'std::vector<unsigned char> abortCode' previously declared here
:295:5: error: jump to case label
:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'

    case SIGNAL_CI_APP_MMI_ABORT_REQ:
260:      std::vector<unsigned char> abortCode;
      ...
      break;

281:case SIGNAL_CI_APP_MMI_ABORT_ACK:
      ...
284:      std::vector<unsigned char> abortCode;

note:
KT. So the switch is a 'single' scope but has multiple blocks(jumps). The
problem is that there is chance to go any block such as default even if it is
not covered in code and this 'skip' the initiailisation. not clear why it causes
a problem but the 'best' thing you can do is to limit the scope of the variable.
That way you'll satisfy both the compiler and the reader. Or declare variables
before switch.

switch(i)
{
  case 1:
    {
      int r = 1;
      cout << r;
    }
    break;
  case 2:
    {
      int r = x - y;
      cout << r;
    }
    break;
};


={============================================================================
*kt_dev_gcc_010* error: dereferencing pointer to incomplete type

error: dereferencing pointer to incomplete type

struct
{
  ...
  Resources *resources;

} Mgr;

typedef struct _Resources {
    ...
    VideoDecoderHandle                 videoDecoder;
    ...
} Resources;

static callback( void* context ) 
{
    // this cause error
    Mgr* mgr = (GstNexusMgr*) context;
    if( VideoDecoder_GetStatus( mgr->resources->videoDecoder, &vset ) );

    // this works okay
    Resources *resources = (Resources *) context;
    if( VideoDecoder_GetStatus( resources->videoDecoder, &vset ) );
}


={============================================================================
*kt_dev_gcc_011* error: void value not ignored as it ought to be

error: void value not ignored as it ought to be

Error rc = N_Playpump_GetSettings(sharedMem->playpump[i], &pset);

/**
Summary:
Get current settings
**/
void N_Playpump_GetSettings(
    N_PlaypumpHandle playpump,
    N_PlaypumpSettings *pSettings /* [out] */
    );


={============================================================================
*kt_dev_gcc_011* error-cpp-preprocessor

Have missed `;` at the end of function declaration.

// <header-two>
VTABLE_GetElement_X(const VTable_t* vtable, uint32_t line)    // error
VTABLE_GetElement_X(const VTable_t* vtable, uint32_t line);   // okay

This header is included in various source and gcc shows errors which seemingly
  comes from completely unrelated.

This is becuase

// source one
#include "header one.h"

// header one
#include ...
#include "<header-two>.h"
#include "<header-three>.h"

Shows errors right from the beginning of <header-three> since <header-two> is
not properly completed by using `;` and affect the rest of preprocessing.


={============================================================================
*kt_dev_gcc_011* error-invalid-storage-class

Have missed ending brace and gets odd errors:

quota_resource.c: In function 'QuotasOnDevice_LimitQuotaSize':
quota_resource.c:4076: error: invalid storage class for function 'QuotasOnDevice_SetSizes'
quota_resource.c:4076: warning: no previous prototype for 'QuotasOnDevice_SetSizes'
quota_resource.c:4076: warning: declaration of 'QuotasOnDevice_SetSizes' shadows a global declaration
quota_resource.c:654: warning: shadowed declaration is here
quota_resource.c: In function 'QuotasOnDevice_SetSizes':
...
and errors on the rest of functions in that file.


PRVFUNC void QuotasOnDevice_LimitQuotaSize(RMF_QUOTA_Instance quota)
{
    if (quota->creationInfo.min_allowed_unit != RMF_QUOTA_SIZE_UNITS_UNDEF)
    {
        // long code
        {
            /*quotas[Idx]->creationInfo.max_size = quotas[Idx]->creationInfo.min_allowed_size;*/
            DIAG_LOG_INFO(gRmfSegmentId, ("max_size is lower than min_allowed_size. Zeroing size"));

            quota->creationInfo.max_size = i64zero;
        }
    // }

    if (quota->creationInfo.max_allowed_unit != RMF_QUOTA_SIZE_UNITS_UNDEF)
    {
        {
            quota->creationInfo.max_size = quota->creationInfo.max_allowed_size;
        }
    }
}


PRVFUNC SYSTEM_STATUS QuotasOnDevice_SetSizes(SYSTEMCOMMON_DEVICE_HANDLE device_handle)
{
}


={============================================================================
*kt_dev_gcc_012* warn: may be used uninitialized in this function -Wmaybe-uninitialized

error: 'value' may be used uninitialized in this function 
  [-Werror=maybe-uninitialized]

This is promoted to error since -Wall used. However, coundn't find easily why
it emited this warning in the code below:


else {
  ErrorEventValue::Enum errVal = ErrorEventValue::other;
  ErrorEventContext::Enum errContext = ErrorEventContext::other;

  if (...) {
    boost::tie(errVal, errContext) =
      mapGStreamerToMediaRouterError_src(error, text_msg, msg->src) ;

  } else if (...) {
    boost::tie(errVal, errContext) =
      mapGStreamerToMediaRouterError_sink(error);

  } else {
    errVal = ErrorEventValue::other;
    errContext = ErrorEventContext::other;
  }

  // ERROR:
  produceEvent(
      boost::bind(&MediaRouterEventListener::ErrorEvent, _1,
        errVal, errContext, text_msg));

  // OK: when use enum directly
  // produceEvent(
  //     boost::bind(&MediaRouterEventListener::ErrorEvent, _1,
  //                 ErrorEventValue::other, ErrorEventContext::other, test_msg));
}


From GCC:

-Wmaybe-uninitialized
    For an automatic variable, if there exists a path from the function entry
    to a use of the variable that is initialized, but there exist some other
    paths for which the variable is not initialized, the compiler emits a
    warning if it cannot prove the uninitialized paths are not executed at run
    time. These warnings are made optional because GCC is not smart enough to
    see all the reasons why the code might be correct in spite of appearing to
    have an error. Here is one example of how this can happen:

              {
                int x;
                switch (y)
                  {
                  case 1: x = 1;
                    break;
                  case 2: x = 4;
                    break;
                  case 3: x = 5;
                  }
                foo (x);
              }

    If the value of y is always 1, 2 or 3, then x is always initialized, but
    GCC doesn't know this. To suppress the warning, you need to provide a
    default case with assert(0) or similar code. 

Cannot see path which goes with unitialized variable. Worse, didn't change
this function. WTF?

https://gcc.gnu.org/wiki/Better_Uninitialized_Warnings


The cause is this: This check applies to not only the current function but
also sub function calls. The 'value' variable in the message is one from
called one and there it is not initialized. When initialize it, error goes
away.

std::pair<> mapGStreamerToMediaRouterError_src(error, text_msg, msg->src)
{
    ErrorEventValue::Enum value;
    ...
}


={============================================================================
*kt_dev_gcc_100* gcc-doc gcc-header

{reference}
http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html
http://gcc.gnu.org/wiki/HomePage
https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/

{gcc-headers}
Has two parts.

For ubuntu:

/usr/lib/gcc/i686-linux-gnu/4.6/include
/usr/include/c++/4.6/

For debian:

/usr/include/c++/4.9.2
/usr/include/x86_64-linux-gnu/c++/4.9/bits$ ll

total 200
drwxr-xr-x 2 root root  4096 Dec 23 09:31 ./
drwxr-xr-x 6 root root  4096 Dec 23 09:31 ../
-rw-r--r-- 1 root root  1924 Dec 25  2014 atomic_word.h
-rw-r--r-- 1 root root  2890 Dec 25  2014 basic_file.h
-rw-r--r-- 1 root root  1849 Dec 25  2014 c++allocator.h
-rw-r--r-- 1 root root 48207 Dec 25  2014 c++config.h
-rw-r--r-- 1 root root  1608 Dec 25  2014 c++io.h
-rw-r--r-- 1 root root  3304 Dec 25  2014 c++locale.h
-rw-r--r-- 1 root root  1333 Dec 25  2014 cpu_defines.h
-rw-r--r-- 1 root root  2242 Dec 25  2014 ctype_base.h
-rw-r--r-- 1 root root  2284 Dec 25  2014 ctype_inline.h
-rw-r--r-- 1 root root  2098 Dec 25  2014 cxxabi_tweaks.h
-rw-r--r-- 1 root root  5177 Dec 25  2014 error_constants.h
-rw-r--r-- 1 root root  2388 Dec 25  2014 extc++.h
-rw-r--r-- 1 root root 24237 Dec 25  2014 gthr-default.h
-rw-r--r-- 1 root root  5608 Dec 25  2014 gthr.h
-rw-r--r-- 1 root root 24237 Dec 25  2014 gthr-posix.h
-rw-r--r-- 1 root root  6788 Dec 25  2014 gthr-single.h
-rw-r--r-- 1 root root  4099 Dec 25  2014 messages_members.h
-rw-r--r-- 1 root root  6177 Dec 25  2014 opt_random.h
-rw-r--r-- 1 root root  1783 Dec 25  2014 os_defines.h
-rw-r--r-- 1 root root  2778 Dec 25  2014 stdc++.h
-rw-r--r-- 1 root root  1741 Dec 25  2014 stdtr1c++.h
-rw-r--r-- 1 root root  2933 Dec 25  2014 time_members.h


={============================================================================
*kt_dev_gcc_100* cpp-standard

Preface

This is a reference manual for the C programming language as implemented by the GNU Compiler
Collection (GCC). Specifically, this manual aims to document:

The 1989 ANSI C standard, commonly known as C89/C90

The 1999 ISO C standard, commonly known as C99, ISO/IEC 9899:1999, to the extent that C99 is
implemented by GCC

The current state of GNU extensions to standard C 

This manual describes C89 as its baseline. C99 features and GNU extensions are explicitly labeled as
such.

By default, GCC will compile code as C89 plus GNU-specific extensions. Much of C99 is supported;
once full support is available, the default compilation dialect will be C99 plus GNU-specific
extensions. (Some of the GNU extensions to C89 ended up, sometimes slightly modified, as standard
language features in C99.)

The C language includes a set of preprocessor directives, which are used for things such as macro
text replacement, conditional compilation, and file inclusion. Although normally described in a C
language manual, the GNU C preprocessor has been thoroughly documented in The C Preprocessor, a
separate manual which covers preprocessing for C, C++, and Objective-C programs, so it is not
included here. 


{C90-C99}
After ANSI produced the official standard for the C programming language in 1989, which became an
international standard in 1990, the C language specification remained relatively static for some
time, while C++ continued to evolve, largely during its own standardization effort. Normative
Amendment 1 created a new standard for C in 1995, but only to correct some details of the 1989
standard and to add more extensive support for international character sets. The standard underwent
further revision in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which
was adopted as an ANSI standard in May 2000. The language defined by that version of the standard is
commonly referred to as "C99". 

<for-example>
for(int i = 0; i < 0; i++)
   ;

sam01.c:153:3: error: ‘for’ loop initial declarations are only allowed in C99 mode
sam01.c:153:3: note: use option -std=c99 or -std=gnu99 to compile your code

<for-C99>
The following causes error:
usecomma.cpp:70:42: error: invalid conversion from 'Node* {aka node*}' to 'int' [-fpermissive]
usecomma.cpp:72:22: error: base operand of '->' is not a pointer

{
   // search the end using count
70:   for( int current = 1, pend = list->header; current < list->count; current++)
72:      pend = pend->pnext;
}

{
   // search the end using count
   pend = list->header;
   for( int current = 1; current < list->count; current++)
      pend = pend->pnext;

   or

   // search the end using count
   int current;
   for( current = 1, pend = list->header; current < list->count; current++) 
      pend = pend->pnext;
}

Why? Because cannot define different types in the init part of for. See declaration.

From ISO/IEC 9899-1999

6.8.5 Iteration statements
Syntax

for ( expression opt ; expression opt ; expression opt) statement
for ( declaration expression opt ; expression opt) statement

note: This is why the var declared in a for has a scope
5 An iteration statement is a block whose scope is a strict subset of the scope of its enclosing
block. The loop body is also a block whose scope is a strict subset of the scope of the iteration
statement. 

Now the 'block wrapped around the loop' comes into its own; it explains why the variable i cannot be
accessed outside the loop. You can declare more than one variable, but they must all be of
the-'same' -type:

for (int i = 0, j = sizeof(something); i < j; i++, j--) { ... }


<cpp-03> C++03 C++98 Support in GCC
C++03 replaced the prior revision of the C++ standard, called C++98, and was
later replaced by C++11.

<cpp-11> C++11 C++11
https://isocpp.org/std/the-standard

<cxx-status>
https://gcc.gnu.org/projects/cxx-status.htm

// C++0x was the working name of the ISO C++ 2011 standard, which introduced a
// host of new features into the standard C++ language and library. This project
// sought to implement new C++11 features in GCC, and made it the first compiler
// to bring feature-complete C++11 to C++ programmers.
// 
// C++11 features are available as part of the "mainline" GCC compiler in the
// trunk of GCC's Subversion repository and in GCC 4.3 and later. 
// 
// >
// To enable C++0x support, add the command-line parameter -std=c++0x to your g++
// command line. Or, to enable GNU extensions in addition to C++0x extensions,
//         add -std=gnu++0x to your g++ command line. GCC 4.7 and later support
//         -std=c++11 and -std=gnu++11 as well.
// 
// Important: GCC's support for C++11 is still experimental. Some features were
// implemented based on early proposals, and no attempt will be made to maintain
// backward compatibility when they are updated to match the final C++11
// standard.
// 
// $ g++ -v --help | egrep "\-std"
// 
//   -std=c++0x                  Conform to the ISO 1998 C++ standard, with
//                               extensions that are likely to become a part of
//                               the upcoming ISO C++ standard, dubbed C++0x. Note
//                               that the extensions enabled by this mode are
//                               experimental and may be removed in future
//                               releases of GCC.
// 
// note: when use gcc, got link errors that cannot find STLs. must use g++.
// $ g++ -std=c++0x sample.cpp

// 25.10.2017
// no need to set "-std=c++0x" when use 4.9.2
// g++ (Debian 4.9.2-10) 4.9.2

  -std=c++0x                  `Deprecated` in favor of -std=c++11
  -std=c++11                  Conform to the ISO 2011 C++ standard

C++11 Support in GCC

GCC 4.8.1 was the first feature-complete implementation of the 2011 C++
standard, previously known as C++0x.

This mode can be selected with the -std=c++11 command-line flag, or
-std=gnu++11 to enable GNU extensions as well.

{override-keyword}
Explicit virtual overrides from GCC 4.7

{alias-declaration}
Primers p68. GCC 4.4.5 don't.

class Foo {

  using line_no = vector< string >::size_type;

  typedef vector< string >::size_type line_no;
};


{explicit}
From GCC 45. See *kt_dev_cpp_005* for more.


{in-class-initializers}
For GCC 4.6.3 it emit error:
usecomma.cpp:5:19: sorry, unimplemented: non-static data member initialisers



{cxx-cplusplus}
__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus
to test whether a header is compiled by a C compiler or a C++ compiler. This
macro is similar to __STDC_VERSION__, in that it expands to a version number.
Depending on the language standard selected, the value of the macro is 199711L
for the 1998 C++ standard, 201103L for the 2011 C++ standard, 201402L for the
2014 C++ standard, 201703L for the 2017 C++ standard, or an unspecified value
strictly larger than 201703L for the experimental languages enabled by
-std=c++2a and -std=gnu++2a.


{the-gnu-c++-library}
http://gcc.gnu.org/onlinedocs/libstdc++/index.html


={============================================================================
*kt_dev_cxx_0000* cxx-nullptr

This is for *cxx-11*

$ gcc sam01.c
sam01.c: In function ‘main’:
sam01.c:7:26: error: ‘nullptr’ undeclared (first use in this function)
sam01.c:7:26: note: each undeclared identifier is reported only once for each function it appears in

$ g++ -g -std=c++0x sam01.c

This new feature especially helps to avoid mistakes that occurred when a null
pointer was interpreted as an `integer` value. For example:

void f(int);
void f(void*);

f(0);       // calls f(int)
f(NULL);    // calls f(int) if NULL is 0, ambiguous otherwise
f(nullptr); // calls f(void*)

<cxx-nullptr>
nullptr is a new keyword. It automatically converts into each pointer type but
not to any integral type. It has type std::nullptr_t, defined in <cstddef>, so
you can now even overload operations for the case that a null pointer is
passed. Note that `std::nullptr_t` counts `as a fundamental data type` 


// from SO

How is it a keyword and an instance of a type?

This isn't surprising. Both true and false are keywords and as literals they
have a type ( bool ). nullptr is a pointer literal of type std::nullptr_t, and
it's a prvalue (you cannot take the address of it using &).

4.10 about pointer conversion says that a prvalue of type std::nullptr_t is a
null pointer constant, and that an integral null pointer constant can be
converted to std::nullptr_t. The opposite direction is not allowed. This
allows overloading a function for both pointers and integers, and passing
nullptr to select the pointer version. Passing NULL or 0 would confusingly
select the int version.

A cast of nullptr_t to an integral type needs a reinterpret_cast, and has the
same semantics as a cast of (void*)0 to an integral type (mapping
    implementation defined). A reinterpret_cast cannot convert nullptr_t to
any pointer type. Rely on the implicit conversion if possible or use
static_cast.

The Standard requires that sizeof(nullptr_t) be sizeof(void*).

// c++config.h
namespace std
{
#if __cplusplus >= 201103L
  typedef decltype(nullptr)	nullptr_t;
#endif
}

<ex>

// g++ (Debian 4.9.2-10) 4.9.2

echo -e "#include <utility>\nint main() { std::pair<bool, const char*> x(false, 0); return 0; }" | g++ --std=c++0x -Wall -x c++ -o foo -

echo -e "#include <utility>\nint main() { const char* const null_ptr = 0; std::pair<bool, const char*> x(false, null_ptr); return 0; }" | g++ -Wall -x c++ -o foo -

echo -e "#include <utility>\nint main() { std::pair<bool, const char*> x(false, 0); return 0; }" | g++ -Wall -x c++ -o foo -

// ????
Regardless of "-std=c++0x", comiles well for all cases but fails as:

4.4.5/bits/stl_pair.h:90: error: invalid conversion from 'int' to 'const char*'


={============================================================================
*kt_dev_gcc_101* gcc-typeof

To check actual type of some expression. For example:

http://gcc.gnu.org/onlinedocs/gcc/Typeof.html
http://stackoverflow.com/questions/16832863/behaviour-of-sizeof-in-c-gcc


={============================================================================
|kt_dev_cxx_0000| cxx-attribute gcc-attribute

https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html#Function-Attributes

6.33 Declaring Attributes of Functions

In GNU C and C++, you can use function attributes to specify certain function
properties that may help the compiler *cxx-optimize* calls or check code more
carefully for correctness. For example, you can use attributes to specify that
a function never returns (noreturn), returns a value depending only on the
values of its arguments (const), or has printf-style arguments (format).

You can also use attributes to control memory placement, code generation
options or call/return conventions within the function being annotated. Many
of these attributes are `target-specific.` For example, many targets support
attributes for defining interrupt handler functions, which typically must
follow special register usage and return conventions. Such attributes are
described in the subsection for each target. However, a considerable number of
attributes are supported by most, if not all targets. Those are described in
the `Common Function Attributes` section.

Function attributes are introduced by the `__attribute__ keyword` in the
declaration of a function, followed by an attribute specification enclosed in
double parentheses. You can specify multiple attributes in a declaration by
separating them by commas within the double parentheses or by immediately
following one attribute specification with another. See Attribute Syntax, for
the exact rules on attribute syntax and placement. Compatible attribute
specifications on distinct declarations of the same function are merged. An
attribute specification that is not compatible with attributes already applied
to a declaration of the same function is ignored with a warning.

Some function attributes take one or more arguments that refer to the
function’s parameters by their positions within the function parameter list.
Such attribute arguments are referred to as positional arguments. Unless
specified otherwise, positional arguments that specify properties of
parameters with pointer types can also specify the same properties of the
implicit C++ this argument in non-static member functions, and of parameters
of reference to a pointer type. For ordinary functions, position one refers to
the first parameter on the list. In C++ non-static member functions, position
one refers to the implicit this pointer. The same restrictions and effects
apply to function attributes used with ordinary functions or C++ member
functions.

GCC also supports attributes on variable declarations (see Variable
    Attributes), labels (see Label Attributes), enumerators (see Enumerator
      Attributes), statements (see Statement Attributes), and types (see Type
        Attributes).

*cxx-pragma*

There is some overlap between the purposes of attributes and pragmas (see
    Pragmas Accepted by GCC). It has been found convenient to use
__attribute__ to achieve a natural attachment of attributes to their
corresponding declarations, whereas #pragma is of use for compatibility with
other compilers or constructs that do not naturally form part of the grammar.

In addition to the attributes documented here, GCC plugins may provide their
own attributes.


6.33.1 Common Function Attributes

format (archetype, `string-index`, `first-to-check`)

The format attribute specifies that a function takes printf, scanf, strftime
or strfmon style arguments that should be type-checked against a format
string. For example, the declaration:

extern int
my_printf (void *my_object, const char *my_format, ...)
      __attribute__ ((format (printf, 2, 3)));

causes the compiler to check the arguments in calls to my_printf for
  consistency with the printf style format string argument my_format.

The parameter archetype determines how the format string is interpreted, and
should be printf, scanf, strftime, gnu_printf, gnu_scanf, gnu_strftime or
strfmon. (You can also use __printf__, __scanf__, __strftime__ or
    __strfmon__.) 

In the example above, the format string (my_format) is the second argument of
the function my_print, and the arguments to check start with the third
argument, so the correct parameters for the format attribute are 2 and 3.

The format attribute allows you to identify your own functions that take
format strings as arguments, so that GCC can check the calls to these
functions for errors. The compiler always (unless -ffreestanding or
    -fno-builtin is used) checks formats for the standard library functions
printf, fprintf, sprintf, scanf, fscanf, sscanf, strftime, vprintf, vfprintf
and vsprintf whenever such warnings are requested (using -Wformat), so there
is no need to modify the header file stdio.h. In C99 mode, the functions
snprintf, vsnprintf, vscanf, vfscanf and vsscanf are also checked. Except in
strictly conforming C standard modes, the X/Open function strfmon is also
checked as are printf_unlocked and fprintf_unlocked. See Options Controlling C
Dialect.


={============================================================================
|kt_dev_cxx_0000| cxx-likely gcc-likely cxx-expect

https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html

long __builtin_expect (long exp, long c)

__builtin_expect to provide the compiler with `branch prediction` information.
In general, you should prefer to use actual profile feedback for this
(-fprofile-arcs), as programmers are notoriously bad at predicting how their
programs actually perform. However, there are applications in which this data
is hard to collect.

`The return value is the value of exp`, which should be an `integral expression.`
The semantics of the built-in are that it is expected that exp == c

// likely that ptr is not null and if so, call foo()

if (__builtin_expect (ptr != NULL, 1))
  foo (*ptr);

// unlikely that part is not null, that is, likely that prt is null so exp,
// "ptr != NULL" returns false, do NOT call foo()

if (__builtin_expect (ptr != NULL, 0))
  foo (*ptr);

// likely x is 0 and if so, do not call foo(). if not, call foo().

if (__builtin_expect (x, 0))
  foo ();


http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html

As the gcc documentation says, you can use this `compiler built-in function` to
give the optimizer a clue about the likely result of an integer (or Boolean)
  expression. In the context of an if statement, this enables the optimizer to
  reorder the code in a way that gives best performance, by ensuring that the
  code that is most likely to execute after the conditional immediately follows
  the conditional when the instruction stream is fed to the CPU pipeline.

The __builtin_expect() function takes two arguments: `a value to be tested`, and
`the expected result.` Both of these are integral values. The interface is a
little clumsy for most uses, since the common case is that we want to test for
"true" (non-zero) or "false" (zero). 

Thus, `the Linux kernel defines two simpler interfaces`: likely() and unlikely() 
(in include/linux/compiler.h):

    #define likely(x)      __builtin_expect(!!(x), 1)
    #define unlikely(x)    __builtin_expect(!!(x), 0)

In other words, likely(x) means "I expect x is true", and and unlikely(x) means
"I expect x is false".

Here's my test program. The comments should be enough to help you understand
some of the more obscure pieces. Below, I'll just skip to looking at the test
results.

The program essentially repeatedly scans a one-million-element integer array
whose contents are zero (in the default case). Using the program, we can time
the results of the checks that are performed either with or without using
__builtin_expect().

For example, here we scan the array without  __builtin_expect():

    $ cc -DDONT_EXPECT -O3 builtin_expect_test.c -o bn
    $ time -f "%E real, %U user, %S sys" ./bn 1000
    0, 1000000000
    0:02.68 real,  2.67 user, 0.00 sys

In this case, the program looped one thousand times through the array, to
perform a total of one billion checks, and the real time for execution was 2.68
seconds. (The test machine is an Intel Core Duo 2.53GHz, and the gcc version is
    4.6.3.)

Here's what happens if we employ  __builtin_expect(), telling the compiler that
the expected result of the test is 0.

    // KT, expects 0 and best case
    $ cc -DEXPECT_RESULT=0 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    0, 1000000000
    0:02.28 real,  2.28 user, 0.00 sys

The execution time fell to 2.28 seconds. In other words (for this particular
    CPU, compiler version, and program), __builtin_expect() improved the
execution time of each check by 0.4 nanoseconds (0.4 seconds for one billion
    checks).

Well and good. What if we tell __builtin_expect() to expect the wrong value?

    // KT, expects 1 when all elements are 0 so worst case
    $ cc -DEXPECT_RESULT=1 -O3 builtin_expect_test.c -o b1
    $ time -f "%E real, %U user, %S sys" ./b1 1000
    0, 1000000000
    0:04.19 real,  4.18 user, 0.00 sys

In this case, unsurprisingly, we made each check run slower, by about 1.5 (i.e.,
    4.19 - 2.68) nanoseconds. So, should you use __builtin_expect()?  

You should only use __builtin_expect()-or the Linux kernel's likely() and
unlikely()-if it's "very likely" that your code will follow the predicted
branch. How much is "very likely"? If you're looking for actual numbers, the
answer will depend on your compiler version, CPU, and code. But to illustrate
that you should generally [avoid] these optimizations unless your code is very
likely to follow one branch, here's some further tests using the above code.

In this test, the program first injects some nonzero values into the array
before doing tests for zero using __builtin_expect(). Nonzero values are placed
at every tenth element in the array:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000000, 900000000
    0:02.79 real,  2.76 user, 0.01 sys

Note what happened. Even though most array elements contained the expected zero
value, execution speed was actually worse (2.79 seconds versus 2.69 seconds)
  than not using __builtin_expect() at all! In fact, even when only one in ten
  thousand values is nonzero, we're still at only roughly the break-even point:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10000 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000, 999900000
    0:02.66 real,  2.64 user, 0.00 sys

The point where using these optimizations becomes worthwhile will depend on the
factors mention above, but the point is that you should really only use them
when your predicted path is very likely, and if your predicted path is not very
likely, then you're better off avoiding them, as you'll actually slow your code
down a little. Compiler-assisted run-time profiling The gcc documentation
contains the following advice regarding the use of __builtin_expect():

    In general, you should prefer to use actual profile feedback for this
    (-fprofile-arcs), as programmers are notoriously bad at predicting how their
    programs actually perform. However, there are applications in which this
    data is hard to collect. 

That's good concise advice. To put things another way, the only time you should
use __builtin_expect() is when you can't use compiler-assisted runtime
optimization (perhaps because your program has no easily repeatable pattern of
    execution-the Linux kernel is an obvious example) and you are certain that
your predicted code path is very (very) likely to be the one that will be taken.


{reading}
This is about branch-prediction and optimisation in a compiler. 

[kedar@ashwamedha ~]$ cat abc.c

int testfun(int x)
{
  // we instruct the compiler, "else" block is more probable by saying that x is
  // more likely to be false(0)
  
  if(__builtin_expect(x, 0)) 
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
 
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
 
abc.o:     file format elf32-i386
 
Disassembly of section .text:
 
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   75 07                   jne    11 < testfun+0x11 >
   The compiler branches the "if" block and keeps "else" sequential
   a:   b8 06 00 00 00          mov    $0x6,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 19 00 00 00          mov    $0x19,%eax
  16:   eb f7                   jmp    f < testfun+0xf > 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "if" block is more probable by saying that x is
  // more likely to be true(1), non-zero.

  if(__builtin_expect(x, 1))
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
                                                                                                   
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
                                                                                                   
abc.o:     file format elf32-i386
                                                                                                   
Disassembly of section .text:
                                                                                                   
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   74 07                   je     11 < testfun+0x11 >
   The compiler branches the "else" block and keeps "if" sequential
   a:   b8 19 00 00 00          mov    $0x19,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 06 00 00 00          mov    $0x6,%eax
  16:   eb f7                   jmp    f < testfun+0xf >
<

KT, As shown, the probable cases are placed in sequential and menas in the pipe
line. So most of case there is no jump.


{ex-from-glibc}

#if __GNUC__ >= 3
# define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
# define __glibc_likely(cond)	__builtin_expect ((cond), 1)
#else
# define __glibc_unlikely(cond)	(cond)
# define __glibc_likely(cond)	(cond)
#endif

if (__glibc_unlikely (*s == L_('\0')))
   goto noconv;


https://developer.gnome.org/glib/stable/glib-Miscellaneous-Macros.html

G_LIKELY()

#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))

if (G_LIKELY (random () != 1))
  g_print ("not one");

#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))

if (G_UNLIKELY (random () == 1))
  g_print ("a random one");


if (G_UNLIKELY (!stream->caps)) {
    // when "stream->caps" is null, handle error case
}

So, do read code as if there is no likely/unlikely thing.


<ex-from-qt>

Q_LIKELY(expr)

Hints to the compiler that the enclosed condition, expr, is likely to evaluate
to true.

Use of this macro can help the compiler to optimize the code.

Example:

    // the condition inside the "if" will be successful most of the times
    for (int i = 1; i <= 365; i++) {
        if (Q_LIKELY(isWorkingDay(i))) {
            ...
        }
        ...
    }

This function was introduced in Qt 4.8.

See also Q_UNLIKELY().


={============================================================================
*kt_dev_gcc_106* gcc: link: lrt

-lrt 

Means that librt.a to use clock_gettime.


={============================================================================
*kt_dev_gcc_107* gcc: link: sysroot and rpath-link

When not use sysroot with NXP toolchain, cause the problem:

-Wl,-rpath-link=/home/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools/usr/lib
-Xlinker --end-group -o
/home/NDS-UK/parkkt/TestBuild/APOLLO_01/LittleEndian/components/FOSH/FOSH_App/debug/FOSH_App
/backup/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools/usr/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.4.0/../../../../arm-linux-uclibcgnueabi/bin/ld:
crt1.o: No such file: No such file or directory


-rpath-link=dir
When using ELF or SunOS, one shared library may require another. This happens when an ld -shared
link includes a shared library as one of the input files.

When the linker encounters such a dependency when doing a non-shared, non-relocatable link, it will
automatically try to locate the required shared library and include it in the link, if it is not
included explicitly. In such a case, the -rpath-link option specifies the first set of directories
to search. The -rpath-link option may specify a sequence of directory names either by specifying a
list of names separated by colons, or by appearing multiple times.

This option should be used with caution as it overrides the search path that may have been hard
compiled into a shared library. In such a case it is possible to use unintentionally a different
search path than the runtime linker would do.

The linker uses the following search paths to locate required shared libraries:

1. Any directories specified by -rpath-link options.

2. Any directories specified by -rpath options. The difference between -rpath and -rpath-link is
that directories specified by -rpath options are included in the executable and used at runtime,
whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is only
  supported by native linkers and cross linkers which have been configured with the --with-sysroot
  option.

3. On an ELF system, for native linkers, if the -rpath and -rpath-link options were not used, search
the contents of the environment variable LD_RUN_PATH.

4. On SunOS, if the -rpath option was not used, search any directories specified using -L options.

5. For a native linker, the search the contents of the environment variable LD_LIBRARY_PATH.

6. For a native ELF linker, the directories in DT_RUNPATH or DT_RPATH of a shared library are
searched for shared libraries needed by it. The DT_RPATH entries are ignored if DT_RUNPATH entries
exist.

7. The default directories, normally /lib and /usr/lib.

8. For a native linker on an ELF system, if the file /etc/ld.so.conf exists, the list of directories
found in that file. 

If the required shared library is not found, the linker will issue a warning and continue with the
link.


={============================================================================
*kt_dev_gcc_111* gcc: profiling

{how-to-use-gcc-optimisation} {gcc-profiling}
The example program above does have a very predictable, repeatable flow of execution. Let's see what
happens when we use compiler-assisted optimization. Building the programming now involves two steps:
a profiling phase and an optimized compile. In the profiling phase, we build and run an instrumented
version of the executable. We build as follows:

    $ cc -O3 -DDONT_EXPECT -fprofile-generate builtin_expect_test.c -o bn.prof

(The -fprofile-generate option implies -fprofile-arcs, as well as one or two other profiling
options.)

We then run the executable, which generates profiling information that is stored in a file (with the
extension .gcda).

    $ time -f "%E real, %U user, %S sys" ./bn.prof 1000
    0, 1000000000
    0:05.39 real,  5.37 user, 0.00 sys

Note that, because of the instrumentation code, the profiled version runs rather slower that the
normally compiled code.  Running this code created a file containing the profiling results:

    $ ls *.gcda
    builtin_expect_test.gcda

We then employ the -fprofile-use compiler option,which (implicitly) uses the profiling results to
create an optimized executable.

    $ cc -O3 -DDONT_EXPECT -fprofile-use builtin_expect_test.c -o bn.opt

And then we run the optimized program:

    $ time -f "%E real, %U user, %S sys" ./bn.opt 1000
    0, 1000000000
    0:01.95 real,  1.94 user, 0.00 sys

This optimized version runs significantly faster (1.95 versus 2.28 seconds) than our version that
used __builtin_expect(). This is because, in addition to the branching in the if statement, the
branching in the for loops was also optimized.

It's left as an exercise for the reader to show that employing __builtin_expect() (to expect 0) in
conjunction with compiler-assisted optimization doesn't improve things: the compiler already
optimizes the if branching as well as the programmer-directed optimization. One other interesting
exercise  is, of course, to compare the assembler (cc -S) code generated for each of the above
cases. 


={============================================================================
*kt_dev_cxx_0000* cxx-cpp-pragma cxx-pragma

https://gcc.gnu.org/onlinedocs/cpp/Pragmas.html

// stops compilation
#error "unknwon cpu - you need to find out the stack grows downward or upward"

// get a mesg during compilation like:
// NDS_pthread.c:43:4: warning: #warning "xxx2" 
#warning "xxx2"

#pragma once

If #pragma once is seen when scanning a header file, that file will never be
read again, no matter what. It is a less-portable alternative to using
‘#ifndef’ to guard the contents of header files against multiple inclusions.


={============================================================================
*kt_dev_cxx_0000* cxx-cpp-defined

3.7.1 Standard Predefined Macros

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus
to test whether a header is compiled by a C compiler or a C++ compiler. This
macro is similar to __STDC_VERSION__, in that it expands to a version number.
Depending on the language standard selected, the value of the macro is 

199711L for the 1998 C++ standard,
`201103L for the 2011 C++ standard`, 
201402L for the 2014 C++ standard, 
201703L for the 2017 C++ standard, 

or an unspecified value strictly larger than 201703L for the experimental
  languages enabled by -std=c++2a and -std=gnu++2a.

The 199711L stands for Year=1997, Month = 11 (i.e., November of 1997) -- the
date when the committee approved the standard that the rest of the ISO
approved in early 1998.

For the 2003 standard, there were few enough changes that the committee
(apparently) decided to leave that value unchanged.

For the 2011 standard, it's required to be defined as 201103L, (again,
    year=2011, month = 03) again meaning that the committee approved the
standard as finalized in March of 2011.

For the 2014 standard, it's required to be defined as 201402L, interpreted the
same way as above (February 2014).

For the 2017 standard, it's required to be defined as 201703L (March 2017).

Before the original standard was approved, quite a few compilers normally
defined it to 0 (or just an empty definition like #define __cplusplus) to
signify "not-conforming". When asked for their strictest conformance, many
defined it to 1.

I almost forgot to mention, but one more tidbit about ancient compilers: a few
of the earliest versions of cfront (and probably a few others copying it)
defined c_plusplus instead of __cplusplus. I don't recall it's being defined
to any meaningful value though.


-D name 
Predefine name as a macro, with definition 1. 

-D name=definition
The contents of definition are tokenized and processed as if they appeared
during translation phase three in a '#define' directive. In particular, the
definition will be truncated by embedded newline characters.

If you are invoking the preprocessor from a shell or shell-like program you may
need to use the shell's quoting syntax to protect characters such as spaces that
have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its
argument list with surrounding parentheses before the equals sign (if any).
Parentheses are meaningful to most shells, so you will need to quote the option.
With sh and csh, -D'name(args...)=definition' works.

-D and -U options are processed in the order they are given on the command line.
All -imacros file and -include file options are processed after all -D and -U
options. 

*cxx-cpp-defined*
4.2.3 Defined

The special operator `defined` is used in '#if' and '#elif' expressions to test
whether a certain name is defined as a macro. "defined name" and "defined
(name)" are both expressions whose `value is 1` if name is defined as a macro at
the current point in the program, and 0 otherwise. 

`Thus, #if defined MACRO is precisely equivalent to #ifdef MACRO.`

`defined` is useful when you wish to test more than one macro for existence at
once. For example,

     #if defined (__vax__) || defined (__ns16000__)

would succeed if either of the names __vax__ or __ns16000__ is defined as a
macro.

Conditionals written like this:

     #if defined BUFSIZE && BUFSIZE >= 1024

can generally be simplified to just `#if BUFSIZE >= 1024`, since if BUFSIZE is not
defined, it will be interpreted as having the value 0.

If the defined operator appears as a result of a macro expansion, the C standard
says the behavior is undefined. GNU cpp treats it as a genuine defined operator
and evaluates it normally. It will warn wherever your code uses this feature if
you use the command-line option -pedantic, since other compilers may handle it
differently. 


NOTE:
#define CHECK_CXX_CPP_DEFINED
#define CHECK_CXX_CPP_DEFINED 1

are the same? 

{
  // that is, expect to run EXPECT_THAT(true, true) regardless of if macro is
  // defined.
  //
  // if use 
  // #define CHECK_CXX_CPP_DEFINED 
  //
  // then see error:
  // :8855:27: error: operator '||' has no left operand
  // #if CHECK_CXX_CPP_DEFINED || 1
  //
  //  control:
  //  -DCHECK_CXX_CPP_DEFINED=0
 
#if CHECK_CXX_CPP_DEFINED || 1
  EXPECT_THAT(true, true);
#else
  EXPECT_THAT(false, true);
#endif

  // fails when #define CHECK_CXX_CPP_DEFINED 0
#if CHECK_CXX_CPP_DEFINED || 0
  EXPECT_THAT(true, true);
#else
  EXPECT_THAT(false, true);
#endif
}

what's the benefit of using "#if CHECK_CXX_CPP_DEFINED || 0" style?


<ex>
Q: What's the difference between "define _LIMITS_H" and "define _LIMITS_H 1"?

#define SAMPLE
#define SAMPLE 1
#define SAMPLE 2

// This works for all three cases
#ifdef SAMPLE
  printf("sample is def\n");
#endif

// Only emit error for case 1: 
// : error: operator '==' has no left operand
#if SAMPLE == 1
  printf("sample is =1\n");
#endif

// Only emit error for case 1: 
// : error: operator '>' has no left operand
#if SAMPLE > 1
  printf("sample is >1 \n");
#endif

After all, "define MACRO x" is to use macro value and no real needs as a guard
macro.


http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros

The standard predefined macros are specified by the relevant language
standards, so they are available with all compilers that implement those
standards. Older compilers may not provide all of them. Their names all start
with double underscores.

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus
to test whether a header is compiled by a C compiler or a C++ compiler. This
macro is similar to __STDC_VERSION__, in that it expands to a version number.
Depending on the language standard selected, the value of the macro is
199711L, as mandated by the 1998 C++ standard; 201103L, per the 2011 C++
standard; an unspecified value strictly larger than 201103L for the
experimental languages enabled by -std=c++1y and -std=gnu++1y. 

__FILE__

This macro expands to the name of the current input file, in the form of a C
string constant. This is the path by which the preprocessor opened the file,
not the short name specified in '#include' or as the input file name
argument. For example, "/usr/local/include/myheader.h" is a possible expansion
of this macro. 

// For c files, this is a path from where run gcc to build.

<how-to-get-filename-without-full-path>

char *strrchr(const char *s, int c);
The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

#include <stdio.h>
#include <string.h>
#define FILE (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

int main()
{
   printf("file is %s\n", __FILE__);
   printf("file is %s:%d:%s\n", FILE, __LINE__, __PRETTY_FUNCTION__ );
}

__LINE__

This macro expands to the current input line number, in the form of a decimal
integer constant.  While we call it a predefined macro, it's a pretty strange
macro, since its "definition" changes with each new line of source code. 

__FILE__ and __LINE__ are useful in generating an error message to report an
inconsistency detected by the program; the message can state the source line
at which the inconsistency was detected. For example,

     fprintf (stderr, "Internal error: "
                      "negative string length "
                      "%d at %s, line %d.",
              length, __FILE__, __LINE__);

An '#include' directive changes the expansions of __FILE__ and __LINE__ to
correspond to the included file. At the end of that file, when processing
resumes on the input file that contained the '#include' directive, the
expansions of __FILE__ and __LINE__ revert to the values they had before the
'#include' (but __LINE__ is then incremented by one as processing moves to the
    line after the '#include').

A '#line' directive changes __LINE__, and may change __FILE__ as well. See
Line Control.


*cxx-cpp-defined-func*

__func__ and __FUNCTION__ 

C99 introduces __func__, and GCC has provided __FUNCTION__ for a long time.
Both of these are strings containing the name of the current function (there
    are slight semantic differences; see the GCC manual). 
`neither of them is a macro`; the preprocessor does not know the name of the
current function. They tend to be useful in conjunction with __FILE__ and
__LINE__, though. 


__PRETTY_FUNCTION__

http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html

GCC provides three magic variables that hold the name of the current function,
    as a string. The first of these is __func__, which is part of the C99
    standard:

The identifier __func__ is implicitly declared by the translator as if,
    immediately following the opening brace of each function definition, the
    declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing function.
This name is the unadorned name of the function.

__FUNCTION__ is another name for __func__. Older versions of GCC recognize only
this name. However, it is 'not' standardized. For maximum portability, we
recommend you use __func__, but provide a fallback definition with the
preprocessor:

     #if __STDC_VERSION__ < 199901L
     # if __GNUC__ >= 2
     #  define __func__ __FUNCTION__
     # else
     #  define __func__ "<unknown>"
     # endif
     #endif

In C, __PRETTY_FUNCTION__ is yet another name for __func__. 

>
However, in C++, __PRETTY_FUNCTION__ contains the type signature of the function
as well as its bare name. For example, this program:

     extern "C" {
     extern int printf (char *, ...);
     }
     
     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };
     
     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)  // [KT] seems useful

These identifiers are not preprocessor macros. In GCC 3.3 and earlier, in C
only, __FUNCTION__ and __PRETTY_FUNCTION__ were treated as string literals; they
could be used to initialize char arrays, and they could be concatenated with
other string literals. GCC 3.4 and later treat them as variables, like __func__.
In C++, __FUNCTION__ and __PRETTY_FUNCTION__ have always been variables. 


={============================================================================
*kt_dev_cxx_0000* cxx-cpp-use

{cxx-ndebug} *cxx-assert*
The `assert` macro is defined in `cassert` header. It depends on a preprocessor
varaible named NDEBUG. If NDEBUG is defined, assert do nothing. By default,
         it's not defined.

If the macro NDEBUG was defined at the moment <assert.h> was last included,
   the macro assert() generates no code, and hence does nothing at all.
Otherwise, the macro assert() prints an error message to standard error and
terminates the program by calling abort(3) `if expression is false` (i.e.,
    compares equal to zero).

#ifdef NDEBUG
#define assert(condition) ((void)0)
#else
#define assert(condition) /*implementation defined*/
#endif

The definition of the macro assert depends on another macro, NDEBUG, which is
not defined by the standard library.

If NDEBUG is defined as a macro name at the point in the source code where
<cassert> is included, then assert does nothing.

If NDEBUG is not defined, then assert checks if its argument (which must have
    scalar type) compares equal to zero. If it does, assert outputs
implementation-specific diagnostic information on the standard error output
and calls std::abort. The diagnostic information is required to include the
text of expression, as well as the values of the standard macros __FILE__,
     __LINE__, and the standard variable __func__.


<cxx-assert-static-assert> *cxx-11*
The C++ 11 standard introduced a feature named static_assert() which can be
used to test a software assertion `at the compile time.`

Prior to the C++ 11 standard the primary mean of producing a compile-time
error message was via the #error directive, which causes the implementation to
produce a diagnostic message that includes the message that followed it.


<ex>
From ansic, p91. exercise 4-14. Define a macro swap(t,x,y) that interchanges
two arguments of type t. (Block structure will help.)

#define swap(t, x, y) do {\
   t z;\
   z = x;\
   x = y;\
   y = z;\
} while(0)

If use C++ then make it more useful:

#define swap(x, y) do {\
  decltype(x) z;\
  z = x;\
  x = y;\
  y = z;\
} while(0)


<cxx-cpp-conditional>

#define BSD 3
#define SYSV 4

#define HEHE BSD
//#define HEHE SYSV

#if HEHE == SYSV
  #define HDR "x/sysv.h"
#elif HEHE == BSD
  #define HDR "y/bsd.h"
#endif

int main() {
  printf("hdr %s\n", HDR);
  return 0;
}


<cxx-cpp-error> <cxx-cpp-warning>
https://gcc.gnu.org/onlinedocs/cpp/Diagnostics.html#index-_0023warning

5 Diagnostics

The directive ‘#error’ causes the preprocessor to report a fatal error. The
tokens forming the rest of the line following ‘#error’ are used as the error
message.

You would use ‘#error’ inside of a conditional that detects a combination of
parameters which you know the program does not properly support. For example, if
you know that the program will not run properly on a VAX, you might write

#ifdef __vax__
#error "Won't work on VAXen.  See comments at get_last_object."
#endif

If you have several configuration parameters that must be set up by the
installation in a consistent way, you can use conditionals to detect an
inconsistency and report it with ‘#error’. For example,

#if !defined(FOO) && defined(BAR)
#error "BAR requires FOO."
#endif

The directive ‘#warning’ is like ‘#error’, but causes the preprocessor to issue
a warning and `continue preprocessing.` The tokens following ‘#warning’ are used
as the warning message.

You might use ‘#warning’ in obsolete header files, with a message directing the
user to the header file which should be used instead.

Neither ‘#error’ nor ‘#warning’ macro-expands its argument. Internal whitespace
sequences are each replaced with a single space. The line must consist of
complete tokens. It is wisest to make the argument of these directives be a
single string constant; this avoids problems with apostrophes and the like.


{useful-macros}
#define abs(n) ((n) < 0 ? -(n) : (n))

#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

// a is array
#define NELEMENTS(a) (sizeof(a)/sizeof(*(a)))

// build enum and string table
#define FSM_E(x) {x,#x}

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  FSM_E(BOOT_EVENT_READY),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

enum Events
{
  // BOOT_EVENTS
  BOOT_EVENT_CLOSED = 0x01,
  BOOT_EVENT_READY,
  ...
  BOOT_EVENT_STOP,
};


<ex> *cxx-op-conditional*
#define PREFS_API_TERMINAL_HDMI_STATE_2_STRING(x) ((((x) == PREFS_API_TERMINAL_HDMI_STATE_HDMI_OFF) ? "PREFS_API_TERMINAL_HDMI_STATE_HDMI_OFF" :\
		(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDMI_NOT_AVAILABLE) ? "PREFS_API_TERMINAL_HDMI_STATE_HDMI_NOT_AVAILABLE" :\
				(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_DISABLED) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_DISABLED" :\
						(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_ENCRYPTING) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_ENCRYPTING" :\
								(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_NOT_AVAILABLE) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_NOT_AVAILABLE" :\
										(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_ERROR) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_ERROR" :\
												(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_REVOCATION) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_REVOCATION" :\
														(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_AUTHENTICATING) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_AUTHENTICATING" :\
																(((x) == PREFS_API_TERMINAL_HDMI_STATE_HDCP_NOT_AVAILABLE_MESSAGE) ? "PREFS_API_TERMINAL_HDMI_STATE_HDCP_NOT_AVAILABLE_MESSAGE" :\
																		"UNKNOWN"))))))))))


<ex> define, use, and undef. work?

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  int iarr[5] = {0};

  for( int i = 0; i < 5; i++)
  {
    printf( "iarr[%d] = %d\n", i, iarr[i]);
  }

#define SET_VALUE_INT(idx, value) \
  do { \
    iarr[idx] = value; \
  } while(0)

  SET_VALUE_INT(2, 1);
  SET_VALUE_INT(3, 1);
  SET_VALUE_INT(4, 1);
#undef SET_VALUE_INT

  for( int i = 0; i < 5; i++)
  {
    printf( "iarr[%d] = %d\n", i, iarr[i]);
  }

  exit(EXIT_SUCCESS);
}

yes, works.


<ex>
https://www.gnu.org/software/libc/manual/html_node/Interrupted-Primitives.html

24.5 Primitives Interrupted by Signals

A signal can arrive and be handled while an I/O primitive such as open or read
is waiting for an I/O device. If the signal handler returns, the system faces
the question: what should happen next?

#define	EINTR     4  /* Interrupted system call */

POSIX specifies one approach: make the primitive fail right away. The error code
for this kind of failure is EINTR. This is flexible, but usually inconvenient.

Typically, POSIX applications that use signal handlers must check for EINTR
  after each library function that can return it, in order to try the call
  again. Often programmers forget to check, which is a common source of error.

The GNU C Library provides a convenient way to retry a call after a temporary
failure, with the macro TEMP_FAILURE_RETRY:

Macro: TEMP_FAILURE_RETRY (expression) 

This macro evaluates expression once, and examines its value as type long int.
If the value equals -1, that indicates a failure and errno should be set to show
what kind of failure. If it fails and reports error code EINTR,
     TEMP_FAILURE_RETRY evaluates it again, and over and over until the result
       is not a temporary failure.

The value returned by TEMP_FAILURE_RETRY is whatever value expression produced.


={============================================================================
*kt_dev_cxx_0000* cxx-cpp-issue

EC++02, no to preprocessor

Prefer the compiler to the preprocessor because:

* type-checking

* better to decode compile error and to use symbolic debugger. 

#define ASPECT_RATIO 1.653

const double AspectRatio = 1.653

* smaller code (?) since blind substitution could result in multiple copies in
  your object code.

* class-const
class specific const and better encapsulation.

* avoid problem when use macro with an expression

// one

#define CALL_WITH_MAX(a,b) func((a) > (b) ? (a) : (b) )

int a = 5, b = 0;

CALL_WITH_MAX(++a, b);     // a is increased twice
CALL_WITH_MAX(++a, b+10);  // a is increased once since (a > b) is false

// two when the order of evaluation matters

#define square(x)    x*x
init z = 5
square(z+1);

36? No, it is 11.

If want to avoid function call cost, use 'inline' instead.


={============================================================================
*kt_dev_cxx_0000* cpp-do-while

<cpp-do-while> swallowing-the-semicolon
http://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html#Swallowing-the-Semicolon

The summary is:

This is only when uses macros `which has block, is used like function` in a
single statement but not in expression. For example, think

if( do { ... } while(0); )

Not valid code. This trick is useful but macros still has its own limiations.


Often it is desirable to define a macro that expands into a compound
statement. Consider, for example, the following macro, that advances a pointer
(the argument p says where to find it) across whitespace characters:

#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
 while (p < lim) {            \
   if (*p++ != ' ') {         \
     p--; break; }}}

Here backslash-newline is used to split the macro definition, which must be a
single logical line, so that it resembles the way such code would be laid out
if not part of a macro definition.

A call to this macro might be SKIP_SPACES (p, lim). Strictly speaking, the
call expands to a compound statement, which is a complete statement with no
need for a semicolon to end it. 

However, since it looks like a function call, it minimizes confusion if you
can use it like a function call, writing a semicolon afterward, as in
SKIP_SPACES (p, lim);

This can `cause trouble before else` statements, because the semicolon is
actually a null statement.  Suppose you write

if (*p != 0)                     // if (*p != 0)
 SKIP_SPACES (p, lim);           //    {...};
else ...                         // else ...

The presence of two statements(the compound statement and a null statement) in
between the if condition and the else makes 'invalid' C code because must be
one statement.

sam01.c:161:3: error: 'else' without a previous 'if'

The definition of the macro SKIP_SPACES can be altered to solve this problem,
    using a do ... while statement. Here is how:

#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
    while (p < lim) {            \
      if (*p++ != ' ') {         \
        p--; break; }}}          \
while (0)

Now SKIP_SPACES (p, lim); expands into

if (*p != 0)
   do {...} while (0);
else ...

which is one statement. The loop executes exactly once; most compilers
generate no extra code for it. 

note that there should be NO spaces after "\"; otherwise compile error.


={============================================================================
*kt_dev_cxx_0000* cpp-stringification

http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification

Sometimes you may want to convert a macro argument `into a string constant`

Parameters are not replaced inside string constants, but you can use the '#'
preprocessing operator instead. When a macro parameter is used with a leading
'#', the preprocessor replaces it with the literal text of the actual
argument, converted to a string constant. Unlike normal parameter replacement,
the argument is [not-macro-expanded-first]. This is called stringification.

The preprocessor will replace the stringified arguments with string constants.
The C compiler will then combine all the adjacent string constants into one
long string.

Here is an example of a macro definition that uses stringification:

     #define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

     WARN_IF (x == 0);
          ==> do { if (x == 0)
                fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);

The other example from ansic, p90.

#define dprint(expr)    printf(#expr " = %g\n", expr )

dprint(x/y);
   ==> printf( "x/y = %g\n", x/y );

The argument for EXP is substituted once, as-is, into the if statement, and
  once, stringified, into the argument to fprintf. If x were a macro, it would
  be expanded in the if statement, but not in the string.

The do and while (0) are a kludge to make it possible to write WARN_IF (arg);,
    which the resemblance of WARN_IF to a function would make C programmers
      want to do; see Swallowing the Semicolon.

Stringification in C involves more than putting double-quote characters around
the fragment. The preprocessor backslash-escapes the quotes surrounding
embedded string constants, and all backslashes within string and character
constants, in order to get a valid C string constant with the proper contents.
Thus, stringifying p = "foo\n"; results in "p = \"foo\\n\";". However,
backslashes that are not inside string or character constants are not
  duplicated: '\n' by itself stringifies to "\n".

All leading and trailing whitespace in text being stringified is ignored. Any
sequence of whitespace in the middle of the text is converted to a single
space in the stringified result. Comments are replaced by whitespace long
before stringification happens, so they never appear in stringified text.


#define dprint(expr)    printf(#expr " = %g\n", expr )
#define dprint_string(expr)    string coll(#expr " = %g\n")
#define dprint_string_1(expr)    string coll(#expr)

#define xstr(s) str(s)
#define str(s) #s
#define foo 4

TEST(Cpp, Stringification)
{
  {
    double x = 10.0;
    double y = 3.0;

    // printf( "x/y = %g\n", x/y );
    // x/y = 3.33333
    dprint(x/y);
  }

  {
    dprint_string("string");
    EXPECT_THAT(coll, "\"string\" = %g\n");
  }

  {
    dprint_string_1("string");
    EXPECT_THAT(coll, "\"string\"");
  }

  // If you want to stringify the-result-of-expansion of a macro argument, you
  // have to use two-levels of macros.
  {
    // is not "4" because not macro-expanded
    string coll1{str (foo)};
    EXPECT_THAT(coll1, "foo");

    // s is stringified when it is used in str, so it is not macro-expanded
    // first. But s is an ordinary argument to xstr, so it is completely
    // macro-expanded before xstr itself is expanded (see Argument Prescan).
    // Therefore, by the time str gets to its argument, it has already been
    // macro-expanded. 
    //
    // xstr (foo)
    // ==> xstr (4)
    // ==> str (4)
    // ==> "4"

    string coll2{xstr(foo)};
    EXPECT_THAT(coll2, "4");
  }

  // print the name of an [expression] and its value, along with the file name
  // and the line number.
  //
  // ex
  // int some_function() {
  //   int foo;
  //   /* a lot of complicated code goes here */
  //   dumpme(foo, "%d");
  //   /* more complicated code goes here */
  // }
  //
  // cxx.cpp:4157: value=100

  {
#define dumpme(x, fmt) printf("%s:%u: %s=" fmt "\n", __FILE__, __LINE__, #x, x)

    int value{100};
    dumpme(value, "%d");
  }


  // void JPA_CREATE(const char* vname, int value)
  // {
  //   printf("JPA_CREATE: value=%s value=%d...\n", vname, value );
  // }

  //  {
  //#define KT_CREATE(value)	JPA_CREATE( #value, value)
  //
  //    int val = 3;
  //    int is_this_my_own = 4;
  //
  //    KT_CREATE(val);
  //    KT_CREATE(is_this_my_own);
  //  }
  
  // <case>
  // want to print on console then usuel loggig and macros are defined like:
  //
  // PDM_DISK_SPINDOWN_LOG( g_pdm_diag_segment_id, ("device %s now in power saving mode", physDev->shDeviceName));
  //
  // to
  // 
  // printf("device %s now in power saving mode", physDev->shDeviceName);
  //
  // #ifdef CQ1840116
  // #define PDM_DISK_SPINDOWN_LOG           DIAG_LOG_ERROR
  // #else
  // #define PDM_DISK_SPINDOWN_LOG           DIAG_LOG_INFO
  // #endif
  // 
  // #define DIAG_LOG_ERROR(id, msg)		DIAG_LOG_F2B_WRITE((id), DIAG_CMN_TRACE_ERROR, msg)
  //
  // How?

  {
#define PDM_DISK_SPINDOWN_LOG           DIAG_LOG_ERROR
#define DIAG_LOG_ERROR(id, msg)         printf msg

    // #define DIAG_LOG_ERROR(id, msg)         printf msg
    // printf "(\"device %s now in power saving mode\", \"physDev->shDeviceName\")";
    //
    // #define DIAG_LOG_ERROR(id, msg)         printf msg
    // printf ("device %s now in power saving mode", "physDev->shDeviceName");

    // PDM_DISK_SPINDOWN_LOG( g_pdm_diag_segment_id, ("device %s now in power saving mode", "physDev->shDeviceName"));
    PDM_DISK_SPINDOWN_LOG( g_pdm_diag_segment_id, ("device %s now in power saving mode\n", "physDev->shDeviceName"));
  }
}


={============================================================================
*kt_dev_cxx_0000* cpp-concatenation cpp-##

https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation

3.5 Concatenation

It is often useful `to merge two tokens into one` while expanding macros. This
is called token pasting or token concatenation. The ‘##’ preprocessing
operator performs token pasting. 

When a macro is expanded, the two tokens on either side of each ‘##’ operator
are combined into a single token, which then replaces the ‘##’ and the two
original tokens in the macro expansion. 

Usually both will be identifiers, or one will be an identifier and the other a
preprocessing number. When pasted, they make a longer identifier. This isn't
the only valid case. It is also possible to concatenate two numbers (or a
    number and a name, such as 1.5 and e3) into a number. Also,
multi-character operators such as += can be formed by token pasting.


However, two tokens that don't together form a valid token cannot be pasted
together. For example, you cannot concatenate x with + in either order. If you
try, the preprocessor issues a warning and emits the two tokens. Whether it
puts white space between the tokens is undefined. It is common to find
unnecessary uses of ‘##’ in complex macros. If you get this warning, it is
likely that you can simply remove the ‘##’.

Both the tokens combined by ‘##’ could come from the macro body, but you could
just as well write them as one token in the first place. Token pasting is most
useful when one or both of the tokens comes from a macro argument. If either
of the tokens next to an ‘##’ is a parameter name, it is replaced by its
actual argument before ‘##’ executes. As with stringification, the actual
argument is not macro-expanded first. If the argument is empty, that ‘##’ has
no effect.

Keep in mind that the C preprocessor converts comments to whitespace before
macros are even considered. Therefore, you cannot create a comment by
concatenating ‘/’ and ‘*’. You can put as much whitespace between ‘##’ and its
operands as you like, including comments, and you can put comments in
arguments that will be concatenated. However, it is an error if ‘##’ appears
at either end of a macro body.

Consider a C program that interprets named commands. There probably needs to
be a table of commands, perhaps an array of structures declared as follows:

     struct command
     {
       char *name;
       void (*function) (void);
     };
     
     struct command commands[] =
     {
       { "quit", quit_command },
       { "help", help_command },
       ...
     };

It would be cleaner not to have to give each command name twice, once in the
  string constant and once in the function name. A macro which takes the name
  of a command as an argument can make this unnecessary. The string constant
  can be created with stringification, and the function name by concatenating
  the argument with ‘_command’. Here is how it is done:

     #define COMMAND(NAME)  { #NAME, NAME ## _command }
     
     struct command commands[] =
     {
       COMMAND (quit),
       COMMAND (help),
       ...
     };


#{ cxx issues 
={============================================================================
*kt_dev_cxx_0000* cxx-issue-string

{cxx-issue-strncpy} cxx-strncpy

SYNOPSIS
       #include <string.h>

       char *strcpy(char *dest, const char *src);
       char *strncpy(char *dest, const char *src, size_t n);

DESCRIPTION
       The  strcpy() function copies the string pointed to by src, including
       the terminating null byte ('\0'), to the buffer pointed to by dest.

       The strings may not overlap, and the destination string dest must be
       large enough to receive the copy.  Beware of buffer overruns!  (See BUGS.)

       The strncpy() function is similar, except that `at most` n bytes of src
       are copied.  Warning: If there is no null byte among the first n bytes
       of src, the string placed in dest `will not be null-terminated.`


<ex-real> `stack buffer-overflow` was detected by ASan:
==283== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7c25d990
at pc 0xb4e02520 bp 0x989fe85c sp 0x989fe43c
READ of size 4 at 0x7c25d990 thread T145 (CnS Server Mana)
==283== SetCurrent: 0x9c230000 for thread 0x641ff430
==283== T503: stack [0x64100000,0x64200000) size 0x100000; local=0x641fed74
0x7d519d53 is located 0 bytes to the right of 3-byte region [0x7d519d50,0x7d519d53)
allocated by thread T144 (CnS Server Mana) here:
    #0 0xb4e0251f (/mtd_exe/lib/libasan.so.0+0xe51f)
    #1 0xa8cde413 (/mtd_exe/Comp_LIB/libjson.so+0x20413)
    #2 0xa8bf81f7 (/mtd_exe/lib/libstdc++.so.6.0.17+0xa31f7)
    #3 0x7cb85c3 (/mtd_exe/exeAPP+0x7cb85c3)
    #4 0x7cb8803 (/mtd_exe/exeAPP+0x7cb8803)
    #5 0x7c73cbf (/mtd_exe/exeAPP+0x7c73cbf)
    #6 0x7c8e13f (/mtd_exe/exeAPP+0x7c8e13f)
    #7 0x7c1d60f (/mtd_exe/exeAPP+0x7c1d60f)
    #8 0x7c1e74b (/mtd_exe/exeAPP+0x7c1e74b)
    #9 0x158c3db (/mtd_exe/exeAPP+0x158c3db)
    #10 0x158c2d3 (/mtd_exe/exeAPP+0x158c2d3)
    #11 0x159133f (/mtd_exe/exeAPP+0x159133f)
    #12 0xb4e11397 (/mtd_exe/lib/libasan.so.0+0x1d397)
    #13 0xa93070f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
Shadow bytes around the buggy address:
  0x2faa3350: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fd fd
  0x2faa3360: fa fa fa fa fa fa fa fa fa fa fd fd fa fa fd fd
  0x2faa3370: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fa fa
  0x2faa3380: fa fa fd fd fa fa fa fa fa fa fd fd fa fa fd fd
  0x2faa3390: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd
=>0x2faa33a0: fa fa fd fd fa fa 00 04 fa fa[03]fa fa fa fa fa
  0x2faa33b0: fa fa fd fa fa fa fd fd fa fa fa fa fa fa fd fd
  0x2faa33c0: fa fa fa fa fa fa fd fd fa fa fa fa fa fa fa fa
  0x2faa33d0: fa fa fa fa fa fa fd fa fa fa fd fd fa fa fd fa
  0x2faa33e0: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fa fa
  0x2faa33f0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fd

Here is the backtrace analyzed with addr2line tool:

#0 0xb4e0251f (/mtd_exe/lib/libasan.so.0+0xe51f)
`__interceptor_memcpy`
/fox-p/vd47_a15/toolchain/build.arm.cortex-a15/sources/gcc_1/libsanitizer/
asan/asan_interceptors.cc:288
288     ASAN_READ_RANGE(from, size);
289     ASAN_WRITE_RANGE(to, size);

#1 0xa8cde413 (/mtd_exe/Comp_LIB/libjson.so+0x20413)
char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag)
??:?

#2 0xa8bf81f7 (/mtd_exe/lib/libstdc++.so.6.0.17+0xa31f7)
_S_construct_aux<const char*>
/fox-p/vd47_a15/toolchain/build/obj/gcc_final/arm-v7a15v4r3-linux-gnueabi/
libstdc++-v3/include/bits/basic_string.h:1722

#3 0x7cb85c3 (/mtd_exe/exeAPP+0x7cb85c3)
CCNSVTP::PrintVTPLocal(CCNSVTP::CCNSVTP_TYPE type, char* str)
/GOLFP_2014/AP_MM/AP_ConversationApp/ClientAgent/Src/CnSProfile.cpp:416
414         if (NULL != str)^M
415         {^M
416                 std::string str_text = (std::string)str;^M

#4 0x7cb8803 (/mtd_exe/exeAPP+0x7cb8803)
CCNSVTP::PrintVTP(CCNSVTP::CCNSVTP_TYPE type, char * str, int bool_result)
/GOLFP_2014/AP_MM/AP_ConversationApp/ClientAgent/Src/CnSProfile.cpp:241
241   PrintVTPLocal(VTP_CONVERSATION_STATE_DATA,str);^M
242   break;^M


#5 0x7c73cbf (/mtd_exe/exeAPP+0x7c73cbf)
CCnSParsePacket::t_ParseConnectionInfo(std::string&)
/GOLFP_2014/AP_MM/AP_ConversationApp/ClientAgent/Src/CnSParsePacket.cpp:639
635   char * pChar = NULL ;
636   int length = stConfServer.szStat.size();
637   pChar = new char[length+1];
638  ::strncpy(`pChar`,stConfServer.szStat.c_str(),length);
639  CCNSVTP::GetInstance()->PrintVTP(CCNSVTP::CCNSVTP_TYPE_STATE_DATA,pChar,0);

Again:
  "Warning: If there is no null byte among the first n bytes of src, the
  string placed in dest will not be null-terminated."

So strncpy copies m most chars but the pChar actually is not null terminated.
This cause a issue when converted to a std::string.

The proposed fix is:

$ diff CnSParsePacket.cpp.orig CnSParsePacket.cpp
638c638
<  ::strncpy(pChar,stConfServer.szStat.c_str(),length);
---
>  ::strncpy(pChar,stConfServer.szStat.c_str(),length+1);
>

<<ex> *cxx-memory-issue* *cxx-memcpy-issue* *cxx-strncpy-issue*
Seen on NDS MW issue

MW_Process crash with core dump in SIM_dbc_query_ReadProgrammeInstanceInfo
(during memcpy) 

#define SIM_DBC_MAX_SORT_STRING_LEN   40

// void *memcpy(void *dest, const void *src, size_t n);

(void)memcpy((void*)&obj_array[offset].sort_title[0], 
    (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

// source when crashed
0x1d8dfec: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x1d8dffc: 0xc009 0x0 0x0 0x0

// dest
x/40a obj_array[0].sort_title
0x204eb20: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x204eb30: 0x0 0x0 0x0 0x0

DESCRIPTION
       The memcpy() function copies n bytes from memory area src to memory
       area dest.  The memory areas must not overlap.  Use memmove(3) if the
       memory areas do overlap.

// solution

strncpy(&obj_array[offset].sort_title[0], 
    (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

The problem is out of index. Since when src, results[24].value.text, is less
than SIM_DBC_MAX_SORT_STRING_LEN(40) then memcpy copies blindly over from and
this cause out of index access on src.

So strncpy will ensure only the length of the value.text is copied when there
is a null in src (destination then padded out with nulls) or a maximum of 40
is copied if the source string is over 40.


<cxx-snprintf>
This is one of the great things about snprintf(). It always copies a
terminating null character into the target. If you goof and specify a maximum
number of characters to copy that is less than the actual number of characters
in the source (as we did here), snprintf() will copy however many characters
it can, but the last character written to the target is guaranteed to be a
null character.

// from man page
       The functions snprintf() and vsnprintf() write at most size bytes
       (including the terminating null byte ('\0')) to str.


={============================================================================
*kt_dev_cxx_0000* cxx-type cxx-twos-complement

The int type type on MIPS: size int: 4

signed int  : -219874992
unsigned int : 4075092304

How to get the negative value in `twos-complement`? "NOT X + 1 = -X" and this
show that `negate(-)` is different from `bitwise not(~)`

    23:    1 0111
NOT 23: 1110 1000   // -24, 0xFFFF FFE8
 ----------------
        1111 1111

NOT 23: 1110 1000
+    1: 0000 0001
 ----------------
   -23: 1110 1001   // -24 + 1, 0xFFFF FFE9


<twos-complement-bit-pattern>

8 bits two's complement
------------------------- 128 elements [0,127]
0000 0000    : 0
------------------------- 127 elements 
0000 0001 {{ : 1
0000 0010    : 2
0000 0011    : 3
0000 0100    : 4
...
0111 1111 }} : 127        xxx_MAX                     //         -(127)-2
------------------------- 128 elements [-1, -128]
1000 0000    : -128       xxx_MIN                     // not -0. -(127)-1
------------------------- 127 elements 
1000 0001 {{ : -127 (0111 1110 + 1 = 0111 1111 (127)) // not -1. -(127)
1000 0010    : -126 (0111 1101 + 1 = 0111 1110 (126)) // not -2
...
1111 1110    : -2
1111 1111 }} : -1         Uxxx_MAX, 255, 2**8-1 *NOT* 256, 2**8
------------------------- 

To get two's complement in programmatic way

uint32_t i = 0x27BDFFE0:

0010.0111.1011.1101.1111.1111.1110.0000

i's twos complement is:

1101.1000.0100.0010.0000.0000.0001.1111      // ~X (not)
+1                                           // +1
--------------------------------------------------
1101.1000.0100.0010.0000.0000.0010.0000      // -X (negate)

(-ins) = 0xD8420020                          // twos-complement, negate
1101.1000.0100.0010.0000.0000.0010.0000


<the-max-negative-num-is-special>

// The addition operation in the CPU is agnostic to whether the integer is
// signed or unsigned. The bit representation is the same. 
//
// Here `negate` means that -value but not ~value which is bitwise not.
// 
// If you `negate` 0x80000000, _MIN, you get the same again and that is
// something to look out for because there is `no-change` in bit representation.
// This means abs() has no effect when fed the largest negative number. So bit
// representation is 'agnostic' to whether it's signed or unsigned.

TEST(Bit, MaxNegagiveIsSpecial)
{
  // get max negative, ???_MIN
  int int_min = (~((unsigned int)0) >> 1)+1;

  bitset<32> bitset_int_min{int_min};
  EXPECT_EQ(bitset_int_min.to_string(), "10000000000000000000000000000000");

  // what'd happen when negate ???_MIN?
  int negate_min = -int_min;
  bitset<32> bitset_negate_min{negate_min};
  EXPECT_EQ(bitset_negate_min.to_string(), "10000000000000000000000000000000");
}


<to-toggle-between-unsigned-and-signed> *interview-quiz*
note: possible interview quiz? 

The bit representation is the same for both signed and unsigned value

>>> 2**8
256
>>> -1 + 2**8
255
>>> bin(-1+2**8)
'0b11111111'

>>> 2**32
4294967296
>>> -1 + 2**32
4294967295L
>>> bin(-1 + 2**32)
'0b11111111111111111111111111111111'
>>> import ctypes
>>> ctypes.c_ulong(-1)
c_ulong(4294967295L)

This means that both has the same offset from 2**8(256) for example.

 |         | -128
 |         | -127, 129
 |         | -126, 130
 |         |
 |11111111 |
1|00000000 | 256

  256-126  = 130     // -126 to unsigned
-(256-130) = 126     // 130 to signed


<ex> *ex-itoa* to support negative and XXX_MIN

The ansic, page 64, exercise 3-4. 

In a two's complement number representation, our version of itoa does 'not'
handle the 'largest' negative number, that is, the value of n equal to -(2 to
    the power (wordsize - 1)). Explain why not. Modify it to print that value
correctly regardless of the machine on which it runs. 

void itoa( int n, char s[] );

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_4
As shown above, the problem is that negate do not change the max negative value.


// the original version

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )        // record sign
    n = -n;                   // make n positive. 

  i = 0;

  do {                        // generate digits in reverse order
    s[i++] = '0' + n % 10;    // get next digit
  } while( (n /= 10) > 0 );   // delete it.

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}

When n is INT_MIN=-2147483648

* (n /= 10) will be negative since -n has no effect and n is negative. 
  From n=-2147483648 to n=-214748364(0xf3333334)
* do-while loop will run once only since n will be negative
* a single character since INT_MIN % 10 = -8.
* place in the string a '-'

In ansic, p41, arithmetic operators, 
   
// Why '%' produce negative value?
//
// 51
// -10
// 90
// 6
// -76
// 65
// 69
// 11
// 86
// 64
//
// The reason is that rand() makes 32 bit random numbers and bigrand() makes
// even bigger so overflow happens. overflow happens and return value becomes
// negative.
//
// As ANSIC says:
//
// "The direction of truncation for / and the sign of result for % are machine
// dependent for negative operands, as is the action taken on overflow or
// underflow". 

namespace bit_overflow 
{
  int bigrand()
  {
    return RAND_MAX*rand() + rand();
  }
} // namespace

TEST(Bit, Overflow)
{
  using namespace bit_overflow;

  for (int i = 0; i < 10; ++i)
    cout << (bigrand() % 100) << endl;
}


// the revised version

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )
    n = -n;                         // note-3

  i = 0;

  do { 
    s[i++] = '0' + abs(n % 10);     // note-1
  } while( n /= 10 );               // note-2

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}


converted string: -./,),(-*,(     // use the original
converted string: -2147483648     // use the revised


note-2: Change 'while ((n /= 10) > 0)' to 'while (n /= 10)' to make the loop
continue 'divide' and n will eventually equal zero after successive divides by
10, and 'n /= 10' will evaluate to false sooner or later. If use
"while((n/=10)>0)" then handles `only positive` and stops on the first check
since n/=10 becomes negative.

note-1: Change 'n % 10 + '0 to 'abs(n % 10) + '0, to get the correct character
since n%10 is negative so need to make positive to get correct char back.
Using abs() here is okay since it was already reduced to smaller one.

note-3: What if use abs(XXX_MIN) here? No effect.


={============================================================================
*kt_dev_cxx_0000* cxx-builtin-type

{data-type} From ansic:

char
int      an integer, typically the natural size of integers on the host machine
float
double

short, long, signed and unsigned 'qualifiers'. short is 'at-least' 16 bits,
  long 'at-least' 32 bits and int either 16 or 32 bits. Each compiler is free
  to choose appropriate sizes for its own hardware.

note:
The char is not singed char. there are char, signed, unsigned types because
whether char is signed or unsigned 'depends' on compiler. From ansic, "whether
plain chars are signed or unsigned is machine-dependent". So recommendation is
that 'not' use char but use signed or unsigned.

The standard header <limits.h> and <float.h> contain symbolic constants for
all of these sizes along with other properties of the machine and compiler.


From C++: 2.1.1 Arithmetic Types

Type        Meaning           Minimum Size
------------------------------------------
bool        boolean           NA
short       short integer     16 bits
int         integer           16 bits
long        long integer      32 bits 
long long   long integer      64 bits           // from C++11

<ex>
The ansic, page 36, exercise 2-1. Write a program to determine the range of
char, short, int, and long variables, both signed and unsigned, by printing
appropriate values from standard headers and by direct computation. Harder if
you compute them: determine the range of the various floating-point types.

#include <limits.h>

#define MY_ULONG_MAX (~(unsigned long)0)

int main(int argc, char* argv[])
{
  printf("ulong max from limits: %luL\n", ULONG_MAX );
  printf("ulong max from calc  : %luL\n", MY_ULONG_MAX );
}

ulong max from limits: 4294967295L
ulong max from calc  : 4294967295L


<use-headers>
From http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_1

#include <stdio.h>
#include <limits.h>

int main(void)
{
  printf("\nBits of type char: %d\n\n", CHAR_BIT);

  printf("Maximum numeric value of type char: %d\n", CHAR_MAX);
  printf("Minimum numeric value of type char: %d\n\n", CHAR_MIN);

  printf("Maximum value of type signed char: %d\n", SCHAR_MAX);
  printf("Minimum value of type signed char: %d\n\n", SCHAR_MIN);

  printf("Maximum value of type unsigned char: %u\n\n", (unsigned) UCHAR_MAX);
  
  printf("Maximum value of type short: %d\n", SHRT_MAX);
  printf("Minimum value of type short: %d\n\n", SHRT_MIN);

  printf("Maximum value of type unsigned short: %u\n\n", (unsigned) USHRT_MAX);

  printf("Maximum value of type int: %d\n", INT_MAX);
  printf("Minimum value of type int: %d\n\n", INT_MIN);

  printf("Maximum value of type unsigned int: %u\n\n", UINT_MAX);

  printf("Maximum value of type long: %ld\n", LONG_MAX);
  printf("Minimum value of type long: %ld\n\n", LONG_MIN);

  printf("Maximum value of type unsigned long: %lu\n", ULONG_MAX);
  printf("Maximum value of type unsigned long long: %llu\n\n", ULLONG_MAX);

  return 0;
}

Bits of type char: 8

Maximum numeric value of type char: 127
Minimum numeric value of type char: -128

Maximum value of type signed char: 127
Minimum value of type signed char: -128

Maximum value of type unsigned char: 255

Maximum value of type short: 32767
Minimum value of type short: -32768

Maximum value of type unsigned short: 65535

Maximum value of type int: 2147483647
Minimum value of type int: -2147483648

Maximum value of type unsigned int: 4294967295

Maximum value of type long: 2147483647
Minimum value of type long: -2147483648

Maximum value of type unsigned long: 4294967295
Maximum value of type unsigned long long: 18446744073709551615


<use-calculation> use variables for each type
Integer solution. Floats to follow. I know 'long long' is not in K&R. Pilcrow
12:00, 31 July 2011 (UTC)

/* calculate the ranges of various types */
#include <stdio.h>
#include <limits.h>

int main(void)
{
  /* integer types */
  unsigned char c;
  unsigned short s;
  unsigned int i;
  unsigned long l;
  unsigned long long ll;

  putchar('\n');
  printf("VALUE RANGES FOR INTEGER TYPES\nUPPERCASE comes from <limits.h>\n"
      "lowercase is calculated.\n\n");

  /* char */
  c = ~0;     // note: this is Uxxx_MAX
  c >>= 1;    // note: this is xxx_MAX. why this work? since it's 'unsigned'
  printf("signed char:   %4d,           %4d\n",-c-1,c);
  printf("SCHAR_MIN:     %4d, SCHAR_MAX %4d\n",SCHAR_MIN,SCHAR_MAX);
  printf("unsigned char: %4u,           %4u\n",0,c*2+1);
  printf("UCHAR_MAX:                     %4u\n",UCHAR_MAX);
  putchar('\n');

  // kt@kt-ub-vb:~/work$ ./a.out 
  // 
  // VALUE RANGES FOR INTEGER TYPES
  // UPPERCASE comes from <limits.h>
  // lowercase is calculated.
  // 
  // signed char:   -128,            127
  // SCHAR_MIN:     -128, SCHAR_MAX  127
  // unsigned char:    0,            255
  // UCHAR_MAX:                      255

  /* short */
  s = ~0;
  s >>= 1;
  printf("signed short:   %6d,           %6d\n",-s-1,s);
  printf("SHRT_MIN:       %6d, SHRT_MAX: %6d\n",SHRT_MIN,SHRT_MAX);
  printf("unsigned short: %6u,           %6u\n",0,s*2+1);
  printf("USHRT_MAX:                        %6u\n",USHRT_MAX);
  putchar('\n');

  /* int */
  i = ~0;
  i >>= 1;
  printf("signed int:    %11d,          %11d\n",-i-1,i);
  printf("INT_MIN:       %11d, INT_MAX: %11d\n",INT_MIN, INT_MAX);
  printf("unsigned int:  %11u,          %11u\n",0,i*2+1);
  printf("UINT_MAX:                            %11u\n",UINT_MAX);
  putchar('\n');

  /* long */
  l = ~0;
  l >>= 1;
  printf("signed long:   %11ld,           %11ld\n",-l-1,l);
  printf("LONG_MIN:      %11ld, LONG_MAX: %11ld\n",LONG_MIN, LONG_MAX);
  printf("unsigned long: %11lu,           %11lu\n",0l,l*2+1);
  printf("ULONG_MAX:                            %11lu\n", ULONG_MAX);
  putchar('\n');


  /* long long */
  ll = ~0;
  ll >>= 1;
  printf("signed long long:   %20lld,            %20lld\n",-ll-1,ll);
  printf("LLONG_MIN:          %20lld, LLONG_MAX: %20lld\n",LLONG_MIN, LLONG_MAX);
  printf("unsigned long long: %20llu,            %20llu\n",0ll,ll*2+1);
  printf("ULLONG_MAX:                                          %20llu\n", ULLONG_MAX);

  return 0;
}


VALUE RANGES FOR INTEGER TYPES
UPPERCASE comes from <limits.h>
lowercase is calculated.

signed char:   -128,            127
SCHAR_MIN:     -128, SCHAR_MAX  127
unsigned char:    0,            255
UCHAR_MAX:                      255

signed short:   -32768,            32767
SHRT_MIN:       -32768, SHRT_MAX:  32767
unsigned short:      0,            65535
USHRT_MAX:                         65535

signed int:    -2147483648,           2147483647
INT_MIN:       -2147483648, INT_MAX:  2147483647
unsigned int:            0,           4294967295
UINT_MAX:                             4294967295

signed long:   -2147483648,            2147483647
LONG_MIN:      -2147483648, LONG_MAX:  2147483647
unsigned long:           0,            4294967295
ULONG_MAX:                             4294967295

signed long long:   -9223372036854775808,             9223372036854775807
LLONG_MIN:          -9223372036854775808, LLONG_MAX:  9223372036854775807
unsigned long long:                    0,            18446744073709551615
ULLONG_MAX:                                          18446744073709551615


={============================================================================
*kt_dev_cxx_0000* cxx-bits cxx-limits

namespace cxx_code
{
  // /usr/include/c++/4.9/limits

  /// numeric_limits<bool> specialization.
  template<>
    struct numeric_limits<bool>

} // namesapce

TEST(Bit, RightShift)
{
  {
    // fails
    // unsigned int int_max = (~((int)0)) >> 1;
    // int int_max = (~((int)0)) >> 1;
    // 
    // unsigned int val = ((~0) >> 1);
    
    // okays
    // unsigned int val = (((unsigned)~0) >> 1);
    // unsigned int val = ((unsigned)~0 >> 1);    // okay, since cast is higher
    //
    // int int_max = (~((unsigned int)0)) >> 1;
    // unsigned int int_max = (~((unsigned int)0)) >> 1;

    unsigned int uint_max = ~((unsigned int)0);
    unsigned int uint_max_two = (1U << 32) -1;

    int int_max = uint_max >> 1;
    int int_min = int_max + 1;

    bitset<32> bitsetx{int_max};
    EXPECT_EQ(bitsetx.to_string(), "01111111111111111111111111111111");

    EXPECT_EQ(uint_max, numeric_limits<unsigned int>::max());
    EXPECT_EQ(uint_max_two, numeric_limits<unsigned int>::max());

    EXPECT_EQ(int_max, numeric_limits<int>::max());
    EXPECT_EQ(int_min, numeric_limits<int>::min());
  }

  // why is that different?
  {
    // 1. when use `bitwise not`, the size and signness is `independant`. The
    // result `depends on the other operand` and done at `compile-time`. 
    //
    // so ~(0) makes "111...11" which don't have size and signness.
    //
    // 2. The signess must be known to compiler when do shift to have guaranteed
    // result. Since do not know signness, use `signed by default` and gets 1
    // for MSB when right-shift
    //
    // *cxx-shift-right-shift* 
    // the point is that must use `unsigned` to do `right-shift` 
    // in order to have guaranteed 0 values. 
    //
    // so (~(0)>>1) makes "111...11"
    //
    // This is why glibc macro uses unsigned type which set size and signness.
    // from glibc and see exercise 2-1 for examples.
    //
    // # ifndef ULONG_MAX
    // #  define ULONG_MAX ((unsigned long int) ~(unsigned long int) 0)
    // # endif
    // # ifndef LONG_MAX
    // #  define LONG_MAX ((long int) (ULONG_MAX >> 1))
    // # endif

    // input3 works since the result is `independant` but assigned to unsigned.
    // input1 version is shorter version of this.

    unsigned int input1 = ~((unsigned int)0)>>1;
    unsigned int input2 = (~(0)>>1);
    unsigned int input3 = ~0;
    input3 >>=1;

    std::bitset<32> bset1{input1};
    EXPECT_EQ(bset1.to_string(), "01111111111111111111111111111111");

    // this is wrong
    std::bitset<32> bset2{input2};
    EXPECT_EQ(bset2.to_string(), "11111111111111111111111111111111");

    std::bitset<32> bset3{input3};
    EXPECT_EQ(bset3.to_string(), "01111111111111111111111111111111");
  }
}


TEST(Bit, Tricks)
{
  // get bits which has [5, 0]th bis on. e.g. 0001.1111
  // in this case, do not need to specify unsigned.

  int value{};

  const int POS_TO_TURN_ON=5;
  value =  ~(~0 << POS_TO_TURN_ON);
  EXPECT_THAT(value, 0x1F);
}


<cxx-shift>
The summary is that for `unsigned`, `zero-filled` when do `right-shift`.

http://msdn.microsoft.com/en-us/library/336xbhcz.aspx

The `left-shift` causes that the bit positions that have been vacated by the
shift operation are `zero-filled.` 

The `right-shift` causes the bit pattern in shift expression to be shifted to
the right by the number of positions specified by additive-expression. 

For `unsigned` numbers, the bit positions that have been vacated by the shift
operation are `zero-filled`. 

For `signed` numbers, the sign bit is used to fill the vacated bit positions.
In other words, if the number is positive, 0 is used, and if the number is
negative, 1 is used.

The result of a right-shift of a signed negative number is implementation
dependent. Although Visual C++ uses the sign bit to fill vacated bit
positions, there is no guarantee that other implementations also do so.

The ansic says: Right shifting a 'signed' quantity will fill with sign bit
(arithmetic shift) on some machines and with 0 bits (logical shift) on others. 


<2> `left-shift-operator`
To explain this point, try this exercise first:

<ex> *ex-getbits* ansic, p49. 
The function getbits(x, p, n) returns the (right adjusted) n-bit field of x
that begins at position p. For example, getbits(x, 4, 3) returns the three
bits; 4th, 3th, 2th, right adjusted.

unsigned getbits( unsigned x, int p, int n );

<wrong>
unsigned getbits( unsigned x, int p, int n );
{
  return x >> (p+1-n) & ~(1 << n);
}

`left-shift` fills 0 but:

~(1<<3)   = ~(1000) = ~(11111000) = 00000111    // wrong
                    = ~(00001000) = 11110111    // real

<correct>
unsigned getbits( unsigned x, int p, int n )    // note unsigned
{
  return (x >> (p+1-n)) & ~(~0 << n);
}

this can be written using variables to make it clearer/easier to understand

unsigned getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  unsigned shift = (p+1-n);
  return (x >> shift) & mask;
}


note: to get n num bits on since `not-operator` don't have size and signness.

~(~0 << 2)    : ...0011
((-1) & 0x11) : ...0011


note:
1. "~(~0 << n)" is interesting in making a 'mask' value.
2. Why (p+1-n) for a shift? Since p(position) starts from 0.

7 6 5 4 3 2 1 0   8 7 6 5 4 3 2 1  position
     [* * *]           [* * *]
4+1-3 = 2 shift   5-3 = 2 shift

3. Do not need () since >> is higher than & but advisable to make easier to see.


<analysis> To see the differnece, see the below result.
#include <iostream>
#include <bitset>

int main()
{
  int ival = 1;

  int ival2 = ~( 1 << 3 );
  std::bitset<32> bitset2{ival2};
  std::cout << bitset2 << std::endl;

  int ival3 = ~(~0 << 3 );
  std::bitset<32> bitset3{ival3};
  std::cout << bitset3 << std::endl;

  unsigned int val2 = (~0);
  std::bitset<32> bitset2{val2};
  std::cout << bitset2 << std::endl;

  unsigned int val3 = (~1);
  std::bitset<32> bitset3{val3};
  std::cout << bitset3 << std::endl;
}

11111111111111111111111111110111       // <- 0...0001000 <- 0000001
00000000000000000000000000000111       // <- 1...1111000

11111111111111111111111111111111       // (~0)
11111111111111111111111111111110       // (~1)


<ex>
See use of 'U' which fix the warning like:
: warning: narrowing conversion of ‘-4’ from ‘int’ to ‘long long unsigned int’
since `signed` is default.

#define __DIAG_ALIGNMENT	(4U)
#define DIAG_CMN_ALIGN(x)	(((x) + (__DIAG_ALIGNMENT-1)) &~ (__DIAG_ALIGNMENT-1))


<3> independent-of-size
No difference when tried 'unsigned int'. The point is that "~0" is not the same
as "1". This is "independent of word length" in ansic p49. For example,

x = x & ~077

Set the last 'six' bits of x to zero since "x & ~077" is
`independent-of-word-length` and it thus perferable to, for example, x &
0177700, which assumes that x is a 16-bit quantity. The portable form involves
no extra cost, since ~077 is a constant expression that can be evaluated at
`compile-time` and the value `expands-to-fit` the type of operand that is used
with and that's why said independent.


<ex> *ex-bitcount*

// From ansic, p50. 
// The function counts the number of 1 bits in its integer argument. 
//
// 1. The key is not to use sizeof operator
// 2. unsigned argument
// 3. use independent of type.

// returns bit position starting from 1 since input >> is evalueated after
// ++count.
uint32_t count_bits_01(const uint32_t value)
{
    uint32_t count{};
    uint32_t input = value;

    // do not need to check like: if (input &1) to increase count for every
    // interation since when runs out 1, input becomes 0 and the loop ends. 
    for (; input != 0; input >>= 1)
        ++count;

    return count;
}

// page 51. exercise 2-9. In a two's complement number system, x &= (x-1) deletes
// the rightmost 1-bit in x. Explain why. Use this observation to write a 'faster'
// version of bitcount.
// 
// Answer:
// 
// If x is odd, then (x-1) has the same bit representation as x except that the
// rightmost 1-bit becomes a 0. In this case, (x & (x-1)) == (x-1).
// 
// x = 5: 5(101) & 4(100) = 100  // 101 -> 100 by having rightmost 1 to 0
// 
// If x is even, the end result of anding(&) x and x-1 has the rightmost 1 of x to 0.
// 
// x = 4: 4(100) & 3(11)  = 0    // 100 -> 0   by having rightmost 1 to 0
//          ^ rightmost 1
// x = 6: 6(110) & 5(101) = 100  // 110 -> 100 by having rightmost 1 to 0
//           ^ rightmost 1
// x = 8: 8(1000) & 7(111) = 0   // 1000 -> 0  by having rightmost 1 to 0
// 
// 000   0     All even numbers has tailing 0s and it becomes 1 when minus 1
// 001   1
// 010   2
// 011   3
// 100   4
// 101   5
// 110   6
// 111   7
// ...
// 
// note: This is about careful observation but not a mechanism of borrowing a carry
// for example. For both odd and even case, has the effect of having rightmost 1 to
// 0. So clear 1 from x one by one and no need to check on if to count bits.
// 
// note: And(&) is faster than shift operation? Yes and also there is no `if` in
// the loop.
// 
// int bitcount(unsigned x)
// {
//   int b;
// 
//   for (b = 0; x != 0; x &= (x-1))
//     b++;
//   return b;
// }

// but this fails. WHY?
uint32_t count_bits_02(const uint32_t value)
{
    uint32_t count{};
    uint32_t input = value;

    for (; input != 0; input &= (input-1))
        ++count;

    return count;
}


// returns bit position starting from 0 since input >> is evalueated before
// ++count.

uint32_t count_bits_03(const uint32_t value)
{
    uint32_t count{};
    uint32_t input = value;

    for (; input && (input >>=1);)
        ++count;

    return count;
}

TEST(CxxAlgoTest, FindNumberOfBitsBetweenTwoIntegers)
{
    // A = 35 = 10 0011
    // B =  9 =    1001
    EXPECT_THAT(count_bits_01(35), Eq(6));
    EXPECT_THAT(count_bits_01(9), Eq(4));

    // fails
    // EXPECT_THAT(count_bits_02(35), Eq(6));
    // EXPECT_THAT(count_bits_02(9), Eq(4));

    EXPECT_THAT(count_bits_03(35), Eq(5));
    EXPECT_THAT(count_bits_03(9), Eq(3));
}


<ex>
From ansic, exercise 2-6. Write a function setbits(x,p,n,y) that returns x with
the n bits that begin at position p set to the rightmost n bits of y, leaving
the other bits unchanged.

Had difficult to understand a question. The question is that set n bits of x
starting from p with rightmost n bits of y and return the result.

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_6

int getbits( unsigned x, int p, int n );
int setbits( unsigned x, int p, int n, unsigned y );
void printbits( unsigned x );

// one
return (
    (x & ~(~(~0 << n) << p+1-n))    // set n bits of x to 0. x & ~(mask << shift)
    |
    (
     (~(~0 << n) & y)               // get rightmost n bits of y. mask & y
     << p+1-n                       // shift to be in p pos
    )
    );


// two
// The following function, "getbits", is from K&R p 49 */
// getbits: get n bits from position p
unsigned getbits(unsigned x, int p, int n)
{
  return (x >>(p+1-n) & ~(~0 << n));
}

// asbits - shows integers as bit strings. note <quiz> this is useful as bitset
// Usage:                                
//         asbits(x, sizeof(x), FLAG)    
// FLAG = 1|0, showing if newline desired
void asbits(unsigned x, size_t s, int nl)
{
  int i;

  for(i = s*8-1; i>=0; i--) {
    getbits(x, i, 1)? putchar('1') : putchar('0');
    if(!(i%4))putchar(' ');
  }
  if(nl)putchar('\n');
}

<example>
#include <iostream>

using namespace std;

int getbits( unsigned x, int p, int n );
int setbits( unsigned x, int p, int n, unsigned y );
void printbits( unsigned x );

int getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  return (x>>p-n+1) & mask;
}

int setbits( unsigned x, int p, int n, unsigned y )
{
  unsigned xi = x & ~(~(~0<<n) << p-n+1); // xi = x & ~mask << p-n+1;
  unsigned yi = (y & ~(~0<<n)) << p-n+1;  // yi = y & mask << p-n+1;
  return xi | yi;
}

void printbits( unsigned x )
{
  int bits;

  for( bits = sizeof x *8 -1; bits >= 0; bits-- )
  {
    getbits( x, bits, 1 ) ? putchar('1') : putchar('0');
    if( bits % 4 == 0 )
      putchar(' ');
  }
  
  putchar('\n');
}

int main()
{
  unsigned int val1 = 0x558088;
  unsigned int val2 = 0x07507;

  cout << "val1: ";
  printbits( val1 );

  cout << "val2: ";
  printbits( val2 );

  cout << "setb: ";
  printbits( setbits( val1, 14, 3, val2 ));
}

val1: 0000 0000 0101 0101 1000 0000 1000 1000 
val2: 0000 0000 0000 0000 0111 0101 0000 0111 
setb: 0000 0000 0101 0101 1111 0000 1000 1000 
                           ^^^

<key> To set some bits of x with some bits of y, then some bits of x must be 0
before oring.

| XA | 00 | XB |
        OR
| 00 | YY | 00 |

<to-print-a-bits-in-string>
The possible approach is to use right shift one by one, check if it's 0 or 1,
    and save or print it. This approach has a problem since check on LSB, will
    get the reversed output. This is why "asbits" starts from MSB by using
    getbits() but not LSB.

<stack-and-queue>
This reminds me stack and queue.

input: 11101
           ^ start

      0 1 2 3 4 pos in array
      1 1 1 0 1

read(pop) as a stack, FILO          read(get) as a queue, FIFO
note. reversed output
       10111                           11101
           ^ start                         ^ start

if putchar(printf) array for both cases
   11101

if putchar when get it
   10111


<exercise>
From ansic, exercise 2-7. Write a function invert(x,p,n) that returns x with the
n bits that begin at position p inverted (i.e., 1 changed into 0 and vice
    versa), leaving the others unchanged.

// setbits uses y to set x and here xin uses instead.
unsigned invert_mine(unsigned x, int p, int n)
{
  // this makes easier to see a code
  unsigned msk = ~(~0 << n);

  // [*][x ][*] : x
  // [0][1 ][0] : msk << p+1-n
  // [0][x ][0] : (msk << p+1-n) & x
  // [1][x'][1] : ~((msk << p+1-n) & x)
  // [0][1 ][0]
  // [0][x'][0] : &
  unsigned xin = (~((msk << p+1-n) & x)) & msk << p+1-n;

  // this is the same as setbits
  return (x & ~(msk<< p+1-n)) | ((xin & msk)<< p+1-n);
}

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_7    note: xor
GP is in error. Here is a correct solution. Pilcrow 17:45, 31 August 2011 (UTC) 
unsigned invert_online(unsigned x, int p, int n)
{
  return x ^ ((~(~0<<n))<< p+1-n);
  // return x ^ (mask << shift);
}


int main()
{
  unsigned int val1 = 0x558088;

  cout << "val1: ";
  printbits( val1 );

  cout << "invt: ";
  printbits( invert( val1, 14, 3 ));
}

val1: 0000 0000 0101 0101 1000 0000 1000 1000 
invt: 0000 0000 0101 0101 1111 0000 1000 1000 
                           ^^^

<exercise>
From ansic, exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x
rotated to the right by n bit positions.

note: the keys are
1. Cannot use single mask and bit operation since it 'rotates' so have to use loop.
2. Needs observation when the rightmost bit is either 1 or 0.

1) The type is 'unsigned' so do not need to concern about value when do right shift. If not, need to
know the the length of type, such as sizeof(x).

// one note: prefer this since do not use sizeof and function call
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned rightrot(unsigned x, unsigned n)
{
  while (n > 0) {
    if ((x & 1) == 1)
      x = (x >> 1) | ~(~0U >> 1);      // note: must use 'U' suffix or unsigned cast
    else
      x = (x >> 1);
    n--;
  }
  return x;
}

// two
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned int rightrot(unsigned int x, int n)
{
  int m, i;

  for(i=0; i < n; i++) {
    m = getbits(x, 0, 1);
    m <<= (sizeof(m)*8-1);       // notice the use of sizeof
    x >>= 1;
    x |= m;
  }
  return x;
}

int main()
{
  unsigned int val1 = 0x07507;

  cout << "val1: ";
  printbits( val1 );

  cout << "rrot: ";
  printbits( rightrot( val1, 3 ));
}

val1: 0000 0000 0000 0000 0111 0101 0000 0111 
rrot: 1110 0000 0000 0000 0000 1110 1010 0000 
      ^^^

{bitwise-octal}
A leading 0 on an integer constant means 'octal' and this seems better than hex
to use with bit pattern.

0 0
1 01
2 10
3 11
4 100
5 101 
6 110
7 110

0177 1.111.111
0x7F 111.1111


={============================================================================
*kt_dev_cxx_0000* cxx-type cxx-32-bit cxx-64-bit

<ex> *cxx-printf*
{
  printf("ulong max from limits: %luL\n", ULLONG_MAX );
  printf("ulong max from limits: %lluL\n", ULLONG_MAX );
  cout << "ulong max from limits: " << ULLONG_MAX << endl;
}

ulong max from limits: 4294967295L            //         0xffffffff 
ulong max from limits: 18446744073709551615L  // 0xffffffffffffffff
ulong max from limits: 18446744073709551615

This shows that printf outputs differently depending on specifier used.

<ex>

{
  unsigned long long umax = UINT_MAX;

  printf("Maximum value of type unsigned int : %llu, 0x%llx\n\n",
      umax, umax);
}

Maximum value of type unsigned int : 4294967295, 0xffffffff

{
  unsigned long long umax = UINT_MAX;

  printf("Maximum value of type unsigned int : %u, 0x%llx\n\n",
      umax, umax);
}

Maximum value of type unsigned int : 4294967295, 0xffffffff00000000

Why different? printf bug?

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %u, 0x%x\n\n",
      umax, umax);
}

value of type unsigned int : 4294967295, 0xffffffff

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %llu, 0x%llx\n\n",
      umax, umax);
}

value of type unsigned int : 18446744073709551615, 0x10804875b


note:
Looks like that printf uses pointer depending on `specifier used`


<ex>

{
    double d_val = 3.14;
    int i_val = d_val;
    double d_vval = i_val;

    std::cout << "d_val: " << d_val << ", i_val: " << i_val << std::endl;
    std::cout << "d_val: " << d_val << ", i_val: " << i_val << ", d_vval: " << d_vval << std::endl;

    printf ("d_val: %e, i_val: %e, \n", d_val, i_val );
    printf ("d_val: %e, i_val: %e, d_vval: %e \n", d_val, i_val, d_vval);
}

d_val: 3.14, i_val: 3
d_val: 3.14, i_val: 3, d_vval: 3
d_val: 3.140000e+00, i_val: 3.034283e-86,
d_val: 3.140000e+00, i_val: 3.000000e+00, d_vval: 0.000000e+00


<ex>
Started from a question that "What would happen when do UINT_MAX*16 and put the
result back to unsigned int?"

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %u, 0x%x \n", umax, umax);

  unsigned long long ll = 16*umax;

  or

  unsigned int ll = 16*umax;

  printf("value of type unsigned long: %llu, 0x%llx \n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 4294967280, 0xfffffff0


<cxx-wrap-around>
The result looks like done 16(2^4) shift regardless of type used. Why is that?
This is due to *wrap-around*

CPM P35.

If we assign an out-of-range value to an object of unsigned type, the result is
the 'remainder' of the value 'modulo' the number of values the 'target' type can
hold. For example, 8-bit unsigned char can hold values from 0 through 255
inclusive. If we assign a value outside this range, the compiler assigns the
remainder of that value modulo 256. Therefore, assigning -1 to an unsigned char
gives that object the value 256.

{
  unsigned int umax = UINT_MAX;

  printf("value of type unsigned int : %u, 0x%x \n", umax, umax);

  unsigned long long ll = 2*umax;

  printf("value of type unsigned long: %llu, 0x%llx\n\n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 4294967294, 0xfffffffe


{
  unsigned long long umax = UINT_MAX;

  printf("value of type unsigned int : %llu, 0x%llx \n", umax, umax);

  unsigned long long ll = 2*umax;

  printf("value of type unsigned long: %llu, 0x%llx \n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 8589934590, 0x1fffffffe

The above shows that wrap-around happens before promotion.


{
  unsigned long long umax = UINT_MAX;

  printf("value of type unsigned int : %llu, 0x%llx \n", umax, umax);

  unsigned long long ll = 16*umax;

  printf("value of type unsigned long: %llu, 0x%llx \n", ll, ll);
}

value of type unsigned int : 4294967295, 0xffffffff
value of type unsigned long: 68719476720, 0xffffffff0


<Q>
Interesting thing found is that when use calculation to get MIN and MAX, cout
prints out MIN without minus sign but printf do. When use real value as limits.h
do, cout prints out minus sign.

#include <iostream>
#include <climits>
#include <cstdio>

using namespace std;

#define MUINT_MAX (~(unsigned)0)

// #define MINT_MAX ((unsigned)~0>>1)
// #define MINT_MIN (-MINT_MAX-1)

// taken from limits.h
#define MINT_MIN  (-MINT_MAX - 1)
#define MINT_MAX  2147483647

int main()
{
  cout << "uint: " << 0 << " - " << UINT_MAX << endl;
  cout << " int: " << INT_MIN << " - " << INT_MAX << endl;

  cout << "uint: " << 0 << " ~ " << MUINT_MAX << endl;
  cout << " int: " << -MINT_MAX-1 << " ~ " << MINT_MAX << endl;

  printf("signed int : %4d ~ %4d \n", MINT_MIN, MINT_MAX );
}

uint: 0 - 4294967295
 int: -2147483648 - 2147483647
uint: 0 ~ 4294967295
 int: -2147483648 ~ 2147483647            // note:
signed int : -2147483648 ~ 2147483647 


<cxx-type-cxx-size-t>
type `size_t` is a machine-specific `unsigned type` that is guaranteed to be
large enough to hold `the size of any` object in memory.

namespace cxx_code 
{
  // /usr/include/c++/4.9/cstddef

#ifndef _GLIBCXX_CSTDDEF
#define _GLIBCXX_CSTDDEF 1

#pragma GCC system_header

#include <bits/c++config.h>
#include <stddef.h>

#if __cplusplus >= 201103L
  namespace std
  {
    // We handle size_t, ptrdiff_t, and nullptr_t in c++config.h.
    using ::max_align_t;
  }
#endif

#endif // _GLIBCXX_CSTDDEF


  // c++config.h
  namespace std
  {
    typedef __SIZE_TYPE__ size_t;
    typedef __PTRDIFF_TYPE__ ptrdiff_t;

    // *cxx-nullptr*
#if __cplusplus >= 201103L
    typedef decltype(nullptr) nullptr_t;
#endif
  }
} // namespace


<cxx-issue>
The problem is when use size_t variable, -Wall is on, and use printf like:

  AS_LOG_ERROR("failed to find timer with tag %ld to remove", variable);

To avoid failire on 64 bit build, change it to "%lld" but now it fails for 32
bit build. 

So the solution is:
changed the type of variable to uint32_t.


<cxx-issue>
https://www.gnu.org/software/libc/manual/html_node/Integers.html

20.1 Integers

The C language defines several integer data types: integer, short integer,
long integer, and character, all in both signed and unsigned varieties.

The GNU C compiler extends the language to contain long long integers as
well.

The C integer types were intended to allow code `to be portable` among machines
with different inherent data sizes (word sizes), so each type may have
different ranges on different machines. The problem with this is that a
program often needs to be written for a particular range of integers, and
sometimes must be written for a particular size of storage, regardless of what
machine the program runs on.

To address this problem, `the GNU C Library contains C type definitions` you can
use to declare integers that meet your exact needs. 

Because the GNU C Library header files are customized to a specific machine,
`your program source code doesn’t have to be.`

These typedefs are in `stdint.h`.

If you require that an integer be represented in exactly N bits, use one of
the following types, with the obvious mapping to bit size and signedness:

int8_t
int16_t
int32_t
int64_t
uint8_t
uint16_t
uint32_t
uint64_t

// LP64
// __x86_64__
// size of (int) is                : 4
// size of (unsigned int) is       : 4
// size of (long) is               : 8
// size of (unsigned long) is      : 8
// size of (long int) is           : 8
// size of (unsigned long int) is  : 8
// size of (long long) is          : 8
// size of (unsigned long long) is : 8
// size of (* int) is              : 8
// size of (* unsigned int) is     : 8
// size of (size_t) is             : 8
// size of (uint32_t) is           : 4
// size of (uint64_t) is           : 8
//
//
// LP32
// __x86_32__
// size of (int) is                : 4
// size of (unsigned int) is       : 4
// size of (long) is               : 4
// size of (unsigned long) is      : 4
// size of (long int) is           : 4
// size of (unsigned long int) is  : 4
// size of (long long) is          : 8
// size of (unsigned long long) is : 8
// size of (* int) is              : 4
// size of (* unsigned int) is     : 4
// size of (size_t) is             : 4
// size of (uint32_t) is           : 4
// size of (uint64_t) is           : 8


Ok, then these types would solve the issue? "NO" since see the issue on using
*cxx-printf*

So the same `uint64_t` has the same physical size on both but is regarded as
different type:

{
  uint64_t value{10};

#if !defined(__LP64__) || !defined(_LP64)

  // 32 bits
  // warning: format ‘%ld’ expects argument of type ‘long int’, 
  // but argument 2 has type ‘uint64_t {aka `long long unsigned int`}’ [-Wformat=]
  //
  // printf("uint64 value is %ld\n", value);

  printf("uint64 value is %lld\n", value);

#else

  // 64 bits
  // warning: format ‘%lld’ expects argument of type ‘long long int’, 
  // but argument 2 has type ‘uint64_t {aka `long unsigned int`}’ [-Wformat=]
  //
  // printf("uint64 value is %lld\n", value);

  printf("uint64 value is %ld\n", value);

#endif
}

So problem here is `have to use right format specifier` depending on 32/64.

the possible two solution:

1. use if/def

#if defined(__LP64__) || defined(_LP64)
  AS_LOG_ERROR("failed to find timer with tag %ld to remove", tag);
#else
  AS_LOG_ERROR("failed to find timer with tag %lld to remove", tag);
#endif

https://stackoverflow.com/questions/685124/how-to-identify-a-64-bit-build-on-linux-using-the-preprocessor

__LP64__
_LP64

https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros

These macros are defined, with value 1, if (and only if) the compilation is
for a target where long int and pointer both use 64-bits and int uses 32-bit.

see *cxx-cpp-check-define*


2. the other solution is to use PRId64

https://stackoverflow.com/questions/9225567/how-to-print-a-int64-t-type-in-c

// cause error since it have to use "%"
AS_LOG_ERROR("failed to find timer with tag % to remove" PRId64, tag);

// ok
AS_LOG_ERROR("failed to find timer with tag %" PRId64 " to remove", tag);

this is effectively same as pre-processor replace PRIxx with "ld" or "lld".


*cxx-issue-case* *cxx-vaarg-issue*

This not only cause compile warnings. It causes core dump on embedded which is
very difficult to get call traces since it's crashes in libc.

int64 spk{-1};

printf("pk(%d)\n", spk);

#0  0xb68bce6e in strlen () from /lib/libc.so.6
#1  0xb689fe04 in vfprintf () from /lib/libc.so.6
#2  0xb68a2aea in printf () from /lib/libc.so.6

should catch `cxx-warning` when build then could save days.

warning: format ‘%d’ expects argument of type ‘int’, 
  but argument 2 has type ‘int64 {aka long long int}’ [-Wformat=]


={============================================================================
*kt_dev_cxx_0000* cxx-printf-format cxx-vaarg

<cxx-printf-format>

       int printf(const char *format, ...);

man 3 printf

   Format of the format string

       The format string is a character string, beginning and ending in its
       initial shift state, if any. The format string is composed of zero or
       more  directives: 
       
       ordinary  characters (not  %),  which  are copied unchanged to the
       output stream; 
       
       and `conversion specifications`, each of which results in fetching zero
       or more subsequent arguments. Each conversion specification is
       introduced by the character `%`, and
       
       In between 

       1. there may be (in this order) zero or more `flags`, 
       2. an optional minimum `field width`, 
       3. an optional `precision` 
       4. an optional `length modifier`
       5. `ends with a conversion specifier`

   The length modifier

       Here, "integer conversion" stands for d, i, o, u, x, or X conversion.

       hh     
       A following integer conversion corresponds to a signed char or unsigned
       char argument, or a following n conversion corresponds to a pointer to
       a signed char argument.

       h
       A following integer conversion corresponds to a short int or unsigned
       short int argument, or a following n conversion corresponds to a
       pointer to a short int argument.

       l
       (ell) A following integer conversion corresponds to a long int or
       unsigned long int argument, or a following n conversion corresponds to
       a pointer to a long int argument, or a following c conversion
       corresponds to a wint_t argument, or a following s conversion
       corresponds to a pointer to wchar_t argument.

       ll
       (ell-ell).  A following integer conversion corresponds to a long long
       int or unsigned long long int argument, or a following n conversion
       corresponds to a pointer to a long long int argu‐ ment.

       L 
       A following a, A, e, E, f, F, g, or G conversion corresponds to a long
       double argument. (C99 allows %LF, but SUSv2 does not.)


   The conversion specifier

       A character that specifies the type of conversion to be applied.  The
       conversion specifiers and their meanings are:

       d, i
       
       The int argument is converted to signed decimal notation.  The
       precision, if any, gives the minimum number of digits that must appear;
       if the converted value requires fewer digits, it is padded on the left
       with  zeros.  The default precision is 1.  When 0 is printed with an
       explicit precision 0, the output is empty.

       o, u, x, X 
       
       The  `unsigned-int` argument is converted to 

       unsigned octal (o),

       unsigned decimal (u), 

       unsigned hexadecimal (x and X) notation. 
       The letters abcdef are used for x conversions; the letters ABCDEF are
       used for X conversions.  
         
       The precision, if any, gives the minimum number of digits that must
       appear; if the converted value requires fewer digits, it is padded on
       the left with zeros.  The default precision is 1.   When  0 is  printed
       with an explicit precision 0, the output is empty.

       p
       The void * pointer argument is printed in hexadecimal 
       (as if by %#x or %#lx).

       a, A

       (C99;  not  in  SUSv2,  but  added in SUSv3) For a conversion, the
       `double` argument is converted to hexadecimal notation (using the
           letters abcdef) in the style [-]0xh.hhhhp±; for A conversion the
       prefix 0X, the letters ABCDEF, and the exponent separator P is used.
       There is one hexadecimal digit before the decimal point, and the number
       of digits after it is equal to the precision.  The default precision
       suffices for an  exact  repre- sentation of the value if an exact
       representation in base 2 exists and otherwise is sufficiently large to
       distinguish values of type double.  The digit before the decimal point
       is unspecified for nonnormalized numbers, and nonzero but otherwise
       unspecified for normalized numbers.


       f, F   
       The `double  argument` is rounded and converted to decimal notation in
       the style [-]ddd.ddd, where the number of digits after the
       decimal-point character is equal to the precision specification.  If
       the  precision  is missing,  it  is  taken as 6; if the precision is
       explicitly zero, no decimal-point character appears.  If a decimal
       point appears, at least one digit appears before it.

       g, G
       The `double argument` is converted in style f or e (or F or E for G
           conversions). The precision specifies the number of significant
       digits.  If the  precision  is  missing,  6  digits  are given;  if
       the  precision is zero, it is treated as 1.  Style e is used if the
       exponent from its conversion is less than -4 or greater than or equal
       to the precision.  Trailing zeros are removed from the fractional part
       of the result; a decimal point appears only if it is followed by at
       least one digit.

       s
       
       If no l modifier is present: The const char * argument is expected to
       be a pointer to an array of character type (pointer to a string).
       Characters from the array are written up  to  (but not  including)  a
       terminating null byte ('\0'); if a precision is specified, no more than
       the number specified are written.  If a precision is given, no null
       byte need be present; if the precision is not specified, or is greater
       than the size of the array, the array must contain a terminating null
       byte.

       If an l modifier is present: The const wchar_t * argument is expected
       to be a pointer to an array of wide characters.  Wide characters from
       the array are converted to multibyte characters (each  by a call to the
           wcrtomb(3) function, with a conversion state starting in the
           initial state before the first wide character), up to and including
       a terminating null wide character.  The resulting multibyte characters
       are written up to (but not including) the terminating null byte.  If a
       precision is specified, no more bytes than the number specified are
       written,  but no  partial  multibyte characters are written.  Note that
       the precision determines the number of bytes written, not the number of
       wide characters or screen positions.  The array must con‐ tain a
       terminating null wide character, unless a precision is given and it is
       so small that the number of bytes written exceeds it before the end of
       the array is reached.


{cxx-vaarg} cxx-variable-arguments cxx-cpp

The va_arg, va_copy, va_end, and va_start `macros` provide a portable way to
access the arguments to a function when the function takes a variable number
of arguments. 

There are two versions of the macros: The macros defined in STDARG.H conform
to the ISO C99 standard; the macros defined in VARARGS.H are deprecated but
are retained for backward compatibility with code that was written before the
ANSI C89 standard. 


STDARG(3) Linux Programmer's Manual

NAME
stdarg, va_start, va_arg, va_end, va_copy - variable argument lists

SYNOPSIS
 #include <stdarg.h>

 void va_start(va_list ap, last);
 type va_arg(va_list ap, `type`);
 void va_end(va_list ap);
 void va_copy(va_list dest, va_list src);

DESCRIPTION

A function may be called with a `varying number of arguments` of
`varying types` 

The include file <stdarg.h> declares a type va_list and defines three macros
for stepping through a list of arguments whose number and types are not known
to the called function.

The called function must declare an object of type va_list which is used by
the macros va_start(), va_arg(), and va_end().


va_start() 

The va_start() macro initializes `ap` for subsequent use by va_arg() and
va_end(), and must be called first.

The argument `last` is the name of the last argument `before` the variable
argument list, that is, the last argument of 
`which the calling function knows the type.`

Because the address of this argument may be used in the va_start() macro, it
should not be declared as a register variable, or as a function or an array
type.


va_arg()

The va_arg() macro expands to an expression that has the type and value of the
next argument in the call. The argument ap is the va_list ap initialized by
va_start(). Each call to va_arg() modifies ap so that the next call returns
the next argument. `The argument type is a type name specified` so that the
type of a pointer to an object that has the specified type can be obtained
simply by adding a * to type.

The first use of the va_arg() macro after that of the va_start() macro returns
the argument after last. Successive invocations return the values of the
remaining arguments.

  If there is no next argument, or if type is not compatible with the type of
  the actual next argument (as promoted according to the default argument
  promotions), `random errors will occur. *cxx-error*`

If ap is passed to a function that uses va_arg(ap, type) then the value of ap
is undefined after the return of that function.


va_end()

Each invocation of va_start() must be matched by a corresponding invocation of
va_end() in the same function. After the call va_end(ap) the variable ap is
undefined. Multiple traversals of the list, each bracketed by va_start() and
va_end() are possible. va_end() may be a macro or a function.

<ex>

namespace cxx_cpp
{
  void argprint(int num_args, ...)
  {
    va_list ap;

    // The argument `last` is the name of the last argument `before` the
    // variable argument list, that is, the last argument of `which the calling
    // function knows the type.`

    va_start(ap, num_args);

    // note that num_arg is valid arg to use

    for (int i = 0; i < num_args; ++i)
    {
      std::cout << "arg " << i << " is " << va_arg(ap, int) << std::endl;
    }

    va_end(ap);
  }


  // The function takes a string of format characters and prints out the
  // argument associated with each format character `based on the type`

  void xprint(char *fmt, ...)
  {
    va_list ap;
    int d;
    char c, *s;

    va_start(ap, fmt);

    while (*fmt)
    {
      switch (*fmt++)
      {
        case 's':
          s = va_arg(ap, char *);
          printf("string %s\n", s);
          break;
        
        case 'd':
          d = va_arg(ap, int);
          printf("int %d\n", d);
          break;

        case 'c':

          // c = va_arg(ap, char);
          // cxx.cpp:7950:26: warning: ‘char’ is promoted to ‘int’ when passed through ‘...’
          //            c = va_arg(ap, char);
          //                           ^
          // cxx.cpp:7950:26: note: (so you should pass ‘int’ not ‘char’ to ‘va_arg’)
          // cxx.cpp:7950:26: note: if this code is reached, the program will abort
          //
          // need a cast here since va_arg only takes fully promoted types

          c = (char) va_arg(ap, int);
          printf("char %c\n", c);
          break;
      }
    }
    va_end(ap);
  }

} // namespace


// arg 0 is 10
// arg 1 is 20
// arg 2 is 30
//
// string foo
// int 10
// char a
//
// string foo
// int 10
// int 97

TEST(Cpp, Vaarg)
{
  using namespace cxx_cpp;

  argprint(3, 10, 20, 30);

  xprint("sdc", "foo", 10, 'a');
  xprint("sdd", "foo", 10, 'a');
}


<cxx-vprintf>

#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

#include <stdarg.h>

int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);

The functions vprintf(), vfprintf(), vsprintf(), vsnprintf() are equivalent to
the functions printf(), fprintf(), sprintf(), snprintf(), respectively, except
that they are called with a `va_list instead of` a variable number of
arguments. These functions do not call the va_end macro. Because they
invoke the va_arg macro, the value of ap is undefined after the call. See
stdarg(3).

The functions snprintf() and vsnprintf() do not write more than size bytes
(including the terminating null byte ('\0')). If the output was truncated due
to this limit then the return value is the number of characters (excluding the
    terminating null byte) which would have been written to the final string
if enough space had been available. Thus, a return value of size or more means
that the output was truncated.  (See also below under NOTES.) If an output
error is encountered, a negative value is returned.


{cxx-vaarg-cpp-vaarg} variadic-macros

http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html

A `macro` can be declared to accept a variable number of arguments much as a
function can. The syntax for defining the macro is similar to that of a
function. Here is an example:

     #define eprintf(...) fprintf (stderr, __VA_ARGS__)

This kind of macro is called `variadic`. When the macro is invoked, all the
tokens in its argument list after the last named argument (this eprintf macro
    has none), including any commas, become the variable argument. This
sequence of tokens replaces the identifier __VA_ARGS__ in the macro body
wherever it appears. Thus, we have this expansion:

     eprintf ("%s:%d: ", input_file, lineno)
          ==>  fprintf (stderr, "%s:%d: ", input_file, lineno)

The variable argument is completely macro-expanded before it is inserted into
the macro expansion, just like an ordinary argument. You may use the '#' and
'##' operators to stringify the variable argument or to paste its leading or
trailing token with another token. (But see below for an important special
    case for '##'.)

If your macro is complicated, you may want `a more descriptive name` for the
variable argument than __VA_ARGS__. CPP permits this, as an extension. You may
write an argument name immediately before the '...'; that name is used for the
variable argument. The eprintf macro above could be written

     #define eprintf(args...) fprintf (stderr, args)


<use-named-and-variable-args>

You `can have named arguments as well as variable arguments` in a variadic
macro. We could define eprintf like this, instead:

     #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)

This formulation looks more descriptive, but unfortunately it is `less
flexible`: you must now supply at `least-one-argument` after the format string
because in standard C, you cannot omit the comma separating the named argument
`from` the variable arguments, because there will be an extra comma after the
format string.

*cxx-error* on for GCC 4.6 and 6.x when use:

#define eprintf(fmt, ...)  fprintf(stdout, fmt, __VA_ARGS__)
eprintf("success!\n");

cxx.cpp:7996:66: error: expected primary-expression before ‘)’ token
  #define eprintf(format, ...)  fprintf(stdout, format, __VA_ARGS__)

HOW to fix?

TEST(Cpp, VaargMacro)
{
  eprintf("success!\n");
}


`the '##' token paste operator` has a special meaning when placed between a
comma and a variable argument. If you write

     #define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

and the variable argument is left out when the eprintf macro is used, then the
`comma before the '##' will be deleted.` 

     eprintf ("success!\n")
          ==> fprintf(stderr, "success!\n");

// no napesapce effect but for visual effect
namespace cxx_cpp
{
#define eprintf(fmt, ...)  fprintf(stdout, fmt, ##__VA_ARGS__)
} // namespace


// [ RUN      ] Cpp.VaargMacro
// success!
// [       OK ] Cpp.VaargMacro (0 ms)

TEST(Cpp, VariableArgsMacro)
{
  eprintf("success!\n");
}


The above explanation is ambiguous about the case where the only macro
parameter is a variable arguments parameter, as it is meaningless to try to
distinguish whether no argument at all is an empty argument or a missing
argument. In this case the C99 standard is clear that the comma must remain,
however the existing GCC extension used to swallow the comma. So CPP retains
the comma when conforming to a specific C standard, and drops it otherwise.

Variadic macros are a new feature in C99. GNU CPP has supported them for a
long time, but only with a named variable argument ('args...', not '...' and
    __VA_ARGS__). If you are concerned with portability to previous versions
of GCC, you should use only named variable arguments. On the other hand, if
you are concerned with portability to other conforming implementations of C99,
you should use only __VA_ARGS__.

Previous versions of CPP implemented `the comma-deletion extension` much more
generally. We have restricted it in this release to minimize the differences
from C99. 

To get the same effect with both this and previous versions of GCC, the token
preceding the special '##' must be a comma, and there must be white space
between that comma and whatever comes immediately before it:

  #define eprintf(format, args...) fprintf (stderr, format , ##args)


{case}

Use:

MHEGDebugInfo(eMHVdsm, "_mhvDsmEventCreate %d\n", num);

#if ...

#define MHEGDebugInfo(comp, ...) {BP_PRINT(MHEGDebugCompToBPComp(comp), CCDebugBP::INFO, __VA_ARGS__);\
                                  MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__); }
...

#define MHEGOnlyDebugInfo(comp, ...) (MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
...

#else

#define MHEGDebugInfo(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugDebug(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelDebug, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugWarning(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelWarning, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugMajor(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelMajor, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugFatal(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelFatal, __FUNCTION__, __VA_ARGS__))

#endif

void MHEGDebugTrace(MHEGComponent comp, MHEGLevel level, const char* functionName, ...)
{
  // Always send to BP print, at least for now.
  if ((s_traceLevels[comp] >= level) && (s_traceLevels[comp] < eMHEGLevelOff))
  {
    va_list ap;
    va_start(ap, functionName);
    char *message = va_arg(ap, char*);
    output(comp, level, functionName, message, ap);
    va_end(ap);
  }
}

#define LINE_LIMIT 1024
static char temp_buffer[LINE_LIMIT + 1]; // Limit all strings to LINE_LIMIT

void output(MHEGComponent comp, MHEGLevel level, const char* function, const char* string, va_list arg)
{
  AUTOLOCK();

  // TODO, add support for timestamp.
  // Check for space
  // Construct final string
  long int tick = PCTime::Tick();

  // #define SNPRINTF snprintf

  int pos = SNPRINTF(temp_buffer, LINE_LIMIT, "[%ld:%ld][%s][%s][%s] ", 
      tick/1000, tick%1000, s_names[comp], s_traceLevelName[level], function);

  // string is fmt

  size_t len = vsnprintf(temp_buffer + pos, LINE_LIMIT - pos - 1, string, arg) + pos;

  if (temp_buffer[len - 1] != '\n')
  {
    temp_buffer[len] = '\n';
    len++;
    temp_buffer[len] = '\0';
  }

  BP_PRINTR(CCDebug::DEFAULT, CCDebugBP::INFO, temp_buffer);
}


{case}

From Tizen:

__pServiceAppImpl is pointer from creating objcets.

/*
 * @param[in] NID         The Tizen namespace
 * @param[in] condition   The condition that is expected to be true
 * @param[in] r           The last result to set
 * @param[in] ...         The message to display
 */

SysTryReturnResult(NID_APP, __pServiceAppImpl, E_OUT_OF_MEMORY, "[E_OUT_OF_MEMORY] Insufficient memory.");

// *cxx-unlikely*

#ifndef unlikely
#define unlikely(x)  __builtin_expect(!!(x), 0)
#endif

#define SysTryReturnVoidResult(NID, condition, r, ...) \
  do \
  { \
    if (unlikely(!(condition))) \
    { \
      SysLogException(NID, r, __VA_ARGS__); \
      return; \
    } \
  } while (0);

// nested variadic macro

#define SysLogException(NID, r, ...)  SysLogExceptionInternal(NID, r, __PRETTY_FUNCTION__, __LINE__, __VA_ARGS__)


void
SysLogExceptionInternal(unsigned long nid, result r, const char* pFunction, int lineNumber, const char* pFormat, ...)
{
  va_list args;

  SetLastResult(r);

  if (!logInfo.platformExceptionEnabled)
  {
    return;
  }

  va_start(args, pFormat);
  __PrintSysLog(static_cast<_LogType>(LOG_EXCEPTION), static_cast<LogID>(nid), pFunction, lineNumber, pFormat, args);
  va_end(args);
}

void 
__PrintSysLog(_LogType type, LogID id, const char* pFunction, int lineNumber, const char* pFormat, va_list args)
{
  if (!iniLoaded)
  {
    __InitializeLogInfo();
  }

  if (!__GetEnableInfo(static_cast<LogID>(id)))
  {
    return;
  }

  char logBody[LOG_LEN_MAX];
  snprintf(logBody, LOG_LEN_MAX, "%s(%d) > %s", pFunction, lineNumber, pFormat);
  logBody[LOG_LEN_MAX -1] = '\0';

  char logTag[LOG_MODULE_NAME_LEN_MAX];

  snprintf(logTag, LOG_MODULE_NAME_LEN_MAX, "%s", __GetModuleName(static_cast<LogID>(id)));
  logTag[LOG_MODULE_NAME_LEN_MAX - 1] = '\0';

  switch (type)
  {
    case static_cast<_LogType>(LOG_INFO):
      LOG_VA(LOG_INFO, logTag, logBody, args);
      break;

    case static_cast<_LogType>(LOG_DEBUG):
      LOG_VA(LOG_DEBUG, logTag, logBody, args);
      break;

    case static_cast<_LogType>(LOG_EXCEPTION):
      ALOG_VA(LOG_ERROR, logTag, logBody, args);
      break;

    case static_cast<_LogType>(LOG_USER):
      ALOG_VA(LOG_ERROR, logTag, logBody, args);
      break;

    default:
      LOG_VA(LOG_DEBUG, LOG_TAG_NULL, logBody, args);
      break;
  }
}

#ifndef LOG_VA
#define LOG_VA(priority, tag, fmt, args) \
  vprint_log(D##priority, tag, fmt, args)
#endif

#define vprint_log(prio, tag, fmt...) \
  __dlog_vprint(LOG_ID_MAIN, prio, tag, fmt)


result
ServiceApp::Execute(ServiceAppInstanceFactory pServiceAppFactory, const IList* pArguments)
{
  r = pAppImpl->Construct(pArguments);
  SysTryCatch(NID_APP, !IsFailed(r), r = E_SYSTEM, E_SYSTEM, "[E_SYSTEM] %s.", GetErrorMessage(r));
CATCH:
  delete pServiceApp;

  return r;
}

#define SysTryCatch(NID, condition, expr, r, ...) \
  do \
  { \
    if (unlikely(!(condition))) { \
      SysLogException(NID, r, __VA_ARGS__); \
      expr; \
      goto CATCH; \
  } \
} while (0);


{case-example-two}

_INFO("main:_terminate:leave\n");

#ifndef _ERR
#define _ERR(fmt, args...) LOGE("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _DBG
#define _DBG(fmt, args...) LOGD("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _INFO
#define _INFO(fmt, args...) LOGI("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef LOGI
#define LOGI(...) ((void)LOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOGE
#define LOGE(...) ((void)LOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOG
#define LOG(priority, tag, ...) \
  print_log(D##priority, tag, __VA_ARGS__)
#endif

#define print_log(prio, tag, fmt...) \
  __dlog_print(LOG_ID_MAIN, prio, tag, fmt)

int __dlog_vprint(log_id_t log_id, int prio, const char *tag, const char *fmt, va_list ap)
{
  char buf[LOG_BUF_SIZE];

  vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);

  return write_to_log(log_id, prio, tag, buf);
}

int __dlog_print(log_id_t log_id, int prio, const char *tag, const char *fmt, ...)
{
  va_list ap;
  char buf[LOG_BUF_SIZE];

  va_start(ap, fmt);
  vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
  va_end(ap);

  return write_to_log(log_id, prio, tag, buf);
}

static int __write_to_log_kernel(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
	ssize_t ret;
	int log_fd;
	struct iovec vec[3];

	if( log_id < LOG_ID_MAX )
		log_fd = log_fds[log_id];
	else
		return -1; // for TC

	if (!tag)
		  tag = "";

	vec[0].iov_base	= (unsigned char *) &prio;
	vec[0].iov_len	= 1;
	vec[1].iov_base	= (void *) tag;
	vec[1].iov_len	= strlen(tag) + 1;
	vec[2].iov_base	= (void *) msg;
	vec[2].iov_len	= strlen(msg) + 1;

   // *cxx-syscall*
	ret = writev(log_fd, vec, 3);

	return ret;
}

static int __dlog_init(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
#ifdef HAVE_PTHREADS
  pthread_mutex_lock(&log_init_lock);
#endif
  // get filtering info

  // open device
  if( write_to_log == __dlog_init)
  {
    log_fds[LOG_ID_MAIN] = open("/dev/"LOG_MAIN, O_WRONLY);
    log_fds[LOG_ID_RADIO] = open("/dev/"LOG_RADIO, O_WRONLY);
    log_fds[LOG_ID_SYSTEM] = open("/dev/"LOG_SYSTEM, O_WRONLY);

    if( log_fds[LOG_ID_MAIN] < 0 || log_fds[LOG_ID_RADIO] < 0 )
    {
      fprintf(stderr, "open log dev is failed\n");
      write_to_log = __write_to_log_null;
    }
    else
      write_to_log = __write_to_log_kernel;

    if( log_fds[LOG_ID_SYSTEM] < 0 )
    {
      log_fds[LOG_ID_SYSTEM] = log_fds[LOG_ID_MAIN];
    }
  }
#ifdef HAVE_PTHREADS
  pthread_mutex_unlock(&log_init_lock);
#endif
  return write_to_log(log_id, prio, tag, msg);
}


*cxx-vaarg-issue* *cxx-printf-issue* why-ellipses-dangerous
http://www.learncpp.com/cpp-tutorial/714-ellipses-and-why-to-avoid-them/

Two points:

o no type checks on calling parameters

o no checks on the number of calling parameters

#include <cstdarg> // needed to use ellipses

// The ellipses must be the last parameter
double FindAverage(int nCount, ...)
{
  long lSum = 0;

  // We access the ellipses through a va_list, so let's declare one
  va_list list;

  // We initialize the va_list using va_start. The first parameter is
  // the list to initialize. The second parameter is the last non-ellipse
  // parameter.
  va_start(list, nCount);

  // Loop nCount times
  for (int nArg=0; nArg < nCount; nArg++)
    // We use va_arg to get parameters out of our ellipses
    // The first parameter is the va_list we're using
    // The second parameter is the type of the parameter
    lSum += va_arg(list, int);

  // Cleanup the va_list when we're done.
  va_end(list);

  return static_cast<double>(lSum) / nCount;
}
 
int main()
{
  cout << FindAverage(5, 1, 2, 3, 4, 5) << endl;
  cout << FindAverage(6, 1, 2, 3, 4, 5, 6) << endl;
}

Why ellipses are dangerous

Ellipses offer the programmer a lot of flexibility to implement functions that
can take a variable number of parameters. However, this flexibility comes with
some very dangerous downsides.

With regular function parameters, the compiler uses type checking to ensure
the types of the function arguments match the types of the function parameters
(or can be implicitly converted so they match). This helps ensure you don't
pass a function an integer when it was expecting a string, or vice versa.
However, note that ellipses parameters have no type declarations. When using
ellipses, the compiler completely suspends type checking for ellipses
parameters. This means it is possible to send arguments of any type to the
ellipses! However, the downside is that the compiler will no longer be able to
warn you if you call the function with ellipses arguments that do not make
sense. When using the ellipses, it is completely up to the caller to ensure
the function is called with ellipses arguments that the function can handle.
Obviously that leaves quite a bit of room for error (especially if the caller
    wasn't the one who wrote the function).

Lets look at an example of a mistake that is pretty subtle:
	
cout << FindAverage(6, 1.0, 2, 3, 4, 5, 6) << endl;

Although this may look harmless enough at first glance, see that the second
argument (the first ellipse argument) is a double instead of an integer. This
compiles fine, and produces a somewhat surprising result:

1.78782e+008

which is a REALLY big number. How did this happen?

As you have learned in previous lessons, a computer stores all data as a
sequence of bits. A variable's type tells the computer how to translate that
sequence of bits into a meaningful value.  However, you just learned that the
ellipses throw away the variable's type! Consequently, the only way to get a
meaningful value back from the ellipses is to manually tell va_arg() what the
expected type of the next parameter is. This is what the second parameter of
va_arg() does. If the actual parameter type doesn't match the expected
parameter type, bad things will usually happen.

In the above FindAverage program, we told va_arg() that our variables are all
expected to have a type of int. Consequently, each call to va_arg() will
return the next sequence of bits translated as an integer.

In this case, the problem is that the double we passed in as the first ellipse
argument is 8 bytes, whereas va_arg(list, int) will only return 4 bytes of
data with each call. Consequently, the first call to va_arg will only read the
first 4 types of the double (producing a garbage result), and the second call
to va_arg will read the second 4 bytes of the double (producing another
    garbage result).  Thus, our overall result is garbage.

Because type checking is suspended, the compiler won't even complain if we do
something completely ridiculous, like this:
	
int nValue = 7; cout << FindAverage(6, 1.0, 2, "Hello, world!", 'G', &nValue,
    &FindAverage) << endl;

Believe it or not, this actually compiles just fine, and produces the
following result on the author's machine:

1.79766e+008

This result epitomizes the phrase, "Garbage in, garbage out" which is a
popular computer science phrase used primarily to call attention to the fact
that computers, unlike humans, will unquestioningly process the most
nonsensical of input data and produce nonsensical output (wikipedia).

So, in summary, type checking on the parameters is suspended, and we have to
trust the caller to pass in the right type of parameters. If they don't, the
compiler won't complain; our program will just produce garbage (or maybe
    crash).

<second-problem>
As if that wasn't dangerous enough, we run into a second potential problem.
Not only do the ellipses throw away the type of the parameters, it also throws
away the number of parameters in the ellipses!  This means we have to devise
our own solution for keeping track of the number of parameters passed into the
ellipses. Typically, this is done in one of two ways:

o One of the fixed parameters is used as a parameter count (this is the
    solution we use in the FindAverage example above)

o The ellipse parameters are processed until a sentinel value is reached. A
sentinel is a special value that is used to terminate a loop when it is
encountered. For example, we could pick a sentinel value of 0, and continually
process ellipse parameters until we find a 0 (which should be the last value).
Sentinel values only work well if you can find a sentinel value that is not a
legal data value. 

However, even here we run into trouble. For example, consider the following call:

For example:

cout << FindAverage(6, 1, 2, 3, 4, 5) << endl;

On the authors machine at the time of writing, this produced the result:

699773

What happened? We told FindAverage() we were going to give it 6 values, but we
only gave it 5.  Consequently, the first five values that va_arg() returns
were the ones we passed in. The 6th value it returns was a garbage value
somewhere in the stack. Consequently, we got a garbage answer.

When using a sentinel value, if the caller forgets to include the sentinel,
     the loop will run continuously until it runs into garbage that matches
     the sentinel (or crashes).

Recommendations for safer use of ellipses

First, if possible, do not use ellipses at all! Oftentimes, other reasonable
solutions are available, even if they require slightly more work. For example,
          in our FindAverage() program, we could have passed in a dynamically
          sized array of integers instead. This would have provided both
          strong type checking (to make sure the caller doesn't try to do
              something nonsensical) while preserving the ability to pass a
          variable number of integers to be averaged.

Second, if you do use ellipses, do not mix expected argument types within your
ellipses if possible.  Doing so vastly increases the possibility of the caller
inadvertently passing in data of the wrong type and va_arg() producing a
garbage result.

Third, using a count parameter as part of the argument list is generally safer
than using a sentinel as an ellipses parameter. This forces the user to pick
an appropriate value for the count parameter, which ensures the ellipses loop
will terminate after a reasonable number of iterations even if it produces a
garbage value.


={============================================================================
*kt_dev_cxx_0000* cxx-bitset

CXXSLR-12.5 Bitsets

The bitset is a class template and is defined in bitset header. Like array
class, has a 'fixed' size. This is a exmple of a `non-type template parameter`
and this is then considered part of the type.

// bool vector < bitset and bit array < bool array
//
// note:
// sizeof(vector<bool>) is valid? seems not

TEST(Bit, SizeConsideration)
{
  const int size{1000};

  vector<bool> coll_bool_vector(size, 1);
  bitset<size> coll_bitset(1U);
  int coll_bit_array[size/32+1];
  bool coll_bool_array[size];

  EXPECT_THAT(coll_bool_vector.size(), size);
#if __GNUC__ && __x86_64__
  EXPECT_THAT(sizeof(coll_bool_vector), 72);   // 64 bits
#else
  EXPECT_THAT(sizeof(coll_bool_vector), 1);   // 32 bits, need to update
#endif

  EXPECT_THAT(coll_bitset.size(), size);
#if __GNUC__ && __x86_64__
  EXPECT_THAT(sizeof(coll_bitset), 128);     // 64 bits
#else
  EXPECT_THAT(sizeof(coll_bitset), 1);     // 32 bits
#endif

  // 1000/32 = 31, 31+1 = 32, 32*4 = 128
  EXPECT_THAT(sizeof(coll_bit_array), 128);

  EXPECT_THAT(sizeof(coll_bool_array), size);
}


{cxx-bitset-ctors}

bitset<n> b;   
b has n bits; each bit is 0.

bitset<n> b(u);   
b is a copy of the n low-order bits of unsigned long long(ULL) value u.

<init-from-unsigned>
If the size of bitset > the number of bits in ULL, 
   the remaining high-order are set to 0.

If the size of bitset < the number of bits in ULL, 
   the only low-order bits are used. 

<init-from-string>
bitset<n> b(s, pos, m);
'b' is a copy of the 'm' characters from the 'string' starting at position
'pos'. s may contain only 0 and 1 and if contains any other characters, throws
invalid_argument.

The characters with the lowest indices in the string correspond to the
high-order bits and vice versa.

bitset<n> b(cp, pos, m);
same as the above but copies from the character array to which cp points.

namespace cxx_code
{
  // usr/include/c++/4.9/bitset/

  template<size_t _Nb>
    class bitset
    : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>
    {

      /// Initial bits bitwise-copied from a single word (others set to zero).
#if __cplusplus >= 201103L
      constexpr bitset(unsigned long long __val) noexcept
        : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
#else
      bitset(unsigned long __val)
        : _Base(__val)
      { _M_do_sanitize(); }
#endif

    };

} // namespace

TEST(Bit, BitSetCtor)
{
  // *cxx-error*
  // {
  //   int value = 1024;
  //
  //   // warning: narrowing conversion of ‘value’ from ‘int’ to ‘long long unsigned int’ inside { } [-Wnarrowing]
  //   bitset<32> bitsetx{value};
  //   EXPECT_EQ(bitsetx.to_string(), "00000000000000000000010000000000");
  // }

  // *cxx-template-non-type-parameters*
  {
    unsigned int value = 1024;
    bitset<32> coll{value};
    EXPECT_EQ(coll.to_string(), "00000000000000000000010000000000");
  }

  // note: can use variable to set size of bitset.
  {
    const int x = 40;
    bitset<x> coll(1U);
    EXPECT_THAT(coll.size(), 40);
  }
}


{cxx-bitset-operations}
<about-the-state-of-the-entire-bitset>
b.any();       is any bit in b on?
// Do not use is?? style although returns a bool.

b.all();       are all the bits on?
b.none();      are no bits on?
b.count();     number of bits that are on.
b.size();      return the number of bits in b.

<change-the-bitset>
b.test(pos);   return true if bit at position is on.
b.set(pos, v); set the bit at pos to the bool value v.
b.set();       set all bits.
b.reset(pos);  turn off the bit at pos.
b.reset();     turn off all bits.
b.flip(pos);   change the state of the bit at pos.
b.flip();      flip all bits.

<subsctipt>
When read, that is const version, return a bool true if it's on. When write,
     which is non-const return special type that let us change bit at pos.

bool ret = b[pos];
b[31] = 0;
b[0].flip();

<retrive-the-value>
These return a value that holds the same bit pattern. Can use ONLY IF the size
of the bitset is less than or equal to the corresponding size; UL or ULL.
Otherwise, throw overflow_error exception.

b.to_ulong();
b.to_ullong();

<io-operations>
This read into a temp string and read until it has read as many as the size of
bitset.

os << b;
is >> b;


<ex>

TEST(Bit, BitSet)
{
  {
    bitset<32> bitvec(1U);
    EXPECT_EQ(bitvec.to_string(), "00000000000000000000000000000001");

    EXPECT_EQ(bitvec.any(), true);
    EXPECT_EQ(bitvec.none(), false);
    EXPECT_EQ(bitvec.all(), false);
    EXPECT_EQ(bitvec.count(), 1);
    EXPECT_EQ(bitvec.size(), 32);

    bitvec.flip();
    EXPECT_EQ(bitvec.count(), 31);
    bitvec.reset();
    EXPECT_EQ(bitvec.count(), 0);
    bitvec.set();
    EXPECT_EQ(bitvec.count(), 32);

    bitset<16> bitvec2("01011001011");
    EXPECT_EQ(bitvec2.to_string(), "0000001011001011");
  }

  // see the use of bitset and bitset only supports fixed size.  
  //
  // How can use bitset with dynamic size since the size is constant expression?
  // Options are:
  // 
  // o. vector<bool>
  // o. boost has a dynamic_bitset you can use.

  {
    unsigned short short11 = 1024;
    bitset<16> bitset11{short11};
    EXPECT_EQ(bitset11.to_string(), "0000010000000000");

    unsigned short short12 = short11 >> 1;  // 512
    bitset<16> bitset12{short12};
    EXPECT_EQ(bitset12.to_string(), "0000001000000000");

    unsigned short short13 = short11 >> 10;  // 1
    bitset<16> bitset13{short13};
    EXPECT_EQ(bitset13.to_string(), "0000000000000001");

    unsigned short short14 = short11 >> 11;  // 0
    bitset<16> bitset14{short14};
    EXPECT_EQ(bitset14.to_string(), "0000000000000000");
  }
}


// Programming Pearl, C 01, Q 02
// How would you implement bit vectors using bitwise logical operations?
//
// C and old C++ programs usually use type long for arrays of bits and
// manipulate them with the bit operators, such as &, |, and ~.

namespace bit_vectors 
{
  const unsigned int BITSPERWORD = 32;
  const unsigned int SHIFT = 5;
  const unsigned int MASK = 0x1F;
  const unsigned int SIZE = 60;

  // bit vector to represent a array of bits. Why +1? Since 0-31 bits falls to
  // array[0] and 32-63 falls to array[1], and so on. SIZE is num of bits to
  // represent and BITSPERWORD is num of bits of a word(int). So there should be
  // one array at least for 0-31 bits. 
  
  int a[1 + SIZE/BITSPERWORD];

  void set_bit(int pos)
  {
    // MASK
    // MASK is 11111(31) to convert pos into [31-0] bits. By &, make only [31-0] 
    // bits valid and not others and effectively pos - 31 for values 
    // which are > 32. that is:
    //
    // 32 -> 0
    // 33 -> 1
    // ..
    //
    // [pos >> SHIFT]
    // pos is int and right shift on int may cause problem? Not in [] since it
    // is unsigned.
    //
    // Here, ">> 5" menas to devide 2^5, 32 which is num of bits of a word. so
    // find array index that pos falls on and this matches up 1 << (pos & MASK)

    a[pos >> SHIFT] |= ( 1 << (pos & MASK));
  }

  void clear_bit(int pos)
  {
    a[pos >> SHIFT] &= ~( 1 << (pos & MASK));
  }

  bool test_bit(int pos)
  {
    return (a[pos >> SHIFT] & ( 1 << (pos & MASK))) ? true : false;
  }
} // namespace

TEST(Bit, BitVectors)
{
  using namespace bit_vectors;

  auto array_size = sizeof(a)/sizeof(a[0]);

  set_bit(35);
  set_bit(45);
  EXPECT_EQ(test_bit(45), true);

  // 45        35
  // 10000000001000 | 0
  //
  // for (int i = 0; i < (int)array_size; ++i)
  // {
  //   cout << ":" << hex << (a[i]);
  // }
  // cout << endl;

  clear_bit(45);
  EXPECT_EQ(test_bit(35), true);
  EXPECT_EQ(test_bit(45), false);

  // 35
  // 1000 | 0
  
  // for (int i = 0; i < (int)array_size; ++i)
  // {
  //   cout << ":" << hex << (a[i]);
  // }
  // cout << endl;
}


<cxx-alignment>

// general platform alignment. not DMA specific
#define SYSTEM_ALIGNMENT (8)

// check if an address is aligned to the given alignment boundry, 
// note: alignment boundry must be a power of two

#define IS_ALIGNED(addr,alignb) (((((uint32_t)(addr))) & (((unsigned)alignb)-1)) == 0)

// return true so aligned
if (IS_ALIGNED(size, SYSTEM_ALIGNMENT)) 
{
  *p_aligned_size = size;
}
// return false so not aligned
else 
{
  *p_aligned_size = ((size / SYSTEM_ALIGNMENT) + 1) * SYSTEM_ALIGNMENT;
}


Why 'alignment byte -1'? 7(111) in this case. Use the fact that 8 bytes
aligned address always has `xxx000` and AND with `0111` always yields 0.

For 4 bytes, use `011`.

dec   bin
0     0000      & 0111 = 0  // ALIGNED
1     0001      & 0111 = !0
2     0010      & 0111 = !0
3     0011      & 0111 = !0
----------
4     0100      & 0111 = !0 
5     0101      & 0111 = !0
6     0110      & 0111 = !0
7     0111      & 0111 = !0
----------
8     1000      & 0111 = 0  // ALIGNED
9   0 1001
10  0 1010
11  0 1011
----------
12  0 1100
13  0 1101
14  0 1110
15  0 1111
----------
16  1 0000
32 10 0000


<cxx-align>
As with cxx-bitset, use 3(b11) to clear off these two bits which result in 4
bytes address alignments

// Make a value or an address multiple of __DIAG_ALIGNMENT

#define __DIAG_ALIGNMENT	(4U)
#define DIAG_CMN_ALIGN(x)	(((x) + (__DIAG_ALIGNMENT-1)) &~ (__DIAG_ALIGNMENT-1))

/* Compute total len of message which goes over IPC */
total_len = (uint32_t)messageLen + (uint32_t)DIAG_CMN_ALIGN(client_name_len) + (uint32_t)DIAG_IPC_MSG_HEADER_SIZE;

// (x+3) & ~3

0     0000      3 , 0011 & 1100 = 0
1     0001      4 , 0100 & 1100 = 4
2     0010      5 , 0101 & 1100 = 4
3     0011      6 , 0110 & 1100 = 4
----------
4     0100      7 , 0111 & 1100 = 4
5     0101      8 , 1000 & 1100 = 8
6     0110      9 , 1001 & 1100 = 8
7     0111      10, 1010 & 1100 = 8


={============================================================================
*kt_dev_cxx_0000* cxx-cast cpp-pointer-handle

Use a pointer variable to hold handle.

#include <iostream>

using namespace std;

typedef void* HANDLE;

int _gval = 2;

int main()
{
  cout << "{ main == " << std::endl;

  HANDLE x = (HANDLE) _gval;

  std::cout << x << std::endl;

  cout << "} main == " << std::endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-issue-incremental-build

2014.08.

Problem: Found that the old code was used in the long debugging sesseion and
made me wonder why it is still called since moved to new code already? Found
that the state was the mix of new and old code. Quite difficult to debug and to
find out what's happened. Limiation of incremental build or make system?

Why: The problem code is

CPort::CPort()
{
#ifdef FS_SUPPORTED
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CFs));
  MHEGDebugDebug(eMPORT, "CFs is created");
#else
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CDsm));
  MHEGDebugDebug(eMPORT, "CDsm is created");
#endif
...
}

What will happen when use incremental build after removing this #define? This
file was not changed so not compiled in the build. So other new codes were
compiled without this def and this old code compiled with this def. Therefore,
         had CFs object while believeing CDsm object.


={============================================================================
*kt_dev_cxx_0000* cxx-volatile

This is non-portable feature. For values that is controlled by processes
outside the direct control of the program and might be changed in ways outside
the control of the program.

It's a `directive` to the compiler telling that is shoud not perform
'optimisations' on such objects.

static volatile int T=10;

static storage qualifier gives T static storage duration (C++11 §3.7) and
  internal linkage, while volatile still governs the optimization and
  reordering.


={============================================================================
*kt_dev_cxx_0000* cxx-stream cxx-stdio

{redirection}
When shell runs a program, three files are open, with file descriotors 0, 1,
2, called standard input, output, and error. For redirectins, shell changes
default assignment for 0,1,2 to the named files. All done by shell, but not by
a program.

prog <infile
otherprog | prog
prog >outfile
prog | otherprog


{file-io}
library level                                system level
FILE* fopen( char *name, char *mode);        open
int getc( FILE* fp );
int putc( int c, FILE *fp );

#define getchar()    getc(stdin)
#define putchar(c)   putc((c), stdout)

FILE* stdin       stdout, strerr
      keyboard    screen

Every program has these FILE pointers opened automatically.

<example> simple cat program
#include <stdio.h>
#include <stdlib.h>

void filecopy( FILE *ifp, FILE *ofp )
{
  int c;

  while((c = getc(ifp)) != EOF )
    putc( c, ofp );
}

// cat: concatenate files
main( int argc, char *argv[] )
{
  FILE* fp;

  char *prog = argv[0];

  // no args; copy standard input
  if( argc == 1 )
    filecopy( stdin, stdout );
  else
    while(--argc > 0)
      if((fp = fopen( *++argv, "r" )) == NULL )
      {
        fprintf( stderr, "%s: can't open %s\n", prog, *argv );
        exit(1);
      }
      else
      {
        filecopy(fp, stdout);
        fclose(fp);
      }

  // check stream status
  if( ferror(stdout) )
  {
    fprintf( stderr, "%s: error writing stdout\n", prog );
    exit(2);
  }

  exit(0);
}


<ex>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char **argv)
{
    int count = 0;
    char filename[256] = {0};
    FILE *fp;

    if (argc < 2)
    {
        fprintf(stderr, "specify num of files to run...\n");
        exit(EXIT_FAILURE);
    }

    // count  = atoi(argv[1]);
    count  = 20;

    fprintf(stderr, "create, open but not close for %d...\n", count);

    for (unsigned int i = 0; i < count; ++i)
    {
        sprintf(filename, "./k_%d", i );

        fprintf(stderr, "opening %d, %s...\n", i, filename);
        if ((fp = fopen( filename, "w+")) == NULL)
        {
            fprintf(stderr, "fail to open %d, %s,...\n", i, filename);
            perror("fopen error");
            exit(EXIT_FAILURE);
        }
    }

    sleep(1000);

    exit(EXIT_SUCCESS);
}


<why-stderr>
Output written on stderr normally appears on the screen even if the standard output is redirected.

<freopen>
The freopen in stdio.h enables us to bind a file to stdin so can have < redirection effect.

The freopen() function opens the file whose name is the string pointed to by path and associates the
stream pointed to by stream with it. The original stream (if it exists) is closed. The mode argument
is used just as in the fopen() function. The primary use of the freopen() function is to change the
file associated with a standard text stream (stderr, stdin, or stdout).

freopen("input.txt","r",stdin);     // redirects standard input
freopen("output.txt","w",stdout);   // redirects standard output
int x;
cin>>x;           // reads from input.txt
cout<<x<<endl;    // writes to output.txt

<example> compare with stringstream example
#include <iostream>
#include <string>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  StockLine sline;

  freopen("input.txt", "r", stdin);

  while(!feof(stdin))
  {
    cin >> sline.name;
    cin >> sline.time;
    cin >> sline.volume;
    cin >> sline.high;
    cin >> sline.low;

    cout << "{ " 
      << sline.name << ", "
      << sline.time << ", "
      << sline.volume << ", "
      << showpoint 
      << sline.high << ", "
      << sline.low << " }" << endl;
  }
}

// input file
VOD.L 1 100 184.0 183.7
ITV.L 4 45 184.55 183.7

// <Q> Why three lines?
{ VOD.L, 1, 100, 184.000, 183.700 }
{ ITV.L, 4, 45, 184.550, 183.700 }
{ ITV.L, 4, 45, 184.550, 183.700 }

The fixed version:

#include <iostream>
#include <string>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  StockLine sline;

  freopen("input.txt", "r", stdin);

  while(!feof(stdin))
  {
    cin >> sline.name;
    cin >> sline.time;
    cin >> sline.volume;
    cin >> sline.high;
    cin >> sline.low;

    if(!feof(stdin))                      // note: difference
    {
      cout << "{ " 
        << sline.name << ", "
        << sline.time << ", "
        << sline.volume << ", "
        << showpoint 
        << sline.high << ", "
        << sline.low << " }" << endl;
    }
  }
}


{readline}
<getline> from ansic, section 1.9, p29.
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#define MAXLINE 1000 // maximum input line size

// <one> notice that it includes '\n'
int mygetline(char line[], int maxlen )
{
  int c, i;

  // <Q1> also notice that ' < maxlen-1' leave one space for a null
  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  // <Q2>
  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
  return i;
}

// <two>
int mygetline(char line[], int maxlen )
{
  int c, i;

  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF); i++)
    line[i] = c;

  line[i] = '\0';
  return i;
}

// copy 'from' into 'to'; assume 'to' is big enough
void copy( char to[], char from[] )
{
  while( *to++ = *from++ )
    ;
}

// print the longest line from stdin
int main()
{
  int curlen;              // current line length
  int maxlen;              // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  maxlen = 0;
  while(( curlen = mygetline( line, MAXLINE )) > 0 )
  {
    printf("while: %s", line);

    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


<Q1> What's the difference between one and two?

one: "...\n"

kt@kt-ub-vb:~/work$ ./a.out 
this is one.
while: this is one.
this is two line.
while: this is two line.
this is three line.
while: this is three line.
this is three line.


two: "...\n...\n...\n" 

kt@kt-ub-vb:~/work$ ./a.out 
this is one.
this is two line.
this is three line.
while: this is one.     // pressed C-d
this is two line.
this is three line.

this is one.            // pressed C-d
this is two line.
this is three line.

Notice that use of 'return' size in this call since starts from 0.

0  1  2  3  4  5  6  (return)
h  e  l  l  o  \n \0
1  2  3  4  5  6  7

<Q2> Does it cause accessing out of array index when \n falls in the last of read loop?
When array size is 10, then 0-9 is valid index. The first loop is for [0,8], and [9] for '\n', and
[10] for '\0'?

{
  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
}

NO since when 8th reads '\n' and loop stops so no increase. [8] = '\n' and [9] = '\0'. That is the
first loop is [0,8). The [size-1] is reserved for null to make it a string.

read idx: 0 1 2 3 4 5 6 7 8   9
input   : a a a a a a a a '\n'

If use standard liberay to get line, can use:

char *fgets( char *line, int maxline, FILE *fp);
int fputs( char *line, FILE *fp);

However, getline is more useful since returns the line length.

int getline( char *line, int max )
{
  if( fgets( line, max, stdin ) == NULL )
    return 0;
  else
    return strlen(line);
}


<stdio-getline>
ssize_t getline(char **lineptr, size_t *n, FILE *stream);

int main()
{
  int curlen; // current line length
  int maxlen; // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  char* pline = line;
  size_t max = MAXLINE;

  maxlen = 0;
  while(( curlen = getline( &pline, &max, stdin )) > 0 )
  {
    printf("while: %s", line);

    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


={============================================================================
*kt_dev_cxx_0000* cxx-stream cxx-file

Figure 15.1. Class Hierarchy of the Fundamental Stream Classes

The classes in this class hierarchy play the following roles:

o The base class ios_base defines the properties of all stream classes
  independent of the char- acter type and the corresponding character traits.
  Most of this class consists of components and functions for state and format
  flags.

o The class template basic_ios<> is derived from ios_base and defines the
  common prop- erties of all stream classes that depend on the character types
  and the corresponding character traits. These properties include the
  definition of the buffer used by the stream. The buffer is an object of a
  class derived from the template class basic_streambuf<> with the
  corresponding template instantiation. It performs the actual reading and/or
  writing.

o The class templates basic_istream<> and basic_ostream<> derive virtually
  from basic_ios<> and define objects that can be used for reading or writing,
  respectively. Like basic_ios<>, these classes are templates that are
    parametrized with a character type and its traits. When
    internationalization does not matter, the corresponding instantiations for
    the char- acter type char — istream and ostream — are used.

o The class template basic_iostream<> derives from both basic_istream<> and
  basic_ostream<>. This class template defines objects that can be used for
  both reading and writing.

o The class template basic_streambuf<> is `the heart` of the IOStream library.
  This class defines the interface to all representations that can be written
  to or read from by streams and is used by the other stream classes to
  perform the reading and writing of characters. For access to some external
  representation, classes are derived from basic_streambuf<>.


namespace std
{
  // /home/keitee/works/7/iosfwd

  template<typename _CharT, typename _Traits = char_traits<_CharT>> 
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT>> 
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>> 
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>> 
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>> 
    class basic_iostream;


  /// Base class for @c char streams.
  typedef basic_ios<char> 		ios;

  /// Base class for @c char buffers.
  typedef basic_streambuf<char> 	streambuf;

  /// Base class for @c char input streams.
  typedef basic_istream<char> 		istream;

  /// Base class for @c char output streams.
  typedef basic_ostream<char> 		ostream;

  /// Base class for @c char mixed input and output streams.
  typedef basic_iostream<char> 		iostream;
}


*cxx-stream-preformance*

<iostream> contains declarations of the global stream objects, such as cin and cout.

For the application programmer, it should be sufficient to include <iosfwd> for
the declaration of the stream classes and <istream> or <ostream> when using the
input or output functions, respectively. The header <iostream> should be
included only if the standard stream objects are to be used.


<cxx-getline>

CXXSLR-13.2.10 Input/Output Operators

std::getline() comes from `string class` but do not need to qualify std:: due
to argument dependent lookup.

note that there is ifstream::getline() ad std::getline() is preferable since
do not need to set size to read and it grows as needed since it uses
std::string.


This function reads all characters, including leading whitespaces, 
`until the line delimiter or end-of-file is reached.` 

The line delimiter is extracted `but not appended`; not include a new line
character. so have to add '\n' when output it back to a file.

while (getline(std::cin, s)) {       // for each line from cin
...
}


Note also that since C++11, getline() is overloaded for both lvalue and rvalue
stream references, which allows using temporary string streams. See Section
15.10, page 802, for details about string streams.

void process (const std::string& filecontents)
{
  // process first line of passed string:
  std::string firstLine;
  std::getline(std::stringstream(filecontents), // OK since C++11
      firstLine);
  ...
}

namespace cxx-code
{
  // /usr/include/c++/4.9.2/bits/basic_string.h
  /**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @param __delim  Character marking end of line.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until @a __delim is
   *  found, the end of the stream is encountered, or `str.max_size()`
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  @a __delim is encountered, it is extracted but not stored into
   *  @a __str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);

  /**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from is into @a __str until &apos;\n&apos; is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  end of line is encountered, it is extracted but not stored into
   *  @a __str.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
	    basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }
}


*cxx-stream-manipulator*

*cxx-endl*
endl    basic_ostream Inserts a newline character into the buffer and
        `flushes the output buffer to its device`

ends    basic_ostream Inserts a (terminating) null character into the buffer

flush   basic_ostream Flushes the output buffer to its device

ws      basic_istream Reads and ignores whitespaces


<ex>
Often, the stream you are writing to does not belong to you, especially if you
are writing a general-purpose library or API. For example, if you write a
fancy logging function that takes an output stream and a string, modifies the
string, sets the format flags, and writes it to the stream, you have
potentially unwanted side-effects.  After client code calls your logging
function, its stream has potentially had its format flags rearranged. The
solution is to copy the old ones and restore them when you’re done.

void logError(ostream &out, const string &s)
{
  string tmp(s);
  tmp.insert(0, "ERROR: ");

  // save flags
  ios_base::fmtflags flgs = out.setf(ios_base::left);

  out.width(72);
  out << tmp << '\n';

  // reset to original
  out.flags(flgs);
}


<ex>
I set the width inside the loop while I set the right flag prior to the loop. I
had to do this because the width resets to zero after each write to the stream.
Format flags are not reset after writes, so I only had to initialize them once
and be done with it.

{
  size_t width{72};
  string line{};

  output_file.setf(ios_base::right);

  while (input_file)
  {
    output_file.width(width);
    getline(input_file, line);
    output_file << line << '\n';
  }
}


15.7.5 Numeric Base

A group of three flags defines which base is used for I/O of integer values. The
flags are defined in the class ios_base with the corresponding mask

*cxx-stream-hex*
hex
Writes and reads hexadecimal

None
Writes decimal and reads according to the leading characters of the integral
value


15.7.6 Floating-Point Notation
If ios::fixed is set, floatingpoint values are printed using decimal notation.

setprecision      Set decimal precision (function )

*cxx-round*
In all cases, the remainder is not cut off `but rounded.`

TEST(CxxIO, check_manipulators_float)
{
  double value = 8.809030;
  std::ostringstream os;

  os << std::fixed << std::setprecision(2) << value;

  EXPECT_THAT(os.str(), "8.81");
}


*cxx-stream-file* *cxx-file*

CLR-15.9 Figure 15.2. Class Hierarchy of the File Stream Classes

Compared with the mechanism of C, a major advantage of the file stream classes
for file access is the `automatic management of files.` The files are
automatically opened at construction time and closed at destruction time. This
is possible, of course, through appropriate definitions of corresponding
constructors and destructors.

The ifstream class binds file to stream and then need a call to read data from
stream such as getline(). Further, *cxx-stream-iterator* add iterator features
to a stream. However freopen binds file to stdin and can use cin >> to read
data.

namespace cxx_code
{
  {
    // iosfwd

    typedef basic_ifstream<char>              ifstream;
    typedef basic_ifstream<wchar_t>   wifstream;
  }

  {
    // fstream
    
    // [27.8.1.5] Template class basic_ifstream
    /**
     *  @brief  Controlling input for files.
     *  @ingroup io
     *
     *  @tparam _CharT  Type of character stream.
     *  @tparam _Traits  Traits for character type, defaults to
     *                   char_traits<_CharT>.
     *
     *  This class supports reading from named files, using the inherited
     *  functions from std::basic_istream.  To control the associated
     *  sequence, an instance of std::basic_filebuf is used, which this page
     *  refers to as @c sb.
     */
    template<typename _CharT, typename _Traits>
      class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
      /**
       *  @brief  Create an input file stream.
       *  @param  __s  Null terminated string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::in is automatically included in @a __mode.
       *
       *  Tip:  When using std::string to hold the filename, you must use
       *  .c_str() before passing it to this constructor.
       */
      explicit
        basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
        : __istream_type(), _M_filebuf()
        {
          this->init(&_M_filebuf);
          this->open(__s, __mode);
        }

#if __cplusplus >= 201103L
      /**
       *  @brief  Create an input file stream.
       *  @param  __s  std::string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::in is automatically included in @a __mode.
       */
      explicit
        basic_ifstream(const std::string& __s,
            ios_base::openmode __mode = ios_base::in)
        : __istream_type(), _M_filebuf()
        {
          this->init(&_M_filebuf);
          this->open(__s, __mode);
        }
#endif
    }
  }
} // namespace


*cxx-stream-file-flag*

15.9.3 File Flags

in    Opens for reading (default for ifstream)
out   Opens for writing (default for ofstream)

Table 15.33. Flags for Opening Files
Table 15.34. Meaning of Open Modes in C++


15.9.4 Random Access


{buffered-io} 
In the previous example, uses getline on file stream but when use it with stdin stream, it behaves
differntly. Why? As with FILE, it is buffered.

<example>
#include <iostream>
#include <string>

using namespace std;

int main()
{
  string line;

  while( cin >> line )
    cout << "cout: " << line << endl;

  cout << "end: " << line << endl;
}

$ ./a.out 
this
cout: this
that
cout: that
this is a long line <enter>
cout: this
cout: is
cout: a
cout: long
cout: line
end: line


={============================================================================
*kt_dev_cxx_0000* cxx-stringstream

CLR-15.10 Stream Classes for Strings

stringstream provide a buffer but don’t have an I/O channel. A major use of this
capability is the processing of I/O independent of the actual I/O.


`stringstream` "see(treat) string as a stream so use stream ops; IO ops" and
provide a `buffer` 

  sstream buffer <-> stream

For example, text for output `can be formatted` in a string and then sent to an
output channel sometime `later`. Another use is reading input line by line and
processing each line by using stream operations.


Supports in-memory IO. Use stream operation such as read(>>) and write(<<) but
they are really to read from or write to a string since use it as if the
string were IO stream. 

Figure 15.3. Class Hierarchy of the String Stream Classes

The following stream classes - corresponding to the stream classes for files -
are defined for strings:

  o The class template basic_istringstream<> with the specializations
    istringstream and wistringstream for reading from strings 
    ("input string stream")

  o The class template basic_ostringstream<> with the specializations
    ostringstream and wostringstream for writing to strings 
    ("output string stream")

  o The class template basic_stringstream<> with the specializations
    stringstream and wstringstream `for reading from and writing to strings`

  o The class template basic_stringbuf<> with the specializations stringbuf
    and wstringbuf, used by the other string stream classes to perform the
    reading and writing of characters

stringstream has input and output as well so use it

typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;


<cxx-stringstream-ops>

#include <sstream>

sstream strm(string);   
strm is an sstream that holds a copy of the string s.

std::basic_string<CharT,Traits,Allocator> str() const;
strm.str();
`return a copy of cxx-string` that strm holds. Returns the buffer as a string

strm.str(string);       
copies the string s into strm. Sets the contents of the buffer to string and
  remove the current contents from the stream. Can use the function str() to
  `assign new contents to the buffer`

*cxx-stringstream-clear*
strm.str(""); 
clears sstream buffer

// note: strm.clear()? no.

os = std::ostringstream("");


std::ios::clear
void clear (iostate state = goodbit);

Set error state flags
Sets a new value for the stream's internal error state flags.


<ex>
TEST(StringConverison, check_stringstream)
{
  // note that os, buffer, has all inputs from << and seek() moves writing pos.
  // *cxx-string-convert-to-string*

  // to string
  {
    std::ostringstream os;

    os << "decimal : " << 15 << hex << ", hex : " << 15 << endl;
    EXPECT_EQ(os.str(), "decimal : 15, hex : f\n");

    bitset<15> bit_set(5789);
    os << "float : " << 4.67 << ", bitset : " << bit_set << endl;
    EXPECT_EQ(
      os.str(),
      "decimal : 15, hex : f\nfloat : 4.67, bitset : 001011010011101\n");

    os.seekp(0);
    os << "octal : " << oct << 15;
    EXPECT_EQ(
      os.str(),
      "octal : 1715, hex : f\nfloat : 4.67, bitset : 001011010011101\n");
  }

  // to string in hex
  {
    std::ostringstream os;
    // os << "0x" << hex << 16;
    os << std::hex << 16;
    EXPECT_THAT(os.str(), "10");
  }

  // input integer to hex string
  {
    std::string input{"15056"};
    uint32_t value = std::stoi(input.c_str());

    std::ostringstream os;
    os << hex << value;
    EXPECT_THAT(os.str(), "3ad0");
  }

  // input integer and add some. to string
  {
    std::string input{"15056"};
    uint32_t value = std::stoi(input.c_str());

    std::ostringstream os;
    os << 5000 + value;
    EXPECT_THAT(os.str(), "20056");
  }

  // to string
  {
    std::stringstream ss;
    std::vector<string> string_vector{};

    for (int i = 0; i < 4; ++i)
    {
      ss << "player " << i;
      string_vector.push_back(string(ss.str()));
      ss.str("");
    }

    EXPECT_THAT(string_vector,
                ElementsAre("player 0", "player 1", "player 2", "player 3"));
  }

  // to number
  {
    // The following lines read the integer x with the value 3 and the
    // floating-point f with the value 0.7 from the stringstream:

    int x{};
    float f{};

    istringstream is{"3.7"};

    // or
    // string input{"3.7"};
    // stringstream is(input);
    //
    // or
    // string input{"3.7"};
    // stringstream is;
    // is.str(input);

    is >> x >> f;

    ASSERT_THAT(x, Eq(3));
    ASSERT_THAT(f, FloatEq(0.7));
  }

  // to number
  {
    stringstream is{"1 2 3 4"};
    int value{};
    vector<int> coll{};

    while (is >> value)
      coll.push_back(value);

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4));
  }

  // to number
  {
    stringstream is{"1234"};
    int value{};

    is >> setw(2) >> value;

    // actually was 1234
    // EXPECT_THAT(value, 12);
  }

  // to number
  {
    string coll{"10101"};
    string token = coll.substr(0, 1);
    EXPECT_EQ(stoi(token), 1);
  }

  // to number
  {
    string coll{"10101"};
    stringstream is{coll.substr(0, 1)};
    int value{};
    is >> value;
    EXPECT_EQ(value, 1);
  }

  // to number(hex)
  {
    stringstream is{"fabc"};
    int value{};

    is >> hex >> value;

    EXPECT_THAT(value, 64188);
  }
}


<ex> *cxx-string-convert-to-number*

// file parsing example *cxx-ex-ifstream*
//
// input.txt
//
// VOD.L 1 100 184.0 183.7
// VOD.X 2 100 189.0 183.8
// VOD.L 3 100 185.0 183.9
// VOD.X 4 100 186.0 184.0
// VOD.L 5 100 187.0 183.1

struct StockData
{
    string  name;
    int     time;
    int     volume;
    float   high;
    float   low;
};

// = 03 ======
// { VOD.L, 1, 100, 184.000, 183.700 }
// { VOD.X, 2, 100, 189.000, 183.800 }
// { VOD.L, 3, 100, 185.000, 183.900 }
// { VOD.X, 4, 100, 186.000, 184.000 }
// { VOD.L, 5, 100, 187.000, 183.100 }

void t_sstream_03()
{
    string line{};
    StockData sdata{};

    ifstream ifs("input.txt", std::ifstream::in);

    while (getline(ifs, line))
    {
        istringstream iss(line);

        // *cxx-string-convert-to-number*
        iss >> sdata.name; 
        iss >> sdata.time;
        iss >> sdata.volume;
        iss >> sdata.high;
        iss >> sdata.low;

        cout << "{ " 
            << sdata.name << ", "
            << sdata.time << ", "
            << sdata.volume << ", "
            << showpoint 
            << sdata.high << ", "
            << sdata.low << " }" << endl;
    }

    ifs.close();
}


<ex>
double sciToDub(const string& str) {
  stringstream ss(str);
  double d = 0;
  ss >> d;
  if (ss.fail( )) {
    string s = "Unable to format ";
    s += str;
    s += " as a number!";
    throw (s);
  }
  return (d);
}

// *cxx-string-convert-to-number*
// The following lines read the integer x with the value 3 and the
// floating-point f with the value 0.7 from the string s:

TEST(CxxStringTest, UseInputStringStream)
{
  int x{};
  float f{};
  istringstream is{"3.7"};

  is >> x >> f;
 
  ASSERT_THAT(x, Eq(3));
  ASSERT_THAT(f, FloatEq(0.7));
}


<ex> ostrringstream
ostringstream is useful when need to `build up` our output a little at a time
but do not want to print the output until later.

void PerfCounter::dump()
{
    std::stringstream ss{};
    uint32_t countSnap{1};

    // only when there are two nodes to use
    for (CounterData *pstart = phead; 
            pstart && pstart->pnext; pstart = pstart->pnext)
    {
        ss << "snap: " << countSnap << ": ";
        ss << pstart->name << " -> " << pstart->pnext->name << " took ";

        // time diff in us from current to next
        uint64_t timeDiff = 
            (pstart->pnext->ts.tv_sec*1000000 + pstart->pnext->ts.tv_nsec/1000)-
            (pstart->ts.tv_sec*1000000 + pstart->ts.tv_nsec/1000);

        ss << timeDiff << "us" << std::endl;
        ++countSnap;
    }

    std::cout << ss.str();
}


<ex> cxx-string-convert-to-string-from-object

std::ostream &operator<<(std::ostream &os, const Location &location)
{
    os << "(" << location.latitude() << "," << location.longitude() << ")";
    return os;
}

TEST_F(ALocation, ProvidesPrintableRepresentation) {
   Location location{-32, -105};
   stringstream s;
 
   s << location;
 
   ASSERT_THAT(s.str(), StrEq("(-32,-105)"));
}


={============================================================================
*kt_dev_cpp_0004* cxx-postfix

There are situations where the `value` of increase is different from the
*cxx-side-effect*. `cxx-postfix` differs in value and effect.

WHEN n = 5: 

x = n++;    // x has 5; value is 5 and side-effect is 6.
x = ++n;    // x has 6; value is 6 and side-effect is 6.

When no value is used and use only effect, postfix and postfix are the same:

// when valus is not used
if( c == '\n' )
   nl++;

// when value is used
int val = 5;

fcall( ++val );   // fcall(6);
fcall( val++ );   // fcall(5);


<ex> algo-squeeze

Delete all c from string s. From C prog language, p47. All these are example
where postfix is required.

void squeeze(char s[], int c);

namespace algo_squeeze
{
  // ansic version
  void squeeze1(char s[], int c)
  {
    int i, j;

    for (i = j = 0; s[i] != '\0'; i++)
      if (s[i] != c)
        s[j++] = s[i];

    s[j] = '\0';
  }

  // use one var
  void squeeze2(char s[], int c)
  {
    char *scan;

    for (scan = s; *scan; scan++)
    {
      // if not matches: copy s[current] = s[sacn] and increase s
      if (*scan != c)
        *s++ = *scan;
    }

    *s = *scan;
  }

  void squeeze3(char s[], int c)
  {
    // do not use `run` variable since use s for that
    char *pos = s;

    while (*s)
    {
      if (*s != c)
        *pos++ = *s;

      ++s;
    }

    // set the end
    *pos = '\0';
  }
} // namespace algo_squeeze

TEST(AlgoSqueeze, try_1)
{
  using namespace algo_squeeze;

  {
    char arr[]          = "this is a program to squeeze";
    const char result[] = "this is a program to squz";

    squeeze1(arr, 'e');

    // std::cout << arr << std::endl;

    EXPECT_THAT(strcmp(arr, result), 0);
  }

  {
    char arr[]          = "this is a program to squeeze";
    const char result[] = "this is a program to squz";

    squeeze2(arr, 'e');

    EXPECT_THAT(strcmp(arr, result), 0);
  }

  {
    char arr[]          = "this is a program to squeeze";
    const char result[] = "this is a program to squz";

    squeeze3(arr, 'e');

    EXPECT_THAT(strcmp(arr, result), 0);
  }
}

/*
ansic, exercise 2-4.

Write an alternate version of squeeze(s1,s2) that deletes each character in the
string s1 that matches 'any' character in the string s2.

void squeeze2(char s[], char t[]);

*/

namespace algo_squeeze_2
{
  void squeeze1(char s[], char t[])
  {
    int i, j, k;
    for (k = 0; t[k] != '\0'; k++)
    {
      for (i = j = 0; s[i] != '\0'; i++) // { squeeze1()
        if (s[i] != t[k])
          s[j++] = s[i];
      s[j] = '\0'; // }
    }
  }

  // mine
  void squeeze2(char s[], char t[])
  {
    char *run, *write;

    for (; *t; t++)
    {
      for (write = run = s; *run; run++)
      {
        if (*run != *t)
          *write++ = *run;
      }

      *write = '\0';
    }
  }

  // simple way would be that loops t[] for each char of s[]. O(n2)
  // so if suppose it's ASCII char, may use loopup table and get O(n) but use
  // more space.

  // Cannot use bset[(*t-'a')] since this assumes input is all lower characters.
  // For example, for space char(32) index becomes -65 (32-97) and makes a core.

  void squeeze3(char s[], char t[])
  {
    // assuems ASCII *cxx-vector-bool*
    std::vector<bool> lookup(256);

    // fills up the table
    while (*t)
    {
      lookup[*t] = true;
      ++t;
    }

    char *pos;

    for (pos = s; *s; ++s)
    {
      // not in the lookup, that is, not shown in t[]
      if (lookup[*s] == false)
        *pos++ = *s;
    }

    // since *s shuld be '\0'
    *pos = *s;
  }
} // namespace algo_squeeze_2

TEST(AlgoSqueeze, try_2)
{
  using namespace algo_squeeze_2;

  {
    char arr[]          = "hello world";
    char filter[]       = "ol";
    const char result[] = "he wrd";

    squeeze1(arr, filter);

    // std::cout << arr << std::endl;

    EXPECT_THAT(strcmp(arr, result), 0);
  }

  {
    char arr[]          = "hello world";
    char filter[]       = "ol";
    const char result[] = "he wrd";

    squeeze2(arr, filter);

    EXPECT_THAT(strcmp(arr, result), 0);
  }

  {
    char arr[]          = "hello world";
    char filter[]       = "ol";
    const char result[] = "he wrd";

    squeeze3(arr, filter);

    EXPECT_THAT(strcmp(arr, result), 0);
  }
}


<ex> *ex-any* ansic, exercise 2-5. 
Write the function any(s1,s2), which returns the first location in the string s1
where any character from the string s2 occurs, or -1 if s1 contains no
characters from s2.

note: 
The standard library function strpbrk does the same job but returns a pointer to
the location.

char *strpbrk(const char *s, const char *accept);

// not good since based on the "squeeze" approach which means more work to find
// the first time since key chars can happen any order and did not stop on
// "first" match

int any_mine( char s[], char t[] )
{
  int ret = -1;
  int i;

  // run through t[]
  for(; *t; t++)
  {
    // run through s[]
    for( i = 0; s[i]; i++ )
    {
      // found a match
      if( s[i] == *t )
      {
        // update found index when either it's the first time or found the less
        // than the previous
        if( ret < 0 || i < ret )
        {
          ret = i;
          break;
        }
      }
    }
  }

  return ret;
}


*ex-bitset*
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_5

Here's a much better solution, by Partha Seetala. This solution has a worst-
case time complexity of only O(n + m) which is considerably better.

It works in a very interesting way. He first defines an array with one element
for each possible character in the character set, and then takes the second
string and 'ticks' the array at each position where the second string contains
the character corresponding to that position. It's then a simple matter to loop
through the first string, quitting as soon as he hits a 'ticked' position in the
array.

#include <stdio.h> /* for NULL */

int any(char *s1, char *s2)
{
  // (b) for full ANSIness, #include <limits.h>, make the array unsigned char,
  // cast as required, and specify an array size of UCHAR_MAX(255) + 1.

  char array[256]; 

  int  i;
  if (s1 == NULL) {
    if (s2 == NULL) {
      return(0);
    } else {
      return(-1);
    }
  }

  // (a) by making this char array[256] = {0}; the first loop becomes
  // unnecessary.
  for(i = 0; i < 256; i++) {
    array[i] = 0;
  }

  while(*s2 != '\0') {
    array[*s2] = 1;
    s2++;
  }

  i = 0;
  while(s1[i] != '\0') {
    if (array[s1[i]] == 1) {
      return(i);
    }
    i++;
  }

  // (c) the return statements' (parentheses) are not required.
  return(-1);
}


={============================================================================
*kt_dev_cpp_0004* expr-chain

int v1, v2;
cin >> v1 >> v2;

cout << "Enter numbers:" << endl;

Why work? Because operators returns reference of 'lhs' operand which is `cin`
  and `cout`


={============================================================================
*kt_dev_lang_011* expr-literal

To specify the type of a literal. Primus p40.

{char-and-char-string-literals}

<prefix>    meaning          type
u           unicode 16 char  char16_t
U           unicode 32 char  char32_t
L           wide char        wchar_t
u8          utf-8            char

L'a'
u8"hi!"


{integer-literals}

<suffix>    minimum type
u/U         unsigned
l/L         long
ll/LL       long long

42ULL       // unsigned long long


{floating-literals}

<suffix>    type
f/F         unsigned
l/L         long double

3.14159L    // long double


={============================================================================
*kt_dev_cxx_0004* cxx-pointer cxx-array

A pointer is a 'variable' that contains the address of a variable. In other
words, pointer type variable and variable is a label of address. The type
defines the size of variable. For pointer, defines two things; this is a
pointer and the type that this pointer points to. 

The unary operator*() is the `indirection` or `dereference` operator; when
applied pointer, it accesses the 'object' that pointer points to. The
declaration of the pointer ip is intended as a mnemonic:

int *ip;

It says that the expression '*ip' is an 'int'. *ip is used as an 'ordinary'
int variable. note the implication that a pointer is constrained to point to a
particular kind of object: every pointer points to a specific 'type'. 


<void-pointer> 
There is one exception: a pointer to void is used to hold any 'type' of
pointer but 'cannot' be dereferenced itself.

++*ip;
(*ip)++;

The parentheses are necessary in the second example:

ANSI C explains without them, the expression would increase ip instead of what
it points to, because unary operators like * and ++ associate `right-to-left`.
However, in C++, postfix ++ has higher precedence. The both has the same result.
This effect having a pointer increased used in *ex-strcpy* example. 

Also, any pointer can be cast to void* and back again without loss of
information. See *ex-qsort*


<push-and-pop-idiom>
*p++ = val;    // push val onto stack
val = *--p;    // pop top of stack into val

Here *--p decrements p before fetching the character that p points to since
`right-to-left` applies.


<read-and-write>
variable is a readable lable of address whether or not a pointer, so read or
write to it means to get its content but not the address. 

variable = xxx;   // this is an write operation to a memory.
xxx = variable;   // this is an read operation(fetch) from a memory.


{call-by-value-and-reference}
C passes arguments to function by value.

swap( a, b );

void swap(int x, int y)
{
  int temp;

  temp = x;
  x = y;
  y = temp;
}

swap( &a, &b );

void swap(int *x, int *y)
{
  int temp;

  temp = *x;
  *x = *y;
  *y = temp;
}


{pointer-and-array}
An array is a data structure that is similar to the library vector type but
offers different trade-off. Like vector, array is a container of unnamed object
of a 'single' type. Unlike vector, has 'fixed' size. That run-time advantage
comes at the cost of lost flexibility.

In C++ pointers and arrays are closely interwined. The elements in an array are
objects. When subscript an array, the result is the object at that location in
the array. Array has special property. the compiler automatically substitute
array(name) with a pointer to the first element.

The ansic said the name of array is a 'synonym' for the location of the initial
element.

string name[] = {"one", "two", "three"};
string* p = &name[0];   // same
string* p = name;       // same

This means that operations on array are really operations on pointers.


<cpp-pointer-index> from-ansic, indexing and pointer arithmetic
An array-and-index expression is equivalent to one written as a pointer and
offset. 

The pointer version will in general be 'faster'. There is one difference
between an array name and a pointer that must be kept in mind. A pointer is
variable but array name is 'not' a variable. However when pass an array to a
function call as a argument? This is a variable such as strlen(char *);

a[i] can also be written as *(a+i)

int a[10]; int *pa;

pa = a; pa++;     // okay
a = pa; a++;      // error since array name is not variable

* a[n] has [0, n-1]. So a+n points to the off-the-end.

* q-p+1 means the number of elements from p to q 'inclusive' when q > p and p
  and q are pointers within the array. (inclusive since +1)
  
* q-p is the size when arr[size], p is &arr[0] and q is &arr[`off-the-end`]

* a length of a has +1 than a index. Run loop from [0, n-1] or [1, n]

// index
char array[length];             // 10

[0,9]                           // 10 loops
for( i = 0; i < length; i++ )
   array[i];

[1,10]                          // 10 loops when not need index
while( length-- > 0 )
  *ptr++;


<defining-array>
An array declarator has the form a[d], where a is the name and d is the
dimension. note that the number of elements in an array is 'part' of the array's
'type' so must be known at compile time.  That means the dimension is constant
expression.


<array-subscript>
For library types such as string and vector, subscript type is size_type which
is `unsigned`. So if use negative value, then will be 'converted' to the
unsigned. However, for built-in array, it is not so can have negative subscript.
ansic p100.

int *p = &ia[2];
int j = p[1];
int k = p[-2];


<array-init>
int a3[5] = { 0, 1, 2 };   // { 0, 1, 2, 0, 0 } since value-init the rest
int a4[11] = {};           // { 0,...0 } since value-init all


<difference-between-arr-and-parr> cpp-sizeof cxx-array-begin
int main () {

  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int* parr = new int[100];

  std::vector<int> ivec( std::begin(arr), std::end(arr) );     // 1. okay
  std::vector<int> ivec( std::begin(parr), std::end(parr) );   // 2. error
  std::vector<int> ivec( std::begin(*parr), std::end(*parr) ); // 3. error
  
  return 0;
}

For 2, error: no matching function for call to ‘begin(int*&)’  // typename int*
For 3, error: no matching function for call to ‘begin(int&)’   // typename int

sam01.cpp:14:41: note: candidates are:
/usr/include/c++/4.6/bits/range_access.h:48:5: note: 
  template<class _Container> decltype (__cont.begin()) std::begin(_Container&)
/usr/include/c++/4.6/bits/range_access.h:58:5: note: 
  template<class _Container> decltype (__cont.begin()) std::begin(const _Container&)
/usr/include/c++/4.6/bits/range_access.h:87:5: note: 
  template<class _Tp, unsigned int _Nm> _Tp* std::begin(_Tp (&)[_Nm])
/usr/include/c++/4.6/initializer_list:86:5: note: 
  template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)

Why? std::begin() shall work with array? Array is different from block of
memory. Here are the libary implementation:

/usr/include/c++/4.6/bits/range_access.h:87:5:

/**
 *  @brief  Return an iterator pointing to the first element of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  begin(_Tp (&__arr)[_Nm])    // note see the size
  { return __arr; }

/**
 *  @brief  Return an iterator pointing to one past the last element
 *          of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  end(_Tp (&__arr)[_Nm])
  { return __arr + _Nm; }


* Array is 'sized' data structure and size is known at 'compile' time and can be
  used implicitly.

* Array is different.


char parray[] = "this is sample string";
char *pnew = "this is sample string";

printf("0: %0x 1: %0x \n", &parray, &parray[0] );
printf("0: %0x 1: %0x \n", &pnew, &pnew[0] );

0: bfc09896 1: bfc09896
0: bfc09890 1: 80489c5 


<3> decltype seems return char * for both but typeid are different. Why?
decltype( parray ) x;
decltype( pnew ) x;

tid: A22_c  // parray
tid: Pc     // pnew

Since the special conversion in array do not happen when use decltype. Really?
YES.

decltype(arr) x = 100;

$ ./comp.sh sam01.cpp 
.cpp: In function ‘int main()’:
.cpp:13:21: error: array must be initialised with a brace-enclosed initialiser

decltype(arr) x;
int y = x;

$ ./comp.sh sam01.cpp 
.cpp: In function ‘int main()’:
.cpp:14:11: error: invalid conversion from ‘int*’ to ‘int’ [-fpermissive]


<4> `op-sizeof` 
cout << "size: " << sizeof(arr) << endl;
cout << "size: " << sizeof(parr) << endl;
cout << "size: " << sizeof(*parr) << endl;

size: 40
size: 4
size: 4


<complicated-array-declaration>
int arr[6];

arr     0        5
[ ] -> [ ][ ]...[ ]

Here arr, &arr[0], &arr have the same address and arr type is int(*arr)[6]. This
is similar to function pointer definition. The size is part of type, that is,
   int(&)[10] in the following case. The parentheses are needed and read from
   inside to outside. 

int (&arrRef) [ 10 ] = arr;   // refers to an array of ten ints

the reference param is bound to the corresponding arg

void print( int (&arr) [ 10 ])
{
  for( auto elem : arr )
    cout << elem << endl;
}

This could also means the first low of multidimensional array and the both are
the same.

void print( int (*matrix)[10], int rowsize );
void print( int matrix[][10], int rowsize );


<complicated-array-type>
As seen above, array arr type is int(*)[6]. Likewise, state_list is **.

typedef struct fsm_instance {
   char*              name;
   fsm_state_t**      state_list;
   fsm_event_t*       event_list;
   fsm_state_t*       current_state;
   fsm_state_t*       previous_state;
} fsm_instance_t;

static Fsm::fsm_state_t* bootStateList[] = {
  &stateClosed,
  ...
  FSM_INVALID_STATE
};

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

fsm_instance fsm = { "...", &bootStateList, &bootEventList, ... };


<pointers-to-pointers>
From ansic, p107. A stripped-down sort utility. Can use shell and qsort but need
a data representation that will cope efficiently and conveniently with
variable-length text lines. The array of pointers elimiates the twin problems of
complicated storage management and high overhead of moving elements. This is
similar to difference between contiguous and linked list of sort algorithms. 

[ ] -> defghi         [ ]  +->      defghi      
[ ] -> jklmnopqrst    [ ] -+ +->    jklmnopqrst 
[ ] -> abc            [ ] ---+   -> abc         

<ex>
#include <stdio.h>
#include <string.h>

// max #lines to be sorted
#define MAXLINES 5000         

// Means that 1) is a pointer, 2) an array, and 3) has char * type element.
char *lineptr[MAXLINES];

int readlines( char *lineptr[], int nlines );
int writelines( char *lineptr[], int nlines );

void qsort( char *lineptr, int left, int right );

main()
{
  int nlines;     // number of input line read

  if( (nlines = readlines( lineptr, MAXLINES )) >= 0 )
  {
    qsort( lineptr, 0, nlines-1 );     // see [0, nlines-1]
    writelines( lineptr, nlines );
    return 0;
  }
  else
  {
    printf("error: input too big to sort\n");
    return 1;
  }
}

#define MAXLEN 1000     // max length of any input line

int getline( char *, int );
char *alloc(int);

// read inupt lines
int readlines( char *lineptr[], int maxlines )
{
  int len, nlines;
  char *p, line[MAXLEN];

  nlines = 0;

  while( (len = getline( line, MAXLEN )) > 0 )
    if( nlines >= maxlines || (p = alloc(len)) == NULL )
      return -1;
    else
    {
      line[len-1] = '\0';     // delete newline since getline includes a newline.
      strcpy( p, line );
      lineptr[nlines++] = p;  // this makes [0, nlines-1]
    }

  return nlines;
}

void writelines( char *lineptr[], int nlines )
{
  int i;

  for( i = 0; i < nlines; i++ )
    printf("%s\n", lineptr[i] );
}

// or can be written as
void writelines( char *lineptr[], int nlines )
{
  while( nlines-- > 0 )
    printf("%s\n", *lineptr++ );
}

There should be minor changes to qsort and swap.

void swap( char *v[], int i, int j )
{
  char *temp;     // <diff>

  temp = v[i], v[i] = v[j], v[j] = temp;
}

*ex-qsort*
void qsort( char *v[], int left, int right )
{
  int i, last;

  if( left >= right )
    return;

  swap( v, left, (left+right)/2 );

  last = left;

  for( i = left+1; i <= right; i++ )
   if( strcmp( v[i], v[left] ) < 0 )   // <diff>
     swap( v, ++last, i );

  swap( v, left, last );

  qsort( v, left, last-1 );
  qsort( v, last+1, right );
}


<pointers-and-malloc>
How to use malloc to have pointer array?

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main( int argc, char *argv[] )
{
  // Can use "char* result = malloc(...);" However problem is how to use/access
  // allocated memory afterwards. If use result[0] or result++, it moves 1 but
  // not 4. The compiler warns you as:
  //
  // c:21:13: warning: assignment makes integer from pointer without a cast [enabled by default]
  // c:26:9: warning: assignment from incompatible pointer type [enabled by default]
  //
  // After all, memory is memory and address is address. The 'type' is all about
  // how a compiler 'view' it; how to access it via [] or ++. sub script is
  // pointer arithmetic after all.

  // char *result[5];
  char** result = malloc(5*sizeof(*result));

  result[0] = strdup("one");
  result[1] = strdup("two");
  result[2] = strdup("three");
  result[3] = strdup("four");
  result[4] = NULL; // strdup("five");

  // Since it is 'pointer' type array, pointer++ always moves 4 bytes wheather
  // or not array element has char or int pointer. In other words, pointer size
  // is the same regardless of type.

  char** it;

  // to end loop there should be an element which has NULL.
  for(it=result; it && *it; ++it)
  {
    printf("%s\n", *it);
    free(*it);
  }

  free(result);
}


<pointers-vs-multi-dimensional>
From ansic, p112. When pass two dimensional array to a function f, can be
declared as

f( int daytab[2][13] );
f( int daytab[][13] );
f( int (*daytab)[13] );

The last needs () since [] is higher than *. Othewise, it is an array of 13
pointers to integers. The key is that the number of rows is irrelevant to a
compiler and this is how a compiler see an array in contiguous memory.

[0][13]                [1][13]                [2][13]                ...
<-------- 13 ---------><-------- 13 ---------><-------- 13 --------->

The other case is that followings are the same.

void print( const int* );
void print( const int[] );
void print( const int[10] );

From ansic, p113. Given the definitions:

int a[10][20];
int *b[10];

Then a[3][4] and b[3][4] are 'both' syntactically legal references to a single
int. Here legal means both type is the same but can have different
representation. The a is a true two dimensional array; 200 int-sized locations
have been set aside; 20*row+col. For b, however, only allocates 10 pointers.
When each of b has 20 long, it has 200 plus 10 pointers.

The important advantage of the pointer array is that the rows of the array may
be of different length. So can be one int or array of int. In other words, int
*b[10], int **b[10], int ***b[10] are the same.

char *names[] = { "Illegal month", "Jan", "Feb", "Mar" };

names:
[] -> "Illegal month\0"
[] -> "Jan\0"
[] -> "Feb\0"
[] -> "Mar\0"

char names[][15] = { "Illegal month", "Jan", "Feb", "Mar" };

names:
[] -> "Illegal month\0"
[] -> "Jan\0          "
[] -> "Feb\0          "
[] -> "Mar\0          "


={============================================================================
*kt_dev_cpp_0004* pointer-argv

<ex>
ansic, p116. argv example of option handling such as:

// echo command-line arguments
main( int argc, char *argv[] )
{
  while( --argc > 0 )
    printf("%s%s", *++argv, ( argc > 1 ) ? " " : "" );
    // or
    printf(( argc > 1 ) ? "%s " : "%s", *++argv );

  printf("\n");
  return 0;
}


find -x -n pattern
find -xn pattern

int main( int argc, char *argv[] )
{
  int c;

  // <1>
  while( --argc > 0 && (*++argv)[0] == '-' )
    while( c = *++argv[0] )
      switch(c) 
      {
        case 'x':
          printf("x option\n");
          break;
        case 'n':
          printf("n option\n");
          break;
        default:
          printf("unknown option\n");
          break;
      }

  // <2>
  if( argc != 1 )
    printf("usage: find -n -x pattern\n");

  return 0;
}

In <1>, argv is a pointer variable to a array but not array name so can increase it. so (*++argv)[0]
is the first character of argv[1]. Alternative be **++argv. See the skill of using 0 index without
using argv[i] indexing.

while( --argc > 0 && ((*++argv)[0] == '-' ))    // -
    while( c = *++argv[0] )                     // x or n
      printf("%c\n", c );

The *++argv[0] increments the pointer argv[0] but not argv itself. Since argv is alreay increased,
argv[0] means "-nx or -n", then ++ and * means "n".

(gdb) p argv
$5 = (char **) 0xbffff358
(gdb) p *argv
$6 = 0xbffff4f1 "-nx"

<2> this shall always be 1 if all are processed. If argc != 1 but loops ends, means that there are
argvs which does not start with -.


<example>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  char arr[] = "abcd";
  char *parr = arr;
    
  printf("%c",   *(arr+0) ); // same as printf("%c",   arr[0] );
  printf("%c",   *(arr+1) ); // same as printf("%c",   arr[1] );
  printf("%c",   *(arr+2) ); // same as printf("%c",   arr[2] );
  printf("%c\n", *(arr+3) ); // same as printf("%c\n", arr[3] );

  printf("%c",   *(parr+0) ); // same as printf("%c",   parr[0] );
  printf("%c",   *(parr+1) ); // same as printf("%c",   parr[1] );
  printf("%c",   *(parr+2) ); // same as printf("%c",   parr[2] );
  printf("%c\n", *(parr+3) ); // same as printf("%c\n", parr[3] );

  // error: subscripted value is neither array nor pointer nor vector
  // printf("%c",   (*parr)[0] );
  // printf("%c",   (*parr)[1] );
  // printf("%c",   (*parr)[2] );
  // printf("%c\n", (*parr)[3] );

  printf("%c",   (&*parr)[0] );
  printf("%c",   (&*parr)[1] );
  printf("%c",   (&*parr)[2] );
  printf("%c\n", (&*parr)[3] );
  
  char *pparr[] = {"this is one line", "this is second line"};
  char **ppchar = pparr;

  printf("%s\n",   ppchar[0] );       // this is one line
  printf("%s\n",   ppchar[1] );       // this is second line

  printf("%c\n",   (*ppchar)[0] );    // t
  printf("%c\n",   (*ppchar)[1] );    // h

  printf("%c\n",   *((*ppchar)+0) );  // t
  printf("%c\n",   *((*ppchar)+1) );  // h
} 


<ex>
Have core file when use argv[x]. Why? Turns out that used:

int main(int argc, char *argv);     // fail
int main(int argc, char **argv);    // okay

#include <stdio.h>

int main(int argc, char **argv)
{
    char *ptr = (char*)argv;
    char **pptr = argv;

    printf("argv[0] = %s\n", argv[0]);

    return;
}

(gdb) p ptr
$1 = 0xbfffef54 "\336\360\377\277"
(gdb) p pptr
$2 = (char **) 0xbfffef54
(gdb) p *ptr
$3 = -34 '\336'
(gdb) p *pptr
$4 = 0xbffff0de "/home/kyoupark/work/a.out"
(gdb) p *(char**)ptr
$5 = 0xbffff0de "/home/kyoupark/work/a.out"
(gdb) p/x *ptr
$6 = 0xde
(gdb) 


<ex> *ex-tail* *ex-interview*
see *kt_dev_glib_006* tail-program for a solution.


{pointer-and-string}
char amessage[] = "now is the time";
char *pmessage = "now is the time";

The important difference is that amessage is an array that is 'initialised' with
string constant. Individual characters may be changed. 

On the other hand, pmessage is a pointer, initialised to point to a string
constant and can be modified but undefined if you try to modify the string
contents.


={============================================================================
*kt_dev_cpp_0004* pointer-null

{null-pointer} 
C gurantees that zero is never a valid address for data. Pointer and integers
are not interchangeable but zero is the sole exception. NULL `symbolic-constant`


={============================================================================
*kt_dev_cpp_0004* pointer-reading

Difference between char *a and char a[]

char * and char [] both are used to access character array, Though functionally
both are same, they are syntactically different. See how both works in order to
access string.

A. How char a[] works?

Consider following example for storing and accessing string using character
array.

char a[] = "HELLO";

In the example string "Hello" is stored in character array 'a'. Character array
  is used to store characters in 'contiguous' memory location. It will take
  following form after 'initialization'. We have not specified array size in
  this example. Each array location will get following values -

a[0] = 'H'
a[1] = 'E'
a[2] = 'L'
a[3] = 'L'
a[4] = 'O'
a[5] = '\0'

It will Looks Like This
array a :  H    E    L    L    O '\0'
         a[0] a[1] a[2] a[3] a[4]


Accessing Individual Element :
Suppose we have to find out a[3] then firstly compiler will check whether 'a' is
array or pointer.  If 'a' is array variable then it starts at the location 'a',
      goes three elements past it, and returns the character there. In this
        method element is accessed sequentially

B. How char *a works?

String "Hello" will be stored at any anonymous location in the form of array. We
even don't know the location where we have stored string, However string will
have its starting address. Syntax of char *a :

char *a = "HELLO";

the above syntax will take following form -

pointer a :  H    E    L    L    O '\0'
           a[0] a[1] a[2] a[3] a[4]
           anonymous array

We have declared pointer of type character i.e pointer variable is able to hold
the address of character variable. Now base address of anonymous array is stored
in character pointer variable. 'a' stores base address of the anonymous
array(unknown array)

Address = [Base Address of Anonymous Array]  + [i]

Accessing Individual Element :

Consider we have to access a[3] then

In short if 'a' is a pointer, it starts at the location "a", gets the pointer
value there, adds 3 to the pointer value, and gets the character pointed to by
that value. In both cases a[3] returns same character but procedure is
different.


={============================================================================
*kt_dev_cxx_0000* cxx-cstring cxx-check cxx-sizeof

Queries size of the `object` or `type`. Used when actual size of the object
must be known `at compile time`:

sizeof (type)
sizeof expression/object

Both versions return a constant of type std::size_t *cxx-size-t*

Explanation

* returns size in bytes of the object representation of type.
* returns size in bytes of the object representation of the type, that would be
  returned by expression, if evaluated.  

* Depending on the computer architecture, a byte may consist of 8 or more bits,
  the exact number being recorded in CHAR_BIT.

* sizeof(char), sizeof(signed char), sizeof(unsigned char) always return 1.

* Cannot be used with function types, incomplete types, or bit-field lvalues.

* When applied to a reference, the result is the size of the `referenced-type`

* When applied to a class type, the result is the size of an object of that
  class 'plus' any additional padding required to place such object in an array.

* When applied to an empty class type, always returns 1.
  `cpp-empty-base-class-optimization`


<sizeof-which-version>
sizeof(`type`)
sizeof expression/object

must use sizeof(type) for type since syntatical reson:

val1 = sizeof int;

: error: expected primary-expression before 'int'
: error: expected ';' before 'int


<to-get-array-size> cpp-array
Two forms and the 'latter' is 'better' since do not need to be changed if the
type changes.

int length= sizeof(arr)/sizeof(int);
int length= sizeof(arr)/sizeof(arr[0]);


int func()
{
  int arr[] = { ... };
  int length= sizeof(arr)/sizeof(int);
  ...
}

This works fine as expected; sizeof(array) returns a size of an array, but if
you pass array in func, it is converted to a pointer and the return of sizeof
is the size of pointer but not the array.

int func(int arr[])
{
  int length = sizeof(arr)/sizeof(int);   // note: THIS DOESN'T WORK!
  ...
}


namespace use_sizeof {

struct nlist {
  struct nlist *next;
  char *name;
  char *defn;
};

} // namespace

TEST(Size, Arrays)
{
  using namespace use_sizeof;

  // array, sizeof, strlen and valid index:
  // 
  //   0   1   2   3   4   5 
  //   D   S   M   :   !   \0
  // 
  // valid array index     [0, 6) [0, size(), sizeof()) or [0, 5] [0, size()-1]
  // valid cstring index   [0, 5) [0, strlen()) or [0, 4] [0, strlen()-1]

  char *s1 = "this is first message";
  char s2[] = "this is first message";

  // is a pointer
  EXPECT_EQ(sizeof(s1), 8);
  EXPECT_EQ(sizeof s1, 8);

  // is object
  EXPECT_EQ(sizeof(*s1), 1);

  // is array
  EXPECT_EQ(sizeof(s2), 22);
  EXPECT_EQ(sizeof(s2)/sizeof(s2[0]), 22);

  // strlen
  EXPECT_EQ(strlen(s2), 21);

  string s{s1};
  EXPECT_EQ(s.size(), 21);

  char coll1[100];
  EXPECT_EQ(sizeof(coll1), 100);

  char coll2[] = {1,2,3,4,5,6,7};
  EXPECT_EQ(sizeof(coll2), 7);

  struct nlist *plist;
  EXPECT_EQ(sizeof(plist), 8);
  // 8 or else?
  EXPECT_EQ(sizeof(*plist), 24);
}


{cxx-strlen} *cxx-side-effect*  
* strlen() excludes NULL which means `sizeof-1, size-1`
* `cxx-cstring` needs an extra space for NULL

#include <iostream>
#include <cstring>

using namespace std;

int main()
{
  const char *literal = "DSM:!";

  std::cout << "length is " << sizeof("DSM:!") << std::endl;
  std::cout << "length is " << strlen("DSM:!") << std::endl;
  std::cout << "length is " << sizeof("") << std::endl;
  std::cout << "length is " << strlen("") << std::endl;

  std::cout << "length is " << sizeof(literal) << std::endl;
  std::cout << "length is " << sizeof(*literal) << std::endl;
  std::cout << "length is " << strlen(literal) << std::endl;
}

length is 6   // sizeof
length is 5   // strlen
length is 1   // sizeof
length is 0   // strlen

length is 4   // literal since it's pointer
length is 1
length is 5

The strlen() function calculates the length of the string s, 'excluding' the
terminating null byte ('\0'). In other words, strlen knows about a c string
but sizeof do not. Hence sizeof returns +1 more. 

note: sizeof is better since it is not a func call and done in compile.


{cxx-check}
... [0               (size-1)] size ...
    <------------------------>

Use the fact that the valid index is always < container.size(). When i equals
to size() is either empty or past end.

// to check if it is empty

void StrBlob::check(size_type i, const string &msg) const
{
  if( i >= data->size() )
    throw out_of_range(msg);
}

string& StrBlob::front()
{
  check( 0, "front on empty StrBlob" );
  return data->front();
};


// to check if it's beyond [0, size)

std::string &StrBlobPtr::deref() const
{
  // StrBlobPtr::check()
  auto p = check( curr, "dereference past end");
  return (*p)[curr];    // () is necessary since [] is higher than *
}


// to check if it's beyond the begin

The trick is that decrement curr 'before' calling check() and that way, if
curr is already 0, the value that we pass to check() will be a large positive
value representing an 'invalid' subscript since size_t is 'unsigned' number.

StrBlobPtr &StrBlobPtr::operator--()
{
  --curr;
  check(curr, "decrement past begin of StrBlobPtr");
  return *this;
}


{cstring-in-memory}

int main(int argc, char* argv[])
{
  // '\n' is character constant(single character) and "\n" is s string constant 

  char str1[] = "\n"; 
  char str2[] = ""; 
  char str3[] = "one"; 
}

(gdb) p str1
$1 = "\n"
(gdb) p str2
$2 = ""
(gdb) p str3
$3 = "one"

(gdb) p /x str1
$4 = {0xa, 0x0}
(gdb) p /x str2
$5 = {0x0}
(gdb) p /x str3
$6 = {0x6f, 0x6e, 0x65, 0x0}


<ex> *ex-strcat* 
From ansic, exercise 5-3. Write a pointer version of the function strcat that
we showed in Chapter 2: strcat(s,t) copies the string t to the end of s.

Concatenate t to end of s. s must be big enough. The lib version returns a
pointer of resulting string

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_3
void mstrcat_one(char *s, char *t)
{
  // NOT OK when s is empty
  while(*++s); /* Get to the end of the string */
  while((*s++ = *t++));
}

void wrong_strcat(char *s, char *t)
{
  while(*s++)           // *cxx-side-effect*
    ;

  while(*s++ = *t++)
    ;
}

void mstrcat_four(char *s, char *t)
{
  while(*s)
    s++;

  while(*s++ = *t++)
    ;
}

void strcat( char s[], char t[] )
{
  int i, j;

  i = j = 0;
  while( s[i] != '\0' )               // find end of
    i++;

  // while( s[i++] = t[j++] )         // copy t
  while( (s[i++] = t[j++]) != '\0' )  // copy t, no `postfix-issue`
    ;
}


<ex> *ex-strend* 
From ansic, exercise 5-4. pointer arithmetic
Write the function strend(s,t), which returns 1(found) if the string t occurs
at the end of the string s, and 0 otherwise.

int strend(char *s, char *t);

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_4
// bool strend(char *s, char *t);

bool strend_01(char *s, char *t)
{
    // assume s is bigger than t
    size_t diff = strlen(s) - strlen(t);

    char *psource = s+diff, *ptarget = t;
    while (*psource)
    {
        if (*psource != *ptarget)
            return false;
        
        ++psource, ++ptarget;
    }

    return true;
}

bool strend_02(char *s, char *t)
{
    // assume s is bigger than t. uses parameter
    s += strlen(s) - strlen(t);

    while (*s++ == *t++)
    {
        // if cxx-side-effect, +1, points NULL then all matches up.
        if (*s == '\0')
            return true;
    }

    return false;
}

// = 02 ======
// strend(this is first message, ssage) returns 1
// strend(this is first message, xsage) returns 0
// strend(this is first message, ssage) returns 1
// strend(this is first message, xsage) returns 0

int t_string_02()
{
    char s1[] = "this is first message";
    char t1[] = "ssage";
    char t2[] = "xsage";

    cout << "strend(" << s1 << ", " << t1 << ") returns " << strend_01(s1, t1) << endl;
    cout << "strend(" << s1 << ", " << t2 << ") returns " << strend_01(s1, t2) << endl;
    cout << "strend(" << s1 << ", " << t1 << ") returns " << strend_02(s1, t1) << endl;
    cout << "strend(" << s1 << ", " << t2 << ") returns " << strend_02(s1, t2) << endl;
}


{cxx-off-the-end} *cxx-end* *cxx-pointer-arithmetic*
Pointer arithmetic or comparison is 'undefined' when use pointers that do not
point to members of the 'same' array. It is not legal to add two pointers
while pointer addition is legal; pointer add integer. 

When substracting a pointer p from another pointer q, q-p, the result is the
number of array elements in the sequence [p:q)

{
    int vi[10]{};
    short vs[10]{};

    cout << "vi[5]: " << &vi[5] << ", vi[3]: " << &vi[3] << endl;
    cout << "vi[5]: " << &vi[5]-2 << endl;
    cout << &vi[5] - &vi[3] << endl;
}

vi[5]: 0x7ffdc7831fb4, vi[3]: 0x7ffdc7831fac
vi[5]: 0x7ffdc7831fac
2


As for `off-the-end` iterator, taking a pointer to the element one beyond the
end of an array is guaranteed to work. This is important for many algorithms
(§4.5, §33.1). However, since such a pointer does not in fact point to an
element of the array, it may not be used for reading or writing. The result of
taking the address of the element before the initial element or beyond
one-past-the-last element is undefined and should be avoided. 

#include <iostream>

using namespace std;

int main()
{
  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  cout << "{";

  for( int* b = arr, *e = &arr[10]; b != e; ++b )
    cout << *b << ", ";

  cout << "}" << endl;
}


<ex> *ex-count-keyword*
ansic p137, Keyword counting program.

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

struct key 
{
  char *word;
  int count;

  // note: must `ordered-list`
} keytab[NKEYS] = { "auto", 0, "break", 0, ... };

int getword( char *, int );
struct key *binsearch( char *, struct key *, int );

main()
{
  char word[MAXWORD];

  struct key *p;

  while( getword( word, MAXWORD ) != EOF )
    if( isalpha( word[0] ) )
      if((p = binsearch( word, keytab, NKEYS )) != NULL )
        p->count++;

  for( p = keytab; p < keytab + NKEYS; p++ )
    if( p->count > 0 )
      printf("%4d %s\n", p->count, p->word );

  return 0;
}

// See how `binary-search` `equality-version` is changed to use structure.
//
// WHY use `off-the-end` but not the last when use pointer?
//
// [0]      [1]     [2]     [3]     [4]     [5]     OFF
// diff 0   diff 1  diff 2  diff 3  diff 4  diff 5 
//  X                                                Y
//
//  Y - X is `size` and the number of items in between excluding Y. However,
//  when use `offset` from the start, use Y-1 as when use `index`
//

struct key *binsearch( char *word, struct key *tab, int n)
{
  int cond;
  struct key *low = &tab[0];
  struct key *high = &tab[n];       // `off-the-end`
  struct key *mid;

  // "low < high" since use of off-the-end but not because of Binary1/Binary2 difference.
  while( low < high )
  {
    // "high-low" is "size" which is different from (low + (size-1))/2. Howerver, doesn't matter.
    mid = low + ( high-low )/2;

    if((cond = strcmp( word, mid->word )) < 0 )
      high = mid;  // why not mid-1? since high is excluded in while condition. not sure.
    else if( cond > 0 )
      low = mid+1;
    else
      return mid;
  }

  return NULL;
}


<ex>
From CPR p112, `forgettable-version` 

vector<string> text;

// As with interator or pointer, use `pointer-arithmetic` to get the middle.
auto begin = text.begin(), end = text.end();
auto middle = text.begin() + (end-begin)/2;

// while there are still elements to look at and we haven't yet found sought.
while( middle != end && *middle != sought )
{
  if( sought < *middle )
    end = middle;              # throw upper
  else
    begin = middle+1;

  middle = begin + ( end - begin )/2;
}

// when no found, begin, end, and middle are the same.


={============================================================================
*kt_dev_cxx_0000* cxx-switch

To emphasize that the cases represent a range of values:

switch(ch)
{
  case 'a': case 'e': case 'i': case 'o': case 'u':
    ...
  break;
}

Have to define a default label even if there is no work for the case to
indicate that the case was considered. See *cxx-switch-case*

<switch-under-the-hood>
http://stackoverflow.com/questions/3012011/switch-case-assembly-level-code

Here is the C source:

switch(i)
{
    case 1:
    {
        printf("Case 1\n");
        break;
    }
    case 2:
    {           printf("Case 2\n");
        break;
    }
    case 3:
    {
        printf("Case 3\n");
        break;
    }
    case 4:
    {
        printf("Case 4\n");
        break;
    }
    // omitted to 10:
    default:
    {
        printf("Nothing\n");
        break;
    }
}  

Now the resultant assembly for the same is:

movl    $5, -4(%ebp)
cmpl    $10, -4(%ebp)
ja  L13
movl    -4(%ebp), %eax
sall    $2, %eax
movl    L14(%eax), %eax
jmp *%eax
.section .rdata,"dr"
.align 4
L14:
.long   L13
.long   L3
.long   L4
.long   L5
.long   L6
.long   L7
.long   L8
.long   L9
.long   L10
.long   L11
.long   L12
.text
L3:
movl    $LC0, (%esp)
call    _printf
jmp L2
L4:
movl    $LC1, (%esp)
call    _printf
jmp L2
L5:
movl    $LC2, (%esp)
call    _printf
jmp L2
L6:
movl    $LC3, (%esp)
call    _printf
jmp L2
L7:
movl    $LC4, (%esp)
call    _printf
jmp L2
L8:
movl    $LC5, (%esp)
call    _printf
jmp L2
L9:
movl    $LC6, (%esp)
call    _printf
jmp L2
L10:
movl    $LC7, (%esp)
call    _printf
jmp L2
L11:
movl    $LC8, (%esp)
call    _printf
jmp L2
L12:
movl    $LC9, (%esp)
call    _printf
jmp L2
L13:
movl    $LC10, (%esp)
call    _printf
L2:  

First the code is comparing the i to 10 and jumping to the default case when the
value is greater then 10 (cmpl $10, -4(%ebp) followed by ja L13). The next bit
of code is shifting the input to the left by two (sall $2, %eax) which is the
same as multiple by four (it multiplies by 4 because each entry in the jump
    table is 4 bytes long). So what is had done here is generated an offset into
the jump table. It then loads an address from the jump table (movl L14(%eax),
    %eax) and jumps to it (jmp *%eax).

The `jump-table` is simply a list of addresses (represented in assembly code by
    labels):

L14:
.long   L13
.long   L3
.long   L4
...

One thing to notice is that L13 represents the default case. It is both the
first entry in the jump table (for when i is 0) and is handled specially at the
beginning (when i > 10).

<01>
@puffadder: most modern compilers use heuristics to determine when it's more
efficient to use branches versus a jump table. E.g. if your case levels were say
1, 100 and 1000 you might expect branches to be used. - Paul R Jun 10 '10 at
7:07 

<02>
You have a switch statement with 5 case statements and the cases all have
numbers that are spread far apart so a jump table will not be used, 'if type'
will. {Q} May choose not to use a jump table because there will be entries which
are not used? Up to a compiler?

<switch-grouping>

typedef enum {
  E_01,    //
  E_02,
  E_03,
  E_11,    //
  E_12,
  E_13,
  E_21,    //
  E_22,
  E_23,
  E_31,    //
  E_32,
  E_33
} EVENTS;

typedef enum {
  E_G00, E_G01, E_G02, E_G03, E_GNO
} GROUPS;

int getEventGroup( int events )
{
  switch( events )
  {
    case E_01: case E_02: case E_03:
      return E_G00;
      break;
      ...

    default:
        return E_GNO;
        break;
        std::cout << "IS IT EXECUTED?? " << events << std::endl;
  }
}

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( getEventGroup(events) )
    {
      case E_G00:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

OR

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( events )
    {
      case E_01: case E_02: case E_03:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

The both do the same. The first is a bit clearer at the expense of one function
call?


<does-it-work>
Found it in the real code. Does the line after default get executed? NO.

switch( events )
{
  case E_01: case E_02: case E_03:
    ...
      break;
  default:
    return E_GNO;
    break;
    std::cout << "IS IT EXECUTED?? " << events << std::endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-loop cxx-for cxx-while cxx-side-effect

{cxx-range-for}
The `range-for` is supported from GCC 4.6

o range-for caches `begin()` and `end()` so has risk of using `invalidated-iterators`
o shall use `const&` in for loop statement to avoid unnecessary copy.
o do not call end() in every loop
o range-for do not use iterator but use element itself. 

for( T &r : vec )
   r *= 2;

is interpreted as:

for( auto beg = vec.begin(), end = vec.end(); beg != end; ++beg )
{
  T &r = *beg;
  r *= 2;
}

The range for changes way to access element:

{
  for( const auto &elem : coll )
    cout << elem << " ";
}

{
  for (const auto it = coll.cbegin(); it != coll.cend(); ++it)
    cout << *it << " ";
}


NOTE:
cxx-range-for can be used only with types that suppors iterators, begin(), and
not used with integers.

TEST(CxxFeaturesTest, UseRangeForOnInteger)
{
  int num_loops{10};

  for (const auto &e : num_loops)
  {
    cout << "e : " << e << endl;
  }
}

: In member function ‘virtual void CxxFeaturesTest_UseRangeForOnInteger_Test::TestBody()’:
:796:24: error: ‘begin’ was not declared in this scope
   for (const auto &e : num_loops)


{cxx-range-for-and-cxx-while}

The `cxx-for-loop` is preferable 
  `when there is a simple initialization and increment` 
  since keeps the loop control statement `close together and visiable` 
  at the top of the loop.

<ex>
As this case, cxx-while is straightforward but cxx-for requires more thought
and make clean code.

// algo-sort-heap from programming pearl
//
// pre  : heap(1, n-1)
// post : heap(1, n)
// 
// void siftup(n)
// {
//   int i = n;
// 
// loop:
//   // invariant: heap(1, n) except between i and its parent
//   
//   // terminates when reaches the root
//   if (i == 1)
//     break;
//
//   p = i / 2;
//
//   // terminates when it meets heap property
//   if (x[i] >= x[p])
//     break;
// 
//   swap(i, p);
// 
//   i = p;
// }


// while version
void siftup_01(vector<int> &coll, int n)
{
  int i = n;
  int p = i / 2;

  for (; (i != 1) && (coll[i] <= coll[p]);)
  {
    swap(coll[i], coll[p]);
    i = p;
    p = i / 2;
  }
}

void siftup_02(vector<int> &coll, int n)
{
  int i = n;
  int p = i / 2;

  while (i != 1 && coll[i] <= coll[p])
  {
    swap(coll[i], coll[p]);
    i = p;
    p = i / 2;
  }
}

However, when tries to use cxx-for causes cxx-error

// *cxx-error*
void siftup_01(vector<int> &coll, int n)
{
  int i = n;
  int p = i / 2;
 
  for (; (i != 1) && (coll[i] <= coll[p]); i = p)
  {
    swap(coll[i], coll[p]);
    p = i / 2;
  }
 
  // effectively this and should update p after i so this is an error
  //
  // for (; (i != 1) && (coll[i] <= coll[p]);)
  // {
  //   swap(coll[i], coll[p]);
  //   p = i / 2;
  //   i = p;
  // }
}

// *cxx-error*
void siftup_01_error(vector<int> &coll, int n)
{
  int i = n;
  int p = i / 2;
 
  // for (; (i != 1) && (coll[i] <= coll[p]); i = p)
  // {
  //   p = i / 2;
  //   swap(coll[i], coll[p]);
  // }
 
  // effectively this and cause error since has different pair of i and p in
  // check of the lopp.
  for (; (i != 1) && (coll[i] <= coll[p]);)
  {
    p = i / 2;
    swap(coll[i], coll[p]);
    i = p;
  }
}

// for version from text
void siftup_03(vector<int> &coll, int n)
{
  int i, p;
  for (i = n; i > 1 && coll[p = i/2] > coll[i]; i = p)
    swap(coll[i], coll[p]);
}


Again, 

// pre  : heap(2, n)
// post : heap(1, n)
// 
// void siftdown(n)
// {
//   int i = 1;
// 
// loop:
//   // invariant: heap(1, n) except between i and its children(0, 1, or 2)
//   
//   // c is index of the left child
//   c = i * 2;
//
//   // terminates when no children
//   if (c > n)
//     break;
// 
//   // when the right child is lesser
//   if (c+1 <= n)
//    if (x[c] > x[c+1])
//      c++;
//
//   // terminates when it meets heap property
//   if (x[i] <= x[c])
//     break;
// 
//   swap(i, c);
// 
//   i = c;
// }

void siftdown_01(vector<int> &coll, int n)
{
  int i = 1;
  int c = i * 2;

  if (c+1 <= n)
    if (coll[c] > coll[c+1])
      c++;

  while ((c < n) && (coll[i] > coll[c]))
  {
    swap(coll[i], coll[c]);

    i = c;

    c = i * 2;

    if (c+1 <= n)
      if (coll[c] > coll[c+1])
        c++;
  }
}

// *cxx-error* 
// void siftdown_01(vector<int> &coll, int n)
// {
//   int i = 1;
//   int c = i * 2;
// 
//   if (c+1 <= n)
//     if (coll[c] > coll[c+1])
//       c++;
// 
//   for (; (c < n) && (coll[i] > coll[c]); i = c)
//   {
//     swap(coll[i], coll[c]);
// 
//     if (c+1 <= n)
//       if (coll[c] > coll[c+1])
//         c++;
// 
//     c = i * 2;
//   }
// }

void siftdown_02(vector<int> &coll, int n)
{
  int c;

  for (int i = 1; (c = i*2) <= n; i = c)
  {
    if (c+1 <= n && coll[c] > coll[c+1])
      c++;

    if (coll[i] <= coll[c])
      break;

    swap(coll[i], coll[c]);
  }
}


{cxx-side-effect} from online
A "side effect" is defined by the C++ standard in [intro.execution], by:

Reading an object designated by a volatile glvalue (3.10), modifying an
object, calling a library I/O function, or calling a function that does any of
those operations are all side effects, which are `changes` in the state of the
execution environment.

y = (x = d) * 5;      // sets y to 15.

The value returned from x = d, is its main effect. The changing of the value
of x is a side effect.


  *cxx-remeber*
  ""Therefore, the point is whether or not `evaluation` cause side-effect and 
  use `side-effect` in operations `afterwords`.""


Use `prefix-version` for all cases except when necessary.


<postfix-asm>
Used gcc and asm for MIPS. When try `postfix`, shows `fetch-and-increase`. No
use of the previous copy; j=i; and i+=i; in asm. However, if use user type
then need to have a previous copy to have the same effect. 

// postfix version

#include <stdio.h>

int main()
{
  int i = 0, j = 0;

  j = i++;
  printf("j is %d\n", j );
  return 0;
}

// asm
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       afbf0024        sw      ra,36(sp)
  400598:       afbe0020        sw      s8,32(sp)
  40059c:       03a0f021        move    s8,sp       # save sp to s8. s8 is sp.
  4005a0:       afc0001c        sw      zero,28(s8) # i = 0
  4005a4:       afc00018        sw      zero,24(s8) # j = 0           // fetch
  4005a8:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005ac:       afc20018        sw      v0,24(s8)   # j = i
  4005b0:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005b4:       24420001        addiu   v0,v0,1     # v0(i) = i+1     // i++
  4005b8:       afc2001c        sw      v0,28(s8)   # i = v0
  4005bc:       3c020040        lui     v0,0x40
  4005c0:       24440690        addiu   a0,v0,1680
  4005c4:       8fc50018        lw      a1,24(s8)   # get j and call print
  4005c8:       0c100124        jal     400490 <printf@plt>
  4005cc:       00000000        nop
  4005d0:       00001021        move    v0,zero
  4005d4:       03c0e821        move    sp,s8
  4005d8:       8fbf0024        lw      ra,36(sp)
  4005dc:       8fbe0020        lw      s8,32(sp)
  4005e0:       27bd0028        addiu   sp,sp,40
  4005e4:       03e00008        jr      ra
  4005e8:       00000000        nop
  4005ec:       00000000        nop


// Use -Os. See how it's done. Just use zero to print and no increase.

00400590 <main>:
  400590:       3c040040        lui     a0,0x40
  400594:       27bdffe0        addiu   sp,sp,-32
  400598:       24840658        addiu   a0,a0,1624
  40059c:       afbf0018        sw      ra,24(sp)
  4005a0:       0c100124        jal     400490 <printf@plt>
  4005a4:       00002821        move    a1,zero
  4005a8:       8fbf0018        lw      ra,24(sp)
  4005ac:       00001021        move    v0,zero
  4005b0:       03e00008        jr      ra
  4005b4:       27bd0020        addiu   sp,sp,32  


// pointer version

#include <stdio.h>

void print_array(int arr[], int len)
{
  int *pend;

  pend = arr+len;

  while( arr != pend )
    printf("arr is : %d\n", *arr++ );
}

int main()
{
  int int_arr[] = { 1,2,3,4,5,6,7,8,9,10};

  print_array(int_arr, sizeof(int_arr)/sizeof(int));

  return 0;
}


004005c0 <print_array>:
  4005c0:       27bdffd8        addiu   sp,sp,-40
  4005c4:       afbf0024        sw      ra,36(sp)
  4005c8:       afbe0020        sw      s8,32(sp)
  4005cc:       03a0f021        move    s8,sp
  4005d0:       afc40028        sw      a0,40(s8)  # save arr
  4005d4:       afc5002c        sw      a1,44(s8)  # save len
  4005d8:       8fc2002c        lw      v0,44(s8)  # get len
  4005dc:       00021080        sll     v0,v0,0x2  # v0 = v0 << 2. 101000 (40) for 10 integers
  4005e0:       00401821        move    v1,v0      # v1 = len
  4005e4:       8fc20028        lw      v0,40(s8)  # get arr
  4005e8:       00621021        addu    v0,v1,v0   # v0 = len + arr {pend}
  4005ec:       afc20018        sw      v0,24(s8)  # save v0
  4005f0:       08100188        j       400620 <print_array+0x60>
  4005f4:       00000000        nop
{4005f8}:       8fc20028        lw      v0,40(s8)  #<2> get arr {inced-arr}
  4005fc:       8c430000        lw      v1,0(v0)   #    get *arr note. {deref} 0($x)
  400600:       8fc20028        lw      v0,40(s8)  #    get arr
  400604:       24420004        addiu   v0,v0,4    #    arr++
  400608:       afc20028        sw      v0,40(s8)  #    save arr++
  40060c:       3c020040        lui     v0,0x40    #    
  400610:       24440750        addiu   a0,v0,1872
  400614:       00602821        move    a1,v1      #    *arr
  400618:       0c10012c        jal     4004b0 <printf@plt>
  40061c:       00000000        nop
{400620}:       8fc30028        lw      v1,40(s8)  # <1> get arr {inced-arr}
  400624:       8fc20018        lw      v0,24(s8)  #   get pend {const}
  400628:       1462fff3        bne     v1,v0,4005f8 <print_array+0x38>    # !=
  40062c:       00000000        nop
  400630:       03c0e821        move    sp,s8
  400634:       8fbf0024        lw      ra,36(sp)
  400638:       8fbe0020        lw      s8,32(sp)
  40063c:       27bd0028        addiu   sp,sp,40
  400640:       03e00008        jr      ra
  400644:       00000000        nop

00400648 <main>:
  400648:       27bdffb8        addiu   sp,sp,-72
  40064c:       afbf0044        sw      ra,68(sp)
  400650:       afbe0040        sw      s8,64(sp)
  400654:       03a0f021        move    s8,sp
  400658:       3c020040        lui     v0,0x40
  40065c:       27c30018        addiu   v1,s8,24
  400660:       24420760        addiu   v0,v0,1888
  400664:       24060028        li      a2,40
  400668:       00602021        move    a0,v1
  40066c:       00402821        move    a1,v0
  400670:       0c100130        jal     4004c0 <memcpy@plt> # may be copy array into stack (24)?
  400674:       00000000        nop
  400678:       27c20018        addiu   v0,s8,24
  40067c:       00402021        move    a0,v0   # arr address
  400680:       2405000a        li      a1,10   # len
  400684:       0c100170        jal     4005c0 <print_array>
  400688:       00000000        nop
  40068c:       00001021        move    v0,zero
  400690:       03c0e821        move    sp,s8
  400694:       8fbf0044        lw      ra,68(sp)
  400698:       8fbe0040        lw      s8,64(sp)
  40069c:       27bd0048        addiu   sp,sp,72
  4006a0:       03e00008        jr      ra
  4006a4:       00000000        nop
        ...
004004c0 <memcpy@plt>:
  4004c0:       3c180040        lui     t8,0x40
  4004c4:       8f1917d8        lw      t9,6104(t8)
  4004c8:       03200008        jr      t9
  4004cc:       271817d8        addiu   t8,t8,6104

See <2> since dereference first and increase later.


<ex>
// use pointer arithmetic to return length
int mstrlen_1(const char *s)
{
    const char *p = s;

    while (*s)
        ++s;

    return s-p;
}

// use a variable to return length
int mstrlen_2(const char *s)
{
    unsigned int i = 0;

    while (*s)
    {
        ++s;
        ++i;
    }

    return i;
}

// cxx-side-effect made in while() is not used. Hence okay.
int mstrlen_3(const char *s)
{
    unsigned int i = 0;

    while (*s++)
        ++i;

    return i;
}

// cxx-side-effect made in while() is used in getting a length. side-effect cause
// +1 and not okay.
int mstrlen_4(const char s[])
{
  const char *run = s;

  while (*run++)
    ;

  return run-s;
}

// cxx-side-effect is not used. Hence okay.
int mstrlen_5(const char s[])
{
  const char *run = s;

  while (*run)
    ++run;

  return run-s;
}

void t_mstrlen()
{
    const char *input = "01234567890123456";

    printf("mstrlen is %d\n", mstrlen_1(input));
    printf("mstrlen is %d\n", mstrlen_2(input));
    printf("mstrlen is %d\n", mstrlen_3(input));
    printf("mstrlen is %d\n", mstrlen_4(input));
    printf("mstrlen is %d\n", mstrlen_5(input));
}

mstrlen is 17
mstrlen is 17
mstrlen is 17
mstrlen is 18     // not okay
mstrlen is 17


<ex> *ex-strcpy*

note that library versions of strcpy() and strncpy() functions return a
pointer to the destination string dest

void strcpy( char *s, char *t )
{
  while( *s++ = *t++ ) 
    ;
}


Why not a problem? while() evaluation cause cxx-side-effects but
cxx-side-effect(+1) is not used.

For *pbeg++, post-increase is high than dereference(*) so it's the same as
*(pbeg++) but how this behave as *(pbeg); pbeg++; ? because it returns the
previous copy which is `value`. This is how CPR explains and matches to asm
result.

int *ip;
*ip++;      // inc ip itself
(*ip)++;    // inc *ip, not ip

Here there are three operations; fetch, increase and dereference.
post-increase do fetch and increase but return the value before increase and
dereference it.


<ex> *ex-escape* 
From ansic, exercise 3-2. Write a function escape(s,t) that converts
characters like newline and tab into visible escape sequences like \n and \t
as it copies the string t to s. Use a switch. Write a function for the other
direction as well, converting escape sequences into the real characters.

void escape(char* s, char* t)
{
  // when use "while(*t++)", the result missed out the first char. Since
  // cxx-side-effect is used afterwords.

  while( *t )
  {
    switch(*t)
    {
      case '\t':
        *s++ = '\\';    // note to escape
        *s++ = 't';
        break;

      default:
        *s++ = *t;
        break;
    }

    t++;
  }
  
  *s = '\0';
}

  `while(expression)`
    statement

  "If expression is non-zero, statement is executed and expression is
  re-evaluated." 


<ex> *cxx-atoi* atoi second version in ansic p61
#include <ctype.h>

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;

  sign = (s[i] == '-') ? -1 : 1;

  // skip sign
  if( s[i] == '+' || s[i] == '-' )
    i++;

  for(n = 0; isdigit( s[i] ); i++)
    n = n*10 + (s[i]-'0');

  return sign*n;
}


Again shows the cxx-side-effect issue. If use the approach as below then miss
out the one char. When there is no leading space, expect i==0 when loop ends
but i==1 since will have the side effect.

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  while( isspace(s[i++]) )
    ;
  ...
}


Two solutions:

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;
}

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  while( isspace(s[i]) )
    i++;
}


<ex>
Similar to ex-bitcount but this gets the number of interation while input has
1 bit so effectly gets MSB position.

#include <iostream>

using namespace std;

int main()
{
  // 1100 1110 0101, [11..0]
  // unsigned int input = 3301;

  unsigned int count = 0;

  // gets 12
  for(count=0; input; input >>= 1)
    ++count;

  // gets 11
  for(count=0; input && (input>>=1);)
    ++count;
  
  // gets 11
  while(input && (input >>= 1))
    ++count;

  cout << "count: " << count << endl;
}


<ex> *ex-expand* 
From ansic, exercise 3-3. Write a function expand(s1,s2) that expands
shorthand notations like a-z in the string s1 into the equivalent complete
list abc...xyz in s2. Allow for letters of either case and digits, and be
prepared to handle cases like a-b-c and a-z0-9 and -a-z . Arrange that a
leading or trailing - is taken literally

#include <stdio.h>
#include <ctype.h>

#define UP(N) ((N) >= 'A' && (N) <= 'Z')
#define LO(N) ((N) >= 'a' && (N) <= 'z')
#define NU(N) ((N) >= '0' && (N) <= '9')
#define AN(N) (UP(N) || LO(N) || NU(N))

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_3
// Pilcrow 20:33, 14 September 2011 (UTC) 
int expand_online(const char s1[], char s2[], int sz)
{
  int i, j, temp;

  j=0;
  for(i = 0; s1[i] != '\0'; i++) {
    if(j >= sz) return 0;                                   /* buffer overflow */
    if(i==0 || s1[i] != '-') {                              /* first character or not '-'*/
      s2[j++] = s1[i];
      continue;
    }
    if(s1[i] == '-' && (!AN(s1[i-1]) || !AN(s1[i+1]))) {    /* leading, trailing, isolated '-' */
      s2[j++] = s1[i];
      continue;
    }
    if(s1[i] == '-' && (
          (UP(s1[i-1]) && UP(s1[i+1]) && s1[i-1] < s1[i+1]-1) ||
          (LO(s1[i-1]) && LO(s1[i+1]) && s1[i-1] < s1[i+1]-1) ||
          (NU(s1[i-1]) && NU(s1[i+1]) && s1[i-1] < s1[i+1]-1))) {
      temp = s1[i-1]+1;
      while (temp < s1[i+1]) {
        s2[j++] = temp++;
      }
      continue;
    }
    s2[j++] = s1[i];                                            /* didn't hit any 'continue's */
  }
  s2[j] = '\0';
  return 1;
}

// mine
int check( char a, char b )
{
  // do not support 'z-a-' and this outputs 'a-'
  // if( (isalpha(a) && isalpha(b)) || (isdigit(a) && isdigit(b)) )
  //   return 1;

  if( (isalpha(a) && isalpha(b)) && (a <= b) )
    return 1;

  if( (isdigit(a) && isdigit(b)) && (a <= b) )
    return 1;

  return 0;
}

void expand( const char s1[], char s2[] )
{
  // a-a
  // a-!
  // a-z
  // aa-z
  // a-9
  // a- a-z
  // ---a
  // a-z0-9
  // a-c-f
  // a-0-8 -> 012345678
  // -a-z
  // so "a-" is a signal to check

  // <outline-second>
  // while( s1 is not null )
  // {
  //    // a-z, a-z0-9, a-b-d,
  //    if( s1 is alphabet or number AND s1+1 is - )
  //    {
  //      // check if it is valid token; alpha and alpha or number and number
  //      if(check(s1,s1+2)) // valid
  //      {
  //        for(char first = s1[]; first <= s1+2; )
  //        {
  //          copy first; s2++; first +=1;
  //        }
  //      }
  //      else
  //        copy s1, s1+1 to S2; // 'a-'
  //        s1 += s1+2; // move two
  //    }
  //    else // handles all invaild cases including a leading or trailing - is taken literally
  //    {
  //      copy s1 to s2;
  //      s1++;
  //    }
  //
  //  } // while end

  while( *s1 )
  {
    if( isalnum(*s1) && (*(s1+1) == '-' ) )
    {
      if( check( *s1, *(s1+2)) )
      {
        for( char start = *s1; start < *(s1+2); start +=1 )
          *s2++ = start;

        s1 += 2;
      }
      else
      {
        *s2++ = *s1++;
        *s2++ = *s1++;
      }
    }
    else
    {
      *s2++ = *s1++;
    }
  } // while end

  // note that missed this in the first place
  *s2 = '\0';
}

int main(int argc, char* argv[])
{
  const char *s[] = {   // <pointers-to-pointers>
    "a-z-", 
    "z-a-", 
    "-1-6-",
    "a-ee-a", 
    "a-R-L", 
    "1-9-1",
    "5-5", 
    "C-Y", 
    "a-z0-9", 
    NULL };

  // one
  {
    char result[100]={0};
    int i = 0;

    printf("=============\n");

    while ( s[i] ) {

      /*  Expand and print the next string in our array s[]  */
      expand_online(s[i], result, 99);
      printf("Unexpanded: %s\n", s[i]);
      printf("Expanded  : %s\n", result);
      ++i;
    }
  }

  // two
  {
    char result[100]={0};
    int i = 0;

    printf("=============\n");

    while ( s[i] ) {

      /*  Expand and print the next string in our array s[]  */
      expand(s[i], result);
      printf("Unexpanded: %s\n", s[i]);
      printf("Expanded  : %s\n", result);
      ++i;
    }
  }

  return 0;
} 

Q: //how will the input 5-5-5 can be handled ? will it output to "555" or "55" or "5" ? 

$ ./a.out 
=============
Unexpanded: a-z-
Expanded  : abcdefghijklmnopqrstuvwxyz-
Unexpanded: z-a-
Expanded  : z-a-
Unexpanded: -1-6-
Expanded  : -123456-
Unexpanded: a-ee-a
Expanded  : abcdee-a
Unexpanded: a-R-L
Expanded  : a-R-L
Unexpanded: 1-9-1
Expanded  : 123456789-1
Unexpanded: 5-5
Expanded  : 5-5
Unexpanded: C-Y
Expanded  : CDEFGHIJKLMNOPQRSTUVWXY
Unexpanded: a-z0-9
Expanded  : abcdefghijklmnopqrstuvwxyz0123456789
=============
Unexpanded: a-z-
Expanded  : abcdefghijklmnopqrstuvwxyz-
Unexpanded: z-a-
Expanded  : z-a-
Unexpanded: -1-6-
Expanded  : -123456-
Unexpanded: a-ee-a
Expanded  : abcdee-a
Unexpanded: a-R-L
Expanded  : a-R-L
Unexpanded: 1-9-1
Expanded  : 123456789-1
Unexpanded: 5-5
Expanded  : 5
Unexpanded: C-Y
Expanded  : CDEFGHIJKLMNOPQRSTUVWXY
Unexpanded: a-z0-9
Expanded  : abcdefghijklmnopqrstuvwxyz0123456789


<ex>

// from stl
find(const char_type* __s, std::size_t __n, const char_type& __a)
{
  for (std::size_t __i = 0; __i < __n; ++__i)
    if (eq(__s[__i], __a))
      return __s + __i;
  return 0;
}

// from EXCPC++ p6
find(const char* s, int n, char a)
{
  while(n-- > 0 & toupper(*s) != toupper(a))
  {
    ++s;
  }

  return n >= 0 : s : 0;
}


{cxx-operator-comma} *cxx-side-effect*
The comma operator is a sequence point (as they are && and ||) so the order of
evaluation of the operands is 'fixed'. It is a binary operator that evaluates
its first operand, performs all side effects and discards the result, and then
evaluates the second operand and returns its value.

Any number of expressions separated by commas can form a single expression
because the comma operator is associative. 

The use of the comma operator guarantees that the sub-expressions will be
evaluated in `left-to-right` order, and the value of the last becomes the
value of the entire expression:

x = (y, z);

will do y and, after performing all `side effects`, will discard it, then do z
and finally will set x to z.

Because the comma operator discards its first operand, it is useful where the
first operand has `desirable side effects`, such as in the initializer or the
counting expression of a for loop. Used `to produce side effects.`

For example, this for statement:

for (p=0; p+=(a&1)*b, a!=1; a>>=1, b<<=1)
   ...

can be re-written:

p=0;
p+=(a&1)*b;          // see
while (a!=1) {
    ...
    a>>=1;
    b<<=1;
    p+=(a&1)*b;      // see
}

The primary use of the comma operator is `to produce side effects` in the
following situations:

Calling a function
Entering or repeating an iteration loop
Testing a condition
Other situations where a side effect is required but the result of the
expression is not immediately needed

for (i=0; i<2; ++i, f() );

A for statement in which i is incremented and f() is called at each iteration.

if ( f(), ++i, i>1 ) { /* ... */ } 

An if statement in which function f() is called, variable i is incremented,
   and variable i is tested against a value. The first two expressions within
   this comma expression are evaluated before the expression i>1. Regardless
   of the results of the first two expressions, the third is evaluated and its
   result determines whether the if statement is processed.

func( ( ++a, f(a) ) ); 

A function call to func() in which a is incremented, the resulting value is
passed to a function f(), and the return value of f() is passed to func(). The
function func() is passed only a single argument, because the comma expression
is enclosed in parentheses within the function argument list.


{control-break-continue}
<ex> *ex-trim* 
from ansic, p65. Remove trailing blanks, tabs, newlines.

int trim( char s[] )
{
  int n;

  // see `strlen(s)-1`
  for(n = strlen(s)-1; n > 0; n--)
    if( s[n] != ' ' && s[n] != '\t' && s[n] != '\n' )
      break;

  s[n+1] = '\0';
  return n;
}

Sacn backwards looking for the first character that is not a blank, tab or
newline. May perform better than searching from the beginning.

note:
negative or positive in ascii?

for( i = 0; i < n; i++ )
{
  // skip negative elements
  if( a[i] < 0 )
    continue;

  // do positive elements
}


{control-goto}
From ansic, p66, this is handy if the error handling is `nontrivial` and can
occur in several places.

for( ... )
  for( ... )
  {
    ...

    if(disaster)
      goto error:
  }
...

error:
   clean up the mess

The goto can always be written without one.

for( i = 0; i < n; i++ )
   for( j = 0; j < m; j++ )
      if( a[i] == b[j] )
         goto found;          // how about return

// didn't find any common elements

found:
  // got one


found = 0;
for( i = 0; i < n && !found; i++ )     // note !found <goto-alternative>
   for( j = 0; j < m && !found; j++ )
      if( a[i] == b[j] )
         found = 1;

if(found)
  // got one
else
  ...
  // didn't find any common elements


<ex>
  
template <typename _Iterator, typename _Compare>
_Iterator my_partition_02(_Iterator begin, _Iterator end, _Compare comp)
{
  // find the start of unmatched(unsorted) sub group

  _Iterator start_of_unmatched = begin;
  while (comp(*start_of_unmatched))
    if (++start_of_unmatched == end)
      return start_of_unmatched;

  cout << "s: " << *start_of_unmatched << endl;

  _Iterator run = start_of_unmatched;
  while (++run != end)
  {
    // if item matches to condition
    if (comp(*run))
    {
      std::iter_swap(run, start_of_unmatched);
      ++start_of_unmatched;
    }
  }

  return start_of_unmatched;
}

template <typename _Iterator, typename _Compare>
_Iterator my_partition_02_x(_Iterator begin, _Iterator end, _Compare comp)
{
  // find the start of unmatched(unsorted) sub group

  _Iterator start_of_unmatched = begin;
  while (comp(*start_of_unmatched++))
    if (start_of_unmatched == end)
      return start_of_unmatched;

  // `6` but not `43`
  cout << "s: " << *start_of_unmatched << endl;

  _Iterator run = start_of_unmatched;
  while (++run != end)
  {
    // if item matches to condition
    if (comp(*run))
    {
      std::iter_swap(run, start_of_unmatched);
      ++start_of_unmatched;
    }
  }

  return start_of_unmatched;
}

TEST(AlgoMutating, AlgoPartition)
{
  // pass
  {
    vector<unsigned int> coll{43,6,11,42,29,23,21,19,34,37,48,24,15,20,13,26,41,30,6,23};

    auto iter = my_partition_02(coll.begin(), coll.end(), 
        [](unsigned int value)
        { return value <= 25; }
        );

    EXPECT_THAT(coll, 
        ElementsAreArray({6,11,23,21,19,24,15,20,13,6,23,43,42,29,34,26,41,30,37,48}));
    EXPECT_THAT(distance(coll.begin(), iter), 11);
    EXPECT_THAT(*iter, 43);
  }

  // fail 
  {
    vector<unsigned int> coll{43,6,11,42,29,23,21,19,34,37,48,24,15,20,13,26,41,30,6,23};

    auto iter = my_partition_02_x(coll.begin(), coll.end(), 
        [](unsigned int value)
        { return value <= 25; }
        );

    // { 6,11,23,21,19,24,15,20,13,6,23,43,42,29,34,26,41,30,37,48}));
    //                                  ^^
    // {43,11,23,21,19,24,15,20,13,6,23, 6,42,29,34,26,41,30,37,48}));
    
    // EXPECT_THAT(coll, 
    //     ElementsAreArray({6,11,23,21,19,24,15,20,13,6,23,43,42,29,34,26,41,30,37,48}));

    EXPECT_THAT(coll, 
         ElementsAreArray({43,11,23,21,19,24,15,20,13,6,23,6,42,29,34,26,41,30,37,48}));

    EXPECT_THAT(distance(coll.begin(), iter), 11);
    EXPECT_THAT(*iter, 43);
  }


={============================================================================
*kt_dev_cxx_0000* cxx-precedence

http://en.cppreference.com/w/cpp/language/operator_precedence

From CPR 4.12 P166.

The following table lists the precedence and associativity of C++ operators.
Operators are listed top to bottom, in descending precedence. Where no
associativity follows the above one and same precedence in each segment. 

Precedence Operator, Description, Use, Associativity, (L)eft-to-right

 ::               global scope                  ::name                      L
                  class                         class::name
                  namespace                     namespace::name
 ----------------------------------------------------------------------------
 .                member selector               object.member               L
 ->               member selector               pointer->member
 []               subscript                     expr[ expr ]
 ()               function call                 name( expr_list )
 ()               type construction             type( expr_list )
 ----------------------------------------------------------------------------
 ++               post increment                lvalue++                    R
 --               post decrement                lvalue++
 typeid           type ID                       typeid(type)
 explicit cast    type conversion               cast_name<type> expr
 ----------------------------------------------------------------------------
 ++               pre increment                 ++lvalue++                  R
 --               pre decrement                 --lvalue++
 ~                'bitwise' not                   ~expr
 !                logical not                   !expr
 -                unary minus                   -expr
 +                unary plus                    +expr
 *                `dereference`                   *expr
 (TODO)

 ----------------------------------------------------------------------------
 *                multiply                      expr * expr                 L
 /                divide                        expr / expr
 %                modulo(remainder)             expr % expr
 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------
 ==               equality                      expr == expr                L
 !=               ineuality
 ----------------------------------------------------------------------------

 ----------------------------------------------------------------------------
 =                assignment                    lvalue = expr               R 

 ----------------------------------------------------------------------------
 ,                comma                         expr, expr                  L


{io-operators}

CPR p155.

The IO operators are `overloaded-version` of shift operators for IO. An
overloaded operator has the `same-precedence-and-associativity` as the built-in
version of that operator and has `left-associative`.

cout << "hi" << " there" << endl;

executes as

((cout << "hi") << " there") << endl;


={============================================================================
*kt_dev_cxx_0000* cxx-evaluation-order

CPR 135

An expression with two or more operators is a `compound-expression`. Evaluating
compound expression involves `grouping` the operand to the operators.

The value of an expression depends on how the subexpressions are grouped.

`cxx-precedence` and `cxx-associativity` determine how the operands are grouped.
That is, they determine which parts of the expression are the operands for each
of the operators in the expression. `associativity` determines how to group
operands with the same `precedence`

Users can override these rules by parenthesizing to force a particular grouping
as a subexpression.

However, `precedence` says nothing about the order in which the operands are
evaluated. `order-of-operand-evaluation`.

<ex>
6 + 3 * 4 / 2 + 2;

equivalent to:

((6 + ((3 * 4) / 2)) + 2);

Can think that `inner-group` is evaluated first even if the evaluation order in
that group is unspecified? NO when involves `evaluation`


CPR p138.

<cxx-evaluation-order> *cxx-undefined*
The `order-of-operand-evaluation` is `independent` of `precedence` and
`associativity`.

f() + g() * h() + j();

* `precedence` gurantees that the results of g() and h() are multiplied.

* `associativity` guarantees that the result of f() is added to the product of
  g() and h() and that the result of that addition is added to the value of j().

* However, NO guarantees as to the order in which these functions are called.

In other words, for operators that do not specify evaluation order, it is an
`cxx-undefined` for an expression to refer to and change the same object. 

note: in gcc, calls f, g, h, and j in order


{cxx-shortcut-evaluation} *cxx-operator-logical*
when the first argument of the AND function evaluates to false, the overall
value must be false; and when the first argument of the OR function evaluates to
true, the overall value must be true.

the logical AND(&&) operator guarantees that its lhs operand is evaluated first.

{
  // check if time of entry is <= than rhs. 
  // have to be less in seconds and then check on nano seconds.

  bool checkLessThanOrEqualTo(struct timespec const &rhs) const
  {
    return (expiry.tv_sec < rhs.tv_sec) ||
      ((expiry.tv_sec == rhs.tv_sec) && (expiry.tv_nsec <= rhs.tv_nsec));
  }
}


{

  // that is, only when timerfd is still valid, close it and if close is a
  // success then return 0 so the final evaluation value is 0.

  if ((timer_fd_ >= 0) && (close(timer_fd_)) != 0)
    LOG_MSG("failed to close timerfd");
}


<ex>
cout << i << " " << ++i << endl;

((((cout << i) << " " ) << ++i) << endl);     // `cxx-undefined`


<ex> EXC++47

return string("size = ") + itoa(size_, buf, 10) +
  ", used = " + itoa(used_, buf, 10);

this really amouts to:

return 
  operator+(
      operator+(operator+(string("size = ") + itoa(size_, buf, 10)),", used = "),
      itoa(used_, buf, 10)
      );

Say size_ is 10 and used_ is 5. the problem is that both uses the same buf
which is overwritten depending on the order.

// when outer opearator+()'s first parameter is evalueated first and that's
// stored in temporary string before the second itoa reuses the buffer.
size = 10, used = 5       

// when outer opearator+()'s second parameter is evalueated first and inner
// itoa will clobber the result of the outer itoa before either value is used.
size = 10, used = 10


<ex> ansic, p53. 
C do not specify the 'order' in which the operands of an operator are
evaluated. 

x = f() + g();    // f may be evaluated before g or vice versa

Function calls, nested assignment statements, and increment and decrement
operators cause *cxx-side-effect* - some variable is changed as a by-product
of the `evaluation` of an expression. In any expression involving side
effects, there can be subtle dependencies on the 'order' in which variables
taking part in the expression are updated.

printf("%d %d\n", ++n, power(2, n));   // WRONG this is not a comma operator

a[i] = i++;

`When side effects take place` is left to `discretion` of the compiler, since
the best order depends strongly on machine architecture.


<gcc-warning>

-Wsequence-point

Warn about code that may have undefined semantics because of violations of
sequence point rules in the C and C++ standards.

The C and C++ standards define the order in which expressions in a C/C++ program
are evaluated in terms of sequence points, which represent a partial ordering
between the execution of parts of the program: those executed before the
sequence point, and those executed after it. 

These occur after the evaluation of a full expression (one which is not part of
    a larger expression), 
      
`after the evaluation of the first operand of a &&, ||, ? : or , (comma) operator`, 
before a function is called (but after the evaluation of its arguments and the
    expression denoting the called function), and in certain other places. 
        
Other than as expressed by the sequence point rules, the order of evaluation of
subexpressions of an expression is `not specified.` All these rules describe only
a partial order rather than a total order, since, for example, if two functions
are called within one expression with no sequence point between them, the order
in which the functions are called is not specified. However, the standards
committee have ruled that function calls do not overlap.

It is not specified when between sequence points modifications to the values of
objects take effect. Programs whose behavior depends on this have undefined
behavior; the C and C++ standards specify that “Between the previous and next
sequence point an object shall have its stored value modified at most once by
the evaluation of an expression. Furthermore, the prior value shall be read only
to determine the value to be stored.”. If a program breaks these rules, the
results on any particular implementation are entirely unpredictable.

Examples of code with undefined behavior are 

a = a++; 
a[n] = b[n++]
a[i++] = i;

Some more complicated cases are not diagnosed by this option, and it may give an
  occasional false positive result, but in general it has been found fairly
  effective at detecting this sort of problem in programs.

  The C++17 standard will define the order of evaluation of operands in more
  cases: in particular it requires that the right-hand side of an assignment be
  evaluated before the left-hand side, so the above examples are no longer
  undefined. But this warning will still warn about them, to help people avoid
  writing code that is undefined in C and earlier revisions of C++.

The standard is worded confusingly, therefore there is some debate over the
precise meaning of the sequence point rules in subtle cases. Links to
discussions of the problem, including proposed formal definitions, may be found
on the GCC readings page, at http://gcc.gnu.org/readings.html.

This warning is enabled by -Wall for C and C++.

<ex>
    auto i = buf_.find_last_of(" \f\n\r\t\v");
    i = (i == string::npos) ? 0 : ++i;

    .cpp:1991:7: warning: operation on ‘i’ may be undefined [-Wsequence-point]
     i = (i == string::npos) ? 0 : ++i;
     ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To fix:

    auto x = buf_.find_last_of(" \f\n\r\t\v");
    auto i = (x == string::npos) ? 0 : ++x;


<ex> EXC++47

int f (int & x, int y = 1) { return x += y; }
int g (int & x) { return x /= 2; }

int main()
{
    int i = 42;

    // f(43) = 43
    // g(21) = 21

    cout << "f(" << i << ") = " << f(i) << endl;
    cout << "g(" << i << ") = " << g(i) << endl;

    // both function modifies its argument and in this case, g() runs first and
    // then f().
    // f(22) = 22, g(21) = 21

    cout << "f(" << i << ") = " << f(i) << ", "
        << "g(" << i << ") = " << g(i) << endl;
}


<ex>
while (fgets(line, 256, file))
{
  sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], 
      &Highs[i], &Lows[i++]);
}


<ex> see reverse polish calculator
The + and * are commutative operators, the order in which the popped operands
are combined is irrelevant, but for - and / the left and right operands must
be distinguished.

push( pop() - pop () );

This is wrong since the order in which the two calls of pop are evaluated is
not 'defined'.


={============================================================================
*kt_dev_lang_016* expr-unary

The unary negation operator ! converts a non-zero operand into 0 and a zero
operand into 1. A common use of ! is in constructions like:

if(!valid) rather then if(valid==0)

<ex>
From ansic, exercise 2-2. Write a loop equivalent to the for loop above without
using && or ||.

for(i=0; i<lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
   s[i] = c;

// 01

while (i < (lim - 1))
{
  c = getchar();

  if (c == EOF)
    break;
  else if (c == '\n')
    break;

  s[i++] = c;
}

// 02

for(i=0; i<lim-1 ? (c=getchar()) != '\n' ? c != EOF : 0 : 0; ++i)
   s[i] = c;


={============================================================================
*kt_dev_lang_016* expr-assign

The operator "+=" is called `assignment operator` and most binary operators have
a corresponding assignment operator "op=", where op is + - * / % << >> & ^ |.

note: 
that "expr1 op= expr2" is equivalent to "expr1 = (expr1) op (expr2)" and notice
that () around expr since:

x *= y + 1; means x = x * ( y + 1 ); rather than x = x * y + 1;

note:
that assignment statement, c = getchar(), and the 'type' of an assignement
  expression is the type of its left operand in case of assignement operator.
  The point is that expresssion has a 'type'.

note:
The "&~" is not `assignment opearator` since do not have `=`. No such an
operator and turns out "x & ~y".


={============================================================================
*kt_dev_cxx_0000* cxx-op-conditional (the ?: operator)

CPR 4.7 151. The conditional operator(the ?: operator):

  `cond` ? `expr1` : `expr2`;

  * often leads to 'succint' code.
  * embed simple if-else logic inside an expression.
  * `cond` is an expression used as a condition.
  * guarantees that only one of expr1 or expr2 is evaluated.

<ex>
Prints newline after every 10th element and after n-th and blank for all other
elements.

for( i = 0; i < n; i++ )
   printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ' );

printf("You have %d item%s.\n", n, n==1 ? "" : "s" );

<ex> *ex-lower* 
ansic, page 52, exercise 2-10. 
Rewrite the function lower, which converts upper case letters to lower case with
a conditional expression instead of if-else.

int lower(int c);

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_10

ASCII:
  65, 0x41, A (uppercase)
  ...
  97, 0x61, a (lowercase)
  ...

int lower(int c)
{
  return c >= 'A' && c <= 'Z' ? c + 'a' - 'A' : c;
}

note: 
Why ASCII only? This seems to works for ASCII and EBCDIC since both has constant
offset for alphabet chars and sequential values for numbers.

<ex>
Use the same idea but more 'portable' solution since do not depend on the order
of key codes. 

int lower(int c)
{
  char *Uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char *Lowercase = "abcdefghijklmnopqrstuvwxyz";
  char *p = NULL;

  return NULL == (p = strchr(Uppercase, c)) ? c : *(Lowercase + (p - Uppercase));
}

char *strchr(const char *s, int c);
returns a pointer to the 'first' occurrence of the character c in the string s


{same-type}
The `expr1` and `expr2` are the 'same' type or types that can be converted to a
common type.

<ex>
int cond = 0;
printf("this is char %s\n", cond ? "ture" : cond );

C: warning: pointer/integer type mismatch in conditional expression [enabled by default]
C++: error: operands to ?: have different types ‘const char*’ and ‘int’


{nested}
Nest one conditional operator inside another. This is three-way test. 

note: the nested quickly become unreadable so good idea to nest no more than two
or three.

string finalgrade = (grade < 60) ? "fail" : "pass";

string finalgrade = (grade > 90) ? "high pass" 
                                 : (grade < 60) ? "fail" : "pass";

<ex>
int currentTime =
    presentationTime < bufPos.first ? bufPos.first :
    presentationTime > bufPos.second ? bufPos.second :
    presentationTime;

if(presentationTime < bufPos.first)
    currentTime = bufPos.first;
else if (presentationTime > bufPos.second)
    currentTime = bufPos.second;
else
    currentTime = presentationTime;


{low-precedence}
Has fairly low precedence so usually must parenthesize the conditional
subexpression.

cout << ((grade < 60) ? "fail" : "pass");     // okay
cout << (grade < 60) ? "fail" : "pass";       // prints 1 or 0
cout << grade < 60 ? "fail" : "pass");        // error


={============================================================================
*kt_dev_cxx_0000* cxx-code-style

https://google.github.io/styleguide/cppguide.html

Use common sense and BE CONSISTENT.

If you are editing code, take a few minutes to look at the code around you and
determine its style. If they use spaces around their if clauses, you should,
too. If their comments have little boxes of stars around them, make your
comments have little boxes of stars around them too.


General Naming Rules
---------------
Names should be descriptive; avoid abbreviation.

Note that certain universally-known abbreviations are OK, such as i for an
iteration variable and T for a template parameter.

int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
int lstm_size;             // "LSTM" is a common machine learning abbreviation.

NOTE about _ and __

From the 2003 C++ Standard:

17.4.3.2.1 Global names [lib.global.names]

Certain sets of names and function signatures are always reserved to the
implementation:

Each name that contains a double underscore (__) or begins with an underscore
followed by an uppercase letter (2.11) is reserved to the implementation for
any use.  

Each name that begins with an underscore is reserved to the implementation for
use as a name in the global namespace.165

165) Such names are also reserved in namespace ::std (17.4.3.1).

C++P 2.3.3
The standard also reserves a set of names for use in the standard library. May
not contain two consecutive underscores, nor can an identifier begin with an
underscore followed immediately by an uppercase letter.


File Names
---------------
If there is no consistent local pattern to follow, prefer "_".

my_useful_class.cc
myusefulclass_test.cc

A very common case is to have a pair of files called, e.g., foo_bar.h and
foo_bar.cc, defining a class called FooBar.


Type Names, Function Names
---------------
Type names start with a capital letter and have a capital letter for each new
word, with no underscores: MyExcitingClass, MyExcitingEnum.

The names of all types  classes, structs, type aliases, enums, and type
template parameters  have the same naming convention. Type names should start
with a capital letter and have a capital letter for each new word. No
underscores. For example:

// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, string>;

// enums
enum UrlTableErrors { ...


*cxx-code-style*

Variable Names, `Namespace` Names, Instance Names, Function Parameters
---------------
The names of variables (including function parameters) and data members are
all lowercase, with underscores between words.

string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.


Class Data Members
are named like ordinary nonmember variables, but with a trailing underscore.

class TableInfo {
  ...
 private:
  string table_name_;             // OK - underscore at end.
  string tablename_;              // OK.
  static Pool<TableInfo>* pool_;  // OK.
};


note:
From CC:

* it's most prominent and gets read first
* to express what rather then the how

revenueTotal;     revenue_total;
expenseTotal;     expense_total;
recordTotal;      record_total;

`x of y` consideration?

area_code_length;
local_number_length;
number_month_in_years;      // number of monthes
month_number_in_years;      // month number


note:
document.Print() or document.PrintDocument()?

customerId.Next();  or customer.GetNextCustomerId()
printer.Ready();
pen.CurrentColor();

In OOP, document.PrintDocument() is redundant and become inaccurate when used
to derived class. Important to have descriptive instance name. 


Constant Names, Enumerator Names
---------------
Variables declared constexpr or const, and whose value is fixed for the
duration of the program, are named with a leading "k" followed by mixed case.

Enumerators (for both scoped and unscoped enums) should be named either like
constants or like macros: either kEnumName or ENUM_NAME.

enum UrlTableErrors {
  kOK = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};

enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};

TODO: Which one? Use macro style for now.


Comments
---------------
// is much more common
Do not state the obvious.

<words-about-comment> CPR 1.3
An 'incorrect' comment is worse than no comment at all.

// Find the element in the vector.  <-- Bad: obvious!

auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}

To this:

// Process "element" unless it was already processed.
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}

Self-describing code doesn't need a comment. The comment from the example
above would be obvious:

if (!IsAlreadyProcessed(element)) {
  Process(element);
}

If having multiple arguments in a single line decreases readability due to the
complexity or confusing nature of the expressions that make up some arguments,
try creating variables that capture those arguments in a descriptive name:

int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);


Formatting
---------------
Each line of text in your code should be at most 80 characters long.

Use only spaces, and indent 2 spaces at a time.

ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}


Conditionals
---------------

if (condition) {  // Good - proper space after IF and before {.


Pointer and Reference Expressions
---------------
It is allowed (if unusual) to declare multiple variables in the same
declaration, but it is disallowed if any of those have pointer or reference
decorations. Such declarations are easily misread.

int x, *y;  // Disallowed - no & or * in multiple declaration

// CPR 2.3.3
// 
// declaration = base type + declarators
//               int         *p;
// 
// There are two style choices:
// Foo *msg1, *msg2;
// Foo* msg1, *msg2;


Namespace Formatting
---------------
Namespaces do not add an extra level of indentation


<ex> why formatting matter

This shows how spaces can changes its reading. Taken from stl code which uses
tabs and tabstops 2. For this example, changes tab to space to show the point.

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
      return 0;
    }

Does this compare function run for loop only once? When changes tabstop, it is
  clear now.

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (lt(__s1[__i], __s2[__i]))
          return -1;
        else if (lt(__s2[__i], __s1[__i]))
          return 1;
      return 0;
    }


<ex>
Search through "last-current_" as a variable which do not exist and wondered
it for long. 

  char *next_line = (char*)internal_memchr(current_, '\n', last-current_);

This is not variable after all.

  char *next_line = (char*)internal_memchr(current_, '\n', last - current_);


<cxx-code-style-header>

Names and Order of Includes
---------------
In dir/foo.cc or dir/foo_test.cc, whose main purpose is to implement or test
the stuff in dir2/foo2.h, order your includes as follows:

1. dir2/foo2.h.
2. A blank line
3. C system files.
4. C++ system files.
5. A blank line
6. Other libraries' .h files.
7. Your project's .h files.

With the preferred ordering, if dir2/foo2.h omits any necessary includes, the
build of dir/foo.cc or dir/foo_test.cc will break. Thus, this rule ensures
that build breaks show up first for the people working on these files, not for
innocent people in other packages.

Within each section the includes should be ordered alphabetically.

For example, the includes in
google-awesome-project/src/foo/internal/fooserver.cc

#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"

<ex> other exmple

Included headers ordering but I think a nice and consistent way of including
them is as all alphabetically in each group:

local project headers
3PS library headers
OS specific headers
standard headers


<cxx-code-style-header-guard> *cxx-header-guard*

2.4 Once-Only Headers

If a header file happens to be included twice, the compiler will process its
contents twice. This is very likely to cause an error, e.g. when the compiler
sees the same `structure definition` twice. Even if it does not, it will
certainly waste time.

The standard way to prevent this is to enclose the entire real contents of the
file in a conditional, like this:

     /* File foo.  */
     #ifndef FILE_FOO_SEEN
     #define FILE_FOO_SEEN
     
     the entire file
     
     #endif /* !FILE_FOO_SEEN */

This construct is commonly known as a "wrapper #ifndef". When the header is
included again, the conditional will be false, because FILE_FOO_SEEN is
defined. The preprocessor will skip over the entire contents of the file, and
the compiler will not see it twice.

In a user header file, the macro name `should not begin with` '_'. In a system
header file, it should begin with '__' to avoid conflicts with user
programs. In any kind of header file, the macro name should contain the name
of the file and some additional text, to avoid conflicts with other header
files.  

http://www.learncpp.com/cpp-tutorial/1-10a-header-guards/

<ex> when not use guard

// #ifndef __GEOSERVER_H__
// #define __GEOSERVER_H__

class GeoServer
{
  // has only function declaration
};

// #endif // __GEOSERVER_H__


In file included from geoserver_test.cpp:3:0:
geoserver.h:13:7: error: `redefinition` of ‘class GeoServer’
 class GeoServer
       ^
In file included from geoserver_test.cpp:2:0:
geoserver.h:13:7: error: previous definition of ‘class GeoServer’
 class GeoServer
       ^


={============================================================================
*kt_dev_cxx_0000* cxx-code-style-bracing-allman

{style-allman}
The Allman style is named after Eric Allman. It has been incorrectly referred
to as "ANSI style" supposedly for its use in the documents describing the ANSI
C standard; later adopted as the ISO C international standard, though in fact
those documents use K&R style. It is also sometimes known as "BSD style" since
Allman wrote many of the utilities for BSD Unix although this should not be
confused with the different "BSD KNF style"; see below.

  "This style puts the brace associated with a control statement on the next
  line, indented to the same level as the control statement. Statements within
  the braces are indented to the next level."

while (x == y)
{
    something();
    somethingelse();
}
 

Suggested advantages of this style are that the indented code is clearly set
apart from the containing statement by lines that are almost completely
whitespace and the closing brace lines up in the same column as the opening
brace. Some people feel this makes it easy to find matching braces.
Additionally, the blocking style delineates the actual block of code from the
associated control statement itself. 

Commenting out the control statement, removing the control statement entirely,
           refactoring, or removing of the block of code is less likely to
           introduce syntax errors because of dangling or missing braces.
           Furthermore, it's consistent with brace placement for the
           outer/function block.

Even like this, with conditional compilation:

char c;
#ifdef HAS_GETCH
while ((c = getch()) != EOF)
#else
while ((c = getchar()) != EOF)
#endif
{
    do_something(c);
}


  "No spaces immediately after opening parenthesis nor before closing
  parenthesis. Place a space before the opening parenthesis."

The else/else if keywords belong on a new line. Always use block bracing even
for single line blocks.

if (a == b)
{
    foo = bar;
    boz = jabber;
}
else if (c == d)
{
    foo = jabber;
}
else
{
    boz = baz;
}

<ex>
string FindAddr( list<Employee> emps, string name )
{
  for( list<Employee>::iterator i = emps.begin();
      i != emps.end();
      i++ )
  {
    if( *i == name )
    {
      return i->addr;
    }
  }
  return "";
}


string FindAddr (list<Employee> emps, string name)
{
  for (list<Employee>::iterator i = emps.begin();
      i != emps.end();
      i++)
  {
    if (*i == name)
    {
      return i->addr;
    }
  }
  return "";
}


{k-and-r-style}
The K&R style, so named because it was used in Kernighan and Ritchie's book
The C Programming Language, is commonly used in C. It is also used for C++,
    C#, and other curly brace programming languages.

When adhering to K&R, each function has its opening brace at the next line on
the same indentation level as its header, the statements within the braces are
indented, and the closing brace at the end is on the same indentation level as
the header of the function at a line of its own. The blocks inside a function,
    however, have their opening braces at the same line as their respective
    control statements; closing braces remain in a line of their own, unless
    followed by an else or while keyword.

In this style a control statement with only a single statement in its scope
may omit the braces. The C Programming Language refers to this as fertile soil
for bugs (programming logical errors) and discourages it.

int main(int argc, char *argv[])
{
    ...
    while (x == y) {
        something();
        somethingelse();
 
        if (some_error) {
            /* the curly braces around this code block could be omitted */
            do_correct();
        } else
            continue_as_usual();
    }
 
    finalthing();
    ...
}


={============================================================================
*kt_dev_cxx_0000* cxx-code-deep-nested-if

CodeComplete 17.1

the problem of deep nested if

<ex> from real code

SYSTEM_STATUS SPM_API_Network_GetMainStatus(SPM_API_Network_MainStatus *l_value)
{
  SYSTEM_STATUS status = SPM_API_STATUS_ERROR;

  f_syncContextNetworkReady.timeout = spm_config->main_and_ethernet_status_timeout;

  /* check if the ClientId is arrived...if not wait */
  if (SPM_CLIENT_MSG_waitForClientId() != SPM_API_STATUS_OK)
  {
    // error case

    SPM_CLIENT_DIAG_LOG_ERROR(("Error in acquiring the Client Id"));
  }
  /* Wait for network to become ready */
  else if(SPM_CLIENT_MSG_waitForServerEvent(&f_syncContextNetworkReady, false) 
      != SPM_API_STATUS_OK)  /* wait only if needed */
  {
    // error case

    SPM_CLIENT_DIAG_LOG_WARN(("Returning default main status SPM_API_NETWORK_MAIN_CONFIG_UNSET"));
    *l_value = SPM_API_NETWORK_MAIN_CONFIG_UNSET;
    status = SPM_API_STATUS_OK;
  }
  else
  {
    // norminal(normal) case

    message.event = SPM_CLIENT2SERVER_EVENT_NETWORK_GET_MAIN_STATUS;
    if (SPM_CLIENT_MSG_waitForServer(&f_syncContextServer, &message ) 
        != SPM_API_STATUS_OK)
    {
      // error case

      SPM_CLIENT_DIAG_LOG_ERROR(("SPM_CLIENT_MSG_waitForServer failed"));
    }
    else
    {
      // norminal case

      (void)SYSTEMUTIL_THR_MutexLock(&f_SPM_Network_StaticData_mutex);

      *l_value = f_main_status;
      status = f_syncContextServer.lastResponse;
      SPM_CLIENT_DIAG_LOG_INFO(("Returning main status = 0x%X, result of function = 0x%X", 
            f_main_status, status));

      (void)SYSTEMUTIL_THR_MutexUnlock(&f_SPM_Network_StaticData_mutex);
    }
  }

  return status;
}


# ============================================================================
#{ CXX
={============================================================================
*kt_dev_cxx_0000* cxx-reference

<cxx-core-guideline>
http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
https://github.com/CppKorea/CppCoreGuidelines
https://github.com/Microsoft/GSL


{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

RDP, design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

RCPR, C++ primer, 5th Ed.
http://www.informit.com/store/c-plus-plus-primer-9780321714114


={============================================================================
*kt_dev_cxx_0000* cxx-oop

The key ideas in OOP are data abstraction, inheritance, and dynamic binding.

o `data-abstration` CPR 254 

Data Abstraction is a programming and design technique that relies on the
`separation of interface and implementation.` 

  o `encapsulation`
    `enforces the separation` of a class interface and implementation and
    hides its implementation. 

Class users need not know or care how the type actually works and can instead
think abstractly about what the type does. 


o `inheritance` 
Can define classes that `model the relationships` among similar types. 

Conceptually, neither the kind of device nor the character size affects the IO
operations we want to perform. For example, we would like to use >> to read data
regardless of whether we are reading a console window, a disk file, or a string.
Similarly, we would like to use that operator regardless of whether the
characters we read fit in a char or require a wchar_t.

The library lets us ignore the differences among these different kinds of
streams by using inheritance. As with templates, we can use classes related by
inheritance without understanding the details of how inheritance works.

inheritance lets us say that a particular class inherits from another class.
Ordinarily, we can use an object of an inherited class as if it were an object
of the same type as the class from which it inherits.

  o `cxx-dynamic-binding` 
    Use objects of these types while ignoring the details of how they differ.
    This is mechnism to make inheritance work along with virtual mechnism and
    object layout(subobject) scheme.


={============================================================================
*kt_dev_cxx_0000* cxx-ctor cxx-init-in-class-init

*cxx-synthesize*
There are operations synthesized by compiler if they are not defined by user
and `only if` they are needed. These are `public and inline` according to
EC++05.

dtor, default-ctor, 
*cxx-copy-control* : copy ctor and assign, move ctor and assign *cxx-11*


*cxx-deleted*
However, not always possible since there are cases when compiler cannot:

o When a class has reference or cxx-const member.
o When there's a class member that don't have default ctor.
o When base class have private on any of synthesized default-operations.


*cxx-ctor-default* default-initialization
The `default-ctor` is a special constructor which takes `no-arguments`.

The recommendation on initialization is to avoid syn-version and do it
explicitly:

`cxx-init-in-class-init` (C++11) or `ctor-init-list`


The reasons to avoid the syn-version:

o The `default-init` for built-in types means `undefined value.`

  The synthesised detault-ctor will use `cxx-in-class-init` if there is and
  otherwise `default-init` its member and use default ctor for its class
  member. So undefined value for built-in types and default constructed
  value for user types.

o Compile error when there's a class member that don't have default ctor since
  compiler cannot syn default ctor for this class.

o `If defines any other ctor for the class, the compiler do not generates`
  default ctor. So if a class requires control to init an object in one case,
  then the class is likely to require control in all cases.


<ex>

{
  class Base1
  {
  public:
    Base1(const std::string &name) { (void)name; }

  private:
    int value_;
  };
}

TEST(CxxCtor, show_default_ctor_is_necessary)
{
  // cause compile error
  // error: no matching function for call to ‘cxx_ctor::Base1::Base1()’
  //      Base1 o;
  // 
  // since:
  //
  // `If defines any other ctor for the class, the compiler do not generates`
  // default ctor. So if a class requires control to init an object in one case,
  // then the class is likely to require control in all cases.
  //
  // {
  //   using namespace cxx_ctor;
  //   Base1 o;
  // }

  {
    using namespace cxx_ctor;
    Base1 o("another ctor");
  }
}

That's why `default-ctor` is almost nearly required.

To see when syn versions are useful. see {make-base-class-for-reference-counting}


{cxx-default}

Again:

o `If defines any other ctor for the class, the compiler do not generates`
  default ctor. So if a class requires control to init an object in one case,
  then the class is likely to require control in all cases.

17.6 Generating Default Operations

By default, the compiler generates each of these operations if a program uses
it. However, if the programmer takes control by defining one or more of those
operations, the generation of related operations is suppressed:

o If the programmer declares any constructor for a class, the default
  constructor is not generated for that class.

o If the programmer declares a copy operation, a move operation, or a destructor
  for a class, no copy operation, move operation, or destructor is generated for
  that class.

Unfortunately, `the second rule is only incompletely enforced`: for backward
compatibility, copy constructors and copy assignments are generated even if a
destructor is defined. However, that generation is deprecated in the ISO
standard (§iso.D), and you should expect a modern compiler to warn against it.

If necessary, we can be explicit about which functions are generated (§17.6.1)
and which are not (§17.6.4).

To tell the compiler to create syn version for functions `but-not-limited` to
default ctor.

class Sales_data {
  public:
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data &);
    ~Sales_data() = default;
    ...
};


{cxx-ctor-const}
The ctor `cannot-be-const`. When create a const object of a class type, the
object does not assume its constness until after the ctor completes the
object's initialisation. Thus, ctor can write to const objects during their
construction.

Tried copy-ctor and compile error:

    FooFoo(const FooFoo& arg) const : foo()
    { cout << "FooFoo's copy ctor: " << endl; }

:38:31: error: constructors may not be cv-qualified


*cxx-init-inclass-init* *cxx-11* CPR 73 *cxx-default-arg*
in-class-init are `restricted as to the form`: must either be enclosed inside
curly braces or follow an = sign. May not specify an inclass-init inside
parentheses.

class Game
{
  public:

    // CardPlayer player1("this is player");
    //
    // t_string.cpp:53:23: error: expected identifier before string constant
    //      CardPlayer player("this is player");
    //                        ^
    // t_string.cpp:53:23: error: expected ‘,’ or ‘...’ before string constant
    
    CardPlayer player2{"this is player"};
    CardPlayer player3 = {"this is player"};
};


<ex>
class window_mgr {

  private:
    // to start up with a single, default-inited screen.
    vector<Screen> screens{ Screen(24, 80, ' ') };       // direct init form 
    vector<Screen> screens = { Screen(24, 80, ' ') };    // copy init form
};


<ex>
class T {
  T() = default;
  T(const string &s) : bookNo(s) {}
  ...
  string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

The `cxx-in-class-init` do like `cxx-default-arg` because:

T(const string &s) : bookNo(s) {}

is equivalent to:

T(const string &s) : bookNo(s), units_sole(0), revenue(0) {}

However, `cxx-in-class-init` is not the same as `cxx-default-arg`

T(const string &s, unsigned units = 0, double revenue = 0.0) 
  : bookNo(s), units_sole(units), revenue(revenue) {}

since cannot set "units, and revenue" as default argument


namespace cxx_ctor
{
  class CtorUseDefaultArgument
  {
  public:
    CtorUseDefaultArgument(std::string const &bookNo,
                           unsigned sold    = 10,
                           unsigned revenue = 20)
        : bookNo_(bookNo)
        , units_sold_(sold)
        , revenue_(revenue)
    {}

    // to make it easy to check values
    std::string bookNo_;
    unsigned units_sold_;
    unsigned revenue_;
  };

  class CtorUseInClassInit
  {
  public:
    // CtorUseInClassInit(std::string const &bookNo, unsigned sold, unsigned
    // revenue)
    //   :bookNo_(bookNo), units_sold_(sold), revenue_(revenue)
    // {}

    CtorUseInClassInit(std::string const &bookNo)
        : bookNo_(bookNo)
    {}

    std::string bookNo_;
    unsigned units_sold_{10};
    unsigned revenue_{20};
    unsigned value_{};
  };
} // namespace cxx_ctor

TEST(CxxCtor, default_argument)
{
  using namespace cxx_ctor;

  {
    CtorUseDefaultArgument o("ctor");

    EXPECT_THAT(o.bookNo_, "ctor");
    EXPECT_THAT(o.units_sold_, 10);
    EXPECT_THAT(o.revenue_, 20);
  }

  {
    CtorUseDefaultArgument o("ctor", 30);

    EXPECT_THAT(o.bookNo_, "ctor");
    EXPECT_THAT(o.units_sold_, 30);
    EXPECT_THAT(o.revenue_, 20);
  }

  {
    CtorUseDefaultArgument o("ctor", 30, 40);

    EXPECT_THAT(o.bookNo_, "ctor");
    EXPECT_THAT(o.units_sold_, 30);
    EXPECT_THAT(o.revenue_, 40);
  }

  // error since there is no such ctor. so if want to do the same as default
  // argument case, have to `define all ctors` to cover cases default ctor do.
  //
  // {
  //   // error: no matching function for call to
  //   // ‘cxx_ctor::CtorUseInClassInit::CtorUseInClassInit(const char [5])’
  //
  //   CtorUseInClassInit o("ctor");
  //
  //   EXPECT_THAT(o.bookNo_, "ctor");
  //   EXPECT_THAT(o.units_sold_, 10);
  //   EXPECT_THAT(o.revenue_, 20);
  // }

  // works now when changes ctor. so note that cxx-inclass-init has the same
  // effect as cxx-default-argument.

  {
    CtorUseInClassInit o("ctor");

    EXPECT_THAT(o.bookNo_, "ctor");
    EXPECT_THAT(o.units_sold_, 10);
    EXPECT_THAT(o.revenue_, 20);
    EXPECT_THAT(o.value_, 0);
  }
}


{cxx-ctor-init-list} 
The following is initialization and assignment but not initialization since
members are default initialized `before-ctor-body-runs`. 

ABEntry::ABEntry(...)
{
  theName = name;
  theAddress = address;
  thePhones = phones;
  numTimesConsulted = 0;
}

Why `ctor-init-list`? From CPR 289 and EC++04.

o Efficient than initialization-and-assignment.

  <when-ctor-init-list-is-must>
o By the time the body of ctor begins excuting, initialization is completed so
  there are 'three' cases that must use `ctor-init-list`: 

  const, reference, and class member that do not have a default ctor.

o Only for ctor
  :38:38: error: only constructors take member initializers
     MSTR &operator=(const MSTR &m) : mesg(m.mesg)

// C++ cookbook

Handled in the caller:
you also gain automatic exception handling. If an object is constructed in the
initializer list, and that object throws an exception during construction, the
runtime environment destroys all other previously constructed objects in the
list, and the exception continues to the caller of the constructor.

Handled in the callee:
On the other hand, if you assign the argument in the body of the constructor,
   then you have to handle the exception with a try/catch block.


CPR 265. When a data memder is omitted from the ctor-init-list, it is
'implicitly' initialized using the same process as is used by the synthesized
default-ctor; in-class-init if there is or default-init.


Use `ctor-init-list` always:

ABEntry::ABEntry(...)
: theName(name),
  theAddress(address),
  thePhones(phones),
  numTimesConsulted(0)
{}

ABEntry::ABEntry(...)
: theName(),                  // value-init
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}

The ctor-init-list is all about making sure that built-in type do not have
undefined values since user type has constructors so no undefined value. Is it
overkill when use constructor initializer for all members since default ctor
will be used when omitted? Use ctor-init-list always since:

o Avoid to remember which memebers may go uninitialized if they are omitted.
o Cover data members which are const or reference.


Must be done in class definition? NO. can be done in memeber definition in cpp
file.

class Derived: public Base 
{ 
  public: Derived( parms ) : Base( parms ), m_xxx(param), ... 
          { ... }
};


{cxx-ctor-init-order}
CPR 289. Members are initialized in the order in which they appear in the class
definition. The order of initialization often doesn't matter unless one member
is initialized in terms of another.

* Good idea to write ctor-init in the same order as the members are declared.

// :293:21: warning: ‘MakeToken::str_’ will be initialized after [-Wreorder]
//         string str_{};


* Good idea to write member initializer to use the ctor's parameters rather
  than another data member from the same object.

// EXC++47
class Array : private ArrayBase, public Container
{
  public:
    Array (size_t startingSize = 10)
      : size_(startingSize),
      buffer_(new T[size_]) {}              // *cpp-error*

  private:
    T* buffer_;
    size_t used_, size_;
};


<cxx-ctor-type-member> <cxx-typename> CPR 272
As with data and function member, type member is a local name and is subject
to the access control. Users can use that name.

CPR 259. The data member can be used `regardless of where` they are defined
because the compiler processes classes in two steps; the data member are
compiled first and then function member. 

However, `type member must appear before` they are used. So usually appear at
the beginning of the class.

class Screen {
  public:
    typedef std::string::size_type pos;

    OR

    using pos = std::string::size_type;

  private:
    pos cursor = 0;
};


<type-member-error> CPR 285
An inner scope can redefine a name from an outer scope. However, if that is a
type member, `may not redefine that name.`

typedef double Money;

class Account {
  public:
    Money balance() { return bal; }

  private:
    typedef double Money;
    Money bal;
    ...
};

Although it is an error to redefine a type name, compilers are not required to
diagnose this error. Some compilers will quietly accept such code, even though
the program is in error.

note: VC emits no errors.

<ex>
Some compliers are kind enough to generate a warning if the data members are
listed in the ctor-init in a different order from the order in which the
members are declared.

This is a warning and turned to an error due to compiler flag:

class X {
  // ...
  GstMediaRouterSize videoSize;

  SetSourceReason::Enum setSourceReason;
};

: error: 'X::setSourceReason' will be initialized after
: error:   'GstMediaRouterSize videoSize'
: error:   when initialized here  // points to the ctor.

X::X() :
  ...
  setSourceReason(SetSourceReason::unspecified),
  videoSize(0, 0)                 // points to the ctor.
{}

It solves the errors when changes the order of declaration:

class X {
  // ...
  
  SetSourceReason::Enum setSourceReason;

  GstMediaRouterSize videoSize;
};


// *TN*
// Always get a derived version since it's static binding and so this item is
// wrong as:
//
// namespace OR6 {
// 
// using namespace std;
// 
// class B0 {
//     public:
//         B0() 
//         { 
//             cout << "B0::B0" << endl; 
//             call_virtual_function();
//         }
// 
//         virtual ~B0() 
//         { 
//             cout << "B0::~B0" << endl; 
//         }
// 
//         virtual void call_virtual_function()
//         {
//             cout << "B0::call_virtual_function()" << endl; 
//         }
// };
// 
// class D0 {
//     public:
//         D0() 
//         { 
//             cout << "D0::D0" << endl; 
//             call_virtual_function();
//         }
// 
//         virtual ~D0() 
//         { 
//             cout << "D0::~D0" << endl; 
//         }
// 
//         virtual void call_virtual_function()
//         {
//             cout << "D0::call_virtual_function()" << endl; 
//         }
// };
// 
// } // namespace
// 
// = 06 ======
// D0::D0
// D0::call_virtual_function()
// end of main
// D0::~D0
// 
// void t_override_06()
// {
//     using namespace OR6;
// 
//     D0 d1;
//     cout << "end of main" << endl;
// }
//
// <cxx-ctor-no-virtual> EC++09, no virtual call in ctor or dtor 
// Assume that each time a transaction object is created, an appropriate log
// entry needs to be created in a log. If it is a derived object, then need to
// have a log entry for that type.
// 
// Solution?:
// 
// class Transaction {
//   public:
//     Transaction();
// 
//     // to make type-dependent-log-entry
//     virtual void logTransaction() const = 0;
//     ...
// };
// 
// Transaction::Transaction()
// {
//   // call
//   logTransaction();
// }
// 
// class BuyTransaction: public Transaction {
//   public:
//     virtual void logTransaction() const;
//     ...
// };
// 
// class SellTransaction: public Transaction {
//   public:
//     virtual void logTransaction() const;
//     ...
// };
// 
// // use
// {
//    BuyTransaction buy;
// }
// 
// Will it have a log entry of BuyTransaction as expected? NO. Will have the base
// class version if there is one. 
// 
// // this is becuase it is a virtual call in base ctor
// 
// C++ don't allow this because when base ctor runs, 'only' base part is created.
// Hence base version. If it was allowed, then derived call would access derived
// part which is not created or initialized. This is undefined so 'not' allowed.
// 
// Remember that construction happens first from base. Also this can be explained
// as this is becuase it is static bining at compile time. Has nothing to do with
// virtual mechanism since not through reference or pointer.
// 
// 1. For the example above, some compilers issue a warning. Even if there is no
// warnings, there will be a link error unless there is a definition of pure
// virtual function. Remember pure virtual can have definition. 
// 
// 2. Can use normal virtual function (not pure) but still get base version.
// 
// 
// Solution. Make it non virtual, move up the implementation in class tree to
// have single implementation, and pass up the type dependent info to the base
// class.
// 
// class Transaction {
//   public:
//     explicit Transaction( const std::string& logInfo );
// 
//     // non virtual function
//     void logTransaction( const std::string& logInfo) const;
//     ...
// };
// 
// Transaction::Transaction( const std::string& logInfo )
// {
//   ...
//   logTransaction( logInfo );
// }
// 
// class BuyTransaction: public Transaction {
//   public:
//     // pass-log-to-base-class
//     BuyTransaction( parameters ) 
//       : Transaction( createLogString(parameters) )
//     { ... }
//     ...
//   private:
//       'static' std::string createLogString( parameters );
// };
// 
// See the use of createLogString, helper func, instead of initializing each
// member and it is more convenient and consider this when there are many
// parameters.
// 
// *cxx-static-members* 
// Why static? By doing this, there is no danger of accidentally referring to the
// BuyTransaction object's as-yet-uninitialized data or function members when
// base ctor and part runs.


{cxx-ctor-class-invariant}
Such a statement of what is assumed to be true for a class is called a class
invariant. It is `the job of a constructor` to establish the invariant for its
class (so that the member functions can rely on it) and for the member
functions to make sure that the invariant holds when they exit. 

Unfortunately, our Vector constructor only partially did its job. It properly
initialized the Vector members, but it failed to check that the arguments
passed to it made sense. Consider:

Vector v(27);

This is likely to cause chaos. Here is a more appropriate definition:

Vector::Vector(int s)
{
  if (s<0) throw length_error{};

  elem = new double[s];

  sz = s;
}


={============================================================================
*kt_dev_cxx_0000* cxx-init-form

// `default-init`
string s1;                 


// `direct-init`
string s2(s1);           
string dots(10, '.');
string s(dots);
string null_book("9-999-99999-9");

// `copy-init when converting-ctor` 
string null_book = "9-999-99999-9"; 

// `copy-init when copy-ctor` 
string s2 = s1;                     


void f(vector<int>);
f(10);                        // error since ctor that takes a size is explicit
f(vector<int>(10));           // okay


// `default-init` in constructor
ABEntry::ABEntry(...)
: theName(),                  // T var(). same as units_sold(0)
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}


// *cxx-temporary* *cxx-value-init*
void doSomething(B bObject);
doSomething(B(28));           // T(val). converting ctor

return pair<string, int>();   // T()


// `default-init` and `value-init`
string* ps = new string;      // default-init
string* ps = new string();    // value-init. new T()

int* pi = new int;            // default-init
int* pi = new int();          // value-init. new T()

vector<T> v3(n, val);         // has n elements with value val
vector<T> v4(n);              // has n copies of a value-init objects


// CPR42. An object that is initialised gets the specified value at the moment
// it is created. The value used to initialized a variable can be arbitrarily
// complicated expressions.

double salePrice = applyDiscount(price, discount);


*cxx-remember*
The `value-init` uses the form `T()` and is a special or narrow case of
`default-init`. The value-init only matters for built-in types since default
and value init do the same for other types since class type will have default
values since ctors would do if ctors do the right work.


<ex>
TEST(StlVector, InitializeFromExpression)
{
  vector<int> coll;
  StlVectorFillVector(coll);

  // okay as well
  // int value;
  // cin >> value;
  // vector<bool> table1(value);

  vector<bool> table1(coll.size());
  vector<bool> table2(10);

  EXPECT_THAT(table1.size(), 20);
  EXPECT_THAT(table2.size(), 10);
}

TEST(StlVector, InitializeForms)
{
  // default init
  vector<int> coll1;

  for (int i = 0; i < 5; i++)
  {
    int val;
    coll1.push_back(val);
  }

  // default init and fails
  EXPECT_THAT(coll1, ElementsAre(0,0,0,0,0));

  // value init
  vector<int> coll2(5);
  EXPECT_THAT(coll2, ElementsAre(0,0,0,0,0));

  // value init
  vector<int> coll3(5, 10);
  EXPECT_THAT(coll3, ElementsAre(10,10,10,10,10));
}


<cxx-static-init>
If no initializer is specified, a global, namespace, local static, or static
member (collectively called static objects) is initialized to {} of the
appropriate type.


={============================================================================
*kt_dev_cxx_0000* cxx-init-copy-form

Both `copy-init` and `direct-init` uses function matching in ctors depending
on if conversion is necessary; coverting ctor or copy ctor. 

However, copy-init only works with implicit ctors and also direct-init allows
one more conversion. 

string null_book = "9-999-99999-9"; // `copy-init when converting-ctor` called
string s2 = s1;                     // `copy-init when copy-ctor` called
string s2(s1);                      // `direct-init when copy-ctor` called
string s2("9-999");                 // `direct-init when converting-ctor` called


<ex>
To sum, *cxx-init-copy-init* uses copy ctor which is counted as implicit
conversion. So it cannot use with explicit copy ctor and in cases more
conversion since only one conversion is allowed at a time. 

namespace ctor_init
{
  class Foo
  {
    public:
      Foo() : mesg_() {} 

      // mesg_ is updated only here
      Foo(const string &mesg) : mesg_(mesg) 
      {
        os_ << mesg_ << " and converting ctor";
      }

      Foo(const Foo &foo)
      {
        mesg_ = foo.mesg_;
        os_ << mesg_ << " and copy ctor";
      }

      string return_mesg()
      {
        return os_.str();
      }

    private:
      ostringstream os_;
      string mesg_;
  };
} // namespace

TEST(Ctor, CtorInitForms)
{
  using namespace ctor_init;

  // direct
  {
    // conversion from char * to string before calling ctor
    Foo foo1("use direct init");
    EXPECT_THAT(foo1.return_mesg(), "use direct init and converting ctor");
  }

  // copy for foo2
  {
    // conversion from char * to string before calling ctor
    Foo foo1("use direct init");
    Foo foo2(foo1);
    EXPECT_THAT(foo2.return_mesg(), "use direct init and copy ctor");
  }

  // copy
  {
    Foo foo1("use copy init");
    Foo foo2 = foo1;
    EXPECT_THAT(foo2.return_mesg(), "use copy init and copy ctor");
  }

  // copy error
  // // cxx.cpp:533:16: error: conversion from ‘const char [14]’ to non-scalar type ‘ctor_init::Foo’ requested
  // //      Foo foo2 = "use copy init";
  // //                 ^
  // {
  //   Foo foo2 = "use copy init";
  //   EXPECT_THAT(foo2.return_mesg(), "use copy init and copy ctor");
  // }
}

namespace ctor_init_converting_ctor
{
  class Foo
  {
    public:
      Foo() : mesg_() {} 

      Foo(const string &mesg) : mesg_(mesg) 
      {
        os_ << mesg_ << " and string converting ctor";
      }

      Foo(const Foo &foo)
      {
        mesg_ = foo.mesg_;
        os_ << mesg_ << " and copy ctor";
      }

      // added
      Foo(const char *mesg) : mesg_(mesg)
      {
        os_ << mesg_ << " and char converting ctor";
      }

      string return_mesg()
      {
        return os_.str();
      }

    private:
      ostringstream os_;
      string mesg_;
  };
} // namespace

TEST(Ctor, CtorInitFromMore)
{
  using namespace ctor_init_converting_ctor;

  {
    Foo foo2 = "use copy init";
    EXPECT_THAT(foo2.return_mesg(), "use copy init and char converting ctor");
  }
}

namespace ctor_init_explicit
{
  class Foo
  {
    public:
      Foo() : mesg_() {} 

      explicit Foo(const string &mesg) : mesg_(mesg) 
      {
        os_ << mesg_ << " and string converting ctor";
      }

      explicit Foo(const Foo &foo)
      {
        mesg_ = foo.mesg_;
        os_ << mesg_ << " and copy ctor";
      }

      // added
      explicit Foo(const char *mesg) : mesg_(mesg)
      {
        os_ << mesg_ << " and char converting ctor";
      }

      string return_mesg()
      {
        return os_.str();
      }

    private:
      ostringstream os_;
      string mesg_;
  };
} // namespace

TEST(Ctor, CtorInitFromExplicit)
{
  using namespace ctor_init_explicit;

  // copy
  {
    // conversion from char * to string before calling ctor
    Foo foo1("use direct init");
    Foo foo2(foo1);
    EXPECT_THAT(foo2.return_mesg(), "use direct init and copy ctor");
  }

  // // copy 
  // {
  //   Foo foo1("use copy init");
  //
  //  when use explicit Foo(const Foo &foo);
  //
  //   // cxx.cpp:628:16: error: no matching function for call to
  //   // ‘ctor_init_explicit::Foo::Foo(ctor_init_explicit::Foo&)’
  //
  //   Foo foo2 = foo1;
  //   EXPECT_THAT(foo2.return_mesg(), "use copy init and copy ctor");
  // }

  // copy error
  // // cxx.cpp:533:16: error: conversion from ‘const char [14]’ to non-scalar type ‘ctor_init::Foo’ requested
  // //      Foo foo2 = "use copy init";
  // //                 ^
  // {
  //   Foo foo2 = "use copy init";
  //   EXPECT_THAT(foo2.return_mesg(), "use copy init and copy ctor");
  // }
}


<ex>
Question is "does these above statements involve copy-assign?"

For example, what calls are involved in this statments?

    Query q = Query("fiery") & Query("bird") | Query("wind");
            <----------------------------------------------->

calls converting or copy ctor to build right-side of statements. NO copy
assign gets called. this example calls three Query ctor and two overloaded
operators. 


> WordQuery::WordQuery
> Query::Query
> WordQuery::WordQuery
> Query::Query
> WordQuery::WordQuery
> Query::Query

> Query::Query(const Query&): fiery
> Query::Query(const Query&): bird
> AndQuery::AndQuery
> Query::Query(shared_ptr)

> Query::Query(const Query&): (fiery & bird)
> Query::Query(const Query&): wind
> OrQuery::OrQuery
> Query::Query(shared_ptr)


={============================================================================
*kt_dev_cxx_0000* cxx-init-list cxx-initializer-list

There are many different ways to initialize. C++11 introduced the concept of
generalized `cxx-uniform-initialization`, which means that for any
initialization. 

*cxx-11*
Must use -std=c++0x or -std=gnu++0x.

The followings are possible now:

int units_sold = 0;
int units_sold = {0};
int units_sold{0};            // `cxx-list-init` `cxx-brace-init`
int units_sold(0);
int units_sold{};

The empty {}, is used to indicate that a default value is desired. 

char buf[max] {};         // *cxx-array* initialize every char to 0
int x4 {};                // x4 becomes 0


const string hybrid_str{"hybrid:"};
int values[] { 1, 2, 3 };
vector<int> v{ 2, 3, 5, 7, 11, 13, 17 };
vector<std::string> cities{"Berlin", "London", "Braunschweig", "Cologne" };
complex<double> c{4.0,3.0};


*cxx-remember*
The good things are:

o cxx-list-init do `value-init` for built-in types
o save you from conversions that lose information, narrowing conversions.
o general universal form

An cxx-list-init `forces value-init`, which means that even local variables of
fundamental data types, which usually have an `undefined` value, are
initialized by zero, or nullptr, if it is a pointer.

int i;      // i has undefined value
int j{};    // j is initialized by 0    *cxx-remember*
int* p;     // p has undefined value
int* q{};   // q is initialized by nullptr


<ex>

The result is not what expects to see since milliseconds ms is not initialised.

// [ RUN      ] CxxTime.check_duration_2
// 188209768194270 ms
// 3742327457174483840 ns
// [       OK ] CxxTime.check_duration_2 (0 ms)

TEST(CxxTime, check_duration_2)
{
  {
    std::chrono::seconds twentySeconds{20}; // 20 seconds
    std::chrono::hours aDay{24};            // 24 hours
    std::chrono::milliseconds ms;           // NOTE NOT milliseconds

    // 24 hours and 20 seconds in milliseconds?
    // 24 * 60 * 60 * 1000 + 20 * 1000

    ms += twentySeconds + aDay;   // 86,420,000 milliseconds
    --ms;                         // 86,419,999 milliseconds
    ms *= 2;                      // 172,839,998 milliseconds

    std::cout << ms.count() << " ms" << std::endl;

    // convert ms to ns
    std::cout << std::chrono::nanoseconds(ms).count() << " ns" << std::endl;
  }

  {
    std::chrono::seconds twentySeconds{20}; // 20 seconds
    std::chrono::hours aDay{24};            // 24 hours
    std::chrono::milliseconds ms{};         // 0 milliseconds

    // 24 hours and 20 seconds in milliseconds?
    // 24 * 60 * 60 * 1000 + 20 * 1000

    ms += twentySeconds + aDay;   // 86,420,000 milliseconds
    --ms;                         // 86,419,999 milliseconds
    ms *= 2;                      // 172,839,998 milliseconds

    // std::cout << ms.count() << " ms" << std::endl;
    EXPECT_THAT(ms.count(), 172839998);

    // convert ms to ns
    // std::cout << std::chrono::nanoseconds(ms).count() << " ns" << std::endl;
    EXPECT_THAT(std::chrono::nanoseconds(ms).count(), 172839998000000);
  }
}


*cxx-list-init-reduce-size*

Use cxx-list-init to use complete object to initialize

int main()
{
  vector<int> coll{1,2,3,4,5,6};

  for ( auto it = coll.cbegin(); it < coll.cend(); ++it )
    cout << *it << ' ';

  cout << endl;
}

-rwxr-xr-x  1 kyoupark kyoupark 58848 Sep 20 09:46 a.out*

int main()
{
  vector<int> coll;

  for(int i=1; i <= 6; i++)
    coll.push_back(i);

  for ( auto it = coll.cbegin(); it < coll.cend(); ++it )
    cout << *it << ' ';

  cout << endl;
}

-rwxr-xr-x  1 kyoupark kyoupark 66560 Sep 20 09:45 a.out.old*


{cxx-init-list}
The initializer list is to support for user-defined types and 

o repersents an array of values of the `same-type`. The element in a list
  are always `const`.

o can write a function that takes varying number of arguments.


// /usr/include/c++/4.9/initializer_list
#include <initializer_list>


<ex> *cxx-vector-init*

namespce cxx_code
{
  /**
   *  @brief  Builds a %vector from an initializer list.
   *  @param  __l  An initializer_list.
   *  @param  __a  An allocator.
   *
   *  Create a %vector consisting of copies of the elements in the
   *  initializer_list @a __l.
   *
   *  This will call the element type's copy constructor N times
   *  (where N is @a __l.size()) and do no memory reallocation.
   */
  vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
    : _Base(__a)
  {
    _M_range_initialize(__l.begin(), __l.end(),
        random_access_iterator_tag());
  }
}

<ex>

namespace cxx_init_list
{
  class Foo
  {
    public:
      Foo() : mesg_() {} 

      // mesg_ is updated only here
      Foo(const string &mesg) : mesg_(mesg) 
    {
      os_ << mesg_ << " and converting ctor";
    }

      Foo(const Foo &foo)
      {
        mesg_ = foo.mesg_;
        os_ << mesg_ << " and copy ctor";
      }

      Foo(std::initializer_list<std::string> values)
      {
        for (auto &e : values)
          os_ << e << ", ";
      }

      string return_mesg()
      {
        return os_.str();
      }

    private:
      ostringstream os_;
      string mesg_;
  };

  // to show that it can be used in a function and return vector than print out
  // to be used in test

  // *cxx-const* *cxx-temporary* *cxx-reference*

  std::vector<string> 
    error_message_1(std::string const &message, std::initializer_list<std::string> const &ls)
  {
    std::vector<string> coll{};

    coll.push_back(message);

    for(auto const &e : ls)
      coll.push_back(e);

    return coll;
  }

  // const is must to use temporary and if not, non-const compile error

  std::vector<int> 
    error_message_2(std::initializer_list<int> const &ls)
  {
    std::vector<int> coll{};

    for(auto const &e : ls)
      coll.push_back(e);

    return coll;
  }

  // no error when use tempoarary since it not use reference

  std::vector<int> 
    error_message_3(std::initializer_list<int> ls)
  {
    std::vector<int> coll{};

    for(auto const &e : ls)
      coll.push_back(e);

    return coll;
  }

} // namespace

TEST(Initialise, List)
{
  using namespace cxx_init_list;

  // copy, brace init
  {

    // when no Foo(std::initializer_list<std::string> values);
    //
    // cxx.cpp:719:35: error: no matching function for call to
    // ‘ctor_init_list::Foo::Foo(<brace-enclosed initializer list>)’
    //
    //      Foo foo1{"one", "two", "three"};

    Foo foo1{"one", "two", "three"};
    EXPECT_THAT(foo1.return_mesg(), "one, two, three, ");
  }

  {
    EXPECT_THAT(error_message_1("error", {string("one"), string("two"), string("three")}),
        ElementsAre("error", "one", "two","three"));
  }

  {
    EXPECT_THAT(error_message_2({1,2,3,4,5}),
        ElementsAre(1,2,3,4,5));
  }

  {
    EXPECT_THAT(error_message_3({1,2,3,4,5}),
        ElementsAre(1,2,3,4,5));
  }
}


<ex>
class StrVec
{
  public:
    StrVec() {}
    StrVec(std::initializer_list<std::string> il)
    {
      auto vec = alloc_and_copy(il.begin(), il.end());
      element_ = vec.first;
      free_ = cap_ = vec.second;
    }
};

StrVec sv{"one", "two", "three"};

<ex>
this becomes initializer_list and see that syntax:

// this is array
// const auto arabicToRomanConversions[] = {..};

    const auto arabicToRomanConversions{
        make_pair(1000u, "M"), 
        make_pair(900u, "CM"), 
        make_pair(500u, "D"), 
        make_pair(400u, "CD"), 
        make_pair(100u, "C"),
        make_pair(90u, "XC"), 
        make_pair(50u, "L"), 
        make_pair(40u, "XL"), 
        make_pair(10u, "X"), 
        make_pair(9u, "IX"), 
        make_pair(5u, "V"), 
        make_pair(4u, "IV"), 
        make_pair(1u, "I") 
    };

<ex> multi-array using cxx-vector and cxx-array

TEST(StlMultiArray, UseVectorAndArray)
{
  const size_t rows = 5;
  const size_t cols = 5;

  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0

  vector<vector<int>> coll_vector(rows, vector<int>(cols, 0)); 

  cout << "{" << endl;
  for (size_t i = 0; i < rows; ++i)
  {
    for(size_t j = 0; j < cols; ++j)
      cout << coll_vector[i][j] << " ";
    cout << endl;
  }
  cout << "}" << endl;

  // 0 0 0 0 0
  // 1 1 1 1 0
  // 0 0 0 0 0
  // 0 1 1 1 1
  // 2 0 0 0 0

  std::vector<std::vector<int>> coll_vector_5{
    {0,0,0,0,0},
    {1,1,1,1,0},
    {0,0,0,0,0},
    {0,1,1,1,1},
    {2,0,0,0,0}
  };

  cout << "{" << endl;
  for (size_t i = 0; i < rows; ++i)
  {
    for(size_t j = 0; j < cols; ++j)
      cout << coll_vector_5[i][j] << " ";
    cout << endl;
  }
  cout << "}" << endl;


  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0

  array<array<int, cols>, rows> coll_array{}; 

  cout << "{" << endl;
  for (size_t i = 0; i < rows; ++i)
  {
    for(size_t j = 0; j < cols; ++j)
      cout << coll_array[i][j] << " ";
    cout << endl;
  }
  cout << "}" << endl;

  // 0 0 0 0 0
  // 1 1 1 1 0
  // 0 0 0 0 0
  // 0 1 1 1 1
  // 2 0 0 0 0

  std::array<std::array<int, 5>, 5> coll_array_5 = {
    0,0,0,0,0,
    1,1,1,1,0,
    0,0,0,0,0,
    0,1,1,1,1,
    2,0,0,0,0
  };

  cout << "{" << endl;
  for (size_t i = 0; i < rows; ++i)
  {
    for(size_t j = 0; j < cols; ++j)
      cout << coll_array_5[i][j] << " ";
    cout << endl;
  }
  cout << "}" << endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-dtor cxx-non-virtial-destruction-problem

{cxx-ctor-order}
Opposite to ctor in destruction order so dtor body runs first and then
implicit member destruction phase.

Under inheritence: 

------------> ctor
base     derived
<------------ dtor


{cxx-dtor-in-derived-classes}
The dtor is one of `copy-controls` and means if not defined, the compiler will
make one which is `non-virtual` when the base don't have one.

The virtual is only used in class definition and for other functions, if it's
virtual in base then all overrides in derived classes are virtual. How about
dtor? That's the same. 

Unlike the constructors and assignment operators, the destructor is reponsible
only for destroying the resources allocated by the derived class. From user or
programmer POV.


{cxx-dtor-non-virtual-destruction-problem} *cxx-override*
EC++07. The problem is that base dtor runs when derived dtor is expected via
derived-to-base pointer is used.

GCC spec says it will have cxx-undefined result but in reality, destroy only
the base part; `partially destroyed.` 

note In GCC, no runtime error in simple test. what's the real problem?


This is the same for other member functions. That is if miss out virtual
keywords in a base, then will have only base version even if expected derived
version. 

Therefore, there are two cases when override do not happen; 

o one when argument is different, see `cxx-override-condition`

o one when miss out virtual keyword in a base as shown here.


note that:

o `non-virtual-destruction-problem` only for `dynamic-binding` 
  if uses static binding and no vtable is involved. The compiler knows only
  about derived type and do not emits code to follow vtables.

it is a problem only when use dynamic allocation through a base pointer.
Although cxx-vector do not have virtual dtor and it is okay if used only
statically. 

Due to *non-virtual-destruction-problem,* all base class `must` have virtual
dtor; the first and the second at below and as advised in EC++07.

o polymorphic base class
  designed for inheritance and defined virtual funcs. 
  `must have virtual dtor.`

o base class which are not intended to extend 
  Like STL which has no virtual funcs and no overrides. However, if do use it
  as a base, causes the same non-virtual-destruction-problem. 

o a class not to be inherited
  designed for no inheritance like STL. DO NOT use virtual-dtor sicne it will
  increate a size of instance and make it not portable.
  *cxx-preventing-inheritance* 


The point is that use virtual dtor only for polymorphic base class.


<ex>

namespace cxx_dtor {

  class NoVirtualDtorBase
  {
    public:
      NoVirtualDtorBase() 
      { std::cout << "\tno virtual ctor: base" << std::endl; }

      ~NoVirtualDtorBase() 
      { std::cout << "\tno virtual dtor: base" << std::endl; }

    private:
      int base_;
  };

  class DerivedFromNoVirtual : public NoVirtualDtorBase
  {
    public:
      DerivedFromNoVirtual() 
      { std::cout << "\tno virtual ctor: derived" << std::endl; }

      ~DerivedFromNoVirtual() 
      { std::cout << "\tno virtual dtor: derived" << std::endl; }

    private:
      int derived_;
  };

  class VirtualDtorBase
  {
    public:
      VirtualDtorBase() 
      { std::cout << "\tvirtual ctor: base" << std::endl; }

      virtual ~VirtualDtorBase() 
      { std::cout << "\tvirtual dtor: base" << std::endl; }

    private:
      int value_;
  };

  class DerivedFromVirtual : public VirtualDtorBase
  {
    public:
      DerivedFromVirtual() 
      { std::cout << "\tvirtual ctor: derived" << std::endl; }

      ~DerivedFromVirtual() 
      { std::cout << "\tvirtual dtor: derived" << std::endl; }

    private:
      int derived_;
  };

} // namespace

// {
//         no virtual ctor: base
//         no virtual ctor: derived
//         no virtual dtor: base
// }
// {
//         virtual ctor: base
//         virtual ctor: derived
//         virtual dtor: derived
//         virtual dtor: base
// }
// {
//         no virtual ctor: base
//         no virtual ctor: derived
// }
//         no virtual dtor: derived
//         no virtual dtor: base

TEST(Dtor, NoVirtualDtorProblem)
{
  using namespace cxx_dtor;

  // no "dtor: derived" called
  {
    cout << "{" << endl;
    NoVirtualDtorBase* pbase = new DerivedFromNoVirtual;

    // https://stackoverflow.com/questions/7403883/derived-class-with-non-virtual-destructor
    // If you don't do delete in the above manner, then it will be fine. 

    delete pbase; 

    cout << "}" << endl; 
  }

  {
    cout << "{" << endl;
    VirtualDtorBase* pbase = new DerivedFromVirtual;
    delete pbase;
    cout << "}" << endl;
  }

  // static
  {
    cout << "{" << endl;
    DerivedFromNoVirtual object;
    cout << "}" << endl;
  }
}


{dtor-in-cxx-abc} {pure-virtual-dtor} *cxx-abc* *cxx-pure*
EC++07. Why use this? Sometimes you have a class that you'd like to be abstract
but you don't have any pure virtual functions.

class AWOW {
  public:
    virtual ~AWOW() = 0;
};

AWOW::~AWOW() {}

The pure-virtual-dtor `must` have a definition(implementation) and must be
implemeted outside class definitions.

MEC++33. `pure virtual do not mean it has no implementation` and means that
the class is abstract and the derived func must implement it. True, most
pure virtual functions are never implemented, but `dtor are a special-case.`
They must be implemented, because they are called whenever a derived class
destructor is invoked.  

o if there is no dtor implementation when use pure dtor in base, will cause
link error when use drived object.

o if there is no dtor in cxx-abc, compiler will make it but will suffer from 
*cxx-dtor-non-virtual-destruction-problem*

o this is why cxx-abc should have virtual dtor

<ex>
// Why dtor should be virtual in cxx-abc?

namespace cxx_dtor {

  class AbstractBase
  {
    public:
      AbstractBase() : base_(0)
      { std::cout << "\tabstract ctor: base" << std::endl; }

      ~AbstractBase() 
      { std::cout << "\tabstract dtor: base" << std::endl; }

      virtual int get_value() = 0;

    private:
      int base_;
  };

  class DerivedFromAbstract : public AbstractBase
  {
    public:
      DerivedFromAbstract() : derived_(10)
      { std::cout << "\tabstract ctor: derived" << std::endl; }

      ~DerivedFromAbstract() 
      { std::cout << "\tabstract dtor: derived" << std::endl; }

      virtual int get_value() override { return derived_; };

    private:
      int derived_;
  };


  class AbstractBaseNoDtor
  {
    public:
      AbstractBaseNoDtor() : base_(0)
      { std::cout << "\tabstract ctor: base" << std::endl; }

      // ~AbstractBase() 
      // { std::cout << "\tabstract dtor: base" << std::endl; }

      virtual int get_value() = 0;

    private:
      int base_;
  };

  class DerivedFromAbstractNoDtor : public AbstractBaseNoDtor
  {
    public:
      DerivedFromAbstractNoDtor() : derived_(10)
      { std::cout << "\tabstract ctor: derived" << std::endl; }

      ~DerivedFromAbstractNoDtor() 
      { std::cout << "\tabstract dtor: derived" << std::endl; }

      virtual int get_value() override { return derived_; };

    private:
      int derived_;
  };

} // namespace

TEST(Dtor, AbstractBaseClassNoCompileError)
{
  {
    using namespace cxx_dtor;

    DerivedFromAbstract* pabc1; 
    DerivedFromAbstract* pabc2; 

    (void) pabc1;
    (void) pabc2;
  }

  {
    using namespace cxx_dtor;

    DerivedFromAbstract abc; 
  }

  {
    using namespace cxx_dtor;

    DerivedFromAbstractNoDtor* pabc1; 
    DerivedFromAbstractNoDtor* pabc2; 

    (void) pabc1;
    (void) pabc2;
  }

  {
    using namespace cxx_dtor;

    DerivedFromAbstract abc; 
  }
}

// shows *cxx-dtor-non-virtual-destruction-problem*

TEST(Dtor, AbstractBaseClassNeedVirtualDtor)
{
  using namespace cxx_dtor;

  cout << "{" << endl;
  AbstractBaseNoDtor* pbase = new DerivedFromAbstractNoDtor;

  // cxx.cpp:1108:10: warning: deleting object of abstract class type ‘cxx_dtor::AbstractBaseNoDtor’ which has non-virtual destructor will cause undefined behaviour [-Wdelete-non-virtual-dtor]
  //    delete pbase; 

  delete pbase; 
  cout << "}" << endl; 
}


={============================================================================
*kt_dev_cxx_0000* cxx-default-argument

{in-function} see *cxx-in-class-init*
The default argument in function. If a parameter has a default argument, all
the parameters that follow it `must` also have default arguments. The default
arguments are used from right most arguments that means that user provided
arguments are used from left most.

typedef string::size_type sz;
string screen( sz ht = 24, sz wid = 80, char background = ' ' );
string screen( sz ht = 24, sz wid, char background = ' ');           // ERROR

string window = screen();        // == screen( 24, 80, ' ');
string window = screen(66);      // == screen( 66, 80, ' ');
string window = screen(66,256);  // == screen( 66, 256, ' ');

So consider ordering the parameters in declaration so that those lesat likely
to use a default value appear first. 

note:
Use copy-init form.


{in-ctor}

class T {
  T() = default;
  T(const string s) : bookNo(s) {}
  ...
  string bookNo;
};

equals to: see there is no default ctor here

class T {
  T(const string s = "") : bookNo(s) {}
  ...
  string bookNo;
};


{in-virtual}
The default arg in virtual func will `always be used base's one` even when the
drived version is run because default arg is `statically bound.` So the
recommendation is that should use the same argument values in the base and
derived.

Problem case is:

class Shape {
  public:
    enum ShapeColor { Red, Green, Blue };
    virtual void draw( ShapeColor color = Red ) const = 0;
    ...
};

class Rectangle : public Shape {
  public:
    virtual void draw( ShapeColor color = Green ) const;
    ...
};


struct Cat {
    virtual void speak(const char *s = "meow")
        { printf("%s.\n", s); }
};

struct Tiger : public Cat {
    void speak(const char *s = "roar") override
        { printf("%s!!\n", s); }
};

Cat c;       c.speak();  // "meow."
Tiger t;     t.speak();  // "roar!!"
Cat *p = &t; p->speak(); // "meow!!"


*cpp-remember*
Use carefully as there are logical cases where need to have args from the same
source. For example, it's logical error when one arg is from def init and the
other is from the user.


<not-declaration>
https://quuxplusone.github.io/blog/2020/04/18/default-function-arguments-are-the-devil/?fbclid=IwAR2UrgZIMXBDPS9S8npjC5htJh8kLIQeyfc8m_Y_6t6pmPc1imDuEJbI6IE

Fiddly redeclaration rules

A default function argument appears syntactically in a function declaration, but
the default argument itself behaves like a definition, in that there must be
only one of it per translation unit.

int f(int x = 1);
int f(int x = 1);  // ERROR: redefinition of default argument

Even in the function definition, you aren’t allowed to repeat the default
argument’s value. This means that a piece of the function’s interface is
invisible at the site of the function’s implementation. I frequently see
workarounds such as this:

int f(int x/*=1*/) {
    return x;
}

But, like any code comment, this /*=1*/ could easily get out of sync with
reality.

int f(int x = 2);

int f(int x/*=1*/) {   // OOPS!
    return x;
}


={============================================================================
*kt_dev_cxx_0000* cxx-copy-control

Q: How copy control can access private members of rhs?

*cxx-synthesize*
copy ctor, copy assign, move ctor(C++11), move assign(C++11)

If not defined, complier will synthesise them. Don't use syn version of copy
controls when use dyn allocated resource.


{cxx-copy-ctor} copy-init, pass-by-value
Initialize object `from the other of the same-type`, and convert that operand
if necessary.

The first arg is a reference to a class and the rest args can be defaults. 

class Foo {
  Foo(const &Foo);   // wrong
  Foo(const Foo&);   // okay
};

Used in contexts:

o `cxx-copy-form-init` for the same type and converting-ctor for different type
o `pass-by-value` in function call
o `return-by-value` in *cxx-return*

  *cpp-remember*
  converting-ctor will be used if return statement requires conversion.

o `list-form-init`
o `implicit cxx-type-coversion` using a *cxx-temporary*

For pass and return by value they are rightly non-reference type and
`copy-inited`. Hence called `copy-ctor`. Defines how pass-by-value is
implemented for the type.


<cxx-synthesized-copy-ctor>
Do `memberwise-copy` the members of its argument. The type of each member
determines how that member is copied. Members of class type are copied by the
copy ctor for that class and members of built-in are copied directly.

class Sales_data
{
  public:
    Sales_data(const Sales_data &);

  private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};

The equivalent copy constructor that would be synthesized:

Sales_data::Sales_data(const Sales_data& orig):
    bookNo( orig.bookNo ),          // use string copy constructor
    units_sold( orig.units_sold ),  // use direct copy
    revenue( orig.revenue )
{}


<ex>
#include<iostream>
#include<string>
#include<memory>

using namespace std;

class Foo 
{
  public:

    Foo()
    { cout << "Foo's def ctor" << endl; }

    Foo( int val ) 
    { fval = val; }

    Foo( const Foo &f )
    { fval = f.fval; cout << "Foo's copy ctor: " << fval << endl; }

    int get() { return fval; }

  private:
    int fval;
};

class FooFoo
{
  public:
    FooFoo(int val) : foo(val) 
      { cout << "FooFoo's ctor: " << val << endl; }

    // note: calls foo's `copy-ctor`.
    //
    // FooFoo(const FooFoo& arg): foo(arg.foo) 
    // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

    // note: calls foo's `default-ctor`. value-init
    //
    // FooFoo(const FooFoo& arg): foo() 
    // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

    // note: calls foo's `default-ctor`. value-init
    //
    // FooFoo(const FooFoo& arg) 
    // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

  private:
    Foo foo;
};

int main()
{
  FooFoo ax(100);
  FooFoo bx(200);

  // note: both shows the same result. calls copy-ctor.
  FooFoo cx = bx;     // `copy-init`
  FooFoo cx(bx);      // `direct-init`
}

FooFoo's ctor: 100
FooFoo's ctor: 200
Foo's copy ctor: 200
FooFoo's copy ctor: 200


{cxx-copy-why-reference-parameter} cxx-recursive cxx-const
Why copy-ctor own parameter `must-be-a-reference`? 

If it is not a reference, then the call would never succeed. To copy-construct
object, use copy-ctor which is itself a function. Need to use copy-ctor to
copy argument and to copy the argument, use copy-ctor. `cxx-indefinite` Use
reference so that remove need of copy.

NO. Actualy, compile error:

:35:28: error: invalid constructor; you probably meant ‘FooFoo (const FooFoo&)’


<ex>

this causes infinite loop on cin and eventually seg fault because
ip's ctor is called on and on.

15.3.2 Input Operator >>

Note that the second argument is modified. To make this possible, the second
argument is passed by non-constant reference.
 
no seg fault but result is wrong since uses a copy
istream &operator>>(istream &is, ipv4 ip);

result is right
istream &operator>>(istream &is, ipv4 &ip);

seg fault when use:

istream &operator>>(istream &is, const ipv4 ip);

see that tempory is made to maintain constness but don't know why it
causes a infinite ctor.
 
run gdb

os >> address;

causes call operator>>() which calls ipv4 ctor since it needs const copy.

operator>>() calls

is >> ip.value1_>> delim;

this calls operator>>() which calls ipv4 ctor since it needs const copy.

operator>>() calls

is >> ip.value1_>> delim;

... cxx-recursive
 
even if operator>>() is called with const copy, it needs another const copy
when execute "is >> ip.value1_>> delim;"

when use istream &operator>>(istream &is, ipv4 ip)

is >> ip.value1_>> delim;

do not cause to call operator>>() again.

so the key is when operator>>() is called ip is not writable so create one
and this cause recursive. 


// istream &operator>>(istream &is, ipv4 ip)

istream &operator>>(istream &is, const ipv4 ip)
{
  char delim{};
  is >> ip.value1_>> delim;
  // is >> ip.value1_>> delim 
  //   >> ip.value2_ >> delim 
  //   >> ip.value3_ >> delim
  //   >> ip.value4_;
  return is;
}


{cxx-copy-assign} deleted-copy-controls. reference-member.
As with copy-ctor, cannot use synthesied `copy-assign` when there are
reference and const member data. Because copy assign is 'deleted' if the class
has a const or reference member. CPR 508.

// uses operator-overload and must be a member

class Foo {
  Foo& operator=(const Foo&);
};

The copy-assign controls how objects of its class are assigned

Sales_data trans, accum;
trans = accum;

Assign with different types? Need additional copy-assign.


<assignment-must-return-a-reference-to-this>
EC++10. All assign operations *cxx-overload-operator-assign* must follow this
convention like built-in types `because of chain of assignment` and should
behave the same as built-in types.

x = y = z = 15;   // right associative

Widget wx, wy, wz;
wx = wy = wz = DefaultWidget;

class Widget {
  public:
    Widget& operator=( const Widget& rhs )
    {
      ...
      return *this;
    }
};


{the-rule-of-three-or-five}
The rule of three (the rule of five in C++11) is a rule of thumb in C++ that
claims if a class defines one of the following it should probably explicitly
define all three:[1]

note: 
Nevertheless, needing either the copy-ctor or the copy-assign does not
(necessarily) indicate the need for a destructor.

note:
Why 3 or 5? Do not need ctor.


<ex> CPR 505
The need of own dtor for a class allocating dynamic resources is obvious.
Since if there's no dtor defined, the syn dtor will `not-run-delete` on the
pointer, ps, so must define own dtor. How possibly the compiler can know what
pointer member points to?

However, the need of own copy ctor and assign is less clear. See what will
happen when use syn versions of copy and assign. 

class HasPtr {
  public:
    HasPtr(const std::string& s = std::string() )  // def arg and def ctor 
      : ps( new std::string(s)), i(0) {}

    ~HasPtr() { delete ps; }

  private:
    std::string* ps;
};


<not-a-choice-of-style>
What are the problems? The syn versions does not operate well for a class using
dyn resource.

HasPtr func(HasPtr hp)  // member-wise copy using a syn copy ctor.
{
  HasPtr ret = hp;      // a syn copy assign. ret and hp points the same.
  ...
  return ret;           // `double free` on ret and hp, when exit a call
}

There still is an issue even if there is no return:

HasPrt p("...");
void func(p);

// p and func's arg points the same. when func exits, func's arg is deleted and
// p has invalid pointer which was already deleted after func().

HasPrt q(p);

// p and q have invalid pointer.

So must define copy-ctor and copy-assign as well. Two methods on what copying an
object will mean: `valuelike or pointerlike` what when copying pointer member
will mean


<for-const-reference-member>
Must define own copy-controls when there are const and reference members
because compiler will not create syn versions since cannot 'rebind' const and
reference.

TODO: How to define user copy controls for these cases? real use case?


{construct-and-copy-all-parts}
EC++12. When having own copy functions(copy-ctor and copy-assign), then means
that you shall have `full responsibility` for copying. Two cases: 

1. When add member variables to a class.

Customer& Customer::operator=( const Customer& rhs )
{
  name = rhs.name;
  return *this;
}

If add new member data, then must update 'all' copy functions and ctors too.
Otherwise, have copy functions to copy 'parts' of object but not all.

2. When defines copy functions for derived class. Have to handle 'base' part
as well because having own copy controls means to have full responsibilities.

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs )
  :priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  {
    priority = rhs.priority;
    return *this;
  }
};


The problem is that this code do nothing about base part and that means: 

For construction, PriorityCustomer ctor will use a default ctor of Customer
and Customer part will be default init. For copy, PriorityCustomer copy-ctor
will do nothing on Customer part and it will remain unchanged. So shall be:

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs ) 
  :Customer(rhs),~
  priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  { 
    Customer::operator=(rhs); ~
    priority = rhs.priority;
    return *this;
  }
};


={============================================================================
*kt_dev_cxx_0000* cxx-copy-assign-self

{cxx-copy-self-assign}
EC++11. When implement `copy-assign`, must think about self-assign and
exception-safe.

Why? because there are 'less' obvious self-assignment cases and are the result
of aliasing: having more than one way to refer to an object.

<one> aliasing

a[i] = a[j];   // potential assign to self when i==j
*px = *py;     // potential assign to self when point to the same

<two> aliasing in same class hierarchy since base ptr can point to derived.
Here, rb and *pd might actually be the same.

void doSomething( const Base& rb, Derived* pd );


{direct-self-assign-check} EXP++38.
Use `direct-self-assign-check` for optimization and use `copy-and-swap-idiom`
for correct implementation.

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  if( this != &rhs )
  {
    // ...
  }
}


{cxx-copy-and-swap-idiom}
Classes that define `swap` often use it to define their `copy-assign`. This
`swap`s the lhs operand with a 'copy' of the rhs.

// valuelike
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

To

// HasPtr copy-ctor copies the string in right hand operand into rhs before
// changing left hand operand.
HasPtr& HasPtr::operator=(HasPtr rhs)
{
  swap(*this, rhs);             // see *cxx-copy-swap* for HasPtr::swap()
  return *this;                 // rhs is destroyed, which deletes the old ps.
}

The `copy-and-swap-idiom` is exception-safe which automatically handle
self-assign.

The only code that might throw is the new expression 'inside' the copy-ctor.
If an exception occurs, it will happen before having changed the lhs.

Also EC++11 says the compiler can generate more efficient code by moving
copying from the function body to parameter construction. 


={============================================================================
*kt_dev_cxx_0000* cxx-pass-by-reference cxx-reference

{pointer-and-reference} *ex-interview*
EC++20. If you peek under the hood of a C++ compiler, will find that
references are typically implemented as pointers. 

To this question, reference may or may not be the same as pointer. In user
level, there are differences and in compiler level, implemented as pointers.
The reference is a sub set of pointer which is limited in use?


{why-reference} cxx-return-reference cxx-operator-[]

o No copy made so efficient code

o Syntatic need such as return of operator[], operator*

vector<T> v; v[5] = 10;

see *cxx-swap*


{differences}
"No operator operates on a reference" which means operation becomes operation
on underlying object since a reference is another name.

o `no-null-reference` and `must be initialized(binded)` 

From MEC++01. Unlike pointer, `no need to check its validity` since always
refers to an object. So efficient code.

void printDouble( const double* pd )
{
  if(pd)
    cout << *pd;
}

to

void printDouble( const double& rd )
{ cout << rd; }


o `bound-once`

All operations on that reference are actually operations on the object to
which the reference is bound. Reference is `bound-once` but for pointer, can
change pointer itself and can point any other objects.


o `no-reference-to-reference` 

There is no reference to a reference. but there's a pointer to a pointer. 

This do not mean it's a compile error but mean that don't have the same as
pointer has. This rrval binds to ivalue but not to rval.

TEST(CxxReference, no_reference_to_reference)
{
  {
    int ivalue{10};

    int &rval = ivalue;
    int &rrval = rval;
  }

  {
    int ivalue{10};

    int &rval = ivalue;
    int &rrval = ivalue;
  }
}


o Reference should match to type and cannot bind to a literal.

int &ref = 10;                        // error
double dval = 3.14; int &ref = dval;  // error


o `no-const-reference` whreas reference-to-const
 
There is no const reference but there's a const pointer because a pointer is
object. Like any other const object, *cxx-const* pointer must be initialized.

error: uninitialised const ‘pint’ [-fpermissive]

CPR p50. A reference is not an object. object does not mean only object of
class. A reference defines an `alternative-name` for an object. This is called
binding hence `must be initialized.`

int *const cpi = &i;    // const-pointer


o A reference has no address. 

[ RUN      ] CxxReference.no_address
ival : 100
iref : 100
irref: 100
ival : 0x7ffe9c457384
iref : 0x7ffe9c457384
irref: 0x7ffe9c457384
[       OK ] CxxReference.no_address (0 ms)

TEST(CxxReference, no_address)
{
  int ival = 100;
  int &iref = ival;
  int &irref = ival;

  cout << "ival : " << ival << endl;
  cout << "iref : " << iref << endl;
  cout << "irref: " << irref << endl;

  cout << "ival : " << &ival << endl;
  cout << "iref : " << &iref << endl;
  cout << "irref: " << &irref << endl;
}


o `no-array-of-reference` no-pointer-to-reference

No array and vector of reference.

int* ptrs[10];
int& refs[10];    // error. no arrays of ref


o no-null-reference

C++PL p198. If you need a notion of "no value", pointers offer nullptr. There is
no equivalent null reference, so if you need a no value using a pointer may be
most appropriate.


<ex> EC++20

class Person {
  ...
  private:
    string name;
    string address;
};

class Student: public Person {
  ...
  private:
    string schoolName;
    string schoolAddress;
};

When call this function, it costs six ctor and dtor: x4 string, Person and
Student. 

bool validateStudent(Student s);

Student plato;
validateStudent(plato);

Use refernece to avoid these cost of copying:

bool validateStudent(const Student& s);

*cxx-remember*
The good points:

o Less expensive since no object creation so more performance. So
  recommendation is that: 

  use `pass-by-value` for built-in, iterator, and `cxx-function-object` 
  use `pass-by-reference` for class types.

  NOTE: WHY cxx-function-object?

o The `const` is necessary since in pass-by-value case, the caller know that
  they are shielded from any changes the function might make. To have the same
  protection for pass-by-reference, need const. 

o Can avoid *cxx-sliced-off* problem. For example:

class Window {
  public:
    ...
    std::string name() const;
    virtual void display() const;
};

class WindowWithScrollBars: public Window {
  public:
    ...
    virtual void display() const;
};

// see "Window w"
void printNameAndDisplay(Window w)
{
  std::out << w.name();
  w.display();
}

WindowWithScrollBars wwsb; 
printNameAndDisplay(wwsb);

Which version of display will be called? Always be the Window::display() since
it is pass-by-value using Window copy ctor and is sliced-offed. Hence Window
object. To fix this, should use pass-by-reference.

void printNameAndDisplay(const Window& w)
{
  std::out << w.name();
  w.display();
}


<ex>
// C++ Templates The Complete Guide Second Edition

1.6.1 Pass by Value or by Reference?

You might wonder, why we in general declare the functions to pass the
arguments by value instead of using references. 

In general, passing by reference is recommended for types other than cheap
simple types (such as fundamental types or std::string_view), because no
unnecessary copies are created.

However, for a couple of reasons, passing by value in general is often better:

o The syntax is simple.
o Compilers optimize better.
o *cxx-move* semantics often makes copies cheap.
o And sometimes there is no copy or move at all.

In addition, for templates, specific aspects come into play:

*cxx-template-reference*

o A template might be used for both simple and complex types, so choosing the
  approach for complex types might be counter-productive for simple types.

o As a caller you can often still decide to pass arguments by reference, using
  std::ref() and std::cref() (see Section 7.3 on page 112). *cxx-ref*

o Although passing string literals or raw arrays always can become a problem,
  passing them by reference often is considered to become the bigger problem.
  All this will be discussed in detail in Chapter 7. For the moment inside the
  book we will usually pass arguments by value unless some functionality is
  only possible when using references.


<ex> *cpp-ex-tree* *cpp-recursive*

TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
  if(!root)
  {
    root = newnode;
    root->left = root->right = NULL;
  }
  else if( LT(newnode->entry.key, root->entry.key) )
    root->left = TreeInsert( root->left, newnode);
  else
    root->right = TreeInsert( root->right, newnode);

  return root;
}

int main()
{
  TreeNode *proot, *pnode;
  CreateTree( &proot );

  for(int idx = 0; idx < size; idx++)
  {
    pnode = MakeTreeNode( arr[idx] );
    proot = TreeInsert( proot, pnode );
    // TreeInsert( proot, pnode );        // ERROR
  }
  ...
}

The problem is that it does not update proot with the return from TreeInsert
when recursive ends and proot remains null.

Since this passes pointer by value; that is pass by value but value is a
pointer although uses pointer form. The point is that this do not change what
pointer points to but change pointer itself. 


Revised to use `pass by reference`

void TreeInsert( TreeNode** root, TreeNode* newnode )
{
  if(!*root)
  {
    *root = newnode;
    (*root)->left = (*root)->right = NULL;
  }
  else if( LT(newnode->entry.key, (*root)->entry.key) )
    TreeInsert( &((*root)->left), newnode);
  else
    TreeInsert( &((*root)->right), newnode);
}

int main()
{
  for(int idx = 0; idx < size; idx++)
  {
    pnode = MakeTreeNode( arr[idx] );
    TreeInsert( &proot, pnode );
  }
}


The pass by reference is not about the form, pointer or reference, but about
whether it's object itself, 'pointed' object and something referring to.


<ex>
tree example from random-binary-search-tree-template-version

template <typename Entry>
class Binary_tree 
{
   Binary_node<Entry> *root;
};

template <typename Record>
Error_code Search_tree<Record>::insert( const Record &new_data )
{
  return search_and_insert( this->root, new_data );
}

// As with the above example, have to use reference of pointer *cxx-declarator*
// Otherwise, suffers the same problem as TreeInsert().
// 
// Error_code Search_tree<Record>::search_and_insert( 
//  Binary_node<Record> *sub_root, 
//  const Record &new_data); 

template <typename Record>
Error_code Search_tree<Record>::search_and_insert( 
    Binary_node<Record> *&sub_root, 
    const Record &new_data ) 
{
  if( sub_root == NULL )
  {
    sub_root = new Binary_node<Record>(new_data);
    return success;
  }
  else if( new_data < sub_root->data )
    return search_and_insert( sub_root->left, new_data );
  else if( new_data > sub_root->data )
    return search_and_insert( sub_root->right, new_data );
  else 
    return duplicate_error;
}

See how using a reference can make a code simple and neat to implement pass by
reference approach than using a pointer.


*cxx-reference-return*

namespace cxx_reference
{
  class Screen
  {
  private:
    int move;
    int set;

  public:
    Screen()
        : move(0)
        , set(0)
    {}

    Screen &set_move_1(int val)
    {
      move = val;
      return *this;
    }

    Screen &set_move_2(int val) { move = val; }

    Screen set_move_3(int val)
    {
      move = val;
      return *this;
    }

    Screen set_move_4(int val) { move = val; }

    void set_set(int val) { set = val; }

    std::string print()
    {
      std::ostringstream os{};
      os << "move " << move << ", set " << set;
      return os.str();
    }
  };

  class Foo
  {
  private:
    std::string _name;

  public:
    std::string &get_name_1() { return _name; }

    std::string &get_name_2()
    {
      std::string name{"get_name_2"};
      return name;
    }

    std::string print()
    {
      std::ostringstream os{};
      os << _name;
      return os.str();
    }
  };
} // namespace cxx_reference

TEST(CxxReference, check_return)
{
  using namespace cxx_reference;

  // shows that the call operator and dot operator has the same precedence and
  // left associative. so can use the result of a call to call a member of the
  // resulting object.

  // set_move_1() returns reference
  {
    Screen scr{};

    scr.set_move_1(5).set_set(10);
    EXPECT_THAT(scr.print(), "move 5, set 10");
  }

  // set_move_2() returns reference
  {
    Screen scr{};

    scr.set_move_2(5).set_set(10);
    EXPECT_THAT(scr.print(), "move 5, set 10");
  }

  // set_move_3() returns copy so set_set() do not change scr
  {
    Screen scr{};

    scr.set_move_3(5).set_set(10);
    EXPECT_THAT(scr.print(), "move 5, set 0");
  }

  // set_move_4() returns copy
  {
    Screen scr{};

    scr.set_move_4(5).set_set(10);
    EXPECT_THAT(scr.print(), "move 5, set 0");
  }
}

// see difference when use "cxx-auto"

TEST(CxxReference, check_return_and_auto)
{
  using namespace cxx_reference;

  // set_move_1() returns reference and use "auto &"
  {
    Screen scr{};

    auto &screen = scr.set_move_1(5);
    screen.set_set(10);
    EXPECT_THAT(scr.print(), "move 5, set 10");
  }

  // set_move_1() returns reference and use "auto". *cxx-auto*
  {
    Screen scr{};

    auto screen = scr.set_move_1(5);
    screen.set_set(10);
    EXPECT_THAT(scr.print(), "move 5, set 0");
  }
}


<cxx-return-reference-cxx-access-private> cxx-operator-==

// Q: does it work to access private of that?

bool operator==(const Location &that)
{
  return longitude_ == that.longitude_ &&
    latitude_ == that.latitude_;
}

// while use of reference member is error when returning whole object but use of
// reference member is find when returning that reference member

class AUsePrivateMemberThroughReference
{
  private:
    int val_;

  public:
    AUsePrivateMemberThroughReference() : val_(10) {}

    int &returnReference()
    {
      return val_;
    }

    // cxx.cpp: In member function ‘virtual void Reference_UsePrivateMemberThroughReference_Test::TestBody()’:
    // cxx.cpp:800:9: error: ‘int AUsePrivateMemberThroughReference::val_’ is private
    //      int val_;
    //          ^
    // cxx.cpp:840:9: error: within this context
    //      ref.val_ = 100;

    // AUsePrivateMemberThroughReference &returnReference()
    // {
    //     return *this;
    // }

    void changePrivate(AUsePrivateMemberThroughReference &that)
    {
      that.val_ = 200;
    }

    void printValue() const
    {
      std::cout << "value: " << val_ << std::endl;
    }
};


TEST(Reference, AccessOnReference)
{
    AUsePrivateMemberThroughReference firstObjectWithValue10;

    firstObjectWithValue10.printValue();
    int &ref = firstObjectWithValue10.returnReference();
    ref = 100;
    firstObjectWithValue10.printValue();

    // error
    // firstObjectWithValue10.printValue();
    // AUsePrivateMemberThroughReference &ref = firstObjectWithValue10.returnReference();
    // ref.val_ = 100;
    // firstObjectWithValue10.printValue();

    AUsePrivateMemberThroughReference secondObjectWithValue10;
    secondObjectWithValue10.changePrivate(firstObjectWithValue10);
    firstObjectWithValue10.printValue();
}


={============================================================================
*kt_dev_cxx_0000* cxx-vexing-parse

<ex> EXC++42
This is function declaration for a function named t that takes no parameters
and returns T by value.

T t();

<ex>
The intention is to have value-init but defines a function.

std::string source();
source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);

error: assignment of function 'std::string source()'
error: cannot convert 'std::string' to 'std::string()' in assignment

See `function` in error message. to use it as intended, create a temporary and
use copy initialzation. not useful.

std::string source = string();

<ex>
CPR 293. Using the default ctor.

Sales_data obj();

if (obj.isbn() == Primer.isbn())

Intended to declare a default-init object but the compiler complains that
  cannot apply member access notation to a function. The correct way:

Sales_data obj;

<ex>
From C++CA 2.1.1, if you pass a *cxx-temporary* rather than a named variable
`the syntax can be the same as that of a fuction declaration.`

class background_task;
std::thread my_thread( background_task() );     // T()

This declares the `function` my_thread that takes a single parameter which is
  pointer to a function taking no parameters and returning a background_task
  object. 
  
However, the intention was to create std::thread `instance` with function
object to run.

Solution?

std::thread my_thread( (background_task()) );   // extra ()
std::thread my_thread{ background_task() };     // brace-init

<ex>

{
  // error: request for member ‘isNull’ in ‘y’, which is of non-class type
  // ‘QVariant(QString (*)())’ QVariant y(QString());

  // OK
  // QVariant y((QString()));

  // OK.
  QVariant y(QString{});
}


={============================================================================
*kt_dev_cxx_0000* cxx-copy-dyn-resource cxx-ex-hasptr-exmaple

{when-use-resource-has-dyn-lifetime}
* Don't know how many object is needed
* Don't know the exact type of object
* Share data between objects


{valuelike-or-pointerlike}
The topic about valuelike or pointerlike is the difference in how to implement
copy functions of a type. No different in swap discussion.

<valuelike> deep-copy, self-contained-object
The copy and the original are independent since copy underlying object as well.

note: 
The STL containers and string use valuelike copy.

namespace VALUELIKE 
{

// value-like hasptr
class HasPtr 
{
  public:
    HasPtr(const std::string &s = std::string()):
      ps_(new std::string(s)), count_(0) 
  {
    cout << "::HasPtr(), " << *ps_ << endl;
  }

    // copy ctor *cxx-except-safety*
  HasPtr(const HasPtr &rhs):
    ps_(new std::string(*rhs.ps_)), count_(rhs.count_) 
  {
    cout << "::HasPtr(const HasPtr&), " << *ps_ << endl;
  }

  // copy assign
  HasPtr& operator=(const HasPtr &rhs)
  {
    auto newps = new string(*rhs.ps_);
    // delete old only when copy is done
    delete ps_;
    ps_ = newps;
    count_ = rhs.count_;
    return *this;
  }

  ~HasPtr() { cout << "::~HasPtr(), " << *ps_ << endl; delete ps_; }

  private:
    std::string *ps_;
    int count_;
};

// hp is copy ctor'ed
HasPtr f(HasPtr hp)
{
  // ret is copy ctor'ed
  HasPtr ret = hp;
  return ret;
}

} // namespace


// = 03 ======
// ::HasPtr(), hi mom!
// ::HasPtr(const HasPtr&), hi mom!
// ::HasPtr(const HasPtr&), hi mom!
// ::~HasPtr(), hi mom!
// ::~HasPtr(), hi mom!
// =----======
// ::~HasPtr(), hi mom!

void t_sp_03()
{
  using namespace VALUELIKE;

  // allocate a copy
  HasPtr h("hi mom!");

  // copy ctor copies h in the call f and that copy is destroyed when f exits
  f(h);
  cout << "=----======" << endl;
}


namespace VALUELIKE_MOVE 
{

// value-like hasptr with cxx-move
// The HasPtr copy-and-swap example shows that 'single' assignment operator acts
// as both copy and move assign.

class HasPtr 
{
  friend void swap(HasPtr &lhs, HasPtr &rhs);

  public:
  HasPtr(const std::string &s = std::string()):
    ps_(new std::string(s)), count_(0) 
  {
    cout << "::HasPtr(), " << *ps_ << endl;
  }

  // copy ctor
  HasPtr(const HasPtr &rhs):
    ps_(new std::string(*rhs.ps_)), count_(rhs.count_) 
  {
    cout << "::HasPtr(const HasPtr&), " << *ps_ << endl;
  }

  // move ctor
  HasPtr(HasPtr &&rhs) noexcept:
    ps_(rhs.ps_), count_(rhs.count_)
    {
      cout << "::HasPtr(HasPtr&&), " << endl;
      rhs.ps_ = nullptr;
    }

  // // copy assign
  // HasPtr& operator=(const HasPtr &rhs)
  // {
  //     auto newps = new string(*rhs.ps_);
  //     // delete old only when copying is okay
  //     delete ps_;
  //     ps_ = newps;
  //     count_ = rhs.count_;
  //     return *this;
  // }

  // move assign is both move- and copy-assign
  // *cxx-move* *cxx-copy-and-swap*
  // see that use (HasPtr rhs) but not (HasPtr &&rhs) and since operator=
  // use non-reference type, use either copy ctor or move ctor depending
  // on the type of argument.
  HasPtr &operator=(HasPtr rhs)
  {
    cout << "::operator=(HasPtr), " << endl;
    swap(*this, rhs);
    return *this;
  }

  // this causes "seg fault" see *gdb-debug-stl*
  // ~HasPtr() { cout << "::~HasPtr(), " << *ps_ << endl; delete ps_; }
  //
  // #0  0x00007f26b4131f10 in std::basic_ostream<char, std::char_traits<char> >& std::operator<< <char, std::char_traits<char>, std::allocator<char> >(std::basic_ostream<char, std::char_traits<char> >&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()
  //    from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
  // #1  0x0000000000403fa6 in VALUELIKE_MOVE::HasPtr::~HasPtr() ()
  // #2  0x0000000000402761 in t_sp_13_2() ()
  // #3  0x000000000040374e in main ()

  // h    -> (1)
  // h2   -> (2)
  //
  // h = h2
  //
  // h    -> (1)
  // h2   -> (2)
  // arg  -> (3)      // copy ctor'ed from h2
  //
  // h    -> (3)
  // h2   -> (2)
  // arg  -> (X)      // dtor'ed
  //
  // h = std::move(h2);
  //
  // h    -> (3)
  // h2   -> (X)      // moved-from state
  // arg  -> (2)      // moved-to
  //
  // h    -> (2)
  // h2   -> (X)      // moved-from state
  // arg  -> (X)      // dtor'ed
  //
  // So h2.ps_ is null which HasPtr move ctor did. If comment out the line
  // to set nullptr to ps_ in move ctor, then this dtor could work? NO
  // since do *double-delete*
  //
  // h    -> (3)
  // h2   -> (2)      // moved-from state
  // arg  -> (2)      // moved-to
  //
  // h    -> (2)
  // h2   -> (2)      // moved-from state
  // arg  -> (X)      // dtor'ed
  //
  // ...
  // =----======
  // ::~HasPtr(), hi mom!
  // ::~HasPtr(), !0 
  // *** Error in `./a.out': free(): invalid pointer: 0x00000000020f2058 ***
  // Aborted (core dumped)
  // 
  // Program terminated with signal SIGABRT, Aborted.
  // #0  0x00007f81f6370067 in __GI_raise (sig=sig@entry=6)
  //     at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
  // 56	../nptl/sysdeps/unix/sysv/linux/raise.c: No such file or directory.
  // (gdb) bt
  // #0  0x00007f81f6370067 in __GI_raise (sig=sig@entry=6)
  //     at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
  // #1  0x00007f81f6371448 in __GI_abort () at abort.c:89
  // #2  0x00007f81f63ae1b4 in __libc_message (do_abort=do_abort@entry=1, 
  //     fmt=fmt@entry=0x7f81f64a3210 "*** Error in `%s': %s: 0x%s ***\n")
  //     at ../sysdeps/posix/libc_fatal.c:175
  // #3  0x00007f81f63b398e in malloc_printerr (action=1, 
  //     str=0x7f81f649f326 "free(): invalid pointer", ptr=<optimized out>)
  //     at malloc.c:4996
  // #4  0x00007f81f63b4696 in _int_free (av=<optimized out>, p=<optimized out>, 
  //     have_lock=0) at malloc.c:3840
  // #5  0x000000000040bb32 in __gnu_cxx::new_allocator<char>::deallocate (
  //     this=0x7ffcc426a107, __p=0x20f2058 "!")
  //     at /usr/include/c++/4.9/ext/new_allocator.h:110

  ~HasPtr() 
  { 
    if (this->ps_)
      cout << "::~HasPtr(), " << *ps_ << endl; 
    else
      cout << "::~HasPtr(), " << endl; 
    delete ps_; 
  }

  private:
  std::string *ps_;
  int count_;
};

inline void swap(HasPtr &lhs, HasPtr &rhs)
{
  using std::swap;
  swap(lhs.ps_, rhs.ps_);
  swap(lhs.count_, rhs.count_);
}

} // namespace


// = 13_2 ======
// ::HasPtr(), hi mom!
// ::HasPtr(const HasPtr&), hi mom!
// ::HasPtr(const HasPtr&), hi mom!
// ::operator=(HasPtr), 
// ::~HasPtr(), hi mom!
// ::HasPtr(HasPtr&&), 
// ::operator=(HasPtr), 
// ::~HasPtr(), hi mom!
// =----======
// Segmentation fault

// = 13_2 ======
// ::HasPtr(), hi mom!
// ::HasPtr(const HasPtr&), hi mom!
// ::HasPtr(const HasPtr&), hi mom!
// ::operator=(HasPtr), 
// ::~HasPtr(),             // temp from copy assign 
// ::HasPtr(HasPtr&&), 
// ::operator=(HasPtr),     // temp form copy assign
// ::~HasPtr(), 
// =----======
// ::~HasPtr(),             // h2 from main
// ::~HasPtr(), hi mom!     // h from main

void t_sp_13_2()
{
  using namespace VALUELIKE_MOVE;

  // allocate a new copy
  HasPtr h("hi mom!");
  HasPtr h2(h);

  h = h2;
  h = std::move(h2);
  cout << "=----======" << endl;
}


<pointerlike> shallow-copy, own-reference-counting *cxx-sp-shared*

class HasPtr
{
    public:
        HasPtr(const std::string &s = std::string())
            : ps_(new std::string(s)), use_(new std::size_t(1))
        {
            std::cout << "::HasPtr(): " << *ps_ << " used " << *use_ << std::endl;
        }

        // copy ctor
        HasPtr(const HasPtr &rhs)
            : ps_(rhs.ps_), use_(rhs.use_)
        {
            // increase a counter
            ++*use_;
            std::cout << "::HasPtr(const HasPtr &): " << *ps_ << " used " << *use_ << std::endl;
        }

        // copy assign
        // decrease lhs and increase rhs
        HasPtr& operator=(const HasPtr &rhs)
        {
            // increase first to support cxx-self-assign. ???
            ++*rhs.use_;

            // do dtor's work. when there is no users
            if (--*use_ == 0)
            {
                delete ps_;
                delete use_;
            }

            // do ctor's work
            ps_ = rhs.ps_;
            use_ = rhs.use_;
            std::cout << "::HasPtr &operator=(const HasPtr &): " << *ps_ << " used " << *use_ << std::endl;

            return *this;
        }

        // move ctor
        HasPtr(HasPtr &&rhs)
            : ps_(rhs.ps_), use_(rhs.use_)
        {
            // do not increase a counter
            // ++*use_;
            
            // this why ~HasPtr() has checks
            rhs.ps_ = nullptr;
            rhs.use_ = nullptr;
            std::cout << "::HasPtr(HasPtr &&): " << *ps_ << " used " << *use_ << std::endl;
        }

        // move assign
        HasPtr& operator=(HasPtr &&rhs)
        {
            // cxx-self-assign direct check
            if (this != &rhs)
            {
                if (--*use_ == 0)
                {
                    delete ps_; delete use_;
                }

                ps_ = rhs.ps_; use_ = rhs.use_;

                std::cout << "::HasPtr &operator=(HasPtr &&): " << *ps_ << " used " << *use_ << std::endl;

                rhs.ps_ = nullptr;
                rhs.use_ = nullptr;
            }

            return *this;
        }

        ~HasPtr()
        {
            // when there is no users
            // have to check if use_ is not null since use_ can be null due to
            // move support. Otherwise, cxx-seg-fault. 
            // For copy, works okay without it.
            if (use_ && --*use_ == 0)
            {
                std::cout << "::~HasPtr(): " << *ps_ << " used " << *use_ << std::endl;
                delete ps_; delete use_;

                // cxx-nullptr
                // error: cannot convert ‘size_t* {aka long unsigned int*}’ to ‘std::string* {aka std::basic_string<char>*}’ in assignment
                // rhs.ps_ = rhs.use_ = nullptr;
                ps_ = nullptr;
                use_ = nullptr;
            }
        }

    private:
        // value type
        std::string *ps_;

        //  other member
        // int other_;

        // reference count to track how many shares this
        std::size_t *use_;
};

HasPtr use_ptr(HasPtr hp)
{
    HasPtr ret;
    std::cout << "use_ptr: use copy controls" << std::endl;
    ret = hp;
    return ret;
}

// =============
// ::HasPtr(): hi mon! used 1
// ::HasPtr(const HasPtr &): hi mon! used 2
// ::HasPtr(const HasPtr &): hi mon! used 3
// -------------
// ::~HasPtr(): hi mon! used 0

TEST(CxxSpTest, UseHasPtrCopyCtor) {

    // h1, h2, h3 shares the same underlying.
    
    cout << "=============" << endl;

    HasPtr h1("hi mon!");

    HasPtr h2 = h1;
    HasPtr h3{h2};

    cout << "-------------" << endl;
}

// =============
// ::HasPtr(): hi mom! used 1
// ::HasPtr(HasPtr &&): hi mom! used 1
// ::HasPtr(HasPtr &&): hi mom! used 1
// -------------
// ::~HasPtr(): hi mom! used 0

TEST(CxxSpTest, UseHasPtrMove) {

    // h, h2, and h3 use the same one underlying string
 
    cout << "=============" << endl;

    HasPtr h1("hi mom!");
    HasPtr h2 = std::move(h1);
    HasPtr h3 = std::move(h2);

    cout << "-------------" << endl;
}

// =============
// ::HasPtr(): hi mon! used 1
// ::HasPtr(): hi dad! used 1
// ::HasPtr &operator=(const HasPtr &): hi mon! used 2
// -------------
// ::~HasPtr(): hi mon! used 0

TEST(CxxSpTest, UseHasPtrCopyAssign) {

    cout << "=============" << endl;

    HasPtr h1("hi mon!");
    HasPtr h2("hi dad!");

    h2 = h1;

    cout << "-------------" << endl;
}

// =============
// ::HasPtr(): hi mon! used 1
// ::HasPtr(): hi dad! used 1
// ::HasPtr &operator=(HasPtr &&): hi mon! used 1
// -------------
// ::~HasPtr(): hi mon! used 0

TEST(CxxSpTest, UseHasPtrMoveAssign) {

    cout << "=============" << endl;

    HasPtr h1("hi mon!");
    HasPtr h2("hi dad!");

    h2 = std::move(h1);

    cout << "-------------" << endl;
}

// =============
// ::HasPtr(): hi mon! used 1
// ::HasPtr(const HasPtr &): hi mon! used 2
// ::HasPtr():  used 1
// use_ptr: use copy controls
// ::HasPtr &operator=(const HasPtr &): hi mon! used 3
// -------------
// ::~HasPtr(): hi mon! used 0

TEST(CxxSpTest, UseHasPtrUseFunction) {

    cout << "=============" << endl;

    HasPtr h1("hi mon!");
    HasPtr h2 = use_ptr(h1);

    cout << "-------------" << endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-copy-swap cxx-swap copy-and-swap-idiom

The typical swap involves "one copy and two assignments"

T temp = v1;
v1 = v2;
v2 = temp;

HasPtr temp = v1;
v1 = v2;
v2 = temp;

None of this memory allocation is necessary. If could swap its internal
strcture, pointers, in this case rather than using std::swap, expects
efficiency and constant-time operation. 

The function swap() is provided to swap the values of two objects. 

// The general implementation of swap() is defined in `utility` as follows
// cannot find it in gcc

namespace cxx_code 
{
  template <typename T>
    inline void swap(T& a, T& b) ... {
      T tmp(std::move(a));
      a = std::move(b);
      b = std::move(tmp);
    }
} // namesapce

namespace cxx_reference
{
  void swap_by_value(int x, int y)
  {
    int temp;
    temp = x;
    x = y;
    y = temp;
  }

  void swap_by_pointer(int *x, int *y)
  {
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
  }

  void swap_by_reference(int &x, int &y)
  {
    int temp;
    temp = x;
    x = y;
    y = temp;
  }
} // namespace

TEST(Reference, Swap)
{
  using namespace cxx_reference;

  // no swap happens since uses a copy
  {
    int x = 10, y = 20;
    swap_by_value(x, y);
    EXPECT_EQ(x, 10);
    EXPECT_EQ(y, 20);
  }

  // swap
  {
    int x = 10, y = 20;
    swap_by_pointer(&x, &y);
    EXPECT_EQ(x, 20);
    EXPECT_EQ(y, 10);
  }

  // swap, no need to pass its address
  {
    int x = 10, y = 20;
    swap_by_reference(x, y);
    EXPECT_EQ(x, 20);
    EXPECT_EQ(y, 10);
  }

  // *cxx-swap* std-swap uses reference
  {
    int x = 10, y = 20;
    std::swap(x, y);
    EXPECT_EQ(x, 20);
    EXPECT_EQ(y, 10);
  }
}

So which one is better between type specific swap or std::swap given move
sementics are supported by all containers?


{cxx-swap-type-specific}
*cxx-valuelike* shows that overloaded swap, *cxx-template-speciailsation* is
needed for valuelike class for:

`optimization`, `exception-safety`

`Like STL containers, provide both memeber and non-member swap` To have the
member version swap never throw exception because it use swap on built-in
types that never throw exception. This offers the strong excepiton-safety
guarantee.


<cxx-swap-and-const>
swap works always regardless of const. Here swap works on built-in type and
pointer which is not affected by constness check; bitwise const.


CPR 516. Classes that manages `resources` often also define a swap. Defining
swap is particularly important for classes that plan to `use with algorithms`
that `reorder elements.` Such algorithms call swap whenever they need to
exchange two elements. reorder uses copy-assign.

If it was *cxx-pointerlike* own swap is not necessary. The pointerlike is good
for copy-control and swap.

// *cxx-valuelike* for better peformance but pointerlike wins
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

// HasPtr copy-ctor copies the string in right hand operand into rhs before
// changing left hand operand.

HasPtr& HasPtr::operator=(`HasPtr rhs`)
{
  swap(*this, rhs);             // see *cxx-copy-swap* for HasPtr::swap()
  return *this;                 // rhs is destroyed, which deletes the old ps.
}

// *cxx-pointerlike*
class HasPtr {

  friend void swap(HasPrt&, HasPtr&);         // friend

  public:
   HasPtr(const std::string& s = std::string() )
    : ps( new std::string(s)), i(0) {}
        
   ~HasPtr() { delete ps; }

  private:
   std::string* ps;
};

// overloaded type specific swap, *cxx-template-speciailsation*

inline void swap(HasPtr& lhs, HasPtr& rhs)
{
  using std::swap;                              // note:  
  swap( lhs.ps, rhs.ps );                       // resolved to std::swap()
  
  OR 

  std::swap( lhs.ps, rhs.ps );
}


EC++25. *cxx-pattern-pimpl-idiom*

class WidgetImpl {                          // class for Widget data;
   public:                                  // details are unimportant
      ...

   private:
      std::vector<double> v;                // possibly lots of data 
                                            // expensive to copy!
};

class Widget {                              // class using the pimpl-idiom
   public:
      Widget(const Widget& rhs);

      `Widget& operator=(const Widget& rhs)`  // to copy a Widget, copy its
      {                                     // WidgetImpl object. For
       ...                                  // details on implementing
       `*pImpl = *(rhs.pImpl);`               // operator= in general,
       ...                                  // see Items 10, 11, and 12.
      }
>
   private:
      WidgetImpl *pImpl;                    // ptr to object with this
};                                              

Imagine how expensive it may be when there's no swap for Widget and when use
`std::swap()`

Widget A, B; 
swap(A, B);

All we really need to do is swap their pImpl pointers, but the default swap
algorithm has no way to know that. Instead, it would copy not only three
Widgets, but also three WidgetImpl objects. Very inefficient. Cost three
copies that use `operator=` of valuelike class. For some types such as
cxx-pattern-pimpl-idiom, none of these copies are really necessary. 

How to avoid these cost? To address this, should provide `type specific` swap
to be used by clients


<attempt-one> use non-member swap and total-template-specialization

namespace std {

  template<typename T>          // typical implementation of std::swap;
  void swap(T& a, T& b)         // swaps a's and b's values
  {
    T temp(a);
    a = b;
    b = temp;
  }
}

This is a way to say that to specialize std::swap for Widget. This is called
`total-template-specialization`. See *cxx-template-specialization* 

namespace std {                              

  // defines in std namespace
  // this is a specialized version of std::swap when T is Widget.
  // see syntax and own definition.

  template<>                                 
  void swap<Widget>(Widget& a, Widget& b)    
  {
    // to swap Widgets, just swap their pImpl pointers
    swap(a.pImpl, b.pImpl);                  
  }
}

Although not permitted to alter the contents of the std namespace, but we are
allowed to totally specialize standard templates (like swap) for types of our
own creation (such as Widget).

This function will not compile because it is trying to access the pImpl
pointers inside a and b, and they are 'private' 

So other ways might be:

  * Could declare our specialization a friend, but the convention is different:
    so not consider. 

  * specialized (overloaded) swap calls public member swap. It's okay since do
    not use friend here.

class Widget {                     // same as above, except for the
public:                            // the public swap member func
  ...
  void swap(Widget& other)
  {
    using std::swap;               // the need for this declaration
    swap(pImpl, other.pImpl);      // to swap Widgets, swap their pImpl pointers
  }
  ...
};

namespace std {

  template<>
  void swap<Widget>(Widget& a, Widget& b)
  {
    a.swap(b);                     // to swap Widgets, call member function
  }
}

this works since the specicialised version wins in funcation matching.


<attempt-two> use-template-specialization for class template
However, suppose that Widget and WidgetImpl were class templates instead of
classes. Needs more generic solution but cannot use the same as before since
the specialization would look like:

namespace std {

  template<typename T>                       
  void swap<Widget<T>>(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);                     // to swap Widgets, call their
  }                                // swap member function
}

This is 'illegal' code since C++ `do not allow 'partial' specialization` for
function template. If this is possible, then it means that can add a template
into std namespace.

The overloading function-template is fine, but std is a special namespace, and
the rules governing it are special, too. It's okay to totally specialize
templates in std, but it's not okay to add new templates (or classes or
    functions or anything else) to std. Undefined behavior.


<attempt-three> *cxx-swap-solution*
Works for classes as for class templates. 

namespace WidgetStuff {
  // templatized WidgetImpl, etc.
  ...                                     

  // has swap member function

  template<typename T>                    
  class Widget { 
    ... 
  };                   

  ...

  // overloaded non-member swap function. `not part of the std namespace`
  template<typename T>                    
  void swap(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);
  }
}

This use swap(Widget<T>&, Widget<T>&) through *cxx-arg-dependent-lookup*


<cxx-swap-solution>

The aim is:

  "If a class defines its own swap, uses that class-specific version.
  If not , uses the std::swap() instead."

template<typename T>
void doSomething(T& obj1, T& obj2)
{
  // make std::swap available in this function
  `using std::swap;`
  ...
  
  // use `unqualified swap` 
  // try the best swap for objects of type T via *cxx-arg-dependent-lookup* 

  `swap`(obj1, obj2);          
  ...
}

How this work:

o using std::swap(). As *cxx-name-lookup* using-declaration add this name to
  the candidate set which are in the same scope. Type specific version is a
  better match in function matching since std::swap is template.

o Use *cxx-arg-dependent-lookup* in swap(HasPtr&, HasPtr&)

note: 
Does "using std::swap" hide swap(T)? No since *cxx-hide-name* happens between
other scopes.


<attempt-four> 
attempt-treee and plus std::swap specialization when write class but not class
templeate Why? To cover possible wrong use like:

std::swap(obj1, obj2);

This force compiler to consider only the swap in std including any template
specialization. In addition to the type specific swap in a class, have
specialized std::swap to call member swap. This is to make type-specific swap
implementations available to code written in this fashion.


{case}
*cxx-vector-swap* code since vector is *cxx-valuelike*

As shown the reference, to provide special implementations for more complex
types by using function overloading.

The key is that this is `overloaded` global swap() for `this type.` That means
that every container has member and nonmember swap.

namespace cxx_code
{
  template<typename _Tp, typename _Alloc = std::allocator< _Tp >>
    class vector : protected _Vector_base<_Tp, _Alloc>
  {
    /**
     *  @brief  Swaps data with another %vector.
     *  @param  x  A %vector of the same element and allocator types.
     *
     *  This exchanges the elements between two vectors in constant time.
     *  (Three pointers, so it should be quite fast.)
     *  Note that the global std::swap() function is specialized such that
     *  std::swap(v1,v2) will feed to this function.
     */
    void
      swap(vector& __x)
      {
        std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
        std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
        std::swap(this->_M_impl._M_end_of_storage,
            __x._M_impl._M_end_of_storage);

        // _GLIBCXX_RESOLVE_LIB_DEFECTS
        // 431. Swapping containers with unequal allocators.
        std::__alloc_swap< _Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
            __x._M_get_Tp_allocator());
      }
  }

  /// See std::vector::swap().
  template<typename _Tp, typename _Alloc>
    inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}

// see how swap works on vector
// void swap( vector& other ); (until C++17)
TEST(CxxSwap, check_container)
{
  std::vector<int> coll1{1, 2, 3, 4};
  std::vector<int> coll2{5, 6, 7, 8, 9, 10};
  EXPECT_THAT(coll1.size(), 4);
  EXPECT_THAT(coll2.size(), 6);

  // swap them
  swap(coll1, coll2);

  EXPECT_THAT(coll1.size(), 6);
  EXPECT_THAT(coll1, ElementsAre(5, 6, 7, 8, 9, 10));

  EXPECT_THAT(coll2.size(), 4);
  EXPECT_THAT(coll2, ElementsAre(1, 2, 3, 4));
}


={============================================================================
*kt_dev_cxx_0000* cxx-copy-control cxx-ex-message-example

{copy-control-for-bookkeeping} 

Do not allocate dynamic resources but needs copy-controls.

CPR 519. Although copy control is most often needed for classes that allocate
resources, that is not the only reason and some class have bookkeeping or
other actions that copy control must perform.

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set
...                                  ...

<ex>
#include <iostream>
#include <set>
#include <vector>
#include <string>

// TN:
// * Do not use dynamic allocations but use pointers.
//
// * Do not use dynamic allocation, but use copy controls since her "copy" has
//   different meaning
//
//
// Sketch its operations:
//
// * Folder has pointers to Messages that is has and Messages has pointers to
// Folders it belongs.
// 
// * Message class provide save() and remove() operations to add or remove a
// Message from a specified folder. To create a new Message, specify the
// contents of the message and call save() to put a message to a folder.
//
// * To copy a message, the copy and the original will be a 'distinct' Message
// and shall be in the same 'set' of Folders. Thus copy the contents and to make
// the new to appear in the same Folders as the original, must update Folders to
// add the new message into each Folder. ADD. copy-ctor
//
// * To destroy a Message, remove it from the Folders. REMOVE. dtor.
//
// * To assign a Message, will replace the contents and remove Message from lhs
// Folder-set and add that distinct Message to rhs Folder-set. REMOVE and ADD.
// copy-assign.
//
// *cpp-remember*
//  The copy assign often does the same work as is needed in the copy ctor and
//  dtor. In this example, REMOVE and ADD. In such case the 'common' work should
//  be put in private utility functions.
//
// {
//     string s1("contents1");
// 
//     // all new messages, no copies yet
//     Message m1(s1);
// 
//     Folder f1;
// 
//     m1.save(f1); m3.save(f1); m5.save(f1);
// 
//     m1.debug_print();
//     f2.debug_print();
// 
//     // create some copies
//     Message c1(m1);
// 
//     m1.debug_print();
//     f2.debug_print();
// 
//     // now some assignments
//     m2 = m3;
// 
//     m1.debug_print();
//     f2.debug_print();
// 
//     // finally, self-assignment
//     m2 = m2;
// 
//     m1.debug_print();
//     f2.debug_print();
// }

class Message;

class Folder
{
    public:
        // def ctor ok
        Folder() = default;

        // copy ctor
        Folder(const Folder &f);

        // copy assign
        Folder &operator=(const Folder &f);

        ~Folder();

        // for user/clients
        void save(Message &m);
        void remove(Message &m);

        // for Message
        void addMsg(Message *m) { messages_.insert(m); }
        void removeMsg(Message *m) { messages_.erase(m); }

        // for debug
        void debug_print();

    private:
        std::set<Message *> messages_{};
};


class Message
{
    // *cxx-friend-member*
    friend void Folder::debug_print();
    friend void swap(Message &lhs, Message &rhs);

    public:

        // def ctor
        explicit Message(const std::string &contents = ""): contents_(contents) {}

        // copy ctor
        Message(const Message &rhs): 
            contents_(rhs.contents_), folders_(rhs.folders_)
        {
            // add_to_folders(). add lhs to folders
            for (auto &folder : folders_)
                folder->addMsg(this);
        }
        
        // copy assign
        //
        // TN:
        // *cxx-cxcept-safety*
        // it say "handle self-assignment by removing pointers before inserting
        // them" but that's not since clear() clears and remove it effectively. 
        //
        // if comment out clear() below, works file for self assign.
        // adding steps.

        Message &operator=(const Message &rhs)
        {
            // remove_from_folders(). remove lhs from folders. duplicate
            for (auto &folder : folders_)
                folder->removeMsg(this);

            // what if not call this?
            folders_.clear();

            contents_ = rhs.contents_;
            folders_ = rhs.folders_;

            // add_to_folders(). add lhs to folders. duplicate
            for (auto &folder : folders_)
                folder->addMsg(this);

            return *this;
        }

        // move ctor
        Message(Message &&rhs):
            contents_(std::move(rhs.contents_))
        {
            // move_folders(). use set move assign. duplicate
            folders_ = std::move(rhs.folders_);

            // however, do more to build "move" meaning in this class
            for (auto &folder : folders_)
            {
                folder->removeMsg(&rhs);        // pointer
                folder->addMsg(this);
            }

            // ensure that destrying m is `harmless`
            rhs.folders_.clear();
        }

        // move assign
        Message &operator=(Message &&rhs)
        {
            // cxx-self-assign direct check
            if ( &rhs != this )
            {
                // remove_from_folders(). remove lhs from folders. duplicate
                for (auto &folder : folders_)
                    folder->removeMsg(this);

                folders_.clear();

                contents_ = std::move(rhs.contents_);

                // move_folders()
                folders_ = std::move(rhs.folders_);

                // however, do more than moving members to build "move" meaning
                // in this class

                for (auto &folder : folders_)
                {
                    folder->removeMsg(&rhs);        // pointer
                    folder->addMsg(this);
                }
            }

            return *this;
        }

        ~Message()
        {
            // remove_from_folders(). remove lhs from folders. duplicate
            for (auto &folder : folders_)
                folder->removeMsg(this);

            folders_.clear();
        }

        // for user/client
        // add a message to the folder
        void save(Folder &f)
        {
            // add the folder to this message
            folders_.insert(&f);

            // add this message to the folder
            f.addMsg(this);
        }

        // remove a message from the folder
        void remove(Folder &f)
        {
            // remove the folder from this message
            folders_.erase(&f);

            // remove this message from the folder
            f.removeMsg(this);
        }

        void addFldr(Folder *f) { folders_.insert(f); }
        void removeFldr(Folder *f) { folders_.erase(f); }

        void debug_print()
        {
            std::cout << "message: " << contents_ << std::endl;
            std::cout << "appears in " << folders_.size() << " folders" << std::endl;
        }

    private:
        // *cxx-in-class-init*
        std::string contents_{};
        std::set<Folder*> folders_{};
};


// define them here due to incomplete type issue

void swap(Message &lhs, Message &rhs)
{
	using std::swap;  // not strictly needed in this case, but good habit

	// remove pointers to each Message from their (original) respective Folders
	for (auto f: lhs.folders_) 
		f->removeMsg(&lhs);
	for (auto f: rhs.folders_) 
		f->removeMsg(&rhs);

	// swap the contents and Folder pointer sets
	swap(lhs.folders_, rhs.folders_);   // uses swap(set&, set&)
	swap(lhs.contents_, rhs.contents_); // swap(string&, string&)

	// add pointers to each Message to their (new) respective Folders
	for (auto f: lhs.folders_) 
		f->addMsg(&lhs);
	for (auto f: rhs.folders_) 
		f->addMsg(&rhs);
}


Folder::Folder(const Folder &f):
    messages_(f.messages_)
{
    // add_to_message()
    for (auto &mesg : messages_)
        mesg->addFldr(this);
}

Folder &Folder::operator=(const Folder &f)
{
    // remove_from_message()
    for (auto &mesg : messages_)
        mesg->removeFldr(this);

    messages_ = f.messages_;

    // add_to_messages()
    for (auto &mesg : messages_)
        mesg->addFldr(this);

    messages_.clear();

    return *this;
}

Folder::~Folder()
{
    // remove_from_message()
    for (auto &mesg : messages_)
        mesg->removeFldr(this);

    messages_.clear();
}

void Folder::save(Message &m)
{
    messages_.insert(&m);
    m.addFldr(this);
}

void Folder::remove(Message &m)
{
    messages_.erase(&m);
    m.removeFldr(this);
}

void Folder::debug_print()
{
    std::cout << "folder contents " << messages_.size() << " messages" << std::endl;
    size_t count = 0;
    for (auto m : messages_)
        std::cout << "message " << ++count << ": " << m->contents_ << std::endl;
}

int main()
{
    using namespace std;

    string s1("contents1");
    string s2("contents2");
    string s3("contents3");
    string s4("contents4");
    string s5("contents5");
    string s6("contents6");

    // all new messages, no copies yet
    //
    // message: contents1
    // appears in 2 folders
    // folder contents 4 messages
    // message 1: contents1
    // message 2: contents2
    // message 3: contents4
    // message 4: contents6

    Message m1(s1);
    Message m2(s2);
    Message m3(s3);
    Message m4(s4);
    Message m5(s5);
    Message m6(s6);

    Folder f1;
    Folder f2;

    m1.save(f1); m3.save(f1); m5.save(f1);
    m1.save(f2); m2.save(f2); m4.save(f2); m6.save(f2);

    m1.debug_print();
    f2.debug_print();

    cout << "------------" << endl;
    // create some copies
    //
    // message: contents1
    // appears in 2 folders
    //
    // f1, folder contents 4 messages
    // message 1: contents1
    // message 2: contents3
    // message 3: contents5
    // message 4: contents1, c1
    //
    // f2, folder contents 8 messages
    // message 1: contents1
    // message 2: contents2
    // message 3: contents4
    // message 4: contents6
    // message 5: contents1, c1
    // message 6: contents2
    // message 7: contents4
    // message 8: contents6
   
    Message c1(m1);
    Message c2(m2), c4(m4), c6(m6);

    m1.debug_print();
    f1.debug_print();
    f2.debug_print();

    cout << "------------" << endl;
    // now some assignments
    //
    // message: contents5
    // appears in 1 folders
    //
    // f1, folder contents 7 messages
    // message 1: contents5
    // message 2: contents3
    // message 3: contents3
    // message 4: contents5
    // message 5: contents5
    // message 6: contents3
    // message 7: contents1
    //
    // f2, folder contents 4 messages
    // message 1: contents1
    // message 2: contents2
    // message 3: contents4
    // message 4: contents6

    m2 = m3;
    m4 = m5;
    m6 = m3;
    m1 = m5;

    m1.debug_print();
    f1.debug_print();
    f2.debug_print();

    cout << "------------" << endl;
    // finally, self-assignment
    //
    // // m2(contents3) and m1(contents5) are in f1. since do not support self
    // assign, removes them effectively.
    //
    // message: contents5
    // appears in 1 folders
    // message: contents3
    // appears in 1 folders
    //
    // message: contents5
    // appears in 0 folders
    // message: contents3
    // appears in 0 folders
    //
    // folder contents 5 messages
    // message 1: contents3
    // message 2: contents5
    // message 3: contents5
    // message 4: contents3
    // message 5: contents1
    // folder contents 4 messages
    // message 1: contents1
    // message 2: contents2
    // message 3: contents4
    // message 4: contents6

    m1.debug_print();
    m2.debug_print();

    m2 = m2;
    m1 = m1;

    m1.debug_print();
    m2.debug_print();
    f1.debug_print();
    f2.debug_print();

    cout << "------------" << endl;
    // capacity: 0
    // capacity: 1
    // capacity: 2
    // capacity: 4
    // capacity: 4
    // capacity: 8
    
    // capacity: 0
    // capacity: 1
    // capacity: 2
    // capacity: 4
    // capacity: 4
    // capacity: 8
    vector<Message> vm;
    cout << "capacity: " << vm.capacity() << endl;
    vm.push_back(m1);

    cout << "capacity: " << vm.capacity() << endl;
    vm.push_back(m2);

    cout << "capacity: " << vm.capacity() << endl;
    vm.push_back(m3);

    cout << "capacity: " << vm.capacity() << endl;
    vm.push_back(m4);

    cout << "capacity: " << vm.capacity() << endl;
    vm.push_back(m5);

    cout << "capacity: " << vm.capacity() << endl;
    vm.push_back(m6);

    vector<Folder> vf;
    cout << "capacity: " << vf.capacity() << endl;
    vf.push_back(f1);

    cout << "capacity: " << vf.capacity() << endl;
    vf.push_back(f2);

    cout << "capacity: " << vf.capacity() << endl;
    vf.push_back(Folder(f1));

    cout << "capacity: " << vf.capacity() << endl;
    vf.push_back(Folder(f2));

    cout << "capacity: " << vf.capacity() << endl;
    vf.push_back(Folder());

    Folder f3;
    f3.save(m6);
    cout << "capacity: " << vf.capacity() << endl;
    vf.push_back(f3);

    return 0;
}


={============================================================================
*kt_dev_cxx_0000* cxx-move cxx-ex-strvec-example

In some circumstances, an object is `immediately destroyed` after it is
copied. In those cases, moving rather than copying the object can provide a
significant performance boost. 

IO or unique_ptr classes which cannot be copied but can be moved since these
have a resource such as a pointer or an IO buffer that may not be shared.

In previous library, class stored in a container had to be `copyable`. Under
new standard, can use container on types that cannot be copied so long as they
can be moved.

<ex>

CPR 524

StrVec example which is a simplification of the library vector class. Like
vector, supports reallocation. If there is not enough space left, then obtains
new space, moves the existing elements into that space, free the old space, and
adds the new elements.

| 0 | 1 | 2 | 3 | 4 | unconstructed std::string elements |
^                     ^                                  ^
elements              first_free                         cap

namespace cxx_case_strvec
{
  class StrVec
  {
  private:
    using size_type = std::string::size_type;

    // TODO: why static in the text?
    std::allocator<std::string> m_alloc;

    std::string *m_element{nullptr};
    std::string *m_free{nullptr};
    std::string *m_capacity{nullptr};

    // allocate and construct memory copying from [begin, end) and return
    // [begin, end) of the constructed.

    std::pair<std::string *, std::string *>
      alloc_and_copy_(const std::string *begin, const std::string *end)
      {
        // use iterator arithmetic
        auto data = m_alloc.allocate(end - begin);
        return {data, std::uninitialized_copy(begin, end, data)};
      }

    // free [element, cap) only when elemenet is not null
    // move backwards from 'free' to call dtor on [element, free)
    //
    // NOTE: needs destroy()? Yes since std::string is `valuelike` and has own
    // memory for holding characters

    void free_()
    {
      if (m_element)
      {
        for (auto p = m_free; p != m_element; /* empty */)
          m_alloc.destroy(--p);

        m_alloc.deallocate(m_element, m_capacity - m_element);
      }
    }

    // o cxx-move
    // move the data from the old memory to the new std::move() returns rvalue,
    // which cause construct() to use string move ctor.
    
    // o cxx-gdb
    // seg-fault when use `element` in the loop:
    //
    // for (size_t i = 0; i != size(); ++i)
    //     alloc.construct(dest++, std::move(*element_++));
    //
    // *gdb-debug* bt when use -g
    // Program terminated with signal SIGSEGV, Segmentation fault.
    // #0  0x00007f94aa120113 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string&&) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
    // (gdb) bt
    // #0  0x00007f94aa120113 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string&&) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
    // #1  0x0000000000401bf7 in __gnu_cxx::new_allocator<std::string>::construct<std::string<std::string> > (this=0x602cd1 <StrVec::alloc>, __p=0xa53000) at /usr/include/c++/4.9/ext/new_allocator.h:120
    // #2  0x0000000000401932 in StrVec::reallocate (this=0x7ffdc9026bc0) at t_ex_strvec.cpp:117
    // #3  0x0000000000401aa5 in StrVec::check_and_alloc (this=0x7ffdc9026bc0) at t_ex_strvec.cpp:147
    // #4  0x000000000040165e in StrVec::push_back (this=0x7ffdc9026bc0, s="two") at t_ex_strvec.cpp:44
    // #5  0x000000000040133e in main () at t_ex_strvec.cpp:198
    //
    // when not use -g
    // (gdb) bt
    // #0  0x00007f3348f5c113 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string&&) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
    // #1  0x0000000000401bf7 in void __gnu_cxx::new_allocator<std::string>::construct<std::string, std::string>(std::string*, std::string&&) ()
    // #2  0x0000000000401932 in StrVec::reallocate() ()
    // #3  0x0000000000401aa5 in StrVec::check_and_alloc() ()
    // #4  0x000000000040165e in StrVec::push_back(std::string const&) ()
    // #5  0x000000000040133e in main ()
    //
    // How to debug? See that uses 'construct' and gdb is useful to see
    // what's going on when stepping through. Found out that the loop
    // continues and saw that when add to print i and size().
    //
    // ...
    // i: 16856, size: 18446744073709534761
    // Segmentation fault (core dumped)
    //
    // (gdb) f 2
    // #2  0x0000000000401932 in StrVec::reallocate (this=0x7ffdc9026bc0) at t_ex_strvec.cpp:117
    // 117                     alloc.construct(dest++, std::move(*element_++));
    // (gdb) p i
    // $1 = 16856
    // (gdb) p/u free_-element_
    // $6 = 18446744073709534760
    //
    // Why? Since element_ is member data and keep increasing it, then size()
    // member function would produce negative which turns into big number sicne
    // size() returns size_t, unsigned int.

    void reallocate_()
    {
      auto new_capacity = size() ? size() * 2 : 1;
      auto new_data = m_alloc.allocate(new_capacity);

      auto dest = new_data;
      auto source = m_element;

      for (size_type i = 0; i != size(); ++i)
      {
        m_alloc.construct(dest++, std::move(*source++)); 
      }

      m_element = new_data;
      m_free = dest;
      m_capacity = m_element + new_capacity; 
    }

    // check if it needs reallocation

    void check_and_alloc_()
    {
      if (size() == capacity())
      {
        reallocate_();
      }
    }

  public:
    StrVec() = default;
    ~StrVec() { free_(); }

    StrVec(std::initializer_list<std::string> il)
    {
      auto coll = alloc_and_copy_(il.begin(), il.end());
      m_element = coll.first;
      m_free = m_capacity = coll.second;
    }

    // copy controls. makes a copy
    StrVec(const StrVec &rhs)
    {
      std::cout << "StrVec(const StrVec &rhs)" << std::endl;
      auto coll = alloc_and_copy_(rhs.begin(), rhs.end());
      m_element = coll.first;
      m_free = m_capacity = coll.second;
    }

    // copy controls. makes a copy and also support cxx-self-assian.
    StrVec &operator=(const StrVec &rhs)
    {
      if (this != &rhs)
      {
        std::cout << "StrVec &operator=(const StrVec &rhs)" << std::endl;
        auto coll = alloc_and_copy_(rhs.begin(), rhs.end());
        free_();
        m_element = coll.first;
        m_free = m_capacity = coll.second;
        return *this;
      }
    }

#ifdef MOVE_SUPPORTED
    // *cxx-move* controls. no need to alloc
    StrVec(StrVec &&rhs) noexcept
      : m_element(rhs.m_element), m_free(rhs.m_free), m_capacity(rhs.m_capacity)
    {
      std::cout << "StrVec(StrVec &&rhs)" << std::endl;
      rhs.m_element = rhs.m_free = rhs.m_capacity = nullptr;
    }

    // move controls. no need to alloc
    StrVec &operator=(StrVec &&rhs) noexcept
    {
      if (this != &rhs)
      {
        std::cout << "StrVec &operator=(StrVec &&rhs)" << std::endl;
        free_();
        m_element = rhs.m_element;
        m_free = rhs.m_free;
        m_capacity = rhs.m_capacity;

        rhs.m_element = rhs.m_free = rhs.m_capacity = nullptr;
      }

      return *this;
    }
#endif 

  public:
    std::string &operator[](size_type n) { return m_element[n]; }

    size_type size() const { return m_free - m_element; }
    size_type capacity() const { return m_capacity - m_element; }

    std::string *begin() const { return m_element; }
    std::string *end() const { return m_free; }

    const std::string *cbegin() const { return m_element; }
    const std::string *cend() const { return m_free; }

    // *cxx-copy*
    void push_back(const std::string &s)
    {
      check_and_alloc_();

      // TODO: construct a copy of s
      //
      // The first argument to construct must be a pointer to
      // unconstructed space allocated by `allocate()`. 
      //
      // The second argument `determine which constructor` to use to
      // construct the object in that space. This is string's copy ctor.

      m_alloc.construct(m_free++, s);
    }

    // *cxx-move-overload*
    //
    // The *cxx-std-move* is to signal to compiler to pick up move operations
    // via resolution. The std::move() doesn't itself do any moving, but merely
    // converts its argument into a so-called rvalue reference.

    void push_back(std::string &&s)
    {
      check_and_alloc_();
      m_alloc.construct(m_free++, std::move(s));
    }

    // *cxx-emplace-back* is covered in chapter 16
    template <typename... Args>
      void emplace_back(Args&&... args)
      {
        check_and_alloc_();
        m_alloc.construct(m_free++, std::forward<Args>(args)...);
      }
  };

  StrVec returnVector()
  {
    StrVec coll;

    coll.push_back("func1");
    coll.push_back("func2");
    coll.push_back("func3");

    // this is where move is necessary
    return coll;
  }
} // namespace cxx_case_strvec

TEST(CxxCase, StringVector)
{
  using namespace cxx_case_strvec;

  {
    StrVec coll{"string1", "string2", "string3"};

    {
      // since T, std::string, supports streams
      ostringstream os;
      for (const auto & e : coll)
        os << e << ",";

      EXPECT_THAT(os.str(), "string1,string2,string3,");
    }

    // operator[]
    {
      EXPECT_THAT(coll[0], "string1");

      coll[0] = "element1";
      coll[1] = "element2";
      coll[2] = "element3";

      // since T, std::string, supports streams
      ostringstream os;
      for (const auto & e : coll)
        os << e << ",";

      EXPECT_THAT(os.str(), "element1,element2,element3,");
    }

    // push_back
    {
      coll.push_back("push1");
      coll.push_back("push2");

      // since T, std::string, supports streams
      ostringstream os;
      for (const auto & e : coll)
        os << e << ",";

      EXPECT_THAT(os.str(), "element1,element2,element3,push1,push2,");
    }

    // copy
    {
      StrVec coll2;
      coll2 = coll;

      // since T, std::string, supports streams
      ostringstream os;
      for (const auto & e : coll)
        os << e << ",";

      EXPECT_THAT(os.str(), "element1,element2,element3,push1,push2,");
      EXPECT_THAT(coll.size(), 5);

      // stringstream-clear
      os = ostringstream("");
      for (const auto & e : coll2)
        os << e << ",";

      EXPECT_THAT(os.str(), "element1,element2,element3,push1,push2,");
      EXPECT_THAT(coll2.size(), 5);
    }

    // move
    {
      StrVec coll2;
      coll2 = std::move(coll);

      EXPECT_THAT(coll2.size(), 5);

#ifdef MOVE_SUPPORTED
      EXPECT_THAT(coll.size(), 0);
#else
      // copy will be used instead
      EXPECT_THAT(coll.size(), 5);
#endif

      ostringstream os;
      for (const auto & e : coll2)
        os << e << ",";

      EXPECT_THAT(os.str(), "element1,element2,element3,push1,push2,");
      EXPECT_THAT(coll2.size(), 5);
    }

    // cxx-emplace-back
    {
      // coll is still around

      coll.emplace_back("string1");
      coll.emplace_back(5, 'c');    // add "ccccc"

      std::string s1("string2");
      std::string s2("string3");
      coll.emplace_back(s1 + s2);   // use string move

#ifdef MOVE_SUPPORTED
      EXPECT_THAT(coll.size(), 3);
#else
      EXPECT_THAT(coll.size(), 8);
#endif
      ostringstream os;
      for (const auto & e : coll)
        os << e << ",";

#ifdef MOVE_SUPPORTED
      EXPECT_THAT(os.str(), "string1,ccccc,string2string3,");
#else
      EXPECT_THAT(os.str(), 
          "element1,element2,element3,push1,push2,string1,ccccc,string2string3,");
#endif
    }

    // cxx-return
    {
      StrVec coll2;
      EXPECT_THAT(coll2.size(), 0);

      // will use cxx-copy-assign or cxx-move-assign? Use cxx-move
      coll2 = returnVector();

      EXPECT_THAT(coll2.size(), 3);
    }
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-move

{cxx-rvalue} {cxx-lvalue}
In C, `lvalue` could stand on the left-hand side of an assignment whereas
`rvalue could not.` In C++ this distinction is less simple. Generally
speaking, lvalue refers to an object's `identity` (its location in memory)
whereas rvalue refers to object's `value`(its contents).

*expression-has-a-value*
From ansic: In C, any assignment, such as "c = getchar()" is an expression and
has a value, which is the value of the left hand side after the assignment.
This means that an assignment can appear as part of a larger expression, such
as "while((c = getchar()) != EOF)"

The `lvalue` and `rvalue` are `properties` of an expression. Expressions yield
or require rvalue/lvalue. Operators `differ` as to whether require lvalue or
rvalue operands and as to whether return lvalue or rvalues. Some yield or
require lvalues and others yield or require rvalues:

Assignment `requires` a (non-const) lvalue as its left hand operand and
`yields` its left-hand operand as an lvalue.

The address-of-operator(&) requires an lvalue operand and returns a pointer to
its operand as an rvalue.

<ex> show that x++ returns rvalue which is the previous, temporary.

{
  int x = 10;
  int *pint;

  pint = &(++x);

  // *cxx-error* since & requires lvalue
  // : error: lvalue required as unary ‘&’ operand
  // pint = &(x++);
}


<ex> function that return cxx-lvalue-reference

CPR 226. "Calls to functions that return reference are lvalue" which means
that can be used in the same ways as any other lvalue.

char &get_value(string &str, string::size_type ix)
{
  return str[ix];
}

{
  string s("a value");
  get_value(s, 0) = 'A';  // changes s[0] to A
}


<cxx-reference-binding> CPR 532 
The `cxx-rvalue-reference` is a reference that `must be bound to an rvalue`
and as with reference, it is just another name for an object. 

o `use '&&' rather than '&'` 

o Cannot bind `lvalue-reference(from)` to expression that requires a conversion, to
  literals, or to expression that return an rvalue. 

o Can bind `rvalue-reference(from)` to lvalue reference 
  but `cannot directly` bind lvalue to rvalue reference

  note: 
  What does "directly" mean? Can do indirectly and see *cxx-reference-collapsing*

o Can bind `rvalue(moved-from)` to `const-lvalue-reference(moved-to)`

  // which will be called? no copy or move controls are called
  // *cxx-reference-binding* Can bind `rvalue` to `const-lvalue-reference`
  // assume that the moved is const and that meanss nothing will be changed so
  // why bother to copy of it? so no copy or move.
  {
    Move m1{"m1", 10};
    Move m2{"m2", 20};

    // void set_move(const Move &m); rvalue to lvalue reference
    set_move(std::move(m2)); 
  }

{
  int i = 42;

  int &r = i;             // okay

  // cxx-error, cannot bind `lvalue` to `rvalue-reference` 
  // : error: cannot bind ‘int’ lvalue to ‘int&&’
  // int &&rr = i;

  // cxx-error, i*42 is rvalue
  // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
  // int &r2 = i*42;

  const int &r3 = i*42;   // okay bind `rvalue` to `const-lvalue-reference`

  int &&r4 = i*42;        // okay
}

<ex> *cxx-reference-collapsing*

// cxx-sp-code:
//
//      template<typename _Tp1, typename _Del>
//        shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
//        : __shared_ptr<_Tp>(std::move(__r)) { }
//

//  std::shared_ptr<DBusMessagePrivate> m_private;

// no cxx-error

DBusMessage::DBusMessage(std::unique_ptr<DBusMessagePrivate> &&rhs)
    : m_private(std::move(rhs))
{}

// cxx-error sicne make_unique() returns lvalue but shared_ptr() needs rvalue
// error: no matching function for call to 
// ‘std::shared_ptr<DBusMessagePrivate>::shared_ptr(std::unique_ptr<DBusMessagePrivate>&)’

DBusMessage::DBusMessage(std::unique_ptr<DBusMessagePrivate> &&rhs)
    : m_private(rhs)
{}

{
  return DBusMessage(
    std::make_unique<DBusMessagePrivate>(DBusMessage::MethodCallMessage,
                                         service,
                                         path,
                                         interface,
                                         method));
}


*cxx-return*
Functions that return a non-reference type, along with the arithmetic,
relational, bitwise, and `postfix` operations, all yield rvalues.

string f();
string &r2{f()};          // error when 

f() returns rvalue since returns a value and cannot bind rvalue to lvalue
reference.


<cxx-rvalue-is-temporary> *cxx-move* *cxx-temporary* implicit move sementics
Looking at the list of rvalue and lvalue expressions, lvalue has `persitent`
state, whereas rvalue are either literals or `temporary objects` created in
the course of evaluating expressions.

The `cxx-rvalue-reference` can only be bound to temporaries: the referred-to
object is about to be destroyed and there can be `no other users` of that
(move-from) object and only one user of (move-to) object. So the code that
uses an rvalue reference is `free to take over resources` from the object to
which the reference refers.

{
  StrVec returnVector()
  {
    StrVec coll;

    coll.push_back("func1");
    coll.push_back("func2");
    coll.push_back("func3");

    // this is where move is necessary
    return coll;
  }

  // cxx-return
  {
    StrVec coll2;
    EXPECT_THAT(coll2.size(), 0);

    // will use cxx-copy-assign or cxx-move-assign? Use cxx-move
    coll2 = returnVector();

    EXPECT_THAT(coll2.size(), 3);
  }
}

When class has both a move and copy ctor, how does the library know what to
use? Use *cxx-function-matching* since copy ctor takes const StrVec& and move
only takes StrVec&&.


<cxx-std-move>

return rvalue reference to its given object.

#include <utility>

int &&rr = std::move(rr1);
moved-to             moved-from

Essentially `to tell or signal compiler` that we do not intend to use rr1 again
except to assign to it or destroy it. So after move, cannot make any
assumptions about the value of the moved-from object. 


use std::move():

Since there is *cxx-arg-dependent-lookup*  `if user defines move()` then
*cxx-overload* rule picks up the right version. However, std::move is
template and *cxx-rvalue* matches to `any type` so name collision are more
likely to use move() but less likely to be intentional. Therefore, suggest fully
qualified one, std::move().


{cxx-move-can-be-dangerous} <destructible-state>
The move-ctor must ensure that the moved-from object is left in a state that
destroying that object will be harmless. The moved-from object continues to
exist, eventually will be destroyed and the dtor will be run on that. 

`What's sensible state of the moved-from object depends on context.` 

For example:

Setting pointer members to nullptr makes StrVec::free() in dtor do nothing.
Otherwise, would delete the memory(resource) we have moved. Also this is why do
not have const on s since changes its state.

std::string *m_element{nullptr};
std::string *m_free{nullptr};
std::string *m_capacity{nullptr};

StrVec::StrVec( StrVec&& s ) noexcept
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  // leave s(moved-from) in a state in which it is safe to run the dtor
  s.elements = s.first_free = s.cap = nullptr;
}

StrVec &StrVec::operator=( StrVec &&rhs ) noexcept;


Since moved-from object has indeterminate state, std::move is a dangerous
operation. When we call std::move must be certain that there can be no user
of the moved-from object. 

Be careful about meaning of move: The actual move happens on elements which is
string in this case and move is done by copying and setting pointer members in
StrVec POV and is not to free the memory moved. This is a meaning of taking over
the resources in s, StrVec.

Moving from an object does not destroy that object. Therefore, must ensure that
the moved-from object is `in a state in which the dtor can be run.` In this
example, if not set these pointer members null, there shall be a problem when
dtor runs and calls free().

In addition to that, move operations guarantee that the object remains valid
meaning that can runs operations but no guarantees/assumptions about its value.
Can safely be given a new value or used in other ways that do not depend on its
current value. StrVec move leave the moved-from object in the same state `as a
default initialized object` and other classes may behave differently.

See *cxx-ex-hasptr-exmaple* for the problem when moved-from state is wrong.


{cxx-move-controls}
See `no const` on parameter and `noexcept` since `do not allocate` any new
memory and take over the memory from its argument. 

StrVec(const StrVec&);                // copy ctor
StrVec &operator=(const StrVec&);     // copy assign

StrVec(StrVec&&) noexcept;            // move ctor
StrVec &operator=(StrVec&&) noexcept; // move assign


{cxx-move-synthesized} *cxx-copy-control*
If class do not define copy ctor and assign then compiler `always make` these
operations; either memberwise or deleted.

cxx-move operations are different. The compiler make move operations `only if` a
class does `not` define any copy ctor and assign and `only if` all non-static
members can be move constructed and assigned because if a class doesn't have a
move operation, `the corresponding copy operation is used` in place of move via
function matching. 

*cxx-remember*
o if class has own copy ctor and assign then move `will not be synthesized`

o if class has copy ctors deleted then move will not be synthesized. this is
  from experience but not from text


note:
This means that having cxx-copy-controls ONLY can effectively turn off *cxx-rvo*
since move controls will not be made. RCGL P9

*cxx-remember*
"class that define move operations `must` also define own copy operations." 

If class defines either move ctor and/or move assign but not defined copy
controls, the copy controls will de defined `deleted`. 


{cxx-move-conditions}

o *cxx-noexcept* on move

The library containers provide guarantees as to what they do if an exception
happens; vector guarantees that if an exception happens when call push_back, the
vector itself will be left unchanged.

Imagine that push_back in StrVec causes reallocation as vector, uses move ctor
but exceptions happens in the middle of moving. There would be a problem.

However, if used copy ctor, not a problem when exception happens since the
original copy still remains. Like, exception safe condition in using dynamic
resources.

To avoid this potential problem, vector must use a copy ctor instead move during
reallocation unless it knows that element's type move ctor cannot throw an
exception. How to tell the library that move ctor is safe to use? Do so by using
explicitly `noexcept` keyword on move ctor and assign.


o cxx-copy is bigger than cxx-move 

Using the copy controls in place of move controls is safe and will meet the
requirement of move controls since objects is moved by copying operations. In
other words, copy controls are more of necessary to work properly, move controls
are more of `performance choice` so if there are no move operations, copy
controls will be used instead.

note: 
If a class has no move operations, copy operations will be used even if
attempt to use move by calling std::move().

// Foo define copy but no move operations
Foo z(std::move(x));       // copy ctor

Here copy initialization happens but std::move returns rvalue, Foo&&, but no
move ctor. So can convert a Foo&& to const Foo&, copy ctor is viable and it is
called since *cxx-reference-binding* "can bind rvalue to const lvalue reference"


{cxx-move-overload} *cxx-overload*
Member functions other than constructors and assignment can benefit from
providing both copy and move versions.

{
  // *cxx-copy*
  void push_back(const std::string &s)
  {
    check_and_alloc_();

    // TODO: construct a copy of s
    //
    // The first argument to construct must be a pointer to
    // unconstructed space allocated by `allocate()`. 
    //
    // The second argument determine which constructor to use to
    // construct the object in that space. This is string's copy ctor.

    m_alloc.construct(m_free++, s);
  }

  // *cxx-move-overload* *cxx-overload*
  //
  // The *cxx-std-move* is to signal to compiler to pick up move operations
  // via resolution. The `std::move() doesn't itself do any moving`, but merely
  // converts its argument into a so-called rvalue reference.

  void push_back(std::string &&s)
  {
    check_and_alloc_();
    m_alloc.construct(m_free++, std::move(s));
  }
}


<ex>
namespace cxx_move
{
  class Move
  {
  private:
    std::string m_name;
    int m_value;

  public:
    explicit Move(std::string name = "", int value = 0)
        : m_name(name)
        , m_value(value)
    {}

    // copy controls
    Move(const Move &rhs)
        : m_name(rhs.m_name)
        , m_value(rhs.m_value)
    {
      std::cout << "Move(const Move &rhs)" << std::endl;
      // m_name = rns.m_name;
      // m_value = rhs.m_value;
    }

    Move &operator=(const Move &rhs)
    {
      std::cout << "Move &operator=(const Move &rhs)" << std::endl;
      m_name  = rhs.m_name;
      m_value = rhs.m_value;
    }

#ifdef MOVE_BUT_USE_COPY
    // move controls
    Move(Move &&rhs)
        : m_name(rhs.m_name)
        , m_value(rhs.m_value)
    {
      std::cout << "Move(Move &rhs)" << std::endl;
    }

    Move &operator=(Move &&rhs)
    {
      std::cout << "Move &operator=(Move &&rhs)" << std::endl;
      m_name  = rhs.m_name;
      m_value = rhs.m_value;
    }
#else
    // move controls
    Move(Move &&rhs)
        : m_name(std::move(rhs.m_name))
        , m_value(rhs.m_value)
    {
      std::cout << "Move(Move &rhs)" << std::endl;
    }

    Move &operator=(Move &&rhs)
    {
      std::cout << "Move &operator=(Move &&rhs)" << std::endl;
      m_name  = std::move(rhs.m_name);
      m_value = rhs.m_value;
    }

#endif

    bool isNameEmpty() const { return m_name.empty(); }

    void setMembers(std::string &&name, int &&value)
    {
      m_name  = name;
      m_value = value;
      std::cout << "name: " << m_name << ", value: " << m_value << std::endl;
    }
  };
} // namespace cxx_move

TEST(CxxMove, signal)
{
  using namespace cxx_move;

  // use copy controls
  {
    std::vector<Move> coll;

    Move m1{"m1", 10};
    Move m2{"m2", 20};

    coll.push_back(m1);
    coll.push_back(m2);

    // string member is not empty since it's copied
    EXPECT_THAT(m1.isNameEmpty(), false);
    EXPECT_THAT(m2.isNameEmpty(), false);
  }

  // use move controls
  {
    std::vector<Move> coll;

    Move m1{"m1", 10};
    Move m2{"m2", 20};

    coll.push_back(std::move(m1));
    coll.push_back(std::move(m2));

#ifdef MOVE_BUT_USE_COPY
    // string member is NOT empty since it's NOT moved
    EXPECT_THAT(m1.isNameEmpty(), false);
    EXPECT_THAT(m2.isNameEmpty(), false);
#else
    // string member is empty since it's moved
    EXPECT_THAT(m1.isNameEmpty(), true);
    EXPECT_THAT(m2.isNameEmpty(), true);
#endif
  }
}


{cxx-move-iterator-adaptor}
The StrVec::reallocate can be rewritten using move iterator which would be
easier. 

The uninitialized_copy() copy and costruct elements in uninitialized space but
there is no analogous to move objects into unconstruced memory. Instead, the
new library defines move iterator adaptor which changes the behavior of
iterator's dereference operator to 'fetch' elements.

Ordinarily, an iterator dereference operator returns an lvaue reference to the
element but move iterator yields an rvalue reference.

The make_move_iterator() 'transform' an ordinary iterator to a move iterator.

The uninitialized_copy() uses the iterator dereference to fetch elements from
the input sequence. Because passed move iterators, the dereference yields an
rvalue reference, which means `construct` will use the move (string) ctor to
construct the elements.

void StrVec::reallocate()
{
  auto newcapacity = size() ? 2 * size() : 1;

  auto newdata = alloc.allocate(newcapacity);   // first

  auto dest = newdata;      // start in the new array
  auto elem = elements;     // start in the old array

  // 'before'
  // for( size_t i = 0; i != size(); ++i )
  //  alloc.construct( dest++, std::move(*elem++) );

  // 'after'
  auto dest = uninitialized_copy(
      make_move_iterator( begin() ),
      make_move_iterator( end() ),
      first );

  free();   // member which destroy and deallocate

  elements = newdata;
  first_free = dest;
  cap = elements + newcapacity;
}


note:
STL makes no guarantees about which algorithms can be used with move iterators
or which cannot since move can destory the source. Should pass move iterators to
algorithms only when confident that algorithms does not access an element after
it has assigned to that element.


{cxx-reference-quailifier} *cxx-move* CPR 546
Ordinarily, can call a member function on object, regardless of whether that is
an lvalue or rvalue. Sometimes such usage can be surprising. Here assign to the
rvalue *cxx-return* of concatentating these strings:

s1 + s2 = "wow!";

Still allow assignment to rvalues for backward compatability. *cxx-11* have a
way to `prevent such usage` by forcing the left-hand operand, the object to
which `this` points, to be an lvalue.

To indicate `the lvalue/rvalue property of this`, use reference qualify:

The refernece qualified and must follow the `const`.

class Foo {
  public:
    Foo someMem() & const;    // error

    // copy version, lvalue reference qualifier
    Foo someMem() const &;    

    // move version, rvalue reference qualifier
    Foo someMem() const &&;   
};


={============================================================================
*kt_dev_cxx_0000* cxx-ex-query-example cxx-interface cxx-grep

CPR 484. 12.3.2

Requirements are:
 * Search a given file for a word
 * Show the number of times the word occurs
 * Show a list of lines on which that word appears in ascending order
 * Show the line only once if a word occurs more than once on the same line
 * Repeat a search for any given word until user quit

The output for query word "element" is:

element occurs 112 times
	(line 36) A set element contains only a key;
	(line 158) operator creates a new element
	...

When reads the input,
 * must remember the line(s) in which each word appears.
 * need to read the input a line at a time and break up the lines into its
   separate words.

When makes output,
 * must be able to fetch the line numbers associated with a given word.
 * the line numbers must appear in ascending order with no duplicates.
 * must print the text in the input file at a given line number.


*cxx-design*
When design a class, can be helpful to write programs using the class before
implementing the members. That way, can see whether the class has the
`operation` we need. A good way to start the design of a program is to list
the program's operations. Again, what operation we need helps us see what
`data structure` we will need.

{
    std::ifstream ifs("README", std::ifstream::in);

    TextQuery tq(ifs);

    while (true)
    {
        cout << "pls enter the word to search or q to quit: ";

        string word;

        // if see condition to quit
        if (!(cin >> word) || s == "q") break;

        // run query and print the result
        print(cout, tq.query(word)) << endl;
    }
}

*TN* This ex is more than simple grep since simple grep is one-pass but this
do mutiple-pass. So needs more structures.

*TN* Search a given word whenever a user runs a query? If built a structure
which has a word and where that word was shown then no need to search a whole
file every time. So use a map<word, set<lines>>

*TN* What if have to return the result from query()? Since the result is not
simple due to more structures used, need to pack them to return. Like
iterator, pack them as a class. So needs to make it sharable, not a member
and use shared_ptr on file and set.

*TN* The hard part in designing query function is deciding what the query
function return. The easiest way to return "all" those data is to define a
second class, QueryResult. 

Prefer print() over TextQuery::query_and_print() since QueryResult is a user
facing class, *cxx-interface*


{ex-simple}
#include <iostream>
#include <memory>
#include <set>
#include <vector>
#include <map>
#include <sstream>
#include <fstream>

class QueryResult
{
    using lineno = std::size_t;

    friend std::ostream &print(std::ostream &os, const QueryResult &result);

    public:
        QueryResult(const std::string &word,
                std::shared_ptr<std::vector<std::string>> input_file,
                std::shared_ptr<std::set<lineno>> lines)
            : word_(word), input_file_(input_file), lines_(lines)
        {}

    private:
        std::string word_;

        // file;
        std::shared_ptr<std::vector<std::string>> input_file_;

        // set of line numbers
        std::shared_ptr<std::set<lineno>> lines_;
};


// utility
std::string make_plural(size_t count, const std::string &message, const std::string &ending)
{
    return (count > 1) ? message + ending : message;
}


class TextQuery
{
    using lineno = std::size_t;

    public:
        // *TN* have to make empty vector here and otherwise access nullptr in
        // ctor.
        TextQuery(std::istream &input)
            : input_file_(std::make_shared<std::vector<std::string>>())
        {
            std::string line{};

            while (getline(input, line))
            {
                std::stringstream ssline{line};
                std::string word;
                    
                input_file_->push_back(line);

                // can use a varialbe and increase it in the loop
                lineno current_line = input_file_->size()-1;

                // *cxx-stringstream* parse up a line
                while (ssline >> word)
                {
                    // not covered in the book -- cleanup_str removes
                    // punctuation and converts all text to lowercase so that
                    // the queries operate in a case insensitive manner
                    // word = cleanup_str(word);

                    auto &lines = word_map_[word];

                    // if a word is not in the map, that is to be seen in the
                    // first time, the second is default inicialized shared_ptt,
                    // which is null. Have to create a empty set.

                    if (!lines)
                        lines = std::make_shared<std::set<lineno>>();

                    lines->insert(current_line);
                }
            }
        }

        QueryResult query(const std::string &word) const
        {
            // *TN* How to handle the case when not found? Use empty set rather
            // then nullptr since print() do not have to handle a special case.
            static auto notfound = std::make_shared<std::set<lineno>>();

            // *TN* should not use [] since it can add a new one
            auto pos = word_map_.find(word);

            if (pos != word_map_.end())
                return QueryResult(word, input_file_, pos->second);
            else
                return QueryResult(word, input_file_, notfound);
        }

        // *cxx-map-find*
        // when not use QueryResult and do the same as print().
        void query_and_print(const std::string &word) const
        {
            auto pos = word_map_.find(word);

            if (pos != word_map_.end())
            {
                std::cout << word << " occurs " << pos->second->size() << " "
                    << make_plural(pos->second->size(), "time", "s") << std::endl;

                for (auto e : *pos->second)
                    std::cout << "(line " << e+1 << ") " << (*input_file_)[e] << std::endl;
            }
            else
                std::cout << word << " not found" << std::endl;
        }

    private:

        std::string cleanup_str(const std::string &word)
        {
            std::string ret;
            for (auto it = word.begin(); it != word.end(); ++it)
            {
                // if (!ispunct(*it))
                //     ret += tolower(*it);

                // to keep the case
                if (!ispunct(*it))
                    ret += *it;
            }
            return ret;
        }

        // vector<line> file;
        std::shared_ptr<std::vector<std::string>> input_file_;

        // *TN* map is itself not a shared_ptr
        // map<word, shared_ptr<set<lineno>>> word_map;
        std::map<std::string, std::shared_ptr<std::set<lineno>>> word_map_;
};

// *cxx-interface* part of interface
// *TN* return ostream since to give a user to control output
std::ostream &print(std::ostream &os, const QueryResult &result)
{
    os << result.word_ << " occurs " << result.lines_->size() << " "
        << make_plural(result.lines_->size(), "time", "s") << std::endl;

    // since it is a vector, can use *cxx-iter*arithmetic*:
    // 
    // for (auto e : *(pos->second))
    //     cout << "(line " << e + 1 << ") " << *(result_file_->begin()+e) << endl;

    for (auto e : *result.lines_)
        os << "(line " << e+1 << ") " << (*result.input_file_)[e] << std::endl;

    // *TN* if miss out this line, gets *seg-fault* and the trace is:
    //
    // ostream &print(ostream &os, const QueryResult &result)
    // {
    //      ...
    //      return os;
    // }
    //
    // Program terminated with signal SIGSEGV, Segmentation fault.
    // #0  0x00007f84dd7af05c in std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&) ()
    //    from /usr/lib/x86_64-linux-gnu/libstdc++.so.6

    return os;
}


// *cxx-simple-grep*
// = 01 ======
// pls enter the word to search or q to quit: GNU
// GNU occurs 10 times
// (line 1) This directory contains the sources of the GNU C Library.
// (line 4) The GNU C Library is the standard system C library for all GNU systems,
// (line 5) and is an important part of what makes up a GNU system.  It provides the
// (line 14) The GNU C Library implements much of the POSIX.1 functionality in the
// (line 17) incorporated into an official GNU C Library release.
// (line 19) When working with Linux kernels, this version of the GNU C Library
// (line 25) The GNU C Library supports these configurations for using Linux kernels:
// (line 53) the GNU C Library.  You might also consider reading the WWW pages for
// (line 56) The GNU C Library is (almost) completely documented by the Texinfo manual
// (line 69) The GNU C Library is free software.  See the file COPYING.LIB for copying

void t_query_01()
{
    using namespace std;

    std::ifstream ifs("README", std::ifstream::in);

    TextQuery tq(ifs);

    cout << "pls enter the word to search or q to quit: ";

    string word;

    // if see condition to quit
    if (!(cin >> word)) return;

    // run query and print the result
    tq.query_and_print(word);
}


// = 02 ======
// pls enter the word to search or q to quit: GNU
// GNU occurs 10 times
// (line 1) This directory contains the sources of the GNU C Library.
// (line 4) The GNU C Library is the standard system C library for all GNU systems,
// (line 5) and is an important part of what makes up a GNU system.  It provides the
// (line 14) The GNU C Library implements much of the POSIX.1 functionality in the
// (line 17) incorporated into an official GNU C Library release.
// (line 19) When working with Linux kernels, this version of the GNU C Library
// (line 25) The GNU C Library supports these configurations for using Linux kernels:
// (line 53) the GNU C Library.  You might also consider reading the WWW pages for
// (line 56) The GNU C Library is (almost) completely documented by the Texinfo manual
// (line 69) The GNU C Library is free software.  See the file COPYING.LIB for copying
// 
// pls enter the word to search or q to quit: q

void t_query_02()
{
    using namespace std;

    std::ifstream ifs("README", std::ifstream::in);

    TextQuery tq(ifs);

    while (true)
    {
        cout << "pls enter the word to search or q to quit: ";

        string word;

        // if see condition to quit
        if (!(cin >> word) || word == "q") break;

        // run query and print the result
        print(cout, tq.query(word)) << endl;
    }

    ifs.close();
}
 
int main()
{
    using namespace std;

    cout << "= 02 ======" << endl;
    t_query_02();

    cout << "= 01 ======" << endl;
    t_query_01();
}


{ex-extented}
To support more advanced queries:

  * word queries:
    Executing Query for: Daddy

  * not queries:
    Executing Query for: ~(Alice)

  * or queries:
    Executing Query for: (hair | Alice)

  * and queries:
    Executing Query for: (hair & Alice)

  * compound queries which uses normal C++ precedence rule:
    Executing Query for: (fiery & bird | wind)


Can use TextQuery? No. To see why, consider a Not query and we would have to
able to find the word for which the Not query was searching. There is no such
word. Instead a Not query has a query whose value it negates. Similarly, And
and Or query have two queries whose results it combines. 

This `observation` suggests that we model our different kinds of queries as
independent classes that share a common base class. The solution is to have
four classes which has the same interface and use *cxx-abc* 

WordQuery, NotQuery, OrQuery, AndQuery


These four query types are not related to one another by inheritance; they are
`conceptually siblings and shares the same interface.` This suggest that will
need to define ABC to represent that interface.

Two abc:

  * QueryBase, abc for single operand
   
  * BinaryQuery, abc for two operands. The AndQuery and OrQuery share one
    property that the other classes do not. Each has two operands. To model
    this, define another ABC to represent queries with two operands.


<object-to-represent-query>
Need to create queries. The simplest way is to write C++ expressions to create
the compounded queries:

   Query q = Query("fiery") & Query("bird") | Query("wind");

`This problem description` suggests that user code won't use the inherited
class directly. Instead, will define an `interface class` named Query which hide
the hierarchy and has the same operations as Query_base. It will have three
overloaded operators and ctor.

  * & operator will create a Query bound to a new AndQuery.
  * | operator will create a Query bound to a new OrQuery.
  * ~ operator will create a Query bound to a new NotQuery.
  * Query ctor that takes a string will create a Query bound to a new WordQuery.
    WordQuery is a base unit in building a query.

Users will create and manipulate Query_base objects only `indirectly`
through operations on Query object: overloaded operators

*cxx-design*
How is it going to be used?

{
    std::ifstream ifs("t_query.dat", std::ifstream::in);

    TextQuery tq(ifs);

    Query q = Query("hair");

    // run query and print the result
    const auto results = q.eval(tq);

    print(cout, results) << endl;
}

So:

* Use TextQuery and QueryResult from the simple example.
* Need Query, QueryBase, and the derived from QueryBase.

Inheritance hierarchy is:                                    

User     Query class             Query Base
         - interface class       - ABC
         - hide QB from user        |           |           | 
                                 WordQuery   NotQuery    BinaryQuery
                                                         - ABC
                                                            |           |
                                                         AndQuery    ORQuery


#include <iostream>
#include <memory>
#include <set>
#include <vector>
#include <map>
#include <sstream>
#include <fstream>
#include <iterator>     // for inserter
#include <algorithm>

// g++ -std=c++11 t_ex_xxx.cpp

// Have to use cleanup_str() to see matches on "hair." or "hair,", which uses
// *cxx-ispunct* ispunct that in any case they are isgraph but not isalnum.
//
// (1) Alice Emma has long flowing red hair. 
// (2) Her Daddy says when the wind blows 
// (3) through her hair, it looks almost alive, 
// (4) like a fiery bird in flight. 
// (5) A beautiful fiery bird, he tells her, 
// (6) magical but untamed. 
// (7) "Daddy, shush, there is no such thing," 
// (8) she tells him, at the same time wanting 
// (9) him to tell her more.
// (10) Shyly, she asks, "I mean, Daddy, is there?"


//////////////////////////////////////////////////////////////////////////////
// simple example
class QueryResult
{
    using lineno = std::size_t;

    // to support extended example
    using line_iter = std::set<lineno>::const_iterator;

    friend std::ostream &print(std::ostream &os, const QueryResult &result);

    public:
        QueryResult(const std::string &word,
                std::shared_ptr<std::vector<std::string>> input_file,
                std::shared_ptr<std::set<lineno>> lines)
            : word_(word), input_file_(input_file), lines_(lines)
        {}

        std::shared_ptr<std::vector<std::string>> get_file() 
        { return input_file_; }

        line_iter begin() const { return lines_->cbegin(); }
        line_iter end() const   { return lines_->cend(); }

    private:
        std::string word_;

        // vector<line> file;
        std::shared_ptr<std::vector<std::string>> input_file_;

        // shared_ptr<set<lineno>> lines_;
        std::shared_ptr<std::set<lineno>> lines_;
};


// utility
std::string make_plural(size_t count, const std::string &message, const std::string &ending)
{
    return (count > 1) ? message + ending : message;
}


class TextQuery
{
    using lineno = std::size_t;

    public:
        // *TN* have to make empty vector here and otherwise access nullptr in
        // ctor.
        TextQuery(std::istream &input)
            : input_file_(std::make_shared<std::vector<std::string>>())
        {
            std::string line{};

            while (getline(input, line))
            {
                std::stringstream ssline{line};
                std::string word;
                    
                input_file_->push_back(line);

                // can use a varialbe and increase it in the loop
                lineno current_line = input_file_->size()-1;

                // *cxx-stringstream* parse up a line
                while (ssline >> word)
                {
                    // not covered in the book -- cleanup_str removes
                    // punctuation and converts all text to lowercase so that
                    // the queries operate in a case insensitive manner
                    word = cleanup_str(word);

                    auto &lines = word_map_[word];

                    // if a word is not in the map, that is to be seen in the
                    // first time, the second is default inicialized shared_ptt,
                    // which is null. Have to create a empty set.

                    if (!lines)
                        lines = std::make_shared<std::set<lineno>>();

                    lines->insert(current_line);
                }
            }
        }

        QueryResult query(const std::string &word) const
        {
            // *TN* How to handle the case when not found? Use empty set rather
            // then nullptr since print() do not have to handle a special case.
            static auto notfound = std::make_shared<std::set<lineno>>();

            // *TN* should not use [] since it can add a new one
            auto pos = word_map_.find(word);

            if (pos != word_map_.end())
                return QueryResult(word, input_file_, pos->second);
            else
                return QueryResult(word, input_file_, notfound);
        }

        // when not use QueryResult and do the same as print().
        void query_and_print(const std::string &word) const
        {
            auto pos = word_map_.find(word);

            if (pos != word_map_.end())
            {
                // *cxx-map-find*
                std::cout << word << " occurs " << pos->second->size() << " "
                    << make_plural(pos->second->size(), "time", "s") << std::endl;

                for (auto e : *pos->second)
                    std::cout << "(line " << e+1 << ") " << (*input_file_)[e] << std::endl;
            }
            else
                std::cout << word << " not found" << std::endl;
        }

    private:
        std::string cleanup_str(const std::string &word)
        {
            std::string ret;
            for (auto it = word.begin(); it != word.end(); ++it)
            {
                // if (!ispunct(*it))
                //     ret += tolower(*it);

                // to keep the case
                if (!ispunct(*it))
                    ret += *it;
            }
            return ret;
        }

        // vector<line> file;
        std::shared_ptr<std::vector<std::string>> input_file_;

        // *TN* map is itself not a shared_ptr
        // map<word, shared_ptr<set<lineno>>> word_map;
        std::map<std::string, std::shared_ptr<std::set<lineno>>> word_map_;
};

// *cxx-interface* part of interface
// *TN* return ostream since to give a user to control output
std::ostream &print(std::ostream &os, const QueryResult &result)
{
    os << result.word_ << " occurs " << result.lines_->size() << " "
        << make_plural(result.lines_->size(), "time", "s") << std::endl;

    // since it is a vector, can use *cxx-iter*arithmetic*:
    // 
    // for (auto e : *(pos->second))
    //     cout << "(line " << e + 1 << ") " << *(result_file_->begin()+e) << endl;

    for (auto e : *result.lines_)
        os << "(line " << e+1 << ") " << (*result.input_file_)[e] << std::endl;

    // *TN* if miss out this line, gets *seg-fault* and the trace is:
    //
    // ostream &print(ostream &os, const QueryResult &result)
    // {
    //      ...
    //      return os;
    // }
    //
    // Program terminated with signal SIGSEGV, Segmentation fault.
    // #0  0x00007f84dd7af05c in std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&) ()
    //    from /usr/lib/x86_64-linux-gnu/libstdc++.so.6

    return os;
}


//////////////////////////////////////////////////////////////////////////////
// extended example

// *TN*
// Query q = Query("hair");
//
// builds a chain and each operand(Query) has sp which is a cheap and leak safe.
//
// Q q -> NQ -> (Q -> WQ)     () has pimpl relationship
//
// and pss TextQuery
//
// q.eval(tq);
//
//
// Query q = Query("fiery") & Query("bird") | Query("wind");
//
// q -> OQ  -> AQ   -> Q-> WQ
//                  -> Q-> WQ
//          -> Q -> WQ
//
// *TN*
// QueryBase tree are not intended to be used by user so no public interface;
// all private and protected dtor. Instead, use friend between Query and
// QueryBase tree. Also private ctor as well.

class QueryBase
{
    using lineno = std::size_t;

    // friend
    friend class Query;

    protected:
        virtual ~QueryBase() = default;

    private:
        virtual QueryResult eval(const TextQuery &) const = 0;
        virtual std::string rep() const = 0;
};

// *cxx-pattern-interface* *cxx-pattern-pimpl*
class Query
{
    // friend
    friend Query operator~(const Query &operand);
    friend Query operator&(const Query &lhs, const Query &rhs);
    friend Query operator|(const Query &lhs, const Query &rhs);
    
    public:
        Query(const std::string &word);

        // *cxx-interface-class*
        // * these are non-virtual calls which makes virtual calls via pimpl.
        // *cxx-override-access-control*

        // runs a query, which is heart of this system.
        // need QueryBase due to *cxx-incomplete-type* to call function.
        QueryResult eval(const TextQuery &t) const
        { return qimpl_->eval(t); }

        // return string representation of a query
        std::string rep() const
        { return qimpl_->rep(); }

    private:
        Query(std::shared_ptr<QueryBase> query) : qimpl_(query) {}

        std::shared_ptr<QueryBase> qimpl_;
};


class WordQuery : public QueryBase
{
    // friend
    friend class Query;

    WordQuery(const std::string &word) : query_(word)
    {
        std::cout << "WQ::WQ(" << word << ")" << std::endl;
    }

    QueryResult eval(const TextQuery &tq) const
    { return tq.query(query_); }

    std::string rep() const
    { return query_; }

    std::string query_;
};

class NotQuery : public QueryBase
{
    friend Query operator~(const Query &operand);

    NotQuery(const Query &q) : rhs_(q)
    {
        std::cout << "NQ::NQ(" << rep() << ")" << std::endl;
    }

    QueryResult eval(const TextQuery &tq) const
    { 
        auto result_lines = std::make_shared<std::set<size_t>>();

        // return set which has a query word and begin/end represents lines
        // which has this word.
        auto query_result = rhs_.eval(tq);
        auto it = query_result.begin(), eos = query_result.end();
        
        if (it == eos)
            std::cout << "QueryResult::eval: it == eos" << std::endl;

        // build a new set which do not have this word
        auto file_size = query_result.get_file()->size();
        for (size_t i = 0; i < file_size; ++i)
        {
            // if not found a line in the line set
            if (it == eos || *it != i)
                result_lines->insert(i);
            // if found
            else if (it != eos)
                ++it;

            // *cxx-undefined* *cxx-off-the-end*
            // Can we do this? No since it blocks when do ++it and call trace
            // is below. This seems that increasing iterator which is past 
            // off-the-end is a cause.
            //
            // // if not found a line in the line set
            // if (*it != i)
            //     result_lines->insert(i);
            // else
            //     ++it;

            // (gdb) bt
            // #0  0x00007ffff7b466e0 in std::_Rb_tree_increment(std::_Rb_tree_node_base const*) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
            // #1  0x0000000000403c65 in std::_Rb_tree_const_iterator<unsigned long>::operator++ (this=0x7fffffffdd60) at /usr/include/c++/4.9/bits/stl_tree.h:283
            // #2  0x00000000004032ea in NotQuery::eval (this=0x614f40, tq=...) at t_ex_query_extend.cpp:343
            // #3  0x0000000000402d69 in Query::eval (this=0x7fffffffe090, t=...) at t_ex_query_extend.cpp:277
            // #4  0x0000000000402145 in t_query_03 () at t_ex_query_extend.cpp:396
            // #5  0x000000000040225c in main () at t_ex_query_extend.cpp:406
        }

        return QueryResult(rep(), query_result.get_file(), result_lines);
    }

    std::string rep() const
    { return "~(" + rhs_.rep() + ")"; }

    // *TN*
    // the operand(s) can be an object of any of the concrete classes derived
    // from QueryBase: A NotQuery can be applied to any, or another NotQuery, or
    // compound query. To allow this flexibility, the operands must be stored as
    // pointers to QueryBase. That way we can bind the pointer to whichever
    // concrete class we need.
    //
    // However, rather than using simple pointer, will use Query object. Just as
    // user code is simplified by using the interface class, we can simplify our
    // own class by using the same class.
    //
    // Q: really simplified?

    Query rhs_;
};


// *cxx-abc* since do not override eval().
class BinaryQuery : public QueryBase
{
    protected:
        using lineno = std::size_t;

        BinaryQuery(const Query &lhs, const Query &rhs, std::string op):
            lhs_(lhs), rhs_(rhs), op_(op) {}

        std::string rep() const
        { return "(" + lhs_.rep() + " " + op_ + " " + rhs_.rep() + ")"; }

        Query lhs_, rhs_;
        std::string op_;
};

class AndQuery : public BinaryQuery
{
    friend Query operator&(const Query &lhs, const Query &rhs);

    AndQuery(const Query &lhs, const Query &rhs):
        BinaryQuery(lhs, rhs, "&") 
    {
        std::cout << "AQ::AQ(" << rep() << ")" << std::endl;
    }

    QueryResult eval(const TextQuery &tq) const
    {
        auto result_lines = std::make_shared<std::set<lineno>>();

        auto lhs_result = lhs_.eval(tq), rhs_result = rhs_.eval(tq);

        // *algo-set-intersection* *cxx-set-and*
        // *TN"
        // std::inserter(result_lines, ...) cause compile errors.

        std::set_intersection(
                lhs_result.begin(), lhs_result.end(),
                rhs_result.begin(), rhs_result.end(),
                std::inserter(*result_lines, result_lines->begin()));

        return QueryResult(rep(), lhs_result.get_file(), result_lines);
    }
};

class OrQuery : public BinaryQuery
{
    friend Query operator|(const Query &lhs, const Query &rhs);

    OrQuery(const Query &lhs, const Query &rhs):
        BinaryQuery(lhs, rhs, "|")
    {
        std::cout << "OQ::OQ(" << rep() << ")" << std::endl;
    }

    QueryResult eval(const TextQuery &tq) const
    {
        auto lhs_result = lhs_.eval(tq), rhs_result = rhs_.eval(tq);

        // *cxx-set-insert* *cxx-set-or*
        auto result_lines = std::make_shared<std::set<lineno>>(
                lhs_result.begin(), lhs_result.end());
        result_lines->insert(rhs_result.begin(), rhs_result.end());

        return QueryResult(rep(), lhs_result.get_file(), result_lines);
    }
};


// implementations
inline Query::Query(const std::string &word) :  qimpl_(new WordQuery(word)) 
{
    std::cout << "Q::Q(" << word << ")" << std::endl;
}

inline Query operator~(const Query &operand)
{
    // *TN* use Query ctor so have to have friend relationship with Query.
    return std::shared_ptr<QueryBase>(new NotQuery(operand));
}

inline Query operator&(const Query &lhs, const Query &rhs)
{
    return std::shared_ptr<QueryBase>(new AndQuery(lhs, rhs));
}

inline Query operator|(const Query &lhs, const Query &rhs)
{
    return std::shared_ptr<QueryBase>(new OrQuery(lhs, rhs));
}

*cxx-overload-operator-io*
std::ostream &operator<<(std::ostream &os, const Query &query)
{
    return os << query.rep();
}


//////////////////////////////////////////////////////////////////////////////
// example

// = 03 ======
// ~Query("hair")
// WQ::WQ(hair)
// Q::Q(hair)
// NQ::NQ(~(hair))
// ~(hair) occurs 8 times
// (line 2) Her Daddy says when the wind blows
// (line 4) like a fiery bird in flight.
// (line 5) A beautiful fiery bird, he tells her,
// (line 6) magical but untamed.
// (line 7) "Daddy, shush, there is no such thing,"
// (line 8) she tells him, at the same time wanting
// (line 9) him to tell her more.
// (line 10) Shyly, she asks, "I mean, Daddy, is there?"

void t_query_03()
{
    using namespace std;

    std::ifstream ifs("t_query.dat", std::ifstream::in);

    TextQuery tq(ifs);

    cout << "~Query(\"hair\")" << endl;
    Query q = ~Query("hair");

    const auto result = q.eval(tq);

    print(cout, result) << endl;
}

int t_query_04()
{
    using namespace std;

    std::ifstream ifs("t_query.dat", std::ifstream::in);

    TextQuery tq(ifs);


    // WQ::WQ(hair)
    // Q::Q(hair)
    //
    // Executing Query for: hair
    // hair occurs 2 times
    //         (line 1) Alice Emma has long flowing red hair.
    //         (line 3) through her hair, it looks almost alive,
    Query q0 = Query("hair");

    cout << "\nExecuting Query for: " << q0 << endl;

    const auto results0 = q0.eval(tq);

    print(cout, results0) << endl;


    // WQ::WQ(Alice)
    // Q::Q(Alice)
    //
    // Executing Query for: Alice
    // Alice occurs 1 time
    //         (line 1) Alice Emma has long flowing red hair.
    Query q1 = Query("Alice");
 
    cout << "\nExecuting Query for: " << q1 << endl;

    const auto results1 = q1.eval(tq);

    print(cout, results1) << endl;


    // WQ::WQ(Alice)
    // Q::Q(Alice)
    // NQ::NQ(~(Alice))
    //
    // Executing Query for: ~(Alice)
    // ~(Alice) occurs 9 times
    //         (line 2) Her Daddy says when the wind blows
    //         (line 3) through her hair, it looks almost alive,
    //         (line 4) like a fiery bird in flight.
    //         (line 5) A beautiful fiery bird, he tells her,
    //         (line 6) magical but untamed.
    //         (line 7) "Daddy, shush, there is no such thing,"
    //         (line 8) she tells him, at the same time wanting
    //         (line 9) him to tell her more.
    //         (line 10) Shyly, she asks, "I mean, Daddy, is there?"
    Query q2 = ~Query("Alice");
 
    cout << "\nExecuting Query for: " << q2 << endl;

    const auto results2 = q2.eval(tq);

    print(cout, results2) << endl;


    // WQ::WQ(Alice)
    // Q::Q(Alice)
    // WQ::WQ(hair)
    // Q::Q(hair)
    // OQ::OQ((hair | Alice))
    //
    // Executing Query for: (hair | Alice)
    // (hair | Alice) occurs 2 times
    //         (line 1) Alice Emma has long flowing red hair.
    //         (line 3) through her hair, it looks almost alive,
    Query q3 = Query("hair") | Query("Alice");
 
    cout << "\nExecuting Query for: " << q3 << endl;

    const auto results3 = q3.eval(tq);

    print(cout, results3) << endl;


    // WQ::WQ(Alice)
    // Q::Q(Alice)
    // WQ::WQ(hair)
    // Q::Q(hair)
    // AQ::AQ((hair & Alice))
    // 
    // Executing Query for: (hair & Alice)
    // (hair & Alice) occurs 1 time
    //         (line 1) Alice Emma has long flowing red hair.
    Query q4 = Query("hair") & Query("Alice");
 
    cout << "\nExecuting Query for: " << q4 << endl;

    const auto results4 = q4.eval(tq);

    print(cout, results4) << endl;


    // WQ::WQ(wind)
    // Q::Q(wind)
    // WQ::WQ(bird)
    // Q::Q(bird)
    // WQ::WQ(fiery)
    // Q::Q(fiery)
    // AQ::AQ((fiery & bird))
    // OQ::OQ(((fiery & bird) | wind))
    // 
    // Executing Query for: ((fiery & bird) | wind)
    // ((fiery & bird) | wind) occurs 3 times
    //         (line 2) Her Daddy says when the wind blows
    //         (line 4) like a fiery bird in flight.
    //         (line 5) A beautiful fiery bird, he tells her,
    Query q5 = Query("fiery") & Query("bird") | Query("wind");
 
    cout << "\nExecuting Query for: " << q5 << endl;

    const auto results5 = q5.eval(tq);

    print(cout, results5) << endl;
}


int main()
{
    using namespace std;

    cout << "= 04 ======" << endl;
    t_query_04();

    cout << "= 03 ======" << endl;
    t_query_03();
}


={============================================================================
*kt_dev_cxx_0000* cxx-abc cxx-ex-quote-example cxx-refactoring

o supports several discount strategy
o each book has isbn number. the same book has the same isbn. 

This is the previous approach to support several discounts:

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;

    // defines discount strategy
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};


<cxx-refactoring>
Imagine that want to support `several discount strategies` How? 

Define a class which represents each strategy derived from Bulk_quote or
Quote. Or move up members for discount strategy to Quote.


Quote -> Bulk_quote -> School_quote
                    -> Xmas_quote
                    ...

However, all do not represent the general concept. So:

o Each of these discout strategies requires a quantity and a discount amount
  which are common to all discout strategies. Make it general and abstract.
  
o Each of the derived classes `will implement its discount strategy` by defining
  its own version of net_price.

This is refactoring example. Refactoring involves redesigning a class
hierarchy to move operations and/or data from one class to another. Even
though we changed the inheritance hierarchy, `code that uses` Bulk_quote or
Quote `would 'not' need to change but need to recompile.`


So seperate Disc_quote to represent `the general discount concept`, not a
concreate discount strategy, and make it abstract base class to prevent users
creating a object of this type.

class Discount_quote : public Quote {
  
  public:
    Discount_quote() = default;
    Disccount_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

    // *cxx-pure-virtual-function*
    double net_price(std::size_t) const = 0;

  protected:
    std::size_t quantity = 0;
    double discount = 0.0;
};

class Bulk_quote : public Discount_quote {
  ...
};


<error-when-create-abc> *cxx-abc* *cxx-override*
This happens when tries to create an implementation class which is derived
from ABC class. This is because implementation class did not override some of
members.

/port/CPort.cpp: In static member function 'static CPort* CPort::getInstance()':
/port/CPort.cpp:36:27: error: cannot allocate an object of abstract type 'CPort'
/port/CPort.h:29:1: note:   because the following virtual functions are pure within 'CPort':
/interface/port/IPort.h:48:22: note: 	virtual IIframe* IPortingLayer::getIframe()
/interface/port/IPort.h:56:23: note: 	virtual ISession* IPortingLayer::getSession()
/port/CPort.cpp: In constructor 'CPort::CPort()':
/port/CPort.cpp:46:25: error: cannot allocate an object of abstract type 'CIframe'
/port/CIframe.h:27:1: note:   because the following virtual functions are pure within 'CIframe':
/interface/port/IIframe.h:73:18: note: 	virtual void IIframe::destory(uint32_t)
/interface/port/IIframe.h:80:18: note: 	virtual bool IIframe::isDisplayed()
/interface/port/IIframe.h:86:18: note: 	virtual bool IIframe::setDisplayFlag()
/interface/port/IIframe.h:94:18: note: 	virtual bool IIframe::isMHEG2(void*, uint32_t)
/interface/port/IIframe.h:102:18: note: 	virtual bool IIframe::isMHEG4(void*, uint32_t)

Why? When deriving a cxx-abc class, if don't override a pure virtual func then the
derived also becomes ABC. Hence errors.

This may be a way to check whether overrides happens or not? Yes, when use ABC
and only one override. No when not use ABC and there are multiple overrides
down the inheritance.


<containers-and-inheritance>
In order to use objects of inheritance in containers, must use pointer or
reference due to sliced-off. For example, cannot use this approach.

vector<Quote> sales; or vector<Bulk_quote> sales;

One of the ironies of OOP in C++ is that we cannot use objects directly to
support it. Instead `must use pointers and references.` So often define
auxiliary class to help manage complexity that pointer use impose.


<ex>

1. use size(count) and head only
2. in push, no full check since it overwrites and in pop, it simply
calculates first from head substracing size.
3. no iterator support is needed if not use begin()/end()
 
// when introduce `discount` concept

namespace case_quote
{
  class Quote
  {
    public:

      Quote() : book_no_(), price_(0.0) {}

      Quote(string const& book, double sale_price) :
        book_no_(book), price_(sale_price) {}
      
      virtual ~Quote() {}

      std::string isbn() const { return book_no_; }

      // calculate net price but do not have "discount" concept
      virtual double net_price(size_t count) const { return count * price_; }

    private:
      std::string book_no_;
    protected:
      double price_;
  };

  class Discount_Quote : public Quote
  {
    public:

      // *cxx-ctor*
      // Why need to have constructors in abstract class although cannot define
      // objects of this type directly? Becuase ctors in classes derived from
      // Discount_quote will use the Discount_quote ctor to construct the
      // Disc_quote part of their objects. Default ctor default initialize those
      // members.

      Discount_Quote() : quantity_(0), discount_(0.0) {}
      Discount_Quote(string const& book, double price, 
          size_t quantity, double discount_percent) :
        Quote(book, price), quantity_(quantity), discount_(discount_percent) {}

      // *cxx-dtor*
      // no need to have virtual dtor here since Quote has it already
  
      // *cxx-abc*
      // okay to have in the middle of inheritance and "discount" concept
      virtual double net_price(size_t count) const = 0;

    protected:
      size_t quantity_;
      double discount_;
  };

  class Bulk_Quote : public Discount_Quote
  {
    public:
      Bulk_Quote(string const& book, double price, 
          size_t quantity, double discount_percent) :
        Discount_Quote(book, price, quantity, discount_percent) {}

      // cxx-override cxx-const
      // const is one of override condition

      virtual double net_price(size_t count) const override
      {
        if (count >= quantity_)
          return count * (1 - discount_) * price_;
        else
          return count * price_;
      }
  };

  double print_total(ostream& os, Quote const& item, size_t sold)
  {
    double net_price = item.net_price(sold);

    os << "isbn: " << item.isbn() << ", sold: " << sold 
      << ", total due: " << net_price << endl;

    return net_price;
  }

} // namespace


// To use *gtest-fixture* and do not use user class like:
//
// class Basket
// {
//     public:
//         Basket() : items(compare) {}
// 
//         void add_item(const shared_ptr<Quote> &item);
// 
//         // virtual copy, copy version
//         // which signals to use lvalue object, lvalue reference qualifier
//         void add_item(const Quote &item)
//         {
//             cout << "basket::add_item::copy version" << endl;
//             items.insert(shared_ptr<Quote>(item.clone()));
//         }
// 
//         // virtual copy, move version
//         // which signals to use rvalue object, rvalue reference qualifier
//         void add_item(Quote &&item)
//         {
//             cout << "basket::add_item::move version" << endl;
//             items.insert(shared_ptr<Quote>(std::move(item).clone()));
//         }
// 
// 
//         double total_receipt(ostream &os) const;
// 
//     private:
//         static bool compare(const shared_ptr<Quote> lhs, const shared_ptr<Quote> rhs)
//         { return lhs->isbn() < rhs->isbn(); }
// 
//         // using comp = bool (*)(const shared_ptr<Quote> lhs, const shared_ptr<Quote> rhs);
//         // multiset<shared_ptr<Quote>, comp> items;
// 
//         using comp = bool (const shared_ptr<Quote> lhs, const shared_ptr<Quote> rhs);
//         multiset<shared_ptr<Quote>, comp*> items;
// };
// 
// void Basket::add_item(const shared_ptr<Quote> &item)
// {
//     cout << "basket::add_item::copy version" << endl;
//     items.insert(item);
// }
// 
// double Basket::total_receipt(ostream &os) const
// {
//     for (auto iter = items.cbegin(); iter != items.cend();
//             iter = items.upper_bound(*iter))
//     {
//         os << "isbn : " << (*iter)->isbn() 
//             << ", sold : " << items.count(*iter)
//             << ", total sales: " << (*iter)->net_price( items.count(*iter)) 
//             << endl;
//     }
// }
//
// int main()
// {
//     Basket sale;
// 
//     // Quote sales which has no discount. 45*3 = 135
//     sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
//     sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
//     sale.add_item(make_shared<Quote>("123", 45));
// 
//     // minimum 3 and 15% discount. no discount 45*2 = 90
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
// 
//     // Bulk_quote sales which has discount: minimum 3 and 15% discount
//     // 35*4*(1-.15) = 119
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 35, 3, .15)));
// 
//     // Bulk_quote sales which has discount: minimum 5 and 25% discount
//     // 35*6*(1-.25) = 157.5
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
//     sale.add_item(shared_ptr<Quote>(new Bulk_quote("912", 35, 5, .25)));
// 
//     sale.display(cout);
//     sale.total_receipt(cout);
// }

class BulkQuoteTest : public ::testing::Test
{
  protected:

    // *cxx-using* is under *cxx-access-control*

    using Quote = case_quote::Quote;

    BulkQuoteTest() : items_{compare} {}
    virtual ~BulkQuoteTest() {}

    virtual void SetUp() {}
    virtual void TearDown() {}

    double total_receipt() const
    {
      double total{};

      // when there are duplicates, skip them since net_price() gets called for
      // them in single call

      for (auto it = items_.cbegin(); it != items_.cend();
          it = items_.upper_bound(*it))
      {
        total = (*it)->net_price(items_.count(*it));

        cout << "isbn: " << (*it)->isbn()
          << ", sold: " << items_.count(*it)
          << ", total sales: " << total << endl;
      }

      return total;
    }

    static bool compare(std::shared_ptr<Quote> const lhs, std::shared_ptr<Quote> const rhs)
    {
      return lhs->isbn() < rhs->isbn();
    }

    using comp = 
      bool(std::shared_ptr<Quote> const lhs, std::shared_ptr<Quote> const rhs);

    std::multiset<std::shared_ptr<Quote>, comp*> items_;
};

TEST_F(BulkQuoteTest, CheckTotal_1)
{
  items_.insert(shared_ptr<Quote>(new Quote("123", 45)));
  items_.insert(shared_ptr<Quote>(new Quote("123", 45)));
  items_.insert(shared_ptr<Quote>(new Quote("123", 45)));

  // Quote sales which has no discount. 45*3 = 135
  EXPECT_THAT(total_receipt(), 135);

  items_.clear();
}

TEST_F(BulkQuoteTest, CheckTotal_2)
{
  using namespace case_quote;

  items_.insert(shared_ptr<Quote>(new Bulk_Quote("345", 45, 3, .15)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("345", 45, 3, .15)));

  // minimum 3 to have 15% discount. 2 and no discount 45*2 = 90
  EXPECT_THAT(total_receipt(), 90);

  items_.clear();
}

TEST_F(BulkQuoteTest, CheckTotal_3)
{
  using namespace case_quote;

  items_.insert(shared_ptr<Quote>(new Bulk_Quote("678", 35, 3, .15)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("678", 35, 3, .15)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("678", 35, 3, .15)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("678", 35, 3, .15)));

  // Bulk_quote sales which has discount: minimum 3 and 15% discount
  // 35*4*(1-.15) = 119
  EXPECT_EQ(total_receipt(), 119);

  items_.clear();
}

TEST_F(BulkQuoteTest, CheckTotal_4)
{
  using namespace case_quote;

  items_.insert(shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));
  items_.insert(shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));

  // Bulk_quote sales which has discount: minimum 5 and 25% discount
  // 35*6*(1-.25) = 157.5
  EXPECT_EQ(157.5, total_receipt());

  items_.clear();
}


{cxx-virtual-copy} *cxx-clone* CPR-633

As seen, the user has to use shared_ptr to add items:

{
  sale.add_item(std::shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));
  sale.add_item(std::shared_ptr<Quote>(new Bulk_Quote("912", 35, 5, .25)));

  or 

  sale.add_item(std::make_shared<Quote>("912", 35, 5, .25));
}


To allow the user to add items like:

sale.add_item(Quote("def", 35));
sale.add_item(Bulk_quote("678", 55, 5, .25));


have to chagne add_item():

void add_item(const shared_ptr<Quote> &item);

void add_item(const Quote &sale);    // copy version
void add_item(Quote &&sale);         // move version

void add_item( const Quote &sale )
{
  items_.insert(std::shared_ptr<Quote>(new Bulk_Quote(sale)));
}

This won't do right thing when do add_item(Bulk_Quote) since only Quote parts
will be copied. See *cxx-sliced-off* problem. How to solve? Use overloads?
Use virtual copy to have right version. 


<ex>
namespace case_quote_clone
{
  class Quote
  {
    public:

      Quote() : book_no_(), price_(0.0) {}

      Quote(string const& book, double sale_price) :
        book_no_(book), price_(sale_price) {}
      
      virtual ~Quote() {}

      std::string isbn() const { return book_no_; }

      // calculate net price but do not have "discount" concept
      virtual double net_price(size_t count) const { return count * price_; }

      // *cxx-clone* *cxx-move* copy version
      // *cxx-reference-qualifier*
      // note: shall have `const` or see *cxx-const-to-nonconst-error*
      // note: if there's no move verison, copy version will be used instead
      virtual Quote* clone() const &
      {
        cout << "quote::clone() &" << endl;
        return new Quote(*this);
      }

      // cxx-clone, move version
      virtual Quote* clone() const &&
      {
        cout << "quote::clone() &&" << endl;
        return new Quote(std::move(*this));
      }

    private:
      std::string book_no_;
    protected:
      double price_;
  };

  class Discount_Quote : public Quote
  {
    public:

      // *cxx-ctor*
      // Why need to have constructors in abstract class although cannot
      // define objects of this type directly? Becuase ctors in classes
      // derived from Disc_quote will use the Disc_quote ctor to construct
      // the Disc_quote part of their objects. Default ctor default
      // initialize those members.

      Discount_Quote() : quantity_(0), discount_(0.0) {}
      Discount_Quote(string const& book, double price, 
          size_t quantity, double discount_percent) :
        Quote(book, price), quantity_(quantity), discount_(discount_percent) {}

      // *cxx-dtor*
      // no need to have virtual dtor here since Quote has it already
  
      // *cxx-abc*
      // okay to have in the middle of inheritance and "discount" concept
      virtual double net_price(size_t count) const = 0;

    protected:
      size_t quantity_;
      double discount_;
  };

  class Bulk_Quote : public Discount_Quote
  {
    public:
      Bulk_Quote(string const& book, double price, 
          size_t quantity, double discount_percent) :
        Discount_Quote(book, price, quantity, discount_percent) {}

      // cxx-override cxx-const
      // const is one of override condition

      virtual double net_price(size_t count) const override
      {
        if (count >= quantity_)
          return count * (1 - discount_) * price_;
        else
          return count * price_;
      }

      // cxx-clone
      // cxx-error virtual Bulk_Quote* clone() const override &
      // cxx-const
      // if don't have const, no error but no override. so use override keyword
      virtual Bulk_Quote* clone() const& override
      {
        cout << "bulk_quote::clone() &" << endl;
        return new Bulk_Quote(*this);
      }

      virtual Bulk_Quote* clone() const&& override
      {
        cout << "bulk_quote::clone() &&" << endl;
        return new Bulk_Quote(std::move(*this));
      }
  };

  double print_total(ostream& os, Quote const& item, size_t sold)
  {
    double net_price = item.net_price(sold);

    os << "isbn: " << item.isbn() << ", sold: " << sold 
      << ", total due: " << net_price << endl;

    return net_price;
  }


  class Basket
  {
    public:
      // *cxx-undefined*
      // Without it, cause core when add_item is called.
      Basket() : items_{compare}
      {}

      void add_item(std::shared_ptr<Quote> const& item)
      {
        cout << "basket::add_item(shard_ptr)" << endl;
        items_.insert(item);
      }

      // copy version
      void add_item(Quote const& item)
      {
        cout << "basket::add_item(Quote const&)" << endl;
        items_.insert(std::shared_ptr<Quote>(`item.clone()`));
      }

      // move version *cxx-dynamic-binding*
      void add_item(Quote &&item)
      {
        cout << "basket::add_item(Quote &&)" << endl;
        items_.insert(std::shared_ptr<Quote>(`std::move(item).clone()`));
      }

      double total_receipt(ostream& os) const
      {
        double total{};

        for (auto iter = items_.cbegin(); iter != items_.cend();
            iter = items_.upper_bound(*iter))
        {
          total = (*iter)->net_price(items_.count(*iter));
          os << "isbn: " << (*iter)->isbn()
            << ", sold: " << items_.count(*iter)
            << ", total sales: " << total << endl;
        }

        return total;
      }

    private:
      static bool compare(const std::shared_ptr<Quote> lhs,
          const std::shared_ptr<Quote> rhs)
      { return lhs->isbn() < rhs->isbn(); }

      using comp = bool(const std::shared_ptr<Quote>,
          const std::shared_ptr<Quote>);

      std::multiset<shared_ptr<Quote>, comp*> items_;
  };

} // namespace

// [ RUN      ] CxxCaseQuote.Clone
// basket::add_item(Quote &&)
// quote::clone() &&
// basket::add_item(Quote &&)
// quote::clone() &&
// basket::add_item(Quote &&)
// quote::clone() &&
// basket::add_item(Quote &&)
// bulk_quote::clone() &&
// basket::add_item(Quote &&)
// bulk_quote::clone() &&
// isbn: 123, sold: 3, total sales: 135
// isbn: 345, sold: 2, total sales: 90
// [       OK ] CxxCaseQuote.Clone (2 ms)

TEST(CxxCaseQuote, Clone)
{
  using namespace case_quote_clone;

  Basket sale;

  // Quote sales which has no discount. 45*3 = 135
  sale.add_item(Quote("123", 45));
  sale.add_item(Quote("123", 45));
  sale.add_item(Quote("123", 45));

  // minimum 3 and 15% discount. no discount 45*2 = 90
  sale.add_item(Bulk_Quote("345", 45, 3, .15));
  sale.add_item(Bulk_Quote("345", 45, 3, .15));

  sale.total_receipt(cout);
}


={============================================================================
*kt_dev_cxx_0000* cxx-abc-call-in-dtor

<cxx-abc-pure-virtual>
// from mapfile

 .text.__cxa_pure_virtual
                0x00000000004027b0       0x1f /usr/lib/gcc/x86_64-linux-gnu/4.9/libstdc++.a(pure.o)
                0x00000000004027b0                __cxa_pure_virtual

// gcc/libsupc++/pure.cc

extern "C" void
__cxxabiv1::__cxa_pure_virtual (void)
{
  writestr ("pure virtual method called\n");
  std::terminate ();
}

<purpose>
https://stackoverflow.com/questions/920500/what-is-the-purpose-of-cxa-pure-virtual?noredirect=1&lq=1
If anywhere in the runtime of your program an object is created with a virtual
function pointer not filled in, and when the corresponding function is called,
you will be calling a 'pure virtual function'.

The handler you describe should be defined in the default libraries that come
with your development environment. If you happen to omit the default
libraries, you will find this handler undefined: the linker sees a
declaration, but no definition. That's when you need to provide your own
version.

The infinite loop is acceptable because it's a 'loud' error: users of your
software will immediately notice it. Any other 'loud' implementation is
acceptable, too.


<ex>
in this case, provides own __cxa_pure_virtual(). see this pointer, 0x2b02b4fc,
gets changed and item is getting freed?

Core was generated by `/NDS/bin/MW_Process MW_Process'.
Program terminated with signal 8, Arithmetic exception.
#0  0x008bee20 in __cxa_pure_virtual () at ms_utils.cpp:103
#0  0x008bee20 in __cxa_pure_virtual () at ms_utils.cpp:103
        _XDEBUG_TraceAssociationStr = 0x12f49a0 "< no-ctx >"
        _XDEBUG_FuncInfo = {funcName = 0x12f4710 "__cxa_pure_virtual", dummy = 0}
#1  0x00997a08 in MSCPP::ITEM::GetFilter (this=0x1, filter_type=MSCPP::E_MS_FILTER_TYPE_BUFFERPUMP) at item.cpp:6259
        p_filter = 0xff0000 <PANEL_ReceiveMessage+1072>
#2  0x0099b768 in MSCPP::ITEM::SetItemRunningJobs (`this=0x2b02b4fc`, p_item_running_jobs=0x2b02b4fc) at item.cpp:15740
No locals.
#3  0x0099b7c8 in MSCPP::ITEM::UndoGraph (this=0xff0000 <PANEL_ReceiveMessage+1072>, graph_index=1) at item.cpp:15688
No locals.
0x4, p_params = `0x2b02b4fc`, callback = 0x98fce8 <MSCPP::ITEM::ActionListFsm_SetState(MSCPP::ITEM_ACTION_LIST_FSM_STATE)+28>}, undo_event = {p_action_list = 0x4, callback = 0x2b02b4fc}, action_done_event = {action_id = 4, p_out_params = 0x2b02b4fc, result = 10026216}, action_undone_event = {action_id = 4, result = 721597692}}}
        _XDEBUG_FuncInfo = {funcName = 0x1333440 "ActionFsm_HandleUndoEvent", dummy = 0}

        
extern "C"
{
  /** In some platforms, the function is not implemented, meaning
    that we should provide an implementation */
  void __cxa_pure_virtual(void);

  void __cxa_pure_virtual(void)
  {
    XDEBUG_DEFINE_FUNC_INFO("__cxa_pure_virtual");
    crash_variable -=1;
    XDEBUG_WARN1_2("is valud is %d, new value : %d ", crash_variable, 5/(crash_variable-1)) ;
    MS_ASSERT_ZERO("Pure virtual function call");
  }
}


// CMS_MEDIA_SERVICES/Media_Streamer/generic/inc/item.hpp

namespace MSCPP
{
    class MS_FILTER : public TRACE_ASSOCIATION, private virtual NonCopyable
    {
        public:
            virtual MS_FILTER *GetSource(_in_ ITEM       *p_item) = 0;
            virtual MS_FILTER *GetDest(_in_ ITEM         *p_item) = 0;
    };

    class SHARED_FILTER : public MS_FILTER
    {
      // no override
    };

    class BUFFERPUMP_FILTER : public SHARED_FILTER, public MS_SRC_PUSH, public MS_DEST_PULL
    {
      public:
        virtual MS_FILTER *GetSource(_in_ ITEM       *p_item);
        virtual MS_FILTER *GetDest(_in_ ITEM         *p_item);
    };
}


MS_FILTER* ITEM::GetFilter(_in_ MS_FILTER_TYPE   filter_type)
{
  MS_FILTER *p_filter = m_p_source_filter;

  while (p_filter != XNULL)
  {
    if (p_filter->GetType() == filter_type)
    {
      break;
    }
    p_filter = p_filter->GetDest(this);
  }

  return p_filter;
}

so what's the actual filter type? is it in the middle of free?


={============================================================================
*kt_dev_cxx_0000* cxx-copy-prevent-copies cxx-delete cxx-no-copy

CPR 507 and EC++06. How can define a class to prevent copy or assign like
`iostream` class? Do not defining copy-controls? This do not work as compiler
will make them if not defined. 

Two ways: `delete-keyword` and `private-access-control`.

<cxx-copy-delete> *cxx-11*
Signal to the compiler `not to define` these members and lead to compile error
when try to use it. Or syn version will be `deleted` when compiler cannot make
it.

struct NoCopy {
  NoCopy() = default;
  NoCopy(const NoCopy&) = delete;                 // NO copy-ctor 
  NoCopy& operator=(const NoCopy&) = delete;      // NO copy-assign
  ~NoCopy() = default;
  ...
};


*cxx-dtor*
If the dtor is deleted, then there is no way to destory objects of that type.
The compiler will not let us define variables or create temporaries of that
type.


<cxx-copy-private-before-cxx-11>
To prevent copies before C++11:

class PrivateCopy {
  private:
    // `declare but not define` 
    PrivateCopy(const PrivateCopy&);
    PrivateCopy &operator=(const PrivateCopy&);

  public:
    PrivateCopy() = default;
    ~PrivateCopy();
};

Since the dtor is public, users will be able to define object but not be able
to copy such objects.

The either way will see errors:

: error: ‘messaging::dispatcher::dispatcher(const messaging::dispatcher&)’ is private
       dispatcher(dispatcher const &) = delete;
       ^

: error: use of deleted function ‘messaging::dispatcher::dispatcher(const messaging::dispatcher&)’
       { return dispatcher(&q_); }


<ex>
namespace cxx_copy_control
{
  class CopyControlBase1
  {
  private:
    int value_;

  public:
    CopyControlBase1()  = default;
    ~CopyControlBase1() = default;

  private:
    CopyControlBase1(const CopyControlBase1 &base)
    {
      (void)base;
      cout << "copy-ctor: base" << endl;
    } // @11

    CopyControlBase1 &operator=(const CopyControlBase1 &base)
    {
      (void)base;
      cout << "copy-assign: base" << endl;
      return *this;
    }
  };

  class Derived1 : public CopyControlBase1
  {
  public:
    void print() { cout << "derived get shout" << endl; };
  };

  class CopyControlBase2
  {
  private:
    int value_;

  public:
    CopyControlBase2()  = default;
    ~CopyControlBase2() = default;

  public:
    CopyControlBase2(const CopyControlBase2 &base) = delete;
    CopyControlBase2 &operator=(const CopyControlBase2 &base) = delete;
  };

  class Derived2 : public CopyControlBase2
  {
  public:
    void print() { cout << "derived get shout" << endl; };
  };
} // namespace cxx_copy_control

TEST(CxxCopyControl, UsePrivateAndDelete)
{
  using namespace cxx_copy_control;

  {
    CopyControlBase1 b1, b2;

    // error: ‘cxx_copy_control::CopyControlBase1::CopyControlBase1
    // (const cxx_copy_control::CopyControlBase1&)’
    // is private within this context
    CopyControlBase1 b3(b1);
  }

  {
    CopyControlBase2 b1, b2;

    // error: use of deleted function
    // ‘cxx_copy_control::CopyControlBase2::CopyControlBase2
    // (const cxx_copy_control::CopyControlBase2&)’
    CopyControlBase2 b3(b1);
  }

  {
    CopyControlBase2 b1(100);
    CopyControlBase2 b2;

    // error: use of deleted function ‘void
    // copy_control_assign::CopyControlBaseUseDelete::operator=(const
    // copy_control_assign::CopyControlBaseUseDelete&)’
    //    d2 = d1;
    //       ^

    b2 = b1;
  }

  {
    Derived2 b1, b2;

    // error: use of deleted function
    // ‘cxx_copy_control::Derived2::Derived2(const cxx_copy_control::Derived2&)’
    //      Derived2 b3(b1);
    //                    ^
    // note: ‘cxx_copy_control::Derived2::Derived2(const
    // cxx_copy_control::Derived2&)’ is implicitly deleted because the default
    // definition would be ill-formed:
    //    class Derived2 : public CopyControlBase2
    //          ^~~~~~~~
    // error: use of deleted function
    // ‘cxx_copy_control::CopyControlBase2::CopyControlBase2(const
    // cxx_copy_control::CopyControlBase2&)’ note: declared here
    //      CopyControlBase2(const CopyControlBase2 &base) = delete;
    //      ^~~~~~~~~~~~~~~~

    Derived2 b3(b1);
  }
}


<cxx-friend-can-access> 
However, friend and members still can access private. How to prevent this? Use
`link error` by not defining in addition to using private access.

using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  public:
    int m_iDataABCAnimal;
    Base(const Base& base);      // NO definition
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

int main()
{
  Base b1, b2;

  Base b3(b1);
}

$ ./comp.sh use-prevent-copy.cpp 
/tmp/ccskAMRR.o: In function `main':
/home/kit/work/use-prevent-copy.cpp:22: undefined reference to 
  `Base::Base(Base const&)' collect2: ld returned 1 exit status


To prevent access from derived classes or user, make copy control private and
cause compile error.

To prevent access from friend or members, so declare copy controls but not
define. By doing this, can cause 'link' errors when there are attempts to use.
Because when used, compiler will try to link but no definition. The example is
ios_base, basic_ios, and sentry of STL implementation.


<boost-noncopyable>
EC++06. For a easy use of adding preventing copy features discussed above, use
uncopyable class as a base which is boost::noncopyable. This has couple of
consideration for inheritance.

#include <iostream>

class Uncopyable {
  protected:                                                   // note
    Uncopyable() {}
    ~Uncopyable() {}

  private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};

// class Foo : public/protected Uncopyable {                  // note
class Foo : private Uncopyable {                              // 13
  public:
    void WhoAmI() { std::cout << "foo" << std::endl; }
};

int main()
{
  Foo f;
  f.WhoAmI();

  // errors only when add followings
  Foo o;
  o = f;                                                      // @26
}

: In function ‘int main()’:
:26:6: error: use of deleted function ‘Foo& Foo::operator=(const Foo&)’
:13:7: error: ‘Foo& Foo::operator=(const Foo&)’ is implicitly deleted 
   because the default definition would be ill-formed:
:10:17: error: ‘Uncopyable& Uncopyable::operator=(const Uncopyable&)’ is private
:13:7: error: within this context

note: Why protected on ctor and dtor? Only possible to create it via
inheritance. e.g. derived class.

note: Regardless of inheritance type, won't compile. Why shouldn't be public?
Since it is not is-a relationship and the case use is 'private'.

note: Why not virtual dtor in base? By using protected dtor, make it error to
use delete on base but able to run dtor via derived class. See
non-virtual-destruction-problem. 


*cpp-access-error*
<Q> Why this error on calling test_f()? Since use of reference parameter do not
cost copy constructor, what calls are involved here?

error: 'Uncopyable' is an inaccessible base of ‘Foo’

void test_f( Uncopyable &uc )
{
  uc.WhoAmI();
}

int main()
{
  Foo fo;
  test_f(fo);
}


={============================================================================
*kt_dev_cxx_0000* cxx-function-matching cxx-overload

Known as *cxx-overload-resolution* and function matchins means the same.

`The name has scope` and `object has lifetime.` Three possible outcomes: best
match, no match, and ambiguous call.


01: *cxx-name-lookup* *cxx-argument-dependant-lookup*

For `name-lookup` inside a namespace, look in members in case class, and if
not found, continue looking in enclosing scope; which is a open scope having a
name to look up. This can be `block, class, or cxx-namespace` So continue looking
in classes up the chain of inheritance or namespaces. This search goes upwards
that means declared before use and before in reading order. For example, int
A::C1::f3() in qualified name. 

In addition, use `argument-dependant-lookup` for reference and pointer of
class type. For non-class, enclosing scope that is before the point of use and
is still open. See Primers p797. `using-declaration` or directive add names to
the candidate set. 

  "If found the name, the compiler looks 'no' further"

Use the number of arguments, type match, and conversion to get viable
functions. `In C++, name lookup happens before type checking`


<scope-and-search>
The search looks 'outwards' or 'upwards' through the 'enclosing' scopes which
are declared 'before' the point of use and are still 'open'. The enclosing
scopdes are blocks, namespaces, and base classes and search goes upwards and
ends 'global' namespace. Hence *cxx-hide-name* can happen.


02: <build-candidate> use name and build candiate of overloads and
template instantiations

Use 'name' only hence called name-lookup. Build candidate functions which is
the set of overloaded functions and should be the same name and visible.
Include any function-template instantiation for which template argument
deduction succeeds.

// *cxx-overload-condition* *cxx-scope*
// Member functions differing only in their constness can be overloaded.
// Conditons for overloading
//
// * Shall be the same 'name'
// * Shall have different param list in the 'number' or the 'type'
// * Shall be in `the same scope`
// 
// It is an error for two functions to differ only in terms of their return
// types.


03: <build-viables>


#04: <find-best-match> prefer best and nontemplate

The exact match is better than a match that requires a conversion.
`nontemplate` function is selected if there's only one in the set. If not,
more specialized func template is called. otherwise, the call is ambiguous.


#05: <check-access>

See accessibilty in case of inheritance. From EC++40


#06: <virtual-or-not>

If it is a virtual call, generate a code for run-time binding. Otherwise,
generate a normal call.


{wider-candidate-set-op-overload}

a op b;

This says nothing about whether it would calls member or non-member. So the set
is wider to both member and non-member to be considered.  


<in-inheritance>
CPP 617. Hierarchical nesting of class scope; means that the derived is nested
in the base scope and names in the derived can hide names declared in the base.
See {override-keyword} *kt_dev_cpp_023* The point is that the name-lookup
happens at compile time and uses static-type. The below shows that point.

class Disc_quote : public Quote {
  public:
    // added in this class only
    std::pair<a,b> discount_policy() const {}
};

class Bulk_quote : public Disc_quote {
  ...
};

Bulk_quote bulk;

Bulk_quote* bulkP = &bulk;
Quote* itemP = &bulk;        // static and dynamic type differ

bulkP->discount_policy();
itemP->discount_policy();    // error

What if discount_policy is a virtual func? Doesn't matter in this case and it's
still error because this is not found in Quote class.

Tried with GCC and got an error:
.cpp:139:10: error: 'class Quote' has no member named 'discount_policy'


<cxx-hide-name>
EXC++34. Name Hiding

The code below may will compile or maybe not. GCC 4.7.2 builds fine. 

The std::accumulate uses operator+(int, N::C) and the problem is that the
compiler may or may not be able to see that function depending on the compiler
implementation since C++ does not specify which standard headers will include
each other.

The namespace N do not have oparator+() and continue to search it in std
namespace. If compiler finds one then no look further so don't see the one in
global scope. If compiler do not find one, then see one in global scope.

<ex>
namespace N { class C {}; }

int operator+(int i, N::C) { return i+1; }

#include <numeric>

int main()
{
  N::C a[10];
  std::accumulate(a, a+10, 0);
}


The solution is to make the operator+() the part of interface by putting it
into the same namespace. This will builds regardless of compiler
implementations.

namespace N { 
  class C {}; 
  int operator+(int i, N::C) { return i+1; }
}

#include <numeric>

int main()
{
  N::C a[10];
  std::accumulate(a, a+10, 0);
}


={============================================================================
*kt_dev_cxx_0000* cxx-function-alias

https://www.fluentcpp.com/2017/10/27/function-aliases-cpp/

C++11: function aliases

C++11 provides another approach for this:

const auto newId = newIdFromDatabase;

This solves most of the above drawbacks: it makes no extra copy, since calling
  newId is calling newIdFromDatabase, and the declaration is quite
  straightforward.

EDIT: Note the const! As Stephan T. Lavavej pointed out, having a bare auto
newId = newIdFromDatabase would be dangerous because the function pointer
newId could be changed and point to something else. It would be like a global
variable, but in the form of a function. Very complex and bug-prone.

Here, newId was a function pointer. We could also define it a function
reference:


auto& newId = newIdFromDatabase;

In this case we no longer needs a const because this function reference, like
  all references, can’t be reassigned. But the resulting declaration looks a
  bit weird. A big thank you to Stephan for those observations.

Note that you don’t even need to have the full definition of newIdFromDatabase
available at the point of the function alias declaration. Only its declaration
needs to be visible from it. Indeed, the actual resolution is made by the
linker, like with any other function.

EDIT: Note that newId is not strictly a function alias since there is no such
thing in C++, but a function pointer that semantically plays the role of an
alias here.

Let’s mention that C++98 could achieve an roughly equivalent result, as it
could manipulate functions:


typedef int (&IdFunction)();
IdFunction newId = newIdFromDatabase;

But the syntax was really not natural to read, and you can imagine that it
  doesn’t get better when there are more arguments. The real new feature that
  enables practical function aliasing here is auto.

Note that while one-liners added an extra step in debugging, this approach
kind of removes one step. Indeed, when you step in newId at call site, you
directly fall into newIdFromDatabase and you don’t even see newId in the call
stack. This can be disturbing. Another drawback is that since newId is a
function reference, it will not be inlined.


={============================================================================
*kt_dev_cxx_0000* cxx-namespace cxx-interface

{cxx-namespace-case}
03/07/2014. At samsung. 
When moves application which was a process and uses static link to the shared
library application to be used by other processes. The codes which works well
before starts to fail since crash happens when try to create a thread using
custom thread library. 

Problem of linking? Problem of the thread library when used in shared library
application? Somehow linker picks up the wrong libaray since a debugger shows
odd address when thread creation call is made and causes a crash? 

Tried various directions and spent many days. Eventually, found out that
PCThread::Create() is a problem and works fine when changes parameter orders.
The problem was that the process loads a lot of shared library and one of
those has the same PCThread class in it but different signature. When our
library make a call, it picks it up from the other shared library in which has
different signature so crashes. Sovled when wraps PCThread class with a
namespace.

note: So this was a problem of symbols between shared libraries.

The typical example is to use third party library and name conflict happens
when other parties develops a libaray separately. In static link, conflict
happens in link stage. In dynamic loading, this happens at run time and called
dynamic binding. So more difficult to find out.

See *kt_linux_core_107* shared library: search and resove


{cxx-namespace}
To solve name pollution or collisions, namespace partitions the global
namespace and `a namespace is a scope` It provides a much more controlled
mechanism and any declaration can be put into a namespace.


<global-namespace>
Names defined at global scope are in the global-namespace which is implicitly
declared and exists in every program. The scope operator can be used. Use "::"
for global variables.

::member_name


<named-namespace>
*cxx-remember* Except for function and namespce definitions, a declaration is
terminated by a semicolon.

namespace Foo {
  ...
}


<ways-to-use-member-in-namespace>
Code outside the namespace must indicate the namespace in which the name is
defined.

cplusplus_primer::Query q = cplusplus_primer::Query("Hello");

Other ways of referring to members from outside their namespace are using
declaration, using directive, and argument-dependent lookup.


<use-marco>

#define NS_OPEN namespace XXX {
#define NS_CLOSE }

# header or source file

# include <xxx>

NS_OPEN
...
NS_CLOSE


{cxx-namespace-unnamed} *cxx-static-file* 
Unnamed namespace. variables in unnamed namespace has staic lifetime so has
file scope as with file static. If a header file has vars in unnamed
namespace, it create different static vars which are local to file that
includes that header file. This also means that unnamed-namespace never spans
multiple files and do 'not' recommend to have it in a header since the names
in that namespace define different entities local to each file that includes
the header.

C++PL 422
By default, const objects, constexpr objects, type aliases, and anything
declared static in a namespace scope have internal linkage.


namespace {
  ...
}

<ex>
#include <iostream>

int i;         // 3

namespace {
   int i;      // 6
}

int main()
{
   i = 10;     // 11. ambiguous: defined globally and in an 
               // unnested, unnamed namespace.

   return 0;
}

sam01.cpp: In function ‘int main()’:
sam01.cpp:11:2: error: reference to ‘i’ is ambiguous
sam01.cpp:3:5: error: candidates are: int i
sam01.cpp:6:6: error:                 int {anonymous}::i

<same-as-static>
For static variable, try to use extern keyword and fails to link in the end.
This is the same when use unnamed namespace. If not use extern then have
multiple definition error. 

<global-variables>
Can use namespace for global variables:

// file one
namespace NG {
  int gfs_count;
}

// file two
namespace NG {
  extern int gfs_count;
}


{cxx-using-declaration-and-directive} *cxx-using*
The `using-declaration` which brings one namespace member into the scope that
uses it.

using std::cin;

The `using-directive` which brings whole namespace into the the scope that
have both a namespace and a scope that uses directive. This is enclosing scope
that is outter scope than the one uses directive.

`using namespce` std;

<avoid-use-of-directive>
Why? Other than else, `late detection`; means that ambiguity errors are
detected only at the point of use when use directive. This late detection
means that conflicts can arise long after introducing a particular library. If
the program begins using a new part of the library, perviously undetected
collisions may arise.

// ex. blip namespace is injected into the global namespce but no compile
// error. Emit error when strat to use j. At a point of `use`.

#include <iostream>

namespace blip {
  int i=16, j=15;
}

int j = 0;

int main()
{
  using namespace blip;

  //++j;

  return 0;
}


// ex. immediate compile error regardless of using j. At a point of
// `declaration`. sam01.cpp:9:13: error: ‘j’ is already declared in this scope

#include <iostream>

namespace blip {
  int i=16, j=15;
}

int j = 0;

using blip::j; 

int main()
{
   return 0;
}


<avoid-use-in-header-file>
Why? A header that has a using directive or declaration at its top-level
injects names into every file that includes the header. 

<when-directive-useful>
One place where using directive are useful is in the implementation files of
the namespace itself.


{cxx-namespace-nested}

namespace X { 
  namespace App {
    class X : public XXX
    {
      ...
    };
  }
}

using namespace X;
using namespace X::App;
X a;

or

using namespace X;
App::X a;


{rename-namespace}
namespace bt = boost::posix_time;


{cxx-argument-dependant-lookup} *cxx-adt* 

CPP 797. See this statements:

std::string s;
std::cin >> s;

this is equi to:

operator>>(std::cin, s); 

This operator>>() is defined in the string libaray as a `non-memeber` and in
std namespace. 

When func has class type argument which is class object, pointer or reference,
     the compiler searches `namespace` in which argument defined in addition
     to the normal scope to lookup. 

In this case, searches the namespace std, where cin and string is defined and
found this func from string. 

This saves the programmer a lot of typing. Otherwise, should use for every
use:

using std::operator>>; or std::operator>>(std::cin, s);

Either would make simple use of the IO library more complicated. This makes it
easy to use nonmember func which is conceptually part of class interface.


EXC++31 Koenig Lookup

In short, the meaning of code in namespace B is being affected by a function
declared in the completely separate namespace A, even though B has done
nothing but simply mention a type found in A.

namespace aren't quite as independent as people originally thought, but they
are still pretty independent and fit their intendted purpose.


<ex>

When you pass in a function parameter that belongs to a namespace, the
compiler includes that namespace when performing name lookup on functions
within the body of the function. You may not need this every day, but it saves
a lot of typing or an extra using directive when you do. The idea behind this
is that functions that operate on some type are often defined in the same
namespace as that type. Incidentally, it a good practice, in general, to put
functions that operate on certain types in the same namespace as those types,
when possible.

void f(dev::Device& d) {
  register(d); // This is actually dev::register
}


EXC++ 120. say that member is more strongly related to the class than a
nonmember.

namespace A
{
  class X {};
  void f(X);
}

namespace B
{
  void f(A::X);
  void g(A::X parm)
  {
    // use A::f or B::f()?. ambiguous
    f(parm);
  }
};


namespace A
{
  class X {};
  void f(X);
}

class B
{
  void f(A::X);
  void g(A::X parm)
  {
    // use B::f(), not ambiguous
    f(parm);
  }
};


<what-makes-up-the-interface-of-class>
EXC++32. Interface Principle.

the class definition:

"A class describes a set of data, along with the functions that operate on
that data"

Here, function means all function. For class X, all functions, including
`free-functions` (non-member function), that both:

* Mention X
* Are supplied wth X 
  means that `come in the same header file and/or namespace`

are logically part of X, because they form part of the interface of X.
See *cxx-ex-query-example*


*cxx-pattern-handle*
`handle-technique` for writing OO code in a language that doesn't have
classes. After all, "a sef of data, along with the functions that operate on
that data"

struct _iobuf { /* data goes here */ };

typedef struct _iobuf FILE;

FILE* fopen(const char* filename, const char* mode);
int fclose(FILE* stream);

long ftell(FILE* stream);
/* etc */


class FILE
{
  public:
    FILE(const char* filename, const char* mode);
    ~FILE();

    int fseek(long offset, int origin);
    long ftell();
    /* etc */

  private:
    /* data goes here */
};


{namespace-express-logical-structure}
The namespace is open and it shall express logical structure; interface
separated from implementation.  

The declaration and definition should be in the same namespace and this means
that shall use namespace block in 'both' header and source file as well.

// Sales_data.h
#include <string>

namespace cplusplus_primer {
  class Sales_data { ... };
  Sales_data operator+( const Sales_data&, const Sales_data&);
  // declarations for the remaining functions in the Sales_data interface
}

// Sales_data.cpp
#include "Sales_data.h"

namespace cplusplus_primer {
  // definitions for the Sales_data members and overloaded operators
}

// user.cpp
#include "Sales_data.h"

int main()
{
  using c_plusplus_primer::Sales_data;
  Sales_data trans;
  ...
}


<cxx-ood> *cxx-encapsulation* *cxx-namespace*

https://stackoverflow.com/questions/1434937/namespace-functions-versus-static-methods-on-a-class

C.5: Place helper functions in the same namespace as the class they support
http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c5-place-helper-functions-in-the-same-namespace-as-the-class-they-support

EC++23 About considering encapsulation in design:

OOD principle dictates that data and functions that operates on them should be
bundled together. Does it suggest that member function is a better choice? No
since OOD is about encapsulation. The non-member and non-friend provides more
encapsulation, packaging flexibility, and extensibility.

The greater something is encapsulated, then the greater our ability to change
it later without breaking user codes. Roughly, when there are 'more' funcs to
access data, it's less encapsulated. Assumes that it follows the rule in
EC++22 that member data must be private and therefore provide only funtional
interfaces to access data.

If use private member data, then only member function and friend can use it.
If member function and non-member non-friend function provides the same
functionality, which is better? non-member non-friend function 

  "Since it doesn't increase the number of functions that can access the
  private part of the class or dependant on memeber data." 

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
};


Add more interface?

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    void clearEverything();
    ...
};


Or, add non-member non-friend function?

void clearBrowser( Webbrowser& wb )
{
  wb.clearCache();
  wb.clearHistory();
  wb.removeCookies();
}


Use namespace due to *cxx-argument-dependant-lookup*

namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}


Partitioning on convenience functions

The convenience function can't offer any functionality that a WebBrowser
client couldn't already get in some other way. However, can make client to be
compliation dependent on only what they uses.

// `<webbrowser.h>` for class WebBrowser and core functionality.
namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}

// `<webbrowserbookmarks.h>` for bookmark related convenience functions.
namespace WebBrowserStuff {
  ...
}

// `<webbrowsercookies.h>` for cookies related convenience functions.
namespace WebBrowserStuff {
  ...
}


Partitioning on functionality

Use the same approach but on separated functionality. Like STL, vector, list
and etc are in each header but in the same namespce. Cannot do the same with
class member since a class cannot be split into pieces.


Functional extensibility

When necessary, can extend functionality in the existing namespace by adding
more. This is 'horizental' extension compared with 'vertical', i.e., class
inheritence. 

After all, it's all about encapsulation and seperation. The class is closed or
tightly coupled approach since if it changes, the client will be broken. By
having non-member non-friend in the middle, can have seperation between
classes and client. This is like indirect access or interface class approach.


<namespace-as-module> C++PL 14.3.3
Could give the user's interface and the implementer's interface different
names but (because namespace are open) we don't have to.

    Parser (user interface)
         ^             ^
        /|\           /|\ 
         |        Parser_impl (implementation interface)
         |                 ^
  Driver code             /|\
                        Parser code

// user interface
namespace Parser
{
  double expr(bool);
}

// implementer interface
namespace Parser_impl
{
  using namespace Parser;

  double prim(bool);
  double term(bool);

  using namespace Lexer;
  using Error::error;
  using Table::table;
}


={============================================================================
*kt_dev_cxx_0000* cxx-overload-operator

CPR 552

Operator overloading defines the meaning of an operator applied to operand(s)
of a 'class' type.

  * Overloaded operators are 'functions' with special names
  
  * Overloaded operators has the same number of parameters as the operator has
    operands. unary and binary.

  * Except for overloaded function call operator, overloaded operator must not
    have default arguments.

  * Member operator function has `this` bound to lhs operand. 
  
  * Operator function must either be a member of a class or have at least one
    parameter of class type. Since cannot change operators of built-in types
    and argument dependant lookup for nonmember case.

  * Operator function has the same precedence and associativity as built-in
    operator.

  * Be consitent with use of the built-in types.

  * Four symbols(+, -, *, &) serve as both unary and binary operators. 
  * note: +, - for unary?
  

{cxx-overload-member-or-nonmember}
Whether to implement operator function as either a member or non-member?

// non-member case
data1 + data2;
operator+(data1, data2);

// member case
data1 += data2;
data1.operator+=(data2);

  o For member, the first(lhs) operand is bound to implict `this` 

  o For member, the `lhs` operand must be an object of the class of which that
    operator is a member. 
  
  o 'symmetric' operators - those that might convert either oparand, such as
    arithmetic, equiality, relational, and bitwise operators - usually should
    be nonmember.

    Since use symetric operators with mixed types. For example, can add `int`
    and `double` which can use either type as lhs or rhs operand. To provide
    similar mixed-type expressing involving class object, must be nonmember to
    allow 'conversion' since member fixes ths lhs type.


{cxx-overload-assignment} {operator-compound}
The standalone version of op `must be nonmember` since the literal, "hi!", do
not have member operations.

string u = "hi" + s; 

a = b + 1.0;
a = 1.0 + b;

However, the assignment version, operator+=(), is 'not' symmetric and
commutative. they are different and must be `member`.

data1 += data2;   // data1.operator+=(data2);
data2 += data1;   // data2.operator+=(data1);


note: 
CPR 564. Compound assignment operators are 'not' required to be members. So
"assignment operators 'must', and ordinarily compound assignment operators
'should', be defined as members.


*cxx-remember*
EXPC++20. The operator+= is more efficient since it operates on the `lhs`
directly and returns only a reference, not a temporary object. The standalone
version should be implemented in terms of assignment version.

T& T::operator+=(const T& other)
{
  ...;
  return *this;
}

This must return `const return` and see *cxx-const-return* to prevent this:

const Number operator+( const Number& lhs, const Number& rhs );

Number a, b, c;
a + b = c;

// How to eliminate this cost? Not always possible to shun this. Can use
// operator+= and see MEC++22 for more. Or can use compiler's
// <return-value-optimisation> in MEC++20.

const T operator+(const T& a, const T& b)
{
  T temp(a);
  temp += b;                // `implemented in terms of` +=
  return temp;
}


<cxx-overload-operator-io> cxx-operator-io
it is based on syntax and library requirement.

If IO-op for Sales_data was member, then:

Sales_data data;

data << cout;     // since against to usual syntax of built-in type
cout << data;     // since cannot change the library for any type

*cxx-overload-operator-io* should be non-member


{assign-op}
The assign("="), member access arrow("->"), and call("()") 'must' be a member.

The copy and move assign that assign one object to another object of the 'same'
thye. The assign operator that assign 'other' types as the `rhs`.

<ex>
vector defines the third assign operator that takes a linitializer-list.

vector<string> v;
v = {"a", "an", "the"};

class StrVec {
  public:
    // return referece to its lhs to be consistent with built-in type
    StrVec &operator=(std::initializer_list<std::string>);
};


{input-output}

  * the first parameter of an output operator is reference to `non-const` since
    writing to the stream changes its state.

  * the second parameter should be a reference to `const` since avoids copying
    and printing does not change that object.

  * return its stream parameters for chaining
  
  * implemented in terms of member or virtual member function which do actual
    work.

<<, >> operators 'must' be `non-member` and usually a 'friend' since uses
private members. 

istream &operator>>(istream &is, Sales_data &item);

ostream &operator<<(ostream& os, const Sales_data& item)
{
  os << item.isbn() << " " << item.revenue() << ...;
  return os;
}

<ex>
To have different output for different object? Can use virtual? That means
member func.

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& operator<<( ostream& str ) const;
		...
};

TextBlock t; Graphic g;

t << cout; g << cout;

input, output operators must be non-member but then cannot use virtual. How to
solve?

class NLComponent {
	 public:
	 virtual ostream& print( ostream& os ) const = 0;
	 ...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& print( ostream& os ) const;
};

// used virtual mecanism on the second arg since it is reference.
inline ostream& operator<<( ostream& os, const NLComponent& c )
{ return c.print(os); }


{cxx-operator-overload-equal-and-relational} cxx-operator-less cxx-operator==

note: 
cannot implement it in terms of the other; operator<() cannot be implemented
by return !operator>();

There is a subtle difference between equal and relational(operator <) as to
define 'ordering'.

o Classes for which there is a logical meaning for equality should define
  operator== to use with the library algorithms.

o If defines operator==, should also define operator!=.

o `non-member or member`

<ex> non-member case

bool operator==( const Sales_data *lhs, const Sales_data *rhs )
{
  return lhs.isbn() == rhs.isbn() &&
    lhs.units_sold == rhs.units_sold &&
    lhs.revenue == rhs.revenue;
}

bool operator!=( const Sales_data *lhs, const Sales_data *rhs )
{
  return !(lhs == rhs);
}


As with equal, classes for which the equality operator is defined also often
have relational since associative containers as a key and some algorithms use
the less-than operator.

<consistent-with-equaluty>
Should Sales_data support relational operator when supports euality?

The relational should be consistent in both "strict weak ordering" and "equal".

Suppose there are two Sales_data object which has the same ISBN but different
other members. 

Then operator== treats them 'unequal' but compareIsbn() which is operator< and
is used in ordered container, treats them 'equal' since neither of which is
"less than" the other.

So `the ordering depends on how plan to use the class` For Sales_data class there
is no single logical defintion of < so better not to define < at all.


{subscript} cxx-return-reference
* must be member.
* return a reference to the element that is fetched.
* can be used on either side of an assignment. So it is a good idea to define
  with `const` and `nonconst` version.

class StrVec {
  public:
    std::string& operator[](std::size_t n)
    { return elements[n]; }

    const std::string& operator[](std::size_t n) const
    { return elements[n]; }

  private:
    std::string *elements;
};


See cpp-sp-ex-strblob-example for more.


{cxx-operator-postfix-cxx-overload-operator-postfix} *cxx-prefix-cxx-postfix* 
MEC++06. cxx-postfix can be ineffective when used on user-type.

The prefix form of the increment operator is sometimes called - increment and
fetch, while the postfix form is often known as fetch and increment.

o member
o How distinguish between prefix and postfix form?
o `const UPInt` operator++(int); always use `int` regardless of type to use.
o `the prefix should return a reference`
o the postfix should return the old `value`, not a reference.

class UPInt {                           // "unlimited precision int"
  public:
    `UPInt&` operator++();                // prefix
    `const UPInt` operator++(int);        // `postfix`
    UPInt& operator--();                // prefix
    const UPInt operator--(int);        // `postfix`

    UPInt& operator+=(int);             // a += operator for UPInts and ints
    ...
};

UPInt i;

++i; // calls i.operator++();
i++; // calls i.operator++(0);             // to distinguish with '++i'
--i; // calls i.operator--();
i--; // calls i.operator--(0);

// prefix form: increment and fetch
UPInt& UPInt::operator++()
{
  *this += 1;                   // increment
  return *this;                 // fetch
}

// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
  const UPInt oldValue = *this; // fetch
  ++(*this);                    // increment
  return oldValue;              // return what was fetched
}


*cxx-unused*
The only purpose of the parameter is to 'distinguish' prefix from postfix
function invocation. Many compilers issue warnings if you fail to use named
parameters in the body of the function to which they apply, and this can be
annoying. To avoid such warnings, a common strategy is to omit names for
parameters you don't plan to use; that is what is been done above.

namespace cxx_ctor
{
  class foo
  {
    public:

      explicit foo(int &value) : value_(value) 
    {
      cout << "foo(int)" << endl;
    }

      foo(int &value, int) : value_(value) 
    {
      cout << "foo(int, int)" << endl;
    }

    private:
      int value_;
  };
} // namespace


TEST(Ctor, Unused)
{
  using namespace cxx_ctor;

  int value{10};

  // *cxx-error*
  //
  // cxx_ex.cpp: In member function ‘virtual void Cxx_Ex_Test::TestBody()’:
  // cxx_ex.cpp:42:12: error: no matching function for call to ‘foo::foo(int)’
  //    foo f1(10);
  //             ^
  // cxx_ex.cpp:42:12: note: candidates are:
  // (1)
  // cxx_ex.cpp:27:5: note: foo::foo(int&, int)
  //      foo(int &value, int) : value_(value)
  //      ^
  // cxx_ex.cpp:27:5: note:   candidate expects 2 arguments, 1 provided
  // (2)
  // cxx_ex.cpp:23:14: note: foo::foo(int&)
  //      explicit foo(int &value) : value_(value)
  //               ^
  // cxx_ex.cpp:23:14: note:   no known conversion for argument 1 from ‘int’ to ‘int&’
  // (3)
  // cxx_ex.cpp:19:7: note: constexpr foo::foo(const foo&)
  //  class foo
  //        ^
  // cxx_ex.cpp:19:7: note:   no known conversion for argument 1 from ‘int’ to ‘const foo&’
  // (4)
  // cxx_ex.cpp:19:7: note: constexpr foo::foo(foo&&)
  // cxx_ex.cpp:19:7: note:   no known conversion for argument 1 from ‘int’ to ‘foo&&’
  //
  // foo f1(10);

  foo f1(value);
  foo f2(value, 30);
}


<why-const-in-post-inc> const-return
If you have ever wondered if it makes sense to have functions return const
objects, now you know: sometimes it does as seen above postfix of user type.

If not, it allows this:

UPInt i; i++++;

So to make this behave like premitive type, return const. 

TEST(Operator, PrefixPostfix)
{
  int i = 2;

  i++;
  EXPECT_THAT(i, 3);

  // error: lvalue required as increment operand
  // i++++;

  ++++i;
  EXPECT_THAT(i, 5);
}


<should-prefer-pre-inc-when-use-none-premitive>
The *cxx-prefix* increment function has no such temporaries. This leads to the
possibly startling conclusion that, for efficiency reasons alone, clients of
UPInt should prefer prefix increment to postfix increment unless they really
need the behavior of postfix increment.

When dealing with `user types`, prefix increment should be used whenever
possible, because it is inherently more efficient.

The principle is that postfix increment and decrement should be implemented in
terms of their prefix counterparts. You then need only maintain the prefix
versions, because the postfix versions will automatically behave in a
consistent fashion.

Again, CPR p148 recommends prefix version than postfix because post-inc
increase first and return(yield) the previous copy and it cost extra. May have
no effect for built-in types due to optimization but may be expensive for
`iterators`. 


{cxx-operator-dereference}

As with shared pointer, operator->() makes sense when item is pointer.

multiset<std::shared_ptr<Quote>, comp> items;

for (auto item = items.cbegin(); item != items.cend();
 item = items.upper_bound(*item))
{
 os << (*item)->isbn() << " occurs, " << endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-integer-division

<ex>
// From ansic 1.2., this is a program to implement a formula "C = (5/9)(F-32)"
// to print a table of Fahrenheit and Celsius.
//
// print Fahrenheit-Celsius table

// fah:   0 cel:   0
// fah:  20 cel: -17
// fah:  40 cel:  -6
// fah:  60 cel:   4
// fah:  80 cel:  15
// fah: 100 cel:  26
//
// celsius = 5 * (fahr-32) / 9;      // okay
// celsius = 5/9 * (fahr-32);        // not okay
// 
// Since `integer-division` truncates; any fractional part is discarded so 5/9
// would be trancated to zero.

TEST(IntegerDivision, FahrenheitCelsius)
{
  int fah{}, cel{};
  int low{0}, high{100}, step{20};

  while (fah <= high)
  {
    cout << 
      " fah: " << setw(3) << setfill(' ') << fah << 
      " cel: " << setw(3) << setfill(' ') << cel << endl;
    cel = 5 * (fah-32) / 9;
    fah += step;
  }
}

// "5/9" is still integer division.
// 
// If an arithmetic operator has integer operands, an integer operation is
// performed. If an arithmetic operator has one floating-point operand and one
// integer operand, howerver, the integer will be converted to floating point
// before the operation is done. 
// 
// "while(fhar <= upper)" and "fahr-32" would be converted to floating point.
//
// note: Nevertheless, writing floating-point constants with explicit decimal
// point 'emphasizes' their floating-point nature for human readers.

// fah: 0.000000 cel: 0.000000
// fah: 20.000000 cel: -17.777779
// fah: 40.000000 cel: -6.666667
// fah: 60.000000 cel: 4.444445
// fah: 80.000000 cel: 15.555555
// fah: 100.000000 cel: 26.666666

TEST(IntegerDivision, FahrenheitCelsius_Float)
{
  float fah{}, cel{};
  int high{100}, step{20};

  // no warnings
  while (fah <= high)
  {
    cout << 
      " fah: " << setw(3) << setfill(' ') << fah << 
      " cel: " << setw(3) << setfill(' ') << cel << endl;

    // cel = 5 * (fah-32) / 9;
    // cel = 5/9 * (fah-32);        // not okay
    // cel = 5/9 * (fah-32.0);      // not okay
    
    cel = 5/9.0 * (fah-32);      // okay
    // cel = 5.0/9.0 * (fah-32.0);  // okay

    fah += step;
  }
}


<ex>
// value:  10 perce: 6000
// value:  40 perce: 1500
// value: 100 perce: 600
// value: 200 perce: 300
// value: 250 perce: 200
// value: 356 perce: 100
// value: 450 perce: 100
// value: 600 perce: 100
//
// value:  10 perce:   1
// value:  40 perce:   6
// value: 100 perce:  16
// value: 200 perce:  33
// value: 250 perce:  41
// value: 356 perce:  59
// value: 450 perce:  75
// value: 600 perce: 100
//
// value:  10 perce:   0
// value:  40 perce:   0
// value: 100 perce:   0
// value: 200 perce:   0
// value: 250 perce:   0
// value: 356 perce:   0
// value: 450 perce:   0
// value: 600 perce: 100

TEST(IntegerDivision, Precentage)
{
  int total{600}, perce{};
  vector<int> values{10,40,100,200,250,356,450,600};

  for (auto value : values)
  {
    perce = total / value * 100;
    cout << 
      " value: " << setw(3) << setfill(' ') << value << 
      " perce: " << setw(3) << setfill(' ') << perce << endl;
  }

  for (auto value : values)
  {
    perce = (value * 100)/total;
    cout << 
      " value: " << setw(3) << setfill(' ') << value << 
      " perce: " << setw(3) << setfill(' ') << perce << endl;
  }

  for (auto value : values)
  {
    perce = (value/total)*100;
    cout << 
      " value: " << setw(3) << setfill(' ') << value << 
      " perce: " << setw(3) << setfill(' ') << perce << endl;
  }
}


<ex> *cxx-modulus*

note that:

0 % 3 == 0
1 % 3 == 1
2 % 3 == 2
3 % 3 == 0

X % 1 == 0


// F: 60 > score
// D: 70 >
// C: 80 >
// B: 90 >
// A: 100 >
//
// plus '+' for 8, 9 and '-' for 0,1,2 for each grade

vector<string> grade_scores(const vector<int> scores)
{
  const vector<string> grade_table{"F", "D", "C", "B", "A"};
  vector<string> result;
  string grade{};

  for (auto e : scores)
  {
    if (e < 60)
      result.push_back(grade_table[0]);
    else
    {
      grade.clear();

      int band = (e - 50)/10;
      grade = grade_table[band];

      int plus_or_minus = (e - 50)%10;
      if (plus_or_minus <3)
        grade += "-";
      else if (plus_or_minus > 7)
        grade += "+";

      result.push_back(grade);
    }
  }

  return result;
}

vector<string> grade_scores_model(const vector<int> scores)
{
  const vector<string> grade_table{"F", "D", "C", "B", "A"};
  vector<string> result;
  string grade{};

  for (auto e : scores)
  {
    if (e < 60)
      result.push_back(grade_table[0]);
    else
    {
      grade.clear();

      grade = grade_table[(e - 50)/10];

      int plus_or_minus = e % 10;
      if (plus_or_minus <3)
        grade += "-";
      else if (plus_or_minus > 7)
        grade += "+";

      result.push_back(grade);
    }
  }

  return result;
}

TEST(AlgoGrade, UseTable)
{
    const vector<int> coll{54, 60, 62, 66, 68, 71, 73, 78, 89, 98};
    EXPECT_THAT(grade_scores(coll), 
            ElementsAre("F", "D-", "D-","D", "D+","C-", "C", "C+", "B+", "A+"));

    EXPECT_THAT(grade_scores_model(coll), 
            ElementsAre("F", "D-", "D-","D", "D+","C-", "C", "C+", "B+", "A+"));
}


// CodeComplete 18.4 Stair-Step Access Tables.
//
// A: 90.0% >=
// B: 90.0% <
// C: 75.0% <
// D: 65.0% <
// F: 50.0% <
//
// Suppose scores are floating numbers.

const string grade_stair_step(const double score)
{
  const vector<double> range_limit{50.0, 65.0, 75.0, 90.0, 100.0};
  const vector<string> grade{"F", "D", "C", "B", "A"};

  int max_grade_level = grade.size()-1;
  int grade_level{};
  string student_grade{"A"};

  while ((student_grade == "A") && (grade_level < max_grade_level))
  {
    if (score < range_limit[grade_level])
      student_grade = grade[grade_level];

    ++grade_level;
  }

  return student_grade;
}

TEST(AlgoGrade, UseStairStep)
{
    EXPECT_THAT(grade_stair_step(49.0), "F");
    EXPECT_THAT(grade_stair_step(60.0), "D");
    EXPECT_THAT(grade_stair_step(62.0), "D");
    EXPECT_THAT(grade_stair_step(66.0), "C");
    EXPECT_THAT(grade_stair_step(68.0), "C");
    EXPECT_THAT(grade_stair_step(89.0), "B");
    EXPECT_THAT(grade_stair_step(98.0), "A");
}


<ex>
cause infinitive loop when size_-1 is 1 thinking it would makes 0 or 1 but it
only makes 0.

return rand() % (size_-1);


={============================================================================
*kt_dev_cxx_0000* cxx-type-conversion cxx-explicit

{cxx-type-conversion-builtin}

When an operator has operands of different types, they are converted to a
widest `common-type` to preserve precision.

CPR p159. Happens in expression, func call and func matching

int ival = 3.541 + 3;

Here, two conversion.

o 3 becomes `double` since double is common-type.

o The result of addition becomes `int` since in assignment, the left type
  dominates.

cases:

o integral promotion. promote smaller types to int. when mixed, promote to a
  `bigger type`

o In conditions, nonbool are converted to bool. However, not always possible.
  see below.

o In assignment or initialization, converted to the left or the type of
  variable. Can be 'truncated'.

o common-type for mixed types.

o convert between signed and unsigned.


<truncated-and-undefined> *cxx-undefined*
If the conversion is from a floating-point type to an integer type, the value is
truncated; the fractional part is removed.

signed char sc = 256;   // `out-of-range`. -128...127. `undefined value`
int ival = 3.541 + 3;


<integral-promotion> known as standard conversion
The `integral-promotion` converts the small types(bool, char, short, unsigned
    short) to a larger type(`int`) if all possible values of that type fit in an
int. Otherwise, to unsigned int. 


<when-type-and-signess-different>
Depends on the relative size of the 'integral' type on the machine. When signess
is the same, converted to the bigger type. When signess differ, two cases:

o unsigned >= signed then, the signed is converted to unsigned.

o unsigned < signed then, If all values of unsigned fits in the larger type,
  unsigned operand is conveted to signed. If the values don't fit, the signed
  operand is converted to unsigned. 


<when-same-type-and-signess-different>
unsigned char uc = -1;  // `out-of-range`. 255. See `wrap-around`

Recommends that don't mix between them:

//
unsigned ui = 10; int i = -42;
cout << ui + i << endl;

unsigned int u1 = 42, u2 = 10;
cout << u2 - u1 << endl;

These two cases shows the same result. 4294967264. why? because converted to
`unsigned`.


// infinite loop because u = -1 and means Uxxx_MAX

for( unsigned u = 10; u >= 0; --u )
   cout << n << endl;


// infinite loop due to implicit conversion

unsigned int begi;

for( int i = endi-1; i >= begi; --i )
   cout << line[i];

When begi is 0 and "i >= begi" cause implicit conversion to `unsigned` since it
is comparison between signed and unsigned. note: this is a problem of
string-npos.


<when-use-with-double>

https://www.embeddeduse.com/2016/05/04/is-a-cpp-float-variable-ever-equal-to-0-0f/

TEST(TypeConversion, Double)
{
  // double value: 0
  // double value: 0
  // double value is not < or > 0
  {
    double value{0};
    printf("double value: %g\n", value);
    printf("double value: %u\n", value);

    if (value < 0)
      printf("double value is < 0\n");
    else if (value > 0)
      printf("double value is > 0\n");
    else
      printf("double value is not < or > 0\n");
  }
}

// when runs on ARM platform, evaluated as less than 0

double rtpSkweAdjust;

atr_ulog(kLogLevelNotice, 
    "KT: +rtpSkweAdjust %u \n", inSession->source.rtpSkewAdjust);

if (inSession->source.rtpSkewAdjust > 0)
{
  atr_ulog(kLogLevelNotice, 
      "KT: +rtpSkweAdjust %u > 0 \n", inSession->source.rtpSkewAdjust);
}
else if (inSession->source.rtpSkewAdjust < 0)
{
  atr_ulog(kLogLevelNotice, 
      "KT: +rtpSkweAdjust %u < 0 \n", inSession->source.rtpSkewAdjust);
}
else
{
  atr_ulog(kLogLevelNotice, 
      "KT: +rtpSkweAdjust %u NOT < 0 or > 0\n", inSession->source.rtpSkewAdjust);
}

 KT: +rtpSkweAdjust 0 
 KT: +rtpSkweAdjust 0 < 0 


<ex>
this do not work as expected due to comparison between signed and unsigned.

{
  int majorityElement_1(vector<int>& nums)
  {
    int max_element{};
    std::map<int, size_t> table;

    // first loop to count occurance of the input

    for (auto e : nums)
      ++table[e];

    // second loop to find the most frequent
    // since there is only one max, no need to have two loop like here

    // int current_max{std::numeric_limits<int>::min()};
    size_t current_max{std::numeric_limits<uint32_t>::min()};

    for (auto const &e : table)
    {
      // algo_ex.cpp:4867:23: warning: comparison between signed and unsigned
      // integer expressions [-Wsign-compare]
      //
      // if (current_max < e.second)

      if (current_max < e.second)
      {
        current_max = e.second;
        max_element= e.first;
      }
    }

    return max_element;
  }

} // namespace


<ex> *ex-lower*

ASCII only since uses "offset = a-A" based on that upper case comes first and
lower case comes later in the table. 

int lower(int c)
{
  if( c => 'A' && c <= 'Z' )
    return 'a' + (c - 'A');   // clearer?
    return c + 'a' - 'A';     // c -'A' + 'a' or c + 'A' - 'a' ?
  else
    return c;
}


<ex> *ex-interview*

Amazon phone interview. Explain a problem to print money value to string such as
ONE HUNDRED AND FOURTY FIVE PENCE for $100.45. This simplifies handling of
fractional part and can get it by x100. The rest is string process.

int main()
{
  float fval = 100.45;
  int decimal = fval;
  int fraction = (fval - decimal)*100;

  cout << "float   : " << fval << endl;
  cout << "decimal : " << decimal << endl;
  cout << "fraction: " << fraction << endl;
}

float   : 100.45
decimal : 100
fraction: 44


{cxx-type-conversion-class}
cxx-convertsion-ctor and cxx-conversion-op are `class-type-conversions.`

<ex>
EXC++39 says that avoid converison operators and non-explicit ctors.

string s1, s2, s3;
s1 = s2 - s3;           // oops, probably menat "+"

*cxx-ctor-converting* is every ctor with `single` argument and do `implicit`
conversion from arg type to that class type and conversion-op is opposite.

class T {       <- from other type to T   cxx-ctor-conversion
   ...          -> from T to other types  cxx-conversion-op
};


class Sale_data {

   combine(const Sales_data&);
   Sales_data(const std::string &s);
   Sales_data(std::istream &);

};

string null_book;

item.combine(null_book);

The combine() expect 'Sales_date' type but it is given a string. How can make
it work? The compiler do `implicit cxx-type-conversion` to make a call succeed
and creates a `cxx-temporary` Sales_data object. So this equates to:

item.combine(Sales_data(str));

<ex> *cxx-default-argument*
Since the second parameter has a default value, this can be used as a single
parameter ctor and, hence, as an implicit conversion. Make it explicit!

Complex (double real, double imaginary = 0)
  : real_(real), imaginary_(imaginary)
{}


*cxx-remember* <only-one-conversion-allowed>
The compiler will do only `one implicit conversion` and the following is error.

item.combine("9-999-99999-9");

Since this requires two conversion to make it succeed.

item.combine(string("9-999-99999-9"));
item.combine(Sales_data("9-999-99999-9"));


{cxx-explicit-keyword}
Whether the conversion is desiable depends on "how users wil use the
conversion." More problematic is the conversion from istream to Sales_data.
When combine() finishes, temporary is gone and lost input. 

item.combine(cin);

To avoid this, can use cxx-explicit:

class Sales_data {

  `explicit` Sales_data(const std::string &s): bookNo(s) {};
  `explicit` Sales_data(std::istream &s);
  combine(const Sales_data&);

};

Now have to use ctor `explicitly`:

item.combine(null_book);                      // error
item.combine(cin);                            // error

item.combine(Sales_data(null_book));          // T(x)
item.combine(static_cast<Sales_data>(cin));

NOTE:
this means that *cxx-explicit* is only useful for *cxx-ctor-conversion* which
has single arguments *cxx-conversion-op*

: error: only declarations of constructors and conversion operators can be ‘explicit’
virtual explicit void operator()(const std::string &, const std::string &) {}


{implicit-conversion-problems}
Avoid implicit conversion. From MEC++05. Recommend to use a member func to do
the same.

<ex>
template< typename T>
class Array {
  public:
    Array(int lowBound, int highBound);
    Array(int size);
    ...
};

bool operator==(const Array<int> &lhs, const Array<int> &rhs);

Array<int> a(10); Array<int> b(10);

for( int i=0; i < 10; ++i )
  if( a == b[i] ) {                 // meant to be a[i] == b[i]
    ...
  }
  else {
    ...
  }

There is no match candidate, operator==( Array<int>, int ), and compiler do
convert the second arg to Array because there is converting-ctor. This is the
same as:

if( a == static_cast< Array<int>> (b[i]) )

This causes a creation and deletion of unknowm number of Array objects for
each iteration. How to prevent this?

  *cpp-remember*
  `The implicit conversion is not always useful since temporary is made.` More
  expensive, lost state(input), or making changes on temporary. So the point
  is about making it explicit in code and
  `forcing-user-to-know-what-they-are-doing`.


// Q: CPR 297
// the string ctor that takes a single parameter of type const char * is not
// explicit.
//
// <ex>
// EXPC++39. The std-string has no implicit conversion to a const char*. Should it?
// If it had that conversion, this code would compile cleanly because the compiler
// would silently convert both strings to const char* and then substract those
// pointers.
//
// string s1, s2, s3;
// s1 = s2 - s3;           // oops, probably meant "+"


<ex-of-explicit>
The vector<T> v(number) is explicit so the following is in error.

explicit container::container (size_type num)
- Creates a container with num elements.
- The elements are created by their default constructor.
- Provided by vector, deque, list, forward list.

// x.member(vector<string>& vec);
x.member(10);  // error


<cpp-copy-init>
`copy-init` only uses `converting-ctor` which uses `implicit-conversion` to make a
call succeed but not `copy-ctor`. So if use `explicit` converting-ctor then
cannot use `copy-init` and must use `direct-init`

*cpp-remember* prefer direct-init to copy-init.


explicit Sales_data(const std::string &s): bookNo(s) {};

Sales_data item(null_book);     // okay, `direct-init`
Sales_data item = null_book;    // error, `copy-init`

note:
* The explicit-keyword supress conversion or use of constructor in a context
  that requires an implicit conversion.

  *why-direct-init* CPR 296
* The explicit ctor can be used `only with direct-init`
  
  Because direct-init explicitly say to initialize so that's why it is okay
  for use explicit ctor
    
* The explicit-keyword is meaningful 'only' on constructors that can be called
  with a `single-arguments` since constructors with more arguments are not
  used to perform an implicit conversion.
  
  note:
  EXPC++42. Prefer using `direct-form-init` to `copy-form-init` since works
  wherever the latter works and can take multiple parameters.

* The explicit-keyword is used only in constructor declaration inside a
  class.

o The `cxx-copy-ctor` cannot use `cxx-explicit` since used implicitly in cases
  as pass by value such as *cxx-return* 

  <ex> cxx-error when use explicit on cxx-copy-ctor
  
  explicit DBusConnection(const DBusConnection &);
  explicit DBusConnection(DBusConnection &&);

  DBusConnection DBusConnection::systemBus(const EventLoop &eventloop)
  {
    // error: no matching function for call to 
    // ‘DBusConnection::DBusConnection(DBusConnection)’
  
    return DBusConnection(nullptr);
  }


<ex>

class Base {
  public:
    explicit Base(const string &s) : mesg(s) {}
    // Base(const string &s) : mesg(s) {}

    void message( const Base & b ) 
    { 
      cout << "base: " << b.mesg << endl;
      cout << "base: " << mesg << endl; 
    }

  private:
    string mesg;
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base ba(string("iam base"));
  Base baa = string("iam base two");            // 1

  ba.message(string("this is mesg for base"));  // 2

  std::cout << "--} main " << std::endl;
}

When use `explicit-keyword`, two errors:

: error: conversion from ‘std::string {aka std::basic_string<char>}’ to
non-scalar type ‘Base’ requested

: error: no matching function for call to ‘Base::message(std::string)’
: note: candidate is:
: note: void Base::message(const Base&)
: note:   no known conversion for argument 1 from ‘std::string {aka
  std::basic_string<char>}’ to ‘const Base&’

  *cpp-remember*
  After all, explicit-keyword surpress implicit-converson and effect is
  that cannot use copy-init.


*cxx-conversion-op* cxx-operator-conversion
The conversion-op is a conversion from class type `to other type.` Have no
explicitly stated return type and no parameters. Must be member.

operator T() const;     where T represents `type`

class SamallInt {
  public:
    operator int() const { return val;}

  private:
    std::size_t val;
};

SmallInt si;

si = 4;   // implicitly converts 4 to SmallInt then calls operator=
si + 3;   // implicitly converts si to int then do integer addition


note:
Although the compiler will apply only one user-defined conversion at a time,
         implicit user-defined conversion can be preceded or followed by a
         standard(built-in) conversion.

// the `double` converted to `int` and calls SmallInt(int) ctor.

SmallInt si = 3.14;

*cxx-remember*
To avoid following problem, use *cxx-explicit*

class SamallInt {
  public:
    `explicit` operator int() const { return val;}
};

int i = 42;
cin << 42;

There is no operator<< in cin but could use conversion-to-bool to convert `cin`
to bool. So 0 or 1 depending on the cin state, promoted to int and used as the
lhs to the left shift operator.

0 or 1 << 42;

<ex>

// 11.4 The for_each() Algorithm
// A third example demonstrates how to use the return value of the for_each()
// algorithm. Because for_each() has the special property that it returns its
// operation, you can process and return a result inside the operation:
//
// note that this is not predicate since it has its state.

namespace algo_for_each {
  class MeanValue {
    public:
      MeanValue(): num_(0), sum_(0) {}

      void operator()(int elem) {
        num_++;
        sum_ += elem;
      }

      operator double() {
        return static_cast<double>(sum_)/num_;
      }

    private:
      long num_;
      long sum_;
  };
}

TEST(AlgoForEach, GetMean)
{
  using namespace algo_for_each;

  vector<int> coll{1,2,3,4,5,6,7,8};

  double mean = for_each(coll.begin(), coll.end(),
      MeanValue());

  EXPECT_THAT(mean, DoubleEq(4.5));
}


={============================================================================
*kt_dev_cxx_0000* cxx-temporary

EXC++06, 07

string FindAddr( list<Employee> emps, string name )
{
  for( list<Employee>::iterator i = emps.begin();
      i != emps.end();
      i++ )
  {
    // *cxx-type-conversion*
    if( *i == name )
    {
      return i->addr;
    }
  }
  return "";
}

string FindAddr( const list<Employee> &emps, const string &name )
{
  list<Employee>::const_iterator end( emps.end() );
  for( list<Employee>::const_iterator i = emps.begin();
      i != end;
      ++i )
  {
    if( i->name == name )
    {
      return i->addr;
    }
  }
  return "";
}

// have to provide operator==(const Employee&, const string &)
string FindAddr( const list<Employee> &emps, const string &name )
{
  list<Employee>::const_iterator i(
      find( emps.begin(), emps.end(), name));

  if( i != emps.end() )
  {
    return i->addr;
  }
  return "";
}



{cxx-temporary} MEC++19 *cxx-type-conversion*
The temporary is used in implicit type conversion, non-const-to-const, func
call, casting and return. Can have an impact on the performance in
construction and destruction.

<ex> *cxx-return*
Return the plural version of the word if the counter is greater than 1.

string make_plural( size_t ctr, const string& word, const string& ending)
{
  return (ctr>1) ? word + ending : word;
}

The word is copied to the call(ing) site or unnamed string temporary is copied
to the call site for 'word + ending' case.

<ex>
Here `return explicitly constructed temporary`, 'pair<string, int>' is T.
That is T() and so is default constructed and value-init.

See {return-reference-vs-copy} for interesting case. So whether or not there
is a temp object created in called site, there is a copy to call site when a
func is defined to return a copy.

pair<string, int> process( vector< string > v )
{
  if( !v.empty())
   return {v.back(), v.back().size() };
   // or return pair<string, int>( v.back(), v.back().size() );
  else
    return pair<string, int>();
}

<ex>
const char* PersonInfo::theName() const;

virtual std::string name() const
{ return PersonInfo::theName(); }


<cxx-temporary-in-type-converison> *cxx-type-conversion*

size_t countChar( const string& str, char ch );    // see *cxx-const*

char buffer[MAX_STRING_LEN];

countChar( buffer, c ); // string str = string temp-object(buffer);

When it is called, there is a type mismatch so string temp object will be
created, buffer is copied, and binding to argument happens. Destruction
happens when return. If buffer size is big, then it is costly. It is for
compiler to make a func call succeed.

if remove const from the above:

size_t countChar( string& str, char ch );    // see no const here

Then gets *cxx-const-to-nonconst-error*

: error: invalid initialisation of non-const reference of type ‘std::string&
{aka std::basic_string<char>&}’ from an rvalue of type ‘char*’

since basic_string(const char*) is not explicit and cause implicit conversion
which creates temporary; temporary is const and rvalue and const-to-nonconst
is not allowed.


{cxx-temporary-is-const}
WHY? In any case, compiler will create temporary due to type mismatch and if
temporary was not const (means mutable or can change this) then make a changes
to temporary. Not expected result.

reference-to-const parameters don't suffer from this problem, because such
parameters, by virtue of being const, can't be changed.

How to eliminate this?

1. No implicit conversion
make *cxx-ctor-converting-ctor* explit or do not provide them. 

2. MEC++21


<ex> *cxx-iter* *cxx-next*

9.2.6 The Increment and Decrement Problem of Vector Iterators

For arrays, vectors, and strings, this might not compile on some platforms.

std::vector<int> coll;

// sort, starting with the second element - NONPORTABLE version

if (coll.size() > 1) {
  std::sort(++coll.begin(), coll.end());
}

Depending on the platform, the compilation of ++coll.begin() might fail.
However, if you use, for example, a deque rather than a vector, the
compilation always succeeds.

The reason for this strange problem lies in the fact that iterators of
vectors, arrays, and strings might be implemented as ordinary pointers. 

*cxx-temporary*
And for all fundamental data types, such as pointers, 
`you are not allowed to modify temporary values.` 

For structures and classes, however, doing so is allowed. Thus, if the
iterator is implemented as an ordinary pointer, the compilation fails; if
implemented as a class, it succeeds.


Why needs next()? So next() returns increased temp value.

int ReturnInteger()
{
  int value{3301};
  return value;
}

struct StructValue
{
  int value_;

  StructValue(int value): value_(value) {}

  int operator++() { return ++value_; }
};

StructValue ReturnStruct()
{
  StructValue value{3301};
  return value;
}

TEST(Iterator, NativeAndStructTemporary) 
{
  // show that not allowed to modify tempory

  // cxx.cpp: In member function ‘virtual void Temporary_NativeAndStruct_Test::TestBody()’:
  // cxx.cpp:1539:45: error: lvalue required as increment operand
  //    cout << "return int: " << ++ReturnInteger() << endl;
  // cout << "return int: " << ++ReturnInteger() << endl;
  
  EXPECT_THAT(++ReturnStruct(), 3302);
}

TEST(Iterator, OperationOnTemporary)
{
  {
    vector<int> coll{4,2,6,3,1,5};
    sort(++coll.begin(), coll.end());
    EXPECT_THAT(coll, ElementsAre(4,1,2,3,5,6));
  }
  {
    string coll{"this is a string object"};
    sort(++coll.begin(), coll.end());
    EXPECT_THAT(coll, Eq("t    abceghiiijnorssstt"));
  }
}

GCC 630 shows no errors and no applicable.


TEST(Iterator, Next)
{
  {
    vector<int> coll{1,2,3,4,5};
    auto pos = coll.begin();
    EXPECT_EQ(*pos, 1);

    ++pos;
    EXPECT_EQ(*pos, 2);

    // since next() uses copy, do not change input iterator

    auto next_pos = next(pos);
    EXPECT_EQ(*pos, 2);
    EXPECT_EQ(*next_pos, 3);
  }

  // 9.3.2 next() and prev()
  // Note that next() does not check whether it crosses the end() of a sequence.
  // Thus, it is up to the caller to ensure that the result is valid.
  {
    vector<int> coll{1,2,3,4,5};
    vector<int> result{};

    for(auto pos = coll.begin(); pos != coll.end(); pos = next(pos))
      result.push_back(*pos);

    EXPECT_THAT(coll, result);
  }

  // what would happen when call next() on empty? cxx-undefined
  //
  // /usr/include/c++/4.9/debug/safe_iterator.h:356:error: attempt to advance a
  //     past-the-end iterator 1 steps, which falls outside its valid range.

  {
    vector<int> coll{};
    auto pos = coll.begin();
    auto result = next(pos);
  }
}


<in-casting> from ansic, p45.
The cast produces the 'value' of n in the proper type; n itself is not altered. 

squrt( (double)n );

item.combine( static_cast<Sales_data>(str) );


={============================================================================
*kt_dev_cxx_0000* cxx-return-rvo cxx-rvo

https://shaharmike.com/cpp/rvo/

namespace cxx_rvo
{
  // Note: All methods have side effects
  struct Snitch
  {
    Snitch(int value)
        : value_(value)
    {
      cout << "c'tor" << endl;
    }
    ~Snitch() { cout << "d'tor" << endl; }

    Snitch(const Snitch &) { cout << "copy c'tor" << endl; }
    Snitch(Snitch &&) { cout << "move c'tor" << endl; }

    Snitch &operator=(const Snitch &)
    {
      cout << "copy assignment" << endl;
      return *this;
    }

    Snitch &operator=(Snitch &&)
    {
      cout << "move assignment" << endl;
      return *this;
    }

    int getValue() const { return value_; }

  private:
    int value_{0};
  };

  Snitch ExampleRVO()
  {
    std::cout << "in ExampleRVO: " << std::endl;
    return Snitch(100);
  }

  std::vector<Snitch> ReturnVector()
  {
    // vector<Snitch> ivec(1000000000, 1);
    // vector(n, elem); creates n elements
    std::vector<Snitch> coll(10, Snitch(200));
    cout << "in ReturnVector: size of vector: " << coll.size() << endl;
    return coll;
  }

  Snitch createSnitch() { return Snitch(200); }

  void foo(Snitch s) { cout << "snitch value is: " << s.getValue() << endl; }

} // namespace cxx_rvo

// [ RUN      ] CxxRVO.check_single_construction
// in ExampleRVO:
// c'tor
// d'tor
// [       OK ] CxxRVO.check_single_construction (0 ms)

TEST(CxxRVO, check_single_construction)
{
  using namespace cxx_rvo;

  Snitch snitch = ExampleRVO();
}

// [ RUN      ] CxxRVO.check_copy_to_vector
// c'tor
// copy c'tor   // 0
// copy c'tor
// copy c'tor
// copy c'tor
// copy c'tor
// copy c'tor
// copy c'tor
// copy c'tor
// copy c'tor
// copy c'tor   // 9
// d'tor
// in ReturnVector: size of vector: 10
// d'tor
// d'tor
// d'tor
// d'tor
// d'tor
// d'tor
// d'tor
// d'tor
// d'tor
// d'tor
// [       OK ] CxxRVO.check_copy_to_vector (0 ms)

TEST(CxxRVO, check_copy_to_vector)
{
  using namespace cxx_rvo;

  std::vector<Snitch> coll = ReturnVector();

  cout << "return from ReturnVector: size of vector: " << coll.size() << endl;
}

// [ RUN      ] CxxRVO.check_argument
// c'tor
// snitch value is: 200
// d'tor
// [       OK ] CxxRVO.check_argument (0 ms)

TEST(CxxRVO, check_argument)
{
  using namespace cxx_rvo;

  foo(Snitch(200));
}

// [ RUN      ] CxxRVO.check_assignment
// c'tor
// ----------
// c'tor
// move assignment
// d'tor
// d'tor
// [       OK ] CxxRVO.check_assignment (0 ms)

TEST(CxxRVO, check_assignment)
{
  using namespace cxx_rvo;

  // ctor
  Snitch s = createSnitch();
  cout << "----------" << endl;

  // assign
  s = createSnitch();
}

// [ RUN      ] CxxRVO.check_when_rvo_on
// c'tor
// d'tor
// [       OK ] CxxRVO.check_when_rvo_on (0 ms)
// [ RUN      ] CxxRVO.check_when_rvo_off
// c'tor
// c'tor
// move c'tor
// d'tor
// d'tor
// d'tor
// [       OK ] CxxRVO.check_when_rvo_off (0 ms)

namespace cxx_rvo
{
  Snitch createSnitch2(bool runtime_condition)
  {
    Snitch a(100), b(100);
    if (runtime_condition)
    {
      return a;
    }
    else
    {
      return b;
    }
  }
} // namespace cxx_rvo

TEST(CxxRVO, check_when_rvo_on)
{
  using namespace cxx_rvo;

  // ctor
  Snitch s = createSnitch();
}

TEST(CxxRVO, check_when_rvo_off)
{
  using namespace cxx_rvo;

  // ctor
  Snitch s = createSnitch2(true);
}


Return Value Optimization (RVO), Named RVO (NRVO) and Copy-Elision are in C++
since C++98. In this post I will explain what these concepts mean and how they
help improve runtime performance.


Return Value Optimization

RVO basically means the compiler is allowed `to avoid creating temporary`
objects `for return values`, even if they have side effects.

Here’s a simple example:

Snitch ExampleRVO() {
  return Snitch();
}

int main() {
  Snitch snitch = ExampleRVO();
}

// when cxx-rvo is on
$ clang++ -std=c++11 main.cpp && ./a.out
c'tor
d'tor


As *cxx-return-cxx-move* shows, it uses *cxx-move* context in return but that's
not even needed since *cxx-rvo* do not use move context at all and cxx-rvo is
default.

elide: to not pronounce a particular sound in a word:


$ clang++ -std=c++11 -fno-elide-constructors main.cpp && ./a.out
c'tor
move c'tor
d'tor
move c'tor
d'tor
d'tor

*cxx-side-effect*
In the first run (`without -fno-elide-constructors`) which means rvo is on, the
compiler refrained from calling code `despite it having a clear side effect` 
(being printing to console in ctor). 


<rvo-is-default>
This is also the default behavior, meaning practically all C++ programs
utilize RVO.


Without RVO the compiler creates 3 Snitch objects instead of 1:

Snitch ExampleRVO() {
  return Snitch();
}

o A temporary object inside ExampleRVO() (when printing c'tor);

o A temporary object for the returned object inside main() (when printing the
  first move c'tor);

o The named object snitch (when printing the second move c'tor).


Performance

The neat thing about RVO is that `it makes returning objects free.` It works via
allocating memory for the to-be-returned object `in the caller’s stack frame.`
The returning function then uses that memory as if it was in its own frame
without the programmer knowing / caring.

In C++98 days this was significant:

#include <vector>
using namespace std;

vector<int> ReturnVector() {
  return vector<int>(1, 1);
}

int main() {
  for (int i = 0; i < 1000000000; ++i) {
    ReturnVector();
  }
}

// off RVO
$ clang++ -fno-elide-constructors -std=c++98 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m37.235s
user	0m37.168s
sys	0m0.024s

$ clang++ -std=c++98 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m17.681s
user	0m17.668s
sys	0m0.000s

217% difference on my machine by simply avoiding the copy of the vector. In
C++11 (or newer) environments it is even marginally faster to disable RVO:

// off RVO
$ clang++ -fno-elide-constructors -std=c++11 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m18.195s
user	0m18.188s
sys	0m0.000s

$ clang++ -std=c++11 -stdlib=libc++ -O3 main.cpp && time ./a.out
real	0m18.356s
user	0m18.340s
sys	0m0.000s

This is due to Move Semantics, which is the subject of the next post.

<ex> gcc-ex

https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#index-fno-elide-constructors

elide: to not pronounce a particular sound in a word:

3.5 Options Controlling C++ Dialect
 
-fno-elide-constructors

The C++ standard allows an implementation to omit creating a temporary that is
only used to initialize another object of the same type. Specifying this option
disables that optimization, and forces G++ to call the copy constructor in all
cases. This option also causes G++ to call trivial member functions which
otherwise would be expanded inline.
 
In C++17, the compiler is required to omit these temporaries, but this option
still affects trivial member functions.

$ g++ main.cpp && ./a.out
main before
in ExampleRVO:
c'tor
main after
d'tor

$ g++ -fno-elide-constructors main.cpp && ./a.out
main before
in ExampleRVO:
c'tor
move c'tor
d'tor
move c'tor
d'tor
main after
d'tor


$ time ./on-evo.out
c'tor
d'tor
end of main

real    2m46.195s
user    2m42.556s
sys     0m0.292s


$ time ./no-evo.out
c'tor
move c'tor
d'tor
move c'tor
d'tor
d'tor
end of main

real    4m27.133s
user    4m24.960s
sys     0m0.368s


In trying to come up with an example where RVO is faster on modern C++ using STL
containers I hit a wall, mostly because of move-semantics but also because on
x86_84 RVO is in the ABI so disabling it is harder. Please post such examples if
you have any!


Named Return Value Optimization (NRVO)

Named RVO is when an object with a name is returned but is nevertheless not
copied. A simple example is:

Snitch ExampleNRVO() {
  Snitch snitch;
  return snitch;
}

int main() {
  ExampleNRVO();
}

Which has a similar output to ExampleRVO() above:

$ clang++ -std=c++11 main.cpp && ./a.out
c'tor
d'tor

While RVO is almost always going to happen, NRVO is more restricted, as we
will see below. I personally don’t think NRVO deserves its own acronym.


Copy Elision

RVO is part of a larger group of optimizations called copy-elision. Essentials
are the same, except copy-elision is not required to happen as part of return
statements, for example:

void foo(Snitch s) {
}

int main() {
  foo(Snitch());
}

c'tor
d'tor

In my experience, RVO is more frequent (and thus useful) than other
copy-elision practices, but your mileage may vary.


void foo(Snitch s) {
    cout << "snitch value is: " << s.getValue() << endl;
}

TEST(CxxFeaturesTest, UseCopyElison)
{
    cout << "----------" << endl;
    foo(Snitch(200));
    cout << "----------" << endl;
}

// with -fno-
----------
c'tor
move c'tor
snitch value is: 0
d'tor
d'tor
----------

// without -fno-
----------
c'tor
snitch value is: 200
d'tor
----------


*cxx-rvo-when-off*

When RVO doesn’t / can’t happen

RVO is an optimization the compiler is allowed to apply (starting C++17 it is
    in fact required to in certain cases). However, even in C++17 it is not
always guaranteed. Let’s look at a few examples.

The following examples are cases where, on my environment, RVO doesn’t happen.
Some of them may change with other compiler / versions.


Deciding on Instance at Runtime

When the compiler can’t know from within the function which instance will be
returned it must disable RVO:

Snitch CreateSnitch(bool runtime_condition) {
  Snitch a, b;
  if (runtime_condition) {
    return a;
  } else {
    return b;
  }
}

int main() {
  Snitch snitch = CreateSnitch(true);
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
c'tor
move c'tor
d'tor
d'tor
d'tor


Returning a Parameter / Global

When returning an object that is not created in the scope of the function
there is no way to do RVO:

Snitch global_snitch;

Snitch ReturnParameter(Snitch snitch) {
  return snitch;
}

Snitch ReturnGlobal() {
  return global_snitch;
}

int main() {
  Snitch snitch = ReturnParameter(global_snitch);
  Snitch snitch2 = ReturnGlobal();
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
copy c'tor
move c'tor
d'tor
copy c'tor
d'tor
d'tor
d'tor


Returning by std::move()

Returning by calling std::move() on the return value is an anti-pattern. It is
wrong most of the times. It will indeed attempt to force move-constructor, but
in doing so it will disable RVO. It is also redundant, as move will happen if
it can even without explicitly calling std::move() (see here).

TODO
https://stackoverflow.com/questions/14856344/when-should-stdmove-be-used-on-a-function-return-value

Snitch CreateSnitch() {
  Snitch snitch;
  return std::move(snitch);
}

int main() {
  Snitch snitch = CreateSnitch();
}
Output:

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
move c'tor
d'tor
d'tor


Assignment

RVO can only happen when an object is created from a returned value. Using
operator= on an existing object rather than copy/move constructor might be
mistakenly thought of as RVO, but it isn’t:

Snitch CreateSnitch() {
  return Snitch();
}

int main() {
  Snitch s = CreateSnitch();
  s = CreateSnitch();
}

// with -fno-
$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
--- where it is not rvo
c'tor
move assignment
d'tor
---
d'tor


Returning Member

In some cases even an unnamed variable can’t RVO:

struct Wrapper {
  Snitch snitch;
};

Snitch foo() {
  return Wrapper().snitch;
}

int main() {
  Snitch s = foo();
}

$ clang++ -std=c++11 -stdlib=libc++ main.cpp && ./a.out
c'tor
move c'tor
d'tor
d'tor


Conclusion

While we can’t count on RVO to always take place, it will in most cases. For
`those cases where it doesn’t we always have Move Semantics,` which is the
topic of the next post. As always, optimize for readability rather than
performance when writing code, unless you have a quantifiable reason.


TODO: *C++17*
https://jonasdevlieghere.com/guaranteed-copy-elision/

<ex>
std::vector<std::string> return_vector(const std::string &input)
{
    std::vector<std::string> svec{};

    for(int i = 0; i < 10; ++i)
    {
        svec.push_back(input);
    }

    return svec;
}

int main()
{
    auto rvec = return_vector("string vector");
}

// modified to print vector copy and move ctor in stl_vector.h
kyoupark@kit-debian64:~/works$ g++ -std=c++11 xxx.cpp 
kyoupark@kit-debian64:~/works$ ./a.out    // nothing printed
kyoupark@kit-debian64:~/works$ g++ -std=c++11 -fno-elide-constructors xxx.cpp 
kyoupark@kit-debian64:~/works$ ./a.out 
kit:vector move ctor          
kit:vector move ctor


={============================================================================
*kt_dev_cxx_0000* cxx-return cxx-undefined

{cxx-return-what-should-return} {cxx-reference-return-by-value} EC++21
The `pass-by-reference` is great so always use reference? 

note: *cxx-overload-operator*
How distinguish between two multiply and dereferene?

// dereferene operator, member
T& operator*() { return *ptr_; }
    
// multiply operator, nonmmber
friend const T operator*( const T &lhs, const T &rhs );


These are tries to save a construction cost by using pass-by-reference. 
Not quite right.

<1> 
Use stack but remember a refenrece is a name for some 'existing' object. Here
returns a reference to object that no longer exist.

Rational c = a*b;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational retult( lhs.n*rhs.n, lhs.d*rhs.d );
    return result;
  }
};


<2> 
Use heap but there is no way to delete in case: 

Rational w, x, y, z;
w = x*y*z;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational *retult = new Rational( lhs.n*rhs.n, lhs.d*rhs.d );
    return *result;
  }
};


<3> 
Use function static? Not right for multi-threaded and even for
single-threaded.

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    static Rational retult;
    ...
    return result;
  }

  bool operator==( const Rational& lhs, const Rational& rhs);
};

Rational a, b, c, d;

if( (a*b) == (c*d) )
{
  ...
}

This will always true since it is evaluated as

if( operator==( operator*(a,b), operator*(c,d) ) )

*cxx-remember*
Therefore, should return a copy and pay a small cost for correct behavior and
usually no cost due to *cxx-rvo* 

There are cases that must return a copy not a reference such as operator*().
This is a operator to multiply not to dereferene.


class Rational {
  friend const Rational operator*( const Rational& lhs, const Rational& rhs );
  ...
};

*cxx-remember* C++PL 191
To keep a program readable, it is often best to avoid functions that modify
their arguments. Instead, you can return a value from the function explicitly:

void increment(int &aa) { ++aa; }
int next(int p) { return p+1; }

void g()
{
  int x = 1;
  increment(x);   // x = 2
  x = next(x);    // x = 3
}

The increment(x) notation doesn't give a clue to the reader that x's value is
being modified, the way x = next(x) does. Consequently, "plain" reference
arguments should be used `only where` the name of the function gives a strong
hint that the reference argument is modified.


{cxx-return-no-reference-to-internals}

CCG F.43: Never (directly or indirectly) return a pointer or a reference to a
local object

EC++28, avoid returning handles to object internals

Here internals means everything except public interface and includes private
and protected member function. If returns handles (iterator, pointer and
    reference) to internals, causes three problems: breaks encapsulatation,
constness, and dangling-handles.


<compromising-encapsulation-and-constness>
The pass by reference is more efficient than pass by value and the interface
offer client a way to learn what rectangle's points are:

class Rectangle {
  public:
    Point& upperLeft() const { return pData->ulhc; }

  private:
    std::shared_ptr<RectData> pData;
};

Is it okay? NO because client can change its value:

// use
const Rectangle rec( ... );
rec.upperLeft().setX(50);

The problem is that makes memeber data effectively public as returns reference
to it from a public member function since this is *cxx-const-bitwise*


The solution is that it offers read-only access:

class Rectangle {
  public: >
   `const` Point& upperLeft() const { return pData->ulhc; }

  private:
   std::shared_ptr<RectData> pData;
};

Similar to the example of {const-member-func}

<ex>
using namespace std;

class Sample {
  private:
    int val;

  public:
    Sample() : val(10) {}
    int& getx() { return val;}
    void printx() { cout << val << endl; }
};

int _tmain(int argc, _TCHAR* argv[])
{
  Sample sam;
  cout << "------" << endl;
  sam.printx();
  sam.getx() = 20;
  cout << "------" << endl;
  sam.printx();

  return 0;
}

This changes private member val to 20.


<dangling-handles>
class GUIObject { ... }
const Rectangle boundingBox( const GUIObject& obj );

// use
GUIObject* pgo;
...
const Point* pUpperLeft = &( boundingBox(*pgo).upperLeft() );

This returns a temporary Rectangle and returns its upper member. The problem
is this temporary is destroyed when this statement ends and pUpperLeft will
dangle even if const use.

vector and string's [] operator returns reference but these are exceptions to
this rule, but not a general rule. Better not use [] operator.


{cxx-return-cxx-temporary}

The function returns value

std::string YVCloudAuth::getAuthToken() const;

and here defines a reference to use return value so takes a reference to a
temporary.

try
{
  `const std::string&` token = cloudAuth->getAuthToken();
  Header.replace("<add-youview-token>", token.c_str());
}

You're taking a reference to a temporary object

That's allowed.

exactly, this const reference binds to this *cxx-rvalue* extending it's lifetime
for the lifetime of the reference itself. But in practice it's like giving a
temp an alias. see below for a nice explanation


http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/

GotW #88: A Candidate For the "Most Important const"

Q1: Is the following code legal C++?

    // Example 1

    string f() { return "abc"; }

    void g() {
      `const string&` s = f();
      cout << s << endl;    // can we still use the "temporary" object?
    }


A1: Yes.

This is a C++ feature. the code is valid and does exactly what it appears to
do.

Normally, a temporary object lasts only until the end of the full expression
in which it appears. 

However, C++ deliberately specifies that binding a temporary object to a
reference to const on the stack `lengthens the lifetime of the temporary` to
the lifetime of the reference itself, and thus avoids what would otherwise be
a common dangling-reference error. 

In the example above, the temporary returned by f() lives until the closing
curly brace. 

Note `this only applies to stack-based references.` It doesn't work for
references that are members of objects.

Q2: What if we take out the const. is Example 2 still legal C++?

    // Example 2

    string f() { return "abc"; }

    void g() {
      string& s = f();       // still legal?
      cout << s << endl;
    }

A2: No.

`The "const &" is important.` The first line is an error and the code won't
compile portably with this reference to non-const, because f() returns a
temporary object (i.e., `rvalue`) and only lvalues can be bound to references
to non-const.

*cxx-const-to-non-const-error*
:19:21: error: invalid initialization of non-const reference of type 
  ‘std::string& {aka std::basic_string<char>&}’ 
  from an `rvalue` of type ‘std::string {aka std::basic_string<char>}’

Note: Visual C++ does allow Example 2 but emits a "nonstandard extension used"
warning by default. A conforming C++ compiler can always allow
otherwise-illegal C++ code to compile and give it some meaning — hey, it could
choose to allow inline COBOL if some kooky compiler writer was willing to
implement that extension, maybe after a few too many Tequilas. For some kinds
of extensions the C++ standard requires that the compiler at least emit some
diagnostic to say that the code isn’t valid ISO C++, as this compiler does.

Note: gcc 4.7.2 and see *cxx-rvalue*

<ex>
I once heard Andrei Alexandrescu give a talk on ScopeGuard (invented by Petru
    Marginean) where he used this C++ feature and called it "the most important
const I ever wrote." And this brings us to the Guru Question, which highlights
the additional subtlety that Andrei's code deftly leveraged.

Guru Question

Q3: When the reference goes out of scope, which destructor gets called?
A3: The same destructor that would be called for the temporary object. It's just
being delayed.

Corollary: You can take a const Base& to a Derived temporary and it will be
destroyed without virtual dispatch on the destructor call.

This is nifty. Consider the following code:

    // Example 3

    Derived factory(); // construct a Derived object

    void g() {
      const Base& b = factory(); // calls Derived::Derived here
      // use b
    } // calls Derived::~Derived directly here - not Base::~Base + virtual dispatch!

Does this work in practice on real compilers? Yes: Every compiler I have access
to calls the correct Derived destructor, including even ancient Borland 5.5 and
Visual C++ 6.0 (and Digital Mars, though DM calls the destructor at the wrong
    time, as noted above).

Andrei leverages this subtlety (of course) in his ScopeGuard implementation to
avoid making the implementation classes' destructors virtual at all, which is
okay in that case because those classes otherwise have no need for one. 


{cxx-return-const-return}

// this is old and out-dated.
//
// EC++03. When `return by value` for user type, use const to raise error when
// mistake happens:
// 
// const Rational operator*( const Rational& lhs, const Rational& rhs );
// 
// if( a * b = c )       // typo. was meant if( a * b == c )
// 
// If these are built-in type, this is flat-out error but not for class type. 
// 
// * The returned `built-in` type is an `rvalue` and can't be modified. EXPC++43.
// * Even if it were legal, the fact that it returns object by value would mean
//   that a copy would be modified and that's not the behavior you want. 
// 
// So better to be prepared for this kind of mistakes. Also this is an example of
// returning a copy than reference.


CCG F.20: For “out” output values, prefer return values to output parameters

Note A struct of many (individually cheap-to-move) elements may be in
aggregate expensive to move. It is not recommended to return a const value.

`Such older advice is now obsolete`; it does not add value, and it interferes
with move semantics.  

const vector<int> fct(); // bad: that "const" is more trouble than it is worth

vector<int> g(const vector<int>& vx)
{
  // ...
  fct() = vx; // prevented by the "const"

  // ...
  // expensive copy: move semantics suppressed by the "const"
  // *TN* since move controls requires non-const argument.
  return fct(); 
}

The argument for adding const to a return value is that it prevents (very
rare) accidental access to a temporary. The argument against is prevents
(very frequent) use of move semantics.

*TN* So better to allow move semantics than to prevent access to a temporary


Exceptions

If a type is `expensive to move` (e.g., array<BigPOD>), consider allocating
it on the free store and return a handle (e.g., unique_ptr ), or passing it in
a reference to non-const target object to fill (to be used as an
out-parameter).


F.47: Return T& from assignment operators

Reason 

The convention for operator overloads (especially on value types) is for
operato r=(const T&) to perform the assignment and then return (non-const)
  *this. This ensures consistency with standard-library types and follows the
  principle of “do as the ints do.”

Note 
Historically there was some guidance to make the assignment operator return
const T&. This was primarily to avoid code of the form (a = b) = c such code
is not common enough to warrant violating consistency with standard types.

Example

class Foo
{
  public:
    ...
      Foo& operator=(const Foo& rhs) {
        // Copy members.
        ...
          return *this;
      }
};


{no-return-when-expected}

#include <iostream>
#include <string>

using namespace std;

bool str_subrange( const string& str1, const string& str2 )
{
  if( str1.size() == str2.size() )
    return str1 == str2;

  auto small_size = ( str1.size() < str2.size() ) ? str1.size() : str2.size();

  for( decltype(small_size) i = 0; i != small_size; ++i )
    if( str1[i] != str2[i] )
      ;                          // NO ERROR in this case
      return;                    // ERROR-01
                                 // ERROR-02
}

int main()
{
  string str1 = "KYOUNG";
  //string str2 = "YOU";
  string str2 = "KYO";

  bool ret = false;

  ret = str_subrange(str1, str2);
  if( ret )
    cout << "return true" << endl;
  else
    cout << "return false" << endl;

  return 0;
}

<ERROR-01>
VC and GCC picks up this error. This is GCC case:

.cpp: In function bool str_subrange(const std::string&, const std::string&)
.cpp:16: error: return-statement with no value, in function returning bool

<ERROR-02> *cxx-undefined*
Both VC adn GCC do not picks up this error. Also says that its result at
runtime is 'undefined'. When running for VC and GCC showed different result:
VC returns true and GCC do false. Hence 'undefined'. 


<ex-case> *cxx-switch-case*
Have spent a day to find out why a program crashes. Two lessons:

  * It is better to have a core dump rather then narrowing down where a crash
    happens. Since looked like there are other places to be suspicious while
    doing gdb session until reachs to the real cause such as constructors, map
    insertions, and so on.

  * From the *C89* standard as quoted in the new testament: Flowing off the
    end of a function is equivalent to a return with no expression. In either
    case, the return value is undefined.

This is a debug trace routines and defines enums, strings for enums. It is
easy to make a mismatch between enum and strings when add more enums. So
better to have strings from enums using macro stringfication. However, in that
case, enum should be sequential.

typedef enum MHEGComponent_
{
    eMHEGNull       = 0x00000001,
    eMHEGeng        = 0x00000002,
    eMHEGengRuntime = 0x00000004,
    ...
} MHEGComponent;

const char* s_names[] =
{
    "Null",
    "MHEGEng",
    "MHEGEngRun",
    ...
};

const uint32_t getIndex(MHEGComponent comp)
{
  switch (comp)
  {
    case 0x00000001: return 0; break;
    case 0x00000002: return 1; break;
    case 0x00000004: return 2; break;
    case 0x00000008: return 3; break;
    case 0x00000010: return 4; break;
    ...
    case 0x00000040: return 6; break;
    case 0x00000080: return 7; break;
    case 0x00000100: return 8; break;
    case 0x00000200: return 9; break;
    case 0x00000400: return 10; break;
  }
}

This didn't have default case and when there is a enum which don't have a
matching case, no return statement but this function returns int. Which value
will you get? Quick test shows *cxx-undefined* return value.

case: 3000
val: 134520896


<when-return-local>
const string& foo()
{
  string ret;

  if
    return ret;
  else
    return "Empty";
}

Both return cause undefined result at the call site(caller) because it returns
reference to local to function foo().


<no-return-string>

// supposed to return string but not

std::string return_string(const std::string &input)
{
    // return ??
}

int main()
{
    return_string("this is call from main");
    ...
}

// without -D_GLIBCXX_DEBUG
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007f0f6974f170 in std::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6

// with -D_GLIBCXX_DEBUG
Program received signal SIGSEGV, Segmentation fault.
0x00000000004018b3 in __gnu_cxx::__exchange_and_add_single (__mem=0xfffffffffffffff9, __val=-1) at /usr/include/c++/4.9/ext/atomicity.h:67
67          _Atomic_word __result = *__mem;


={============================================================================
*kt_dev_cxx_0000* cxx-bool

Do not have a minimum size. In VC, is the same as `int` type. 

<ex> on ubuntu linux
#include <iostream>
#include <bitset>

using std::cout;
using std::endl;

int main () {

  bool* parr = new bool(20);

  cout << "size: " << sizeof(parr) << endl;
  cout << "size: " << sizeof(*parr) << endl;
  cout << "valu: " << *parr << endl;

  return 0;
}

size: 4
size: 1
valu: 1


{non-bool-to-bool}
When assign non-bool to bool type, `type-conversion` happens and got 0 or 1
depending on the value of non-bool. That is false for 0 and 'true' for 'any'
other values other than 0.

bool b = 42;    // b is true


{bool-to-non-bool}

if( val == true ) { ... }

`If val is non-bool type`, conversion to <non-bool> which is bigger type
happens and this becomes 

if( val == 1 ) { ... }

This may not be what intented if want to cover all cases of non-zero because
it runs only when val is 1. Therefore, want the case of when val is 1 then do
it directly.

The direct form is:

if(val) or if(!val) 

It is usually bad idea to use the boolean literals true and false as operands
in a comparison. These literals should be used 'only' to compare to an object
of type 'bool'.


<ex>
In the mips g++, have bool variables but shows value in some cores rather
then ture/false literals. So true is `non-zero`

bool errorState;
bool stopped;

errorState = false, stopped = true
errorState = 103, stopped = 101
errorState = 101, stopped = 110

http://stackoverflow.com/questions/4276207/is-c-c-bool-type-always-guaranteed-to-be-0-or-1-when-typecasted-to-int
In C++ (§4.5/4):
    An rvalue of type bool can be converted to an rvalue of type int, with
    false becoming zero and true becoming one.

In C, when a value is converted to _Bool, it becomes 0 or 1 (§6.3.1.2/1):
    When any scalar value is converted to _Bool, the result is 0 if the value
    compares equal to 0; otherwise, the result is 1.


{not-use-in-computation}
Do not use bool and char for computation since there is conversion. For
example:

bool b1 = true;
bool b2 = -b1;

b2 is true since b1 promoted to 1, negates to -1, and convert back to bool but
it is nonzero hence true. <Q> why promoted? due to negate operator?


{bool-conversion} equal-misspell

<1>
The fact that we can use assignment in a condition can have surprising effects:

if (i = j)

The condition like this which assigns the value of j to i and then tests the
result of the assignment. If j is nonzero, the condition will be true in
conditons. 'true' means `nonzero` (all other value than zero). 

The author of this code almost surely intended to test whether i and j have
the same value:

if (i == j)

Bugs of this sort are notoriously difficult to find.


<2> 
auto loc = wordmap.find( sought );

if( loc = wordmap.end() )  // meant if( loc == wordmap.end() )

GCC error is:

tquery.cpp:63: error: could not convert '(loc <unknown operator> ((const
        std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char,
        std::char_traits<char>, std::allocator<char> >,
        std::shared_ptr<std::set<long unsigned int, std::less<long unsigned
        int>, std::allocator<long unsigned int> > > > >&)((const
            std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char,
            std::char_traits<char>, std::allocator<char> >,
            std::shared_ptr<std::set<long unsigned int, std::less<long unsigned
            int>, std::allocator<long unsigned int> > > > >*)(&((const
                  TextQuery*)this)->TextQuery::wordmap.std::map<_Key, _Tp,
              _Compare, _Alloc>::end [with _Key = std::basic_string<char,
              std::char_traits<char>, std::allocator<char> >, _Tp =
              std::shared_ptr<std::set<long unsigned int, std::less<long
              unsigned int>, std::allocator<long unsigned int> > >, _Compare =
              std::less<std::basic_string<char, std::char_traits<char>,
              std::allocator<char> > >, _Alloc = std::allocator<std::pair<const
              std::basic_string<char, std::char_traits<char>,
              std::allocator<char> >, std::shared_ptr<std::set<long unsigned
              int, std::less<long unsigned int>, std::allocator<long unsigned
              int> > > > >]()))))' 
to 'bool'

This happens when tries to covert loc iterator to bool. If it were ==, then
operator== would return bool type.


<3>
Meant to be == and this if is always true.

bool QueueFull(Queue* queue)
{
   if( queue->count = MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}


={============================================================================
*kt_dev_cxx_0000* cxx-bool-conversion-cxx-conversion-to-bool

namespace cxx_code
{
  // *cxx-conversion-op* *cxx-overload-call* *cxx-operator-bool*
  // operator T() const;     where T represents `type`

  `explicit` operator bool() const
  { return _m_ptr == 0 ? false : true; }

  struct absInt {
    int operator() (int val) const {
      return val < 0 ? -val : val;
    }
  };
}

note that operator bool() also covers !(not) operator as well which is member
of user_class. there is no such thing like "bool operator!() {}"

    if (!user_class) return;


The classes rarely provide conversion operator but one important exception is
convertion to bool.

In earlier version of the library, the IO types defined a `conversion-to-void`
to avoid the kind of problems above. Under the new standard, instead defines
an `explicit-conversiton-to-bool`.

`However, even if uses explicit, this explicit has no effect` when use stream in
condition such as:

if, while, for and do statements. logical operators. conditional operators.
 
because `conversion-to-bool` is intended for use in conditions and hence
ordinarily should be defined as explicit to avoid problems in other uses:

while(std::cin >> string)

Reads input into value, return cin, and cin converted to bool depending on
cin state. This bool conversion is the typical use of *cxx-conversion-op*


<ex> *cxx-stream*
The issue is tht the code below starts to fail to build suddenly when upgrages
gcc.

: error: cannot convert ‘std::istream {aka std::basic_istream<char>}’ to ‘bool’
in initialization"

This is because operator bool() is defined 'explicit'. This issue was shadowed
by the fact that gcc-4.9 (and below) still had operator void*() const.

stringstream s;

operator>>() returns stream stream is implicitly converted to bool since
copy-init is used. now it is made exlpicit so failed to do so.

-    bool read_ok = s >> st;
-    ASSERT_THAT(read_ok, Eq(true));
-
+    s >> st;
+    ASSERT_THAT(s.good(), Eq(true));


note: 
Like cin, seems useful to have bool conversion when class has state.


Two stream functions are defined for the use of streams in Boolean expressions

explicit operator bool ()
Returns whether the stream has not run into an error (corresponds to !fail())

operator ! ()
Returns whether the stream has run into an error (corresponds to fail())

fail() is stream member function:
Returns true if an error has occurred (failbit or badbit is set)


<conversion-to-bool> cxx-operator-bool
The conversion to bool is often used to read objects and test for success in
the same expression. returns whether the stream has run into an error.

// as long as obj can be read
while (std::cin >> obj) {
  // process obj (in this case, simply output it)
  std::cout << obj << std::endl;
}

The loop is terminated if the failbit or badbit is set.

Like the implicit conversion to a bool, this operator is often used to test
for success in the same expression in which an object was read:

if (! (std::cin >> x)) {
  // the read failed
  ...
}


<ex> cxx-string-getline
All characters, including leading whitespaces, are extracted until any of the
following happens:

o strm.good() is false (which might cause an appropriate exception)
o delim or strm.widen('\n') is extracted
o str.max_size() characters are stored

How can we use getline() to read multiple lines in loop such as:

  while (getline(...))

It returns a stream and when you use it in a boolean context the compiler
looks for an conversion operator that can convert it into a type that can be
used in the boolean context.


<ex> problem when use old operator void*()
Use implicit conversion operator which is traditional. This is the way
iostream uses so it is possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
  public:
    operator void*(); // return 0 if smart pointer is null, nonzero otherwise.
    ...
};

This approach has a problem since it allows following: 

SmartPtr<Apple> pa; SmartPtr<Orange> po;

if( pa == po ) ...

This compiles even if there is no operator== taking a SmartPtr<Apple> and a
SmartPtr<Orange>:

Since both smart pointers can be implicitly converted into void* pointers, and
there is a built-in comparison function for built-in pointers.

So the below fails although they points to the same.

SmartPtr<Apple> pa; SmartPtr<Orange> po;

pa = po;

if( pa == po ) ...


<ex> problem when use old operator void*()

Before C++11, the `cxx-operator-bool()` was declared as `operator-void*()`,
which could cause problems such as those described in C++SL Section 15.10.1,
page 805:

a typical programming error when dealing with string streams was to forget to
extract the string with the function str() and to write to the stream directly
instead. This was, from a compiler's point of view, a possible and reasonable
thing to do because there was an implicit conversion to void*. 

ostringstream os;
cout << os.str() << endl;       // right

As a result, the issue is that instead of its value the state of the stream was
written in the form of an address. 


Section 15.3.3, page 756

Type void*

Operators << and >> also provide the possibility of printing a pointer and
reading it back in again. An address is printed in an implementation-dependent
format if a parameter of type void* is passed to the output operator. For
example, the following statement prints the contents of a C-string and its
address:

char* cstring = "hello";

std::cout << "string \"" << cstring << "\" is located at address: "
<< static_cast<void*>(cstring) << std::endl;

The result of this statement might appear as follows:

string "hello" is located at address: 0x10000018

It is even possible to read an address again with the input operator. However,
   note that addresses are normally transient. The same object can get a
   different address in a newly started program. A possible application of
   printing and reading addresses may be programs that exchange addresses for
   object identification or programs that share memory.

*cxx-remember*
With C++11, this conversion was replaced by an explicit conversion to bool, so
passing a stringstream to the output operator << without calling str() is no
longer possible.


<problem>
This member function prints "1" then the address. What happended?

class printer {

  void wtf()
  {
    std::cout << "what: " << &printer::print << std::endl;
  }
};


*cxx-stream-code-ios*

namespace cxx_code
{
  // 4.7.2/bits/basic_ios.h

  // 27.4.5  Template class basic_ios
  /**
   *  @brief  Virtual base class for all stream classes.
   *  @ingroup io
   *
   *  Most of the member functions called dispatched on stream objects
   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
   */

  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
  {
    public:
      //@{
      /**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  "if (!a_stream) ..." and "while (a_stream) ..."
       */
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
        operator!() const
        { return this->fail(); }
      //@}
  }

  // iosfwd
  // ostream

  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
  {
  }

  /// Base class for @c char output streams.
  typedef basic_ostream<char> 		ostream;


  // bits/shared_ptr_base.h

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
      // ...

      `explicit` operator bool() const // never throws
      { return _m_ptr == 0 ? false : true; }
    }
}

<ex>
if remove "insert for bool values", then both will use string version.
Looks like it's to do with name resolution.

but there is no bool conversion of string. Then how it uses bool version?

NO. it turns out that's because there is implicit pointer to bool conversion and
that's what's happening here.

[ RUN      ] String.check_string_bool_1
insert(std::string &&key, bool value)
key: key1, value: 1
insert(std::string &&key, std::string &&value)
key: key2, value: value2
[       OK ] String.check_string_bool_1 (0 ms)
[ RUN      ] String.check_string_bool_2
check_bool: 1
[       OK ] String.check_string_bool_2 (0 ms)

this "implicit pointer to bool conversion" explains how this works:


see cxx-bool-conversion-cxx-conversion-to-bool

same from SO:

https://stackoverflow.com/questions/14770252/string-literal-matches-bool-overload-instead-of-stdstring

"Hello World" is a string literal of type "array of 12 const char" which can be
converted to a "pointer to const char" which can in turn be converted to a bool.
That's precisely what is happening. The compiler prefers this to using
std::string's conversion constructor.

A conversion sequence involving a conversion constructor is known as a
user-defined conversion sequence. The conversion from "Hello World" to a bool is
a standard conversion sequence. The standard states that a standard conversion
sequence is always better than a user-defined conversion sequence (§13.3.3.2/2):

a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than
a user-defined conversion sequence or an ellipsis conversion sequence

This "better conversion sequence" analysis is done for each argument of each
viable function (and you only have one argument) and the better function is
chosen by overload resolution.

If you want to make sure the std::string version is called, you need to give it
an std::string:

namespace cxx_bool
{
  // // insert for bool values
  void insert(const std::string &key, bool value)
  {
    std::cout << "insert(const std::string &key, bool value)" << std::endl;
    std::cout << "key: " << key << ", value: " << value << std::endl;
  }

  void insert(std::string &&key, bool value)
  {
    std::cout << "insert(std::string &&key, bool value)" << std::endl;
    std::cout << "key: " << key << ", value: " << value << std::endl;
  }

  // insert for string values
  void insert(const std::string &key, const std::string &value)
  {
    std::cout << "insert(const std::string &key, const std::string &value)"
              << std::endl;
    std::cout << "key: " << key << ", value: " << value << std::endl;
  }

  void insert(std::string &&key, std::string &&value)
  {
    std::cout << "insert(std::string &&key, std::string &&value)" << std::endl;
    std::cout << "key: " << key << ", value: " << value << std::endl;
  }

  void check_bool(bool value)
  {
    std::cout << "check_bool: " << value << std::endl;
  }
} // namespace cxxbool


={============================================================================
*kt_dev_cxx_0000* cxx-const 

<must-be-initialized>
Because we can't change the value of a const object after we create it, `must`
be initialized.


<constant-expression>
A constant expression is an expression that involves only constants:

#define MAXLINE 100
char line[MAXLINE+1];


{cxx-const-file-scope} *cxx-static* *cxx-internal-linkage* CPR 60

o constant expression

const int bufSize = 512;

The compiler will replace uses of the variable with its corresponding value
during compilation. That is, the compiler will generate code using the value
512 in the places that our code uses bufSize. To do this, the compiler has to
see the initializer. 

When split a program into multiple files, every file must have access to its
initializer. In order to see initializer, the variable must be defined in
every file. 

To support this, `yet avoid multiple definitions` of the same variable, const
variable are defined as local to file. When define a const with the same name
in multiple files, it is `as if` had written definitions for separate
variables in each file. 

// $ g++ -g -std=c++0x -c a.c
// $ g++ -g -std=c++0x -c b.c
// $ g++ -g -std=c++0x a.o b.o main.c

#include <cstdio>
#include "def.h"

int main()
{
    printf("this is main\n");
    printf("this is main: the const is %d\n", ci_max_value );

    print_const_from_a();
    print_const_from_a();

    return 0;
}

// this is a.c
//
#include <cstdio>
#include "def.h"

void print_const_from_a()
{
    printf("this is a.c and the const is %d\n", ci_max_value );
}

// this is b.c
//
#include <cstdio>
#include "def.h"

void print_const_from_b()
{
    printf("this is b.c and the const is %d\n", ci_max_value );
}

// this is def.h
//
const int ci_max_value = 500;

extern void print_const_from_a();
extern void print_const_from_b();

// output
//
$ nm a.o
0000000000000000 T _Z18print_const_from_av
0000000000000024 r _ZL12ci_max_value

$ nm b.o
0000000000000000 T _Z18print_const_from_bv
0000000000000024 r _ZL12ci_max_value

$ nm a.out
...
000000000040071c r _ZL12ci_max_value
0000000000400744 r _ZL12ci_max_value
0000000000400778 r _ZL12ci_max_value

The nm result is the same when defines ci_max_value in each c file and even
when uses different initializers.

Again as said, although use `the same name`, 
  "it is `as if` had written definitions for separate variables in each file."
  by `generating` a separate variable in each file.


o for not a constant expression

When initialzer is not a constant expression, not generate a separate variable
in each file and want const object behave like other variable. Must use
`extern` on 'both' definition and declaration.

// file one
extern const int bufSize = fcn();

// file two
extern const int bufSize;


o *cxx-extern* works for constant expression as well.

$ nm a.o
                 U ci_max_value
$ nm b.o
                 U ci_max_value
$ nm a.out
0000000000400758 R ci_max_value


<ex>
Suppose that a header has const definition like below and is included in
multiple files. Is it a problem?

const char *const MESSAGE_TYPE_URL_LIST = "text/uri-list";

Interesting, I was using gcc. It seems this is legal in C++ but not in C. Causes
link error, duplicated.

The reason:

the C++ Standard, Annex C
3.5 [also 7.1.6]
Change: A name of file scope that is explicitly declared const, and not
explicitly declared extern, has `internal-linkage`, while in C it would have
`external-linkage`

Because const objects can be used as compile-time values in C++, this feature
urges programmers to provide explicit initializer values for each const.  This
feature allows the user to put const objects in header files that are included
in many compilation units.


o tried 1 with gcc

$ nm a.o
0000000000000000 R ci_max_value
$ nm b.o
0000000000000000 R ci_max_value

$ gcc -g a.o b.o main.c
b.o:(.rodata+0x0): multiple definition of `ci_max_value'
a.o:(.rodata+0x0): first defined here
/tmp/ccfme3ln.o:(.rodata+0x0): multiple definition of `ci_max_value'
a.o:/home/kyoupark/works/t_const/a.c:11: first defined here
collect2: error: ld returned 1 exit status


All in all, it is *cxx-feature* C++ feature which makes const file-scope.


{top-and-low-level-const} *cxx-const* *cxx-declarator*
This is `only for pointer` which has `indirect access` so makes two level in
terms of constness. This matters when copy an object.

  const int *const `variable`         // const pointer (pointer itself)
  <-- 1 --> <- 2 ->

  const int * `variable`              // pointer to const int

  const int *const `variable`         // const pointer to const
  int const *const `variable`         // same

  const int & `variable`              // reference to const *cxx-reference-const*
  int const & `variable`              // same

o 1, `base-type` part which is for `underlying object` and for low-level. That is a
  object that point or reference to.

o 2, `declarator-type` part which is for compound type, reference or pointer, and
  for top-level. That is pointer or reference itself.

Do not think about top low-level. The point is that low-level, underlying
object, never be ignored but top-level can be since it's not about
underlying object. The main thing is if it's break constness of underlying
object.

In other words, top-level restrics only what we can do `through` that reference
or pointer and says nothing about whether the underlying object itself. 

<ex> *cxx-reference-of-pointer*
this is a reference of pointer:

Binary_node<Record> *&sub_root; 

<ex>
TEST(Const, NoViaConstReference)
{
  int i{};
  int &ri = i;
  const int &rc = i;  // non-const to const is fine

  ri = 0;

  // cxx.cpp:3312:6: error: assignment of read-only reference ‘rc’
  // rc = 0;
}


{cxx-const-no-const-to-non-const}

TEST(Const, NoConstToNonConst)
{
  {
    const int ci{100};

    // no const to non-const is allowed
    // *cxx-const-error-const* cxx-error: invalid initialization of reference
    // of type ‘int&’ from expression of type ‘const int’

    // int &ri = ci;
    
    // int &ri = (int &)ci;   // no error since used cast
  }

  {
    int nci{100};
    const int *pci = &nci;
    EXPECT_THAT(*pci, 100);

    // cxx-error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]
    // int *pi = pci;
  }
}


{const-on-base-type}
When use const with type alias, it can be surprising. For example,

typedef char *pstring;

const pstring cstr = 0;    // a "const pointer to char"
const pstring *ps;         // a "pointer to "const pointer to char*"

The important thing is that type alias `is not replacing string` but it a type
and const applies on `base-type`.

// wrong interpretation. base type is char and * is part of declarator. cstr is
// pointer to "const char" 
const char* cstr = 0;      

// base type is "pstring" so const is on pstring type is a const pointer to char
const pstring cstr = 0;    


{cxx-const-on-iterators} *cxx-iter*
The *cxx-iter* has overloads and uses different from to use const or non-const.
cxx-overloads depending cxx-const

/**
*  Returns a read/write iterator that points to the first
*  element in the %vector.  Iteration is done in ordinary
*  element order.
*/
iterator
begin() _GLIBCXX_NOEXCEPT
{ return iterator(this->_M_impl._M_start); }

/**
*  Returns a read-only (constant) iterator that points to the
*  first element in the %vector.  Iteration is done in ordinary
*  element order.
*/
const_iterator
begin() const _GLIBCXX_NOEXCEPT
{ return const_iterator(this->_M_impl._M_start); }


// as `T *const` , iter itself is const
const std::vector<T>::iterator iter = vec.begin();

// as `const T *` , *iter is const
std::vector<T>::const_iterator iter = vec.begin();


={============================================================================
*kt_dev_cxx_0000* cxx-const-temporary

{use-reference-const-argument} *cxx-reference-const*
Use `cxx-reference-const` argument when possible since two implications over
plain reference param in func:
 
o clerer interface
  if not, a function that don't change a reference param and mislead its user
  to think it does change.
 
o can be used both const-param and non-const param. 
 
o better performance

The `const` only matters when use reference.
 
void fcn( const int i ); 
fcn(j);     // const int i = j; 
fcn(cj);    // const int i = cj;
 
void fcn( int i ); 
fcn(j);     // int i = j; 
fcn(cj);    // int i = cj; NO ERROR
 
 
<ex> 
const GstCaps *caps = gst_caps_from_string(); 
gst_caps_unref(GetCaps *caps);
 
:44: error: invalid conversion from 'const GstCaps*' to 'GstCaps*' :44: error:
initializing argument 1 of 'void gst_caps_unref(GstCaps*)'
 
<ex> *cxx-const-cxx-temporary* 

find_char(const string& s, char c);   // ok, match to literal, temporary
find_char("Hello", 'o');   

find_char(string& s, char c);         // ERROR,  literal is temporary
find_char("Hello", 'o');   


EXPECT_THAT(validator2->validate("abc123!@#"), true);

// error
bool validate(std::string& password) override

// okay
bool validate(std::string password) override

// okay
bool validate(std::string const& password) override


<ex> *cxx-temporary*
// miss out const on argument
void add_item(shared_ptr<Quote> &item);

sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));

t_quote_two.cpp:94:58: error: no matching function for call to ‘Basket::add_item(std::shared_ptr<Quote>)’
     sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
                                                          ^
t_quote_two.cpp:94:58: note: candidate is:
t_quote_two.cpp:72:6: note: void Basket::add_item(std::shared_ptr<Quote>&)
 void Basket::add_item(shared_ptr<Quote> &item)
      ^
t_quote_two.cpp:72:6: note:   no known conversion for argument 1 
  from ‘std::shared_ptr<Quote>’ to ‘std::shared_ptr<Quote>&’


{cxx-const-non-const-to-const} *cxx-type-match-exceptions* CPR p61
As long as maintain constness, allow conversion and so two exceptions to type
match rule. 

These are `implicit` `non-const-to-const` and `base-referencer-to-derived`
conversion. Can bind reference-to-const to non-const, a literal, temporary, or
other expression that evaluate to an type.

int i;
const int &j = i;       // type match exception. `non-const to const`
const int *p = &i;      // type match exception. non-const to const
int &r = j, *q = p;     // ERROR since `no const to nonconst`


<const-reference-to-literal>
compiler make a 'temporary' to allow conversion and maintain constness.

const int &ri = 42;     // ok since temporay from 42
int &ri = 10;           // ERROR

double dval = 3.14;     // ok, not a reference
int ival = dval;        // ok, truncation
const int &ri = dval;   // ok, will bind to temporary

int &ri = dval;         // ERROR
// error: invalid initialization of reference of type 
// ‘int&’ from expression of type ‘double’

The reference is alias for something exist and also need to maintain
constness. The compiler transforms this:

const int temp = dval;  // see const and tempoary is const object.
cont int &di = temp;

This also shows an example of creating a temporary through const conversion.

int main()
{
  int i{100};
  const int &ri = i;

  i = 200;

  std::cout << "i: " << i << std::endl;
  std::cout << "ri: " << ri << std::endl;

  double dval{3.14};
  const int &di = dval;

  dval = 6.28;

  std::cout << "d: " << dval << std::endl;
  std::cout << "rd: " << di << std::endl;
}

i: 200
ri: 200
d: 6.28
rd: 3                   // not changed, temporary


={============================================================================
*kt_dev_cxx_0000* cxx-const-member-function cxx-this

{cxx-overload-condition} cxx-const-overload
Member functions differing only in their constness can be overloaded. Conditons
for overloading

o Shall be the `same-name`
o Shall have different param list in the `number-or-type` 
o Shall be in the `same-scope`

It is an error for two functions to differ only in their return types since
don't see return type. See {virtual-copy-constructor} for override case.

<cxx-const-overload>
The reason that the compiler can use the constness of the argument to
distinguish which funtion to call is that there is `no-const-to-non-const`
conversion.

void fcn( const int i );          // support both const and non-const
void fcn( int i );                // *error* redefines and *cxx-pass-by-value*

Record lookup(account *);         // pointer
Record lookup(account *const);    // const pointer. *error* redefines

Record lookup(account &);         // non-const version
Record lookup(const account &);   // const version

Record lookup(account *);         // non-const version
Record lookup(const account *);   // const version

the const version cover both const and non-const uses.


{cxx-const-member-func}
EC++03. Two points:

o Clearer interface to show which member func can change state; read or write.
o Make it possible to work with const objects. 


{cxx-const-this} *cxx-this*
Member function access the object through an extra, implicit parameter named
`this`. The compiler passes the address of `total` to the implicit `this`
parameter `as if` rewrites this call as:

total.isbn();

// where Sales_data::isbn(Sales_data *const this);
Sales_data::isbn(&total);

Since `this` is intended to always refer to "this" object, `this` is const
pointer. When defines const member function:

string isbn `const` { return bookNo; }

The `const` changes the type of the implicit `this` pointer.

Without const, `this` is a `const pointer` to non-const by default and means that
can use(bind) only nonconst objects since there's no const-to-nonconst
conversion which cause *cpp-const-to-nonconst-error*

 T *const this -> `const` T *const this

So:
  Cannot change object via const member func.
  Can be used on 'both' const and nonconst class object.
  Cannot call non-const member function on const object.


{call-from-const-to-non-const}
*cxx-const-error* when calls non-const member on const object.

cxx-error: passing ‘const std::map<int, StateMachine::State>’ 
  `as ‘this’ argument discards qualifiers` [-fpermissive]

<ex>
namespace const_member_function
{
  class Screen
  {
    public:
      Screen() : mesg_("screen") {}

      string get_message() const { return mesg_; }
      string get_message() { return mesg_; }

    private:
      string mesg_;
  };

  // *cxx-const-error-cxx-error-const* 
  //
  // when there's no const version of get_message() which means that calls 
  // non-const member on const
  //
  // cxx.cpp: In function 
  // ‘std::string const_member_function::print_screen(const
  //  const_member_function::Screen&)’:
  //
  // cxx.cpp:3359:26: error: passing ‘const const_member_function::Screen’ 
  // as ‘this’ argument of ‘std::string
  // const_member_function::Screen::get_message()’ discards qualifiers
  // [-fpermissive]
  // 
  //      return s.get_message();

  string print_screen(const Screen &s)
  {
    return s.get_message();
  }

  template <class T, size_t R, size_t C>
    class array2d
    {
      std::vector<T> arr;

      public:
      array2d() :arr(R*C) {}
      explicit array2d(std::initializer_list<T> l):arr(l) {}

      // *cxx-const-error-const* when there's no const version
      //
      // when use constexpr function
      //  
      //  constexpr T& at(size_t const r, size_t const c)
      //  {
      //     return arr.at(r*C + c);
      //  }
      //
      // cxx.cpp: In instantiation of ‘constexpr T& const_member_function::array2d<T, R, C>::at(size_t, size_t) const [with T = int; long unsigned int R = 2ul; long unsigned int C = 3ul; size_t = long unsigned int]’:
      // cxx.cpp:3420:21:   required from ‘void const_member_function::print_array2d(const const_member_function::array2d<T, R, C>&) [with T = int; long unsigned int R = 2ul; long unsigned int C = 3ul]’
      // cxx.cpp:3439:20:   required from here
      // cxx.cpp:3403:31: error: invalid initialization of reference of type ‘int&’ from expression of type ‘const value_type {aka const int}’
      //           return arr.at(r*C + c);
      //
      // also this cause
      // *cxx-const-error* ‘constexpr const T& array2d<T, R, C>::at(size_t, size_t) const’ cannot be overloaded
      

      // non-const version
      //
      // *cxx-const-error-const* when there's no const version
      //
      // cxx.cpp:3409:21: error: passing ‘const const_member_function::array2d<int, 2ul, 3ul>’ as ‘this’ argument of ‘T& const_member_function::array2d<T, R, C>::at(size_t, size_t) [with T = int; long unsigned int R = 2ul; long unsigned int C = 3ul; size_t = long unsigned int]’ discards qualifiers [-fpermissive]
      //            std::cout << arr.at(i, j) << ' ';
      //
      // T& at(size_t const r, size_t const c)
      // {
      //    return arr.at(r*C + c);
      // }

      // const version covers both const and non-const use
      constexpr T const & at(size_t const r, size_t const c) const 
      {
        return arr.at(r*C + c);
      }
    };

  template <class T, size_t R, size_t C>
    void print_array2d(array2d<T, R, C> const & arr)
    {
      for (int i = 0; i < R; ++i)
      {
        for (int j = 0; j < C; ++j)
        {
          std::cout << arr.at(i, j) << ' ';
        }

        std::cout << std::endl;
      }
    }

} // namespace

TEST(Const, ForMemberFunction)
{
  using namespace const_member_function;
  {
    Screen screen;
    print_screen(screen);
  }

  {
    array2d<int, 2, 3> a;
    print_array2d(a);
  }
}


<ex>
This is not straitforward to understand. Since find_entry_for() is const
member function, makes `this` const and data member becomes const and find_if
returns const iterator. so *cxx-const-to-non-const-error*

However, get a long error as shown in *cxx-template-decode-error*

class bucket_type
{
  public:

  private:
    using bucket_value = std::pair<Key, Value>;
    std::list<bucket_value> data;

    // error
    using bucket_iterator = typename std::list<bucket_value>::iterator;

    // okay
    using bucket_iterator = typename std::list<bucket_value>::const_iterator;

    bucket_iterator find_entry_for(const Key &key) const
    {
      return std::find_if(data.begin(), data.end(),
          [&](const bucket_value &item) {
          return item.first == key;
          });
    }
};


<ex>
Okay. remove const from find_entry_for() and gets error from value_for().

class bucket_type
{
  public:
    Value value_for(const Key &key, const Value &default_value) const
    {
      // read on shared mutex
      boost::shared_lock<boost::shared_mutex> lock(m);

      auto found_entry = find_entry_for(key);
      return found_entry == data.end() ? default_value : found_entry->second;
    }

  private:

    bucket_iterator find_entry_for(const Key &key)
    {
      return std::find_if(data.begin(), data.end(),
          [&](const bucket_value &item) {
          return item.first == key;
          });
    }
};

: error: `passing` ‘const threadsafe_lookup_table<std::basic_string<char>, int>::bucket_type’ as ‘this’ argument of ‘threadsafe_lookup_table<Key, Value, Hash>::bucket_type::bucket_iterator threadsafe_lookup_table<Key,
         Value, Hash>::bucket_type::find_entry_for(const Key&) [with Key =
         std::basic_string<char>; Value = int; Hash =
         std::hash<std::basic_string<char> >; threadsafe_lookup_table<Key,
         Value, Hash>::bucket_type::bucket_iterator =
         __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
         int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
         std::allocator<std::pair<std::basic_string<char>, int> > > >]’
         discards qualifiers [-fpermissive]

           auto found_entry = find_entry_for(key);
                                                ^

<ex>
NS_ZINC::Future<Position> Gst::getPosition() const
{
    return returnDefault(
                Position(0,
                    int32_t(GST_TIME_AS_MSECONDS(cachedCurrent)),
                    int32_t(GST_TIME_AS_MSECONDS(cachedCurrent))));
}

template<typename T>
NS_ZINC::Future<T> Gst::returnDefault(const T& val)
{
    return NS_ZINC::asyncInvoke(getDispatcher(), *getDispatcher(),
            boost::bind(&GstMediaRouter::getPosition_async, this));
}

This emits an error:

: error: `passing` 'const nickel::system::GstMediaRouter' as 'this' argument of 'zinc::Future<T>
nickel::system::GstMediaRouter::returnDefaultIfStopped(const T&) [with T =
Zinc::Media::Position]' discards qualifiers


*cxx-const-error-const* *cxx-remember*
Because value_for() is const which makes a `call from const to non-const`
since there is `no-const-to-nonconst`


{const-non-const-member} *cxx-const-overload-const*
If there is only a const version of display() then following is a compile
error. Assume display() is const member func and set() is nonconst member
func.

screen myscreen;
myscreen.display().set(10);

Since display() returns const T& and cannot call nonconst, set() on const
object. Solution?


o Have const and non-const version

class Screen {
  public:
    Screen& display()
    { cout << "dis: this is non-const member" << endl; return *this; }

    `const` Screen& display() `const`
    { cout << "dis: this is const member" << endl; return *this; }

    void set()
    { cout << "set: this is non-const member" << endl; }

    void set() const
    { cout << "set: this is const member" << endl; }
};


int main(int argc, char** argv)
{
  Screen screen;

  screen.display();
  screen.display().set();

  const Screen cscreen;

  cscreen.display();
  cscreen.display().set();    // error for note-02
}

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is const member


  *cxx-remember* 
  A const member function 'must' have a form

    const T& () const;
    
  If it were written

  Screen& display() const
  { cout << "dis: this is const member" << endl; return *this; }

  then cause *cxx-const-to-non-const-error*


o Have one implementation for both const and non-const *cxx-const-cast*

From EC++03. Why need? If member function is big, code duplication. So implement
once and use it twice. Have one const implementation and nonconst version simply
calls const one.

Why this direction? If you were to call a nonconst from a const, would run the
risk that that object you'd promised not to modify would be changed. 

class TextBlock {
  const char& operator[]( std::szie_t position ) const 
  {
    ...
    return text[position];
  }

  char& operator[]( std::size_t position )
  {
    // Use static_cast to set const and const_cast `to remove const`

    return const_cast<char&> ( static_cast<const TextBlock&>(*this)[position] );
  }
};

From CPR 233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
  return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
  auto &r = shorterString(const_cast<`const` string&>(s1), 
                          const_cast<`const` string&>(s2));

  return const_cast< string& >(r);
}

This is safe to cast the const string back to a plain string and return it
because it is one of original non-const arguments.


o Change the order

myscreen.set_set(10).display();
const_screen.display();


{cxx-const-to-non-const-error}

<ex>
Screen& display() `const` { return *this;}

test.cpp: In member function 'Screen& Screen::display() const':
test.cpp:14:58: error: invalid initialisation of reference of type 'Screen&'
from expression of type 'const Screen'

<ex>
ThreadedDispatcher(int priority, std::string &name = std::string());

<ex>

// not okay.
void _do_work(std::string &name, int priority);

// okay
void _do_work(std::string const &name, int priority);

ThreadedDispatcher::ThreadedDispatcher(int priority, std::string const &name)
  : _running(true) 
  , _t(std::thread(&ThreadedDispatcher::_do_work, this, name, priority))
{}

cause cryptic errors:

// In file included from /usr/include/c++/6/memory:79:0,
//                  from cxx_pattern.cpp:4:
// /usr/include/c++/6/functional: In instantiation of ‘struct std::_Bind_simple<std::_Mem_fn<void (cxx_pattern_dispatcher::ThreadedDispatcher::*)(std::__cxx11::basic_string<char>&, int)>(cxx_pattern_dispatcher::ThreadedDispatcher*, std::__cxx11::basic_string<char>, int)>’:
// /usr/include/c++/6/thread:138:26:   required from ‘std::thread::thread(_Callable&&, _Args&& ...) [with _Callable = void (cxx_pattern_dispatcher::ThreadedDispatcher::*)(std::__cxx11::basic_string<char>&, int); _Args = {cxx_pattern_dispatcher::ThreadedDispatcher*, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, int&}]’
// cxx_pattern.cpp:1652:75:   required from here
// /usr/include/c++/6/functional:1365:61: error: no type named ‘type’ in ‘class std::result_of<std::_Mem_fn<void (cxx_pattern_dispatcher::ThreadedDispatcher::*)(std::__cxx11::basic_string<char>&, int)>(cxx_pattern_dispatcher::ThreadedDispatcher*, std::__cxx11::basic_string<char>, int)>’
//        typedef typename result_of<_Callable(_Args...)>::type result_type;
//                                                              ^~~~~~~~~~~
// /usr/include/c++/6/functional:1386:9: error: no type named ‘type’ in ‘class std::result_of<std::_Mem_fn<void (cxx_pattern_dispatcher::ThreadedDispatcher::*)(std::__cxx11::basic_string<char>&, int)>(cxx_pattern_dispatcher::ThreadedDispatcher*, std::__cxx11::basic_string<char>, int)>’
//          _M_invoke(_Index_tuple<_Indices...>)
         ^~~~~~~~~

This causes `const-to-non-const` conversion *cxx-const-error-const*

So *cxx-const-member* 'must' have this form since const applies to this
pointer: 


when do not have const set(), then causes an error since set is nonconst
version

    void set() const
    { cout << "set: this is const member" << endl; }

cscreen.display().set();

test.cpp: In function 'int main(int, char**)':
test.cpp:32:24: error: passing 'const Screen' as 'this' argument of 'void
Screen::set()' discards qualifiers [-fpermissive]


when remove const return and function do not return *this.  The const
display() returns non-const as 'declared' since no comiple error and works. 

Screen& display() const                           // not "const Screen& () const"
{ cout << "dis: this is const member" << endl; }  // do not return *this

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is non-const member           // see

*cxx-remember*
The point is that the const member func has always this form when use return.
Why? see bitwise-const for more. This matters only when returns reference but
not a copy.

const T func( ... ) const // OK
T func( ... ) const       // NO 


{cxx-const-in-func-definition}
Must use 'const' for both.

: error: prototype for 'bool Stack::empty()' does not match any in class 'Stack'
: error: candidate is: bool Stack::empty() const

class Stack {
  ...
  bool empty() `const`;
  ...
};

bool Stack::empty() `const` 
{
  ...
}


={============================================================================
*kt_dev_cxx_0000* cxx-const-member-variable

As with this case, const member string varible causes copy opeation deleted
and compile error when trying to use copy expression. The same error as
"because the default definition would be ill-formed:"

// represent a person
class Contact
{
  public:
    Contact() {}
    Contact(const std::string &name, const std::string &phone)
      :name_(name)
    {
      SetPhone(phone);
    }

    void SetPhone(const std::string &phone)
    {
      static std::regex pattern{"\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}"};
      // to verify that phone has the form (ddd)ddd-dddd
      // if (!std::regex_match(phone, pattern))
      //   throw std::runtime_error(std::string("bad phone number:") + phone);

      phone_ = phone;
    }

  private:
    std::string name_;
    std::string phone_;
    const std::string pattern{"\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}"};
};


={============================================================================
*kt_dev_cxx_0000* cxx-const-bitwise

{bitwise-const} physical constness
From EC++03. bitwise-const(physical const) is C++'s definition and compiler
only catches assignment to member data which is read-only. 

note: these are compiler errors at build time even if a user not use a member
function which causes an error.

<ex>

Error_code Stack::top(Stack_entry &item) const
{
  else
    item = entry[count--];   // ERROR since count is member

  return outcome;
}

:53:21: error: decrement of member 'Stack::count' in read-only 'object'


<ex>

int cube(const int& num)
{
  num = num * num;   // ERROR
  return num;
}

:22:14: error: assignment of read-only reference 'num'


<ex>

#include <iostream>

using namespace std;

class Sample {
  public:
    Sample(const char* str) : text(str) {}

    // read-only assignment error
    // : In function ‘int main(int, char**)’:
    // :25:11: error: assignment of read-only 'location' ‘sam.Sample::operator[](1u)’

    const char& operator[] (std::size_t pos) const
    { return text[pos]; }

    // *cpp-const-to-nonconst* error
    // 11:22: error: invalid initialization of reference of type ‘char&’ 
    //   from expression of type ‘const char’

    char& operator[] (std::size_t pos) const
    { return text[pos]; }

  private:
    std::string text;
};

int main(int argc, char** argv)
{
  Sample sam("CONSTMEMEBER");

  std::cout << sam[1] << endl;

  sam[1] = 'X';                  // error
}


<ex> when changed to use pointer instead

#include <iostream>

using namespace std;

class Sample {
  public:
    Sample(const char* str) : ptext(new std::string(str)) {}

    // As with the above, emits read-only assignment error.
    const char& operator[] (std::size_t pos) const
    { return (*ptext)[pos]; }

    // NO error and can change the value
    char& operator[] (std::size_t pos) const
    { return (*ptext)[pos]; }

    ~Sample() { delete ptext; }

  private:
    std::string* ptext;
};

int main(int argc, char** argv)
{
  Sample sam("CONSTMEMEBER");

  std::cout << sam[1] << endl;
  sam[1] = 'X';                  // no error and can chage the value
  std::cout << sam[1] << endl;
}

No compile errors because 'indirect' use of an object (outside of an object)
can avoid C++'s const check called bitwise-const. Since do not make changes to
*this, member, pointer in this case, so compiler do not complain. This means
const member func can change object state. Break encapsulation.


<solution-one>
From EC++28. this form fix this problem as below since not able to modify via
this call. However, 'dangling' handles problem still remains since it returns
reference to internal member such as reading it which is already gone.

Therefore, recommend to use const T(...) const form as a 'default'.

const char& operator[] (std::size_t pos) const


<solution-two>
Use *cpp-const-logical*


={============================================================================
*kt_dev_cxx_0000* cxx-const-logical

<ex>
EC++03. Hence logical-const. This is an example to cache the length whenever
it is requested. cache textLength. Although it changes its member, it
maintains logical constness as it updates length to cache purpose. 

class CTextBlock {
  public:
    std::size_t length() const;

  private:
    char* pText;
    mutable std::size_t textLength;    // mutable
    mutable bool lengthIsValid;        // mutable
};

Last calculated length of textblock

std::size_t CTextBlock::length() const
{
  if( !lengthIsValid )
  {
    textLength = std::strlen( pText );
    lengthIsValid = true;
  }

  return textLength;
}


<ex> cxx-lazy-initialization

// from Singleton discussion

class Singleton {
  public:
    // single point of access
    // *cxx-lazy-initialisation* means that do not create instance 
    // until its first access.
    static Singleton* Instance()
    {
      if(_instance==0) {
        _instance = new Singleton;
      }
      return _instance;
    }

    // <no-user-creation>
    // shall be an implementation since gets created in Instance() anyway.
    // <Q> why not private?
  protected:
    Singleton() {};

    // can have different concrete classes in different hierachy
  private:
    'static' Singleton* _instance;
};


={============================================================================
*kt_dev_cxx_0000* cxx-const-mutable cxx-mutable

To make member data writable from a const member func. A mutable data member is
never const even when it is a member of a const object.

class T {
  public:
    void some_member() const;

  private:
    'mutable' size_t access_ctr;
};

<usecase>
* in debug, to count the number of calls for a member func.
* to use logical constness
* to use lock as a mutable member. seems useful.
* see {lazy-fetching} in *kt_dev_mecpp_002* 

All these cases are about 'logical' constness and the snippet from online:

A mutable variable could be used for example for tracking lifetime of an
object and regularly prints a log of its internal state. In this case, nothing
changes for the object from the external point of view, but some thing in its
internal state changes. This does not contradict to promise to not modify the
object, because in this case, const can be seen as "I promise to my user that
this operation will not modify any visible state / information he could
access". 

Why logical? Since do it in ways that clients cannot detect or that maintain
constness in terms of logic. 


<ex>
When use the mix of C and C++, face an build error when builds C++ source.

SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
...
  source = _determineSource(in, &sourcelen, &inIndex, &usePath);
}

const char* _determineSource(const char* in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');      // C++ version
  ...
}


Session.cpp:876:23: error: invalid conversion from 'const char*' to 'char*'

Looked at the strchr man page and it says:

NAME
       strchr, strrchr, strchrnul - locate character in string

SYNOPSIS
       #include <string.h>

       char *strchr(const char *s, int c);
       

What? What's going on here?! Found that from glibc string.h


/* Find the first occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO            // IF
extern "C++"
{
extern char *strchr (char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
extern __const char *strchr (__const char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strchr (char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}

__extern_always_inline __const char *
strchr (__const char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}
# endif
}
#else                                              // ELSE for C
extern char *strchr (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif

That says that will use non-const version for C++ build and const version for C.
So:

SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
  ...
  source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);    <DN>
}

const char* _determineSource(`char* in`, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');
  ...
}


={============================================================================
*kt_dev_cxx_0000* cxx-const-read-logical-state

https://isocpp.org/wiki/faq/const-correctness#logical-vs-physical-state

How can it help me design better classes if I distinguish logical state from
physical state?  

Because that encourages you to design your classes from the outside-in rather
than from the inside-out, which in turn makes your classes and objects easier to
understand and use, more intuitive, less error prone, and faster. (Okay, that’s
    a slight over-simplification. To understand all the if’s and’s and but’s,
    you’ll just have to read the rest of this answer!)

Let’s understand this from the inside-out — you will (should) design your
classes from the outside-in, but if you’re new to this concept, it’s easier to
understand from the inside-out.

On the inside, your objects have physical (or concrete or bitwise) state. This
is the state that’s easy for programmers to see and understand; it’s the state
that would be there if the class were just a C-style struct.

On the outside, your objects have users of your class, and these users are
restricted to using only public member functions and friends. These external
users also perceive the object as having state, for example, if the object is of
class Rectangle with methods width(), height() and area(), your users would say
that those three are all part of the object’s logical (or abstract or
    meaningwise) state. To an external user, the Rectangle object actually has
an area, even if that area is computed on the fly (e.g., if the area() method
    returns the product of the object’s width and height). In fact, and this is
the important point, your users don’t know and don’t care how you implement any
of these methods; your users still perceive, from their perspective, that your
object logically has a meaningwise state of width, height, and area.

note:
Even if there is no 'area' member data in a class, user assumes that and this is
logical state.

The area() example shows a case where the logical state can contain elements
that are not directly realized in the physical state. The opposite is also true:
classes sometimes intentionally hide part of their objects’ physical (concrete,
    bitwise) state from users — they intentionally do not provide any public
member functions or friends that would allow users to read or write or even know
about this hidden state. That means there are bits in the object’s physical
state that have no corresponding elements in the object’s logical state.

As an example of this latter case, a collection-object might 'cache' its last
lookup in hopes of improving the performance of its next lookup. This cache is
certainly part of the object’s physical state, but there it is an internal
implementation detail that will probably not be exposed to users - it will
probably 'not' be part of the object’s logical state. Telling what’s what is
easy if you think from the outside-in: if the collection-object’s users have no
way to check the state of the cache itself, then the cache is transparent, and
is not part of the object’s logical state.


https://isocpp.org/wiki/faq/const-correctness#logical-vs-physical-state

Should the constness of my public member functions be based on what the method
does to the object’s logical state, or physical state?  

Logical.

There’s no way to make this next part easy. It is going to hurt. Best
recommendation is to sit down. And please, for your safety, make sure there are
no sharp implements nearby.

Let’s go back to the collection-object example. Remember: there’s a lookup
method that caches the last lookup in hopes to speed up future lookups.

Let’s state what is probably obvious: assume that the lookup method makes no
changes to any of the collection-object’s logical state.

So... the time has come to hurt you. Are you ready?

Here comes: if the lookup method does not make any change to any of the
collection-object’s logical state, but it does change the collection-object’s
physical state (it makes a very real change to the very real cache), should the
lookup method be const?

The answer is a resounding Yes. (There are exceptions to every rule, so “Yes”
    should really have an asterisk next to it, but the vast majority of the
    time, the answer is Yes.)

This is all about “logical const” over “physical const.” It means the decision
about whether to decorate a method with const should hinge primarily on whether
that method leaves the logical state unchanged, irrespective (are you sitting
    down?) (you might want to sit down) irrespective of whether the method
happens to make very real changes to the object’s very real physical state.

In case that didn’t sink in, or in case you are not yet in pain, let’s tease it
apart into two cases:

    If a method changes any part of the object’s logical state, it logically is
    a mutator; it should not be const even if (as actually happens!) the method
    doesn’t change any physical bits of the object’s concrete state.

    Conversely, a method is logically an inspector and should be const if it
    never changes any part of the object’s logical state, even if (as actually
        happens!) the method changes physical bits of the object’s concrete
    state.

If you’re confused, read it again.

If you’re not confused but are angry, good: you may not like it yet, but at
least you understand it. Take a deep breath and repeat after me: “The constness
of a method should makes sense from outside the object.”

If you’re still angry, repeat this three times: “The constness of a method must
make sense to the object’s users, and those users can see only the object’s
logical state.”

If you’re still angry, sorry, it is what it is. Suck it up and live with it.
Yes, there will be exceptions; every rule has them. But as a rule, in the main,
this logical const notion is good for you and good for your software.

One more thing. This is going to get inane, but let’s be precise about whether a
method changes the object’s logical state. If you are outside the class - you
are a normal user, every experiment you could perform (every method or sequence
    of methods you call) would have the same results (same return values, same
      exceptions or lack of exceptions) irrespective of whether you first called
    that lookup method. If the lookup function changed any future behavior of
    any future method (not just making it faster but changed the outcome,
        changed the return value, changed the exception), then the lookup method
    changed the object’s logical state - it is a mutuator. But if the lookup
    method changed nothing other than perhaps making some things faster, then it
    is an inspector.


={============================================================================
*kt_dev_cxx_0000* cxx-const-read-const-correctness

http://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/

1. What is a "shared variable"?

A "shared variable" is one that could be accessed from more than one thread at
the same time.

This concept is important in the C++ memory model. For example, the C++ memory
model (the core of which is described in ISO C++ §1.10) prohibits the invention
of a write to a "potentially shared memory location" that would not have been
written to in a sequentially consistent execution of the program, and the C++
standard library refers to this section when it prohibits "modify[ing] objects
accessible by [other] threads" 'through' a const function, as we will see in #2.


2. What do const and mutable mean on shared variables?

Starting with C++11, const on a variable that is possibly shared means
"read-only or as good as read-only" for the purposes of concurrency. Concurrent
const operations on the same object are required to be safe without the calling
code doing external synchronization.

If you are implementing a type, unless you know objects of the type can never be
shared (which is generally impossible), this means that each of your
`const-member-functions` must be either:

    truly physically/bitwise const with respect to this object, meaning that
    they perform no writes to the object's data; or else

    internally synchronized so that if it does perform any actual writes to the
    object's data, that data is correctly protected with a mutex or equivalent
    (or if appropriate are atomic<>) so that any possible concurrent const
    accesses by multiple callers can't tell the difference.

Types that do not respect this cannot be used with the standard library, which
requires that:

    "... to prevent data races (1.10). ... [a] C++ standard library function
    shall not directly or indirectly modify objects (1.10) accessible by threads
    other than the current thread unless the objects are accessed directly or
    indirectly via the function's *non-const* arguments, including this."-ISO C++
    §17.6.5.9

    note: that is, shall not modify if the objects are accessed via const


Similarly, writing `mutable` on a member variable means what it has always
meant: The variable is "writable but `logically-const`." Note what this implies:

    The "logically const" part now means "can be used safely by multiple
    concurrent const operations." The "mutable" and "writable" part further
    means that some const operations may actually be writers of the shared
    variable, which means it's inherently got to be correct to read and write
    concurrently, so it should be protected with a mutex or similar, or made
    atomic<>.

In general, remember:

    Guideline: Remember the "M&M rule": For a member variable, mutable and mutex
    (or atomic) `go-together`.

This applies in both directions, to wit:

    (1) For a member variable, mutable implies mutex (or equivalent): 

    A mutable member variable is presumed to be a mutable shared variable and so
    must be synchronized internally-protected with a mutex, made atomic, or
    similar.

    (2) For a member variable, mutex (or similar synchronization type) implies
    mutable: 

    A member variable that is itself of a synchronization type, such as a mutex
    or a condition variable, naturally wants to be mutable, because you will
    want to use it in a non-const way (e.g., take a std::lock_guard<mutex>)
    inside concurrent const member functions.

We'll see an example of (2) in Part 2, GotW #6b.


3. How are const and mutable different in C++98 and C++11?

First, let's be clear: C++98 single-threaded code still works. 

C++11 has excellent C++98 compatibility, and even though the meaning of const
has evolved, C++98 single-threaded code that uses the old "logically const"
meaning of const is still valid.

With C++98, we taught a generation of C++ developers that "const means logically
const, not physically/bitwise const." That is, in C++98 we taught that const
meant only that the observable state of the object (say, via its non-private
    member functions) should not change as far as the caller could tell, but its
internal bits might change in order to update counters and instrumentation and
other data not accessible via the type's public or protected interface.

That definition is 'not' sufficient for concurrency. With C++11 and onward, which
now includes a concurrency memory model and thread safety specification for the
standard library, this is now much simpler: 

const now really does mean "read-only, or safe to read concurrently"-either
truly physically/bitwise const, or internally synchronized so that any actual
writes are synchronized with any possible concurrent const accesses so the
callers can't tell the difference.

Although existing C++98-era types still work just fine in C++98-era
single-threaded code for compatibility, those types and any new ones you write
today should obey the new stricter requirement if they could be used on multiple
threads. 

The good news is that most existing types already followed that rule, and code
that relies on casting away const and/or using mutable data members in
single-threaded code has already been generally questionable and relatively
rare.  
        
Summary

Don't shoot yourself (or your fellow programmers) in the foot. Write
const-correct code.

Using const consistently is simply necessary for correctly-synchronized code.
That by itself is ample reason to be consistently const-correct, but there's
more: 

It lets you document interfaces and invariants far more effectively than any
mere /* I promise not to change this */ comment can accomplish. It's a powerful
part of `design-by-contract` 

It helps the compiler to stop you from accidentally writing bad code. It can
even help the compiler generate tighter, faster, smaller code. That being the
case, there's no reason why you shouldn't use it as much as possible, and every
reason why you should.

Remember that the correct use of mutable is a key part of const-correctness. If
your class contains a member that could change even for const objects and
operations, make that member mutable and protect it with a mutex or make it
atomic. That way, you will be able to write your class' const member functions
easily and correctly, and users of your class will be able to correctly create
and use const and non-const objects of your class' type.

It's true that not all commercial libraries' interfaces are const-correct. That
isn't an excuse for you to write const-incorrect code, though. 

It is, however, one of the few good excuses to write const_cast, plus a detailed
comment nearby grumbling about the library vendor's laziness and how you're
looking for a replacement product.


={============================================================================
*kt_dev_cxx_0000* cxx-const-read-correctness

EXPC++ 43

Problem: In the following code, `add or remove const` (including minor
    variants and related keywords) wherever appropriate. Note: Don't comment
on or change the structure of this program. It's contrived and condensed for
illustration only.

For bonus points: In what places are the program's results undefined or
uncompilable due to const errors?

class polygon {
public:
    polygon() : area{-1} {}

    void add_point( const point pt ) { area = -1;
                                       points.push_back(pt); }

    point get_point( const int i ) { return points[i]; }

    int get_num_points() { return points.size(); }

    double get_area() {
        if( area < 0 )   // if not yet calculated and cached
            calc_area();     // calculate now
        return area;
    }

private:
    void calc_area() {
        area = 0;
        vector<point>::iterator i;
        for( i = begin(points); i != end(points); ++i )
            area += /* some work using *i */;
    }

    vector<point> points;
    double        area;
};

polygon operator+( polygon& lhs, polygon& rhs ) {
    auto ret = lhs;
    auto last = rhs.get_num_points();
    for( auto i = 0; i < last; ++i ) // concatenate
        ret.add_point( rhs.get_point(i) );
    return ret;
}

void f( const polygon& poly ) {
    const_cast<polygon&>(poly).add_point( {0,0} );
}

void g( polygon& const poly ) { poly.add_point( {1,1} ); }

void h( polygon* const poly ) { poly->add_point( {2,2} ); }

int main() {
    polygon poly;
    const polygon cpoly;

    f(poly);
    f(cpoly);
    g(poly);
    h(&poly);
}


<solution>

When I pose this kind of problem, I find that most people think the problem is
on the easy side and address only the more-usual const issues. There are,
   however, subtleties that are worth knowing, and hence this Item.

1. The point object is passed by value, so there is little benefit to
declaring it const.

    void  add_point( const point pt )

In this particular case, because the function is `defined-inline`, the const
value parameter can make sense. This is because for inline functions the
declaration and definition are the same. Otherwise, const value parameters
should appear only on the definition, not on the declaration. Let's see why.

Putting the const on a 'value' parameter in a function declaration is
irrelevant outside the function; it makes no difference to the caller and can
only confuse readers. 

To the compiler, the function signature is the 'same' whether you include this
const in front of a value parameter or not. For example:

// see *cxx-const-overload*
// `value-parameter`: `top-level-const` is not part of function signature
int f( int );
int f( const int );    // redeclares f(int): this is the same function

// `nonvalue-parameter`: `top-level-const` is part of function signature
int g( int& );
int g( const int& );   // overloads g(int&): these are two functions

But putting the const on the value parameter does make a difference to how it
can be used 'inside' the function's actual definition. Remember that, inside a
function, the parameters are just the 'first' set of local variables, so
putting a const on a value parameter simply means that the function can't
modify its local variable, which only happens to be a parameter. Here's an
example that declares and then defines the same function f:

int f( int );          // declaration: no const

int f( const int i ) { // definition: use const to express "read-only"

    vector<int> v;
    v.push_back(i);    // ok, only reads from i

    i = 42;            // error, attempts to modify i

}

  Guideline: Consider not writing const on `pass-by-value` function parameters
  when only forward-declaring a function. You can always add it on the
  `definition` to express a read-only parameter.


2. get_point and get_num_points should be `cxx-const-member-function`

    point get_point( const int i ) { return points[i]; }

    int   get_num_points() { return points.size(); }

These functions should be marked const, because they don't change the state of
the object.


3. get_area should be `const-member-function`

    double get_area() {
        if( area < 0 )        // if not yet calculated and cached
            calc_area();      // calculate now
        return area;
    }

Even though this function modifies the object's internal state, we should
consider making it const. Why? Because this function does not modify the
object's `observable-state`; we are doing some caching here, but that's an
internal implementation detail and the object is *cxx-const-logical* even if
it isn't physically const.


4. Therefore calc_area should also be `const-member-function`

    void calc_area() {
        area = 0;
        vector<point>::iterator i;
        for( i = begin(points); i != end(points); ++i )
            area += /* some work using *i */;
    }

Once we make get_area be const, this private helper function 'ought' also to
be const.

In turn, once you make this function const, the compiler will tell you that
you also need to do something about the member variable area, which should be:

    mutable, so that it's writable in a const member function; and

    synchronized using a mutex or made atomic<>, so that it's
    concurrency-safe, as discussed in GotW #6a.


5. Also, calc_area should use a const_iterator.

The iterator should not change the state of the points collection, and so it
ought to be a const_iterator. We're now 'forced' to make this change anyway if
we're making calc_area be a const member function, but 

note that if we had said auto for the iterator's type we wouldn't have had to
make any change at all.

While we're at it, the for loop inside calc_area: It should prefer to use the
range-based for loop, as well as auto.

Combining all that, we get this simpler and const-correct code:

      for( auto& pt : points )
          area += /* some work using pt */;

    Guideline: Prefer declaring variables using auto.

    Guideline: Prefer range-based for loops to naked iterator-incrementing for
    loops when visiting the elements of the range in order.


6. area should be `mutable` and synchronized.

    double        area;

As noted already, in conjunction with the other changes the internal cache
variable will area now want to be mutable so that it can be used correctly and
safely inside const member functions, and because it is now a shared variable
potentially used by multiple concurrent const operations it must also be
synchronized—protected with a mutex or made atomic.

Bonus Question: Before reading on, which should it be: Protected by a mutex? or
made atomic<double>?

Have you thought about it? All right, let's continue

Both work, but a mutex is usually 'overkill' for a single variable.

Option 1 is to use a mutex in the perhaps-soon-to-be-canonical "mutable mutex
mutables" pattern:

// Option 1: Use a mutex  *cxx-mutable*

    double get_area() const {
        auto lock = unique_lock<mutex>{mutables};
        if( area < 0 )    // if not yet calculated and cached
            calc_area();  // calculate now
        return area;
    }

private:
    // ...
    mutable mutex  mutables;      // canonical pattern: mutex that
    mutable double area;          // covers all mutable members

Option 1 generalizes well if you add more data members in the future. However,
       it's also more invasive and generalizes less well if you add more const
       member functions in the future that use area, because they will all
       have to remember to acquire a lock on the mutex before using area.

Option 2 is to just change double to mutable atomic<double>. 

    mutable atomic<double> area; 

This is attractive because the "mutable part" of polygon is just a single
variable. That can work, but you have to be careful because that's not the
only necessary change, for two reasons:

    The minor reason is that atomic<double> doesn't support +=, so if we only
    change area's 'type' then calc_area will no longer compile. That can be
    worked around, but leads us to the major reason...

    The major reason is that, because calc_area is a `compound-operation` and
    must be safe to run on multiple threads concurrently, we must restructure
    calc_area to be safe to run concurrently. In particular it should not
    perform intermediate updates to area, and should ensure that multiple
    competing concurrent updates to area don't cause overwrites that lose
    written values.

There are several ways to do it, but the simplest is probably to allow benign
redundant recalculations in the case of concurrent calls to calc_area, on the
grounds that it's probably no worse than blocking the concurrent calls which
would have to wait anyway.

// Option 2: Use an atomic

    // void calc_area() {
    //     area = 0;
    //     vector<point>::iterator i;
    //     for( i = begin(points); i != end(points); ++i )
    //         area += /* some work using *i */;
    // }

    void calc_area() const {
        auto tmp = 0.0;              // do all the work off to the side
        for( auto& pt : points )
            tmp += /* some work using pt */;
        area = tmp;                  // then commit with a `single-write`
    }

private:
    // ...
    mutable atomic<double> area;

Notice that concurrent const operations that call to calc_area can still
overlap and overwrite each other's results, but that's benign because they're
concurrent const operations so they will all calculate the 'same' value. 

Also, concurrent calc_area calls use the shared points variable in a loop
which should make us mentally check that it doesn't cause cache contention,
      but `because they're all readers` it won't and so this too is fine.

note: "tmp" is local to a thread in thread stack


7. operator+'s `rhs` parameter should be a `reference-to-const`.

polygon operator+( polygon& lhs, polygon& rhs );

The rhs parameter should be passed by reference to const, of course.

    Guideline: Prefer passing a read-only parameter by const& if you are only
    going `to read from it (not make a copy of it).`

"But wait!" I can just hear some of you saying, "you forgot about lhs! Shouldn't
it be const& too?" Actually, not so much:


8. operator+'s `lhs` parameter should be `passed-by-value`.

The key point is that we're going to copy from it anyway, in this case
immediately: *cxx-copy-ctor*

    auto ret = lhs;

When you're in the `special` case of "read-only parameter that you're going to
  take copy of anyway," there are several ways to accept the parameter, which
  I'll cover in detail in another GotW. For now, suffice it to say that
  usually you shouldn't overthink these options, and just use pass-by-value as
  the simplest method, which offers some advantages that we also touched on in
  GotW #4:

    If the caller passes a named polygon object (an lvalue), there's no
    difference. Both pass-by-const& followed by an explicit copy and
    pass-by-value will perform 'one' copy.

    If the caller passes a temporary polygon object (an rvalue), the compiler
    automatically move-constructs lhs from that, which probably makes no
    difference for a small type like polygon but can be considerably cheaper for
    many types.

    Guideline: Prefer passing a read-only parameter by value 
    `if you're going to make a copy` of the parameter anyway, because it
    enables move from rvalue arguments.


9. Also in operator+, last should be const.

    auto last = rhs.get_num_points();
    for( auto i = 0; i < last; ++i ) // concatenate
        ret.add_point( rhs.get_point(i) );
    return ret;
}

Since last should never change, prefer to say so by making it const.

    Guideline: Prefer to make variables, including locals, const if they
    should not change.

Incidentally, notice that once we make rhs a reference-to-const parameter as
noted above, we see another reason why get_point should be a const member
function.


10. f's const_cast may give `undefined` behavior, and is morally wrong anyway.

void f( const polygon& poly ) {
    const_cast<polygon&>(poly).add_point( {0,0} );
}

Bonus: The result of the const_cast is undefined if the referenced object was
declared as const-the case of f(cpoly) below. *cxx-const-undefined*

The parameter isn't really const, so don't declare it as const and then try to
modify it anyway. Lying to the compiler, never mind to the caller, is a bad
idea, never mind morally reprehensible in most value systems.


11. g's const is illegal and useless.

void g( polygon& const poly ) { poly.add_point( {1,1} ); }

This const is illegal; you can't apply const directly to the reference itself,
     besides which references are already const inasmuch as they cannot be
     reseated to refer to a different object.

note:     
void g( polygon& const poly ) { poly.add_point( {1,1} ); }

cause:
:51:24: error: ‘const’ qualifiers cannot be applied to ‘polygon&’

void g( const polygon& poly ) { poly.add_point( {1,1} ); }

cause:
:53:56: error: passing ‘const polygon’ as ‘this’ argument of ‘void
  polygon::add_point(point)’ discards qualifiers [-fpermissive]


void h( polygon* const poly ) { poly->add_point( {2,2} ); }

h's const merely ensures that h's body won't modify the pointer value.  This
is the same as the const value parameters in add_point and get_point, and
perfectly fine on the definition.


12. Examining the mainline.

int main() {
    polygon poly;
    const polygon cpoly;

    f(poly);

This is fine.

    f(cpoly);

As already noted, this causes undefined results when f tries to cast away the
  const-ness of its parameter and then modify it. *cxx-const-undefined*

    g(poly);

This is fine.

    h(&poly);
}

This is fine.


Summary

Here is a revised version of the code that corrects the const issues noted
above, but does not attempt to correct any other poor style. Note that because
of the atomic member, which is not copyable, we now provide polygon's copy and
move operations explicitly.

class polygon {
public:
    polygon() : area{-1} {}

    polygon( const polygon& other ) : points{other.points}, area{-1} { }

    polygon( polygon&& other ) 
        : points{move(other.points)}, area{other.area.load()}
        { other.area = -1; }

    polygon& operator=( const polygon& other )
        { points = other.points; area = -1; return *this; }

    polygon& operator=( polygon&& other ) {
        points = move(other.points);
        area = other.area.load();
        other.area = -1;
        return *this;
    }

    void add_point( point pt ) 
        { area = -1; points.push_back(pt); }

    point get_point( int i ) const { return points[i]; }

    int get_num_points() const { return points.size(); }

    double get_area() const {
        if( area < 0 )   // if not yet calculated and cached
            calc_area();     // calculate now
        return area;
    }

private:
    void calc_area() const {
        auto tmp = 0.0;
        for( auto& pt : points )
            tmp += /* some work using pt */;
        area = tmp;
    }

    vector<point>          points;
    mutable atomic<double> area;              // *cxx-mutable*
};

polygon operator+( polygon lhs, const polygon& rhs ) {
    const auto last = rhs.get_num_points();
    for( auto i = 0; i < last; ++i ) // concatenate
        lhs.add_point( rhs.get_point(i) );
    return lhs;
}

void f( polygon& poly ) { poly.add_point( {0,0} ); }

void g( polygon& poly ) { poly.add_point( {1,1} ); }

void h( polygon* poly ) { poly->add_point( {2,2} ); }

int main() {
    auto poly = polygon{};

    f(poly);
    g(poly);
    h(&poly);
}


={============================================================================
*kt_dev_cxx_0000* cxx-const-constexpr

Since *cxx-11* , constexpr can be used to enable that expressions be evaluated
at compile time.


={============================================================================
*kt_dev_cxx_0000* cxx-inline

EC++30 recommends to minimize use of inline.

good:

* Can avoid function call overhead

* Request to the compiler but not a command since the compiler may choose to
  ignore this request.

* EC++30 says that can have compiler optimisation on inlined code area.

bad: as with macro, inline has cost:

* bigger size and performance penalty which can cause additional paging and
  reduced instruction cache hit.

* impossible to provide binary upgrades. Force client to compile than to
  relink. Think when changes inline func. All clients should be recompiled.

* problem with debugger.

* A compiler refuse to inline function that has calls to 'virtual' funcs
  because cannot know it at compile time.


<cxx-ctor-empty-ctor>
ctor and dtor may be 'worse' candiate for inline. Why? There are codes written
by compilers and inserted into program during compilation for construction,
destruction, exception handling during those, new and delete, and so forth.

These are up to compiler implementation. So empty ctor can have followings:

class Derived: public Base {
  public:
    Derived() {}              // is it really empty?
    ...
  private:
    std::string dm1, dm2, dm3;
};

Derived::Derived()
{
  Base::Base();

  try{ dm1.std::string::string(); }
  catch(...) {
    Base::~Base();
    throw;
  }

  try{ dm2.std::string::string(); }
  catch(...) {
    dm1.std::string::~string();
    Base::~Base();
    throw;
  }

  try{ dm3.std::string::string(); }
  catch(...) {
    dm1.std::string::~string();
    dm2.std::string::~string();
    Base::~Base();
    throw;
  }
}

This is unrepresentative of what real compiler emit but do what ctor must
offer. When think ctors of base class, class members, not attractive for
inlining. 

Initially don't inline anything, or at least limit your inlining to those
functions that must be inline. Employ inlines cautiously including templates
functions. Think about 80-20 rule and may use profiler to find out 20% as a
candidate for inlining.


={============================================================================
*kt_dev_cxx_0000* cxx-auto

{auto-specifier}
When initialize it from a expression, have to know the type of that expression
and can be difficult.

Under new standard, let the compiler figure out the type by using auto type
specifier and by deducing the type from the initializer. so must have
initializer.

note: GCC 4.4.5 supports.

auto item = val1 + val2;

double salePrice = applyDiscout( price, discount );


{auto-and-const}

const int ci = i, &cr = ci;

auto b = ci;      // b is int
auto c = cr;      // c is int
auto d = &i;      // d is int*
auto e = &ci;     // e is const int*

auto figures out type and also initialize. So copy initialize do not affect
constness but the last does affect so have const in its deduced type.

<ex> to use reference
  for(const auto& e: vint)
  {
    ...
  }


<ex>
template<typename T>
int countUnique(const T &s)
{
    T chars;

    // okay
    for (auto it = s.cbegin(); it != s.cend(); ++it)
    {
    }
        
    // *cxx-const* error on "++it" since it itself is const see cxx-range-for
    for (const auto it = s.begin(); it != s.end(); ++it)
    {
        if (chars.find(*it) == T::npos)
            chars += *it;
    }

    // *cxx-range-for*
    for (const auto e : chars)
    {
        if (chars.find(e) == T::npos)
            chars += e;
    }

    return chars.size();
}


={============================================================================
*kt_dev_cxx_0000* cxx-decltype cxx-typedef cxx-struct {class-vs-struct} 

Want to have a `type deduced without defining an initialized variable.` Return
the type of expression but do not 'evaluate' it, that is, do not call
expression.

string s("...");
decltype( s.size() ) count = 0;

<ex>

static bool compare(std::shared_ptr<Quote> const lhs, std::shared_ptr<Quote> const rhs)
{
  return lhs->isbn() < rhs->isbn();
}

// error
decltype(compare) comp;

// okay
using comp = 
  bool(std::shared_ptr<Quote> const lhs, std::shared_ptr<Quote> const rhs);


<when-decltype-return-reference-type> to get reference type of expression
The decltype return reference type when expression yields objects that is
lvalue, that can stand on the left hand side of assignment.

int i = 42, *p = &i, &r = i;

decltype( r + 0 ) b;          // int b
decltype( *p ) c;             // int& c; error.

The decltype of a parenthesized variable is always a reference.

decltype((i)) d;              // int& d; error.
decltype(i) e;                // int e;

The side effect when decltype returns a reference is that variable must be
initialized as usual reference variable does.


<typeof-and-decltype>
The cxx-typeof is gcc one and cxx-decltype is C++.

The problem is:

std::vector<typeof(k)> myVec;
    
C++0x standard introduces an alternative called 'decltype', which can be used
to replace uses of typeof. Unfortunately, in some more complex use cases when
deduced types are used as parameters for templates resolving into types
declared as 'constexpr', use of typeof() triggers a compile-error.

note: decltype usage. decltype is used to get type for template. solution was
to have #define to use decltype only for C++0x but typeof for before C++0x.


{cxx-struct-and-typedef}
The structure is declared like this. No space allocated since it is
declaration.

// As with class, see terminating ";".

struct point {
  int x;
  int y;
};


Here point is that `structure tag` defines a `type`. So defining structure
objects is analogous to defining objects of any type.

"struct { ... } x, y, z;" is analogus to "int x, y, z;"

`Why tag?` The tag can be used later in definition of instances of the structure
since cannot use the above later. Given the declaration above:

struct point pt = { 320, 200 };

The only legal operation on structure are copy and assign as a unit but not
compare.

*cxx-typedef* From ansic, p146.
The typedef creates a `new data type name` and does not create a `new type` in
any sense; merely adds a `new name for some existing type.` In effect, typedef
is like #define, except that it is interpreted by the compiler.

struct point top;               // without using typedef
struct point bot;

typedef struct point point;
point top;                      // now use `point` instead
point bot;


{cxx-struct-initialization}

typedef struct {
  int a;
  int b;
  int arr[2];
} NODE;

int main()
{
  // note: this warning happens due to -Wextra
  // : warning: missing initializer [-Wmissing-field-initializers]
  // : warning: (near initialization for 'node.arr') [-Wmissing-field-initializers]
  // NODE node = {0,0};

  NODE node = {0,0,{0,0}};

  return 0;
}

To avoid warning, may have {0} for a single element array

typedef struct {
  int a;
  int b;
  int arr[1];
  int c;
} NODE;

NODE node = {0,0,{0},0};


<ex> *cxx-struct-designated-initializers*

struct sd_bus_vtable {
        /* Please do not initialize this structure directly, use the
         * macros below instead */

        uint8_t type:8;
        uint64_t flags:56;
        union {
                struct {
                        size_t element_size;
                } start;
                struct {
                        const char *member;
                        const char *signature;
                        const char *result;
                        sd_bus_message_handler_t handler;
                        size_t offset;
                } method;
                struct {
                        const char *member;
                        const char *signature;
                } signal;
                struct {
                        const char *member;
                        const char *signature;
                        sd_bus_property_get_t get;
                        sd_bus_property_set_t set;
                        size_t offset;
                } property;
        } x;
};

#define SD_BUS_VTABLE_START(_flags)                                     \
        {                                                               \
                .type = _SD_BUS_VTABLE_START,                           \
                .flags = _flags,                                        \
                .x.start.element_size = sizeof(sd_bus_vtable),          \
        }

causes errors when compile it using GCC:

error: expected primary-expression before ‘.’ token
   SD_BUS_VTABLE_START(0),
   ^
error: expected primary-expression before ‘.’ token
   SD_BUS_METHOD("Multiply", "xx", "x", method_multiply, SD_BUS_VTABLE_UNPRIVILEGED),
   ^

https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html

6.29 Designated Initializers

Standard C90 requires the elements of an initializer to appear in a fixed
order, the same as the order of the elements in the array or structure being
initialized.

In ISO C99 you can give the elements `in any order`, specifying the array
indices or `structure field names they apply to`, and GNU C allows this as an
extension in C90 mode as well. `This extension is not implemented in GNU C++`

note that means C++ do not supports struct initialisation using field names

In a structure initializer, specify the name of a field to initialize with
‘.fieldname =’ before the element value. For example, given the following
structure,

struct point { int x, y; };

the following initialization

struct point p = { .y = yvalue, .x = xvalue };

is equivalent to

struct point p = { xvalue, yvalue };

To fix:

o Use `.c` but not `.cpp` to build.

o Use the macro which works for C and C++ as well.

#define SD_BUS_VTABLE_START(_flags)                                     \
        {                                                               \
                .type = _SD_BUS_VTABLE_START,                           \
                .flags = _flags,                                        \
                .x = {                                                  \
                    .start = {                                          \
                        .element_size = sizeof(sd_bus_vtable)           \
                    },                                                  \
                },                                                      \
        }

See Nested initialization
https://en.cppreference.com/w/c/language/struct_initialization


<ex>

struct view_class {
  const char *title;
  const char *style;
  Evas_Object *(*create)(struct viewmgr *vmgr);
  void (*update)(Evas_Object *base, Elm_Object_Item *it);
  void (*show)(Evas_Object *base, Elm_Object_Item *it);
  void (*hide)(Evas_Object *base, Elm_Object_Item *it);
  void (*resume)(Evas_Object *base, Elm_Object_Item *it);
  void (*pause)(Evas_Object *base, Elm_Object_Item *it);
  void (*terminate)(Evas_Object *base);
  int show_bg;
};                                                          

This is struct declaration and not a typedef. So need to use struct keyword to
create a object. All three examples below creates objects.

note: see use of comma for below examples to create a object.

static struct view_class _vclass = {   static struct view_class _vclass = {
  .title = NULL,                         NULL,                             
  .style = "homepanel/apps/1",           "homepanel/apps/1",               
  .create = _create,                     _create,                          
  .update = _update,                     _update,                          
  .show = _show,                         _show,                            
  .hide = _hide,                         _hide,                            
  .resume = _resume,                     _resume,                          
  .pause = _pause,                       _pause,                           
  .terminate = _terminate,               _terminate,                       
  .show_bg = 0,                          0,                                
};                                     };                                  

or

struct view_class {
  const char *title;
  const char *style;
  Evas_Object *(*create)(struct viewmgr *vmgr);
  void (*update)(Evas_Object *base, Elm_Object_Item *it);
  void (*show)(Evas_Object *base, Elm_Object_Item *it);
  void (*hide)(Evas_Object *base, Elm_Object_Item *it);
  void (*resume)(Evas_Object *base, Elm_Object_Item *it);
  void (*pause)(Evas_Object *base, Elm_Object_Item *it);
  void (*terminate)(Evas_Object *base);
  int show_bg;
} x = {
  NULL,
  "homepanel/apps/1",
  _create,
  _update,
  _show,
  _hide,
  _resume,
  _pause,
  _terminate,
  0,
};

If it was a typedef then would use like:

static view_class _vclass = {
  .title = NULL,
  .style = "homepanel/apps/1",
  .create = _create,
  .update = _update,
  .show = _show,
  .hide = _hide,
  .resume = _resume,
  .pause = _pause,
  .terminate = _terminate,
  .show_bg = 0,
};

<ex> creates a type name but not object. 
typedef struct tnode {
  char *word;
  int count;
  struct tnode* left;
  struct tnode* right;

  // note: <diff-between-c-and-cpp> error for C but okay for CPP since it is a
  // pointer and okay as long as not define object. To define object, compiler
  // may see whole definition.
  //
  // msort-list.c:7:3: error: unknown type name 'tnode' when use C.

  tnode* left;
  tnode* right;

} Treenode;

<ex> both creates a type name.
typedef struct tnode *Treeptr;

typedef struct tnode {
  char *word;
  int count;
  Treeptr left;
  Treeptr right;
} Treenode;


<ex>
typedef struct treenode TreeNode;

typedef struct treenode {
  TreeEntry entry;
  TreeNode  *left;
  TreeNode  *right;
} TreeNode;

or

typedef struct treenode {
  TreeEntry entry; 
  treenode  *left;
  treenode  *right;
} TreeNode;


<ex> <cxx-typedef-error>
note:
this is used to be okay for C but now fails on C++

struct List;         // 7

typedef struct node
{
  EntryType entry;
  node*     pnext;         // okay for CPP
  List*     plist;
} Node;

typedef struct {
   int   count;
   Node* header;
} List;              // 19

gen-list-linked.cpp:19:3: error: conflicting declaration ‘typedef struct List List’
gen-list-linked.cpp:7:8: error: ‘struct List’ has a previous declaration as ‘struct List’


<okay>
struct list;

typedef struct node
{
  EntryType entry;
  node*     pnext;
  list*     plist;
} Node;

typedef struct list {
  int    count;
  Node*  header;
} List;

OR

typedef struct list List;

typedef struct node
{
  EntryType entry;
  node*     pnext;
  List*     plist; or list* plist;
} Node;

typedef struct list {
  int    count;
  Node*  header;
} List;

<example> this is to create a pointer type name but not object.
typedef struct _fsm
{
  VRM_FSM_INIT  init;
  ...

} *FSM_T;

FSM_T new_fsm = 0;


{cxx-type-alias} <cxx-typedef>

typedef double wages;
using wages = double;         // *cxx-11* *cxx-using*

namespace cxx_typedef
{
  // defined here since cannot do in the block since:
  //
  // cxx.cpp:7062:3: error: a template declaration cannot appear at block scope

  template<typename Value>
    using mmap = map<unsigned int, Value>; 

} // namespace


TEST(Typedef, Alias)
{
  {
    // cannot be a const map since operator[] is for non-const.

    map<unsigned int, string> coll{ 
      {1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}
    };

    coll[3] = "threee";
    coll[3] = "threeee";
    coll[3] = "threeeee";
    coll[3] = "threeeeee";

    ASSERT_THAT(coll[3], Eq("threeeeee"));
  }

  {
    typedef map<unsigned int, string> mmap; 

    mmap coll{ 
      {1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}
    };

    coll[3] = "threee";
    coll[3] = "threeee";
    coll[3] = "threeeee";
    coll[3] = "threeeeee";

    ASSERT_THAT(coll[3], Eq("threeeeee"));
  }

  // this is cxx-type-alias

  {
    using mmap = map<unsigned int, string>; 

    mmap coll{ 
      {1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}
    };

    coll[3] = "threee";
    coll[3] = "threeee";
    coll[3] = "threeeee";
    coll[3] = "threeeeee";

    ASSERT_THAT(coll[3], Eq("threeeeee"));
  }

  // this is *cxx-template-alias*
  // The aliasing mechanism can be used to define a new template by binding some
  // or all template arguments.

  {
    using namespace cxx_typedef;

    mmap<std::string> coll{ 
      {1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}
    };

    coll[3] = "threee";
    coll[3] = "threeee";
    coll[3] = "threeeee";
    coll[3] = "threeeeee";

    ASSERT_THAT(coll[3], Eq("threeeeee"));
  }
}

note: can be suprising result when use alias with compound type and const

typedef char *pstring;
const pstring cstr = 0;       // do not interpret as "const char *pstring cstr"
const pstring *ps;

The cstr is "const pointer to char" but not "pointer to const char" since base
type is "char *" and const applies on base type.


<typedef-in-class>
Effectively, make alias to classA. Useful when class name changes. Seen in
Tizen code. typedef is just a 'synonym' for some type (from ESTL)

typedef classA classB;


<typedef-multiple>
Is it error to have multiple typedefs? No. See *kt_dev_gcc_001* and the error
is to have conflicting typedefs.

<two-reasons-to-use-typedef>
1. To parameterize a program against portability problems. If typedef are used
for data types that may be machine-dependent, only the typedef need change
when the program is moved.

2. To provide better documentation for a program. A type Treeprt may be easier
to understand.


{class-vs-cxx-struct}
The only difference between struct and class is the default access specifier
for members and derivation; struct is 'public' and class is private by
default. CPR 616

<ex>
Looks like struct and class are differnt. 

struct/class Point
{
    int x;
    int y;
};
 
struct Rect
{
    Point bot;
    Point top;
};

Rect a{1,2,3,4};          // okay


To give it initial vause, then:

struct/class Point
{
    int x{};
    int y{};
};

struct/class Point
{
    Point() x(0), y(0) {}
    int x;
    int y;
};
 
Rect a{1,2,3,4};          // error

xxx.cpp: In function ‘int main()’:
xxx.cpp:54:22: error: too many initializers for ‘Rect’
     Rect a = {1,2,3,4};
                      ^
xxx.cpp:54:22: error: could not convert ‘1’ from ‘int’ to ‘Point’
xxx.cpp:54:22: error: could not convert ‘2’ from ‘int’ to ‘Point’


{layout-order-and-size}
From C++BS 8.2.1.

An object of a struct holds its members in the order they are declared.

struct Readout {
  char hour;
  int value;
  char seq;
};

A more realistic layout of a Readout on a machine with 4-byte int would be:

hour :   [*      ]
value:   [* * * *]
seq  :   [*      ]

In this case, as on many machines, sizeof(Readout) is 12, and not 6 as one
would naively expect from simply adding the sizes of the individual members.

You can minimize wasted space by simply ordering members by size (largest
    member first).

struct Readout {
  int value;
  char hour;
  char seq;
};

This would give us:

value:      [* * * *]
hour: seq : [* *    ]

It is usually best to order members for readability and sort them by size only
if there is a demonstrated need to optimize.


={============================================================================
*kt_dev_cpp_016* cpp-pointer-array

{array-vs-struct}
1. From C++BS 8.2. Objects of structure types can be assigned, passed as
function arguments, and returned as the result from a function. For example:

Address current;
Address set_current(Address next)
{
  address prev = current;
  current = next;
  return prev;
}

Other plausible operations, such as comparison (== and !=), are not available
by default. However, the user can define such operators.

2. An array is an aggregate of elements of the same type. In its simplest
form, a struct is an aggregate of elements of arbitrary types.


{array-as-an-object}
Placing a built-in array in a struct allows us to treat that array as an
'object': we can copy the struct containing it in initialization (including
    argument passing and function return) and assignment. For example:

struct Point {
  int x,y
};

struct Array {
  Point elem[3];
};

Array shift(Array a, Point p)
{
  for (int i=0; i!=3; ++i) {
    a.elem[i].x += p.x;
    a.elem[i].y += p.y;
  }
  return a;
}

Array points2 {{1,2},{3,4},{5,6}};

Array ax = shift(points2,{10,20});

The notation for Array is a bit primitive: Why i!=3? Why keep repeating
.elem[i]? Why just elements of type Point? The standard library provides
std::array as a more complete and elegant development of the idea of a
fixed-size array as a struct:

This array is a template to allow arbitrary numbers of elements of arbitrary
types. It also deals directly with the possibility of exceptions and const
objects.

struct Point {
   int x,y
};

using Array = array<Point,3>; // array of 3 Points

Array points {{1,2},{3,4},{5,6}};

int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
  for (int i=0; i!=a.size(); ++i) {
    a[i].x += p.x;
    a[i].y += p.y;
  }
  return a;
}

Array ax = shift(points,{10,20});

<pros-and-cons>
The main advantages of std::array over a built-in array are that it is a
'proper' object type (has assignment, etc.) and does not implicitly convert to
a pointer to an individual element:

The disadvantage of std::array compared to a built-in array is that we can't
'deduce' the number of elements from the length of the 'initializer':

// 3 elements
Point point1[] = {{1,2},{3,4},{5,6}}; 

// 3 elements
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; 

// error : number of elements not given
array<Point> point3 = {{1,2},{3,4},{5,6}}; 


={============================================================================
*kt_dev_cxx_0000* cxx-static-members cxx-static-class-const

{cxx-static-function-static} cxx-static-file-static
Global vars has a program scope. The static vars are still global object but
has a limited scope.

The `function-static` is only accessible within the function, and has no
linkage.(?) It is initialised the first time execution reaches the definition,
  not necessarily during the program's initialization phases.

From ANSIC 83, so static is to 'limit' the scope of the object whether is
to file or function.  

The `file-static` is private to a file and will not conflict with the same
names in other files of the same program. The `file-static` can be used on
both variables and functions.

`internal-linkage` refers to everything only in scope of a translation unit.

`global-static` `file-static` should use *cxx-namespace-unnamed* in C++.
global(file) static has a file scope.

`local-static` `function-static` 
local(function) static has a function scope. 


void foo () {   
  static int x = 0;
  ++x;
  cout << x << endl;
}

int main (int argc, char const *argv[]) {
  foo();  // 1
  foo();  // 2
  foo();  // 3
  return 0;
}


<limit-scope-meaning>
static has limited file-scope. 

// file one
#include <iostream>

static int gfs_count;
// extern static int gfs_count; 
// causes an compile error: conflicting specifiers in declaration of 'gfs_count'

void print_gfs()
{
  std::cout << "{ "; 

  for(int idx = 0; idx < 5; idx++)
    gfs_count++;

  std::cout << gfs_count << std::endl;

  std::cout << "}" << std::endl; 
}

// file two
#include <iostream>

extern int gfs_count;
extern void print_gfs();

int main()
{
  std::cout << "{ "; 

  std::cout << gfs_count << std::endl;    // if remove this, no link error
  print_gfs();

  std::cout << "}" << std::endl; 
}

No error in building and in using a function in file-one but failed to use
static variable, gfs_count, in file two in link stage.

$ make
echo '>> build use-main.cpp'
g++ -std=c++0x -o main.o -c use-main.cpp
echo '>> build file-static.cpp'
g++ -std=c++0x -o file.o -c file-static.cpp
echo '>> bulid main'
g++ -std=c++0x -o out main.o file.o
main.o: In function `main':
use-main.cpp:(.text+0x1e): undefined reference to `gfs_count'
collect2: ld returned 1 exit status
make: *** [main] Error 1


<static-member-func-and-this>
The staic members are associated with the class rather than objects. So can
call static member function as `class method` or class operation as in
smalltalk and static member variable as `class variable` or class static. 

See *class-variable-case* for class variable example.

note: static members 'obey' normal access control.

The static-member-func do not bound to any object; do not have a this pointer.
Aa a result static-member-func `may not be declared as const` and not refer to
this in the body. 

The static member func, class-method, do not have `this-pointer` because no
need to distinguish objects and this means class-methond can only use class
variable.


Use directly through the scope operator:

double r;
r = Account::rate();

Even though static are not part of the object, can use object to
access a static member.

Account ac1;
Account *ac2 = &ac1;

r = ac1.rate();
r = ac2->rate();

Member function can use it directly without the scope operator.


{cxx-static-class-variable}
The objects do not contain data associated with class variable. When
initialized? The default constructor `implicitly default initialize`
static-member-variable. The class-static `must-be-defined-and-inited` outside
of class because it's global objects.

class FooStatic {
  private:
    // note not defined and okay since it's const
    static const size_t MAX_CODE_LENGTH{4};         
    // note error since not const 
    // static size_t MAX_CODE_LENGTH{4};            
    
    static const std::string DIGIT_NOT_FOUND;

    // static const std::string DIGIT_NOT_FOUND{"*"};
    // : error: in-class initialization of static data member 
    //  ‘const string Foo::DIGIT_NOT_FOUND’ of non-literal type
    //   static const std::string DIGIT_NOT_FOUND{"*"};
    //                                               ^
    // : error: non-constant in-class initialization invalid for 
    //  static member ‘Foo::DIGIT_NOT_FOUND’
    // : note: (an out of class initialization is required)

  public:
    FooStatic() {}
};

*cxx-static-access*
const std::string FooStatic::DIGIT_NOT_FOUND{"*"};

TEST(Static, DefineStaticOutside)
{
    FooStatic foo;
}


<ex>
// c++ cookbook, 8.4 Automatically Adding New Class Instances to a Container

namespace cxx_static
{
  // c++ cookbook, 8.4 Automatically Adding New Class Instances to a Container

  class StaticClass
  {
    protected:
      int value_{};
      size_t id_{};

      string name_{};
      static list<StaticClass*> instances_;
      static size_t track_id_;

    public:
      StaticClass(int value, string name =  "static class")
        : value_(value), name_(name)
        {
          id_ = ++track_id_;
          instances_.push_back(this);
        }

      ~StaticClass()
      {
        auto it = find(instances_.begin(), instances_.end(), this);
        if (it != instances_.end())
          instances_.erase(it);
      }

    public:
      static void ShowList()
      {
        cout << "ShowList: " << instances_.size() << endl;
        for (const auto &e : instances_)
        {
          cout << "ShowList: name : " << e->name_ << endl;
          cout << "ShowList: value: " << e->value_ << endl;
          cout << "ShowList: id   : " << e->id_ << endl;
        }
      }
  };

  list<StaticClass*> StaticClass::instances_;
  size_t StaticClass::track_id_ = 0;

} // namespace

// ShowList: 3
// ShowList: name : instance 1
// ShowList: value: 1
// ShowList: id   : 1
// ShowList: name : instance 2
// ShowList: value: 10
// ShowList: id   : 2
// ShowList: name : instance 3
// ShowList: value: 100
// ShowList: id   : 3

TEST(Static, TrackClassInstances)
{
  using namespace cxx_static;

  StaticClass sc1(1, "instance 1");
  StaticClass sc2(10, "instance 2");
  StaticClass sc3(100, "instance 3");
  StaticClass::ShowList();
}

// ShowList: 0

TEST(Static, TrackClassInstancesWhenNothingCreated)
{
  using namespace cxx_static;

  StaticClass::ShowList();
}


// [ RUN      ] Static.UnderInheritance
// Foo::createInstance()
// Bar::createInstance()
// Foo::createInstance()
// Bar::createInstance()
// Foo::createInstance()
// [       OK ] Static.UnderInheritance (0 ms)

TEST(Static, UnderInheritance)
{
  using namespace cxx_static;

  Foo::createInstance();
  Bar::createInstance();

  Foo foo;
  foo.createInstance();

  Bar bar;
  bar.createInstance();

  Foo *p = new Bar;
  p->createInstance();
  delete p;
}


{cxx-const-class-const} EC++02
If it's const, it `limit the scope of a constant to a class` Ordinarily, class
static members may not be initialized in the class body. However, can be used
in-class-initializer. Hence it's called class-const and be static. Otherwise
got error:

usecomma.cpp:8:13: error: invalid use of non-static data member ‘Foo::MAX’

<in-h>
class Foo {
  private:
    static const double interest = 30;    // declaration. cxx-in-class-init. 
    double table[ interest ];             // can be used.
};

<in-cpp>
As with this example, if the only use is the context where the compiler can
substitute the member's value, then no need to define class-const. However,
           used in other context such as passing it to func arg, must define.

// definition and 'must' not init since an initializer is provided inside a
// class.

double Foo::interest;                     


After all, class-method and class-variable is to limit a scope of golbal
objects as with file or function static. The bottom line is that static is
global but we can limit its scope to file, class, or function.

1. SCOPE. easy access as global, no need to create an object to use, but in
the class scope.

2. created only when it is used. It is true for <function-static> in
{limit-the-number-of-object}.

3. to solve init-order-problem


{cxx-static-elf-bss} *elf-bss* *tool-nm*

static void AsanDie() {

  static atomic_uint32_t num_calls;
}

00164f74 b __asan::AsanDie()::num_calls

The global var is:

001639d4 B __asan_rt_version


={============================================================================
*kt_dev_cxx_0000* cxx-except

The exception are run-time anomalies that prevent the program from continuing
normally. Exception handling supports the cooperation between the detecting
and handling parts of a program. 

MEC++09: What's different to the approach of returning error code? 

  o Exception `cannot be ignored` and if do, it is terminated. 
  
  o From MEC++12. The execution return to call site for func call but never
    for exception when think that throw is a function call.

Exception handling involves:

  o throw expression
  o try blocks and catch clauses or exception handlers
  o exception classes

try {
  program-statements
} catch (exception-declaration) {
      handler-statments
} catch (exception-declaration) {
      handler-statments
}


{cxx-except-standard}
Exception classes are defined in four headers.

  o #include <exception>
    The C++ Standard library provides a `base class` specifically designed to
    declare objects to be thrown as exceptions. It is called std::exception
    and is defined in the exception header. This class has a virtual member
    function called what() that returns a null-terminated character sequence
    and that can be overwritten in derived classes to contain some sort of
    description of the exception. 

  o #include <stdexcept> 
    The stdexcept header defines several `general purpose exception classes`
    which are derived from std::exception.

  o #include <new>
    Defines bad_alloc exception type.

  o #include <typeinfo>
    Defines the bad_cast exception type. 

namespace cxx_code
{
  // o #include <exception>
  /**
   *  @brief Base class for all library exceptions.
   *
   *  This is the base class for all exceptions thrown by the standard
   *  library, and by certain language expressions.  You are free to derive
   *  your own %exception classes, or use a different hierarchy, or to
   *  throw non-class data (e.g., fundamental types).
   */
  class exception
  {
    public:
      exception() _GLIBCXX_USE_NOEXCEPT { }
      virtual ~exception() _GLIBCXX_USE_NOEXCEPT;

      /** Returns a C-style character string describing the general cause
       *  of the current error.  */
      virtual const char* what() const _GLIBCXX_USE_NOEXCEPT;
  };

  // o #include <stdexcept> 
  // exception takes message in ctor

  class logic_error : public exception;

  /** This represents an argument whose value is not within the expected
   *  range (e.g., boundary checks in basic_string).  */
  class out_of_range : public logic_error 
  {
    public:
      explicit out_of_range(const string& __arg);
      virtual ~out_of_range() _GLIBCXX_USE_NOEXCEPT;
  };

  class runtime_error : public exception 
  {
    string _M_msg;

    public:
    /** Takes a character string describing the error.  */
    explicit 
      runtime_error(`const string& __arg`);

    // note: see noexcept on dtor
    virtual ~runtime_error() _GLIBCXX_USE_NOEXCEPT;

    /** Returns a C-style character string describing the general cause of
     *  the current error (the same string passed to the ctor).  */
    virtual const char* 
      what() const _GLIBCXX_USE_NOEXCEPT;
  };
} // namespace


All exceptions thrown by components of the C++ Standard library derived from
this exception class. These are:

bad_alloc            thrown by new on allocation failure
bad_cast             thrown by dynamic_cast when it fails in a dynamic cast
bad_exception        thrown by certain dynamic exception specifiers
bad_typeid           thrown by typeid
bad_function_call    thrown by empty function objects
bad_weak_ptr         thrown by shared_ptr when passed a bad weak_ptr

Also deriving from exception, exception header defines two generic exception
types that can be inherited by custom exceptions to report errors:

logic_error          error related to the internal logic of the program
runtime_error        error detected during runtime


{cxx-except-stack-unwinding}
A `throw` acts like a return; statements following a throw are not executed.
If no 'matching' catch found, current/calling function is exited until found
one in the call tree.

If not found a matching catch and call 'terminate'. If found, run catch and
coutinue running from the the end of the try block catched but not the point
where throw is called.

When no try-catch block in the chain, 1,2, and 3 runs only.  

func3()              func2()                func1()
{                    {                      {
   (1)                   (2)                    (3)
   func2();              func1();               throw...;
   (6)                   (5)                    (4)
}                    }                      }


During stack-unwinding, function exits 'prematurely' and means local objects
are dstroyed and dtor is called.


={============================================================================
*kt_dev_cxx_0000* cxx-except-dtor-ctor cxx-except-stack-unwinding

{exception-in-ctor}
Partially constructed. Even if it's partially constructed, guaranteed that the
constructed members will be properly destroyed. From EC++30 p137 and see
*cxx-ctor-empty-ctor-represenstaion*

But from MEC++10, it shows many ways to handle exceptions in ctor so not sure
that it is properly destroyed. Seems EC++ is the latest.


{cxx-exception-in-dtor} *cxx-except-stack-unwinding* *cxx-dtor*
Why exception in dtor is the problem? Since stack-unwinding starts to find
matching catch and local objects are destroyed. If dtor of object being
destroyed can raise an execption, then there would be two running exceptions and
it is not allowed in C++. EC++08 says that terminate is called or undefined.

*cxx-remember*
The main problem is `permature termination` which means no chance to do useful
things such as resource clean-up and making a log entry in handling exception
or before terminating or swallowing. So premature termination means the
undefined state of an application or system.

So no exception in dtor and `if necessary, should handle in the same dtor.` This
is the base assumption *cxx-stl* has and it guarantee that any class's dtor will
not raise an execption.

see *cxx-except-noexcept*

      ~dispatcher() noexcept(false)
      {
        if (!chained_)
          wait_and_dispatch();
      }


{exception-and-raii}
To handle exception, shall use resource-managing-class, RAII, since destruction
will be handled when do stack unwinding.


{how-to-handle-exeception-in-dtor}
See {raii-for-resource-using-own-interface} for other examples. From EC++08.
General recommendation is not to raise exception in dtor. If interface to use
comes from external source then it could raise an exception. What to do? These
are how to handle when exception happens in dtor.

// think this external source
class DBConnection {
  public:
    ...
    static DBConnection create();    // fatctory-func
    void close();                    // can throw exception
};

// resource managing class
class DBConn {
  public:
    ~DBConn() { db.close(); }

  private:
    DBConnection db;
};

// client use
{
  DBConn dbc( DBConnection::create() );
  ...
}

Two approach to address exception in dtor:

<1> terminate the program
By doing this, make a log entry to see and prevent undefined behavior.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
    std::abort();
  }
}

Can use {noexcept} at below? Seems not as it has the same effect when not
handling exaction from a dtor: no chance to do useful thing such as making a log
entry.

<2> swallow the exception
Can be used when the program must be able to continue execution even after
exception is happened.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
  }
}

<3> However, said that the better way is:

class DBConn {
  public:
    void close()
    {
      db.close();             // can exception happen
      closed = true;
    }

    ~DBConn() 
    { 
      if(!closed)
      {
        try { db.close(); }
        catch(...) {
          // make log enrtry
          // terminate or swallow
        }
      }
    }

  private:
      DBConnection db;
      bool closed;
};


The client have an opportunity to handle the exception and if the client choose
not to handle it then fall back to default action: terminating or swallowing. It
appears that it make raii less useful and pass the burden on to the client but
it is not since it gives them opportunity to handle.  it. See
{raii-and-exception-in-dtor} for the point to consider when use raii.

// client use
{
  DBConn dbc( DBConnection::create() );

  try{ dbc.close() }
  catch(...)
  {
    // try to address exception and if successful, set closed to true.
  }
}


{function-try-block}
CPR 773, 18.1.3 shows function-try to handle exception in construction or
destruction phase.

Since constructor initializers executes 'before' ctor body, exception handling
in ctor body cannot catch that.

* The members are initialised in the order of defined in class. covered by
  function-try-block.
* The parameters are copied using copy-ctor and if exception happens, covered in
  caller site.
* Runs constructor-initializers if there are. covered by function-try-block.
* Runs ctor-body. covered by function-try-block.

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) : 
  data( std::make_shared< std::vector<T>> (il)) {}

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) try : 
  data( std::make_shared< std::vector<T>> (il)) { /* empty body */ }
catch ( const std::bad_alloc& e) { handle_out_of_memory(e); }


{exception-object} user-defined-exception-object
The `throw` and `catch` expression use special-object, exception object. If it's
a class type, must be 'complete' type and have dtor and copy or move op. If it's
array or func type, it's converted to its pointer type. 

Because there's a stack-unwinding, must not to throw a pointer to a local
object. Hence exception object is 'copied' in space that is manintained by
compiler and remains vaild 'until' catched.

} catch (exception-declaration) {

Exception is like a functin call and exception declaration is like a function
  with one param. Like function call, catch 'parameter' can be non-refernce or
  reference. If it's class type from inheritance and non-reference then
  `sliced-off` can happen in `throw` and `catch` 

How can use reference in catch? Since there is separation between throw and
catch site. That is the exception object is held in 'global' space by a
compiler.

throw expr -> (copy init) -> exception object -> (copy init) -> catch (expr)

<ex>
#include <iostream>
using namespace std;

class B 
{
  public:
  B() { cout << "B ctor" << endl; }
  B(const B& b) { cout << "B copy ctor" << endl; }
  ~B() { cout << "B dtor" << endl; }
  virtual string what() { return "i'm B"; }
};

class CD : public B
{
  public:
  CD() { cout << "CD ctor" << endl; }
  CD(const CD& b) { cout << "CD copy ctor" << endl; }
  ~CD() { cout << "CD dtor" << endl; }
  string what() { return "i'm CD"; }
};

int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor            // {
going to throw
B copy ctor                            // {  exception object
B dtor            // }
B copy ctor                // {
An exception occurred. Exception Nr. i'm B
B dtor                     // }
B dtor                                 // }
end

<exception-catch-by-reference>
The catch by referecne is recommendation.

* Catch by pointer, do not know if should call delete on it because do not know
  if it is created by new or not.
* Catch by value, sliced-off can happen.
* Catch by reference, okay for both problems above.

<ex> to show sliced-off.

int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
B ctor               // {  copy init for derived
CD copy ctor         // }
CD dtor
B dtor
B copy ctor
An exception occurred. Exception Nr. i'm B
B dtor
CD dtor              // { dtor for exception object
B dtor               // } 
end


<ex> to see when catch reference

int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
B ctor
CD copy ctor
CD dtor
B dtor               // note to see there is no copy init for catch argument
An exception occurred. Exception Nr. i'm CD
CD dtor              // { dtor for exception object
B dtor               // } 
end


<ex> when throw base and catch derived

int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (CD& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
going to throw
terminate called after throwing an instance of 'B'
Aborted (core dumped) 
  
note: the exception spec mismatches hence terminated.


{cxx-except-first-fit}
Restricted type conversion for exception. 

  * conversions from nonconst to const
  * conversions from derived to base type

No others are allowrd such as class type conversion.

Since catch uses the order of appearance in code, this is called first-fit
strategy compared to best-fit in function-matching. If use exceptions from an
inheritance, 'must' order from derived type to least derived.

  class logic_error : public exception;
  class invalid_argument : public logic_error;

try {
  ...
} catch ( logic_error& ex ) {
  ...
} catch ( invalid_argument& ex ) {
  ...
}

must be:

try {
  ...
} catch ( invalid_argument& ex ) {
  ...
} catch ( logic_error& ex ) {
  ...
}


<ex> cxx-except-blanket-catch-hidden

catch(ZINC_UNUSED const std::exception& e)
{
  ...
}

This seems like a rather blanket catch and could potentially catch some
serious exceptions that you don't intend on catching given the below comments.
You should be more specific in which exceptions you catch IMO.

There's a whole list of exceptions that could be thrown. Just because you're
not expecting it right now doesn't mean it won't happen in the future. I don't
think std::exception should be caught anywhere but say in a main message loop.
It's much harder to debug exceptions being 'hidden' like that, as what() is
not always likely to include a useful what().


<rethrow>
Partially handle the exception and may decide that the exception must be
handled by a function further up the call chain.

  * Do not specify an expression; the current exception object is passed up
  * Changes will be passed up only if catch uses a reference

catch (myerror& eobj) {
  eobj.status = errCodes::severeErr;
  throw;
}


*cxx-except-catch-all*
To catch all exceptions regardless of type. If used with other handlers, must be
the last one. Often used with rethrow.

catch (...)
{
  // work to partially handle the exception
  throw;
}


<exception-object-always-copied>
The execution returns to call site for func call but never for exception. This
means that whenever throw happens, a copy is 'always' made regardless of catch
type whether it is value or reference because throw leaves a call site. This is
natural since there should be execption object anyway.

// example-one
catch( Widget& w )
{
  ...
  throw;
}

Use 'current' exception and throw it again, rethrow. So there is no addtional
copy made and w can be a derived class in Widget inheritance.

// example-two
catch( Widget& w )
{
  ...
  throw w;        // see
}

This create a new Widget type exception and cost copy ctor and dtor even if
catch reference. Checked with code. Therefore, 'rethrow' recommended if
possible.


={============================================================================
*kt_dev_cxx_0000* cxx-except-noexcept cxx-noexcept

CLR 3.1.7 Keyword noexcept

Here, inside noexcept(...), you can specify a boolean condition under which no
exception gets thrown: Specifying noexcept without condition is a short form
of specifying `noexcept(true)` which means exception is not allowed

<ex>
/*
CLR 3.1.7 Keyword noexcept

Here, inside noexcept(...), you can specify a boolean condition under which no
exception gets thrown: Specifying noexcept without condition is a short form of
specifying `noexcept(true)` which means exception is not allowed

~TemplateDispatcher()
{}

is same as:

~TemplateDispatcher() noexcept(true)
{}

*/

TEST(CxxException, noexcept_condition_1)
{
  using namespace cxx_except;

  {
    int value{1};

    Foo foo;

    EXPECT_THAT(value, 1);
  }

  // FooNoAbort dtor is allowed to throw so no abort happens
  {
    int value{1};

    try
    {
      FooNoAbort foo;
    } catch (std::exception &e)
    {
      // fails since what() returns "const char*"
      // EXPECT_THAT(e.what(), "noexcept(false) so expects no abort");

      EXPECT_THAT(std::string(e.what()), "noexcept(false) so expects no abort");
    }

    EXPECT_THAT(value, 1);
  }
}

// "noexcept(true)" but throw so violates promise. abort happens.
//
// [ RUN      ] Exception.Noexcept
// terminate called after throwing an instance of 'std::runtime_error'
//   what():  noexcept(true) so expects abort
// Aborted

TEST(CxxException, DISABLED_noexcept_condition_2)
{
  using namespace cxx_except;

  {
    int value{1};

    try
    {
      FooAbort foo;
    } catch (exception &e)
    {
      std::cout << e.what() << std::endl;
    }

    EXPECT_THAT(value, 1);
  }
}


{noexcept-specification} *cxx-noexcept*
A function can specify that it does not `throw` exception by providing a
noexcept specificaton.

void recoup(int) noexcept;    // won't `throw`
void alloc(int);              // might `throw`

void recoup(int) noexcept;
void recoup(int) throw();     // equivalent declaration in earlier C++

WHY noexcept? If the compiler knows that no exceptions will be thrown, can
(sometimes) perform 'oprimizations' that must be supressed if code might
throw.


{spec-mismatch}
The compiler does 'not' check the `noexcept` specification at compile time and
as a result, possible that a function that claims it will not `throw` will in
fact throw. In that case, `terminate()` is called, thereby 'enforcing' the
promise not to `throw` at run time.

MEC++14. If there is a mismatch of 'spec' between throw and catch, permature
program-termination happens and This means no clean-up so should be avoided.

void f2() throw (int);  // says it will throw only int type exception

void f2() throw (int)
{
  ...
  // extern void f1();  // may throw anything
  f1();
  ...
}

Like this, can wrap old code with new code that handles exception. But if f1()
  raise exception other than int, 'violate' f2's exception specification.


<avoid-spec-mismatch>

* Do not mix template and exception spec because do not know T type so not able
  to write spec.

* Change default handler, unexpected(), to handle those. For example, if we use
  a library that raise unexpected exception:


<when-use-noexcpt>

* When absolutly sure that there's no exception.

* When don't know what to do or not possible to handle an exception. Exit the
  program.


<why-deprecated-and-dynamic>
From stl reference, p24. noexcept targets a lot of problems (empty) exception
specifications, throw(), have. (also lot of problems of specifying the spec)

1. Runtime checking: C++ exception specifications are checked at run-time
rather than at compile time, so they offer no programmer guarantees that all
exceptions have been handled. The runtime failure mode (calling
    std::unexpected()) does not lend itself to recovery.

2. Runtime overhead: Runtime checking requires the compiler to produce
additional code that also hampers optimizations.

3. Unusable in generic code: Within generic code, it is not generally possible
to know what types of exceptions may be thrown from operations on template
arguments, so a precise exception specification cannot be written.

In practice, only two forms of exception-throwing guarantees are useful: 

An operation might throw an exception (any exception) or an operation will
never throw any exception. The former is expressed by omitting the
exception-specification entirely, while the latter can be expressed as throw()
  but rarely is, due to performance considerations.

Especially because noexcept does not require stack unwinding, programmers can
now express the nothrow guarantee 'without' additional overhead. As a result,
    the use of exception specifications is 'deprecated' since C++11. 


={============================================================================
*kt_dev_cxx_0000* cxx-except-safety

C++PL 13.2

The library provides one of following guarantees for every library operation:

o. basic
For all operations. The basic invariants of all objects are maintained, and no
resources are leaked. 

o. strong
For key operations. In addition to providing the basic guarantee, either the
operation succeeds, or it has no effect. 

o. nothrow
For some operatins. In addition to providing the basic guarantee, some
operations are guaranteed not to throw an exception. 


{self-assign-exception-safe}
EC++29. Two requirements for exception safety when exception happens:

See *self-assign* for reasons why need to handle self-assign. Also if not, then
it's not exception safe as well. If this is exception safe, then lhs state
shouldn't change when new raise exception, but the below don't and the below
isn't exception safe.

// NO self-assign and exception-safe in valuelike case
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  delete ps;
  auto newp = new string(*rhs.ps);
  ps = newp;
  return *this;
}

// combine dtor and copy. handle self-assign and exception-safe by moving delete
// after new. careful-statement-ordering

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

EC++11. Making operator=() exception-safe typically renders it self-assign-safe
too. So think about exception-safe only. Alternatively, can use
*copy-and-swap-idiom* 

<ex>
// from the bad example
void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  Lock ml(&mutex);

  delete bgImage;
  ++imageChanges;
  bgImage = new Image(imgSrc);
};

// offer strong

class PrettyMenu {
  ...
  std::shared_ptr<Image> bgImage;
  ...
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  Lock ml(&mutex);

  bgImage.reset( new Image(imgSrc) );  // bad_alloc or ctor exception
  ++imageChanges;
};

The deletion of old image takes place 'only' if the new image is successfully created because reset
will be called only if the parameter is successfully created.

note: This offers 'almost' strong guarantee and offers the basic exception since if the parameter
imgSrc constructor throws an exception, possible that the read marker for the input stream has been
moved and such movement would be a change in state visible to the rest of the program.

General design to lead to the strong guarantee: use {copy-and-swap-idiom} and {pimpl-idiom} in
*kt_dev_cpp_006* 

<copy-and-swap-idiom-case>
Make a copy and all changes to the copy. If any of the modifying operation throws an exception, the
original remains 'unchanged'. After all changes have been successfully completed, swap the modified
with the original in non-throwing swap operation.

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

HasPtr& HasPtr::operator=(const HasPtr rhs)  // note. not ref and it's copy
{
  ...                // operations to change the copy if there are more to do
  swap(*this, rhs);
  reutn *this;       // rhs is destroyed, which deletes the old ps.
}

<pimpl-idiom-case>
This is the same as copy-and-swap and is different from usual pimpl-idiom. The object has a pointer
to the implementation that has all object data. This can be rewritten as general design although
offer no better gurarantee than the previous for this particular example.

struct PMImpl {
  std::shared_ptr<Image> bgImage;
  int imageChanges;
};

class PrettyMenu {
  private:
    std::shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  using std::swap;

  std::shared_ptr<PMImpl> pNew( new PMImpl(*pImpl) );

  pNew->bgImage.reset( new Image(imgSrc) );  // bad_alloc or ctor exception
  ++pNew->imageChanges;

  swap(pImpl, pNew);
};

<exception-safety-is-difficult>
Although copy-and-swap-idiom is a good way for strong but doesn't guarentee that the overall
function is strongly exception safe.

void someFunc()   // uses copy-and-swap
{
  ...
  f1();
  f2();
  ...
}

Although f1 and f2 provide strong exception, difficult to have strong for someFunc to guarantee
since the state of the program is not the same as it was when someFunc was called, even though f2
didn't change anything. f1 has strong exception but may change state.

Two reasons for difficulty:

1. side effect
As long as functions operate only on local state, relatively easy to offer the strong guarantee but
when on non-local data, it's much harder such as database.

2. efficiency
Copy and swap idiom requires more space and time.

<recommendation>
The strong guarantee is desiable but not always practical. Especially, when use third party or
legacy code which do not provide exception safety. In other words, can offer no stronger than the
weakest guarantee of the functions it uses.

Aim to provide basic guarantee which is resonable for many functions and think carefully about
strong safety: if it's practical in terms of efforts, cost in efficiency and complexity, how many
functions should have strong safety. 80-20 rule?


={============================================================================
*kt_dev_cpp_019* except-disable

<default-exception-handler>

class UnexpectedException { };

void convertUnexpected()
{ throw UnexpectedException(); }

set_unexpected( convertUnexpected );

This convert <all-unhandled-exception> to UnexpectedException and there should be catch for that
type. This means to set default exception handler.

OR

void convertUnexpected()
{ throw; }

set_unexpected( convertUnexpected );

This convert all to <bad_exception> but no detail about why. Q: why bad_exec?


{exception-cost}
MEC++15. Exception has cost:

1. If not use exception, can save speed and space penalty. There is compiler option to disable it.

2. the cost of try and exception spec in space varies from compiler to compiler. As a rough
estimate, expect your overall code size to increase by 5-10% and your runtime to go up by a similar
amount if you use try blocks. So try to 'minimise' the use.

<80-20-rule>
But think 80-20 rule and that exception is rare. The recommendation is that think if it is feasible
not to use exception, if can minimise, if can use other compiler showing better exception
implementation, and if use profiler to find out 20% to use exception.


<exception-to-disable>
From stackoverflow and said G++ specific.

Option #1: Simply never catch exceptions. {QQ} really?

Exceptions don't have much overhead when they're not thrown or caught; if you're throwing and not
prepared to catch, well, you're doing to die anyway, so the performance impact at that point is
trivial. Note also that stack unwinding will not be performed if an exception is not handled; the
program will simply terminate without performing stack unwinding.

It's important to note that, in G++, exceptions have almost no overhead when not actually thrown.
G++ generates extra information sufficient to trace back the execution of the program through the
stack, and some extra code to invoke destructors, etc - however none of this extra code or data is
ever used until an exception is actually thrown. So you should not see a performance difference
between code with exceptions enabled but not used and code with exceptions disabled (through
whatever mechanism).

Q: not sure it means never throw or never catch.

Option #2: Pass -fno-exceptions.

This flag instructs G++ to do two things:
http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html

All exception handling in STL libraries are removed; throws are replaced with abort() calls Stack
unwind data and code is removed. This saves some code space, and may make register allocation
marginally easier for the compiler (but I doubt it'll have much performance impact).  Notably,
however, if an exception is thrown, and the library tries to unwind through
-fno-exceptions code, it will abort at that point, as there is no unwind data.

This will, effectively, turn all exceptions into abort()s, as you would like. Note, however, that
you will not be allowed to throw - any actual throws or catchs in your code will result in a
compile-time error.

Option #3: (Nonportable and not recommended!) Hook __cxa_allocate_exception.

C++ exceptions are implemented using (among others) the __cxa_allocate_exception and __cxa_throw
internal library functions. You can implement a LD_PRELOAD library that hooks these functions to
abort():

void __cxa_allocate_exception() { abort(); }
void __cxa_throw() { abort(); }

WARNING: This is a horrible hack. It should work on x86 and x86-64, but I strongly recommend against
this. Notably, it won't actually improve performance or save code space, as -fno-exceptions might.
However, it will allow the throw syntax, while turning throws into abort()s.


={============================================================================
*kt_dev_cpp_019* except-terminate-call-tree

#0  0x745911f4 in raise () from /lib/libc.so.0
#1  0x7458a884 in abort () from /lib/libc.so.0
#2  0x77d3a300 in __gnu_cxx::__verbose_terminate_handler() () from /lib/libstdc++.so.6
#3  0x77d37cc0 in ?? () from /lib/libstdc++.so.6
#4  0x77d37d14 in std::terminate() () from /lib/libstdc++.so.6
#5  0x77d37edc in __cxa_throw () from /lib/libstdc++.so.6
#6  0x7702ff5c in void zinc::detail::throwExceptionUsingTraits<DBus::ErrorNoReply>
    (char const*, std::map<std::string, std::string, std::less<std::string>, 
     std::allocator<std::pair<std::string const, std::string> > > const&) () 
    from /opt/zinc-trunk/lib/libZincDbusBindingRuntime.so.0


={============================================================================
*kt_dev_cpp_019* except-case

class BrokerException: public std::runtime_error
{
  public:
    BrokerException() : std::runtime_error("Error in MetadataBroker."){}

    BrokerException(std::string msg) : 
      std::runtime_error(msg)
  {}

    /** Explicit virtual destructor to control RTTI generation. */
    virtual ~BrokerException() throw();
};

class NetworkProblemException : public BrokerException
{
  public:
    /**  */
    NetworkProblemException (const std::string& mesg = "")
      : BrokerException(mesg)
      {}

    /** Explicit virtual destructor to control RTTI generation. */
    virtual ~NetworkProblemException() throw();
};

{
    try
    {
        throw NetworkProblemException("Error in somewhere");
    }
    catch(const ServiceNotFoundException& e)
    {
        URANIUM_ERROR("Caught ServiceNotFoundException. What = "<<e.what());
        //This is seriously wrong. We got events which don't belong to a known service.
        //Stop creating this window now.
        failEventWindowCreation(*command);
    }
    catch(const InvalidNullEventException& e)
    {
        URANIUM_ERROR("Caught InvalidNullEventException while retrieving \
                IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::InvalidResponseException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::InvalidResponseException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::TransientServerProblemException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::TransientServerProblemException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::InternalProblemException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::InternalProblem while \
                retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::InvalidRequestException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::InvalidRequestException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const NS_COBALT_SYSTEM::NetworkProblemException& e )
    {
        URANIUM_ERROR("Caught NS_COBALT_SYSTEM::NetworkProblemException \
                while retrieving IP events. What = "<<e.what());
    }
    catch(const std::exception& e )
    {
        URANIUM_ERROR("Caught std::exception. What = "<<e.what());
    }
    // *cxx-except-catch-all*
    catch(...)
    {
        URANIUM_ERROR("Caught an exception while receiving IP events.");
    }
}


={============================================================================
*kt_dev_cpp_019* except-and-finally

Q: There is no finally keyword in C++. What should you use instead? 
A: Allocate local objects whose destructors perform cleanup 


={============================================================================
*kt_dev_cxx_0000* cxx-inheri

The inheritance provides `overriding` and `polymorphism`.

{cxx-polymorphism} *cxx-dynamic-binding* *cxx-override*
Polymorphism is derived from a Greek words meaning "many forms".

Oppose to compile-time static binding, the compiler generates `code` to decide
at run-time which function to call. This dynamic binding or virtual mechanism
based on the fact that the static and dynamic types of reference and pointers
can differ is how C++ supports polymorphism.

Polymorphism in general is when a piece of a program is designed to allow
multiple different types to be used in it.

`static-polymorphism` is a use of polymorphism that is determined when the
program is constructed (such as the Template system in C++). Once the program
is constructed, the choice is made and the type used is known.

`dynamic-polymorphism` is determined at run-time. Through a `pointer` or
`reference` to a base class that allows for descendant class pointers to be
passed in. The base class provides the interface and the descendants implement
that interface in different ways that are suitable to the specifics of the
class. Decisions are made during run time that choose which type to pass.

The important distinction is deciding at construction (compile) or run-time.

Generally, a well designed static polymorphism performs better than dynamic,
so it is to be preferred when the design makes it possible. If the information
  to make a choice is not available until run-time, dynamic is the choice.


<from-python>
the meaning of an operation depends on the type of the objects being operated
on.

How? overloading and overiding


{cxx-type-static-dynamic}
The `cxx-dynamic-binding` at run-time so called `run-time-binding` because
`static-type` is different from `dynamic-type` 

pointer or reference of base class = derived class objects;
`static-type`                          `dynamic-type`

o This is an exception to normal type-match as this is a conversion between
  different types. see *cxx-type-match-exceptions*

o Do not know which object to bind until run-time. 

  "The `subobject` is key to how inheritance and dynamic-binding works. MEC++:
  inheritance give rise to pointer and reference with two different types:
  static and dynamic type."


{conceptual-structure-of-deirved-object}

| ----------- |
|  base part  |
| ----------- |
| drived part |   // non-static members
| ----------- |

Quote item; Bulk_quote bulk;

// implicit base-to-derived conversion for ref and pointer.

Quote* p = &item;
p = &bulk;

Quote& r = bulk;

See followings when use p or r:

o Calls non-virtual funcs of base, get base version. `static-type`
o Calls virtual funcs of base, get derived version. `dynamic-type`
o Calls any func of derived then compile error. `static-type`
o Deference and copy then `cxx-sliced-off`. `static-type`

class Bulk_quote : public Quote {
  public:
    double net_price( std::size_t ) const override;
};

// see reference arg
double print_total(ostream& os, `const Quote& item`, size_t n)
{
  // make a virtual call
  double ret = item.net_price(n);
  os << ... ;
  return ret;
}

Quote item;
Bulk_quote bulk_item;

print_total( item );          // uses Quote version
print_total( bulk_item );     // uses Bulk version. *cxx-dynamic-binding*


{cxx-sliced-off}
The `staic-binding` is done at compile-time. cxx-copy-ctor and cxx-copy-assign
are func calls and `derived-to-base` conversion happens when base's copy-ctor
and copy-assign is called.

Quote item(bulk);         // sliced-off
item = bulk;              // sliced-off


<ex>
From MEC++33. When there are concrete classes like this:

base <- derived1
     <- derived2

The problem case is:

obj = obj;               // the same class. fine
baseobj = derivedobj;    // sliced-off
derivedobj = baseobj;    // compile error

// GCC
: error: no match for 'operator=' in 'lo = bo'
: note: candidate is:
: note: Derived& Derived::operator=(const Left&)
: note:   no known conversion for argument 1 from 'Base' to 'const Derived&'
note: this is a syn coy-ctor that a compiler created.

*baseptr = *baseptr;     // the same class. fine
*baseptr = *baseptr;     // diff. base = derived. sliced-off. 1)
*baseptr = *baseptr;     // diff. derived = base. 2) no-compile-error

Why different results, no comile error? Because a compiler use `static-type`
and only base part will be copied for 1) and 2).

So two problems here:

o The sliced-off with no comiple error can happen when use pointer
o Real programmers write code like this.

How can make it compile error to flag up two cases, 1) and 2), in compile
time? That is to make it difficult to use incorrectly. 

TODO: So what's the solution? need to summarise the followings again.

<approach-one> 
Make operator= virtual. May thought it can use virtual mechanism. MEC++ said
that derived's version will be called and shall have the same params for virual
funcs. But the return can be different.

class Base {
private:
	Animal& operator=(const Base& rhs); 
	...
};

class Derived: public Base {
public:
	Derived& operator=(const Base& rhs);
	...
};

However, in GCC 4.6.3, the params of virtual function can be different and
derived's version is not called. Note: Q: Changed in C++11?

Note: MEC++ seems to be wrong as a compiler use static-type and base version
gets called. So don't need to consider.

Note: see {override-keyword} and need to sum up if needed.

<approach-two-and-three>
Make operator= private and protected. Do not work when *pbase1 = *base2;

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is private
sam_slice.cpp:92:13: error: within this context

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is protected
sam_slice.cpp:92:13: error: within this context

So not a solution.


<approach-to-make-abstract-class>
To remove sliced-off cases, make the base abstract and all derived on the same
level. MEC++ says it as make non-leaf classes abstract.

This only enables copys between objects in the same class whether it is via
object or pointer.

But MEC++ says it is more about uncovering the design need to have abstract
class out of derived classes.


{cxx-virtual-and-definition} *cxx-vtable*
Ordinarily if we do not use a function, do not need to supply a definition for
that function. However `must define every virtual function` regardless of
whether it is used because do not know which version of a function is called
until run time. 

note: To make a vtable in compile time.

<ex>
In the porting layer design and implementation, have drawn the class hierarchy.

 ISession (ABC) and more...      IEvent 

 IDriver : public ISession, public IEvent

 CDsm : public IDriver and more...

When add more interface classes which are ABC and add more concrete derived
classes, shall add the same member functions in a header and source of a
derived class. Otherwise, will have compile/link error since ABC forces
derived class to define functions. See *error-when-create-abc* for what
happens when not overrides pure virtual functions. Tedious. Any other better
way?

1> How about having a *pure-virtual-dtor* to make a ABC and having normal
virtual members?  If have a class definition and the defintion of a
pure-virtual-dtor in the header, get a multiple defintion error since this is
included in every file which use it. Can have source file which has a dtor
definition but still needs definitions for other members. If not, get errors
as 3>.

2> How about having a virtual members for interface classes? Since it has
implementation, that is okay for a derived class not to override or implement
it. So no tedious work. However, cannot force derived to override and can
forget to implement it. Here talking about 'interface' class.

3> What will happen when changes pure virtual functions to normal virtual
functions but do not have implementation? Simply changes a header since it has
a header only as a interface class.

Linking CXX executable mhegproto
port/libmhport.a(CDsm.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `~IDriver':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x94): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x98): undefined reference to `IEvent::unsubscribeEvent(void*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x9c): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTI7IDriver[typeinfo for IDriver]+0x28): undefined reference to `typeinfo for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `.LANCHOR0':
CDsm.cpp:(.rodata+0x5ac): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
CDsm.cpp:(.rodata+0x5b0): undefined reference to `IEvent::unsubscribeEvent(void*)'
CDsm.cpp:(.rodata+0x5b4): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CCi.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'

This shows how GCC implements vtables for a class.


{virtual-and-resolution}
The compiler generates code to decide at run time which function to call when
a virtual function is called through a reference or pointer. This is run-time
binding and polymorphism in C++.


{preventing-inheritance}

o *cxx-11* *cxx-final*

class Last final : Base { ... };

* Use private ctor. See {control-the-number-of-object}


={============================================================================
*kt_dev_cxx_0000* cxx-inheri-multiple

MI and SI (single inheritance)

The problem is that a class inherit from the same base class more than once
and this means there are more than one subobject. Then what is the real
problem or consequence out of having more than one subobject?

From C++ Primer, p810, took this example from IO library:

basic_ios (ABC) <- istream <- iostream
                <- ostream <- iostream

basic_ios holds stream's buffer and state but iostream wants to use "the same
buffer and condition state for both reading and writing". If an iostream
object has two copies of its basic_ios, `this sharing is not possible.`

That is, in iostream, cause ambiguity and can use both data using scope
specifier like istream::x and ostream::x. `so real issue is sharing`

To solve this, use `virtual inheritance` and this shared base class is called
a virtual base class. How? `makes only one shared subobject` for that virtual
base class.


namespce cxx_code
{
  // istream

  /**
   *  @brief  Template class basic_istream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all input streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual input.
   */
  template<typename _CharT, typename _Traits>
    `class basic_istream : virtual public basic_ios<_CharT, _Traits>`
  {
  }

  /**
   *  @brief  Template class basic_iostream
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class multiply inherits from the input and output stream classes
   *  simply to provide a single interface.
   */
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
    public basic_ostream<_CharT, _Traits>
  {
  }

  // iosfwd

  /// Base class for @c char mixed input and output streams.
  typedef basic_iostream<char> 		iostream;

} // namespace


From EC++40, p193,

This problem is called "deadly-MI-diamond" Problems? `ambiguity` and
`replication` in the derived. C++ takes no position on virtual inheritance
problem. (checked with VC and no errors when there's a deadly MI diamond) and
its default is to perform the replication. 

However, VI 'costs' in size, speed and initialization problem. So
recommendation is don't use VI unless you need to.

<syntax>
Which one is right to have public inheritance from Y and Z?

class X : public Y, Z {
  ...
};

class X : public Y, public Z {
  ...
};


see *cxx-incomplete-type* on why every virtual function shall be defined.


={============================================================================
*kt_dev_cxx_0000* cxx-inheri-ctor-init

{cxx-init-order-class}
non-virtual base classes are initialized in `left-to-right` order as they are
declared.

// EXC++47
class Array : private ArrayBase, public Container
{
  Array (size_t startingSize = 10)
    : Container (startingSize),
    ArrayBase (Container::GetSize()) {}       // *cxx-error*
};

That means it's trying to use a member of the not-yet-initialized Container
base subobject.


<1>
Unless we say otherwise, the base part of a derived is 'default' initialized.

The usual way is:

class Disc_quote : public Quote {
  public:
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

};

If omit base ctor, then base part, Quote, is default-init.

class Disc_quote : public Quote {
  public:
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      quantity(qty), discount(disc) {}

};


<2> when there are class member data

class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer 
{
  public:

    // note: "impl(dispatcher_)" shows that calls ctor on member data
    //
    explicit DispatchingEventProducer(boost::shared_ptr<EventDispatcher>
        dispatcher_) : impl(dispatcher_) {}

  private:
    mutable detail::DispatchingEventProducerHoisted impl;
};

class DispatchingEventProducerHoisted : boost::noncopyable 
{
public:

	explicit DispatchingEventProducerHoisted
       (boost::shared_ptr<EventDispatcher> dispatcher_);
   ...
};


<3>
As for ctor, 'copy' controls must explicitly call base part and otherwise has
'oddly configured' object such as the derived part copied as expected but the
base part 'default'-init. 

*cxx-remember* dtor is the only exception that do only for its own part.

class Base {
  public:
    Base(int val) { ... }
};

class Left: public Base {
  public:
    Left(int val) {}
    ...
};

sam_slice.cpp: In constructor 'Left::Left(int)':
sam_slice.cpp:27:32: error: no matching function for call to 'Base::Base()'

Because Base has another ctor so default-ctor will not be made and shows this
error.


{call-base-in-virtual-of-derived}
Use scope operator. This is called circumventing the virtual mechanism; base
version do work common to all types and the derived version do whatever
additional work.

class Window {
  public:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow: public Window {
  public:
    virtual void onResize()
    {
      Window::onResize();
      ...
    }
};


{base-class-pointer-container} {RTTI} <problem-one>
MEC++03: In inheritance, base pointer can point to derived class and when passes
a array of derived instead of base, <undefined-result> can happen.

class BalancedBST: public BST { };

void printBSTArray(ostream& s, const BST array[], int numElements)
{
  for (int i = 0; i < numElements; ++i) {
    s << array[i]; // this assumes an operator<< is defined
  } 
} // for BST objects

Because array[i] is *(array+i) and means can end up with wrong place. This warning applies to
deleting arrays like: delete [] array;

{Q} what is the real problem here? how does it relate to base class pointer? 

<problem-two> when use dynamic_cast
EC++27. Use smart-pointers to base to access 'any' possible derived class. Only SpecialWindow
support blinking. Means that need to have to check its type at rumtime.

class Window { ... }
class SpecialWindow: public Window {
  public:
    void blink( ... );
    ...
};

typedef std::vector<std::shared_ptr<Window>> VPW;
                                    ^^^^^^
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow* psw = dynamic_cast<SepecialWindow*>( iter->get() ) )
  {                        ^^^^^^^^^^^^
    psw->blink();
  }
}

Undesirable because dynamic_cast is slow and also need to know to which type the object should be
cast since dynamic_case 'must' refer 'complete' object. Means already you know what it is.


<problem-three>
From MEC++33: when showing virtual operator= to support mixed type assign in inheritance.

Derived& Derived::operator=(const Base& rhs)      # virtual member op
{
	 const Derived& rhs_derived = dynamic_cast<const Derived&>(rhs);

	 // proceed with a normal assignment of rhs_derived to left *this
}


<solution-one> type-safe container

typedef std::vector<std::shared_ptr<SpecialWindow>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
  (*iter)->blink();
}

Remove dynamic_cast BUT limited to SpecialWindow only. Not other possible derived class.


<solution-two> use virtual func in the hierarchy

class Window { 
  public: >
   virtual void blink {}      // def-impl. do-nothing
};

class SpecialWindow: public Window {
  public: >
   virtual void blink( ... ); // do real work
};

typedef std::vector<std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
   (*iter)->blink();
}


={============================================================================
*kt_dev_cxx_0000* cxx-access-control

<cxx-access-specifier>
Members after a `private` specifier are accessible to the member functions of
the class but are not accessible to code that uses the class. The `private`
section encapsulate the implementation.

A derived class `may` access the `public` and `protected` members of its base
class. `cannot access private of its base class.`


<derivation-access-specifier>
Access to a member that a class inherits is controlled by a combination of the
`member-access-specifier` in the base class and the
`derivation-access-specifier` in the derivation list.

The derivation-access-specifier `do not affect access of base class` in the
derived class. The purpose of `derivation-access-specifier` is to control the
access that "`users-of-derived-class` including other classes derived from the
derived class" have to the members inherited from base class.

This has `no effect on the single inheritance` which is between direct base and
the derived. If omits this, it will be private by default. 

class Base {
  public:
    void pub_mem();
  protected:
    int prot_mem;
  private:
    char priv_mem;
};

struct Pub_Derv : public Base {
  // can access pub_mem, prot_mem but cannot access priv_mem.
};

struct Priv_Derv : private Base {
  // can access pub_mem, prot_mem but cannot access priv_mem.
  // regardless of derivation, cannot access priv_mem. derivation doesn't affect
  // in the derived class.
};


However, that affects `users-of-derived-class`

Pub_Derv d1;
Priv_Derv d2;

d1.pub_mem();
d2.pub_mem();     // error, pub_mem is `private` in the derived class

struct Derived_from_Private : public Priv_Derv {
  // error, prot_mem is `private` in Priv_Derv
  int use_base() { return prot_mem; }
};


<on-derived-base-conversion>
As with this, this remains the same when derived to base conversion happens.
That is: 

User code may use the derived to base conversion only if inherits publicly
from base and may not for other derivations.


<cpp-access-error>

class Base { virtual void dummy() {} };
class DerivedPub: public Base { int a; };
class DerivedPri: private Base { int a; };

// okay
Base * pdd1 = new DerivedPub;

// error
Base * pdd2 = new DerivedPri;

t_cast.cpp: In function ‘void t_cast_01()’:
t_cast.cpp:17:23: error: ‘Base’ is an inaccessible base of ‘DerivedPri’
     Base * pdd2 = new DerivedPri;
                       ^

<ex>
// cxx-ctor-access

namespace cxx_ctor_access
{
  class Bar
  {
    public:
      Bar() : mesg_() {}

      Bar(string const& mesg) : mesg_(mesg) {}

      // copy ctor
      Bar(Bar const& bar)
      {
        mesg_ = bar.mesg_;
        os_ << mesg_ << " and copy ctor";
      }

      string return_mesg()
      {
        return os_.str();
      }

    private:
      ostringstream os_;
      string mesg_;
  };
  
  class Foo
  {
    public:
      Foo() : mesg_() {}

      Foo(string const& mesg) : mesg_(mesg) {}

      // copy ctor without const 
      Foo(Foo& foo)
      {
        mesg_ = foo.mesg_;
        os_ << mesg_ << " and copy ctor";
        foo.mesg_ = "xxx";
      }

      // raise error only when that's different type:
      //
      // cxx.cpp: In constructor ‘cxx_ctor_access::Foo::Foo(cxx_ctor_access::Bar&)’:
      // cxx.cpp:835:14: error: ‘std::string cxx_ctor_access::Bar::mesg_’ is private
      //        string mesg_;
      //               ^
      // cxx.cpp:855:13: error: within this context
      //          bar.mesg_ = "xxx";
      //              ^

      Foo(Bar& bar)
      {
        // both cause errors
        // mesg_ = bar.mesg_;
        // bar.mesg_ = "xxx";
      }

      string return_mesg()
      {
        return os_.str();
      }

    private:
      ostringstream os_;
      string mesg_;
  };

} // namespace

TEST(Ctor, Access)
{
  using namespace cxx_ctor_access;

  Foo foo1{"foo1"};
  
  Foo foo2(foo1);
  EXPECT_THAT(foo2.return_mesg(), "foo1 and copy ctor");
}


={============================================================================
*kt_dev_cxx_0000* cxx-cast cxx-named-cast
  
EC++27 minimize casting, MEC++02 

These casts are called named cast and these provides:

o. Easier-to-recognise style in code both for humans and for tools.

o. The more narrowly specified purpose and precision of meaning. 
   Better for a comipler to diagnose usuage errors.


{careful-about-cast}

<ex>
Uses function style cse. The both do exactly the same although doesn't feel
like a cast.

doSomething(Widget(15));
doSomething(static_cast<Widget>(15));


<do-not-assume-how-things-are-laid-out>
C++ can have an object that might have more than one address; that is when
pointed by a Base* pointer and when pointed by Derived*. This cannot happen in
C and other lanauages.

Derived d;
Base *pb = &d;

Sometimes, a base class pointer and derived class pointer values will not be
the same. When that's the case, an offset is applied at runtime to the
Derived* pointer to get the correct Base* pointer value. DO not use "I know
how things are laid out" casts.


<cast-means-more-code>
The cast do nothing but tell compilers to treat one type as another? Mistaken
since type conversion often lead to 'additional' code that is executed at
runtime. 

int x, y;
...
double d = static_cast<double>(x)/y;

Use division but use floating point division.


<cast-create-a-temp-object> 
Assume that a virtual function in derived class call their base class
counterparts first.

class Window 
{
  virtual void onResize() {...}
};

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      static_cast<Window>(*this).onResize();
      ...
    }
    ...
};

It does call onResize but on the temp object. WHY? The solution is:

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      Window.onResize();
      ...
    }
    ...
};


<cast-is-expensive>
The dymamic_cast is expensive and slow since often is implemented using string
comparison in the hierarchy. The compier supports 'upcast' that is implicit
derived-to-base conversion so a base pointer can point either base object and
derived object. How to know which? 

The need for dynamic cast arises when want to use derived class ops on what
you believe to be a derived class objects 

"via base pointer or reference." ??? 

This example is repeated in *kt_dev_cpp_022* inheritance

class Window { ... };
class SpecialWindow: public Window {
  public:
    void blink();
};

typedef std::vector< std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow *psw = dynamic_cast<SpecialWindow*> (iter->get()))
    psw->blink();
}

Here used dymamic_cast to meet the condition which only derived class supports
blink(). To avoid this dymamic_cast, two approaches:


<solution-one>
typedef std::vector< std::shared_ptr<SpecialWindow>> VPW;

But, do not support all possible window derivatives.

<solution-two>
Use virtual mechanism. 

class Window {
  public:
    virtual void blink() {}     
    // default impl is no-op. see *kt_dev_ecpp_010* for why it can be a bad idea
};

class SpecialWindow : public Window {
  public:
    virtual void blink() { ... }
};

<other-things-to-remember>
Avoid cascading dynamic cast and try to hide cast inside a function.

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow1 *psw = dynamic_cast<SpecialWindow1*> (iter->get()))
    psw->blink();
  else if( SpecialWindow2 *psw = dynamic_cast<SpecialWindow2*> (iter->get()))
    psw->blink();
  ...
}


{cpp-cast-read}
http://www.cplusplus.com/doc/tutorial/typecasting/

<implicit-conversions-with-classes>
In the world of classes, 'implicit' conversions can be controlled by means of
three member functions:

  Single-argument constructors *cpp-single-ctor* allow implicit conversion
  from a particular type to initialize an object. *cxx-conversion-ctor*

  Assignment operator: allow implicit conversion from a particular type on
  assignments.  

  Type-cast operator: allow implicit conversion to a particular type.
  *cxx-conversion-op*


#include <iostream>
using namespace std;

class A {};

class B {
  public:
    // conversion from A (constructor):
    B (const A& x) {}

    // conversion from A (assignment):
    B& operator= (const A& x) {return *this;}

    // conversion to A (type-cast operator)
    operator A() {return A();}
};

int main ()
{
  A foo;
  B bar = foo;    // calls constructor
  bar = foo;      // calls assignment
  foo = bar;      // calls type-cast operator
  return 0;
}

The type-cast operator uses a particular syntax: it uses the operator keyword
followed by the destination type and an empty set of parentheses. Notice that
the return type is the destination type and thus is not specified before the
operator keyword.


<type-casting>
C++ is a strong-typed language. Many conversions, specially those that imply a
different interpretation of the value, require an 'explicit' conversion, known
in C++ as type-casting. There exist two main syntaxes for generic
type-casting: functional and c-like:

double x = 10.3;
int y;

y = int (x);    // functional notation
y = (int) x;    // c-like cast notation

The functionality of these generic forms of type-casting is enough for most
needs with fundamental data types. 

However, these operators can be applied indiscriminately on classes and
pointers to classes, which can lead to code that - while being syntactically
correct - can cause runtime errors. For example, the following code compiles
'without' errors: 

// class type-casting
#include <iostream>
using namespace std;

class Dummy {
  double i,j;
};

class Addition {
    int x,y;

  public:
    Addition (int a, int b) { x=a; y=b; }
    int result() { return x+y;}
};

int main () {
  Dummy d;
  Addition * padd;
  padd = (Addition*) &d;
  cout << padd->result();
  return 0;
}

The program declares a pointer to Addition, but then it assigns to it a
reference to an object of another 'unrelated' type using explicit
type-casting:

`unrestricted explicit` type-casting allows to convert any pointer into any
other pointer type, independently of the types they point to. The subsequent
call to member result will produce either a run-time error or some other
unexpected results.

In order to control these types of conversions 'between' classes, we have four
specific casting operators: dynamic_cast, reinterpret_cast, static_cast and
const_cast. Their format is to follow the new type enclosed between
angle-brackets (<>) and immediately after, the expression to be converted
between parentheses.

dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)

The traditional type-casting equivalents to these expressions would be:

(new_type) expression
new_type (expression)

but each one with its own special characteristics:


{cxx-cast-dynamic-cast}
dynamic_cast can only be used `with pointers and references to classes` (or
    with void*). Its purpose is to ensure that the result of the type
conversion points `to a valid complete object` of the destination pointer
type.

This naturally includes pointer 'upcast' (converting from pointer-to-derived
    to pointer-to-base), in the same way as allowed as an implicit conversion.
DONE BY COMPILER.

But dynamic_cast can also 'downcast' (convert from pointer-to-base to
    pointer-to-derived) `polymorphic classes (those with virtual members)`
`if-and only if` the pointed object is a valid 'complete' object of the target
type. 

<ex>
TEST(Rtti, DynamicCast)
{
  using namespace cxx_rtti;

  {
    RttiDerived d;

    auto result = dynamic_cast<RttiBase*>(&d);
    EXPECT_TRUE(result != NULL);

    RttiBase *bp = dynamic_cast<RttiBase*>(&d);

    // "derived is a subclass of base"
    EXPECT_THAT(bp, Ne(nullptr));
  }

  {
    try {
      RttiDerived dp1;

      // upcast
      RttiBase* pbase1 = new RttiDerived;

      RttiBase* pbase2 = new RttiBase;

      RttiBase* pbase3;
      RttiDerived* pderived;

      // derived to derived, okay.
      //
      // *cxx-dtor-non-virtual-destruction-problem* when no virtual keyword in
      // class definition
      //
      // cxx.cpp:4138:51: error: cannot dynamic_cast ‘pbase1’ (of type ‘class cxx_rtti::RttiBase*’) to type ‘class cxx_rtti::RttiDerived*’ (source type is not polymorphic)
      //        pderived = dynamic_cast<RttiDerived*>(pbase1);

      pderived = dynamic_cast<RttiDerived*>(pbase1);
      EXPECT_THAT(pderived, Ne(nullptr));

      // downcast from base to derived, fails since pbase2 is not complete objedct
      pderived = dynamic_cast<RttiDerived*>(pbase2);
      EXPECT_THAT(pderived, nullptr);

      // upcast from derived to base

      pbase3 = dynamic_cast<RttiBase*>(pbase1);
      EXPECT_THAT(pbase3, Ne(nullptr));

      pbase3 = dynamic_cast<RttiBase*>(&dp1);
      EXPECT_THAT(pbase3, Ne(nullptr));

    } catch (exception& e) {cout << "Exception: " << e.what();}
  }
}


Compatibility note: This type of dynamic_cast requires RTTI to keep track of
dynamic types. Some compilers support this feature as an option which is
disabled by default. This needs to be enabled for runtime type checking using
dynamic_cast to work properly with these types.

The code above tries to perform two dynamic casts from pointer objects of type
Base* (pba and pbb) to a pointer object of type Derived*, but only the first
one is successful. Notice their respective initializations:

Even though both are pointers of type Base*, pba actually points to an object
of type Derived, while pbb points to an object of type Base. Therefore, when
their respective type-casts are performed using dynamic_cast, pba is pointing
to a full object of class Derived, whereas pbb is pointing to an object of
class Base, which is an incomplete object of class Derived.


<for-pointer>
When dynamic_cast cannot cast a pointer because it is not a complete object of
the required class, `returns a null pointer to indicate the failure.`

<for-reference>
If dynamic_cast is used to convert to a reference type and the conversion is
not possible, an exception of type `bad_cast` is thrown instead.

dynamic_cast can also perform the other implicit casts allowed on pointers:
casting null pointers between pointers types (even between unrelated classes),
        and casting any pointer of any type to a void* pointer.


*cxx-static-cast* converts 

  o between `related types` such as one pointer type to another in the same
    class hierarchy,
        
  *cxx-enum*
  o an integral type to an enumeration, or a floating-point type to an
    integral type

  o conversions defined by constructors and conversion operators.

  *cxx-void*
  o from void* to any pointer type. In this case, it guarantees that if the
    void* value was obtained by converting from that same pointer type, the
    resulting pointer value is the same.


*cxx-reinterpret-cast* converts 

  o between `unrelated types` such as integer to a pointer or a pointer to an
    unrelated pointer type.

    class A { /* ... */ };
    class B { /* ... */ };
    A * a = new A;
    B * b = reinterpret_cast<B*>(a);
    
    This code compiles, although it does not make much sense, since now b
    points to an object of a totally unrelated and likely incompatible class.
    Dereferencing b is unsafe.

  o The conversions that can be performed by reinterpret_cast but not by
    static_cast are low-level operations based on reinterpreting the binary
    representations of the types, which on most cases results in code which is
    system-specific, and thus non-portable. For example:

    int *p;
    char *pc = reinterpret_cast<char*>(ip);


{cpp-cast-const-cast}
This manipulates the constness of the object pointed by a pointer, either to
'set' or to 'remove'. For example, in order to pass a const pointer to a
function that expects a non-const argument:

<remove-const-cast>

#include <iostream>
using namespace std;

void print (char * str)
{
  cout << str << '\n';
}

int main () {
  const char * c = "sample text";
  print ( const_cast<char *> (c) );
  return 0;
}

The example above is safe because function print does not write to the pointed
object. 


<cpp-const-undefined> *cpp-undefined*
After removing the constness of a pointed object, writing to it causes
'undefined' behavior since compiler store it in read-only memory as an
optimisation.


<set-const-cast>
From CPR 233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
  return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
  auto &r = shorterString(const_cast<const string&>(s1), 
                          const_cast<const string&>(s2));

  return const_cast< string& >(r);
}

This is safe to cast the const string back to a plain string and return it
because it is one of original nonconst arguments.


{cpp-cast-error}

sanitizer_symbolizer_posix_libcdep.cc:78:77: 
error: ISO C++ forbids casting between pointer-to-function and pointer-to-object [-Werror]
   swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, "swift_demangle");
                                                                             ^
cc1plus: all warnings being treated as errors


// As of now, there are no headers for the Swift runtime. Once they are
// present, we will weakly link since we do not require Swift runtime to be
// linked.
typedef char *(*swift_demangle_ft)(const char *mangledName,
                                   size_t mangledNameLength, char *outputBuffer,
                                   size_t *outputBufferSize, uint32_t flags);
static swift_demangle_ft swift_demangle_f;

// This must not happen lazily at symbolication time, because dlsym uses
// malloc and thread-local storage, which is not a good thing to do during
// symbolication.
static void InitializeSwiftDemangler() {
  swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, "swift_demangle");
}


// to get around this
static char *(*`swift_demangle_f`)(const char *mangledName,
                                   size_t mangledNameLength, char *outputBuffer,
                                   size_t *outputBufferSize, uint32_t flags);

From C99 spec, section 6.2.5, paragraph 27:

    A pointer to void shall have the same representation and alignment
    requirements as a pointer to a character type. Similarly, pointers to
    qualiﬁed or unqualiﬁed versions of compatible types shall have the same
    representation and alignment requirements. All pointers to structure types
    shall have the same representation and alignment requirements as each
    other. All pointers to union types shall have the same representation and
    alignment requirements as each other. `pointers to other` types need not
    have the same representation or alignment requirements.

So no; no guarantee that a void * can hold a function pointer(pointers to
    other).

And section 6.3.2.3, paragraph 8:

    A pointer to a function of one type may be converted to a pointer to a
    function of another type and back again; the result shall compare equal to
    the original pointer.

implying that one function pointer type can hold any other function pointer
value. Technically, that's not the same as guaranteeing that function-pointer
types can't vary in size, merely that their values occupy the same range as
each other.


={============================================================================
*kt_dev_cxx_0000* cxx-rtti

{cxx-rtti} CPR 19.2 825
The RTTI(run-time type identification) is provided through two operators:

* `typeid` operator, which returns the type of a given expression
* `dynamic_cast` operator, which 'safely' coverts base type pointer or reference
  into ones to a derived type

These operators are useful when we have a derived operation that we want to
perform through a pointer or reference to a base type and it is not possible to
make that operation a virtual function since when the operation is virtual, the
compiler automatically selects the right function.

note:
Ordinarily, 'should' use virtual 'functions' if we can since RTTI is more
error-prone and the programmer must know to which type the object should be cast
and must check that the cast was successful.


{cxx-rtti-dynamic-cast}
The only requirement is that the object argument is a polymorphic type, which
means that it has at least one virtual function.

dynamic_cast<type*>(e);
dynamic_cast<type&>(e);
dynamic_cast<type&&>(e);

If e has one of these types, the the call will succeed. Otherwise, the cast
fails and the result is 0. If the cast to a `reference` type fails, throws an
`bad_cast` exception.

class RttiBase 
{
  public:
    // to make it polymorphic
    ~RttiBase() {}

  private:
    int id_;
};

class RttiDerived : public RttiBase 
{
  private:
    int value_;
};

TEST(Rtti, UseDynamicCast)
{
  RttiDerived d;

  auto result = dynamic_cast<RttiBase*>(&d);
  EXPECT_TRUE(result != NULL);

  // if (RttiBase *bp = dynamic_cast<RttiBase*>(&d))
  //   cout << "derived is a subclass of base" << endl;
  // else
  //   cout << "derived is NOT a subclass of base" << endl;
}

note:
By defining the variable in a condition, cast and check as a single operation.
Moreover, bp is not accessible outside the if. If the cast fails, then the
unbound pointer is not available.


{cxx-rtti-typeid}
The `typeid` allows to check the type of an expression or type name.

typeid (e);

This operator returns a reference to a constant object of type `type_info` that is
defined in the standard header typeinfo. A value returned by typeid can be
compared with another value returned by typeid using operators == and != or can
serve to obtain a null-terminated character sequence representing the data type
or class name by using its name() member.

class RttiBase 
{
  private:
    int id_;
};

class RttiDerived : public RttiBase 
{
  private:
    int value_;
};

TEST(Rtti, UseTypeid)
{
  RttiBase b, bb;
  RttiDerived d;
  bool result{};

  result = (typeid(b) == typeid(d));
  EXPECT_EQ(result, false);

  result = (typeid(b) == typeid(bb));
  EXPECT_EQ(result, true);

  result = (typeid(d) == typeid(RttiDerived));
  EXPECT_EQ(result, true);
}


{using-rtti}
An example when RTTI might be useful. Consider a class hierarchy for which
implements the equality operator. Equals if they have the same type an same
value for data members. Each derived type may add its own data members.

Use virtual equality operator that operates on reference to the base type?

This strategy doesn't quite work since virtual function must have the same
parameter type in hierarchy and which is a reference to the base type. This
means that equal function could use 'only' members from the base type.

class Base {
  friend bool operator==(const Base&, const Base&);

  public:
    //
  protected:
    virtual bool equal(const Base&) const;
};

class Derived : public Base {
  protected:
    virtual bool equal(const Base&) const;
};


// return false if typeids are different; otherwise makes a virtual call to
// equal.

bool operator==(const Base &lhs, const Base &rhs)
{
  return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

// the cast always succeed since type check is done already. Why do dynamic cast
// then? Because needs to access the members of rhs but not funtions.

bool Derived::equal(const Base& rhs) const
{
  auto r = dynamic_cast<const Derived&>(rhs);

  // do whatever is required to compare two objects.
}

bool Base::equal(const Base& rhs) const
{
  // do whatever is required to compare two objects.
}


{typeinfo}
The exact definition of the type_info varies by compiler but the standard
gurantees that the class will provide at least the operations:

t1 == t2
t1 != t2
t.name();
t1.before(t2);

The string returned by member name of type_info depends on the specific
implementation of your compiler and library. The only guarantee is that it
returns a unique string for each type.

<ex>
#include <iostream>
#include <typeinfo>

using namespace std;

int main () {
  int *a, b;
  a=0; b=0;
  if (typeid(a) != typeid(b))
  {
    cout << "a and b are of different types:\n";
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
  }
  return 0;
}

// on GCC 4.6.3, VM.
a and b are of different types:
a is: Pi
b is: i

// on the text.
a and b are of different types:
a is: int *
b is: int  


<ex>
// typeid, polymorphic class
#include <iostream>
#include <typeinfo>
#include <exception>
using namespace std;

class Base { virtual void f(){} };
class Derived : public Base {};

int main () {
  try {
    Base* a = new Base;
    Base* b = new Derived;
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
    cout << "*a is: " << typeid(*a).name() << '\n';
    cout << "*b is: " << typeid(*b).name() << '\n';
  } catch (exception& e) { cout << "Exception: " << e.what() << '\n'; }
  return 0;
}

// on GCC 4.6.3, VM.
a is: P4Base
b is: P4Base
*a is: 4Base
*b is: 7Derived

// on the text.
a is: class Base *
b is: class Base *
*a is: class Base
*b is: class Derived

Notice how the type that typeid considers for pointers is the pointer type
itself, static type. However, when typeid is applied to objects typeid yields
their dynamic type.

If the type that typeid evaluates is a pointer preceded by the dereference
operator (*), and this pointer has a null value, typeid throws a bad_typeid
exception.


={============================================================================
*kt_dev_cxx_0000* cxx-override

{cxx-override-when-do-not-work}
Believe that made an override and expect that derived version gets called. no
compile error and why? Two things:

namespace cxx_override
{
  namespace no_override
  {
    class Base
    {
      public:
        Base() : base_(10) {}

        virtual int get_value()
        { return base_; }

      private:
        int base_;
    };

    class Derived: public Base
    {
      public:
        Derived() : derived_(20) {} 

        virtual int get_value(int value)
        { 
          (void)value;
          return derived_; 
        };

      private:
        int derived_;
    };
  } // namespace
} // namespace

TEST(Override, Condition_1)
{
  using namespace cxx_override::no_override;

  // No override since it do not meet *cxx-override-condition* Hence no vtable
  // update and base version called.
  {
    Derived derived;
    Base* pbase = &derived;
    EXPECT_THAT(pbase->get_value(), 10);
  }

  // cxx.cpp: In member function ‘virtual void Override_Condition_Test::TestBody()’:
  // cxx.cpp:4285:34: error: no matching function for call to ‘cxx_override::no_override::Derived::get_value()’
  //      EXPECT_THAT(pbase->get_value(), 20);
  //
  // Effectively defines a new function in the derived, inner scope, name found
  // and stops lookup. so hide the name in the base in *cxx-name-lookup* 
  //
  // {
  //   Derived derived;
  //
  //   // see Derived
  //   Derived* pbase = &derived;
  //
  //   EXPECT_THAT(pbase->get_value(), 20);
  // }
}


{cxx-override-condition} *cxx-dtor-non-virtual-destruction-problem*
To override:

name, parameter type, `cxx-const`, and return type `should be the same` 

An exception to this when return type is a pointer or reference. Tried pointer
return type, no errors so return type in overrides can be different only that
is pointer. See p606 in ref-CPR.

EC++33. do not find any useful or practical.
EC++36. If you redefine non-virtual, it hides names. The other problem is to
exhibit 'inconsistent' behavior depending on type of pointer used.

namespace cxx_override
{
  namespace no_virtual
  {
    class Base
    {
      public:
        Base() : base_(10) {}

        int get_value()
        { return base_; }

      private:
        int base_;
    };

    class Derived: public Base
    {
      public:
        Derived() : derived_(20) {} 

        int get_value()
        { return derived_; };

      private:
        int derived_;
    };
  } // namespace
} // namespace

TEST(Override, Condition_2)
{
  using namespace cxx_override::no_virtual;

  // No override happens since there is no virtual used.
  {
    Derived derived;
    Base* pbase = &derived;
    EXPECT_THAT(pbase->get_value(), 10);
  }

  {
    Derived derived;
  
    // see Derived
    Derived* pderived = &derived;
  
    EXPECT_THAT(pderived->get_value(), 20);
  }
}

namespace cxx_override
{
  namespace with_virtual
  {
    class Base
    {
      public:
        Base() : base_(10) {}

        virtual int get_value()
        { return base_; }

      private:
        int base_;
    };

    class Derived: public Base
    {
      public:
        Derived() : derived_(20) {} 

        int get_value()
        { return derived_; };

      private:
        int derived_;
    };
  } // namespace
} // namespace

TEST(Override, Condition_3)
{
  using namespace cxx_override::with_virtual;

  {
    Derived derived;
    Base* pbase = &derived;

    // now override works
    EXPECT_THAT(pbase->get_value(), 20);
  }

  {
    Derived derived;
  
    // see Derived
    Derived* pderived = &derived;
  
    EXPECT_THAT(pderived->get_value(), 20);
  }
}


namespace cxx_override
{
  namespace with_virtual_and_private
  {
    class Base
    {
      public:
        Base() : base_(10) {}

        virtual int get_value()
        { return base_; }

      private:
        int base_;
    };

    class Derived: private Base
    {
      public:
        Derived() : derived_(20) {} 

        int get_value()
        { return derived_; };

      private:
        int derived_;
    };
  } // namespace
} // namespace

// TEST(Override, Condition_4)
// {
//   using namespace cxx_override::with_virtual_and_private;
// 
//   {
//     Derived derived;
// 
//     // *cxx-error*
//     // cxx.cpp:4864:20: error: ‘cxx_override::with_virtual_and_private::Base’ is an inaccessible base of ‘cxx_override::with_virtual_and_private::Derived’
//     //
//     //      Base* pbase = &derived;
//     //                     ^
//     // means that *cxx-override* must use public inheritance
// 
//     Base* pbase = &derived;
// 
//     // now override works
//     EXPECT_THAT(pbase->get_value(), 20);
//   }
// 
//   {
//     Derived derived;
//   
//     // see Derived
//     Derived* pderived = &derived;
//   
//     EXPECT_THAT(pderived->get_value(), 20);
//   }
// }


{cxx-override-keyword} {cxx-final-keyword}
*cxx-override-when-do-not-work* is surprisingly hard(really?) to find because
there is no compile error. To avoid this, use *cxx-override* keyword from
*cxx-11* and cause compile error when it's not overrided:

using namespace std;

class Base {
  public:
    virtual int fcn() { cout << "base: fcn" << endl; }
};

class D1 : public Base {
  public:
    int fcn(int) `override` { cout << "d1  : fcn(int) " << endl; }
};

class D2 : public D1 {
  public:
    int fcn(int) `final` { cout << "d1  : fcn(int) " << endl; }
    int fcn() { cout << "d2  : fcn" << endl; }
};

int main()
{
  D1 d1obj;
  Base* bp = &d1obj;
  bp->fcn();
}

:12:9: error: ‘int D1::fcn(int)’ marked override, but does not override
     int fcn(int) override { cout << "d1  : fcn(int) " << endl; }
         ^

The *cxx-final* keyword is used to end cxx-override as with cxx-final in
inheritance.


{cxx-override-access-control} *cxx-access-control*
override do not respect access-control in derived class.

namespace OR3 {

using namespace std;

class B0 {
  public:
    virtual int calls_public() { cout << "B0::calls_public" << endl; }
    virtual int calls_private() { cout << "B0::calls_private" << endl; }
    virtual int calls_protected() { cout << "B0::calls_protected" << endl; }
};

class D1 : public B0 {
  public:
    int calls_public() { cout << "D1::calls_public" << endl; }
  protected:
    int calls_private() { cout << "D1::calls_private" << endl; }
  private:
    int calls_protected() { cout << "D1::calls_protected" << endl; }
};

}

// = 04 ======
// D1::calls_public
// D1::calls_protected
// D1::calls_private

void t_override_04()
{
    using namespace OR3;

    D1 dobj;
    B0* p = &dobj;
    p->calls_public();
    p->calls_protected();
    p->calls_private();
}


{which-virtuals}
EC++34 

When design classes, should think 'three', pure virtual, virtual, and
non-virtual, separately to specify with precision what you want derived
classes to inherit.

o Pure virtual (abstract). To have 'only' interface inherited. *cxx-interface* 

o (Simple) virtual (overridable). To have interface and 'default'
  implementation.


<no-separation-between-interface-and-default-implementation> *cxx-class-model-inheritance*
When use simple virtual, shall be careful since 'default' implementation is
inherited without 'request' from the derived. This can be a problem when the
derived do not redefine it.

class Airplane {
  public:
    virtual void fly( const Airport& destination ) 
    { // code for usual plane type. default; }
    ...
};

class ModelA : public Airplane { ... };
class ModelB : public Airplane { ... };
class ModelC : public Airplane { ... };

Although this is classic OOD, has a problem. This is okay for model A and B but
not C because C is different type of plane that has different way to fly and
should have defined own fly(). 

*cxx-remember* 
If C has forgot to redefine own, it will use the default. The solution is to
'force' the derived explicitly request implementation if they need.


o use *cxx-abc* to force it override 

Has separation between interface and default implementation.

class Airplane {
  public:
    virtual void fly( const Airport& destination ) = 0;  // pure and interface
    ...
  protected:
    void defaultFly( ... );                              // implementation
};

void Airplane::defaultFly( ... )
{
   // code for usual plane type. default;
}

class ModelA : public Airplane {
  public:
    virtual void fly( ... ) { `defaultFly( ... );` }    // explicit request
};

class ModelC : public Airplane {
  public:
    virtual void fly( ... ) { specific code for model C type }
};

The derived have to explicitly ask default implementation or if forget to
redefine ModelC::fly then will get errors in compile time because cannot
create ModelC objects. That's because ModelC is ABC.


o use the fact that *cxx-abc* pure virtual can have implementation

To avoid having a separate function for default implementation, use the fact
that pure virtual can have its implementation and use it instead 

class Airplane {
  public: 
    virtual void fly( const Airport& destination ) = 0; // make a pure
};

// pure virtual implementation
void Airplane::fly( ... )
{
   code for usual plane type. default.
}

class ModelA : public Airplane {
  public:
    virtual void fly( ... )  { `Airplance::fly( ... );` }  // explicit
};

class ModelC : public Airplane {
  public:
    virtual void fly( ... ) { specific code for model C type }
};

The both approaches are the essentially same in that force the derived to
override, to request default implementation and if not override, emits errors.


o non-virtial, non non-overridable

Have interface and 'mandatory' implementation that is default implementation
but not overridable. 


={============================================================================
*kt_dev_cxx_0000* cxx-override-ref: C++ under the hood, Scott Meyers

<1>
http://www.han-ese.nl/~ewout/ESE/INF2/CPP_onder_de_motorkap.pdf

Overview

This talk offers a detailed look at how C++ compilers typically implement
language features, focusing on the cost of those features - or, more
typically, the lack thereof - compared to equivalent functionality in C. It
begins with an extremely detailed examination of the implementation of virtual
functions under both single and multiple inheritance, explaining how
performance considerations have influenced both the design and implementation
of this language feature. It then moves to an overview of the implementation
of all other features of C++, dividing them into "no-cost" and "low-cost"
categories. The information in this paper is an overview of more detailed
information covered in the conference presentation.

Implementing Virtual Functions

Given a class such as this,

class B {
  public:
    B();
    virtual ~B();                            // 0
    virtual void f1();                       // 1
    virtual int f2(char c) const;            // 2
    virtual void f3(const std::string& s);   // 3
    void f4() const;
};

Compilers number the virtual functions in the order in which they are
encountered. Different compilers may start the numbering with different
values, but it's common to start counting at 0. Assuming 0 is the initial
value, the virtuals in B would be numbered as indicated by the comments. Note
that neither B's constructor nor its member function f4 receive numbers.
That's because they're not virtual functions, hence are implemented
differently - like non-member functions, which themselves are implemented like
functions in C.

`For each class with at least one virtual function`, compilers generate a
virtual function table, `vtbl`. A vtbl is an array of function pointers such
that the n th entry of the table points to the implementations of the virtual
function numbered n. B's vtbl would look like this:

B's vtbl []    -> impl of B::~B
         []    -> impl of B::f1
         []    -> impl of B::f2
         []    -> impl of B::f3

In the case of pure virtual functions, there is typically no implementation to
point to. In that case, the vtbl slot for the function generally points to a
compiler-generated function that, when called, issues a runtime error message
(e.g., "Pure virtual function called") and exits the program. 

Consider now a derived class D :

class D: public B {
  public:
    D();                          // nonvirtual  - no number
    virtual ~D();                 // redefined   - number 0 (as in base class)
    virtual void f1();            // redefined   - number 1 (as in base class)
    virtual void f5(char *str);   // new virtual - number 4
};

Compilers set up a vtbl for D in the same way they do for B, except that when
D redefines a virtual function it inherits, that function gets the same number
in D as in B. D's vtbl thus looks like this:

D's vtbl []    -> impl of D::~D
         []    -> impl of D::f1
         []    -> impl of B::f2
         []    -> impl of B::f3
         []    -> impl of D::f5

Note that in cases where D inherits its virtual function implementations from
B, D's vtbl points to functions implemented in B. This reveals that the cost
of a virtual function call is independent of the depth of the hierarchy. At
runtime, when a virtual is to be called, there is no need to search the
hierarchy for the "right" implementation, because the hierarchy was flattened
during construction of the vtbls.  

Every object of a class with at least one virtual function contains a virtual
table pointer, `vptr`. This pointer is added by the compiler, and its location
may vary from compiler to compiler. An object's vptr points to the vtbl
appropriate for the type of the object; compilers automatically insert code to
achieve this into constructors and destructors. note: to set vptr. At runtime
we could have the following situation where all B objects have a vptr pointing
to B's vtbl and all D objects have a vptr pointing to D's vtbl:

For the following C++ source code,

void makeACall(B *pB)
{
  // call the implementation of f1 appropriate for whatever type of object pB
  // points to

  pB->f1(); 
} 

Compilers emit code equivalent to this:

(*pB->vptr[1])(pB); 

Call the function pointed to by vtbl entry 1 (f1's number/index) in the vtbl
pointed to by pB->vptr; pass pB as the "this" pointer

// this means that the code to select 1 entry in the vtbl is done at compile
// time but still need to decide what pB actually points at runtime.
// "pass pB as the "this" pointer"


Virtual Functions Under Multiple Inheritance

Under multiple inheritance (MI), a new issues arises: a single object has
multiple addresses, and different addresses need to be passed to different
functions. For example, suppose D has two base classes

class B1 { ... };
class B2 { ... };
class D: public B1, public B2 { ... };

A D object can be pointed to by pointers of any of three different types
(excluding void*): B1*, B2*, or D*. 

At runtime, such an object is likely to be laid out in memory like this, where
the diagram shows where pointers of each of these different types point:

B1*, D* ->  B1 data
B2*     ->  B2 data
            D data

Given these functions,

void f(B1 *pb1);  // expects pb1 to point to the top of a B1
void g(B2 *pb2);  // expects pb2 to point to the top of a B2

consider:

D *pd = new D;    // pD points to top of object

// fine, f expects a pointer to top of object
f(pd);            

// pointer adjustment required : g expects a pointer to B2 part of object
g(pd);            

In fact, offset adjustments may be necessary even for something as simple as a
pointer initialization:

B2 *pb2 = pd;     // pb2 should point to B2 part of object, not to top


Unfortunately, the need for an offset adjustment may not be determinable
during compilation. For example, given this hierarchy

class B1 {
  public:
    virtual void mf();     // may be overridden in derived classes
};

class B2 {
  public:
    virtual void mf();     // may be overridden in derived classes
};

and this implementation of g,

void g(B2 *pb2)
{
  pb2->mf();               // offset adjustment required?
}

The this pointer passed to mf may or may not require an offset adjustment. If
the mf called is implemented in B2, no adjustment is needed, but if the mf
called is implemented in B1 or D, an adjustment typically is required. During
compilation, however, there is no way to know the type of object pb2 points
to, hence no way to know which implementation of mf is being called.

<key> Compilers 'solve' this problem by creating 'extra' vptrs and vtbls in MI
hierarchies. In particular a class with n 'base' classes can be expected to
give rise to objects with n vptrs and n vtbls, e.g.:

note: this means extra vptr and vtbl entry(trunk) for each additional 'base' class
note: Here again, single inheritance means one level of inheritance so single inheritance is
different from single hierachy of inheritance.

B1*, D* ->  B1/D vptr   -> D vtbl [] impls of virtuals declared in B1 or D (and maybe B2)
            B1 data
B2*     ->  B2 vptr     -> D as B2 vtbl [] impls of virtuals declared in B2
            B2 data
            D data

When compilers generate code for a call to a virtual function, they 'know'
which vptr they are using hence where the object pointer currently points and
they know which vtbl they are using hence the this pointer expected by the
function pointed to by each vtbl entry, so they can determine whether an
offset adjustment is required for the call.


The code for the offset adjustment itself is typically placed in a thunk 
- a small piece of code not part of any function. Vtbl entries 'requiring'
offset adjustments then point to thunks, and thunks forward calls to the
target function implementation after performing the offset:

<key> 
In the above example, called g(B2*) with D and D's version should be called.
However, B2's vtable entry has B2's version and so update that entry with
trunk which adjust this to D and call D's version. See <understand-trunk> for
more. Thunks themselves are often implemented as alternative vtbl function
entry points:

This treatment of the implementation of virtual functions under MI is still
incomplete, because it fails to take into account the possibility of virtual
base classes, but, as Stan Lippman comments in Inside the C++ Object Model ,
     "Virtual base class support wanders off into the Byzantine...The material
     is simply too esoteric to warrant discussion...." 

However, one thing should be clear: virtual functions are implemented very
efficiently. In fact, their implementation is both smaller and faster than
most C approximations (e.g., anything based on cascading if/then/else type
    tests).

note: this article has lots of references to refer to when necessary.


<2>
Visual C and C++ (General) Technical Articles

C++: Under the Hood Jan Gray March 1994

Jan Gray is a Software Design Engineer in Microsoft's Visual C++ Business Unit.
He helped design and implement the Microsoft Visual C++ compiler. 

Introduction

It is important to understand how your programming language is implemented. Such
knowledge dispels the fear and wonder of "What on earth is the compiler doing
here?"; imparts confidence to use the new features; and provides insight when
debugging and learning other language features. It also gives a feel for the
relative costs of different coding choices that is necessary to write the most
efficient code day to day. This paper looks "under the hood" of C++, explaining
"run-time" C++ implementation details such as class layout techniques and the
`virtual-function-call-mechanism`.

Questions to be answered include: 

1. How are classes laid out?  
2. How are data members accessed?
3. How are member functions called?
4. What is an adjuster thunk?
5. What are the costs: Of single, multiple, and virtual inheritance? Of virtual
functions and virtual function calls?  Of casts to bases, to virtual bases? Of
exception handling? 

First, we'll look at struct layout of C-like structs, single inheritance,
multiple inheritance, and virtual inheritance, then consider data member access
  and member functions, virtual and not. We'll examine the workings of
  constructors, destructors, and assignment operator special member functions
  and dynamic construction and destruction of arrays. Finally, we'll briefly
  consider the impact of exception-handling support. For each language feature
  topic, we'll very briefly present motivation and semantics for the language
  feature (although "Introduction to C++" this is not), and examine how the
  language feature was implemented in Microsoft Visual C++. Note the distinction
  between abstract language semantics and a particular concrete implementation.
  Other vendors have sometimes made different implementation choices for what
  ever reasons. In a few cases we contrast the Visual C++ implementation with
  others. 


Class Layout

In this section we'll consider the storage layouts required for different kinds
of inheritance.

C-like Structs

As C++ is based upon C, it is "mostly" upwards-compatible with C. In particular,
the working papers specify the same simple struct layout rules that C has:
  Members are laid out in their declaration order, subject to implementation
  defined alignment padding. All C/C++ vendors ensure that valid C structs are
  stored identically by their C and C++ compilers.

Here A is a simple C struct with the obvious expected member layout and padding.

A*->   A::c (padding)
       A::i

struct A {
  char c;
  int i;
}; 


C-like Structs with C++ Features

Of course, C++ is an object-oriented programming language: It provides
inheritance, encapsulation, and polymorphism by extending the mundane C struct
into the wondrous C++ class. Besides data members, C++ classes can also
encapsulate member functions and many other things. However, except for 'hidden'
data members introduced to implement virtual functions and virtual inheritance,
     the instance size is 'solely' determined by a class's data members and base
     classes.

Here B is a C-like struct with some C++ features : There are
public/protected/private access control declarations, member functions, static
members, and nested type declarations. Only the non-virtual data members occupy
space in each instance. Note that the standards committee working papers permit
implementations to reorder data members separated by an access declarator, so
these three members could have been laid out in 'any' order. (In Visual C++,
    members are always laid out in declaration order, just as if they were
    members of a C struct) 

B*->   B::bm1
       B::bm2
       B::bm3

struct B {
  public:
    int bm1;
  protected:
    int bm2;
  private:
    int bm3;
    static int bsm;
    void bf();
    static void bsf();
    typedef void* bpv;
    struct N { };
};


Single Inheritance

C++ provides inheritance to factor out and share 'common' aspects of different
types. A good example of a classes-with-inheritance data type organization is
biology's classification of living things into kingdoms, phyla, orders,
  families, genus, species, and so on. This organization makes it possible to
  specify attributes, such as "mammals bear live young" at the most appropriate
  level of classification; these attributes are then inherited by other classes,
  so we can conclude without further sp ecification that whales, squirrels, and
  people bear live young. Exceptional cases, such as platypi (a mammal, yet lays
      eggs), will require that we override the inherited attribute or behavior
  with one more appropriate for the derived class. More on that later. 

In C++, inheritance is specified by using the ": base" syntax when defining the
derived class. Here D is derived from its base class C.

C* ->    C::c1

struct C {
  int c1;
  void cf();
};

C*, D* ->   C::c1
            D::d1

struct D : C {
  int d1;
  void df();
};

Since a derived class inherits all the properties and behavior of its base
class, each instance of the derived class will contain a `complete-copy` of the
instance data of the base class. Within D, there is no requirement that C's
instance data precede D's. But by laying D out this way, we ensure that the
address of the C object within D corresponds to the address of `the-first-byte`
of the D object. As we shall see, this eliminates adding a displacement to a D*
when we need to obtain the address of its embedded C. This layout is used by all
known C++ implementations.

Thus, in a single inheritance class hierarchy, new instance data introduced in
each derived class is simply appended to the layout of the base class. Note our
layout diagram labels the `address-points` of pointers to the C and D objects
within a D . 


Multiple Inheritance

Single inheritance is quite versatile and powerful, and generally adequate for
expressing the (typically limited) degree of inheritance present in most design
problems. Sometimes, however, we have two or more sets of behavior that we wish
our derived class to acquire. C++ provides multiple inheritance to combine them. 

For instance, say we have a model for an organization that has a class Manager
(who delegates) and class Worker (who actually does the work). Now how can we
model a class MiddleManager, who, like a Worker, accepts work assignments from
his/her manager and who, like a Manager, delegates this work to his/her
employees? This is awkward to express using single inheritance: For
MiddleManager to inherit behavior from both Manager and Worker, both must be
base classes. If this is arranged so that MiddleManager inherits from Manager
which inherits from Worker , it erroneously ascribes Worker behavior to
Managers. (Vice versa, the same problem.) Of course, MiddleManager could inherit
from just one (or neither) of Worker or Manager, and instead, duplicate
(redeclare) both interfaces, but that defeats polymorphism, fails to reuse the
existing interface, and leads to maintenance woes as interfaces evolve over
time.

Instead, C++ allows a class to inherit from multiple base classes:

struct Manager ... { ... };
struct Worker ... { ... };
struct MiddleManager : Manager, Worker { ... };

How might this be represented? Continuing with our "classes of the alphabet"
example: 

struct C {
  int c1;
  void cf();
};

E* ->   E::e1

struct E {
  int e1;
  void ef();
};

C*, F* ->   C::c1
    E* ->   E::e1
            F::f1

struct F : C, E {
  int f1;
  void ff();
}; 

Struct F multiply inherits from C and E. As with single inheritance, F contains
a copy of the instance data of each of its base classes. Unlike single
inheritance, it is not possible to make the address point of each bases'
embedded instance correspond to the address of the derived class: 
  
note: since E do not have C in it therefore E should not have the same point as
C.

F f;
// (void*)&f == (void*)(C*)&f;
// (void*)&f < (void*)(E*)&f; 

Here, the address point of the embedded E within F is not at the address of the
F itself. As we shall see when we consider casts and member functions, this
`displacement` leads to a small 'overhead' that single inheritance does not
generally require. An implementation is free to lay out the various embedded
base instances and the new instance data in any order. Visual C++ is typical in
laying out the base instances in `declaration-order`, followed by the new data
members, also in declaration order. (As we shall see, this is not necessarily
    the case when some bases have virtual functions and others don't). 


Virtual Inheritance

Returning to the MiddleManager example which motivated multiple inheritance in
the first place, we have a problem. What if both Manager and Worker are derived
from Employee?

struct Employee { ... };
struct Manager : Employee { ... };
struct Worker : Employee { ... };
struct MiddleManager : Manager, Worker { ... };

Since both Worker and Manager inherit from Employee, they each contain a copy of
the Employee instance data. Unless something is done, each MiddleManager will
contain 'two' instances of Employee, one from each base. If Employee is a large
object, this 'duplication' may represent an unacceptable storage overhead. More
seriously, the two copies of the Employee instance might get modified separately
or inconsistently. We need a way to declare that Manager and Worker are each
willing to share a single embedded instance of their Employee base class, should
Manager or Worker ever be inherited with some other class that also wishes to
share the Employee base class. In C++, this "sharing inheritance" is
(unfortunately) called `virtual-inheritance` and is indicated by specifying that
a base class is virtual.

struct Employee { ... };
struct Manager : virtual Employee { ... };
struct Worker : virtual Employee { ... };
struct MiddleManager : Manager, Worker { ... };

Virtual inheritance is considerably more 'expensive' to implement and use than
single and multiple inheritance. Recall that for single (and multiple) inherited
bases and derived classes, the embedded base instances and their derived classes
either share a common address point (as with single inheritance and the
    'leftmost' base inherited via multiple inheritance), or have a simple
'constant' displacement to the embedded base instance as with multiple inherited
non-leftmost bases, such as E.  

note: so use constant displacement for multiple inheritance.

With virtual inheritance, on the other hand, there can (in general) be no fixed
displacement from the address point of the derived class to its virtual base. If
such a derived class is further derived from, the further deriving class may
have to place the `one-shared-copy` of the virtual base at some other, different
offset in the further derived class. Consider this example: 

struct C {
  int c1;
  void cf();
};

struct G : virtual C {
  int g1;
  void gf();
}; 

G* -> G::vbptr    -> GdGvbptrG
      G::g1          GdGvbptrC
C* -> C::c1

struct H : virtual C {
  int h1;
  void hf();
}; 

H* -> H::vbptr    -> HdHvbptrH
      H::h1          HdHvbptrC
C* -> C::c1

struct I : G, H {
  int i1;
  void _if();
}; 

IdGvbptrC {              G*, *I ->  G::vbptr    -> IdGvbptrG
                                    G::g1          IdGvbptrC
            IdHvbptrC {  H* ->      H::vbptr    -> IdHvbptrH
                                    H::h1          IdHvbptrC
          }           }             I::i1
                         C* ->      C::c1

Ignoring the vbptr members for a moment, notice that within a G object, the
embedded C immediately follows the G data member, and similarly notice that
within an H, the embedded C immediately follows the H data member. Now when we
layout I , we can't preserve both relationships. In the Visual C++ layout above,
       the displacements from G to C in a G instance and in an I instance are
       different.  Since classes are generally compiled without knowledge of how
       they will be derived from, each class with a virtual base must have a
       `way-to-compute` the location of the virtual base from the address point
       of its derived class. 

In Visual C++, this is implemented by 'adding' a `hidden-vbptr` ("virtual base
    table pointer") field to 'each' instance of a class with virtual bases. This
field points to a shared, `per-class` table of displacements from the address
point of the vbptr field to the class's virtual base(s). 

note: Only G and H has vbptr and this is offset to get common C through G or H

Other implementations use embedded pointers from the derived class to its
virtual bases, one per base. This other representation has the advantage of a
smaller code sequence to address the virtual base, although an optimizing code
generator can often common-subexpression-eliminate repeated virtual base access
computations. However, it also has the disadvantages of larger instance sizes
for classes with multiple virtual bases, of slower access to virtual bases of
virtual bases (unle ss one incurs yet further hidden pointers), and of a less
regular pointer to member dereference.

In Visual C++, G has a hidden vbptr which addresses a virtual base table whose
second entry is GdGvbptrC. (This is our notation for "in G, the displacement
    from G's vbptr to C". 

We omit the prefix to "d" if the quantity is constant in all derived classes.

For example, on a 32-bit platform, GdGvbptrC would be 8 (bytes). Similarly, the
embedded G instance within an I addresses a vbtable customized for G's within
I's, and so IdGvbptrC would be 20. As can be seen from the layouts of G , H ,
and I , Visual C++ lays out classes with virtual bases by: 

note: 8 and 20 is offset value

1. Placing embedded instances of the non-virtually inherited bases first, 

2. Adding a hidden vbptr unless a suitable one was inherited from one of the
non-virtual bases, 

3. Placing the new data members declared in the derived class, and, finally, 

4. Placing a single instance of each of the virtually inherited bases at the end
of the instance.

This representation lets the virtually inherited bases "float" within the
derived class (and its further derived classes) while keeping together and at
constant relative displacements those parts of the object that are not virtual
bases. 


Data Member Access

Now that we have seen how classes are laid out, let's consider the cost to
access data members of these classes. No inheritance. In absence of inheritance,
       data member access is the same as in C: a dereference off some
       displacement from the pointer to the object. 

C* pc;
pc->c1; // *(pc + dCc1); 


Single inheritance.

Since the displacement from the derived object to its embedded base instance is
a constant 0, that constant 0 can be folded with the constant offset of the
member within that base.

D* pd;
pd->c1; // *(pd + dDC + dCc1); // *(pd + dDCc1);
pd->d1; // *(pd + dDd1); 


Multiple inheritance. 

Although the displacement to a give n base, or to a base of a base, and so on,
         might be non-zero, it is still constant, and so any set of such
         displacements can be folded together into one constant displacement off
         the object pointer. Thus even with multiple inheritance, access to any
         member is inexpensive.

F* pf;
pf->c1; // *(pf + dFC + dCc1); // *(pf + dFc1);
pf->e1; // *(pf + dFE + dEe1); // *(pf + dFe1);
pf->f1; // *(pf + dFf1); 


Virtual inheritance. 

Within a class with virtual bases, access to a data member or non-virtually
inherited base class is again just a constant displacement off the object
pointer. However, access to a data member of a virtual base is comparatively
expensive, since it is necessary to fetch the vbptr, `fetch-a-vbtable-entry`,
  and then add that displacement to the vbptr address point, just to compute the
  address of the data member. However, as shown for i.c1 below, if the type of
  the derived class is statically known, the layout is also known, and it is
  unnecessary to load a vbtable entry to find the displacement to the virtual
  base.

I* pi;
pi->c1; // *(pi + dIGvbptr + (*(pi+dIGvbptr))[1] + dCc1);
pi->g1; // *(pi + dIG + dGg1); // *(pi + dIg1);
pi->h1; // *(pi + dIH + dHh1); // *(pi + dIh1);
pi->i1; // *(pi + dIi1);
I i;
i.c1; // *(&i + IdIC + dCc1); // *(&i + IdIc1); 

What about access to members of transitive virtual bases, for example, members
of virtual bases of virtual bases (and so on)? Some implementations follow one
embedded virtual base pointer to the intermediate virtual base, then follow its
virtual base pointer to its virtual base, and so on.  Visual C++ optimizes such
access by using additional vbtable entries which provide displacements from the
derived class to any transitive virtual bases. 

Casts

Except for classes with virtual bases, it is relatively inexpensive to
explicitly cast a pointer into another pointer type. If there is a base-derived
relationship between class pointers, the compiler simply adds or subtracts the
displacement between the two (often 0). 

F* pf;
(C*)pf; // (C*)(pf ? pf + dFC : 0); // (C*)pf;
(E*)pf; // (E*)(pf ? pf + dFE : 0); 

In the C* cast, no computations are required, because dFC is 0. In the E* cast,
   we must add dFE , a non-zero constant, to the pointer. C++ requires that null
   pointers (0) remain null after a cast.  Therefore Visual C++ checks for null
   before performing the addition. This check occurs only when a pointe r is
   implicitly or explicitly converted to a related pointer type, not when a
   derived* is implicitly converted to a base*const this pointer when a base
   member function is invoked on a derived object. 

As you might expect, casting over a virtual inheritance path is relatively
expensive: about the same cost as accessing a member of a virtual base: 

I* pi;
(G*)pi; // (G*)pi;
(H*)pi; // (H*)(pi ? pi + dIH : 0);
(C*)pi; // (C*)(pi ? (pi+dIGvbptr + (*(pi+dIGvbptr))[1]) : 0); 

In general, you can avoid a lot of expensive virtual base field accesses by replacing them with one
cast to the virtual base and base relative accesses: 

/* before: */              ... pi->c1 ... pi->c1 ...
/* faster: */ C* pc = pi;  ... pc->c1 ... pc->c1 ... 


Member Functions

A C++ member function is just another member in the scope of its class. Each
(non-static) member function of a class X receives a special `hidden-this`
parameter of type X *const , which is implicitly initialized from the object the
member function is applied to. Also, within the body of a member function,
member access off the 'this' pointer is implicit. 

struct P {
  int p1;
  void pf(); // new
  virtual void pvf(); // new
}; 

P* ->    P::vfptr    -> &P::pvf
         P::p1

P has a non-virtual member function pf() and a virtual member function pvf(). It
is apparent that virtual member functions incur an instance size hit, as they
require a `virtual-function-table-pointer`. More on that later. Notice there is
no instance cost to declaring non-virtual member functions. Now consider the
definition of P::pf() : 

void P::pf() { // void P::pf([P *const this])
  ++p1;        // ++(this->p1);
} 

Here P::pf() receives a hidden this parameter, which the compiler has to pass
each call. Also note that member access can be more expensive than it looks,
     because member accesses are this relative. On the other hand, compilers
     commonly enregister this so member access cost is often no worse than
     accessing a local variable. On the other hand, compilers may not be able to
     enregister the instance data itself because of the possibility this is
     aliased with some other data. 


Overriding Member Functions `virtual-function-call-mechanism`

Member functions are inherited just as data members are. Unlike data members, a
derived class can override, or replace, the actual function definition to be
used when an inherited member function is applied to a derived instance. Whether
the override is static (determined at compile time by the static types involved
    in the member function call) or dynamic (determined at run-time by the
      dynamic object addressed by the object pointer) depends upon whether the
    member function is declared virtual.  


Class Q inherits P's data and function members. It declares pf(), overriding
P::pf(). It also declares pvf(), a virtual function overriding P::pvf(), and
declares a new non-virtual member function qf(), and a new virtual function
qvf(). 

struct P {
  int p1;
  void pf();            // new
  virtual void pvf();   // new
}; 

struct Q : P {
  int q1;
  void pf();            // overrides P::pf
  void qf();            // new
  void pvf();           // overrides P::pvf
  virtual void qvf();   // new
};

P*, Q*   ->    P::vfptr    -> &Q::pvf
               P::p1       -> &Q::qvf
               Q::q1

note: this is Q instance

For non-virtual function calls, the member function to call is statically
determined, at compile time, by the type of the pointer expression to the left
of the -> operator. 

In particular, even though ppq points to an instance of Q, ppq->pf() calls
P::pf(). Also notice the pointer expression `left-of-the` -> is passed as the
hidden this parameter. 

P p; P* pp = &p; Q q; P* ppq = &q; Q* pq = &q;
pp->pf();   // pp->P::pf();   // P::pf(pp);
ppq->pf();  // ppq->P::pf();  // P::pf(ppq);
pq->pf();   // pq->Q::pf();   // Q::pf((P*)pq);
pq->qf();   // pq->Q::qf();   // Q::qf(pq); 


For `virtual-function-calls`, the member function to call is determined at
runtime. Regardless of the declared type of the pointer expression left of the
-> operator, the virtual function to call is the one appropriate to the type of
the 'actual' instance addressed by the pointer. In particular, although ppq has
type P*, it addresses a Q, and so Q::pvf() is called.

pp->pvf();  // pp->P::pvf();  // P::pvf(pp);
ppq->pvf(); // ppq->Q::pvf(); // Q::pvf((Q*)ppq);
pq->pvf();  // pq->Q::pvf();  // Q::pvf((P*)pq); 


`virtual-function-call-mechanism`

`hidden-vfptr-members` are introduced to implement this mechanism. A vfptr is
added to a class (if it doesn't already have one) to address that
`class-virtual-function-table` (vftable). `each-virtual-function` in a class has
a corresponding entry in that class's vftable. Each entry holds the address of
the virtual function override appropriate to that class. Therefore, calling a
virtual function requires 'fetching' the `instance-vfptr`, and indirectly
calling through one of the vftable entries addressed by that pointer. This is in
'addition' to the usual function call overhead of parameter passing, call, and
return instructions. In the example above, we fetch q's vfptr, which addresses
Q's vftable, whose first entry is &Q::pvf. Thus Q::pvf() is called. 

Looking back at the layouts of P and Q, we see that the Visual C++ compiler has
placed the hidden vfptr member `at-the-start` of the P and Q instances. This
helps ensure that virtual function dispatch is as fast as possible. In fact, the
Visual C++ implementation ensures that the first field in any class 'with'
virtual functions is always a vfptr. This can require inserting the new vfptr
before base classes in the instance layout, or even require that a right base
class that does begin with a vfptr be placed before a left base that does not
have one.


<vtable-per-class>
Most C++ implementations will share or reuse an inherited base's vfptr. Here Q
did 'not' receive an 'additional' vfptr to address a table 'for' its new virtual
function qvf(). Instead, a qvf entry is appended to the end of P's vftable
layout. In this way, `single-inheritance` remains inexpensive. Once an instance
has a vfptr it doesn't need another one. New derived classes can introduce yet
more virtual functions, and their vftable entries are simply 'appended' to the
end of their one per-class vftable. 

note: 
single inheritance means one level of inheritance so single inheritance is
different from single hierachy of inheritance.


Virtual Functions: Multiple Inheritance

<understand-trunk>
It is possible for an instance to contain more than one vfptr if it inherits
them from multiple bases, each with virtual functions. Consider R and S: 

struct P {
  int p1;
  void pf();            // new
  virtual void pvf();   // new
}; 

struct R {
  int r1;
  virtual void pvf(); // new
  virtual void rvf(); // new
}; 

R*    ->    R::vfptr    -> &R::pvf
            R::r1       -> &R::rvf

struct S : P, R {
  int s1;
  void pvf(); // overrides P::pvf and R::pvf
  void rvf(); // overrides R::rvf
  void svf(); // new
}; 

P*, S*->    P::vfptr    -> &S::pvf
            P::r1
    R*->    R::vfptr    -> &thunk1     // note: this is vtable entry
            R::r1       -> &S::rvf
            S::s1

            trunk1: this -= SdPR; goto S::pvf

note: see R has its own vfptr

Here R is just another class with some virtual functions. Since S multiply
inherits, from P and R, it contains an embedded instance of each, plus its own
instance data contribution, S::s1. Notice the right base R has a different
address point than do P and S, as expected with multiple inheritance. S::pvf()
  overrides both P::pvf() and R::pvf(), and S::rvf() overrides R::rvf(). Here
  are the required semantics for the pvf override: 

S s; S* ps = &s;
((P*)ps)->pvf();  // ((P*)ps)->P::vfptr[0])((S*)(P*)ps)
((R*)ps)->pvf();  // ((R*)ps)->R::vfptr[0])((S*)(R*)ps)
ps->pvf();        // one of the above; calls S::pvf() 

note:
This is code that compiler generate to follow vptr when virtual function call is
made.

Since S::pvf() overrides both P::pvf() and R::pvf(), it must replace their
vftable entries in the S vftable s. However, notice that it is possible to
invoke pvf() both as a P and an R. The problem is that R's address point does
not correspond to P's and S's. The expression (R*)ps does not point to the same
part of the class as does (P*)ps. Since the function S::pvf() expects to receive
an S* as its hidden this parameter, the virtual function call itself must
automatically convert the R* at the call site into an S* at the callee.

Therefore, S's copy of R's vftable's pvf slot takes the address of an adjuster
thunk, which applies the address adjustment necessary to convert an R* pointer
into an S* as desired. In MSC++, for multiple inheritance with virtual
functions, adjuster thunks are required only when a derived class virtual
function overrides virtual functions of multiple base classes. 

note:
The S has own vftable since each class has one. Since this is S instance, always
call S::pvf regardless of which address point is used.

// class A vtable  class B vtable  class C vtable
// [1] A::f        [1] { A sub     [1] { A sub
// [2] A::f        [2] }           [2] }      
//                 [3] B::f        [3] { B sub
//                 [4] B::f        [4] }
//                                 [5] { C sub
//                                 [6] }
// 
// vptr            vptr            vptr
// instances of A  instances of B  instances of C
// 
// For C's instances, if functions are overrides and are virtual, then update
// related vtable for C class and if no virtual, compiler will not generate code
// to run virtual mechanism.  


Address Points and "Logical This Adjustment"

Consider next S::rvf(), which overrides R::rvf(). Most implementations note that S::rvf() must have
a hidden this parameter of type S*. Since R's rvf vftable slot may be used when this call occurs:

((R*)ps)->rvf(); // (*((R*)ps)->R::vfptr[1])((R*)ps)

Most implementations add another thunk to convert the R* passed to rvf into an S*. Some also add an
additional vftable entry to the end of S’s vftable to provide a way to call ps->rvf() without first
converting to an R*. MSC++ avoids this by intentionally compiling S::rvf() so as to expect a this
pointer which addresses not the S object but rather the R embedded instance within the S. (We call
    this "giving overrides the same expected address point as in the class that first introduced
    this virtual function".) This is all done transparently, by applying a "logical this adjustment"
to all member fetches, conversions from this , and so on, that occur within the member function.
(Just as with multiple inheritance member access, this adjustment is constant-folded into other
 member displacement address arithmetic.) Of course, we have to compensate fo r this adjustment in
our debugger. 

ps->rvf(); // ((R*)ps)->rvf(); // S::rvf((R*)ps)

Thus MSC++ generally avoids creating a thunk and an 'additional' extra vftable entry when overriding
virtual functions of non-leftmost bases. 

Adjuster Thunks

As described, an adjuster thunk is sometimes called for, to adjust this (which is found just below
    the return address on the stack, or in a register) by some constant displacement en route to the
called virtual function. Some implementations (especially cfront-based ones) do not employ adjuster
thunks. Rather, they add additional displacement fields to each virtual function table entry.
Whenever a virtual function is called, the displacement field, which is quite often 0, is added to
the object address as it is passed in to become the this pointer: 

ps->rvf();
// struct { void (*pfn)(void*); size_t disp; };
// (*ps->vfptr[i].pfn)(ps + ps->vfptr[i].disp);


The disadvantages of this approach include both larger vftable s and larger code sequences to call
virtual functions. More modern PC-based implementations use adjust-and-jump techniques:


S::pvf-adjust: // MSC++
this -= SdPR;
goto S::pvf()

Of course, the following code sequence is even better (but no current implementation generates it):

S::pvf-adjust:
this -= SdPR; // fall into S::pvf()
S::pvf() { ... } 


Virtual Functions: Virtual Inheritance

Here T virtually inherits P and overrides some of its member functions. In Visual C++, to avoid
costly conversions to the virtual base P when fetching a vftable entry, new virtual functions of T
receive entries in a 'new' vftable, requiring a new vfptr, introduced at the top of T. 

struct T : virtual P {
  int t1;
  void pvf();           // overrides P::pvf
  virtual void tvf();   // new
}; 

note: this layout is different from usual inheritance.

TdTvbptrP {  T* ->  T::vfptr     -> &T::tvf
                    T::vbptr     -> TdTvbptrT
          }         T::t1           TdTvbptrP
             P* ->  P::vfptr     -> &T::pvf
                    P::p1

void T::pvf() {
  ++p1;           // ((P*)this)->p1++; // vbtable lookup!
  ++t1;           // this->t1++;
}

As shown above, even within the definition of a virtual function, access to data members of a
virtual base must still use the vbtable to fetch a displacement to the virtual base. This is
necessary because the virtual function can be subsequently inherited by a further derived class with
different layout with respect to virtual base placement. And here is just such a class: 

struct U : T {
  int u1;
}; 


             T* ->  T::vfptr     -> &T::tvf
UdTvbptrP {         T::vbptr     -> UdTvbptrT
                    T::t1           UdTvbptrP
          }         U::u1
             P* ->  P::vfptr     -> &trunk2
                    P::p1

                    trunk2: this -= (UdP-TdP); goto T::pvf

Here U adds another data member, which changes the dP , the displacement to P . Since T::pvf expects
to be called with a P* in a T , an adjuster thunk is necessary to adjust T this so it arrives at the
callee addressing just past T::t1 (the address point of a P* in a T T). (Whew!  That’s about as
complex as things get!) 

Special Member Functions

This section examines hidden code compiled into (or around) your special member functions.

Constructors and Destructors

As we have seen, sometimes there are hidden members that need to be initialized during construction
and destruction. Worst case, a constructor may perform these activities

1. If "most-derived," initialize vbptr field(s) and call constructors of virtual bases.
2. Call constructors of direct non-virtual base classes.
3. Call constructors of data members.
4. Initialize vfptr field(s).
5. Perform user-specified initialization code in body of constructor definition.

A "most-derived" instance is an instance th at is not an embedded base instance within some other
derived class.

So, if you have a deep inheritance hierarchy, even a single inheritance one, construction of an
object may require many successive initializations of a class's vfptr. (Where appropriate, Visual
    C++ will optimize away these redundant stores.) Conversely, a destructor must tear down the
object in the exact reverse order to how it was initialized:

1. Initialize vfptr field(s).
2. Perform user-specified destruction code in body of destructor definition.
3. Call destructors of data members (in reverse order).
4. Call destructors of direct non-virtual bases (in reverse order).
5. If "most-derived," call destructors of virtual bases (in reverse order).

In Visual C++, constructors for classes with virtual bases receive a hidden “most-derived flag” to
indicate whether or not virtual bases should be initialized. For destructors, we use a "layered
destructor model," so that one (hidden) destructor function is synthesized and called to destroy a
class including its virtual bases (a "most-derived" instance) and another to destroy a class
excluding its virtual bases. The former calls the latter, then destroys virtual bases (in reverse
    order). 

Virtual Destructors and Operator Delete

Consider structs V and W. 

V*    ->    V::vfptr    -> &V::~V

struct V {
  virtual ~V();
}; 

W*    ->    V::vfptr    -> &W::~W

struct W : V {
  operator delete();
}; 

Destructors can be virtual. A class with a virtual destructor receives a hidden vfptr member, as
usual, which addresses a vftable. The table contains an entry holding the address of the virtual
destructor function appropriate for the class. What is special about virtual destructors is they are
implicitly invoked when an instance of a class is deleted. The call site (delete site) does not know
what the dynamic type being destroyed is, and yet it must invoke the appropriate operator delete for
that type. 

For instance, when pv below addresses a W, after W::~W() is called, its storage must be destroyed
using W::operator delete() .

V* pv = new V;
delete pv;           // pv->~V::V(); // use ::operator delete()
pv = new W;
delete pv;           // pv->~W::W(); // use W::operator delete()
pv = new W;
::delete pv;         // pv->~W::W(); // use ::operator delete()

To implement these semantics, Visual C++ extends its "layered destructor model" to automatically
create another hidden destructor helper function, the "deleting destructor," whose address replaces
that of the "real" virtual destructor in the virtual function table. This function calls the
destructor appropriate for the class, then optionally invokes the appropriate operator delete for
the class. 

Arrays

Dynamic (heap allocated) arrays further co mplicate the responsib ilities of a virtual destructor.
There are two sources of complexity.  First, the dynamic size of a heap allocated array must be
stored along with the arra y itself, so dynamically allocated arrays automatically allocate extra
storage to hold the number of array elements. The other complication occurs because a derived class
may be larger than a base class, yet it is imperative that an array delete correctly de stroy each
array elemen t, even in contexts where the array size is not evident:

struct WW : W { int w1; };
pv = new W[m];
delete [] pv; // delete m W's (sizeof(W) == sizeof(V))
pv = new WW[n];
delete [] pv; // delete n WW's (sizeof(WW) > sizeof(V))

Although, strictly speaking, polymorphic array delete is undefined behavior, we had several customer
requests to implement it anyway. Th erefore, in MSC++, th is is implemented by yet another
synthesized virtual destructor he lper function, the so-called “vector delete destructor,” which
(since it is custom ized for a particular class, such as WW) has no difficulty iterating through the
array elem ents (in reverse order), callin g the appropriate destructor for each. 

Exception Handling

Briefly, the exception handling proposal in the C++ standards committee working papers provides a
facility by which a function can notify its callers of an exceptional condition and select
appropriate code to deal with the situation. This provides an alternative mechanism to the
conventional method of checking error status return codes at every function call return site.

Since C++ is object-oriented, it should come as no surprise that objects are employed to represent
the exception state, and that the appropriate exception handler is selected based upon the static
or dynamic type of except ion object "thrown." Also, since C++ always ensures that frame objects
that are going out of scope are properly destroyed, implementations must ensure that in
transferring control (unwinding the stack frame) from throw site to "catch" site, (automatic) frame
objects are properly destroyed. Consider this example: 

struct X { X(); };         // exception object class
struct Z { Z(); ~Z(); };   // class with a destructor
extern void recover(const X&);
void f(int), g(int);

int main() {
  try {
    f(0);
  } catch (const X& rx) {
    recover(rx);
  }
  return 0;
}

void f(int i) {
  Z z1;
  g(i);
  Z z2;
  g(i-1);
}

void g(int j) {
  if (j < 0)
    throw X();
}

This program will throw an exception. main() establishes an exception handler context for its call
to f(0), which in turn constructs z1, calls g(0), constructs z2, and calls g(-1). g() detects the
negative argument condition and throws an X object exception to whatever caller can handle it.
Since neither g() nor f() established an exception handler context, we consider whether the
exception handler established by main() can handle an X object exception. Indeed it can. Before
control is transferred to the catch clause in main(), however, objects on the frame between the
throw site in g() and the catch site in main() must be destroyed. In this case, z2 and z1 are
therefore destroyed.

An exception handling implementation might employ tables at the throw site and the catch site to
describe the set of types that might catch the thrown object (in general) and can catch the thrown
object at this specific catch site, respectively, and generally, how the thrown object should
initialize the catch clause "actual parameter." Reasonable encoding choices can ensure that these
tables do not occupy too much space.

However, let us reconsider function f(). It looks innocuous enough. Certainly it contains neither
try, catch, nor throw keywords, so exception handling would not appear to have much of an impact
on f(). Wrong! The compiler must ensure that, once z1 is constructed, if any subsequently called
function were to raise an exception ("throw") back to f(), and therefore out of f(), that the z1
object is properly destroyed. Similarly, once z2 is constructed, it must ensure that a subsequent
throw is sure to destroy z2 and then z1.

To implement these "unwind semantics," an implementation must, behind the scenes, provide a
mechanism to dynamically determine the context (site), in a caller function, of the call that is
raising the exception. This can involve additional code in each function prolog and epilog, and
worse, updates of state variables between each set of object initializations. For instance, in the
example above, the context in which z1 should be destroyed is clearly distinct from the subsequent
context in which z2 and then z1 should be destroyed, and therefore Visual C++ updates (stores) a new
value in a state variable after construction of z1 and again after construction of z2. All these
tables, function prologs, epilogs, and state variable updates, can make exception handling
functionality a significant space and speed 'expense'. As we have seen, this expense is incurred
even in functions that do not employ exception handling constructs. Fortunately, some compilers
provide a compilation switch and other mechanisms to disable exception handling and its overhead
from code that does not require it. 

Summary

There, now go write your own compiler. Seriously, we have considered many of the significant C++
run-time implementation issues. We see that some wonderful language features are almost free, and
others can incur significant overhead. These implementation mechanisms are applied quietly for you,
       behind the curtains, so to speak, and it is often hard to tell what a piece of code costs
       when looking at it in isolation. The frugal coder is well advised to study the generated
       native code from time to time and question whether use of this or that particularly cool
       language feature is worth its overhead. 


={============================================================================
*kt_dev_cxx_0000* cxx-class-model

<implementation-inheritance-and-interface-inheritance>

EXCEP++22

The two protocols have similarities; some computations and even some messages
are the same. So the programmer has compe up with the following design to
encapsulate `the common` in a base class.

class BasicProtocol
{
  public:
    bool BasicMsgA();
    ...
};

class Protocol1 : public BasicProtocol
{
  public:
    bool DoMsg1();
    ...
};

class Protocol2 : public BasicProtocol
{
  public:
    bool DoMsg2();
    ...
};

Each DoMsgXX() calls BasicProtocol::BasicXX() as needed to do the common work
but the DoMsgXX() performs the actual transmission itself.

This means that derived class do not work like base class. This is clearly
describing an "is implemented in terms of", so can be rewritten by private
inheritance or comosiiton. or cxx-class-model-avoid-public


<deep-inheritance>
Problem? If use public inherirance to use implementation, then end up creating
deep inheritance; interfaces of many classes, impact on memory and performace
since bigger vtables.

o Public inheritance is to use `is-a` and `works-like-a`, when use overrides
  and all overrides must require no more and promise no less.

o Public inheritance is interface inheritance.

CodeComplete p144. LSP (Liskov Substitution Principle) All the routines
defined in the base class should mean the same thing when they are used in
each of derived classes. Semantic meaning. Reduce complexity. 


{cxx-class-implemented-in-terms-of-model} 

Two variants: composition and private inheritance

<composition> cxx-class-has-a-model EC++38
The composition has other synonyms such as containment, aggregation, or
membership.

<ex> `has-a-model` composition
This is a composition in application domain and says that Person 'has' a name. 

class Person {
  public:
    ...
  private: >
   std::string name;             // composition
   Address address;
   PhoneNumber voiceNumber;
   PhoneNumber faxNumber;
};


<ex>
Suppose that need to implement template class that supports no duplicates,
then std::set is an option? However, set is fast but has space overhead per
element but space is more important for your applicaion.  Then can we use
std::list instead? 

template<typename T>
class Set: `public` std::list<T>;

We cannot use public-inheritance since it is not `is-a-model` and std::list
can have duplicates. The right way is to implement by using it and this is a
composition in implementation domain.

template<class T>
class Set {
  public:
    bool member( ... ) const;
    void insert( ... );
    void remove( ... );
    std::size_t size() const;

  private: >
    std::list<T> rep;
};

template<typename T>
bool Set<T>::member( const T& item ) const
{
  // is there find member function in list? no.
  return std::find( rep.begin(), rep.end(), item ) != rep.end() );
}

template<typename T>
void Set<T>::remove( const T& item )
{
  typename std::list<T>::iterator it = std::find( rep.begin(), rep.end(), item );
  
  if( it != rep.end() ) rep.erase(it);
}

template<typename T>
void Set<T>::insert( const T& item )
{
   if( !member(item) ) rep.push_back(item);
}

template<typename T>
std::size_t Set<T>::size() const
{
  return rep.size();
}


<cxx-inheri-private-inheritance> EC++39
The private inheritance is implementation inheritance; inherits
impelementation only but not interface. 

Assume Widget class needs to keep track of how many times each member func is
called and periodically examine the information. Can redefine that virtual
function so that it examines the current state of the Widget.

class Timer {

  public:
    explicit Timer( int tickFrequency );
    virtual void onTick() const;
};

class Widget : public Timer { ... };

No as Widget is not a timer and is not `is-a-model`.

class Widget : private Timer {

  // As *cxx-override-access-control* override do not respect access control.

  private:
    virtual void onTick() const;
    ...
};


Instead, can use composition approach.

class Widget {

  private:

    class WidgetTimer: public Timer {
      public:
        virtual void onTick() const;
        ...
    };

    WidgetTimer timer;
    ...
};


<prevent-inheritance> cxx-final
When derives a class from Widget but want that class do not redefine onTick?
Not possible using private inheritance. So the composition is an approach
before C++11 to prevent derivation and final keyword in C++11.


{cxx-class-compositions-over-private}

Between composition and private inheritance, which do we need to use between
them? `prefer composition whenever possible.`

o If use composition approach, takes out WidgetTimer out of Widget, and use
  pointer instead, then can minimize compilation dependency since otherwise
  inheritance must see base class definition. Timer's definition. No need to
  include Timer header in Widget user. *cxx-pattern-pimpl*
 
o The composition is eaiser to understand.

Use `private-inheritance` only when is absolutely necessary; when need to
access protected area of the base and to redefine virtual functions of base
but no conceptual relationship. 

CodeComplete(p143) PI violates encapsulation and tends to point to design
errors that should be resolved.


={============================================================================
*kt_dev_cxx_0000* cxx-class-model-avoid-public cxx-pattern-strategy

EXCXX-22, 23. way to improve encapsulation

See *cxx-pattern-nvi* and *cxx-ex-query-example*

See duplicated code, `common logic`? How to reuse? Move it to the base and use
public inheritance using two patterns: 

o The `cxx-pattern-pimpl` hides the implementation behind an opaque pointer so
  that any changes to them will not require client code to compile. Called
  `compiler-firewall-idiom` and `opaque-pointer` is a pointer to a declared
  but undefined class.

  struct XxxxImpl; XxxxImpl* pimpl_;

o *cxx-pattern-template-method*


class GenericTableAlgorithm
{
  public:
    GenericTableAlgorithm(const string& table);
    virtual ~GenericTableAlgorithm();

    // common logic:
    //
    // a) physically reads the table's records, calling Filter() on each to
    // determine whether it should be included in the rows to be processed 
    //
    // b) when the list of rows to operate upon is complete, call ProcessRow()
    // for each row.

    bool Process();

  private:
    virtual bool Filter(const Record&);
    virtual bool ProcessRow(const PrimaryKey&) = 0;

    // should provide Process() implementation
    struct GenericTableAlgorithmImpl* pimpl_;
};


// to extend worker class

class MyAlgorithm : `public` GenericTableAlgorithm
{
  // override Filter() and ProcessRow() `to implement a specific operation`
};

class YourAlgorithm : `public` GenericTableAlgorithm
{
  // override Filter() and ProcessRow() to implement a specific operation
};


// client code

int main()
{
  MyAlgorithm a("Customer");
  a.Process();

  or

  YourAlgorithm a("Customer");
  a.Process();
}


That is, what want to do is "implemented in terms of" and two ways:

o public inheritance

`is, work-like-a, usable-as-a relationship` and possible due to sub-object.
The problem is it can cuase `deep inheritance`

public inheritance inherits both interface and implementation which is
different from override, virtual, or specialisation.

`not to reuse code of base but to be resued by polymorphism`

o private inheritance or membership


<better-way>
What's the better way? The current holds two responsibilities, or purposes:

o interface and algorithm. Process()

o extensibility. extend GenericTableAlgorithm for specialized case or usage.

"Prefer cohesion. Always give each piece of code module, class, function - a
single, well-defined responsibility."


class GTAClient;

// Responsibility 1. Provide a public interface that encapsulate common
// functionality 

class GenericTableAlgorithm
{
  public:
    GenericTableAlgorithm(const string& table
                          `GTAClient& worker`);

    // Have separated away the inheritance relationship so the dtor doesn't need
    // to be virtual.
    ~GenericTableAlgorithm();

    // Does all the work; calling Filter() and ProcessRow()
    bool Process();

    struct GenericTableAlgorithmImpl* pimpl_;
};


// Responsibility 2. Provide abstract interface for extensibility 

class GTAClient
{
  public:
    virtual ~GTAClient() = 0;
    virtual bool Filter(const Record&);
    virtual bool ProcessRow(const PrimaryKey&) = 0;
};

class MyWorker : public GTAClient
{
  // override Filter() and ProcessRow() `to implement a specific operation`
}

class YourWorker : public GTAClient
{
  // override Filter() and ProcessRow() to implement a specific operation
}

int main()
{
  GenericTableAlgorithm a("Customer", MyWorker());
  GenericTableAlgorithm a("Customer", YourWorker());
  a.Process();
}

The good things are:

o Any `interface changes` to public interface of GenericTableAlgorithm like
  add more member function does not affect the concrete worker class at all
  since not in the inheritance. If not, have to recompile all derived classes

o Any `protocal changes` to GenericTableAlgorithm such as additional arguments
  to Filter() or ProcessRow()? All external clients have to be recompiled even
  though the public interface is unchanged, because a derivation interface is
  visiable in the class definition. (???, not sure). 
  So the benefit is that not affect external users.
 
o Any concrete worker class can be used with any other algorithm using
  Filter()/ProcessRow() interface. not just GenericTableAlgorithm.

*cxx-remember*
Remember the computer science motto:
  "Most problems can be solved by adding a level of indirection."

This becomes very similar to *cxx-pattern-strategy*


<to-further>
If GenericTableAlgorithm do not have member data and does not need to keep
`state` across invocations like *cxx-fobj*, then could replace it with
function.

bool GenericTableAlgorithm(const string& table, GTAClient& worker)
{
  // contents of Process()
}

int main()
{
  GenericTableAlgorithm("Customer", MyWorker());
}


Further, if worker object never need to store state, all instances are
functionally equivalent and provide only virtual functions, then:

template<typename GTACworker>
bool GenericTableAlgorithm(const string& table)
{
  // contents of Process()
}

int main()
{
  // `cxx-template-explicit-argument`
  GenericTableAlgorithm<MyWorker>("Customer");
}


<ex>

cxx-pattern-strategy

The Morden C++ Challenge, Design Pattern, Chapter 08

72. Computing order price with discounts

// discount for product, each item, customer

A retail store sells a variety of goods and can offer various types of discount,
for selected customers, articles, or per order. The following types of discount
could be available:

// discount types

A fixed discount, such as 5%, regardless of the article or the quantity that is
purchased.

A volume discount, such as 10%, for each article when buying more than a
particular quantity of that article.

A price discount per total order of an article, that is, a discount for an
article when a customer buys a quantity of that article so that the total cost
exceeds a particular amount. For instance, a 15% discount for an article when
the total cost of that article exceeds $100. If the article costs $5, and the
customer buys 30 units, the total cost is $150; therefore, a 15% discount
applies to the order of that article.

A price discount per entire order (regardless what articles and in which
quantity they were ordered).

Write a program that can calculate the final price of a particular order. It is
possible to compute the final price in different ways; for instance, all
discounts could be cumulative, or on the other hand, if an article has a
discount, a customer or total order discount might not be considered.


The problem proposed here can be solved with the `strategy pattern` This design
pattern defines a family of algorithms and makes them interchangeable within the
family. In this particular problem, both the discounts and the final order price
calculators could be implemented based on the strategy pattern. The following
diagram describes the hierarchy of discount types and their interchangeable use
within the other classes, customer, article, order_line, and order:

*/

namespace cxx_pattern_strategy
{
  struct discount_type
  {
    virtual ~discount_type() {}

    // get discount percentage for each type

    virtual double 
      discount_percent(double price, double quantity) const noexcept = 0;
  };

  // *cxx-final*
  struct fixed_discount final : public discount_type
  {
    explicit fixed_discount(double discount) noexcept
      : discount_(discount) 
      {}

    virtual double
      discount_percent(double, double) const noexcept override
      { return discount_; }

    private:
      double discount_;
  };

  struct volume_discount final : public discount_type
  {
    explicit volume_discount(double quantity, double discount) noexcept
      : discount_(discount), min_quantity_(quantity)
      {}

    virtual double
      discount_percent(double, double quantity) const noexcept override
      { return quantity >= min_quantity_ ? discount_ : 0; }

    private:
      double discount_;
      double min_quantity_;
  };

  // discount on total price
  struct price_discount final : public discount_type
  {
    explicit price_discount(double price, double discount) noexcept
      : discount_(discount), min_total_price_(price)
      {}

    virtual double
      discount_percent(double price, double quantity) const noexcept override
      { return (price * quantity) >= min_total_price_ ? discount_ : 0; }

    private:
      double discount_;
      double min_total_price_;
  };

  // discount on item price
  struct amount_discount final : public discount_type
  {
    explicit amount_discount(double price, double discount) noexcept
      : discount_(discount), min_total_price_(price)
      {}

    virtual double
      discount_percent(double price, double) const noexcept override
      { return price >= min_total_price_ ? discount_ : 0; }

    private:
      double discount_;
      double min_total_price_;
  };


  // user(client) class

  struct customer
  {
    std::string name_;
    discount_type* discount_;
  };

  enum class article_unit
  { piece, kg, meter, sqmeter, cmeter, liter };

  struct article
  {
    int             id_;
    std::string     name_;
    double          price_;
    article_unit    unit_;
    discount_type*  discount_;
  };

  struct order_line
  {
    article         product_;
    int             quantity_;

    discount_type*  discount_;
  };

  struct order
  {
    int                     id_;
    customer*               buyer_;
    std::vector<order_line> lines_;

    discount_type*          discount_;
  };

  struct price_calculator
  {
    virtual double calculate_price(order const& o) = 0;
  };

  struct cumulative_price_calculator : public price_calculator
  {
    virtual double calculate_price(order const& o) override
    {
      double price = 0;

      // each item ordered
      for (auto ol : o.lines_)
      {
        double line_price = ol.product_.price_ * ol.quantity_;

        // product discount
        if (ol.product_.discount_ != nullptr)
        {
          line_price *= (1.0 - ol.product_.discount_->discount_percent(
                ol.product_.price_, ol.quantity_));
        }

        // order_line discount
        if (ol.discount_ != nullptr)
        {
          line_price *= (1.0 - ol.discount_->discount_percent(
                ol.product_.price_, ol.quantity_));
        }

        // buyer discount
        if (o.buyer_ != nullptr && o.buyer_->discount_ != nullptr)
        {
          line_price *= (1.0 - o.buyer_->discount_->discount_percent(
                ol.product_.price_, ol.quantity_));
        }

        price += line_price;
      } // end for

      // whole order discount
      if (o.discount_ != nullptr)
        price *= (1.0 - o.discount_->discount_percent(price, 0));

      return price;
    };
  };

} // namespace

TEST(PatternStrategy, ComputingOrderPriceWithDiscounts)
{
  using namespace cxx_pattern_strategy;
  
  fixed_discount fd(0.1);   // 10%
  volume_discount vd(10, 0.15);
  price_discount pd(100, 0.05);
  amount_discount ad(100, 0.05);

  // customers, (name, discount)
  customer c1{"default", nullptr};
  customer c2{"john", &fd};
  customer c3{"joane", &pd};

  // items, (id, name, price, unit, discount)
  article a1{1, "pen", 5, article_unit::piece, nullptr};
  article a2{2, "expensive pen", 15, article_unit::piece, &fd};
  article a3{3, "scissors", 10, article_unit::piece, &vd};

  cumulative_price_calculator calc;

  // order, (order id, customer, ordered items, discount)
  order o1{101, &c1, {{a1, 1, nullptr}}, nullptr};
  EXPECT_THAT(calc.calculate_price(o1), 5);

  order o2{102, &c2, {{a1, 1, nullptr}}, nullptr};
  EXPECT_THAT(calc.calculate_price(o2), 4.5);
}


<ex>
see *cxx-ex-quote*


<ex>
EFCXX-35

cxx-pattern-strategy via function pointers

class GameCharacter;

// default calculation
int defaultHealthCalc( const GameCharacter& gc );

class GameCharacter {
  public:
    typedef int(*HealthCalcFunc)(const GameCharacter&);

    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) 
      : healthFunc(hcf) {}

    int healthValue() const
    { return healthFunc(*this); }
    ...

  private:
      HealthCalcFunc healthFunc;
};

class EvilBadGuy : public GameCharacter {};

int loseHealthQuickly(const GameCharacter&);
int loseHealthSlowly(const GameCharacter&);

EvilBadGuy ebg1(loseHealthQuickly);
EvilBadGuy ebg2(loseHealthSlowly);

This is interesting in that calculation function can be set indepandantly with
game character class tree.

Therefore, *cxx-pattern-strategy* is about seperation between interface and
extensibility.


={============================================================================
*kt_dev_cxx_0000* cxx-class-model-implemented-in-terms-of

EXCEP++24.

Always minimise "coupling". `The inheritance is strongest and tightly coupling.`
Second to friendship. Should use `containment` to avoid needless coupling and
dependencies if can express a class relationship using it.


template <class T>
class MyList
{
  public:
    bool    Insert( const T&, size_t index );
    T       Access( size_t index ) const;
    size_t  Size() const;

  private:
    T*      buf_;
    size_t  bufSize_;
};

Two ways to write a MySet `is-implemented-in-terms-of` MyList;
`cxx-inheri-private-inheritance` and `containment`.


non-public inheritance uses public and protected area and containment uses
only public.

template <class T>
class MySet1 : private MyList<T>
{
  public:
    bool    Add( const T& );            // calls Insert()
    T       Get( size_t index ) const;  // calls Access()

    // *cxx-access-control* to make Size() public
    using MyList<T>::Size;

    // ...
};

template <class T>
class MySet2
{
  public:
    bool    Add( const T& );            // calls impl_.Insert()
    T       Get( size_t index ) const;  // calls impl_.Access()
    size_t  Size() const;               // calls impl_.Size()
    // ...

  private:
    MyList<T> impl_;
};

The containment is `has-a`, `composition`, `delagation`, and the inheritance is
a superset of single containment since it has a subobject.


<when-inheritance-appropriate>

See *cxx-class-model-inheritance* for other examples.

When use non-public inheritance? To use override. Even when it is the case,
can avoid this.

class Base
{
  public:
    virtual int Func1();
  protected:
    bool Func2();
  private:
    bool Func3();   // uses Func1
};


To get the right behavior, need to override Func1 so inheritance is necessary.
However, the problem is that grants access to Func2 to all members of Derived.
Needless made all Derived's members depend upon Base's protected interface.

class Derived : private Base
{
  public:
    int Func1();
    // some of functions use Base::Func2 and some of which don't
};


Wouldn't it be nice to introduce as much couling as really need? 
`"require no more and promise no less"`

class DerivedImpl : private Base
{
  public:
    int Func1();
    // functions that use Func2
};

class Derived
{
  // functions that don't use Func2
  private:
    DerivedImpl impl_;
};


this is much better since:

o Separates and encapsulates the dependencies on Base.

o Follows `one-class-one-resposibility` guideline; coustomizing Base and
  implementing itself in-terms-of Base.

o Allows multiple copiles of helper(like DerivedImpl) class. *cxx-helper-class*

note:
Similar to `cxx-pattern-pimpl`? No since not to reduce compiler dependancy.


<is-almost-a>
This is not quite "is-a" model and not behave quite the way that a resonable
Base client could expect. Do not use public inheritance

EFFC++32, 38, 39
 
The base represent a more 'general' concept than the derived since the derived
represent a more `specialised concept.` 

For example,

class Square : public Rectangle;

class Bird : public Penguin;

May be true in mathematics but not necessarily true in class. is-a model
should mean means that can use the derived where the base can be used and
means anything that is true of the base is also true of the derived.


<containment-in-generic-way>
Again, back to MySet example. It is `implementable-in-terms-of any class` that
supports the required functions that we need than MyList only.

Different user code may choose to instantiate MySet using implementations with
different performance characteristics. Write code that does many more inserts
than searches and want to use an implementation that optimizes inserts.

Difficult to have this flexibility with inheritance since it fix an
implementation decision at design time.

template <class T, `class Impl = MyList<T>`> 
class MySet3
{
  public:
    bool    Add( const T& );            // calls impl_.Insert()
    T       Get( size_t index ) const;  // calls impl_.Access()
    size_t  Size() const;               // calls impl_.Size()
    // ...

  private:
    Impl impl_;
};


note:
*cxx-queue* *cxx-stack* uses this technique which are implemented of in terms
of deque.


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-template-method

Behavioral Pattern, EC++35

The design pattern [REF003] called it `template-method`. base class define
skeleton of an algorithm in an operation and let subclass redefine certain
steps without changing the algorithms structure.

<ex>
Application framework where application subclass application and document to
suit speficif needs. For example, a drawing application defines
DrawApplication and DrawDocument subclass.

Document                Application
+Save()                 +AddDocument()
+Open()                 +OpenDocument()
+Close()                +DoCreateDocument()*        // virtuals
+DoRead()*              +CanOpenDocument()*
                        +AboutToOpenDocument()*

MyDocument              MyApplication
+DoRead()               +DoCreateDocument()         // return new MyDocument
                        +CanOpenDocument()
                        +AboutToOpenDocument()

// this is template method which is non-virtual
void Application::OpenDocument( const char* name ) {
  if( !CanOpenDocument(name)) {
    // cannot handle this document
    return;
  }

  // *cxx-pattern-factory-func* to create application specific document
  Document* doc = DoCreateDocument();  

  // steps
  if(doc) {
    _docs->AddDocument(doc);
    AboutToOpenDocument(doc);
    doc->Open();
    doc->DoRead();
  }
}


o Without chaning the algorithm's structure, the template-method defines steps
  in terms of abstract operations that subclass override to provide concrete
  behavior. `define invariant parts once` and `leave variant part to subclass.`

// TODO: seems wrong since common/logic code should be in the base?
o Refactoring. To avoid code duplication, identify the differences among
  existing subclasses and then separate the differences into new operations,
  replace the differing code with a template method(in base) that calls one of
  these new operations. This is also about code resuse but difference is
  steps, that is template method(function).

o Hook operations.


*cxx-pattern-nvi*

EC++35. In the following example, different character may calculate their
health in different ways. Use virtual? This is alternatives to usual virtual
design. Called NVI(non-virtual interface) idiom as a public non-virtual in the
base call a `private virtual function` that can be redefined but it's little more
than window dressing as still use virtuals. 

  "HOW and WHEN: template-method means that base controls when and derived
  control how."

EC++ limits template method when it uses private virtual and EXPC++ p84 also
says "avoid public virtial functions; prefer using the template method pattern
instead."


class GameCharacter {
  public:
    int healthValue() const
    {
      // do before stuff 
      int retVal = doHealthValue();
      // do after stuff
    }

  // NOTE: see this is private and *cxx-ex-query-example*
  private:     
    virtual int doHealthValue() const
    {
      // default calc code
    }
};

class XGameCharacter : public GameCharacter;

The base defines before and after stuff and when to call the derived part that
is the derived dependent. The before and after can be lock/unlock, logging,
pre/post condition.

note:
For primitive operation which should be overridden, often prefix names with
Do: DoRead as DoCreateDocument shown above.


<hook-operation>
To extend parent class operation. But it is esay to forget to call the
inherited function so can use template-method to give the parent class a
control over how subclasses extend it. This is called hook-operation. 

void ParentClass::Operation() {
  // parent class behavior
  HookOperation();
}

virtual void DerivedClass::Operation() {
  ParentClass::Operation();
  // additional
}

virtual void ParentClass::HookOperation() { }

virtual void DerivedClass::HookOperation() {
  // derived class extension
}


<private-or-protected>
As *cxx-override-access-control* override do not respect access control.
However as with hook to call base function, access control do matter when call
base version.

class Window {
  private:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow : public Window {
  public:
    virtual void onResize() {
      Window::onResize();
      // additional to the derived
    }
    ...
};

: In member function 'virtual void Derived::doMorePri()':
:26:16: error: 'virtual void Base::doMorePri()' is private
:51:20: error: within this context

<ex>

cxx_pattern_template

The Morden C++ Challenge, Design Pattern

69. Generating social security numbers

Write a program that can generate social security numbers for two countries,
Northeria and Southeria, that have different but similar formats for the
numbers:

In Northeria, the numbers have the format SYYYYMMDDNNNNNC, where
  S is a digit representing the sex, `9 for females and 7 for males`, 
  YYYYMMDD is the birth date, (same)
  NNNNN is a `five-digit random number`, unique for a day (meaning that the same
  number can appear twice for two different dates, but not the same date), 
  and C is a digit picked so that the checksum computed as described later is a
  `multiple of 11.`

In Southeria, the numbers have the format SYYYYMMDDNNNNC, where 
  S is a digit representing the sex, `1 for females and 2 for males`, 
  YYYYMMDD is the birth date, (same)
  NNNN is a `four-digit random number`, unique for a day, 
  and C is a digit picked so that the checksum computed as described below is a
  `multiple of 10.`
  
  
The checksum in both cases is a sum of all the digits, each multiplied by its
weight (the position from the most significant digit to the least). 

For example, the checksum for the Southerian number 12017120134895 is computed
as follows:

crc = 14*1 + 13*2 + 12*0 + 11*1 + 10*7 + 9*1 + 8*2 + 7*0 + 6*1 + 5*3 
           +  4*4 +  3*8 +  2*9 +  1*5
    = 230 = 23 * 10
 
The formats for both countries are very similar, although several details are
different:

The value of the digit for the sex
The length of the random part, and therefore the length of the entire number
The number the checksum must be a multiple of

This problem can be solved using the template method design pattern, which
defines the skeleton of an algorithm and lets subclasses redefine particular
steps:

*/

namespace cxx_pattern_template
{
  enum class sex_type {female, male};

  class social_number_generator
  {
    public:
      std::string generate(sex_type sex, unsigned year, unsigned month, unsigned day)
      {
        std::stringstream snumber;

        snumber << sex_digit(sex);                  // call virtual
        snumber << year << month << day;
        snumber << next_random(year, month, day);   // call virtual

        // For example, the checksum for the Southerian number 12017120134895 is
        // computed as follows:
        // 
        // crc = 14*1 + 13*2 + 12*0 + 11*1 + 10*7 + 9*1 + 8*2 + 7*0 + 6*1 + 5*3 
        //     +  4*4 +  3*8 +  2*9 +  1*5

        auto number = snumber.str();
        auto index = number.length();

        // *cxx-algo-accumulate*
        auto sum = std::accumulate(std::begin(number), std::end(number),
            0, // init value
            [&](int init, char c)
            { return init + (index-- * (c - '0')); });

        auto rest = sum % modulo_value();           // call virtual
        snumber << modulo_value() - rest;

        return snumber.str();
      }

      // dtor-in-cxx-abc
      virtual ~social_number_generator() {}

    // works but public also works
    // protected:
    
    public:
      social_number_generator(int min, int max) 
        : ud(min, max)
      {}

    protected:
      virtual int sex_digit(sex_type const sex) const noexcept = 0;
      virtual int next_random(unsigned year, unsigned month, unsigned day) = 0;
      virtual int modulo_value() const noexcept = 0;

    protected:
      std::map<unsigned, int> cache;
      std::uniform_int_distribution<> ud;
      std::default_random_engine eng;
  };

  class southeria_social_number_generator final : public social_number_generator
  {
    public:
      southeria_social_number_generator():
        social_number_generator(1000, 9999)
    {}

    protected:
      virtual int sex_digit(sex_type sex) const noexcept override
      {
        return sex == sex_type::female ? 1 : 2;
      }

      // 4 digit.
      // cxx-algo-unique use cache to have unique number?
      virtual int next_random(unsigned year, unsigned month, unsigned day) override
      {
        auto key = year*10000 + month*100 + day;
        while (true)
        {
          auto number = ud(eng);

          // when not found
          auto pos = cache.find(number);
          if (pos == std::end(cache))
          {
            cache[key] = number;
            return number;
          }
        }
      }

      virtual int modulo_value() const noexcept override
      { return 11; }
  };

  class northeria_social_number_generator final : public social_number_generator
  {
    public:
      northeria_social_number_generator():
        social_number_generator(1000, 9999)
    {}

    protected:
      virtual int sex_digit(sex_type sex) const noexcept override
      {
        return sex == sex_type::female ? 9 : 7;
      }

      // 5 digit. why are these two functions same as southeria?
      
      virtual int next_random(unsigned year, unsigned month, unsigned day) override
      {
        auto key = year*10000 + month*100 + day;
        while (true)
        {
          auto number = ud(eng);

          auto pos = cache.find(number);
          if (pos == std::end(cache))
          {
            cache[key] = number;
            return number;
          }
        }
      }

      virtual int modulo_value() const noexcept override
      { return 11; }
  };

  // *cxx-pattern-factory*

  class social_number_generator_factory
  {
    public:
      social_number_generator_factory()
      {
        generators_["north"] = 
          std::unique_ptr<northeria_social_number_generator>(
              new northeria_social_number_generator());

        generators_["south"] = 
          std::unique_ptr<southeria_social_number_generator>(
              new southeria_social_number_generator());
      }

      social_number_generator* get_generator(std::string country) const
      {
        auto it = generators_.find(country);
        if (it != std::end(generators_))
          return it->second.get();

        throw std::runtime_error("not found country");
      }

    private:
      std::map<std::string,
        std::unique_ptr<social_number_generator>> generators_;
  };

} // namespace

TEST(PatternTemplate, GeneratingSecurityNumber)
{
  using namespace cxx_pattern_template;

  social_number_generator_factory factory;

  {
    auto snorth1 = factory.get_generator("north");
    std::string result;
    if (snorth1 != nullptr)
    {
      result = snorth1->generate(
          sex_type::female, 2017, 12, 25);

      cout << "snorth1: " << result << endl;
    }
  }

  {
    auto ssouth1 = factory.get_generator("south");
    std::string result;
    if (ssouth1 != nullptr)
    {
      result = ssouth1->generate(
          sex_type::female, 2017, 12, 25);

      cout << "ssouth1: " << result << endl;
    }
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-pimpl cxx-pimpl cxx-pattern-bridge

*cxx-encapsulation*

CPR 270. The benefits of encapsulation.

o The implementation of an encapsulated class can change over time without
  requiring changes in user code. User code needs to change only when the
  interface changes.

o The data are protected from mistakes that users might introduce. If there is
  a bug that corrupts an object's state, the place to look for the bug are
  localized and limited.


EC++31: minimize compilation dependencies 

Two cases can cause complilation dependency problem:

o Class interface changes which means *cxx-header* file changes.

o No separation between interface and implementation in class definition which
  means *cxx-header* file changes.

The `implementation separation` can be achieved when use function tables which
has a set of fixed interfaces and this is often done via registration. Such as
OS abstraction or driver abstraction which happens when porting.
 
But, how to handle when `interface changes`? For example, when replace graphic
library which has different interfaces. Usually talk about how to design
interfaces for user but if user uses it everywhere and replace library, need
to find every place using it. If there is a single point or file to use
interfaces then better to cope with changes? More about C.

This item is to reduce compliation dependancy by separating interface from
implementation and this happens because C++ isn't very good at separating
interface from implementation.


{problem}

// person.h
class Person {
  public:
    Preson( const Date& birthDay, const Address& addr );
    std::string name() const;
    ...

  private:
    std::string theName;
    Date theBirthDate;
    Address theAddress;
};

`member data is implementaion` details and need class definition such as Date
to compile. So headers of these class are needed:

// person.cpp
#include <string>
#include "date.h"
#include "address.h"

This cause `cascading-compilation-dependencies`. Suppose if this Date or
Address class changes then classes using one of these should be compiled all
over again.

date.h    -- persoh.h -- xxx.cpp that use person class. 
address.h --          -- xxx.cpp
                      -- ...

o Any files using Person class as well even if not use member functions using
  Date or Address.

o No interface change. If only change implementation like adding or removing
  memeber data, will cause to compile every cpp files that includes person.h. 

Can use `cxx-forward-declaration` to avoid this? NO because cannot create an
object since the compiler cannot know the size of p and how big a Person
object is. 


class Date;
class Address;

class Person {
  private:
      std::string theName;
      Date theBirthDate;
      Address theAddress;
};

Person p(params);    // define a person object

sam01.cpp:10:10: error: field ‘theBirthDate’ has incomplete type
sam01.cpp:11:13: error: field ‘theAddress’ has incomplete type


<solution>
o Decouple interface from implementation

o Use dependencies on declaration than definition. This moves from
  dependencies-on-definition to dependencies-on-declaration


<ex>
STL uses this approach: Two header files.

<iosfwd> has declaration only
<sstream> <streambuf> <fstream> <iostream> are all implementation files


{cxx-pattern-pimpl} AKA `cpp-handle-class`. 

// See *exception-safe* in *kt_dev_cxx_019* 
// Have two classes. One is what client use and has a pointer to
// implementation. 
>
Use the fact that compiler has no problem to get size of built-in types like
pointer. No definition needed.

o Use built-in types such as reference and pointer.
 
o Need only declaration for member function which uses a class as `argument` or
  `return` by value because the definition is needed only when call a func or
  define a func. So if Date class changes then only need to recompile clients
  that actually uses them but not all clients. See *cxx-forward-declaration*
 
  Date today(); void func(Date d);
  
  No Date definition is needed to declare these function. This removes
  dependency on definition and client should include necessary headers to
  actually call these.


// person.h, interface class
class PersonImpl; // *cxx-forward-declaration*
class Date;
class Address;

class Person {
  ...
  private:
    std::shared_ptr<PersonImpl> pImpl;    // set pimpl
};


// personimpl.h, implementation class
Both class must have the same interface. If add or remove member data; changes
implementation, no need to compile clients.


// person.cpp, interface class
#include "person.h"
#include "personimpl.h"    // for pimpl class

Person::Person(...) : pImpl( new PersonImpl (...) ) {}   // create-and-set-impl

std::string Person::name() const                         // forwarding
{ return pImpl->name(); }


<summary>
(client)    (interface class)                (impl. class)
use         interface: no virtuals           interface
            set impl in ctor.                has real impl. and can use other
            ptr to impl                      classes as Date and Address 
                                             in this example.

                                             (subclassing)

note:
o If impl class changes, need to change only cpp file of interface class but
  not clients.

o How about subclassing impl class to have other impls? okay.


EXC++27-31

The *cxx-pattern-pimpl* has advantages:

o Breaks compile-time dependencies.

has costs in performace:

o Each construction/destruction must allocate/deallocate memory.

o At least one extra indirection and size overhead.
 

EXC++29

What should go into Impl class from interface or visual class?

1. Put all private data (but not functions) into Impl.
2. Put all nonvirtual private members into Impl.
3. Put all private and protected members into Impl.

`Put all nonvirtual private members and private data` into Impl class since
client code shouldn't and doesn't care about these parts and protected and
virtuals to be seen and used by derived class.


*cxx-sp-unique*
when use unique_ptr and foward declaration, it fails to compile. However, it is
okay when include a header instead.

/include/c++/6.4.0/bits/unique_ptr.h:74:22: error: invalid application of ‘sizeof’ to incomplete type ‘MlPlayerPrivate’
  static_assert(sizeof(_Tp)>0,
                      ^

class MlPlayerPrivate;

class MlPlayer final : public Player
{
private:
  std::unique_ptr<MlPlayerPrivate> m_private;
}


From Smart Pointers in C++, Fluent C++

There is a rule in C++ that says that deleting a pointer leads to undefined behaviour if:

o this pointer has type void*, or

o the type pointed to is incomplete, that is to say is only forward declared,

std::unique_ptr happens to check in its destructor if the definition of the
type is visible before calling delete. So it refuses to compile and to call
delete if the type is only forward declared.

Since we removed the declaration of the destructor in the Fridge class, the
compiler took over and defined it for us. But compiler-generated methods are
declared inline, so they are implemented in the header file directly. And
there, the type of FridgeImpl is incomplete.  Hence the error.

The fix would then be to declare the destructor and thus prevent the compiler
from doing it for us. So the header file becomes:

And we can still use the default implementation for the destructor that the
compiler would have generated. But we need to put it in the implementation
file, after the definition of FridgeImpl:


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-interface

Similar to JAVA's interface but C++ one can have data or func implementation.
Use ABC and interface class can have only interfaces or interface and default
implementation.

class Person {                      // class IPerson(ABC)
  public:
    virtual ~Person();              // see 'virtual'
    virtual std::string name() const = 0; 
    virtual std::string birthDate() const = 0; 
    virtual std::string address() const = 0; 
    ...
    // *cxx-pattern-factory-func*
    'static' std::shared_ptr<Person> create(
        const std::string& name, const Date& birthday, const Address& address);
};


std::shared_ptr<Person> Person::create(...)
{    
  // create "RealPerson" <create-and-set-impl>
  return std::shared_ptr<Person> ( new RealPerson (...) );
}


// implementation
//
class RealPerson: public Person {         // public IPerson
  private:
    std::string theName;                  // has-implementation-details
    Date theBirthDate;

  public:
    RealPerson(...): ... {}
    virtual ~RealPerson() {}
    virtual std::string name() const;

    ... same interface
};


Then client use:

std::shared_ptr<Person> pp ( Person::create(...) );

<summary>
(client) (interface class)   
(client)    interface: virtuals
...         factory-function 
            ptr to impl      

         (subclassing) 
            real implementation : use other classes

* Like `pimpl-pattern`, no interface change and can force class interface to
  derived class.
 
* Used subclassing.
 
* Like pimpl idiom, separated implementation. When implementation, derived
  class, changes, no need to compile clients. But re-link.

* No singleton class style but effectively singleton since cannot create ABC
  class and only ABC has a interface to create. note: not a singleton.

IPerson::create(...)
 |
 |-return new RealPersonX or
 |-return new RealPersonY
 |-...
 +-return new RealPersonZ


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-singleton cxx-singleton

<cxx-init-order-problem> *cxx-undefined*

// file A
class FileSystem {
  public:
    ...
      std::size_t numDisk() const;
    ...
};

extern FileSystem tfs;            // global tfs

// file B
class Directory {
  Directory()
  {
    std::size_t = tfs.numDisk();  // here uses tfs
    ...
  }
  ..
};

Directory tempDir( params );      // global dir


How can you make sure that the global object tfs will be initialised before
tempDir which uses that? 

This is called the intialization order fiasco, where global variables can be
accessed, initialization value 0 for bulit-in types, before they are
initialised since the order of initialization for global variables(including
class statics) between translation units is undefined. 

This is the *cxx-data-race* on global variables. 

How to solve? By replacing the global variable with a function that returns a
reference to a local static variable, this guarantee that it is initialised
before anything accesses it. This is only true for single-threaded. 

On many pre-C++11 compilers this race condition is problematic in practice
because multiple threads may believe they're first and try to initialize the
variable, or threads may try to use it after initialization has started on
another thread but before it's finished. 

`In C++11 this problem is solved`: the initialization is defined to happen on
exactly one thread.


{singleton-simple}
To the initial problem, use `function-static`. EC++04 said it is common
implementation of `singleton-pattern`

// file A
class FileSystem {
   ...
};

// extern FileSystem tfs;
FileSystem& tfs()
{ >
  static FileSystem fs; return fs;
}

// file B
class Directory {
   // use tfs
};

// Directory tempDir( params );
Directory& tempDir()
{ >
  static Directory td(tempDir); return td;
}


{other-problems-using-global}
Using global, static objects have two problems:

o Do not keep you from instantiating multiple objects of the same type(class).
  Not about the name.

class X one_instance; class X two_instance.

o No control of access. *cxx-init-order-problem*

Good things over global by making a class itself responsible for keeping track
of its sole instance:

o `instance-control`
 
o `controlled-access` 
  Sicne Singleton encapsulates its sole instance, have strict control over how
  client access it

o `lazy-initialization` 
  `no-creation` if it is not called. In the following example, no creation
  unless a user call instance() but global do not.


<code> RDP 129
For C++, use singleton class, pattern. Put simply, sigleton can be called
`class-static` in the same sense as function static.


class Singleton {

  public:
    // `controlled-access` single point of access
    // `cxx-lazy-initialisation` means that do not create instance until its
    // first access.

    `static` Singleton* Instance()
    {
      if(_instance==0) {
        _instance = new Singleton;
      }
      return _instance;
    }

    // *cxx-copy-prevent-copies*
    Singleton(Singleton const&) = delete;
    Singleton& operator=(Singleton const&) = delete;

  protected:                         
    // `no direct user creation`
    // gets created only via Instance()
    Singleton() {};                  

  // can have different concrete classes in different hierachy
  private:
    `static` Singleton* _instance;
};

Singleton* Singleton::_Instance = 0;


// cxx-singleton-copy-and-dtor
// 
// Have to use shared_ptr to copy and dtor context? No. This is static function
// and there is no Singleton object created. Hence no copy controls.

*cxx-memory*
No need to delete _instance? Yes, will be reclaimed when an application
terminates.


{singleton-plus-factory}
The singleton is similar to `factory-function` in that both has a single point
to create hence static func. However, the aim is different. The singleton is
about `when-or-how-to-create` and the factory is about `what-to-create`. 


Like to have singleton and flexibility to choose what to create as well? Here
are ways:

<ex> RDP 132

o Make a usual factory class a singleton to ensure there is only one instance
  by making globally accessible without resorting to global variable.

o Allow subclass on factory but not on singleton.
 
o Use env to select what to create at run-time.

// RDP 92
class MazeFactory {
  public:
    // ... public interfaces ...
    MazeFactory();
    virtual Maze* MakeMaze() const;
    virtual Wall* MakeWall() const;
    virtual Room* MakeRoom(int n) const;
    virtual Door* MakeDoor(Room *r1, Room *r2) const;
};


// Add a singleton
class MazeFactory {
  public:
    static MazeFactory* Instance();

    // ... public interfaces ...
    virtual Maze* MakeMaze() const;
    virtual Wall* MakeWall() const;
    virtual Room* MakeRoom(int n) const;
    virtual Door* MakeDoor(Room *r1, Room *r2) const;

  // no more than one instance
  protected:
    MazeFactory();

  private:
    static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new MazeFactory;
  }

  return _instance;
}

class EnchantedMazeFactory : public MazeFactory
{
  public:
    EnchantedMazeFactory();

    virtual Room *MakeRoom(int n ) const
    { return new EnchantedRoom(n); }
    ...
};

// Support subclass or other instances
MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    const char* mazeStyle = getenv("MAZESTYLE");

    if( strcmp( mazeStyle, "bombed" ) == 0 ) {
      _instance = new `BombedMazeFactory;`
    }
    else if( strcmp( mazeStyle, "ehchanted" ) == 0 ) {

      // note: subclass ctor should be public which means can create directly.
      _instance = new `EnchantedMazeFactory;`

      // other possible subclasses
      // should modify Instance() whenever there are new subclasses

    } else { 
      // default. okay since can access protected ctor
      _instance = new MazeFactory;
    }
  }

  return _instance;
}

How about overriding Instance() in class hierachy? No since there must be an
instance to call Instance() but constructor is protected. So no way to create
object. 

So MUST use
`class-method`, `staic-member-function`, for singleton-pattern.

class MazeFactory {
  public:
    'virtual' MazeFactory* Instance(); 
    ... public interfaces ...

  protected:
      MazeFactory();

  private:
      static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

BombedMazeFactory* BombedMazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new BombedMazeFactory;
  }

  return _instance;
}


<1> RDP 130

* Another approach to support "subclassing singleton class"

o Use 'registry' to find a class to use and this is more flexible because
  there is no code change necessary, e.g., Instance(), when there are new
  sigleton class to add.

  The downside is that 'all' possible singleton classes must be created before
  register since must build a list to look up beforehand. 

* No protected ctor so can create static global instance

class Singleton {
  public:
    'static' void Register( char* name, Singleton* );
    'static' Singleton* Instance();

  protected:
    'static' Singleton* Lookup( const char* name );

  private:
    'static' Singleton* _instance;
    'static' List<NameSingletonPair>* _registry;
};

Singleton* Singleton::Instance() 
{
  if(_instance==0) {

    const char* singletonName = getenv("SINGLETON");
    _instance = Lookup(singletonName);
  }
  return _instance;
}

// to register in ctor
MySingleton::MySingleton() 
{
  ...
  Singleton::Register( "MYSINGLETON", this );
}

// create and used file static since no protected ctor
static MySingleton mySingleton;
static YourSingleton yourSingleton;

mySingleton.Instance();


note:
MEC++26 shows more such as how limit the number of objects.


{read}
https://code.google.com/p/google-singleton-detector/wiki/WhySingletonsAreControversial

note: here suppose that talks about class singleton but singleton+factory.

Why Singletons Are Controversial

The use of singletons is actually a fairly controversial subject in the Java
community; what was once an often-used design pattern is now being looked at
as a less than desirable coding practice.

The problem with singletons is that they introduce global state into a
program, allowing anyone to access them at anytime (ignoring scope). Even
worse, singletons are one of the most overused design patterns today, meaning
that many people introduce this possibly detrimental global state in instances
where it isn't even necessary. 

`What's wrong with singletons' use of global state?`

`First, programs using global state are very difficult to test.` One of the
hallmarks of testability is a loose coupling of classes, allowing you to
isolate a single class and test it completely. When one class uses a singleton
(and I'm talking about a classic singleton, one that enforces it own
 singularity thorough a static getInstance() method), the singleton user and
the singleton become inextricably coupled together. 

It is no longer possible to test the user (class) without also testing the
singleton. In many cases, this is a deal breaker that can prevent a developer
from testing a class at all, especially if the singleton represents a
`resource` that should not be updated by tests (i.e.  an important database).

The ideal solution here is to pass in the singleton as a parameter in the
user's constructor, allowing a tester to easily `mock out` the singleton for
tests. The singleton then doesn't have to enforce its own singularity; this
can be handled by the client or a factory class, which could produce the real
version or a test version, eliminating the global state altogether. In fact,
it should be considered a violation of the Single Responsibility Principle of
  OO design to have an object responsible for its own singularity as well as
  its normal tasks.

NOTE:
it is about testability of class which gets created from singleton interface
and two issue:
  o not able to mock it out. can use #define to use mock object instead?
  o class have state. this is real problem 

Second, programs that rely on global state hide their dependencies. One of the
unique abilities of a singleton is that it can be accessed anywhere though its
globally available static method (i.e.  getInstance()), allowing programmers
to use it inside of a method `without having to pass it in` expressly through
parameters. While this may seem easier to the programmer, relying on this
static instance means that the signatures of methods no longer show their
`dependencies`, because the method could `pull a singleton "out of thin air."`
This means that users need knowledge of the inner workings of code to properly
use it, making it more difficult to use and test.

Tying these two problems together shows another issue with singletons. In
todays world of test-driven and agile development, it is more important than
ever to have small tests covering most of your code. One of the important
things about these tests is that they must be able to be run in any order (not
    dependent on each other), which can become a problem with singleton usage.

Because the dependencies of some given methods aren't clear when they rely
on singletons (getting them from static getters), a tester may unknowing write
two tests that actually depend on each other by modifying a shared resource
(the singleton). This can produce flaky tests, ones that pass when run in one
order but fail when run in another, which aren't very useful.

Still not convinced? Well, this certainly wasn't originally my idea, and it's
not even that new. If you're looking for some more compelling arguments, check
out some of these sources:

All pages with Singleton in their title at the Portland Pattern Repository
Wiki

Use Your Singletons Wisely (IBM developerWorks) 


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-factory cxx-factory

Creational Pattern, Factory Method

The factory-function plays the role of the ctor for the derived classes that
are actually created. Hence called virtual constructor

This is about a method but not a class. Two points:

o Encapsulation. No code to create in the client and move it into factory-func. 
 
o Defer decision on `what to create`: creation in the base such as parameterized
  factory-func or to defer creation to subclass, so any product class in the
  tree. This subclassing often used in framework since no need to make changes
  in framework. `flexibility`


<static-vs-virtual-factory-func>
The non-virtual factory function is static and efficient because no virtual
cost and has single point to access. But hard-wired choice of classes to
create. Have to change it whenever the choice to create changes. 

The `virtual factory function` has bigger code but subclassing can change
class to create. So useful for framework that cannot be changed. When
factory-func is on the creator tree and uses virtual func: pure virtual or
virtual which as default implementation. Let subclassing decide which class to
create; application specific document which is out of framework.


(client)           (creator class, Application)           (product class, Document) 
-----------------  ------------------------------------   ------------------------- 
Creator.NewDoc();  // factory-func.
                   // set impl in factory func.
                   `virtual` CreateDoc() = 0; or
                   `virtual` CreateDoc();

                   NewDoc()                                Open();
                   { pDoc = CreateDoc(); pDoc->Open(); }

                   (subclass)                              (subclass)
                   -------------------------------------   -------------------------
                   WordApplication, DrawApplicaion, ...    WordDoc, DrawDoc, ...
                   `virtual` CreateDoc()
                   { return new WordDoc; }
                   { return new DrawDoc; }

This can be used in parallel class implementation. See design pattern book for
more.

This looks like factory + pimpl and create object in the different tree.


<ex> 
virtual-factory-func sample-code-from-design-pattern

Has hard-coded classes to create as with NewDoc:

Maze* MazeGame::CreateMaze() {
  Maze* aMaze = new Maze;
  Room* r1 = new Room(1);
  Room* r2 = new Room(2);
  Door* theDoor = new Door(r1, r2);

  aMaze->AddRoom(r1);
  ...
  return aMaze;
}

Revised to use virtual factory and which opens a way to redefine factory
function itself whcih can redefine what to create; Different Maze which has
different Rooms. 

class MazeGame {
  public:
    // *cxx-pattern-template*
    Maze* CreateMaze();

    // factory functions
    virtual Maze* MakeMaze() const { return new Maze; }
    virtual Room* MakeRoom( int n ) const { return new Room(n); }
    virtual Wall* MakeWall(...);
    virtual Door* MakeDoor(...);
};

Maze* MazeGame::CreateMaze() {
  Maze* aMaze = MakeMaze();

  Room* r1 = MakeRoom(1); Room* r2 = MakeRoom(2);
  Door* theDoor = MakeDoor( r1, r2 );

  aMaze->AddRoom(r1); aMaze->AddRoom(r2);
  ...
  return aMaze;
};

class BombedMazeGame : public MazeGame {
  public:
    virtual Wall* MakeWall() const { return new BombedWall; }
    virtual Room* MakeRoom(int n) const { return new RoomWithABomb(n); }
};

class EnchantedMazeGame : public MazeGame {
  public:
    virtual Wall* MakeDoor() const { return new DoorNeedingSpell; }
    virtual Room* MakeRoom(int n) const { return new EnchantedRoom(n); }
};

BombedMazeGame bombMaze;               // BombedMazeGame
Maze* pMaze = bombMaze.CreateMaze();   // client know what to create
pMaze->func();

When CreateMaze() is called, will use redefined factory-funcs to create
application specific class.


{parameterized-factory-func}
The realistic examples may support different derived class to create using
additional params, file, DB or env var. 

<ex> 
Can use template instead of subclassing as to what to create:

class Creator {
  public:
    virtual Product* CreateProcut() = 0;
};

template <class T>
class StandardCreator : public Creator {
  public:
    virtual Product* CreateProduct();
};

template <class T>
Product* StandardCreator<T>::CreateProduct() {
   return new T;
};

<ex> non-member-factory-func
From EC++40. Use id to select different concrete class and non-member
factory function and conditional switch in it.

std::shared_ptr<IPerson> makePerson( DatabaseID personID );

DatabaseID id(askUserForDatabaseID());
std::shared_ptr<IPerson> pp ( makePerson(id) );

pp->name();
pp->birthDate();


<ex> RDP
class Creator {
  public:
    virtual Product* Create( ProductId );
};

Product* Creator::Create( ProductId id )
{
  if( id == MINE ) return new MyProduct;
  if( id == YOURS ) return new YourProduct;

  return 0;
};

Product* MyCreator::Create( ProductId id )
{
  if( id == YOURS ) return new MyProduct;          // changed ids
    if( id == MINE ) return new YourProduct;

  if( id == THEIRS ) return new TheirProduct;      // extented

  return Creator::Create(id);                      // fall back on base class for others.
};


<ex> on-disk-representation-factory-func
From MEC++25. Creating objects from reading disk and there should be type to
create in disk.

class NLComponents {
  public:
    ...
};

class TextBook : public NLComponents {
  public:
    ...
};

class Graphic : public NLComponents {
  public:
    ...
};

class NewsLetter {
  public:
    ...
  private:
    list<NLComponents*> components;

    // static factory function
    static NLComponents* readComponent( istream& str );
};

NewsLetter::NewsLetter( istream& str )
{
  while( str ) {
    components.push_back( readComponent( str ) );
  }
}


{virtual-copy} *cxx-clone*

cxx-clone copies and creats type dependant instance and return pointer of it.

class NLComponent {
  public:
    virtual NLComponent* clone() const = 0;
    ...
};

class TextBlock : public NLComponent {
  public:
    virtual TextBlock* clone() const
    { return new TextBlock(*this); }
    ...
};

class Graphic : public NLComponent {
  public:
    virtual Graphic* clone() const
    { return new Graphic(*this); }
    ...
};

class NewsLetter {
  public:
    NewsLetter( const NewsLetter& rhs );
    ...

  private:
      list<NLComponents*> components;
};

NewsLetter::NewsLetter( const NewsLetter& rhs )
{
  for( list<NLComponent*>::const_iterator it = rhs.components.begin();
      it != rhs.components.end(); ++it )
  {
    components.push_back( (*it)->clone() );
  }
}

<ex>
subclassing and registry

class Factory : public Base
{
  public:
    virtual ~Factory() {}
    virtual Executor *CreateExecutor( Environment *env, Params *params ) = 0;
};

class ServiceListExecutorFactory : public AS_WORKER::Factory
{
  public:
    ServiceListExecutorFactory() {}

    AS_WORKER::Executor *CreateExecutor( AS_WORKER::Environment *env,
        AS_WORKER::Params *params )
    {
      return new AS_SERVICELIST::ServiceListExecutor( env, params );
    }
};

// maps request string to "factory"
{
  servicelistexecutor                  = new AS_SERVICELIST::ServiceListExecutorFactory();
  serviceListStatusExecutor            = new AS_SERVICELIST::ServiceListStatusExecutorFactory();
  ...

  map->RegisterUrl(REQ_METHOD_HTTP_GET, (char *) "/as/services",          servicelistexecutor );
  map->RegisterUrl(REQ_METHOD_HTTP_GET, (char *) "/as/services/<b>/<sb>", servicelistexecutor );
  ...
}


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-observer

The observer pattern describes how to establish these relationship. The key
object in this pattern are `subject` and `observer` A subject may have any
number of dependent observers. All observers are notified whenever the subject
undergoes a change in state. In response, each observer will query the subject
to synchronise its state with the subject's state.

This kind of interaction is also known as `publish-subscribe`. The subject is
the publisher of notifications. It sends out these notifications without
having to know who its observers are. Any number of observers can subscribe to
receive notifications.


cxx_pattern_observer

The Morden C++ Challenge, Design Pattern, Chapter 08

71. Observable vector container

Write a class template that behaves like a vector but can notify registered
parties of internal state changes. The class must provide at least the following
operations:

Various constructors for creating new instances of the class
operator= to assign values to the container
push_back() to add a new element at the end of the container
pop_back() to remove the last element from the container
clear() to remove all the elements from the container
size() to return the number of elements from the container
empty() to indicate whether the container is empty or has elements

operator=, push_back(), pop_back(), and clear() must notify others of the state
changes. The notification should include the type of the change, and, when the
case, the index of the element that was changed (such as added or removed).


The observable vector described in this problem is a typical example of a
subject in the design pattern called observer. This pattern describes an object,
called the subject, that maintains a list of dependent objects, called
observers, and notifies them of any state changes by calling one of their
methods. The class diagram shown here describes a possible pattern
implementation for the proposed problem:


*/

namespace cxx_pattern_observer
{
  enum class collection_action
  { add, remove, clear, assign };

  std::string to_string(collection_action const action)
  {
    switch(action)
    {
      case collection_action::add: return "add";
      case collection_action::remove: return "remove";
      case collection_action::clear: return "clear";
      case collection_action::assign: return "assign";
      default: return "unsupported action";
    }
  }

  struct collection_change_notification
  {
    collection_action action_;
    // std::vector<size_t> item_indexes_;
    size_t item_indexes_;
  };

  class collection_observer
  {
    public:
      virtual ~collection_observer() {}

      // why not reference?
      virtual void collection_changed(collection_change_notification notificaiton) = 0;
  };

  class observer : public collection_observer
  {
    public:
      virtual void collection_changed(collection_change_notification notification) override
      {
        std::cout << "action: " << to_string(notification.action_);

        // if (!notification.item_indexes_.empty())
        {
          std::cout << ", indexes: ";

          // the index of the element that was changed (such as added or removed)
          // so no need to have for loop
          // for (auto i : notification.item_indexes_)
          //   std::cout << i << ' ';

          std::cout << notification.item_indexes_;
        }

        std::cout << std::endl;
      }
  };

#if 0
  // this is code from the text which works but not sure why this is complicated
  // as this.

  // final?
  template <typename T, typename Allocator = std::allocator<T>>
  class observable_vector final
  {
    typedef typename std::vector<T, Allocator>::size_type size_type;

    public:

    // ???
    observable_vector() noexcept(noexcept(Allocator()))
      : observable_vector(Allocator()) 
    {}

    explicit observable_vector(Allocator const& alloc) noexcept
      : data_(alloc) 
      {}

    observable_vector(size_type count, const T& value, 
        Allocator const& alloc = Allocator())
      : data_(count, value, alloc)
    {}

    explicit observable_vector(size_type count, 
        Allocator const& alloc = Allocator())
      : data_(count, alloc)
    {}

    // moves

    observable_vector(observable_vector&& other) noexcept
      : data_(other.data_)
      {}

    observable_vector(observable_vector&& other, Allocator const& alloc)
      : data_(other.data_, alloc)
    {}

    // init list
    observable_vector(std::initializer_list<T> init,
        Allocator const& alloc = Allocator())
      : data_(init, alloc)
    {}

    template<typename InputIterator>
      observable_vector(InputIterator first, InputIterator last,
          Allocator const& alloc = Allocator())
      : data_(first, last, alloc)
      {}

    observable_vector& operator=(observable_vector const& other)
    {
      if (this != &other)
      {
        data_ = other.data_;

        // 1. weak_ptr?
        // 2. std::vector<size_t>{} is empty when assign?

        for (auto o : observers_)
        {
          if (o != nullptr)
          {
            o->collection_changed(
                // {collection_action::assign, std::vector<size_t>{}}
                {collection_action::assign, 0}
                );
          }
        }
      }

      return *this;
    }

    observable_vector& operator=(observable_vector&& other)
    {
      if (this != &other)
      {
        data_ = std::move(other.data_);

        for (auto o : observers_)
        {
          if (o != nullptr)
          {
            o->collection_changed(
                // {collection_action::assign, std::vector<size_t>{}}
                {collection_action::assign, 0}
                );
          }
        }
      }

      return *this;
    }

    // only rvalue version?
    // the index of the element that was changed (such as added or removed)

    void push_back(T&& value)
    {
      data_.push_back(value);

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              // {collection_action::add, std::vector<size_t>{data_.size()-1}}
              {collection_action::add, data_.size()-1}
              );
        }
      } // end for
    }

    void pop_back()
    {
      data_.pop_back();

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              // {collection_action::remove, std::vector<size_t>{data_.size()+1}}
              // {collection_action::remove, std::vector<size_t>{data_.size()}}
              {collection_action::remove, data_.size()}
              );
        }
      } // end for
    }

    void clear() noexcept
    {
      data_.clear();

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              // {collection_action::clear, std::vector<size_t>{}}
              {collection_action::clear, 0}
              );
        }
      } // end for
    }

    size_type size() const noexcept
    { return data_.size(); }


    bool empty() const noexcept
    { return data_.empty(); }

    void add_observer(collection_observer* const o)
    { observers_.push_back(o); }

    void remove_observer(collection_observer const* const o)
    {
      observers_.erase(
          std::remove(std::begin(observers_), std::end(observers_), o),
          std::end(observers_)
          );
    }

    private:
    // what's the difference when use std::vector<T>?
    std::vector<T, Allocator> data_;
    std::vector<collection_observer*> observers_;
  };
#endif

  template <typename T>
  class observable_vector
  {
    typedef typename std::vector<T>::size_type size_type;

    public:

    observable_vector() noexcept
      : data_()
    {}

    // explicit observable_vector(Allocator const& alloc) noexcept
    //   : data_(alloc) 
    //   {}

    // observable_vector(size_type count, const T& value, 
    //     Allocator const& alloc = Allocator())
    //   : data_(count, value, alloc)
    // {}

    // explicit observable_vector(size_type count, 
    //     Allocator const& alloc = Allocator())
    //   : data_(count, alloc)
    // {}

    // // moves

    // observable_vector(observable_vector&& other) noexcept
    //   : data_(other.data_)
    //   {}

    // observable_vector(observable_vector&& other, Allocator const& alloc)
    //   : data_(other.data_, alloc)
    // {}

    // init list
    explicit observable_vector(std::initializer_list<T> init)
      : data_(init)
    {}

    // template<typename InputIterator>
    //   observable_vector(InputIterator first, InputIterator last,
    //       Allocator const& alloc = Allocator())
    //   : data_(first, last, alloc)
    //   {}

    observable_vector& operator=(observable_vector const& other)
    {
      if (this != &other)
      {
        data_ = other.data_;

        // 1. weak_ptr?
        // 2. std::vector<size_t>{} is empty when assign?

        for (auto o : observers_)
        {
          if (o != nullptr)
          {
            o->collection_changed(
                // {collection_action::assign, std::vector<size_t>{}}
                {collection_action::assign, 0}
                );
          }
        }
      }

      return *this;
    }

    observable_vector& operator=(observable_vector&& other)
    {
      if (this != &other)
      {
        data_ = std::move(other.data_);

        for (auto o : observers_)
        {
          if (o != nullptr)
          {
            o->collection_changed(
                // {collection_action::assign, std::vector<size_t>{}}
                {collection_action::assign, 0}
                );
          }
        }
      }

      return *this;
    }

    // the index of the element that was changed (such as added or removed)

    void push_back(T&& value)
    {
      cout << "push_back(T&&)" << endl;

      data_.push_back(value);

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              {collection_action::add, data_.size()-1}
              );
        }
      } // end for
    }

    void push_back(T& value)
    {
      cout << "push_back(T&)" << endl;

      data_.push_back(value);

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              {collection_action::add, data_.size()-1}
              );
        }
      } // end for
    }

    void pop_back()
    {
      data_.pop_back();

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              {collection_action::remove, data_.size()}
              );
        }
      } // end for
    }

    void clear() noexcept
    {
      data_.clear();

      for (auto o : observers_)
      {
        if (o != nullptr)
        {
          o->collection_changed(
              {collection_action::clear, 0}
              );
        }
      } // end for
    }

    size_type size() const noexcept
    { return data_.size(); }

    bool empty() const noexcept
    { return data_.empty(); }

    void add_observer(collection_observer* const o)
    { observers_.push_back(o); }

    void remove_observer(collection_observer const* const o)
    {
      observers_.erase(
          std::remove(std::begin(observers_), std::end(observers_), o),
          std::end(observers_)
          );
    }

    private:
    // what's the difference when use std::vector<T>?
    // std::vector<T, Allocator> data_;
    std::vector<T> data_;
    std::vector<collection_observer*> observers_;
  };

} // namespace

TEST(PatternObserver, ObservableVectorContainer)
{
  using namespace cxx_pattern_observer;

  observable_vector<int> ov;
  observer o;
  int value{5};

  ov.add_observer(&o);

  cout << "=========" << endl;
  ov.push_back(1);

  cout << "=========" << endl;
  ov.push_back(2);

  cout << "=========" << endl;
  ov.push_back(value);

  cout << "=========" << endl;
  ov.pop_back();
  cout << "=========" << endl;
  ov.clear();

  ov.remove_observer(&o);

  // no notification since observer is removed.

  observable_vector<int> ovv{1,2,3};

  cout << "=========" << endl;
  ov = ovv;

  cout << "=========" << endl;
  ov = observable_vector<int>{7,8,9};
}


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-decorator

Structural Pattern

o flexible `alternative to subclassing for extending functionality` since
  subclassing is static and inflexible

o enclose(wraps) the component in another object that add functionality and it
  is also known as "wrapper". builds chain of objects

o do additional work before or after forwarding.

<ex>
cxx_pattern_decorator

The Morden C++ Challenge, Design Pattern

67. Validating passwords

Write a program that validates password strength based on predefined rules,
which may then be selected in various combinations. At a minimum, every password
must meet a minimum length requirement. In addition, other rules could be
enforced, such as the presence of at least one symbol, digit, uppercase and
lowercase letter, and so on.

The problem described here is a typical case for the decorator pattern. This
design pattern allows 

"adding behavior to an object without affecting other objects of the same type." 

This is achieved by wrapping an object within another
object. Multiple decorators could be stacked on top of each other, each time
adding new functionality. In our case, the functionality would be validating
that a given password meets a particular requirement.

The following class diagram describes the pattern for validating passwords:

        password_validator (abc)
        +                   +
length_validator         password_validator_decorator 
                            +
                         digit_password_validator, 
                         case_password_validator, 
                         symbol_password_validator, ...

*/

namespace cxx_pattern_decorator
{
  // *cxx-abc*
  class password_validator
  {
    public:
      virtual ~password_validator() {}

      // virtual bool validate(std::string& password) = 0;
      // virtual bool validate(std::string password) = 0;

      virtual bool validate(std::string const& password) = 0;
  };

  // mandatory(default) implementation

  class length_validator : public password_validator
  {
    public:
      length_validator(unsigned int min_length) noexcept : length_(min_length) 
      {}

      // bool validate(std::string& password) override
      // bool validate(std::string password) override
      bool validate(std::string const& password) override
      {
        cout << "length_validator {" << endl;

        auto result = password.length() >= length_;

        cout << "length_validator }" << endl;

        return result;
      }

    private:
      unsigned int length_;
  };


  class password_validator_decorator : public password_validator
  {
    public:

      // *point* moves unique_ptr to primitive component

      explicit password_validator_decorator(
          std::unique_ptr<password_validator> validator)
        : validator_(std::move(validator)) 
      {}

      // bool validate(std::string& password) override
      // bool validate(std::string password) override
      bool validate(std::string const& password) override
      {
        cout << "password_validator_decorator {" << endl;
        // *point*
        auto result = validator_->validate(password);
        cout << "password_validator_decorator }" << endl;

        return result;
      }

    private:
 
      // *point* points to the next in the chain.

      std::unique_ptr<password_validator> validator_;
  };

  // must have one digits

  class digit_password_validator final : public password_validator_decorator
  {
    public:
      explicit digit_password_validator(
          std::unique_ptr<password_validator> validator)
        : password_validator_decorator(std::move(validator))
      {}

      // bool validate(std::string& password) override
      // bool validate(std::string password) override
      bool validate(std::string const& password) override
      {
        cout << "digit_password_validator {" << endl;

        // *point* forwards to that primitive component

        if (password_validator_decorator::validate(password) == false)
          return false;

        cout << "digit_password_validator }" << endl;

        // *cxx-algo-unique*

        return password.find_first_of("0123456789") != std::string::npos;
      }
  };

  // must have one lower and one upper case

  class case_password_validator final : public password_validator_decorator
  {
    public:
      explicit case_password_validator(std::unique_ptr<password_validator> validator)
        : password_validator_decorator(std::move(validator))
      {}

      // bool validate(std::string& password) override
      // bool validate(std::string password) override
      bool validate(std::string const& password) override
      {
        cout << "case_password_validator {" << endl;

        if (password_validator_decorator::validate(password) == false)
          return false;

        bool has_lower{false};
        bool has_upper{false};

        for (size_t i = 0; i < password.size() && !(has_lower && has_upper); ++i)
        {
          if (std::islower(password[i])) has_lower = true;
          else if (std::isupper(password[i])) has_upper = true;
        }

        cout << "case_password_validator }" << endl;

        return has_lower && has_upper;
      }
  };

  // must have one of symbols

  class symbol_password_validator final : public password_validator_decorator
  {
    public:
      explicit symbol_password_validator(std::unique_ptr<password_validator> validator)
        : password_validator_decorator(std::move(validator))
      {}

      // error
      // bool validate(std::string& password) override
      // okay
      // bool validate(std::string password) override
      bool validate(std::string const& password) override
      {
        cout << "symbol_password_validator {" << endl;

        if (password_validator_decorator::validate(password) == false)
          return false;

        cout << "symbol_password_validator }" << endl;

        return password.find_first_of("!@#$%^&*(){}[]?<>") != std::string::npos;
      }
  };

} // namespace


// o shows how chain of objects works
//
// o concrete "length_validator" object must be the inner most in the chain.
//
// [ RUN      ] PatternDecorator.ValidatingPasswords
// digit_password_validator {
// password_validator_decorator {
// length_validator {
// length_validator }
// password_validator_decorator }
// digit_password_validator }
// [       OK ] PatternDecorator.ValidatingPasswords (1 ms)

TEST(PatternDecorator, ValidatingPasswords_1)
{ 
  using namespace cxx_pattern_decorator;

  // okay
  // std::unique_ptr<length_validator> validator1(new length_validator(8));
  // std::unique_ptr<digit_password_validator> validator2(new digit_password_validator(std::move(validator1)));

  // use temporary
  // *point* build chain of approval

  std::unique_ptr<digit_password_validator> validator2(
      new digit_password_validator(std::unique_ptr<length_validator>(new length_validator(8)))
      );

  // *cxx-14*
  // auto validator1 = std::make_unique<digit_password_validator>(
  //     std::make_unique<length_validator>(8));

  EXPECT_THAT(validator2->validate("abc123!@#"), true);

  // since do not have a digit
  EXPECT_THAT(validator2->validate("abcde!@#"), false);
}


// now added `case` in the middle of decorator chain and this fails on `case
// validator` so ends there and see no ends for `digit validator`
//
// digit_password_validator {
// password_validator_decorator {
// case_password_validator {
// password_validator_decorator {
// length_validator {
// length_validator }
// password_validator_decorator }
// case_password_validator }
// password_validator_decorator }
// cxx_pattern.cpp:242: Failure
// Value of: validator2->validate("abc123!@#")
// Expected: is equal to true
//   Actual: false (of type bool)
// [  FAILED  ] PatternDecorator.ValidatingPasswords (3 ms)

TEST(PatternDecorator, ValidatingPasswords_2)
{
  using namespace cxx_pattern_decorator;

  // use temporary
  std::unique_ptr<digit_password_validator> validator2(new digit_password_validator(
        std::unique_ptr<case_password_validator>(new case_password_validator(
            std::unique_ptr<length_validator>(new length_validator(8))
            ))));

  // now expects false
  EXPECT_THAT(validator2->validate("abc123!@#"), false);
} 


// TEST(PatternDecorator, ValidatingPasswords_3)
// {
//    auto validator2 = 
//       std::make_unique<symbol_password_validator>(
//          std::make_unique<case_password_validator>(
//             std::make_unique<digit_password_validator>(
//                std::make_unique<length_validator>(8))));
//  
//    assert(validator2->validate("Abc123!@#"));
//    assert(!validator2->validate("Abc123567"));
// }


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-composite

Structural Pattern

o let clients treat individual objects and compositions of objects `uniformly`
  the user can group components to form lager components but the problem with
  this is that must treat "`primitive` and `container` object differently"
  
o represent both primitives and their containers which means the interface
  covers both. this is different from *cxx-pattern-decorator*

  So some interface are not implemented. Line, Rectangle, and Text are
  primitives and they has no child so none implements child related
  operations. However, Picture that composites primitives implements Draw to
  call Draw on its children and implements them. 

o cxx-pattern-decorator can be viewed as a degenerated composite with only one
  component. However, a decorator adds additional responsibilities; it's not
  intended for object aggregation. 

  (similar in that both have chain of objects and calls)

<ex>
The Morden C++ Challenge, Design Pattern

68. Generating random passwords

Write a program that can generate random passwords according to some predefined
rules. Every password must have a configurable minimum length. In addition, it
should be possible to include in the generation rules such as the presence of at
least one digit, symbol, lower or uppercase character, and so on. These
additional rules must be configurable and composable.

This problem could be solved using the composite pattern or a variation of the
pattern. This design pattern composes objects into tree hierarchies and enables
treating groups (or trees) of objects `the same way` as individual objects of the
same type. The following class diagram shows a hierarchy of classes that can be
used for generating passwords:

        password_generator (abc)
        +                         +
composite_password_generator    basic_password_generator (primitive)
(container)                       +
                                digit_generator, case_generator, symbol_generator, ...

*/

namespace cxx_pattern_composite
{
  // *cxx-abc*
  class password_generator
  {
    public:
      virtual std::string generate() = 0;
      virtual std::string allowed_chars() const = 0;
      virtual size_t length() const = 0;
      virtual void add(std::unique_ptr<password_generator> generator) = 0;
      virtual ~password_generator() {}
  };

  class basic_password_generator : public password_generator
  {
    public:
      explicit basic_password_generator(size_t const length) noexcept
        : len_(length)
        {}

      virtual std::string generate() override
      { throw std::runtime_error("not implemented"); }

      virtual void add(std::unique_ptr<password_generator>) override
      { throw std::runtime_error("not implemented"); }

      virtual size_t length() const override final
      { return len_; }

    private:
      size_t len_;
  };

  class digit_generator : public basic_password_generator
  {
    public:
      explicit digit_generator(size_t const length) noexcept
        : basic_password_generator(length)
        {}

      virtual std::string allowed_chars() const override
      { return "0123456789"; }
  };

  class symbol_generator : public basic_password_generator
  {
    public:
      explicit symbol_generator(size_t const length) noexcept
        : basic_password_generator(length)
        {}

      virtual std::string allowed_chars() const override
      { return "!@#$%^&*(){}[]?<>"; }
  };

  class upper_letter_generator : public basic_password_generator
  {
    public:
      explicit upper_letter_generator(size_t const length) noexcept
        : basic_password_generator(length)
        {}

      virtual std::string allowed_chars() const override
      { return "ABCDEFGHIJKLMNOPQRSTUVXYWZ"; }
  };

  class composite_password_generator : public password_generator
  {
    public:
      composite_password_generator()
      {}

      virtual std::string generate() override
      {
        std::string password{};

        for (auto& g : generators_)
        {
          // calls a generator
          std::string chars = g->allowed_chars();

          std::uniform_int_distribution<> ud(0, static_cast<int>(chars.length()-1));

          for (size_t i = 0; i < g->length(); ++i)
            password += chars[ud(eng)];
        }

        std::shuffle(std::begin(password), std::end(password), eng);

        return password;
      }

      virtual void add(std::unique_ptr<password_generator> generator) override
      {
        generators_.push_back(std::move(generator));
      }

    private:
      virtual std::string allowed_chars() const override
      { throw std::runtime_error("not implemented"); }

      virtual size_t length() const override
      { throw std::runtime_error("not implemented"); }

      std::default_random_engine eng;

      // *point*
      std::vector<std::unique_ptr<password_generator>> generators_;
  };

} // namespace


TEST(PatternComposite, PasswordGenerator_1)
{
  using namespace cxx_pattern_composite;

  composite_password_generator generator;

  generator.add(std::unique_ptr<symbol_generator>(new symbol_generator(2)));
  generator.add(std::unique_ptr<digit_generator>(new digit_generator(2)));

  auto password = generator.generate();
  cout << "password: " << password << endl;
}

TEST(PatternComposite, PasswordGenerator_2)
{
  using namespace cxx_pattern_composite;

  composite_password_generator generator;

  generator.add(std::unique_ptr<symbol_generator>(new symbol_generator(2)));
  generator.add(std::unique_ptr<digit_generator>(new digit_generator(2)));
  generator.add(std::unique_ptr<upper_letter_generator>(new upper_letter_generator(2)));

  auto password = generator.generate();
  cout << "password: " << password << endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-pattern-chain-of-responsibility

Behavioral Patterns

o Lets you send requests to an object implicitly through a `chain of candidate
  objects`. Any candidate may fullfill the request depending on run-time
  conditions.

cxx_pattern_chain_of_responsibility

The Morden C++ Challenge, Design Pattern

70. Approval system

Write a program for a purchasing department of a company that allows employees
to approve new purchases (or expenses). However, based on their position, each
employee may only approve expenses up to a predefined limit. For instance,
regular employees can approve expenses up to 1,000 currency units, team managers
up to 10,000, and the department manager up to 100,000. Any expense greater than
that must be explicitly approved by the company president.

The problem described can be expressed in a series of if... else if... else...
endif statements. An object-oriented version of this idiom is the chain of
responsibility design pattern. This pattern defines a chain of receiver objects
that have the responsibility of either handling a request or passing it to the
next receiver in the chain if one exists. The following class diagram shows a
possible implementation of the pattern for this problem:

*/

namespace cxx_pattern_chain_of_responsibility
{
  class role
  {
    public:
      virtual double approval_limit() const noexcept = 0;
      virtual ~role() {}
  };

  class employee_role : public role
  {
    public:
      virtual double approval_limit() const noexcept override
      {
        return 1000;
      }
  };

  class team_manager_role : public role
  { 
    public:
      virtual double approval_limit() const noexcept override
      {
        return 10000;
      }
  };

  class dept_manager_role : public role
  {
    public:
      virtual double approval_limit() const noexcept override
      {
        return 100000;
      }
  };
  
  class president_role : public role
  {
    public:
      virtual double approval_limit() const noexcept override
      {
        return std::numeric_limits<double>::max();
      }
  };

  struct expense
  {
    double amount_;
    std::string desc_;

    expense(double const amount, std::string desc)
      : amount_(amount), desc_(desc)
    {}
  };

  class employee
  {
    public:
      explicit employee(std::string name, std::unique_ptr<role> role)
        : name_(name), role_(std::move(role)) 
      {}

      void set_direct_manager(std::shared_ptr<employee> manager)
      {
        manager_ = manager;
      }

      void approve(expense const& e)
      {
        if (e.amount_ <= role_->approval_limit())
        {
          std::cout << name_ << " approved expense '" << e.desc_ << "', cost= "
            << e.amount_ << std::endl;
        }
        // *point* calls manager_
        else if (manager_ != nullptr)
          manager_->approve(e);
      }

    private:
      std::string name_;
      std::unique_ptr<role> role_;
      std::shared_ptr<employee> manager_;
  };

} // namespace

// [ RUN      ] PatternChainOfResponsibility.ApprovalSystem
// john smith approved expense 'magazins', cost= 500
// robert booth approved expense 'hotel accomodation', cost= 5000
// david jones approved expense 'conference costs', cost= 50000
// cecil williamson approved expense 'new lorry', cost= 200000
// [       OK ] PatternChainOfResponsibility.ApprovalSystem (1 ms)

TEST(PatternChainOfResponsibility, ApprovalSystem)
{
  using namespace cxx_pattern_chain_of_responsibility;

  // employee
  auto john = std::make_shared<employee>("john smith",
      std::unique_ptr<employee_role>(new employee_role()));

  // team manager
  auto robert = std::make_shared<employee>("robert booth",
      std::unique_ptr<team_manager_role>(new team_manager_role()));

  // dept manager
  auto david = std::make_shared<employee>("david jones",
      std::unique_ptr<dept_manager_role>(new dept_manager_role()));

  // president 
  auto cecil = std::make_shared<employee>("cecil williamson",
      std::unique_ptr<president_role>(new president_role()));

  // *point* build chain of approval

  john->set_direct_manager(robert);
  robert->set_direct_manager(david);
  david->set_direct_manager(cecil);

  john->approve(expense{500, "magazins"});
  john->approve(expense{5000, "hotel accomodation"});
  john->approve(expense{50000, "conference costs"});
  john->approve(expense{200000, "new lorry"});
}


={============================================================================
*kt_dev_cxx_0000* cxx-incomplete-type cxx-forward-declaration cpp-layout

struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;

*cxx-semicolon*
The semicolon marks the end of the (usually empty) list of declarators. It is
  a common mistake among new programmers to forget the semicolon at the end of
  a class definition.


CPR 278.

Just as can `declare` a function apart from its definition, can also declare
a class without defining it.

class Screen;

This declaration, sometimes referred to as a `forward-declaration`, introduces
the name Screen into the program and indicates that Screen refers to a class
type. `After a declaration and before a definition` is seen, the type Screen
is an `incomplete-type`; it is known that Screen is a class type but not known
what members that type contains.


<limited-use>
We can use an incomplete type in only limited ways: We can define pointers or
references to such types, and we can declare (`but not define`) functions that
use an incomplete type `as a parameter or return type.`

EXPC++26 *cpp-minimise-compile-time*
Parameter and return types need only to be forward declared, so instead of the
full definiton, really only need its forward declaration. e.g., iosfwd


<object-function-member>
A class must be defined(not just declared) before we can write code that
creates objects of that type or use virtual function of it. Otherwise, the
compiler does `not know how much storage such objects need.` Similarly, the
class must be defined before a reference or pointer is used to access a member
of the type. 

After all, if the class has not been defined, the compiler cannot know what
members the class has and don't know the class(type) layout:

o Cannot create object of that type.
o Cannot defines funcs using return or params of incomplete type.
o Cannot use that type to define data member of the other class.

see *cpp-ex-strblob-example*


<cpp-declaration>
A declaration tells compilers about the name and type of something and a
definition provides compilers with the details a a declartation omits. For an
object, the definition is where compilers set aside memory for the object. For
a function or function template, it provides the code body. For a class or
class template, it list the members of the class or template.

<compilation>
From p656. Ordinarily, when call a function, the compiler needs to see only a
declaration. Similarly, when use objects of class type, the class definition
must be available but the definition of the member functions need not be
present. 

As a result, put class definition and function declaration `in header file`
and definition of ordinary and class member function is source files.


From ansic, p80. A declaration announces the properties of a
variable(primarily its type) and a definition 'also' cuases storage to be set
aside.

int sp;
double val[MAXVAL];

this 'define' the external variables and cause storage to be set aside and
'also' serve as the declaration for the rest of that source file.


extern int sp;
extern double val[];

this 'declare' for the rest of the source file that sp is an int and val is a
double array.


{cxx-override-virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for
that function. This is true. The code below works fine with no errors.

#include <iostream>

class AA {
  public:
  void member_defined() { std::cout << "has definition" << std::endl; }
  void member_nodefined();
};

int main()
{
  AA aa;

  aa.member_defined();

  return 0;
}

*cxx-virtual*
However `must define every virtual function` regardless of whether it is used
because do not know which version of a function is called until run time.

extern int i;     // declare
int i;            // declare and define

void func(..);    // declare
void func(..)     // declare and define
{
   ...
}


={============================================================================
*kt_dev_cxx_0000* cxx-empty-base-class-optimization

The class has no data members at all and there can be space advantage. Compilers
are allowrd to let an empty base subobject occupy zero space; whereas an empty
member object must occupy nonzero space.

class B { // functions only, no data };

class D
{
  // b_ must occupy at least one byte even though B is an empty class.
  B b_;
};

class D : private B
{
  // the B base subobject need not occupy any space at all
};


={============================================================================
*kt_dev_cxx_0000* cxx-design-defines-problem

In order to define what the problem is:

* to translate vague goals
* to clarfy contradictory requests
* to translate perhaps unstated desires into a precisely formulated project
  that can be programmed.


<80-20-rule> 80 and 20

EC++ p139.

Typical program spends 80% of its time excuting only 20% of its code. Your
goal as a software developer is to identify the 20% of your code that can
increase your program's overall performance.

From MEC++16:

The 80-20 Rule states that 80 percent of a program's resources are used by
about 20 percent of the code: 80 percent of the runtime is spent in
approximately 20 percent of the code; 80 percent of the memory is used by some
20 percent of the code; 80 percent of the disk accesses are performed for
about 20 percent of the code; 80 percent of the maintenance effort is devoted
to around 20 percent of the code. 

The rule has been repeatedly verified through examinations of countless
machines, operating systems, and applications. The 80-20 rule is more than
just a catchy phrase; it's a guideline about system performance that has both
wide applicability and a solid empirical basis.


={============================================================================
*kt_dev_cxx_0000* cxx-design-by-contract 
  
{ex-for-type}

* EC++18, Make it hard to use incorrectly 
* for compile time and for types but not values

// Make compile error for incorrect uses (interface usage errors):

class Date {
  public:
    Date(int month, int day, int year);
    ...
};

// client use

Date d(30, 3, 1995);    // wrong order
Date d(3, 40, 1995);    // invalid

How to make compile errros? Use C++ type system.

struct Day {
  explicit Day(int day) : val(day) {}
  int val;
};

struct Month {
  explicit Month(int month) : val(month) {}
  int val;
};

struct Year {
  explicit Year(int year) : val(year) {}
  int val;
};

class Date {
  public:
    Date( const Month& month, const Day& day, const Year& year);
    ...
};


// error since not explicit and wrong order
Date d(30, 3, 1995);                      

// error since wrong order
Date d( Day(3), Month(40), Year(1995) );

// okay but invalid value. However, easy to 'see'!
Date d( Month(40), Day(3), Year(1995) );  


How to make compile error for invalid values?

* Used functions only to represent months.

class Month {
  public:
    static Month Jan() { return Month(1); }
    ...
    static Month Dec() { return Month(12); }

  private:
    // prevent creation of new values
    explicit Month(int m); 
};

Date d( Month::Mar(), Day(30), Year(1995) );


* Consider enum? NO since not type-safe. Safer solution is to predefine all
  vaild months. note: C++11 enum supports type checks. see *cxx-enum* 


{ex-for-values}

* runtime check for values
 
<cxx-design-policy>
* Using policies can improve the flexibility of classes by deferring design
  decisions to the user of the type. It is common to use policies when a group
  of types has a common interface but vary in their implementation. Policies
  are also particularly useful when it is impossible to anticipate and satisfy
  all possible usage scenarios of a given type.

// C++ cookbook, 5.6 Defining Constrained Value Types

template<typename Policy_T>
struct ConstrainedValue
{
  public:
    // public typedefs
    //
    // t_ex.cpp:435:22: error: expected nested-name-specifier before ‘Policy_T’
    //      typedef typename Policy_T policy_type;
    //                       ^
    // typedef typename Policy_T policy_type;

    typedef Policy_T policy_type;
    typedef typename Policy_T::value_type value_type;
    typedef ConstrainedValue self;
    // default constructor
    ConstrainedValue( ) : m(Policy_T::default_value) { }
    ConstrainedValue(const self& x) : m(x.m) { }
    ConstrainedValue(const value_type& x) 
    { 
      cout << "converting ctor" << endl;
      Policy_T::assign(m, x); 
    }

    operator value_type( ) const { return m; }

    // uses the policy defined assign function
    void assign(const value_type& x) {
      Policy_T::assign(m, x);
    }

    // assignment operations
    self& operator=(const value_type& x) { assign(x); return *this; }
    self& operator+=(const value_type& x) { assign(m + x); return *this; }
    self& operator-=(const value_type& x) { assign(m - x); return *this; }
    self& operator*=(const value_type& x) { assign(m * x); return *this; }
    self& operator/=(const value_type& x) { assign(m / x); return *this; }
    self& operator%=(const value_type& x) { assign(m % x); return *this; }
    self& operator>>=(int x) { assign(m >> x); return *this; }
    self& operator<<=(int x) { assign(m << x); return *this; }

    // unary operations
    self operator-( ) { return self(-m); }
    self operator+( ) { return self(+m); }
    self operator!( ) { return self(!m); }
    self operator~( ) { return self(~m); }
    // binary operations
    friend self operator+(self x, const value_type& y) { return x += y; }
    friend self operator-(self x, const value_type& y) { return x -= y; }
    friend self operator*(self x, const value_type& y) { return x *= y; }
    friend self operator/(self x, const value_type& y) { return x /= y; }
    friend self operator%(self x, const value_type& y) { return x %= y; }
    friend self operator+(const value_type& y, self x) { return x += y; }
    friend self operator-(const value_type& y, self x) { return x -= y; }
    friend self operator*(const value_type& y, self x) { return x *= y; }
    friend self operator/(const value_type& y, self x) { return x /= y; }
    friend self operator%(const value_type& y, self x) { return x %= y; }
    friend self operator>>(self x, int y) { return x >>= y; }
    friend self operator<<(self x, int y) { return x <<= y; }
    // stream operators
    friend ostream& operator<<(ostream& o, self x) { o << x.m; return o; }
    friend istream& operator>>(istream& i, self x) {
      value_type tmp; i >> tmp; x.assign(tmp); return i;
    }
    // comparison operators
    friend bool operator<(const self& x, const self& y) { return x.m < y.m; }
    friend bool operator>(const self& x, const self& y) { return x.m > y.m; }
    friend bool operator<=(const self& x, const self& y) { return x.m <= y.m; }
    friend bool operator>=(const self& x, const self& y) { return x.m >= y.m; }
    friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
    friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
  private:
    value_type m;
};

template<int Min_N, int Max_N>
struct RangedIntPolicy
{
  typedef int value_type;
  const static value_type default_value = Min_N;
  static void assign(value_type& lvalue, const value_type& rvalue) {
    if ((rvalue < Min_N) || (rvalue > Max_N)) {
      throw range_error("out of valid range");
    }
    lvalue = rvalue;
  }
};

typedef ConstrainedValue< RangedIntPolicy<1582, 4000> > GregYear;
typedef ConstrainedValue< RangedIntPolicy<1, 12> > GregMonth;
typedef ConstrainedValue< RangedIntPolicy<1, 31> > GregDayOfMonth;

void gregOutputDate(GregDayOfMonth d, GregMonth m, GregYear y) {
  cout << m << "/" << d << "/" << y << endl;
}

TEST(Ranged, X)
{
  try {
    gregOutputDate(14, 7, 2005);
  }
  catch(...) {
    cerr << "whoops, shouldn't be here" << endl;
  }
  try {
    gregOutputDate(1, 13, 1582);
    // gregOutputDate(1, 5, 1148);
    cerr << "whoops, shouldn't be here" << endl;
  }
  catch(...) {
    cerr << "are you sure you want to be using a Gregorian Calendar?" << endl;
  }
}

{ex-for-interface}
Force client to follow interface rule

Investment* createInvestment();

This means that client remember to use raii to prevent resource leaks. The
better interface decision is:

std::shated_ptr<Investment> createInvestment();

So it force client to use smart_ptr.


={============================================================================
*kt_dev_cxx_0000* cxx-design-define-variable

EC++26, postpone variable definitions

Avoid unused varaibles but see that there are variables which aren't
completely unused so to postpone variable definitions as long as possible
until is needed and have init value. Increases clarity and efficiency.

std::string encryptPassword( const std::string& password )
{
  using namespace std;

  string encrypted;

  if( password.length() < MinimumPasswordLength )
  {
    throw logic_error("Password is too short");
  }

  ...

  return encrypted;
}

The real meaning of 'as long as possible': postpone a variable's definition
until right before you have to use the variable, also try to postpone the
definition until you have initialsation arguments for it. Avoid cost of
construction, destruction and default construction.


{what-about-loop}
# approach A                           # approach B
Widget w;
for( int i=0; i < n; i++ )             for( int i = 0; i < n; i++ )
{                                      {
  w = some value;                         Widget w(some value);
  ...                                     ...
}                                      }

1 ctor, 1 dtor, n assign.              n ctor and dtor.

Choose depending on whether ctor/dtor is expensive than assign.

The approach B makes that the name w is only visible in the loop. This is good
for comprehensibility and maintainability. So approach B is 'recommended'
unless performance analysis shows approach A is better.


{make-variable-available-only-for-some}
By defining the variable in a condition, the pointer dp is not accessible
outside the if. If the cast fails, then the unbound pointer is not available
for use in subsequent code where we might forget to check whether the cast
succeeded.

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
   
} else {  // bp points at a Base object

    // use the Base object to which bp points
}


={============================================================================
*kt_dev_cxx_0000* cxx-design-interface-first

See *cxx-sp-ex-strblob-example* as well.

https://isocpp.org/wiki/faq/operator-overloading#design-interfaces-first

Should I design my classes from the outside (interfaces first) or from the
inside (data first)?

From the outside!

A good interface provides a simplified view that is expressed in the vocabulary
of a user. In the case of OO software, the interface is normally the set of
public methods of either a single class or a tight group of classes.

First think about what the object logically represents, 'not' how you intend to
physically build it. For example, suppose you have a Stack class that will be
built by containing a LinkedList:

class Stack {
  public:
    // ...
  private:
    LinkedList list_;
};

Should the Stack have a get() method that returns the LinkedList? Or a set()
  method that takes a LinkedList? Or a constructor that takes a LinkedList?
  Obviously the answer is No, since you should design your interfaces from the
  outside-in. i.e., 
  
  "users of Stack objects don’t care about LinkedLists; they care about
  pushing and popping."

Now for another example that is a bit more subtle. Suppose class LinkedList is
built using a linked list of Node objects, where each Node object has a
pointer to the next Node:

class Node { /*...*/ };

class LinkedList {
  public:
    // ...
  private:
    Node* first_;
};

Should the LinkedList class have a get() method that will let users access the
first Node? Should the Node object have a get() method that will let users
follow that Node to the next Node in the chain? In other words, what should a
LinkedList look like from the outside? Is a LinkedList really a chain of Node
objects? Or is that just an implementation detail? And if it is just an
implementation detail, how will the LinkedList let users(Stack class) access
each of the elements in the LinkedList one at a time?

The key insight is the realization that a LinkedList is not a chain of Nodes.
That may be how it is built, `but that is not what it is.` What it is is a
sequence of elements. 

Therefore the LinkedList `abstraction` should provide a LinkedListIterator
class as well, and that LinkedListIterator might have an operator++ to go to
the next element, and it might have a get()/set() pair to access its value
stored in the Node (the value in the Node element is solely the responsibility
    of the LinkedList user, which is why there is a get()/set() pair that
    allows the user to freely manipulate that value).

Starting from the user’s perspective, we might want our LinkedList class to
support operations that look similar to accessing an array using pointer
arithmetic:

    void userCode(LinkedList& a)
    {
      for (LinkedListIterator p = a.begin(); p != a.end(); ++p)
        std::cout << *p << '\n';
    }

To implement this interface, LinkedList will need a begin() method and an
end() method. These return a LinkedListIterator object. The LinkedListIterator
will need a method to go forward, ++p; a method to access the current element,
     *p; and a comparison operator, p != a.end().

The code follows. 

The important thing to notice is that LinkedList does not have any methods
that let users access Nodes. 

Nodes are an implementation technique that is completely buried. This makes:

  the LinkedList class safer (no chance a user will mess up the invariants and
      linkages between the various nodes), 
  
  easier to use (users don’t need to expend extra effort keeping the node-count
      equal to the actual number of nodes, or any other infrastructure stuff),

  and more flexible (by changing a single typedef, users could change their code
      from using LinkedList to some other list-like class and the bulk of their
      code would compile cleanly and hopefully with improved performance
      characteristics).


#include <cassert>    // Poor man's exception handling

class LinkedListIterator;
class LinkedList;

class Node {
  // No public members; this is a "private class"
  friend class LinkedListIterator;   // A friend class
  friend class LinkedList;
  Node* next_;
  int elem_;
};

class LinkedListIterator {
  public:
    bool operator== (LinkedListIterator i) const;
    bool operator!= (LinkedListIterator i) const;
    void operator++ ();   // Go to the next element

    // note: get/set to access element(value)
    int& operator*  ();   // Access the current element

  private:
    LinkedListIterator(Node* p);
    Node* p_;
    friend class LinkedList;  // so LinkedList can construct a LinkedListIterator
};

class LinkedList {
  public:
    void append(int elem);    // Adds elem after the end
    void prepend(int elem);   // Adds elem before the beginning

    // ...
    LinkedListIterator begin();
    LinkedListIterator end();

    // ...
  private:
    Node* first_;
};

Here are the methods that are obviously inlinable 

inline bool LinkedListIterator::operator== (LinkedListIterator i) const
{
  return p_ == i.p_;
}
inline bool LinkedListIterator::operator!= (LinkedListIterator i) const
{
  return p_ != i.p_;
}
inline void LinkedListIterator::operator++()
{
  assert(p_ != NULL);  // or if (p_==NULL) throw ...
  p_ = p_->next_;
}
inline int& LinkedListIterator::operator*()
{
  assert(p_ != NULL);  // or if (p_==NULL) throw ...
  return p_->elem_;
}
inline LinkedListIterator::LinkedListIterator(Node* p)
  : p_(p)
{ }
inline LinkedListIterator LinkedList::begin()
{
  return first_;
}
inline LinkedListIterator LinkedList::end()
{
  return NULL;
}

Conclusion: 

The linked list had two different kinds of data. The values of the elements
stored in the linked list are the responsibility of the user of the linked
list (and only the user; the linked list itself makes no attempt to prohibit
    users from changing the third element to 5), and the linked list’s
infrastructure data (next pointers, etc.), whose values are the responsibility
of the linked list (and only the linked list; e.g., the linked list does not
    let users change (or even look at!) the various next pointers).

Thus the only get()/set() methods were to get and set the elements of the
linked list, but not the infrastructure of the linked list. Since the linked
list hides the infrastructure pointers/etc., it is able to make very strong
promises regarding that infrastructure (e.g., if it were a doubly linked list,
    it might guarantee that every forward pointer was matched by a backwards
    pointer from the next Node).

So, we see here an example of where the values of some of a class’s data is
the responsibility of users (in which case the class needs to have get()/set()
    methods for that data) but the data that the class wants to control does
  not necessarily have get()/set() methods.

The purpose of this example is not to show you how to write a linked-list
class. In fact you should not “roll your own” linked-list class since you
should use one of the “container classes” provided with your compiler. Ideally
you’ll use one of the standard container classes such as the std::list<T>
template.


={============================================================================
*kt_dev_cxx_0000* cxx-design-core-guide

I.23: Keep the number of function arguments low

Reason 
Having many arguments opens opportunities for confusion. Passing lots of
arguments is often costly compared to alternatives.

Discussion 
The two most common reasons why functions have too many parameters are:

1. Missing an abstraction. There is an abstraction missing, so that a compound
value is being passed as individual elements instead of as a single object
that enforces an invariant. This not only expands the parameter list, but it
leads to errors because the component values are no longer protected by an
enforced invariant.

2. Violating “one function, one responsibility.” The function is trying to do
more than one job and should probably be refactored.

Example The standard-library merge() is at the limit of what we can
comfortably handle:

template<class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, InputIterator2 last2,
                      OutputIterator result, Compare comp);

Note that this is because of problem 1 above  missing abstraction. Instead of
  passing a range (abstraction), STL passed iterator pairs (unencapsulated
      component values).

Here, we have four template arguments and six function arguments. To simplify
the most frequent and simplest uses, the comparison argument can be defaulted
to < :

template<class InputIterator1, class InputIterator2, class OutputIterator>
OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, InputIterator2 last2,
                      OutputIterator result);

This doesn’t reduce the total complexity, but it reduces the surface
  complexity presented to many users. To really reduce the number of
  arguments, we need to bundle the arguments into higher-level abstractions:

template<class InputRange1, class InputRange2, class OutputIterator>
OutputIterator merge(InputRange1 r1, InputRange2 r2, OutputIterator result);

Grouping arguments into “bundles” is a general technique to reduce the number
  of arguments and to increase the opportunities for checking.

Note How many parameters are too many? Try to use fewer than four (4)
parameters.  There are functions that are best expressed with four individual
parameters, but not many.

Alternative: Use better abstraction: Group arguments into meaningful objects
and pass the objects (by value or by reference).

Alternative: Use default arguments or overloads to allow the most common forms
of calls to be done with fewer arguments.


={============================================================================
*kt_dev_cxx_0000* cxx-new-delete

default-value-initialize:

string* ps = new string;      // default-init
string* ps = new string();    // value-init. T()

int* pi = new int;            // default-init
int* pi = new int();          // value-init. T()

For built-in types, value-init set initialized values and default-init has
`uninitialized values.` For class types, both will use default ctors and so no
difference. 
  
The `cxx-new-operator` combines `allocation and construction`; creates `unnamed`
and then *cxx-default-init* objects e.g. calls ctor for class object.


{cxx-new-operator-and-cxx-operator-new}
MEC++08: This operator is built into the language and, like *cxx-sizeof* you
can't change its meaning: it always does the same thing:
`allocation and construction.`

The `cxx-new-operator`, use `cxx-operator-new` (or operator new[]) to allocate
raw memory, runs ctor to construct, and returns pointer to constructed memory.
Raise 'bad_alloc' exception when there is no memory.

For deletion, do opposite; runs dtor and operator delete( or delete[]) to free
memory.

*cxx-remember* cxx-delete-null
C++ runtime gurantees that delete nullptr do nothing.


{do-not-mix-with-array-form}
EC++16. Use the same form in corresponding uses of new and delete since these
do two things but think what will happen when call destructor(s) less or more
than needed. Undefined in both ways. 

std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100]; 

delete stringPtr1;
delete[] stringPtr2;

This can be not obvious when use typedef: 

typedef std::string AddressLines[4];
std::string *pal = new AddressLines;

delete pal;    // undefined
delete[] pal;

If do not know that there is a typedef, for example, it is in a file somewhere
in huge source tree then may be a problem.


{operator-new-and-delete}
This is the C++ equivalent of calling malloc and free. What you can change is
how the memory for an object is allocated. The name of the function that the
new operator calls to allocate memory is operator new. Can rewrite or overload
that function to change its behavior.

The operator new function is usually declared like this:

void * operator new(size_t size);

The return type is void*, because this function returns a pointer to raw,
    uninitialized memory.

void *rawMemory = operator new(sizeof(string));

Like malloc, operator new's only responsibility is to allocate memory.

note: Can define own operator new and delete but careful because it takes over
responsibility for 'all' dynamic memory allocation. Since it changes global
one so new operator will automatically invoke your custom version of operator
new.


{new-operator-with-zero-size}
What happens if get_size returns 0? The answer is that our code works fine.
Calling new[0] is legal even though we cannout create an array variable of
size 0.

char arr[0];              // error: cannot define a zero-length array
char *cp = new char[0];   // ok: but cp can't be dereferenced

// p acts as the off-the-end pointer
size_t n = get_size();
int *p = new int[n];
for (int* q = p; q != p + n; ++q)
  // process the array
  

{new-handler}
EC++49, new handler

Before operator new throws an exception in response to an unsatisfiable
request for memory, calls a error handling function called new handler. Can
set user's handler by calling set_new_handler for 'flexibility' of handling
allocation errors.

namespace std {
  typedef void (*new_handler)();
  new_handler set_new_handler( new_handler p ) throw();     // see cxx-noexcept
};

void outOfMem()
{
  std::cerr << "Unable to satisfy request for memory\n";
  std::abort();
}

int main()
{
  std::set_new_handler( outOfMem );
  int *pBigDataMemory = new int[10000000000L];
  ...
}

When operator new is unable to fulfill a memory request, calls new handler
'repeatedly' until it can find enough memory. So handler must do one of
followings:

1. Make more memory avaiable
For example, allocate a large block of memory at program start-up, then
release it for use the first time thw handler is invoked.

2. Install a different handler
If the current handler can't make any more memory available, perhaps it knows
of a different handler that can and next time operator new calls the new
handler. note: May have hierachy of handler.

3. Deinstall handler
Call set_new_handler(0). With no handler installed, operator new will throws
an exception when allocation is unsuccessful.

4. Throw an exception
Throw a type bad_alloc or derived from bad_alloc.

5. Not return
Typically calls abort or exit.


{class-specific-handler}
Instead of using 'global' handler, can use class specific handler.

// Widget

class Widget {
  public:
    static std::new_handler set_new_handler( std::new_handler p ) throw ();
    static void *operator new( std::size_t size ) throw ( std::bad_alloc );

  private:
    static std::new_handler currentHandler;
};

std::new_handler Widget::currentHandler = 0;

std::new_handler Widget::set_new_handler( std::new_handler p ) throw ()
{
  // note: this merely set currentHandler
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}

void* Widget::operator new( std::size_t size ) throw( std::bad_alloc )
{
  // note: save old global handler and set new one
  NewHandlerHolder h( std::set_new_handler(currentHandler));

  // note: call global operator new
  return ::operator new(size);
}

// HandlerHolder
// note: uses raii to restore global handler back when done

class NewHandlerHolder {
  public:
    explicit NewHandlerHolder( std::new_handler nh ) : handler(nh) {}
    ~NewHandlerHolder() { std::set_new_handler(handler); }

  private:
    std::new_handler handler;

    // preventing copies
    NewHandlerHolder( const NewHandlerHolder& );
    NewHandlerHolder& operator=( const NewHandlerHolder& );
};

// Use

void outOfMem();

Widget::set_new_handler( outOfMem );

// note: see how Widget's operator new is called due to arg-dependent lookup.
Widget* pw1 = new Widget;              // if allocation fails, call outOfMem

std::string* ps = new std::string;     // if allocation fails, call global one if there is

Widget::set_new_handler(0);            // set no handler for Widget

Widget* pw2 = new Widget;              // if allocation fails, throw exception immediately

<to-support-other-class>
This scheme is the same regardless of the class and then use template to
support other types.

template<typename T>
class NewHandlerSupport {
  public:
    static std::new_handler set_new_handler( std::new_handler p ) throw ();
    static void* operator new( std::size_t size ) throw (std::bad_alloc);

    // other versions of operator new.
  private:
    static std::new_handler currentHandler;
};

template<typename T>
std::new_handler NewHandlerSupport<T>::currentHandler = 0;

template<typename T>
std::new_handler NewHandlerSupport<T>::set_new_handler( std::new_handler p ) throw ()
{
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}

template<typename T>
void* NewHandlerSupport<T>::operator new( std::size_t size ) throw( std::bad_alloc )
{
  NewHandlerHolder h( std::set_new_handler(currentHandler));

  return ::operator new(size);
}

class Widget : public NewHandlerSupprt<Widget> {
  // as before but without set_new_handler and operator new
};

note: never use type parameter T. All need is a different copy of
NewHandlerSupport, in particular its static data member currentHandler.
Template mechanism do.

note: this is useful and called 'mixin' style inheritance. how about "is-a"
relationship?


{replace-new}
EC++50: when to replace new and delete

Three common reasons to replace complier provided operator new and delete.

1. To detect usage errors

1.1. Operator new keeps a list of allocated addresses and operator delete
removes addresses from the list, easy to detect usage errors.

1.2. Overrun and underrun. Have signature before and after the memory made
available to clients.  Operator delete can check if the signatures are still
intact, can log when overrun or underrun occurred along with the value of the
offending pointer.

2. To improve efficiency

2.1. The default operator new and delete is general purpose such as large
blocks, small blocks, and mixtures of the two. Have to worry about heap
fragmentation. If know allocation 'pattern' of an application, can use custom
operator new and delete to have performance improvements.

2.2. Custom version for objects of a particular type such as class-specific
allocators. Boot pool libaray for fixed-size allocators.

2.3. Reduce space overhead. The general version often incur some overhead for
each allocated block.  Allocators tuned for small objects such as boost pool
library essentially eliminate such overhead.

2.4. Cluster related objects. If know that particular data structures are used
together and like to minimize page 'fault', can create a separate 'heap' for
the data so they are clustered together as few pages as possible. Placement
version can make it possible to achieve such clustering. note: placement new
use case.

3. To collect usage statics

Before writing custom new and delete, gather information about how application
uses dynamic memory.  Distribution of allocated block size, their lifetime,
     allocation and deallocation order such as FIFO, LIFO, or random, usage
     pattern changes in different stages of execution, maximum amount of
     allocated memory in use at any one time (high water mark or peak value).
     Custom version make it easy to collect this kind of information.

4. To have unconventioal behavior

4.1. Allocate and deallocate blocks in shared memory which has a C API or
memory-mapped I/O. note: placement new use case.

4.2. Overwrite deallocated blocks with zeros in order to increase the security
of application data.


<example> to show how to replace global operator new and see EC++51 for details
static const int signature = 0xDEADBEEF;

typedef unsigned char Byte;

// this code has several flaws
void* operator new( std::size_t size ) throw( std::bad_alloc )
{
  using namespace std;

  size_t realSize = size + 2*sizeof(int);

  void *pMem = malloc( realSize );
  if( !pMem ) throw bad_alloc();

  *(static_cast<int*>(pMem)) = signature;
  *(reinterpret_cast<int*>(static_cast<Byte*>(pMem)+realSize-sizeof(int)) ) = signature;

  return static_cast<Byte*>(pMem)+sizeof(int);
}

<alignment-consideration>
Many computer architectures require that data of particular type be placed in
memory in particular kinds of address. Called alignments. If not, cause
hardware exception or slow performance. If simly uses malloc then no problem
since C++ guarantees malloc returns alligned pointer. However, the above code
is not returning a pointer we got from malloc. So this is consideration when
think of custom new and delete.

Two options: Compiler can have options for different memory managers or open
source memory managers such as boost pool library for allocation of a large
number of small objects, fixed-size allocator.


{cxx-new-placement}

Widget* pw = new Widget;

Two functions are called: operator new and constructor. What would happen when
operator new allocated memory but constructor raised exception? C++ runtime
system gurantees to undo operator new.

{normal-new-and-delete-form}
The normal global new and delete are:

void* operator new( std::size_t ) throw (std::bad_alloc);            // normal new
void* operator new( std::size_t, void* ) throw();                    // placement new
void* operator new( std::size_t, const std::nothrow_t& ) throw();    // nothrow new
void operator delete( void* rawMemory ) throw ();
void operator delete( void* rawMemory, std::size_t ) throw ();       // at class scope


{placement-new} interview question
Means operator new function that takes additional parameters other than the
size. To use this version of new, include 'new' header.

note: see how passes parameters to operator new
note: operator new and deletes use 'overloads' mechanism.

// placement version to log allocations to ostream
static void* operator new( std::size_t size, std::ostream& os ) throw (std::bad_alloc);

// particularly useful placement version
void* operator new( std::size_t size, void *pMemory) throw();

<ex>
One example is to tell not to raise exception. No exception and return 'nullptr'
instead. 

This is for older code which expect null pointer when allocation fails since
newer C++ raise an exception instead. This is called 'nothrow' new. This only
guarentees no exception in operator new but not whole expression since
constructor can still raise an exception. So will never have a need for
nothrow new.

The nothrow keyword is the same as noexcept but used in new operator
expression.

int* pi = new (std::nothrow) int;

<ex>
The other example is that it is used inside vector<> to create objects in the
vector's unused capacity. note: not sure when looked at gcc code. 

<example>
new (place_address) type 
new (place_address) type (initializers)

Widget * constructWidgetInBuffer(void *buffer, int widgetSize)
{
  return new (buffer) Widget(widgetSize);
}

This function returns a pointer to a Widget object that's constructed within the buffer passed to
the function.

<must-provide-all>
C++ choose corresponding delete when undo operator new so must provide 'both' when customize new and
delete. If not found, no delete is called.

Suppose class specific new and delete that logs allocations to ostream.

class Widget {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);

    // normal class specific form of delete
    static void operator delete( void *p, std::size_t size ) throw();
};

Widget* pw = new (std::cerr) Widget;

As with nothrow version, the problem is that C++ cannot find the corresponding delete when
constructor raises exception. So must have placement 'delete' as well.

void operator delete(void*, std::ostream&) throw();

If not, no delete is called if constructor throws an exception.

However, consider what happens if no exception is thrown and get to delete in client code. This
calls the normal operator delete but not placement version. Placement delete is called 'only' if an
exception arises from a 'constructor' that's coupled to a call to a placement new.

delete pw;

Therefore, must provide all to forestall all memory leaks associated with placement versions of new.

class Widget {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);

    // placement version
    static void operator delete(void *p, std::ostream& os) throw();

    // normal delete
    static void operator delete(void *p) throw();
};

<consider-cxx-hide-name>
Since member function names hides functions in outer scopes, class specific new and delete hides
normal new and delete.

class Base {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);
};

Base* pb = new Base;                // error since normal new is hidden
Base* pb = new (std::cerr) Base;    // okay

Similarly, new in derived hides both global and inherited versions.

class Derived : public Base {
  static void* operator new( std::size_t size ) throw( std::bad_alloc );
};

Derived* pd = new (std::clog) Derived;    // error
Derived* pd = new Derived;                // okay

So unless mean to prevent class clients from using these forms, be sure to make them available in
addition to any custom versions you create.

<conclusion>
An easy way is to create base class containing all and client just use inheritance to get the
standard forms.

class StandardNewDeleteForms {
  public:
    // normal new/delete
    static void* operator new( std::size_t size ) throw (std::bad_alloc)
    { return ::operator new(size); }
    static void operator delete( void* rawMemory ) throw ()
    { ::operator delete(rawMemory); }

    // placement new/delete
    static void* operator new( std::size_t size, void* pMem ) throw()
    { return ::operator new(size, pMem); }
    static void operator delete( void* rawMemory, void* pMem) throw()
    { ::operator delete( rawMemory, pMem ); }

    // nothrow new/delete
    static void* operator new( std::size_t size, const std::nothrow_t& nt ) throw()
    { return ::operator new(size, nt); }
    static void operator delete( void* rawMemory, const std::nothrow_t&) throw()
    { ::operator delete( rawMemory ); }
};

class Widget : public StandardNewDeleteForms {
  public:
    // make those visible
    using StandardNewDeleteForms::operator new;
    using StandardNewDeleteForms::operator delete;

    static void* operator new( std::size_t size, std::ostream& os ) throw( std::bad_alloc );
    static void operator delete( void* rawMemory, std::ostream& os ) throw();
};


={============================================================================
*kt_dev_cxx_0000* cxx-allocator

The C++ standard library uses special objects to handle the allocation and
deallocation of memory. Such objects are called allocators. They represent a
special "memory model" and are used `as an abstraction to translate` the need
to use memory into a raw call for memory. The use of different allocator
objects at the same time allows you to use different memory models in a
program.

Originally, allocators were introduced as part of the STL to handle the nasty
problem of different pointer types on PCs (such as near, far, and huge
    pointers). 

Now, allocators serve as a base for technical solutions that use certain
`memory models`, such as shared memory, garbage collection, and
object-oriented databases, without changing the interfaces.


#include <memory>

template<class T>
struct allocator;

template<>
struct allocator<void>;


The allocator provides `type-aware allocation` since it is template and returns
unconstructed memory while *cxx-operator-new* uses only size. Be careful since
using unconstructed memory is cxx-undefined.

o The default allocator is used as the default value everywhere an allocator can
  be used as an argument.

o Provides a way to decouple alloc/dealloc and construction/destruction and
  allows finer control. For example, allocate big memory and pay the overhead of
  construction only when needed.

<ex>

[ RUN      ] CxxMemoryModel.allocator
sizeof p : 8
sizeof *p: 32
coll{string1,string2,string3,}
coll{string1,string2,string3,}
[       OK ] CxxMemoryModel.allocator (0 ms)

TEST(CxxMemoryModel, allocator)
{
  // do allocation only
  {
    std::allocator<std::string> alloc;
    auto const p = alloc.allocate(10);
    std::cout << "sizeof p : " << sizeof(p) << std::endl;
    std::cout << "sizeof *p: " << sizeof(*p) << std::endl;
    alloc.deallocate(p, 10);
  }

  // do allocation and construction
  {
    std::allocator<std::string> alloc;

    // auto const data = alloc.allocate(10);
    auto data = alloc.allocate(10);

    // back it up.
    // NOTE: shall use `coll` to deallocate and access. crashes otherwise.
    auto const coll = data;

    // calls ctor. From *cxx-11*, supports many ctors of the 'type'. 
    //
    // The first argument to construct() must be a pointer to unconstructed
    // space allocated by allocate(). The second and subsequent argument
    // determine ctor to use.
    //
    // alloc.destroy(p) calls dtor

    alloc.construct(data++, "string1");
    alloc.construct(data++, "string2");
    alloc.construct(data++, "string3");

    std::cout << "coll{";

    for (int i = 0; i < 3; i++)
      std::cout << coll[i] << ",";

    std::cout << "}" << std::endl;

    alloc.deallocate(coll, 10);
  }

  // do allocation and construction
  {
    std::allocator<std::string> alloc;
    auto const data = alloc.allocate(10);

    const std::vector<std::string> coll{"string1", "string2", "string3"};

    // o The library defines two that calls `construct()` on each element in
    //   unconstructed memory.
    //
    // o Returns the position after the last initialized element.
    //   Like cxx-copy, return its incremented destination iterator.
    //
    // to sum, do "construct and copy" to destination
    //
    // uninitialized_copy_n(b, n, b2);
    // uninitialized_fill(b, e, t);
    // uninitialized_fill_n(b, n, t);

    auto result = std::uninitialized_copy(
        coll.cbegin(), coll.cend(), data);

    std::cout << "coll{";

    for (int i = 0; i < 3; i++)
      std::cout << data[i] << ",";

    std::cout << "}" << std::endl;

    alloc.deallocate(data, 10);
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-random

{cxx-random-cxx-rand-function}
NAME
       rand, rand_r, srand - pseudo-random number generator

SYNOPSIS
       #include <stdlib.h>

       int rand(void);
       int rand_r(unsigned int *seedp);
       void srand(unsigned int seed);

DESCRIPTION
       The  rand()  function returns a pseudo-random integer in the range 0 to
       RAND_MAX inclusive (i.e., the mathematical range [0, `RAND_MAX`]).

NOTES
       The versions of rand() and srand() in the Linux C Library use the  same
       random number generator as random(3) and srandom(3), so the lower-order
       bits should be as random as the higher-order bits.  However,  on  older
       rand()  implementations,  and  on  current implementations on different
       systems, the lower-order bits are much less  random  than  the  higher-
       order  bits.   Do  not use this function in applications intended to be
       portable when good randomness is needed.  (Use random(3) instead.)

<ex>
#include <stdlib.h>

void Randomize()
{
  srand( (unsigned int) (time(NULL)%10000));
}

*linux-time* for `time()` 

int PoissonRandom( double expectedvalue )
{
  int n = 0;
  double limit;
  double x;

  limit = exp(-expectedvalue);
  x = rand()/(double) INT_MAX;
  while( x > limit )
  {
    n++;
    x *= rand()/(double) INT_MAX;
  }

  return n;
}


{cxx-random}

CLR-17.1 Random Numbers and Distributions

the engines, which are the sources of randomness. These engines create random
unsigned values, which are uniformly distributed between a predefined minimum
and a maximum; 

the distributions transfer those values into random numbers, which are
linearly or nonlinearly distributed according to usersupplied parameters.

The *call-rand* has several problems. Many programs need random numbers in a
different range and some require random floating-point numbers. Some needs
numbers that reflect a nonuniform distribution. 

o engine: types that generate a sequence of random unsigned integers
  a random-number engine is a `stateful` source of randomness.

o distribution: types that use an engine to retuen numbers according to a
  particular probability distribution.

  In the constructor, the first argument specifies the minimum value (default:
  0), and the second argument specifies the maximum value (default:
  numeric_limits<type>::max()

`The engines are function-object` class that define a call operator and returns a
random unsigned number. The engine object is similar to the output of rand().

The library defines `several random-number engines` that differ in terms of
performance and quality of randomness. Each compiler designates one of these
as the default_random_engine type. This is intended to be the engine with the
most generally useful properties.

When refer to an random-number generator, mean the combination of a
distribution object with an engine.


*cxx-random-same-sequence*

Even though the numbers generated appear to be random, a given generator returns
the same sequence of numbers each time it is run. This is very `helpful` during
testing and on the other hand, programs have to take this fact into account. 

To have different sequence, make the engine and distribution objects `static`
and they will hold their state across calls.

TEST(CxxRandom, check_distribution_1)
{
  std::default_random_engine dre{};

  std::ostringstream oss{};

  {
    std::string expected{"16807, 282475249, 1622650073, 984943658, 1144108930, 470211272, 101027544, 1457850878, 1458777923, 2007237709, "};

    // `The engines are function-object` class that define a call operator and
    // returns a random unsigned number. The engine object is similar to the
    // output of rand().

    // use random but always shows the same sequence
    for (size_t i = 0; i < 10; ++i)
      oss << dre() << ", ";

    EXPECT_THAT(oss.str(), expected);
  }

  {
    // clear oss
    oss.str("");

    std::uniform_int_distribution<unsigned> dist1{0, 6};

    for (size_t i = 0; i < 10; ++i)
      oss << dist1(dre) << ", ";

    // std::cout << oss.str() << std::endl;

    EXPECT_THAT(oss.str(), "2, 3, 5, 0, 0, 3, 4, 0, 2, 0, ");
  }

  {
    // clear oss
    oss.str("");

    std::uniform_int_distribution<unsigned> dist1{6, 12};

    for (size_t i = 0; i < 10; ++i)
      oss << dist1(dre) << ", ";

    // std::cout << oss.str() << std::endl;

    EXPECT_THAT(oss.str(), "8, 10, 10, 12, 11, 9, 6, 10, 8, 10, ");
  }
}

namespace cxx_random
{
  class UseEngine
  {
    private:
      static std::default_random_engine dre;
      static std::uniform_int_distribution<size_t> dist;

    public:
      int operator()() { return dist(dre); }
  };

  std::default_random_engine UseEngine::dre{};
  std::uniform_int_distribution<size_t> UseEngine::dist{0, 24};

  class UseRand
  {
    private:
      int max_{};
      int min_{};

    public:
      int operator()() { return min_ + (rand() % (max_ - min_ + 1)); }

      UseRand(int min, int max)
          : max_{max}
          , min_{min}
      {}
  };
}

TEST(CxxRandom, check_distribution_2)
{
  using namespace cxx_random;

  std::ostringstream oss{};

  // always same sequence
  {
    std::vector<size_t> coll1{};

    std::generate_n(std::back_inserter(coll1), 12, UseEngine());

    for (size_t i = 0; i < coll1.size(); ++i)
      oss << coll1[i] << ", ";

    // std::cout << oss.str() << std::endl;

    EXPECT_THAT(oss.str(), "0, 3, 18, 11, 13, 5, 1, 16, 16, 23, 9, 12, ");
  }

  // always same sequence but differnet numbers since dre is static single
  // instance and makes different sequence

  {
    std::vector<size_t> coll1{};

    oss.str("");

    std::generate_n(std::back_inserter(coll1), 12, UseEngine());

    for (size_t i = 0; i < coll1.size(); ++i)
      oss << coll1[i] << ", ";

    // std::cout << oss.str() << std::endl;

    EXPECT_THAT(oss.str(), "20, 0, 1, 13, 16, 0, 9, 1, 10, 17, 14, 23, ");
  }

  {
    std::vector<size_t> coll1{};

    oss.str("");

    std::generate_n(std::back_inserter(coll1), 12, UseRand{0, 23});

    for (size_t i = 0; i < coll1.size(); ++i)
      oss << coll1[i] << ", ";

    // std::cout << oss.str() << std::endl;

    EXPECT_THAT(oss.str(), "7, 22, 9, 19, 17, 7, 10, 12, 9, 13, 2, 19, ");
  }
}

TEST(CxxRandom, check_distribution_3)
{
  // single instance and makes different sequence
  {
    std::default_random_engine dre;

    std::vector<unsigned int> coll1{};

    for (size_t i = 0; i < 18; ++i)
    {
      coll1.push_back(dre());
    }

    std::vector<unsigned int> coll2{};

    for (size_t i = 0; i < 18; ++i)
    {
      coll2.push_back(dre());
    }

    // differnt sequence
    EXPECT_THAT(coll1==coll2, false);
  }

  // different dre instance and makes the same sequence
  {
    std::vector<unsigned int> coll1{};
    std::vector<unsigned int> coll2{};

    {
      std::default_random_engine dre;

      for (size_t i = 0; i < 18; ++i)
      {
        coll1.push_back(dre());
      }
    }

    {
      std::default_random_engine dre;

      for (size_t i = 0; i < 18; ++i)
      {
        coll2.push_back(dre());
      }
    }

    // same sequence
    EXPECT_THAT(coll1==coll2, true);
  }
}


*cxx-random-seed*

The same sequence is helpful during debugging. However, once program is tested
we often want to cause each run to generate different random results.

default_random_engine(C++11) implementation-defined

namespace cxx_code
{
  // bits/random.h
  /**
   * @brief Constructs a %linear_congruential_engine random number
   *        generator engine with seed @p __s.  The default seed value
   *        is 1.
   *
   * @param __s The initial seed value.
   */
  explicit
    linear_congruential_engine(result_type __s = default_seed)
    { seed(__s); }

  /**
   * The classic Minimum Standard rand0 of Lewis, Goodman, and Miller.
   */
  typedef linear_congruential_engine<uint_fast32_t, 16807UL, 0UL, 2147483647UL>
    minstd_rand0;

  typedef minstd_rand0 default_random_engine;
}

TEST(CxxRandom, check_distribution_4)
{
  constexpr auto MAX_GENERATION{1000};

  std::default_random_engine dre1{};
  std::default_random_engine dre2{2147483646};

  std::default_random_engine dre3{};
  dre3.seed(32767);

  std::default_random_engine dre4{32767};

  int unmatched{};
  int matched{};

  for (size_t i = 0; i < MAX_GENERATION; ++i)
  {
    // uses different seeds so expects no matches between them
    if (dre1() == dre2())
      ++matched;

    // uses the same seeds so expects matches between them
    if (dre3() != dre4())
      ++unmatched;
  }

  EXPECT_THAT(matched, 0);
  EXPECT_THAT(unmatched, 0);
}

Picking a good seed, like most things about generating good random numbers, is
surprisingly hard. The most common approach is to call `call-time()` function. 

Since that retuns time as the number of seconds, this seed is `only` useful for
applications that generate the seed at longer intervals. This usually doesn't
work if the program is run repeatedly as part of an automated process; it might
wind up with the same seed several times.


CPL-40.7 Random Numbers


{cxx-random-unique}

namespace pearl_1_6_4
{
  // How to slect `unique random numbers`?
  //
  // https://github.com/filipegoncalves/codinghighway/tree/master/ProgrammingPearls/Column1/1.6.4
  //
  // Here, we are faced with the challenge of avoiding duplicates. Column 12 is
  // a must-read to solve this exercise the good way. It introduces very
  // important concepts and algorithms to efficiently generating a set of m
  // unique random integers in [0, n-1], with m <= n.
  // 
  // Because we don't want the set to be ordered, we cannot use Knuth's
  // Algorithm S. Instead, we opt for Knuth's Algorithm P, in which we shuffle
  // an n-element array that contains the numbers 0..n-1.  To implement
  // Algorithm P, we need a randint() function. We will learn more about it in
  // column 13; for now, it simply adds a random quantity to the lower bound
  // that doesn't exceed the upper bound.
  // 
  // The resulting file, numbers2.in, is provided in this column's root folder.

  const int N=10000000;
  const int M=1000000;
  int arr[N];

  // +1 to support [from, to] and -1 in suffle as below

  int randint(int from, int to) {
    return from + (rand()%(to-from+1));
  }

  void swap(int i, int j) {
    int t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
  }
}

// so not sorted but makes unique random numbers

TEST(ProgrammingPearl, C1_6_4)
{
  using namespace pearl_1_6_4;

  multiset<int> coll{};
  bool duplicates{false};

	int i;

	srand(time(NULL));

  // makes unique numbers
	for (i = 0; i < N; i++)
		arr[i] = i;

  // shuffle
	for (i = 0; i < M; i++)
		swap(i, randint(i, N-1));

  // output
	for (i = 0; i < M; i++)
  {
    coll.insert(arr[i]);
		// printf("%d\n", arr[i]);
  }

  for (auto e : coll)
  {
    if (1 < coll.count(e))
      duplicates = true;
  }

  EXPECT_THAT(duplicates, false);
}


={============================================================================
*kt_dev_cxx_0000* cxx-enum

The enumerations group together sets of `integral constants` and 
`defines new type.` From ansic, there are two advantages over #define:

o To associate constant value with `symbolic names`

o A debugger may be able to print values of enumeration variables. confirmed on
  gcc.


{cxx-enum-scoped} *cxx-11*
cxx-enum-scoped support scope and type checks.

`cxx-enum-scoped is a new type` so no longer need to use typedef and can be used
in other class.

class WeatherStation
{
public:
    virtual ~WeatherStation(){};
 
    // typedef enum
    // {
    //     North, South, East, West
    // } Direction;
 
    // typedef enum
    // {
    //     Optimistic, Pessimistic
    // } Outlook;

    enum Direction
    {
        North, South, East, West
    };
 
    enum Outlook
    {
        Optimistic, Pessimistic
    };
};

class UserInterface
{
  public:
    UserInterface( const std::shared_ptr<WeatherStation>& weather_station ) :
      weather_station_( weather_station )
    {
    }

    std::pair<std::string, std::string> predict_range()
    {
      return std::make_pair( 
          weather_station_->prediction( WeatherStation::Optimistic ),
          weather_station_->prediction( WeatherStation::Pessimistic ) );
    }
};


{cxx-enum-forms}
The enumerator is const and `need not be unique` By default, start at 0 and
increases by 1.

// `class enum` scoped, named
enum class open_modes { input, output, append };

// `plain enum` unscoped, named
enum color { red, yellow, green };

// unscoped, unnamed
enum { floatPrec = 6, doublePrec = 10, double_doublePrec = 10 };


{cxx-enum-class-cxx-enum-scoped} *cxx-11* CPR 19.3 832.  

o like C, *cxx-enum-unscoped* named or unnamed defines `enumerators` which is
  open to all

o only *cxx-enum-class* is scoped, type and supports *cxx-type-checking*

o are under *cxx-access-control*

namespace cxx_enum
{
  enum color { red, yellow, green };          // unscoped
  enum class peppers { yellow, red, green };  // scoped
} // namespace

TEST(Enum, ScopedAndUnscoped)
{
  using namespace cxx_enum;

  {
    // explicitly use unscoped enumerators and implicitly use unscoped

    int value_1 = color::yellow;
    int value_2 = yellow;
    EXPECT_THAT(value_1, value_2);
  }

  {
    // {
    //   enum color { red, yellow, green };          // unscoped
    //   enum {red, yellow, green};                  // unscoped and unnamed
    // }
    // 
    // enum {red, yellow, green}; causes errors with enum color {}:
    // 
    // cxx.cpp:1497:9: error: redeclaration of ‘red’
    //    enum {red, yellow, green};                  // unscoped and unnamed
    //          ^~~
    // cxx.cpp:1495:16: note: previous declaration ‘cxx_enum::color red’
    //    enum color { red, yellow, green };          // unscoped
    //                 ^~~
    // 
    // {
    //   enum color { red, yellow, green };        // unscoped
    //   enum stoplight { red, yellow, green };    // unscoped
    // } // namespace
    //
    // so can use enumerators of unscoped enum and this allows *cxx-enum-hack* 

    int value_1 = yellow;
    int coll[green];
    EXPECT_THAT(8, sizeof(coll));

    color value_2 = yellow;

    EXPECT_THAT(value_1, value_2);
  }

  {
    // However, followings cause type error:
    // cxx-error: invalid conversion from ‘int’ to ‘color’ [-fpermissive]
    // note: it's interesting and unscoped is also type?
    //
    // color color_selected = 2;
    // 
    // OK
    // color color_selected = yellow;

    // cxx-error: type error, cannot convert ‘peppers’ to ‘int’ in initialization
    // int value_1 = peppers::red;
  }
}

namespace cxx_enum_in_class
{
  enum class named_and_scoped {red, yellow, green};

  class Foo
  {
    // private:
    //   enum {red, yellow, green};

    public:
      enum {red, yellow, green};

    private:
      std::string name_;

    // private:
    //   named_and_scoped color_;

    public:
      named_and_scoped color_;

    public:
      Foo() : name_("") {} 
  };
} // namespace

TEST(Enum, InClass)
{
  using namespace cxx_enum_in_class;

  // as expected for scoped enum
  {
    named_and_scoped value_1, value_2;
    value_1 = named_and_scoped::red;
    value_2 = named_and_scoped::yellow;

    // cxx-error followings are type error, no conversion:
    //
    // enum class procstatus {suspended, running};
    // 
    // // error since no there is no converison to bool
    // << setw(20) << left << (e.status ? "Running" : "Suspended")
    // 
    // // okay
    // << setw(20) << left << (e.status == procstatus::running ? "Running" : "Suspended")
    //
    // cout << "value_1 : " << flag1 << endl;
    // EXPECT_THAT(0, named_and_scoped::red);

    EXPECT_THAT(value_1, named_and_scoped::red);
    EXPECT_THAT(value_2, named_and_scoped::yellow);
  }


  // use enum in a class? As with unscoped enum, can use cxx-enum-hack but have
  // to use "Foo::" prefix as scoped enum. Also, is under cxx-access-control.
  // benefit? 

  {
    // when use `private`
    // cxx.cpp:1563:20: error: ‘cxx_enum::Foo::<unnamed enum> green’ is private within this context
    //   int flag3 = Foo::green;
    //                    ^~~~~
    // Since it's in class, this scoped but not named

    int value_1 = Foo::green;

    // cxx.cpp:1587:19: error: ‘green’ was not declared in this scope
    //      int value_2 = green;
    // int value_2 = green;

    EXPECT_THAT(value_1, 2);
    EXPECT_THAT(2, Foo::green);

    int coll[Foo::green];
    EXPECT_THAT(8, sizeof(coll));
  }

  {
    Foo foo;
    foo.color_ = named_and_scoped::red;
  }
}


{underlying-type}
Although each enum defines a unique type, it is represented by one of the
built-in integral type. If do not specify, then by default for scoped enum
have `int` as the underlying type.

There is no default for unscoped enums; all we know is that the underlying type
is large enough to hold the enumerator values.

Being able to specify the underlying type lets us control the type used across
different implementation.

// real use case?


{func-with-enum-arg}
The enum is type and cannot pass the same integral value to an enum parameter. 

enum Tokens { INLINE = 128, VIRTUAL = 129 }

void ff(Tokens);
void ff(int);

Tokens curr = INLINE;

ff(128);       // ff(int)
ff(INLINE);    // ff(Tokens)
ff(curr);      // ff(Tokens)

But can pass an object or enumerator of unscoped enumaration to a parameter of
integral type; the enum promotes to int or to a larger integral type depending
on the underlying type of the implementaion.

void newf(unsigned char);
void newf(int);

unsigned char uc = VIRTUAL;

newf(VIRTUAL);    // newf(int);
newf(uc);         // newf(unsigned char);


<ex>

enum class EnumFlags :char { SPORT=1, KIDS=2, MUSIC=4 };

constexpr EnumFlags operator| (EnumFlags lhs, EnumFlags rhs)
{
  // C++PL 220
  // explicit converison is nessary since enum class does not support implicit
  // conversions.
  return static_cast<EnumFlags>(static_cast<char>(lhs)|static_cast<char>(rhs));
}

constexpr EnumFlags operator& (EnumFlags lhs, EnumFlags rhs)
{
  return static_cast<EnumFlags>(static_cast<char>(lhs)&static_cast<char>(rhs));
}

class ScopedEnum 
{
  public:
    int checkFlags(EnumFlags flag)
    {
      int result{};

      switch(flag)
      {
        // used constexpr on oeprator| and & since someone might want to
        // use them in constant expression.
        case EnumFlags::SPORT:
          cout << "has sport flag" << endl;
          result = 0;
          break;

        case EnumFlags::KIDS:
          cout << "has kids flas" << endl;
          result = 1;
          break;

        case EnumFlags::MUSIC:
          cout << "has music flag" << endl;
          result = 2;
          break;

          // to avoid warning
          // warning: case value ‘5’ not in enumerated type ‘EnumFlags’ [-Wswitch]
          // case EnumFlags::SPORT|EnumFlags::MUSIC:
          //     cout << "has sport and music flag" << endl;
          //     result = 3;
          //     break;

        default:
          cout << "has unknown flag" << endl;
          result = 100;
      }

      return result;
    }
};

// [ RUN      ] Enum.ScopedEnum
// has sport flag
// has kids flas
// has music flag
// has unknown flag
// [       OK ] Enum.ScopedEnum (0 ms)

TEST(Enum, ScopeAndType)
{
  ScopedEnum scoped;

  EXPECT_EQ(0, scoped.checkFlags(EnumFlags::SPORT));
  EXPECT_EQ(1, scoped.checkFlags(EnumFlags::KIDS));
  EXPECT_EQ(2, scoped.checkFlags(EnumFlags::MUSIC));

  // to avoid warning
  // EXPECT_EQ(3, scoped.checkFlags(EnumFlags::SPORT|EnumFlags::MUSIC));

  EXPECT_EQ(100, scoped.checkFlags(EnumFlags::SPORT|EnumFlags::KIDS));
  // EXPECT_EQ(100, scoped.checkFlags(200));
}


<cxx-enum-forwrard-declaration> *cxx-incomplete-type* *cxx-forward-declaration*

Although online search shows that enum forward declarion is supported in
cxx-11 but seems not. 

No. This example is not 'forward declaration' since it uses enumerators in both
files.

keitee@keitee-mint:~/git/kb/code-cxx/cxx_enum$ gcc --version
gcc (Ubuntu 7.4.0-1ubuntu1~18.04) 7.4.0

cxx_enum.cpp:

#include <iostream>
#include "gtest/gtest.h"
#include "gmock/gmock.h"

// enum EnumValues
// {
//   Idle,
//   Searching,
//   Pairing,
//   Complete,
//   Failed
// };

// enum class EnumClassValues
// {
//   Idle,
//   Searching,
//   Pairing,
//   Complete,
//   Failed
// };

enum class EnumClassValues { Idle, Searching, Pairing, Complete, Failed };

void print_enum_values();
void print_enum_class_values();

int main(int argc, char **argv)
{
  // print_enum_values();

  print_enum_class_values();

  // Since Google Mock depends on Google Test, InitGoogleMock() is
  // also responsible for initializing Google Test.  Therefore there's
  // no need for calling testing::InitGoogleTest() separately.
  testing::InitGoogleMock(&argc, argv);
  return RUN_ALL_TESTS();
}


cxx_use_enum.cpp:

#include <iostream>

// causes error
//
// kb/code-cxx/cxx_enum/cxx_use_enum.cpp:9:6: error: 
//  use of enum ‘EnumValues’ without previous declaration
// enum EnumValues;
//
// Before C++11, C++ didn't support forward-declaration of enums at all!
// However, some compilers (like MS Visual Studio) provide language extensions
// for that.
// 
// enum EnumValues;

// Ok. print_enum_values() uses local one which can be different from others
// declared somewhere else.
//
// enum EnumValues
// {
//   Idle,
//   Searching,
//   Pairing,
//   Complete,
//   Failed
// };
//
// enum EnumValues
// {
//   Idle,
//   Pairing,
//   Complete,
//   Failed,
//   Searching
// };


// void print_enum_values()
// {
//   std::cout << "EnumValues " << EnumValues::Searching << std::endl;
// }

// cxx_use_enum.cpp:49:38: error: ‘Searching’ 
//  is not a member of ‘EnumClassValues’
//    EnumClassValues e{EnumClassValues::Searching};
// 
// enum class EnumClassValues;

// Ok.
enum class EnumClassValues { Idle, Searching, Pairing, Complete, Failed };

void print_enum_class_values()
{
  EnumClassValues e{EnumClassValues::Searching};

  std::cout << "EnumValues " 
    << (e == EnumClassValues::Searching ? "searching" : "not searching") 
    << std::endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-nested-class

A class defined within another class, called nested class or nested type.

Most used to define implementation class. This defines `type-member` of
enclosing class. The nested class are:

o `independent classes` in terms of object to their enclosing class.
o `type members` of enclosing class and are under access control.
o types which are scope.

<ex>
A companion class, QueryResult, which is `tightly coupled` to TextQuery class.
It would make little sense to use QueryResult for any other purpose than to
represent the result of a query operation. `To reflect this coupling,` make
QueryResult a `type member` of TextQuery.

class TextQuery {
  public:

    // to be defined later but must be seen before use since it is a type
    // member.
    class QueryResult; 
    ...
};

To define a nested class outside of enclosing class:

class TextQuery::QueryResult {

  // no need to qualify the name of QueryResult
  friend std::ostream& print(std::ostream&, const QueryResult&);

  public:

    // no need to define line_no since a nested class can use a member of its
    // enclosing class without needing to qualify.
    QueryResult(std::string,
      std::shared_ptr<std::set<line_no>>,
      std::shared_ptr<std::vector<std::string>>);
  ...
};

TextQuery::QueryResult::QueryResult(string s,
      shared_ptr<set<line_no>> p,
      shared_ptr<vector<std::string>> f):
  sought(s), lines(p), file(f) {}


To define a nested-class static member:

int TextQuery::QueryResult::static_mem = 1024;


Since a nested class is a type member of its enclosing class, can use the name
of nested class the same way it uses any other member.

TextQuery::QueryResult
TextQuery::query(const string &sought) const
{
  static shared_ptr<set<line_no>> nodata(new set<line_no>);

  auto loc = wm.find(sought);
  if (loc == wm.end())
    return QueryResult(sought, nodata, file);
  else
    return QueryResult(sought, loc->second, file);
}

// Since there is no connection between the object of an enclosing class and
// objects of its nested class, have to use members of enclosing class to
// construct the QueryResult object to return.


<ex>

  class Snapper
  {
    struct SnapTime
    {
      chrono::system_clock::time_point tp;
      std::string description;
    }   // missed ';' which causes errors below

  };

cxx.cpp:1817:5: error: new types may not be defined in a return type
     struct SnapTime
     ^
cxx.cpp:1817:5: note: (perhaps a semicolon is missing after the definition of ‘cxx_time_lap::Snapper::SnapTime’)
cxx.cpp:1823:22: error: return type specification for constructor invalid
     explicit Snapper()
                      ^


={============================================================================
*kt_dev_cxx_0000* cxx-regex

7.3.2.1. Raw Character Strings

*cxx-string-raw*

If need a lot of backslashes and quotes in the string literals, it becomes
difficult to use backslash escape mechnism:

string s = "\\w+\\\\\\w+";     // I hope I got that right

To turn off backslash esacpe mechnism:

string s = R"(\w+\\\w+)";

With examples like that, even experts easily become confused, and raw string
  literals provide a significant service.

// Are the five backslashes correct or not?
"('(?:[^\\\\']|\\\\.)*'|\"(?:[^\\\\\"]|\\\\.)*\")|"     

TEST(StringLiteral, raw_string)
{
  {
    std::ostringstream os1{};
    std::ostringstream os2{};

    const char message[] = "this is \
                           a multi-line message \
                           and works";
    os1 << message;

    os2 << "this is                            a multi-line message            "
           "                and works";

    const std::string expected{"this is                            a multi-line message                            and works"};

    EXPECT_THAT(os1.str(), expected);
    EXPECT_THAT(os2.str(), expected);
  }

  // they are not the same since cxx-string-raw includes `space` as well.
  // [ RUN      ] StringLiteral.raw_string
  // 1
  //
  //     22
  //
  //     333
  // 1
  // 22
  // 333
  // [       OK ] StringLiteral.raw_string (0 ms)
  {
    std::string coll1{R"(1

    22

    333)"};

    std::string coll2{"1\n22\n333"};

    // std::cout << coll1 << std::endl;
    // std::cout << coll2 << std::endl;
  }

  // string-raw works like extended-regex
  //
  // regex
  //
  // While `basic regular expressions require these to be escaped` if you want
  // them `to behave as special characters`, when using extended regular
  // expressions you must escape them if you want them to match a literal
  // character. 

  {
    std::string coll1("~Query(\"hair\")");
    std::string coll2(R"(~Query("hair"))");

    EXPECT_THAT(coll1, coll2);
  }

  // multi-lines
  {
    std::ostringstream os1;
    std::ostringstream os2;

    // have to `escape` like basic regex and `newline` but note that it
    // includes `spaces`

    const char out[] = "{ \"address\": {\n\
                        \"road\":\"Drury Ln\",\n\
                        \"city\":\"Fountain\",\n\
                        \"state\":\"CO\",\n\
                        \"country\":\"US\" }}";

    os1 << out;

    // std::cout << out << std::endl;

    const char out2[] = "{ \"address\": {\n\
         \"road\":\"Drury Ln\",\n\
         \"city\":\"Fountain\",\n\
         \"state\":\"CO\",\n\
         \"country\":\"US\" }}";

    os2 << out2;

    // std::cout << out2 << std::endl;

    // raw-string is better
    const std::string s = R"({ "address": {
         "road":"Drury Ln",
         "city":"Fountain",
         "state":"CO",
         "country":"US" }})";

    // std::cout << s << std::endl;

    // different due to spaces
    EXPECT_THAT(os1.str(), Ne(os2.str()));

    // when have same spces
    EXPECT_THAT(os2.str(), s);
  }

  {
    // compile error:
    // std::string json_content1 = R"(
    // {
    //     "Title":"(C/C++)",
    //     "Subtitle":"(Powered by C/C++)",
    //     "Description":"(The world of C/++ developers)",
    //     "MainPage":"cpp",
    //     "Items":null,
    //     "Id":"6"
    // })";

    // okay since do not have "(", ")" in it
    std::string json_content1 = R"(
    {
        "Title":"C/C++",
        "Subtitle":"Powered by C/C++",
        "Description":"The world of C/++ developers",
        "MainPage":"cpp",
        "Items":null,
        "Id":"6"
    })";

    // https://www.drdobbs.com/cpp/new-c-language-features-in-visual-studio/240165945
    // prefix(optional) R "delimiter( raw_characters )delimiter"	(6)	(since C++11)
    //
    // The use of ZZZ as a delimiter in the following lines solves the problem
    // and allows you to embed double quotation marks and *parenthesis* in the
    // raw literal string:
    //
    // https://www.youtube.com/watch?v=DiZ-az_nJMM

    std::string json_content2 = R"ZZZ(
    {
        "Title":"(C/C++)",
        "Subtitle":"(Powered by C/C++)",
        "Description":"(The world of C/++ developers)",
        "MainPage":"cpp",
        "Items":null,
        "Id":"6"
    })ZZZ";

    std::string json_content3 = R"JSON(
    {
        "Title":"(C/C++)",
        "Subtitle":"(Powered by C/C++)",
        "Description":"(The world of C/++ developers)",
        "MainPage":"cpp",
        "Items":null,
        "Id":"6"
    })JSON";

    // well, don't need to use `delimeter` for json since do not have
    // parenthesis.

    std::string json_content4 = R"(
    {
      "uris": [
        {
          "path": "/as/drm/status",
          "method": "ws",
          "thread": "AS_WS_DRM",
          "content": {
            "status": "UNAVAILABLE"
          }
        }
      ]
    })";
  }
}


14.1 The Regex Match and Search Interface

TEST(Regex, UseMatch)
{
  // find XML/HTML tagged value (using fefault syntax)
  regex reg1("<.*>.*</.*>");
  bool found = regex_match("<tag>value</tag>", reg1);
  EXPECT_EQ(found, true);

  // find XML/HTML tagged value (tags before and after the value must match)
  // R"(<(.*)>.*</\1>)" // equivalent to: "<(.*)>.*</\\1>"
  regex reg2("<(.*)>.*</\\1>");
  found = regex_match("<tag>value</tag>", reg2);
  EXPECT_EQ(found, true);

  // find XML/HTML tagged value (using grep syntax)
  regex reg3("<\\(.*\\)>.*</\\1>", regex_constants::grep);
  found = regex_match("<tag>value</tag>", reg2);
  EXPECT_EQ(found, true);

  // use C string as reg expression (needs explicit cast to regex)
  found = regex_match("<tag>value</tag>", regex("<.*>.*</.*>"));
  EXPECT_EQ(found, true);

  // regex_match() versus regex_search():
  //
  // regex_match() checks whether the *whole* character sequence matches a
  // regular expression.
  //
  // regex_search() checks whether the character sequence *partially* matches a
  // regular expression.

  found = regex_match ("XML tag: <tag>value</tag>",
      regex("<(.*)>.*</\\1>")); // note: fails to match
  EXPECT_EQ(found, false);

  found = regex_search ("XML tag: <tag>value</tag>",
      regex("<(.*)>.*</\\1>")); // matches
  EXPECT_EQ(found, true);

  found = regex_match ("XML tag: <tag>value</tag>",
      regex(".*<(.*)>.*</\\1>.*")); // matches
  EXPECT_EQ(found, true);

  found = regex_search ("XML tag: <tag>value</tag>",
      regex(".*<(.*)>.*</\\1>.*")); // matches
  EXPECT_EQ(found, true);
}

TEST(Regex, MatchFound)
{
  string data{"XML tag: <tag-name>the value</tag-name>."};

  {
    regex rx(R"(<([\w-]+)>(.*)<(\/[\w-]+)>)");

    // for returned details of the match
    std::smatch m;

    auto found =  regex_search(data, m, rx);
    EXPECT_TRUE(found);
  }

  {
    // ok
    regex rx("<(.*)>(.*)</(\\1)>");

    // for returned details of the match
    std::smatch m;

    auto found =  regex_search(data, m, rx);
    EXPECT_TRUE(found);
  }
}


<cxx-regex-match-result>

we can demonstrate the use of match_results objects, which can be passed to
regex_match() and regex_search() to get details of matches. Class
std::match_results<> is a template that has to get instantiated by the
iterator type of the characters processed. The C++ standard library provides
some predefined instantiations:

  o smatch: for details of matches in strings
  o cmatch: for details of matches in C-strings (const char*)
  o wsmatch: for details of matches in wstrings
  o wcmatch: for details of matches in wide C-strings (const wchar_t*)

// CXXSLR-14.2 Dealing with Subexpressions

TEST(Regex, MatchResult)
{
  string data{"XML tag: <tag-name>the value</tag-name>."};
  // regex rx(R"(<([\w-]+)>(.*)<(\/[\w-]+)>")");
  /// regex rx("<([\w-]+)>(.*)<(\/[\w-]+)>");
  //            <([\w-]+)>(.*)<\/([\w-]+)>
  regex rx("<(.*)>(.*)</(\\1)>");

  // for returned details of the match
  std::smatch m;

  auto found =  regex_search(data, m, rx);
  EXPECT_TRUE(found);

  if (found)
  {
    // Regex: <(.*)>(.*)</(\1)>
    // XML tag: <tag-name>the value</tag-name>.
    //           | m[1] | |  m[2] |  | m[3] | |
    // | prefix|             m[0]            | suffix
    //
    // In general, the match_results object contains:
    //
    //  o A sub_match object m[0] for all the matched characters
    //
    //  o A prefix(), a sub_match object that represents all characters before the
    //  first matched character
    //
    //  o A suffix(), a sub_match object that represents all characters after the
    //  last matched character

    EXPECT_THAT(m.empty(), false);

    // size() yields the number of sub_match objects (including m[0]).

    EXPECT_THAT(m.size(), 4);

    // member function str() to yield the matched string as a whole (calling
    // str() or str(0)) or the nth matched substring (calling str(n)), which is
    // empty if no matched substring exists (thus, passing an n greater than
    // size() is valid)
    // that is m[0]

    EXPECT_THAT(m.str(), "<tag-name>the value</tag-name>");

    // member function length() to yield the length of the matched string as a
    // whole (calling length() or length(0)) or the length of the nth matched
    // substring (calling length(n)), which is 0 if no matched substring exists
    // (thus, passing an n greater than size() is valid)

    EXPECT_THAT(m.length(), 30);

    // member function position() to yield the position of the matched string as
    // a whole (calling position() or position(0)) or the position of the nth
    // matched substring (calling length(n))

    EXPECT_THAT(m.position(),9);
    EXPECT_THAT(m.prefix().str(), "XML tag: ");
    EXPECT_THAT(m.suffix().str(), ".");

    EXPECT_THAT(m[1].str(), "tag-name");
    EXPECT_THAT(m.str(1), "tag-name");
    EXPECT_THAT(m.position(1), 10);

    EXPECT_THAT(m[2].str(), "the value");
    EXPECT_THAT(m.str(2), "the value");
    EXPECT_THAT(m.position(2), 19);

    EXPECT_THAT(m[3].str(), "tag-name");
    EXPECT_THAT(m.str(3), "tag-name");
    EXPECT_THAT(m.position(3), 30);

    // use iterator

    ostringstream os;

    for (auto pos = m.begin(); pos != m.end(); ++pos)
    {
      os << *pos << ", " << pos->length() << endl;
    }

    // works
    // char expected[] = "<tag-name>the value</tag-name>, 30\n"
    //   "tag-name, 8\n"
    //   "the value, 9\n"
    //   "tag-name, 8\n";
    // EXPECT_THAT(os.str(), expected);

    // works
    // string expected("<tag-name>the value</tag-name>, 30\ntag-name, 8\nthe value, 9\ntag-name, 8\n");
    // EXPECT_THAT(os.str(), expected);

    EXPECT_THAT(os.str(), 
        "<tag-name>the value</tag-name>, 30\ntag-name, 8\nthe value, 9\ntag-name, 8\n");
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-template-decode-error

this is an *cxx-const-to-non-const-error*

// single long error and if do warpping:

ccon.cpp:317:16: error: could not convert ‘std::find_if(_IIter, _IIter,
    _Predicate) [with _IIter =
__gnu_debug::_Safe_iterator<std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
std::allocator<std::pair<std::basic_string<char>, int> > > >; _Predicate =
  threadsafe_lookup_table<Key, Value, Hash>::bucket_type::find_entry_for(const
      Key&) const [with Key = std::basic_string<char>; Value = int; Hash =
  std::hash<std::basic_string<char> >; threadsafe_lookup_table<Key, Value,
Hash>::bucket_type::bucket_iterator =
  __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
std::allocator<std::pair<std::basic_string<char>, int> > > >]::<lambda(const
    bucket_value&)>](std::__debug::list<_Tp, _Allocator>::end() const [with
      _Tp = std::pair<std::basic_string<char>, int>; _Allocator =
      std::allocator<std::pair<std::basic_string<char>, int> >;
      std::__debug::list<_Tp, _Allocator>::const_iterator =
      __gnu_debug::_Safe_iterator<std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
      int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
      std::allocator<std::pair<std::basic_string<char>, int> > > >; typename
      std::__cxx1998::list<_Tp, _Alloc>::const_iterator =
      std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
      int> >](), <lambda closure object>threadsafe_lookup_table<Key, Value,
      Hash>::bucket_type::find_entry_for(const Key&) const [with Key =
      std::basic_string<char>; Value = int; Hash =
      std::hash<std::basic_string<char> >; threadsafe_lookup_table<Key, Value,
      Hash>::bucket_type::bucket_iterator =
      __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
      int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
      std::allocator<std::pair<std::basic_string<char>, int> > >
      >]::<lambda(const bucket_value&)>{(* & key)})’ from
    ‘__gnu_debug::_Safe_iterator<std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
std::allocator<std::pair<std::basic_string<char>, int> > > >’ to
  ‘threadsafe_lookup_table<std::basic_string<char>,
int>::bucket_type::bucket_iterator {aka
  __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
  int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
  std::allocator<std::pair<std::basic_string<char>, int> > > >}’ }); ^


// decode it to understand

ccon.cpp:314:16: error: could not convert 

// see ';' as sepeartor

‘std::find_if(_IIter, _IIter, _Predicate) 
  [
  with 
    _IIter =
    __gnu_debug::_Safe_iterator<std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
    int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
    std::allocator<std::pair<std::basic_string<char>, int> > > >; 

    _Predicate =
    threadsafe_lookup_table<Key, Value, Hash>::bucket_type::find_entry_for(const
        Key&) const [with Key = std::basic_string<char>; 

    Value = int; 

    Hash = std::hash<std::basic_string<char> >; 
    
    threadsafe_lookup_table<Key, Value, Hash>::bucket_type::bucket_iterator =
    __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
    int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
    std::allocator<std::pair<std::basic_string<char>, int> > > >]::<lambda(const
        bucket_value&)>
  ]
  (
   std::__debug::list<_Tp, _Allocator>::end() const 
   [with
        _Tp = std::pair<std::basic_string<char>, int>; _Allocator =
        std::allocator<std::pair<std::basic_string<char>, int> >;

        std::__debug::list<_Tp, _Allocator>::const_iterator =
        __gnu_debug::_Safe_iterator<std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
        int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
        std::allocator<std::pair<std::basic_string<char>, int> > > >; 

        typename std::__cxx1998::list<_Tp, _Alloc>::const_iterator =
        std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>, int>> 

   ](), <lambda closure object>threadsafe_lookup_table<Key, Value, Hash>::bucket_type::find_entry_for(const Key&) const 
   [with Key =
        std::basic_string<char>; Value = int; Hash =
        std::hash<std::basic_string<char> >; 
        threadsafe_lookup_table<Key, Value, Hash>::bucket_type::bucket_iterator =
        __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
        int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
        std::allocator<std::pair<std::basic_string<char>, int> > >
        >
   ]::<lambda(const bucket_value&)>{(* & key)}
  )
’ 
  
  from
      ‘__gnu_debug::_Safe_iterator<std::__cxx1998::_List_const_iterator<std::pair<std::basic_string<char>,
      int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
      std::allocator<std::pair<std::basic_string<char>, int> > > >’ 

  to

      ‘threadsafe_lookup_table<std::basic_string<char>, int>::bucket_type::bucket_iterator 

      {aka __gnu_debug::_Safe_iterator<std::__cxx1998::_List_iterator<std::pair<std::basic_string<char>,
        int> >, std::__debug::list<std::pair<std::basic_string<char>, int>,
        std::allocator<std::pair<std::basic_string<char>, int> > > >}’ }); ^


={============================================================================
*kt_dev_cxx_0000* cxx-template-function

The types become known during complilation in generic programming whereas OOP
deals with types that are not known until run time.

When we write a generic program, write the code in a way that is independent
of any particular type and supply the type(s) or value(s) on which that
instance of the program will operate.

We can use that generic definition to define many different types of
`vectors`, each of which differs from the others as to the type of elements
the `vector` contains.


{cxx-template-syntax}
The requirement to put a space between two closing template expressions has
gone:

vector<list<int> >;  // OK in each C++ version
vector<list<int>>;   // OK since *cxx-11*

// Error case as should be 'typename U'

template <typename T, U> inline T calc( const T&, const U& );

// Can use typename or class but recommands typename

template <typename T, class U> inline T calc( const T&, const U& );


{cxx-template-function-cxx-function-template}
Rather than defining a new function for each type, define a function template
to generate function.

*cxx-template-parameter-list*
The template-parameter-list acts much like a function parameter list. At run
time, arguments are supplied that initialize parameters.

Analogously, template parameters represents types or values used in the
definition of a class or function. When use a template, specify template
arguments to bind to the template parameters.

*cxx-templete-decuction*
Which actual type T represents `is determined at compile time` based on how
template function is used. deduce the argument type to determine what type
to bind to the parameter T.

*template-instantiation*
Use the deduced template parameters `to instantiate a specific version` of the
function. Creates a new instance of the template.

// `template-parameter-list` is "<typename T>"
namespace cxx_template
{
  template <typename T>
  int compare(const T &a, const T &b)
  {
    if (a < b)
      return -1;
    if (b < a)
      return 1;
    return 0;
  }
} // namespace cxx_template

TEST(CxxTemplate, check_function)
{
  using namespace cxx_template;

  // `template-parameter-type` T is "int"
  // int compare(const int& v1, const int& v2)

  EXPECT_THAT(compare(1, 2), -1);
  EXPECT_THAT(compare(2, 1), 1);
  EXPECT_THAT(compare(2, 2), 0);

  // T is "vector<int>" and  instantiates to 
  // "int compare(const vector<int>&, const vector<int>&)"

  std::vector<int> coll1{1, 2, 3}, coll2{1, 2, 4};
  EXPECT_THAT(compare(coll1, coll2), -1);
  EXPECT_THAT(compare(coll2, coll1), 1);
}


<principle-to-write-generic-code>
Here two important principles for writing generic codes from this example:

o The function parameters in the templeate are `reference to const`

This makes the function runs faster and also it can be uses on types that
cannot be copied such as IO types and unique_ptr.

o Used only < comparison. More genarally, reduce the requirement on element or
  argument type.

Instead of:

template <typename T>
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v1 > v2 ) return 1;
  return 0;
}


{cxx-template-instantiation} *cxx-template-code-generation* cxx-header
Ordinarily, when call a function, the compiler needs to see only a
declaration. Similarly, when use objects of class type, the class definition
must be available but the definition of the member functions need not be
present. As a result, put class definition and function declaration in header
file and definition of ordinary and class member function is source files. 

`Templates are different` since the compiler generates code `only when use` a
template; instantiate a specific instance of the template. So to generate an
instantiation, needs to have the code that defines a function and class
template member function. As a result, headers includes definitions as well as
declarations.

*cxx-remember*
cxx-template should be in header which is must and otherwise, emit link errors.


The fact that the compiler generates code only when use a template affects
when generate compilation errors.

Sales_data data1, data2;
cout << compare(data1, data2) << endl;

Sales_data don't have operator<(). Errors such as this cannot be detected
until the compiler instantiates the definition of compare on type Sales_data.
No errors when use with types which supports operator<()

The instantiation is a process that create a concrete independent function
or class from a template when compiling. Code generation and these compiler
generated function or class are an `instantiation of the template` Must be
defined in the same namespace that contains the original template. 

see *cxx-template-control-instantiation* p675 for C++ feature to control this.


<overloading-and-templates>
function templetes can be overloaded by other templates or by ordinary
nontemplate functions. The things to remember is:

As shown in function-matching, non-template and then the more speciailized
function are preferred.


={============================================================================
*kt_dev_cxx_0000* cxx-template-class cxx-template-friend

<cxx-template-argument>
Unlike function template, compiler `cannot deduce the type of parameter` so
user must provide extra `additional information` to instantiate it. Which is
the list of `template arguments` 

It is up to the user to ensure that the template argument type support any
operations that template uses, and that those operations behave correctly in
the context in which the template uses them. Include headers for any type to
instantiate that template.

see *cpp-ex-strblob-template*

*cxx-template-argument* binds to *cxx-tempalte-parameter* Use these argument to
instantiate a `specific and independent class from the template.` 

note:
May think that specialzation is a special case of instantiation.

Blob<int> ia;
Blob<int> ia2 = { 0, 1, 2, 3, 4 };
Blob<string> names;

From class template, compiler will generate a class:

template <> 
class Blob<int> {
  typedef typename std::vector<int>::size_type size_type;
  Blob();
  Blob(std::initializer_list<int> il);
  ...
  private:
    std::shared_ptr<std::vector<int>> data;
    ...
};


A class template is used `to instantiate a type` and an instantiated type
always includes template arguments.

std::shared_ptr<std::vector<string>>  // both are different type


{cxx-template-friend}
When a class contains a friend declaration, the class and the friend can
independently be template or not.

<one-to-one>
The one-to-one friendship is the most common form of friendship from a class
template to `the specific instantiation` of class or function template.

// forward declaration needed for friend declaration in Blob

template <typename T> class BlobPtr;
template <typename T> class Blob;
template <typename T> bool operator==(const Blob<T> &, const Blob<T> &);

template <typename T> 
class Blob {

    // `each intantiation of Blob` grants limited access to the instantiation of
    // BlobPtr and the equality operator with the same type, T. 

    friend class BlobPtr<T>;

    // see notation
    friend bool operator==<T>(const Blob<T> &, const Blob<T> &);
};


<one-to-many>
Can also make every(all) instantiation(type) of another template its friend or
may limit friendship to a specific instantiation.

templcate <typename T> 
class C2 {

  // single instantiation
  friend claass Pal<T>;

  // all instances of Pal2 are friends. no forward declaration required.
  // do not use T

  template <typename X> friend class Pal2;
};


// DO NOT GET IF IT IS ABOUT FRIEND???

#if 0

<ex> *cxx-template-function-template-argument*

// Define function which has template argument

namespace cxx_template_friend
{
  // basics/stack1.hpp

  template <typename T>
    class Stack
    {
      public:
        void push(T const& elem)
        {
          elems_.push_back(elem);
        }

        void pop()
        {
          if (elems_.empty())
            throw std::runtime_error("coll is empty");

          elems_.pop_back();
        }

        T const& top() const
        {
          if (elems_.empty())
            throw std::runtime_error("coll is empty");

          return elems_.back();
        }

        bool empty() const
        {
          return elems_.empty();
        }

      private:
        std::vector<T> elems_;
    };

  // To show how to define operator<< for template *cxx-overload-operator*
  //
  // C++ Templates The Complete Guide Second Edition
  // 2.4 Friends
  //
  // However, when trying to declare the friend function and define it
  // afterwards, things become more complicated. In fact, we have two options:
  // 1. We can implicitly declare a new function template, which must use a
  // different template parameter, such as U:

  template<typename T>
  ostream& operator<<(ostream& os, Stack<T> const& s)
  {
    cout << "stack's top : " << s.top() << endl;
    return os;
  }

} // namespace

TEST(Template, Friend)
{
  using namespace cxx_template_friend;

  Stack<int> si;

  si.push(1); si.push(2); si.push(3);
  EXPECT_THAT(si.top(), 3);

  cout << si;
}


// cxx-time-duration-cast
//
// A typical example is code that segments a duration into different units. For
// example, the following code segments a duration of milliseconds into the
// corresponding hours, minutes, seconds, and milliseconds
//
// raw: [2 of 3600/1]::[0 of 60/1]::[55 of 1/1]::[42 of 1/1000]
//      02::00::55::42

namespace cxx_time_duration_case
{
  template <typename Unit, typename Ratio>
    ostream &operator<<(ostream &os, const chrono::duration<Unit,Ratio> &d)
    {
      os << "[" << d.count() << " of " << Ratio::num << "/" << Ratio::den << "]";
      return os;
    }
} // namespace


TEST(Time, DurationCast)
{
  using namespace cxx_time_duration_case;

  chrono::milliseconds ms(7255042);

  chrono::hours   hh = 
    chrono::duration_cast<chrono::hours>(ms);

  // take remians which means take hours out
  chrono::minutes mm = 
    chrono::duration_cast<chrono::minutes>(ms % chrono::hours(1));

  chrono::seconds ss = 
    chrono::duration_cast<chrono::seconds>(ms % chrono::minutes(1));

  chrono::milliseconds msec = 
    chrono::duration_cast<chrono::milliseconds>(ms % chrono::seconds(1));

  ostringstream os;

  os << hh << "::" << mm << "::" << ss << "::" << msec;

  EXPECT_THAT(os.str(), "[2 of 3600/1]::[0 of 60/1]::[55 of 1/1]::[42 of 1/1000]");

  os.str("");

  // see that same count() function used as operator<<() above
  
  os << hh.count() << "::" << mm.count() << "::" 
    << ss.count() << "::" << msec.count();

  EXPECT_THAT(os.str(), "2::0::55::42");
}


namespace cxx_lock
{
  template <typename T>
    class locked_queue
    {
      public:
        // push an item into the end of the queue
        void push(T const& item)
        {
          std::lock_guard<std::mutex> lock(mutex_);
          queue_.push(item);
        }

        size_t size() const noexcept
        {
          return queue_.size();
        }

      private:
        std::queue<T> queue_;
        std::mutex mutex_;
    };

  template<typename T>
    void do_something(int item, locked_queue<T>& q)
    {
      default_random_engine engine(item);  // cxx-random-seed
      uniform_int_distribution<int> dist(10, 1000);

      for (int i = 0; i < 10; ++i)
      {
        this_thread::sleep_for(chrono::milliseconds(dist(engine)));
        q.push(item + i);
      }
    }

} // namespace

TEST(CConThread, LockGuard)
{
  using namespace cxx_lock;

  locked_queue<int> lq;

  std::thread t1([&]{ do_something(10, lq); });
  std::thread t2([&]{ do_something(20, lq); });
  t1.join();
  t2.join();

  EXPECT_THAT(lq.size(), 20);
}

#endif


{template-static}
As with a static in ordinary class, there must be exactly one definition of
each static member. Each instantiation has its own instance of static members.

template <typename T> class Foo {
  public:
    static std::size_t count() { return ctr; }
    ...

  private:
    static std::size_t ctr;
};

template <typename T>
size_t Foo<T>::ctr = 0;

Foo<int> fi;

auto ct = Foo<int>::count();  // via scope operator and instantiated only used
ct = fi.count();              // via an object


={============================================================================
*kt_dev_cxx_0000* cxx-template-type-member cxx-type-member

*cxx-static-access*

Uses scope operator(::) to access both *cxx-static* member and cxx-type-members. 

For example, string::size_type. In non-template code, the compiler has access
to the class definition and knows whether a name accessed through the scope
operator is a type or static member.

`However, in template code,` when see code such as T::mem, won't know whether
name is a type or a static member until instantiation is done. 

The problem is: 

Is it defining a variable named p or multiplying a static data member named
size_type by p?

T::size_type *p;

By default, the language assumes that a name accessed through the scope
operator `is not a type.` So if want to use type member of template must
`explicitly tell using the keyword typename`

template<typename T> 
typename T::value_type top( const T& c )
{
  if( !c.empty() )
    return c.book();
  else
    return `typename` T::value_type();
}

"typename T::value_type" is a type an do *cxx-value-init*


EC++42. This is called `dependant type names` since it depends on the template
parameter. This causes `parsing difficulty` and this is why must tell it to
compiler and use typename but not class.

template<typename T>
void print2nd(const T& container)
{
  typename T::const_iterator iter(container.begin()); // must use typename
  ...
}

The exception to this is when typename is used in base class type. Suppose
that if it have to use typename in this case, then how difficult it is to
parse. Suppose Nested is a type(class) in this example.

template<typename T>
class Derived: public Base<T>::Nested {               // not use typename here
  public:
    explicit Derived(int x) : Base<T>::Nested(x) {    // not use typename here
      typename Base<T>::Nested temp;                  // use as usual
      ...
    }
    ...
};


Use *cxx-typedef* alias for a dependant name. This example is to create a
local variable which is the type pointed by a iterator.

template<typename iterT>
void workWithIterator(iterT iter)
{
  typename std::iterator_traits<iterT>::value_type temp(*iter);
  ...
}

template<typename iterT>
void workWithIterator(iterT iter)
{
  typedef typename std::iterator_traits<iterT>::value_type value_type;
  value_type temp(*iter);
  ...
}

<ex>
In the StrBlob example, it uses: 

class StrBlob {
  public:
    typedef std::vector<std::string>::size_type size_type;
    ...
};

But,

class StrBlob {
  public:
    `typedef typename` std::vector<std::string>::size_type size_type;
    ...
};

Tried the both and the both compiles and works well.

namespace cxx_code
{
  template<typename _Tp, typename _Alloc = std::allocator<_Tp>> 
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      typedef size_t					 size_type;
    };
} // namespace

<ex>
{
  // error 
  typedef std::list<bucket_value>::iterator bucket_iterator;

  // okay
  typedef typename std::list<bucket_value>::iterator bucket_iterator;

: error: need ‘typename’ before ‘std::__debug::list<std::pair<_T1, _T2> >::iterator’ 
  because ‘std::__debug::list<std::pair<_T1, _T2> >’ is a dependent scope
         typedef std::list<bucket_value>::iterator bucket_iterator;
                 ^
}

<ex>
template<typename Policy_T>
struct ConstrainedValue
{
  public:

    // error: expected nested-name-specifier before ‘Policy_T’
    //      typedef typename Policy_T policy_type;
    //                       ^
    // typedef typename Policy_T policy_type;

    typedef Policy_T policy_type;

    // ...
};


{template-type-members-initialize}

No problem to define T member when use template. How set initial value to them?

1. Taken from the example of *cxx-template-default-argument*

template <typename T = int> 
class Numbers {
  public:
    Numbers(T v = 0): val(v) {}
  private:
    T val;
};

However, it assumes that T would be integral type. How about user or class type?


2. Uses copy assign with temporary, T().

template <typename T>
class MovingAverage
{
    public:
        MovingAverage(size_t initial_size=10)
        {
            resize(initial_size);
        }

        void reset()
        {
            accumulated_value = T();
            head = 0;
            tail = 0;
        }

        void resize(size_t new_size)
        {
            reset();
            values.resize(new_size, T());
        }

    private:
        T accumulated_value;
};


3. Other way?


={============================================================================
*kt_dev_cxx_0000* cxx-template-default-argument

*cxx-11* Under new standard, supports default argument for both function and
class template while the earlier version support only for class.

<ex> function template

The rewritten example of the previous example and see that F represent the
type of a callable objects. `default type`

namespace cxx_template_default
{
  // `This shows how function-object is useful` *cxx-functor*
  // default template argument, the type of callable
  // default function argument, F()

  template <typename T, typename F = less<T>>
  int compare(const T &a, const T &b, F f = F())
  {
    if (f(a, b))
      return -1;
    if (f(b, a))
      return 1;
    return 0;
  }

  template <typename T = int> struct Numbers
  {
    Numbers(T value = 0)
        : value_(value)
    {}

    T value_;
  };

} // namespace cxx_template_default

TEST(CxxTemplate, DefaultTypeArgument)
{
  using namespace cxx_template_default;

  {
    // 1 < 2
    EXPECT_THAT(compare(1, 2), -1);
    // 2 > 1
    EXPECT_THAT(compare(2, 1), 1);
    // 2 == 2
    EXPECT_THAT(compare(2, 2), 0);
  }

  {
    // 1 < 2
    EXPECT_THAT(compare(1, 2, greater<int>()), 1);
    // 2 > 1
    EXPECT_THAT(compare(2, 1, greater<int>()), -1);
    // 2 == 2
    EXPECT_THAT(compare(2, 2, greater<int>()), 0);
  }

  {
    vector<int> coll1{1, 2, 3}, coll2{1, 2, 4};
    EXPECT_THAT(compare(coll1, coll2), -1);
    EXPECT_THAT(compare(coll2, coll1), 1);
  }

  {
    Numbers<> o1(10);
    Numbers<int> o2(10);
    EXPECT_THAT(o1.value_, o2.value_);
  }

  // compile error
  // {
  //   Numbers<> o1(10);
  //   Numbers<std::string> o2("value");
  //   EXPECT_THAT(o1.value_, o2.value_);
  // }
}


Can use it with user type, Sales_data, if provides own comparision function.

Sales_data item1(cin), item2(cin);

bool compareIsbn( const Sales_data &lhs, const Sales_data &rhs )
{
    return lhs.isbn() < rhs.isbn();
}

bool j = compare( item1, item2, compareIsbn );


<ex> class template

template <typename T = int>
class Numbers
{
  ...
}

Numbers<long double> lots_of_precision;
Numbers<> average_precision;  // empty <> says we want the default type, int;


={============================================================================
*kt_dev_cxx_0000* cxx-template-member

Either an ordinary class or class template may have a member function that is
itself a template; `member template function.` See this word ordering since it
summarise that it is member function and function template.

"member template `may not be virtual` "

<with-nontemplate-class>
The member template of ordinary class from CPR 672. This example is similar to
the default deleter in unique_ptr *cxx-sp-delete* since overloads operator().
Like default deleter, support any type and use *cxx-template-member*


namespace cxx_template
{
  class DebugDelete
  {
  public:
    DebugDelete(std::ostream &os = std::cerr)
        : os_(os)
    {}

    // *cxx-functor*
    // as with any function template, T is deduced by the compiler

    template <typename T>
    void operator()(T *p) const
    {
      os_ << "deleting " << typeid(p).name() << ", p = " << p << endl;
      delete p;
    }

  private:
    // *cxx-reference-member
    std::ostream &os_;
  };
} // namespace cxx_template

TEST(CxxTemplate, memeber_template)
{
  using namespace cxx_template;

  // deleting Pd, p = 0x9be7008
  // deleting Pi, p = 0x9be7018
  {
    double *pd = new double();
    int *pi    = new int();
    DebugDelete d;
    d(pd);
    d(pi);
  }

  // see TEST(CxxSmartPointer, check_deleter);
  //
  // deleting PSs, p = 0x1d5e830
  // deleting Pi, p = 0x1d5e850
  {
    std::unique_ptr<int, DebugDelete> pi(new int, DebugDelete());
    std::unique_ptr<std::string, DebugDelete> ps(new std::string,
                                                 DebugDelete());
  }
}


<with-template-class>
Both the class and member template have `independent template parameters` 
To support iterators into varying kinds of sequences.

template <typename T> 
class Blob {
  template <typename It> 
    Blob(It b, It e);
  ...
};

when define a member template outside of class template:

template <typename T>
template <typename It>
  Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b,e)) {}

To instantiate:

// Blob<int>::Blob(int *, int *);
Blob<int> a1(begin(iarray), end(iarray));

Blob<int> a1(ivec.begin(), ivec.end());

Blob<string> a1(svec.begin(), svec.end());

As with "with-nontemplate-class", function parameter types are deduced as it
is function template.


={============================================================================
*kt_dev_cxx_0000* cxx-template-explicit-instantiation

*cxx-code-bloat*
The fact that instantiations are generated when a template is used means that
the same instantiation may appear in multiple object files. This overhead can
become significant in large systems. 

Essentially, the same binary representation of an instantiated template is in
multiple files, and this can make your library or executable much larger than
it needs to be.

note: 
Not solved by a linker?

Under new standard *cxx-11* , `can avoid this through explicit instantiation.`

extern template `declaration`     // instantiation `declaration`
template `declaration`            // instantiation `definition`

When the compiler sees an "extern template declaration", will not generate
code for that instantiation `in that file` and it is to say there will be
nonextern use of that elsewhere in the program. 

o There may be several extern declarations for a given instantiation but there
  `must be exactly one definition for that particular instantiation` 

o since compiler automatically instantiates a template when use it, extern
  declaration must appear before any code that use it.

// `file1.cc`
// "instantiation declaration"
extern template class Blob<string>;
extern template int compare( const int&, const int& );

// Blob<string> instantiation will appear elsewhere
Blob<string> sa1, sa2;

// Blob<int>, its initializer_list ctor, and copy ctor are instantiated in this file.
Blob<int> a1 = { 0, 1, 2, 3, 4 };
Blob<int> a2(a1);

// compare(const int&, const int&) instantiation will appear elsewhere
int i = compare( a1[0], a2[0] );


// `file2.cc` *cxx-template-instantiate-all*
// compiler generate `all members` including inline members when see
// `instantiation definition` and must link file1.o with file2.o.

template class Blob<std::string>;
template int compare( const int&, const int& );


*cxx-template-instantiate-all*
The instantiation definition `generates all the members of that template`
including inline member function even if we do not use a member since the
compiler cannot know which member the program uses.

Can be used only for types that can be used with every member function of a
class template.

<ex>

template<typename T>
DBusMessage & DBusMessage::operator>>(T &arg)
{
  if (m_private->m_type == ReplyMessage)
  {
    if (m_private->m_args.empty())
    {
      logWarning("no more args in dbus message");
    }
    else
    {
      const DBusMessagePrivate::Argument &value = m_private->m_args.front();
      arg = static_cast<T>(value);
      m_private->m_args.pop_front();
    }
  }
  else
  {
    logWarning("dbus message is not a method reply, cannot read arguments");
  }

  return *this;
}

// see

template DBusMessage & DBusMessage::operator>> <bool>(bool&); 
template DBusMessage & DBusMessage::operator>> <int>(int&);
template DBusMessage & DBusMessage::operator>> <unsigned>(unsigned&);
template DBusMessage & DBusMessage::operator>> <double>(double&);
template DBusMessage & DBusMessage::operator>> <std::string>(std::string&);


<ex>
https://stackoverflow.com/questions/15974080/instantiation-of-template-member-function

*cxx-interview*

How to instantiate all members from a template? When it is useful? from
youview interview. How to before cxx-11?

http://stackoverflow.com/questions/2351148/explicit-instantiation-when-is-it-used

For instance, libstdc++ contains the explicit instantiation of

namespace cxx-code *cxx-string*
{
  // bits/stringfwd.h
  //
  namespace std 
  {
    template <typename charT,
    typename traits = char_traits<charT>,
    typename Allocator = allocator<charT> > 
      class basic_string;

    typedef basic_string<char> string;
  }
} // namespace


namespace cxx-code *cxx-string*
{
  // gcc/libstdc++-v3/src/c++11/string-inst.cc

  // Instantiation configuration.
  #ifndef C
  # define C char
  #endif

  namespace std _GLIBCXX_VISIBILITY(default)
  {
  _GLIBCXX_BEGIN_NAMESPACE_VERSION

    typedef basic_string<C> S;

    template class basic_string<C>;
    ...
  }
}

so every time you use functions of std::string, the same function code doesn't
need to be copied to objects. The compiler only need to refer (link) those to
libstdc++


https://msdn.microsoft.com/en-us/library/by56e477%28VS.80%29.aspx
Explicit Instantiation Visual Studio 2005 Other Versions

Explicit instantiation lets you create an instantiation of a templated class
or function without actually using it in your code. Because this is useful
`when you are creating library files` that use templates for distribution,
uninstantiated template definitions are not put into object (.obj) files.

  // libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007efe7d4aa000)
  //
  // {cxx-shared-downside-of-static} *why-use-shared-library*
  //
  // 1. Duplicates in disk and ram spce.
  // 
  // 2. If a change is required perhaps a security or bug fix to an object
  // module in a static library, then all executables using that module must
  // be relinked in order to incorporate the change. This disadvantage is
  // further compounded by the fact that the system administrator needs to be
  // aware of which applications were linked against the library.

  since templates are ordinarily in header files and by using explicit
  instantiation, make a shared library. so the same reason of using library.

The following explicitly instantiates MyStack for int variables and six items:

template class MyStack<int, 6>;

This statement creates an instantiation of MyStack without reserving any
storage for an object; code is generated for all members.

The following explicitly instantiates 'only' the constructor member function:

template MyStack<int, 6>::MyStack( void );

Function templates can be explicitly instantiated by redeclaring them with a
specific type argument, as seen in the example in Function Template
Instantiation.


={============================================================================
*kt_dev_cxx_0000* cxx-template-explicit-argument *cxx-template-function*

CPR 16.2.2

The user have to specify the type of template argument when not possible for
the compiler to deduce the type since doesn't appear in the `function parameter`
list and there is no arguments whose type can be used to deduce the type of
T1. That way `the user` can choose whatever `precision` is appropriate.

template< typename T1, typename T2, typename T3 > 
T1 sum( T2, T3 );

auto val3 = sum(i, lng);              // cannot deduce T1
auto val3 = sum<long long>(i, lng);   // long long sum( int, long )


<can-specify-all>
The explicit template functon argument matches `from left to right` and the below
is poor design since have to specify all of them to get T3.

template<typename T1, typename T2, typename T3> 
T3 alternative_sum( T2, T1 );

// error, can deduce T3
auto val3 = alternative_sum<long long>(i, lng);

// ok, all are specified
auto val3 = alternative_sum<long long, int, long>(i, lng);

note: Q: does it have real use case?


<normal-conversion>
As with ordinary argument, normal conversion applies on
`cxx-template-explicit-argument` since no deduction involved.

template <typename T> 
int compare(const T& v1, const T& v2);

long lng;

compare(lng, 1024);         // error since parameters do not match
compare<long>(lng, 1024);   // okay. compare( long, long );
compare<int>(lng, 1024);    // okay. compare( int, int );

<ex> ???

bool QVariant::canConvert() const

Returns true if the variant can be converted to the template type T, otherwise
false.

{
  template<typename T>
    bool canConvert() const
    { return canConvert(qMetaTypeId<T>()); }
}


={============================================================================
*kt_dev_cxx_0000* cxx-template-type-traits cxx-type-traits

<type-transformation>
Sometimes do not have direct access to the type we need. How to return 'value'
rather than a reference in this example? 

The problem is that we know almost nothing about the types we're passed. In
this function, the only operators we 'know' we can use are iterator operations
but no iterator operations that yield elemen type (as opposed to reference to
    element).

To get the element type, use type transformation template in the <type_traits>
header.

When instantiate `remove_reference<>` with a reference type, public type
memeber `type` is the referred-to type. 

remove_reference<int&>     // `type` member is `int`

template< typename T > 
auto &fcn( It beg, It end ) -> typename remove_reference<decltype(*beg)>::type
{
  // process the range
  return *beg;  // return a reference to an element from the range
}

Returns a copy of an element's value.

*cpp-q* : Still use C++11 feature, trailing return. How to do that before C++11? 


{cxx-type-traits} 

CXXSLR 5.4

Almost everything in the C++ standard library is template based. To support
the programming of templates, sometimes called metaprogramming, template
utilities are provided to help both programmers and library implementers.

Type traits, which were introduced with TR1 and extended with C++11, provide a
'mechanism' to define behavior 'depending' on types. A type trait provides a
way to deal with `the properties of a type.`

namespace cxx_code
{
  // tr1/type_traits

  /// integral_constant
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static const _Tp                      value = __v;
      typedef _Tp                           value_type;
      typedef integral_constant<_Tp, __v>   type;
    };
  
  /// typedef for true_type
  typedef integral_constant<bool, true>     true_type;

  /// typedef for false_type
  typedef integral_constant<bool, false>    false_type;

  /// is_pointer
  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
				      remove_cv<_Tp>::type>::value)>
    { };

} // namespace

<ex>
namespace cxx_type_trait
{
  template <typename T>
    bool foo(T const &val)
    {

      // is_pointer<T> yields either a `true_type` ro `false_type`, for which
      // ::value either yields true or false.

      if (std::is_pointer<T>::value)
      {
        // std::cout << "foo() called for a pointer" << std::endl;
        return true;
      }
      else
      {
        return false;
      }
    }
} // namespace

TEST(Template, TypeTrait)
{
  using namespace cxx_type_trait;

  int *pint;

  EXPECT_THAT(foo(pint), true);
}

The `trait` std::is_pointer, defined in `type_traits` header, is used to check
whether type T is a pointer type. 


{cxx-type-traits-and-overloads}
Use traits to provide two different actions based on type better than
providing two overloads of foo(); one for ordinary types and one for pointer
types?

One answer is that sometimes, too many overloads are necessary. the power of
type traits comes more from the fact that they are building blocks for generic
code, which can be demonstrated by two examples.

<ex>
Suppose that you have a function foo() that should be implemented differently
for integral and floating-point type arguments. The usual approach would be to
overload this function for all available integral and floating-point types:

void foo (short);             // provide integral version
void foo (unsigned short);
void foo (int);
...
void foo (float);             // provide floating-point version
void foo (double);
void foo (long double);

This repetition is not only tedious but also introduces the problem that it
might not work for new integral or floating-point types, either provided by
the standard, such as long long, or provided as user-defined types.

note:
Sure, can use template specialisation which still needs different
implementation. Whith is better?

With the type traits, you can provide the following instead:

namespace cxx_type_trait
{
  template <typename T>
    void foo_impl(T value, std::true_type)
    {
      (void) value;
      std::cout << "foo() called for integral type" << std::endl;
    }

  template <typename T>
    void foo_impl(T value, std::false_type)
    {
      (void) value;
      std::cout << "foo() called for floating type" << std::endl;
    }

  template <typename T>
    void foo_overload(T value)
    {
      foo_impl(value, std::is_integral<T>());
    }

} // namespace


// [ RUN      ] Template.TypeTrait
// foo() called for integral type
// foo() called for floating type
// [       OK ] Template.TypeTrait (1 ms)

TEST(Template, TypeTrait)
{
  using namespace cxx_type_trait;

  {
    int ivalue{10};
    double dvalue{10.0};

    foo_overload(ivalue);
    foo_overload(dvalue);
  }
}

The std::is_integral<T>() `at compile time` yields std::true_type or
std::false_type, which defines which of the provided foo_impl() overloads gets
instantiated.


<ex>
Another example for the usability of type traits is the need to process the
"common type" of two or more types.

For example, it would be an appropriate type of the minimum or the sum of two
values of different type. Otherwise, if I want to implement a function that
yields the minimum of two values of different types, which return type should
it have:

template <typename T1, typename T2>
??? min (const T1& x, const T2& y);

Using the type traits, you can simply use the std::common_type<> to declare
this type:

template <typename T1, typename T2>
typename std::common_type<T1,T2>::type min (const T1& x, const T2& y);


<cxx-type-traits-iterator-traits>

CXXSLR-9.5 Iterator Traits

// for writing algorithm? needs more.

It might be useful or even necessary to be able to overload behavior for
different iterator categories. By using iterator tags and iterator traits (both
    provided in <iterator>), such an overloading can be performed.

<cxx-iter-tag>
For each iterator category, the C++ standard library provides an `iterator-tag`
that can be used as a "label" for iterators:

namespace std {
  struct output_iterator_tag {
  };
  struct input_iterator_tag {
  };
  struct forward_iterator_tag
    : public input_iterator_tag {
    };
  struct bidirectional_iterator_tag
    : public forward_iterator_tag {
    };
  struct random_access_iterator_tag
    : public bidirectional_iterator_tag {
    };
}

<cxx-iter-traits>
If you write generic code, may need the type of the elements to which the
iterator refers. Therefore, the C++ standard library provides a special
template structure to define the iterator traits.

This structure contains all relevant information about an iterator and is used
as a common interface for `all the type definitions an iterator should have`
(the category, the type of the elements, and so on):

namespace std {
  template <typename T>
    struct iterator_traits {
      typedef typename T::iterator_category iterator_category;
      typedef typename T::value_type value_type;
      typedef typename T::difference_type difference_type;
      typedef typename T::pointer pointer;
      typedef typename T::reference reference;
    };
}

In this template, `T stands for the type of the iterator.` Thus, you can write
code that, for any iterator, uses its category, the type of its elements, and
so on. For example, the following expression yields the value type of iterator
type T:

typename std::iterator_traits<T>::value_type


={============================================================================
*kt_dev_cxx_0000* cxx-template-argument-deduction

For function template, deduction is process of determining the template
arguments type from the function arguments. This generates a version of the
function that best matches the given call.

// C++ Templates The Complete Guide Second Edition
// 1.2 Template Argument Deduction

Type Conversions During Type Deduction

automatic type conversions are limited during type deduction:

o When declaring call parameters by reference, even trivial conversions do not
  apply to type deduction. Two arguments declared with the same template
  parameter T must match exactly.

o When declaring call parameters by value, only trivial conversions that decay
  are supported: Qualifications with const or volatile are ignored, references
  convert to the referenced type, and raw arrays or functions convert to the
  corresponding pointer type. For two arguments declared with the same
  template parameter T the decayed types must match.


template<typename T>
T max (T a, T b);

max(4, 7.2);            // ERROR: T can be deduced as int or double?

There are three ways to handle such errors:

1. Cast the arguments so that they both match:

max(static_cast<double>(4), 7.2); // OK

2. Specify (or qualify) explicitly the type of T to prevent the compiler from
  attempting type deduction:

max<double>(4, 7.2); // OK

3. Specify that the parameters may have different types.

template<typename T1, typename T2>
T1 max (T1 a, T2 b);


<cxx-template-argument-deduction-return> <cxx-trailing-return-type> *cxx-11*

CXXSLR-16.2.3

Suppose that want to write the function that takes a sequence and returns a
reference to an element.

template< typename It > 
???& fcn( It beg, It end )
{
  // process the range
  return *beg;  // return a reference to an element from the range
}

vector<int> vi = { 1, 2, 3, 4 };
Blob<string> ca = { "hi", "bye" };

auto &i = fcn( vi.begin(), vi.end() );    // should return int&
auto &i = fcn( ca.begin(), ca.end() );    // should return string&

Do not know the exact type to return but know that want that type to be a
reference to the element type of the sequence. 

template<typename It, typename Return> 
Return &fcn( It beg, It end );

Sure, can have more arguments but more template argument imposes a burden on
the user. How to solve?

  "If a return type depends on template parameters, the simplest and best
  approach to deduce the return type is to let the compiler find out."


May use decltype(*beg) to get the type but beg don't exist until the parameter
list has been seen. The trailing return type allows us define the return type
after the parameter list is seen.

template< typename T > 
`auto`& fcn( It beg, It end ) -> decltype(*beg)
{
  // process the range
  return *beg;  // return a reference to an element from the range
}

This say fcn's return type is the same as the type returned by dereferencing
its beg parameter and which is a reference to the type.


<ex>
namespace cxx_template_return_type
{
  // use cxx-iter-trait but limited when T is iterator
  template <typename T>
    typename std::iterator_traits<T>::value_type &
    return_element_01(T first, T last)
    {
      (void)last;
      return *first;
    }

  template <typename T>
    auto return_element_02(T first, T last) 
    -> typename std::iterator_traits<T>::reference
    {
      (void)last;
      return *first;
    }

  // use cxx-trailing-return before cxx-14
  template <typename T>
    auto return_element_03(T first, T last) 
    -> decltype(*first)
    {
      (void)last;
      return *first;
    }

  // : error: ‘first’ was not declared in this scope
  // template <typename Iterator>
  // decltype(*first) return_element_04(Iterator first, Iterator last)
  // {
  //   return *first;
  // }

  // 1.3. C++ Templates The Complete Guide Second Edition
  // 1.3.2 Deducing the Return Type

  template <typename T>
    T max_01(T const& a, T const& b)
    {
      return b < a ? a : b;
    }

  // declare that the return type is derived from what operator?: yields:

  template <typename T1, typename T2>
    auto max_02(T1 a, T2 b) -> decltype(b < a ? a : b )
    {
      return b < a ? a : b;
    }

  // *cxx-14*
  // Since C++14, this is possible by simply not declaring any return type (you
  // still have to declare the return type to be auto):
  //
  // template <typename T1, typename T2>
  //   auto max_02(T1 a, T2 b)
  //   {
  //     return b < a ? a : b;
  //   }
  //
  // indicates that the actual return type must be deduced from the return
  // statements in the function body. In fact, using true as the condition for
  // operator?: in the declaration is enough:
  //
  // Note that an initialization of type auto always decays. This also applies
  // to return values when the return type is just auto.

  template <typename T1, typename T2>
    auto max_03(T1 a, T2 b) -> decltype(true ? a : b )
    {
      return b < a ? a : b;
    }

  // *cxx-type-trait-decay* *cxx-decay*
  // However, in any case this definition has a significant drawback: It might
  // happen that the return type is a reference type, because under some
  // conditions T might be a reference. For this reason you should return the
  // type decayed from T, which looks as follows:
  //
  // o Yields the decayed type of T.
  // o In detail, for type T the following transformations are performed:
  // – First, remove_reference (see Section D.4 on page 729) is applied.
  //
  // xxx_t is the same as xxx<T>::type and which is *cxx-14*
  //
  // decay_t<int const&> // yields int
  // decay_t<int const[4]> // yields int const*
  // void foo();
  // decay_t<decltype(foo)> // yields void(*)()

  template <typename T1, typename T2>
    auto max_04(T1 a, T2 b) 
    -> typename std::decay<decltype(true ? a : b )>::type
    {
      return b < a ? a : b;
    }

  // cxx-error
  // template <typename T1, typename T2>
  //   typename std::decay<decltype(true ? a : b )>::type 
  //   max_05(T1 a, T2 b) 
  //   {
  //     return b < a ? a : b;
  //   }

  // *cxx-14*
  // However, since C++14 you can simplify the usage of traits like this by
  // appending _t to the trait name and skipping typename and ::type

  // template <typename T1, typename T2>
  //   auto max_05(T1 a, T2 b) 
  //   -> std::decay_t<decltype(true ? a : b )>
  //   {
  //     return b < a ? a : b;
  //   }

  // *cxx-type-trait-commontype*
  // CXXSLR-5.4.1 Purpose of Type Traits
  // For example, the expression std::common_type<T1,T2>::type yields int if
  // both arguments are int, long, if one is int and the other is long, or
  // std::string if one is a string and the other is a string literal (type
  // const char*).
  //
  // Again, note that std::common_type<> decays so that the return value can’t
  // become a reference.

  template <typename T1, typename T2>
    typename std::common_type<T1, T2>::type 
    max_06(T1 a, T2 b)
    {
      return b < a ? a : b;
    }

  // "In fact, using true as the condition for operator?: in the declaration is
  // enough:". Does it mean it ALWAYS picks up type of a?

  template <typename T1, typename T2>
    auto which_type(T1 a, T2 b) -> decltype(true ? a : b )
    {
      return a ? a : b;
    }
} // namespace


TEST(Template, ReturnType)
{
  using namespace cxx_template_return_type;

  {
    vector<int> coll{3,4,5,6};

    EXPECT_THAT(return_element_01(coll.begin(), coll.end()), 3);
    EXPECT_THAT(return_element_02(coll.begin(), coll.end()), 3);
    EXPECT_THAT(return_element_03(coll.begin(), coll.end()), 3);
  }

  {
    max_01(4, 5);

    // cxx.cpp:4622:16: error: no matching function for call to ‘max_01(int, double)’
    //    max_01(4, 7.2);
    //                 ^
    // cxx.cpp:4622:16: note: candidate is:
    // cxx.cpp:4591:7: note: template<class T> T cxx_template_return_type::max_01(const T&, const T&)
    //      T max_01(T const& a, T const& b)
    //        ^
    // cxx.cpp:4591:7: note:   template argument deduction/substitution failed:
    // cxx.cpp:4622:16: note:   deduced conflicting types for parameter ‘const T’ (‘int’ and ‘double’)
    //    max_01(4, 7.2);
    //                 ^
    // max_01(4, 7.2);
  }
  {
    auto result = max_02(4, 7.2);
    EXPECT_THAT(typeid(result).name(), typeid(double).name());
  }

  // WHY NOT the result type is int type?
  // 1.3. C++ Templates The Complete Guide Second Edition
  // but generally produce an intuitively expected result (e.g., if a and b have
  // different arithmetic types, a common arithmetic type is found for the
  // result).

  {
    auto result = max_02(8, 7.2);
    EXPECT_THAT(typeid(result).name(), typeid(double).name());
  }
  {
    auto result = max_03(8, 7.2);
    EXPECT_THAT(typeid(result).name(), typeid(double).name());
  }
  {
    auto result = max_04(8, 7.2);
    EXPECT_THAT(typeid(result).name(), typeid(double).name());
  }

  // {
  //   std::string s{"string"};
  //   auto result = which_type(s, 0);
  //   EXPECT_THAT(typeid(result).name(), typeid(std::string).name());
  // }
}


<more-than-one-type>
The function template can have more than one type, function parameters, to
allow normal conversion on the parameters.

template <typename T>         // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

long lng;
compare( lng, 1024 );         // compare( long, int );

Since there are cxx-template-limited-conversion, the deduced type do not match
and this is an error when do not have the same type.

To solve this:

template <typename A, typename B>
int flexibleCompare( const A& v1, const B& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

flexibleCompare( lng, 1024 );   // flexibleCompare( long, int );

Of course, < operator must exist that can compare those types.


<cxx-template-value> normal-conversion-for-ordinary-argument
Ordinary type that do not involve a template type parameter have no special
processing so uses normal conversion.

template <typename T>
ostream &print( ostream &os, const T &obj )
{
    return os << obj;
}

print(cout, 42);         // print( ostream&, int )

ofstream f("output");
print(f, 10);            // convert ofstream to ostream&. derived-to-base.


{deduction-and-function-pointer}
The pointer pf1 points to the instantiation of compare. The type of the
parameter in function pointer, pf1, 'determines' the type of template
argument. T is bound to `int`.

template <typename T> int compare( const T&, const T& );

int (*pf1) ( const T&, const T& ) = compare;


It is an error if the template argument cannot be determined from the function
pointer type.

void func(int (*)(const string&, const string&));
void func(int (*)(const int&, const int&));

func(compare);     // error. Which instantiation of compare?

However, by looking at the function's parameter, not possible to determine a
unique type for the template arguments.

To solve this ambiguity, use template-explicit-argument.

func(compare<int>);


{deduction-and-reference}
When function parameter is `reference`, two important points:

template <typename T> void f(T &p);

<when-use-lvalue-reference>
template <typename T> void f1(T &v1);

f1(i);    // T is `int`
f1(ci);   // T is `const` `int`
f1(5);    // error since cannot bind `lvalue-reference` to `rvalue`.
          // <const-reference-to-literal>
          // const int &ri = 42;    // ok 
          // &ri = 42;              // error

template <typename T> void f2(const T &v1);

f2(i);    // T is `int`
f2(ci);   // T is `int`
f1(5);    // okay since `const &` can be bound to rvalue. T is `int`

The point is that use "const T&" to support 'any' type. The `const` is part of
function parameter type but not part of template parameter list.


<when-use-rvalue-reference>
template <typename T> void f3( const T&& );

f3(5);      // T is `int`

How about this?

f3(i);

CPR 688. Error? Since cannot bind an `rvalue-reference` to an `lvalue`? The
exception which are the foundation for how `std::move()` operate.

The first is when pass an `lvalue` to `rvalue-reference` function `parameter`,
    deduce it as argument's `lvalue-reference`.

f3(i);      // T is `int&`

Then instantiates 

void f3(const int& &&);

*cxx-reference-collapsing*
Wired? reference to reference? Ordinarily, cannot define that but allows
'indirectly' through `reference-collapsing`

X& &, X& &&, X&& & to X&. X&& && to X&&

The reference collapsing applies 'only' when a reference to a reference is
created indirectly such as in a type alias or a template parameter. so can
call f3 on lvalue.

f3(i);      // T is `int&`
f3(ci);     // T is `const int&`

void f3<int&>(int& &&); -> void f3<int&>(int&);

The point is that to pass `any type` So both way so the same; support any type.


<which-one>
Which one to use? This matters when write template.

template <typename T> void f3(T &&val)
{ 
    T t = val;      // copy or binding?
    t = fcn(t);     // change only t or val and t?
    if(val == t) { ... }
}


* When call f3 on `rvalue`, f3(42), T is `int` so "int t = val". t and val are
  independant.
    
* When call f3 on `lvalue`, f3(i), T is `int&` so "int& t = val". When change t, will
  change val as well. so if test will always yield true.

  note: is it legal?

  int& t = int& val; 

It is suprisingly difficult to write code that is correct when type is plain
nonreference or reference type. 

In practice, `rvalue-reference` used in one of two context: argument forwading
or template overload.

// *cpp-overload* const overloading
Record lookup( account & );             // nonconst version
Record lookup( const account &);        // const version

// *cpp-overload* copy and move overloading
void push_back( const X& );             // copy version
void push_back( X&& );                  // move version

template <typename T> void f( const T& );   // binds to `lvalue` and `const-rvalue`
template <typename T> void f( T&& );        // binds to `nonconst-rvalue`


<std-move>
The standard defines std::move() which is example that works on rvalue and
lvalue arguments through *reference-collapsing*

In other words, cannot directly bind `rvalue-reference` to `lvalue` but can
'indirectly' as `reference-collapsing`. Use std::move() to obtain an
`rvalue-reference` bound to an lvalue.

template <typename T>
typename remove_reference<T>::type&& move( T&& t )
{
  // get `rvalue-reference` of the referred-to type
  return static_cast<typename remove_reference<T>::type &&> (t);
}

string s1("hi!"), s2;

// temporary, `rvalue`, to string&& move(string &&t)
s2 = std::move( string("bye") );       
// `lvalue`, to string&& move(string &t)
s2 = std::move( s1 );


={============================================================================
*kt_dev_cxx_0000* cxx-template-forward

{cxx-forward}
Some function need to forward their arguments with types 'unchanged' to
another function. In such cases, need to 'preserve' everything including
whether or not type is `const` and whether the argument is an `lvalue` or an
`rvalue`.

<ex>
template <typename F, typename T1, typename T2>
void flip(F f, T1 param1, T2 param2)
{
  f(param2, param1);
}

// use *cxx-rvalue-reference* to preserve template parameter:
//
// A function parameter that is an rvalue reference to a template parameter
// `preserves` constness and lvalue/rvalue property of its corresponding
// argument.

template <typename F, typename T1, typename T2>
void flip_reference(F f, T1&& param1, T2&& param2)
{
  f(param2, param1);
}

void f(int value1, int& value2)
{
  (void) value1;
  ++value2;
}

void g(int&& value1, int& value2)
{
  (void) value1;
  ++value2;
}


// Use `std::forward()` to preserve the types of the original arguments. Unlike
// std::move(), std::forward() 'must' be called with an explicit template
// argument, *cxx-template-explicit-argument* and returns rvalue reference to
// that type, T &&. 
// 
// template <typename F, typename T1, typename T2>
// void flip(F f, T1 &&t1, T2 &&t2)                    // 1
// {
//   f(std::forward<T2>(t2), std::forward<T1>(t1));    // 2
// }
// 
// To preserve type information is two-step process, 1 and 2.
// 
// *cxx-ref*
// What's the difference between std::ref() and std::forward() solution?
// By std::forward() solution, user of template don't need to anyting.

template <typename F, typename T1, typename T2>
void flip_forward(F f, T1 &&param1, T2 &&param2)
{
  f(std::forward<T2>(param2), std::forward<T1>(param1));
}

TEST(Template, Forward)
{
  {
    int i = 10;
    int j = 20;

    f(i, j);

    EXPECT_THAT(i, 10);
    EXPECT_THAT(j, 21);   // changed
  }

  {
    int i = 10;
    int j = 20;

    flip(f, i, j);

    // both are not changed since flip() uses local copy and f() changes that

    EXPECT_THAT(i, 10);
    EXPECT_THAT(j, 20);
  }

  {
    int i = 10;
    int j = 20;

    flip(f, std::ref(i), j);

    // change since passed reference

    EXPECT_THAT(i, 11);   // changed
    EXPECT_THAT(j, 20);
  }

  {
    int i = 10;
    int j = 20;

    flip_reference(f, i, j);

    EXPECT_THAT(i, 11);   // changed
    EXPECT_THAT(j, 20);
  }

  // Still flip_reference() solves half of the problem since cannot be used to
  // call a function that has an rvalue parameter.
  //
  // flip_reference() pass `preserved` parameter down to g and which are int.
  // They binds to int&& adn this is error.
  //
  // WHY not reference-collapsing? Because g() is not template.
  //
  // {
  //   int i = 10;
  //   int j = 20;
  //
  //   // cxx.cpp:5315:27:   required from here
  //   // cxx.cpp:5240:19: error: cannot bind ‘int’ lvalue to ‘int&&’
  //   //    f(param2, param1);
  //   //                    ^
  //
  //   flip_reference(g, i, j);
  //
  //   EXPECT_THAT(i, 11);   // changed
  //   EXPECT_THAT(j, 20);
  // }

  {
    int i = 10;
    int j = 20;

    flip_forward(f, i, j);

    EXPECT_THAT(i, 11);   // changed
    EXPECT_THAT(j, 20);
  }
}


// *cxx-rvalue-reference* *cxx-forward*
//
// From CPP Challenge, 56. Select algorithm
// 
// Write a function that, given a range of values and a projection function,
// transforms each value into a new one and returns a new range with the selected
// values. For instance, if you have a type book that has an id, title, and author,
// and have a range of such book values, it should be possible for the function to
// select only the title of the books. Here is an example of how the function
// should be used:
//
// *cxx-result-of*
//
// std:: result_of <T, Args...>::value
//
// o Yields the return type of the callable T called for Args...
//
// Since C++11, to get the return type you could call: typename std::result_of<Callable(Args...)>::type
//
// typename std::decay<typename std::result_of<typename std::decay<F>::type&(typename std::vector<T>::const_reference)>::type>::type
//                                            {                                                                       }
//                    {                                                                                                      }
// after all,
// 1. "typename std::decay<F>::type&(vector<T>::const_reference)" gets the address of function that takes const reference
// 2. result_of<>::type gets return type
// 3. decay<>::type gets decayed type

namespace cxx_template
{
  struct book
  {
    int id;
    string title;
    string author;
  };

  template <typename T, typename F,
           typename R = typename std::decay<typename std::result_of<typename std::decay<F>::type&(typename std::vector<T>::const_reference)>::type>::type>
             std::vector<R> select(std::vector<T> const& coll, F&& f)
             {
               std::vector<R> result{};
               std::transform(coll.cbegin(), coll.cend(), std::back_inserter(result),
                   std::forward<F>(f));
               return result;
             }

} // namespace

TEST(Template, ForwardEx)
{
  using namespace cxx_template;

  std::vector<book> books{
    {101, "The C++ Programming Language", "Bjarne Stroustrup"},
      {203, "Effective Modern C++", "Scott Meyers"},
      {404, "The Modern C++ Programming Cookbook", "Marius Bancila"}};

  auto titles = select(books, [](book const& b) {return b.title;});

  EXPECT_THAT(titles, 
      ElementsAre("The C++ Programming Language", "Effective Modern C++", "The Modern C++ Programming Cookbook"));


  auto authors = select(books, [](book const &b) {return b.author; });

  EXPECT_THAT(authors, 
      ElementsAre("Bjarne Stroustrup", "Scott Meyers", "Marius Bancila"));


  auto ids = select(books, [](book const &b) {return b.id; });

  EXPECT_THAT(ids, 
      ElementsAre(101, 203, 404));
}


<cxx-template-type-check>
When use greater<int> as op in build_partition, found that it works in the
first recurvise loop but less<int> after that. How to check whether it's
less<int> or greater<int>?

namespace U57_2019_01_05
{
  template <typename Iter, typename Comp>
    Iter build_partition(Iter begin, Iter end, Comp op)
    {
      // *cxx-error* since no operator+()
      // Iter pivotpos = (begin + end) / 2;

      Iter pivotpos = begin + (std::distance(begin, end) / 2);
      auto pivot_value = *pivotpos;
      Iter last_small = begin;

      //  
      decltype(op) xx;
      // // cxx-greater
      // EXPECT_THAT(xx(2, 1), true);

      // cxx-less
      EXPECT_THAT(xx(1, 2), true);

      ...
    }

  template <typename Iter, 
           typename Comp = typename std::decay<typename std::less<typename std::iterator_traits<Iter>::value_type>>::type>
  void quicksorti(Iter begin, Iter end, Comp&& op = Comp())
  {
    Iter lastsmall;

    if (begin < end)
    {
      lastsmall = build_partition(begin, end, std::forward<Comp>(op));

      // *cxx-error*
      quicksorti(begin, lastsmall);

      quicksorti(lastsmall+1, end);
    }
  }
} // namespace


TEST(U57, 2019_01_05)
{
  using namespace U57_2019_01_05;

  {
    vector<int> coll{29, 33, 35, 26, 19, 12, 22};
    quicksorti(coll.begin(), coll.end());
    EXPECT_THAT(coll, 
        ElementsAre(12, 19, 22, 26, 29, 33, 35));
  }

  {
    vector<int> coll{29, 33, 35, 26, 19, 12, 22};
    quicksorti(coll.begin(), coll.end(), std::greater<int>());
    // actual
    // { 29, 33, 35, 26, 12, 19, 22 }
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-template-overload

A function return a string representation of a given object.

// *cxx-stringstream* print any type

template <typename T> 
string debug_rep(const T &t)
{
  ostringstream ret;
  ret << t;           // use T's output operator
  return ret.str();   // return a copy of the string to which ret is bound
}

Why it says, "use T's output operator" since operator<< is usually non-member
function?

When use gdb, this "ret << t" leads to:

std::operator<< <char, std::char_traits<char>, std::allocator<char> > 
    (__os=..., __str="this is string") 
    at /include/c++/4.9.2/bits/basic_string.h:2777
2777	      return __ostream_insert(__os, __str.data(), __str.size());

This is not in "class basic_string" and in std global namespace. Looks like a
global function template.

  /**
   *  @brief  Write string to a stream.
   *  @param __os  Output stream.
   *  @param __str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a __str into os following the same rules as for
   *  writing a C string.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
	       const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 586. string inserter not a formatted function
      return __ostream_insert(__os, __str.data(), __str.size());
    }


When use own class like, "debug_rep(My);", emit errors:

$ ./bldcpp.sh t_templ.cpp 
t_templ.cpp: In instantiation of 'std::string debug_rep(const T&) [with T = My; std::string = std::basic_string<char>]':
t_templ.cpp:27:17:   required from here
t_templ.cpp:15:9: error: cannot bind 'std::basic_ostream<char>' lvalue to 'std::basic_ostream<char>&&'
     ret << t;
         ^
In file included from /home/kpark/gcc-build/install/include/c++/4.9.2/iostream:39:0,
                 from t_templ.cpp:1:
/include/c++/4.9.2/ostream:602:5: note: initializing argument 1 of 'std::basic_ostream<_CharT, _Traits>& std::operator<<(std::basic_ostream<_CharT, _Traits>&&, const _Tp&) [with _CharT = char; _Traits = std::char_traits<char>; _Tp = My]'
     operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
     ^

<ex>
namespace cxx_template_overload
{
  class Mine 
  {
    private:
      string name;

    public:
      Mine(): name(string("mine")) 
      { // cout << "mine class" << endl; 
      }

      const string& get() { return name; }
  };

  ostringstream& operator<<(ostringstream& os, Mine mine) 
  { 
    os << mine.get();
    return os;
  }

  template <typename T> string debug_rep(const T &t)
  {
    ostringstream ret;
    ret << t;
    return ret.str();
  }
} // namespace

TEST(Template, Overload)
{
  using namespace cxx_template_overload;

  Mine mine;
  ostringstream os;

  // string str("this is string");
  // cout << debug_rep(str) << endl;

  os << debug_rep(mine) << endl;   
  EXPECT_THAT(os.str(), "mine\n");
}


Things to remember:

o When there are several overloaded templates that provide an eqaually good
  match for a call, the most specialized version is perferred.

o When a non-template function provides an equally good match for a call as a
  function template, the non-template version is preferred.


={============================================================================
*kt_dev_cxx_0000* cxx-template-variadic

A template function or class that can take varying number of parameters which
is called a parameter pack to represent zero or more parameters. Two kinds:
`template parameter pack` and `function parameter pack.`

template <typename T, typename... Args>         // Args is template param pack
void foo(const T &t, const Args& ... rest);     // rest is function param pack

int i = 0; double d = 3.14; string s = "how now brown cow";
foo( i, s, 42, d );  // three parameters in the pack
foo( s, 42, "hi" );  // two parameters in the pack
foo( d, s );         // one parameters in the pack
foo( "hi" );         // empty pack

The compiler deduces the parameter types and also the number of parameters in
the pack, and `instantiate four different foo`:

void foo(const int&, const string&, const int&, const double&);
void foo(const string&, const int&, const char[3]&);
void foo(const double&, const string&);
void foo(const char[3]&);


<variadic-sizeof-operator>
*cxx-11* use the `sizeof...` operator to know how many elements are in a pack
which is different from sizeof operator, *cxx-sizeof*

<ex>
namespace cxx_template_variadic
{
  template <typename T, typename... Args>
    std::pair<int, int> foo(T const& t, Args const&... args)
    {
      (void) t;
      return make_pair(
          // number of template parameters
          sizeof...(Args), 
          // number of function parameters
          sizeof...(args)
          );
    }
} // namespace

TEST(Template, VariadicSizeofOperator)
{
  using namespace cxx_template_variadic;

  int i = 0; double d = 3.14; std::string s = "how now brown cow";

  // three parameters in the pack
  EXPECT_THAT(foo(i, s, 42, d), make_pair(3,3));

  // two parameters in the pack
  EXPECT_THAT(foo(s, 42, "hi"), make_pair(2,2));

  // one parameters in the pack
  EXPECT_THAT(foo(d, s), make_pair(1,1));

  // empty pack
  EXPECT_THAT(foo("hi"), make_pair(0,0));
}


<variadic-or-initializer-list> 
*cxx-initializer-list* define a function that can take a varying number of
arguments which must have the 'same' type.

The point is that variadic functions are used when we know neither the number
nor the types of the arguments to process.


<variadic-recursive>
Variadic are often recursive. To stop the recustion, we also need nonvariadic
funtion.

template <typename T> 
ostream &print( ostream &os, const T &t)
{ return os << t; }

template <typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args&... rest)
{
  os << t << ", ";            // print the first argument.
  return print(os, rest...);  // recursive call; print the other arguments.
}

The key part is that the 'first' argument in rest gets bound to t. That pops
up a argument from the pack and the remaining in rest 'form' the pack for the
next call until there is the last since variadic is only viable match. 

print( cout, i, s, 42 );
...
print( cout, s, 42 );
print( cout, 42 );

When the last remains, the variadic and the nonvariadic are viable and the
nonvariadic gets called since it is more speciailized. So ends recursion.

note: The declaration of the nonvariadic version of print 'must' be 'before'
variadic version since must be 'in' scope when the variadic version is
defined. Otherwise, the variadic will recurse indefinitely.


<pack-expansion>
When expand a pack, also provide a `pattern` to be used on each expanded
element. Trigger an expansion by putting an ellipsis(...) to the right of
pattern. 

template <typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args&... rest)     // 1
{
  os << t << ", ";          
  return print(os, rest...);                                      // 2
}

* 1. Expand Args to generate function parameter pack. Applies the pattern,
  "const Args&" to 'each' element in the template pack.

* 2. Expand rest  and the pattern is the name of the function parameter pack.


To see how pattern works, more complicated pattern is: 

template <typename T> string debug_rep( const T &t );

template <typename T, typename... Args>
ostream &errorMsg( ostream &os, const Args&... rest)     // 1
{
  // print( os, debug_rep(a1), debug_rep(a2), ... );
  return print(os, `debug_rep(rest)...`);                  // pattern
}

When call this:

errorMsg( cerr, fcnName, code.num(), otherData, "other", item );

expands to:

print( cerr, debug_rep(fcnName), debug_rep(code.num()), 
               debug_rep(otherData), debug_rep("other"), debug_rep(item) );


However, this fails to compile since expanded as if five arguments to print.

template <typename T, typename... Args>
ostream &errorMsg( ostream &os, const Args&... rest)     // 1
{
  return print(os, debug_rep(rest...) );                 // pattern
}

print(cerr, debug_rep(fcnName, code.num(), otherData, "other", item));


<cpp-template-variadic-forward>
Can use variadic template together with std::forward. To illustrate this, add an
emplace_back to StrVec class.

The emplace_back is variadic member template that uses its arguments to
construct an element directly in space managed by the container.

class StrVec {
  public:
    // each function parameter will be an rvalue reference
    template <typename... Args> void emplace_back(Args &&...args)
    {
      chk_n_alloc();  // reallocate the StrVec if necessary
      alloc.construct(first_free++, std::forward<Args>(args)...);
    }
};

svec.emplace_back(10, 'c');

The pattern in the call to construct will expand to

std::forward<int>(10), std::forward<char>(c)


={============================================================================
*kt_dev_cxx_0000* cxx-template-specialization

{cxx-template-non-type-parameters}

CPR 16.5

Not always possible to write a `single` template suited for every possible
template argument. In some cases, the general template is wrong for a type. 

o When the general template definition might not compile or might do the wrong
  thing.

o When can take advantage of some specific knowledge to write more efficient
  code.

When cannot or do not want to use the template version, can define a
specialized version of the class or function template.

CPR 16.1

o A non-type parameter represents `a value rather than a type.` These value must
  be constant expression and is a constant value inside the template
  definition.

o A non-type parameters are specified by using a specific type name instead of
  the class or typename keyword.

Again, compare() is an example for which the general definition is not
appropriate for a particular type, character pointers. We want to compare
pointers by strcmp() rather than by comparing the pointer values.

// generic version for any two types

template <typename T> 
int compare(const T&, const T&)
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

// `non-type-template-parameter` version for string literals define parameters
// as references to an array since cannot copy an array. *cxx-declarator*

template <unsigned N, unsigned M> 
int compare(const char (&p1) [N], const (&p2) [M])
{
  return strcmp(p1, p2);
}

If calls compare() with character pointers, the first version will be called
because `non-type-template` version will be called only when pass a string
literal which is array of const char or an array.


// instantiate type-template version

const char *p1 = "hi", *p2 = "mom";
compare(p1, p2);          

// instantiate non-type template version
// int compare(const char (&p1)[3], const char (&p2)[4]);

compare("hi", "mom");     


{cxx-template-specialization}
To handle character pointers, can define a `template specialization` of the
first version. A `separate definition` of the template, specific instantiation
in which `one or more template parameters are specified` to have particular
types.

  *cxx-template-specialization-or-cxx-template-explicit-argument*

  Can use `cxx-template-explicit-argument` because it specifies the types?
  No becuase explict-argument `specifies the type` with the same
  defintion(code) but specialization supply `different definition` and
  specifies definition or instantiation. 


// C++ Templates The Complete Guide Second Edition

2.5 Specializations of Class Templates

You can specialize a class template for certain template arguments. Similar to
the overloading of function templates, specializing class templates allows you
to optimize implementations for certain types or to fix a misbehavior of
certain types for an instantiation of the class template. 

However, if you specialize a class template, you must also specialize all
member functions.  Although it is possible to specialize a single member
function of a class template, once you have done so, you can no longer
specialize the whole class template instance that the specialized member
belongs to.


<for-function-template>
To indicate that we are specializing a template, use empty braket(<>) whcih
means we must supply arguments for `all template parameter` in the original
template.

// specialized, special version of compare
template <>
int compare(const char* `const` &p1, const char* `const` &p2)
{ return strcmp( p1, p2 ); }

The hard part is to understand the function parameter type because the
function parameter 'must' match the corresponding types in the 'original'
template:

template <typename T> int compare(const T&, const T&);

const char *p1 = "hi", *p2 = "mom";

Want to use T as "const char *" and original template requires "const" version
of the "type". As with *cxx-const-on-base-type* the type to use in
specialization is "const char * const" since base type is "const char *"

This specialization becomes `non-type-template-version` which affect function
matching.


<ex>

namespace cxx_template 
{
  // Q: strcmp returns +5/-5 than 1/-1

  int internal_strcmp(const char *p1, const char *p2)
  {
    while (true)
    {
      unsigned int c1 = *p1;
      unsigned int c2 = *p2;

      if (c1 == c2) break;
      if (c1 != c2) return c1 < c2 ? -1 : 1;
    }

    return 0;
  }

  template <unsigned N, unsigned M>
    int compare(const char (&p1) [N], const char (&p2) [M])
    {
      return internal_strcmp(p1, p2);
    }

  template <>
    int compare(const char* const &p1, const char *const &p2)
    {
      return internal_strcmp(p1, p2);
    }

  template <typename T, int size>
    class FileBuf
    {
      public:
        int get_size()
        {
          return sizeof(array_)/sizeof(T); 
        }

      private:
        T array_[size];
    };

  template<int MIN, int MAX>
  struct RangedIntPolicy
  {
    typedef int value_type;
    value_type value_ = MIN;
    // value_type value_{MIN};

    int assign(value_type value)
    {
      if ((value < MIN) || (value > MAX))
        return -1;

      value_ = value;
      return 0;
    }
  };

} // namespace

TEST(Template, Specialisation)
{
  using namespace cxx_template;

  {
    EXPECT_THAT(compare("mon", "hi"), 1);
    EXPECT_THAT(compare("hi", "mon"), -1);

    // cxx.cpp:2829:33: error: call of overloaded ‘compare(const char [3], const
    // char [3])’ is ambiguous

    // EXPECT_THAT(compare("hi", "hi"), 0);

    const char *p1 = "hi";
    const char *p2 = "mon";
    EXPECT_THAT(compare(p1, p2), -1);
  }

  {
    FileBuf<int, 20> fbuf;
    EXPECT_THAT(fbuf.get_size(), 20);
  }

  {
    RangedIntPolicy<10, 100> rint;
    EXPECT_THAT(rint.assign(9), -1);
    EXPECT_THAT(rint.assign(101), -1);
    EXPECT_THAT(rint.assign(30), 0);
  }
}


<scope-rule>
In order to specialize a template, the original template `must be in scope.`
Moreover, a declaration for a specialization must be in scope before any use
of it.

Because the compiler can generate code using the original template when a
specialization is missing, errors in declaration 'order' between a template
and specialization are easy to make but hard to find. The compiler is unlikely
to detect.

The best practice is that should have all in the same header file.
Declarations for all templates should appear first, followed by any
specialization.


<for-class-template> *cxx-hash*
As an example, specialize the library hash template to store Sales_data object
in an unordered container. Must do so in the 'same' namespace in which the
original template is defined.

CPR 709. To use unordered map with our own data type, must define a
specialization of the hash template and it must define:

  * An overloaded call operator that return a size_t and takes an object of
    the container's key type.

  * Two type members, result_type and argument_type, which are the return and
    argument types, respectively, of the call operator.

  * The default constructor and copy-assign operator.

To add members to std namespace

namespace std {
  // indicate cxx-template-specialisation for T, Sales_data, type
  template <>
    struct hash <Sales_data>
    {
      typedef size_t result_type;
      typedef Sales_data argument_type;

      size_t operator() ( const Sales_data& s ) const;
    };

  size_t hash<Sales_data>::operator()(const Sales_data &s) const
  {
    // use 'unnamed', temporary object and delegate the complexity of good
    // hash function to the library.

    return hash<string>() (s.bookNo) 
      ^ hash<unsigned>() (s.units_sold) ^ hash<double>() (s.revenue);
  }
}  // no semicolon after the end of namespace


Assuming this speciailization is in scope, this will be used automatically
when we use Sales_data as a key:

unordered_multiset<Sales_data> SDest;

Since hash<Sales_data> uses the private members of Sales_data, must make this
calss, the specific instantiation, a friend of Sales_data.
*cpp-template-friend*

// in std since we added it to that namespace
template <class T> class std::hash;

class Sales_data {
  friend class std::hash<Sales_data>;
  ...
};


The second way: Having added the declaration for the specialization to std
namespce we can define the specialization outside the std.

namespace std {
   template <> struct hash< Sales_data >;
}

template <> struct hash <Sales_data> 
{
  size_t operator() ( const Sales_data& s ) const
  {
    ...
  }
  // other members as before
}


{cxx-template-partial-specialization}
Differently from function template, can specify some, but not all, of the
template parameters of class template. 

  `"Partial speciailization is only for class template."` 

After the class name, specify arguments for the template parameters we are
specializing and correspond positionally to the parameters in the original
template. 

The remove_reference type-trait works through a series of specialization.

// original, most general template and for any type

template <typename T> 
struct remove_reference 
{
    typedef T type;
};

// partial specialization used for lvalue and rvalue reference
// *cxx-reference-quailifier*

template <typename T> 
struct remove_reference`<T&>` 
{ typedef T type; };

template <typename T> 
struct remove_reference`<T&&>`
{ typedef T type;};

The specialization's parameter list has the same number of parameters as the
original but `the parameter's type in the specialization` differ from the
original.

int i;

// decltype(42) is `int`, use the original
remove_reference<decltype(42)>::type a;

// decltype(i) is `int&`, use the first 
remove_reference<decltype(i)>::type b;

// decltype(std::move(i)) is `int&&`, use the second
remove_reference<decltype(std::move(i))>::type c;

All three, a, b, and c, have type `int` 


{member-specialization}
Rather then specialize the whole template, can specialize specific member
function(s). If Foo is a template with a member Bar.

template <typename T> struct Foo 
{
    Foo(const T &t = T()): mem(t) {}
    void Bar() { /* ... */ }
    T mem;
};

template <> void Foo<int>::Bar()
{
  ...
}

When use Foo with any type other than int, members are instantiated as usual.
Here specializing the Bar member of Foo<int> class.

Foo<string> fs;   // instantiate Foo<string>::Foo()
fs.Bar();         // instantiate Foo<string>::Bar()

Foo<int> fi;      // instantiate Foo<int>::Foo()
fi.Bar();         // use specialization version of Foo<int>::Bar()


={============================================================================
*kt_dev_cpp_054* template-inheritance

Have got an error on GCC in following case:

template <typename Entry>
class Binary_tree 
{
  ...

  protected:
    Binary_node<Entry> *root;
};


template <typename Record>
class Search_tree: public Binary_tree<Record>
{
  public:
    ...
    Error_code tree_search( Record &target ) const;
};

template <typename Record>
Error_code Search_tree<Record>::tree_search( Record &target ) const
{
  Error_code result = success;

  // <1> Binary_node<Record> *found = search_for_node( root, target );
  // Binary_node<Record> *found = search_for_node( Search_tree<Record>::root, target );
  // Binary_node<Record> *found = search_for_node( Binary_tree<Record>::root, target );
  // Binary_node<Record> *found = search_for_node( this->root, target );
  if( found == NULL )
    return not_present;
  else
    target = found->data;

  return result;
}

The <1> caues an error:
bintree.cpp: In member function ‘Error_code Search_tree<Record>::tree_search(Record&) const’:
bintree.cpp:107:49: error: ‘root’ was not declared in this scope

Why? Googled and found:

http://www.parashift.com/c++-faq-lite/nondependent-name-lookup-members.html
[35.19] Why am I getting errors when my template-derived-class uses a member it inherits from its
template-base-class? 

Perhaps surprisingly, the following code is not valid C++, even though some compilers accept it:

template<typename T>
class B {
  public:
    void f() { }  // member of class B<T>
};

template<typename T>
class D : public B<T> {
  public:
    void g()
    {
      f();        // bad (even though some compilers erroneously (temporarily?) accept it)
    }
};

This might hurt your head; better if you sit down.

Within D<T>::g(), the name f does not depend on template parameter T, so f is known as a
nondependent name. On the other hand, B<T> is dependent on template parameter T so B<T> is called a
dependent name.

Here's the rule: the compiler does 'not' look in dependent base classes (like B<T>) when looking up
nondependent names (like f).

This doesn't mean that inheritance doesn't work. Class D<int> is still derived from class B<int>,
the compiler still lets you implicitly do the is-a conversions (e.g., D<int>* to B<int>*),
dynamic binding still works when virtual functions are invoked, etc. But there is an issue
about how names are looked up.

Workarounds:
1) Change the call from f() to this->f(). <note> this is interesting. "Since this is always
implicitly dependent in a template", this->f is dependent and the lookup is therefore deferred until
the template is actually instantiated, at which point all base classes are considered.

2) Insert using B<T>::f; just prior to calling f().

3) Change the call from f() to B<T>::f(). Note however that this might not give you what you want if
f() is virtual, since it inhibits the virtual dispatch mechanism.

So in the above example, all other cases works other than <1>


={============================================================================
*kt_dev_cpp_300* case: framework {tizen-case}

From Tizen and points to see are:

o Used factory-func to create a self in the derived class but used static-factory-func. Have
separation and single point of acess to create whole instances.

o Not used singleton but used protected and private ctor or/and dtor in a tree. The protected is
used like singleton to allow derived to create base part.

o Used pimpl-idiom but do not have the same interface between them. not necessary to have the same
interface 

o the way to pass cpp func addresses to c

 
App: ABC                                     _AppImpl: public interface classes
                                                friend class App
 'protected': ctor(); new _AppImpl              'private': ctor and dtor (only App can create AppImpl)
 'static' App* GetInstance(); calls ->          static _AppImpl* GetInstance()
                                                Construct()
                                                Execute()
 |
 |
 |
ServiceApp:                                  _ServiceAppImpl: public interface classes
 'protected': ctor(); new _ServiceAppImpl       'private': ctor and dtor
 static ServiceApp* GetInstance(); ->           static _ServiceAppImpl* GetInstance()
 static Execute(); 
   : use user provided factory-func to create user class and creates all instances
   : register a event listener and run efl_main

 | 
 | Framework 
 |-----------------------------------------------------------------------------
 | User classes
 |----------------------------------
 |                                 | ...
AppService:                       XXXService:
 static CreateInstance();
   : member-static-factory-func to create AppService. This is interesting because used subclassing
   to decide what to create but used static-factory-func.

OspMain():
   result r = Tizen::App::Service::Execute( AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute( AppService::CreateInstance, &args); )


// App

class App
{
  // interfaces
  public: 
    virtual OnXXX()=0;
    virtual void OnLowMemory(void);

    // very few use of forwarding to impl.
    virtual OnYYY()
    { __pAppImpl->OnYYY(); }

    static App* GetInstance();
    {
      _AppImpl* pAppImpl = _AppImpl::GetInstance();

      if (pAppImpl != null)
      {  // [KT] why need this as it returns App* which is passed to Impl?
        return pAppImpl->GetAppInstance();
      }

      return null;
    }

    virtual ~App(void)			# see virtual
    { delete __pAppImpl; }

  protected:
    App(void);
    { __pAppImpl = 'new' (std::nothrow) _AppImpl('this'); }

  private:
    class _AppImpl* __pAppImpl;
};


// _AppImpl

class _AppImpl : public IEventListener
{
  public:
    'static' _AppImpl* GetInstance()
    { return __pAppImpl; }

    App* _AppImpl::GetAppInstance(void)
    { return __pApp; }

    result Construct(const Tizen::Base::Collection::IList* pArgs);
    result Execute(_IAppImpl* pIAppImpl);
    {
      pAppImpl->__pIAppImpl = pIAppImpl;

      app_event_callback_s state_handler;

      state_handler.create = &OnCreate;
      state_handler.service = &OnService;
      state_handler.terminate = &OnTerminate;
      state_handler.pause = &OnPause;
      state_handler.resume = &OnResume;
      state_handler.device_orientation = NULL;

      state_handler.low_memory = &OnLowMemory;
      state_handler.low_battery = NULL;
      state_handler.language_changed = &OnLanguageChanged;
      state_handler.region_format_changed = &OnRegionFormatChanged;

      // see how to pass data from cpp to c and efl_main should copy since it is local
      // 
      eflResult = app_efl_main(&argc, &pArgv, &state_handler, this);
    }

    // same name but static. what will happen?
    'static' void OnLowMemory(void* user_data);

  private:

    _AppImpl::_AppImpl(App* pApp)
      : ...
        , __pApp(pApp)
          , __pIAppImpl(null)
  { __pAppImpl = this; }

    virtual ~_AppImpl(void)
    { __pAppImpl = null; }

    'static' _AppImpl* __pAppImpl;

    App* __pApp;
    _IAppImpl* __pIAppImpl;

    // [KT] otherwise, compile errer when App creates Impl
    friend class App;
};


// ServiceApp(Service) since used typedef ServiceApp Service

class ServiceApp : public Tizen::App::App
{
  public:
    virtual ~ServiceApp(void)
    { delete __pServiceAppImpl; }

    'static' ServiceApp* GetInstance(void)
    {
      _ServiceAppImpl* pServiceAppImpl = _ServiceAppImpl::GetInstance();
      if (pServiceAppImpl == null)
      {
        return null;
      }

      return pServiceAppImpl->GetServiceAppInstance();
    }

    'static' result Execute(ServiceAppInstanceFactory pServiceAppFactory, 
        const Tizen::Base::Collection::IList* pArguments);
    {
      result r = E_SUCCESS;

      ServiceApp* pServiceApp = null;
      _AppImpl* pAppImpl = null;

      // call AppService::CreateInstance. create <AppService> instance
      // use pServiceApp only when exception happens to delete. Here done all creations of objects. 
      pServiceApp = pServiceAppFactory();

      // free to use all instances
      pAppImpl = _AppImpl::GetInstance();

      _ServiceAppImpl* 'pServiceAppImpl' = _ServiceAppImpl::GetInstance();

      // add it as event listner and set app state to initializing
      r = pAppImpl->Construct(pArguments);

      // derive-to-base conversion as _ServiceAppImpl to _IAppImpl
      // pass cpp Onxx funcs to c efl and run app_efl_main
      r = pAppImpl->Execute(pServiceAppImpl); 
    }

  protected:
    ServiceApp(void)
    { __pServiceAppImpl = 'new' (std::nothrow) _ServiceAppImpl('this'); }

  private:
    ServiceApp(const ServiceApp& rhs);
    ServiceApp& operator =(const ServiceApp& rhs);

    class _ServiceAppImpl* __pServiceAppImpl;
}


// _ServiceAppImpl

class _ServiceAppImpl
: public Tizen::Base::Object
, public Tizen::App::_IAppImpl
, public Tizen::Base::Runtime::ITimerEventListener
, virtual public Tizen::Base::Runtime::IEventListener
{
  public:
    static _ServiceAppImpl* GetInstance();
    { return __pServiceAppImpl; }

  private:
    _ServiceAppImpl(ServiceApp* pServiceApp)
      : __pAppImpl(_AppImpl::GetInstance())
        , __pServiceApp(pServiceApp)
        , __pAppTerminatingInternalEventListener(null)
        , __pLifeDurationTimer(null)
        , __lifeDuration(0)
        , __pauseLifeDurationTimer(false)
  {
    __pServiceAppImpl = this;
  }

    ServiceApp*
      _ServiceAppImpl::GetServiceAppInstance(void)
      {
        return __pServiceApp;
      }

    virtual ~_ServiceAppImpl(void);

    static _ServiceAppImpl* __pServiceAppImpl;
    _AppImpl* __pAppImpl;
    ServiceApp* __pServiceApp;
    _IAppEventListener* __pAppTerminatingInternalEventListener;

    friend class ServiceApp;
};


// AppService. client class which is out of framework and namespace.

class AppService
: public Tizen::App::ServiceApp
, public Tizen::App::Package::IPackageInstallationEventListener
, public Tizen::App::_IAppManagerEventListener
, public Tizen::System::IBootEventListener
, virtual public Tizen::Base::Runtime::IEventListener
{

  public:
    // create self
    'static' Tizen::App::ServiceApp* CreateInstance(void)
    {
      // [KT] why static?
      'static' AppService* pAppService = new (std::nothrow) AppService();
      __pAppService = pAppService;

      // convert to base
      return pAppService;
    }

    static AppService* GetAppServiceInstance(void);
    AppService();
    virtual ~AppService();

    // OnXXX interfaces
    virtual bool OnAppInitializing(Tizen::App::AppRegistry& appRegistry);
    ...
      virtual void OnLowMemory(void);

    static AppService* __pAppService;
};

OspMain() {

   result r = Tizen::App::Service::Execute(AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute(AppService::CreateInstance, &args); )
}

int main(int argc, char* pArgv[])
{
   int r = OspMain(argc, pArgv);
}


={============================================================================
*kt_dev_cpp_301* case: wrapper

{example-one} {wrapper}
This is taken from *kt_dev_mecpp_007* to discuss it again: This case is that main is in c and is to
use some features written cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typedefs               {
										  int wraaper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Here wrapper is used to bridge between cpp and c:

int wrapper_func()
{
	ClassX* pclass = new Class( params );

	pclass->func();
	...
}


{example-two} {{add-reference-counting-to-existing-classes}} {wrapper} {forwarding}
How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


={============================================================================
*kt_dev_cpp_302* case: porting layer

{case-one}
The case which use singleton to have a porting layer for different platforms.

├── Interfaces
│   ├── Core
│   │   ├── IPluginRegister.h
│   │   └── SectionDataDefines.h
│   └── PortingLayer (has interface classes)
│       ├── IAPLAppLaunch.h
│       ├── IAPLAVControl.h
│       ├── ...
│       ├── IAPLMutex.h
│       ├── IAPLOSAbstraction.h
│       └── IApplitePortingLayer.h
├
├── PortingLayer (for platform A)
│   ├── Inc (headers for each class which implements each interface
│   │   ├── APLAVController.h
│   │   ├── APLDebug.h
│   │   ├── ...
│   │   ├── APLMutex.h
│   │   ├── APLOSAbstraction.h
│   │   └── ApplitePortingLayer.h
│   └── Src (sources for each class which implements eash interface, functionality)
│       ├── APLAVController.cpp
│       ├── APLDebug.cpp
│       ├── ...
│       └── ApplitePortingLayer.cpp (this is the gate class)


User                 CApplitePortingLayer : publuc IApplitePortingLayer
getInstace()         - get functions to get each interface pointer
Ins->getInterface(); - pointer members for each interface

                     CInterfaceA : public IInterfaceA             CInterfaceB ...
                     - *.h, *.cpp
                     - actual platform specific implementation


class CApplitePortingLayer : public IApplitePortingLayer
{

private:
	///default constructor
	CApplitePortingLayer(){};

public:
	uses singleton
	has all getXXX funcs for each functionality which returns member pointer for each.
	ctor creates all interface classes and set member pointers.

	///This function creates the porting layer interfaces. factory-func
	static CApplitePortingLayer* Instance(CReceiverAppBase* receiver);
	{
		 if (m_singleton == NULL)
		 {
			  m_singleton = new CApplitePortingLayer(receiver);
		 }
		 return m_singleton;
	}

	///This function gets the porting layer interfaces if created.
	static CApplitePortingLayer* GetInstance();
	{
		return m_singleton;
	}
}

Creates all concrete classes which implments interfaces.

CApplitePortingLayer::CApplitePortingLayer(CReceiverAppBase* receiver)
:m_receiver(receiver)
{
	m_graphics =  new CAPLGraphics((IReceiverAppPorting*)receiver, receiver->GetViewIndex());
	m_debug = new CAPLDebug((PCTask*)receiver, receiver->GetTCTv());
	m_mediaManager = new CAPLMediaManager((IReceiverAppPorting*)receiver, receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);		m_OSAbstraction = new CAPLOSAbstraction((IReceiverAppPorting*)receiver, receiver->GetTCTv(), (PCTask*)receiver);
	m_persistentStorage = new CAPLPersistentStorage();
	m_sectionFilter = new CAPLSectionFilter(receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);
	m_serviceInformation = CAPLServiceInformation::Instance((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_systemProperties = new CAPLSystemProperties((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_security = new CAPLSecurity();
	m_serial = new CAPLSerial();
	m_typeface = CAPLTypeface::getInstance();
	m_appLaunch = new CAPLAppLaunch((IReceiverAppPorting*)receiver);

    //initialise curl here, needed for both network and X509 operations
    CAPLCurl::InitCurl();
}

The good thing is that make CApplitePortingLayer singleton and manage other interfaces via it rather
than making every interface a singleton class.

This approach means that each concrete implementation calss, Cxx, implements interfaces and users
will use it directly. If the client is CPP file, that's fine and each Cxx can have typedefs, enums
and so on but if C file then do not work. For C files, each Cxx class provide C function and there
should be a way to share typedefs between CPP and C files. So should be a single header which has
common typedefs for C and CPP land.

Also can use that make all interface concrete class to have private interfaces and make a friend
between CApplitePortingLayer and otheres. That makes only CApplitePortingLayer can create and use
those.

{case-two}
├── OAL (OS AL)
│   ├── Inc
│   │   ├── ...h
│   │   └── ...h
│   └── Src 
│       ├── LINUX (this is folder which has platform implementation)
│       ├── WINDOWS
│       ├── VXWORS
│       ├── ...


={============================================================================
*kt_dev_cpp_304* case: overloads

{overloads-ctor}
Has many ctor overloads to create different SCE objects depending on different event sources.

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos,
   const std::string& lang,
   const NS_IRON_SYSTEM::Event& dttEvent) :
{}


SCE::SCE(shared_ptr<SCE>& dttEvent, shared_ptr<SCE>& masEvent):
{
}

SCE::SCE(shared_ptr<SCE>& masEvent, const uint32_t start_, const uint32_t end_):
{}

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos, const SystemEventWrapper& masEvent) :
{
}

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos, 
    boost::shared_ptr<Service> service_, uint32_t start_, uint32_t end_):
    synopsis(),
{}


{overloads-call-operator}
Likewise, has many () overloads to call () operator depending on arguments. 

ServicePtrVecPtr operator()(
        const std::vector<NS_SYSTEM::Result>& sysServices,
        ServicePtrVecPtr) const;

SummaryResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, SummaryResultSetPtr, uint32_t requestedStartIndex = 0) const;

CategoryResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, CategoryResultSetPtr) const;

PublicationResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, PublicationResultSetPtr) const;

ProgrammePtr operator()(
        const NS_SYSTEM::Result&, ProgrammePtr) const;

FullEventPtr operator()(
        const NS_SYSTEM::Result&, FullEventPtr) const;


# ============================================================================
#{ STL
={============================================================================
*kt_dev_cxx_0000* cxx-stl

http://www.sgi.com/tech/stl/ 

{cxx-stl-design-rationale}
The idea behind the STL is to beat the combinatorial explosion of containers
and functions that implement the same data structures and algorithms without
forcing all program structures to be objects that are all in the same
hierarchy. As long as a type has the needed properties, it works with STL
containers or algorithms, no matter what class hierarchies it is or isn't part
of.

STL provides a collection of such things that are recognized as both useful
and reasonable design. The picky could point out std::string as a
counter-example to good design, here. 


The concept of the STL is based on a `separation of data and operations.` The
data is managed by container classes, and the operations are defined by
configurable algorithms. Iterators are the 'glue' between these two
components.

This STL concept contradicts the original idea of object-oriented programming:
However, the reason for doing so is very important. In principle, you can
combine every kind of container with every kind of algorithm, so the result is
a very 'flexible' but still rather 'small' framework.

One fundamental aspect of the STL is that all components work with 'arbitrary'
types. Thus, the STL is a good example of the concept of `generic programming.`
Containers and algorithms are generic for arbitrary types and classes,
respectively.


{components}

container

Containers are used to manage 'collections' of objects of a certain kind.
Every kind of container has its own advantages and disadvantages, so having
different container types reflects different requirements for collections in
programs.

iterator

Iterators are used to step through the elements of collections of objects. The
major advantage of iterators is that they offer a small but common interface
for any arbitrary container type. 

The interface for iterators is almost the same as for ordinary pointers. To
increment an iterator, you call operator ++. To access the value of an
iterator, you use operator *. 

So, you might consider an iterator a kind of a smart pointer that translates
the call "go to the next element" into whatever is appropriate.

algorithm

Algorithms are used to process the elements of collections. Algorithms use
iterators. Thus, because the iterator interface for iterators is common for
all container types, an algorithm has to be written only once to work with
arbitrary containers.


{cxx-stl-error-handling}
The design goal of the STL was the best performance rather than the highest
security. Error checking wastes time, so almost 'none' is done. Two reasons:

Error checking reduces performance, and speed is still a general goal of
programs. As mentioned, good performance was one of the design goals of the
STL.

If you prefer safety over speed, you can still get it, either by adding
wrappers or by using special versions of the STL. But when error checking is
built into all basic operations, you can't program to avoid error checking to
get better performance. For example, when every subscript operation checks
whether a range is valid, you can't write your own subscripts without
checking.  However, it is possible the other way around.


{exception-handling}
As a result of these discussions, the C++ standard library since C++98 gives
the following basic guarantee for exception safety: The C++ standard library
will not leak resources or violate container invariants in the face of
exceptions.

Regarding this stronger guarantee; atomic with respect to exceptions or
transaction safe, the C++ standard library now guarantees the following:

The library reference, p249 for details.

Note that all these guarantees are based on the requirement that 'destructors'
never throw, which should always be the case in C++. The C++ standard library
makes this promise, and so must the 'application' programmer.

<what-container-consideration> see *cxx-move-conditions*
If you need a container with full commit-or-rollback ability, you should use

either `a list` (without calling or special handling for remove(),
remove_if(), merge(), sort(), and unique()) 

or `an associative/unordered container`
(without calling their multiple-element insert operations). This avoids having
to make copies before a modifying operation to ensure that no data gets lost.
Note that making copies of a container could be very expensive.

If you can't use a node-based container and need the full commit-or-rollback
ability, you have to provide wrappers for each critical operation.


<precondition>
The C++ standard library states that any STL use that violates preconditions
results in undefined behavior because these errors occur at 'runtime', not at
compile time, they cause undefined behavior. In particular, the use of the STL
requires that the following be met:


* `Iterators must be valid` 
For example, they must be initialized before they are used. Note that
iterators may become invalid as a side effect of other operations. In
particular, iterators become invalid

for vectors and deques, if elements are inserted or deleted or reallocation
takes place, and

for unordered containers, if 'rehashing' takes place (which also might be the
result of an insertion).

* Iterators that refer to the past-the-end position have no element to which
to refer. Thus, calling operator * or operator -> is not allowed. This is
especially true for the return values of the end(), cend(), and rend()
  container member functions.

* Ranges must be valid:
Both iterators that specify a range must refer to the same container.
The second iterator must be reachable from the first iterator.

* If more than one source range is used, the second and later ranges usually
must have at least as many elements as the first one.

Destination ranges must have enough elements that can be overwritten;
otherwise, insert iterators must be used.


{cxx-stl-guarantees}
From ESTL 5. The revolutionary aspect of STL is its complexity guarantees
regardless of the STL platform you are using.


{cxx-error} *cxx-include*

when do not include fstream:

c04.cpp:259:14: error: variable ‘std::ifstream ifs’ has initializer but incomplete type
     ifstream ifs{filename};
              ^
c04.cpp:261:14: error: variable ‘std::ofstream ofs’ has initializer but incomplete type
     ofstream ofs{ofilename};
              ^

={============================================================================
*kt_dev_cxx_0000* cxx-pair cxx-tuple

5.1 Pairs and Tuples

{cxx-pair}
The class pair treats two values `as a single unit.` The pair is defined in
<utility> header and the default pair ctor do `value-init` since it will use
T().

As usual, pair class is dependant on type T; menas that dependant on
operations provided by type T.

namesapce cxx_code 
{
  /// Struct holding two objects of arbitrary type.
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;    /// @c first_type is the first bound type
      typedef _T2 second_type;   /// @c second_type is the second bound type

      _T1 first;                 /// @c first is a copy of the first object
      _T2 second;                /// @c second is a copy of the second object

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 265.  std::pair::pair() effects overly restrictive
      /** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
        : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
        : first(__a), second(__b) { }
    };

  // *cxx-pair-make-pair*
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }

} // namespace

See that it is declared as `struct` instead of class so that all members are
public. Here are some operations to see:

pair<T1,T2> p
Default constructor; creates a pair of values of types T1 and T2, initialized
with their default constructors

pair<T1,T2> p(val1,val1)
Creates a pair of values of types T1 and T2, initialized with val1 and val1

pair<T1,T2> p(rv1,rv2)
Creates a pair of values of types T1 and T2, `move initialized` with rv1 and rv2

p.first 
Yields the first value inside the pair (direct member access)

p.second 
Yields the second value inside the pair (direct member access)

*cxx-11* *cxx-get*
get<0>(p) Equivalent to p.first (since C++11)
get<1>(p) Equivalent to p.second (since C++11)


p1 == p2 
Returns whether p1 is equal to p2 (equivalent to p1.first==p2.first &&
    p1.second==p2.second)

p1.swap(p2) Swaps the data of p1 and p2 (since C++11)
swap(p1,p2) Same (as global function) (since C++11)

// cxx-make-pair cxx-template-function
make_pair(val1,val2) 

Returns a pair with types and values of val1 and val2. 
The make_pair() function template enables you to create a value pair 'without'
writing the types explicitly since the type is deduced from.

std::pair<int,char>(42,’@’)
std::make_pair(42,’@’)


<ex>

namespace cxx_pair
{
  template <typename T1, typename T2>
    std::ostream & operator<<(std::ostream &os, std::pair<T1, T2> const & p)
    {
      os << "{" << get<0>(p) << ", " << get<1>(p) << "}";
    }
} // namespace

TEST(Pair, MakePair)
{
  // gcc 4.9.2 emits no error but 6.3.0 emits error:
  //
  // cxx.cpp:36:5: error: direct-list-initialization of ‘auto’ requires exactly
  // one element [-fpermissive] 
  //
  // };
  // ^
  // cxx.cpp:36:5: note: for deduction to ‘std::initializer_list’, use
  // copy-list-initialization (i.e. add ‘ =’ before the ‘{’)
  //
  // const auto pair_map{
  //     make_pair(10, "X"),
  //     make_pair(9, "IX"),
  //     make_pair(5, "V")
  // };

  {
    const auto pair_map{
      make_pair(10, "X"),
      make_pair(9, "IX"),
      make_pair(5, "V")
    };
  
    auto it = pair_map.begin();
    EXPECT_THAT(it->first, 10);
    EXPECT_THAT(it->second, "X");
  }

  {
    std::vector<std::pair<int,bool>> 
        coll{
          {5,false},{3,false},{7,false},
          {1,true},{2,false},{8,false},
          {9,false}};

    auto found_value = std::numeric_limits<size_t>::max();
    decltype(found_value) found_index{}, index{};

    for (auto const &e: coll)
    {
      // if not visited before and see min value
 
      // if (!e.second && e.first < found_value)
      if (!get<1>(e) && get<0>(e) < found_value)
      {
        found_value = get<0>(e);
        found_index = index;
      }

      ++index;
    }

    EXPECT_THAT(found_value, 2);
    EXPECT_THAT(found_index, 4);
  }

  {
    using namespace cxx_pair;

    auto p = make_pair(80, 88);

    cout << p << endl;
  }
}


<cxx-pair-reference>
To force reference semantics, you have to use ref(), *cxx-ref* which forces a
reference type, or cref(), which forces a constant reference type.

TEST(Pair, PackReference)
{
  int i{10};
  int j{20};

  // no connetion between i, j and val pair
  {
    auto val = make_pair(i, j);

    ++val.first;
    ++val.second;

    EXPECT_THAT(val.first, 11);
    EXPECT_THAT(val.second, 21);
    EXPECT_THAT(i, 10);
    EXPECT_THAT(j, 20);
  }

  {
    // *cxx-ref*
    auto val = make_pair(std::ref(i), std::ref(j));

    ++val.first;
    ++val.second;

    EXPECT_THAT(val.first, 11);
    EXPECT_THAT(val.second, 21);

    // they are changed now
    EXPECT_THAT(i, 11);
    EXPECT_THAT(j, 21);
  }
}


*cxx-pair-comparison*
namespace cxx_code
{
  // /usr/include/c++/4.9/bits/stl_pair.h

  /// Two pairs of the same type are equal iff their members are equal.
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }

  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
  template<class _T1, class _T2>
    inline _GLIBCXX_CONSTEXPR bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }

} // namespace


In a comparison of pairs, the first value has higher priority. Thus, if the
first values of two pairs differ, the result of their comparison is used as
the result of the overall comparison of the pairs. If the members first are
equal, the comparison of the members second yields the overall result:


<ex>

TEST(Pair, Comparison)
{
  {
    auto p1 = make_pair(1, 2);
    auto p2 = make_pair(3, 2);

    EXPECT_THAT(p1 > p2, false);
    EXPECT_THAT(p1 < p2, true);
  }

  {
    auto p1 = make_pair(1, 2);
    auto p2 = make_pair(1, 3);

    EXPECT_THAT(p1 > p2, false);
    EXPECT_THAT(p1 < p2, true);
  }

  {
    auto p1 = make_pair(13, 2);
    auto p2 = make_pair(13, 4);

    EXPECT_THAT(p1 > p2, false);
    EXPECT_THAT(p1 < p2, true);
  }
}


{cxx-tuple} *cxx-make-tuple*
Tuples extends the concept of pairs to an 'arbitrary' number of different
types.

<ex>

#include <tuple>

// tup1: 41 6.3 nico 
// tup2: 22 44 two 
// tup1: 41 44 nico 
// tup1 is bigger than tup2
// tup1: 22 44 two 

TEST(Tuple, MakeTuple)
{
  tuple<int, float, string> tup1{41, 6.3, "nico"};

  cout << "tup1: ";
  cout << get<0>(tup1) << " ";
  cout << get<1>(tup1) << " ";
  cout << get<2>(tup1) << " " << endl;

  auto tup2 = make_tuple(22, 44, "two");

  cout << "tup2: ";
  cout << get<0>(tup2) << " ";
  cout << get<1>(tup2) << " ";
  cout << get<2>(tup2) << " " << endl;;

  get<1>(tup1) = get<1>(tup2);

  cout << "tup1: ";
  cout << get<0>(tup1) << " ";
  cout << get<1>(tup1) << " ";
  cout << get<2>(tup1) << " " << endl;;

  if( tup1 > tup2 )
  {
    cout << "tup1 is bigger than tup2" << endl;
    tup1 = tup2;
  }

  cout << "tup1: ";
  cout << get<0>(tup1) << " ";
  cout << get<1>(tup1) << " ";
  cout << get<2>(tup1) << " " << endl;;
}


<iteration>
A tuple is no ordinary container class where you can iterate over the elements.
Instead, you have to know the `index` of elements you want to access at compile
time. Passing an index at runtime is 'not' possible:

int i;
get<i>(t1) // compile-time error: i is no compile-time value

The good news is that it is also a compile-time error to pass an 'invalid'
index:

get<3>(t1) // compile-time error if t1 has only three elements


{cxx-tie}
`Creates a tuple of references`, which allows extracting (individual) values
out of a tuple. So getting values out of tuple is easy than using get<x>.

TEST(Tuple, Tie)
{
  {
    tuple<int, float, string> tup1{41, 6.3, "nico"};
    int i;
    float f;
    string s;

    auto tup = make_tuple(std::ref(i), std::ref(f), std::ref(s));

    // if prints out tup here before assigning value, then do not get tup1's
    // value and see undefined value instead. referece?

    tup = tup1;

    // shows the same

    EXPECT_THAT(get<0>(tup), 41);
    EXPECT_THAT(get<1>(tup), 6.3);
    EXPECT_THAT(get<2>(tup), "nico");

    EXPECT_THAT(i, 41);
    EXPECT_THAT(f, 6.3);
    EXPECT_THAT(s, "nico");

    // changes both tup and i,f,s

    i = 51; f = 7.3; s = "nico nico";

    EXPECT_THAT(get<0>(tup), 51);
    EXPECT_THAT(get<1>(tup), 7.3);
    EXPECT_THAT(get<2>(tup), "nico nico");

    EXPECT_THAT(i, 51);
    EXPECT_THAT(f, 7.3);
    EXPECT_THAT(s, "nico nico");
  }

  // cxx-tie do the same
  {
    tuple<int, float, string> tup1{41, 6.3, "nico"};
    int i;
    float f;
    string s;

    auto tup = tie(i, f, s);
    tup = tup1;

    // shows the same

    EXPECT_THAT(get<0>(tup), 41);
    EXPECT_THAT(get<1>(tup), 6.3);
    EXPECT_THAT(get<2>(tup), "nico");

    EXPECT_THAT(i, 41);
    EXPECT_THAT(f, 6.3);
    EXPECT_THAT(s, "nico");

    // changes both tup and i,f,s

    i = 51; f = 7.3; s = "nico nico";

    EXPECT_THAT(get<0>(tup), 51);
    EXPECT_THAT(get<1>(tup), 7.3);
    EXPECT_THAT(get<2>(tup), "nico nico");

    // more convenient way to access

    EXPECT_THAT(i, 51);
    EXPECT_THAT(f, 7.3);
    EXPECT_THAT(s, "nico nico");
  }
}


The use of std::ignore allows ignoring tuple elements while parsing with tie().
This can be used to extract tuple values partially:

std::tuple <int,float,std::string> t(77,1.1,"more light");

int i;
std::string s;

// assigns first and third value of t to i and s
std::tie(i, std::ignore, s) = t;


<cxx-tuple-init>
The constructor taking a variable number of arguments to initialize a tuple is
declared as 'explicit':

namespace std {
  template <typename... Types>
    class tuple {
      public:
        explicit tuple(const Types&...);
        template <typename... UTypes> explicit tuple(UTypes&&...);
        ...
    };
}

This situation, however, has consequences when using initializer lists to
define values of a tuple. For example, you can't use the assignment syntax to
initialize a tuple because that is considered to be an implicit conversion:

std::tuple<int,double> t1(42, 3.14);    // OK, old syntax
std::tuple<int,double> t2{42, 3.14};    // OK, new syntax
std::tuple<int,double> t3 = {42, 3.14}; // ERROR, Why? *cxx-copy-form-init*


std::vector<std::tuple<int,float>> v { {1,1.0}, {2,2.0} }; // ERROR

std::tuple<int,int,int> foo() {
  return { 1, 2, 3 }; // ERROR
}


std::vector<std::pair<int,float>> v1 { {1,1.0}, {2,2.0} }; // OK

std::vector<int> foo2() {
  return { 1, 2, 3 }; // OK
}

For tuples, you have to 'explicitly' convert the initial values into a tuple

std::vector<std::tuple<int,float>> 
  v { std::make_tuple(1,1.0), std::make_tuple(2,2.0) }; // OK

std::tuple<int,int,int> foo() {
  return std::make_tuple(1,2,3); // OK
}


<ex>
TEST(Pair, Initialisation)
{
  // initializer_list that has pairs
  
  // gcc 4.9.2 is fine but 6.3.0 emits error:
  //
  // cxx.cpp:36:5: error: direct-list-initialization of ‘auto’ requires exactly
  // one element [-fpermissive] 
  //
  // };
  // ^
  // cxx.cpp:36:5: note: for deduction to ‘std::initializer_list’, use
  // copy-list-initialization (i.e. add ‘ =’ before the ‘{’)          
  //
  // const auto pair_map{
  //     make_pair(10, "X"),
  //     make_pair(9, "IX"),
  //     make_pair(5, "V")
  // };

  const auto pair_init_01{
    make_pair(10, "X"),
    make_pair(9, "IX"),
    make_pair(5, "V")
  };

  const auto pair_init_02 = {
    make_pair(10, "X"),
    make_pair(9, "IX"),
    make_pair(5, "V")
  };

  // vector that has pairs

  std::vector<std::pair<int,string>> pair_init_03{
    make_pair(10, "X"),
    make_pair(9, "IX"),
    make_pair(5, "V")
  };

  std::vector<std::pair<int,string>> pair_init_04{
    {10, "X"},
    {9, "IX"},
    {5, "V"}
  };

  // vector that has tuples

  std::vector<std::tuple<int, string, int>> tuple_init_01{
    make_tuple(10, "X", 1),
    make_tuple(9, "IX", 2),
    make_tuple(5, "V", 3)
  };

  // cxx.cpp:165:3: error: converting to ‘std::tuple<int,
  // std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
  // int>’ 
  //
  // from initializer list would use explicit constructor ‘constexpr std::tuple<
  // <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements =
  // {int, const char (&)[2], int}; <template-parameter-2-2> = void; _Elements =
  // {int, std::basic_string<char, std::char_traits<char>, std::allocator<char>
  //
  // >, int}]’
  //    };
  //    ^
  //
  // why error fot both? However, std-pair has no explicit ctors
  //
  // /usr/include/c++/4.9/tuple
  // /// Primary class template, tuple
  // template<typename... _Elements> 
  //   class tuple : public _Tuple_impl<0, _Elements...>
  //   {
  //     typedef _Tuple_impl<0, _Elements...> _Inherited;
  //
  //     explicit
  //     constexpr tuple(const _Elements&... __elements)
  //     : _Inherited(__elements...) { }
  //
  // std::vector<std::tuple<int,string, int>> tuple_init_02{
  //   {10, "X", 1},
  //   {9, "IX", 2},
  //   {5, "V", 3}
  // };
  //
  // std::vector<std::tuple<int,string, int>> tuple_init_02 = {
  //   {10, "X", 1},
  //   {9, "IX", 2},
  //   {5, "V", 3}
  // };
  
}


<tuple-print>
The tuple class was first made public in the 'boost' library. There, tuple had
an interface to write values to output streams, but there is no support for this
in the C++ standard library. With the following header file, you can print any
tuple with the standard output operator <<

#include <iostream>
#include <tuple>

using namespace std;

// helper: print element with index IDX of tuple with MAX elements
template <int IDX, int MAX, typename... Args>
struct PRINT_TUPLE {
  static void print( std::ostream& strm, const std::tuple<Args...> &t)
  {
    strm << std::get<IDX>(t) << (IDX+1==MAX ? "" : ",");
    PRINT_TUPLE<IDX+1, MAX, Args...>::print(strm, t);
  }
};

// partial specialization to end the recursion
template <int MAX, typename... Args>
struct PRINT_TUPLE<MAX, MAX, Args...>
{
  static void print( std::ostream& strm, const std::tuple<Args...>& t)
  {}
};

template <typename... Args>
std::ostream& operator<<( std::ostream& strm, const std::tuple<Args...> &t)
{
  strm << "[";
  PRINT_TUPLE<0, sizeof...(Args), Args...>::print(strm, t);
  return strm << "]";
}


int main()
{
  tuple<int, float, string> t1( 41, 6.3, "nico" );
  cout << "io: " << t1 << endl; 
}


This code makes heavy use of template metaprogramming to recursively iterate
at compile time over the elements of a tuple. Each call of
PRINT_TUPLE<>::print() prints one element and calls the same function for the
next element. A partial specialization, where the current index IDX and the
number of elements in the tuple MAX are equal, ends this recursion.


={============================================================================
*kt_dev_cxx_0000* cxx-minmax cxx-min cxx-max

cxx-max is inline function and not macro and see *algo-minmax*

namespace cxx_code
{
  // /usr/include/c++/4.9/bits/stl_algobase.h
  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The greater of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
   */
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
        //return  __a < __b ? __b : __a;
        if (__a < __b)
          return __b;
      return __a;
    }

  /**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  `__comp`  A @link comparison_functors comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
   */
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      //return __comp(__a, __b) ? __b : __a;
      if (__comp(__a, __b))
        return __b;
      return __a;
    }
}


={============================================================================
*kt_dev_cxx_0000* cxx-ref

CXXSLR-5.4.3 Reference Wrappers

Class std::reference_wrapper<>, declared in <functional>, is used primarily to
"feed" references to function templates that take their parameter by value.

For a given type T, this class provides ref() for an implicit conversion to T&
and cref() for an implicit conversion to const T&, which usually allows
function templates to work on references `without cxx-template-specialization`

<ex>

namespace cxx_template_reference
{
  template <typename T>
    void foo(T value)
    {
      ++value;
    }
} // namespace

TEST(Template, Reference)
{
  using namespace cxx_template_reference;

  int value{10};

  foo(value);
  EXPECT_THAT(value, 10);

  foo(std::ref(value));
  EXPECT_THAT(value, 11);
}


This feature is used by the C++ standard library at various places. For example:

o make_pair() uses this to be able to create a pair<> of references
o make_tuple() uses this to be able to create a tuple<> of references
o Binders use this to be able to bind references
o Threads use this to pass arguments by reference


={============================================================================
*kt_dev_cxx_0000* cxx-coll

According to the way the order of elements is defined. See difference between
`ordered` and `sorted` term.


{cxx-coll-sequence}
`sequence-containers` are `ordered-collections` in which every element has a
certain `position`. This position depends on the time and place of the
insertion, but it is `independent` of the value of the element. 

For example, if you put six elements into an ordered collection by appending
each element at the end of the collection, these elements are in the 'exact'
`insert-order` in which you put them.

array, vector, deque, list, and forward_list.


{cxx-coll-associative}
`associative-containers` are `sorted-collections` in which the position of an
element depends on its 'value' (or key, if it’s a key/value pair) due to a
certain 'sorting' criterion. 

If you put six elements into a collection, their 'value' determines their
order. The order of insertion doesn't matter. atomatic sorting.

set, multiset, map, and multimap.


{cxx-coll-associative-unordered}
`unordered-containers` (associative) containers are 'unordered' collections in
which the position of an element doesn't matter. The only important question
is whether a specific element is 'in' such a collection.

Thus, if you put six elements into a collection, their order is undefined and
might change over time. 

unordered_set, unordered_multiset, unordered_map, and unordered_multimap.


{cxx-coll-implementation}
Sorted collections have the additional ability to be ordered according to a
sorting criterion.

However, the STL collection types are completely distinct from one another and
have very different implementations that are not derived from one another. As
we will see:

o Sequence containers are usually implemented as arrays or linked lists.
o Associative containers are usually implemented as binary trees.
o Unordered containers are usually implemented as hash tables.

The particular implementation of any container is not defined by the C++
standard library. However, the behavior and complexity specified by the
standard do not leave much room for variation. So, in practice, the
implementations differ only in minor details.


={============================================================================
*kt_dev_cxx_0000* cxx-coll-performance

{cxx-amortized}
Some complexity definitions in the C++ reference manual are specified as
amortized. This means that the operations in the long term behave as
described.  However, a single operation may take longer than specified. 

For example, if you append elements to a dynamic array, the runtime depends on
whether the array has enough memory for one more element. If there is enough
memory, the complexity is constant because inserting a new last element always
takes the same time. However, if there is not enough memory, the complexity is
linear because, depending on the number of elements, you have to allocate new
memory and copy all elements. 

Reallocations are rather rare, so any sufficiently long sequence of that
operation behaves as if each operation has constant complexity. Thus, the
complexity of the insertion is 'amortized' constant time.


*algo-bigo*

C++PL 894

List refers to insertion and deletion not necessarily at the ends of a
container.

+ suffix indicates that occasionally a significant extra cost incurred and
means armortized.

// what does empty mean?

                    []              List      Front     Back      Iterators
vector              const,O(1)      O(n)+               const+    `random`
list                                const     const     const     bi
deque               const,O(1)      O(n)      const     const     random

map                 O(log(n))       O(log(n))+                    bi
multimap                            O(log(n))+                    bi
set                                 O(log(n))+                    bi
multiset                            O(log(n))+                    bi

unordered_map       const+          const+                        forward 
unordered_multimap                  const+                        forward 
unordered_set                       const+                        forward 

string              `const,O(1)`      O(n)+     O(n)+     const+    `random`


<contiguous-and-node-based> the other criteria
string, vector, deque, and array uses `contiguous memory` Hence, insert/delete
in the middle can be expensive since have to move elements but fast access.

// TODO: incomplete sentence
All node-based containers (lists, forward lists, sets, multisets, maps, and
multimaps), including the unordered containers,


However, it contains 'general' statements that might not fit in reality. For
example, if you manage only a few elements, you can ignore the complexity
because short element processing with linear complexity is better than long
element processing with logarithmic complexity (in practice, "few" might
    become very large here).  

As a supplement to the table, the following rules of thumb might help:

1. By 'default', you should use a 'vector'. It has the simplest internal data
structure and provides random access. Thus, data access is convenient and
flexible, and data processing is often fast enough.

2. If you insert and/or remove elements often at the beginning and the end of
a sequence, you should use a 'deque'. You should also use a deque if it is
important that the amount of internal memory used by the container shrinks
when elements are removed. Also, because a vector usually uses one block of
memory for its elements, a deque might be able to contain more elements
because it uses several blocks. 

3. If you insert, remove, and move elements often in the middle of a
container, consider using a 'list'. Lists provide special member functions to
move elements from one container to another in constant time. Note, however,
that because a list provides no random access, you might suffer significant
  performance penalties on access to elements inside the list if you have only
  the beginning of the list.

Like all node-based containers, a list doesn't invalidate iterators that refer
to elements, as long as those elements are part of the container. Vectors
invalidate all their iterators, pointers, and references whenever they exceed
their capacity and part of their iterators, pointers, and references on
insertions and deletions. Deques invalidate iterators, pointers, and
references when they change their size, respectively.


4. If you need a container that handles 'exceptions' so that each operation
either succeeds or has no effect, you should use either a list or an
associative/unordered container. 

note all node-based see *cxx-move-conditions*


5. If you often need to 'search' for elements according to a certain
criterion, use an 'unordered' set or multiset that hashes according to this
criterion. However, hash containers have no ordering, so if you need to rely
on element order, you should use a set or a multiset that sorts elements
according to the search criterion.

6. To process key/value 'pairs', use an unordered (multi)map or, if the
element order matters, a (multi)map.

7. If you need an 'associative' array, use an unordered map or, if the element
order matters, a map.

8. If you need a 'dictionary', use an unordered multimap or, if the element
order matters, a multimap.


In practice, predicting which container type is the best is often difficult. 

see *cxx-stl-design-rationale*

The big 'advantage' of the STL is that you can try different versions
'without' much effort. The major work - implementing the different data
structures and algorithms - is done. You have only to combine them in a way
that is best for you.


={============================================================================
*kt_dev_cxx_0000* cxx-coll-element-type

CXXSLR-244

Containers, iterators, and algorithms of the STL are templates. Thus, they can
process both predefined or user-defined types. However, because of the
operations that are called, some requirements apply. The elements of STL
containers must meet the following `three fundamental requirements`:

o An element must be 'copyable' or 'movable'. 

Thus, an element type implicitly or explicitly has to provide a copy or move
constructor. A generated copy should be equivalent to the source. This means
that any test for equality returns that both are equal and that both source
and copy behave the same.

o An element must be (move) 'assignable' by the assignment operator. 

Containers and algorithms use assignment operators to overwrite old elements
with new elements.

o An element must be 'destroyable' by a destructor. 

Containers destroy their internal copies of elements when these elements are
removed from the container. Thus, the destructor must not be private. Also, as
usual in C++, a destructor must not throw; otherwise, all bets are off.

*cxx-ctor-default*
These three operations are generated implicitly for any class. Thus, a class
meets the requirements automatically, provided that no special versions of
these operations are defined and no special members disable the sanity of
those operations.

Elements might also have to meet the following requirements:

* For some member functions of sequence containers, the default constructor
must be available. For example, it is possible to create a nonempty container
or increase the number of elements with no hint of the values those new
elements should have. These elements are created without any arguments by
calling the default constructor of their type.

* For several operations, the test of equality with operator == must be
defined and is especially needed when elements are searched. For unordered
containers, however, you can provide your own definition of equivalence if the
elements do not support operator == (see Section 7.9.7, page 379).
*cxx-map-element-type*

o For cxx-coll-associative, the operations of the sorting criterion must be
  provided by the elements. By default, this is the operator <, which is
  called by the *cxx-less* function object.

* For unordered containers, a hash function and an equivalence criterion must
be provided for the elements. See Section 7.9.2, page 363, for details.


{cxx-coll-associative-requirement-on-key-type} 
C++P 425. The ordered container uses opearator<() for ordering relation which
defines so called "strick weak ordering":

"equivalent" means:
  Neither two keys "less than" the other, then those are "equivalent"

Here the library *cxx-less*

namespace std {
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
};


{cxx-coll-value-reference-semantics}
STL containers provide `cxx-coll-value` semantics. The containers contain the
values of the objects you insert rather than the objects themselves. In
practice, however, you may also need 'reference' semantics. This means that
the containers contain references to the objects that are their elements.

The approach of the STL to support only value semantics has both strengths and
weaknesses.

<pros>
o Copying elements is simple.

o References are error prone. 
  You must ensure that references don't refer to objects that no longer exist.
  You also have to manage circular references, which might occur.

<cons>
o Copying elements might result in bad performance or may not even be
  possible.

o Managing the same object in several containers at the same time is not
  possible.

*cxx-sp*
Unfortunately, there is no support for reference semantics in the C++ standard
library. However, you can implement reference semantics in terms of value
semantics. The obvious approach to implementing reference semantics is to use
pointers as elements. However, ordinary pointers have the usual problems. A
better approach is to use a kind of smart pointer.


={============================================================================
*kt_dev_cxx_0000* cxx-coll-common-operations

Usually, the STL containers provide only those special member functions that
in general have "good" performance, where "good" normally means constant or
logarithmic complexity. This prevents a programmer from calling a function
that might cause bad performance.

<cxx-emplace>
Here c means container and the emplace_* construct a object `directly` in a
container `rather then copying from a temporary`

c.emplace_back( "978-3403", 25, 15.99 );
c.push_back( Sales_data("978-3403", 25, 15.99) );  // *cxx-temporary*

*cxx-begin-array*

// initialize-from-c-array from *cxx-11* supports std::begin()

int intarr[] = { 0, 1, ... };
vector<int> ivec(std::begin(intarr), std::end(intarr));


// *cxx-list-init* *cxx-11*

ContType c(initlist)
ContType c = initlist

vector<string> articles = { "a", "an", "the" };
vector<string> articles{ "a", "an", "the" };

// from-range
ContType c(beg,end)
Creates a container and initializes it with copies of all elements of
[beg,end) (not for array<>)

When initialize a container from other container, container and 'element' type
  must be indentical. The constructor for a given range provides the ability
  to initialize the container with elements of another container if there is
  an automatic conversion from the source element type to the destination
  element type.

vector<const char*> articles = { "a", "an", "the" };
forward_list<string> words (articles.begin(), articles.end());


// *cxx-11* *cxx-move-iterator*
std::list<std::string> l;

// move all elements of the list into a vector
std::vector<std::string> c(std::make_move_iterator(l.begin()),
                           std::make_move_iterator(l.end()) );


ContType c(rv)
ContType c = rv
Move constructor; creates a new container, taking the contents of the rvalue
rv (since C++11; not for array<>)

std::vector<int> v1;

// move contents of v1 into v2, state of v1 undefined afterward
std::vector<int> v2 = std::move(v1);


<cxx-coll-op-cxx-push-back>
provided for `all cxx-coll-sequence,` where appending an element is possible
and reasonably fast.

coll.push_back(i);


<cxx-coll-op-cxx-cxx-size-cxx-empty>
size() is provided for any container class except forward_list because it
couldn't have constant complexity there.

coll.size();

empty() returns whether the number of elements is zero (begin()==end()). 

*cxx-remember* *cxx-empty*
Prefer empty() over size()==0, because it might be implemented more
efficiently than size(), and size() is not provided for forward lists.


<cxx-coll-op-cxx-cxx-resize>
is used to change the number of elements except array including increse from
size 0. If the size grows, you can pass an additional parameter to specify the
value of the 'new' elements. Otherwise, use default ctor.

coll.resize(10,99);


<cxx-coll-op-cxx-cxx-comparison>
For all but unordered containers, the usual comparison operators ==, !=, <,
    <=, >, and >= are defined according to the following three rules:

o Both containers must have the same 'type'.

o Two containers are equal if their elements are 'equal' and have the same
  'order'. To check equality of elements, operator == is used.

o To check whether a container is less than another container, a
  lexicographical comparison is done

For unordered containers, only the operators == and != are defined. They
return true when each element in one container has an equal element in the
other container. The order doesn't matter (that's why they are unordered
containers).


<cxx-coll-op-clear>
Removes all elements (empties the container; not for array<>)


7.1.2 Container Operations

<cxx-coll-op-cxx-assign> constant complexity

c = c2         
Assigns all elements of c2 to c

c = rv         
Move assigns all elements of the rvalue rv to c (since C++11; not for array<>)

c = initlist   
Assigns all elements of the initializer list initlist (since C++11; not for
array<>)

If you assign containers, you 'copy' all elements of the source container and
remove all old elements in the 'destination' container. Thus, assignment of
containers is relatively 'expensive'.


<ex> cxx-vector-assign

void GetVectorArg(const vector<int> &coll)
{
  vector<int> coll_;

  coll_ = coll;

  ASSERT_THAT(coll_.size(), 6);
}

TEST(Vector, CopyAndMoveAssign)
{
  // assign
  {
    vector<int> coll1{1,2,3,4,5,6};
    vector<int> coll2{};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 0);

    coll2 = coll1;

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 6);
  }

  // assign
  {
    vector<int> coll1{1,2,3,4,5,6};
    vector<int> coll2{};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 0);

    coll2 = {1,2,3,4,5,6};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 6);
  }

  // move
  {
    vector<int> coll1{1,2,3,4,5,6};
    vector<int> coll2{};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 0);

    coll2 = std::move(coll1);

    ASSERT_THAT(coll1.size(), 0);
    ASSERT_THAT(coll2.size(), 6);
  }

  // assign
  {
    vector<int> coll1{1,2,3,4,5,6};
    GetVectorArg(coll1);
  }
}


<cxx-coll-op-cxx-swap> constant complexity
Since C++98, 'all' containers provide a swap() 'member' function to swap
contents of two containers. In fact, it swaps only some 'internal' pointers
that refer to the data (elements, allocator, sorting criterion, if any). So,
     swap() is guaranteed to have only 'constant' complexity, not the linear
     complexity of a copy assignment.

Iterators and references to elements of a container follow swapped elements.
After swap(), iterators and references 'still' refer to the elements they
referred to before, `which, however, are in a different container then.`

c1.swap(c2) Swaps the data of c1 and c2
swap(c1,c2) Swaps the data of c1 and c2

note: that for containers of type array<>, the behavior of swap() is slightly
different. Because you can't internally just swap pointers, swap() has
'linear' complexity, and iterators and references refer to the same container
but different elements afterward. <Q> only for array?


<cxx-coll-op-cxx-subscript>
The operator[] has different sementics in sequential and associative.

*cxx-reference*

s[n]  return a reference to the element at position n in string.
v[n]  return a reference to the element at position n in vector.

cxx-coll-sequential

The index must be 'in' range as C array does. The operator does 'not' check
whether the index is in range and the program must ensure that the index is
valid. To ensure that can use at() that throws `out_of_range` if the index is
invalid.

  A safer way to access a character is to use the at() member function.
  However, such a check costs runtime, so the check is 'not' provided for the
  usual accessing of characters of a string.


cxx-coll-associative

As explained in `cxx-coll-associative`, since not having an element for an
index is not an error, so insert a new element. Also use at() not to insert
element accidentally in which throw out_of_range.


={============================================================================
*kt_dev_cxx_0000* cxx-coll-insert-coll-erase cxx-iter-invalidate

There are some differences between containers as to what to return from insert
and erase and arguments. 


{cxx-vector-insert-cxx-vector-erase} cxx-insert cxx-erase

`where, pos, beg, end are iterators`

Table 7.14. Insert and Remove Operations of Vectors

c.push_back(elem)       Appends a copy of elem at the end
c.pop_back()            `Removes` the last element (`does not return it`)

c.insert(pos,elem)      Inserts a copy of elem before `iterator position pos` and
                        returns the position of the new element

c.insert(pos,n,elem)    Inserts n copies of elem before iterator position pos
                        and returns the position of the first new element (or
                        pos if there is no new element)

c.insert(pos,beg,end)   Inserts a copy of all elements of the range [beg,end)
                        before iterator position pos and returns the position
                        of `the first new element` (or pos if there is no new
                        element)

c.insert(pos,initlist)  Inserts a copy of all elements of the initializer list
                        initlist before iterator position pos and returns the
                        position of the first new element (or pos if there is
                        no new element; since C++11)

c.erase(pos)            Removes the element at iterator position pos and
                        `returns the position of the next element`

c.erase(beg,end)        Removes all elements of the range [beg,end) and
                        `returns the position of the next element`

c.resize(num)           Changes the number of elements to num (if size() grows new
                        elements are created by their default constructor)

c.resize(num,elem)      Changes the number of elements to num (if size() grows
                        new elements are copies of elem)

*cxx-vector-clear*
c.clear()               Removes all elements (empties the container)


{cxx-set-insert-cxx-set-erase} cxx-insert cxx-erase
All elements in set are considered `constant`. Means that iterators are also
constant:

o Cannot call any 'modifying' algorithm on the elements of a set or a
  multiset. 

o To change the key of an element, you have only one choice: You must replace
  the old element with a new element that has the same value.


Table 7.39. Insert and Remove Operations of Sets and Multisets

c.insert(val)       Inserts a copy of val and returns the position of the new
                    element and, for sets, whether it succeeded

`c.insert(pos,val)`   Inserts a copy of val and returns the position of the new
                    element (pos is used as a hint pointing to where the
                    insert should start the search)

note: 
cxx-set use position argument? `used it as a hint` However, containers are free
to ignore it. The prime purpose is that you have one insert function that has
the same interface for all container types. Remember `sequence-container` use
insert(pos, val)


c.insert(beg,end)
Inserts a copy of all elements of the range [beg,end) (returns nothing)

c.insert(initlist)
Inserts a copy of all elements in the initializer list initlist (returns
nothing; since C++11)


*cxx-emplace*
c.emplace(args...)
Inserts a copy of an element initialized with args and returns the position of
the new element and, for sets, whether it succeeded (since C++11)


c.erase(val)        Removes `all elements` equal to val and returns the number
                    of removed elements

c.erase(pos)        Removes the element at iterator position pos and 
                    `returns the following position` 
                    (`returned nothing before C++11`)

c.erase(beg,end)    Removes all elements of the range [beg,end) and 
                    `returns the following position` 
                    (`returned nothing before C++11`)

c.clear()           Removes all elements (empties the container)


<cxx-set-insert-different-return> *cxx-map-insert*
The return types of the inserting functions insert() and emplace() differ as
follows:

`cxx-set` provide the following interface:

o `cxx-set and cxx-map do not allow duplicates.` If they can’t insert the value
  because an element with an equal value or key exists, they return the
  position of the existing element and false. If they can insert the value,
  they `return the position of the new element and true.`

pair<iterator,`bool`>  insert (const value_type& val);
*cxx-insert* when key is unique

iterator             insert (const_iterator posHint, const value_type& val);
*cxx-insert* when key is not unique

template <typename... Args> pair<iterator, `bool`> 
  emplace (Args&&... args);
template <typename... Args> iterator 
  emplace_hint (const_iterator posHint, Args&&... args);

The bool in return is only for set since insert in multiset always succeed.
multisets allow duplicates, whereas sets do not. Thus, the insertion of an
element might fail for a set if it already contains an element with the same
value. Therefore, the return type for a set returns two values by using a pair
structure

* The member second of the pair structure returns whether the insertion was
  successful.

* The member first of the pair structure returns the position of the newly
  inserted element or the position of the still existing element.


`cxx-multiset` provide the following interface:

* Containers that allow duplicates, (unordered) multisets and multimaps. They
  return the position of the new element. Since C++11, newly inserted elements
  are guaranteed to be placed at the end of existing equivalent values.

iterator insert (const value_type& val);
iterator insert (const_iterator posHint, const value_type& val);

template <typename... Args> iterator 
  emplace (Args&&... args);
template <typename... Args> iterator 
  emplace_hint (const_iterator posHint, Args&&... args);


{cxx-map-insert-cxx-map-erase} cxx-insert cxx-erase
Unlike set, maps provide a more convenient way to modify the key of an
element. Instead of calling replace_key(), you can simply write the following:

// insert new element with value of old element
coll["new_key"] = coll["old_key"];

Table 7.45. Insert and Remove Operations of Maps and Multimaps

c.insert(val)       Inserts a copy of val and returns the position of the new
                    element and, for maps, whether it succeeded

`c.insert(pos,val)`   Inserts a copy of val and returns the position of the new
                    element (pos is used as a `hint` pointing to where the
                    insert should start the search)

c.insert(beg,end)   Inserts a copy of all elements of the range [beg,end)
                    (returns nothing)

c.insert(initlist)  Inserts a copy of all elements in the initializer list
                    initlist (returns nothing; since C++11)

c.erase(val)        Removes all elements equal to val and returns the number
                    of removed elements

c.erase(pos)        Removes the element at iterator position pos and
                    `returns the following position` 
                    (`returned nothing before C++11`)

c.erase(beg,end)    Removes all elements of the range [beg,end) and 
                    `returns the following position` 
                    (`returned nothing before C++11`)

c.clear()           Removes all elements (empties the container)

coll.insert( { word, 1} );    // *cxx-map-insert* *C++11* most convenient way
coll.insert( std::map<std::string,int>::value_type( word, 1) );
coll.insert( decltype(coll)::value_type( word, 1) );
coll.insert( make_pair(word, 1) );
coll.insert( pair<string, size_t>(word, 1) );

<ex>
As with set, different return applies to map as well.

TEST(Map, Insert)
{
  // cannot be a const map since operator[] is for non-const.
  map<unsigned int, string> pmap{ 
    {1, "one"}, {2, "two"}, {3, "three"}, {4, "four"}
  };

  // PRINT_M_ELEMENTS(pmap);

  pmap[3] = "threee";
  pmap[3] = "threeee";
  pmap[3] = "threeeee";
  pmap[3] = "threeeeee";

  ASSERT_THAT(pmap[3], Eq("threeeeee"));

  // PRINT_M_ELEMENTS(pmap);

  pmap.insert({3, "third"});
  pmap.insert({3, "thirdd"});
  pmap.insert({3, "thirddd"});
  pmap.insert({3, "thirdddd"});

  ASSERT_THAT(pmap[3], Eq("threeeeee"));
}


<cxx-insert-return-position>
The text reads: 
  "c.insert(pos, elem): inserts a copy of elem 'before' iterator pos and
  returns the position of the new element"

   [ pos-1 ] [ pos ] [pos+1]

insert invalidate iterator from pos since they are after the insertion point.


{cxx-list-insert-cxx-list-erase}

Table 7.24. Insert and Remove Operations of Lists

c.insert(pos,n,elem)    Inserts n copies of elem before iterator position pos
                        and returns the position of the first new element (or
                        pos if there is no new element)

c.insert(pos,beg,end)   Inserts a copy of all elements of the range [beg,end)
                        before iterator position pos and returns the position
                        of the first new element (or pos if there is no new element)

c.insert(pos,initlist)  Inserts a copy of all elements of the initializer list
                        initlist before iterator position pos and returns the
                        position of the first new element (or pos if there is
                        no new element; since C++11)

*cxx-emplace*
c.emplace(pos,args...) 
Inserts a copy of an element initialized with args before iterator position
pos and returns the position of the new element (since C++11)

c.emplace_back(args...) 
Appends a copy of an element initialized with args at the end 
(returns nothing; since C++11)

`c.emplace_front`(args...) 
Inserts a copy of an element initialized with args at the beginning 
(returns nothing; since C++11)

c.erase(pos)      Removes the element at iterator position pos and returns the
                  position of the next element

c.erase(beg,end)  Removes all elements of the range [beg,end) and returns the
                  position of the next element


<ex>
*cxx-remember*  *cxx-off-the-end*
*end() is always error and use of end() is okay.

vec<int> veci;
veci.push_back(1); .. to (3); // [1,2,3,E)
veci.insert( veci.end(), 4 );

1 2 3 4

<ex> enter 1, 2, 3
list<string> lst;
auto iter = lst.begin();

while( cin >> word )
   iter = lst.insert( iter, word ); // or lst.push_front(word);

3 2 1 

// no iter update
while(...)
   lst.insert(iter, word);

1 2 3

In the latter case, iter remains the same, `cxx-off-the-end`, in list and
works fine. However, this approach will creates core dump in case of vector
because addition and deletion will invalidate iterator of vector.


{cxx-iter-invalidated} CPR 353.
Operations that add or remove elements from a container could invalidate
pointers, references, or iterator to container elements. Using an invalidated
pointer is the same kind of problems as using an unitialized pointer. 

This is only for sequential containers that use `contiguous-memory`

After `add` an element:

* Iterators, pointers, and references to a `vector` or `string` are invalid if
  the container was reallocated. If no rellocation happens, indirect
  references before the insertion remain valid; those after insertion are
  invalid.

* Same for `deque` if we add elements anywhere but at the front or back. If we
  add at the front or back, iterators are invalidated but references and
  pointers to exisiting elements are not.

* Iterators, pointers, and references to `list` or `forward_list` remain valid.

After `remove` an element:

* All other iterators, references, and pointers to a `vector` or `string`
  remain valid before the removal point. The `off-the-end` iterator is always
  invalidated.

* All others to a `deque` are invalidated if the removed elements are anywhere
  but the front or back.

* All others to `list` or `forward_list` remains valid.


<ex>
* invalidated iterators also apply to associative containers. erase for map
  which invalidate iterators for `erased` elements.

* `erase()`/`insert()` returns void for associative containers. not any more
  since C++11 and see map cases.

Can't use the find() member functions to remove elements that have a certain
value instead of a certain key. So can use loop but careful not to saw off the
branch on which you are sitting.


// core will be generated
TEST(Iterator, InvalidOnVector)
{
  std::vector<int> coll{1,2,3,4};

  auto it = find(coll.begin(), coll.end(), 2);
  if( it != coll.end())
  {
    it = coll.insert( it, 7 );
    it = coll.insert( it, 6 );
    it = coll.insert( it, 5 );

    // Q: This seems okay since inserting element at the same pos,2? what will
    // happen?
    //
    // veci.insert( it, 7 );
    // veci.insert( it, 6 );
    // veci.insert( it, 5 );
    //
    // core dump since it gets invalidated.
  }

  EXPECT_THAT(coll, ElementsAre(1,5,6,7,2,3,4));
}


// *cxx-undefined*
// may cause runtime error but not always so undefined. 
// Calling erase() for the element to which you are referring with it
// invalidates it as an iterator of coll and calling ++it results in
// undefined behavior.
//
// However, when use -D_GLIBCXX_DEBUG:
//
// /usr/include/c++/6/debug/safe_iterator.h:298:
// Error: attempt to increment a singular iterator.
// 
// Objects involved in the operation:
//     iterator "this" @ 0x0x7ffcae5ac5d0 {
//       type = __gnu_debug::_Safe_iterator<std::_Rb_tree_const_iterator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> >, std::__debug::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> > > > (constant iterator);
//       state = singular;
//       references sequence with type 'std::__debug::map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, int> > >' @ 0x0x7ffcae5ac600
//     }

TEST(DISABLED_StlIterator, InvalidIteratorOnMap)
{
  std::map<std::string, int> coll{
    {"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}
  };

  int value = 2;

  for (auto it = coll.cbegin(); it != coll.cend(); ++it)
  {
    if (it->second == value)
      coll.erase(it);
  }
}

TEST(StlIterator, ValidIteratorOnMapBeforeC11)
{
  std::map<std::string, int> coll{
    {"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}
  };

  int value = 2;

  for (auto it = coll.cbegin(); it != coll.cend();)
  {
    // before C++11 since erase returns nothing. *cxx-side-effect*
    if (it->second == value)
      coll.erase(it++);
    else
      ++it;
  }
}

TEST(StlIterator, ValidIteratorOnMapAfterC11)
{
  std::map<std::string, int> coll{
    {"one", 1}, {"two", 2}, {"three", 3}, {"four", 4}, {"five", 5}
  };

  int value = 2;

  for (auto it = coll.cbegin(); it != coll.cend();)
  {
    if (it->second == value)
      it = coll.erase(it);
    else
      ++it;
  }
}


// https://stackoverflow.com/questions/37280744/got-singular-iterator-error-in-looping-with-iterator-and-pop-back

// why this work?
TEST(StlIterator, InvalidIteratorOnDeque_Okay_One)
{
  deque<int> coll{1,2,3};

  for (auto it = coll.rbegin(); it != coll.rend(); ++it)
  {
    cout << "it : " << *it << endl;
    coll.pop_back();
  }
}

// why this work?
TEST(StlIterator, InvalidIteratorOnDeque_Okay_Two)
{
  deque<int> coll{1,2,3};

  for (auto it = coll.rbegin(); it != coll.rend();)
  {
    cout << "it : " << *it << endl;
    coll.pop_back();
    ++it;
  }
}

TEST(StlIterator, InvalidIteratorOnDeque_Okay_Three)
{
  deque<int> coll{1,2,3};

  for (auto it = coll.rbegin(); it != coll.rend();)
  {
    cout << "it : " << *it << endl;
    coll.pop_back();
    it = coll.rbegin();
  }
}

// /usr/include/c++/6/debug/safe_iterator.h:149:
// Error: attempt to copy-construct an iterator from a singular iterator.
// 
// Objects involved in the operation:
//     iterator "this" @ 0x0x7ffde23ae160 {
//       type = __gnu_debug::_Safe_iterator<std::__cxx1998::_Deque_iterator<int, int&, int*>, std::__debug::deque<int, std::allocator<int> > > (mutable iterator);
//       state = singular;
//     }
//     iterator "other" @ 0x0x7ffde23ae1f0 {
//       type = __gnu_debug::_Safe_iterator<std::__cxx1998::_Deque_iterator<int, int&, int*>, std::__debug::deque<int, std::allocator<int> > > (mutable iterator);
//       state = singular;
//       references sequence with type 'std::__debug::deque<int, std::allocator<int> >' @ 0x0x7ffde23ae230
//     }
// Aborted

TEST(DISABLED_StlIterator, InvalidIteratorOnDeque_ErrorOne)
{
  deque<int> coll{1,2,3};

  for (auto it = coll.rbegin(); it != coll.rend();)
  {
    it = coll.rbegin();
    cout << "it : " << *it << endl;
    coll.pop_back();
  }
}

TEST(DISABLED_StlIterator, InvalidIteratorOnDeque_ErrorTwo)
{
  deque<int> coll{1,2,3};

  for (auto it = coll.rbegin(); it != coll.rend();)
  {
    ++it;
    cout << "it : " << *it << endl;
    coll.pop_back();
  }
}


<ex>

// shows *cxx-iter-invalidated* case

PortfolioIterator RearrangeByQuantity(PortfolioIterator begin,
    PortfolioIterator end, unsigned int max_quanity)
{
  // how to get T of coll such as algo-remove? here, assumes that we know T
  vector<unsigned int> coll;

  PortfolioIterator start = begin;
  PortfolioIterator current{};

  // one pass to filter <=

  for (; start != end; ++start)
  {
    // not use push_back() since void push_back()
    if (*start <= max_quanity)
      current = coll.insert(coll.end(), *start);
  }

  start = begin;

  // second pass to filter >

  for (; start != end; ++start)
  {
    if (*start > max_quanity)
      coll.push_back(*start);
  }

  // copy it back
  copy(coll.begin(), coll.end(), begin);

  // *cxx-vector-reallocation* *cxx-iter-invalidated*
  // *cxx-iter-singular* means invalidated iterator since there is no gurantee
  // that current is valid after second pass push_back due to relocation
  //
  // /usr/include/c++/6/debug/safe_iterator.h:298:
  // Error: attempt to increment a singular iterator.
  // 
  // Objects involved in the operation:
  //     iterator "this" @ 0x0x7ffdeb5ea9a0 {
  //       type = __gnu_debug::_Safe_iterator<__gnu_cxx::__normal_iterator<unsigned int*, std::__cxx1998::vector<unsigned int, std::allocator<unsigned int> > >, 
  //          std::__debug::vector<unsigned int, std::allocator<unsigned int> > > (mutable iterator);
  //       state = singular;
  //       references sequence with type 'std::__debug::vector<unsigned int, std::allocator<unsigned int> >' @ 0x0x7ffdeb5eaa00
  //     }
  // Aborted
  //
  // return ++current;

  // to make it pass, not used
  return current;
}


// no compile error but errors when built with -D_GLIBCXX_DEBUG and run
//
// /usr/include/c++/6/debug/safe_iterator.h:191:
// Error: attempt to construct a constant iterator from a singular mutable 
// iterator.
// 
// Objects involved in the operation:
//     iterator "this" @ 0x0x7ffcc61e9980 {
//       type = __gnu_debug::_Safe_iterator<__gnu_cxx::__normal_iterator<int const*, std::__cxx1998::vector<int, std::allocator<int> > >, std::__debug::vector<int, std::allocator<int> > > (constant iterator);
//       state = singular;
//     }
//     iterator "other" @ 0x0x7ffcc61e97f0 {
//       type = __gnu_debug::_Safe_iterator<__gnu_cxx::__normal_iterator<int*, std::__cxx1998::vector<int, std::allocator<int> > >, std::__debug::vector<int, std::allocator<int> > > (mutable iterator);
//       state = singular;
//       references sequence with type 'std::__debug::vector<int, std::allocator<int> >' @ 0x0x7ffcc61e9820
//     }
// Aborted

TEST(DISABLED_StlVector, EraseChangesEnd_EmitRuntimeError)
{
  vector<int> coll1;
  INSERT_ELEMENTS(coll1, 0, 8);
  EXPECT_THAT(coll1, ElementsAre(0,1,2,3,4,5,6,7,8));

  auto it = coll1.begin()+1;

  // note: it is not valid after this so should be
  // it = coll1.erase(it);

  coll1.erase(it);
  EXPECT_THAT(coll1, ElementsAre(0,2,3,4,5,6,7,8));

  coll1.erase(it);
  EXPECT_THAT(coll1, ElementsAre(0,3,4,5,6,7,8));

  vector<int> coll2{0, 1, 2, 3, 4, 5, 6, 7, 8};

  // in every iteration, update it which is invalidated after insert/erase.
  for(auto it = coll2.begin(); it != coll2.end(); /* no */)
  {
    // if see even values, remove it
    if(!(*it % 2))
      it = coll2.erase(it);
    else
      ++it;
  }

  EXPECT_THAT(coll2, ElementsAre(1,3,5,7));
}


TEST(StlVector, InsertAndErase)
{
  vector<int> coll{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

  EXPECT_THAT(coll, ElementsAre(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));

  // in every iteration, update it which is invalidated after insert/erase.
  for(auto it = coll.begin(); it != coll.end(); /* no */)
  {
    // if see odd values, repeat it in front of it.
    if(*it % 2)
    {
      // *cxx-iter-arthimetic*
      it = coll.insert(it, *it);
      it += 2;
    }
    else
      // cxx-vector-erase cxx-erase
      it = coll.erase(it);
  }

  EXPECT_THAT(coll, ElementsAre(1, 1, 3, 3, 5, 5, 7, 7, 9, 9));
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-remove cxx-remove

{algo-remove}

6.7.1 “Removing” Elements

TEST(AlgoMutating, AlgoRemove)
{
  // coll.erase() delete elements but algo-remove do not.
  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    for (auto it = coll.begin(); it != coll.end(); ++it)
    {
      if (*it == 2)
        it = coll.erase(it);
    }

    EXPECT_THAT(coll, ElementsAre(1,3,4,5,6,7,8,9));
  }

  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    auto end = remove(coll.begin(), coll.end(), 2);

    EXPECT_THAT(distance(end, coll.end()), 4);
    EXPECT_THAT(coll, 
        ElementsAreArray({1,3,4,5,6,7,8,9,2,2,2,2}));

    coll.erase(end, coll.end());
    EXPECT_THAT(coll, ElementsAre(1,3,4,5,6,7,8,9));
  }

  // show that algo-remove() do not remove elements
  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    remove(coll.begin(), coll.end(), 2);

    // std::vector<int> coll{1,3,4,5,6,7,8,9,2,8,2,9};
    //                                       ^^^^^^^ 

    EXPECT_THAT(coll, ElementsAreArray({1,3,4,5,6,7,8,9,2,8,2,9}));
  }
}


So *algo-remove* reorder:

<elemenets not matched> <elements matched>
                       |
                        += return the past of the last element

Thus, `algo-remove()` did not change the number of elements in the collection
for which it was called. Have to call erase member function to actually
remove.


<cxx-coll-remove>
coll.remove() is only for list and forward_list since no such member function
for others.


This explains iterator which glues algorithm and container. In practice, there
are some limits and workarounds you should know. Many of these have to do with
modifications. These aspects are surprising and show `the 'price' of the STL`
concept that separates containers and algorithms with great flexibility.

  Why don't algorithms call erase() by themselves? This question highlights
  the price of the flexibility of the STL. The STL separates data structures
  and algorithms by using iterators as the interface. However, iterators are
  `an abstraction to represent a 'position' in a container.` In general,
  iterators do not know their containers. Thus, the algorithms, which use the
  iterators to access the elements of the container, can't call any member
  function for it.


{cxx-remove-associative}

Manipulation algorithms-those that remove elements and those that reorder or
modify elements-have another 'problem' when you try to use them with
associative or unordered containers:

Associative and unordered containers can't be used as a destination. The
reason is simple:

If they would work for associative or unordered containers, modifying
algorithms could change the value or position of elements, thereby violating
the order maintained by the container

In order to maintain internal order, every iterator for an associative and
unordered container is declared as an iterator for a 'constant' value or key.

<ex>
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  set<int> coll{1,2,3,4,5,6,7,8,9};

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  // algo-remove
  std::remove( coll.begin(), coll.end(), 3 );

  // print 
  cout << "post: " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

// same error when use remove(coll.cbegin(), coll.cend(), 3)

In file included from /usr/include/c++/4.6/algorithm:63:0,
                 from sam01.cpp:3:
/usr/include/c++/4.6/bits/stl_algo.h: In function '_FIter std::remove(_FIter, _FIter, const _Tp&) 
   [with _FIter = std::_Rb_tree_const_iterator<int>, _Tp = int]':
sam01.cpp:17:39:   instantiated from here
/usr/include/c++/4.6/bits/stl_algo.h:1106:13: error: assignment of read-only location 
   '__result.std::_Rb_tree_const_iterator<_Tp>::operator* [with _Tp = int, std::_Rb_tree_const_iterator<_Tp>::reference = const int&]()'


*cxx-remember*
How does one remove elements in associative containers? The answer is simple:
Call their member functions

<ex>
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  set<int> coll{1,2,3,4,5,6,7,8,9};

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  int num = coll.erase(3);

  // print number of removed elements
  cout << "number of removed elements: " << num << endl;

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

pre : 9 elements
1 2 3 4 5 6 7 8 9 
number of removed elements: 1
pre : 8 elements
1 2 4 5 6 7 8 9 


{constant-key} cxx-map cxx-set cxx-unordered
Here, the iterator pos iterates through the sequence of pairs of const string
and float, and you have to use operator -> to access key and value of the
actual element

Trying to change the value of the key results in an error:

elem.first = "hello"; // ERROR at compile time
pos->first = "hello"; // ERROR at compile time

However, changing the value of the element is no problem, as long as elem is
declared as a nonconstant reference and the type of the value is not constant:

elem.second = 13.5; // OK
pos->second = 13.5; // OK

To change the key of an element, you have only one choice: You must replace
the old element with a new element that has the same value. 

// Section 7.8.2, page 339.

Note that maps provide a more convenient way to modify the key of an element.
Instead of calling replace_key(), you can simply write the following:

// insert new element with value of old element
coll["new_key"] = coll["old_key"];

// remove old element
coll.erase("old_key");


{algorithm-or-member-function}
Even if you are able to use an algorithm, it might be a bad idea to do so. A
container might have member functions that provide much better performance.

Calling remove(val) for elements of a 'list' is a good example of this. If you
call remove() for elements of a list, the algorithm doesn't know that it is
operating on a list and thus does what it does for any container: reorder the
elements by changing their values. If, for example, the algorithm removes the
first element, all the following elements are assigned to their previous
elements. This behavior contradicts the main advantage of lists: the ability
to insert, move, and remove elements by modifying the links instead of the
values.

note: 
The `remove()` member is only for list and forward_list and erase for others.

*cxx-remember*
To avoid bad performance, lists provide special member functions for all
manipulating algorithms. You should 'always' prefer them. 

The problem is, you have to know that a member function exists that has
significantly better performance for a certain container. You have to change
the code when you switch to another container type.

<container-specific>
The `list` and `forward_list` define several algorithms as memebers because can
use generic ones with list but at a cost in performance. These container
spscific ones are merge, sort, unique, remove and reserse. The member version
should be used in preference to the generic for list and forward_list.

Also, a important difference between the list-specific and the generic is that
the list version change the underlying containers.

// *ex-algo-remove*
int main()
{
  list<int> coll;

  // insert elements from 6 to 1 and 1 to 6
  for (int i=1; i<=6; ++i) {
    coll.push_front(i);
    coll.push_back(i);
  }

  // remove all elements with value 3 (poor performance)
  coll.erase (remove(coll.begin(),coll.end(), 3), coll.end());

  // remove(val) 'all' elements with value 4 (good performance)
  coll.remove (4);
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-sequential

Consider performance trade-offs between insert/delete and random-access.

vector      : random-access, fast insert/delete at the back
string      : random-access, fast insert/delete at the back
deque       : double-ended q, random-access, fast insert/delete at front/back
array       : C++11. fixed size. possible to copy and assign.

*cxx-coll-contiguous*
string, vector, deque, and array are `contiguous-memory`. Hence, insert/delete
in the middle can be expensive since have to move elements but fast access.

list        : double llist, bi-directional, fast insert/delete at any point
forward list: single llist, forward, support push_front only.

these provides sequential access and may have memory overhead but fast
insert/delete.

note:
The forward_list don't support size() but others do. The size() has fast and
constant time which is different from ESTL so seems it's true for C++11? Primus
says C++ library has improved significantly in recent.

*cxx-iter-arithmetic*
The list and forward_list don't support iterator arithmetic since this is for
containers that supports random access; string, vector, deque and array.


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-array

An array(an instance of the container class array<>) models a static array. It
wraps an ordinary static C-style array providing the interface of an STL
container.

This manages its elements in an array of `fixed size` and the number of elements
is a part of the type of an array.

Conceptionally, an array is a sequence of elements with constant size. Thus, you
can neither add nor remove elements to change the size. Only a replacement of
element values is possible.

If you need a sequence with a fixed number of elements, class array<> has the
best performance because memory `is allocated on the stack` (if possible),
`reallocation never happens`, and you have random access.

namespace
{
  // #include <array>
  namespace std {
    template <typename T, size_t N>
      class array;
  }
}


<initialize>

7.2.2 Array Operations

Create, Copy, and Destroy

Table 7.4 lists the constructors and destructors for arrays. Because class
array<> is an aggregate, these constructors are only implicitly defined. You can
create arrays with and without elements for initialization. The default
constructor default initializes the elements, which means that the value of
fundamental types is undefined.

TEST(CxxArray, check_ctors)
{
  // all fundamental types are initialised.
  {
    std::array<int, 8> coll = {};

    EXPECT_THAT(coll, ElementsAre(0, 0, 0, 0, 0, 0, 0, 0));
  }

  {
    std::array<int, 8> coll = {11, 22, 33};

    EXPECT_THAT(coll.size(), 8);

    coll.back()           = 999;
    coll[coll.size() - 2] = 42;

    EXPECT_THAT(coll, ElementsAre(11, 22, 33, 0, 0, 0, 42, 999));
  }

  {
    array<int, 3> coll{1, 2, 3};
    EXPECT_THAT(coll, ElementsAre(1, 2, 3));
  }
}

note:
array header do not define ctors at all. How does it support ctor with
initializer_list?


<element-access>
For nonconstant arrays, these operations return a reference to the element.
Thus, you could modify an element by using one of these operations

c[idx]      Returns the element with index idx (no range checking)
c.at(idx)   Returns the element with index idx 
            (throws range-error exception if idx is out of range)
c.front()   Returns the first element (no check whether a first element exists)
c.back()    Returns the last element (no check whether a last element exists)


<ex> *cxx-vector-array*

7.3.3 Using Vectors as C-Style Arrays

As for class cxx-array, the C++ standard library guarantees that the elements of
a vector are in contiguous memory. Thus, you can expect that for any valid index
i in vector v, the following yields true:

&v[i] == &v[0] + i

This guarantee has some important consequences. It simply means that you can
use a vector in all cases in which you could use a `dynamic array.` 


<ex> multi-array using cxx-vector and cxx-array

TEST(CxxArray, check_multi_dimention)
{
  const size_t rows = 5;
  const size_t cols = 5;

  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0

  {
    std::vector<std::vector<int>> coll(rows, std::vector<int>(cols, 0));

    cout << "{" << endl;
    for (size_t i = 0; i < rows; ++i)
    {
      for (size_t j = 0; j < cols; ++j)
        cout << coll[i][j] << " ";
      cout << endl;
    }
    cout << "}" << endl;
  }

  // 0 0 0 0 0
  // 1 1 1 1 0
  // 0 0 0 0 0
  // 0 1 1 1 1
  // 2 0 0 0 0

  {
    std::vector<std::vector<int>> coll{{0, 0, 0, 0, 0},
                                       {1, 1, 1, 1, 0},
                                       {0, 0, 0, 0, 0},
                                       {0, 1, 1, 1, 1},
                                       {2, 0, 0, 0, 0}};

    cout << "{" << endl;
    for (size_t i = 0; i < rows; ++i)
    {
      for (size_t j = 0; j < cols; ++j)
        cout << coll[i][j] << " ";
      cout << endl;
    }
    cout << "}" << endl;
  }

  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0
  // 0 0 0 0 0

  {
    std::array<std::array<int, cols>, rows> coll{0};

    cout << "{" << endl;
    for (size_t i = 0; i < rows; ++i)
    {
      for (size_t j = 0; j < cols; ++j)
        cout << coll[i][j] << " ";
      cout << endl;
    }
    cout << "}" << endl;
  }

  // 0 0 0 0 0
  // 1 1 1 1 0
  // 0 0 0 0 0
  // 0 1 1 1 1
  // 2 0 0 0 0

  {
    std::array<std::array<int, 5>, 5> coll{0, 0, 0, 0, 0, 1, 1, 1, 1,
                                           0, 0, 0, 0, 0, 0, 0, 1, 1,
                                           1, 1, 2, 0, 0, 0, 0};

    cout << "{" << endl;
    for (size_t i = 0; i < rows; ++i)
    {
      for (size_t j = 0; j < cols; ++j)
        cout << coll[i][j] << " ";
      cout << endl;
    }
    cout << "}" << endl;
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-vector

CXXSLR-7.3 Vectors

A vector manages its elements in a `dynamic array` and supports random access,
which means you can access each element directly with the corresponding index.

vectors provide good performance if you append or delete elements `at the end.`

If you insert or delete in the middle or at the beginning, performance gets
worse. This is because every element behind has to be moved to another
position. In fact, the assignment operator would be called for every following
element.


{cxx-vector-code}

namespace cxx_code
{
  // /usr/include/c++/4.7.2/bits/vector.tcc

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)


    // /usr/include/c++/4.7.2/bits/stl_vector.h

    template<typename _Tp, typename _Alloc = std::allocator<_Tp>>
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      // *cxx-iter* see bits/stl_iterator.h
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
        const_iterator;

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %vector.
       */
      reference
        front()
        { return *begin(); }

      // iterators
      /**
       *  Returns a read/write iterator that points to the first
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
        begin() _GLIBCXX_NOEXCEPT
        { return iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      const_iterator
        begin() const _GLIBCXX_NOEXCEPT
        { return const_iterator(this->_M_impl._M_start); }

      /**
       *  Returns a read/write iterator that points one past the last
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
        end() _GLIBCXX_NOEXCEPT
        { return iterator(this->_M_impl._M_finish); }

      /**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %vector.  Iteration is done in
       *  ordinary element order.
       */
      const_iterator
        end() const _GLIBCXX_NOEXCEPT
        { return const_iterator(this->_M_impl._M_finish); }


      *cxx-vector-ctor*

        /**
         *  @brief  Creates a %vector with no elements.
         */
        vector()
#if __cplusplus >= 201103L
        noexcept(is_nothrow_default_constructible<_Alloc>::value)
#endif
        : _Base() { }

        /**
         *  @brief  Creates a %vector with default constructed elements.
         *  @param  __n  The number of elements to initially create.
         *  @param  __a  An allocator.
         *
         *  This constructor fills the %vector with @a __n default
         *  constructed elements.
         */
        explicit
        vector(size_type __n, const allocator_type& __a = allocator_type())
        : _Base(__n, __a)
        { 
          _M_default_initialize(__n); 
        }

      // vector<Elem> c(initlist) 
      // 
      // Creates a vector initialized with the elements of initializer
      // list initlist (since C++11)
      // 
      // vector<Elem> c = initlist 
      // 
      // Creates a vector initialized with the elements of initializer
      // list initlist (since C++11)
      // 
      // Table 7.9. Constructors and Destructor of Vectors

      /**
       *  @brief  Creates a %vector with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n copies of @a __value.
       */
      vector(size_type __n, const value_type& __value,
          const allocator_type& __a = allocator_type())
        : _Base(__n, __a)
      { 
        _M_fill_initialize(__n, __value); 
      }

      /**
       *  @brief  Builds a %vector `from an initializer list.`
       *  @param  __l  An initializer_list.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements in the
       *  initializer_list @a __l.
       *
       *  This will call the element type's copy constructor N times
       *  (where N is @a __l.size()) and do no memory reallocation.
       */
      vector(initializer_list<value_type> __l,
          const allocator_type& __a = allocator_type())
        : _Base(__a)
      {
        _M_range_initialize(__l.begin(), __l.end(),
            random_access_iterator_tag());
      }

      // NOTE: there is no interface like push_front(), pop_front() on vector.
      // why?

      /**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation. It shrinks the %vector by one.
       *
       *  Note that no data is returned, and if the last element's
       *  data is needed, it should be retrieved before pop_back() is
       *  called.
       */
      void
        pop_back() _GLIBCXX_NOEXCEPT
        {
          --this->_M_impl._M_finish;
          _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
        }

      // *cxx-operator-[]*
      // element access
      /**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */
      reference
        operator[](size_type __n) _GLIBCXX_NOEXCEPT
        { return *(this->_M_impl._M_start + __n); }

      // *cxx-vector-insert*
      /**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       */
      iterator
        insert(const_iterator __position, const value_type& __x);
    };
} // namespace


{cxx-vector-reallocation} cxx-iter-invalidated
To support fast random access, vector elements are stored `contiguously`. To
maintain contiguous memory and to avoid reallocating a container each time an
element is added, the allocation strategy is: 

  When they have to get new memory, `vector` and `string` implementations
  typically allocate `capacity` beyond what is immediately needed. Thus there
  is no need to `reallocate` the container for each new element. The vector
  has to move all of its elements each time when it reallocates memory.

The capacity of a vector is important for two reasons:

* Reallocation invalidates all references, pointers, and iterators for elements
  of the vector.

  "This means its memory may or may not move. Because of this uncertainty, must
  consider any existing iterators into `vector` to be invalidated. - EXPC++ p3"

* Reallocation takes time.

c.shrink_to_fit();
C++11. request to reduce capacity() to equal size()

c.capacity();
returns `the maximum possible number of elements` without reallocation.

c.reserve(n);
allocate space for at least n elements `but do not affect size()`


<reserve-or-constructor> cxx-vector-ctor cxx-vector-init
To avoid reallocation, you can use reserve() to ensure a certain capacity
before you really need it. In this way, you can ensure that references remain
valid as long as the capacity is not exceeded

std::vector<int> v;  // create an empty vector
v.reserve(80);       // reserve memory for 80 elements

Initialize a vector with enough elements by passing additional arguments to
the constructor.

std::vector<T> v(5); // creates a vector and initializes it with five values
                     // (calls five times the default constructor of type T)

note: 
The type of the elements must provide a default constructor for this ability.
For fundamental types, zero initialization is guaranteed. 

But for complex types, even if a default constructor is provided, the
initialization takes time. If the only reason for initialization is to reserve
memory, you should use reserve().

*cxx-vector-resize*

c.resize(num) 
Changes the number of elements to num 
(if size() grows new elements are created by their default constructor)

c.resize(num,elem) 
Changes the number of elements to num 
(if size() grows new elements are copies of elem)


TEST(Vector, Ctors)
{
  {
    vector<int> coll(5);
    ASSERT_THAT(coll.size(), Eq(5));
    EXPECT_THAT(coll, ElementsAre(0,0,0,0,0));
  }

  // *cxx-vector-resize*
  {
    vector<int> coll;
    coll.resize(5);
    ASSERT_THAT(coll.size(), Eq(5));
    EXPECT_THAT(coll, ElementsAre(0,0,0,0,0));
  }

  {
    vector<int> coll(5, 10);
    ASSERT_THAT(coll.size(), Eq(5));
    EXPECT_THAT(coll, ElementsAre(10,10,10,10,10));
  }

  // *cxx-vector-resize*
  {
    vector<int> coll;
    coll.resize(5, 10);
    ASSERT_THAT(coll.size(), Eq(5));
    EXPECT_THAT(coll, ElementsAre(10,10,10,10,10));
  }

  {
    VectorCtorsTest coll(10, 100);
    // icoll3.print();
    ASSERT_THAT(coll.size(), Eq(10));
  }

  // initializer_list
  {
    vector<int> coll{1,2,3,4,5,6};
    EXPECT_THAT(coll, ElementsAre(1,2,3,4,5,6));
  }

  // iterator
  {
    istringstream is{"1 2 3 4 5 6"};

    vector<int> coll((istream_iterator<int>(is)), istream_iterator<int>());

    // *cxx-error* without additional (). WHY?
    // vector<int> coll(istream_iterator<int>(is), istream_iterator<int>());

    EXPECT_THAT(coll, ElementsAre(1,2,3,4,5,6));
  }
}


<ex>
Started from "Why so many dtors get called?"

class VectorEraseCallsDtor
{
  public:
    VectorEraseCallsDtor(const string name="vector"): name_(name) 
      { cout << "VectorEraseCallsDtor::ctor: " << name_ << endl; }
    ~VectorEraseCallsDtor() 
      { cout << "VectorEraseCallsDtor::dtor: " << name_ << endl; }

    string GetName() { return name_; }

  private:
    string name_;
};

// 1. cxx-vector-reallocation is not something when create a vector with big
// numbers. This happens from the start.
//
// 2. do not predict how rellocation or destruction gets called.
// 
// When doing push_back(), cannot predict the output since relocation is
// involved.
// 
// When erasing from the beginning, cannot predict the output since moves
// element from the end to the beginning. 
//
// -for ---------
// VectorEraseCallsDtor::ctor: name 0
// VectorEraseCallsDtor::dtor: name 0
// -for ---------
// VectorEraseCallsDtor::ctor: name 1
// VectorEraseCallsDtor::dtor: name 0
// VectorEraseCallsDtor::dtor: name 1
// -for ---------
// VectorEraseCallsDtor::ctor: name 2
// VectorEraseCallsDtor::dtor: name 0
// VectorEraseCallsDtor::dtor: name 1
// VectorEraseCallsDtor::dtor: name 2
// -for ---------
// VectorEraseCallsDtor::ctor: name 3
// VectorEraseCallsDtor::dtor: name 3
// -for ---------
// VectorEraseCallsDtor::ctor: name 4
// VectorEraseCallsDtor::dtor: name 0
// VectorEraseCallsDtor::dtor: name 1
// VectorEraseCallsDtor::dtor: name 2
// VectorEraseCallsDtor::dtor: name 3
// VectorEraseCallsDtor::dtor: name 4
// for: name 0
// for: name 1
// for: name 2
// for: name 3
// for: name 4
// -erase---------
// VectorEraseCallsDtor::dtor: name 4
// -erase---------
// VectorEraseCallsDtor::dtor: name 4
// -erase---------
// VectorEraseCallsDtor::dtor: name 4
// VectorEraseCallsDtor::dtor: name 3
// VectorEraseCallsDtor::dtor: name 4

TEST(Vector, CreateWithOnDemand)
{
  vector<VectorEraseCallsDtor> ovec{};

  for(int i = 0; i < 5; ++i)
  {
    cout << "-for ---------" << endl;
    string name = "name " + to_string(i);
    ovec.push_back(VectorEraseCallsDtor(name));
  }

  for (auto &e : ovec)
    cout << "for: " << e.GetName() << endl;

  cout << "-erase---------" << endl;
  auto it = ovec.begin();
  it = ovec.erase(it);

  cout << "-erase---------" << endl;
  it = ovec.erase(it);

  cout << "-erase---------" << endl;
  it = ovec.erase(it);
}


// see no relocation happens
//
// -for ---------
// VectorEraseCallsDtor::ctor: name 0
// VectorEraseCallsDtor::dtor: name 0
// -for ---------
// VectorEraseCallsDtor::ctor: name 1
// VectorEraseCallsDtor::dtor: name 1
// -for ---------
// VectorEraseCallsDtor::ctor: name 2
// VectorEraseCallsDtor::dtor: name 2
// -for ---------
// VectorEraseCallsDtor::ctor: name 3
// VectorEraseCallsDtor::dtor: name 3
// -for ---------
// VectorEraseCallsDtor::ctor: name 4
// VectorEraseCallsDtor::dtor: name 4
// -erase---------
// VectorEraseCallsDtor::dtor: name 4
// -erase---------
// VectorEraseCallsDtor::dtor: name 4
// -erase---------
// VectorEraseCallsDtor::dtor: name 4
// VectorEraseCallsDtor::dtor: name 3
// VectorEraseCallsDtor::dtor: name 4

TEST(Vector, CreateWithReserve)
{
  vector<VectorEraseCallsDtor> ovec{};
  ovec.reserve(10);

  for(int i = 0; i < 5; ++i)
  {
    cout << "-for ---------" << endl;
    string name = "name " + to_string(i);
    ovec.push_back(VectorEraseCallsDtor(name));
  }

  cout << "-erase---------" << endl;
  auto it = ovec.begin();
  it = ovec.erase(it);

  cout << "-erase---------" << endl;
  it = ovec.erase(it);

  cout << "-erase---------" << endl;
  it = ovec.erase(it);
}


// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// VectorEraseCallsDtor::ctor: vector
// -erase---------
// VectorEraseCallsDtor::dtor: vector
// -erase---------
// VectorEraseCallsDtor::dtor: vector
// -erase---------
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector
// VectorEraseCallsDtor::dtor: vector

TEST(Vector, CreateWithPreAllocation)
{
  vector<VectorEraseCallsDtor> ovec(10);

  cout << "-erase---------" << endl;
  auto it = ovec.begin();
  it = ovec.erase(it);

  cout << "-erase---------" << endl;
  it = ovec.erase(it);

  cout << "-erase---------" << endl;
  it = ovec.erase(it);
}


<ex>

// cxx-seg-fault
//
// can benefit from -D_GLIBCXX_DEBUG
//
// /usr/include/c++/4.9/debug/vector:357:error: attempt to subscript container
//     with out-of-bounds index 8, but container only holds 5 elements.
// 
// Objects involved in the operation:
// sequence "this" @ 0x0x7ffe287d4590 {
//   type = NSt7__debug6vectorI20VectorEraseCallsDtorSaIS1_EEE;
// }
// Aborted

TEST(DISABLED_Vector, AccessInvalidIndex)
{
  vector<VectorEraseCallsDtor> ovec{};

  for(int i = 0; i < 5; ++i)
  {
    string name = "name " + to_string(i);
    ovec.push_back(VectorEraseCallsDtor(name));
  }

  cout << "name: " << ovec[8].GetName() << endl;
}

// cxx-undefined
//
// can benefit from -D_GLIBCXX_DEBUG
//
// /usr/include/c++/4.9/debug/vector:357:error: attempt to subscript container
//     with out-of-bounds index 8, but container only holds 5 elements.
// 
// Objects involved in the operation:
// sequence "this" @ 0x0x7ffe5c578460 {
//   type = NSt7__debug6vectorI20VectorEraseCallsDtorSaIS1_EEE;
// }
// Aborted

TEST(DISABLED_Vector, AccessInvalidIndexWithReserve)
{
  vector<VectorEraseCallsDtor> ovec{};
  ovec.reserve(10);

  for(int i = 0; i < 5; ++i)
  {
    string name = "name " + to_string(i);
    ovec.push_back(VectorEraseCallsDtor(name));
  }

  cout << "name: " << ovec[8].GetName() << endl;
}


<shrink-to-fit>
Unlike for strings, it is not possible to call reserve() for vectors to shrink
the capacity. Calling reserve() with an argument that is less than the current
capacity is a no-op. Furthermore, how to reach an optimal performance
regarding speed and memory use is implementation defined. When reallocation is
needed, how much memory it will allocate is implementation specific.

Because the capacity of vectors never shrinks, it is guaranteed that
references, pointers, and iterators remain valid even when elements are
deleted, provided that they refer to a position before the manipulated
elements.

C++11 introduced shrink_to_fit() which is a 'non-binding' request to shrink
the capacity to fit the current number of elements: Valid only for vector,
    string, and deque. capacity and reserve valid only for vector and string.

There is no guarantee that shrink_to_fit will return a memory since it's a
only 'request'.


{cxx-vector-element-access} CXXSLR-7.3.2

Table 7.12. Direct Element Access of Vectors

As usual in C and C++, the first element has index 0, and the last element has
index size()-1. Thus, the nth element has index n-1. 

For non-constant vectors, `these operations return a reference` to the element.
Thus, you could modify an element by using one of these operations, provided
it is not forbidden for other reasons.

c[idx]      Returns the element with index idx (`no range checking`)
c.at(idx)   Returns the element with index idx (throws range-error exception if
            idx is out of range)

c.front()   Returns the first element (`no check` whether a first element exists)

c.back()    Returns the last element (no check whether a last element exists)
            (does not remove it)

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %vector.
       */
      reference
      front() _GLIBCXX_NOEXCEPT
      { return *begin(); }

      /**
       *  Returns a read/write reference to the data at the last
       *  element of the %vector.
       */
      reference
      back() _GLIBCXX_NOEXCEPT
      { return *(end() - 1); }


<at-range-check> cxx-undefined
Only at() performs range checking. If the index is out of range, at() throws an
`out_of_range` exception (see 4.3, page 41). All other functions do not check. A
range error results in undefined behavior. 

Calling operator[], front(), and back() for an empty container always results in
`undefined` behavior. So, you must ensure that the index for operator[] is valid
and that the container is not empty when either front() or back() is called.


<ex>
//  max_size(): 2305843009213693951
//  size()    : 0
//  capacity(): 5
// Hello, how are you ?
//  max_size(): 2305843009213693951
//  size()    : 5
//  capacity(): 5
// Hello, you are how always !
//  size()    : 6
//  capacity(): 10
//  size()    : 4
//  capacity(): 4

TEST(Vector, Capacity)
{
  // create empty vector for strings
  vector<string> sentence;
  // reserve memory for five elements to avoid reallocation
  sentence.reserve(5);

  // *TN* reserve() do not change size()
  cout << " max_size(): " << sentence.max_size() << endl;
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // append some elements
  sentence.push_back("Hello,");
  sentence.insert(sentence.end(),{"how","are","you","?"});

  // print elements separated with spaces
  copy (sentence.cbegin(), sentence.cend(),
      ostream_iterator<string>(cout," "));
  cout << endl;

  // print ‘‘technical data’’
  cout << " max_size(): " << sentence.max_size() << endl;
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // swap second and fourth element
  swap (sentence[1], sentence[3]);
  // insert element "always" before element "?"
  sentence.insert (find(sentence.begin(),sentence.end(),"?"), "always");
  // assign "!" to the last element
  sentence.back() = "!";

  // print elements separated with spaces
  copy (sentence.cbegin(), sentence.cend(),
      ostream_iterator<string>(cout," "));
  cout << endl;

  // print some ‘‘technical data’’ again
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // delete last two elements
  sentence.pop_back();
  sentence.pop_back();

  // shrink capacity (since C++11)
  sentence.shrink_to_fit();
  // print some ‘‘technical data’’ again
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;
}


<cxx-vector-move>

TEST(Vector, CopyAndMoveAssign)
{
  {
    vector<int> coll1{1,2,3,4,5,6};
    vector<int> coll2{};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 0);

    coll2 = coll1;

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 6);
  }

  {
    vector<int> coll1{1,2,3,4,5,6};
    vector<int> coll2{};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 0);

    coll2 = {1,2,3,4,5,6};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 6);
  }

  {
    vector<int> coll1{1,2,3,4,5,6};
    vector<int> coll2{};

    ASSERT_THAT(coll1.size(), 6);
    ASSERT_THAT(coll2.size(), 0);

    coll2 = std::move(coll1);

    ASSERT_THAT(coll1.size(), 0);     // see 0
    ASSERT_THAT(coll2.size(), 6);
  }

  {
    vector<int> coll1{1,2,3,4,5,6};
    GetVectorArg(coll1);
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-vector-bool

For Boolean elements, the standard library provides a
*cxx-template-specialization* of vector<>. 

Such a usual implementation would reserve at least 1 byte for each element. The
vector<bool> specialization usually uses internally only 1 bit for an element,
so it is typically eight times smaller.

But such an optimization also has a snag: In C++, the smallest addressable value
must have a size of at least 1 byte. Thus, such a specialization of a vector
needs special handling for references and iterators.

As a result, a vector<bool> does not meet all requirements of other vectors.
For example, a vector<bool>::reference is not a true lvalue and
vector<bool>::iterator is not a random-access iterator.

In addition, vector<bool> `might perform worse` than normal implementations,
because element operations have to be transformed into bit operations. However,
how vector<bool> is implemented is implementation specific. Thus, the
  performance (speed and memory) might differ.

class vector<bool> is more than a specialization of vector<> for bool. It also
provides some special bit operations. You can handle bits or flags in a more
convenient way.

`vector<bool>` has a dynamic size, so you can consider it a bitfield with
`dynamic-size`. Thus, you can add and remove bits. If you need a bitfield with
`static-size`, you should use `bitset` rather than a vector<bool>.

The additional operations of vector<bool> are:

c.flip()             Negates all Boolean elements (complement of all bits)

c[idx].flip()        Negates the Boolean element with index idx (complement of a
                     single bit)

c[idx] = val         Assigns val to the Boolean element with index idx
                     (assignment to a single bit)

c[idx1] = c[idx2]    Assigns the value of the element with index idx2 to the
                     element with index idx1

note: default value is false.

NOTE:

size:
vector bool size: 40
bitset      size: 128
array bit   size: 128
array bool  size: 1000

performance:
[ RUN      ] CxxBit.check_performace_on_vector_bool
[       OK ] CxxBit.check_performace_on_vector_bool (277 ms)
[ RUN      ] CxxBit.check_performace_on_bitset
[       OK ] CxxBit.check_performace_on_bitset (255 ms)
[ RUN      ] CxxBit.check_performace_on_array_bit
[       OK ] CxxBit.check_performace_on_array_bit (50 ms)
[ RUN      ] CxxBit.check_performace_on_array_bool
[       OK ] CxxBit.check_performace_on_array_bool (34 ms) <<<<<<<<


<cxx-design-proxy>
How this "c[idx].flip()" possible since type bool is fundamental type? Here, the
class vector<bool> uses a common trick, called a proxy. For vector<bool>, the
return type of the subscript operator (and other operators that return an
    element) is an auxiliary class. If you need the return value to be bool, an
automatic type conversion is used. For other operations, the member functions
are provided. The relevant part of the declaration of vector<bool> looks like
this:

namespace std {
  template <typename Allocator> `class vector`<bool,Allocator> {
    public:

      // auxiliary proxy type for element modifications:
      `class reference` {
        ...
        public:
          reference& operator= (const bool) noexcept; // assignments
          reference& operator= (const reference&) noexcept;
          operator bool() const noexcept; // automatic type conversion to bool
          void flip() noexcept;           // bit complement
      };

      ...

      // operations for element access return reference proxy instead of bool:
      reference operator[](size_type idx);
      reference at(size_type idx);
      reference front();
      reference back();
      ...
  };
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-deque

7.4 Deques

A deque is very similar to a vector. It manages its elements with a dynamic
array, provides random access, and has almost the same interface as a vector.

The difference is that with a deque, the dynamic array is open at both ends.
Thus, a deque is fast for insertions and deletions at both the end and the
beginning

This is an abbreviation for "double-ended queue" and a `dynamic array` that
can grow in `both directions.` A deque is very similar to a vector. It manages
its elements with a dynamic array, provides random access, and has almost the
same interface as a vector.

Thus, inserting elements at the end and at the beginning is fast. However,
inserting elements in the middle takes time because elements must be moved.


7.4.1 Abilities of Deques

Deques provide no support to control the capacity and the moment of
reallocation. In particular, any insertion or deletion of elements other than at
the beginning or end invalidates all pointers, references, and iterators that
refer to elements of the deque. However, reallocation may perform better than
for vectors because according to their typical internal structure, deques don’t
have to copy all elements on reallocation.

Blocks of memory might get freed when they are no longer used, so the memory
size of a deque might shrink (however, whether and how this happens is
implementation specific).

In summary, you should prefer a deque if the following are true:

o You insert and remove elements at both ends (this is the classic case for a
  queue).

o You don’t refer to elements of the container.

o It is important that the container frees memory when it is no longer used
(however, the standard does not guarantee that this happens).


12.1 Stacks

It was chosen because, unlike vectors, deques free their memory when elements
are removed and don’t have to copy all elements on reallocation (see Section
    7.12, page 392, for a discussion of when to use which container).


namespace cxx_code
{
  // /usr/include/c++/4.9/bits/stl_deque.h

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
  {}
} // namespace


{cxx-deque-coll-access}
c[idx]    
Returns the element with index idx (no range checking)

c.at(idx) 
Returns the element with index idx (throws range-error exception if idx is out
of range)

Table 7.17. Nonmodifying Operations of Deques

c.front()   Returns the first element (`no check` whether a first element exists)
c.back()    Returns the last element (no check whether a last element exists) 

c.push_back(elem)   Appends a copy of elem at the end
c.pop_back()        Removes the last element (does not return it)

c.push_front(elem)  Inserts a copy of elem at the beginning
c.pop_front()       Removes the first element (does not return it)

*TN* since it supports both ends, no real distinguish between back and front


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-queue cxx-coll-adaptor

{cxx-queue}

12.2 Queues

namespace cxx_code
{
  // *cxx-queue-code*
  // /usr/include/c++/4.9/bits/stl_queue.h

  /**
   *  @brief  A standard container giving FIFO behavior.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Sequence  Type of underlying sequence, defaults to deque<_Tp>.
   *
   *  Meets many of the requirements of a
   *  <a href="tables.html#65">container</a>,
   *  but does not define anything to do with iterators.  Very few of the
   *  other standard container interfaces are defined.
   *
   *  This is not a true container, but an @e adaptor.  It holds another
   *  container, and provides a wrapper interface to that container.  The
   *  wrapper is what enforces strict first-in-first-out %queue behavior.
   *
   *  The second template parameter defines the type of the underlying
   *  sequence/container.  It defaults to std::deque, but it can be any type
   *  that supports @c front, @c back, @c push_back, and @c pop_front,
   *  such as std::list or an appropriate user-defined type.
   *
   *  Members not found in @a normal containers are @c container_type,
   *  which is a typedef for the second Sequence parameter, and @c push and
   *  @c pop, which are standard %queue/FIFO operations.
   */

  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {
      /**
       *  Returns true if the %queue is empty.
       */
      bool
        empty() const
        { return c.empty(); }

      /**  Returns the number of elements in the %queue.  */
      size_type
        size() const
        { return c.size(); }

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %queue.
       */
      reference
        front()
        {
          __glibcxx_requires_nonempty();
          return c.front();
        }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %queue.
       */
      const_reference
        front() const
        {
          __glibcxx_requires_nonempty();
          return c.front();
        }

      /**
       *  Returns a read/write reference to the data at the last
       *  element of the %queue.
       */
      reference
        back()
        {
          __glibcxx_requires_nonempty();
          return c.back();
        }

      /**
       *  Returns a read-only (constant) reference to the data at the last
       *  element of the %queue.
       */
      const_reference
        back() const
        {
          __glibcxx_requires_nonempty();
          return c.back();
        }

      /**
       *  @brief  Add data to the end of the %queue.
       *  @param  __x  Data to be added.
       *
       *  This is a typical %queue operation.  The function creates an
       *  element at the end of the %queue and assigns the given data
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */
      void
        push(const value_type& __x)
        { c.push_back(__x); }

#if __cplusplus >= 201103L
      void
        push(value_type&& __x)
        { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
        { c.emplace_back(std::forward<_Args>(__args)...); }
#endif

      /**
       *  @brief  Removes first element.
       *
       *  This is a typical %queue operation.  It shrinks the %queue by one.
       *  The time complexity of the operation depends on the underlying
       *  sequence.
       *
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       */
      void
        pop()
        {
          __glibcxx_requires_nonempty();
          c.pop_front();
        }
    }
}

Like stack, queue uses *cxx-deque* by default. The optional second template
parameter defines the container that the queue uses internally for its
elements.

The queue implementation simply maps the operations into appropriate calls of
the container that is used internally (Figure 12.4). You can use any sequence
container class that provides the member functions front(), back(),
          push_back(), and pop_front(). 
For example, you could also use a list as the container for the elements:

std::queue<std::string,std::list<std::string>> buffer;


12.2.1 The Core Interface

      back()            front()
          |             |
push() -> "priority queue" -> pop()

push()    inserts an element into the queue.

front()   returns the next element in the queue 
          (the element that was inserted first).

back()    returns the last element in the queue 
          (the element that was inserted last).

pop()     removes an element from the queue.

Note that pop() removes the next element but does not return it, whereas
front() and back() return the element without removing it. Thus, you must
always call front() and pop() to process and remove the next element from the
queue. This interface is somewhat inconvenient, but it performs better if you
want to only remove the next element without processing it.


*cxx-queue-priority*

12.3 Priority Queues

The class priority_queue<> implements a queue from which elements are read
according to their priority.

                        top()   // like front()
                        |
push() -> "priority queue" -> pop()


However, the `next element from top()` is not the first inserted element.
Rather, it is the element `that has the highest priority.` Thus, elements are
partially sorted according to their value. As usual, you can provide the
sorting criterion as a template parameter. By default, the elements are sorted
by using operator<(), *cxx-less* in descending order.

namespace std {
  template <typename T,
           typename Container = vector<T>,
           typename Compare = less<typename Container::value_type>>
             class priority_queue;
}

You can use any sequence container class that provides random-access iterators
and the member functions front(), push_back(), and pop_back(). Random access
is necessary for sorting the elements, which is performed by the heap
algorithms of the STL *algo-sort-heap*

o push() inserts an element into the priority queue.

o top() returns the next element in the priority queue without removing it

o pop() removes an element from the priority queue.


TEST(CollQueue, PriorityQueue)
{
  {
    queue<int> pq;

    pq.push(22);
    pq.push(66);
    pq.push(44);

    //         front
    // 44, 66, 22

    // queue do not have top()

    EXPECT_THAT(pq.front(), Eq(22));
    pq.pop();

    EXPECT_THAT(pq.front(), Eq(66));
    pq.pop();

    pq.push(11);
    pq.push(55);
    pq.push(33);

    //             top
    // 33, 55, 11, 44

    pq.pop();

    // since queue do not support begin()/end(), cannot use ElementsAre and copy
    // to transform it to a vector. Did it manually.
    // copy(pq.begin(), pq.end(), back_inserter(coll));

    vector<int> coll;

    while (!pq.empty())
    {
      coll.push_back(pq.front());
      pq.pop();
    }

    EXPECT_THAT(coll, ElementsAre(11, 55, 33));
  }

  {
    priority_queue<int> pq;

    pq.push(22);
    pq.push(66);
    pq.push(44);

    //         front
    // 22, 44, 66

    EXPECT_THAT(pq.top(), Eq(66));
    pq.pop();

    EXPECT_THAT(pq.top(), Eq(44));
    pq.pop();

    pq.push(11);
    pq.push(55);
    pq.push(33);

    // 11, 22, 33, 55

    pq.pop();

    // since queue do not support begin()/end(), cannot use ElementsAre and copy
    // to transform it to a vector. Did it manually.
    // copy(pq.begin(), pq.end(), back_inserter(coll));

    vector<int> coll;

    while (!pq.empty())
    {
      coll.push_back(pq.top());
      pq.pop();
    }

    EXPECT_THAT(coll, ElementsAre(33, 22, 11));
  }
}


{cxx-queue-operations}

12.4 Container Adapters in Detail

cxx-queue do not supports iterators.

// this is wrong
//
// template <typename T>
// void PRINT_Q_ELEMENTS(const T& coll, const string &optstr = "")
// {
//   size_t count = coll.size();
//   cout << optstr;
// 
//   for(size_t i = 0; i < count; ++i)
//     cout << coll.top() << " ";
// 
//   cout << "(" << count << ")" << endl;
// }


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-stack cxx-adaptor

stack, queue, priority_queue

STL stack uses *cxx-deque* by default and can change by giving it second paramenter.

template <class T, class Container = deque<T> > class stack;

std::stack<int,std::vector<int>> st;

The cxx-deque was chosen because, 

o unlike vectors, deques free their memory when elements are removed and don't
  have to copy all elements on reallocation (see Section 7.12, page 392, for a
  discussion of when to use which container).


This interface is somewhat inconvenient, but it performs better if you want only
to remove the next element without processing it. Note that the behavior of
top() and pop() is *cxx-undefined* if the stack contains no elements. The member
functions size() and empty() are provided to check whether the stack contains
elements.


<ex>

class Stack
{
   bool empty() const;
   void push(T const &elem);
   void pop();
   T &top();
}

TEST(StlStack, check_basic_example)
{
  std::vector<int> coll{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

  std::stack<int> result1;
  std::vector<int> result2;

  // fill in stack
  for (auto e : coll)
    result1.push(e);

  // cxx-stack not work with gtest
  // EXPECT_THAT(result1, ElementsAreArray({12,11,10,9,8,7,6,5,4,3,2,1}));

  // change top element
  result1.top() = 98;

  // EXPECT_THAT(result1, ElementsAreArray({98,11,10,9,8,7,6,5,4,3,2,1}));

  while (!result1.empty())
  {
    result2.push_back(result1.top());
    result1.pop();
  }

  EXPECT_THAT(result2,
              ElementsAreArray({98, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}));
}


<ex> *cxx-class-model* is-implemented-in-terms-of

The standard class stack<> prefers speed over convenience and safety. This is
own stack class, which has the following two advantages:

o pop() returns the next element.
o pop() and top() throw exceptions when the stack is empty. Unlike the
  standard stack class, this one throws an exception rather than resulting in
  undefined behavior.

In addition, have skipped the members that are not necessary for the ordinary
stack user, such as the comparison operations.


namespace cxx_stack
{
  class ReadOnEmptyStack : public std::exception
  {
  public:
    virtual const char *what() const noexcept
    {
      return "connot read when statck is empty";
    }
  };

  template <typename T>
  class Stack
  {
  private:
    std::deque<T> _coll;

  public:
    bool empty() const { return _coll.empty(); }

    void push(const T &elem) { _coll.emplace_back(elem); }

    void pop()
    {
      if (_coll.empty())
        throw ReadOnEmptyStack();

      _coll.pop_back();
    }

    T &top()
    {
      if (_coll.empty())
        throw ReadOnEmptyStack();

      // note "back() but not pop_back()"
      return _coll.back();
    }
  };
} // namespace cxx_stack

TEST(StlStack, check_implemented_in_terms_of)
{
  using namespace cxx_stack;

  Stack<int> coll{};
  std::vector<int> result{};

  coll.push(10);
  coll.push(20);
  coll.push(30);

  coll.pop();

  coll.top() = 80;

  coll.push(100);
  coll.push(200);

  while (!coll.empty())
  {
    result.emplace_back(coll.top());
    coll.pop();
  }

  EXPECT_THAT(result, ElementsAre(200, 100, 80, 10));

  // stack is already empty
  EXPECT_THROW(coll.pop(), ReadOnEmptyStack);
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-list

A cxx-list is implemented as a `doubly linked list` of elements and do not
provide random access. The advantage of a list is that the insertion or
removal of an element is fast at any position.

namespace cxx_code
{
  // bits/stl_list.h

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
  {
  };
} // namespace


<cxx-list-no-random-access>
A direct element access by using operator[] is not provided for lists. This is
because lists don't provide random access, and so an operator[] would have bad
performance.


<cxx-list-ops>
front()
push_front()
pop_front()

back(),
push_back()
pop_back()

c.clear() 
Removes all elements (empties the container)

TEST(List, Ops)
{
  std::list<int> coll1, coll2;

  for (int i = 0; i < 6; ++i)
  {
    coll1.push_back(i);
    coll2.push_front(i);
  }

  EXPECT_THAT(coll1, ElementsAre(0,1,2,3,4,5));
  EXPECT_THAT(coll1.size(), 6); 
  EXPECT_THAT(coll2, ElementsAre(5,4,3,2,1,0));
  EXPECT_THAT(coll2.size(), 6); 

  EXPECT_THAT(coll1.front(), 0);
  EXPECT_THAT(coll1.back(), 5);
  EXPECT_THAT(coll1.size(), 6); 

  // void pop_front() so cannot use EXPECT_THAT()
  coll1.pop_front();
  EXPECT_THAT(coll1.size(), 5); 

  coll1.pop_back();
  EXPECT_THAT(coll1.size(), 4); 

  EXPECT_THAT(coll1, ElementsAre(1,2,3,4));
}

TEST(List, Erase)
{
  std::list<int> coll{10,20,30,40,50};

  auto iter = coll.begin();

  ++iter;
  ++iter;

  coll.erase(coll.begin(), iter);

  EXPECT_THAT(coll, ElementsAre(30,40,50));
}


<cxx-list-splice> cxx-splice

note:
Only for cxx-list or cxx-forward-list

Splice Functions and Functions to Change the Order of Elements

Linked lists have the advantage that you can remove and insert elements at any
position in constant time. If you move elements from one container to another,
this advantage doubles in that you need only redirect some internal
pointers

To support this ability, lists provide not only remove() but also additional
modifying `member functions` to change the order of and relink elements and
ranges. You can call these operations to move elements inside a single list or
between two lists, provided that the lists have the same type.

Table 7.25. Special Modifying Operations for Lists

c.splice(pos, c2) 

`Moves` all elements of c2 to c in front of the iterator position pos.

void list::splice (const_iterator pos, list& source);
void list::splice (const_iterator pos, list&& source);

c.splice(pos, c2, c2pos) 

Moves `the single element` at c2pos in c2 `in front of pos` of list c (c and c2
may be identical)

c.splice(pos, c2, c2beg, c2end) 

Moves all elements of the range [c2beg,c2end) in c2 in front of pos of list c
(c and c2 may be identical)

o Move all elements of the list source into *this and insert them at the
  position of iterator pos.

o After the call, source is empty.

o If source and *this are identical, the behavior is undefined. Thus, the
  caller must ensure that source is a different list. To move elements inside
  the same list, you must use the following forms of splice().

o The caller must ensure that pos is a valid position of *this; otherwise, the
  behavior is undefined.

o Pointers, iterators, and references to members of source remain valid. Thus,
  they belong to this afterward.

* This function does not throw.

o The second form is available since C++11. Before C++11, type iterator was
  used instead of const_iterator.

* Provided by list.


<cxx-list-merge>
c.merge(c2) 
Assuming that both containers contain the elements `sorted`, moves all elements
of c2 into c so that all elements are merged and still sorted

c.merge(c2,op) 
Assuming that both containers contain the elements sorted due to the sorting
criterion op(), moves all elements of c2 into c so that all elements are
merged and still sorted according to op()


<ex>

TEST(List, SpliceAndMerge)
{
  list<int> list_one, list_two;
 
  for(int i=0; i < 6; ++i)
  {
    list_one.push_back(i);
    list_two.push_back(10 + i);
  }
 
  EXPECT_THAT(list_one, ElementsAre(0, 1, 2, 3, 4, 5));
  EXPECT_THAT(list_two, ElementsAre(10, 11, 12, 13, 14, 15));
 
  // splice, verb, to join two pieces of rope, film, etc. together at their
  // ends in order to form one long piece:
  //
  // c.splice(pos,c2) Moves all elements of c2 to c in front of the iterator
  // position pos
  // moves all elements of list_one before the pos of '3' element.
 
  list_two.splice(find(list_two.begin(), list_two.end(), 13), list_one);
 
  // list_one becomes 0

  EXPECT_EQ(list_one.size(), 0); 

  // 10 11 12 [0 1 2 3 4 5] 13 14 15 

  EXPECT_THAT(list_two, 
      ElementsAreArray({10, 11, 12, 0, 1, 2, 3, 4, 5, 13, 14, 15})); 
 
  // c.splice(pos,c2,c2pos) 
  // Moves the element at c2pos in c2 in front of pos of list c 
  // (c and c2 may be identical)
  //
  // move first element of list_two to the end
 
  list_two.splice(list_two.end(), list_two, list_two.begin());
  EXPECT_THAT(list_two, 
      ElementsAreArray({11, 12, 0, 1, 2, 3, 4, 5, 13, 14, 15, 10})); 
 
  list<int> list_three;
  // move first element of list_two to the first of list_three
  list_three.splice(list_three.begin(), list_two, list_two.begin());
 
  EXPECT_THAT(list_two, 
      ElementsAreArray({12, 0, 1, 2, 3, 4, 5, 13, 14, 15, 10})); 
  EXPECT_THAT(list_three, ElementsAre(11)); 
 
  list<int> coll1{20, 21, 22};
  list<int> coll2{30, 31, 32};
  list_three.splice(list_three.begin(), coll1);
  list_three.splice(list_three.end(), coll2);
  EXPECT_THAT(list_three, 
      ElementsAreArray({20,21,22,11,30,31,32}));
 
  // merge

  list<int> list4{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};
  list<int> list5{0, 1, 2, 3, 4, 5};
 
  list5.merge(list4);
  EXPECT_THAT(list5, 
      ElementsAreArray({0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5}));
 
  // 8.8.1 Special Member Functions for Lists (and Forward Lists)
  //
  // Strictly speaking, the standard requires that both (forward) lists be
  // sorted on entry. In practice, however, merging is also possible for
  // unsorted lists. However, you should check this before you rely on it.
  // 
  // list<int> list5;
  // list5.merge({4, 1, 0, 3, 2, 5});
  // EXPECT_THAT(list5, ElementsAreArray({0, 1, 2, 3, 4, 5}));
  //
  // cxx-runtime-error
  //
  // /usr/include/c++/4.9/debug/list:691:error: elements in iterator range [
  //     __x.begin().base(), __x.end().base()) are not sorted.
  //
  // Aborted.
  //
  // list<int> list6;
  // list6.merge({4, 1, 0, 3, 2, 5});
  // EXPECT_THAT(list6, Not(ElementsAreArray({0, 1, 2, 3, 4, 5})));
}


// c.splice(pos,c2, c2beg,c2end) 
// Moves all elements of the range [c2beg,c2end) in c2 in
// front of pos of list c (c and c2 may be identical)

TEST(List, SpliceAndDivide)
{
  list<int> coll{26, 33, 35, 29, 19, 12, 22};
  auto slow = coll.begin();
  auto fast = next(slow);

  for(;fast != coll.end();)
  {
    ++fast;

    if (fast != coll.end())
    {
      ++fast;
      ++slow;
    }
  }

  list<int> coll1;
  list<int> coll2;

  // due to open end of iterator, increase one more compared to C version.
  ++slow;

  coll1.splice(coll1.begin(), coll, coll.begin(), slow);
  coll2.splice(coll2.begin(), coll, slow, coll.end());

  EXPECT_THAT(coll1, ElementsAre(26,33,35,29));
  EXPECT_THAT(coll2, ElementsAre(19,12,22));
}


<cxx-list-sort>

namespace algo_code
{
  // /bits/list.tcc

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {
      // Do nothing if the list has length 0 or 1.
      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
          && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
        {
          __carry.splice(__carry.begin(), *this, begin());

          for(__counter = &__tmp[0];
              __counter != __fill && !__counter->empty();
              ++__counter)
          {
            __counter->merge(__carry);
            __carry.swap(*__counter);
          }
          __carry.swap(*__counter);
          if (__counter == __fill)
            ++__fill;
        }
        while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-list-forward-list

7.6.1 Abilities of Forward Lists

Forward lists have the following limitations compared to lists:

o A forward list does not provide a size() member function. This is a
  consequence of omitting features that create time or space overhead relative
  to a handwritten singly linked list.

Forward lists provide no size() operation. The reason is that it is not
possible to store or compute the current number of elements in constant time.
And to make the fact visible that size() is an expensive operation, it is not
provided. If you have to compute the number of elements, you can use
distance()

So, if you need the size, either track it outside the forward_list or use a
list instead.

*cxx-remember*
o The anchor of a forward list `has no pointer to the last element.` For this
  reason, `a forward list does not provide` the special member functions to
  deal with the last element, back(), push_back(), and pop_back().

Other than these differences, forward lists behave just like lists:


c.front() 
Returns the first element (no check whether a first element exists)

c.begin() 
Returns a bidirectional iterator for the first element

c.end() 
Returns a bidirectional iterator for the position after the last element

c.cbegin() 
Returns a constant bidirectional iterator for the first element (since C++11)

c.cend() 
Returns a constant bidirectional iterator for the position after the last
element (since C++11)

c.before_begin() 
Returns a forward iterator for the position before the first element

c.cbefore_begin() 
Returns a constant forward iterator for the position before the first element

Note that before_begin() and cbefore_begin() do not represent a valid position
of a forward list.

Besides copying and assignments, the only valid operations for return values
of before_begin() are ++, ==, and !=.


before_begin() or insert_after()

Note that for all the insert, emplace, and erase member functions provided for
forward lists, you have a problem: They usually get a position of an element,
where you have to insert a new element or must delete. But this requires a
  modification of the preceding element, because there the pointer to the next
  element has to get modified. For lists, you can just go backward to the
  previous element to manipulate it, `but for forward lists, you can’t.` 

For this reason, the member functions behave differently than for lists, which
is reflected by the name of the member functions. All end with _after, which
means that they insert a new element after the one passed (i.e., they append)
or delete the element after the element passed.



Table 7.32. Insert and Remove Operations of Forward Lists

c.push_front(elem)
c.pop_front()

c.insert_after(pos,elem)
c.insert_after(pos,n,elem) 
c.insert_after(pos,beg,end) 
c.insert_after(pos,initlist) 
c.emplace_after(pos,args...) 
c.emplace_front(args...) 

c.erase_after(pos)
c.erase_after(beg,end)
c.remove(val)
c.remove_if(op)

c.resize(num)
c.resize(num,elem)
c.clear()


<ex> 

TEST(ForwardList, InsertAfter)
{
  {
    forward_list<int> coll{1,2,3};
    coll.insert_after(coll.before_begin(), {77, 88, 99});
    EXPECT_THAT(coll, ElementsAre(77, 88, 99, 1, 2, 3));
  }

  // Note that calling an _after member function with end() or cend() results in
  // undefined behavior because to append a new element at the end of a forward
  // list, you have to pass the position of the last element (or before_begin()
  // if none): 
  //
  // RUNTIME ERROR: appending element after end is undefined behavior 
  //
  // fwlist.insert_after(fwlist.end(),9999);
  //
  // {
  //   forward_list<int> coll{1,2,3};
  //   coll.insert_after(coll.end(), {77, 88, 99});
  //   EXPECT_THAT(coll, ElementsAre(1, 2, 3, 77, 88, 99));
  // }
}

// The drawbacks of having a singly linked list, where you can only traverse
// forward, gets even worse when trying to find an element to insert or delete
// something there. The problem is that when you find the element, you are too
// far, because to insert or delete something there you have to manipulate the
// element before the element you are searching for. For this reason, you have
// to find an element by determining whether the next element fits a specific
// criterion

TEST(ForwardList, DrawBacks)
{
  forward_list<int> coll{1, 2, 3, 4, 5, 97, 98, 99};

  auto pos_before = coll.before_begin();
  for (auto pos = coll.begin(); pos != coll.end(); ++pos, ++pos_before)
  {
    if (*pos % 2 == 0)
      break;
  }

  coll.insert_after(pos_before, 42);
  EXPECT_THAT(coll, ElementsAre(1, 42, 2, 3, 4, 5, 97, 98, 99)); 
}


<ex>
// This is *cxx-is-implemented-in-terms-of* to have size() which is not
// supported.

namespace use_forward_list
{
  template<typename T>
    class ForwardList
    {
      public:
        typedef typename std::forward_list<T>::iterator iterator;

        ForwardList() : count_(0) {}

        size_t size() const { return count_; }
        void push_front(const T& elem)
        {
          ++count_;
          list_.push_front(elem);
        }

        iterator begin() { return list_.begin(); }
        iterator end() { return list_.end(); }

      private:
        size_t count_;
        std::forward_list<T> list_;
    };
}

TEST(ForwardList, ImplementedInTermsOf)
{
  using namespace use_forward_list;

  ForwardList<int> coll;

  for (int i = 0; i < 8; ++i)
  {
    coll.push_front(i);
  }

  // {7, 6, 5, 4, 3, 2, 1}
  
  ForwardList<int> rcoll;

  auto iter = coll.begin();
  for (iter; iter != coll.end(); ++iter)
  {
    rcoll.push_front(*iter);
  }

  // {1, 2, 3, 4, 5, 6, 7}
 
  //iter = rcoll.begin();
  //for (iter; iter != rcoll.end(); ++iter)
  //{
  //  cout << "iter: " << *iter << endl;
  //}

  // do not work since ForwardList is not complete and may not support gtest
  // expects
  // EXPECT_THAT(rcoll, ElementsAre(7, 6, 5, 4, 3, 2, 1, 0));
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-associative

Associative containers `sort their elements automatically` according to a
certain ordering criterion. By default, the containers compare the elements or
the keys with `cxx-less` operator<`. However, you can supply your own comparison
function to define another `sort-criterion`.

<what-container-consideration> cxx-set-performance cxx-map-performance

Pros:

Typically implemented as binary trees. The associative containers differ in
the kinds of elements they support and how they handle duplicates. GCC uses
`red black tree` which is balanced binary tree and search functions have
`log(n)` logarithmic complexity.

Since uses the same rb tree, can consider a cpp-set as a special kind of
cpp-map, in which the value is 'identical' to the key.


Cons:

However, automatic sorting also imposes an important constraint on sets and
multisets: You may not change the value of an element directly, because doing
so might compromise the correct order.

Therefore, to modify the value of an element, you must remove the element
having the old value and insert a new element that has the new value. 

The interface reflects this behavior: 

* `set` and `multiset` don't provide operations for direct element access.
  However, maps has.

* `indirect access via iterators` has the constraint that, from the iterator's
  point of view, the element value is 'constant'.
  *TN* means that cannot use modifying algorithm like algo-remove but can use
  const iterator with coll.erase().


{element-access}
sets and multisets do not provide direct element access, so you have to use
range-based for loops or iterators. Sets and multisets provide the usual
member functions for iterators (Table 7.38).

c.begin()   Returns a bidirectional iterator for the first element
c.end()     Returns a bidirectional iterator for the position after the last
            element
c.cbegin()  Returns a constant bidirectional iterator for the first element
            (since C++11)
c.cend()    Returns a constant bidirectional iterator for the position after
            the last element (since C++11)
c.rbegin()  Returns a reverse iterator for the first element of a reverse
            iteration
c.rend()    Returns a reverse iterator for the position after the last element
            of a reverse iteration
c.crbegin() Returns a constant reverse iterator for the first element of a
            reverse iteration (since C++11)
c.crend()   Returns a constant reverse iterator for the position after the
            last element of a reverse iteration (since C++11)


{iterator-category}
As with all associative container, the iterators are `bidirectional iterators`
Thus, you can't use them in algorithms that are provided 'only' for
random-access iterators, such as algorithms for sorting or random shuffling.


{same-type}
Comparisons are provided only for containers of the same type which includes
sorting criterion. Thus, the elements and the sorting criterion must have the
same types; otherwise, a type error occurs at compile time. For example:

std::set<float> c1;                       // sorting criterion: std::less<>
std::set<float,std::greater<float> > c2;  // std::greater<>
...
if (c1 == c2) { // ERROR: different types
...
}


{change-sorting-criterion} stl-set stl-multiset

set c(op)         Creates an empty set/multiset that uses op as the sorting 
                  criterion

set<Elem>         A set that by default sorts with less<> (operator <)
set<Elem,Op>      A set that by default sorts with Op
multiset<Elem>    A multiset that by default sorts with less<> (operator <)
multiset<Elem,Op> A multiset that by default sorts with Op


<cxx-map-element-type>
if two 'containers' are 'compared' by operator ==, the elements in both
containers are compared using their operator ==, which means that operator ==
has to be provided for the 'element' type.

map c(op)            Creates an empty map/multimap that uses op as the sorting
                     criterion

map<Key,Val>         A map that by default sorts keys with less<> (operator <)
map<Key,Val,Op>      A map that by default sorts keys with Op
multimap<Key,Val>    A multimap that by default sorts keys with less<> (operator <)
multimap<Key,Val,Op> A multimap that by default sorts keys with Op

There are two ways to set sorting criterion.


<as-a-template-parameter>
In this case, the sorting criterion is 'part' of the type. This is the usual
way to specify the sorting criterion. To be more precise, the second parameter
is the 'type' of the sorting criterion. The concrete sorting criterion is the
function 'object' that gets created with the container. To do this, the
constructor of the container calls the default constructor of the type of the
sorting criterion.

typedef std::set<int, std::greater<int>> IntSet; 
typedef std::map<float, std::string, std::greater<float>> coll; 


<as-a-constructor-parameter> 
You might have a type for several sorting criteria that allows having
different initial values or states. This is useful when processing the sorting
criterion at 'runtime' and when sorting criteria are needed that are different
(criterion) but of the same data type.

<ex>
multiset< std::shared_ptr<Quote>, decltype(compare)*> items{ compare };

<ex>
You need a special type for the sorting criterion: one that lets you pass your
sorting details at runtime.

#include <iostream>
#include <set>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

class RuntimeCmp
{
  public:
    enum cmp_mode {normal, reverse};

  private:
    cmp_mode mode;

  public:
    RuntimeCmp( cmp_mode m = normal ) : mode(m) { }

    // call operator. comparison of 'elements': member function for any element type
    template<typename T>
      bool operator() ( const T& t1, const T& t2 ) const
      { return mode == normal ? t1 < t2 : t2 < t1; }

    // comparison of sorting criteria
    bool operator==( const RuntimeCmp& rc ) const 
    { return mode == rc.mode; }
};

typedef set<int, RuntimeCmp> IntSet;

int main()
{
  // use default sorting criterion
  IntSet coll1{ 4, 7, 5, 1, 6, 2, 5 }; 
  PRINT_ELEMENTS(coll1, "coll1 : ");

  // create sorting criterion with reverse order
  RuntimeCmp reverse_order(RuntimeCmp::reverse);

  IntSet coll2(reverse_order);            // <key> set c(op)
  coll2 = { 4, 7, 5, 1, 6, 2, 5 };
  PRINT_ELEMENTS(coll2, "coll2 : ");

  coll1 = coll2;                          // <key> instant change of criterion
  coll1.insert(3);
  PRINT_ELEMENTS(coll1, "coll1 : ");

  // One of Nonmodifying operations for set family
  //
  // c.key_comp() Returns the comparison criterion
  //
  // c.value_comp() Returns the comparison criterion for values as a whole
  // (same as key_comp())

  if( coll1.value_comp() == coll2.value_comp() )
    cout << "coll1 and coll2 have the same sorting criterion" << endl;
  else
    cout << "coll1 and coll2 have the different sorting criterion" << endl;
}

coll1 : 1 2 4 5 6 7 
coll2 : 7 6 5 4 2 1 
coll1 : 7 6 5 4 3 2 1 
coll1 and coll2 have the same sorting criterion

note: the class RuntimeCmp provides the general ability to specify, at
runtime, the sorting criterion for any type.

note: that coll1 and coll2 have the same type, which is 'not' the case when
passing less<> and greater<> as sorting criteria. 

If try to use set c<elem, op> then not compile since they are different type.

typedef set<int> LessSet;
typedef set<int, greater<int>> GreaterSet;

int main()
{
  // use default sorting criterion
  LessSet coll1{ 4, 7, 5, 1, 6, 2, 5 }; 
  PRINT_ELEMENTS(coll1, "coll1 : ");

  GreaterSet coll2{ 4, 7, 5, 1, 6, 2, 5 };
  PRINT_ELEMENTS(coll2, "coll2 : ");

  // coll1 = coll2;                       // ERROR
  // coll1.insert(3);
  // PRINT_ELEMENTS(coll2, "coll1 : ");

  //if( coll1.value_comp() == coll2.value_comp() )    // ERROR
  //  cout << "coll1 and coll2 have the same sorting criterion" << endl;
  //else
  //  cout << "coll1 and coll2 have the different sorting criterion" << endl;
}

note: also that the assignment operator assigns the elements and the sorting
criterion; If change coll1 as below and run the program:

  IntSet coll1{ 4, 7 }; 

Then the result:

coll1 : 4 7 
coll2 : 7 6 5 4 2 1 
coll1 : 7 6 5 4 3 2 1 
coll1 and coll2 have the same sorting criterion

That seems useful since if use c<elem, op> approach, copy each item into the
other set which has different sorting criterion.

<example>
1. How to define a sorting criterion at runtime
2. How to compare strings in a case-insensitive way

#include <iostream>
#include <map>
#include <algorithm>
#include <iomanip>      // for setw()

using namespace std;

class RuntimeStringCmp
{
  public:
    enum cmp_mode {normal, nocase};

  private:
    const cmp_mode mode;

    // aux to compare case insensitive
    // *cxx-toupper*
    static bool nocase_compare( char c1, char c2 )
    { return toupper(c1) < toupper(c2); }

  public:
    RuntimeStringCmp( cmp_mode m = normal ) : mode(m) { }
    
    // the comparison. must be const on all args; otherwise type mismatch compile error
    // 
    // The reference p548. 
    // Lexicographical comparison means that sequences are compared element-by-element. For string
    // element is char
    //
    // bool
    // lexicographical_compare (InputIterator1 beg1, InputIterator1 end1, 
    //                          InputIterator2 beg2, InputIterator2 end2, 
    //                          CompFunc op)
    //
    bool operator() ( const string &s1, const string &s2 ) const 
    {
      if( mode == normal )
        return s1 < s2;
      else
        return lexicographical_compare( s1.begin(), s1.end(),
            s2.begin(), s2.end(), nocase_compare );
    }
};

// container type
typedef map<string, string, RuntimeStringCmp> ssmap;

// fill and print container
void fillAndPrint( ssmap &coll );

int main()
{
  ssmap coll1;
  fillAndPrint(coll1);

  RuntimeStringCmp ignorecase(RuntimeStringCmp::nocase);

  ssmap coll2(ignorecase);
  fillAndPrint(coll2);
}

void fillAndPrint( ssmap &coll )
{
  // insert elements in random order
  coll["Deutschland"] = "Germany";
  coll["deutsch"] = "German";
  coll["Haken"] = "snag";
  coll["arbeiten"] = "work";
  coll["Hund"] = "dog";
  coll["gehen"] = "go";
  coll["Unternehmen"] = "enterprise";     // duplicate
  coll["unternehmen"] = "undertake";
  coll["gehen"] = "walk";
  coll["Bestatter"] = "undertaker";

  // *cxx-stream-setf*
  cout.setf(ios::left, ios::adjustfield);

  for( const auto &elem : coll )
    cout << setw(15) << elem.first << " " << elem.second << endl;

  cout << endl;
}

Bestatter       undertaker
Deutschland     Germany
Haken           snag
Hund            dog
Unternehmen     enterprise
arbeiten        work
deutsch         German
gehen           walk
unternehmen     undertake

arbeiten        work
Bestatter       undertaker
deutsch         German
Deutschland     Germany
gehen           walk
Haken           snag
Hund            dog
Unternehmen     undertake

note: The second block changed the order due to 'nocase' criterion.  
note:
that the second block has one item 'less' because the uppercase word
"Unternehmen" is, from a case-insensitive point of view, equal to the
lowercase word "unternehmen" note: The signature of operator() must be const.


={============================================================================
*kt_dev_cxx_0000* cxx-coll-cxx-set cxx-multiset

namespace cxx_code
{
  // bits/stl_set.h

  template<typename _Key, 
  typename _Compare = `std::less<_Key>`,
  typename _Alloc = std::allocator<_Key> >
    class set
    {
    };

  template <typename T,
           typename Compare = less<T>,
           typename Allocator = allocator<T> >
             class multiset;

} // namespace

// like cxx-sp-unique
std::set<int, greater<int>> iset{13, 9, 7, 10, 2, 11, 12, 8, 7};


{cxx-set-type-requirement}
The elements of a set or a multiset 

o may have any type T that is `comparable` according to the sorting criterion. 

o The optional second template argument defines the sorting criterion and if
not passed, the default criterion `cxx-less <` is used.


{cxx-set-search-operations} cxx-coll-search
Because they are optimized for fast searching of elements, sets and multisets
provide `special search functions` (Table 7.36). These functions are special
versions of general algorithms that have the same name. 

You should always 'prefer' the optimized versions for sets and multisets to
achieve logarithmic complexity instead of the linear complexity of the
`general algorithms.`

*cxx-set-count*

namespace cxx_code
{
  /**
   *  @brief  Finds the number of elements.
   *  @param  __x  Element to located.
   *  @return  Number of elements with specified key.
   *
   *  This function only makes sense for multisets; for set the result will
   *  either be 0 (not present) or 1 (present).
   */
  size_type
    count(const key_type& __x) const;
}

c.count(val)      
Returns the number of elements with value val

TEST(CxxSet, check_duplicate)
{
  {
    std::set<int> coll{13, 9, 7, 10, 2, 11, 12, 8, 7};

    // duplicate, 7, is removed
    EXPECT_THAT(coll.size(), 8);

    auto begin = coll.begin();
    coll.erase(begin);

    begin = coll.begin();
    coll.erase(begin);

    EXPECT_THAT(coll, ElementsAre(8, 9, 10, 11, 12, 13));
    EXPECT_THAT(coll.size(), 6);
  }

  {
    std::multiset<int, greater<int>> coll{13, 9, 7, 10, 2, 11, 12, 8, 7};
    size_t duplicate_count{};

    // see duplicates
    EXPECT_THAT(coll, ElementsAre(13, 12, 11, 10, 9, 8, 7, 7, 2));

    // for (auto e : coll)
    //   if (coll.count(e) % 2 == 0)
    //     ++duplicate_count;

    for (auto e : coll)
      if (1 < coll.count(e))
        ++duplicate_count;

    // why 2 since see 7 two times in a loop
    EXPECT_THAT(duplicate_count, 2);
  }
}


*cxx-set-find*

namespace cxx_code
{
  /**
   *  @brief Tries to locate an element in a %set.
   *  @param  __x  Element to be located.
   *  @return  Iterator pointing to sought-after element, or end() if not
   *           found.
   *
   *  This function takes a key and tries to locate the element with which
   *  the key matches.  If successful the function returns an iterator
   *  pointing to the sought after element.  If unsuccessful it returns the
   *  past-the-end ( @c end() ) iterator.
   */
  iterator
    find(const key_type& __x);
}

c.find(val)       
Returns the position of the `first element` with value val (or end() if none
    found)


*cxx-set-find-vs-count*

For containers with single key, find and count do the same (but the return is
    different) but for containers with multiple key, count has to do more work
since still has to count how many elements have the same key. So if don't need
the count, it's best to use find.


<cxx-set-multi-order-of-duplicates>
For multisets, `since C++11 it is guaranteed that` insert(), emplace(), and
erase() preserve the relative ordering of equivalent elements, and that
inserted elements are placed `at-the-end` of existing equivalent values.

  x   x   x   x   x   x   x
      [  equal    ) 
      lower       upper
      
c.lower_bound(val) 
Returns an `iterator` to the first element `with key not less than val.`

c.upper_bound(val) 
Returns an `iterator` to the first element `with key greater than val.`

c.equal_range(val) 
Returns a `range, pair of iterators`, denoting the elements with val

lower_bound() returns the position of the first element that has the same or a
greater value than the argument, whereas upper_bound() returns the position of
the first element with a greater value. Thus, equal_range() returns the range
of elements that have the same value as the argument.

Not only to find. Can be used to get a position to be inserted in sorted
order.

note: 
these _bound members usually used for multiset, can be used with set.


<ex>
When there are multiple elements of the same key, those will be `adjacent`
within the container.

// this is for multimap
string search_item("Alain de Botton");

auto entries = aurthors.count(search_item);
auto iter = aurthors.find(search_item);

// this relys on the fact that multiple elements are adjacent.
while (entries) {
  cout << iter->second << endl;
  ++iter;
  --entries;
}

// 
for (auto beg = authors.lower_bound(search_item),
    end = authors.upper_bound(search_item);
    beg != end;
    ++beg)
  cout << beg->second << endl;

// return a pair of iterators
for (auto pos = authors.equal_range(search_item);
    pos.first != pos.second;
    ++pos.first)
  cout << pos.first->second << endl;


TEST(Set, Search)
{
  {
    set<int> coll;

    coll.insert(1);
    coll.insert(2);
    coll.insert(4);
    coll.insert(5);
    coll.insert(6);

    EXPECT_THAT(coll, ElementsAre(1, 2, 4, 5, 6));

    EXPECT_THAT(*coll.lower_bound(3), 4);

    // Returns an iterator to the first element with key greater than val.
    EXPECT_THAT(*coll.upper_bound(3), 4);

    EXPECT_THAT(*coll.equal_range(3).first, 4);
    EXPECT_THAT(*coll.equal_range(3).second, 4);


    EXPECT_THAT(*coll.lower_bound(5), 5);

    // Returns an iterator to the first element with key greater than val.
    EXPECT_THAT(*coll.upper_bound(5), 6);

    EXPECT_THAT(*coll.equal_range(5).first, 5);
    EXPECT_THAT(*coll.equal_range(5).second, 6);
  }

  {
    multiset<int> coll;

    coll.insert(1);
    coll.insert(2);
    coll.insert(3);   // 2
    coll.insert(3);
    coll.insert(3);   // 4
    coll.insert(4);   // 5
    coll.insert(5);
    coll.insert(6);

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 3, 3, 4, 5, 6));

    EXPECT_THAT(distance(coll.begin(), coll.lower_bound(3)), 2);

    // Returns an iterator to the first element with key greater than val.
    EXPECT_THAT(distance(coll.begin(), coll.upper_bound(3)), 5);

    EXPECT_THAT(distance(coll.begin(), coll.equal_range(3).first), 2);
    EXPECT_THAT(distance(coll.begin(), coll.equal_range(3).second), 5);
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-map cxx-map cxx-multimap cxx-size-t

*cxx-size-t*
type `size_t` is a machine-specific `unsigned type` that is guaranteed to be
large enough to hold the size of `any` object in memory.

namespace cxx_code 
{
  // /usr/include/c++/4.9/cstddef

#ifndef _GLIBCXX_CSTDDEF
#define _GLIBCXX_CSTDDEF 1

#pragma GCC system_header

#include <bits/c++config.h>
#include <stddef.h>

#if __cplusplus >= 201103L
  namespace std
  {
    // We handle size_t, ptrdiff_t, and nullptr_t in c++config.h.
    using ::max_align_t;
  }
#endif

#endif // _GLIBCXX_CSTDDEF


  // c++config.h
  namespace std
  {
    typedef __SIZE_TYPE__ size_t;
    typedef __PTRDIFF_TYPE__ ptrdiff_t;

    // *cxx-nullptr*
#if __cplusplus >= 201103L
    typedef decltype(nullptr) nullptr_t;
#endif
  }

  // *cxx-red-black-tree*
  // /usr/include/c++/4.9/bits/stl_tree.h

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc = allocator<_Val>> 
      class _Rb_tree
      {
        typedef size_t 				size_type;
      };


  // /usr/include/c++/4.9/bits/stl_map.h

  // *cxx-less*
  template
    <typename _Key, typename _Tp, `typename _Compare = std::less<_Key>,`
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >> 
    class map
    {
      public:
        typedef _Key                                          key_type;
        typedef _Tp                                           mapped_type;

        typedef std::pair<const _Key, _Tp>                    value_type;

        typedef typename _Rep_type::size_type              size_type;

        typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
                key_compare, _Pair_alloc_type> _Rep_type;

        typedef _Compare                                      key_compare;
        typedef _Alloc                                        allocator_type;

	     `_Compare comp;`

        // *cxx-map-insert*
        /**
         *  @brief Attempts to insert a std::pair into the %map.

         *  @param __x Pair to be inserted (see std::make_pair for easy
         *    creation of pairs).
         *
         *  @return  A pair, of which the first element is an iterator that 
         *           points to the possibly inserted pair, and the second is 
         *           a bool that is true if the pair was actually inserted.
         *
         *  This function attempts to insert a (key, value) %pair into the %map.
         *  A %map relies on unique keys and thus a %pair is only inserted if its
         *  first element (the key) is not already present in the %map.
         *
         *  Insertion requires logarithmic time.
         */
        std::pair<iterator, bool>
          insert(const value_type& __x)
          { return _M_t._M_insert_unique(__x); }
    };

  // bits/stl_multimap.h
  template 
    <typename _Key, typename _Tp,
    `typename _Compare = std::less<_Key>,`
      typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
      class multimap
      {
        // [23.3.1.2] element access
        /**
         *  @brief  Subscript ( @c [] ) access to %map data.
         *  @param  __k  The key for which data should be retrieved.
         *  @return  A reference to the data of the (key,data) %pair.
         *
         *  Allows for easy lookup with the subscript ( @c [] )
         *  operator.  Returns data associated with the key specified in
         *  subscript.  If the key does not exist, a pair with that key
         *  is created using default values, which is then returned.
         *
         *  Lookup requires logarithmic time.
         */
        mapped_type&
          operator[](const key_type& __k)
          {
            iterator __i = lower_bound(__k);

            // __i->first is greater than or equivalent to __k.
            if (__i == end() || `key_comp()(__k, (*__i).first)`)
              __i = insert(__i, value_type(__k, mapped_type()));

            return (*__i).second;
          }
      };
} // namespace


{cxx-map-type-requirement}
The elements of a map or a multimap may have any types Key and Tp that meet
the following two requirements:

o Both key and value must be copyable or movable.

o The key must be comparable with the sorting criterion. the default is `cxx-less`
  As with unique_ptr *cxx-sp-delete* use `typename` to set comp.

As with set, key is `constant`. However, a direct modification of the value of
the element is still possible, provided that the type of the value is not
constant.


{cxx-map-value-type} *cxx-remember*
When we dereference an iterator, get a reference to the container's `value type`

The value_type is `pair<'const' key_type, mapped_type>` so implies key cannot
be changed: 

      typedef std::pair<const _Key, _Tp>                    value_type;

This affects the use with algorithms because key is const, only be used with
algorithm that is read-only and the use is limited to search 

but associative is better in searching so `little use of map with algorithm.`
In practice, associative can be used as a source or dest in algorithm.

map<string, int>::value_type v3;    // pair< const string, int > 
map<string, int>::key_type v4;      // string
map<string, int>::mapped_type v5;   // int


{cxx-map-search-operations} cxx-map-find
`As for sets and multisets,` maps and multimaps provide special search member
functions that perform better because of their internal tree structure

c.count(val) 
Returns the number of elements with `key` 

c.find(val) 
Returns the position(iterator) of `the first element with key` or end() if
none found


{element-access} cxx-operator-[]
The usual way to access elements in associative container is via `cxx-range-for`
loops or iterators. An exception to that rule is that maps provide at() and
the subscript operator[] to access elements directly

reference container::operator[] (size_type idx)
const_reference container::operator[ ] (size_type idx) const

T& map::operator [] (const key_type& key)
T& map::operator [] (key_type&& key)

reference container::at (size_type idx)
const_reference container::at (size_type idx) const

T& map::operator at (const key_type& key)
const T& map::operator at (const key_type& key) const


*cxx-map-insert* <associative-array> <cpp-map-default-value>

The both maps and unordered maps can also be thought of as an
`associative-array`, an array whose index is not an integer value. As a
consequence, both containers provide the subscript operator[].

However, that the subscript operator does not behave like the usual subscript
operator for arrays: `Not having an element for an index is 'not' an error.` A
new index (or key) is taken as a reason `to create and insert a new element`
that has the index as the key. `Thus, you can't have an invalid index.`

c[key] 

Inserts an element with key, if it does not yet exist, and returns a reference
to the value of the element with key (only for nonconstant maps)

"Thus, to use this feature, you can't use a value type that has no default
constructor." 


c.at(key) *cxx-map-at*
Returns a reference to the value of the element with key (since C++11)

Returns a reference to the mapped value of the element with key equivalent to
key. If no such element exists, an exception of type `std::out_of_range` is
thrown.

coll.at("vat1") = 0.16;


`The fecth only works for map` but not multimaps since there are multiple
matches. Why not set? Since set has only key. Unlike other containers, [] op on
map returns `mapped_type` but dereferencing of iterator returns `value_type`. 


<ex>

word_count[word] = 1; 

Happens 3 setps but step 3 could be extra

o Search key and not found
o Insert temp element pair{word, 0}. value init since default ctor is called
o Assign it with 1

When accessing map with key which is not exist, cause addition. Inserts a new
element with key "ottto" and prints its value, which is 0 by default.

std::cout << coll["ottto"];

The real bug which meant to print out debug message but creates one elements
which is not added before due to if and else logic in the code.

NICKEL_TRACE("getSourceInformation: "
        << "configuration: " << sourceInfo["CONFIGURATION"]
        << "video size   : " << sourceInfo["VIDEO_WIDTH"]);

TEST(CxxMap, fetch_can_insert)
{
  std::map<unsigned int, int> expected{{1, 0}, {2, 0}, {3, 0}};

  // use insert()
  {
    std::map<unsigned int, int> coll;

    coll.insert({1, 0});
    coll.insert({2, 0});
    coll.insert({3, 0});

    EXPECT_THAT(coll.size(), 3);

    EXPECT_THAT(coll == expected, true);
  }

  // do the same
  {
    std::map<unsigned int, int> coll;

    coll[1];
    coll[2];
    coll[3];

    EXPECT_THAT(coll.size(), 3);

    EXPECT_THAT(coll == expected, true);
  }

  // do the same
  {
    std::map<unsigned int, int> _expected{{1, 1}, {2, 1}, {3, 1}};
    std::map<unsigned int, int> coll;

    coll[1]++;
    coll[2]++;
    coll[3]++;

    EXPECT_THAT(coll.size(), 3);

    EXPECT_THAT(coll == _expected, true);
  }
}


<ex>
*cxx-const-error-const* when calls non-const member on const object.

std::map<int, State> m_states;

void StateMachine::logTransition(int oldState, int newState) `const`
{
  if (oldState == newState) {
    message << "[" << objectName() << "] re-entering state "
      << m_states[newState].name << "(" << newState << ")";
  }
}

errors on "m_states[newState].name"


<ex> *ex-count-words* *ex-count-keyword*

string word;
map<string, size_t> word_count;

while( cin >> word )
   ++word_count[word];

// *cxx-11* *cxx-pair*
for( const auto &w : word_count )
   cout << w.first << " occurs" << 
          w.second << ((w.second>1) ? "times" : " time") << endl;


<ex>
Searching for elements that have a certain 'value' but not key promotes bad
performance.

You can't use the find() member function to search for an element that has a
certain 'value'. Instead, have to use a general algorithm, such as the
find_if() algorithm, or program an explicit loop. Here is an example of a
simple loop:

std::multimap<std::string,float> coll;

// do something with all elements having a certain value
std::multimap<std::string,float>::iterator pos;

for (pos = coll.begin(); pos != coll.end(); ++pos) {
  if (pos->second == value) {
    do_something();
  }
}


<ex>
// error when use -D_GLIBCXX_DEBUG
//
// MATCHER_P(EqPair, expected, "")
// {
//     return arg->first == expected.first && arg->second == expected.second;
// }

TEST(Map, Find)
{
  map<float,float> coll{ {1,7}, {2,4}, {3,2}, {4,3}, {5,6}, {6,1}, {7,3} };

  // *cxx-error*
  // when tries to use custom matcher, get's link error
  // ASSERT_THAT(posKey, EqPair(make_pair(3,2)));

  auto posKey = coll.find(3.0);
  EXPECT_THAT(*posKey, make_pair(3,2));

  // *algo-find-if-const* error if there is no const on predicate. 
  // since it's *cxx-algo-non-modifying* ?

  // *cxx-decltype*
  auto posVal = find_if( coll.cbegin(), coll.cend(),
      // [] ( const pair<float,float> &elem ) {
      // [] ( const map<float,float>::value_type &elem ) {
      [] ( const decltype(coll)::value_type &elem ) {
      return elem.second == 3.0;
      } );
  EXPECT_THAT(posVal->first, Eq(4));
  EXPECT_THAT(posVal->second, Eq(3));
}

TEST(Map, EqualRange)
{
  std::string str = "total";

  std::multimap<std::string, std::string> authors;

  // *cxx-map-insert*
  authors.insert( {"Kit, Park", "How to get through"} );
  authors.insert( {"Barth, John", "Sot-Weed Factor"} );
  authors.insert( {"Barth, John", "Lost in the Funhouse"});
  authors.insert( {"Andy, Steve", "Enterprise"});
  authors.insert( {"Barth, John", "A way to success"});

  std::string search_item("Barth, John");

  auto entries = authors.count( search_item );  // num of elements
  EXPECT_THAT(entries, 3);

  // use iter
  {
    vector<string> result{};
    auto iter = authors.find(search_item);      // first entry

    while( entries ) {
      result.push_back(iter->second);
      ++iter; --entries;
    }

    EXPECT_THAT(result, 
        ElementsAre("Sot-Weed Factor", "Lost in the Funhouse", "A way to success"));
  }

  // use _bound() calls
  {
    vector<string> result{};

    for (auto begin = authors.lower_bound(search_item), end = authors.upper_bound(search_item);
        begin != end; ++begin)
    {
      result.push_back(begin->second);
    }

    EXPECT_THAT(result, 
        ElementsAre("Sot-Weed Factor", "Lost in the Funhouse", "A way to success"));
  }

  // use equal_range()
  // return pair of iter in range [first, off-the-end). Like above, if not found
  // return the same.
  {
    vector<string> result{};
    auto iter = authors.find(search_item);      // first entry

    for (auto rpos = authors.equal_range(iter->first);
        rpos.first != rpos.second; ++rpos.first)
    {
      result.push_back(rpos.first->second);
    }

    EXPECT_THAT(result, 
        ElementsAre("Sot-Weed Factor", "Lost in the Funhouse", "A way to success"));
  }
}


<ex>
`As for set,` different iterator return for map and multimap. As for multiset,
you can't use erase() to remove only the first element of these duplicates
because erase() removes all.

std::multimap<std::string,float> coll;

auto pos = coll.find(key);
if (pos != coll.end()) {
  coll.erase(pos);
}


<ex> *algo-max-element* 

/*
algo-minmax

{
  // bits/predefined_ops.h
  // this is a bit different from cxx-less but do the same.

  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  // bits/stl_algo.h

  **
   *  @brief  Return the maximum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the largest value.

  template<typename _ForwardIterator>
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
      return _GLIBCXX_STD_A::__max_element(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
        if (__comp(__result, __first))
          __result = __first;
      return __result;
    }
}

*/

namespace algo_min_max
{
  bool AbsLess(int elem1, int elem2) { return abs(elem1) < abs(elem2); }
}

// copied from cxx-min-cxx-max
TEST(AlgoMinMax, check_stl_imps)
{
  using namespace algo_min_max;

  {
    std::deque<int> coll{2, 3, 4, 5, 6, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6};

    // NOTE: does it matter since we want max value but not index of max
    // element? yes if want to know the pos of it
    //
    // If more than one minimum or maximum element exists, min_element() and
    // max_element() return `the first` found; minmax_element() returns the first
    // minimum but the last maximum element, so max_element() and minmax_element()
    // don’t yield the same maximum element.

    EXPECT_THAT(*max_element(coll.begin(), coll.end()), 6);
    EXPECT_THAT(*min_element(coll.begin(), coll.end()), -3);

    // get the first
    EXPECT_THAT(distance(coll.begin(), max_element(coll.begin(), coll.end())),
                4);

    // return iterator pair
    // Note also that minmax_element() yields `the last maximum`, so the distance
    // 9.
    auto minmax = minmax_element(coll.begin(), coll.end());
    EXPECT_THAT(*(minmax.first), -3); // first minimum
    EXPECT_THAT(*(minmax.second), 6); // last maximum

    // last maximum is 6 which is the last element so minmax returns the last
    // max.
    EXPECT_THAT(distance(coll.begin(), minmax.second), coll.size() - 1);

    // see difference
    EXPECT_THAT(distance(minmax.first, minmax.second), 9);
    EXPECT_THAT(distance(min_element(coll.begin(), coll.end()),
                         max_element(coll.begin(), coll.end())),
                -1);

    // min/max of absolute values
    EXPECT_THAT(*min_element(coll.begin(), coll.end(), AbsLess), 0);
    EXPECT_THAT(*max_element(coll.begin(), coll.end(), AbsLess), 6);
  }
}

namespace algo_min_max
{
  struct my_less_1
  {
    template <typename _Iterator1, typename _Iterator2>
    bool operator()(_Iterator1 it1, _Iterator2 it2)
    {
      // see *cxx-pair-comparison*
      return *it1 < *it2;
    }
  };

  // use same iterator type
  struct my_less_2
  {
    template <typename _Iterator1>
    bool operator()(_Iterator1 it1, _Iterator1 it2)
    {
      // see *cxx-pair-comparison*
      return *it1 < *it2;
    }
  };

  // implement own min/max_element()
  // max_element(coll.begin(), coll.end();
  //
  // 1. how to define value_type of _Iterator? no need to define var for current
  // max value and comp function. All we need are iterators
  // 2. see comp is a copy

  template <typename _Iterator, typename _Compare>
  _Iterator my_max_element_1(_Iterator it1, _Iterator it2, _Compare comp)
  {
    // need to handle when there is only one element. otherwise, would access
    // to end which is error.
    if (it1 == it2)
      return it1;

    _Iterator result = it1;

    for (++it1; it1 != it2; ++it1)
    {
      // if "current < *it", that is get new max
      if (comp(result, it1))
        result = it1;
    }

    return result;
  }

  // "first and last" var naming seems better.
  template <typename _Iterator, typename _Compare>
  _Iterator
  my_max_element_2(_Iterator __first, _Iterator __last, _Compare __comp)
  {
    // if thre is only one
    if (__first == __last)
      return __first;

    _Iterator __result = __first;

    // if *__result < *__first
    while (++__first != __last)
      if (__comp(__result, __first))
        __result = __first;

    return __result;
  }

  template <typename _Iterator, typename _Compare>
  _Iterator
  my_min_element_2(_Iterator __first, _Iterator __last, _Compare __comp)
  {
    if (__first == __last)
      return __first;

    _Iterator __result = __first;

    while (++__first != __last)
      if (!__comp(__result, __first))
        __result = __first;

    return __result;
  }

  // same but "if (__comp(__first, __result))" which seems better
  template <typename _Iterator, typename _Compare>
  _Iterator
  my_min_element_3(_Iterator __first, _Iterator __last, _Compare __comp)
  {
    if (__first == __last)
      return __first;

    _Iterator __result = __first;

    while (++__first != __last)
      if (__comp(__first, __result))
        __result = __first;

    return __result;
  }

  // std-minmax
  // If more than one minimum or maximum element exists, min_element() and
  // max_element() return `the first` found;
  //
  // minmax_element() returns the first minimum but the last maximum element, so
  // max_element() and minmax_element() don’t yield the same maximum element.

  template <typename _Iterator>
  std::pair<_Iterator, _Iterator> my_minmax_element_1(_Iterator __first,
                                                      _Iterator __last)
  {
    if (__first == __last)
      return std::make_pair(__first, __last);

    _Iterator __max = __first;
    _Iterator __min = __first;

    while (++__first != __last)
    {
      // get max. add "=" to get the last max as std version
      if (*__max <= *__first)
        __max = __first;

      // get min
      if (*__first < *__min)
        __min = __first;
    }

    return std::make_pair(__min, __max);
  }
} // namespace algo_min_max

TEST(AlgoMinMax, UseOwn)
{
  using namespace algo_min_max;

  // on std-map
  {
    // sorted by key
    std::map<int, size_t> counts{{1, 2}, {3, 2}, {5, 3}, {8, 3}, {13, 1}};

    auto e = std::max_element(counts.begin(), counts.end());
    EXPECT_THAT(*e, std::make_pair(13, 1));

    // ForwardIterator
    // max_element (ForwardIterator beg, ForwardIterator end, CompFunc op)
    // op is used to compare two elements:
    // op(elem1,elem2)
    // It should return true when the first element is less than the second
    // element.

    auto maxelem = std::max_element(
      std::begin(counts),
      std::end(counts),
      [](pair<int, size_t> const &e1, pair<int, size_t> const &e2) {
        return e1.second < e2.second;
      });

    EXPECT_THAT(*maxelem, std::make_pair(5, 3));
  }

  // multimap
  {
    // sorted by key and the order in the equal range are the order of input
    std::multimap<int, size_t> counts{{1, 2},
                                      {3, 9},
                                      {3, 8},
                                      {5, 3},
                                      {8, 3},
                                      {13, 2},
                                      {13, 4},
                                      {13, 12},
                                      {13, 1}};

    // for (auto &e : counts)
    //   cout << e.first << ", " << e.second << endl;

    // Q: how max_element() finds the max on the second?
    // see *cxx-pair-comparison*

    auto e = std::max_element(counts.begin(), counts.end());
    EXPECT_THAT(*e, std::make_pair(13, 12));
  }

  // max_element
  {
    // sorted by key
    std::map<int, size_t> counts{{1, 2}, {3, 2}, {5, 3}, {8, 3}, {13, 1}};

    {
      auto pos = my_max_element_1(counts.begin(), counts.end(), my_less_1());
      EXPECT_THAT(*pos, std::make_pair(13, 1));
    }

    {
      auto pos = my_max_element_2(counts.begin(), counts.end(), my_less_1());
      EXPECT_THAT(*pos, std::make_pair(13, 1));
    }
  }

  // min_element
  {
    // sorted by key
    std::map<int, size_t> counts{{1, 2}, {3, 2}, {5, 3}, {8, 3}, {13, 1}};

    {
      auto pos = my_min_element_2(counts.begin(), counts.end(), my_less_1());
      EXPECT_THAT(*pos, std::make_pair(1, 2));
    }

    {
      auto pos = my_min_element_3(counts.begin(), counts.end(), my_less_1());
      EXPECT_THAT(*pos, std::make_pair(1, 2));
    }
  }

  // min_element and my_less_2
  {
    // sorted by key
    std::map<int, size_t> counts{{1, 2}, {3, 2}, {5, 3}, {8, 3}, {13, 1}};

    {
      auto pos = my_min_element_2(counts.begin(), counts.end(), my_less_2());
      EXPECT_THAT(*pos, std::make_pair(1, 2));
    }

    {
      auto pos = my_min_element_3(counts.begin(), counts.end(), my_less_2());
      EXPECT_THAT(*pos, std::make_pair(1, 2));
    }
  }

  {
    std::vector<int> coll{2, 3, 4, 5, 6, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6};

    // return iterator pair
    // Note also that minmax_element() yields `the last maximum`, so the distance
    // 9.
    auto minmax = my_minmax_element_1(coll.begin(), coll.end());
    EXPECT_THAT(*(minmax.first), -3);
    EXPECT_THAT(*(minmax.second), 6);
    EXPECT_THAT(std::distance(minmax.first, minmax.second), 9);
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-coll-unordered

7.9 Unordered Containers

That is, you can consider the container to be a bag: you can put in elements,
but when you open `the bag` to do something with all the elements, you access
  them in a random order.

namespace std {
  template <typename T,
            typename Hash = hash<T>,
            typename EqPred = equal_to<T>,
            typename Allocator = allocator<T>> 
        class unordered_set;

  template <typename Key, typename T,
           typename Hash = hash<T>,
           typename EqPred = equal_to<T>,
           typename Allocator = allocator<pair<const Key, T>> >
        class unordered_map;
}


All standardized unordered container classes are implemented as `hash tables`,
    which nonetheless still have a variety of implementation options.


The hash tables use the “chaining” approach, whereby a hash code is associated
with a linked list.

For each value to store, the hash function maps it to a bucket (slot) in the
hash table. Each bucket manages a singly linked list containing all the
elements for which the hash function yields the same value.


A default hash function is provided for fundamental types and strings, but we
would have to declare our own hash function for other types.

All these unordered container classes have optional template arguments to
specify a hash function and an 'equivalence' criterion, '==' operator.


*cxx-unordered-insert*

`rehashing` is possible only after a call to insert(), rehash(), reserve(), or
clear(). This is a consequence of the guarantee that erase() never
invalidates iterators, references, and pointers to the elements. Thus, if you
delete hundreds of elements, the bucket size will not change.  But if you
insert one element afterward, the bucket size might shrink.

The only important fact is that a specific element is somewhere in the
container. Even when you have two containers with equal elements inside, the
order might be different.

In general, erasing functions do not invalidate iterators and references to
other elements. How- ever, the insert() and emplace() members may invalidate
all iterators when rehashing happens, whereas references to elements always
remain valid. Rehashing happens when, because of an inser- tion, the number of
resulting elements is equal to or exceeds the bucket count times the maximum
load factor (i.e., when the guarantee given by the maximum load factor would
    be broken). The insert() and emplace() members do not affect the validity
of references to container elements.

TEST(CxxUnordered, insert)
{
  // do not have duplicates
  std::unordered_set<std::string> coll{"Braunschweig",
      "Hanover",
      // "Frankfurt",
      "New York",
      "Chicago",
      "Toronto",
      "Paris",
      "Frankfurt"};

  // not allowed to add duplicate
  auto ret = coll.insert("Frankfurt");

  // to indicate "insert has failed"
  EXPECT_THAT(ret.second, false);
}


<cxx-unordered-performance> amortized constant
The cost of a map lookup is O(log(n)) where n is the number of elements in the
map. 

Assuming that the hashing strategy is well chosen and well implemented, you
can guarantee `amortized constant time` for insertions, deletions, and element
search

you should usually prefer unordered maps over maps unless you need the
sorting.


*cxx-unordered-disadvantage*

o lower_bound() and upper_bound() are not provided.

o the iterators are guaranteed only to be forward iterators. 

  reverse iterators, including rbegin(), rend(), crbegin(), and crend(), are
  not supported

  can't use algorithms that require bidirectional iterators, or at least this
  is not portable.


<cxx-unordered-exception>
Unordered containers are `node-based containers`, so any failure to construct
a node simply leaves the container as it was.

o erase() does not throw an exception, provided that the hash function and the
  equivalence criterion don’t throw, which is the case for the default
  functions.


*cxx-unordered-order*
The only guarantee is that duplicates, which are possible because a multiset
is used, are grouped together in the order of their insertion.

TEST(CxxUnordered, check_duplicates)
{
  std::unordered_multiset<string> cities{"Braunschweig",
                                         "Hanover",
                                         "Frankfurt",
                                         "New York",
                                         "Chicago",
                                         "Toronto",
                                         "Paris",
                                         "Frankfurt"};

  {
    std::vector<string> result{};

    for (const auto &elem : cities)
      result.push_back(elem);

    EXPECT_THAT(result,
                ElementsAre("Paris",
                            "Toronto",
                            "Chicago",
                            "New York",
                            "Frankfurt",  // see
                            "Frankfurt",  // see
                            "Hanover",
                            "Braunschweig"));
  }

  {
    // insert additional elements
    cities.insert({"London", "Munich", "Hanover", "Braunschweig"});

    std::vector<string> result{};

    for (const auto &elem : cities)
      result.push_back(elem);

    EXPECT_THAT(result,
                ElementsAreArray({"Munich",
                                  "London",
                                  "Frankfurt", // see
                                  "Frankfurt", // see
                                  "New York",
                                  "Braunschweig", // see
                                  "Braunschweig", // see
                                  "Chicago",
                                  "Toronto",
                                  "Hanover", // see
                                  "Hanover", // see
                                  "Paris"}));
  }
}


*cxx-unordered-search*

Special Search Operations

Unordered containers are optimized for fast searching of elements. To benefit
from this behavior, the containers provide special search functions. These
functions are special versions of general algorithms that have the same name.

c.count(val)
c.find(val)
c.equal_range(val)

TEST(CxxUnordered, search)
{
  {
    std::unordered_multiset<std::string> coll{"Braunschweig",
      "Hanover",
      "Frankfurt",
      "New York",
      "Chicago",
      "Toronto",
      "Paris",
      "Frankfurt"};

    EXPECT_THAT(coll.count("Frankfurt"), 2);
    EXPECT_NE(coll.find("Frankfurt"), coll.end());
  }

  {
    std::vector<std::string> result{};

    std::unordered_multiset<std::string> coll{"Braunschweig",
      "Hanover",
      "Frankfurt",
      "New York",
      "Chicago",
      "Toronto",
      "Paris",
      "Frankfurt"};

    auto range = coll.equal_range("Frankfurt");
    EXPECT_THAT(std::distance(range.first, range.second), 2);

    auto loop = coll.count("Frankfurt");

    auto first = coll.find("Frankfurt");

    for (int i = 0; i < (int)loop; ++i)
    {
      result.emplace_back(*first);
      ++first;
    }

    EXPECT_THAT(result, ElementsAre("Frankfurt","Frankfurt"));
  }
}


<cxx-hash>
Providing Your Own Hash Function

The hash function has to be a function or a function object that takes a value
of the element type as parameter and returns bucket index, a value of type
std::size_t.

your goal is to provide a function that maps the different element values
equally distributed in the range [0,size_t).

Providing a good hash function is trickier than it sounds. A naive approach
would be to simply add all hash values for those attributes that are relevant
for the hash function.

class CustomerHash
{
  public:
    std::size_t operator() (const Customer& c) const {
      return std::hash<std::string>()(c.fname) +
        std::hash<std::string>()(c.lname) +
        std::hash<long>()(c.no);
    }
};

Here, the hash value returned is just the sum of the hash value for the
Customer’s attributes fname, lname, and no.

std::unordered_set<Customer,CustomerHash> custset;

note:
see how to use hash:

  // okay
  cout << "hash(one): " << string("xxx") << endl;

  // error
  cout << "hash(one): " << hash<string>("one") << endl;

  // okay
  cout << "hash(one): " << hash<string>()("one") << endl;


TODO:
A better approach is the following, which uses a hash function provided by
Boost (see [Boost]) and a more convenient interface:


={============================================================================
*kt_dev_cxx_0000* cxx-container-print-elements

// can use either message or delimeter
#include <iostream>
#include <string>
#include <vector>

template<typename T>
void PRINT_ELEMENTS( const T &con, const std::string &message = "" )
{
  cout << message << ":" << endl;
  cout << "{";

  for (const auto &elem : con)
    std::cout << elem << ", ";

  std::cout << "}" << std::endl;
}

int main()
{
  std::vector<int> vcon{1, 2, 3, 4, 5};
  PRINT_ELEMENTS(vcoll, "initialized: " );
}

However, need a change for map:

template<typename T>
inline void PRINT_ELEMENTS_MAP( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << "{" << elem.first << ", " << elem.second << "}" << endl;

  std::cout << std::endl;
}

Q: range-for only works for sequential containers? No

PRINT_ELEMENTS or _MAPS for:
  set, list, map      // works
  unordered_map       // works but not ordered


={============================================================================
*kt_dev_cxx_0000* cxx-iter

{generalization-of-pointer}
A concept of an object that represents positions of elements in a container.
Objects that fulfill this concept are called iterators.

The following fundamental operations define the behavior of an iterator:

o operator*() returns the element of the `current position.` If the elements
  have members, you can use `operator->()` to access those members directly from
  the iterator.

o operator++() lets the iterator step forward to the next element. 'most'
  iterators also allow stepping backward by using operator--()

o operators==() and != return whether two iterators represent the same position.

o operator=() assigns an iterator (the position of the element to which it
  refers).

These operations provide exactly the interface of ordinary pointers in C and
C++ when these pointers are used to iterate over the elements of an ordinary
array.

The difference is that iterators may be 'smart' pointers. Or iterators are an
abstraction to represent a 'position' in a container.


*cxx-iter-categories*
An iterator of a higher category provides all the operations of lower ones.

o output iterator
  `write` but not read, single-pass, increment only. Must supports ++, * and as
  with input, single pass.

o input iterator 
  `read` but not write, single-pass, increment only. Must supports ==, !=, ++,
  *, -> and cannot save the state of an input iterator such as stream. Hence
  single pass.

o forward iterator
  read and write, multi-pass, increment only. Can read and write a sequence
  forward only; ++ operator. unordered_set, unordered_multiset, unordered_map,
  and unordered_multimap are "at least" forward iterators

o bidirectional iterator
  read and write, multi-pass, increment and decrement. Can read and write a
  sequence forward or backword; ++ and -- operator. list, set, multiset, map,
  and multimap.

o `random-access` iterator
  read and write, multi-pass, full `iterator-arithmetic`, `constant-time-access`
  to any position in the sequence. Supports all the functionality of
  bidirectional iterators. 
  

*cxx-iter-code*

{
  // bits/stl_iterator_base_types.h

  /**
   *  @brief  Common %iterator class.
   *
   *  This class does nothing but define nested typedefs.  %Iterator classes
   *  can inherit from this class to save some work.  The typedefs are then
   *  used in specializations and overloading.
   *
   *  In particular, there are no default implementations of requirements
   *  such as @c operator++ and the like.  (How could there be?)
   */
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
    typename _Pointer = _Tp*, typename _Reference = _Tp&>
      struct iterator
      {
        /// One of the @link iterator_tags tag types@endlink.
        typedef _Category  iterator_category;
        /// The type "pointed to" by the iterator.
        typedef _Tp        value_type;
        /// Distance between iterators is represented as this type.
        typedef _Distance  difference_type;
        /// This type represents a pointer-to-value_type.
        typedef _Pointer   pointer;
        /// This type represents a reference-to-value_type.
        typedef _Reference reference;
      };

  // bits/stl_iterator.h

  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
      protected:
        _Iterator _M_current;

        typedef iterator_traits<_Iterator>		__traits_type;

      public:
        typedef _Iterator					iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type  	value_type;
        typedef typename __traits_type::difference_type 	difference_type;
        typedef typename __traits_type::reference 	reference;
        typedef typename __traits_type::pointer   	pointer;
        ...
    };

  // bits/stl_vector.h

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
  {
    // Concept requirements.
    typedef typename _Alloc::value_type                _Alloc_value_type;
    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)

      typedef _Vector_base<_Tp, _Alloc>			 _Base;
    typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
    typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;

    public:
    typedef _Tp					 value_type;
    typedef typename _Base::pointer                    pointer;
    typedef typename _Alloc_traits::const_pointer      const_pointer;
    typedef typename _Alloc_traits::reference          reference;
    typedef typename _Alloc_traits::const_reference    const_reference;

    typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
    typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
    ...
  };
}

*cxx-iter-notation* *cxx-end*

`[begin, end)` notation and `off-the-end` iterator which is one past the last.
This notation applies to subrange as well in use of algorithm. A half-open
range has `two advantages`:

o You have a simple end criterion for loops that iterate over the elements:
  They simply continue as long as end() is not reached.

o It avoids special handling for empty ranges. For empty ranges, begin() is
  equal to end().


EXC++ 01
NOTE that `*end()` is always a programming error since end() returns invalid
iterator.


*cxx-loop*
C++ uses != as a matter of habit rather than < in loops. They do so for the
same reason that they use iterators rather than subscripts because it applies
to various kinds of containers provided by the library: 

  "since not all containers are sequencial."

The internal behavior of iterators depends on the data structure over which they
iterate. For example iterator of `associative-containers` would do
`inorder-traversal` internally. 

Hence, each container type supplies `its own kind of iterator` which knows how
to iterate over. As a result, iterators share the same interface but have
different types.

while(begin != end) {
  *begin  = val;
  ++begin;
}

template< class T>
T* find( T* begin, T* end, const T& value )
{
  while( begin != end && *begin != value ) 
    ++begin;

  return begin;
}


map<string,T> mapT::iterator iter = mapT.begin();

while( iter != mapT.end() )
{
  cout << *iter << ...; // use iter
  ++iter;
}


for( iter = mapT.begin(); iter != mapT.end(); ++iter )
{
  cout << *iter << ...; // use iter
}

note:
The `for-loop` is useful for iterator since you would never need to worry about
not increasing the iterator with it.


*not-specific-to-iterator-category*
Iterator has different categories according to the abilities of iterator and
this affect how to code. To write generic code that is as independent of the
container type as possible, you `should not use special operations` that only
works for random-access iterators.

for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
}

for (auto pos = coll.begin(); pos < coll.end(); ++pos) {
}

note that the second loop does not work with lists, sets, and maps since
`operator < is provided only for 'random' access iterators.`

This shows that it is difficult to write generic code that works on all
container types.

namespace algo_reverse
{
  // reverse iterator(random)
  using RITERATOR = std::vector<int>::iterator;

  void my_reverse(RITERATOR first, RITERATOR last)
  {
    --last;

    for (; first < last; ++first, --last)
      std::swap(*first, *last);
  }

  // bi iterator since it's from cxx-list
  using BITERATOR = std::list<int>::iterator;

  void my_reverse_bi(BITERATOR first, BITERATOR last)
  {
    --last;

    // since `<` is only supported for random
    // for (;first < last; ++first, --last)

    for (; first != last; ++first, --last)
      std::swap(*first, *last);
  }
} // namespace algo_reverse

TEST(CxxAlgo, reverse_different_iterator)
{
  using namespace algo_reverse;

  {
    std::vector<int> coll{1, 2, 3, 4, 5, 6, 7};

    my_reverse(coll.begin(), coll.end());
    EXPECT_THAT(coll, ElementsAre(7, 6, 5, 4, 3, 2, 1));

    my_reverse(coll.begin() + 1, coll.end() - 1);
    EXPECT_THAT(coll, ElementsAre(7, 2, 3, 4, 5, 6, 1));
  }

  {
    std::list<int> coll{1, 2, 3, 4, 5, 6, 7};

    my_reverse_bi(coll.begin(), coll.end());
    EXPECT_THAT(coll, ElementsAre(7, 6, 5, 4, 3, 2, 1));

    // since `+/- is only supported for random
    // my_reverse_bi(coll.begin()+1, coll.end()-1);

    my_reverse_bi(std::next(coll.begin()), std::prev(coll.end()));
    EXPECT_THAT(coll, ElementsAre(7, 2, 3, 4, 5, 6, 1));
  }
}


<cxx-iter-next> <cxx-iter-distance> <cxx-next> <cxx-advance>

namespace algo_code
{
  // /usr/include/c++/4.9/bits/stl_iterator_base_funcs.h

  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(`_ForwardIterator __x`, typename
        iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __i  An input iterator.
   *  @param  __n  The @a delta by which to change @p __i.
   *  @return  Nothing.
   *
   *  This increments @p i by @p n.  For bidirectional and random access
   *  iterators, @p __n may be negative, in which case @p __i is decremented.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
   */
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
      // concept requirements -- taken care of in __advance
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
        random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
          _RandomAccessIterator>)
        __i += __n;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
        bidirectional_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_BidirectionalIteratorConcept<
          _BidirectionalIterator>)
        if (__n > 0)
          while (__n--)
            ++__i;
        else
          while (__n++)
            --__i;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
        random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
          _RandomAccessIterator>)
        return __last - __first;
    }

  // *cxx-distance*
  /**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __first  An input iterator.
   *  @param  __last  An input iterator.
   *  @return  The distance between them.
   *
   *  Returns @c n such that __first + n == __last.  This requires
   *  that @p __last must be reachable from @p __first.  Note that @c
   *  n may be negative.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
   */
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last);

} // namespace


9.3.3 distance()

If the iterators are not random-access iterators, pos2 `must be reachable` from
pos1; that is, it must have the same position or a later position.

TEST(CxxIterator, next)
{
  // why use cxx-next
  //
  // 9.2.6 The Increment and Decrement Problem of Vector Iterators The
  //
  // Depending on the platform, the compilation of ++coll.begin() might fail.
  // However, if you use, for example, a deque rather than a vector, the
  // compilation always succeeds.  The reason for this strange problem lies in the
  // fact that iterators of vectors, arrays, and strings might be implemented as
  // ordinary pointers. And for all fundamental data types, such as pointers, you
  // are not allowed to modify temporary values. For structures and classes,
  // however, doing so is allowed. Thus, if the iterator is implemented as an
  // ordinary pointer, the compilation fails; if implemented as a class, it
  // succeeds.
  //
  // To make your code portable, the utility function next() is provided since
  // C++11 (see Sec- tion 9.3.2, page 443), so you can write:

  {
    std::vector<int> coll{2, 4, 1, 5, 6};

    std::sort(++coll.begin(), coll.end());

    EXPECT_THAT(coll, ElementsAre(2, 1, 4, 5, 6));
  }

  {
    std::vector<int> coll{2, 4, 1, 5, 6};

    std::sort(std::next(coll.begin()), coll.end());

    EXPECT_THAT(coll, ElementsAre(2, 1, 4, 5, 6));
  }

  // since next() uses copy, do not change "pos"
  {
    std::vector<int> coll{1, 2, 3, 4, 5};

    auto pos = coll.begin();
    EXPECT_EQ(*pos, 1);

    ++pos;

    EXPECT_EQ(*pos, 2);

    auto next_pos = std::next(pos);

    EXPECT_EQ(*pos, 2);
    EXPECT_EQ(*next_pos, 3);
  }

  // 9.3.2 next() and prev()
  // Note that next() does not check whether it crosses the end() of a sequence.
  // Thus, it is up to the caller to ensure that the result is valid.
  {
    std::vector<int> coll{1, 2, 3, 4, 5};
    std::vector<int> result{};

    for (auto pos = coll.begin(); pos != coll.end(); pos = std::next(pos))
      result.push_back(*pos);

    EXPECT_THAT(coll, result);
  }

  // what would happen when call next() on empty? cxx-undefined
  //
  // /usr/include/c++/4.9/debug/safe_iterator.h:356:error: attempt to advance a
  //     past-the-end iterator 1 steps, which falls outside its valid range.
  //
  // ok here since do not access through "result"
  {
    std::vector<int> coll{};

    auto pos    = coll.begin();
    auto result = std::next(pos);

    (void)result;
  }
}

TEST(CxxIterator, distance)
{
  // cxx-distance which returns positive/negative
  {
    std::vector<int> coll{1, 2, 3, 4, 5};

    auto pos = std::find(coll.begin(), coll.end(), 3);

    EXPECT_EQ(std::distance(coll.begin(), pos), 2);
    EXPECT_EQ(std::distance(pos, coll.begin()), -2);

    EXPECT_EQ(std::distance(coll.begin(), coll.end()), 5);
    EXPECT_EQ(std::distance(coll.end(), coll.begin()), -5);
  }

  {
    std::set<int> coll{1, 2, 3, 4, 5};

    auto pos = std::find(coll.begin(), coll.end(), 3);

    EXPECT_EQ(std::distance(coll.begin(), pos), 2);

    // /usr/include/c++/4.9/debug/safe_iterator.h:289:error: attempt to
    // increment
    //     a past-the-end iterator.
    //
    // Objects involved in the operation:
    // iterator "this" @ 0x0x7fff1a6a0580 {
    // type =
    // N11__gnu_debug14_Safe_iteratorISt23_Rb_tree_const_iteratorIiENSt7__debug3setIiSt4lessIiESaIiEEEEE
    // (mutable iterator);
    //   state = past-the-end;
    //   references sequence with type `NSt7__debug3setIiSt4lessIiESaIiEEE' @
    //   0x0x7fff1a6a0610
    // }
    // Aborted (core dumped)
    //
    // or when without DEBUG, stucks which seems to be looping.
    // EXPECT_EQ(distance(pos, coll.begin()), -2);
    //
    // since `++first` for non-random iterators:
    //
    // template<typename _InputIterator>
    //   inline typename iterator_traits<_InputIterator>::difference_type
    //   __distance(_InputIterator __first, _InputIterator __last,
    //              input_iterator_tag)
    //   {
    //     // concept requirements
    //     __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
    //
    //     typename iterator_traits<_InputIterator>::difference_type __n = 0;
    //     while (__first != __last)
    // {
    //   ++__first;
    //   ++__n;
    // }
    //     return __n;
    //   }
    //
    // template<typename _RandomAccessIterator>
    //   inline typename iterator_traits<_RandomAccessIterator>::difference_type
    //   __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
    //              random_access_iterator_tag)
    //   {
    //     // concept requirements
    //     __glibcxx_function_requires(_RandomAccessIteratorConcept<
    // 			  _RandomAccessIterator>)
    //     return __last - __first;
    //   }

    EXPECT_EQ(std::distance(coll.begin(), coll.end()), 5);
    // EXPECT_EQ(distance(coll.end(), coll.begin()), -5);
  }
}

={============================================================================
*kt_dev_cxx_0000* cxx-iter-case cxx-case-iter

// StrBlob without StrBlobPtr
//
// CPR 455
//
// * show how to implement a new collection type using library container.
// `is-implemented-in-terms-of-model`
//
// * This shows when shared_ptr is useful than own raii since this case don't
// need `copy-controls` and use syn versions but not a problem as it has only
// one member which is shared_ptr.

namespace cxx_case_strblob
{
  class StrBlob
  {
    public:
      typedef std::vector<std::string>::size_type size_type;
      
      explicit StrBlob() : 
        data_(new std::vector<std::string>()) {}

      explicit StrBlob(std::initializer_list<std::string> il) : 
        data_(new std::vector<std::string>(il)) {}

      size_type size() const noexcept
      { return data_->size(); }
      
      bool empty() const noexcept
      { return data_->empty(); }

      void push_back(std::string const& elem)
      { data_->push_back(elem); }

      void pop_back()
      {
        // *cxx-vector* *cxx-undefined* when called on empty vector
        check(0, "coll is empty");

        // *cxx-vector* do not return value
        data_->pop_back();
      }

      std::string& front()
      {
        check(0, "coll is empty");
        return data_->front();
      }

      std::string& back()
      {
        check(0, "coll is empty");
        return data_->back();
      }

    private:
      shared_ptr<std::vector<std::string>> data_;

      // *cxx-except* has nothing to do with return type
      void check(size_type index, string const& message) const
      {
        if (index >= data_->size())
          throw std::out_of_range(message);
      }
  };

} // namespace


TEST(CxxCase, StringBlobNoIteratorSupport)
{ 
  using namespace cxx_case_strblob;

  {
    StrBlob sb{"one", "two", "three", "four"};

    EXPECT_THAT(sb.size(), 4);
    EXPECT_THAT(sb.front(), "one");
    EXPECT_THAT(sb.back(), "four");

    sb.push_back("five");

    EXPECT_THAT(sb.size(), 5);
    EXPECT_THAT(sb.front(), "one");
    EXPECT_THAT(sb.back(), "five");
  }

  {
    StrBlob sb;

    EXPECT_THAT(sb.size(), 0);
    EXPECT_THROW(sb.front(), std::out_of_range);
  }
} 


// *cxx-iter*
// see that iterator implementation
//
// <- new container class ->  <- companion class like iterator ->
//    StrBlob                    StrBlobPtr
//    - shared_ptr               - weak_ptr
//
//                      vector[]
//                      - underlying container

namespace cxx_case_strblob_iterator
{
  class StrBlobIterator;

  class StrBlob
  {
    friend class StrBlobIterator;

    public:
      typedef std::vector<std::string>::size_type size_type;
      
      explicit StrBlob() : 
        data_(new std::vector<std::string>()) {}

      explicit StrBlob(std::initializer_list<std::string> il) : 
        data_(new std::vector<std::string>(il)) {}

      size_type size() const noexcept
      { return data_->size(); }
      
      bool empty() const noexcept
      { return data_->empty(); }

      void push_back(std::string const& elem)
      { data_->push_back(elem); }

      void pop_back()
      {
        // *cxx-vector* *cxx-undefined* when called on empty vector
        check(0, "coll is empty");

        // *cxx-vector* do not return value
        data_->pop_back();
      }

      std::string& front()
      {
        check(0, "coll is empty");
        return data_->front();
      }

      std::string& back()
      {
        check(0, "coll is empty");
        return data_->back();
      }

      // cause *cxx-incomplete-type* so cannot be defined until StrBlobIterator
      // is defined.

      StrBlobIterator begin();

      StrBlobIterator end();

    private:
      shared_ptr<std::vector<std::string>> data_;

      // *cxx-except* has nothing to do with return type
      void check(size_type index, string const& message) const
      {
        if (index >= data_->size())
          throw std::out_of_range(message);
      }
  };


  // originally StrBlobPtr

  class StrBlobIterator
  {
    public:
      typedef std::vector<std::string>::size_type size_type;

      // *cxx-incomplete-type* so move StrBlobIterator after StrBlob
      StrBlobIterator(StrBlob& blob, size_type pos = 0)
        : blob_(blob.data_), curr_(pos)
      {}

      // *cxx-operator-postfix* prefix version
      StrBlobIterator& operator++()
      {
        check(curr_, "increase past the end");
        ++curr_;
        return *this;
      }

      // *cxx-operator-postfix* postfix version
      StrBlobIterator const operator++(int)
      {
        StrBlobIterator it = *this;
        ++*this;
        return it;
      }

      StrBlobIterator& operator--()
      {
        // decrease first and since it is size_type, -1 becomes big
        --curr_;
        check(curr_, "decrease before the begin");
        return *this;
      }


      StrBlobIterator const operator--(int)
      {
        StrBlobIterator it = *this;
        --*this;
        return it;
      }

      // *cxx-overload-operator*
      //
      // 1. this iterator points vector<string>. return vector<string> or
      // string?
      //
      // 2. Although it's const member function since do not change its state,
      // returns a reference and client can change through it.

      std::string& operator*() const 
      {
        auto blob_ptr = check(curr_, "dereference non-existent element");

        // *cxx-precedence* [] is higher
        return (*blob_ptr)[curr_];
      }

      // this is the original code from the book. However, operator->() make
      // sense when underlying item is pointer. In this case, it's not so
      // comment it out.
      //
      // std::string* operator->() const
      // {
      //     // take address of a string reference
      //     return & this->operator*();
      // }

      // *cxx-overload-operator-equal*

      bool operator==(StrBlobIterator const& other) const
      {
        auto lhs_blob_ptr = blob_.lock();

        // *cxx-access* WHY NOT ERROR???
        
        auto rhs_blob_ptr = other.blob_.lock();

        // don't seem to need "curr_ == other.curr_" since it's enough to see
        // shared pointer is not null

        if (lhs_blob_ptr == rhs_blob_ptr)
          return (!lhs_blob_ptr || curr_ == other.curr_);
        else 
          return false;
      }

      bool operator!=(StrBlobIterator const& other) const
      {
        return !(*this == other);
      }

    private:
      std::weak_ptr<std::vector<std::string>> blob_;
      size_type curr_{0};

      std::shared_ptr<std::vector<std::string>> check(size_type index,
          string const& message) const
      {
        // *cxx-sp-weak*
        auto blob_ptr = blob_.lock();
        if (!blob_ptr)
          throw std::runtime_error("unbounded shared_ptr");

        if (index >= blob_ptr->size())
          throw std::out_of_range(message);

        return blob_ptr;
      }
  };

  // cause *cxx-incomplete-type* so cannot be defined until StrBlobIterator
  // is defined. so define them here

  StrBlobIterator StrBlob::begin()
  {
    return StrBlobIterator(*this, 0);
  }

  StrBlobIterator StrBlob::end()
  {
    return StrBlobIterator(*this, data_->size());
  }

} // namespace

TEST(CxxCase, StringBlobIteratorSupport)
{ 
  using namespace cxx_case_strblob_iterator;

  {
    vector<string> coll;

    StrBlob sb{"one", "two", "three", "four"};

    // for (auto const& e : sb)
    // {
    //   cout <<
    // }
    for (auto it = sb.begin(); it != sb.end(); ++it)
      coll.push_back(*it);

    EXPECT_THAT(coll, ElementsAre("one", "two", "three", "four"));
  }

  {
    vector<string> coll;

    StrBlob sb{"one", "two", "three", "four"};

    for (auto const& e : sb)
      coll.push_back(e);

    EXPECT_THAT(coll, ElementsAre("one", "two", "three", "four"));
  }

  {
    vector<string> coll;

    StrBlob sb{"one", "two", "three", "four"};

    // since operator*() returns reference
    auto it = sb.begin();
    *it = "I";

    for (auto const& e : sb)
      coll.push_back(e);

    EXPECT_THAT(coll, ElementsAre("I", "two", "three", "four"));
  }
} 


namespace cxx_case_strblob_template
{
  template <typename T>
  class StrBlob
  {
    public:

      // was:
      // typedef std::vector<T>::size_type size_type;
      //
      // *cxx-template-type-members* it now needs `typename` keyword since it is
      // a template now.

      typedef typename std::vector<T>::size_type size_type;
      
      explicit StrBlob() : 
        data_(new std::vector<T>()) {}

      explicit StrBlob(std::initializer_list<T> il) : 
        data_(new std::vector<T>(il)) {}

      size_type size() const noexcept
      { return data_->size(); }
      
      bool empty() const noexcept
      { return data_->empty(); }

      void push_back(std::string const& elem)
      { data_->push_back(elem); }

      void pop_back()
      {
        // *cxx-vector* *cxx-undefined* when called on empty vector
        check(0, "coll is empty");

        // *cxx-vector* do not return value
        data_->pop_back();
      }

      T& front()
      {
        check(0, "coll is empty");
        return data_->front();
      }

      T& back()
      {
        check(0, "coll is empty");
        return data_->back();
      }

    private:
      shared_ptr<std::vector<T>> data_;

      void check(size_type index, string const& message) const;
  };

  // *cxx-except* has nothing to do with return type
  //
  // to show how to:
  //
  // <cxx-template-member-function>
  //
  // To write a member function of class template 'outside' of definition,
  // remember that the instantiated type is a new type and must say to which
  // class the member belongs. see Blob`<T>`
  //
  // it is instantiated `only if` it is used and if not, it is not instantiated.

  template <typename T>
    void StrBlob<T>::check(size_type index, string const& message) const
  {
    if (index >= data_->size())
      throw std::out_of_range(message);
  }

} // namespace


TEST(CxxCase, StringBlobTemplate)
{ 
  using namespace cxx_case_strblob_template;

  {
    StrBlob<std::string> sb{"one", "two", "three", "four"};

    EXPECT_THAT(sb.size(), 4);
    EXPECT_THAT(sb.front(), "one");
    EXPECT_THAT(sb.back(), "four");

    sb.push_back("five");

    EXPECT_THAT(sb.size(), 5);
    EXPECT_THAT(sb.front(), "one");
    EXPECT_THAT(sb.back(), "five");
  }

  {
    StrBlob<std::string> sb;

    EXPECT_THAT(sb.size(), 0);
    EXPECT_THROW(sb.front(), std::out_of_range);
  }
} 

// from Problem 46, circular buffer, the modern c++ challenge
// 1. use size(count) and head only
// 2. in push, no full check since it overwrites and in pop, it simply
// calculates first from head substracing size.
// 3. no iterator support is needed if not use begin()/end()

namespace queue_circular_count_iterator
{

template <typename T>
class circular_buffer_iterator;

template <typename T>
class circular_buffer
{
  typedef circular_buffer_iterator<T> const_iterator;
  friend class circular_buffer_iterator<T>;

  public:
  circular_buffer() = delete;
  explicit circular_buffer(size_t const size) : data_(size) 
  {}

  void clear() noexcept 
  { head_ = -1; size_ = 0; }

  bool empty() const noexcept
  { return size_ == 0; }

  bool full() const noexcept
  { return size_ >= data_.size(); }

  size_t capacity() const noexcept
  { return data_.size(); }

  size_t size() const noexcept
  { return size_; }

  const_iterator begin() const
  {
    return const_iterator(*this, first_pos(), empty());
  }

  const_iterator end() const
  {
    return const_iterator(*this, next_pos(), true);
  }

  T pop()
  {
    if (empty())
      throw std::runtime_error("buffer is empty");

    auto pos = first_pos();
    size_--;
    return data_[pos];
  }

  void push(T const item)
  {
    // if (full())
    //   throw std::runtime_error("buffer is full");

    head_ = next_pos();
    data_[head_] = item;

    if (size_ < data_.size())
      size_++;
  }

  private:
  size_t size_{};
  size_t head_{-1};
  std::vector<T> data_;

  // return `head` pos to push
  size_t next_pos() const noexcept
  {
    // *cxx-precedence* *cxx-error*
    // return size_ == 0 ? 0 : (head_ + 1 % data_.size());

    return size_ == 0 ? 0 : ((head_ + 1) % data_.size());
  }

  // return `tail` pos to pop
  size_t first_pos() const noexcept
  {
    return size_ == 0 ? 0 : (head_ + data_.size() - size_ + 1) % data_.size();
  }
};

template <typename T>
class circular_buffer_iterator
{
  typedef circular_buffer_iterator        self_type;
  typedef T                               value_type;
  typedef T&                              reference;
  typedef T const&                        const_reference;
  typedef T*                              pointer;
  typedef std::random_access_iterator_tag iterator_category;
  typedef ptrdiff_t                       difference_type;
 
  public:

  explicit circular_buffer_iterator(circular_buffer<T> const& buf, size_t const pos, bool const last) :
    buffer_(buf), index_(pos), last_(last)
  {}

  self_type& operator++()
  {
    if (last_)
      throw std::out_of_range("iterator cannot be incremented past the end of range.");
    
    index_ = (index_ + 1) % buffer_.data_.size();

    // that is when index_ == `head`
    last_ = (index_ == buffer_.next_pos());

    return *this;
  }

  // *cxx-operator-postfix*
  self_type const operator++(int)
  {
    self_type temp = *this;
    ++*this;
    return temp;
  }

  bool operator==(self_type const& other) const
  {
    // assert(compatible(other));

    return &buffer_ == &other.buffer_
      && index_ == other.index_ 
      && last_ == other.last_;
  }

  bool operator!=(self_type const& other) const
  { return !(*this == other); }

  const_reference operator*() const
  {
    return buffer_.data_[index_];
  }

  private:

  circular_buffer<T> const& buffer_;
  size_t index_;
  bool last_;
};

template <typename T>
std::vector<T> print(circular_buffer<T> & buf)
{
  std::vector<T> coll{};

  for (auto & e : buf)
    coll.push_back(e);

  return coll;
}

} // namespace


TEST(CxxCase, CircularQueueCountIterator)
{
  using namespace queue_circular_count_iterator;

  {
    circular_buffer<int> cbuf(5);   // {0, 0, 0, 0, 0} -> {}

    cbuf.push(1);                   // {1, 0, 0, 0, 0} -> {1}
    cbuf.push(2);                   // {1, 2, 0, 0, 0} -> {1, 2}
    cbuf.push(3);                   // {1, 2, 3, 0, 0} -> {1, 2, 3}

    auto item = cbuf.pop();         // {1, 2, 3, 0, 0} -> {2, 3}
    EXPECT_THAT(item, 1);

    cbuf.push(4);                   // {1, 2, 3, 4, 0} -> {2, 3, 4}
    cbuf.push(5);                   // {1, 2, 3, 4, 5} -> {2, 3, 4, 5}

    // see that it overwrites
    cbuf.push(6);                   // {(6), 2, 3, 4, 5} -> {2, 3, 4, 5, 6}
    cbuf.push(7);                   // {6, (7), 3, 4, 5} -> {3, 4, 5, 6, 7}
    cbuf.push(8);                   // {6, 7, (8), 4, 5} -> {4, 5, 6, 7, 8}

    item = cbuf.pop();              // {6, 7, 8, 4, 5} -> {5, 6, 7, 8}
    EXPECT_THAT(item, 4);
    item = cbuf.pop();              // {6, 7, 8, 4, 5} -> {6, 7, 8}
    EXPECT_THAT(item, 5);
    item = cbuf.pop();              // {6, 7, 8, 4, 5} -> {7, 8}
    EXPECT_THAT(item, 6);

    cbuf.pop();                     // {6, 7, 8, 4, 5} -> {8}
    cbuf.pop();                     // {6, 7, 8, 4, 5} -> {}
    cbuf.push(9);                   // {6, 7, 8, 9, 5} -> {9}
  }

  {
    circular_buffer<int> cbuf(5);

    cbuf.push(1);
    cbuf.push(2);
    cbuf.push(3);
    cbuf.push(4);
    cbuf.push(5);
    cbuf.push(6);
    cbuf.push(7);
    EXPECT_THAT(print(cbuf), ElementsAre(3,4,5,6,7));
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-iter-array

CXXSLR-7.10.2

You can use ordinary C-style arrays as STL containers. However, ordinary C-style
arrays are not classes, so they don't provide member functions such as begin()
and end(). Here, either the noninvasive approach or the wrapper approach must be
used.

Using the `non-invasive-approach` is simple. You need only objects that are able
to iterate over the elements of an array by using the `iterator interface.` Such
iterators already exist: ordinary pointers. 

An STL design decision was to use the `pointer-interface` for iterators so that
you could use ordinary pointers as iterators. This again shows the generic
concept of `pure abstraction`: Anything that `behaves-like` an iterator is an
iterator. In fact, pointers are `random-access` iterators.

*cxx-begin* *cxx-end*
defined in iterator header but do not need to include to use and easy to write
C++ loop.

TEST(CxxIterator, array)
{
  {
    int vals[] = {33, 67, -4, 13, 5, 2};

    std::vector<int> coll(std::begin(vals), std::end(vals));

    decltype(coll) out;

    // These functions are also overloaded, so you can use STL containers or all
    // classes that provide begin() and end() as member functions:
    //
    // std::begin(v)  // yields v.begin()
    // std::end(v)    // yields v.end()

    // cxx-algo-copy
    std::copy(std::begin(coll), std::end(coll), back_inserter(out));

    EXPECT_THAT(out, ElementsAre(33, 67, -4, 13, 5, 2));
  }

  {
    int values[] = { 33, 67, -4, 13, 5, 2 };
    vector<int> vec(begin(values), end(values));

    copy(vec.begin(), vec.end(), ostream_iterator<int>(cout, " "));
    cout << endl;

    // on ordinary array
    copy(begin(values), end(values), ostream_iterator<int>(cout, " "));
    cout << endl;

    // on container
    copy(begin(vec), end(vec), ostream_iterator<int>(cout, " "));
    cout << endl;
  }
}

={============================================================================
*kt_dev_cxx_0000* cxx-iter-adapters

These are several predefined special iterators, called iterator adapters:
insert, stream, reverse, and move iterators


9.4.2 Insert Iterators *cxx-iter-inserter* cxx-inserter

`insert-iterator`, or inserters, are used to let algorithms operate in `insert
mode` rather than in `overwrite mode` by transforming an assignment of an new
value into an insertion. (for overwrite example, algorithms using multiple
    range) 

They fall under the category of `output iterators`, which are able to
write/assign values only while iterating forward.

*cxx-inserter* calls a container operation to add and must:

use front_inserter only if the container has push_front 
use back_inserter only if it has push_back. 

These are `back_inserter`, `front_inserter`, `inserter` which bind iterator to
container operations.

namespace cxx_code 
{
  // *cxx-algo-copy*
  template <typename InputIterator, typename OutputIterator>
    OutputIterator copy (InputIterator from_pos,  // beginning of source
        InputIterator from_end,                   // end of source
        OutputIterator to_pos)                    // beginning of dest.
    {
      while (from_pos != from_end) {
        *to_pos = *from_pos;  // copy values
        ++from_pos;           // increment iterators
        ++to_pos;
      }
      return to_pos;
    }
} // namespace

The interesting part is the assignment of the new value:

*to_pos = value

`An insert-iterator transforms an assignment into an insertion.` However, two
operations are involved: First, operator*() returns the `current-element` of the
iterator; second, operator = assigns the new value. Implementations of insert
iterators usually use the following two-step trick:

o operator*() is implemented as a no-op that simply returns *this. Thus, for
  insert iterators, *pos is equivalent to pos, which is iterator.

{
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
      /// Simply returns *this.
      insert_iterator&
      operator*()
      { return *this; }

    };
}

o The assignment operator is implemented so that it gets transferred into an
  insertion. In fact, the insert iterator calls the push_back(), push_front(),
  or insert() member function of the container.
  note that need to care about underlying container.

namespace cxx_code
{
  // bits/stl_iterator.h

  /**
   *  @param __x  A container of arbitrary type.
   *  @return  An instance of insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
   */
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    `inserter`(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
          typename _Container::iterator(__i));
    }

  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator inserts it in the container at the
   *  %iterator's position, rather than overwriting the value at that
   *  position.
   *
   *  (Sequences will actually insert a @e copy of the value before the
   *  %iterator's position.)
   *
   *  Tip:  Using the inserter function to create these iterators can
   *  save typing.
   */
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
      /// Simply returns *this.
      insert_iterator&
        operator*()
        { return *this; }

      insert_iterator&
        operator=(const typename _Container::value_type& __value)
        {
          // note: update `iter` here
          iter = `container->insert`(iter, __value);
          ++iter;
          return *this;
        }

      insert_iterator&
        operator=(typename _Container::value_type&& __value)
        {
          iter = container->insert(iter, `std::move(__value)`);
          ++iter;
          return *this;
        }

      /// Simply returns *this.  (This %iterator does not @a move.)
      insert_iterator&
        operator++()
        { return *this; }
    }
}


*cxx-iter-insert*

Kinds of Insert Iterators

The C++ standard library provides `three kinds of insert iterators`: back
inserters, front inserters, and general inserters.

They differ in their handling of the position at which to insert a value. In
fact, each uses a different member function, which it calls for the container
to which it belongs. Thus, an insert iterator must be always initialized with
its container.

general inserter calls `insert(pos, val)` member and insert elements directly in
front of the position that is passed as the argument of its initialization and
as the start to insert. `For all containers except array and forward_list.`

Passing a position(iterator) to insert doesn't sound useful? So for associative
and unordered containers, the position is taken as a `hint` to start the search
for the correct position. However, containers are free to ignore it.

c.insert(pos,elem)

For this reason, back inserters are available only for vectors, deques,
lists, and strings; front inserters are available only for deques and lists.

Each kind of insert iterator has a convenience function for its creation and
initialization.

TEST(CxxIterator, adapters_insert_kinds)
{
  std::list<int> coll{1, 2, 3, 4, 5, 6, 7, 8, 9};

  // cxx-iter-back-inserter
  {
    std::vector<int> ret;

    // cxx-algo-copy
    std::copy(coll.cbegin(), coll.cend(), std::back_inserter(ret));
    EXPECT_THAT(ocoll, ElementsAreArray({1, 2, 3, 4, 5, 6, 7, 8, 9}));
  }

  // *cxx-reverse*
  // cxx-iter-front-inserter
  // have to use cxx-deque since it uses push_front
  {
    std::deque<int> ret;

    // cxx-algo-copy
    std::copy(coll.cbegin(), coll.cend(), std::front_inserter(ret));
    EXPECT_THAT(ret, ElementsAreArray({9, 8, 7, 6, 5, 4, 3, 2, 1}));
  }

  // *cxx-inserter*
  {
    std::vector<int> ret{};

    // cxx-algo-copy
    std::copy(coll.cbegin(), coll.cend(), std::inserter(ret, ret.begin()));

    EXPECT_THAT(ret, ElementsAreArray({1, 2, 3, 4, 5, 6, 7, 8, 9}));
  }
}


namespace cxx_code
{
  // c++/4.7/bits/stl_iterator.h

  // 24.4.2.2.1 back_insert_iterator
  /**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
   */
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
      protected:
        _Container* container;

      public:
        /// A nested typedef for the type of whatever container you used.
        typedef _Container          container_type;

        /// The only way to create this %iterator is with a container.
        explicit
          back_insert_iterator(_Container& __x) : container(&__x) { }

        /**
         *  @param  __value  An instance of whatever type
         *                 container_type::const_reference is; presumably a
         *                 reference-to-const T for container<T>.
         *  @return  This %iterator, for chained operations.
         *
         *  This kind of %iterator doesn't really have a @a position in the
         *  container (you can think of the position as being permanently at
         *  the end, if you like).  Assigning a value to the %iterator will
         *  always append the value to the end of the container.
         */
#ifndef __GXX_EXPERIMENTAL_CXX0X__
        back_insert_iterator&
          operator=(typename _Container::const_reference __value)
          {
            container->push_back(__value);
            return *this;
          }
#else
        back_insert_iterator&
          operator=(const typename _Container::value_type& __value)
          {
            container->push_back(__value);
            return *this;
          }

        back_insert_iterator&
          operator=(typename _Container::value_type&& __value)
          {
            container->push_back(std::move(__value));
            return *this;
          }
#endif
    }
} // namespace


*cxx-iter-stream* cxx-stream-iterator

9.4.3 Stream Iterators

A stream iterator is an iterator adapter that allows you to use a stream as a
source or destination of algorithms. In particular, an istream iterator can be
used to read elements from an input stream, and an ostream iterator can be used
to write values to an output stream.

"see(treat) stream as a sequence of elements(container) to use iterators"

A *cxx-stream* is an object that represent I/O channel. Treat stream as a
sequence of elements of a specified type that should have input/output op
defined(>>/<<) and bind iterator to a stream. In other words, see a stream as a
sequence of user provided speficified type. 

*cxx-stringstream*
`stringstream` "see(treat) string as a stream so use stream ops; IO ops" and
provide a `buffer` 


Ostream iterators write assigned values to an output stream. By using ostream
iterators, algorithms can write directly to streams. The implementation of an
ostream iterator uses the same concept as the implementation of insert
iterators. 

The only difference is that 
they `transform the assignment of a new value into an output operation` by using
operator <<.

that is, transform iterator operation to stream operation.

Need to specify which `stream will be used` and the `type of objects` written to
it.

namespace cxx_code
{
  // /usr/include/c++/4.9/bits/stream_iterator.h

  template <class T, class charT=char, class traits=char_traits< charT>>
    class ostream_iterator;

  ostream_iterator (ostream_type& s, const char_type* delimiter);

} // namespace


TEST(CxxIterator, adaptor_stream)
{
  // as gets from std::cin, use stream
  {
    std::istringstream is{"1 2 3 4 5 6"};
    std::vector<int> coll;

    int value{};

    while (is >> value)
      coll.push_back(value);

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6));
  }

  // as gets from std::cin, use iterator
  {
    std::istringstream is{"1 2 3 4 5 6"};
    sdt::vector<int> coll;

    std::istream_iterator<int> isi(is), eof;

    while (isi != eof)
      coll.push_back(*isi++);

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6));
  }

  // use iterator but direct
  {
    std::istringstream is{"1 2 3 4 5 6"};

    std::istream_iterator<int> isi(is), eof;

    // *cxx-vector-ctor*
    // no loop and no isi++
    std::vector<int> coll(isi, eof);

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6));
  }

  // use iterator but direct
  {
    std::istringstream is{"1 2 3 4 5 6"};

    std::vector<int> coll((std::istream_iterator<int>(is)), std::istream_iterator<int>());

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6));
  }

  // use iterator but direct
  {
    std::istringstream is{"1 2 3 4 5 6"};

    std::istream_iterator<int> isi(is), eof;

    // no loop and no isi++
    std::vector<int> coll;
    std::copy(isi, eof, std::back_inserter(coll));

    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6));
  }

  // as gets from std::cin, use stream
  {
    std::istringstream is{"1 2 3 4 5 6"};
    std::istream_iterator<int> isi(is), eof;

    auto result = std::accumulate(isi, eof, 0);

    EXPECT_THAT(result, 21);
  }

  // link ostream_iterator to ostringstream
  {
    std::vector<int> coll{1, 2, 3, 4, 5, 6};
    std::ostringstream os;

    std::ostream_iterator<int> osi(os, ",");

    for (auto e : coll)
      *osi++ = e;

    EXPECT_THAT(os.str(), "1,2,3,4,5,6,");
  }

  // Table 9.9. Operations of ostream Iterators
  // same as cxx-inserter since ++ is nop.
  //
  // With/without "++oo", the result is the same. The ++oo is done to mimic
  // writing into an array through a pointer.

  {
    std::ostringstream os;
    std::ostream_iterator<string> osi(os);

    *osi = "Hello, ";
    ++osi;
    *osi = "world!";

    EXPECT_THAT(os.str(), "Hello, world!");
  }
  {
    std::ostringstream os;
    std::ostream_iterator<string> osi(os);

    *osi = "Hello, ";
    *osi = "world!";

    EXPECT_THAT(os.str(), "Hello, world!");
  }
}


<ex> cxx-iter-stream can make code neat

class Sales_item {
  // these declarations are explained section 7.2.1, p. 270 
  // and in chapter 14, pages 557, 558, 561
  friend std::istream& operator>>(std::istream&, Sales_item&);
  friend std::ostream& operator<<(std::ostream&, const Sales_item&);
  // ...
};

int main()
{
  Sales_item total;

  // read the first transaction
  if( std::cin >> total )
  {
    Sales_item trans;   // variable to hold the running sum

    while(std::cin >> trans )
    {
      // if we're still processing the same book, then update 
      // the running total

      if( total.isbn() == trans.isbn() )
        total += trans;
      // print results for the previous book
      else
      {
        std::cout << total << std::endl;
        total = trans;
      }
    }
    // print the last transaction
    std::cout << total << std::endl;
  } 
  // no input and return failure
  else
  {
    std::cerr << "No data?" << std::endl;
    return -1;
  }

  return 0;
}


This can be re-written as:

int main()
{
  istream_iterator<Sales_item> item_iter(cin), eof;
  ostream_iterator<Sales_item> out_iter(cout, "\n");

  // store first transaction in sum and read the next record
  Sales_item sum = *item_iter++;

  while( item_iter != eof )
  {
    if( item_iter->isbn() == sum.isbn() )
      sum += *item_iter++;    // add it to sum and read the next record
    else
    {
      out_iter = sum;         // print result
      sum = *item_iter++;     // read the next record
    }
  }

  // print the last transaction
  out_iter = sum;
}


<ex> *cxx-ifstream*
Typically, istream_iterators and ostream_iterators are not used directly.
Instead, they are provided as arguments to algorithms. For example, we can
write a simple program to read a file, sort the words read, eliminate
duplicates, and write the result to another file:

int main()
{
  string from, to;
  cin >> from >> to;                      // get source and target file names

  ifstream is{from};                      // input stream for file "from"
  istream_iterator<string> ii{is};        // input iterator for stream
  istream_iterator<string> eos{};         // input sentinel

  ofstream os{to};                        // output stream for file "to"
  ostream_iterator<string> oo{os,"\n"};   // output iterator for stream

  vector<string> b{ii, eos};              // b is a vector initialized from input
  sort(b.begin(), b.end());               // sort the buffer

  *algo-unique-copy*
  unique_copy(b.begin(), b.end(), oo);    // copy buffer to output, discard replicated values

  return !is.eof() || !os;                // return error state (§2.2.1, §38.3)
}

Actually, this program is longer than it needs to be. We read the strings into
a vector, then we sort() them, and then we write them out, eliminating
duplicates. A more elegant solution is not to store duplicates at all.

We used the names ii, eos, and oo only once, so we could further reduce the
size of the program

{
  string from, to;
  cin >> from >> to;                      // get source and target file names

  ifstream is {from};                     // input stream for file "from"
  ofstream os {to};                       // output stream for file "to"

  set<string> b {istream_iterator<string>{is}, ostream_iterator<string>{}};
  copy(b.begin(),b.end(), ostream_iterator<string>{os, "\n"});

  return !is.eof() || !os;                // return error state (§2.2.1, §38.3)
}


<ex> *cxx-algo-accumulate*

#include <numeric>

template <class InputIterator, class T>
T accumulate (InputIterator first, InputIterator last, T init)

// cxx-algo-accumulate
//
// 11.11 Numeric Algorithms
//
// The first form computes and returns the sum of initValue and all elements in
// the range [beg,end).  In particular, it calls the following for each element:
//
// initValue = initValue + elem
//
// The second form computes and returns the result of calling op for initValue
// and all elements in the range [beg,end). In particular, it calls the
// following for each element:
//
// initValue = op(initValue, elem)
//
// Thus, for the values
//  a1 a2 a3 a4 ...
//
// they compute and return either
//  initValue + a1 + a2 + a3 + ...
//
// or
//  initValue op a1 op a2 op a3 op ...
//
// respectively.

namespace cxx_code
{
  // bits/stl_numeric.h

  /**
   *  @brief  Accumulate values in a range.
   *
   *  Accumulates the values in the range [first,last) using operator+().  The
   *  initial value is @a init.  The values are processed in order.
   *
   *  @param  __first  Start of range.
   *  @param  __last  End of range.
   *  @param  __init  Starting value to add other values to.
   *  @return  The final sum.
   */
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {
      for (; __first != __last; ++__first)
        __init = __init + *__first;
      return __init;
    }

  /**
   *  @brief  Accumulate values in a range with operation.
   *
   *  Accumulates the values in the range [first,last) using the function
   *  object @p __binary_op.  The initial value is @p __init.  The values are
   *  processed in order.
   *
   *  @param  __first  Start of range.
   *  @param  __last  End of range.
   *  @param  __init  Starting value to add other values to.
   *  @param  __binary_op  Function object to accumulate with.
   *  @return  The final sum.
   */
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        `_BinaryOperation` __binary_op)
    {
      for (; __first != __last; ++__first)
        __init = __binary_op(__init, *__first);
      return __init;
    }

} // namespace

TEST(CxxAlgoAccumulate, on_stream)
{
  std::istringstream is{"1 2 3 4 5 6"};
  std::istream_iterator<int> start(is), eof;

  auto sum = std::accumulate(start, eof, 0);

  EXPECT_THAT(sum, 21);
}


*cxx-iter-reverse* cxx-reverse-iterator

DO not provide template class as cxx-back-inserter

Allow algorithms operate backward by switching the call of an increment
operator internally into a call of the decrement operator, and vice versa. The
advantage of using `reverse-iterator` is that all algorithms are able to
operate in the opposite direction without special code.

std::sort(vec.begin(), vec.end());    // sort in normal, ascending order
std::sort(vec.rbegin(), vec.rend());  // sort in reverse, decending order

   .cbegin()              .cend()
  [ ] [ ] [ ] [ ] ... [ ]
.crend()               .crbegin() 

All containers with 'bidirectional' iterators or random-access iterators can
create reverse interator. 

CPR read "The containers, aside from forward_list, all have reverse iterators". 
So container shall support ++/-- operator and rbegin/rend/crbegin/crend().


<difference-between-reverse-and-other-iterators> 
As the sort example shown above, then use reverse iterator as a range, don't
need to care about this difference but see the difference when use it as a
single iterator.

// CPR p408

   rcomma.base()   
           cend()
 | ^     | ^
 , L A S T
 |       |
 rcomma  crbegin()

There is the difference when converting reverse to and from since the
resulting iterator `does 'not' refer to the same element.` This is a
consequence of the fact that ranges are half open.

namespace cxx_code
{
  // bits/stl_vector.h

  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
  {
    typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
    typedef std::reverse_iterator<iterator>		 reverse_iterator;

    /**
     *  Returns a read/write reverse iterator that points to the
     *  last element in the %vector.  Iteration is done in reverse
     *  element order.
     */
    reverse_iterator
      rbegin() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(end()); }

    /**
     *  Returns a read/write reverse iterator that points to one
     *  before the first element in the %vector.  Iteration is done
     *  in reverse element order.
     */
    reverse_iterator
      rend() _GLIBCXX_NOEXCEPT
      { return reverse_iterator(begin()); }
  }
} // namespace

This -1 difference is handled by:

namespace cxx_code
{
  // bits/stl_iterator.h

  // 24.4.1 Reverse iterators
  /**
   *  Bidirectional and random access iterators have corresponding reverse
   *  %iterator adaptors that iterate through the data structure in the
   *  opposite direction.  They have the same signatures as the corresponding
   *  iterators.  The fundamental relation between a reverse %iterator and its
   *  corresponding %iterator @c i is established by the identity:
   *  @code
   *      &*(reverse_iterator(i)) == &*(i - 1)
   *  @endcode
   *
   *  <em>This mapping is dictated by the fact that while there is always a
   *  pointer past the end of an array, there might not be a valid pointer
   *  before the beginning of an array.</em> [24.4.1]/1,2
   *
   *  Reverse iterators can be tricky and surprising at first.  Their
   *  semantics make sense, however, and the trickiness is a side effect of
   *  the requirement that the iterators must be safe.
   */
  template<typename _Iterator>
    class reverse_iterator
    {
      /**
       *  @return  A reference to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
       *
       *  @warning This implementation requires that for an iterator of the
       *           underlying iterator type, @c x, a reference obtained by
       *           @c *x remains valid after @c x has been modified or
       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
       */
      reference
        operator*() const
        {
          _Iterator __tmp = current;
          return *--__tmp;
        }
    }
}

// cxx-reverse
// 9.4.1 Reverse Iterators
// Most container classes — all except forward lists and unordered containers —
// as well as strings provide the ability to use reverse iterators to iterate
// over their elements.

TEST(CxxIterator, adaptor_reverse)
{
  {
    std::string coll{"PARK"};
    std::string result{};

    std::string::const_reverse_iterator it = coll.crbegin();

    while (it != coll.crend())
      result.push_back(*it++);

    EXPECT_THAT(result, "KRAP");
  }

  // pos vs rpos
  // You can convert normal iterators into reverse iterators. Naturally, the
  // iterators must be bidirectional iterators, but note that the logical
  // position of an iterator is moved during the conversion.

  {
    // create deque with elements from 1 to 9
    std::deque<int> coll = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    std::deque<int>::const_iterator pos;

    pos = std::find(coll.cbegin(), coll.cend(), 7);
    EXPECT_THAT(*pos, 7);

    std::deque<int>::const_reverse_iterator rpos(pos);
    EXPECT_THAT(*rpos, 6);
  }

  {
    std::string coll{"FIRST,MIDDLE,LAST"};

    auto delim = std::find(coll.cbegin(), coll.cend(), ',');

    EXPECT_THAT(std::string(coll.cbegin(), delim), "FIRST");

    // The result is "TSAL" since iterator goes backward and means [crbegin(),
    // rcomma). To get the expected result, shall use instead [rcomma.base(),
    // cend() ) which converts reverse iterator to normal interator.

    auto rdelim = std::find(coll.crbegin(), coll.crend(), ',');

    EXPECT_THAT(std::string(coll.crbegin(), rdelim), "TSAL");

    // Converting Reverse Iterators Back Using base()
    EXPECT_THAT(std::string(rdelim.base(), coll.cend()), "LAST");
  }

  {
    std::ostringstream os{};

    // create deque with elements from 1 to 9
    std::deque<int> coll = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // find range [2,7]
    deque<int>::const_iterator pos1;
    pos1 = std::find(coll.cbegin(), coll.cend(), 2);

    deque<int>::const_iterator pos2;
    pos2 = std::find(coll.cbegin(), coll.cend(), 7);

    // [2,6]
    std::for_each(pos1, pos2, [&](int e) { os << e << ","; });

    EXPECT_THAT(os.str(), "2,3,4,5,6,");

    deque<int>::const_reverse_iterator rpos1(pos1);
    deque<int>::const_reverse_iterator rpos2(pos2);

    os.str("");

    // *cxx-error* cause runtime error -D_GLIBCXX_DEBUG
    // for_each(rpos1, rpos2, [&](int e)
    //
    // since rpos1 that point 2 and rpos1++ means pos1-- and
    // goes below begin()

    std::for_each(rpos2, rpos1, [&](int e) { os << e << ","; });

    EXPECT_THAT(os.str(), "6,5,4,3,2,");
  }
}

={============================================================================
*kt_dev_cxx_0000* cxx-iter-external-and-internal

*ex-interview* asked in phone screening. 

http://gafter.blogspot.co.uk/2007/07/internal-versus-external-iterators.html

In the "Gang Of Four" Patterns book's discussion of the Iterator pattern, we
read (page 260):

Who controls the iteration? A fundamental issue is deciding which party
  controls the iteration, the iterator or the 'client' that uses the iterator. 
  
When the client controls the iteration, the iterator is called an
`external-iterator` (C++ and Java), and when the iterator controls it, the
iterator is an `internal-iterator` (Lisp and functional languages). 

Clients that use an external iterator must advance the traversal and request
the next element explicitly from the iterator. In contrast, the client hands
an internal iterator an operation to perform, and the iterator applies that
operation to every element in the aggregate.

`external-iterator` are more 'flexible' than internal iterators. It's easy to
compare two collections for equality with an external iterator, for example,
  but it's practically impossible with internal iterators. Internal iterators
    are especially weak in a language like C++ that does not provide anonymous
    functions, closures, or continuations like Smalltalk and CLOS. But on the
    other hand, internal iterators are easier to use, because they define the
    iteration logic for you.


={============================================================================
*kt_dev_cxx_0000* cxx-fobj cxx-function-object cxx-functor

CPR 14.8, 571

* The function object is an object and can 'call' this object. Calling an
  object runs its overloaded call operator.

* The function call operator must be member.

* May define multiple versions of the call operator, each of which must differ
  as to the number or types of parameters.


*cxx-overload-call*

struct absInt {
  int operator() (int val) const {
    return val < 0 ? -val : val;
  }
};

int i = -42;
absInt absObj;
int ui = absObj(i);     // absObj.operator()(i)


*cpp-fobj-has-state*
1. Has state

Can be 'smart' functions because may have other member functions and data
members which means function objects have a 'state'.

In fact, the same functionality, represented by two 'different' function
objects instances of the same class, may have different 'states' at the same
time. This is not possible for ordinary functions. Another advantage of
function objects is that you can initialize them at 'runtime' before you
use/call them.

<ex> CPR 14.8
Allows users provide a different stream and different separator.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class PrintString {
  public:
    PrintString( ostream& o = cout, char c = ' ') : os(o), sep(c) {}

    // const member func. works well. Q: why const as os may change its state?
    // As with "bitwise-const", emits errors only when "assignment" is used on
    // members.

    void operator()(const string &s) const { os << s << sep; }

  private:
    ostream& os; 
    char sep;
};

int main()
{
  PrintString printer;
  printer("printer");

  PrintString errors( cerr, '\n' );
  errors("errors");
}


<ex>
With this technique, two different function objects can solve the problem of
having a function with two 'states' at the same time. For example, you could
simply declare `two function objects and use them independently`:

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class AddValue
{
  private:
    int theValue;

  public:
    AddValue( int v ) : theValue(v)
    { cout << "ctor is called: " << theValue << endl; }

    AddValue(const AddValue& rhs)
    { cout << "copy ctor is called: " << theValue << endl; }

    // note: What might be the result when use this form? 
    // there is no changes to container.
    //
    // void operator() (int elem) const

    void operator() (int &elem) const
    { elem += theValue; }
};

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  AddValue addx(10);
  AddValue addy(20);

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(), addx);
  cout << "-----------------------------" << endl;

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(), addy); 
  cout << "-----------------------------" << endl;

  PRINT_ELEMENTS(coll, "added first: " );
}

ctor is called: 10
ctor is called: 20
initialized: 1 2 3 4 5 6 7 8 9 
copy ctor is called: 0
copy ctor is called: -1218374876
-----------------------------
added 10   : 1 2 3 4 5 6 7 8 9 
copy ctor is called: 134519579
copy ctor is called: -1218374876
-----------------------------
added first: 134519580 134519581 134519582 134519583 ... 134519587 134519588 

note: Wrong result? since copy ctor is wrong and should be like this. The
reason for that if user defines copy ctor must do it right. So if do not
define copy ctor and then compiler would make it and this example works fine.
Here problem is that when defines copy ctor to print message and missed out
memberwise copy.

class AddValue
{
  AddValue(const AddValue& rhs)
  {
    cout << "copy ctor is called: " << rhs.theValue << endl;
    theValue = rhs.theValue;
  }
};

ctor is called: 10
ctor is called: 20
initialized: 1 2 3 4 5 6 7 8 9 
copy ctor is called: 10
copy ctor is called: 10
-----------------------------
added 10   : 11 12 13 14 15 16 17 18 19 
copy ctor is called: 20
copy ctor is called: 20
-----------------------------
added first: 31 32 33 34 35 36 37 38 39 


note: Why is copy ctor called two times? since for_each<> *algo-for-each*
returns _Function and confirms that there is one copy ctor when changes its
definition in stl_algo.h


*algo-for-each*
for_each (coll.cbegin(), coll.cend(), PrintInt());

Creates a temporary object of this class, which is passed to the for_each() as
an argument. The for_each() uses the temporary function object op to call
op(*act) for each element act. If op is an ordinary function, for_each() simply
calls it with *act as an argument. If op is a function object, for_each() calls
its operator () with *act as an argument.

namespace algo_code 
{
  // bits/stl_algo.h:

  /**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __f      `A unary function object.`
   *  @return   @p __f (std::move(@p __f) in C++0x).
   *
   *  Applies the function object @p __f to each element in the range
   *  @p [first,last).  @p __f must not modify the order of the sequence.
   *  If @p __f has a return value it is ignored.
   */
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        __glibcxx_requires_valid_range(__first, __last);

      // note: call op but not use return

      for (; __first != __last; ++__first)
        __f(*__first);

      return _GLIBCXX_MOVE(__f);
    }
}

2. Each function object has its own type. 

Ordinary functions have different types 'only' when their signatures differ.
However, function objects can have different types even when their signatures
are the same. See *cpp-function-adaptor* function<> example below. In fact,
    each functional behavior defined by a function object has its own type. 

This is a significant improvement for generic programming using 'templates'
because you can `pass functional behavior as a template parameter.` 

Doing so enables containers of different types to use the same kind of
function object as a sorting criterion, ensuring that you don't assign,
         combine, or compare collections that have different sorting criteria. 

You can even design hierarchies of function objects so that you can, for
example, have different, special kinds of one general criterion.

// create a set with special sorting criterion
set<Person, PersonSortCriterion> coll;

Note that the sorting criterion PersonSortCriterion is a 'type'. Thus, you can
use it as a template argument for the set. This would not be possible if you
implement the sorting criterion as a plain function.


3. Function objects are usually 'faster' than ordinary functions; function
pointer. The concept of templates usually allows better optimization because
more details are defined at 'compile' time. Thus passing function objects
instead of ordinary functions often results in better performance.


={============================================================================
*kt_dev_cxx_0000* cxx-fobj-predicate cxx-callable

To increase their `flexibility and power`, several algorithms allow the
passing of user-defined functions. This is `cxx-callable` to change a default
operator of algorithms. For example,

  The sort() uses "*cxx-less* operator<()" on element type to sort but want to
  use different order? If sort() was written to simply use "<" then cannot
  able to change its sort order regardless of whether element type supports
  the operator for that order. So the supported operator of element type is
  different matter.


{cxx-predicate}
A predicate is a special kind of auxiliary function. Predicates return a
`boolean`' and are often used to specify a sorting or a search criterion.
Depending on their purpose, predicates are `unary` or `binary`.

Not every unary or binary function that returns a boolean value is a valid
predicate. `the STL requires that predicates be stateless,` meaning that they
should always yield the same result for the same value.


<cxx-predicate-which-to-use> *algo-transform* *algo-for-each*
What predicate is used depends on each algorithm to use. Also see reference
argument to predicate.  

namespace cxx_code
{
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
      // note: call op but not use return

      for (; __first != __last; ++__first)
        __f(*__first);

      return _GLIBCXX_MOVE(__f);
    }

  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>

      _OutputIterator
      transform(_InputIterator __first, _InputIterator __last,
          _OutputIterator __result, _UnaryOperation __unary_op)
      {
        for (; __first != __last; ++__first, ++__result)
          // note: write to output to output iterator and unary
          *__result = __unary_op(*__first);
        return __result;
      }
} // namespace

int square_value_with_return(int value)
{
  value = value*value;
  return value;
}

void square_value_no_return(int value)
{
  value = value*value;
}

void square_refer_no_return(int &value)
{
  value = value*value;
}

TEST(AlgoForEach, Transform)
{
  // value, no changes on coll
  {
    set<int> coll{1, 2, 3, 4, 5, 6, 7, 8};
    for_each(coll.begin(), coll.end(), square_value_no_return);
    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6, 7, 8));
  }

  // reference, changes on coll
  {
    // compile error since key in set are const if use set
    // set<int> coll{1,2,3,4,5,6,7,8};

    vector<int> coll{1, 2, 3, 4, 5, 6, 7, 8};
    for_each(coll.begin(), coll.end(), square_refer_no_return);
    EXPECT_THAT(coll, ElementsAre(1, 4, 9, 16, 25, 36, 49, 64));
  }

  // algo-transform() differs in that it uses `dest`
  {
    vector<int> coll{1, 2, 3, 4, 5, 6, 7, 8};
    vector<int> result;
    transform(coll.begin(), coll.end(), back_inserter(result), 
        square_value_with_return);
    EXPECT_THAT(coll, ElementsAre(1, 2, 3, 4, 5, 6, 7, 8));
    EXPECT_THAT(result, ElementsAre(1, 4, 9, 16, 25, 36, 49, 64));
  }
}


*algo-sort*

The first forms of sort() and stable_sort() sort all elements in the range
[beg,end) with *cxx-less* operator<(). This means that have to provide
operator<() for a user type.

<ex>

namespace cxx_code
{
  // template< class RandomIt, class Compare>
  // void sort( RandomIt first, RandomIt last, Compare comp );

  // /usr/include/c++/4.9/bits/stl_algo.h

  /**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
   *  range @p [__first,__last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
   */
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _Compare __comp)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
          _RandomAccessIterator>)
        __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
            typename iterator_traits<_RandomAccessIterator>::value_type,
            typename iterator_traits<_RandomAccessIterator>::value_type>)
        __glibcxx_requires_valid_range(__first, __last);

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  /**
   *  @brief Sort the elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @e i in the range @p [__first,__last-1),  
   *  *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
   */
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // concept requirements
      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
          _RandomAccessIterator>)
        __glibcxx_function_requires(_LessThanComparableConcept<
            typename iterator_traits<_RandomAccessIterator>::value_type>)
        __glibcxx_requires_valid_range(__first, __last);

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }

  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  inline _Iter_less_iter
    __iter_less_iter()
    { return _Iter_less_iter(); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _Compare __comp)
    {
      if (__first != __last)
      {
        std::__introsort_loop(__first, __last,
            std::__lg(__last - __first) * 2,
            __comp);
        std::__final_insertion_sort(__first, __last, __comp);
      }
    }
} // namespace

TEST(AlgoSorting, AlgoSort)
{
  {
    vector<int> coll{3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5};
    sort(coll.begin(), coll.end());

    EXPECT_THAT(coll, 
        ElementsAreArray({1,2,2,3,3,3,4,4,4,5,5,5,6,6,7}));
  }

  {
    vector<int> coll{3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5};
    // *cxx-callable*
    sort(coll.begin(), coll.end(), std::greater<int>());

    EXPECT_THAT(coll, 
        ElementsAreArray({7,6,6,5,5,5,4,4,4,3,3,3,2,2,1}));
  }
}

bool shorter(string const& s1, string const& s2)
{
  return s1.size() < s2.size();
}

TEST(AlgoSorting, AlgoStableSort)
{
  vector<string> coll{"over", "quick", "red", "fox", "jumps", "red", "the", 
    "slow", "turtle", "the"};

  // sort by alphabet and remove dups. algo-unique()
  {
    std::sort(coll.begin(), coll.end());
    coll.erase(std::unique(coll.begin(), coll.end()), coll.end());
  }

  // eliminated
  EXPECT_THAT(coll, 
      ElementsAre("fox","jumps","over","quick","red","slow","the","turtle"));

  stable_sort(coll.begin(), coll.end(), shorter);

  // sorted and see that the order before sort is maintained
  EXPECT_THAT(coll, 
      ElementsAre("fox","red","the","over","slow","jumps","quick","turtle"));         // by size
}


<ex> *algo-find-if* *algo-prime*

namespace algo_find
{
  bool is_prime(int number)
  {
    // *cxx-abs*
    number = abs(number);

    // 0 and 1 are not prime numbers
    if (number == 0 || number == 1)
      return false;

    int divisor;

    // until find divisor which leaves 0 remainder, that is when divisor is 1 or
    // when other divisor
    for (divisor = number/2; number % divisor != 0; --divisor)
      ;

    // if divisor is 1 then no ther is found.
    return divisor == 1;
  }
} // namespace

// is used to search for the 'first' element of the given range for which the
// passed unary predicate yields true. If it does not find any element that
// matches the predicate, the algorithm returns the end of the range (its
// 'second' argument).

TEST(AlgoFind, FindIf)
{
  using namespace algo_find;

  list<int> coll;

  for (int i = 24; i <= 30; ++i)
    coll.push_back(i);

  auto pos = find_if(coll.begin(), coll.end(), is_prime);
  EXPECT_THAT(*pos, 29);
}


{cxx-predicate-must-stateless} CLR 10.1.4
Predicates are functions or function objects that return a boolean value or a
value that is convertible into bool. However, not every function that returns a
Boolean value is a valid predicate for the STL. This may lead to surprising
behavior.


namespace algo_predicate
{
  class PredicateWithState
  {
    public:
      PredicateWithState(int value):
        nth_(value), count_(0) {}

      // *cxx-unused*
      bool operator()(int)
      {
        return ++count_ == nth_;
      }

    private:
      int nth_;
      int count_;
  };
} // namespace

TEST(Predicate, Stateless)
{
  using namespace algo_predicate;

  list<int> coll = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  
  auto pos = remove_if(coll.begin(), coll.end(),
      PredicateWithState(3));

  coll.erase(pos, coll.end());

  // removed 3 and 6. WHY?
  EXPECT_THAT(coll, ElementsAre(1,2,4,5,7,8,9,10));
}

`Two elements, 3 and 6 elements, are removed.` This happens because the usual
implementation of the algorithm copies the predicate internally during the
algorithm:

See *algo-remove-if* code which uses __find_if which uses `passed predicate`
to find the first pos so 3 is found and this is first copy of predicate.

For the rest, remove_if uses the own copy of passed predicate which finds [3]
pos item that is 6 but this is [3] pos from this second copy of predicate.

The standard does not specify how often a predicate might be copied internally
by an algorithm. Thus, to get the guaranteed behavior of the C++ standard
library, you should not pass a function object for which the behavior
'depends' on how often it is copied or called. In other words: A predicate
should always be 'stateless'.

  *cxx-callable* 
  cxx-predicate is not function object since funciton object has state and is
  flexible but predicate do not have state. 
  

*cxx-const*
To ensure that you can't change the state of a predicate due to a function
call, `you should declare operator () as a constant member function.` 

Or possible to avoid this surprising behavior and to guarantee that this
algorithm works as expected even for a function object such as Nth, without
any performance penalties. You could implement remove_if() in such a way that
the call of find_if() is replaced by its contents:

template <typename ForwIter, typename Predicate>
ForwIter std::remove_if(ForwIter beg, ForwIter end, Predicate op)
{
  while (beg != end && !op(*beg)) {
    ++beg;
  }
  if (beg == end) {
    return beg;
  }
  else {
    ForwIter next = beg;
    return remove_copy_if(++next, end, beg, op);
  }
}

To my knowledge, this problem arises in current implementations 'only' with
the remove_if() algorithm. If you use remove_copy_if(), all works as expected. 

However, for portability, you should never rely on this implementation detail.
You should always declare the function call operator of predicates as being a
constant member function.


<cxx-fobj-predefined> <cxx-less>
some are cxx-predicate and some are not since do not return boolean.

#include <functional>

negate<type>()          - param
plus<type>()            param1 + param2
minus<type>()           param1 - param2
multiplies<type>()      param1 * param2
divides<type>()         param1 / param2
modulus<type>()         param1 % param2
equal_to<type>()        param1 == param2
not_equal_to<type>()    param1 != param2
less<type>()            param1 < param2
greater<type>()         param1 > param2
less_equal<type>()      param1 <= param2
greater_equal<type>()   param1 >= param2
logical_not<type>()     ! param
logical_and<type>()     param1 && param2
logical_or<type>()      param1 || param2
bit_and<type>()         param1 & param2
bit_or<type>()          param1 | param2
bit_xor<type>()         param1 ^ param2


set<int, less<int>> coll;      // == set<int> coll. sort with operator<
set<int, greater<int>> coll;   // sort with operator> 

sort(svec.begin(), svec.end(), greater<string>());    // temporary object


<code-less> template-less from bits/stl_function.h

namespace std {

  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };

  /// One of the @link arithmetic_functors math functors@endlink.
  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };

  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };

  *cxx-less*
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };

  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };

  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };

  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };

  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
};


<ex>
TEST(Predicate, Predefined)
{
  std::plus<int> op;
  EXPECT_THAT(op(10, 20), 30);
}


<cxx-predicate-value-reference>

namespace algo_predicate
{
  class PredicateWithValue
  {
    public:
      void operator()(int value)
      {
        value += 10;
      }
  };

  class PredicateWithReference
  {
    public:
      void operator()(int& value)
      {
        value += 10;
      }
  };
} // namespace

// template<typename _InputIterator, typename _Function>
//   _Function
// for_each(_InputIterator __first, _InputIterator __last, _Function __f)
// {
//   for (; __first != __last; ++__first)
//     __f(*__first);
// 
//   return _GLIBCXX_MOVE(__f);
// }

TEST(Predicate, ValueAndReference)
{
  using namespace algo_predicate;

  {
    vector<int> coll{1,2,3,4,5};
    std::for_each(coll.begin(), coll.end(), PredicateWithValue());
    EXPECT_THAT(coll, ElementsAre(1,2,3,4,5));
  }

  {
    vector<int> coll{1,2,3,4,5};
    std::for_each(coll.begin(), coll.end(), PredicateWithReference());
    EXPECT_THAT(coll, ElementsAre(11,12,13,14,15));
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-fobj-lambda cxx-lambda cxx-11

Lambdas, introduced with *cxx-11* , define a way to specify functional
behavior `inside an expression or statement.` 

You can define objects that represent functional behavior and pass these
objects as `unnamed inline function` to algorithms to be used as predicates or
for other purposes.

Like any other function, lambda has return, parameter, and function body but
unlike function, be defined inside a function.


{cxx-lambda-limits}

o not usable for some cases 
  by rule lambdas have no default constructor and no assignment operator. So,
  for a sorting criterion, a class defining the function objects might still
  be more intuitive.

o Another problem of lambdas is that they can’t have an internal state held
  over multiple calls of a lambda. If you need such a state, you have declare
  an object or variable in the outer scope and pass it by-reference with a
  capture into the lambda. In contrast, function objects allow you to
  encapsulate an internal state


// {cxx-predicate}
// A predicate is a special kind of auxiliary function. Predicates return a
// `boolean`' and are often used to specify a sorting or a search criterion.
// Depending on their purpose, predicates are 'unary' or 'binary'.


{cxx-lambda}

[capture list] (parameter list) -> return type { body }

The capture list is a list of `local variables in the enclosing function.`
`The parameter and return are optional` If omits them, will be *cxx-void* for
parameter or return. 

When return used in the body, has an `inferred return type.` 

<ex>

TEST(CxxFunctionObject, LambdaCaptureAndReturn)
{
  {
    auto func = []() {
      std::string value{"this is a callback"};
      return value;
    };

    EXPECT_THAT(func(), "this is a callback");
  }

  // deduced return is integer
  {
    auto func = [] { return 42; };

    EXPECT_THAT(func(), 42);
  }

  // deduced return is double
  {
    auto func = [] { return 42.0; };

    EXPECT_THAT(func(), 42.0);
  }

  // no deduction
  {
    auto func = []() -> double { return 42; };

    EXPECT_THAT(func(), 42.0);
  }

  // CXXSLR-3.1.10 Lambdas
  // [=] means that the outer scope is passed to the lambda by value. Thus, you
  // can `read` but not modify all data that was readable where the lambda was
  // defined.

  {
    int x = 42;
    int y = 42;

    auto func = [x, &y] {
      // std::cout << "x: " << x << std::endl;
      // std::cout << "y: " << y << std::endl;

      ++y;

      // *cxx-error*
      // cxx.cpp:2646:9: error: increment of read-only variable ‘x’
      //        ++x;
      // ++x;
    };

    x = 77;
    func();
    func();

    // when do capture value? the question is wrong since 
    // EXPECT_THAT(x, 42); is true inside of lambda

    EXPECT_THAT(x, 77);
    EXPECT_THAT(y, 44);
  }


  // To have a mixture of passing by value and passing by reference, you can
  // declare the lambda as mutable. In that case, objects are passed by value,
  // but inside the function object defined by the lambda, you have write access
  // to the passed value.
  // Ok but `x` do not change so what's the point???

  {
    int x = 42;
    int y = 42;

    auto func = [x, &y] () mutable {
      // std::cout << "x: " << x << std::endl;
      // std::cout << "y: " << y << std::endl;

      ++y;

      // no *cxx-error*
      ++x;
    };

    func();
    func();

    // not 44
    EXPECT_THAT(x, 42);
    EXPECT_THAT(y, 44);
  }
}

<ex>
class Work
{
  public:
    static const int DefaultId{0};

    // see that cxx-lambda is used to initialize func_

    Work(int id=DefaultId)
      : id_{id}, func_{[]{}} {}

  private:
    std::function<void()> func_;
};


<ex>

// initialized  : over quick red fox jumps red the slow turtle the 
// sorted       : fox jumps over quick red red slow the the turtle 
// eliminated   : fox jumps over quick red slow the turtle 
// stable sorted: fox red the over slow jumps quick turtle 
// 3 words of length 5 or longer
// for_each     : fox red the over slow jumps quick turtle 
// jumps quick turtle 

namespace cxx_lambda
{
  template<typename T>
    inline void PRINT_ELEMENTS( const T& coll, const std::string &opt = "")
    {
      std::cout << opt;

      for( const auto &elem : coll )
        std::cout << elem << ' ';

      std::cout << std::endl;
    }

  // *algo-unique*
  void eliminate_duplicates(vector<string>& words)
  {
    sort(words.begin(), words.end());
    auto unique_end = unique(words.begin(), words.end());
    words.erase(unique_end, words.end());
  }

  bool check_size(string const& s, string::size_type sz)
  {
    return s.size() >= sz;
  }

  void biggies(vector<string>& words, vector<string>::size_type sz)
  {
    eliminate_duplicates(words);

    // PRINT_ELEMENTS(words, "eliminated: ");

    sort(words.begin(), words.end(),
        [](string const& a, string const& b)
        { return a.size() < b.size(); });

    // PRINT_ELEMENTS(words, "statle sorted: ");

    // get an iter of the first element whose size is >= sz

    // the problem is that find_if() uses *cxx-predicate* which is unary but we
    // need two args.
    //
    // *cxx-lambda* version
    //
    // error when use:
    //
    // [](string const& e)
    //
    // cxx.cpp:2254:30: error: ‘sz’ is not captured
    //          { return e.size() >= sz; });
    //                               ^
    //
    // works when use:
    //
    // [sz](string const& e)
    //
    // auto wc = find_if(words.begin(), words.end(),
    //     [=](string const& e)
    //     { return e.size() >= sz; });

    // *cxx-bind* version
    auto wc = find_if(words.begin(), words.end(),
        std::bind(check_size, _1, sz));

    // get the number of elements that are its size >= sz
    // use *cxx-iter-arithmetic* since it's vector
    auto num = words.end() - wc;

    EXPECT_THAT(num, 3);

    vector<string> result{};

    for_each(wc, words.end(),
        [&](string const& e)
        { result.push_back(e); });

    EXPECT_THAT(result, ElementsAre("jumps", "quick", "turtle"));
  }

} // namespace

TEST(Lambda, Biggies)
{
  using namespace cxx_lambda;

  vector<string> coll{"over", "quick", "red", 
    "fox", "jumps", "red", "the", "slow", "turtle", "the"};

  // PRINT_ELEMENTS( coll, "initialized  : ");

  biggies( coll, 5 );
}


*cxx-lambda-capture*
When define lambda, compiler generates a new `unnamed class` so when pass it to
a function, defines both a new type and an object of that type. So the data
member of a lambda are initialized when a lambda object is created. That means
that `the variable captured by a lambda is 'local' to a lambda.`

// value or reference

v1 = 42;
auto f = [v1] { return v1; };
v1 = 0;
auto j = f();     // j is 42. f is callable

v1 = 42;
auto f = [&v1] { return v1; };
v1 = 0;
auto j = f();     // j is 0.

Unlike parameters, the value of captured variable is copied when the lambda is
`created, not when it is called (executed).` When pass lambda such as return a
lambda, careful for the same reason that a function must not return a
reference to a local variable. If possible, avoid capturing pointers or
reference.


<cxx-lambda-capture-implicit>
`Let the compiler infer variables` we use from the code in the lambda body.
Use an & or = in the capture list. The revised is:

// get an iterator to the first element whose size is >= sz
auto wc = find_if( words.begin(), words.end(),
               [=](const string &a)
               { return a.size() >= sz; } );

// C++PL
The [] is a capture list specifying that `local names` used (such as x) will be
accessed through references. Capture all local names used by reference is [&],
`to “capture” only x`, we could have said so: [&x].

Capture all local names used `by value` is [=]. To give the generated object a
`copy of x`, we could have said so: [=x].

`Capture nothing is [].` 


<ex>

  vector<string> data{"a", "b"};

  // function<void()>
  // capture reference
  // auto executeFunction = [&] {

  // capture copy which means trigger vector copies
  // auto executeFunction = [=] {
      stringstream s;
      s << data[0] << data[1];
      callbackFunction(s.str());
   };

<ex>

// first, last are iterator, i is int, results is vector

        std::vector<T> results(thread_count);

        for (int i = 0; i < thread_count; ++i)
        {
          first = last;

          if (i == thread_count -1)
            last = end;
          else 
            std::advance(last, size);
          
          // wrong result as each thread ends up using final value of
          // iterators since it uses reference but nees snapshot of iterators
          // to work correctly.
          //
          // threads.emplace_back([&]()

          // use copies and right result.
          threads.emplace_back([first, last, i, &results]()
              {
                results[i] = *std::min_element(first, last);
              });
        }


<ex> 
/* 
Suppose that you search in a collection for the first element with a value
that is between x and y.

If need to use in more than one or two places, use function than a lambda.
However, it is not easy to write function to replace a lambda that captures
local variables. For example, find_if takes unary predicate and see how to
pass more than one as this example.
*/

TEST(Lambda, Compare)
{
  deque<int> coll = { 1, 3, 19, 5, 13, 7, 11, 2, 17 };

  int x{5};
  int y{12};

  // use lambda
  {
    auto pos = find_if(coll.begin(), coll.end(),
        [=](int e)
        { return e > x && e < y; });

    EXPECT_THAT(*pos, 7);
  }

  // use cxx-bind which complicated than other ways
  {
    auto pos = find_if (coll.begin(), coll.end(),  // range
        bind(logical_and<bool>(),     // search criterion
          bind(greater<int>(),_1,x),  // _1 > x
          bind(less<int>(),_1,y)));   // _1 < y

    EXPECT_THAT(*pos, 7);
  }

  // handwritten loop, before cxx-11
  {
    deque<int>::iterator pos;

    for (pos = coll.begin(); pos != coll.end(); ++pos)
      if (*pos > x && *pos < y)
        break;

    EXPECT_THAT(*pos, 7);
  }

  // use cxx-fobj cxx-predicate
  {
    class Pred
    {
      public:
        Pred(int x, int y) : x_(x), y_(y) {}
        bool operator()(int value) const
        { return value > x_ && value < y_; }
      private:
        int x_;
        int y_;
    };

    auto pos = find_if(coll.begin(), coll.end(), Pred(x, y));

    EXPECT_THAT(*pos, 7);
  }
}

CXXSLR-6.10.4

Lambdas are a kind of implicitly defined function object. Thus lambdas usually
provide the more intuitive approach to defining functional behavior of STL
algorithms. In addition, lambdas should be as fast as function objects.

However, there are also some drawbacks to lambdas:

o You can't have a hidden internal state of such a function object. Instead,
  all data that defines a state is defined by the caller and passed as a
  capture.

  <cxx-lambda-limits>
  Cannot be used sorting-criterion for associative containers and have state
  as function object does.

o The advantage of specifying the functional behavior where it is needed
  partially goes away when it is needed at 'multiple' places. You can define a
  lambda and assign it to an auto object then, but whether this is more
  readable than directly defining a function object is probably a matter of
  taste.


={============================================================================
*kt_dev_stl_063* cpp-fobj-as-argument

Functor are 'most' often used as argument to the algorithms.

<ex> 
Will print each element in vs to cerr followed by a newline.

for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));

CLR 6.10

Functional arguments for algorithms don't have to be functions and can be any
'callables'. 

*cpp-callables*

Since C++11, the standard uses the term function object for every object that
can be used as a function call. Thus, function pointers, objects of classes
with operator () or with a conversion to a pointer to function, and lambdas
are function objects. Here in this book, however, I use the term for objects
of classes with operator() defined.


<ex> use function object

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class PrintInt
{
  public:
    void operator()(int elem) const
    {
      cout << elem << ' ';
    }
};

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  // print all elements
  for_each (coll.cbegin(), coll.cend(), // range
      PrintInt());                      // operation. T() is temporary

  cout << endl;
}


<ex> use a usual function

void print(int elem)
{ cout << elem << ' '; }

int main()
{
  vector<int> coll{1,2,3,4,5,6,7,8,9};

  for_each( coll.cbegin(), coll.cend(), print );
  cout << endl;
}


{compile-runtime-change}
Suppose that want to add a 'certain' value to all elements of a collection.
Shows that functor with state is useful.

<ex>
When know the value to add at 'compile' time, can use an ordinary function
predicate.

void add10 (int& elem)
{
  elem += 10;
}

for_each(coll.begin(), coll.end(), add10);


<ex>
When know the 'different' values to add at 'compile' time, could use template.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

template <int theValue>       // *cxx-template-nontype-paremeter*
void add( int& elem )
{
  elem += theValue;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  // note: When use cbegin() instead, causes compile error. However, works in
  // previous examples?
  //
  // : error: invalid initialization of reference of type "int&" from
  // expression of type "const int"
  //
  // The reason is that 
  //
  // 1. from for_each code: __f(*__first);
  //
  // 2. from operation code: void add( int& elem )
  //
  // Therefore, add(*__first) and this is "int& elem <- const int". For
  // previous examples, the argument type was int so no problem.

  for_each (coll.begin(), coll.end(),   // range
      add<10>);                         // operation. or add<20>

  PRINT_ELEMENTS(coll, "added      : " );
}

initialized: 1 2 3 4 5 6 7 8 9 
added      : 11 12 13 14 15 16 17 18 19 


<ex>
When know the value to add at 'runtime', then things get complicated. 

This normally results in a global variable that is used both by the function
that calls the algorithm and by the function that is called by the algorithm.
Did you ever copy the definition of a function because it had a static variable
to keep its state(the value to add) and you needed the same function with
another state at the same time? This is exactly the same type of problem. You
can't achieve this with one ordinary function. The below solves it by using two
different function object but same type and functionality.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class AddValue
{
  private:
    int theValue;

  public:
    AddValue( int v ) : theValue(v) { }

    void operator() (int &elem) const
    { elem += theValue; }
};

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(),   // range
      AddValue(10));                    // operation

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(),   // range
      AddValue(*coll.begin()));         // operation. 'runtime'

  PRINT_ELEMENTS(coll, "added first: " );
}

initialized: 1 2 3 4 5 6 7 8 9 
added 10   : 11 12 13 14 15 16 17 18 19 
added first: 22 23 24 25 26 27 28 29 30 


{as-sorting-criteria} CLR 10.1.1
Need a sorted collection of elements that have a class for example, a
collection of Persons. However, can't use the usual operator < to sort the
objects. How?

note: WHY? How about operaor<()?

class Person {
  public:
    string firstname() const;
    string lastname() const;
    ...
};

// class for function predicate
// operator () returns whether a person is less than another person
class PersonSortCriterion {
  public:
    bool operator() (const Person& p1, const Person& p2) const {

      // a person is less than another person
      // if the last name is less
      // if the last name is equal and the first name is less
      return p1.lastname()<p2.lastname() ||
        (p1.lastname()==p2.lastname() &&
         p1.firstname()<p2.firstname());
    }
};

// create a set with special sorting criterion
set<Person, PersonSortCriterion> coll;

Note that the sorting criterion PersonSortCriterion is a 'type'. Thus, you can
use it as a template argument for the set and can design function objects that
represent different sorting criteria with the same type. This would not be
possible if you implement the sorting criterion as a plain function


<as-template-argument>

template <typename T>   // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

This is function template and is useful. However, only supports '<' on type.
How about others such as '>'? If write a template supporting function object,
    then supports whatever operations user selects.

See <template-default-argument> for more.

template <typename T, typename F = less<T>>
int compare( const T &v1, const T &v2, F f = F())
{
  if( f(v1, v2) ) return -1;
  if( f(v2, v1) ) return 1;
  return 0;
}


={============================================================================
*kt_dev_stl_063* cpp-fobj-pass-by-reference

{function-object-passed-by-value} CLR 10.1.2, 3
A function that may have more than one state at the same time.

The function objects are copied or passed by value rather than by reference.
Thus, the algorithm does not change the state of the function object.

Passing function objects by 'value' instead of by reference has the advantage
that you can pass constant and 'temporary' expressions.

The disadvantage of passing the function object by value is that you can't
benefit from modifications of the state of the function objects when access to
the 'final' state might be necessary.

There are three ways to get a "result" from function objects passed to
algorithms:

1. You can keep the state externally and let the function object refer to it.
2. You can pass the function objects by reference.
3. You can use the return value of the for_each() *algo-for-each*


<pass-by-reference> *algo-generate*

10.1.2 Function Objects with Internal State

`To pass a function object by reference`, simply have to qualify the call of
the algorithm so that the function object type is a reference. By this, can
contiune the sequence.

namespace algo_generate
{
  class IntegerSequence
  {
    public:
      IntegerSequence(int value) : value_(value) {}

      int operator()()
      { return ++value_; }

    private:
      int value_;
  };
} // namespace

TEST(AlgoGenerate, Reference)
{
  using namespace algo_generate;

  std::list<int> coll;

  // starting from 1
  IntegerSequence seq(1);

  // `cxx-template-explicit-argument`
  std::generate_n<back_insert_iterator<list<int>>, int, IntegerSequence&>(
      back_inserter(coll),
      4,                    // number of elements
      seq
      );

  EXPECT_THAT(coll, ElementsAre(2,3,4,5));

  // insert values from 43 to 46

  generate_n(
      back_inserter(coll),  // start
      4,                    // number of elements
      IntegerSequence(42)
      );

  EXPECT_THAT(coll, ElementsAre(2,3,4,5,43,44,45,46));

  // currently seq has 6 value and start from that since passed by value

  generate_n(
      back_inserter(coll),  // start
      4,                    // number of elements
      seq
      );

  EXPECT_THAT(coll, 
      ElementsAreArray({2,3,4,5,43,44,45,46,6,7,8,9}));

  // no change of sequence values and repeat it again since seq is copied.

  generate_n(
      back_inserter(coll),  // start
      4,                    // number of elements
      seq
      );

  EXPECT_THAT(coll, 
      ElementsAreArray({2,3,4,5,43,44,45,46,6,7,8,9,6,7,8,9}));
}


<return-function-object>
The passing a functor by reference in order to access its `final state` is not
necessary if you use the `algo-for-each` which has the 'unique' ability to
return its function object (no other algorithm can do this). 

Thus, you can query the state of your function object by checking the return
value of `for_each()`.

The following program is a nice example of the use of the return value of
for_each() and shows how to process the mean value of a sequence:

// function object to process the mean value
class MeanValue {
  private:
    long num; // number of elements
    long sum; // sum of all element values

  public:
    MeanValue () : num(0), sum(0) {
    }

    void operator() (int elem) {
      ++num; // increment count
      sum += elem; // add value
    }

    // return mean value
    double value () {
      return static_cast<double>(sum) / static_cast<double>(num);
    }
};

int main()
{
  vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8 };

  // process and print mean value
  MeanValue mv = for_each (coll.begin(), coll.end(),  // range
      MeanValue());                                   // operation

  cout << "mean value: " << mv.value() << endl;
}

mean value: 4.5


{arg-type-on-function-object}
As with "arg-type-on-bind", should be a match between the element type of
container and the element type of function-object. 

<ex>
class PrintInt
{
  public:
    void operator() (string elem) const   // note: string
    {
      cout << elem << ' ';
    }
};

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  // print all elements
  for_each (coll.cbegin(), coll.cend(), // range
      PrintInt());                      // operation

  cout << endl;
}

$ ./cppbl.sh sample.cpp 
In file included from /usr/include/c++/4.7/algorithm:63:0,
                 from sample.cpp:3:
/usr/include/c++/4.7/bits/stl_algo.h: 
In instantiation of 
'_Funct std::for_each(_IIter, _IIter, _Funct) [with _IIter 
  = __gnu_cxx::__normal_iterator<const int*, std::vector<int> >; _Funct = PrintInt]':

sample.cpp:27:17:   required from here
/usr/include/c++/4.7/bits/stl_algo.h:4442:2: error: invalid conversion 
  from ‘int’ to ‘const char*’ [-fpermissive]


{support-for-pointers}
any real case which is useful?

p575. Recall that comparing two unrelated pointers is undefined. However,
  might want to sort a vector of pointers. Although it would be undefined for
  us to do directly, can do through library function object. 

vector<string *> nameTable;
sort(nameTable.begin(), nameTable.end(), less<string *>());


={============================================================================
*kt_dev_cxx_0000* cxx-fobj-function-type cxx-function-adaptor

Assume to build a simple desk calculator and to define a function table to
store pointers to these callables since all have the same call signature. 

// ordinary function

int add(int i, int j) { return i+j;}

// lambda

auto mod = [](int i, int j) { return i%j; };

// function object

struct divide {
  int operator () (int denominator, int divisor) {
    return denominator/divisor;
  }
};

// string to function mapping

map<string, int(*)(int, int)> binops;

binops.insert({"+", add});
binops.insert({"%", mod});

However, the second is in error since like any other object, a callable object
has a type and lambda type does not match the type of the values in the map.

However, callables with different types may `share the same call signature.` A
call signature corresponds to a function type.


*cxx-function-adaptor*

Solves this and represent `any callables that has the same call signature.` 

#include <functional>

function<int(int,int)>

function<int(int,int)> f1 = add;
function<int(int,int)> f2 = divide();
function<int(int,int)> f3 = [](int i, int j) { return i%j; };

cout << f1(4,2) << endl;
cout << f2(4,2) << endl;
cout << f3(4,2) << endl;

Can redefine a map to build a calculator.

map<string, function<int(int, int)>> binops = {
  {"+", add},
  {"-", std::minus<int>()},
  {"/", divide()},
  ...
};

And when index a map, get a reference to an object of type `function`. The
`function` type overloads the call operator which takes its own arguments and
passes them along to its stored callable objects.

binops["+"](10,5);   // adds(10,5)
binops["-"](10,5);   // minus<int>(10,5)
...


<ex>

template<typename TFrom, typename TTo> 
  std::vector<TTo> Collect(const std::vector<TFrom>& source,
      std::function<TTo(TFrom)> func) 
{
  std::vector<TTo> results;
  std::transform(source.begin(), source.end(), std::back_inserter(results), func);
  return results;
}

  return Collect<User, string>(user, [](User each) { return each.name();});


={============================================================================
*kt_dev_cxx_0000* cxx-fobj-type cxx-function-pointer

{cxx-function-type}
The function pointer points a particular 'type', function's type.

bool (const string &, const string &);        // function's type
bool (*pf)(const string &, const string &);   // pointer to function's type

The () around *pf are necessary. Otherwise, declare pf as a function that
returns a pointer to bool.

bool *pf(const string &, const string &);


When use the name of a function as a 'value', the function is automatically
converted to a pointer.

pf = lengthCompare;                               // automatic conversion
pf = &lengthCompare;

bool b1 = pf( "hello", "goodbye" );               // no need to dereference
bool b1 = *pf( "hello", "goodbye" );
bool b1 = lengthCompare( "hello", "goodbye" );


<function-type-to-member-function>

class atm
{
  private:
    messaging::receive incoming_;
    messaging::sender bank_;
    messaging::sender interface_hardware_;

    void (atd::*state)();

    void waiting_for_card();

    void run()
    {
      state = &atm::waiting_for_card;

      (this->*state)();
    }
};


<function-pointer-parameter>
The third parameter is "function type" and when use function directly, it is
'automatically' converted to function pointer. 

void useBigger( const string &s1, const string &s2, 
    bool pf( const string &, const string & ) );

useBigger( s1, s2, lengthCompare );

  "this is why stl algorithm can take opeartion as typename."


The equivalent declaration but 'explicit'.

void useBigger( const string &s1, const string &s2, 
    bool (*pf)( const string &, const string & ) );

Can use type alias and see that decltype() returns function type.

typedef bool Func( const string &, const string & );
typedef decltype( lengthCompare ) Func;                       // same

typedef bool (*FuncP)( const string &, const string & );
typedef decltype( lengthCompare ) *FuncP;                     // same

void useBigger( const string &s1, const string &s2, Func );
void useBigger( const string &s1, const string &s2, FuncP );  // same

note: 
function's type will be treated as a pointer but only when used as parameter.
Not automatically treated in return type.

CPR 249 for more.


={============================================================================
*kt_dev_cxx_0000* cxx-fobj-bind cxx-bind

The functions ref, cref, and bind are accepted to the *cxx-11* standard. 

#include <functional>
using namespace std::placeholders;

*cxx-11*
$ g++ -std=c++0x t_boost.cpp -L/usr/local/lib


CLR 10.2.2

A `function adapter` is a function object that enables the `composition` of
function objects with each other, with certain values, or with special
functions. (according to the composite pattern in GOF)

auto new_callable = bind(callable, args...);

that `binds callable with args and makes new callable`


The `bind()` allows you to:

o Adapt and compose new function objects out of existing or predefined
  function objects

o Call global functions

o Call `member functions` for objects, `pointers` to objects, and `smart` pointers
  to objects

<code>
namespace cxx_code
{
  /**
   *  @brief Function template for std::bind.
   *  @ingroup binders
   */
  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    `bind`(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
          std::forward<_BoundArgs>(__args)...);
    }
} // namespace

#3  0x73ea9934 in call<nickel::system::GstMediaRouter* const> (this=0x5dbac0, u=<optimized out>) 
    at /boost/bind/mem_fn_template.hpp:105

#4  operator()<nickel::system::GstMediaRouter*> (this=0x5dbac0, u=<optimized out>) 
    at /boost/bind/mem_fn_template.hpp:115

#5  operator()<Zinc::Media::Position, boost::_mfi::cmf0<Zinc::Media::Position, nickel::system::GstMediaRouter>, boost::_bi::list0> (f=..., this=0x5dbac8, a=<optimized out>) 
    at /boost/bind/bind.hpp:243

#6  operator() (this=0x5dbac0) at boost/bind/bind_template.hpp:20

#7  apply (promise=..., functor=...) at /include/zinc-common/async/detail/async-helpers_Impl.h:53


<cxx-bind-placeholder-namespace>
Thus, if a function, member function, function object, or lambda requires some
parameters, you can `bind them to specific or passed arguments.` Specific
arguments you simply name. For passed arguments, you can use the predefined
placeholders _1, _2, ... defined in namespace std::placeholders.

To avoid the tedious repetition of the namespace placeholders, you can use a
corresponding using directive.

using namespace std;
using namespace std::placeholders;

Otherwise, would get:

:20:25: error: "_1" was not declared in this scope


{cxx-bind-nested}
This kind of programming results in functional composition. What is interesting
is that all these function objects are usually declared `inline`. Thus, use a
function-like notation or abstraction but you get good performance.


<case-when-bind-useful>

<ex> different number of arguments

This is an example to show that bind solves different number of argument since
find_if requires `unary predicate` but want to use more complicated predicate.

*cxx-find-if* *cxx-find*

namespace cxx_code
{
  // bits/predefined_ops.h

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
        : _M_value(__value)
      { }

      // shows to use operator==()
      template<typename _Iterator>
        bool
        operator()(_Iterator __it)
        { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }


  // bits/stl_algo.h

  /**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __val    `The value to find.`
   *  @return   `The first iterator` @c i in the range @p [__first,__last)
   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
   */
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    `find`(_InputIterator __first, _InputIterator __last,
        const _Tp& __val)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        __glibcxx_function_requires(_EqualOpConcept<
            typename iterator_traits<_InputIterator>::value_type, _Tp>)
        __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if(__first, __last,
          __gnu_cxx::__ops::__iter_equals_val(__val));
    }

  /**
   *  @brief Find the first element in a sequence for which a
   *         predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that `@p __pred(*i)` is true, or 
   *  @p `__last if no such iterator *  exists.`
   */
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    `find_if`(_InputIterator __first, _InputIterator __last,
        _Predicate __pred)
    {
      // concept requirements
      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
            typename iterator_traits<_InputIterator>::value_type>)
        __glibcxx_requires_valid_range(__first, __last);

      return std::__find_if(__first, __last,
          __gnu_cxx::__ops::__pred_iter(__pred));
    }

  // This is an overload used by find_if() for the Input Iterator case.

  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
        _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(`__pred(*__first)`))
        ++__first;
      return __first;
    }
} // namespace


<ex>

TEST(CxxFunctionObject, Bind)
{
  using namespace cxx_function;

  // use library defined callable
  {
    std::plus<int> fo;
    EXPECT_THAT(fo(10, 20), 30);
  }

  // expect true if size >= 6
  {
    auto fo = std::bind(check_size, std::placeholders::_1, 6);

    EXPECT_THAT(fo("hello"), false);
    EXPECT_THAT(fo("hello!"), true);
  }

  // show when bind() composites
  {
    std::vector<std::string> coll{"bind", "do", "wonders"};

    int size{6};

    auto found1 = std::find_if(coll.cbegin(), coll.cend(),
        [size](std::string const &e)
        { return e.size() >= size; }
        );

    auto found2 = std::find_if(coll.cbegin(), coll.cend(),
        [](std::string const &e)
        { return e.size() >= 6; }
        );

    auto found3 = std::find_if(coll.cbegin(), coll.cend(),
        std::bind(check_size, std::placeholders::_1, size));

    auto found4 = std::find_if(coll.cbegin(), coll.cend(),
        std::bind(check_size, std::placeholders::_1, 6));

    EXPECT_THAT(*found1, "wonders");
    EXPECT_THAT(*found1, *found3);
    EXPECT_THAT(*found2, *found4);

    // don't have to use arguments to bind() and found the first as function
    // object always returns true
    auto found5 = std::find_if(coll.cbegin(), coll.cend(),
        std::bind(check_size, "wonders", 6));

    EXPECT_THAT(*found5, "bind");
  }

  // show when bind() changes order of arguments
  {
    auto fo1 = std::bind(shorter_than_lhs, std::placeholders::_1, std::placeholders::_2);
    auto fo2 = std::bind(shorter_than_lhs, std::placeholders::_2, std::placeholders::_1);

    EXPECT_THAT(fo1("bind", "wonders"), false);
    EXPECT_THAT(fo2("bind", "wonders"), true);
  }

  // shows that bind() internally uses copy of passed arguments
  {
    int value{};

    std::bind(increase, value)();   // same as fo(value) but no effect on value
    std::bind(increase, value)();   // same as fo(value) but no effect on value

    EXPECT_THAT(value, 0);

    // *cxx-ref*
    std::bind(increase, std::ref(value))();   // increased
    std::bind(increase, std::ref(value))();

    EXPECT_THAT(value, 2);
  }
}


<bind-use-global-function>
// The bind() can be used to call global functions.

#include <iostream>
#include <algorithm>
#include <functional>
#include <locale>
#include <string>

using namespace std;
using namespace std::placeholders;

// when case sensitivity doesn't matter.
char myToupper (char c)
{
  // *cxx-toupper*
  // /usr/include/ctype.h:127:12: note: int toupper(int)

  std::locale loc;
  return std::use_facet<std::ctype<char>>(loc).toupper(c);
}

int main()
{
  string s("Internationalization");
  string sub("Nation");

  // search substring case insensitive
  string::iterator pos;

  // *algo-search*
  //
  // ForwardIterator1
  // search (ForwardIterator1 beg, ForwardIterator1 end,
  //    ForwardIterator2 searchBeg, ForwardIterator2 searchEnd,
  //    BinaryPredicate op)
  //
  // Both forms return the position of the first element of the first subrange
  // matching the range [searchBeg,searchEnd) in the range [beg,end).
  //
  // In the second form, for every comparison between elements, the call of the
  // binary predicate op(elem,searchElem) has to yield true.

  pos = search (s.begin(),s.end(),  // string to search in
      sub.begin(),sub.end(),        // substring to search
      bind(equal_to<char>(),        // compare criterion
        bind(myToupper,_1),
        bind(myToupper,_2)));

  if (pos != s.end()) {
    cout << "\"" << sub << "\" is part of \"" << s << "\""
      << endl;
  }
}

<ex> algo-search
// do not modify s
bool caseInsFind2(string& s, const string& p)
{
  auto it = search(s.begin(), s.end(), p.begin(), p.end(),
      [](char lhs, char rhs)
      {
      return toupper(lhs) == rhs;
      });

  return it != s.end();
}

*cxx-bind-copy*

So cxx-bind use copy context for args

{
  // from ASRequestPrivate::marshallAndSendReply
  static void marshallAndSendReply(const std::vector<std::string> &headers, const std::string &body)
  {
    std::this_thread::sleep_for(chrono::milliseconds(100));

    std::cout << "================" << std::endl;
    std::cout << "headers: size : " << headers.size() << ": ";
    for (const auto &h : headers)
    {
      std::cout << h << ", ";
    }
    std::cout << std::endl;

    std::cout << "body: " << body << std::endl;
  }
} // namespace

// invokeMethond() use copy? okay use on temporary?

// [ RUN      ] EventLoop.event_invoke_do_copy
// reset them and quit  <<---
// ================
// headers: size : 1: header1,
// body: body1
// ================
// headers: size : 2: header1, header2,
// body: body2
// ================
// headers: size : 3: header1, header2, header3,
// body: body3
// ================
// headers: size : 4: header1, header2, header3, header4,
// body: body4
// ================
// headers: size : 5: header1, header2, header3, header4, header5,
// body: body5
// [       OK ] EventLoop.event_invoke_do_copy (501 ms)
// 
// [ RUN      ] EventLoop.event_invoke_do_copy
// ================
// headers: size : 1: header1,
// body: body1
// ================
// headers: size : 2: header1, header2,
// body: body2
// ================
// headers: size : 3: header1, header2, header3,
// body: body3
// ================
// headers: size : 4: header1, header2, header3, header4,
// body: body4
// reset them and quit  <<---
// ================
// headers: size : 5: header1, header2, header3, header4, header5,
// body: body5
// [       OK ] EventLoop.event_invoke_do_copy (501 ms)
// 
// [ RUN      ] EventLoop.event_invoke_do_copy
// ================
// headers: size : 1: header1,
// body: body1
// ================
// headers: size : 2: header1, header2,
// body: body2
// ================
// headers: size : 3: header1, header2, header3,
// body: body3
// reset them and quit  <<--- 
// ================
// headers: size : 4: header1, header2, header3, header4,
// body: body4
// ================
// headers: size : 5: header1, header2, header3, header4, header5,
// body: body5
// [       OK ] EventLoop.event_invoke_do_copy (501 ms)

TEST(EventLoop, event_invoke_do_copy)
{
  {
    int value{};

    EventLoop loop;

    auto f1 = std::async(std::launch::async, [&]() {
      std::vector<std::string> header;
      std::string body;

      // header.push_back(std::string("header1"));
      header.push_back("header1");
      body = "body1";

      loop.invokeMethod(marshallAndSendReply, header, body);
      
      // now changes header and body. post it
      header.push_back("header2");
      body = "body2";
      loop.invokeMethod(marshallAndSendReply, header, body);

      // now changes header and body. post it
      header.push_back("header3");
      body = "body3";
      loop.invokeMethod(marshallAndSendReply, header, body);

      // now changes header and body. post it
      header.push_back("header4");
      body = "body4";
      loop.invokeMethod(marshallAndSendReply, header, body);

      // now changes header and body. post it
      header.push_back("header5");
      body = "body5";
      loop.invokeMethod(marshallAndSendReply, header, body);

      // okay, reset them 
      header.clear();
      body.clear();

      std::cout << "reset them and quit" << std::endl;

      EXPECT_THAT(header.size(), 0);
      EXPECT_THAT(body.size(), 0);

      loop.quit(0);
    });

    // blocks here
    loop.run();
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-fobj-bind-member-function

Use pointer to member function?

`a pointer to member is not a callable object`; do not support the function
call operator and cannot directly pass a pointer to member function to an
algorithm.

auto fp = &string::empty;
find_if(svec.begin(), svec.end(), fp);

*cxx-error* and won't compile since the code inside find_if executes something
like:

if (fp(*it))

HOW to slove?

*cxx-function*

o creates a callable for a member function and knows that it must use the
  appropriate pointer-to-member operator to make the call.

o provides polymorphic wrappers that `generalize the notion of a function pointer.`

o #include <functional>

o the first parameter must represent the (normally implicit) object
  on which the member will be run `target object` as it calls member function.

o the signature to `function` must speficy whether the object will be passed as
  a pointer or reference.


namespace cxx_function
{
  class Foo {
    public:
      Foo(size_t value = 0) : value_(value) {}

      void update_10() noexcept
      { value_ += 10; }

      void update_20() noexcept
      { value_ += 20; }

      void update_30() noexcept
      { value_ += 30; }

      size_t get_value() const noexcept
      { return value_; }

    private:
      size_t value_;
  };

  size_t print_value(Foo &foo)
  { return foo.get_value(); }

} // namespace

TEST(CxxFunctionObject, Function)
{
  using namespace cxx_function;

  // expect that nullptr if not set
  {
    Foo foo = Foo(100);
    std::function<void(Foo &)> op;

    if (op == nullptr)
      EXPECT_THAT(true, true);
    else
      EXPECT_THAT(true, false);
  }

  // when use std::function, have to speficy `target`
  {
    Foo foo = Foo(100);
    std::function<void(Foo &)> op = &Foo::update_10;

    // specify the target object
    //
    // that performing a function call without having a `target` to call throws
    // an exception of type std::bad_function_call (see Section 4.3.1, page 43):
    // 
    // std::function<void(int,int)> f; 
    //
    // f(33,66);
    //
    // throws std::bad_function_call

    op(foo);

    EXPECT_THAT(foo.get_value(), 110);
  }

  // the signatuer to std::function specify whether the argument is copy or
  // reference
  {
    // use reference and copy
    {
      Foo foo{100};

      std::function<void(Foo &)> fo1 = &Foo::update_20;
      fo1(foo);
      EXPECT_THAT(fo1.get_value(), 120);

      std::function<void(Foo)> fo2 = &Foo::update_20;
      fo2(foo);
      EXPECT_THAT(fo1.get_value(), 100);
    }

    // use reference
    {
      vector<Foo> coll={Foo(1), Foo(2), Foo(3)};
      vector<size_t> result{};

      std::function<void(Foo &)> op = &Foo::update_20;

      for_each(coll.begin(), coll.end(), op);

      // to get result out and algo-transform requires unary predicate
      transform(coll.begin(), coll.end(), back_inserter(result), 
          print_value);

      EXPECT_THAT(result, ElementsAre(21,22,23));
    }

    // use copy so not updated
    {
      vector<Foo> coll={Foo(1), Foo(2), Foo(3)};
      vector<size_t> result{};

      std::function<void(Foo)> op = &Foo::update_20;

      for_each(coll.begin(), coll.end(), op);

      // to get result out and cxx-transform requires unary predicate
      transform(coll.begin(), coll.end(), back_inserter(result), 
          print_value);

      EXPECT_THAT(result, ElementsAre(1,2,3));
    }
  }
}


*cxx-bind*
As with cxx-function, *cxx-bind*

o The first argument is a member function

o can use `target object` or embedded object


TEST(CxxFunctionObject, BindAndFunction)
{
  using namespace cxx_function;

  // when use std::function<>
  {
    Foo foo{100};
    std::function<void(Foo &)> fo = &Foo::update_10;

    fo(foo);

    EXPECT_THAT(foo.get_value(), 110);
  }

  // when use cxx-bind
  {
    Foo foo{100};
    auto fo = std::bind(&Foo::update_10, _1);

    // see that pass `foo` object to op
    fo(foo);

    EXPECT_THAT(foo.get_value(), 110);
  }

  // when use cxx-bind and object
  {
    Foo foo{100};
    auto fo = std::bind(&Foo::update_10, &foo);

    // see that no target object
    fo();

    EXPECT_THAT(foo.get_value(), 110);
  }

  // `specify the target object`
  //
  // that performing a function call without having a target to call throws
  // an exception of type std::bad_function_call (see Section 4.3.1, page 43):
  // 
  // std::function<void(int,int)> f; 
  //
  // f(33,66);
  //
  // throws std::bad_function_call
  //
  // *cxx-this*
  //
  // As with *cxx-this*, same as Foo::update_10(&foo);
  //
  // Member function access the object through an extra, implicit parameter named
  // `this`. The compiler passes the address of `total` to the implicit `this`
  // parameter `as if` rewrites this call as:
  // 
  // total.isbn();
  // 
  // (where Sales_data::isbn(Sales_data *const this);)
  //
  // Sales_data::isbn(&total);

  // cxx-bind use reference
  {
    // shows that bind() internally uses copy of passed arguments. NO. it is
    // becuase when bind() makes function object it binds to copy or reference.
    {
      int value{};

      std::bind(increase, value)();   // same as fo(value) but no effect on value
      std::bind(increase, value)();   // same as fo(value) but no effect on value

      EXPECT_THAT(value, 0);

      // *cxx-ref*
      std::bind(increase, std::ref(value))();   // increased
      std::bind(increase, std::ref(value))();

      EXPECT_THAT(value, 2);
    }

    // it is when function object is called, that function object gets called
    // with reference within cxx-for-each
    {
      vector<Foo> coll={Foo(1), Foo(2), Foo(3)};
      vector<size_t> result{};

      auto fo = std::bind(&Foo::update_10, _1);

      {
        for_each(coll.begin(), coll.end(), fo);

        // to get result out and algo-transform requires unary predicate
        transform(coll.begin(), coll.end(), back_inserter(result), 
            print_value);

        EXPECT_THAT(result, ElementsAre(11,12,13));
      }
    }
  }

  {
    // from cxx-bind to cxx-function
    {
      Foo foo{100};
      auto fbind = std::bind(&Foo::update_10, _1);

      std::function<void(Foo &)> ffunc = fbind;

      ffunc(foo);

      EXPECT_THAT(foo.get_value(), 110);
    }
  }

  // cxx-function use reference
  {
    vector<Foo> coll={Foo(1), Foo(2), Foo(3)};
    vector<size_t> result{};

    // note:
    // void update_10() but why <void(Foo &)>? becuse of *cxx-this* and this
    // `specify` target object

    std::function<void(Foo &)> op = &Foo::update_10;

    {
      for_each(coll.begin(), coll.end(), op);

      // to get result out and algo-transform requires unary predicate
      transform(coll.begin(), coll.end(), back_inserter(result), 
          print_value);

      EXPECT_THAT(result, ElementsAre(11,12,13));
    }
  }
}


<ex>
client calls:

notify(&IBleRcuDeviceEvent::pairingStatusChanged, pairing));

template<typename F, typename... Args>
  void notify(F f, Args&&... args)
  {
    notify(std::bind(f, std::placeholders::_1, std::forward<Args>(args)...));
  }


client calls:

notify(std::bind(&IBleRcuDeviceEvent::pairingStatusChanged, std::placeholders::_1, pairing));

calls template:

template<typename F>
  void notify(F f)
  {
    notify_impl(f);
  }

function object from std::bind binds to function object from std::function. so
function object from std::function calls function object from bind which calls
actual member function with the composited argument. cxx-bind is like
cxx-warpper.

void notify_impl(std::function<void (std::shared_ptr<T> const &)> fun)
{
  std::shared_ptr<T> strong = o.lock();
  dispatcher_->post(std::bind(fun, strong));
}


*cxx-memfn*

o Use `cxx-memfn` to let the compiler deduce the member's type and to generate
  a callable object. The callable generated by `mem_fn` can be called on
  either an object or a pointer.

TEST(CxxCallable, check_memfn)
{
  using namespace cxx_callable;

  // *cxx-error* since no default ctor for std::mem_fn()
  // {
  //   auto op = std::mem_fn();
  // }

  // need target
  {
    Foo foo = Foo(100);
    auto op = std::mem_fn(&Foo::update_10);

    op(foo);

    EXPECT_THAT(foo.get_value(), 110);
  }

  // use args
  {
    Foo foo = Foo(100);
    auto op = std::mem_fn(&Foo::update);

    op(foo, 100);

    EXPECT_THAT(foo.get_value(), 200);
  }

  // cxx-error compile error
  // {
  //   Foo foo = Foo(100);
  //   auto op = std::mem_fn(&Foo::update_10, &foo);
  //   op();
  //   EXPECT_THAT(foo.get_value(), 110);
  // }

  // for_each() pass reference
  //
  // namespace algo_code
  // {
  //   template <typename _InputIterator, typename _Function>
  //   _Function
  //   for_each(_InputIterator __first, _InputIterator __last, _Function __f)
  //   {
  //     // note: call op but not use return
  //     for (; __first != __last; ++__first)
  //       __f(*__first);
  //     return _GLIBCXX_MOVE(__f);
  //   }
  // 
  //   template <typename _InputIterator,
  //             typename _OutputIterator,
  //             typename _UnaryOperation>
  //   _OutputIterator transform(_InputIterator __first,
  //                             _InputIterator __last,
  //                             _OutputIterator __result,
  //                             _UnaryOperation __unary_op)
  //   {
  //     for (; __first != __last; ++__first, ++__result)
  //       // note: write to output to output iterator and unary
  //       *__result = __unary_op(*__first);
  //     return __result;
  //   }
  // } // namespace algo_code
  {
    std::vector<Foo> coll = {Foo(1), Foo(2), Foo(3)};
    std::vector<size_t> result{};

    auto op = std::mem_fn(&Foo::update_10);

    std::for_each(coll.begin(), coll.end(), op);

    // to get result out and algo-transform requires unary predicate
    std::transform(coll.begin(), coll.end(), back_inserter(result), print_value);

    EXPECT_THAT(result, ElementsAre(11, 12, 13));
  }

  // use pointer
  {
    Foo foo = Foo(100);

    // see how to define pointer to member function
    // error
    // void (*op)(void);
    void (Foo::*op)(void);

    // `Unlike ordinary function pointer, no automatic conversion` between a
    // member funtion and a pointer to that function.
    // must explicitly use address-of operator
    // error
    // op = Foo::update_10;
    op = &Foo::update_10;

    // see how to call
    // error: must use ‘.*’ or ‘->*’ to call pointer-to-member
    // function in ‘op (...)’, e.g. ‘(... ->* op) (...)’
    //      op(foo);
    //            ^
    // op(foo);
    //
    // When initialize a pointer to member, that pointer does 'not' yet point to
    // any data. Supply the object when we dereference that pointer. Analogous
    // to the member access operators, . and ->,
    (&foo->*op)();

    EXPECT_THAT(foo.get_value(), 110);
  }

  {
    std::vector<decltype(&Foo::update_10)> coll{
      &Foo::update_10,
        &Foo::update_20,
        &Foo::update_30
    };

    Foo foo = Foo(100);

    // OK
    (&foo->*coll[0])();

    EXPECT_THAT(foo.get_value(), 110);
  }

  {
    auto f = std::mem_fn(&Foo::update_10);

    std::initializer_list<decltype(f)> coll{std::mem_fn(&Foo::update_10),
                                            std::mem_fn(&Foo::update_20),
                                            std::mem_fn(&Foo::update_30)};

    Foo foo = Foo(100);

    auto it = coll.begin();

    (*it)(foo);

    EXPECT_THAT(foo.get_value(), 110);
  }
}


<cxx-bind-with-virtual>
Calling virtual member functions also works. If a method of the base class is
bound and the object is of a derived class, the correct virtual function of the
derived class gets called.


{cxx-bind-with-pointer}
The *cxx-bind* works with pointers.

// template<typename _InputIterator, typename _Function>
//   _Function
//   for_each(_InputIterator __first, _InputIterator __last, _Function __f)
//   {
//     // note: call op but not use return
//
//     for (; __first != __last; ++__first)
//       __f(*__first);
//
//     return _GLIBCXX_MOVE(__f);
//   }

std::vector<Person*> cp;
for_each (cp.begin(), cp.end(), bind(&Person::print, _1));

std::vector<std::shared_ptr<Person>> sp;
for_each (sp.begin(), sp.end(), bind(&Person::print, _1));

<cxx-bind-ex> CLR 4.4

int main()
{
  C c;
  std::shared_ptr<C> sp(new C);

  // bind() uses callable objects to bind arguments:
  std::bind(func, 77,33)();             // calls: func(77,33)
  std::bind(l, 77,33)();                // calls: l(77,33)
  std::bind(C(), 77,33)();              // calls: C::operator()(77,33)
  std::bind(&C::memfunc, c, 77,33)();   // calls: c.memfunc(77,33)
  std::bind(&C::memfunc, sp, 77,33)();  // calls: sp->memfunc(77,33)

  // *cpp-async* async() uses callable objects to start (background) tasks:
  std::async(func, 42,77);              // calls: func(42,77)
  std::async(l, 42,77);                 // calls: l(42,77)
  std::async(c, 42,77);                 // calls: c.operator()(42,77)
  std::async(&C::memfunc, &c, 42,77);   // calls: c.memfunc(42,77)
  std::async(&C::memfunc, sp, 42,77);   // calls: sp->memfunc(42,77)
}


<ex> from boost bind

struct X
{
    bool f(int a);
};

X x;

shared_ptr<X> p(new X);

int i = 5;

bind(&X::f, ref(x), _1)(i);     // x.f(i)
bind(&X::f, &x, _1)(i);         // (&x)->f(i)
bind(&X::f, x, _1)(i);          // (internal copy of x).f(i)
bind(&X::f, p, _1)(i);          // (internal copy of p)->f(i)

The last two examples are interesting in that they produce "self-contained"
function objects. 

bind(&X::f, x, _1) `stores a 'copy of x`  *cpp-this*
bind(&X::f, p, _1) stores a copy of p, and since p is a boost::shared_ptr, the
function object 'retains' a reference to its instance of X and will remain
valid 'even' when p goes out of scope or is reset(). 


<ex> *cpp-fobj-has-state* *cxx-limits*
The idea is that function object keep state, playspeed, in this case and use
that state when is asked to raise an event.

class SpeedChangeSender
{
public:
    SpeedChangeSender(const boost::shared_ptr<MockMediaRouter>& mock)
        : mock(mock),
        playSpeed(std::numeric_limits<double>::quiet_NaN())
    {}

    void sendSpeedChangeEvent(double newPlaySpeed)
    {
        if(newPlaySpeed != playSpeed)
        {
            VANADIUM_TRACE("Sending SpeedChangeEvent old speed: " << playSpeed
                    << " newPlaySpeed " << newPlaySpeed);
            mock->emitSpeedChangeEvent();
            playSpeed = newPlaySpeed;
        }
    }

private:
    boost::shared_ptr<MockMediaRouter> mock;
    double playSpeed;
};


void registerMockForCanPlayAndPauseVideo()
{
    Sequence s;

    // create a mock object
    boost::shared_ptr<MockMediaRouter> mock = makeMock("http://bb.mpd");

    // create a object
    boost::shared_ptr<SpeedChangeSender> speedChangeSender
        = boost::make_shared<SpeedChangeSender>(mock);

    // first play call and will update function object
    // NS_ZINC::Future<void> GstMediaRouter::setPlaySpeed(const double speed);
    // _1 is "1.0"

    EXPECT_CALL(*mock, setPlaySpeed(1.0)).InSequence(s).WillOnce(
                DoAll(Invoke(boost::bind(&SpeedChangeSender::sendSpeedChangeEvent,
                            speedChangeSender, _1)),
                    Return(makeCompletedFuture())));

    EXPECT_CALL(*mock, start()).WillOnce(
            Return(makeCompletedFuture()));

    // pause and will update function object
    EXPECT_CALL(*mock, setPlaySpeed(0.0)).InSequence(s).WillOnce(
                DoAll(Invoke(boost::bind(&SpeedChangeSender::sendSpeedChangeEvent,
                            speedChangeSender, _1)),
                    Return(makeCompletedFuture())));

    // second play call and will update function object
    EXPECT_CALL(*mock, setPlaySpeed(1.0)).InSequence(s).WillOnce(
                DoAll(Invoke(boost::bind(&SpeedChangeSender::sendSpeedChangeEvent,
                            speedChangeSender, _1)),
                    Return(makeCompletedFuture())));
}


<ex> member-function see *cpp-member-function-address*

void SystemClientEventRepository::eventsReceived(
  boost::shared_ptr<X> command, const NS_ZINC::FutureValue<Y>& eventsFV)
{}


// defines a function pointer to a member function and set it

void (SystemClientEventRepository::*masCallback)
   (boost::shared_ptr<X>, const NS_ZINC::FutureValue<Y> &) = 
   &SystemClientEventRepository::eventsReceived;


bar.addWithCallback(fMASEvents, boost::bind(masCallback, `this`, sharedCmd, _1));


<ex>
{
    const std::vector<std::string> v{"We", "are", " the champions!"};

    const std::size_t count0 = std::count_if(v.cbegin(), v.cend(),
            [](const std::string &s) { return s.empty(); });

    // string's empty member function
    const std::size_t count1 = std::count_if(v.cbegin(), v.cend(),
            boost::bind(&std::string::empty, _1));

    cout << "count0: " << count0 << ", count1: " << count1 << endl;
}


<ex> *cxx-bind-this*
not use passed parameter but instead use *cxx-this* pointer.

VirtualBinSrc::VirtualBinSrc()
{
  // note: here bind() do some magic

  elementFactory["application/dash+xml"] =
    boost::bind(&VirtualBinSrc::makeAndSetupDecodebin, `this`,
        "video/quicktime; audio/x-m4a; text/x-raw");
}

typedef std::map<std::string,
    boost::function<RefObj<GstElement>()> > FactoryContainer;

RefObj<GstElement> 
    VirtualBinSrc::makeAndSetupDecodebin(const char* const outputCaps);

Use:

FactoryContainer elementFactory;

FactoryContainer::iterator it = elementFactory.find(mediaType);

RefObj<GstElement> upstream = it->second();

The "it->second" is callable and "it->second()" calls with no argument with
returns RefObj<GstElement>.

RefObj<GstElement> 
    VirtualBinSrc::makeAndSetupDecodebin
        ("video/quicktime; audio/x-m4a; text/x-raw");


<ex>
// uses

NS_ZINC::Future< int32_t > ProxyMediaRouter::getMediaDuration() const {

    scoped_lock lock(mutex);

    return deferForwardOrDefault(
            boost::bind(&MediaRouter::getMediaDuration, _1),
            properties.mediaDuration.get_value_or(0));
}

NS_ZINC::Future< Position > ProxyMediaRouter::getPosition() const {
    return deferForwardOrDefault(
            boost::bind(&MediaRouter::getPosition, _1), 
            Position());
}


// deferred

template <typename T>
struct future_type;

template <typename T>
struct future_type<NS_ZINC::Future<T> > {
    typedef T type;
};

template<typename Functor>
struct returned_future_type {
    typedef typename future_type<typename Functor::result_type>::type type;
};

// 

struct AbstractDeferredCall {
    virtual ~AbstractDeferredCall() {}

    virtual void operator()(const MediaRouter* mediaRouter) = 0;
};

template<typename Functor, typename T>
class DeferredCall : public AbstractDeferredCall {

    public:

        DeferredCall(boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher, Functor method_) :
            promise(*dispatcher),
            method(method_) {
            }

        NS_ZINC::Future<T> getFuture() {
            return promise.getFuture();
        }

        void operator()(const MediaRouter* mediaRouter) {
            method(const_cast<MediaRouter*>(mediaRouter))
                .then(boost::bind(&chainedComplete<T>, promise, _1));
        }

    private:

        NS_ZINC::Promise<T> promise;
        Functor method;
};


class ZINC_LOCAL ProxyMediaRouter : public MediaRouter
{
    mutable boost::ptr_deque<AbstractDeferredCall> deferredCalls;
};


template<typename Functor>
typename Functor::result_type ProxyMediaRouter::deferCall(Functor f) const {

    typedef typename returned_future_type<Functor>::type T;

    std::auto_ptr<DeferredCall<Functor, T> > deferred
        (new DeferredCall<Functor, T>(dispatcher, f));

    NS_ZINC::Future<T> future(deferred->getFuture());
    deferredCalls.push_back(deferred);
    return future;
}


// mmeber-template

template<typename Functor> typename Functor::result_type 
    ProxyMediaRouter::deferForwardOrDefault(Functor f,
    const typename returned_future_type<Functor>::type& defaultValue) const
{
    typedef typename returned_future_type<Functor>::type T;

    scoped_lock lock(mutex);

    // flag if sourcing is completed or not and ture when it's not completed.
    if (sourcing) {
        // the sourcing is ongoing and defer a call.
        return deferCall(f);
    }

    // return default
    //
    // lastSource is a string and is set when sourcing is completed. isSourced
    // return 
    //  true when the string is not empty.
    //  false when the string is empty
    if (!isSourced())
    {
        // 
        return NS_ZINC::completedFuture<T>(*dispatcher, defaultValue);
    }

    // forward to impl
    return f(impl.get());
}


// This is called by SetSourceContinuation::complete(). The idea is to contain
// all the state manipulation in one place.
//
// That is when continuation which has many calles in chain completes and defer
// any calls to be handled when complete() is called an this when the object is
// in right state.

void ProxyMediaRouter::setSourceComplete
{
    scoped_lock lock(mutex);

    ...

    // Some calls may have been deferred whilst we were setting the source.
    // process those now, but stop if one of them is a call to setSource().
    // FIXME Does not check for setSource() - should it?

    while (!deferredCalls.empty() && !sourcing) {
        deferredCalls.front()(this);
        deferredCalls.pop_front();
    }
}


={============================================================================
*kt_dev_cxx_0000* cxx-algo

Algorithms are not member functions of the container classes and do not work
directly on a container. All in all, this concept reduces the amount of code
and increases the power and the flexibility of the library. 

Operates in terms of iterators and container independent but element type
dependent; means that do not use container's operations (don't add/remove
    items but write/move items) but use operations on element such as '==',
'<', or '+'. 

This is not an object-oriented programming paradigm; it is a generic
functional programming paradigm. However, this concept also has its price: 

First, the usage is not intuitive. 

Second, some combinations of data structures and algorithms might not work.
Even worse, a combination of a container type and an algorithm might be
possible but not useful (for example, it may lead to bad performance).

Thus, it is important to learn the 'concepts' and the 'pitfalls' of the STL to
benefit from it without abusing it.

<ex> algo-max-element algo-min-element algo-find algo-sort 

TEST(AlgoFind, Find)
{
  vector<int> coll{2, 5, 4, 1, 6, 3};

  // *algo-min-element*
  // if there are duplicates, return the first
  auto minpos = min_element(coll.begin(), coll.end());
  EXPECT_THAT(*minpos, 1);

  auto maxpos = max_element(coll.begin(), coll.end());
  EXPECT_THAT(*maxpos, 6);

  // *algo-sort*
  sort(coll.begin(), coll.end());

  auto found = find(coll.begin(), coll.end(), 3);

  // *algo-reverse*
  // reverse the range
  reverse(found, coll.end());
  EXPECT_THAT(coll, ElementsAre(1, 2, 6, 5, 4, 3));
}


{algorithm-category}
There is architecture or the unifying principles that categorise 100+
algorithms: according to what do on container or required arguments. Be
careful since algorithms have assumtions and use right iter for a algo
according to iter category since compilers will 'not' complain.

According to parameter patterns:

alg( beg, end, other args );

// assumes dest is big enough as with range one to 'overwrite'
alg( beg, end, dest, other args );     

// assumes beg2 is big enough as with range one
alg( beg, end, beg2, other args );     

alg( beg, end, beg2, end2, other args );


<ex> algo-accumulate
The third argument determines which addition operator is used and the type of
return. Seems clever.

int sum = accumulate( vec.cbegin(), vec.cend(), 0 );
string sum = accumulate( vec.cbegin(), vec.cend(), string(""));


{cxx-algo-assumption-on-ranges}

<single-range>

To be able to handle subsets of container elements, you pass the beginning and
the end of the range as two separate arguments rather than the whole
collection. This interface is flexible but dangerous.

The caller must ensure that the first and second arguments define a valid
range. Otherwise, the behavior is *cxx-undefined* and endless loops or
forbidden memory access may result. This means that it is up to the programmer
to ensure that.

Two things about `valid range` when [beg, end) use with algorithm:

o `The beg must come 'first' in order.` Othewise, it is not valid range and
  undefined.

o The range shall exist.

// algo-fill fill_n( dest, size, value ) and assumes that vec is 10 size at
// least. so if there is no 10 elements before calling fill_n then undefined.

vector<int> vec;
fill_n( vec.begin(), 10, 0 );

<multiple-range>

Assumption on the second range is it as big as the first since the number of
elements of the second is `deduced from the first range.` If not, undefined.
For example, copy algorithm 'overwrite' rather then 'insert'.

This is for only sequence containers with algorithms because associative and
unordered containers cannot be used as a destination for overwriting
algorithms.

*cxx-coll-associative*
The reason is simple: If they would work for associative or unordered
containers, modifying algorithms could change the value or position of
elements, thereby violating the order maintained by the container (sorted for
    associative containers or according to the hash function for unordered
    containers). In order to avoid compromising the internal order, every
iterator for an associative and unordered container is declared as an iterator
for a constant value or key. Thus, manipulating elements of or in associative
and unordered containers results in a failure at compile time.

// reads, assumes two >= one
equal( one.cbegin(), one.cend(), two.cbegin() );

// write, 'destination', coll2 must have enough room to copy
copy(coll1.cbegin(), coll1.cend(), coll2.begin());


{copy-version} algo-replace *algo-reverse*
Independent-between-sequences/containers. The element types need not be the
exactly same as long as can use element operators or compatible between them.
This is also an example of copying version in algorithm.

replace( ilst.begin(), ilst.end(), 0, 42 );
// replace any element with 0 with 42

replace_copy( ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42 );
// to leave the original sequence unchanged. in this case, copy list to vector.

// copy version
reverse( beg, end );
reverse_copy( beg, end, dest );


{if-version} algo-find
Algorithm that takes an element value typically have a second named version
that takes a predicate in place of the value. Compared to overloaded version.

// if version
// If there is a match, returns an iterator to the first element and if not,
// return end iterator.

find( beg, end, val );
find_if( beg, end, pred );

// overloaded version
unique( beg, end );
uniqie( beg, end, comp );


={============================================================================
*kt_dev_cxx_0000* cxx-algo-non-modifying

RCLR 11.5 Nonmodifying Algorithms

The algorithms presented in this section enable you to access elements without
modifying their values or changing their order.

Predicate op should not modify the passed arguments.


<algo-equal> determines whether two sequences are equal
bool equal (InputIterator1 beg, InputIterator1 end, InputIterator2 cmpBeg)
bool equal (InputIterator1 beg, InputIterator1 end, InputIterator2 cmpBeg, BinaryPredicate op)

The caller must ensure that the range starting with cmpBeg contains enough
elements. 

Complexity: 
linear (at most, numElems comparisons or calls of op(), respectively).

// cxx-algo-equal

// coll1 (vector): 1 2 3 4 5 6 7 (7)
// coll2 (list)  : 3 4 5 6 7 8 9 (7)
// coll3 (list)  : 1 2 3 4 5 6 7 (7)

TEST(CxxStlTest, UseAlgoEqual)
{
    vector<int> coll1;
    list<int> coll2;
    list<int> coll3;

    INSERT_ELEMENTS(coll1, 1, 7);
    INSERT_ELEMENTS(coll2, 3, 9);
    INSERT_ELEMENTS(coll3, 1, 7);

    PRINT_ELEMENTS(coll1, "coll1 (vector): ");
    PRINT_ELEMENTS(coll2, "coll2 (list)  : ");
    PRINT_ELEMENTS(coll3, "coll3 (list)  : ");

    EXPECT_FALSE( equal( coll1.begin(), coll1.end(),
                coll2.begin()));

    EXPECT_TRUE( equal( coll1.begin(), coll1.end(),
                coll3.begin()));

    // coll1 and coll2 are different but are the same as to the order of
    // even/odd.
    EXPECT_TRUE( equal( coll1.begin(), coll1.end(),
                coll2.begin(), [](int lhs, int rhs)
                {
                    return lhs % 2 == rhs % 2; 
                }
                ));
}


<algo-is-permutation> testing for unordered equality
bool is_permutation (ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2)
bool is_permutation (ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2, CompFunc op)

1. These algorithms are available since C++11.

2. The first form compares the elements by using operator ==.

3. The second form compares the elements by using the binary predicate
   op(elem1,elem2) which should return true when elem1 is equal to elem2.

4. Complexity: at worst quadratic (numElems1 comparisons or calls of op(), if
   all elements are equal and have the same order).

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>

using namespace std;

// note: no half-open range
template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}
bool bothEvenOrOdd( int elem1, int elem2 )
{
  return elem1 %2 == elem2 %2;
}

int main()
{
  vector<int> coll1 = { 1, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  list<int> coll2 = { 1, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
  deque<int> coll3 = { 11, 12, 13, 19, 18, 17, 16, 15, 14, 11 };

  PRINT_ELEMENTS( coll1, "coll1(vector): " );
  PRINT_ELEMENTS( coll2, "coll2(list)  : " );
  PRINT_ELEMENTS( coll3, "coll3(deque) : " );

  cout << endl;

  if( is_permutation( coll1.cbegin(), coll1.cend(), // first range
        coll2.cbegin()))                            // second range
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  if( equal( coll1.cbegin(), coll1.cend(),  // first range
        coll2.cbegin()))
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  // check for corresponding even and odd elements
  if( is_permutation( coll1.cbegin(), coll1.cend(),  
        coll3.cbegin(),
        bothEvenOrOdd ))                // comparison criterion
  {
    cout << "coll1 and coll3, even and odd elements correspond" << endl;
  }
  else
    cout << "coll1 and coll3, even and odd elements do not correspond" << endl;
}

coll1(vector): 1 1 2 3 4 5 6 7 8 9 
coll2(list)  : 1 9 8 7 6 5 4 3 2 1 
coll3(deque) : 11 12 13 19 18 17 16 15 14 11 

coll1 == coll2

coll1 != coll2

coll1 and coll3, even and odd elements correspond


<algo-count-if> count elements
difference_type count (InputIterator beg, InputIterator end, const T& value)
difference_type count_if (InputIterator beg, InputIterator end, UnaryPredicate op)

1. The first form counts the elements in the range [beg,end) that are equal to
value value.  

2. Complexity: linear (numElems comparisons or calls of op(), respectively).  

3. Associative and unordered containers provide a similar member function,
count(), to count the number of elements that have a certain value as key

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}

int main()
{
  vector<int> coll;
  int num;

  INSERT_ELEMENTS( coll, 1, 9 );
  PRINT_ELEMENTS( coll, "coll: " );

  // count elements with value 4
  num = count( coll.cbegin(), coll.cend(), 4 );
  cout << "number of elements equal to 4:      " << num << endl;

  // count elements with even value
  num = count_if( coll.cbegin(), coll.cend(), 
              [] (int elem) {
                return elem%2==0;
                });
  cout << "number of elememts with even value: " << num << endl;

  // count elements that are greater than 4
  num = count_if( coll.cbegin(), coll.cend(), 
              [] (int elem) {
                return elem > 4;
                });
  cout << "number of elememts than 4         : " << num << endl;

  return 0;
}

coll: 1 2 3 4 5 6 7 8 9 
number of elements equal to 4:      1
number of elememts with even value: 4
number of elememts than 4         : 5


<ex>
template<typename C, typename P>
int count (const C& c, P pred)
{
  int cnt = 0;

  for (const auto &x : c)
    if (pred(x))
      ++cnt;

  return cnt;
}


={============================================================================
*kt_dev_cxx_0000* cxx-algo-modifying

CLR 11.6
  
This section describes algorithms that modify the elements of a range. There
are two ways to modify elements:

1. Modify them directly while iterating through a sequence.
2. Modify them while copying them from a source range to a destination range.

*cxx-remember*
  Can't use an associative or unordered container as a destination range,
  because the elements in these containers are constant. 

  If you could, it would be possible to compromise the automatic sorting or
  the hash based position, respectively.

All algorithms that have a separate destination range return the position after
the last copied element of that (destination) range.


<algo-transform>

o Can use the same coll for input and output

11.6.3 Transforming and Combining Elements

The first form has four arguments. It transforms elements from a source to a
destination range. Thus, this form copies and modifies elements in one step.

The second form has five arguments. It combines elements from two source
sequences and writes the results to a destination range.

// from bits/stl_algo.h

namespace std {

  /**
   *  @brief Perform an operation on a sequence.
   *  @ingroup 'mutating'_algorithms
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A 'unary' operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  */
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>

    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result, _UnaryOperation __unary_op)
    {
      for (; __first != __last; ++__first, ++__result)
         // note: write to output and unary
         `*__result = __unary_op(*__first);`
      return __result;
    }

  /**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A 'binary' operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */
  template<typename _InputIterator1, typename _InputIterator2, 
      typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _OutputIterator __result,
         _BinaryOperation __binary_op)
    {
      // ...
      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
         *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
}


<algo-generate>

11.6.5 Assigning New Values

Assigning Generated Values

void generate (ForwardIterator beg, ForwardIterator end, Func op)
void generate_n (OutputIterator beg, Size num, Func op)

o generate() assigns the values that are generated by a call of
  op() to each element in the range [beg,end).

o generate_n() assigns the values that are generated by a call of
  op() to the first num elements in the range starting with beg. If num is
  negative, generate_n() does nothing (specified only since C++11).

o The caller must ensure that the destination range is big enough or that
  insert iterators are used.

namespace algo_code
{
  /**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __n      The length of the sequence.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   The end of the sequence, @p __first+__n
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__first+__n).
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
   */
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
      // concept requirements
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
          // "the type returned by a _Generator"
          __typeof__(__gen())>)

        for (__decltype(__n + 0) __niter = __n;
            __niter > 0; --__niter, ++__first)
          *__first = __gen();
      return __first;
    }
}

this means that _Generator shall return value and otherwise get errors:

stl.cpp:2464:7:   required from here
/usr/include/c++/4.9/bits/stl_algo.h:4325:11: error: no match for ‘operator=’ (operand types are ‘std::back_insert_iterator<std::__debug::list<int> >’ and ‘void’)
  *__first = __gen();


<ex>
// 1804289383 846930886 1681692777 1714636915 1957747793 424238335 719885386 1649760492 596516649 1189641421 1025202362 1350490027 (12)
// 2 19 11 22 12 18 4 16 11 8 15 21 (12)

class CardSequence
{
    public:

        // note: error
        // int operator() {

        int operator() () {
            return rand() % 24;
        }
};

TEST(CxxStlTest, UseAlgoGenerate)
{
    vector<uint32_t> ivec1;
    generate_n( back_inserter(ivec1), 12, rand );
    PRINT_ELEMENTS(ivec1);

    vector<uint32_t> ivec2;
    generate_n( back_inserter(ivec2), 12, CardSequence() );
    PRINT_ELEMENTS(ivec2);
}


<algo-copy>

NOTE: TODO: WHY modifying one?

11.6.1 Copying Elements

OutputIterator
copy (InputIterator sourceBeg, InputIterator sourceEnd,
      OutputIterator destBeg)

* The caller must ensure that the destination range is big enough or that
  insert iterators are used.

<ex> *algo-copy*

TEST(AlgoCopy, Error)
{
  {
    std::vector<int> coll;

    for (int i = 0; i <= 6; ++i)
      coll.push_back(i);

    auto first = std::find(coll.begin(), coll.end(), 300);
    auto last = std::find(coll.begin(), coll.end(), 3);

    std::copy(first, last, std::ostream_iterator<int>(cout, ", "));
  }
}

The copy() statement is illegal because [first, last) not a vaild range; indeed
first may actually be after last.

*cxx-seg-fault*
The first is coll.end() and the last is dereferencible iterator. The copy
requires that first 'must' be a valid range. The likely symptom will be a
difficult-to-diagnose core dump during or sometime after the copy.

The real result is that it works fine with release and emits errors with debug
build:

$ ./a.out 
1 2 3 4 5 6 
-----------
/usr/include/c++/4.7/bits/stl_algobase.h:450:error: function requires a 
    valid iterator range [__first, __last).

Objects involved in the operation:
iterator "__first" @ 0x0xbfd49b18 {
type = N11__gnu_debug14_Safe_iteratorIN9__gnu_cxx17__normal_iteratorIPiNSt9
       __cxx19986vectorIiSaIiEEEEENSt7__debug6vectorIiS6_EEEE (mutable iterator);
  state = past-the-end;
  references sequence with type `NSt7__debug6vectorIiSaIiEEE' @ 0x0xbfd49b18
}
iterator "__last" @ 0x0xbfd49b04 {
type = N11__gnu_debug14_Safe_iteratorIN9__gnu_cxx17__normal_iteratorIPiNSt9
  __cxx19986vectorIiSaIiEEEEENSt7__debug6vectorIiS6_EEEE (mutable iterator);
  state = dereferenceable;
  references sequence with type `NSt7__debug6vectorIiSaIiEEE' @ 0x0xbfd49b04
}
Aborted


NOTE: TODO: HOW to use copy between different types?

* To assign all elements of a container, use the assignment operator if the
  containers have the same type (see Section 8.4, page 406) or the assign()
  member function if the containers have different types (see Section 8.4,
  page 407).

namespace
{
  // /usr/include/c++/4.9/bits/stl_algobase.h
  /**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (first - last)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the copy_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
   */
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)

    // bits/stl_algo.h
    /**
     *  @brief Copy the elements of a sequence for which a predicate is true.
     *  @ingroup mutating_algorithms
     *  @param  __first   An input iterator.
     *  @param  __last    An input iterator.
     *  @param  __result  An output iterator.
     *  @param  __pred    A predicate.
     *  @return   An iterator designating the end of the resulting sequence.
     *
     *  Copies each element in the range @p [__first,__last) for which
     *  @p __pred returns true to the range beginning at @p __result.
     *
     *  copy_if() is stable, so the relative order of elements that are
     *  copied is unchanged.
     */
    template<typename _InputIterator, 
  typename _OutputIterator,
  typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
        if (__pred(*__first))
        {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
} // namespace

<ex>
From EXPC++ 05. Snippet to show the queston: How does algo-copy work when the
type of source and dest is different? That is when T and O different?

template<typename T, size_t size>
class fixed_vector
{
  private:
    T v_[size];

  public:
    fixed_vector() {}

    template<typename O, size_t osize>
      fixed_vector( const fixed_vecto<O, osize>& other )
      {
        copy( other.begin(),
              other.begin()+min(size, osize),
              begin() );
      }
};

Why? As all example of algo-copy uses the same element type, so the assignment
is built-in assignment.

        *to_pos = *from_pos;  // copy values

When tries different types, shows the error:

// when use list<int>
// init: 1 2 3 4 5 6 (6)
// list: 1 2 3 4 5 6 (6)

TEST(CxxStlTest, UseAlgoCopy)
{
  vector<int> coll{1,2,3,4,5,6};

  PRINT_ELEMENTS(coll, "init: " );

  list<int> coll1;
  // list<string> coll1;
  copy( coll.begin(), coll.end(), inserter(coll1, coll1.begin()));

  PRINT_ELEMENTS(coll1, "list: " );
}

.cpp:28:65:   required from here
/usr/include/c++/4.7/bits/stl_algobase.h:329:8: error: invalid user-defined
conversion from ‘int’ to ‘std::list<std::basic_string<char> >::value_type&&
{aka std::basic_string<char>&&}’ [-fpermissive]


<algo-fill>

TEST(StlAlgoFill, Fill)
{
  vector<int> coll;
  fill_n(back_inserter(coll), 8, 7);
  EXPECT_THAT(coll, ElementsAre(7,7,7,7,7,7,7,7));  

  fill(coll.begin(), coll.end(), 1);
  EXPECT_THAT(coll, ElementsAre(1,1,1,1,1,1,1,1));  

  vector<int> coll1(8,0);
  fill_n(coll1.begin(), 8, 7);
  EXPECT_THAT(coll1, ElementsAre(7,7,7,7,7,7,7,7));  
}


={============================================================================
*kt_dev_cxx_0000* cxx-algo-mutating

Mutating algorithms `change the order of elements but not their values.`

As with algo-modifying, because elements of associative and unordered
containers have an order defined by the container, you can’t use these
algorithms as a destination for mutating algorithms.

<algo-partition>

11.8.5 Moving Elements to the Front

ForwardIterator
partition (ForwardIterator beg, ForwardIterator end,
  UnaryPredicate op)

o Both algorithms move all elements in the range [beg,end) `to the front`, for
  which the unary predicate op(elem) yields true.

o Both algorithms return the first position for which op() yields false.

o stable_partition(), unlike partition(), preserves the relative order of the
  even and the odd elements.


// |matched group | unmatched group | not checked |
//                  ^return

TEST(AlgoMutating, AlgoPartition)
{
  vector<int> coll1;
  vector<int> coll2;

  INSERT_ELEMENTS(coll1, 1, 9);
  EXPECT_THAT(coll1, ElementsAre(1, 2, 3, 4, 5, 6, 7, 8, 9));

  auto pos1 = partition(coll1.begin(), coll1.end(),    // range
      [](int elem)
      {
      return elem %2 == 0;
      });

  EXPECT_THAT(coll1, ElementsAre(8, 2, 6, 4, 5, 3, 7, 1, 9));

  // algo-partition returns an iterator to the first element where the
  // predicate is not true, or the end of the range if all elements satisfy
  // the predicate. so first odd element:

  EXPECT_EQ(*pos1, 5);

  INSERT_ELEMENTS(coll2, 1, 9);
  EXPECT_THAT(coll2, ElementsAre(1, 2, 3, 4, 5, 6, 7, 8, 9));

  auto pos2 = stable_partition(coll2.begin(), coll2.end(),
      [](int elem)
      {
      return elem %2 == 0;
      });
  EXPECT_THAT(coll2, ElementsAre(2, 4, 6, 8, 1, 3, 5, 7, 9));

  // first odd element:
  EXPECT_EQ(*pos2, 1);
}


// https://github.com/fenbf/review/blob/master/stl/beautiful_std_alg.cpp
// algp-gather (cpp seasoning)
//
// use case: list of items, select some of items (good guys) and move the to
// position around p.  for instance: multiple selection on a list
//
// problem with std::not1:
// http://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning#c635149692925101916

template <typename Iterator, typename Compare>
auto gather(Iterator _first, Iterator _last, Iterator _pos, Compare _comp) -> std::pair<Iterator, Iterator>
{
  using value_type = typename std::iterator_traits<Iterator>::value_type;
  auto _begin = partition(_first, _pos, [&](const value_type e) { return !_comp(e); });
  auto _end = partition(_pos, _last, _comp);
  return {_begin, _end};
}


TEST(AlgoMutating, Gather)
{
  {
    vector<int> coll(10, 0);
    coll[0] = coll[2] = coll[7] = coll[8] = 1;
    EXPECT_THAT(coll, ElementsAre(1, 0, 1, 0, 0, 0, 0, 1, 1, 0));

    // gather(begin, end, pos, comp);
    std::partition(coll.begin(), coll.begin()+4, 
        [](const int x){ return x != 1; });
    std::partition(coll.begin()+4, coll.begin()+10, 
        [](const int x){ return x == 1; });

    EXPECT_THAT(coll, ElementsAre(0, 0, 1, 1, 1, 1, 0, 0, 0, 0));
  }

  {
    vector<int> coll(10, 0);
    coll[0] = coll[2] = coll[7] = coll[8] = 1;
    EXPECT_THAT(coll, ElementsAre(1, 0, 1, 0, 0, 0, 0, 1, 1, 0));

    // rearrange coll to centre around `pos`
    // pos = 4
    // (1, 0, 1, 0, 0, 0, 0, 1, 1, 0));
    //              ^
    // (            ]
    //              (               ]
    // (0, 0, 1, 1, 1, 1, 0, 0, 0, 0));

    gather(coll.begin(), coll.end(), coll.begin()+4, 
        [](const int x){ return x == 1; });

    EXPECT_THAT(coll, ElementsAre(0, 0, 1, 1, 1, 1, 0, 0, 0, 0));
  }
}


<algo-remove>
As with modifying algorithms, you can’t use an associative or unordered
container as a destination, because the elements of these containers are
considered to be constant.

The following algorithms remove elements from a range according to their value
or to a criterion.  These algorithms, however, cannot change the number of
elements. The algorithms move logically only by overwriting “removed” elements
with the following elements that were not removed. They return the new logical
end of the range (the position after the last element not removed). 

ForwardIterator
remove (ForwardIterator beg, ForwardIterator end, const T& value)


TEST(AlgoMutating, AlgoRemove)
{
  // coll.erase() delete elements but algo-remove do not.
  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    for (auto it = coll.begin(); it != coll.end(); ++it)
    {
      if (*it == 2)
        it = coll.erase(it);
    }

    EXPECT_THAT(coll, ElementsAre(1,3,4,5,6,7,8,9));
  }

  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    auto end = remove(coll.begin(), coll.end(), 2);

    EXPECT_THAT(distance(end, coll.end()), 4);
    EXPECT_THAT(coll, 
        ElementsAreArray({1,3,4,5,6,7,8,9,2,2,2,2}));

    coll.erase(end, coll.end());
    EXPECT_THAT(coll, ElementsAre(1,3,4,5,6,7,8,9));
  }

  // show that algo-remove() do not remove elements
  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    remove(coll.begin(), coll.end(), 2);

    // std::vector<int> coll{1,3,4,5,6,7,8,9,2,8,2,9};
    //                                       ^^^^^^^ 

    EXPECT_THAT(coll, ElementsAreArray({1,3,4,5,6,7,8,9,2,8,2,9}));
  }

  {
    std::vector<int> coll{1,2,3,4,5,6,2,7,2,8,2,9};

    auto it = remove_if(coll.begin(), coll.end(), 
        [](int value)
        { return value == 10; }
        );

    EXPECT_THAT(it, coll.end());
  }
}


<algo-permutation>

// 588 Chapter 11: STL Algorithms

// bool
// next_permutation (BidirectionalIterator beg, BidirectionalIterator end)
// 
// next_permutation() changes the order of the elements in [beg,end) according
// to the next permutation.
// 
// Both algorithms return false if the elements got the “normal”
// (lexicographical) order: that is, ascending order for next_permutation() and
// descending order for prev_permutation(). So, to run through all
// permutations, you have to sort all elements (ascending or descending), and
// start a loop that calls next_permutation() or prev_permutation() as long as
// these algorithms return true.
//
// that means return false when coll is sorted.

// start:1 2 3 (3)
// next :1 3 2 (3)
// next :2 1 3 (3)
// next :2 3 1 (3)
// next :3 1 2 (3)
// next :3 2 1 (3)
// finis:1 2 3 (3)
// now  :3 2 1 (3)
// prev :3 1 2 (3)
// prev :2 3 1 (3)
// prev :2 1 3 (3)
// prev :1 3 2 (3)
// prev :1 2 3 (3)
// finis:3 2 1 (3)

TEST(AlgoMutating, AlgoPermutation)
{
  vector<int> coll{1,2,3};

  PRINT_ELEMENTS(coll, "start:");

  // permute coll until they are sorted, ascending
  while(next_permutation(coll.begin(), coll.end()))
  {
    PRINT_ELEMENTS(coll, "next :");
  }

  // return false when sorted
  PRINT_ELEMENTS(coll, "finis:");

  // until descending sorted and the loop ends immediately
  while(prev_permutation(coll.begin(), coll.end()))
  {
    PRINT_ELEMENTS(coll, "prev :");
  }
  PRINT_ELEMENTS(coll, "now  :");

  while(prev_permutation(coll.begin(), coll.end()))
  {
    PRINT_ELEMENTS(coll, "prev :");
  }
  PRINT_ELEMENTS(coll, "finis:");
}


<algo-rotate> algo-slide algo-reverse

11.8.2 Rotating Elements

Rotating Elements inside a Sequence

ForwardIterator
rotate (ForwardIterator beg, ForwardIterator newBeg, ForwardIterator end)

o Rotates elements in the range [beg,end) so that *newBeg is the new first
  element after the call.

o Since C++11, returns beg+(end-newbeg), which is the new position of the
  first element. Before C++11, the return type was void.

TEST(AlgoMutating, AlgoRotate)
{
  vector<int> coll{1,2,3,4,5,6,7,8};

  // rotate one to the left
  // before *cxx-11* void rotate() so comment out 
  // auto pos = rotate(

  rotate(
    coll.begin(),     // begin  
    coll.begin()+1,   // new begin
    coll.end()        // end
  );
  EXPECT_THAT(coll, ElementsAre(2,3,4,5,6,7,8,1));

  // return the new position of the (pervious) first element.
  // EXPECT_THAT(*pos, 1);

  // pos = rotate(

  rotate(
    coll.begin(),
    coll.end()-2,
    coll.end()
  );
  EXPECT_THAT(coll, ElementsAre(8,1,2,3,4,5,6,7));
  // EXPECT_THAT(*pos, 2);

  // rotate so that 4 is the beginning
  // pos = rotate(

  rotate(
    coll.begin(),
    find(coll.begin(), coll.end(), 4),
    coll.end()
  );
  EXPECT_THAT(coll, ElementsAre(4,5,6,7,8,1,2,3));
  // EXPECT_THAT(*pos, 8);
}


// do not use additional space
// like to slide down sub group

template <typename _Iterator>
void my_rotate(_Iterator __begin, _Iterator __new_end, _Iterator __end)
{
  if ((__begin == __new_end) || (__end == __new_end))
    return;

  auto num_slide = std::distance(__new_end, __end);

  for (;__new_end != __begin; --__new_end)
  {
    _Iterator start = __new_end;

    for (int i = 0; i < num_slide; ++i)
    {
      swap(*start, *(start-1));
      ++start;
    }
  }
}

// /usr/include/c++/4.9.2/bits/stl_algo.h
//
// /// This is a helper function for the rotate algorithm.
// template<typename _ForwardIterator>
//   _ForwardIterator
//   __rotate(_ForwardIterator __first,
//      _ForwardIterator __middle,
//      _ForwardIterator __last,
//      forward_iterator_tag)
// {}

TEST(AlgoMutating, AlgoRotateOwn)
{
  vector<int> coll{1,2,3,4,5,6,7,8};

  // rotate one to the left
  my_rotate(
    coll.begin(),     // begin  
    coll.begin()+1,   // new begin
    coll.end()        // end
  );
  EXPECT_THAT(coll, ElementsAre(2,3,4,5,6,7,8,1));

  my_rotate(
    coll.begin(),
    coll.end()-2,
    coll.end()
  );
  EXPECT_THAT(coll, ElementsAre(8,1,2,3,4,5,6,7));

  my_rotate(
    coll.begin(),
    find(coll.begin(), coll.end(), 4),
    coll.end()
  );
  EXPECT_THAT(coll, ElementsAre(4,5,6,7,8,1,2,3));
}

// void
// reverse (BidirectionalIterator beg, BidirectionalIterator end)

// algo-rotate that use algo-reverse()

template <typename _Iterator>
void reverse_rotate(_Iterator begin, _Iterator new_begin, _Iterator end)
{
  std::reverse(begin, new_begin);
  std::reverse(new_begin, end);
  std::reverse(begin, end);
}

TEST(AlgoMutating, AlgoReverse)
{
  {
    vector<int> coll{1,2,3,4,5,6,7,8};

    std::reverse(coll.begin(), coll.end());
    EXPECT_THAT(coll, ElementsAre(8,7,6,5,4,3,2,1));

    std::reverse(coll.begin()+1, coll.end()-1);
    EXPECT_THAT(coll, ElementsAre(8,2,3,4,5,6,7,1));

    vector<int> result;
    std::reverse_copy(coll.begin(), coll.end(), 
        back_inserter(result));
    EXPECT_THAT(result, ElementsAre(1,7,6,5,4,3,2,8));
  }

  {
    vector<int> coll{1,2,3,4,5,6,7,8};

    // rotate one to the left
    reverse_rotate(
        coll.begin(),     // begin  
        coll.begin()+1,   // new begin
        coll.end()        // end
        );
    EXPECT_THAT(coll, ElementsAre(2,3,4,5,6,7,8,1));

    reverse_rotate(
        coll.begin(),
        coll.end()-2,
        coll.end()
        );
    EXPECT_THAT(coll, ElementsAre(8,1,2,3,4,5,6,7));

    reverse_rotate(
        coll.begin(),
        find(coll.begin(), coll.end(), 4),
        coll.end()
        );
    EXPECT_THAT(coll, ElementsAre(4,5,6,7,8,1,2,3));
  }
}

algo-sort-insertion is similar to *algo-remove* *algo-partition* *algo-rotate*
in that it uses two partitions; one that is sorted or meets condition and the
other that is not.


={============================================================================
*kt_dev_cxx_0000* cpp-stream cpp-cout cpp-cin

C++LR 15.1.2 Stream Classes

Just as there are different kinds of I/O  for example, input, output, and file
access  there are different classes depending on the type of I/O. The
following are the most important stream classes:

o Class istream defines input streams that can be used to read data.
o Class ostream defines output streams that can be used to write data.

Both classes are instantiations of the class templates basic_istream<> or
basic_ostream<>, respectively, using char as the character type.


15.3.2 Input Operator >>

The class basic_istreamand thus also the classes istream and wistream defines
>> as an input operator. Similar to basic_ostream, this operator is overloaded
for `almost all fundamental types`, excluding void and nullptr_t, as well as
  for char* and void*.

To make this possible, `leading whitespace is skipped by default` However,
   this automatic skipping of whitespace can be turned off (see Section
       15.7.7, page 789).

15.7.7 General Formatting Definitions

By default, ios::skipws is set, which means that leading whitespaces are
skipped by operator >>. 

Often, it is useful to have this flag set. For example, with it set, reading
the separating spaces between numbers explicitly is not necessary. However,
this implies that reading space characters using operator >> is not possible
  because leading whitespaces are always skipped.  
  
<ex>
{
    int a, b;
    cout << "={ t_stream_02 = " << endl;

    while (cin >> a >> b) 
    {
        cout << "a: " << a << ", b: " << b << std::endl;
    }

    cout << "=} t_stream_02 = " << endl;
}

$ ./a.out
={ t_stream_02 =
123 456
a: 123, b: 456
123456







                    // press ctrl-d
=} t_stream_02 =


o By default, operator >> skips whitespace (that is, spaces, tabs, newlines,
  etc.). ch==0 indicates end-of-input, ctrl-d.

The `whitespace` is used as a separator.

<ex>
#include <iostream>
#include <string>
#include <map>

using namespace std;

// C++PL, 10.2. A DESK CALCULATOR
//
// usage ex:
//
// (input) r = 2.5
// 2.5
// 
// (input) area = pi * r * r
// (pi is predefined) the calculator program will write
// 19.635
//
// The calculator consists of four main parts: a parser, an input function, a
// symbol table, and a driver. Actually, it is a miniature compiler in which the
// parser does the syntactic analysis, the input function handles input and
// lexical analysis, the symbol table holds permanent information, and the
// driver handles initialization, output, and errors.
//
// Terminal symbols (for example, end(eoi), number, +, and - ) are recognized by
// a lexical analyzer and 
//
// nonterminal symbols are recognized by the syntax analyzer functions, expr(),
// term(), and prim().
//
// As soon as both operands of a (sub)expression are known, the expression is
// evaluated; in a real compiler, code could be generated at this point.


// symbol table
map<string, double> table;

int no_of_errors;

double error(const string &s)
{
    no_of_errors++;

    cerr << "error: " << s << endl;
    return 1;
}

// token and tokenizer
enum class Kind: char
{
    name, number, end,
    plus = '+', minus = '-', mul = '*', div = '/', print = ';',
    assign = '=', lp = '(', rp = ')'
};

struct Token
{
    Kind kind;
    string string_value;
    double number_value;
};

// to determine what kind of lexical token
class Token_stream
{
    public:

        // note
        // Token_stream implements the convention that it owns (and eventually
        // deletes; §3.2.1.2, §11.2) an istream passed as a pointer, but not an
        // istream passed as a reference.
        Token_stream(istream &s): ip{&s}, owns{false} {}
        Token_stream(istream *p): ip{p}, owns{true} {}

        ~Token_stream() { close(); }

        // read and return next token
        Token get();

        // most recently read token
        Token &current() { return ct; }

        void set_input(istream &s) { close(); ip = &s; owns = false; }
        void set_input(istream *p) { close(); ip = p; owns = true; }

    private:
        void close() { if (owns) delete ip; }

        // pointer to an input stream
        istream *ip;

        // does the Token_stream own the istream?
        bool owns;

        // current token
        //
        // note
        // gave ct a default value because it seemed sloppy not to. People
        // should not call current() before get(), but if they do, they get a
        // well-defined Token. I chose Kind::end as the initial value for ct so
        // that a program that misuses current() will not get a value that
        // wasn’t on the input stream.
        //
        // note
        // a complete object
        Token ct{Kind::end};
};


Token Token_stream::get()
{
    char ch = 0;

    // read a char at a time
    *ip >> ch;

#ifdef SOLVE_PROBLEMS
	do {	// skip whitespace except '\n' and return when see null(eoi)
		if(!ip->get(ch)) return ct = {Kind::end};
	} while (ch!='\n' && isspace(ch));
#endif

    switch (ch)
    {
        // handle end of input
        //
        // By default, operator >> skips whitespace (that is, spaces, tabs,
        // newlines, etc.), ch==0 indicates end-of-input.
        case 0:

            // assign and return
            // 
            // note that assigning a complete object {Kind::end} is clearer than
            // dealing with individual members of ct. The {Kind::end} is
            // equivalent to {Kind::end,0,0}.
            cout << "token: eol" << endl;
            return ct = {Kind::end};

        // handle operators
        case ';':   // end of expression; print

#ifdef SOLVE_PROBLEMS
// problem #1
//
// It is tedious to remember to add a semicolon after an expression in order to
// get its value printed
//
        case '\n':
            return ct = {Kind::print};
#endif
        case '*':
        case '/':
        case '+':
        case '-':
        case '(':
        case ')':
        case '=':
            return ct = {static_cast<Kind>(ch)};

        case '0': case '1': case '2': case '3': case '4': case '5': 
        case '6': case '7': case '8': case '9': case '.':
            ip->putback(ch);
            *ip >> ct.number_value;
            ct.kind = Kind::number;
            return ct;

        // If the token is not the end of input, an operator, a punctuation
        // character, or a number, it must be a name.
        default:

#ifndef SOLVE_PROBLEMS
            if (isalpha(ch)) {
                ip->putback(ch);
                *ip >> ct.string_value;
                ct.kind = Kind::name;

                return ct;
            }
#endif

#ifdef SOLVE_PROBLEMS

// problem #2
//
// The problem caused by >> reading into a string until whitespace is
// encountered is solved by reading one character at a time until a character
// that is not a letter or a digit is found:
//
// x=7 is an identifier  rather than the identifier x followed by the operator =
// and the number 7. To get what we (usually) want, we would have to add
// whitespace after x: x =7. 
//
// (input) r=25; 
// r=25
//
// (input) r =25; 
// 25

            if (isalpha(ch)) { ct.string_value = ch;

                while (ip->get(ch))
                {
                    if (isalnum(ch))
                        ct.string_value += ch;
                    else
                    {
                        ip->putback(ch);
                        break;
                    }
                }

                ct.kind = Kind::name;

                return ct;
            }

#endif

            // Finally, we may simply have an error.
            error("bad token");
            return ct = {Kind::print};
    }
}


// user input from cin
Token_stream ts{cin};

double expr (bool get);


// handle primaries
//
// Note that prim() always reads one more Token than it uses to analyze its
// primary expression.


double prim (bool get)
{
    // read next token
    if (get) ts.get();

    switch (ts.current().kind)
    {
        case Kind::number:
            {
                double v = ts.current().number_value;

                // problem #1
                // It is tedious to remember to add a semicolon after an expression in order to
                // get its value printed
                ts.get();

                return v;
            }
        case Kind::name:
            {
                double &v = table[ts.current().string_value];


                // Before doing anything to a name, the calculator must first
                // look ahead to see if it is being assigned to or simply read.
                if (ts.get().kind == Kind::assign) v = expr(true);
                return v;
            }
        case Kind::minus:
            {
                return -prim(true);
            }
        default:
            return error("primary expected");
    }
}

// handle multiplication and division
double term (bool get)
{
    double left = prim (get);

    for (;;)
    {
        switch (ts.current().kind)
        {
            case Kind::mul:
                left *= prim (true);
                break;
            case Kind::div:

                // The variable d is introduced into the program exactly where
                // it is needed and initialized immediately. 
                if (auto d = prim(true))
                {
                    left /= d;
                    break;
                }

                return error("divide by 0");

            default:
                return left;
        }
    }
}


// handles addition and substraction
double expr (bool get)
{
    double left = term (get);

    for (;;) 
    {
        switch (ts.current().kind) 
        {
            case Kind::plus:
                left += term (true);
                break;

            case Kind::minus:
                left -= term (true);
                break;
            default:
                return left;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// The Driver

void calculate()
{
    for (;;)
    {
        ts.get();

        if (ts.current().kind == Kind::end) break;
        if (ts.current().kind == Kind::print) continue;
        cout << expr (false) << '\n';
    }
}

int main()
{
    table["pi"] = 3.1415926535897932385;   // insert predefined names
    table["e"] = 2.7182818284590452354;

    calculate();

    return no_of_errors;
}


={============================================================================
*kt_dev_cxx_0000* cxx-string

CXXSLR-13

The string classes of the C++ standard library enable you to use strings as
normal types that cause no problems for the user. Thus, you can copy, assign,
and compare strings as fundamental types without worrying about whether there
  is enough memory or how long the internal memory is valid.

Note that since C++11, reference counted implementations are not permitted any
longer. The reason is that an implementation that lets strings share internal
buffers doesn't work in multithreaded contexts.

*cxx-invasive* ??
The string classes are an example of the `invasive` approach of writing STL
containers. Strings can be considered containers of characters. The characters
inside the string build a sequence over which you can iterate to process the
individual characters. Thus, the standard string classes provide the container
interface of the STL.


*cxx-string-vs-cxx-vector*
This is no surprise because both are containers that are typically implemented
as dynamic arrays. Thus, you could consider a string as a special kind of a
vector that has characters as elements.

However, considering a string as a special kind of vector is dangerous because
there are many fundamental differences between the two. Chief among these are
their two primary goals:

o The primary goal of vectors is to handle and to manipulate the elements of
  the container, not the container as a whole. Thus, vector implementations are
  optimized to operate on elements inside the container.

o The primary goal of strings is to handle and to manipulate the container,
  the string, as a whole. Thus, strings are optimized to reduce the costs of
  assigning and passing the whole container.

These different goals typically result in completely different implementations.


{sting-size-type-and-npos}
All these find functions return an index of the first matching position. the
return value is an `integer and not an iterator.` The usual interface for
strings is not based on the concept of the STL. However, some iterator support
for strings is provided

*cxx-size-t*
The return type of all find functions is `string::size_type`, which is machine
independent. Although don't know the precise type of it, do know it's
`unsigned` integral type. So careful not to mix signed and unsigned data. For
example, s.size() < n.


{string-element-access} *cxx-string-length*

13.2.6 Element Access see *cxx-string-length*

In general, the position after the last character is valid. Thus, the current
number of characters is a valid index. The operator returns the value that is
generated by the default constructor of the character type. Thus, for objects
of type string it returns the char ’\0’.

Before C++11, for the nonconstant version of operator [], the current number
of characters was an invalid index. Using it did result in undefined behavior.

string s; 
s[s.length()]   // yields ’\0’ (`undefined behavior before C++11`)

Accessing a single character of the string is done with operator[]. All these
operations return a reference to the character

1. An argument specifying the index must have a `valid` value. That value must
be less than the number of characters of the string. As usual, the first
character has index 0, and the last character has index length()-1. 

In addition, the index of the position after the last character could be used
to specify the end.

// OK
string s[s.length()];

// ERROR. the # of characters is `not a valid index.`
string s.at(s.length());   


`The operator[] does not check whether the index of the string is valid.` Thus
a safer way to access a character is to use the at() member since at() throws
an out_of_range exception. 

However, such a check costs runtime, so the check is not provided for the
usual accessing of characters of a string. A good way is to aviod subscripting
altogether by using a range-for whenever possible. However not all compiler
supports. *cxx-range-for*


*cxx-string-npos* *cxx-npos*
If the search fails, a special value is needed to return the failure. The type
and value of npos are a big pitfall for the use of strings. 

`Be very careful that you always use string::size_type, not int or unsigned`, for
the return type when you want to check the return value of a find function.
Otherwise, the comparison with string::npos might not work.

The reason is the result of the design decision that npos is defined as -1:

namespace std {
  // /usr/include/c++/7/bits/basic_string.h
  class basic_string {
    public:
      // *cxx-size-t*
      typedef typename Allocator::size_type size_type;
      ...

    public:
      // Data Members (public):
      // NB: This is an unsigned type, and thus represents the maximum
      // size that the allocator can hold.
      ///  Value returned by various member functions when they fail.
      static const size_type	npos = static_cast<size_type>(-1);
  };
}

However, all functions that search for a character or a position allow
any index. If the index exceeds the number of characters, these functions
simply return `string::npos` ("not found").

2. An argument specifying the number of characters could have 'any' value. If
the size is greater than the remaining number of characters, all remaining
characters are used. string::npos always works as a 'synonym' for "all
remaining characters." or "until the end of the string". 

Why? -1, which because size_t is an unsigned integral type, it is the largest
possible representable value for this type.

Thus, the following expression throws an exception if the period is not found:
note: no exception under gcc 4.6.3.


<cxx-string-front-cxx-string-back>
Since C++11, front() and back() are provided to also access the first or last
character, respectively. When called for an empty string, back() results in
undefined behavior.

namespace *cxx-string-code*
{
  /**
   *  Returns a read/write reference to the data at the last
   *  element of the %string.
   */
  reference
    back()
    { return operator[](this->size() - 1); }

  /**
   *  Returns a read-only (constant) reference to the data at the
   *  last element of the %string.
   */
  const_reference
    back() const _GLIBCXX_NOEXCEPT
    { return operator[](this->size() - 1); }
}

<ex> cxx-string-find cxx-string-substr cxx-string-replace

// CXXSLR 13.1.1 A First Example: Extracting a Temporary Filename
// make the original example short.

TEST(StringSplit, GetExtension)
{
  const string suffix{"tmp"};
  vector<string> coll1{"prog.dat", "mydir", "hello.", "opps.tmp", "end.dat"};
  vector<string> coll2;
  string filename, basename, extname;

  for (auto inputname : coll1)
  {
    auto idx = inputname.find('.');

    // if not have .
    if (idx == string::npos)
    { 
      filename = inputname + '.' + suffix;
    }
    else
    {
      basename = inputname.substr(0, idx);
      extname = inputname.substr(idx+1);
      filename = basename + '.' + suffix;

      // to use cxx-string-replace
      if (extname == suffix)
      {
        filename = inputname;
        filename.replace(idx+1, string::npos, "xxx");
      }
    }

    coll2.push_back(filename);
  }

  EXPECT_THAT(coll2, 
      ElementsAre("prog.tmp", "mydir.tmp", "hello.tmp", "opps.xxx", "end.tmp"));
}


={============================================================================
*kt_dev_cxx_0000* cxx-string-code

namespace cxx-code
{
  // bits/stringfwd.h

  namespace std 
  {
    template <typename charT,
    typename traits = char_traits<charT>,
    typename Allocator = allocator<charT>> 
      class basic_string;

    *cxx-string-def*
    `typedef basic_string<char> string;`
  }
} // namespace

// bits/ allocator.h

  /**
   * @brief  The @a standard allocator, as per [20.4].
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html
   *  for further details.
   *
   *  @tparam  _Tp  Type of allocated object.
   */
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      // *cxx-size-t*
      typedef size_t     size_type;
    };

// bits/basic_string.h

  // 21.3  Template class basic_string
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;

      // Types:
      public:
      typedef _Traits                                 traits_type;
      typedef typename _Traits::char_type             value_type;
      typedef typename _CharT_alloc_type::size_type   size_type;

      // *cxx-string-const*
      // when encoding.back() returns reference:
      //
      // this works:
      // return std::string(1, encoding.back());
      // return std::string{encoding.back()};
      //
      // this emits const error:
      // return std::string(encoding.back());

      // *cxx-string-ctor*

      /** *cxx-cstring*
       *  @brief  Construct string as copy of a C string.
       *  @param  __s  Source C string.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(`const` _CharT* __s, const _Alloc& __a = _Alloc());

      /**
       *  @brief  Construct string as multiple characters.
       *  @param  __n  Number of characters.
       *  @param  __c  Character to use.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());

      /**
       *  @brief  Construct string from an initializer %list.
       *  @param  __l  std::initializer_list of characters.
       *  @param  __a  Allocator to use (default is default allocator).
       */
      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());

      /**
       *  @brief  Compare to a string.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a
       *  __str, 0 if their values are equivalent, or > 0 if this
       *  string is ordered after @a __str.  Determines the effective
       *  length rlen of the strings to compare as the smallest of
       *  size() and str.size().  The function then compares the two
       *  strings by calling traits::compare(data(), str.data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
       */
      int
        compare(const basic_string& __str) const
        {
          const size_type __size = this->size();
          const size_type __osize = __str.size();
          const size_type __len = std::min(__size, __osize);

          // note:
          int __r = traits_type::compare(_M_data(), __str.data(), __len);
          if (!__r)
            __r = _S_compare(__size, __osize);
          return __r;
        }

    public:

      // *cxx-string-copy*
      /**
       *  @brief  Copy contents of @a s into this string.
       *  @param  __s  Source null-terminated string.
       */
      basic_string&
      operator=(const _CharT* __s) 
      { return this->assign(__s); }


      // *cxx-string-npos*
      // Data Members (public):
      // NB: This is an unsigned type, and thus represents the maximum
      // size that the allocator can hold.
      ///  Value returned by various member functions when they fail.
      static const size_type	npos = static_cast<size_type>(-1);

    public:
      // *cxx-string-size*
      // Capacity:
      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      size() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }

      ///  Returns the number of characters in the string, not including any
      ///  null-termination.
      size_type
      length() const _GLIBCXX_NOEXCEPT
      { return _M_rep()->_M_length; }

      // *cxx-string-insert* 
      // see that different arg type

      /**
       *  @brief  Insert multiple characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      void
      insert(`iterator __p`, size_type __n, `_CharT __c`)
      {	this->replace(__p, __p, __n, __c);  }

      /**
       *  @brief  Insert value of a string.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a __str starting at @a __pos1.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      */
      basic_string&
      insert(`size_type __pos1`, const `basic_string& __str`)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
    };

// bits/char_traits.h

  /**
   *  @brief  Base class used to implement std::char_traits.
   *
   *  @note For any given actual character type, this definition is
   *  probably wrong.  (Most of the member functions are likely to be
   *  right, but the int_type and state_type typedefs, and the eof()
   *  member function, are likely to be wrong.)  The reason this class
   *  exists is so users can specialize it.  Classes in namespace std
   *  may not be specialized for fundamental types, but classes in
   *  namespace __gnu_cxx may be.
   *
   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt05ch13s03.html
   *  for advice on how to make use of this class for @a unusual character
   *  types. Also, check out include/ext/pod_char_traits.h.  
   */
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT                                    char_type;

      static _GLIBCXX_CONSTEXPR bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static _GLIBCXX_CONSTEXPR bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

    };

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (lt(__s1[__i], __s2[__i]))
          return -1;
        else if (lt(__s2[__i], __s1[__i]))
          return 1;
      return 0;
    }


={============================================================================
*kt_dev_cxx_0000* cxx-string-operations

CXXSLR-13.2

<cxx-string-ctor>
In C++, the type of string literals was changed from char* to const char*. 

  "This enables an automatic type conversion `from const char*` into strings."

The operations that manipulate the value of a string have several overloaded
versions.

string s(cstr);
Creates a string s that is initialized by the C-string cstr

string s(chars,charslen);
Creates a string s that is initialized by charslen characters of the character
array chars

string s1;                 // default initialzation. empty
string s2( s1 );           // direct form of initialzation.
string s2 = s1;            // copy form of initialzation.


TEST(String, Ctors)
{
  {
    string s("nico");
    EXPECT_THAT(s.length(), 4);
  }

  {
    string s(5, 'c');
    EXPECT_THAT(s, ElementsAre('c', 'c', 'c', 'c', 'c'));
  }

  {
    string s(5, 'c');
    EXPECT_THAT(s, "ccccc");
  }

  {
    string s{"zoo"};
    EXPECT_EQ(s, "zoo");
  }

  {
    string s("zoo");
    EXPECT_EQ(s, "zoo");
  }
}


{cxx-string-const} *cxx-string-append*

TEST(String, Const)
{
  {
    // /** *cxx-cstring*
    //  *  @brief  Construct string as copy of a C string.
    //  *  @param  __s  Source C string.
    //  *  @param  __a  Allocator to use (default is default allocator).
    //  */
    // basic_string(`const` _CharT* __s, const _Alloc& __a = _Alloc());

    // not a problem to construct string from const char*
    // const char s1[] = "this is first message";
    // const char *s2 = "this is first message";

    // both cause error
    //
    // t_string.cpp:29:49: error: invalid conversion from ‘char’ to ‘const char*’ [-fpermissive]
    //
    // const char const_letter = 'A';
    // string string_from_const_letter(const_letter);
    //
    // char non_const_letter = 'A';
    // string string_from_non_const_letter(non_const_letter);
  }

  // *cxx-string-const-ctor-const*

  // ctor and append cause error:
  //
  // {
  //   char letter = 'A';
  //
  //   // string.cpp:99:20: error: invalid conversion from ‘char’ to ‘const char*’ [-fpermissive]
  //   //      string s(letter);
  // 
  //   string s(letter);
  // }
  //
  // {
  //   char letter = 'A';
  //
  //   // string.cpp:99:20: error: invalid conversion from ‘char’ to ‘const char*’ [-fpermissive]
  //   //         s.append(letter);
  //
  //   string s;
  //   s.append(letter);
  // }

  // HOW TO GET AROUND?
  
  // /**
  //  *  @brief  Append a character.
  //  *  @param __c  The character to append.
  //  *  @return  Reference to this string.
  //  */
  // basic_string&
  // operator+=(_CharT __c)
  // {
  //  this->push_back(__c);
  //  return *this;
  // }

  {
    string s;
    char letter = 'A';

    s += letter;

    EXPECT_EQ(s, "A");
  }

  {
    string s;
    char letter = 'A';

    s.append(1, letter);
    EXPECT_EQ(s, "A");
  }
}


{cxx-string-to-cstring} *cxx-string-cstring* 

13.2.4 Strings and C-Strings

*cxx-remember* *cxx-cstring* *cxx-null*
`cxx-string` do not provide a special meaning for the character ’\0’, which is
used as a special character in an ordinary C-string to mark the end of the
string. The character '\0' may be part of a string just like every other
character.

If you use an old-style null pointer (NULL) instead of nullptr or a char*
parameter, strange behavior results. The reason is that NULL has an integral
type and is interpreted as the number 0 or the character with value 0 if the
operation is overloaded for a single integral type. So you should always use
nullptr or char* pointers.


`const` CharT* c_str() const;

copy()            Copies or writes the contents to a character array

s.copy(buffer,100); // copy at most 100 characters of s into buffer


data(), c_str()   Returns the value as C-string or character array

*cxx-cstring*
data() and c_str() return the contents of the string as an array of characters.
`The array includes the end-of-string character at position [size()].` 

`use c_str()` because before C++11, the return type of data() was not a valid
C-string, because no ’\0’ character was guaranteed to get appended.

copy() copies the contents of the string `into a character array` provided by
the caller. An ’\0’ character is 'not' appended.

note: 
data() and c_str() return an array that is `owned` by the string. Thus, the
caller must not modify or free the memory. seems not possible since it is const?

namespace cxx_code
{
  // /usr/include/c++/7/bits/basic_string.h

  // String operations:
  /**
   *  @brief  Return const pointer to null-terminated contents.
   *
   *  This is a handle to internal data.  Do not modify or dire things may
   *  happen.
   */
  const _CharT*
    c_str() const _GLIBCXX_NOEXCEPT
    { return _M_data(); }

  /**
   *  @brief  Return const pointer to contents.
   *
   *  This is a pointer to internal data.  It is undefined to modify
   *  the contents through the returned pointer. To get a pointer that
   *  allows modifying the contents use @c &str[0] instead,
   *  (or in C++17 the non-const @c str.data() overload).
   */
  const _CharT*
    data() const _GLIBCXX_NOEXCEPT
    { return _M_data(); }
}


TEST(String, check_cstring_1)
{
  // do not include a null
  std::string sz{"zoo"};
  EXPECT_EQ(sz.size(), 3);

  // include a null
  char cs[] = "zoo";
  EXPECT_EQ(strlen(cs), 3);
  EXPECT_EQ(sizeof(cs), 4);
  EXPECT_EQ(sizeof(cs) / sizeof(char), 4);

  // there is std::string ctor(const char*)
  const char s1[]  = "0123456789012345";
  std::string coll{s1};
  EXPECT_THAT(sizeof(s1), 17);  // s1 is array
  EXPECT_THAT(strlen(s1), 16);  // not include null
  EXPECT_THAT(coll.size(), 16); // not include null

  // c_str() include a null? yes.
  EXPECT_THAT(strlen(coll.c_str()), 16);
  EXPECT_THAT(coll.size(), 16);
  // int memcmp(const void *s1, const void *s2, size_t n);
  EXPECT_THAT(memcmp(s1, coll.c_str(), 17), 0);
  EXPECT_THAT(memcmp(s1, coll.c_str(), coll.size()+1), 0);
}

// when construct a string from array, it will copy up to null?
TEST(String, check_cstring_2)
{
  {
    // src_len is 14 which includes a null since std::string.data()
    //                "0123456789012"
    std::string input{"&streamtype=1"};
    char output[256] = {0};

    EXPECT_THAT(input.size(), 13);
    EXPECT_THAT(strlen(input.c_str()), 13);

    EXPECT_THAT(sizeof(output), 256);

    // char *strcpy(char *dest, const char *src);
    // which understand a cstring.
    strcpy(output, input.c_str());

    EXPECT_THAT(sizeof(output), 256);

    // size of result?
    std::string result{output};

    EXPECT_THAT(input, result);

    EXPECT_THAT(result.size(), 13);
    EXPECT_THAT(strlen(result.c_str()), 13);
  }
}


{can-be-invalidated} cxx-iter-invalidated <string-reallocation>
Convert string into C-strings or character arrays only immediately before you
need the contents as type char*. Since the return value of c_str() and data() is
valid 'only' until the next call of a non-const member function for the same
string. 

// As with invalidated iterators.

const char* p;
p = s.c_str();    // p refers to the contents of s as a C-string
foo(p);           // OK (p is still valid)
s += "ext";       // invalidates p
foo(p);           // ERROR: argument p is not valid


std::string s("abcde");    // s contains: ’a’ ’b’ ’c’ ’d’ ’e’

char& r = s[2];            // reference to third character
char* p = &s[3];           // pointer to fourth character

r = ’X’;                   // OK, s contains: ’a’ ’b’ ’X’ ’d’ ’e’
*p = ’Y’;                  // OK, s contains: ’a’ ’b’ ’X’ ’Y’ ’e’

s = "new long value";      // 'reallocation' invalidates r and p

r = ’X’;                   // ERROR: undefined behavior
*p = ’Y’;                  // ERROR: undefined behavior


{string-capacity} 13.2.5 Size and Capacity
As with vector, string has the same interfaces: size(), length(), max_size(),
   capacity(), and reserve().

1. empty() checks whether the string is empty. Because it might be faster, you
should use empty() instead of length() or size().

2. capacity() returns the number of characters a string could contain without
having to reallocate its internal memory.

The concept of capacity for strings is, in principle, the same as for vector
containers. But one big difference: Unlike with vectors, calling reserve() for
strings might be a call to shrink the capacity. If the argument is less than the
current number of characters, it is a 'nonbinding' shrink-to-fit request meaning
"no guarantee to happen".

So, a call of reserve() without any argument is always a nonbinding
shrink-to-fit request:

// would like to shrink capacity to fit the current size
s.reserve();

Since C++11, shrink_to_fit() provides the same effect:

// would like to shrink capacity to fit the current size (C++11)
s.shrink_to_fit();


{sting-comparison}
tquery.cpp:128: error: no match for 'operator==' in 's == 'q''

shoule be:

if( !(cin >> s) || s == "q" ) break;


{string-modify} 13.2.8 Modifiers
You can modify strings by using different member functions and operators.

<cxx-string-assign>
The assign() member functions provide more when more than one argument is

<cxx-string-swap>
The specialization of swap() for strings guarantees constant complexity, so you
should use it to swap the value of strings and to assign strings if you don't
need the assigned string after the assignment.


TEST(StringOperations, AssignSwap)
{
  {
    const std::string coll{"othello"};
    std::string s{};

    // assign "othello" (equivalent to operator =)
    s.assign(coll);
    EXPECT_EQ(s, "othello");

    s.assign(coll, 1, 3);
    EXPECT_EQ(s, "the");

    s.assign(coll, 2, std::string::npos);
    EXPECT_EQ(s, "hello");
  }

  {
    std::string coll{"othello"};
    std::string s{};

    // assign "othello" (equivalent to operator =)
    s.swap(coll);
    EXPECT_EQ(s, "othello");

    // compile error
    // s.swap("the");
    // s.swap(string("the"));
    
    string str{"the"};
    s.swap(str);
    EXPECT_EQ(s, "the");
  }

  {
    std::string s{};

    s.assign("othello");
    EXPECT_EQ(s, "othello");

    s.assign("the");
    EXPECT_EQ(s, "the");
  }
}


<cxx-string-insert-cxx-string-append>

In JAVA, the following shows inefficient concatenation. Assume that strings are
all the same length, x and there are n strings. Just think about concatenation.
For the first iteration, x copies char by char. Next iteration, 2x and so on.
This reduces to O(xn^2) but not O((xn)^2)

String sentence = "";

for( String w : words )
   sentence = sentence + w;

This add string to sentence and copy the temp result to sentence for each loop.
note: that there is no append() member in String class. Should be written

StringBuffer sentence = new StringBuffer();

for( String w : words )
   sentence.append(w);


How minimize this in C++?

1. Use append
As for the above, use append since string has append member function.

2. Use move()
Since C++11, operator + is also overloaded for strings that are rvalue
references to support the move semantics. If a string argument passed to
operator + is no longer needed afterward.

string foo()
{
  std::string s1("international");
  std::string s2("ization");

  std::string s = std::move(s1) + std::move(s2); // OK
  // s1 and s2 have valid state with unspecified value

  return s;
}


To append characters, you can use operator +=, append(), and push_back().

Operator += appends single-argument values, including initializer lists of
characters since C++11. append() is overloaded for different arguments.

s += ’\n’;                             // append single character

s.append(aString);                     // append "othello" (equivalent to operator +=)
s.append(aString,1,3);                 // append "the"
s.append(aString,2,std::string::npos); // append "hello"
s.append("two\nlines");                // append C-string (equivalent to operator +=)
s.append("nico",5);                    // append character array: ’n’ ’i’ ’c’ ’o’ ’\0’
s.append(5,’x’);                       // append five characters: ’x’ ’x’ ’x’ ’x’ ’x’

Several insert() member functions enable you to insert characters.

const std::string aString("age");
std::string s("p");
s.insert(1, aString);     // s: page
s.insert(1,"ersifl");     // s: persiflage


TEST(StringOperations, Insert)
{
  // *cxx-string-const-error*
  //
  // char x;
  // string.insert(x) causes error since x is not const char *. To add char,
  // use
  //
  // string& string::insert (size_type idx, size_type num, char c);
  
  {
    string s{};
    s.insert(0, 1, 'X');
    s.insert(0, 1, 'X');
    s.insert(0, 1, 'X');
    EXPECT_EQ(s, "XXX");
  }
  {
    string s{};
    s.insert(0, 1, 'X');
    s.insert(0, 1, 'Y');
    s.insert(0, 1, 'Z');
    EXPECT_EQ(s, "ZYX");
  }
}


<ex> cxx-string-insert-padding

// string-pad string-insert
//
// pad(string, lenth, char);
//
// s.insert(pos,num,c) 
//
// Inserts num occurrences of the character c at iterator position pos and
// returns the iterator position of the first new character

template <typename T>
void pad(T &s, typename T::size_type n, typename T::value_type c)
{
    if (n > s.size())
        s.append(n - s.size(), c);
}

TEST(StringPad, InsertAppendPad)
{
  // insert
  string s1{"foo"};
  s1.insert(s1.size(), 20 - s1.size(), 'X');
  EXPECT_EQ(s1, "fooXXXXXXXXXXXXXXXXX");

  string s2{"foo"};
  s2.insert(s2.end(), 20 - s2.size(), 'X');
  EXPECT_EQ(s2, "fooXXXXXXXXXXXXXXXXX");

  // append
  string s3{"foo"};
  s3.append(20 - s3.size(), 'X');
  EXPECT_EQ(s3, "fooXXXXXXXXXXXXXXXXX");

  // pad
  string s4{"foo"};
  pad(s4, 20, 'X');
  EXPECT_EQ(s4, "fooXXXXXXXXXXXXXXXXX");

  wstring ws1{L"foo"};
  pad(ws1, 20, 'X');
  EXPECT_EQ(ws1, L"fooXXXXXXXXXXXXXXXXX");
}


<cxx-string-erase> <cxx-string-replace>

string& string::erase (size_type idx)
string& string::erase (size_type idx, size_type len)

o Both forms erase at most len characters of *this, starting at index idx.
o They return *this.
o `If len is missing, all remaining characters are removed.`
o Both forms throw out_of_range if idx > size().

iterator string::erase (const_iterator pos)
iterator string::erase (const_iterator beg, const_iterator end)

o Both forms erase the single character at iterator position pos or all
  characters of the range [beg,end), respectively.

o They return the position of the first character after the last removed
  character (thus, the second form returns end).

string& string::replace (size_type idx, size_type len, const string& str)
string& string::replace (begin_iterator beg, begin_iterator end, const string& str)

TEST(StringOperations, EraseReplace)
{
  {
    std::string s = "i18n";

    s.replace(1,2,"nternationalizatio");   // change of size
    EXPECT_EQ(s, "internationalization");

    s.erase(13);                           // s: international. note: from 13
    EXPECT_EQ(s, "international");

    s.erase(7, 5);                         // internaxxxxxl
    EXPECT_EQ(s, "internal");

    // *cxx-string-pop-back*
    // void string::pop_back ()
    // Calling this for an empty string results in undefined behavior.

    s.pop_back();                          // s: interna (since C++11)
    EXPECT_EQ(s, "interna");

    s.replace(0, 2,"ex");                   // s: externa
    EXPECT_EQ(s, "externa");
  }

  {
    std::string s = "i18n";

    s.replace(1,2,"nternationalizatio");   // change of size
    EXPECT_EQ(s, "internationalization");

    // use iterator? No, all string find function returns index.
    s.erase(s.find('l'));
    EXPECT_EQ(s, "internationa");
  }

  // when use erase(iterator), it erases only one element. 
  {
    std::string s{"abcde"};

    auto it = s.begin();
    ++it;
    s.erase(it);
    EXPECT_THAT(s, "acde");

    s.erase(it);
    EXPECT_THAT(s, "ade");
  }

  {
    // the replacement string need not be the same size as the substring that
    // it is replacing. cxx-string-replace

    string s = "Niels Stroustrup";
    s.replace(0, 5,"nicholas");
    EXPECT_EQ(s, "nicholas Stroustrup");
  }
}


Use resize() to change the number of characters. If the new size that is passed
as an argument is less than the current number of characters, characters are
removed from the end. If the new size is greater than the current number of
characters, characters are appended at the end. You can pass the character that
is appended if the size of the string grows. If don't, the default constructor
for the character type is used which is the ’\0’ character for type char.

<ex>
// string-trim
//
// 4.2 Trimming a String
// 
// void trim(std::string &s, char c);
// remove chars from the end which matches with the given char
//
// string s1{"zoo"};
// rtrim(s1, 'o');
// EXPECT_EQ(s1, "z");
//
// variations: trim whitespace, trim from the left. 


// use single call to erase than removing one at a time.

namespace trim_2018_11_14 {

  void trim(string &s, const char c)
  {
    int start = s.size()-1;

    while (start)
    {
      if (s[start] != c)
        break;

      --start;
    }

    // same as
    // s.erase(start+1, s.size());
   
    s.erase(start+1);
  }

  // if use iterators
  void trim_iter(string &s, const char c)
  {
    if (s.empty()) return;

    auto end = s.end();

    // it do not check on the first, *begin
 
    // for (; end != s.begin(); --end)
    // {
    //   if (*end != c)
    //     break;
    // }

    for (; end != s.begin() && *--end == c;)
      ;

    // if the first is not the same, +iter
    if (end != s.end() && *end != c)
      ++end;

    s.erase(end, s.end());

    // note: cxx-string-erase
    //
    // case core
    // s.erase(end);
    // 
    // okay 
    // if (end != s.end()) s.erase(end);
    // 
    // okay
    // s.erase(end, s.end());
    //
    // this causes crash on
    //
    // string s1{"zzz"};
    // trim_iter(s1, 'o');
    // EXPECT_EQ(s1, "zzz");
    //
    // since there's no match, end is the same as s.end() after for loop.
    // s.end(pos) is different from s.end(pos, pos) and that explains why it's
    // okay when use erase(pos, pos).
    //
    // okay, understand why it's problem to erase element end poinst to. why
    // didn't get assert when use -D_GLIBCXX_DEBUG.
    //
    // when looked at source:
    //
    // /**
    //  *  @brief  Remove one character.
    //  *  @param __position  Iterator referencing the character to remove.
    //  *  @return  iterator referencing same location after removal.
    //  *
    //  *  Removes the character at @a __position from this string. The value
    //  *  of the string doesn't change if an error is thrown.
    //  */
    // iterator
    //   erase(iterator __position)
    //   {
    //     _GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
    //         && __position < _M_iend());
    //     const size_type __pos = __position - _M_ibegin();
    //     _M_mutate(__pos, size_type(1), size_type(0));
    //     _M_rep()->_M_set_leaked();
    //     return iterator(_M_data() + __pos);
    //   }
    //
    // Oh, it does have ASSERT How to enable? Use -D_GLIBCXX_DEBUG_PEDANTIC then
    // gets assert rather than having a core only which need to debug further. 
    //
    // /usr/include/c++/4.9/bits/basic_string.h:1399: std::basic_string<_CharT,
    // _Traits, _Alloc>::iterator std::basic_string<_CharT, _Traits,
    // _Alloc>::erase(std::basic_string<_CharT, _Traits, _Alloc>::iterator)
    // [with _CharT = char; _Traits = std::char_traits<char>; _Alloc =
    // std::allocator<char>; std::basic_string<_CharT, _Traits,
    // _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,
    // std::basic_string<char> >; typename
    // _Alloc::rebind<_CharT>::other::pointer = char*]: Assertion '__position >=
    // _M_ibegin() && __position < _M_iend()' failed.  
    // Aborted (core dumped)
  }

} // namespace


TEST(StringTrim, 2018_11)
{
  using namespace trim_2018_11_14;

  {
    string s1{"zoo"};
    trim(s1, 'o');
    EXPECT_EQ(s1, "z");
  }

  {
    string s1{"zzz"};
    trim(s1, 'o');
    EXPECT_EQ(s1, "zzz");
  }

  // trim whitespace
  {
    string s1{"zoo                              "};
    trim(s1,' ');
    EXPECT_EQ(s1, "zoo");
  }

  {
    string s1{"zoo"};
    trim(s1,' ');
    EXPECT_EQ(s1, "zoo");
  }

  // trim iterator version
  {
    string s1{"zoo"};
    trim_iter(s1, 'o');
    // EXPECT_EQ(s1, string("z"));
    EXPECT_EQ(s1, "z");
  }

  {
    string s1{"zzz"};
    trim_iter(s1, 'o');
    EXPECT_EQ(s1, "zzz");
  }

  // trim_iter whitespace
  {
    string s1{"zoo                              "};
    trim_iter(s1,' ');
    EXPECT_EQ(s1, "zoo");
  }

  {
    string s1{"zoo"};
    trim_iter(s1,' ');
    EXPECT_EQ(s1, "zoo");
  }
}


{cxx-string-boost}
http://www.boost.org/doc/libs/1_66_0/doc/html/string_algo.html


{cxx-string-clear}
To remove all characters in a string:

s = "";     // assign the empty string
s.clear();  // clear contents
s.erase();  // same as s.erase(0, npos), erase all characters


={============================================================================
*kt_dev_cxx_0000* cxx-string-find

{cxx-string-find} 13.2.11 Searching and Finding

There are three ways to search: by using member functions, the regex, and
algorithms.

*cxx-remember* *cxx-string-iterator*
  All string search and find function returns index but not iterator.

All search functions return the `index` of the first character of the character
that matches the search. `If the search fails, they return string::npos.`

o The first argument is always the `value that is searched for.`

o The optional second value indicates an index at which `to start the search` in
  the string.

o The optional third argument is the number of characters of the value to
  search.

Unfortunately, search argument scheme differs from that of the other string
functions. With the other string functions, `the starting index` is the first
argument, and the value and its length are adjacent arguments. For example:

string& string::erase (size_type idx)
string& string::erase (size_type idx, size_type len)


Finds the first occurrence of value, char or `substring`:

`size_type` string::find (`const string& str`) const
size_type string::find (const string& str, size_type idx) const
size_type string::rfind (const string& str) const
size_type string::rfind (const string& str, size_type idx) const

o These functions search for the first/last substring str. starting at idx.
o The find() functions search forward and return the first substring.
o The rfind() functions search backward and return the last substring.
o These functions return the index of the first character of the substring when
  successful or string::npos if they fail.


<ex> *cxx-string-find*
Given *cxx-string-ctor-const* why not an error?

  s.find(',', i);

Since:

      /**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      */
      size_type
      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;


TEST(String, Find)
{
  EXPECT_THAT(string("hello").find("ll"), 2);
  EXPECT_THAT(string("aaaaa").find("bba"), string::npos);
  EXPECT_THAT(string("aaaaa").find("bba"), -1);
}

namespace algo_code
{
  // bits/basic_string.tcc

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      __glibcxx_requires_string_len(__s, __n);
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
        return __pos <= __size ? __pos : npos;

      if (__n <= __size)
      {
        for (; __pos <= __size - __n; ++__pos)
          if (traits_type::eq(__data[__pos], __s[0])
              && traits_type::compare(__data + __pos + 1,
                __s + 1, __n - 1) == 0)
            return __pos;
      }
      return npos;
    }

  // /usr/include/c++/4.9/bits/basic_string.h

  /**
   *  @brief  Find position of a string.
   *  @param __str  String to locate.
   *  @param __pos  Index of character to search from (default 0).
   *  @return  Index of start of first occurrence.
   *
   *  Starting from @a __pos, searches forward for value of @a __str within
   *  this string.  If found, returns the index where it begins.  If not
   *  found, returns npos.
   */
  size_type
    find(const basic_string& __str, size_type __pos = 0) const
    _GLIBCXX_NOEXCEPT
    { return this->find(__str.data(), __pos, __str.size()); }
}


Finds the first `character of *any* of these chars`:

size_type string::find_first_of (const string& str) const
size_type string::find_first_of (const string& str, size_type idx) const
size_type string::find_first_not_of (const string& str) const
size_type string::find_first_not_of (const string& str, size_type idx) const

o These functions search for the first character that is or is not also an
  element of the string str. `starting at idx.`

o These functions return the index of that character or substring when
  successful or `string::npos if they fail.`

*cxx-remember*
return index of the found which is difference from 0.


{cxx-string-substr}
Extract a substring from any string by using the substr() member function.

13.3.9 Substrings and String Concatenation

      /**
       *  @brief  Get a substring.
       *  @param __pos  Index of first character (default 0).
       *  @param __n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Construct and return a new string using the @a __n
       *  characters starting at @a __pos.  If the string is too
       *  short, use the remainder of the characters.  If @a __pos is
       *  beyond the end of the string, out_of_range is thrown.
      */
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
			    _M_check(__pos, "basic_string::substr"), __n); }


string string::substr () const
string string::substr (size_type idx) const
string string::substr (size_type idx, `size_type len`) const

* All forms return a substring of at most len characters of the string *this 
* If len is missing, all remaining characters are used.
* If idx and len are missing, a copy of the string is returned.
* All forms throw out_of_range if idx > size().


<ex>
TEST(String, Substr)
{
  std::string coll{"interchangeability"};

  // see `cxx-string-length` returns length which is [0, length)
  EXPECT_THAT(coll.length(), 18); 

  // return whole string
  EXPECT_THAT(coll.substr(), "interchangeability");

  // return whole string as find('x') returns string::npos
  EXPECT_THAT(coll.substr(0, coll.find('x')), "interchangeability");

  EXPECT_THAT(coll.substr(coll.find('c')), "changeability");

  EXPECT_THAT(coll.substr(11), "ability");

  // note that the second is `length`
  EXPECT_THAT(coll.substr(5,6), "change");
}


<ex>
// cxx-string-split 
//
// 4.6 Splitting a String
// You want to split a delimited string into multiple strings. For example, you
// may want to split the string "Name|Address|Phone" into three separate
// strings, "Name", "Address", and "Phone", with the delimiter removed.


// cpp-string-find cxx-string-substr cpp-string-replace
// CXXSLR 13.1.1 A First Example: Extracting a Temporary Filename
// make the original example short.

TEST(StringSplit, GetExtension)
{
  const string suffix{"tmp"};
  vector<string> coll1{"prog.dat", "mydir", "hello.", "opps.tmp", "end.dat"};
  vector<string> coll2;
  string filename, basename, extname;

  for (auto inputname : coll1)
  {
    auto idx = inputname.find('.');

    // if not have .
    if (idx == string::npos)
    { 
      filename = inputname + '.' + suffix;
    }
    else
    {
      basename = inputname.substr(0, idx);
      extname = inputname.substr(idx+1);
      filename = basename + '.' + suffix;

      // to use cxx-string-replace
      if (extname == suffix)
      {
        filename = inputname;
        filename.replace(idx+1, string::npos, "xxx");
      }
    }

    coll2.push_back(filename);
  }

  EXPECT_THAT(coll2, 
      ElementsAre("prog.tmp", "mydir.tmp", "hello.tmp", "opps.xxx", "end.tmp"));
}


// split input string by delimeter and put them into vector
// void split(const string &s, char delim, vector<string> &coll);
//
// note that substr(idx, `length`); but not substr(idx, idx);

namespace stringsplit_2018_10
{
  // note:
  // this has *undefined* behaviour; sometimes works and sometimes infinite loop
  // since found is npos when not found and do ++found and use it loop condition.
  //
  // void split(const string &s, char delim, vector<string> &coll)
  // {
  //   size_t i{};
  //   size_t found{};
  //   std::string token;
  // 
  //   for (i = 0; found != std::string::npos; )
  //   {
  //     found = s.find(delim, i);
  //     token = s.substr(i, found-i);
  //     i = ++found;
  //     coll.push_back(token);
  //     // std::cout << "token: " << token << std::endl;
  //   }
  // }

  void split_text(const string &s, char delim, vector<string> &coll)
  {
    string::size_type i = 0;
    string::size_type found = s.find(delim);

    while (found != string::npos)
    {
      // save the first token
      coll.push_back(s.substr(i, found-i));
      // std::cout << "token: " << s.substr(i, found-i) << std::endl;
      i = ++found;
      found = s.find(delim, i);

      // if see no more token, save the current
      if (found == string::npos)
      {
        // std::cout << "token: " << s.substr(i, found) << std::endl;
        coll.push_back(s.substr(i, found));
      }
    }
  }


  void split_revised(const string &input, char delim, vector<string> &coll)
  {
    string::size_type i{};
    string::size_type found = input.find(delim, i);

    while (found != string::npos)
    {
      coll.push_back(input.substr(i, found-i));
      i = ++found;
      found = input.find(delim, i);
    }

    if (found == string::npos)
      coll.push_back(input.substr(i, found-i));
  }
} // namespace


TEST(StringSplit, ByDelimeter_201810)
{
  using namespace stringsplit_2018_10;

  {
    std::vector<std::string> coll;
    split_text("Smith, Bill, 5/1/2002, Active", ',', coll); 
    EXPECT_THAT(coll, ElementsAre("Smith", " Bill", " 5/1/2002", " Active"));
  }

  {
    // fails:
    std::vector<std::string> coll;
    split_text("Smith", ',', coll); 
    EXPECT_THAT(coll, ElementsAre());
  }

  {
    std::vector<std::string> coll;

    split_revised("Smith, Bill, 5/1/2002, Active", ',', coll); 
    EXPECT_THAT(coll, ElementsAre("Smith", " Bill", " 5/1/2002", " Active"));

    coll.clear();
    split_revised("Smith", ',', coll); 
    EXPECT_THAT(coll, ElementsAre("Smith"));
  }
}


// *boost-split* *boost-is-any-of*
// The one function that is in the example that isn’t in the table is
// is_any_of. This is a function template that returns a predicate
// function object that can be used by the trim_if-style functions.

TEST(StringSplit, ByBoost)
{
  {
    vector<string> coll;

    boost::split(coll, "Smith, Bill, 5/1/2002, Active", 
        boost::is_any_of("|"));

    // not found and returns the input
    EXPECT_THAT(coll, ElementsAre("Smith, Bill, 5/1/2002, Active"));
  }

  {
    vector<string> coll;

    boost::split(coll, "Smith, Bill, 5/1/2002, Active", 
        boost::is_any_of(","));

    EXPECT_THAT(coll, ElementsAre("Smith", " Bill", " 5/1/2002", " Active"));
  }

  {
    vector<string> coll;

    boost::split(coll, "Name|Address|Phone", 
        boost::is_any_of("|"));

    EXPECT_THAT(coll, ElementsAre("Name", "Address", "Phone"));
  }

  {
    // note: cxx-boost-split see how boost works
    //
    // Value of: svec
    // Expected: has 1 element that is equal to "Name"
    //   Actual: { "", "", "Name" }, which has 3 elements

    vector<string> coll;
    boost::split(coll, "||Name", boost::is_any_of("|"));

    EXPECT_THAT(coll, ElementsAre("", "", "Name"));
  }
}

namespace stringsplit_2018_11 {

  // 2018.11.14

  void split(const string &s, const char delim, vector<string> &coll)
  {
    string token{};
    size_t start{}, end{}; 

    end = s.find(delim, start);
    for (; end < string::npos;)
    {
      coll.push_back(s.substr(start, end - start));
      start = end+1;
      end = s.find(delim, start);
    }

    coll.push_back(s.substr(start, end - start));
  }

} // namespace


TEST(StringSplit, ByDelimeter_2018_11)
{
  using namespace stringsplit_2018_11;

  {
    std::vector<std::string> coll;

    //         5      11
    split("Smith, Bill, 5/1/2002, Active", ',', coll); 
    EXPECT_THAT(coll, ElementsAre("Smith", " Bill", " 5/1/2002", " Active"));

    coll.clear();

    // when not found
    split("Smith", ',', coll); 
    EXPECT_THAT(coll, ElementsAre("Smith"));
  }

  {
    std::vector<std::string> coll;
    split("192.169.1.20", '.', coll);
    EXPECT_THAT(coll, ElementsAre("192", "169", "1", "20"));
  }

  {
    std::vector<std::string> coll;
    split("Name|Address|Phone", '|', coll);
    EXPECT_THAT(coll, ElementsAre("Name", "Address", "Phone"));
  }
}


<ex>
class StringTokenizer
{
    public:
        StringTokenizer(const string &s, const char *delim = nullptr )
            : str_(s)
        {
            // set default delimiters
            if (!delim)
                delim_ = " \n\r\t\v\f";
            else
                delim_ = delim;

            begin_ = str_.find_first_not_of(delim_);
            end_ = str_.find_first_of(delim_);
        }

        // return # of tokens
        size_t countTokens()
        {
            // if we already have count calculated
            if (count_)
                return count_;

            size_t token_count{}, pos{};

            for (;;)
            {
                // if there are only delimiters then there are no tokens
                if ((pos = str_.find_first_not_of(delim_, pos)) == string::npos)
                    break;

                pos = str_.find_first_of(delim_, pos);
                ++token_count;

                // okay, see no more delimiter so stop.
                if (pos == string::npos)
                    break;
            }

            return count_ = token_count;
        }

        bool hasMoreTokens()
        { return begin_ != end_; }

        // get the next out of input string
        void nextToken(string &token)
        {
            // char and delimiter. so continue
            if ((begin_ != string::npos) && (end_ != string::npos))
            {
                token = str_.substr(begin_, end_- begin_);

                begin_ = str_.find_first_not_of(delim_, end_);
                end_ = str_.find_first_of(delim_, begin_);
            }
            // chars but no more delimiter
            else if(begin_ != string::npos && end_ == string::npos)
            {
                token = str_.substr(begin_, end_);
                begin_ = string::npos;
            }
            // no char but delimiter
            // else if(begin_ == string::npos && end_ != string::npos)
            // no char and no delimiter
            // else if(begin_ == string::npos && end_ == string::npos)
            else
            {
                // *TN* 
                // no need to set token since begin_ and end_ are state
                // variable. hasMoreTokens() use this to signal user to stop
                // loop.

                token = "";
                begin_ = end_ = string::npos;
            }
        }

    private:
        StringTokenizer() {}    // *cxx-ctor-private*
        size_t begin_{};        // char pos
        size_t end_{};          // delim pos
        size_t count_{};
        string str_{};
        string delim_{};
};


int t_string_10()
{
    string str{"Name Address Phone"};

    StringTokenizer st(str);

    cout << "there are " << st.countTokens() << " tokens." << endl;

    while (st.hasMoreTokens())
    {
        string token{};
        st.nextToken(token);
        cout << "token = " << token << endl;
    }
}


<ex> cxx-string-find_first_of

13.1.2 A Second Example: Extracting Words and Printing Them Backward

#include <iostream>
#include <string>

using namespace std;

// This example extracts single words from standard input and prints the
// characters of each word in reverse order. The words are separated by the
// usual whitespaces (newline, space, and tab) and by commas, periods, or
// semicolons:

int main(int argc, char* argv[])
{
  // note: The newline character is also used as a delimiter. However, no
  // special processing is necessary for it because the program reads line by
  // line.

  const string delims(" \t,.;");
  string line;

  while( getline( cin, line ) )
  {
    string::size_type begi, endi;

    // The find_first_not_of() function returns the 'first' index of a character
    // that is not part of the passed string argument.

    begi = line.find_first_not_of(delims);

    // while beginning of a word found
    while( begi != string::npos )
    {
      // searches for the end of the current word. an optional second argument
      // is used that specifies where to 'start' the search in the string.

      endi = line.find_first_of( delims, begi ); 
      if( endi == string::npos )
      {
        // end of word is end of line
        endi = line.length();
      }

      // print characters in reverse
      // 
      // "pots & pans"
      //  ^   ^
      //      endi
      //  begi
      
      // note:
      for( int i = endi-1; i >= static_cast<int>(begi); --i )
        cout << line[i];

      cout << ' ';

      // search beginning of the next word
      begi = line.find_first_not_of( delims, endi );
    }

    // to have next input on next getline
    cout << endl;
  }
}

pots & pans
stop & snap 
I saw a reed
I was a deer 
deliver no pets
reviled on step 
nametag on diaper
gateman no repaid 


note: implicit conversion
If you omit the cast of begIdx to int, this program might run in an endless loop
or might crash. The problem is that string::size_type is an 'unsigned' integral
type. Without the cast, the signed value i is converted automatically into an
unsigned value because it is compared with a unsigned type. 

In this case, the following expression always yields true if the current word
starts at the beginning of the line: 

i>=begIdx 

The reason is that begIdx is then 0, and any unsigned value is greater than or
equal to 0. For example, when i == -1. So, an endless loop results that might
get stopped by a crash due to an illegal memory access. For this reason, I don't
like the concept of string::size_type and string::npos.

The size_type, which is defined by the allocator of the string, must be an
unsigned integral type.  The default allocator, allocator, uses type size_t as
size_type. Because -1 is converted into an unsigned integral type, npos is the
'maximum' unsigned value of its type. 

However, the exact value 'depends' on the exact definition of 'type' size_type:
(unsigned long)-1 differs from (unsigned short)-1 if the size of the types
differs. so maximum values differ.

int idx = s.find("xx");
if (idx == std::string::npos) {
  ...
}

Might yield false if idx has the value -1 and idx and string::npos have
'different' types.


<solution>
One way to avoid this error is to check whether the search fails directly:

if (s.find("hi") == std::string::npos) {
...
}

However, often you need the index of the matching character position. Thus
another simple solution is to define your own signed value for npos:

const int NPOS = -1;

if (idx == NPOS) { // works almost always
...
}

Unfortunately, this solution is not perfect, because the comparison fails if
either idx has type unsigned short or the index is greater than the maximum
value of int. Because of these problems, the standard did not define it that
way. 

However, because both might happen very 'rarely', the solution works in most
situations. To write portable code, however, you should always use
string::size_type for any index of your string type.  For a perfect solution,
    you'd need some overloaded functions that consider the exact type of
    string::size_type. I still hope the standard will provide a better solution
    in the future although with C++11 nothing changed.

note: Q?

for( string::size_t i = endi-1; i >= begi; --i )


={============================================================================
*kt_dev_cxx_0000* cxx-string-numeric-conversion cxx-boost-lexical-cast

{cxx-string-convert-function}

13.2.13 Numeric Conversions

Since C++11, the C++ standard library provides convenience functions to convert
strings into numeric values or to convert numeric values to strings. Only for
types string and wstring, not u16string and u32string.

o They skip leading whitespaces.

o idxRet. They allow you to return the index of the first character after the
  last processed character.

o On success, the function returns the converted integral number as an int
  value.

*cxx-sto* cxx-convert-to-nunmber

stoi(str,idxRet=nullptr, base=10)      Converts str to an int
stol(str,idxRet=nullptr, base=10)      Converts str to a long
stoul(str,idxRet=nullptr, base=10)     Converts str to an unsigned long
stoll(str,idxRet=nullptr, base=10)     Converts str to a long long
stoull(str,idxRet=nullptr, base=10)    Converts str to an unsigned long long
stof(str,idxRet=nullptr)               Converts str to a float
stod(str,idxRet=nullptr)               Converts str to a double
stold(str,idxRet=nullptr)              Converts str to a long double

// to-string. gcc 4.4.5 do not support this

Convert integral/floating-point value to string (since C++11)

C++11 has std::to_string and std::to_wstring functions that are declared in
the <string> header. Those functions use locales and have behavior very close
to boost::lexical_cast<std::string> and boost::lexical_cast<std::wstring>,
   respectively.

to_string(val)                         Converts val to a string
to_wstring(val)                        Converts val to a wstring


// bits/basic_string.h

  // 21.4 Numeric Conversions [string.conversions].
  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
					__idx, __base); }


{cxx-string-convert-stringstream} *cxx-stringstream* 

A stringstream is a convenient way to put data into a string because it lets
you use all of the formatting facilities provided by the standard input and
output stream classes.


int EnvironmentAppIdStrategy::getAppId() const
{
    ApplicationRuntimeInstanceId appRuntimeInstanceId = 0;

    char* appIdFromEnv = getenv(APP_RUNTIME_INSTANCE_ID_ENV_VAR_NAME);

    // note: use stringstring to convert
 
    const std::string appIdAsString(appIdFromEnv);
    std::istringstream is(appIdAsString);
    is >> appRuntimeInstanceId;

    return appRuntimeInstanceId;
}


{cxx-string-convert-lexicalcast} *cxx-boost*
http://www.boost.org/doc/libs/1_58_0/doc/html/boost_lexical_cast.html

Motivation

Sometimes a value must be converted to a literal text form, such as an int
represented as a std::string, or vice-versa, when a std::string is interpreted
as an int. Such examples are common when converting between data types
internal to a program and representation external to a program, such as
windows and configuration files.

The standard C and C++ libraries offer a number of facilities for performing
such conversions. However, they vary with their ease of use, extensibility,
     and safety.

For instance, there are a number of limitations with the family of standard C
functions typified by 'cxx-atoi':

* Conversion is supported in one direction only: from text to internal data
  type. Converting the other way using the C library requires either the
  inconvenience and compromised safety of the sprintf function, or the loss of
  portability associated with `non-standard functions such as itoa`

* The range of types supported is only a subset of the built-in numeric types,
  namely int, long, and double.

* The range of types cannot be extended in a uniform manner. For instance,
  conversion from string representation to complex or rational.

The standard C functions typified by `strtol` have the same basic limitations,
    but offer finer control over the conversion process. However, for the
    common case such control is often either not required or not used. The
    scanf family of functions offer even greater control, but also lack safety
    and ease of use.

The standard C++ library offers `stringstream` for the kind of in-core
formatting being discussed. It offers a great deal of control over the
formatting and conversion of I/O to and from arbitrary types through text.
However, for simple conversions direct use of stringstream can be either
clumsy (with the introduction of extra local variables and the loss of
    infix-expression convenience) or obscure (where stringstream objects are
      created as temporary objects in an expression). Facets provide a
    comprehensive concept and facility for controlling textual representation,
    but their perceived complexity and high entry level requires an extreme
    degree of involvement for simple conversions, and excludes all but a few
    programmers.

The lexical_cast function template offers a convenient and consistent form for
supporting common conversions to and from arbitrary types when they are
represented as text. The simplification it offers is in expression-level
convenience for such conversions. For more involved conversions, such as where
precision or formatting need tighter control than is offered by the default
behavior of lexical_cast, the conventional std::stringstream approach is
recommended. Where the conversions are numeric to numeric, boost::numeric_cast
may offer more reasonable behavior than lexical_cast.


template<typename Target, typename Source>
Target lexical_cast(Source arg)


* The boost::lexical_cast function will even check bounds for you:

#include <boost/lexical_cast.hpp>
#include <cassert>

void sample4()
{
  try {
    const short s = boost::lexical_cast<short>("1000000");
    assert(false);
  } catch (const boost::bad_lexical_cast &e) {
    std::cout << e.what() << std::endl;
  }
}


* Since Boost 1.56, there is a boost::conversion::try_lexical_convert function
  that reports errors by return code. It could be useful in performance
  critical places where bad input could often occur:

#include <boost/lexical_cast.hpp>
#include <cassert>

void sample7() 
{    
  int i = 0;    
  const bool ok = boost::conversion::try_lexical_convert("Bad stuff", i);    
  assert(!ok);
}


<ex>

std::map<std::string, std::string> si;

static uint64_t fake_outputs = 0;

si["POST_REPAIR_OUTPUTS"] =
  boost::lexical_cast<std::string>(fake_outputs++);


<ex>

int EnvironmentAppIdStrategy::getAppId() const
{
    ApplicationRuntimeInstanceId appRuntimeInstanceId = 0;

    char* appIdFromEnv = getenv(APP_RUNTIME_INSTANCE_ID_ENV_VAR_NAME);

    return boost::lexical_cast<int>(appIdFromEnv);
}


TEST(StringConverison, Functions)
{
  // to string
  {
    EXPECT_THAT(to_string(11), "11");
    EXPECT_THAT(to_string(3301), "3301");
  }

  {
    // stl functions
    EXPECT_EQ(std::stoi("  77"), 77);
    EXPECT_EQ(std::stoi("  77.7"), 77);

    // std::stoi("-0x77") yields 0 because it parses only -0, interpreting
    // the x as the end of the numeric value found.
    EXPECT_EQ(std::stoi("-0x77"), 0);

    size_t idx{};

    EXPECT_EQ(std::stoi("  42 is the truth", &idx), 42);
    // idx of first unprocessed char
    EXPECT_EQ(idx, 4);

    // use base 16 and 8. 0x42 = 66
    EXPECT_EQ(std::stoi("  42", nullptr, 16), 66) << endl;

    // std::stol("789", &idx, 8) parses only the first character of the string
    // because 8 is not a valid character for octal numbers.

    EXPECT_EQ(std::stoi("789", &idx, 8), 7);
    // idx of first unprocessed char
    EXPECT_EQ(idx, 1);

    // man strtol()
    //
    // The string may begin with an arbitrary amount of white space (as deter‐
    // mined by isspace(3)) followed by a single optional '+' or '-' sign.  

    // If base is zero or 16, the string may then include a "0x" prefix, and
    // the number  will  be read in base 16; otherwise, a zero base is taken
    // as 10 (decimal) unless the next character is '0', in which case it  is
    // taken as 8 (octal).

    EXPECT_EQ(std::stol("0x12AB", nullptr, 0), 4779);
    EXPECT_EQ(std::stol("12AB", nullptr, 16), 4779);

    // *cxx-string-convert-to-string* *cxx-limits*
    long long ll = std::numeric_limits<long long>::max();
    EXPECT_EQ(std::to_string(ll), "9223372036854775807");

    // try to convert back and throws out_of_range
    EXPECT_THROW(std::stoi("9223372036854775807"), std::out_of_range);
  }
}

TEST(StringConverison, StringStream)
{
  // note that os, buffer, has all inputs from << and seek() moves writing pos.
  // *cxx-string-convert-to-string*

  // to string
  {
    ostringstream os;

    os << "decimal : " << 15 << hex << ", hex : " << 15 << endl;
    EXPECT_EQ(os.str(), "decimal : 15, hex : f\n");

    bitset<15> bit_set(5789);
    os << "float : " << 4.67 << ", bitset : " << bit_set << endl;
    EXPECT_EQ(os.str(), "decimal : 15, hex : f\nfloat : 4.67, bitset : 001011010011101\n");

    os.seekp(0);
    os << "octal : " << oct << 15;
    EXPECT_EQ(os.str(), "octal : 1715, hex : f\nfloat : 4.67, bitset : 001011010011101\n");
  }

  // to string
  {
    stringstream ss;
    vector<string> string_vector{};

    for(int i = 0; i < 4; ++i)
    {
      ss << "player " << i;
      string_vector.push_back(string(ss.str()));
      ss.str("");
    }

    EXPECT_THAT(string_vector, ElementsAre("player 0", "player 1", "player 2", "player 3"));
  }

  // to number
  {
    // The following lines read the integer x with the value 3 and the
    // floating-point f with the value 0.7 from the stringstream:

    int x{};
    float f{};

    istringstream is{"3.7"};

    // or
    // string input{"3.7"};
    // stringstream is(input);
    //
    // or
    // string input{"3.7"};
    // stringstream is;
    // is.str(input);

    is >> x >> f;

    ASSERT_THAT(x, Eq(3));
    ASSERT_THAT(f, FloatEq(0.7));
  }

  // to-number
  {
    stringstream is{"1 2 3 4"};
    int value{};
    vector<int> coll{};

    while (is >> value)
      coll.push_back(value);

    EXPECT_THAT(coll, ElementsAre(1,2,3,4));
  }
}

TEST(StringConverison, BooxtLexicalCast)
{
  EXPECT_THAT(boost::lexical_cast<std::string>(11), "11");
  EXPECT_THAT(boost::lexical_cast<std::string>(3301), "3301");

  EXPECT_THAT(boost::lexical_cast<int>("11"), 11);
  EXPECT_THAT(boost::lexical_cast<int>("3301"), 3301);
}


{cxx-boost-lexical-cast-peformance}
While we weren't looking Boost.Lexical_cast became "in most cases
boost::lexical_cast is faster than scanf, printf, std::stringstream". Yay for
upgrades - now there's no reason to use scanf for performance reasons.

http://www.boost.org/doc/libs/1_58_0/doc/html/boost_lexical_cast/
  performance.html#boost_lexical_cast.performance.tests_description

#include "PerfCounter.h"

#include <iostream>
#include <sstream>
#include <boost/lexical_cast.hpp>

int main(int argc,char** argv)
{
    PerfCounter counter;
    
    for(int i=0;i<10000;++i)
    {
        int out;
        sscanf("42","%d",&out);
    }
    counter.snap("scanf int");

    for(int i=0;i<10000;++i)
    {
        int out;
        std::stringstream ss("42");
        ss >> out;
    }
    counter.snap("stringstream int");

    for(int i=0;i<10000;++i)
    {
        int out = boost::lexical_cast<int>("42");
    }
    counter.snap("boost::lexical_cast<int>");
    std::cout << counter.dump() << std::endl;
}

// on debian

$ ./a.out 
Start -> scanf int took 2112us
scanf int -> stringstream int took 27859us
stringstream int -> boost::lexical_cast<int> took 910us
boost::lexical_cast<int> -> end took 0us


// about the above code

> you're transforming the same value on every iteration, source of which is a
> const - might this be a subject of some optimisation / cache related thing?

Yeah, I was just thinking the same thing. I wouldn't be too surprised if the
compiler replaces the lexical_cast call with a constant result. Try with a
random number converted to a string.

// on the host

Start -> scanf int took 22us
scanf int -> stringstream int took 45us
stringstream int -> boost::lexical_cast<int> took 3us
boost::lexical_cast<int> -> end took 0us

// on the device

Start -> scanf int took 46us
scanf int -> stringstream int took 392us
stringstream int -> boost::lexical_cast<int> took 11us
boost::lexical_cast<int> -> end took 4us

// on debian VM
snap: 1: start -> scanf int took 1050us
snap: 2: scanf int -> stringstream int took 7130us
snap: 3: stringstream int -> boost::lexical_cast<int> took 1922us
delete start
delete scanf int
delete stringstream int
delete boost::lexical_cast<int>

// on build host
snap: 1: start -> scanf int took 1917us
snap: 2: scanf int -> stringstream int took 7663us
snap: 3: stringstream int -> boost::lexical_cast<int> took 1488us
delete start
delete scanf int
delete stringstream int
delete boost::lexical_cast<int>


{to-number-narrow-convertion}
The `list-form-init` do 'not' allow `narrow-conversion` of 'built-in' type.

TEST(StringConverison, NarrowNumericConversion)
{
  // :464:12: warning: narrowing conversion of ‘5.0e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]
  //    int x{5.0};
  //            ^

  int x{5.0};
  EXPECT_EQ(x, 5);

  // I am cramming an int into a short. On my (Windows XP) system, an int is
  // four bytes and a short is two. A short is signed, which means that I have
  // 15 bits to represent a number with and, therefore, 32,767 is the maximum
  // positive value it can hold. The above piece of code goes off without a
  // hitch, but when I increment i by one, it goes beyond the range of a short:

  int i{32767};
  EXPECT_EQ(boost::numeric_cast<short>(i), 32767);
  ++i;
  EXPECT_THROW(boost::numeric_cast<short>(i), boost::bad_numeric_cast);
}

Worthwhile to use this property? Since unlikely to directly initialize an int
from a long double? However such initialization might happen unintentionally
in template. So YES.

  * use `single-form-of-init` whether it is built-in or class type
  * avoid vexing-parse


{cxx-string-print-char} *cxx-stream*

How to print char value itself but not a printable char? Use +saved_input trick.
http://www.cs.technion.ac.il/users/yechiel/c++-faq/print-char-or-ptr-as-number.html

// = 04 ======
// iv : 10
// id : 10
// cv : A
// cv : 65
// cv : 65

int t_string_04()
{
    int iv{10};
    double id{10.0};
    char cv{65};

    cout << "iv : " << iv << endl;
    cout << "id : " << id << endl;
    cout << "cv : " << cv << endl;
    cout << "cv : " << +cv << endl;
    cout << "cv : " << to_string(cv) << endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-string-iterator

A string is an ordered collection of characters. As a consequence, the C++
standard library provides an interface for strings that lets you use them as
STL containers. 

String iterators are random-access iterators. The exact type is implementation
defined, but string iterators are often defined simply as ordinary pointers.

<ex> algorithm-search, algorithm-transform
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(int argc, char* argv[])
{
    // create a string
    string s("The zip code of Braunschweig in Germany is 38100");
    cout << "original: " << s << endl;

    // to lowercase
    transform( s.cbegin(), s.cend(), s.begin(),
            [] (char c) {
            return tolower(c);
            });
    cout << "lowered : " << s << endl;

    // to uppercase
    transform( s.cbegin(), s.cend(), s.begin(),
            [] (char c) {
            return toupper(c);
            });
    cout << "uppered : " << s << endl;

    // search case-insensitive
    string g{"Germany"};
    string::const_iterator pos;

    pos = search( s.cbegin(), s.cend(),   // source string
            g.cbegin(), g.cend(),         // string to search
            [](char c1, char c2) {
            return toupper(c1) == toupper(c2);
            });
    if( pos != s.cend() )
    {
        cout << "substring \"" << g << "\" found at index "
            << pos - s.cbegin() << endl;
    }
}

original: The zip code of Braunschweig in Germany is 38100
lowered : the zip code of braunschweig in germany is 38100
uppered : THE ZIP CODE OF BRAUNSCHWEIG IN GERMANY IS 38100
substring "Germany" found at index 32


<ex> algo-unique
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(int argc, char* argv[])
{
    // create constant string
    const string hello("Hello, how are you?");

    string s( hello.cbegin(), hello.cend() );

    for( char c : s )
        cout << c;

    cout << endl;

    // reverse a string
    reverse( s.begin(), s.end() );
    cout << "reversed     : " << s << endl;

    // sort
    sort( s.begin(), s.end() );
    cout << "sorted       : " << s << endl;

    // remove duplicates
    s.erase( unique( s.begin(), s.end() ), s.end() );
    cout << "no duplicates: " << s << endl;
}

Hello, how are you?
reversed     : ?uoy era woh ,olleH
sorted       :    ,?Haeehlloooruwy
no duplicates:  ,?Haehloruwy


<ex> algo-unique:

ForwardIterator unique (ForwardIterator beg, ForwardIterator end) 
ForwardIterator unique (ForwardIterator beg, ForwardIterator end, BinaryPredicate op)

The first form removes from the range [beg,end) all elements that are equal to
the previous elements. Thus, only when the elements in the sequence are
'sorted', or at least when all elements of the same value are adjacent, does it
remove all duplicates.

The second form removes all elements(elem) that follow an element e and for
which the binary predicate op(e,elem) yields true. 

#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main(int argc, char* argv[])
{
  // source data
  list<int> coll{ 1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4 };

  PRINT_ELEMENTS(coll);

  // remove elements if there was a previous greater element
  coll.erase (unique (coll.begin(), coll.end(), greater<int>()),
      coll.end());
  PRINT_ELEMENTS(coll);
}

1 4 4 6 1 2 2 3 1 6 6 6 5 7 5 4 4
1 4 4 6 6 6 6 7
      ^

The first 6(e) is greater than the following(elms) 1, 2, 2, 3, and 1, so all
these elements are removed.

In other words, the predicate is not used to compare an element with its
predecessor; the element is compared with the previous element(e) that was not
removed

<example>
Uses back inserters to read the standard input into a string:

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <locale>

using namespace std;

int main(int argc, char* argv[])
{
  string input;

  // do not skip whitespaces
  cin.unsetf(ios::skipws);

  // read all chars while compressing whitespaces
  const locale &loc(cin.getloc());
  unique_copy( istream_iterator<char>(cin), istream_iterator<char>(),
      back_inserter(input),
      [=] ( char c1, char c2 ) {
        return isspace(c1, loc) && isspace(c2, loc);
        });

  cout << input;
}


   ,?Haeehlloooruwy
 ,?Haeehlloooruwy

<Q> why still duplicates?


={============================================================================
*kt_dev_cxx_0000* cxx-sp-raii cxx-raii

{resource-acquisition-is-initialization} {resource-managing-class}
EC++13. Why RAII? When use dynamic resource, client is fully resposible for
releasing it after use but it is very difficult to do `bookkeeping` and
problems are:

o Very tricky to ensure that reference lifetime and the lifetime of the objects
  they refer to match, especially when multiple pointers refer to the same
  object.

    o When the objects outlives, means "resource leak". 

    o When the references outlives, means *cxx-dangling-reference* 

        o "double free" that means to try to release what it do not own. For
          example, passing pointers via function calls or between components. 

        o "invalid access" to objects which are released already. 

o Interrupted code path due to exception. the usual path is interrupted and
  may cannot release it as expected.

With *cxx-raii* such as smart poitners, good things are: 

o Make resource bookkeeping easier.

o Can minimize client's burden to use resource properly. For example, raii
  with deleter.

// * Support sharing resources. note that this is from smart pointers but not
// from RAII.


The exception problem:

void f()
{
  // createInvestment() is `cxx-pattern-factory-function` that returns a pointer to
  // dynamically created resource or derived class. client must delete it after
  // use

  Investment* pInv = createInvestment();

  // The problem is code that throws an exception that is not caught inside f.
  // may not reach to delete statement

  delete pInv;
}

How about using catch? 

void f()
{
  try {
    Investment* pInv = createInvestment();
  }
  catch( ... ) {
    delete pInv;
    throw;           // propagate exception to caller of f. rethrow.
  }

  delete pInv;
}

This approach has duplicated clean-up code. How to improve this? 


{cxx-raii} <raii-auto-ptr-approach> unique_ptr
Approaches to implement raii.

void f()
{
  std::auto_ptr<Investment> pInv( createInvestment() );

  // NO need to concern about freeing resource regardless of how control leaves
  // a block 
}


*cxx-raii*

  Use resource managing class by putting reference(resource) 'inside' object
  and use the fact that dtor is called automatically when object is destroyed;
  use resource-managing-class object lifetime. As soon as get resource,
  initialize a object. How? In a 'constructor' and hence called raii.

  C++PL

  RAII, allows us to eliminate “naked new operations,” that is, to avoid
  allocations in general code and keep them buried inside the implementation
  of well-behaved abstractions. Similarly, “naked delete operations” should be
  avoided. Avoiding naked new and naked delete makes code far less error-prone
  and far easier to keep free of resource leaks


Acquire and initialize a resource-managing-class in the same statement.
reference should be 'encapsulated' in a object, resouce-managing-class, but
raii do not exist to encapsulate resource but to 'prevent' leak.

However, auto_ptr is not the best way to manage all dyn resources since
containers of auto_ptr aren't allowed. Use *cxx-sp-unique* instead.


<raii-shared-ptr-approach>
Returning `shared_ptr` from a `factory-function` is a better way that supports
normal copying than auto_ptr. 

// use the fixed type, Foo that's the underlying object.

std::shared_ptr<Foo> factory(T arg)
{
  return make_shared<Foo>(arg);
}

void use_factory(T arg)
{
  shared_ptr<Foo> p = factory(arg);
  // use p and deleted automatically.
}


{raii-for-resource-using-own-interface}
EC++14. There should be 'own' raii class for resource that uses own interface
to create and delete it because cannot use delete operator on it.

<ex> `cxx-auto-lock` 
void lock(Mutex* pm);      // int pthread_mutex_lock( pthread_mutex_t *mptr); 
void unlock(Mutex* pm);

class Lock {
  public:
    'explicit' Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};


// client use

Mutex m;    // pthread_mutex_t m;
...
function()
{
  Lock ml(&m);
  ...
}


<case> 
AUTOLOCK example. This is a case example seen in the code:

class CCAutoLock
{
  private:
    PCMutex* m_mutex;
  public:
    CCAutoLock(PCMutex* mutex) { m_mutex = mutex; m_mutex->Lock(); };
    ~CCAutoLock() { m_mutex->Unlock(); };
};

static PCMutex* g_debug_mutex;
#define AUTOLOCK() CCAutoLock lock(&g_debug_mutex)

void func()
{ 
  AUTOLOCK();
  ...
}


<ex>
When there is a nested call tree used AUTOLOCK, will the value of lock be
maintained? That is the lock of func1 in the below example will BE
VALID/LOCKED when func3 gets run? Will do. However, if all three uses the same
mutex then deadlock.

#include <iostream>

using std::cout; using std::endl;

class ALOCK {
  private:
    int m_num;
  public:
    ALOCK(int val):m_num(val) { cout << "ctor: ALOCK" << m_num << endl; }
    ~ALOCK() { cout << "dtor: ALOCK: " << m_num << endl; }
};

int func3()
{
  ALOCK LOCK(3);

  std::cout << "func 3" << std::endl;

  return 1;
}

int func2()
{
  ALOCK LOCK(2);

  std::cout << "func 2" << std::endl;

  return func3();
}

int func1()
{
  ALOCK LOCK(1);

  std::cout << "func 1" << std::endl;

  return func2();
}

int main()
{
  std::cout << "--{ main " << std::endl;

  func1();

  std::cout << "--} main " << std::endl;
}

Expected output?

--{ main
ctor: ALOCK1
func 1
ctor: ALOCK2
func 2
ctor: ALOCK3
func 3
dtor: ALOCK: 3
dtor: ALOCK: 2
dtor: ALOCK: 1
--} main 


<ex-window-handle> MEC++09.
void displayInfo(const Information& info)
{
  WINDOW_HANDLE w ( createWindow() );

  // display info in window w and exception can happen.

  destoryWindow(w);
}

class WindowHandle {
  public:
    WindowHandle( WINDOW_HANDLE handle ) : w(handle) {}
    ~WindowHandle() { destoryWindow(w); }

    // conversion-op
    operator WINDOW_HANDLE() { return w; }

  private:
    WINDOW_HANDLE w;

    // `cxx-preventing-copy`
    WindowHandle( const WindowHandle& );
    WindowHandle& operator=( const WindowHandle& );
};

void displayInfo(const Information& info)
{
  WindowHandle w(createWindow());

  // display info in window w and exception can happen.

  // displayWindow(w); coversion-op runs to convert WindowHandle to WINDOW_HANDLE

  // destoryWindow(w);
}


<ex>
For example, if your object is an array allocated with new[], you have to
define that the cleanup performs a delete[]. This show that smart pointer is
useful to lessen client's burden since this can be done in smart pointer so
client no need to know; unique_ptr supports delete[] but shared_ptr don't so
need to provide a deleter. CPR 479


{raii-and-two-cautions}
The raii is great but there are two cautions when use raii.

o When use resources which has own interface such as mutex and db connection, it
  can raise exception in destructor. Since raii uses destructor, it can cause
  the problem is described in *cxx-exception-in-dtor*

o Acquire and initialize a raii in the same statement. In other words, use
  constructor. If not, can be a problem as described in EC++17.
  `cxx-evaluation-order`

  processWidget(std::shared_ptr<Widget>( new Widget ), priority());
  
  The problem is that there is no order in evaluating the arguments between
  new, shared_ptr constructor, and priority() call. 
    
  shared_ptr ctor is also under evaluation order here. So if complier reorder
  calls as new, priority, and shared_ptr and priority raise exception then
  raii is broken. Means newed pointer will be lost. The better way is:

  std::shared_ptr<Widget> pw( new Widget );
  processWidget( pw, priority() );


{raii-and-copy-support}
EC++14. What should happen when a Lock object, more generally raii object, is
'copied' or 'assigned'? There are four approaches depending on the type of
resource.

o No copying
 
Likely to be true for Lock. See `cxx-preventing-copy` So,

class Lock: private Uncopyable {
  ...
};


o Reference counting underlying resources

By using shared_ptr with delete, do not need to concern about clean up. 

<raii-vs-shared-pointer>
This is a decision point; use own raii and concern about copy OR use
shared_ptr with deleter and don't concern about copy. Here, use
*cxx-sp-delete* to use unlock instead of default delete.

class Lock {
  public:
    explicit Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};

To:

class Lock {
  public:
    explicit Lock( Mutex* pm )
      :mutexPtr( pm, unlock )    // *cxx-sp-delete*
      {  
          // to get law pointer assuming this is C interface
          lock( mutexPtr.get() );
      }

  private:
    std::shared_ptr<Mutex> mutexPtr;
};

Set deleter using shared_ptr ctor in ctor init list. No longer declares a
destructor.


o Copy the underlying resource

This is *cxx-valuelike* such as string class which uses heap for characters.
Copying the resource managing object should also copy the resource it wraps.
*cxx-deep-copy*


o Transfer ownership of underlying resource

This is unique_ptr. Only one raii refers to a raw resource and when raii is
copied ownership of the resource is transfered. 


={============================================================================
*kt_dev_cxx_0000* cxx-sp-shared *cxx-sp-shared-from-this*

This implements the concept of `cxx-sp-shared-ownership` so that the object and
its associated resources get released whenever the last reference to it gets
destroyed. To perform this task in more complicated scenarios, helper classes,
such as `weak_ptr`, `bad_weak_ptr`, and `enable_shared_from_this` are provided.

o #include<memory> 
o The `default initialized holds a nullptr` *cxx-sp-ctor-empty*
o The template and use "T" but not "T*".

shared_ptr<T> plist;
shared_ptr<list<int>> plist;

<ex>

MEC++29.

Once an object is allocated by calling new, it's crucial to keep track of who
owns that object because the owner - and only the owner - is responsible for
calling delete on it. But ownership can be transferred from object to object as
a program runs by passing pointers as parameters, for example, so keeping track
of an object's ownership is hard work. Classes like auto_ptr can help with this
task, but experience has shown that most programs still fail to get it right. 

Reference counting eliminates the burden of tracking object ownership, because
when an object employs reference counting, it owns itself. When nobody is using
it any longer, it destroys itself automatically. Thus, reference counting
constitutes a simple form of garbage collection.

The bookkeeping is "who is allowed to delete what". 

// problem

class String {
  public:
    String( const char *value="" );
    String& operator=( const String& rhs );
    ...
  private:
      char* data;
};

// handles self-assign but not exception safe
String& String::operator=( const String& rhs )
{
  if( this == &rhs ) return *this;

  delete[] data;
  data = new char[ strlen(rhs.dat) +1 ];
  strcpy( data, rhs.data );
  return *this;
}

String a, b, c, d;
a = b = c = d = "Hello";

With this implementation, this assignment means that all a, b, c, d point
different copies:

a -> "Hello"
b -> "Hello"
c -> "Hello"
d -> "Hello"

How can we make those share one copy of Hello?

namespace cxx_code *cxx-sp-code*
{
  // bits/shared_ptr_base.h @759

  template<_Lock_policy _Lp>  // @442
    class __shared_count
    {
      public:
        constexpr __shared_count() noexcept : _M_pi(0)
        { }

        template<typename _Ptr>
          explicit
          __shared_count(_Ptr __p) : _M_pi(0)
          {
            __try
            {
              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
            }
            __catch(...)
            {
              delete __p;
              __throw_exception_again;
            }
          }

        ~__shared_count() noexcept
        {
          if (_M_pi != 0)
            _M_pi->_M_release();
        }

        __shared_count(const __shared_count& __r) noexcept
          : _M_pi(__r._M_pi)
          {
            if (_M_pi != 0)
              _M_pi->_M_add_ref_copy();
          }

        __shared_count&
          operator=(const __shared_count& __r) noexcept
          {
            _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
            if (__tmp != _M_pi)
            {
              if (__tmp != 0)
                __tmp->_M_add_ref_copy();
              if (_M_pi != 0)
                _M_pi->_M_release();
              _M_pi = __tmp;
            }
            return *this;
          }

        void
          _M_swap(__shared_count& __r) noexcept
          {
            _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
            __r._M_pi = _M_pi;
            _M_pi = __tmp;
          }

        // *cxx-sp-use-count*
        // looks like that each sp holds cxx-sp-use-count

        long
          _M_get_use_count() const noexcept
          { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

        bool
          _M_unique() const noexcept
          { return this->_M_get_use_count() == 1; }

        // Friend function injected into enclosing namespace and found by ADL
        friend inline bool
          operator==(const __shared_count& __a, const __shared_count& __b) noexcept
          { return __a._M_pi == __b._M_pi; }

      private:
        _Sp_counted_base<_Lp>*  _M_pi;
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
      public:
        typedef _Tp   element_type;

        *cxx-sp-ctor-empty*
        constexpr __shared_ptr() noexcept
          : _M_ptr(0), _M_refcount()
          { }

        template<typename _Tp1>
          explicit __shared_ptr(_Tp1* __p)
          : _M_ptr(__p), _M_refcount(__p)
          {
            __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)
              static_assert( sizeof(_Tp1) > 0, "incomplete type" );
            __enable_shared_from_this_helper(_M_refcount, __p, __p);
          }

        __shared_ptr(const __shared_ptr&) noexcept = default;
        __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
        ~__shared_ptr() = default;

        template<typename _Tp1>
          __shared_ptr&
          operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
          {
            _M_ptr = __r._M_ptr;
            _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw
            return *this;
          }

        // *cxx-sp-reset*
        void
          reset() noexcept
          { __shared_ptr().swap(*this); }

        template<typename _Tp1>
          void
          reset(_Tp1* __p) // _Tp1 must be complete.
          {
            // Catch self-reset errors.
            _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr);
            __shared_ptr(__p).swap(*this);
          }

        // Allow class instantiation when _Tp is [cv-qual] void.
        typename std::add_lvalue_reference<_Tp>::type
          operator*() const noexcept
          {
            _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);
            return *_M_ptr;
          }

        _Tp*
          operator->() const noexcept
          {
            _GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);
            return _M_ptr;
          }

        _Tp*
          get() const noexcept
          { return _M_ptr; }

        // *cxx-sp-bool*
        explicit operator bool() const // never throws
        { return _M_ptr == 0 ? false : true; }

        bool
          unique() const noexcept
          { return _M_refcount._M_unique(); }

        long
          use_count() const noexcept
          { return _M_refcount._M_get_use_count(); }

        void
          swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
          {
            std::swap(_M_ptr, __other._M_ptr);
            _M_refcount._M_swap(__other._M_refcount);
          }

        _Tp*                  _M_ptr;         // Contained pointer.
        __shared_count<_Lp>   `_M_refcount`;    // Reference counter.
    };


  // /usr/include/c++/4.9/bits/shared_ptr.h

  // note: 
  // no other operators so use operators in bits/shared_ptr_base.h
  // no member data, no dtor

  /**
   *  @brief  A smart pointer with reference-counted copy semantics.
   *
   *  The object pointed to is deleted when the last shared_ptr pointing to
   *  it is destroyed or reset.
   */
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
  {

    public:
      /**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       */
      *cxx-sp-ctor-empty*
      constexpr shared_ptr() noexcept
        : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;

      /**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
       *  @param  __p  A pointer that is convertible to element_type*.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.
       */
      template<typename _Tp1>
        explicit shared_ptr(_Tp1* __p)
        : __shared_ptr<_Tp>(__p) { }

      /**
       *  @brief  Construct an empty %shared_ptr.
       *  @param  __p  A null pointer constant.
       *  @post   use_count() == 0 && get() == nullptr
       */
      constexpr shared_ptr(nullptr_t __p) noexcept
        : __shared_ptr<_Tp>(__p) { }


      /**
       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r
       *          and stores a copy of the pointer stored in @a __r.
       *  @param  __r  A weak_ptr.
       *  @post   use_count() == __r.use_count()
       *  @throw  bad_weak_ptr when __r.expired(),
       *          in which case the constructor has no effect.
       */
      template<typename _Tp1>
        explicit shared_ptr(const weak_ptr<_Tp1>& __r)
        : __shared_ptr<_Tp>(__r) { }

      *cxx-sp-from-unique*
      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 2399. shared_ptr's constructor from unique_ptr should be constrained
      template<typename _Tp1, typename _Del>
        shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
        : __shared_ptr<_Tp>(std::move(__r)) { }


      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Tp1>
        shared_ptr&
        operator=(const shared_ptr<_Tp1>& __r) noexcept
        {
          this->__shared_ptr<_Tp>::operator=(__r);
          return *this;
        }

      /**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
       *          and the deleter @a __d.
       *  @param  __p  A pointer.
       *  @param  __d  A deleter.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  __shared_ptr will release __p by calling __d(__p)
       */
      template<typename _Tp1, typename _Deleter>
        shared_ptr(_Tp1* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
  };

  // *cxx-sp-make-shared* is function template but have to specify type to point:
  // *cxx-template-explicit-argument*
  //
  // shared_ptr<string> pNico = make_shared<string>("nico");

  /**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __args  Arguments for the @a _Tp object's constructor.
   *  @return A shared_ptr that owns the newly created object.
   *  @throw  std::bad_alloc, or an exception thrown from the
   *          constructor of @a _Tp.
   */
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
          std::forward<_Args>(__args)...);
    }

} // namespace


{cxx-sp-shared-operations}

// Decrements p's reference count and increments q's count
p = q;          

// Return true if p.use_count() is 1
p.unique();

// May be slow operation, intended for *cxx-debug* purpose
p.use_count();

// Swap pointers in p and q
swap(p, q);
p.swap(q);


<ex>

// CXXSLR 5.2 Smart Pointers

TEST(SmartPointerShared, Example)
{
  std::shared_ptr<std::string> pNico{new std::string("nico")};
  std::shared_ptr<std::string> pJutta{new std::string("jutta")};

  // capitalise the first, cxx-string-replace

  (*pNico)[0] = 'N';
  pJutta->replace(0, 1, "J");

  // put them multiple times in a coll

  std::vector<std::shared_ptr<std::string>> whoMadeCoffee;
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);

  {
    std::ostringstream os;
    for(auto const &sp : whoMadeCoffee)
      os << *sp << ",";

    EXPECT_THAT(os.str(), "Jutta,Jutta,Nico,Jutta,Nico,");
  }

  // overwrite name

  *pNico = "Nicolai";

  {
    std::ostringstream os;
    for(auto const &sp : whoMadeCoffee)
      os << *sp << ",";

    EXPECT_THAT(os.str(), "Jutta,Jutta,Nicolai,Jutta,Nicolai,");
  }

  EXPECT_THAT(whoMadeCoffee[0].use_count(), 4);
}


{cxx-sp-shared-init} {cxx-sp-make-shared}

// Use args to initialize the object of type T
make_shared<T>(args);

shared_ptr<T> sp(new X(...)); 
  
performs two allocations: one for X and one for the control block used, for
example, by the shared pointer to manage its use count. 
  
Using make_shared<T>(...) instead is considerably faster, performing only one
allocation, and safer because a situation where the allocation of X succeeds
but the allocation of the control block fails cannot occur: do alloc and bind
at the same time.

TEST(SmartPointerShared, Ctors)
{
  {
    shared_ptr<string> pNico(new string("nico"));           // OK
  }
  {
    shared_ptr<string> pNico{new string("nico")};           // OK
  }
  {
    shared_ptr<string> pNico = make_shared<string>("nico"); // OK
  }

  // // NO since requires cxx-copy-init but shared ptr's ctor are explicit 
  // {
  //   shared_ptr<string> pNico = new string("nico");
  // }

  // // NO
  // {
  //   shared_ptr<int> p (new int(42));
  //
  //   // cxx.cpp:1739:5: error: no match for ‘operator=’ (operand types are ‘std::shared_ptr<int>’ and ‘int*’)
  //   p = new int(1024);                      
  // }

  // points to '9999999999'
  shared_ptr<string> p4 = make_shared<string>(10, '9');

  // points to empty vector<string>
  auto p6 = make_shared<vector<string>>();
}


<ex>
boost::make_shared<VirtualBinIPCSrc>
  (dispatcher, binImplFactory->create());

make_shared() calls VirtualBinIPCSrc ctor and "binImplFactory->create()"
returns a shared pointer, temporary, then which is copy ctor'ed to the binImpl
member. Now shared pointer is in a safe hand.

// shared_ptr copy ctor
shared_ptr(const shared_ptr&) noexcept = default;

boost::shared_ptr<VirtualBin> create()
{ return bin; }

class ZINC_EXPORT VirtualBinIPCSrc
{
    VirtualBinIPCSrc::VirtualBinIPCSrc(
            const boost::shared_ptr<NS_ZINC::Dispatcher>& dispatcher,
            const boost::shared_ptr<VirtualBin>& binImpl)
        : binImpl(binImpl)
    {
    }

    boost::shared_ptr<VirtualBin> binImpl;
};


<use-count-on-make-shared>
What's the use_count when creates make_shared?

int main()
{
  shared_ptr<string> spstr = make_shared<string>("this is string");

  cout << "spstr.count() : " << spstr.use_count() << endl;
}

spstr.count() : 1

This question comes from:

bsk.add_item( make_shared<Quote>("123", 45) );
// void add_item( const std::shared_ptr<Quote>& sale);


{cxx-sp-reset}
Why not assignment instead of using reset when assign a shared pointer with a
new resource? 

  // * Think that operator=() is to decrease a reference counter of left and to
  //   increase the one of right. However, cannot increase a count of new
  //   objects. 

o This is when set shared pointer with new resource and assignment works
  between shared pointers.

p = nullptr;
p.reset();
p.reset(q);
p.reset(q, d);

If p is the only `shared_ptr` pointing at its object, reset frees p's existing
object. If the optional built-in pointer q is passed, makes p points to q,
  otherwise makes p null. If d is supplied, will call d to free q otherwise
  use delete to free q.

After all, `reset()` decrease count of left and set shared pointer with the
given pointer or `nullptr`.

The reset can be used to bind a pointer with shared pointer later.

shared_ptr<string> pNico4;
pNico4.reset(new string("nico"));

TEST(SmartPointerShared, Reset)
{
  // 1. sp, shared structure, and referenced object are separate entity.
  //
  // 2. although shared count is 2, q.use_count() return 0 since cxx-sp-code
  // returns 0 when sp is empty(null)
  //
  // EXPECT_THAT(q.use_count(), 0);

  {
    auto p = make_shared<int>(42);

    // use++
    auto q(p);
    auto r(p);

    EXPECT_THAT(p.use_count(), 3);
    EXPECT_THAT(q.use_count(), 3);

    q.reset();

    EXPECT_THAT(p.use_count(), 2);
    EXPECT_THAT(q.use_count(), 0);
    EXPECT_THAT(r.use_count(), 2);
  }
  {
    auto p = make_shared<int>(42);

    // use++
    auto q(p);
    auto r(p);

    EXPECT_THAT(p.use_count(), 3);
    EXPECT_THAT(q.use_count(), 3);

    // same as reset()
    q = nullptr;

    EXPECT_THAT(p.use_count(), 2);
    EXPECT_THAT(q.use_count(), 0);
    EXPECT_THAT(r.use_count(), 2);
  }
  {
    auto p = make_shared<int>(42);

    // use++
    auto q(p);
    auto r(p);

    EXPECT_THAT(p.use_count(), 3);
    EXPECT_THAT(q.use_count(), 3);

    // multiple reset() are fine
    q.reset();
    q.reset();
    q.reset();
    q.reset();

    EXPECT_THAT(p.use_count(), 2);
    EXPECT_THAT(q.use_count(), 0);
    EXPECT_THAT(r.use_count(), 2);
  }
}


*cxx-sp-get* <access-to-pointee>

T* get() const noexcept; (until C++17)

The shared_ptr provide `only` operators * and ->. Pointer arithmetic and
operator[] are not provided. 

When shared_ptr points to memory block such as shm example above, to access
the memory, you have to use get(), which yields the internal pointer wrapped
by shared_ptr to provide the full pointer semantics:

smp.get()[i] = i*42;

Thus, get() provides an alternative of calling:

(&*smp)[i] = i*42;

shared_ptr<vector<T>> pvec;
T var = (*pvec)[index];          // () is necessary since [] is higher than *


{cxx-sp-shared-check-users} do not rely on use_count()
To check how many users are. Return bool on whether there is the only user of
this sp.

sp.unique();

Often to check whether we are the only user before changing the underlying
object:

if( !p.unique() )
   p.reset( new string(*p) );    // we are not alone. allocate a new copy
*p += newValue;                  // we are the only pointer, okay to change


note: SURE?
use_count() may not be reliable since C++P 453 reads "may be a slow operation,
intended primarily for debugging purpose"


<copy-shared-ptr>

TEST(SmartPointerShared, Copy)
{
  auto p = make_shared<int>(42);

  // p.use++
  auto q(p);

  // all prints 2
  EXPECT_THAT(p.use_count(), 2);
  EXPECT_THAT(q.use_count(), 2);

  EXPECT_THAT(*p, 42);
  EXPECT_THAT(*q, 42);

  auto r = make_shared<int>(52);

  // q.use++ and r.use--. destroies a object which r pointed. 
  r = q;

  // all prints 3
  EXPECT_THAT(p.use_count(), 3);
  EXPECT_THAT(q.use_count(), 3);
  EXPECT_THAT(r.use_count(), 3);
}


<cxx-sp-cast>
CLR Table 5.4

static_pointer_cast(sp)     static_cast<> semantic for sp
dynamic_pointer_cast(sp)    dynamic_cast<> semantic for sp
const_pointer_cast(sp)      const_cast<> semantic for sp

The cast operators allow casting a pointer to a different type. The semantic is
the same as the corresponding operators, and the result is another shared
pointer of a different type. Note that using the ordinary cast operators is not
possible, because it results in undefined behavior:

shared_ptr<void> sp(new int);                 // shared pointer holds a void*
                                              // internally
...
shared_ptr<int>(static_cast<int*>(sp.get()))  // ERROR: undefined behavior
static_pointer_cast<int*>(sp)                 // OK


<ex> <cxx-operator-member-access> *cxx-ex-strblob-example*
The deference(*) and arrow(->) operator used in classes that represent
iterators and in smart pointer.

The arrow must be a member.

class StrBlobPtr {
  public:
    std::string &operator*() const
    {
      // p is shared_ptr of underlying shared vector
      auto p = check( curr, "dereference past end");
      return (*p)[curr];    // () is necessary since [] is higher than *
    }
    std::string *operator->() const
    {
      return & this->operator*();
    }
};

The arrow operator delegate the real work by calling the deference operator
and returning the 'address' of the element returned by that operator.

shared_ptr<> p;

p->mem is synonym for (*p).mem

<ex>
item is iterator(pointer) and *item is itself is shared_ptr. Hence to access
member (*item)->mem since * has lower.

    multiset<std::shared_ptr<Quote>, comp> items;

    for (auto item = items.cbegin(); item != items.cend();
            item = items.upper_bound(*item))
    {
        os << (*item)->isbn() << " occurs, "
            << endl;
    }

<ex>
For array:

*(parray+1) is synomym for parray[1]

the same hold for shared_ptr? No. array is special and not vector.

    shared_ptr<vector<string>> sp(new vector<string>{"one", "two", "three"});

    // OK
    cout << "0: " << (*sp)[0] << endl;
    
    // OK
    cout << "0: " << *(sp->begin()+0) << endl;

    // ERROR
    cout << "0: " << *(*sp+0) << endl;


={============================================================================
*kt_dev_cxx_0000* cxx-sp-weak

The weak pointer is `checked pointer class.` Two points:

o The weak_ptr `do not increase/participate in the reference count` of
  shared_ptr and won't affect the lifetime of the object. 

o Because the object might no longer exist, cannot use a weak_ptr to access
  its object directly.


<cxx-sp-weak-case>
The shared_ptrs are provided to automatically release resources associated
with objects no longer needed. However, under certain circumstances, this
behavior doesn't work or is not what is intended:

o One example is `cyclic references` If two objects refer to each other using
  shared_ptrs, and you want to release the objects and their associated
  resource if no other references to these objects exist, shared_ptr won't
  release the data, because the use_count() of each object is still 1. You
  might want to use ordinary pointers in this situation, but doing so requires
  explicitly caring for and managing the release of associated resources.

  *cxx-dangling-reference*
o Another example occurs when you explicitly `want to share but not own` an
  object. Thus, you have the semantics that the lifetime of a reference to an
  object `outlives the object it refers to.` 
  
  Here, shared_ptrs would never release the object, and 
  
  ordinary pointers might not notice that the object they refer to is not
  valid anymore, which introduces the risk of accessing released data.

  *cxx-cache*
o Another use case pointed out by this answer on Stack Overflow is that
  weak_ptr can be used to maintain a cache. The data may or may not have been
  cleared from the cache, and the weak_ptr references this data.


<cxx-sp-weak-operations>
o This class requires a shared pointer to get created.

  Whenever the last shared pointer owning the object loses its ownership, any
  `weak pointer automatically becomes empty.` 
  
o Cannot use operators * and -> to access a referenced object of a weak_ptr
  directly. Instead, you `have to create a shared pointer out of it.`
  
  Thus, besides default and copy constructors, class weak_ptr provides only a
  constructor taking a shared_ptr.

o The default constructor creates an empty weak pointer. a weak_ptr can be
  empty, which is the case if it is not initialized by a shared_ptr or if the
  last owner of the corresponding object was deleted.

o Creating a shared pointer out of a weak pointer checks whether there is
  (still) an associated object. If not, this operation will throw an exception
  or `create an 'empty' shared pointer`; what exactly happens depends on the
  operation used.

o While dealing with the referenced object, the shared pointer can't get
  released since shared pointer was created out of weak pointer.

As a consequence, class weak_ptr provides only a small number of operations:

*cxx-sp-reset*

weak_ptr<T> w(sp);
w.reset();
w.use_count();
w.expired();
w.lock();

namespace cxx_code *cxx-sp-weak-code*
{
  template<_Lock_policy _Lp>
    class __weak_count
    {
      // *cxx-sp-use-count*
      long
        _M_get_use_count() const noexcept
        { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
    };

  // /usr/include/c++/4.9/bits/shared_ptr_base.h @1338

  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      constexpr __weak_ptr() noexcept
        : _M_ptr(0), _M_refcount()
        { }

      template<typename _Tp1>
        __weak_ptr&
        operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
        {
          _M_ptr = __r._M_ptr;
          _M_refcount = __r._M_refcount;
          return *this;
        }

      long
        use_count() const noexcept
        { return _M_refcount._M_get_use_count(); }

      // *cxx-sp-weak-expired*

      bool
        expired() const noexcept
        { return _M_refcount._M_get_use_count() == 0; }

      _Tp*	 	 _M_ptr;         // Contained pointer.
      __weak_count<_Lp>  _M_refcount;    // Reference counter.
    };

  // /usr/include/c++/4.9/bits/shared_ptr.h

  /**
   *  @brief  A smart pointer with weak semantics.
   *
   *  With forwarding constructors and assignment operators.
   */
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
  {
    public:
      constexpr weak_ptr() noexcept
        : __weak_ptr<_Tp>() { }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
        weak_ptr(const weak_ptr<_Tp1>& __r) noexcept
        : __weak_ptr<_Tp>(__r) { }

      // *cxx-sp-weak-ctor*
      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
        weak_ptr(const `shared_ptr`<_Tp1>& __r) noexcept
        : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1>
        weak_ptr&
        operator=(const shared_ptr<_Tp1>& __r) noexcept
        {
          this->__weak_ptr<_Tp>::operator=(__r);
          return *this;
        }
  };

} // namespace


<ex>

TEST(SmartPointer, WeakNotInReferenceCount)
{
  {
    auto sp = make_shared<int>(42);

    // wp is created out of sp
    weak_ptr<int> wp(sp);

    // wp is not involved in reference of sp. since it's weak, creating wp
    // doesn't change the reference count of p
    EXPECT_THAT(sp.use_count(), 1);

    // sp is created out of wp. lock() checks whether the object to which the
    // weak_ptr points still exist
    if (auto p = wp.lock())
    {
      EXPECT_THAT(sp.use_count(), 2);
      EXPECT_THAT(wp.use_count(), 2);
    }

    // since p is only around in if
    EXPECT_THAT(sp.use_count(), 1);

    // cxx-error compile error
    // if (wp)
    //   std::cout << "wp is not null" << std::endl;
  }

  // Can explicitly convert a weak_ptr into a shared_ptr by using a
  // corresponding shared_ptr constructor. If there is no valid referenced
  // object, this constructor will throw a `bad_weak_ptr exception` 

  {
    auto sp = make_shared<int>(42);

    // wp is created out of sp
    weak_ptr<int> wp(sp);

    // wp is not involved in reference of sp
    EXPECT_THAT(sp.use_count(), 1);

    // sp is created out of wp
    shared_ptr<int> p(wp);
    if (p)
    {
      EXPECT_THAT(sp.use_count(), 2);
      EXPECT_THAT(wp.use_count(), 2);
    }

    EXPECT_THAT(sp.use_count(), 2);
  }

  // Can call expired(), which returns true if use_count() is zero, false
  // otherwise. This option is equivalent to checking whether use_count() is
  // equal to 0 but might be 'faster'.
  
  {
    auto sp = make_shared<int>(42);
    weak_ptr<int> wp(sp);

    // wp is not involved in reference of sp
    EXPECT_THAT(sp.use_count(), 1);

    sp = nullptr;

    // sp is gone and wp.lock() returns nullptr
    // because the last owner of the object released the object in the meantime
    // — lock() yields an empty shared_ptr.

    auto rp = wp.lock();

    EXPECT_THAT(wp.expired(), true);
    EXPECT_THAT(rp, nullptr);
  }

  // You can explicitly convert a weak_ptr into a shared_ptr by using a
  // corresponding shared_ptr constructor. If there is no valid referenced
  // object, this constructor will throw a bad_weak_ptr exception. 

  {
    auto sp = make_shared<int>(42);
    weak_ptr<int> wp(sp);

    // wp is not involved in reference of sp
    EXPECT_THAT(sp.use_count(), 1);

    sp = nullptr;

    // EXPECT_THROW(coll.pop(), ReadEmptyStack);
    try
    {
      std::shared_ptr<int> osp(wp);
    }
    catch(exception &e)
    {
      std::ostringstream os;
      os << e.what();
      EXPECT_THAT(os.str(), "bad_weak_ptr");
    }

    EXPECT_THAT(wp.expired(), true);
  }

  // assign sp later when use make_shared() directly 

  {
    weak_ptr<int> wp;

    EXPECT_THAT(wp.expired(), true);
    EXPECT_THAT(wp.use_count(), 0);

    // *cxx-error*
    // EXPECT_THAT(wp, nullptr);

    EXPECT_THAT(wp.lock(), nullptr);
    EXPECT_THAT(wp.use_count(), 0);

    wp = make_shared<int>(42);

    EXPECT_THAT(wp.expired(), true);
    EXPECT_THAT(wp.use_count(), 0);

    auto sp = wp.lock();

    // because the referenced object is already gone

    EXPECT_THAT(wp.expired(), true);
    EXPECT_THAT(wp.use_count(), 0);

    EXPECT_THAT(sp, nullptr);
  }

  {
    weak_ptr<int> wp;

    EXPECT_THAT(wp.expired(), true);
    EXPECT_THAT(wp.use_count(), 0);

    EXPECT_THAT(wp.lock(), nullptr);
    EXPECT_THAT(wp.use_count(), 0);

    auto sp = make_shared<int>(42);
    wp = sp;

    EXPECT_THAT(wp.expired(), false);
    EXPECT_THAT(wp.use_count(), 1);

    auto spwp = wp.lock();

    // because the referenced object is still around

    EXPECT_THAT(wp.expired(), false);
    EXPECT_THAT(wp.use_count(), 2);

    EXPECT_THAT(spwp, Not(nullptr));
  }
}


<ex> *cxx-sp-weak-ex*

namespace cxx_sp_weak_problem
{
  class Person
  {
    public:
      string name_;
      shared_ptr<Person> mother_;
      shared_ptr<Person> father_;
      vector<shared_ptr<Person>> kids_;

      Person(string const& name,
          shared_ptr<Person> mother = nullptr, shared_ptr<Person> father = nullptr)
        : name_(name), mother_(mother), father_(father)
      {}

      ~Person()
      { cout << "delete: " << name_ << endl; }
  };

  shared_ptr<Person> init_family(string const& name)
  {
    shared_ptr<Person> mom(new Person(name + "'s mom"));
    shared_ptr<Person> dad(new Person(name + "'s dad"));
    shared_ptr<Person> kid(new Person(name, mom, dad));

    mom->kids_.push_back(kid);
    dad->kids_.push_back(kid);

    return kid;
  }

} // namespace

/*
nico's family exists
- nico is shared 3 times
- name of 1st kid of nico's mom: nico
 
jim's family exists
- jim is shared 3 times
- name of 1st kid of jim's mom: jim
 
                                     mom, dad <---
                                               \  \
mom [ 0, 0, kids ]   dad [ 0, 0, kids ]   kid [ m, f, kids ]
               \ (shared or weak)   \
                -> kid               -> kid
 
Solution?
*/

TEST(SharedPointer, WeakCyclicReference)
{
  using namespace cxx_sp_weak_problem;

  // return kids, which is 'nico'
  shared_ptr<Person> p = init_family("nico");

  cout << "nico's family exists" << endl;
  cout << "- nico is shared " << p.use_count() << " times" << endl;
  cout << "- name of 1st kid of nico's mom: " 
    << p->mother_->kids_[0]->name_ << endl;

  // cxx-cross-reference
  // assign op decrease count of p but no one from nico family is deleted since
  // each has a reference to them.
  //
  // same for jim family.

  p = init_family("jim");

  cout << "jim's family exists" << endl;
  cout << "- jim is shared " << p.use_count() << " times" << endl;
  cout << "- name of 1st kid of jim's mom: " 
    << p->mother_->kids_[0]->name_ << endl;
}


namespace cxx_sp_weak_solution
{
  class Person
  {
    public:
      string name_;
      shared_ptr<Person> mother_;
      shared_ptr<Person> father_;

      // *cxx-sp-weak*
      // vector<shard_ptr<Person>> kids_;
      vector<weak_ptr<Person>> kids_;

      Person(string const& name,
          shared_ptr<Person> mother = nullptr, shared_ptr<Person> father = nullptr)
        : name_(name), mother_(mother), father_(father)
      {}

      ~Person()
      { cout << "delete: " << name_ << endl; }
  };

  shared_ptr<Person> init_family(string const& name)
  {
    shared_ptr<Person> mom(new Person(name + "'s mom"));
    shared_ptr<Person> dad(new Person(name + "'s dad"));
    shared_ptr<Person> kid(new Person(name, mom, dad));

    mom->kids_.push_back(kid);
    dad->kids_.push_back(kid);

    return kid;
  }

} // namespace

// As soon as we lose our handle into a kid created - either by assigning a new
// value to p or by leaving main() - the kid's object of the family loses its
// last owner, which has the effect that both parents lose their last owner. So
// 'all' objects, initially created by new, are deleted now so that their
// destructors get called since weak pointer don't increase count.

// [ RUN      ] SharedPointerWeak.CyclicReferenceSolution
// nico's family exists
// - nico is shared 1 times
// - name of 1st kid of nico's mom: nico
// delete: nico
// delete: nico's dad
// delete: nico's mom
// jim's family exists
// - jim is shared 1 times
// - name of 1st kid of jim's mom: jim
// delete: jim
// delete: jim's dad
// delete: jim's mom
// [       OK ] SharedPointerWeak.CyclicReferenceSolution (2 ms)

TEST(SharedPointer, WeakCyclicReferenceSolution)
{
  using namespace cxx_sp_weak_solution;

  // return kids, which is 'nico'
  shared_ptr<Person> p = init_family("nico");

  cout << "nico's family exists" << endl;
  cout << "- nico is shared " << p.use_count() << " times" << endl;
  cout << "- name of 1st kid of nico's mom: "; 

  // cout << p->mother_->kids_[0]->name_ << endl;
  cout << p->mother_->kids_[0].lock()->name_ << endl;

  p = init_family("jim");

  cout << "jim's family exists" << endl;
  cout << "- jim is shared " << p.use_count() << " times" << endl;
  cout << "- name of 1st kid of jim's mom: "; 

  // cout << p->mother_->kids_[0]->name_ << endl;
  cout << p->mother_->kids_[0].lock()->name_ << endl;
}

<ex>

/*
The problem:

In Fusion MW, PDM manages HDD resouce and provides APIs to clients. Various
clients blindly calls API to get or release HDD resouce. 


PDM server has own count to make call to HDD up(when count 0->1) or down(1->0)
based on number of calls from clients. Also, one client maintains own count to
make match between get and release call to FDM.

The problem is that the client which has own count get the count wrong and do
not make release call to PDM. This leaves PDM count one more and this prevents
HDD down when other clients tries to do. THis make HDD is on since when it's
supposed to be down to save power.

How about using smart pointers to this problem?
*/

TEST(SharedPointerWeak, ResourceManagerSolution)
{
  using namespace cxx_sp_weak_problem;

  ResourceManager rm;

  auto client1 = rm.get_resource();
  auto client2 = rm.get_resource();

  EXPECT_THAT(client1.use_count(), 2);

  std::cout << "clients use res..." << std::endl;

  client1->increase_count();
  client2->increase_count();
  client1->increase_count();

  EXPECT_THAT(client2->get_count(), 3);

  // finishes use of resource
  client1.reset();
  client2.reset();

  std::cout << "no client and res shall be released..." << std::endl;

  EXPECT_THAT(client1.use_count(), 0);

  // get resource again
  client1 = rm.get_resource();
  client2 = rm.get_resource();

  EXPECT_THAT(client1.use_count(), 2);

  std::cout << "clients use res..." << std::endl;

  client1->increase_count();
  client2->increase_count();
  client1->increase_count();

  EXPECT_THAT(client2->get_count(), 3);

  // finishes use of resource
  client1.reset();

  // but client2 still use resource
  // *cxx-sp-use-count*
  EXPECT_THAT(client1.use_count(), 0);

  EXPECT_THAT(client2.use_count(), 1);
  EXPECT_THAT(client2->get_count(), 3);

  // another client use the same resource
  auto client3 = rm.get_resource();
  client3->increase_count();
  client3->increase_count();
  EXPECT_THAT(client3->get_count(), 5);
}


={============================================================================
*kt_dev_cxx_0000* cxx-sp-exception

As with STL, boost do not raise exception when dereferencing.

namespace boost {
  template<class T> class shared_ptr {
    public:
      // never throws; only valid when T is not an array type
      T & operator*() const; 
      // never throws; only valid when T is not an array type
      T * operator->() const; 
  };
};


={============================================================================
*kt_dev_cxx_0000* cxx-sp-unique cxx-auto-ptr

`no copy or assign support` that implements the concept of `exclusive ownership`

This was `auto_ptr` before *cxx-11* and it has only one user because
`no-ordinary-copy-and-assign-supported`. Only `one unique_ptr` at a time can
point to a given object. So limit the use and transfer ownerships.

In contrast to shared pointers, a `minimum space and time overhead` is the
focus of this class.

namespace cxx-code *cxx-sp-code* *cxx-sp-delete*
{
  // /usr/include/c++/4.9/bits/unique_ptr.h

  /// Primary template of default_delete, used by unique_ptr
  template<typename _Tp>
    struct default_delete
    {
      /// Default constructor
      constexpr default_delete() noexcept = default;

      /** @brief Converting constructor.
       *
       * Allows conversion from a deleter for arrays of another type, @p _Up,
       * only if @p _Up* is convertible to @p _Tp*.
       */
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

      /// Calls @c delete @p __ptr
      void
        operator()(_Tp* __ptr) const
        {
          // *cxx-static-assert*
          static_assert(sizeof(_Tp)>0, "can't delete pointer to incomplete type");

          delete __ptr;
        }
    };

  /// 20.7.12.2 unique_ptr for single objects.

  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      //...

      class _Pointer 
      { 

      };

      public:

      // *cxx-tuple* set tuple with pointer and a default created
      // deleter

      typedef `std::tuple`<typename _Pointer::type, _Dp>  __tuple_type;
      __tuple_type                                      `_M_t`;

      typedef _Dp                       deleter_type;

      /** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       *
       * The deleter will be value-initialized.
       */
      explicit
        unique_ptr(pointer __p) noexcept
        : _M_t(__p, `deleter_type()`)
        { static_assert(!is_pointer<deleter_type>::value,
            "constructed with null function pointer deleter"); }

      // *cxx-sp-unique-no-copy-support*
      // Disable copy from lvalue.
      unique_ptr(const unique_ptr&) = delete;             // @262
      unique_ptr& operator=(const unique_ptr&) = delete;  // @263

      // *cxx-sp-unique-move*
      /// Move constructor.
      unique_ptr(unique_ptr&& __u) noexcept
        : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }

      /** @brief Move assignment operator.
       *
       * @param __u  The object to transfer ownership from.
       *
       * Invokes the deleter first if this object owns a pointer.
       */
      unique_ptr&
        operator=(unique_ptr&& __u) noexcept
        {
          /* */
        }

      /// Reset the %unique_ptr to empty, invoking the deleter if necessary.
      unique_ptr&
        operator=(nullptr_t) noexcept
        {
          reset();
          return *this;
        }

      /// Release ownership of any stored pointer.
      `pointer`
        release() noexcept
        {
          pointer __p = get();
          std::get<0>(_M_t) = pointer();
          return __p;
        }

      // *cxx-sp-reset*
      /** @brief Replace the stored pointer.
       *
       * @param __p  The new pointer to store.
       *
       * The deleter will be invoked if a pointer is already owned.
       */
      void
        reset(pointer __p = pointer()) noexcept
        {
          using std::swap;
          swap(std::get<0>(_M_t), __p);
          if (__p != pointer())
            get_deleter()(__p);
        }

      // *cxx-conversion-to-bool* *cxx-operator-bool* *cxx-sp-bool*
      /// Return @c true if the stored pointer is not null.
      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }

      // Destructor. *cxx-sp-deleter*
      ~unique_ptr() noexcept
      {
        // get first of tuple which is pointer and 
        // if not null, call deleter() which has `single argument`

        auto& __ptr = std::get<0>(_M_t);
        if (__ptr != nullptr)
          `get_deleter()(__ptr);`     // *cxx-sp-delete*
            __ptr = pointer();
      }

      deleter_type&
        get_deleter() noexcept
        { return std::get<1>(_M_t); }

    };

} // namespace


<cxx-sp-empty>
A unique_ptr does not have to own an object, so it can be empty.


<cxx-sp-bool> *cxx-conversion-to-bool*
You can check whether a unique_ptr owns an object by calling *cxx-operator-bool*

// if up is not empty
if (up) {
   std::cout << *up << std::endl;
}

if (up != nullptr)        // if up is not empty
if (up.get() != nullptr)  // if up is not empty

TEST(SmartPointer, OperatorBool)
{
  {
    auto p = make_shared<int>(42);

    // use++
    auto q(p);
    auto r(p);

    EXPECT_THAT(p.use_count(), 3);
    EXPECT_THAT(q.use_count(), 3);

    q.reset();

    EXPECT_THAT(p.use_count(), 2);
    EXPECT_THAT(q.use_count(), 0);
    EXPECT_THAT(r.use_count(), 2);

    EXPECT_TRUE(p);
    // cxx-sp-bool, q is nullptr
    EXPECT_FALSE(q);
    EXPECT_TRUE(r);
  }

  {
    unique_ptr<int> up{new int(100)};

    EXPECT_TRUE(up);
    EXPECT_THAT(*up, 100);
  }
}


{cxx-sp-unique-transfer-ownership}
The `unique_ptr` do not support copy so `have-to transfer ownership.` 

note: no such a thing in shared_ptr

Two options:

*cxx-sp-reset* *cxx-up-reset*

up.reset() 
Calls the deleter for an owned object and makes up empty 
`(equivalent to up=nullptr)`

up.reset(ptr) 
Calls the deleter for an owned object and reinitializes the shared pointer to
own *ptr

up.release() 
Gives up ownership back to the caller (returns owned object without calling
the deleter)


o Use release() and reset() pair

The release() return the pointer it held and make the unique ptr null so using
reset/release pair to transfer ownerships.

unique_ptr<string> p2(up.release());  // up loses it and up is nullptr
sp.reset(up.release());               // up loses it and up is nullptr


o Use a temporty (use move semantics)

unique_ptr<Foo> p4(new Foo(4));
p4 = unique_ptr<Foo>(new Foo(5));     // move assign


*cxx-sp-unique-move*
Use move semantics *cxx-prefered* since intention is clear

// initialize a unique_ptr with a new object
std::unique_ptr<ClassA> up1(new ClassA);

// error in compile since no copy support
std::unique_ptr<ClassA> up2(up1);            

// copy the unique_ptr. transfer ownership of the unique_ptr
std::unique_ptr<ClassA> up3(std::move(up1)); 


// initialize a unique_ptr with a new object
std::unique_ptr<ClassA> up1(new ClassA);

// create another unique_ptr
std::unique_ptr<ClassA> up2; 

// *error* since no copy support
up2 = up1;              

// assign the unique_ptr since supports `rvalue` assign. transfers ownership
// from up1 to up2
up2 = std::move(up1);   


<ex>

#if 0
:10:27: error: use of deleted function ‘std::unique_ptr<_Tp,
  _Dp>::unique_ptr(const std::unique_ptr<_Tp, _Dp>&) [with _Tp =
  std::basic_string<char>; _Dp = std::default_delete<std::basic_string<char> >;
  std::unique_ptr<_Tp, _Dp> = std::unique_ptr<std::basic_string<char> >]’

:12:8: error: use of deleted function ‘std::unique_ptr<_Tp, _Dp>&
std::unique_ptr<_Tp, _Dp>::operator=(const std::unique_ptr<_Tp, _Dp>&) [with _Tp
= std::basic_string<char>; _Dp = std::default_delete<std::basic_string<char> >;
std::unique_ptr<_Tp, _Dp> = std::unique_ptr<std::basic_string<char> >]’

TEST(CxxSmartPointer, check_unique_not_support_copy)
{
  {
    std::unique_ptr<std::string> p1(new std::string("nico"));

    // *cxx-error*
    unique_ptr<std::string> p2(p1);


    unique_ptr<std::string> p3;

    // *cxx-error*
    p3 = p2;
  }

  {
    // cxx.cpp:1696:36: error: conversion from ‘std::string* {aka
    // std::basic_string<char>*}’ to non-scalar type
    // ‘std::unique_ptr<std::basic_string<char> >’ requested

    unique_ptr<std::string> p1 = new string;
  }
}
#endif

namespace cxx_sp_shared
{
  class Foo 
  {
    private:
      int id;

    public:
      Foo(int val = 1)
        : id(val) 
      { 
        cout << "Foo ctor(" << id << ")" << endl; 
      }

      ~Foo() 
      { 
        cout << "Foo dtor(" << id << ")" << endl; 
      }
  };
} // namespace

TEST(CxxSmartPointer, check_unique_move_assign_1)
{
    using namespace cxx_sp_shared;

    std::unique_ptr<Foo> p1(new Foo(1));
    std::unique_ptr<Foo> p2(new Foo(2));

    // f1 is gone. p1->f2. p2 is null
    p1 = std::move(p2);

    EXPECT_TRUE(p1);
    EXPECT_FALSE(p2);
}

TEST(CxxSmartPointer, check_unique_move_assign_2)
{
  // Foo ctor(1)
  // Foo ctor(2)
  // Foo dtor(1)
  // Foo ctor(3)
  // Foo dtor(2)
  // Foo dtor(3)

  {
    using namespace cxx_sp_shared;

    // reset global counter
    cxx_sp_shared::dtor_count = 0;

    // empty up
    std::unique_ptr<Foo> up;

    // not support copy assign for lvalue but support for rvalue
    up = std::move(std::unique_ptr<Foo>(new Foo(1)));
    up = std::move(std::unique_ptr<Foo>(new Foo(2)));
    // Foo(1) is gone
    EXPECT_THAT(dtor_count, 1);

    up = std::move(std::unique_ptr<Foo>(new Foo(3)));
    // Foo(2) is gone
    EXPECT_THAT(dtor_count, 2);

    up = nullptr;
    // Foo(3) is gone
    EXPECT_THAT(dtor_count, 3);
  }

  // Foo ctor(1)
  // Foo ctor(2)
  // Foo ctor(3)
  // Foo ctor(4)
  //
  // Foo dtor(2)
  // Foo dtor(1)
  // Foo dtor(4)
  // Foo dtor(3)

  {
    using namespace cxx_sp_shared;

    std::unique_ptr<Foo> p1(new Foo(1));
    std::unique_ptr<Foo> p2(new Foo(2));
    std::unique_ptr<Foo> p3(new Foo(3));
    std::unique_ptr<Foo> p4(new Foo(4));

    EXPECT_TRUE(p3);

    // f2 is gone, p2->f3, p3 is null
    p2 = std::move(p3);
    EXPECT_FALSE(p3);

    // p3->f1, p1 is null
    p3 = std::move(p1);

    // f1 is gone, p3 is null since p1 is already null
    p3 = std::move(p1);
    EXPECT_FALSE(p3);
  }
}


<ex>
{ 
  // okay when use std::move()

  std::unique_ptr<length_validator> validator1(new length_validator(8));
  std::unique_ptr<digit_password_validator> validator2(
   new digit_password_validator(std::move(validator1)));

  // do the same when use temporary
  std::unique_ptr<digit_password_validator> validator2(
      new digit_password_validator(std::unique_ptr<length_validator>(new length_validator(8)))
      );

  // *cxx-14*
  auto validator1 = std::make_unique<digit_password_validator>(
      std::make_unique<length_validator>(8));
}


<cxx-sp-misuse-unique>
RCLR 101, 5.2 Smart Pointers

// will have double free issue, lifetime issue

A unique_ptr provides the semantics of exclusive ownership. However, it’s up
to the programmer to ensure that no two unique pointers are initialized by the
same pointer:

std::string* sp = new std::string("hello");
std::unique_ptr<std::string> up1(sp);
std::unique_ptr<std::string> up2(sp); // ERROR: up1 and up2 own same data

Unfortunately, this is a runtime error, so the programmer has to avoid such a
mistake.


// lost pointer p2 won't free the memory and have lost the pointer.

p2.release();

// OK. but must remember to delete(p) since p is not smart pointer
auto p = p2.release();


<cxx-sp-unique-return> *cxx-return-cxx-move*
One exception to the rule that cannot copy a unique_ptr; that according to the
language rules of C++11, the compiler will try a move automatically. Can copy
or assign a unique_ptr that is about to be destoryed.

unique_ptr<int> clone(int p) {
  ...
  // explicitly create a pointer
  return unique_ptr<int>( new int(p) );
}

unique_ptr<int> clone(int p) {
  unique_ptr<int> ret( new int(p) );
  ...
  // return a copy of local object
  return ret;
}


<cxx-pattern-source-and-sink>
http://www.gotw.ca/gotw/025.htm
https://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers

namespace cxx_sp_shared
{
  unique_ptr<Foo> source()
  {
    unique_ptr<Foo> ret(new Foo);
    cout << "source: create up" << endl;
    cout << "source: owns " << ret.get() << endl;
    cout << "source: ends" << endl;

    // *cxx-return-cxx-move*
    return ret;
  }

  void sink(unique_ptr<Foo> p)
  {
    cout << "sink: owns " << p.get() << endl;
    cout << "sink: ends" << endl;
  }
} // namespace

// [ RUN      ] CxxFeaturesTest.UseUniqueSinkSource
// call source()
// Foo ctor(1)
// source: create up
// source: owns 0x21d1be0
// source: ends
// main: owns 0x21d1be0
// sink: owns 0x21d1be0
// sink: ends
// Foo dtor(1)
// main: ends
// [       OK ] CxxFeaturesTest.UseUniqueSinkSource (0 ms)

TEST(SharedPointerUnique, SinkSource)
{
  using namespace cxx_sp_shared;

  cout << "call source()" << endl;
  unique_ptr<Foo> up = source();

  cout << "main: owns " << up.get() << endl;

  // *cxx-move*
  sink(move(up));

  cout << "main: ends" << endl;
}


void g()
{
    std::unique_ptr<ClassA> p;

    for (int i=0; i<10; ++i) {

        // p gets ownership of the returned object since no copy support
        p = source(); 
        // (previously returned object of f() gets deleted)
        ...
    }
} // last-owned object of p gets deleted

'no' resource leak is possible. Even if an exception is thrown, any unique_ptr
that owns data ensures that this data is deleted.


<cxx-sp-unique-as-members> exception-in-ctor

RCLR 103, 5.2 Smart Pointers

If an exception occurs inside a constructor, destructors are called 'only' for
objects that have been fully constructed. This can result in resource leaks
for classes with multiple raw pointers if during the construction the first
new was successful but the second was not.

class ClassB {
  private:
    ClassA* ptr1; // pointer members
    ClassA* ptr2;

  public:

    // constructor that initializes the pointers - will cause resource leak if
    // second new throws

    ClassB (int val1, int val2)
      : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
      }

    // copy constructor - might cause resource leak if second new throws

    ClassB (const ClassB& x)
      : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
      }

    ~ClassB () {
      delete ptr1;
      delete ptr2;
    }
};

To avoid such a 'possible' resource leak, unique_ptr helps to avoid resource
leaks caused by exceptions thrown during the initialization of an object. Note
that destructors are called 'only' if any construction is completed. 


class ClassB {
  private:
    std::unique_ptr<ClassA> ptr1; // unique_ptr members
    std::unique_ptr<ClassA> ptr2;

  public:
    // constructor that initializes the unique_ptrs - no resource leak possible
    ClassB (int val1, int val2)
      : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
      }

    // copy constructor - no resource leak possible
    ClassB (const ClassB& x)
      : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
      }

    // no destructor necessary
    // (default destructor lets ptr1 and ptr2 delete their objects)
};


note: 
o Can skip the destructor now because unique_ptr does the job for you. 

o Also have to implement the copy constructor and assignment operator. By
  default, both would try to copy or assign the members, which isn't possible.
  If you don't provide them, ClassB also would provide only move semantics.
  see *cxx-move-synthesized*

<use-with-containers>
`auto_ptr` is not possible to store an auto_ptr in a container, nor could we
return one from a function. How about `unique_ptr`? solved.


={============================================================================
*kt_dev_cxx_0000* cxx-sp-deleter
  
CXXSLR 5.2.5 Class unique_ptr

Deleters for Other Associated Resources

When the object you refer to requires something other than calling delete or
delete[], you have to specify your own deleter. Note, however, that the
approach to defining a deleter differs slightly from that for shared_ptrs. 

You have to specify the type of the deleter as second template argument. That
type can be a reference to a function, function pointer, or function object
(see Section 6.10, page 233). If a function object is used, its “function call
operator” () should be declared to take a pointer to the object.


For example, how can we make it sense when using resources which have own
interfaces since default deleter uses delete operator.

User can set deleter of shared_ptr rather than the default deleter, delete.
This deleter must take a single argument of type T*. otherwise, compile error 

void end_connection(connection *p) { disconnect(*p); }

void f()
{
  connection c = connect(&d);
  std::shared_ptr<connection> p(&c, end_connection);
}


o the passed deleter is not allowed to throw exceptions.

o the key difference:
  can easily override the deleter of a shared_ptr by passing a callable object
  when create or reset. In contrast, the type of the deleter is part of the
  type of unique_ptr. As a result, it is more complidated for unique_ptr to
  provide own deleter.

  unique_ptr uses template and typename. shared_ptr uses object for deleter and
  template function.

namespace cxx_code *cxx-sp-code*
{
  // /usr/include/c++/4.9/bits/unique_ptr.h

  // *cxx-sp-default-delete*

  template <typename _Tp, `typename _Dp = default_delete<_Tp>`>
    class unique_ptr
    {
      `using deleter_type  = _Dp;`

      /** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       *
       * The deleter will be value-initialized.
       */
      explicit
        unique_ptr(pointer __p) noexcept
        : _M_t(__p, `deleter_type()`)
        { static_assert(!is_pointer<deleter_type>::value,
            "constructed with null function pointer deleter"); }

      /** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * `@param __d  A reference to a deleter.`
       *
       * The deleter will be initialized with @p __d
       */
      unique_ptr(pointer __p,
          typename conditional<is_reference<deleter_type>::value, deleter_type, const deleter_type&>::type __d) noexcept
        : _M_t(__p, __d) { }
    }

  // /usr/include/c++/4.9/bits/shared_ptr.h

  /**
   *  @brief  A smart pointer with reference-counted copy semantics.
   *
   *  The object pointed to is deleted when the last shared_ptr pointing to
   *  it is destroyed or reset.
   */
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp> 
  {
    *cxx-template-member*
      /**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
       *          and the deleter @a __d.
       *  @param  __p  A pointer.
       *  @param  __d  A deleter.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  __shared_ptr will release __p by calling __d(__p)
       */
      template<typename _Tp1, `typename _Deleter`>
      shared_ptr(_Tp1* __p, _Deleter __d)
      : __shared_ptr<_Tp>(__p, __d) { }
  };
} // namespace


namespace cxx_sp_delete
{
  class ClassA
  {
  public:
    ClassA(std::string mesg = {})
        : m_mesg(mesg)
    {}

    std::string getMessage() const { return m_mesg; }

  private:
    std::string m_mesg;
  };

  // Since there is no way to get return from operator() becuase it called
  // unique_ptr code inside, have to use outputting message.
  class DebugDeleteClassA
  {
  public:
    DebugDeleteClassA(ostream &os = cerr)
        : m_os(os)
    {}

    void operator()(ClassA *p)
    {
      m_os << p->getMessage() << " is deleted" << std::endl;
      delete p;
    }

  private:
    // *cxx-reference-member*
    ostream &m_os;
  };

  // generic version since T will be deduced in *cxx-template-member*
  class DebugDelete
  {
  public:
    DebugDelete(ostream &os = cerr)
        : m_os(os)
    {}

    template <typename T>
    void operator()(T *p)
    {
      m_os << p->getMessage() << " is deleted" << std::endl;
      delete p;
    }

  private:
    ostream &m_os;
  };

  void function_delete(std::string *str)
  {
    std::cout << *str << " is deleted" << std::endl;
    delete str;
  }

  class DebugDelete2
  {
  public:
    void operator()(string *str)
    {
      std::cout << *str << " is deleted" << std::endl;
      delete str;
    }
  };

} // namespace cxx_sp_delete

TEST(CxxSmartPointer, check_deleter)
{
  using namespace cxx_sp_delete;

  // unique_ptr uses type of deleter and creates deleter object internally
  {
    std::unique_ptr<ClassA, DebugDeleteClassA> up(
      new ClassA("unique with deleter"));

    EXPECT_THAT(up->getMessage(), "unique with deleter");
  }

  // another unique_ptr ctor which explicitly creates deleter object.
  {
    std::unique_ptr<ClassA, DebugDeleteClassA> up(
      new ClassA("unique with deleter"),
      DebugDeleteClassA());

    EXPECT_THAT(up->getMessage(), "unique with deleter");
  }

  {
    std::unique_ptr<ClassA, DebugDelete> up(new ClassA("unique with deleter"),
                                            DebugDelete());

    EXPECT_THAT(up->getMessage(), "unique with deleter");
  }

  // *cxx-error*
  // {
  //   std::unique_ptr<std::string, decltype(function_delete)> up(new
  //   string("unique"), function_delete);
  // }

  // see that the way of using function pointer
  {
    std::unique_ptr<std::string, void (*)(std::string *)> up(
      new std::string("unique with function deleter1"),
      function_delete);
  }

  {
    using unique_ptr_with_function =
      std::unique_ptr<std::string, void (*)(std::string *)>;

    unique_ptr_with_function up(
      new std::string("unique with function deleter2"),
      function_delete);
  }

  // okay when nullptr is used? Yes since unique_ptr do have checks before
  // calling deleter
  {
    using unique_ptr_with_function =
      std::unique_ptr<std::string, void (*)(std::string *)>;

    unique_ptr_with_function up(nullptr, function_delete);
  }

  // shared pointer takes object as argument
  {
    std::shared_ptr<std::string> sp1(new std::string("nico on function"),
                                function_delete);
    std::shared_ptr<std::string> sp2(new std::string("jutta on function"),
                                function_delete);
  }

  {
    std::shared_ptr<std::string> sp1(new std::string("nico on functor"),
                                     DebugDelete2());

    std::shared_ptr<std::string> sp2(new std::string("jutta on functor"),
                                     DebugDelete2());
  }

  {
    // *cxx-lambda*
    std::shared_ptr<string> sp1(new string("nico"), [](string *str) {
      std::cout << *str << " is deleted" << std::endl;
      delete str;
    });
  }
}

<ex>
Uses typedef like unique_ptr but also provides a way to set comp object
reference

namespace cxx_code *cxx-set-multi*
{
  // stl_multiset.h

  template 
    <typename _Key, `typename _Compare = std::less<_Key>`,
    typename _Alloc = std::allocator<_Key>> 
      class multiset
      {
        typedef _Compare key_compare;
        typedef _Compare value_compare;

        // allocation/deallocation
        /**
         *  @brief  Default constructor creates no elements.
         */
        multiset() = default;

        /**
         *  @brief  Creates a %multiset with no elements.
         *  @param  __comp  Comparator to use.
         *  @param  __a  An allocator object.
         */
        explicit
          multiset(const _Compare& __comp,
              const allocator_type& __a = allocator_type())
          : _M_t(__comp, _Key_alloc_type(__a)) { }
      } 
} // namespace

class BulkQuoteTest : public ::testing::Test
{
  protected:
    // pass compare() reference
    BulkQuoteTest() : items_{compare} {}

    static bool compare(std::shared_ptr<Quote> const lhs, std::shared_ptr<Quote> const rhs)
    {
      return lhs->isbn() < rhs->isbn();
    }

    using comp = 
      bool(std::shared_ptr<Quote> const lhs, std::shared_ptr<Quote> const rhs);

    std::multiset<std::shared_ptr<Quote>, comp*> items_;
};


<ex> 
// to ensure that a temporary file gets removed when the last reference to it
// gets destroyed. see the way that handles more than a single argument passed
// in deleter via member.

#include <string>
#include <fstream>   // for ofstream
#include <memory>    // for shared_ptr
#include <cstdio>    // for remove()

class FileDeleter
{
  private:
    std::string filename;
  public:
    FileDeleter (const std::string& fn)
      : filename(fn) {
      }
    void operator () (std::ofstream* fp) {      // T is ofstream and T*
      fp->close();                              // close.file
      std::remove(filename.c_str());            // delete file
    }
};

int main()
{
  // create and open temporary file:
  std::shared_ptr<std::ofstream> fp(new std::ofstream("tmpfile.txt"),
      FileDeleter("tmpfile.txt"));
  ...
}

<ex> // to use shared_ptrs to deal with shm

#include <memory> // for shared_ptr
#include <sys/mman.h> // for shared memory
#include <fcntl.h>
#include <unistd.h>
#include <cstring> // for strerror()
#include <cerrno> // for errno
#include <string>
#include <iostream>

class SharedMemoryDetacher
{
  public:
    void operator () (int* p) {
      std::cout << "unlink /tmp1234" << std::endl;
      if (shm_unlink("/tmp1234") != 0) {
        std::cerr << "OOPS: shm_unlink() failed" << std::endl;
      }
    }
};

std::shared_ptr<int> getSharedIntMemory (int num)
{
  void* mem;
  int shmfd = shm_open("/tmp1234", O_CREAT|O_RDWR, S_IRWXU|S_IRWXG);
  if (shmfd < 0) {
    throw std::string(strerror(errno));
  }
  if (ftruncate(shmfd, num*sizeof(int)) == -1) {
    throw std::string(strerror(errno));
  }
  mem = mmap(nullptr, num*sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  if (mem == MAP_FAILED) {
    throw std::string(strerror(errno));
  }

  // note: here
  return std::shared_ptr<int>(static_cast<int*>(mem), SharedMemoryDetacher());
}

int main()
{
  // get and attach shared memory for 100 ints:
  std::shared_ptr<int> smp(getSharedIntMemory(100));

  // init the shared memory
  for (int i=0; i<100; ++i) {
    smp.get()[i] = i*42;               // see get
  }
  // deal with shared memory somewhere else:
  ...

  std::cout << "<return>" << std::endl;
  std::cin.get();

  // release shared memory here:
  smp.reset();
  ...
}


{efficiency-and-flexibility}
The difference in how the deleter between shared_ptr and unique_ptr is handled
may have important perforamce impacts. CPR 678.

shared_ptr<connection> p (&c, end_connection);
unique_ptr<connection, decltype(end_connection)*> p ( &c, end_connection );

<shared-ptr>
Since the deleter type is not part of shared_ptr type and not known until run
time, do not hold the deleter as a direct member. Indeed, can change the
deleter type during that shared_ptr's lifetime; can construct a shared_ptr
using one deleter type and subsequently use reset() to give that same
shared_ptr a different deleter type. Cannot have member whose type changes at
run time. Hence deleter must be stored indirectly. (Suppose by pointer)

The shared_ptr dtor must have:

// deleter known only at run time; call through pointer and requires run time
// jump to del's location such as:

del ? del(p) : delete p;

<unique_ptr>
Since the deleter type is part of unique_ptr type and is known at compile
time, the deleter can be stored directly in each unique_ptr object. Indeed,
  call might even be inlined at compile time.

// direct call to the deleter is 'instantiated'
del(p);

<design-choice>
By binding the deleter at compile time, unique_ptr avoids the run-time cost of
an `indirect call` to its deleter. In contrast, by binding at run time,
   shared_ptr makes it easier for users to override the deleter.


{cxx-sp-nullptr} {when-deletion-happens}
Such a deletion does not necessarily have to happen at the end of the scope.
For example, assigning the nullptr to pNico or resizing the vector so that it
contains only the first two elements and would delete when the last owner of
the string set to nullptr.

See that underlying refered-to object is different from shared pointer.

u.reset() 
delete the object to which u points. same as u = nullptr.

u = nullptr
delete the object to which u points only for unique_ptr; makes u null


<ex>

// name: Jutta ,name: Jutta ,name: Nico ,name: Jutta ,name: Nico ,
// name: Jutta ,name: Jutta ,name: Nicolai ,name: Jutta ,name: Nicolai ,
// deleting Nicolai
// deleting Jutta

void delete_mesg(string *str)
{
  cout << "deleting " << *str << endl;
  delete str;
}

TEST(SharedPointer, DeleteTime)
{
  using namespace cxx_sp_delete;

  shared_ptr<string> pnico(new string("nico"), delete_mesg);
  shared_ptr<string> pjutta(new string("jutta"), delete_mesg);

  // uppercase the first char
  (*pnico)[0] = 'N';
  pjutta->replace(0, 1, "J");

  // put them in a container
  vector<shared_ptr<string>> coll;
  coll.push_back(pjutta);
  coll.push_back(pjutta);
  coll.push_back(pnico);
  coll.push_back(pjutta);
  coll.push_back(pnico);

  for (auto e: coll)
    cout << "name: " << *e << " ,";
  cout << endl;

  // overwrite name
  *pnico = "Nicolai";

  // print again to see changes
  for (auto e: coll)
    cout << "name: " << *e << " ,";
  cout << endl;

  // jutta's use count
  EXPECT_THAT(coll[0].use_count(), 4);

  pjutta = nullptr;

  EXPECT_THAT(coll[0].use_count(), 3);

  // pico's use count
  EXPECT_THAT(coll[2].use_count(), 3);

  coll.resize(2);

  pnico = nullptr;

  // WHY 0?
  //
  // *cxx-sp-shared-check-users* do not rely on use_count()
  // use_count() may not be reliable since C++P 453 reads "may be a slow
  // operation, intended primarily for debugging purpose"

  EXPECT_THAT(pnico.use_count(), 0);
  EXPECT_THAT(pjutta.use_count(), 0);
}

<ex>
namespace cxx_sp_use_count
{
  class Foo 
  {
    private:
      int id;
    public:
      Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
      ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
  };
} // namespace

// Again, shows use_count() is not reliable but does match when object is
// deleted.
//
// Foo ctor(1)
// p1.use_count: 2
// p2.use_count: 2
// p1.use_count: 0
// p2.use_count: 1
// p1.use_count: 0
// p2.use_count: 1
// p1.use_count: 0
// p2.use_count: 1
// -----------
// p1.use_count: 0
// p2.use_count: 1
// Foo dtor(1)
// p1.use_count: 0
// p2.use_count: 0
// p1.use_count: 0
// p2.use_count: 0
// p1.use_count: 0
// p2.use_count: 0
// end of main

TEST(SharedPointer, UseCount)
{
  using namespace cxx_sp_use_count;

  shared_ptr<Foo> p1(new Foo(1));
  shared_ptr<Foo> p2(p1);

  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  p1 = nullptr;
  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  p1 = nullptr;
  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  p1 = nullptr;
  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  cout << "-----------" << endl;

  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  p2 = nullptr;
  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  p2 = nullptr;
  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  p2 = nullptr;
  cout << "p1.use_count: " << p1.use_count() << endl;
  cout << "p2.use_count: " << p2.use_count() << endl;

  cout << "end of main" << endl;
}

<ex>
// Foo ctor(1)
// Foo ctor(2)
// Foo ctor(3)
// Foo dtor(2)    // p2.reset() frees p2
// -----------
// -----------    // p3.reset() frees nothing and just change referrring object
// Foo dtor(1)    // p3.reset() frees p1
// -----------
// end of main
// Foo dtor(3)

TEST(SharedPointer, DeleteReleaseReset)
{
  using namespace cxx_sp_shared;

  unique_ptr<Foo> p1(new Foo(1));
  unique_ptr<Foo> p2(new Foo(2));
  unique_ptr<Foo> p3(new Foo(3));

  p2.reset(p3.release());
  cout << "-----------" << endl;

  p3.reset(p1.release());
  cout << "-----------" << endl;

  p3.reset(p1.release());
  cout << "-----------" << endl;

  cout << "end of main" << endl;
}


={============================================================================
*kt_dev_cxx_0000* cxx-sp-read: can store unique_ptr in a container?

For unique-ptr, no copy support and has to transfer ownership. For containers,
the element to store had to be `copyable`.

<try>
#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
  unique_ptr<Foo> p1( new Foo(1) );
  unique_ptr<Foo> p2( new Foo(2) );
  unique_ptr<Foo> p3( new Foo(3) );
  unique_ptr<Foo> p4( new Foo(4) );

  // put them into a container
  vector< unique_ptr<Foo>> pvec;
  pvec.push_back(p1);
}

error: use of deleted function ‘std::unique_ptr<_Tp, _Dp>::unique_ptr(const
           std::unique_ptr<_Tp, _Dp>&) [with _Tp = Foo, _Dp =
std::default_delete<Foo>, std::unique_ptr<_Tp, _Dp> = std::unique_ptr<Foo>]’

This happens since unique_ptr do not support copy. Hence deleted. So cannot
store unique_ptr in a container? NO, can since C++11 since not copyable but
moveable.

http://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers/

C++11: using unique_ptr with standard library containers
June 20th, 2012 at 8:46 pm

Before C++11, the only "smart" pointer available in the standard C++ library
was auto_ptr. Alas, auto_ptr isn't very smart. It has very problematic copy
semantics that make it difficult to use in several important scenarios. In
particular, auto_ptr can not be used with standard containers and algorithms!

To quote from Herb Sutter:

auto_ptr is most charitably characterized as a valiant attempt to create a
unique_ptr before C++ had move semantics. auto_ptr is now deprecated, and
should not be used in new code. When you get a chance, try doing a global
search-and-replace of auto_ptr to unique_ptr in your code base

So what is this unique_ptr thing, and what can it be used for?

Basic capabilities

To put it simply, `unique_ptr` 'should' be the 'default' smart pointer used by
new C++ code, replacing "raw" pointers as much as possible. unique_ptr cleanly
represents the single ownership idiom - it cannot be copied and assigned, and
it cleans up the pointed object when it's destructed.

Here's some code to demonstrate this [1]:

#include <iostream>
#include <cstdlib>
#include <memory>

using namespace std;

struct Foo {
    // use of `this` to get address 
    Foo() {cerr << "Foo [" << this << "] constructed\n";}
    virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

int main(int argc, char** argv) 
{
  // .. some code
  {
    unique_ptr<Foo> fp(new Foo());

    unique_ptr<Foo> fp2(fp);    // ERROR! can't copy unique_ptr
    unique_ptr<Foo> fp3;
    fp3 = fp;                   // ERROR! can't assign unique_ptr

    cerr << "Exiting scope\n";
  } // fp will be destroyed, and will destruct the pointed object

  return 0;
}

The lines marked with the ERROR! comment won't actually compile. The compiler
will complain saying something like:

error: use of deleted function
 'std::unique_ptr<_Tp, _Dp>::unique_ptr(const std::unique_ptr<_Tp, _Dp>&)

If these two lines are commented out, the code will print:

Foo [0x845010] constructed
Exiting scope
Foo [0x845010] destructed

In addition to managing the pointed object's lifetime, unique_ptr provides the
other expected capabilities of a smart pointer: it overloads operator* and
operator->, provides a means to obtain the raw pointer (get), to relinquish
control of the pointed object (release), and to replace the object it manages
(reset). It also lets you customize the way the pointed object is deleted (if
    you don't want it to be the default delete operator), and has some other
niceties - just consult your favorite C++ reference.


What about sources and sinks?

In this article I want to focus not on the grocery list of unique_ptr's
features, but its interesting move semantics. Specifically, given that
unique_ptr forbids copying and assignment, one may wonder how it can fit in
the `cxx-pattern-source-and-sink` which is so useful for smart pointers.

In other words, we'd like this to work:

// source creates a Foo object, wraps it in a smart pointer for safety and
// provides the result to the caller, giving it the ownership of the object in
// the process.

unique_ptr<Foo> source();

// sink gets a Foo object wrapped in a smart pointer for safety. It also assumes
// ownership of the provided object.

void sink(unique_ptr<Foo> p);

*cxx-move*
And in C++11, it does! Even though unique_ptr can't be copied, it can be
'moved'. Move semantics are a perfect match for unique_ptr - the two concepts
reinforce each other. With move semantics, unique_ptr is both safe and
efficient. Here's some code to demonstrate this:

#include <iostream>
#include <cstdlib>
#include <memory>

using namespace std;

struct Foo {
  Foo() {cerr << "Foo [" << this << "] constructed\n";}
  virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

void sink(unique_ptr<Foo> p) {
  cerr << "Sink owns Foo [" << p.get() << "]\n";
}

unique_ptr<Foo> source() {
  cerr << "Creating Foo in source\n";
  return unique_ptr<Foo>(new Foo);
}

int main(int argc, char** argv) {
  cerr << "Calling source\n";
  unique_ptr<Foo> pmain = source();  // Can be written as auto pmain = source();

  cerr << "Now pmain owns Foo [" << pmain.get() << "]\n";
  cerr << "Passing it to sink\n";
  sink(pmain);                    // ERROR! can't copy unique_ptr
  sink(move(pmain));              // OK: can move it!    // meant std::move

  cerr << "Main done\n";
  return 0;
}

Again, there's a line marked with ERROR! here - it demonstrates once again
that a unique_ptr can't be copied. However, it can be explicitly moved, as the
next line shows [2]. When the erroneous line is commented out, this code
prints:

[2] It can also be taken from an rvalue: sink(unique_ptr<Foo>(new Foo)) would
work, because rvalue references can be moved directly. note: here again temp
object hence rvalue

Calling source
Creating Foo in source
Foo [0x1767010] constructed
Now pmain owns Foo [0x1767010]
Passing it to sink
Sink owns Foo [0x1767010]
Foo [0x1767010] destructed
Main done

How cleanly the ownership is being passed between the functions in this code.
At each point in time, only a single unique_ptr owns the pointed Foo object.
Moreover, this is efficient - the actual pointed object only gets constructed
once and destructed once.


Containers - motivation

So unique_ptr is a useful single-ownership smart pointer. But what makes it
really shine (especially when compared to auto_ptr) is that it can be used in
standard containers.

Why is it so important to be able to place smart pointers into containers?
Because holding objects by value is sometimes very expensive. 

Containers, especially when coupled with algorithms, tend to move objects
around. Large objects are expensive to copy, hence we'd like to keep pointers
to objects inside containers instead.


Example

What follows is a very simplistic example that demonstrates this. It shows how
much more expensive it is to sort a vector of large objects that are stored
`by-value`, than it is when they're stored by pointer [3].

Also, I explicitly said to take the container example with a grain of salt as
it was synthetically built to demonstrate the point. Yes, it is best to avoid
huge objects, but that's not always possible.

First, let's create a synthetic "large" object that has well defined ordering
properties by some numeric ID:

struct SomeLargeData {
    SomeLargeData(int id_)
        : id(id_)
    {}
    int id;
    int arr[100];
};

We also need a function to compare two such objects. Actually, we need two -
one for a container that holds object by value, and another for the by pointer
version:

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
    return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
    return a->id < b->id;
}

Let's now create two vectors and populate them with random objects:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));
}

Finally, we'll sort the two vectors with the standard sort algorithm, and
measure the runtime for some large n:

sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

  "The timing results I get are quite consistent - the by-pointer sorting is
  2-3x faster than the by-value sorting [4]."

That's a very significant difference, and it's all due to the copying sort has
to do for moving the objects around inside the container.

[4] The speedup grows as the size of the object grows. Increasing the arr
member to hold 1000 integers makes the speedup 10x.

So holding objects of non-trivial size inside standard containers is not a
good idea in terms of performance. But holding raw pointers to them is also
not so great, because of all the safety issues that come with raw pointers.
The container can't own the pointed objects because its destructor will just
"destruct" the pointer(note not pointed object), which does nothing. So the
calling code(note client) has to own the actual objects which are being
shuffled around by the container. Add exceptions and/or early returns to the
mix, and this is a recipe for memory leaks or even worse problems.

What we'd really like to do is let our objects be managed by a smart pointer
and put that into a container. This would guarantee a clean ownership strategy
- the container destroys its contents when it gets destroyed itself - just the
way it should be. This is why unique_ptr is so exciting.


Containers of unique_ptr

Adapting the by-pointer version of the code above to hold unique_ptr is very
simple. First, we need another comparison function:

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a,
                        const unique_ptr<SomeLargeData>& b) {
    return a->id < b->id;
}

And then we just need to create the vector, populate it and then sort it,
    similarly to the way we've done for the other vectors:

vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    // ...
    vec_byuniqptr.push_back(
        unique_ptr<SomeLargeData>(new SomeLargeData(id)));  
    // note `temporty-unique-ptr` object. shall be this form since no copy
    // supported or use std::move
}

sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);

That's it! And the performance? 'almost' identical to the by-pointer version
(I measured differences of 1-5%, depending on the data).


What about shared pointers?

Another smart pointer C++11 brings with it is the shared_ptr/weak_ptr pair,
        implementing a reference-counted approach to shared ownership. While
        much more flexible than unique_ptr, shared_ptr is slower and consumes
        more memory; managing the reference count is not free [5].

[5] For the sorting benchmark demonstrated in this article shared_ptr is about
10% slower than unique_ptr. As for size, while the size of unique_ptr is
exactly the size of a raw pointer, shared_ptr is about twice as large.

Which one to use depends on your exact needs, but I agree with Herb Sutter's
proposal of using unique_ptr by default and switching to shared_ptr if the
need arises.

In addition, it is my personal opinion that preferring unique_ptr imposes a
certain memory management discipline on the code, since you know at each point
exactly who owns what. Shared pointers give you a sense of security you can
over use and end up with reference leaks, which are tricky to debug (just like
    when writing Python C extension code). 

Moreover, shared pointers signal the intention of APIs less clearly than
owning pointers. When some factory returns a shared pointer, does it mean it
keeps a reference to the object too? With an owning pointer, the API is self
documenting (source returns a unique_ptr? then source is for sure giving away
    ownership).  With a shared pointer, it does not, and need external
documentation to clarify.


Conclusion

I have mentioned how rvalue references and move semantics can make code more
efficient with C++11. unique_ptr is another great example that makes me want
to use a C++11-capable compiler as soon as possible.

unique_ptr provides an excellent mix of efficiency and safe memory management.
IMHO it's a great example of how several ideas in language design interact to
create a whole that is larger than its parts.


Replies:

<1>
fanNo Gravatar Says:
June 25th, 2012 at 14:48

Can't we get the best of all worlds, by doing this:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(&vec_byval.back());   // saves up the inserted entry
}

sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

This gives us fast by-pointer sorting AND ownership of the pointed objects. So
I don't get the excitement about unique_ptr.

<2>
westforkNo Gravatar Says:
November 5th, 2012 at 12:22

Nice article. But my results are different from what you wrote.  I implemented
your code using gcc 4.7 (g++ (Ubuntu/Linaro 4.7.2-4precise1) 4.7.2) on my
desktop (OS xubuntu 12.04, Intel(R) Core(TM)2 Duo CPU, E8400 @ 3.00GHz).  I
build a vector of 2010000 containing SomeLargeData objects, raw pointers to
SomeLargeData objects and unique-pointers to SomeLargeData objects. The results
are that raw pointer container is the faster to sort (as expected) but the
container with the unique pointers is the slower!!!  Here a dump of my tests

By value test
TIMESTAMP-START 11:18:23:127277 (ms ~ 40703127)
TIMESTAMP-END 11:18:27:378556 (ms ~ 40707378)
ELAPSED TIME (ms) 4251

By pointer test
TIMESTAMP-START 11:18:27:378658 (ms ~ 40707378)
TIMESTAMP-END 11:18:29:841735 (ms ~ 40709841)
ELAPSED TIME (ms) 2463

By unique_pointer test
TIMESTAMP-START 11:18:29:841816 (ms ~ 40709841)
TIMESTAMP-END 11:18:35:674064 (ms ~ 40715674)
ELAPSED TIME (ms) 5833

What do you think? The overhead of the unique-ptr over the raw pointer is so
heavy?


<3>
SqeakyNo Gravatar Says:
March 19th, 2013 at 11:58

@Fan The first time the value vector grows it will invalidate all the pointers
in the pointer vector. Since it never tells you when this happens, but can
happen on any insertion, you have to assume that the pointer is invalid after
the next insertion.

@Westfork I would guess that the implementation just hasn't had enough time to
mature yet. There must be at least as much over with the unique_ptr as raw
pointers, but double does seem excessive. Did you remember to delete in the
raw pointer example?


<4>
This is my result on the VM in a laptop.

#include <iostream>
#include <memory>
#include <vector>
#include <sys/time.h>
#include <algorithm>

using namespace std;

typedef uint64_t u64;

static u64 nsec() {
  struct timeval tv;
  if(gettimeofday(&tv, 0) < 0)
    return -1;
  return (u64)tv.tv_sec*1000*1000*1000 + tv.tv_usec*1000;
}

struct SomeLargeData {
  SomeLargeData(int id_)
    : id(id_)
  {}

  // SomeLargeData(int id_)
  //   : id(id_)
  // { cout << "Foo[" << this << "] ctor(" << id << ")" << endl; }
  // ~SomeLargeData() { cout << "Foo[" << this << "] dtor(" << id << ")" << endl; }

  int id;
  int arr[100];
};

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
  return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
  return a->id < b->id;
}

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a, const unique_ptr<SomeLargeData>& b) {
  return a->id < b->id;
}

int main()
{
  uint64_t be, af;
  int n = 400;

  vector<SomeLargeData> vec_byval;
  vector<SomeLargeData*> vec_byptr;
  vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

  for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));    // note. shall be deleted later
    vec_byuniqptr.push_back(unique_ptr<SomeLargeData>(new SomeLargeData(id)));
  }  

  be = nsec();
  sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
  af = nsec();
  cout << "by value: diff(ns): " << af-be << endl;
  cout << "by value: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);
  af = nsec();
  cout << "by ptr: diff(ns): " << af-be << endl;
  cout << "by ptr: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);
  af = nsec();
  cout << "by uptr: diff(ns): " << af-be << endl;
  cout << "by uptr: diff(ms): " << (af-be)/(1000) << endl;
}

$ ./a.out 
by value: diff(ns): 302000
by value: diff(ms): 302
by ptr: diff(ns): 127000
by ptr: diff(ms): 127
by uptr: diff(ns): 585000
by uptr: diff(ms): 585


={============================================================================
*kt_dev_cxx_0000* cxx-sp-issue cxx-sp-shared-from-this

RCLR 5.2.3

* Cyclic reference shown above.


o Double delete *cxx-sp-shared-ownership*

Have to ensure that only `one group of shared pointers` owns an object.

int* p = new int;
shared_ptr<int> sp1(p);
shared_ptr<int> sp2(p);       // new shared ptr group and double delete.

For this reason, you should always directly initialize a smart pointer the
moment you create the object with its associated resource:

shared_ptr<int> sp1(new int);
shared_ptr<int> sp2(sp1);     // OK


{cxx-sp-shared-from-this} *cxx-sp-shared-from-this*
Suppose that we want to introduce a member function for a Person that creates
both the reference from a kid to the parent and a corresponding reference back:

// *cxx-sp-weak-ex*
//
// shared_ptr<Person> initFamily (const string& name)
// {
//   shared_ptr<Person> mom(new Person(name+"'s mom"));
//   shared_ptr<Person> dad(new Person(name+"'s dad"));
//   shared_ptr<Person> kid(new Person(name, mom, dad));
//   mom->kids.push_back(kid);
//   dad->kids.push_back(kid);
//   return kid;                              // return kid
// }

shared_ptr<Person> initFamily (const string& name)
{
  shared_ptr<Person> mom(new Person(name+"'s mom"));
  shared_ptr<Person> dad(new Person(name+"'s dad"));
  shared_ptr<Person> kid(new Person(name));
  kid->setParentsAndTheirKids(mom, dad);
  return kid;                                 // return kid
}

`naive implementation` is:

void setParentsAndTheirKids (shared_ptr<Person> m = nullptr, 
    shared_ptr<Person> f = nullptr) 
{
  mother_ = m;
  father_ = f;

  if (m != nullptr) {
    m->kids.push_back(shared_ptr<Person>(this)); // *cxx-error* 
  }
  if (f != nullptr) {
    f->kids.push_back(shared_ptr<Person>(this)); // *cxx-error*
  }
}

Apart from cyclic reference issue, the problem is the creation of a shared
pointer out of `this` pointer. 

Want to pass kid's shared pointer to mother and father but to do that, need a
shared pointer from the kid, which we don't have at hand since this pointer is
not shared pointer. 

*cxx-sp-issue* *cxx-double-delete*
So creates temporary shared pointer from `this` which is `new group of shared
pointer.` Two shared pointer group to the kid and when mom and dad go free, will
do `double delete`

One way to deal with this problem is to pass the shared pointer to the kid as a
third argument. But the C++ standard library provides another option: class
std::enable_shared_from_this<>.

Use class std::enable_shared_from_this<> `to derive your class`, representing
objects managed by shared pointers, with your class name passed as template
argument. Doing so allows you to use a derived member function
`shared_from_this()` to create a correct shared_ptr out of `this`

class Person : public std::enable_shared_from_this<Person> {
  public:
    ...
      void setParentsAndTheirKids (shared_ptr<Person> m = nullptr,
          shared_ptr<Person> f = nullptr) {

        mother_ = m;
        father_ = f;

        if (m != nullptr) {
          m->kids.push_back(`shared_from_this()`);
        }

        if (f != nullptr) {
          f->kids.push_back(shared_from_this());
        }
      }
    ...
};

class GstM: public MediaRouterAsync,
    public boost::enable_shared_from_this<GstM>
{};


{code}

namespace cxx_code *cxx-sp-code*
{
  //bits/shared_ptr.h

  /** 
   *  @brief Base class allowing use of member function shared_from_this.
   */
  template<typename _Tp>
    class enable_shared_from_this
    {
      protected:
        enable_shared_from_this() { }

      public:
        shared_ptr<_Tp>
          shared_from_this()
          { return shared_ptr<_Tp>(this->_M_weak_this); }

        shared_ptr<const _Tp>
          shared_from_this() const
          { return shared_ptr<const _Tp>(this->_M_weak_this); }
    };
}


={============================================================================
*kt_dev_cxx_0000* cxx-sp-read exception safety

GotW #102: Exception-Safe Function Calls (Difficulty: 7/10)

3. As you continue to root through the archives, you see that someone must not
have liked Example 2 because later versions of the files in question were
changed as follows:

// Example 3
 
// In some header file:
void f( std::unique_ptr<T1>, std::unique_ptr<T2> );
 
// At some call site:
f( std::unique_ptr<T1>{ new T1 }, std::unique_ptr<T2>{ new T2 } );

What improvements does this version offer over Example 2, if any? Do any
  exception safety problems remain? Explain.

This code attempts to “throw unique_ptr at the problem.” Many people believe
that a smart pointer is an exception-safety panacea, a touchstone or amulet that
by its mere presence somewhere nearby can help ward off compiler indigestion.

It is not. Nothing has changed. Example 3 is still not exception-safe, for
exactly the same reasons as before.

Specifically, the problem is that the resources are safe only if they really
make it into a managing unique_ptr, but the same problems already noted can
still occur before either unique_ptr constructor is ever 'reached'. This is
because both of the two problematic execution orders mentioned earlier are still
possible, but now with the unique_ptr constructors tacked onto the end before
invoking f. For one example:

    allocate memory for the T1
    construct the T1
    allocate memory for the T2
    construct the T2
    construct the unique_ptr<T1>
    construct the unique_ptr<T2>
    call f

In the above case, the same problems are still present if either of steps 3 or 4
throws. Similarly with:

    allocate memory for the T1
    allocate memory for the T2
    construct the T1
    construct the T2
    construct the unique_ptr<T1>
    construct the unique_ptr<T2>
    call f

Again, the same problems are present if either of steps 3 or 4 throws.

Fortunately, though, this is not a problem with unique_ptr; it’s just being used
the wrong way, that’s all. Let’s see how to use it better.


Enter make_unique

4. Demonstrate how to write a make_unique facility that solves the safety
problems in Example 3 and can be invoked as follows:

// Example 4
 
// In some header file:
void f( std::unique_ptr<T1>, std::unique_ptr<T2> );
 
// At some call site:
f( make_unique<T1>(), make_unique<T2>() );

The basic idea is:

    We want to leverage the fact that functions called from the same thread
    won't interleave, so we want to provide a function that does the work of
    allocation and construction of the object and construction of the
    unique_ptr.

    Because the function should be able to work with any type, we want to
    express it as a function template.

    Because the caller will want to pass constructor parameters from outside
    make_unique, we’ll use the C++11 perfect forwarding style to pass those
    along to the new-expression inside make_unique.

    Because shared_ptr already has an analogous std::make_shared, for
    consistency we’ll call this one make_unique. (That C++11 doesn’t include
        make_unique is partly an oversight, and it will almost certainly be
        added in the future. In the meantime, use the one provided below.)

Putting the ingredients together, we get:

template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args )
{
    return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}

This solves the exception safety problems. No sequence of generated code can
cause resources to be leaked, because now all we have is two functions, and we
know that one must be executed entirely before the other. Consider the following
evaluation order:

    call make_unique<T1>
    call make_unique<T2>
    call f

If step 1 throws, there are no leaks because make_unique is itself strongly
exception-safe.

If step 2 throws, then is the temporary unique_ptr<T1> created by step 1
guaranteed to be cleaned up? Yes, it is. One might wonder: Isn't this pretty
much the same as the new T1 object created in the corresponding case in Example
2, which isn't correctly cleaned up? No, this time it's not quite the same,
  because here the unique_ptr<T1> is actually a temporary object, and cleanup of
  temporary objects is correctly specified in the standard. From the standard,
  in 12.2/3 (unchanged from C++98):

  "" Temporary objects are destroyed as the last step in evaluating the
  full-expression that (lexically) contains the point where they were created.
  This is true even if that evaluation ends in throwing an exception.

Guidelines:

    Prefer to allocate objects to be managed by a shared_ptr using make_shared,
    and objects to be managed by a unique_ptr with make_unique.

    Although Standard C++ does not yet have make_unique, this is mostly an
    oversight and it will almost certainly eventually be added. In the meantime,
    use the version shown above, and your code will be forward-compatible with
    the likely direction of the C++ standard.

    Avoid using plain new or other raw unmanaged allocation directly. Instead,
    use a factory like make_unique that wraps the raw allocation and immediately
    passes it to another object that will own the resource. Often that owning
    object will be a smart pointer, but it can be a scope guard or any other
    kind of owning object whose destructor will deallocate the resource safely.


={============================================================================
*kt_dev_cxx_0000* cxx-sp-read internal

{auto-ptr}
MEC++28 that is about auto_ptr. The typical implementation is:

template<class T>
class SmartPtr {
  public:
    // create a smart ptr to an obj given a dumb ptr to it. uninitialized ptr default to 0.
    SmartPtr( T* realPtr = 0 );

    // copy and assign a smart ptr
    SmartPtr( const SmartPtr& rhs );
    SmartPtr& operator=( cont SmartPtr& rhs );

    ~SmartPtr();

    // const. though it may lead to modification of what the pointer points to
    T* operator->() const;
    T& operator*() const;

  private:
    // dump(real) pointer
    T* pointee;
};

note: here copy and assign are public and if not allow those, should be private.

<encapsulation>
This smart pointer is testimony to the effectiveness of encapsulation:

1. Allow us to treat smart pointer as built-in pointer. Hide difference.
2. Other example. Handle local and remote DB access as if it is in the same place. Hide.

// template for smart ptrs to objects in a distributed DB
template<class T>
class DBPtr {
  public:
    // create a smart ptr to DB object given a local dumb pointer to it
    DBPtr(T *realPtr = 0);
    DBPtr(DataBaseID id);
    ...
};

class Tuple {
  ...
};

void editTuple(DBPtr<Tuple>& pt)
{
  do {
    pt->displayEditDialog();
  } while (pt->isValid() == false);
}

The tuple to be edited inside editTuple may be physically located on a remote machine, but the
programmer writing editTuple need not be concerned with such matters.

<copy-and-assign> ownership
How support copy semantics? Here implements ownership.

// the book said it has taken from stl
template<class T>
class auto_ptr {
  public:
    auto_ptr(T *ptr = 0): pointee(ptr) {}
    ~auto_ptr() { delete pointee; }

    auto_ptr(auto_ptr<T> &rhs)
    {
      // transfer ownership
      pointee = rhs.pointee;

      // no longer owns anything
      rhs.pointee = 0;
    }

    auto_ptr<T>& operator=( auto_ptr<T> &rhs )
    {
      // self-assign guard
      if( this == &rhs )
        return *this;

      // delete currently owned objects
      delete pointee;

      // transfer ownership
      pointee = rhs.pointee;
      rhs.pointee = 0;

      return *this;
    }

  private:
    T *pointee;
};

note: unconventional copy and assign operator since do not use const on parameters. These have to
change rhs so not use const.

<pass-by-value>
note: this is only for auto_ptr since compile error for unique_ptr for the same code.

Since ownership is transferred, passing auto_ptr by value is often a bad idea. Why?

void printNode( ostream& s, auto_ptr<TreeNode> p ) { s << *p; }

int main()
{
  auto_ptr<TreeNode> ptr( new TreeNode );
  ...
  printNode( cout, ptr );
  ...
}

In printNode call, call copy-ctor and means transfer ownership. When returns, dtor runs and delete
pointee. When main ends, dtor runs again and do double-free. So use reference:

void printNode( ostream& s, auto_ptr<TreeNode>& p ) { s << *p; }

See {the-rule-of-three} for <double-free> example.


<dereferencing-operators>

template< class T>
T& SmartPtr<T>::operator*() const
{
  // perform "smart pointer" processing
  return *pointee;
}

See return as reference because:

1. *pointee can be derived class in inheritance. To avoid sliced-off.
2. More efficient. No temp object.

For operator->(), the statement is interpreted by as:

pt->displayEditDialog(); -> (pt.operator->())->DisplayEditDialog();

So operator-> return either pointer or another smart pointer because can use -> on it.

template< class T>
T* SmartPtr<T>::operator->() const
{
  // perform "smart pointer" processing
  return pointee;
}

Both returns pointer and reference, virtual call through it works as supposed to. This will be fine
for most applications.

<nullness-of-smart-pointer>
If you want to push your smart pointers further, however, you must know more about dumb pointer
behavior and how smart pointers can and cannot emulate it. The followings are for this.

One of the things we cannot do is find out if a smart pointer is null:

SmartPtr<T> ptr;
...
if( ptr == 0 ) ...
if( ptr ) ...
if(!ptr) ...


How to solve? Add isNull member function? Not a solution since do not act like usual pointers.
Typical approach is to use conversion operators.

<approach-one> conversion-to-void
Use implicit conversion operator which is traditional. This is the way iostream uses so it is
possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
  public:
    operator void*(); // return 0 if smart pointer is null, non-zero otherwise.
    ...
};

note: Q: why void*? how it works?

This approach has a problem since it allows following: 

SmartPtr<Apple> pa; SmartPtr<Orange> po;

if( pa == po ) ...

Even if there is no operator== taking a SmartPtr<Apple> and a SmartPtr<Orange>, this compiles,
because both smart pointers can be implicitly converted into void* pointers, and there is a built-in
comparison function for built-in pointers.

<approach-two>
There are many variations and the other is:

template< class T>
class SmartPtr {
  public:
    bool operator!() const; // return true only if smart pointer is null
    ...
};

However, still not complete.

if(!ptn) {           // OK
  ...
}

if( ptn == 0 ) ...   // ERROR
if( ptn) ...


note: How about STL?

<get-dumb-pointer>
TODO: converting smart pointers to dumb pointers.

<smart-pointer-in-inheritance>
class MusicProduct {
  public:
    MusicProduct( const string& title );
    virtual void play() const = 0;
    virtual void displayTitle() const = 0;
    ...
};

class Cassette: public MusicProduct {
  ...
};

class CD: public MusicProduct {
  ...
};

void displayAndPlay( const MusicProduct* pmp, int numTimes )
{
  for( int i=1; i <= numTimes; ++i )
  {
    pmp->displayTitle();
    pmp->play();
  }
}

Cassette *funMusic = new Cassette("Jazz");
CD *nightmareMusic = new CD("Disco Hits of the 70s");

displayAndPlay( funMusic, 10 );
displayAndPlay( nightmareMusic, 0 );

No surprise here but if replace it with smart pointers, then compile errors:

void displayAndPlay( const SmartPtr<MusicProduct> &pmp, int numTimes );

SmartPtr<Cassette> funMusic(new Cassette("Jazz"));
SmartPtr<CD> nightmareMusic(new CD("Disco Hits of the 70s"));

displayAndPlay( funMusic, 10 );
displayAndPlay( nightmareMusic, 0 );

Why won't these compile? Template make a new class so inheritance no longer exist. Is it useful to
maintain inheritance when use template? If so, do further reading.


<smart-pointer-and-const>
For built-in:

const T* const ptr = ...;

For smart pointer:

const SmartPtr< T> ptr = &goodCD;  // const pointer
SmartPtr< const CD> ptr = &goodCD;

Unlike built-in, there is no conversion from non-const to ptr-to-const.

const CD* pConstCD = pCD;

Because template create new classes. If need more, see further.

<example>
#include <iostream>
#include <memory>

using namespace std;

class Foo {  
  public:
    void whoami() { cout << "this is foo" << endl; }
};

template<typename T>
class mauto_ptr {
  public:
    mauto_ptr(T* arg=nullptr) : pointee(arg) { cout << "ctor on :" << arg << endl; }
    ~mauto_ptr() { cout << "dtor on :" << pointee << endl; delete pointee; }

    // * operator
    mauto_ptr<T>& operator*() { return *pointee; }

    // -> operator
    T* operator->() { return pointee; }

    // copy ctor: transfer ownership
    mauto_ptr( mauto_ptr<T>& rhs )
    {
      pointee = rhs.pointee;
      rhs.pointee = nullptr;
    }

    // copy assign:
    mauto_ptr<T>& operator=( mauto_ptr<T>& rhs )
    {
      // self-assign guard
      if( this == &rhs )
        return *this;

      delete pointee;

      pointee = rhs.pointee;
      rhs.pointee = nullptr;

      return *this;
    }

  private:
    T* pointee;
};

void printptr( auto_ptr<int> p )
{
  cout << "value is: " << *p << endl;
}

int main()
{
  {
    cout << "{ start block: " << endl;
    mauto_ptr<Foo> p(new Foo());
    p->whoami();
    cout << "} end block: " << endl;
  }
}

{ start block: 
ctor on :0x9fdf008
this is foo
} end block: 
dtor on :0x9fdf008


={============================================================================
*kt_dev_cxx_0000* cxx-sp-code

// From CPP code challenge, 21. System handle wrapper
//
// template <typename>
// class unique_ptr<T>
// {
//  no copy support
//  move support
//  operator bool();
//  T* get();
//  T* release();
//  void reset(T*);
//  void swap(uniqie_ptr<T> &);
// }
//
// + non-member swap
// + self-assign
//
// note that this version uses T which provides pointer and close() in it.
// changes it to delete().

namespace cxx_sp_unique_own_version
{
  struct pointer_int_trait
  {
    typedef int value_type;
    using pointer = value_type *;

    // *cxx-static*
    // without static, cause build error:
    //
    // cxx.cpp:2243:24: error: cannot call member function 
    // ‘void cxx_sp_unique_own_version::pointer_int_trait::deleter(cxx_sp_unique_own_version::pointer_int_trait::pointer)’ 
    // without object
    //
    //           T::deleter(p_);

    static void deleter(pointer p)
    {
      delete p;
    }
  };

  template <typename T>
    class unique_own
    {
      using pointer = typename T::pointer;

      public:
        // no copy support
        
        // not a build error but don't need to do this as *cxx-scope*
        // unique_own(const unique_own<T> &) = delete;
        // unique_own<T> &operator=(const unique_own<T> &) = delete;

        unique_own(const unique_own &) = delete;
        unique_own &operator=(const unique_own &) = delete;

        // ctor & dtor
        explicit unique_own(typename T::pointer p = nullptr)
          : p_(p) {}

        // move support
        // handle moved-from by using release() and moved-to by using reset().

        unique_own(unique_own &&other) noexcept
          : p_(other.release())
        {
          // don't need to do since it's ctor and p_ is not assigned.
          // if (p_)
          //   T::deleter(p_);
          //
          // p_ = other.p_;
        }

        unique_own &operator=(unique_own &&other) noexcept
        {
          // if (p_)
          //   T::deleter(p_);
          //
          // p_ = other.p_;

          if (this != &other)
            reset(other.release());

          return *this;
        }

        ~unique_own() noexcept
        {
          if (p_)
          {
            // this is not `typename`
            T::deleter(p_);
          }
        }

        pointer release() noexcept
        {
          auto p = p_;
          p_ = nullptr;
          return p;
        }

        // free resource and set p
        void reset(pointer p = nullptr) noexcept
        {
          // check self-assign
          if (p_ != p)
          {
            T::deleter(p_);
            p_ = p;
          }
        }

        // swap
        void swap(unique_own &other) const noexcept
        {
          std::swap(p_, other.p_);
        }

        // *cxx-overload-oparator-bool*
        // as with unique_ptr, must have const to avoid const error
        explicit operator bool() const noexcept
        {
          return p_ != nullptr;
        }

        // *cxx-overload-oparator-dereference*
        typename T::value_type& operator*() const noexcept
        { return *p_; }

      private:
        pointer p_;
    };

  template<typename T>

    // *cxx-error*
    // void swap(unique_own &lhs, unique_own &rhs)
    // 
    // okay
    // void swap(unique_own<T> &lhs, unique_own<T> &rhs)
    //
    // okay
    void swap(const unique_own<T> &lhs, const unique_own<T> &rhs)
    {
      lhs.swap(rhs);
    }

  using unique_own_int = unique_own<pointer_int_trait>;

} // namespace

TEST(SharedPointerOwn, Unique)
{
  using namespace cxx_sp_unique_own_version;

  {
    unique_own_int up{new int(100)};

    EXPECT_TRUE(up);
    EXPECT_THAT(*up, 100);
  }

  {
    unique_ptr<int> p1(new int(1));
    unique_ptr<int> p2(new int(2));
    unique_ptr<int> p3(new int(3));
    unique_ptr<int> p4(new int(4));

    EXPECT_TRUE(p3);

    p2 = std::move(p3);     // p1->F1   , p2->F3, p3->null
    p3 = std::move(p1);     // p1->null , p2->F3, p3->F1
    p3 = std::move(p1);     // p1->null , p2->F3, p3->null

    EXPECT_FALSE(p3);
  }

  {
    unique_ptr<int> p1(new int(1));
    unique_ptr<int> p2(new int(2));
    unique_ptr<int> p3(new int(3));

    p2.reset(p3.release());

    // free int(2) and p3 is null
    
    EXPECT_TRUE(p1);
    EXPECT_TRUE(p2);
    EXPECT_FALSE(p3);

    p3.reset(p1.release());

    // p1 is null
    EXPECT_FALSE(p1);
    EXPECT_TRUE(p2);
    EXPECT_TRUE(p3);

    // frees int(1) and set p3 null
    p3.reset(p1.release());

    // p1 is null
    EXPECT_FALSE(p1);
    EXPECT_TRUE(p2);
    EXPECT_FALSE(p3);
  }

  {
    unique_own_int up1{new int(100)};
    unique_own_int up2{new int(200)};

    EXPECT_TRUE(up1);
    EXPECT_THAT(*up1, 100);

    EXPECT_TRUE(up2);
    EXPECT_THAT(*up2, 200);

    swap(up1, up2);

    EXPECT_TRUE(up1);
    EXPECT_THAT(*up1, 200);

    EXPECT_TRUE(up2);
    EXPECT_THAT(*up2, 100);
  }
}


// note that shared internal object has two: T and reference count.
// 
// template <typename>
// class shared_ptr<T>
// {
//  copy support
//  - no move support
//  operator bool();
//  T* get();
//  - no T* release(); shared_ptr do not support this
//  void reset(T*);
//  void swap(uniqie_ptr<T> &);
//  operator *()
//  operator ->()
//  use_count()
// }
//
// + non-member swap
// + self-assign

namespace cxx_sp_shared_own_version
{
  template <typename T>
    class shared_own
    {
      public:
        // ctor and dtor
        explicit shared_own(T * p = nullptr) noexcept
          : p_(p), pcount_(new size_t(1))
        {}

        ~shared_own() noexcept
        {
          if (--*pcount_ == 0)
          {
            delete p_; 
            delete pcount_;
          }
        }

        // copy support
        shared_own(const shared_own &other)
        {
          p_ = other.p_;
          pcount_ = other.pcount_;
          ++*pcount_;
        }

        shared_own &operator=(const shared_own &other)
        {
          // this requires operator==()
          // if (*this != other)
          
          if (this != &other)
          {
            if (--*pcount_ == 0)
            {
              delete p_;
              delete pcount_;
            }

            p_ = other.p_;
            pcount_ = other.pcount_;
            ++*pcount_;
          }

          return *this;
        }

        // *cxx-overload-operators*
        T& operator *() const noexcept
        {
          return *p_;
        }

        // *cxx-overload-operators*
        T* operator ->() const noexcept
        {
          return p_;
        }

        explicit operator bool() const noexcept
        {
          return p_ != nullptr;
        }

        size_t use_count()
        { return *pcount_; }

        // swap
        void swap(shared_own &other) noexcept
        {
          std::swap(p_, other.p_);
          std::swap(pcount_, other.pcount_);
        }
        
        // reset
        // use *cxx-tempprary* to delete lhs.
        void reset(T* p = nullptr) noexcept
        {
          shared_own<T>(p).swap(*this);
        }

        //
        T* get() noexcept
        {
          return p_;
        }

      private:
        T *p_;              // pointee
        size_t *pcount_;
    };

  template<typename T>
    void swap(shared_own<T> &lhs, shared_own<T> &rhs)
    {
      lhs.swap(rhs);
    }

} // namespace

TEST(SharedPointerOwn, Shared)
{
  using namespace cxx_sp_shared_own_version;

  {
    auto p = shared_own<int>(new int{42});

    // p.use++
    auto q(p);

    // all prints 2
    EXPECT_THAT(p.use_count(), 2);
    EXPECT_THAT(*p, 42);

    EXPECT_THAT(q.use_count(), 2);
    EXPECT_THAT(*q, 42);

    auto r = shared_own<int>(new int{52});

    // q.use++ and r.use--. destroies a object which r pointed. 
    r = q;

    // all prints 3
    EXPECT_THAT(p.use_count(), 3);
    EXPECT_THAT(q.use_count(), 3);
    EXPECT_THAT(r.use_count(), 3);
    EXPECT_THAT(*p, 42);
    EXPECT_THAT(*q, 42);
    EXPECT_THAT(*r, 42);
  }

  {
    shared_own<int> up1{new int(100)};
    shared_own<int> up2{new int(200)};

    EXPECT_TRUE(up1);
    EXPECT_THAT(*up1, 100);

    EXPECT_TRUE(up2);
    EXPECT_THAT(*up2, 200);

    swap(up1, up2);

    EXPECT_TRUE(up1);
    EXPECT_THAT(*up1, 200);

    EXPECT_TRUE(up2);
    EXPECT_THAT(*up2, 100);
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-sp-thread-safety

https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#shared_ptr.thread

Thread Safety

The Thread Safety section of the Boost shared_ptr documentation says
"shared_ptr objects offer the same level of thread safety as built-in types."

The implementation must ensure that concurrent updates to separate shared_ptr
instances are correct even when those instances share a reference count e.g.

shared_ptr<A> a(new A);
shared_ptr<A> b(a);

// Thread 1     // Thread 2
   a.reset();      b.reset();

The dynamically-allocated object must be destroyed by exactly one of the
  threads. Weak references make things even more interesting. The shared state
  used to implement shared_ptr must be transparent to the user and invariants
  must be preserved at all times. 
  
The key pieces of shared state are the strong and weak `reference counts`

Updates to these `need to be atomic` and visible to all threads to ensure
correct cleanup of the managed resource (which is, after all, shared_ptr's
    job!) 

On multi-processor systems memory synchronisation may be needed so that
reference-count updates and the destruction of the managed resource are
race-free.

The function _Sp_counted_base::_M_add_ref_lock(), called when obtaining a
shared_ptr from a weak_ptr, has to test if the managed resource still exists
and either increment the reference count or throw bad_weak_ptr. 

In a multi-threaded program there is a potential race condition if the last
reference is dropped (and the managed resource destroyed) between testing the
reference count and incrementing it, which could result in a shared_ptr
pointing to invalid memory.

The Boost shared_ptr (as used in GCC) features a clever lock-free algorithm to
avoid the race condition, but this relies on the processor supporting an
atomic Compare-And-Swap instruction. 

For other platforms there are fall-backs using mutex locks. Boost (as of
    version 1.35) includes several different implementations and the
preprocessor selects one based on the compiler, standard library, platform
etc. 

// SO
For the version of shared_ptr in libstdc++ the compiler and library are fixed,
    which makes things much simpler: we have an atomic CAS or we don't, see Lock
      Policy below for details. 


http://www.modernescpp.com/index.php/atomic-smart-pointers

Atomic Smart Pointers

22 February 2017

C++20 will have atomic smart pointers. To be exactly, we will get a
std::atomic_shared_ptr and a std::atomic_weak_ptr. But why? std::shared_ptr
and std::weak_ptr are already thread-safe. Sort of. Let me dive into the
details.

Before I start, I want to make a short detour. This detour should only emphasise
how import it is that the std::shared_ptr has a well-defined multithreading
semantic and you know and use it. From the multithreading point of view,
std::shared_ptr is this kind of data structures you will not use in
  multithreading programs. They are by definition shared and mutable; therefore
  they are the ideal candidates for data races and hence for undefined
  behaviour. At the other hand there is the guideline in modern C++: Don't touch
  memory. That means, use smart pointers in multithreading programs.  


Half thread-safe

I often have the question in my C++ seminars: Are smart pointers thread-safe? My
defined answer is `yes and no.` 

Why? A std::shared_ptr consists of a control block and its resource. Yes, the
control block is thread-safe; but no, the access to the resource is not
thread-safe. That means, modifying the reference counter is an atomic operation
and you have the guarantee that the resource will be deleted exactly once. These
are all guarantees a std::shared_ptr gives you.

The assertion that a std::shared_ptr provides, are described by Boost.

o A shared_ptr instance can be "read" (accessed using only const operations)
simultaneously by multiple threads.

o Different shared_ptr instances can be "written to" (accessed using mutable
    operations such as operator= or reset) simultaneously by multiple threads
(even when these instances are copies, and share the same reference count
 underneath.) 


To make the two statements clear, let me show a simple example.
When you copy a std::shared_ptr in a thread, all is fine.

std::shared_ptr<int> ptr = std::make_shared<int>(2011);

for (auto i= 0; i<10; i++) {
   std::thread([ptr]{                           (1)
     std::shared_ptr<int> localPtr(ptr);        (2)
     localPtr = std::make_shared<int>(2014);    (3)
    }).detach(); 
}

At first to (2). By using copy construction for the std::shared_ptr localPtr,
   only the control block is used. That is thread-safe. 

(3) is a little bit more interesting. localPtr (3) is set to a new
std::shared_ptr. This is from the multithreading point of view no problem: Die
lambda-function (1) binds ptr by copy. Therefore, the modification of localPtr
takes place on a copy.

The story will change dramatically if I take the std::shared_ptr by reference.

std::shared_ptr<int> ptr = std::make_shared<int>(2011);  

for (auto i= 0; i<10; i++){
   std::thread([&ptr]{                         (1)
     ptr= std::make_shared<int>(2014);         (2)
   }).detach(); 
}
 

The lambda-function binds the std::shared_ptr ptr by reference (1). Therefore
the assignment (2) is a race condition on the resource and the program has
undefined behaviour.

Admittedly that was not so easy to get. std::shared_ptr requires special
attention in a multithreading environment. They are very special. They are the
only non-atomic data types in C+ for which atomic operations exist.


Atomic Operations for std::shared_ptr

There are specialisations for the atomic operations load, store, compare and
exchange for a std::shared_ptr. By using the explicit variant you can even
specify the memory model. Here are the free atomic operations for
std::shared_ptr.


={============================================================================
*kt_dev_cxx_0000* cxx-sp-case-examples

If you want reference semantics in STL containers - whether because copying
elements is expensive or because identical elements will be shared by
different collections - you should use a smart pointer class that avoids
possible errors. In addition, using a reference wrapper is possible.

<ex> 
#include <iostream>
#include <iterator>
#include <set>
#include <deque>
#include <string>
#include <memory>
#include <algorithm>

using namespace std;

template <typename T>
inline void printItems( const std::string &msg, const T& coll )
{
  std::cout << msg;

  for( const auto &elem : coll )
    std::cout << ' ' << elem->getName() << ": " << elem->getPrice() << std::endl;
}

class Item 
{
  private: 
    string name;
    float price;

  public:
    Item( const string &n, float p = 0 ) : name(n), price(p) { }

    string getName() const { return name; }
    void setName( const string & n ) { name = n; }
    float getPrice() const { return price; }
    float setPrice( float p ) { price = p; }
};

int main()
{
  typedef shared_ptr<Item> ItemPtr;

  set<ItemPtr> allItems;
  deque<ItemPtr> bestsellers;

  // insert objects into collections
  bestsellers = { ItemPtr(new Item("Kong Yize",20.10)),
    ItemPtr(new Item("A Midsummer Night’s Dream",14.99)),
    ItemPtr(new Item("The Maltese Falcon",9.88)) };

  allItems = { ItemPtr(new Item("Water",0.44)),
    ItemPtr(new Item("Pizza",2.22)) };

  allItems.insert(bestsellers.begin(),bestsellers.end());

  // print
  printItems( "best sellers: ", bestsellers );
  printItems( "all         : ", allItems );

  cout << endl;

  // double price of bestsellers
  for_each( bestsellers.begin(), bestsellers.end(),
      [] (shared_ptr<Item> &elem) {
        elem->setPrice(elem->getPrice()*2);
        });

  // replace 2nd bestseller by 1st item with name "Pizza"
  // *algo-find-if* see const since it's *cxx-algo-non-modifying*
  bestsellers[1] = *(find_if( allItems.begin(), allItems.end(),
        [] (const shared_ptr<Item> &elem) {
          return elem->getName() == "Pizza";
          }));

  bestsellers[0]->setPrice(44.77);

  // print
  printItems( "best sellers: ", bestsellers );
  printItems( "all         : ", allItems );
}

best sellers:  Kong Yize: 20.1
 A Midsummer Night’s Dream: 14.99
 The Maltese Falcon: 9.88
all         :  Kong Yize: 20.1
 A Midsummer Night’s Dream: 14.99
 The Maltese Falcon: 9.88
 Water: 0.44
 Pizza: 2.22

best sellers:  Kong Yize: 44.77
 Pizza: 2.22
 The Maltese Falcon: 19.76
all         :  Kong Yize: 44.77
 A Midsummer Night’s Dream: 29.98
 The Maltese Falcon: 19.76
 Water: 0.44
 Pizza: 2.22


={============================================================================
*kt_dev_cxx_0000* cxx-chrono cxx-time

{cxx-ratio}

CLR-5.6 Compile-Time Fractional Arithmetic with Class ratio<>

an interface to specify compile-time fractions and to perform compile-time
arithmetic with them.

It is used in the duration and time_point libraries to efficiently create units
of time.

Predefined ratios make it more convenient to specify large or very small
numbers (see Table 5.20). They allow you to specify large numbers without the
inconvenient and error-prone listing of zeros.

namespace cxx_code
{
  // /usr/include/c++/4.9/ratio
  /**
   *  @brief Provides compile-time rational arithmetic.
   *
   *  This class template represents any finite rational number with a
   *  numerator and denominator representable by compile-time constants of
   *  type intmax_t. The ratio is simplified when instantiated.
   *
   *  For example:
   *  @code
   *    std::ratio<7,-21>::num == -1;
   *    std::ratio<7,-21>::den == 3;
   *  @endcode
   *  
   */
  template<intmax_t _Num, `intmax_t _Den = 1`> *cxx-default*
    struct ratio
    {
      // Note: sign(N) * abs(N) == N
      static constexpr intmax_t num =
        _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

      static constexpr intmax_t den =
        __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

      typedef ratio<num, den> type;
    }

  typedef ratio<1,                1000000000> nano;
  typedef ratio<1,                   1000000> micro;
  typedef ratio<1,                      1000> milli;

} // namespace

TEST(Ratio, Ratio)
{
  using FiveThirds = std::ratio<5,3>;

  // Numerator and denominator
  EXPECT_THAT(FiveThirds::num, 5);
  EXPECT_THAT(FiveThirds::den, 3);

  // Numerator and denominator
  EXPECT_THAT(std::nano::num, 1);
  EXPECT_THAT(std::nano::den, 1000000000LL);
}


{cxx-time}

CLR-5.7 Clocks and Timers

namespace cxx_code
{
  // /usr/include/c++/4.9/chrono

  /// nanoseconds
  typedef duration<int64_t, nano> 	    nanoseconds;

  /// microseconds
  typedef duration<int64_t, micro> 	    microseconds;

  /// milliseconds
  typedef duration<int64_t, milli> 	    milliseconds;

  /// seconds
  typedef duration<int64_t> 		    seconds;

  /// minutes
  typedef duration<int64_t, ratio<60>>   minutes;

  /// hours
  typedef duration<int64_t, ratio<3600>>  hours;

  /// duration
  template<typename _Rep, typename _Period>
    `struct duration`
    {
      typedef _Rep						rep;
      typedef _Period 					period;
      ...
    };

  /** @namespace std::chrono
   *  @brief ISO C++ 2011 entities sub-namespace for time and date.
   */
  namespace chrono
  {
    template<typename _Rep, typename _Period = ratio<1>> *cxx-default*
      `struct duration;`

    template<typename _Clock, typename _Dur = typename _Clock::duration>
      struct time_point;
  }

} // namespace


5.7.2 Durations, relative time

In fact, in the past, the interfaces to system time provided by C and POSIX
switched from seconds to milliseconds, then to microseconds, and finally to
nanoseconds. The problem was that for each switch, a new interface was
provided. For this reason, `a precision-neutral library` was proposed for C++11.

the goal was to provide a precision-neutral concept by `separating` duration and
point of time (“timepoint”) from specific clocks. As a result, the core of the
chrono library consists of the following types or concepts, which serve as
abstract mechanisms to specify and deal with points in and durations of time:

o A duration of time is defined as a specific number of ticks over `a time unit.`

o A timepoint is defined as combination of a duration and a beginning of time
  (the so-called epoch).

  The concept of a timepoint, however, is parametrized by a `clock`, which is
  the object that defines the `epoch` of a timepoint. Thus, different clocks
  have different epochs. In general, operations dealing with multiple
  timepoints, such as processing the duration/difference between two
  timepoints, require using the same epoch/clock. A clock also provides a
  convenience function to yield the timepoint of `now`.

  "So duration is quantity of time and timepoint is duration which has starting
  point."


A duration is a combination of a value representing `the number of ticks` and a
`fraction` representing the unit `in seconds` 

o the first template argument defines `the type of the ticks`

o the optional second template argument defines `the unit type in seconds.` 

// `20 ticks` and one time unit is 1 sec. 20 x 1
std::chrono::duration<int> twentySeconds(20);

// `0.5 tick` and one time unit is 60 secs. 0.5 x 60 = 30
std::chrono::duration<double,std::ratio<60>> halfAMinute(0.5);

// `1 tick` and one time unit is 1/1000 sec
std::chrono::duration<long,std::ratio<1,1000>> oneMillisecond(1);

For more convenience, the C++ standard library provides the following type
  definitions. With them, you can easily specify typical time periods:

std::chrono::seconds twentySeconds(20);
std::chrono::hours aDay(24);
std::chrono::milliseconds oneMillisecond(1);


Table 5.22. Other Operations and Types of durations

d.count()             Returns ticks of the duration d
duration_cast<D>(d)   Returns duration d explicitly converted into type D
duration::rep         Yields the type of the ticks


<cxx-time-duration-cast>
As we have seen, implicit conversions to a more precise unit type are always
possible. However, conversions to a coarser unit type are not, because you
might lose information.

std::chrono::seconds sec(55);
std::chrono::minutes m1 = sec;                          // ERROR
std::chrono::minutes m2 =
std::chrono::duration_cast<std::chrono::minutes>(sec);  // OK


*cxx-time-duration-cast*

A typical example is code that segments a duration into different units. For
example, the following code segments a duration of milliseconds into the
corresponding hours, minutes, seconds, and milliseconds

raw: [2 of 3600/1]::[0 of 60/1]::[55 of 1/1]::[42 of 1/1000]
     02::00::55::42

namespace cxx_time
{
  template <typename Unit, typename Ratio>
  ostream &operator<<(ostream &os, const chrono::duration<Unit, Ratio> &d)
  {
    os << "[" << d.count() << " of " << Ratio::num << "/" << Ratio::den << "]";
    return os;
  }
} // namespace cxx_time_duration_case

TEST(CxxTime, check_duration_cast)
{
  using namespace cxx_time;

  std::chrono::milliseconds ms{7255042};

  // convert ms to hours
  std::chrono::hours hh = std::chrono::duration_cast<chrono::hours>(ms);
  EXPECT_THAT(hh.count(), 2);

  // take remians which means take hours out
  std::chrono::minutes mm = std::chrono::duration_cast<std::chrono::minutes>(
    ms % std::chrono::hours(1));

  std::chrono::seconds ss = std::chrono::duration_cast<std::chrono::seconds>(
    ms % std::chrono::minutes(1));

  std::chrono::milliseconds msec =
    std::chrono::duration_cast<std::chrono::milliseconds>(
      ms % std::chrono::seconds(1));

  std::chrono::nanoseconds nsec1 =
    std::chrono::duration_cast<std::chrono::nanoseconds>(
      ms % std::chrono::seconds(1));

  uint32_t nsec2 = ((ms % std::chrono::seconds(1)).count() * 1000000L);

  std::ostringstream os{};

  os << hh << "::" << mm << "::" << ss << "::" << msec << "::" << nsec1;

  EXPECT_THAT(os.str(),
              "[2 of 3600/1]::[0 of 60/1]::[55 of 1/1]::[42 of "
              "1/1000]::[42000000 of 1/1000000000]");

  os.str("");

  // see that same count() function used as operator<<() above

  os << hh.count() << "::" << mm.count() << "::" << ss.count()
     << "::" << msec.count() << "::" << nsec1.count();

  EXPECT_THAT(os.str(), "2::0::55::42::42000000");
  EXPECT_THAT(nsec1.count(), nsec2);
}


5.7.3 Clocks and Timepoints

o A clock defines an epoch and a tick period. For example, a clock might tick
 in milliseconds since the UNIX epoch (January 1, 1970) or tick in
 nanoseconds since the start of the program. In addition, a clock provides a
 type for any timepoint specified according to this clock. The interface of
 a clock provides a function now() to yield an object for the current point
 in time.

o A timepoint represents a specific point in time by associating a positive or
  negative duration to a given clock.


clock::now()  Yields a time_point for the current point in time

Table 5.23. Operations and Types of Clocks


The C++ standard library provides three clocks, which provide this interface:

o The `system_clock` represents timepoints associated with the usual real-time
  clock of the current system. This clock also provides convenience functions
  to_time_t() and from_time_t() to convert between any timepoint and the C
  system time type time_t, which means that you can convert into and from
  calendar times

o The `steady_clock` gives the guarantee that it never gets adjusted. Thus,
  timepoint values never decrease as the physical time advances, and they
  advance at a steady rate relative to real time.

o The `high_resolution_clock` represents a clock with the shortest tick period
  possible on the current system.


// the following function prints the properties of a clock
// C represents clock
template <typename C>
void print_clock_data(ostringstream &os)
{
  using namespace std;

  os << "- precision: ";

  // clock::period 
  // Yields the type of the unit type (equivalent to clock::duration::period)

  typedef typename C::period P;

  // /usr/include/c++/4.9/ratio
  // typedef ratio<                     1000, 1> kilo;

  if( ratio_less_equal<P, std::milli>::value )
  {
    // This class template alias generates a ratio type that is the
    // multiplication of the ratio types R1 and R2.
    // 
    // The resulting type is the same as if ratio_multiply was defined as:
    //
    // template <typename R1, typename R2> 
    // using ratio_multiply = std::ratio < R1::num * R2::num, R1::den * R2::den >;

    typedef typename ratio_multiply<P, std::kilo>::type TT;
    os << fixed << double(TT::num)/TT::den << " milliseconds" << endl;
  } 
  else
  {
    os << fixed << double(P::num)/P::den << " seconds" << endl;
  }

  // clock::is_steady 
  // Yields true if the clock is steady

  os << "- is ready: " << boolalpha << C::is_steady << endl;
}


TEST(Time, ShowCronoClockDetails)
{
  ostringstream os;

  os << "system_clock: " << endl;
  print_clock_data<std::chrono::system_clock>(os);

  os << "high_resolution_clock: " << endl;
  print_clock_data<std::chrono::high_resolution_clock>(os);

  os << "steady_clock: " << endl;
  print_clock_data<std::chrono::steady_clock>(os);

  // TN: this is different from CLR result 

  char expected[] = "system_clock: \n"
    "- precision: 0.000001 milliseconds\n"
    "- is ready: false\n"
    "high_resolution_clock: \n"
    "- precision: 0.000001 milliseconds\n"
    "- is ready: false\n"
    "steady_clock: \n"
    "- precision: 0.000001 milliseconds\n"
    "- is ready: true\n";

  EXPECT_THAT(os.str(), expected);
}


<cxx-time-steady-clock>
The steady_clock is important to compare or compute the difference of two
times in your program, where you processed the current point in time.


TEST(Time, SteadyClock)
{
  {
    // now() is static function. clock returns `timepoint`
    auto system_start = chrono::system_clock::now();

    sleep(10);

    // diff is `duration`
    auto diff = chrono::system_clock::now() - system_start;

    auto sec = chrono::duration_cast<chrono::seconds>(diff);

    // cout << "this programs runs: " << sec.count() << " seconds" << endl;
    EXPECT_THAT(sec.count(), 10);
  }

  {
    // now() is static function
    auto system_start = chrono::steady_clock::now();

    sleep(10);

    auto diff = chrono::steady_clock::now() - system_start;
    auto sec = chrono::duration_cast<chrono::seconds>(diff);

    // cout << "this programs runs: " << sec.count() << " seconds" << endl;
    EXPECT_THAT(sec.count(), 10);
  }
}


`if the clock was adjusted in the meantime`, this diff might be a negative
duration. For the same reason, using timers with other than the steady_clock
might change their duration when the system clock gets adjusted. 


<cxx-time-crono-print>

Timepoints, absolute time

With any of these clocks - or even with user-defined clocks - you can deal
with timepoints. 

Class time_point provides the corresponding interface, parametrized by a
clock:

namespace std {
  namespace chrono {
    template <typename Clock,
             typename Duration = typename Clock::duration>
               class time_point;
  }
}


std::string as_string(const std::chrono::system_clock::time_point &tp)
{
    // static convenience function
    // Note also that this convenience function probably will work only for
    // system_clocks, the only clocks that provide an interface for conversions
    // to and from time_t.

    std::time_t time = std::chrono::system_clock::to_time_t(tp);

    // std::string ts = std::ctime(&time);
    std::string ts = std::asctime(gmtime(&time));

    // remove trailing newline
    ts.resize(ts.size()-1);
    return ts;
}

// epoch: Thu Jan  1 01:00:00 1970
// now  : Thu Apr 12 10:52:00 2018
// min  : Tue Sep 21 00:11:29 1677
// max  : Sat Apr 12 00:47:16 2262

// Note that it’s 1 o’clock rather than midnight. This may look a bit
// surprising, but remember that the conversion to the calendar time with
// ctime() inside asString() takes the time zone into account.  Thus, the UNIX
// epoch used here  which, again, is not always guaranteed to be the epoch of
// the system time  started at 00:00 in Greenwich, UK. In my time zone, Germany,
// it was 1 a.m. at that moment, so in my time zone the epoch started at 1 a.m.
// on January 1, 1970. Accordingly, if you start this program, your output is
// probably different, according to your time zone, even if your system uses the
// same epoch in its system clock.

// epoch: Thu Jan  1 00:00:00 1970
// now  : Thu Apr 12 10:01:32 2018
// min  : Tue Sep 21 00:12:44 1677
// max  : Fri Apr 11 23:47:16 2262


TEST(Time, Timepoint)
{
  // print the epoch of this clock

  // is equivalent to:
  // std::chrono::time_point<std::chrono::system_clock> tp
  std::chrono::system_clock::time_point tp;

  cout << "epoch: " << as_string(tp) << endl;

  tp = std::chrono::system_clock::now();
  cout << "now  : " << as_string(tp) << endl;

  tp = std::chrono::system_clock::time_point::min();
  cout << "min  : " << as_string(tp) << endl;

  tp = std::chrono::system_clock::time_point::max();
  cout << "max  : " << as_string(tp) << endl;
}

TEST(Time, TimePointArithmetic)
{
  ostringstream os;

  // one day as seconds
  typedef chrono::duration<int, ratio<3600*24>> Days;

  chrono::time_point<chrono::system_clock> tp;

  // allow adjusting timepoints by using timepoint arithmetic.
  
  // add 1 day, 23 hours, and 55 minutes to the epoch
  tp += Days(1) + chrono::hours(23) + chrono::minutes(55);
  os << "later : " << as_string(tp) << endl;

  // diff in minutes
  auto diff = tp - chrono::system_clock::time_point();
  os << "diff : " << chrono::duration_cast<chrono::minutes>(diff).count() 
    << " minutes" << endl;

  // minus 1 year (hoping it is valid and not a leap year
  tp -= chrono::hours(24*365);
  os << "-1 year: " << as_string(tp) << endl;
  
  // 3600 is 1 year
  tp -= chrono::duration<int, ratio<3600*24*365>>(50);
  os << "-50 years: " << as_string(tp) << endl;

  // 3600 is 1 year
  tp -= chrono::duration<int, ratio<3600*24*365>>(50);
  os << "-50 years: " << as_string(tp) << endl;

  char expected[] = "later : Fri Jan  2 23:55:00 1970\n"
      "diff : 2875 minutes\n"
      "-1 year: Thu Jan  2 23:55:00 1969\n"
      "-50 years: Wed Jan 15 23:55:00 1919\n"
      "-50 years: Tue Jan 26 23:55:00 1869\n";

  EXPECT_THAT(os.str(), expected);
}


see Conversions between Timepoints and Calendar Time


<cxx-time-facet>

16.2.2 Locale Facets

The dependencies on national conventions are separated into several aspects
that are handled by corresponding objects. An object dealing with a specific
`aspect of internationalization` is called a facet.

16.4.3 Time and Date Formatting

The two facets time_get<> and time_put<> in the category time provide services
`for parsing and formatting of times and dates.` This is done by the member
functions that operate on objects of type tm. This type is defined in the
header file <ctime>. The objects are not passed directly; rather, a pointer to
them is used as the argument.

Both facets in the time category depend heavily on the behavior of the
function strftime(), also defined in the header file <ctime>. This function
uses a string with conversion specifiers to produce a string from a tm object.


The time_put<> facet defines two functions called put(), which are used to
convert the date information stored in an object of type tm into a sequence of
characters written to an output iterator.

using the conversion specifier cvt
tp.put(to,fs,fill,val,cvt)      

using the conversion specifier cvt and modifier mod
tp.put(to,fs,fill,val,cvt,mod)  

first four arguments:

o to is the output iterator to which the time is written. put() returns a copy
  of this iterator with the position immediately after the last character
  written. Here, you can also pass a stream, which will be converted into a
  stream iterator.

o fs is a stream object of type std::ios_base that defines the formatting. It
  is usually a stream, imbued by the required locale and facets.

o fill is a character to use in case a filling character is needed.
 
o val is the time value of type tm* storing the date to be formatted. The
  first form of put() uses cvt to pass one of the conversion specifiers to
  strftime() to define the requested formatting.

The second form of put() allows you to provide an optional modifier. The
meaning of the argument mod is not defined by the standard. It is intended to
be used as a modifier to the conversion as found in several implementations of
the strftime() function.

// 12/04/18
// Tuesday 12/04/18 02PM

TEST(Time, Facet)
{
  ostringstream os;

  auto now = chrono::system_clock::now();
  time_t t = chrono::system_clock::to_time_t(now);
  tm *tm_now = localtime(&t);

  locale loc;
  const time_put<char> &tp = use_facet<time_put<char>>(loc);

  // %x Locale’s preferred date representation Jul 12 1998
  // 06/12/18
  
  tp.put(cout , cout, ' ', tm_now, 'x');
  cout << endl;

  // use format string
  // Tuesday 06/12/18 04PM

  string fmt = "%A %x %I%p\n";
  tp.put(cout, cout, ' ', tm_now,
      fmt.c_str(), fmt.c_str()+fmt.size());
}


<ex>

// time taken (in ms) : 939987
// time taken (in ns) : 939         // since integer division
// time taken (in ns) : 939.987
// time taken (in ns) : 939
//
// time taken (in ms) : 911476
// time taken (in ns) : 911
// time taken (in ns) : 911.476
// time taken (in ns) : 911

namespace cxx_time_elapsed
{
  struct Timer
  {
    Timer(const std::string &text) : text_(text)
    {
      start_ = chrono::system_clock::now();
    }
    ~Timer()
    {
      auto elapsed = chrono::system_clock::now() - start_;
      auto elapsed_in_ms = chrono::duration_cast<chrono::microseconds>(elapsed);
      auto elapsed_in_ns = chrono::duration_cast<chrono::milliseconds>(elapsed);

      // when this is in scope, this uses:
      //
      // ostream &operator<<(ostream &os, const chrono::duration<Unit,Ratio> &d);
      //
      // othrewise, it's error
      // cout << "time taken (in sec) : " << elapsed << endl;
      
      cout << "time taken (in ms) : " << elapsed_in_ms.count() << endl;

      // // *cxx-integer-division* 
      // cout << "time taken (in ns) : " << elapsed_in_ms.count()/1000 << endl;
      // cout << "time taken (in ns) : " << elapsed_in_ms.count()/1000.0 << endl;
      // cout << "time taken (in ns) : " << elapsed_in_ms.count()*0.001 << endl;
      // cout << "time taken (in ns) : " << elapsed_in_ns.count() << endl;

      cout << "time taken (in ns) : " << elapsed_in_ns.count() 
        << " for " << text_ << endl;
    }

    std::string text_;
    chrono::system_clock::time_point start_;
  };

} // namespace

TEST(Time, ElapsedTime)
{
  using namespace cxx_time_elapsed;

  {
    Timer timer("StringConcat");

    string result{};

    const unsigned int lots {500000};
    for (unsigned int i{0}; i < lots; i++) {
      string user{"user" + to_string(i)};

      result += user;
    }
  }

  {
    Timer timer("StringAppend");

    string result{};

    const unsigned int lots {500000};
    for (unsigned int i{0}; i < lots; i++) {
      string user{"user" + to_string(i)};

      result.append(user);
    }
  }
}

<ex>

// like lap feature of stopwatch
//
// copied from someone's code at YV.
//
// {
//   PerfCounter counter;
// 
//   for(int i=0;i<10000;++i)
//   {
//     int out;
//     sscanf("42","%d",&out);
//   }
//   counter.snap("scanf int");
// 
//   for(int i=0;i<10000;++i)
//   {
//     int out;
//     std::stringstream ss("42");
//     ss >> out;
//   }
//   counter.snap("stringstream int");
// 
//   for(int i=0;i<10000;++i)
//   {
//     int out = boost::lexical_cast<int>("42");
//   }
//   counter.snap("boost::lexical_cast<int>");
//   std::cout << counter.dump() << std::endl;
// }
//
// Start -> scanf int took 2112us
// scanf int -> stringstream int took 27859us
// stringstream int -> boost::lexical_cast<int> took 910us
// boost::lexical_cast<int> -> end took 0us

namespace cxx_time_lap
{
  // design decision:
  // in order to get diff betwen two snaps, required to access two snap. whether
  // snap() or dump() do the work to calc diff? use dump() here

  class Snapper
  {
    public:
      explicit Snapper()
      {
        start_ = chrono::system_clock::now();
      }

      void snap(const std::string text)
      {
        SnapTime st{};
        st.tp = chrono::system_clock::now();
        st.description = text;
        list_.push_back(st);
      }

      void dump()
      {
        std::string previous{"start"};
        decltype(start_) previous_time = start_;

        for (const auto &e : list_)
        {
          auto diff = e.tp - previous_time;
          cout << previous << " -> " << e.description << " took " 
            << chrono::duration_cast<chrono::microseconds>(diff).count() << " us" << endl;

          previous = e.description;
          previous_time = e.tp;
        }
      }

    private:

      struct SnapTime
      {
        chrono::system_clock::time_point tp{};
        std::string description{};
      };

      std::list<SnapTime> list_;
      chrono::system_clock::time_point start_;
  };

  class PerfCounter
  {
    public:
      PerfCounter();
      ~PerfCounter();

      void snap(const string &name_);
      void dump();

    private:
      // *cxx-nested-class*
      // since the original code uses class but makes it all public, use
      // struct instead.
      struct CounterData
      {
        CounterData(const string &name_) : name{name_}, pnext{nullptr} {}
        string name;
        CounterData *pnext;
        struct timespec ts;
      };

      // singly list but has end as well.
      CounterData *phead;
      CounterData *pend;

      // utility function
      CounterData *createSnap(const string &name_);
  };

  PerfCounter::PerfCounter()
  {
    // create a start node
    phead = pend = createSnap("start");
  }

  PerfCounter::~PerfCounter()
  {
    // clean up a list
    for (CounterData *psnap = phead; psnap;)
    {
      phead = psnap->pnext;
      std::cout << "delete " << psnap->name << std::endl;
      delete psnap;
      psnap = phead;
    }
  }

  void PerfCounter::snap(const string &name_)
  {
    CounterData *psnap = createSnap(name_);

    pend->pnext = psnap;
    pend = psnap;
  }

  // utility function to have common code in one place
  // note that use of cpp-nested-class type, `PerfCounter::CounterData` 
  // Otherwise, see compile errors.
  //
  // CounterData *PerfCounter::createSnap(const string &name_) {}
  //
  // perfcounter.cpp:45:1: error: ‘CounterData’ does not name a type
  //  CounterData *PerfCounter::createSnap(const string &name_)
  //  ^

  PerfCounter::CounterData *PerfCounter::createSnap(const string &name_)
  {
    CounterData *psnap = new CounterData(name_);
    clock_gettime(CLOCK_MONOTONIC, &(psnap->ts));
    return psnap;
  }

  // cpp-stringstream
  void PerfCounter::dump()
  {
    std::stringstream ss{};
    uint32_t countSnap{1};

    // only when there are two nodes to use
    for (CounterData *pstart = phead; 
        pstart && pstart->pnext; pstart = pstart->pnext)
    {
      ss << "snap: " << countSnap << ": ";
      ss << pstart->name << " -> " << pstart->pnext->name << " took ";

      // time diff in us from current to next
      uint64_t timeDiff = 
        (pstart->pnext->ts.tv_sec*1000000 + pstart->pnext->ts.tv_nsec/1000)-
        (pstart->ts.tv_sec*1000000 + pstart->ts.tv_nsec/1000);

      ss << timeDiff << "us" << std::endl;
      ++countSnap;
    }

    std::cout << ss.str();
  }

} // namespace


// on VM:
//
// start -> scanf int took 1609 us
// scanf int -> stringstream int took 22991 us
// stringstream int -> boost::lexical_cast<int> took 2445 us
// start -> scanf int took 1709 us
// scanf int -> stringstream int took 23523 us
// stringstream int -> boost::lexical_cast<int> took 2065 us
// ---------
// snap: 1: start -> scanf int took 1706us
// snap: 2: scanf int -> stringstream int took 23524us
// snap: 3: stringstream int -> boost::lexical_cast<int> took 2065us
// delete start
// delete scanf int
// delete stringstream int
// delete boost::lexical_cast<int>

TEST(Time, Snapper)
{
  using namespace cxx_time_lap;

  {
    Snapper counter;

    for(int i=0;i<10000;++i)
    {
      int out;
      sscanf("42","%d",&out);
    }
    counter.snap("scanf int");

    for(int i=0;i<10000;++i)
    {
      int out;
      std::stringstream ss("42");
      ss >> out;
    }
    counter.snap("stringstream int");

    for(int i=0;i<10000;++i)
    {
      int out = boost::lexical_cast<int>("42");
      (void)out;
    }
    counter.snap("boost::lexical_cast<int>");
    counter.dump();
  }

  {
    Snapper sn;
    PerfCounter pc;

    for(int i=0;i<10000;++i)
    {
      int out;
      sscanf("42","%d",&out);
    }
    sn.snap("scanf int");
    pc.snap("scanf int");

    for(int i=0;i<10000;++i)
    {
      int out;
      std::stringstream ss("42");
      ss >> out;
    }
    sn.snap("stringstream int");
    pc.snap("stringstream int");

    for(int i=0;i<10000;++i)
    {
      int out = boost::lexical_cast<int>("42");
      (void)out;
    }
    sn.snap("boost::lexical_cast<int>");
    pc.snap("boost::lexical_cast<int>");

    sn.dump();
    cout << "---------" << endl;
    pc.dump();
  }
}


==============================================================================
*kt_dev_sys_012*	dump_stack

This function can be amended to print any failed capabilities checks using printk, and a
call to the kernel function dump_stack() should give you a pretty good idea of what the
middleware was attempting at the time of the failure. A little guesswork is still required
though, as this will only show you the stack in kernel space, not in the middleware
itself.

only for glibc?


==============================================================================
*kt_dev_sys_014*	newlines between dos and linux

Q: what is it about?

Systems based on ASCII or a compatible character set use either LF (Line feed, '\n', 0x0A, 10 in
decimal) or CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF
(CR+LF, '\r\n', 0x0D0A).  These characters are based on printer commands: The line feed indicated
that one line of paper should feed out of the printer, and a carriage return indicated that the
printer carriage should return to the beginning of the current line. 

CR+LF: Microsoft Windows, DEC TOPS-10, RT-11 and most other early non-Unix and non-IBM OSes, CP/M,
MP/M, DOS (MS-DOS, PC-DOS, etc.) 

LF   : Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS,
Amiga, RISC OS, and others.

fgets() reads in at most one less than size characters from stream and stores them into the buffer
pointed to by s.  Reading stops after an EOF or a newline. If a newline is read, it is stored into
the buffer.  A '\0' is stored after the last character in the buffer. 

can check as below

[ktpark@cdilinux build_mlu]$ file platform.mk (for dos)
platform.mk: ASCII English text, with CRLF line terminators

[ktpark@cdilinux build_mlu]$ file platform.mk.kt (for unix)
platform.mk.kt: ASCII English text


# ============================================================================
#{
={============================================================================
*kt_dev_mecpp_001* 16: 80-20 rule and profiler

Think about characteristics of your app such as IO-bound or CPU-bound. If a profiler tells you about
only the number of statments and func calls, then these can give you some insight but not enough.
The important thing is the time to wait. The input to profiler should represent 20%, called
<representative>, and use as many data set as possible. 


==============================================================================
*kt_dev_mecpp_002* 17: lazy evaluation

When you employ lazy evaluation, you write your classes in such a way that they defer computations
until the results of those computations are required. If the results are never required, the
computations are never performed.

Nevertheless, it's not always a good idea.  Lazy evaluation is only useful when there's a reasonable
chance your software will be asked to perform computations that can be avoided.

Yet C++ is particularly suitable as a vehicle for user-implemented lazy evaluation, because its
support for <encapsulation> makes it possible to add lazy evaluation to a class without clients of
that class knowing it's been done. 

That means it's possible to implement a class using a straightforward eager evaluation strategy, but
then, if your profiling investigations (see Item 16) show that class's implementation is a
performance bottleneck, you can replace its implementation with one based on lazy evaluation.


Four examples and one in *kt_dev_ecpp_006*	

{reference-counting}

class String { ... };

String s1 = "Hello";
String s2 = s1;

Such a copy constructor would incur a relatively large expense, because it would have to make a copy
of s1's value to give to s2, and that would typically entail allocating heap memory via the new
operator and calling strcpy to copy the data in s1 into the memory allocated by s2. This is eager
evaluation.

But s2 hasn't been used yet.

The lazy approach is a lot less work. Instead of giving s2 a copy of s1's value, we have s2 share
s1's value. Need some book-keeping and is transparent to clients: do not know difference.

Because they only read values, not write them. 

cout << s1;            // read s1's value
cout << s1 + s2;       // read s1's and s2's values

In fact, the only time the sharing of values makes a difference is when one or the other string is
modified;

s2.convertToUpperCase();

Inside convertToUpperCase, we can be lazy no longer: we have to make a copy of s2's (shared) value
for s2's private use.


{distinguish-read-and-write}

By using lazy evaluation and proxy classes as described in Item 30, however, we can defer the
decision on whether to take read actions or write actions until we can determine which is correct.


{lazy-fetching}

Imagine large objects containing many constituent fields which can be expensive to get from
database, even worse remote database. To restore a LargeObject is quite expensive.

class LargeObject {                   // large persistent objects
public:
	 LargeObject(ObjectID id);         // restore object from disk
	 const string& field1() const;     // value of field 1
	 int field2() const;               // value of field 2
	 double field3() const;            // ...
	 const string& field4() const;
	 const string& field5() const;
...
};

If need few fields like below,

void restoreAndProcessObject(ObjectID id)
{
	LargeObject object(id);

	if (object.field2() == 0) 
	{
	 	cout << "Object " << id << ": null field2.\n";
	}
}

Data is retrieved from the database only when that particular data is needed inside the object.
Here's one way to implement this kind of <demand-paged-object-initialization>

class LargeObject {
public:
	 LargeObject(ObjectID id);
	 const string& field1() const;
	 int field2() const;
	 double field3() const;
	 const string& field4() const;
	 ...
	 private:
	 ObjectID oid;
	 mutable string *field1Value;  // see below for a
	 mutable int *field2Value;     // discussion of "mutable"
	 mutable double *field3Value;
	 mutable string *field4Value;
	 ...
};

LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), ...
{}

const string& LargeObject::field1() const
{
	 if (field1Value == 0) {
		  read the data for field 1 from the database and make
		  field1Value point to it;
	 }
	 return *field1Value;
}

Null pointers signify fields that have not yet been read from the database. Each LargeObject member
function must check the state of a field's pointer before accessing the data it points to.


The problem that null pointers may need to be initialized to point to real data from inside any
member function. So need mutable keyword. <mutable-example>

NOTE: can use smart-pointer in item28

Refer to <lazy-initialisation>.



{lazy-expression-evaluation}

For numerical application.

template<class T>
class Matrix { ... }; // for homogeneous matrices

Matrix< int> m1(1000, 1000); // a 1000 by 1000 matrix
Matrix< int> m2(1000, 1000); // ditto
...

Matrix< int> m3 = m1 + m2; // add m1 and m2

Lazy evaluation strategy: Instead, it sets up a data structure inside m3 that indicates that m3's
value is the sum of m1 and m2. Such a data structure might consist of nothing more than a pointer to
each of m1 and m2, plus an enum indicating that the operation on them is addition.

Matrix< int> m4(1000, 1000);
... // give m4 some values
m3 = m4 * m1;

We can forget all about m3 being the sum of m1 and m2 (and thereby save the cost of the
computation),

A more common scenario is that we need only part of a computation. For example, suppose we use m3 as
follows after initializing it to the sum of m1 and m2:

cout << m3[4]; // print the 4th row of m3

Clearly we can be completely lazy no longer. But there's no reason we have to compute any more than
the fourth row of m3; the remainder of m3 can remain uncomputed until it's actually needed.

To be fair, laziness sometimes fails to pay off.

m3 = m1 + m2;  // remember that m3 is the sum of m1 and m2
m1 = m4;       // now m3 is the sum of m2 and the OLD value of m1!


Because of the need to store dependencies between values; to maintain data structures that can store
values, dependencies, or a combination of the two; and to overload operators like assignment,
copying, and addition, lazy evaluation in a numerical domain is a lot of work. 

KT. Need to understand expression like a compiler and need to see if it pays off.


==============================================================================
*kt_dev_mecpp_003* 18: over-eager evaluation

The idea behind over-eager evaluation is that if you expect a computation to be requested
frequently, you can lower the average cost per request by designing your data structures to handle
the requests especially efficiently.

<caching> and <prefetching> are examples. 

{space-and-time-trade-off}

that's that greater speed can often be purchased at a cost of increased memory usage.


{lazy-or-eager}

Lazy and eager are not contradictory to each other.

Lazy evaluation is a technique for improving the efficiency of programs when you must support
operations whose results are not always needed. Over-eager evaluation is a technique for improving
the efficiency of programs when you must support operations whose results are almost always needed
or whose results are often needed more than once.

both can yield significant performance improvements in programs whose behavioral characteristics
justify the extra programming effort.


={============================================================================
*kt_dev_mecpp_004* 


={============================================================================
*kt_dev_mecpp_005* 29: reference-counting

See {own-reference-counting} for simple example. This chapter is about how to implement sharing
underlying object like stl string class.

Two motivations:




{summary}

This is optimization technique. When useful because reference-counting costs more moeny, code,
complex and work.

o For cases when objects are big and there are many sharings. More memory to save.
o For cases when there are many copy and assign between objects. More time to save.

Need profiling. However, there is a case which cannot use this technique: data structures using
self-reference which causes isolated collection of objects and reference count never drops to zero.
Therfore, industrial garbage collectors use special technique to find these.


{approach-one}

{{copy-on-write}}

class String {
	 const char& operator[] (int index) const;
	 char& operator[] (int index);
	 ...
};

const version is read-only so that is okay. If want to separate read and write for non-const, that
is to create new object only when writing. How?

cout << s[3];     // read 
s[5] = 'x';       // write

Not possible to separate. This separation could be done using proxy class, MEC++ 30, so now assume
all non-const as write.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}

	return value->data[index];
}

This if-block works only when there is sharing before and create new one only when writing happens.
So this is copy-on-write and the example of {lazy-evaluation}


{{sharable}}

However, there are cases not covered:

String s1 = "Hello";
char* p = &s1[1];

String s2 = s1;
*p = 'x';                // change s1 and s2 as well


s1 -> 2 -> "Hello"
s2 -> 

note: how about stl string class? possible?


The problem is to change underlying object not through String interface. See *kt_dev_ecpp_007* for
returning handles to internal objects.

How to solve?

o Ignore this problem
o Hava a shareable flag in which to create new object when tries to change from outside. This is
waht stl string uses. This is ON by default, operator[] turn it OFF, and cannot change it once it is
OFF. Kind of dirty flag.

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 >
			 bool sharable;
<
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1), sharable(true) # <default>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

There should be a check in member funcs.

String::String( const String& rhs )
{ >
	 if( rhs.value->sharable ) {
<		  value = rhs.value;
		  ++value->refCount;
	 }
	 else {
		  value = new StringValue( rhs.value->data );
	 }
}

Assume that returning from this call means someone outside will have a reference to internal so make
it non-sharable always.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}
>
	value->sharable = false;
<
	return value->data[index];
}

For example:

String s1 = s2 = s3 = "Hello";

s1 -> 3 -> "Hello"
s2 -> 
s3 ->

s3[3] = 'x';

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"

String s4(s3);

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"
s4 -> 1 -> "Hello"


{{make-base-class-for-reference-counting}}

To make this reference counting available to any other class, so make it base class. note there is
no data in this class.

class RCObject {
	 public:
	 	RCObject();
		RCObject( const RCObject& rhs );
		virtual ~RCObject() = 0;

		RCObject& operator= ( const RCObject& rhs );

		... public interface
		addReference();

	private:
		size_t refCount;
		bool sharable;
};


The pure virtual means it must be used as a base class.

See ctor and copy ctor in setting refCount as 0 because it simplfies thing for the client to set
refCount to 1. copy ctor always set refCount to 0 because creating a new value and new value are
always unshared and referenced only by their creator.

RCObject::RCObject(): refCount(0), sharable(true) {}
RCObject::RCObject(const RCObject&): refCount(0), sharable(true) {}

RCObject::~RCObject() {}     # see {pure-virtual-dtor}

Copy assign do nothing and will not be used in reality because it is a base class for a shared value
object(StringValue) which are not assigned to one another. Only String do. {{why-need}} It said it
is for future use but seems not useful to consider since do nothing about refCount.

RCObject& RCObject::operator=( const RCObject& )
{ return *this;}

note: Really need copy ctor and copy assign?

<delete-this> is safe only if *this is a heap object.

void RCObject::removeReference()
{
	 if(--refCount == 0 ) delete this;   # <delete-this>
}

void RCObject::addReference() { ++refCount; }


class String {
	 private:
	 	struct StringValue : public RCObject {    # <public-inheritance>
			 char* data;                           # <data>
			 StringValue( const char* initValue );
			 ~StringValue();
		};
		...
};

String::StringValue::StringValue(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
	 delete [] data;
}


          RCObject: has reference-counting feature
			 |
String -> StringValue -> data

StringValue is almost the same but now StringValue do not manipulate refCount and RCObject has. But
String should call explicitly interfaces to manage refCount. It is clumsy because String must call
these to manage reference counting. can we make it done automatically? move it out of user class?

If can detect access to StringValue through pointer, it could. This is objcet which acts like a
pointer such as smart pointer and which support member selection(->) and dereferencing(*). 


This template gives smart pointer objects control over what happens during their construction,
assignment, and destruction. When such <events> occur, this object can automatically perform the
appropriate manipulations of the refCount field in the objects to which they point.


template<class T>
class RCPtr {
public:
	RCPtr(T* realPtr = 0);
	RCPtr(const RCPtr& rhs);
	~RCPtr();
	RCPtr& operator=(const RCPtr& rhs);
	T* operator->() const; // see Item 28
	T& operator*() const;  // see Item 28
private:
	T *pointee;  // dumb pointer this object is emulating
	void init(); // common initialization code
}; 

template<class T>
RCPtr< T>::RCPtr(T* realPtr): pointee(realPtr)
{
	init();
}

template<class T>
RCPtr< T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)
{
	init();
}

template<class T>
void RCPtr< T>::init()
{
	// if the dumb pointer is null, so is the smart one
	if (pointee == 0) { 
		return;         
	}
	// if the value is not shareable, copy it
	if (pointee->isShareable() == false) { 
		pointee = new T(*pointee); 
	} 
	// note that there is now a new reference to the value
	pointee->addReference(); 
} 

The problem is when T is StringValue and the following happens:

pointee = new T(*pointee);

There is no copy ctor of StringValue and syn version will be used. So memberwise copy but not a deep
copy. Therefore, needs String::StringValue::StringValue( const StringValue& rhs ) 


{{putting-it-all-together}}

Sting is reference counted string class.

                        RCObject
			               |
String               -> StringValue -> data
+RCPtr
+nested StringValue


/*
** RCObject : base class for reference counted objects
*/
class RCObject { 
public:
	 RCObject();
	 RCObject(const RCObject& rhs);
	 RCObject& operator=(const RCObject& rhs);
	 virtual ~RCObject() = 0;
	 void addReference();
	 void removeReference();
	 void markUnshareable();
	 bool isShareable() const;
	 bool isShared() const;
private:
	 size_t refCount;
	 bool shareable;
};

RCObject::RCObject() : refCount(0), shareable(true) {}
RCObject::RCObject(const RCObject&) : refCount(0), shareable(true) {}
RCObject& RCObject::operator=(const RCObject&) { return *this; }
RCObject::~RCObject() {}
void RCObject::addReference() { ++refCount; }

void RCObject::removeReference()
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }
bool RCObject::isShareable() const
{ return shareable; }
bool RCObject::isShared() const
{ return refCount > 1; }


/*
 * RCPtr
 */
template<class T> 
class RCPtr { 
public: 
	 RCPtr(T* realPtr = 0);
	 RCPtr(const RCPtr& rhs);
	 ~RCPtr();
	 RCPtr& operator=(const RCPtr& rhs);
	 T* operator->() const;
	 T& operator*() const;
private:
	 T *pointee;
	 void init();
};

template<class T>
void RCPtr<T>::init()
{
	// if the dump pointer is null, so is the smart one
	if (pointee == 0) return;

	// if is not sharable, create new one
	if (pointee->isShareable() == false) {
		pointee = new T(*pointee);
	}
	
	// new reference
	pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr(T* realPtr) : pointee(realPtr)
{ init(); }

template<class T>
RCPtr<T>::RCPtr(const RCPtr& rhs) : pointee(rhs.pointee)
{ init(); }

template<class T>
RCPtr<T>::~RCPtr()
{ if (pointee) pointee->removeReference(); }    # <delete-this-in-removeReference>

template<class T>
RCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)
{
	 // skip when the value does not change
	 if (pointee != rhs.pointee) {

		  T *oldPointee = pointee;
		  pointee = rhs.pointee;

		  // if possible share it, else make own copy
		  init();

		  // decrease reference
		  if (oldPointee) oldPointee->removeReference();
	 }

	 return *this;
}

template<class T>
T* RCPtr<T>::operator->() const { return pointee; }

template<class T>
T& RCPtr<T>::operator*() const { return *pointee; }


/*
 * String : class to be used by users
 */
class String { 
public: 
	 String(const char *value = "");
	 const char& operator[](int index) const;
	 char& operator[](int index);

private:
	 // class representing string values
	 struct StringValue: public RCObject {
		  char *data;
		  StringValue(const char *initValue);
		  StringValue(const StringValue& rhs);
		  void init(const char *initValue);
		  ~StringValue();
	};

	RCPtr<StringValue> value;
};


void String::StringValue::init(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}
String::StringValue::StringValue(const char *initValue)
{ init(initValue); }
String::StringValue::StringValue(const StringValue& rhs)
{ init(rhs.data); }
String::StringValue::~StringValue()
{ delete [] data; }


String::String(const char *initValue)
: value( new StringValue(initValue) ) {}        # <set-rcptr>

const char& String::operator[](int index) const
{ return value->data[index]; }

char& String::operator[](int index)
{
	if (value->isShared()) {
		value = new StringValue(value->data);
	}
	value->markUnshareable();
	return value->data[index];
}

<assumption>

RCPtr< T> has:

o deep-copying copy constructor
o T inherit from RCObject, or at least that T provide all the functionality that RCObject does. T
must support the RCObject interface and it menas RCPtr and RCObject is tightly coupled.


<note-one> <difference-in-interface-of-sting>
Now there is no need to have String copy ctor, assign, and dtor because syn version doing memberwise
will call matching one of RCPtr which doing work of managing refCount. That is smart.

note: This is an example of using syn version compiler made.

Our original goal was to move the unreusable reference-counting code out of our hand-written String
class and into context-independent classes where it would be available for use with any class. Now
we've done it (in the form of the RCObject and RCPtr classes),

note: Also there is nearly no changes to String interface. encapsulation.


{{add-reference-counting-to-existing-classes}} {wrapper}

How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


={============================================================================
*kt_dev_mecpp_006* 28: log entry

Class template for making log entries whenever a T object is modified; see below for details

template<class T>
class LogEntry {
  public:
    LogEntry(const T& objectToBeModified);
    ~LogEntry();
};

void editTuple(DBPtr<Tuple>& pt)
{
  LogEntry< Tuple> entry(*pt); // make log entry for this operation

  do {
    pt->displayEditDialog();
  } while (pt->isValid() == false);
}


The LogEntry's constructor begins the log entry and its destructor ends the log entry. Two pros:

1. handles exception case
2. easier to create a single LogEntry object than to add separate calls to start and stop an entry 

#include <iostream>

using namespace std;

template<typename T>
class LogEntry {
  public:
  LogEntry( const T& obj ) { cout << "{ modifed: " << obj << endl; }
  ~LogEntry() { cout << "}" << endl; }
};

void a_function(int arg)
{
  LogEntry<int> log(arg);

  cout << "this is a function" << endl;
}

int main()
{
  cout << "this is main { " << endl;

  a_function(5);

  cout << "this is main } " << endl;
}

this is main { 
{ modifed: 5
this is a function
}
this is main } 


={============================================================================
*kt_dev_mecpp_007* link-combine C and C++

There are things to know when use both together in a program.

{name-mangling}
This is the process which C++ compiler give each function a unique name
because supports overloading. There is a directive to tell compiler not to
mangle func name. This is called `linkage directive`


{extern-keyword}
The GCC compiles files based on extension. When compiles cpp files meaning cpp
mangles names, you can make sure that functions are c functions (not to
    mangle) :

extern "C" void drawLine(int x1, int y1, int x2, int y2);

extern "C" {
	 ...
}

extern "C" {
	 #include <string.h>
}

If you want to build a function as a c function, then can do: 

extern "C" double calc( double dparam )
{
	 ...
}

To allow source or header to be compiled under either C or C++.

#ifdef __cplusplus
extern "C"
{
#endif

int strcmp( const char*, const char* );
...

#ifdef __cplusplus
}
#endif


<extern-on-typedef>
Not only for function but also for function pointer typedef.

extern "C" typedef Plugin* createFunction_t(const char *);


<case-example> <wrapper-from-cpp-to-c>
Suppose the case when main written in c uses some features written in cpp. If
there is no extern guard, then:

[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmosa.h:170:1: error: previous
declaration of 'pfmerr_t pfmThreadCreate(SPfmThreadParams*, void (*)(void*), void*)' with 'C++'
linkage 
[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmthread.cpp:80:80: error:
conflicts with new declaration with 'C' linkage


Why? Since the cpp file uses typedefs from it and when compiles the cpp file,
  compiler thinks func defs are C++ linkage from wrapper header since there is
  no extern guard and then see wrapper_func in C linkage from cpp file. So
  conflict.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typdefs               {
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}


C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                 	extern "C"
                               typdefs                {
                                                          #include "wrapper.h" 
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									                                 ....
                                                          }
																			 ...
																		}

This can be avoided if design header and source files carefully. For example,
     if need some c functions that can be used in c file and this function
     creates cpp objects and use it then simply create a header which has
     normal declarations and no externs and only have externs in cpp. The
     point is that the same header is used for both C and CPP.

// ususal c
#include "wrapper.h"
{
	wrapper_func();
}

// usual.h or wrapper.h
int wrapper_func();

// usual cpp or wrapper.cpp
extern "C"
{
  int wrapper_func()
  {
     ClassX* pclass = new Class( params );

     pclass->func();
     ...
  }
}

If usual cpp header or wrapper.h have other cpp headers, will work cpp
compiles such as usual cpp and others but when used in c compile, emits loads
of errors since these cpp files have cpp things.  So better to have single
header file which have all c functions from cpp land. Otherwise, will get
errors shown in *kt_dev_gcc_007* 

<extern-linkage>
Using extern to Specify Linkage
http://msdn.microsoft.com/en-us/library/0603949d.aspx

extern string-literal { declaration-list }
extern string-literal declaration

The extern keyword declares a variable or function and specifies that it has external linkage (its
    name is visible from files other than the one in which it's defined). When modifying a variable,
    extern specifies that the variable has static duration (it is allocated when the program begins
        and deallocated when the program ends). The variable or function may be defined in another
    source file, or later in the same file. Declarations of variables and functions at file scope
    are external by default.

In C++, when used with a string, extern specifies that the linkage conventions of another language
are being used for the declarator(s). C functions and data can be accessed only if they are
previously declared as having C linkage. However, they must be defined in a separately compiled
translation unit.

Microsoft C++ supports the strings "C" and "C++" in the string-literal field. All of the standard
include files use the extern "C" syntax to allow the run-time library functions to be used in C++
programs.

The following example shows alternative ways to declare names that have C linkage:

// specifying_linkage2.cpp
// compile with: /c
// Declare printf with C linkage.
extern "C" int printf( const char *fmt, ... );

//  Cause everything in the specified header files
//   to have C linkage.
extern "C" {
   // add your #include statements here
   #include <stdio.h>
}

//  Declare the two functions ShowChar and GetChar
//   with C linkage.
extern "C" {
   char ShowChar( char ch );
   char GetChar( void );
}

//  Define the two functions ShowChar and GetChar
//   with C linkage.
extern "C" char ShowChar( char ch ) {
   putchar( ch );
   return ch;
}

extern "C" char GetChar( void ) {
   char ch;

   ch = getchar();
   return ch;
}

// Declare a global variable, errno, with C linkage.
extern "C" int errno;


{example-from-code}
/* Define C declaration macros for C++ compatibility. */                                
#if !defined(BEGIN_C_DECLS) && !defined(END_C_DECLS)
#if defined(__cplusplus) || defined(c_plusplus)
# define BEGIN_C_DECLS extern "C" {
# define END_C_DECLS   }
#else /* !__cplusplus */
# define BEGIN_C_DECLS
# define END_C_DECLS
#endif /* __cplusplus */
#endif /* BEGIN_C_DECLS && END_C_DECLS */


{function-pointer-between}
If use function-pointer or function-pointer as arg between them, see Primus p859 for more.


{cpp-main}
The cpp-main has three stages: static-initialisation, main, and static-destruction. So if not use
cpp-main when use both, will not work as expected and shall use cpp-main.

extern "C" int realMain(...);

int main( ... )
{
	 return realMain( ... );
}

This is dependent on compiler and shall check with it.

KT: is it still ture? ture for gcc?


{new-delete-and-malloc-free}
Do not mix between new/delete and malloc/free. For example, char* strdup(char
    *ps), which is not standard in C/C++. Need to free or delete? It depends
on system and compiler so recommends that do not use funcs which is not
standard.

<Q> not standard? The ansic book do not have strdup in string.h in appendix.
This is what was said it's not standard. Now seems it's part of string.h in
GCC.

https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-strdup

Function: char * strdup (const char *s)

    Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | See POSIX Safety
    Concepts.

    This function copies the string s into a newly allocated string. The
    string is allocated using malloc; see Unconstrained Allocation. If malloc
    cannot allocate space for the new string, strdup returns a null pointer.
    Otherwise it returns a pointer to the new string. 


<online>
strdup is not a standard C++ function. but it is apparently a `Posix` function,
       and anyway it's a well known function which has been there since K&R C.
       so if you absolutely must use it, do not fret about any possible name
       collision, and just write strdup for maximum portability.

Why is strdup considered to be evil? Two reasons I can think of:

Not strictly ANSI C, but rather POSIX. Consequently, some compilers (e.g.
    MSVC) discourage use (MSVC prefers _strdup), and technically the C
standard could define its own strdup with different semantics since str is a
reserved prefix. So, there are some potential portability concerns with its
use. 

It hides its memory allocation. Most other str functions don't allocate
memory, so users might be misled (as you say) into believing the returned
string doesn't need to be freed.

But, aside from these points, I think that careful use of strdup is justified,
  as it can reduce code duplication and provides a nice implementation for
  common idioms (such as strdup("constant string") to get a mutable,
      returnable copy of a literal string).


{data-structure-in-between}
The objects that have virtual and inheritance are not compatible with C. This affects when calling
funcs with return or args between them.


==============================================================================
*kt_dev_mecpp_008*	32: program in the future tense

To be prepared for the change. How?

{one}

Express design decision in code instead of comments or documents. For example,
preventing-derivation.


{two}

Design code so that when changes are necessary, the impact is localized. Asks how the class is
designed to be used. See future thense and this is a example of virtual dtor. Encapsulation.


# ============================================================================
#{
={============================================================================
*kt_dev_estl_001*	02: illusion of container-independent code

STL is based on generalizaiton: container is array generalization, iterator is pointer, and
algorithm is function. but do not mean that can write container-independent code because each
container has different interface and characteristics. To minimize impcats of changing containers,
use <encapsulation> using typedef and class.

{no-encapsulation}

class Widget { ... };
vector< Widget > vw;
Widget bestWidget;
...
vector< Widget >::iterator i = find( vw.begin(), vw.end(), bestWidget );


{first-improvement}

class Widget { ... };
>
 typedef vector< Widget > WidgetContainer;
 WidgetContainer vw;
<
Widget bestWidget;
...
>
 WidgetContainer::iterator i = find( vw.begin(), vw.end(), bestWidget );

Also, save you some typing as think about:

map< sting, vector< Widget >::iterator, CIStingCompare>;

Want to sell out the below?

map< sting, vector< Widget >::iterator, CIStingCompare>::const_iterator;


{second-improvement}
Using typdef is not enough to separate client so use class:

class CustomerList {
	 private:
	 >
	 typedef list< Customer > CustomerContainer;
	 typedef CustomerContainer::iterator CCIterator;
	 CustomerContainer customers;
<
	 public:
	 // limit the list-specific detail visible through this interface
	 ...
};


# ============================================================================
#{ c++ concurrent in action
={============================================================================
*kt_dev_cxx_0000* cxx-ccon-thread-build cxx-boost-thread

<cxx-thread-build>

#include <iostream>
#include <thread>

using namespace std;

void hello()
{
    std::cout << "Hello concurrent world\n";
}

int main(int argc, char** argv)
{
    std::thread t(hello);
    t.join();
}

$ g++ -g -std=c++0x tthread.cpp 
$ ./a.out 
terminate called after throwing an instance of 'std::system_error'
  what():  Operation not permitted
Aborted

$ g++ -g -std=c++0x -pthread tthread.cpp 
$ ./a.out 
Hello concurrent world


<ex>
// g++ -std=c++11 -lboost_system -lboost_thread xx.cpp

#include <queue>
#include <iostream>
#include <boost/thread/locks.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/thread.hpp>

using namespace boost;

template <typename T>
class locked_queue
{
    public:
        // push an item into the end of the queue
        void push(T const &item)
        {
            mutex::scoped_lock lock(m_mutex);
            m_queue.push(item);
            // queue went from empty to one, notify a thread
            if(m_queue.size() == 1)
            {
                m_notEmptyCondition.notify_one();
            }
        }

        // pop the oldest item out of the queue
        // blocks until there are item to be popped
        T pop()
        {
            mutex::scoped_lock lock(m_mutex);
            while(m_queue.empty() == true)
                m_notEmptyCondition.wait(lock);

            T item = m_queue.front();
            m_queue.pop();
            return item;
        }

    private:
        std::queue<T> m_queue;
        mutex m_mutex;
        condition_variable m_notEmptyCondition;
};


// producer that pushes two items to a queue
void producer(locked_queue<int> *q)
{
  q->push(1);
  q->push(2);
}

// consumer that pops an item from the queue
void consumer(locked_queue<int> *q)
{
  int i = q->pop();
  std::cout << "consumer: " << i << std::endl;
}

int main()
{
  locked_queue<int> lq;

  // std::cout << "main: starts consumers" << std::endl;

  // set up two consumers to wait for items
  thread c1(bind(&consumer, &lq));
  thread c2(bind(&consumer, &lq));

  // sleep for a second to ensure c1 and c2 are ready
  // not the best code, but good enough for a test case
  sleep(2);

  // create the producer to push in two items
  thread p(bind(&producer, &lq));

  c1.join();
  c2.join();
  p.join();
 
  std::cout << "main: ends" << std::endl;
  return 0;
}


={============================================================================
*kt_dev_cxx_0000* cxx-thread

CXXSLR-18.2.1 Class std::thread

`Class thread doesn’t have a launch policy.` The C++ standard library always
tries to start the passed functionality in a new thread. If this isn’t
possible, it throws a std::system_error (see Section 4.3.1, page 43) with the
error code resource_unavailable_try_again (see Sec- tion 4.3.2, page 45).


2.1.1 Launching a thread

threads are started by constructing a std::thread object that specifies the
task to run on that thread. In the simplest case, that task is just a plain,
ordinary void-returning function that takes no parameters.


2.2 Passing arguments to a thread function

The std::thread object must be self-contained and this means initial function
and its arguments `should be copied` into a thread object.

class background_task
{
  public:
    void operator()() const
    {
      do_something();
      do_something_else();
    }
};

background_task f;

std::thread my_thread(f);

If use *cxx-callable* object, it is `copied` into the storage belonging to the
newly created thread of execution and invoked from there.

arguments exist `only in the context of the new thread.` 

It's therefore essential that the copy is `self-contained` or the result may
not be what's expected.

// *cxx-bind* std::bind uses the same mechanism.

If not self-contained, can cause lifefime issue. For stl algorithms and
predicates, use either usual function or temporary functional object and
passes it as argument. Since the temporty object is self-contained and it is
okay to use with stl algorithms. 

namespace cxx_code
{
  template<typename _Callable, typename... _Args>
    explicit 
    `thread(_Callable&& __f, _Args&&... __args)`
    {
#ifdef GTHR_ACTIVE_PROXY
      // Create a reference to pthread_create, not just the gthr weak symbol.
      auto __depend = reinterpret_cast<void(*)()>(&pthread_create);
#else
      auto __depend = nullptr;
#endif
      _M_start_thread(_S_make_state(
            std::__bind_simple(std::forward<_Callable>(__f),
              std::forward<_Args>(__args)...)),
          __depend);
    }
}


*cxx-thread-detach*
When thread object is self-contained and is detached, no need to worry about
lifetime issue.

<ex>

void update_data_for_widget( widget_id w, widget_data& data );
 
void oops_again( widget_id w )
{
  widget_data data;
 
  std::thread t( update_data_for_widget, w, data );
 
  display_status();
  t.join();                       // cxx-thread-join

  process_widget_data(data);
}
 
The problem is that process_widget_data will be passed an `unchanged data`
rather than a correctly updated version since although passed by reference,
still copied and has internal copy.

note:
This is example from the text but it seems not a valid example since it causes
compile error:

namespace cxx_thread {

  void update_data(std::string &data)
  {
    data = "updated data";
  }

  void use_reference(int &value)
  {
    value += 200;
  }

  void use_value(int value)
  {
    value += 200;
  }

} // namespace


// show how arg and return value from thread are used

TEST(CConThread, ArgumentAndReturn)
{
  using namespace cxx_thread;

  // value
  {
    int value{1};

    std::thread t(use_value, value); 
    t.join();

    EXPECT_THAT(value, 1);
  }

  // cause error:
  //
  // {
  //   int value{1};

  //   // In file included from /usr/include/c++/4.9/thread:39:0,
  //   //                  from ccon.cpp:2:
  //   // /usr/include/c++/4.9/functional: In instantiation of ‘struct std::_Bind_simple<void (*(int))(int&)>’:
  //   // /usr/include/c++/4.9/thread:140:47:   required from ‘std::thread::thread(_Callable&&, _Args&& ...) [with _Callable = void (&)(int&); _Args = {int&}]’
  //   // ccon.cpp:418:36:   required from here
  //   // /usr/include/c++/4.9/functional:1665:61: error: no type named ‘type’ in ‘class std::result_of<void (*(int))(int&)>’
  //   //        typedef typename result_of<_Callable(_Args...)>::type result_type;
  //   //                                                              ^
  //   // /usr/include/c++/4.9/functional:1695:9: error: no type named ‘type’ in ‘class std::result_of<void (*(int))(int&)>’
  //   //          _M_invoke(_Index_tuple<_Indices...>)
  //   //          ^
  //   // makefile:58: recipe for target 'ccon.o' failed
  //   // make: *** [ccon.o] Error 1

  //   std::thread t(use_reference, value);  
  //   t.join();

  //   EXPECT_THAT(value, 201);
  // }
  // 
  // TODO:
  // to understand this error, have to understand cxx-bind in 
  // /usr/include/c++/4.9/functional since cxx-thread uses __bind_simple()

  {
    int value{1};

    // *cxx-ref* to solve this error
    std::thread t(use_reference, std::ref(value));  
    t.join();

    EXPECT_THAT(value, 201);
  }

  {
    int value{1};

    std::thread t([&]{use_reference(value);}); 
    t.join();

    EXPECT_THAT(value, 201);
  }

  // Likewise, have to use std::ref() to compile and to work
  {
    std::string data{"data"};
    std::thread t(update_data, std::ref(data));
    t.join();

    // data is not updated
    EXPECT_THAT(data, string("updated data"));
  }
}


<cxx-thread-join>

the error message when main thread ends without calling t.join():
*cxx-error* *cxx-except*
terminate called without an active exception
Aborted

Once started a thread, need to explicitly decide: 

o whether to wait for it to finish by joining 
o leave it to run on its own by detaching.

If don't decide before thread object is destoryed, then your program is
terminated. the std::thread destructor calls std::terminate().

If don't wait for a thread to finish, lifetime issues can happen and that's
why must use self-contained approach.

Since not waiting for a thread termintated, when ThreadPool gets destroyed it
will destroy thread as well which may be running. Got *cxx-seg-fault* and
trace is:

#0  0x00007effab844067 in __GI_raise (sig=sig@entry=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
#1  0x00007effab845448 in __GI_abort () at abort.c:89
#2  0x00007effac131b3d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#3  0x00007effac12fbb6 in ?? () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#4  0x00007effac12fc01 in std::terminate() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#5  0x0000000000421399 in std::thread::~thread (this=0x1509040, __in_chrg=<optimized out>) at /usr/include/c++/4.9/thread:146
#6  0x0000000000425c9a in __gnu_cxx::new_allocator<std::thread>::destroy<std::thread> (this=0x1509040, __p=0x1509040) at /usr/include/c++/4.9/ext/new_allocator.h:124
#7  0x0000000000425bab in std::allocator_traits<std::allocator<std::thread> >::_S_destroy<std::thread> (__a=..., __p=0x1509040) at /usr/include/c++/4.9/bits/alloc_traits.h:282
#8  0x0000000000425a49 in std::allocator_traits<std::allocator<std::thread> >::destroy<std::thread> (__a=..., __p=0x1509040) at /usr/include/c++/4.9/bits/alloc_traits.h:411
#9  0x00000000004256e3 in std::_Sp_counted_ptr_inplace<std::thread, std::allocator<std::thread>, (__gnu_cxx::_Lock_policy)2>::_M_dispose (this=0x1509030) at /usr/include/c++/4.9/bits/shared_ptr_base.h:524
#10 0x0000000000421f00 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release (this=0x1509030) at /usr/include/c++/4.9/bits/shared_ptr_base.h:149
#11 0x0000000000421a61 in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count (this=0x1508d48, __in_chrg=<optimized out>) at /usr/include/c++/4.9/bits/shared_ptr_base.h:666
#12 0x0000000000421484 in std::__shared_ptr<std::thread, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr (this=0x1508d40, __in_chrg=<optimized out>) at /usr/include/c++/4.9/bits/shared_ptr_base.h:914
#13 0x000000000042149e in std::shared_ptr<std::thread>::~shared_ptr (this=0x1508d40, __in_chrg=<optimized out>) at /usr/include/c++/4.9/bits/shared_ptr.h:93
#14 0x00000000004216d2 in ThreadPool::~ThreadPool (this=0x1508cf0, __in_chrg=<optimized out>) at threadpool.h:10
      

class ThreadPool
{
  public:
    // ~ThreadPool()
    // {
    //     if( workt_ )
    //         workt_->join();
    // }

    void start()
    {
      workt_ = std::make_shared<std::thread>(&ThreadPool::worker, this);
    }

  private:
    std::shared_ptr<std::thread> workt_;
};


<cxx-thread-pass-member-function>

namespace cxx_thread {

  class Foo
  {
    public:
      Foo(int value = 10) : value_(value) {}
      void update_value() { value_ += 10; };
      int get_value() { return value_; }

    private:
      int value_;
  };

} // namespace


TEST(CConThread, MemberFunction)
{
  using namespace cxx_thread;

  Foo foo;

  // not
  // std::thread t(&foo::update_value, &foo);

  std::thread t(&Foo::update_value, &foo);
  t.join();
  EXPECT_THAT(foo.get_value(), 20);
}


TEST_F(AThreadPoolAddRequest, PullsWorkInAThread)
{
    // okay
    // Work work{ [&] { incrementCountAndNotify(); }};

    // error as below since AThreadPoolAddRequest::incrementCountAndNotify()
    // is a member function *cxx-lambda-capture*
    Work work{ [] { incrementCountAndNotify(); }};
}

threadpool_test.cpp: In lambda function:
threadpool_test.cpp:108:45: error: ‘this’ was not captured for this lambda function
     Work work{ [] { incrementCountAndNotify(); }};
                                             ^

<cxx-thread-non-copyable-argument>
Since unique_ptr is only moveable and not a temporary but named object, must be
requested explicitly by std::move().

void process_big_object( std::unique_ptr<big_object> );

std::unique_ptr<big_object> p( new big_object );
p->prepare_data(42);
std::thread t( process_big_object, std::move(p) );


<cxx-thread-movable>
This means that std::thread is movable to ensure that only one thread object
is associated with a particular thread of execution at any one time.

// /usr/include/c++/4.9/thread

namespace cxx_thread
{
  class thread
  {
    template<typename _Callable>
      struct _Impl : public _Impl_base
    {
      _Callable    _M_func;          // note:

      _Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
      { }

      void
        _M_run() { _M_func(); }
    };

    private:
    void _M_start_thread(__shared_base_type);

    public:

    thread() noexcept = default;

    // copy ctors
    thread(thread&) = delete;
    thread(const thread&) = delete;

    // move ctor
    thread(thread&& __t) noexcept
    { swap(__t); }

    template<typename _Callable, typename... _Args>
      explicit 
      thread(_Callable&& __f, _Args&&... __args)
      {
        _M_start_thread(_M_make_routine(std::__bind_simple(
                std::forward<_Callable>(__f),
                std::forward<_Args>(__args)...)));
      }

    template<typename _Callable> 
      shared_ptr<_Impl<_Callable>> _M_make_routine(_Callable&& __f)
      {
        // Create and allocate full data structure, not base.
        return std::make_shared<_Impl<_Callable>>(std::forward<_Callable>(__f));
      }
  };
} // namespace


<user-is-reponsible>
When provide callable to thread whether it is global function, member function
or callable via bind, it is different problem to make sure that this callable
is self-contained that is there is no external reference. That is a user to
make sure that when use thread object.


<cxx-this-thread>

namespace code_cxx
{
  /** @namespace std::this_thread
   *  @brief ISO C++ 2011 entities sub-namespace for thread.
   *  30.3.2 Namespace this_thread.
   */
  namespace this_thread
  {
    _GLIBCXX_BEGIN_NAMESPACE_VERSION

      /// get_id
      inline thread::id
      get_id() noexcept
      {
#ifdef __GLIBC__
        // For the GNU C library pthread_self() is usable without linking to
        // libpthread.so but returns 0, so we cannot use it in single-threaded
        // programs, because this_thread::get_id() != thread::id{} must be true.
        // We know that pthread_t is an integral type in the GNU C library.
        if (!__gthread_active_p())
          return thread::id(1);
#endif
        return thread::id(__gthread_self());
      }

    /// yield
    inline void
      yield() noexcept
      {
#ifdef _GLIBCXX_USE_SCHED_YIELD
        __gthread_yield();
#endif
      }

    void
      __sleep_for(chrono::seconds, chrono::nanoseconds);

    /// sleep_for
    template<typename _Rep, typename _Period>
      inline void
      sleep_for(const chrono::duration<_Rep, _Period>& __rtime)
      {
        if (__rtime <= __rtime.zero())
          return;
        auto __s = chrono::duration_cast<chrono::seconds>(__rtime);
        auto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);
#ifdef _GLIBCXX_USE_NANOSLEEP
        __gthread_time_t __ts =
        {
          static_cast<std::time_t>(__s.count()),
          static_cast<long>(__ns.count())
        };
        while (::nanosleep(&__ts, &__ts) == -1 && errno == EINTR)
        { }
#else
        __sleep_for(__s, __ns);
#endif
      }

    /// sleep_until
    template<typename _Clock, typename _Duration>
      inline void
      sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)
      {
        auto __now = _Clock::now();
        if (_Clock::is_steady)
        {
          if (__now < __atime)
            sleep_for(__atime - __now);
          return;
        }
        while (__now < __atime)
        {
          sleep_for(__atime - __now);
          __now = _Clock::now();
        }
      }

    _GLIBCXX_END_NAMESPACE_VERSION
  }
} // namespace


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-mutex cxx-threadsafe-stack cxx-lock-guard cxx-race

3.1 Problems with sharing data between threads

There are problems with sharing data between threads due to the consequences
of modifying data. The concept used is `cxx-invariant` that is statement always
true about a particular data structures. The problem is when the invariants of
the system cannot be maintained. Broken invariants.


{cxx-race-conditions} cxx-race-data-race
A race condition is anything where the outcome depends on the relative
`ordering of execution of operations` on two or more threads. It is when the
race condition leads to broken invariants that there is a problem.

Such problems will show up at the most inconvenient time since the race
conditions are `timing sensitive` and hard to find and duplicate because the
window of opportunity is small.

The C++ Standard also defines the term `data race` to mean the specific type
of race condition that arises because of concurrent modification to a single
object. uncontrolled concurrent access to a variable

<cxx-race-approaches-to-solve>
o The simplest option is to wrap your data structure with a protection
  mechanism

o lock-free programming

o software transactional memory (STM)


3.2.1 Using mutexes in C++

{cxx-mutex}
Mutexes are the most general of the data-protection mechanisms. But they're
not a silver bullet; it's important to structure your code to protect the
right data and avoid race conditions inherent in your interfaces. Mutexes also
come with their own problems, in the form of a deadlock and protecting either
too much or too little data.


{cxx-lock-guard}
std::lock_guard class template, which implements that *cxx-raii* idiom for a
mutex; it locks the supplied mutex on construction and unlock it on destruction.

<cxx-lock-guard-code> <cxx-mutex-code>

namespace cxx_ccon 
{
  // /usr/include/c++/4/9/mutex

  /// mutex
  class mutex : private __mutex_base
  {
    public:
      typedef __native_type* native_handle_type;

#ifdef __GTHREAD_MUTEX_INIT
      constexpr
#endif
        mutex() noexcept = default;
      ~mutex() = default;

      mutex(const mutex&) = delete;
      mutex& operator=(const mutex&) = delete;
  };


  /// @brief  Scoped lock idiom.
  // `Acquire the mutex here with a constructor call`, then release with
  // the destructor call in accordance with RAII style.
  template<typename _Mutex>
    class lock_guard
    {
      public:
        typedef _Mutex mutex_type;

        explicit lock_guard(mutex_type& __m) : _M_device(__m)
        { _M_device.lock(); }

        lock_guard(mutex_type& __m, adopt_lock_t) : _M_device(__m)
        { } // calling thread owns mutex

        ~lock_guard()
        { _M_device.unlock(); }

        lock_guard(const lock_guard&) = delete;
        lock_guard& operator=(const lock_guard&) = delete;

      private:
        mutex_type&  _M_device;
    };
} 


<ex>

namespace cxx_mutex
{
  std::mutex print_mutex;

  size_t i{};

  std::string print(std::string const& s)
  {
    std::lock_guard<std::mutex> l(print_mutex);
    std::string result{};

    for (i = 0; i < s.size(); ++i)
    {
      this_thread::sleep_for(chrono::milliseconds(20));
    }

    result = "waited for " + to_string(i*20) + "ms and " + s;
    return result;
  }

  std::string print_no_lock(std::string const& s)
  {
    // std::lock_guard<std::mutex> l(print_mutex);

    std::string result{};

    for (i = 0; i < s.size(); ++i)
    {
      this_thread::sleep_for(chrono::milliseconds(20));
    }

    result = "waited for " + to_string(i*20) + "ms and " + s;
    return result;
  }

  // void print_no_lock(std::string const& s)
  // {
  //   for (char c : s)
  //   {
  //     this_thread::sleep_for(chrono::milliseconds(20));
  //     std::cout.put(c);
  //   }
  //   std::cout << std::endl;
  // }

} // cxx_mutex

TEST(CConLock, LockGuard)
{
  using namespace cxx_mutex;

  {
    auto f1 = std::async(std::launch::async,
        print, "Hello from a first thread");

    auto f2 = std::async(std::launch::async,
        print, "Hello from a second thread");

    EXPECT_THAT(f1.get(), 
        "waited for 500ms and Hello from a first thread");

    EXPECT_THAT(f2.get(), 
        "waited for 520ms and Hello from a second thread");
  }

  {
    auto f1 = std::async(std::launch::async,
        print_no_lock, "Hello from a first thread");

    auto f2 = std::async(std::launch::async,
        print_no_lock, "Hello from a second thread");

    EXPECT_THAT(f1.get(), 
        Ne("waited for 500ms and Hello from a first thread"));

    EXPECT_THAT(f2.get(), 
        Ne("waited for 520ms and Hello from a second thread"));
  }

  // mangled output when use stdout
  //
  // HHHeeellllllooo   fffrrrooommm   aaa   msfaeiicrnos nttd h trthehrared
  // eaad
  // d
  // 
  // {
  //   using namespace cxx_mutex_no_lock;
  //
  //   auto f1 = std::async(std::launch::async,
  //       print, "Hello from a first thread");
  //
  //   auto f2 = std::async(std::launch::async,
  //       print, "Hello from a second thread");
  //
  //   print("Hello from a main thread");
  // }
}


{cxx-mutex-not-silver-bullet}
If all the member functions of the class lock the mutex before accessing any
other data members and unlock it when done, the data is nicely protected from
all comers.

Really?

Well, that’s not quite true. If one of the member functions returns a pointer
or reference to the protected data? doesn't matter that the member functions
all lock the mutex

Protecting data with a mutex therefore requires careful interface design, to
ensure that the mutex is locked before there's any access to the protected
data and that there are no backdoors.

If do careful design, the data is safe now? No. If dig a little deeper, it's
not that straightforward. Nothing ever is.

As well as checking that the member functions don't pass out pointers or
references to their callers. also to check that they don't pass such pointers
or references in to functions they call that aren't under your control;
functions that are supplied at runtime via a function argument or other means

<ex>
Accidentally passing out a reference to protected data

class some_data
{
  int a;
  std::string b;

  public:
    void do_something();
};

class data_wrapper
{
  private:
    some_data data;
    std::mutex m;
  public:
    template<typename Function> void process_data(Function func)
    {
      std::lock_guard<std::mutex> l(m);

      // pass "protected" data to user-supplied function
      func(data);
    }
};

some_data* unprotected;

void malicious_function(some_data& protected_data)
{
    unprotected=&protected_data;
}

data_wrapper x;

void foo()
{
    x.process_data(malicious_function);

    // unprotected access to protected data
    unprotected->do_something();
}


{cxx-race-condition-inherent-in-interface}

3.2.3 Spotting race conditions inherent in interfaces

Consider the doubly linked list example again. In order for a thread to safely
delete a node, you need to ensure that you're preventing concurrent accesses
to `three nodes:` the node being deleted and the nodes on either side. If you
protected accesses to the pointers of each node individually, you'd be no
better off than with code that used no mutexes, because the race condition
could still happen:

it's not the individual nodes that need protecting for the individual steps
but the whole data structure, for the whole delete operation. The easiest
solution in this case is to have a single mutex that protects the entire list.


<ex> cxx-stack cxx-threadsafe-stack

Just because individual operations on the list are safe, you're not out of the
woods yet; you can still get race conditions, even with a really simple
interface since interface is not well designed. Consider std::stack<>, listing
3.3.

namespace cxx_code
{
  // bits/stl_stack.h

  template<typename _Tp, typename _Sequence = deque<_Tp>> 
    class stack
    {
      /**
       *  Returns true if the %stack is empty.
       */
      bool
        empty() const
        { return c.empty(); }

      /**  Returns the number of elements in the %stack.  */
      size_type
        size() const
        { return c.size(); }

      /**
       *  Returns a read/write reference to the data at the first
       *  element of the %stack.
       */
      reference
        top()
        {
          __glibcxx_requires_nonempty();
          return c.back();
        }

      /**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %stack.
       */
      const_reference
        top() const
        {
          __glibcxx_requires_nonempty();
          return c.back();
        }

      /**
       *  @brief  Add data to the top of the %stack.
       *  @param  __x  Data to be added.
       *
       *  This is a typical %stack operation.  The function creates an
       *  element at the top of the %stack and assigns the given data
       *  to it.  The time complexity of the operation depends on the
       *  underlying sequence.
       */
      void
        push(const value_type& __x)
        { c.push_back(__x); }

#if __cplusplus >= 201103L
      void
        push(value_type&& __x)
        { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
        { c.emplace_back(std::forward<_Args>(__args)...); }
#endif

      /**
       *  @brief  Removes first element.
       *
       *  This is a typical %stack operation.  It shrinks the %stack
       *  by one.  The time complexity of the operation depends on the
       *  underlying sequence.
       *
       *  Note that no data is returned, and if the first element's
       *  data is needed, it should be retrieved before pop() is
       *  called.
       */
      void
        pop()
        {
          __glibcxx_requires_nonempty();
          c.pop_back();
        }
    };
} // namespace


If change two things:

o top() returns a copy rather than a reference so follow guideline that advise
  do not pass reference or pointer to protected data.

o protect the internal data with a mutex in stack interface

Still subject to cxx-race and The problem is not about mutex-based
implementation. `it's an interface problem` so the race would still occur with
a lock-free implementation. the interface is inherently subject to race.

`The problem is that the result of empty() and size() can't be relied on.` 

stack<int> s;

if(!s.empty())                            <-
{
    int const value = s.top();      <-    <-
    s.pop();                        <-
    do_something(value);
}

o possible race betwen empty and top

if there might be a call to pop() from another thread and this cause to call
top() on an empty stack which is undefined, *cxx-undefined*

o possible race between top and pop

Another race and far more 'insidious'. One of the two values on the stack is
discarded without ever having been read, whereas the other is processed
twice; two top() at the same time and one pop() on each thread. 


If combines that call to top() and pop() under the protection of the mutex
then still has an issue. Consider stack<vector<int>> and vector has lots of
elements. If pop() was defined to return the value popped as well as remove it
from the stack then potential problem:

the value being popped is returned to the caller only after the stack has been
modified, but the process of copying the data to return to the caller might
throw an exception. If this happens, the data just popped is lost; it has been
removed from the stack, but the copy was unsuccessful. 

The designers of the std::stack interface helpfully split the operation in
two: get the top element (top()) and then remove it from the stack (pop()), so
that if you can’t safely copy the data, it stays on the stack. 

Unfortunately, it’s precisely this split that you’re trying to avoid in
eliminating the race condition! Thankfully, there are alternatives, but they
aren’t without cost.

How to avoid this problem of copying?


<1> Pass a reference to receive the popped value.

std::vector<int> result;
some_stack.pop(result);

To remove the problem of copying, use reference. However, it has the distinct
disadvantage that it requires the calling code to construct an instance of the
stack’s value type prior to the call, in order to pass this in as the target.


<2> Use no-throw copy or move constructor. 

There’s only an exception safety problem with a value-returning pop() if the
return by value can throw an exception. Many types have copy constructors that
don’t throw exceptions, and with the new rvalue-reference support in the C++
Standard (see appendix A, section A.1), many more types will have a move
constructor that doesn’t throw exceptions, even if their copy constructor
does.

One valid option is to restrict the use of this thread-safe stack to those
types that can safely be returned by value without an exception. note that may
change as more type supports move semantics. 


<3> Return a pointer to the popped item. 

That is to use dynamically allocated item and pass its pointer. The advantage
here is that pointers can be freely copied without throwing an exception, so
you've avoided Cargill’s exception problem.

However, requiring that each object in the stack be allocated separately with
new would impose quite an overhead compared to the original non-thread-safe
version.


<4> Provide both option 1 and either option 2 or 3. 

Flexibility should never be ruled out, especially in generic code. If you’ve
chosen option 2 or 3, it’s relatively easy to provide option 1 as well, and
this provides users of your code the ability to choose whichever option is
most appropriate for them for very little additional cost.

<ex>

namespace cxx_ccon
{
  struct empty_stack : std::exception
  {
    const char *what() const noexcept
    {
      return "empty_stack exception";
    }
  };

  template<typename T>
    class threadsafe_stack
    {
      public:
        threadsafe_stack() {}

        // This stack implementation is actually copyable; the copy
        // constructor locks the mutex in the source object and then copies
        // the internal stack. You do the copy in the constructor body rather
        // than the member initializer list in order to ensure that the mutex
        // is held across the copy.

        threadsafe_stack(const threadsafe_stack &other)
        {
          // see lock(other.m);
          
          std::lock_guard<mutex> lock(other.m);
          data = other.data;
        }

        // disallow for simplicity

        threadsafe_stack &operator=(const threadsafe_stack &) = delete;

        void push(T value)
        {
          std::lock_guard<mutex> lock(m);
          data.push(value);
        }

        // option 3, if make_shared() throes, data is not modified.
        //
        // The pop() functions throw an empty_stack exception if the stack is
        // empty, so everything still works even if the stack is modified
        // after a call to empty().
        //
        // although it returns pointer, it's a pointer to item but not
        // internal stack itself. 

        std::shared_ptr<T> pop()
        {
          std::lock_guard<mutex> lock(m);
          if (data.empty())
            throw empty_stack();

          std::shared_ptr<T> const res(std::make_shared<T>(data.top()));
          data.pop();
          return res;
        }

        // option 1, use reference

        void pop(T &value)
        {
          std::lock_guard<mutex> lock(m);
          if (data.empty())
            throw empty_stack();

          value = data.top();
          data.pop();
        }

        // no need empty() since use exception.
        // Your five stack operations have now become three: push(), pop(),
        // and empty(). Even empty() is superfluous.

        bool empty() const
        {
          std::lock_guard<mutex> lock(m);
          return data.empty();
        }

      private:
        std::stack<T> data;

        // *cxx-mutable*
        mutable std::mutex m;
    };
} // namesapce

TEST(CConRace, ThreadSafeStack)
{
  using namespace cxx_ccon;

  threadsafe_stack<int> tss;

  // tss.push(1);
  // tss.push(2);
  // tss.push(3);
  // tss.push(4);

  tss.push(5);
  auto sp = tss.pop();

  EXPECT_THAT(*sp, 5);

  // this raises an exception
  if (tss.empty())
  {
    int x;
    EXPECT_THROW(tss.pop(x), empty_stack);
  }
}

cxx-lock-granularity

As the discussion of top() and pop() shows, problematic race conditions in
interfaces essentially arise because of locking at too small a granularity;
the protection doesn’t cover the entirety of the desired operation.


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-not-copyable

cxx-mutex and cxx-condition-variable are not copyable as:

namespace cxx_ccon
{
  /// mutex
  class mutex : private __mutex_base
  {
    public:
      typedef __native_type* 			native_handle_type;

      mutex(const mutex&) = delete;
      mutex& operator=(const mutex&) = delete;
  };

  /// condition_variable
  class condition_variable
  {
    public:
      condition_variable(const condition_variable&) = delete;
      condition_variable& operator=(const condition_variable&) = delete;
  };
}

<ex>

namespace cxx_condition
{
  template <typename T>
    class locked_queue {
      public:
        void push(T const& item)
        {
          std::lock_guard<std::mutex> lock(m_);
          queue_.push(item);

          // as soon as there are items in queue
          if (queue_.size())
            cond_.notify_one();
        }

        T pop() 
        {
          // to use with cxx-condition
          std::unique_lock<std::mutex> lock(m_);

          while (queue_.empty())
            cond_.wait(lock);

          T item = queue_.front();
          queue_.pop();
          return item;
        }

      private:
        std::queue<T> queue_;
        std::mutex m_;
        std::condition_variable cond_;
    };

  int consumed{};

  // *cxx-error*
  void consumer(locked_queue<int>& q)
  {
    for (int i = 0; i < 10; ++i)
    {
      q.pop();
      ++consumed;
    }
  }

  void consumer(locked_queue<int>* q)
  {
    for (int i = 0; i < 10; ++i)
    {
      // use operator->()
      q->pop();
      ++consumed;
    }
  }

} // namesapce

TEST(CConCondition, NotCopyable)
{
  using namespace cxx_condition;

  locked_queue<int> q;

  // *cxx-error*
  // ccon_ex.cpp:89:30:   required from here
  // /usr/include/c++/4.9/tuple:142:42: error: use of deleted function ‘cxx_condition::locked_queue<int>::locked_queue(cxx_condition::locked_queue<int>&&)’
  //   : _M_head_impl(std::forward<_UHead>(__h)) { }
  //                                           ^
  // ccon_ex.cpp:31:11: note: ‘cxx_condition::locked_queue<int>::locked_queue(cxx_condition::locked_queue<int>&&)’ is implicitly deleted because the default definition would be ill-formed:
  //      class locked_queue {
  //            ^
  // ccon_ex.cpp:31:11: error: use of deleted function ‘std::mutex::mutex(const std::mutex&)’
  // In file included from /usr/include/c++/4.9/future:39:0,
  //                  from ccon_ex.cpp:3:
  // /usr/include/c++/4.9/mutex:129:5: note: declared here
  //      mutex(const mutex&) = delete;
  //      ^
  // ...

  std::thread c1(&consumer, q);
}

TEST(CConCondition, Okay)
{
  using namespace cxx_condition;

  locked_queue<int> q;

  // use pointer instead which works
  std::thread c1(&consumer, &q);
}


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-lock cxx-deadlock

The standard library offers help in the form of an operation for acquiring
several locks simultaneously with regard to deadlock problem.

3.2.4 Deadlock: the problem and a solution

<cxx-deadlock>
deadlock does not just occur with locks: can occur any synchronization
construct that can lead to a wait: `neither thread can make progress`
because it is waiting for the other to finish."

Simple rules that can help you to write deadlock-free code.

o Avoid nested locks

o Avoid calling user-supplied code while holding a lock

o Acquire locks in a fixed or the same order


<cxx-lock-std-lock>
The C++ standard library, therefore, provides convenience functions to try to
lock multiple mutexes.

std::lock() can lock two or more mutexes at `once without risk of deadlock`
and provides `all-or-nothing semantics`

<ex>
class X
{
  private:
    std::mutex m;

  public:

    friend void swap( X& lhs, X& rhs )
    {
      if( &lhs == &rhs )
        return;

      // lock both mutexes (or none if not possible)
      std::lock(lhs.m, rhs.m);

      // std::adopt_lock to indicate to std::lock_guard objects that the
      // mutexes are 'already' locked.

      std::lock_guard<std::mutex> lock_a( lhs.m, std::adopt_lock );
      std::lock_guard<std::mutex> lock_b( rhs.m, std::adopt_lock );

      swap( lhs.some_detail, rhs.some_detail );
    }
};

The global std::lock() locks all mutexes passed as arguments, blocking until
all mutexes are locked or until an exception is thrown. In the latter case, it
unlocks mutexes already successfully locked. As usual, after successful
locking, you can and should use a lock guard initialized with adopt_lock as
second argument to ensure that, in any case, the mutexes are unlocked when
leaving the scope. Note that this lock() provides a `deadlock-avoidance`
mechanism, which, however, means that the order of locking inside a multiple
lock is undefined.


<cxx-lock-hierarchy>
This is really `a particular case of lock-ordering` and can provide a means of
checking at runtime. 

The idea is that you divide your application into layers and identify all the
mutexes that may be locked in any given layer. When code tries to lock a
mutex, it isn’t permitted to lock that mutex if it already holds a lock from a
lower layer. So from higher to lower


hierarchical_mutex high_level_mutex(10000);
hierarchical_mutex low_level_mutex(5000);

int do_low_level_stuff();

int low_level_func()
{
    std::lock_guard< hierarchical_mutex> lk( low_level_mutex );
    return do_low_level_stuff();
}

void high_level_stuff(int some_param);

void high_level_func()
{
    std::lock_guard< hierarchical_mutex > lk( high_level_mutex );
    high_level_stuff( low_level_func() );
}

// thread_a() g abides by the rules, so it runs fine. 
//
// thread_a() calls high_level_func(), which locks the high_level_mutex e
// (with a hierarchy value of 10000) and then calls low_level_func() f with
// this mutex locked in order to get the parameter for high_level_stuff().
// low_level_func() then locks the low_level_mutex, but that’s fine because
// this mutex has a lower hierarchy value of 5000.

void thread_a()
{
    high_level_func();
}

hierarchical_mutex other_mutex(100);

void do_other_stuff();

void other_stuff()
{
    high_level_func();
    do_other_stuff();
}


// On the other hand, thread_b() disregards the rules and therefore will fail
// at runtime. 
//
// it locks the other_mutex, which has a hierarchy value of only 100. This
// means it should really be protecting ultra-low-level data. When
// other_stuff() calls high_level_func(), it’s thus violating the hierarchy:
// high_level_func() tries to acquire the high_level_mutex, which has a value
// of 10000, considerably more than the current hierarchy value of 100.

void thread_b()
{
    std::lock_guard< hierarchical_mutex > lk(other_mutex);
    other_stuff();
}

This does mean that can't hold two locks at the same time if they're the same
level in the hierarchy so hand-over-hand locking schemes require that each
mutex in the chain have a lower value than the prior one which my be
impractical in some cases.


<ex> cxx-mutex-user-defined 

Listing 3.8 A simple hierarchical mutex

Show the use of std::lock_guard with user-defined mutex type. Have to have
three member functions: lock, unlock and try_lock

class hierarchical_mutex
{
  std::mutex internal_mutex;

  unsigned long const hierarchy_value;
  uisigned long previous_hierarchy_value;

  // this is value of previous lock
  //
  // *cxx-static* *os-thread-local-storage* *cxx-thread-local* *cxx-11*
  // since it is declared thread_local, every thread has its `own copy`
  // NOTE: have to use `static thread_local`

  static thread_local unsigned long `this_thread_hierarchy_value`;

  // hierarchy value should go from high to low

  void check_for_hierarchy_violation()
  {
    if( this_threa_hierarchy_value <= hierarchy_value )
    {
      throw std::logic_error( "mutex hierarchy violated" );
    }
  }

  void update_hierarchy_value()
  {
    previous_hierarchy_value = this_thread_hierarchy_value;
    this_thread_hierarchy_value = hierarchy_value;
  }

  public:

  explicit hierarchical_mutex( unsigned long value ):
    `hierarchy_value(value)`, previous_hierarchy_value( 0 )
  {}

  void lock()
  {
    check_for_hierarchy_violation();
    internal_mutex.lock();
    `update_hierarchy_value();`
  }

  void unlock()
  {
    this_thread_hierarchy_value = previous_hierarchy_value;
    internal_mutex.unlock();
  }

  bool try_lock()
  {
    check_for_hierarchy_violation();
    if( internal_mutex.try_lock() )
      return false;
    update_hierarchy_value();
    return true;
  }
};

thread_local unsigned long
   hierarchical_mutex::this_thread_hierarchy_value( ULONG_MAX );


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-lock-unique-lock cxx-lock

std::unique_lock provides more `flexibility than std::lock_guard`

o the ability to program explicitly when and how to lock or unlock its mutex.
  Thus, this lock object may or may not have a mutex locked (also known as
  owning a mutex). 

  This differs from a *cxx-lock-guard* which always has an object locked
  throughout its lifetime.

o std::defer_lock to indicate that the mutex should remian unlocked on
  construction then later locked by calling std::unique_lock.lock().

o std::unique_lock is typically larger and has a slight performance penalty so
  lock_guard is in preference if it suits.

<cxx-lock-unique-lock>

namespace cxx_ccon
{
  // bits/std_mutex.h

  /// unique_lock
  template<typename _Mutex>
    class unique_lock
    {
      public:
        typedef _Mutex mutex_type;

        unique_lock() noexcept
          : _M_device(0), _M_owns(false)
          { }

        // *cxx-lock-unique-default*
        explicit unique_lock(mutex_type& __m)
          : _M_device(&__m), _M_owns(false)
        {
          lock();
          _M_owns = true;
        }

        ~unique_lock()
        {
          if (_M_owns)
            unlock();
        }
    }
}

Listing 3.6 Using std::lock() and std::lock_guard in a swap operation

class X
{
  private:
    std::mutex m;

  public:

    friend void swap( X& lhs, X& rhs )
    {
      if( &lhs == &rhs )
        return;

      std::lock( lhs.m, rhs.m );

      // std::adopt_lock to indicate to std::lock_guard objects that the
      // mutexes are `already` locked.

      std::lock_guard<std::mutex> lock_a(lhs.m, `std::adopt_lock` );
      std::lock_guard<std::mutex> lock_b(rhs.m, `std::adopt_lock` );

      swap( lhs.some_detail, rhs.some_detail );
    }
};

Listing 3.9 Using std::lock() and std::unique_lock in a swap operation

class X
{
  private:
    std::mutex m;

  public:

    friend void swap( X& lhs, X& rhs )
    {
      if( &lhs == &rhs )
        return;

      std::unique_lock<std::mutex> lock_a(lhs.m, `std::defer_lock` );
      std::unique_lock<std::mutex> lock_b(rhs.m, `std::defer_lock` );

      std::lock( lock_a, lock_b );

      swap( lhs.some_detail, rhs.some_detail );
    }
};


<cxx-lock-unique-lock>

the following supplementary constructors:

You can pass try_to_lock for a nonblocking attempt to lock a mutex:

std::unique_lock<std::mutex> lock(mutex, std::try_to_lock);
...
if (lock) { // if lock was successful
...
}


You can pass a duration or timepoint to the constructor to try to lock for a
specific period of time:

std::unique_lock<std::timed_mutex> lock(mutex, std::chrono::seconds(1));
...


*cxx-lock-unique-lock-defer-lock*
You can pass defer_lock to initialize the lock without locking the mutex
(yet):

std::unique_lock<std::mutex> lock(mutex, std::defer_lock);
...
lock.lock(); // or (timed) try_lock()
...


{transfer-ownership} like unique_ptr
Because unique_lock instances don't have to own their associated mutexes, the
ownership of a mutex can be transferred between instances by moving the
instances around.

One possible use is to allow a function to lock a mutex and transfer ownership
of that lock to the caller, so the caller can then perform additional actions
`under the protection of the same lock.`

// *cxx-return*
// lk is local variable and can be returned without calling std::move since
// the compiler takes care of calling the move constructor.

std::unique_lock<std::mutex> get_lock()
{
    // some_mutex is extern
    extern std::mutex some_mutex;

    std::unique_lock<std::mutex> lk( some_mutex );
    prepare_data();

    return lk;
}

void process_data()
{
    std::unique_lock<std::mutex> lk(get_lock());
    do_something();
}


<cxx-lock-unique-lock-granulity>
std::unique_lock works well in this situation, because you can call unlock()
when the code no longer needs access to the shared data and then call lock()
again if access is required later in the code:

void get_and_process_data()
{
    std::unique_lock<std::mutex> my_lock(the_mutex);

    some_class data_to_process = get_next_data_chunk();

    my_lock.unlock();

    retult_type result = process( data_to_process );

    my_lock.lock();

    write_result( data_to_process, result );
}


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-call-once

3.3 Alternative facilities for protecting shared data

One particularly extreme (but remarkably common) case is where the shared data
needs protection `only from concurrent access while it’s being initialized,` but
after that no explicit synchronization is required. This might be because the
data is read-only once created, and so there are no possible synchronization
issues, or it might be because the necessary protection is performed
implicitly as part of the operations on the data.

Locking a mutex after the data has been initialized is unnecessary and a
needless hit to performance.

It's for this reason that the C++ Standard provides a mechanism purely for
protecting shared data during initialization.

Suppose you have a shared resource that's so expensive to construct that you
want to do so only if it's actually required; maybe it opens a database
connection or allocates a lot of memory. *cxx-lazy-initialization* such as
this is common in single-threaded code

std::shared_ptr<some_resource> resource_ptr;

void foo()
{
  if(!resource_ptr)
  {
    // If the shared resource itself is safe for concurrent access, the only
    // part that needs protecting when converting this to multithreaded code
    // is the initialization

    resource_ptr.reset(new some_resource);
  }

  // If the shared resource itself is safe for concurrent access, the only

  resource_ptr->do_something();
}


A naive translation to multithreaded which cause `unnecessary serialization`
of threads using the resource. This is because each thread must wait on the
mutex in order to check whether the resource has already been initialized.


std::shared_ptr<some_resource> resource_ptr;

std::mutex resource_mutex;

void foo()
{
  std::unique_lock<std::mutex> lk(resource_mutex);

  if(!resource_ptr)
  {
    resource_ptr.reset(new some_resource);
  }
  lk.unlock();

  resource_ptr->do_something();
}


<cxx-call-once>
C++ provides std::once_flag and std::call_once to handle this situation. Every
thread can just use std::call_once and this do the same as "naive translation"
but has a lower overhead.


std::shared_ptr<some_resource> resource_ptr;

`std::once_flag` resource_flag;

void init_resource()
{
  resource_ptr.reset(new some_resource);
}

void foo()
{
  `std::call_once`(resource_flag, init_resource);      // is called exactly once
  resource_ptr->do_something();
}


The example when used with a class:

class X
{
  private:
    connection_info connection_details;
    connection_handle connection;
    std::once_flag connection_init_flag;
    void open_connection()
    {
      connection=connection_manager.open(connection_details);
    }

  public:
    X(connection_info const& connection_details_):
      connection_details(connection_details_)
  {}

    void send_data(data_packet const& data)
    {
      std::call_once(connection_init_flag, &X::open_connection, this);
      connection.send_data(data);
    }

    data_packet receive_data()
    {
      std::call_once(connection_init_flag,&X::open_connection,this);
      return connection.receive_data();
    }
};

As with std::thread and std::bind, used additional argument to call_once.


*cxx-ccon-not-copyable*

// ???

It's worth noting that, like std::mutex, std::once_flag instances can't be
copied or moved, so if you use them as a class member like this, you'll have
to explicitly define these special member functions should you require them.


<alternative-to-call-once>
One scenario where there's a potential race condition over initialization is
that of a local variable declared with static.

*cxx-pattern-singleton* *cxx-init-order-problem*

In C++11 this problem is solved: the initialization is defined to happen on
exactly one thread, and no other threads will proceed until that
initialization is complete, so the race condition is just over which thread
gets to do the initialization rather than anything more problematic. This can
be used as an alternative to std::call_once for those cases 

`where a single global instance is required:`

Protecting data only for initialization is a special case of a more general
scenario: that of a rarely updated data structure. For most of the time, such
a data structure is read-only and can therefore be merrily read by multiple
threads concurrently.


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-shared-lock cxx-boost-shared-lock

<cxx-shared-lock> 

3.3.2 Protecting rarely updated data structures

This new kind of mutex is typically called a reader-writer mutex, because it
allows for two different kinds of usage: exclusive access by a single “writer”
thread or shared, concurrent access by multiple “reader” threads.

The new C++ Standard Library doesn't provide such a mutex out of the box and
is provided by the boost library, which is based on the proposal.

note: 
The performance is dependent on the number of processors involved and the
relative workloads of the reader and updater threads. therefore important to
profile the performance of the code on the target system to ensure that
there's actually a benefit to the additional complexity.

Those threads that don't need to update the data structure can instead use
boost::shared_lock<boost::shared_mutex> to obtain shared access. This is used
just the same as std::unique_lock, except that multiple threads may have a
shared lock on the same boost::shared_mutex at the same time. 

The only constraint is that if any thread has a shared lock, a thread that
tries to acquire an exclusive lock will block until all other threads have
relinquished their locks, and likewise if any thread has an exclusive lock, no
other thread may acquire a shared or exclusive lock until the first thread has
relinquished its lock.


// Typically, a given DNS entry will remain unchanged for a long period of
// time in many cases DNS entries remain unchanged for years. Although new
// entries may be added to the table from time to time as users access
// different websites, this data will therefore remain largely unchanged
// throughout its life.

#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>

class dns_entry;

class dns_cache
{
    std::map<std::string,dns_entry> entries;

    mutable boost::shared_mutex entry_mutex;          // <mutable>

    public:
    dns_entry find_entry(std::string const& domain) const
    {
        boost::shared_lock<boost::shared_mutex> lk(entry_mutex);

        std::map<std::string,dns_entry>::const_iterator const it= entries.find(domain);
        return (it==entries.end()) ? dns_entry() : it->second;
    }

    void update_or_add_entry(std::string const& domain, dns_entry const& dns_details)
    {
        std::lock_guard<boost::shared_mutex> lk(entry_mutex);
        entries[domain]=dns_details;
    }
};

So update_or_add_entry() uses an instance of std::lock_guard<> to provide
exclusive access while the table is updated; not only are other threads
prevented from doing updates in a call update_or_add_entry(), but threads that
call find_entry() are blocked too.


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-lock-recursive-lock cxx-recursive-lock

3.3.3 Recursive locking

Most of the time, if you think you want a recursive mutex, you probably need to
change your design instead.

<ex> CXXSLR-18

class DatabaseAccess
{
  private:
    std::mutex dbMutex;
    ... // state of database access
  public:
      void createTable (...)
      {
        std::lock_guard<std::mutex> lg(dbMutex);
        ...
      }
      ...
};

When we introduce a public member function that might call other public member
functions, this can become complicated:

void createTableAndInsertData (...)
{
  std::lock_guard<std::mutex> lg(dbMutex);
  ...
  createTable(...); // ERROR: *cxx-deadlock* because dbMutex is locked again
}

By using a recursive_mutex, this behavior is no problem. This mutex allows
multiple locks `by the same thread` and releases the lock when the last
corresponding unlock() call is called


https://en.cppreference.com/w/cpp/thread/recursive_mutex

#include <mutex>
std::recursive_mutex since *cxx-11*

recursive_mutex offers exclusive, recursive ownership semantics:

o A calling thread owns a recursive_mutex for a period of time that starts
  when it successfully calls either lock or try_lock. During this period, the
  thread may make additional calls to lock or try_lock. The period of
  ownership ends when the thread makes a matching number of calls to unlock.

o When a thread owns a recursive_mutex, `all other threads will block` (for
  calls to lock) or receive a false return value (for try_lock) if they
  attempt to claim ownership of the recursive_mutex.


={============================================================================
*kt_dev_cxx_0000* cxx-condition-variable cxx-queue

4.1.1 Waiting for a condition with condition variables

The Standard C++ Library provides not one but two implementations of a
cxx-condition-variable: 

`std::condition_variable` and `std::condition_variable_any` Both of these are
declared in the `condition_variable` header.

the former is limited to working with std::mutex, whereas the latter can work
with anything that meets some minimal criteria for being mutex-like, hence the
_any suffix. 

Because std::condition_variable_any is more general, there's the potential for
additional costs in terms of size, performance, or operating system resources,
so `std::condition_variable should be preferred` unless the additional
flexibility is required.

namespace cxx-code
{
  /// condition_variable
  class condition_variable
  {
    void
    wait(unique_lock<mutex>& __lock) noexcept;

    template<typename _Predicate>
      void
      wait(`unique_lock<mutex>& __lock`, _Predicate __p)
      {
        *cxx-condtion-variable-while*
        while (!__p())
          wait(__lock);
      }
  }
} // namespace


<ex>

std::mutex mut;
std::queue<data_chunk> data_queue;
std::condition_variable data_cond;

void data_preparation_thread()
{
  while(more_data_to_prepare())
  {
    data_chunk const data=prepare_data();

    // NOTE see that `the same mutex` are used for both lock_guard and
    // unique_lock

    std::lock_guard<std::mutex> lk(mut);

    data_queue.push(data);
    data_cond.notify_one();
  }
}

void data_processing_thread()
{
  while(true)
  {
    std::unique_lock<std::mutex> lk(mut);

    // *cxx-condition-variable-predicate*
    // must use *cxx-unique-lock* and otherwise error

    data_cond.wait(lk, []{return !data_queue.empty();});

    data_chunk data=data_queue.front();
    data_queue.pop();

    // Processing data can potentially be a time-consuming operation, and
    // as you saw in chapter 3, it’s a bad idea to hold a lock on a mutex
    // for longer than necessary.

    `lk.unlock();`

    process(data);

    if(is_last_chunk(data))
      break;
  }
}


<cxx-condition-variable-predicate> <cxx-wait-condition-variable>

    data_cond.wait(lk, []{return !data_queue.empty();});

A lambda function that expresses the condition being waited for. checks to see
if the data_queue is not empty() - that is, there's some data in the queue
ready for processing.

`The implementation of wait()` then checks the condition by calling the
supplied lambda function and `returns if the expression returned true.`

If the condition isn't satisfied, `false` which is queue is empty in this case,
`wait() unlocks the mutex` and puts the thread in a blocked or waiting state.

the thread wakes from its slumber (unblocks it), reacquires the lock on the
mutex, and checks the condition again, returning from wait() with the mutex
still locked if the condition has been satisfied. If the condition hasn't been
satisfied, the thread unlocks the mutex and resumes waiting. 

<ex>
where uses condition-variable to do as many work `as long as` there are items in
the queue. Since wait() will not be blocked as long as `prediate` return true
and that is, use of while()

{
  void ThreadedDispatcher::_do_work(std::string const &name, int priority)
  {
    std::unique_lock<std::mutex> lock(_m);

    std::cout << "td is created" << std::endl;

    while (_running)
    {
      // the original code is:
      // cv.wait(lock, bind(&This::hasMoreWorkOrWasStopRequested, this));

      // cxx_pattern.cpp:1716:27: error: ‘this’ was not captured for this lambda function
      //       _cv.wait(lock, []{ !_q.empty() || !_running; });
 

      // return from wait when
      // 1. notified, and q is not empty or
      // 2. notified, q is empty, and running is false

      _cv.wait(lock, [this]{ return !_q.empty() || !_running; });
      if (!_q.empty())
      {
        std::function<void()> work = _next();

        // (see) don't block adding work to the queue such as post() while
        // dispatcher does the work

        lock.unlock();
        std::cout << "td do work" << std::endl;
        work();
        lock.lock();
      }
    }
  }
}

<ex>
where uses condition-variable to use one-by-one since not use while

namespace fsm 
{
  template <typename T>
  class queue
  {
    public:
      void push(const T &message)
      {
        std::lock_guard<std::mutex> lock(m);

        mq.push(message);
        cv.notify_all();
      }

      T wait_and_pop()
      {
        std::unique_lock<std::mutex> lock(m);

        cv.wait(lock, [this]{return !mq.empty();});
        auto message = mq.front();
        mq.pop();
        return message;
      }
  }
}


<cxx-condition-variable-suprious-wake>
When the waiting thread reacquires the mutex and checks the condition, if it
isn't in direct response to a notification from another thread, it's called a
spurious wake. 

Because the number and frequency of any such spurious wakes are by definition
indeterminate, 
   
it is not advisable to use a function with side effects for the condition
check. If you do so, you must be prepared for the "side effects" to occur
multiple times.

CXXSLR-18.6.1 Purpose of Condition Variables

“Spurious wakes cannot be predicted: they are essentially random from the
user’s point of view. However, they commonly occur when the thread library
cannot reliably ensure `that a waiting thread will not miss a notification.`

Since a missed notification would render the condition variable useless, the
thread library wakes the thread from its wait rather than take the risk.”

o this predicate, lambda in this case, is to check this spurious wakes and
  there is no need to wrap it with while check again.

o This implies that predicates passed to waiting functions are always called
  under the lock, so they may safely access the object(s) protected by the
  mutex.

so this is unnecessary:

  while (queue_.empty())
    cond_.wait(lock, [&]{return !queue_.empty();});


https://en.cppreference.com/w/cpp/thread/condition_variable/wait

void wait( std::unique_lock<std::mutex>& lock ); (1) (since C++11)

template< class Predicate > 
  void wait( std::unique_lock<std::mutex>& lock, Predicate pred ); (2) (since C++11)

2) Equivalent to

while (!pred()) {
    wait(lock);
}

This overload may be used to ignore spurious awakenings while waiting for a
specific condition to become true.

Note that lock must be acquired before entering this method, and it is
reacquired after wait(lock) exits, which means that lock can be used to guard
access to pred().


<cxx-condition-variable-wait> <cxx-cv-status>

namespace
{
  // condition_variable
 
  /// cv_status
  enum class cv_status { no_timeout, timeout };

    template<typename _Duration>
      cv_status
      wait_until(unique_lock<mutex>& __lock,
		 const chrono::time_point<__clock_t, _Duration>& __atime)
      { return __wait_until_impl(__lock, __atime); }

    template<typename _Rep, typename _Period>
      cv_status
      wait_for(unique_lock<mutex>& __lock,
	       const chrono::duration<_Rep, _Period>& __rtime)
      { return wait_until(__lock, __clock_t::now() + __rtime); }

    template<typename _Rep, typename _Period, typename _Predicate>
      `bool`
      wait_for(unique_lock<mutex>& __lock,
	       const chrono::duration<_Rep, _Period>& __rtime,
	       _Predicate __p);
}

Also note that for condition variables, you have the interface of waiting for
a `maximum amount of time`: wait_for() waits for a duration of time, whereas
wait_until() waits until a timepoint has arrived.


cv.wait_for(lock, duration) 
cv.wait_until(lock, time_point)

Called without the predicate, both wait_for() and wait_until() return the
following enumeration class (see Section 3.1.13, page 32) values:

o std::cv_status::timeout if the absolute timeout happened
o std::cv_status::no_timeout `if a notification happened`


cv.wait_for(lock, duration, predicate) 
cv.wait_until(lock, time_point, predicate)

Called with a predicate as third argument, wait_for() and wait_until() return
`the result of the predicate` (whether the condition holds).

wait_for() will check the supplied predicate when woken and will return the
value of predicate OR `the timeout expires.` see *cxx-con-wait-unbounded*


TEST(CConCondition, WaitFor)
{
  std::mutex m;
  std::unique_lock<std::mutex> lock(m);
  std::condition_variable cond;
  std::queue<int> q;
  
  EXPECT_THAT(q.empty(), true);

  cond.wait_for(lock, std::chrono::seconds(1),
      [&q](){ return !q.empty(); });

  std::string expected{"it's out of wait"};
  EXPECT_THAT(expected, "it's out of wait");
}


{cxx-threadsafe-queue}
As with *cxx-stack* *cxx-queue* has the same problem, "the interface is
inherently subject to race."

When using a queue to pass data between threads, the receiving thread often
needs to wait for the data. Let’s provide two variants on pop(): 
  
try_pop(), which tries to pop the value from the queue but always returns
immediately (with an indication of failure) even if there wasn’t a value to
retrieve, and wait_and_pop(), which will wait until there’s a value to
retrieve.

<ex>

// Listing 4.5

#include <queue>
#include <mutex>
#include <condition_variable>

template<typename T>
class threadsafe_queue
{
  private:
    mutable std::mutex mut;
    std::queue<T> data_queue;
    std::condition_variable data_cond;

  public:
    threadsafe_queue() {}

    threadsafe_queue(threadsafe_queue const& other)
    {
      std::lock_guard<std::mutex> lk(other.mut);
      data_queue = other.data_queue;
    }

    // disallow for simplicity
    threadsafe_queue& operator=(threadsafe_queue const&) = delete;

    void push(T new_value)
    {
      std::lock_guard<std::mutex> lk(mut);

      data_queue.push(new_value);
      data_cond.notify_one();
    }

    // differently from threadsafe-stack, do not use exception

    bool try_pop(T& value)
    {
      std::lock_guard<std::mutex> lk(mut);

      if (data_queue.empty())
        return false;

      value = data_queue.front();
      data_queue.pop();
      return true;
    }

    std::shared_ptr<T> try_pop()
    {
      std::lock_guard<std::mutex> lk(mut);

      if (data_queue.empty())
        return std::shared_ptr<T>();

      std::shared_ptr<T> res(std::make_shared<T>(data_queue.front()));
      data_queue.pop();

      return res;
    }
    
    // see no unlock on cxx-unique-lock due to *cxx-raii*

    void wait_and_pop(T& value)
    {
      std::unique_lock<std::mutex> lk(mut);

      // *cxx-lambda-this* *cxx-lambda-capture-this*
      //
      // cxx_pattern.cpp:1716:27: 
      // error: `‘this’ was not captured for this lambda function`
      //       _cv.wait(lock, []{ !_q.empty() || !_running; });
      //
      // or can use [&] 

      // when miss out "return" from lambda:
      //       _cv.wait(lock, []{ !_q.empty() || !_running; });
      //
      // /usr/include/c++/6/condition_variable:98:13: 
      // error: could not convert ‘__p.cxx_pattern_dispatcher::ThreadedDispatcher::_do_work(const string&, int)::<lambda()>()’ 
      // from ‘void’ to ‘bool’
      //   while (!__p())
      //           ~~~^~
      // /usr/include/c++/6/condition_variable:98:9: error: in argument to unary !
      //   while (!__p())
         ^~~~~~

      data_cond.wait(lk, [this]{return !data_queue.empty();});

      // as with cxx-threadsafe-statk, combine two operations

      value=data_queue.front();
      data_queue.pop();
    }

    std::shared_ptr<T> wait_and_pop()
    {
      std::unique_lock<std::mutex> lk(mut);

      data_cond.wait(lk, [this]{return !data_queue.empty();});

      // as with cxx-threadsafe-statk, combine two operations

      std::shared_ptr<T> res(std::make_shared<T>(data_queue.front()));
      data_queue.pop();

      return res;
    }

    bool empty() const
    {
      std::lock_guard<std::mutex> lk(mut);
      return data_queue.empty();
    }
};

threadsafe_queue<data_chunk> data_queue;

// see how user code has been changed

void data_preparation_thread()
{
  while(more_data_to_prepare())
  {
    data_chunk const data=prepare_data();
    data_queue.push(data);
  }
}

void data_processing_thread()
{
  while(true)
  {
    data_chunk data;
    data_queue.wait_and_pop(data);
    process(data);
    if(is_last_chunk(data))
      break;
  }
}


={============================================================================
*kt_dev_cxx_0000* cxx-atomic

With is_lock_free(), you can check whether an atomic type internally uses
locks to be atomic. If not, you have `native hardware support` for the atomic
operations (which is a prerequisite for using atomics in signal handlers).


Both compare_exchange_strong() and compare_exchange_weak() are so-called
`compare-and-swap (CAS) operations.` CPUs often provide this atomic operation
to compare the contents of a memory location to a given value and, only if
they are the same, modify the contents of that memory location to a given new
value. This guarantees that the new value is calculated based on up-to-date
information.

The effect is something like the following pseudocode:

bool compare_exchange_strong (T& expected, T desired)
{
  if (this->load() == expected) {
    this->store(desired);
    return true;
  }
  else {
    expected = this->load();
    return false;
  }
}

Thus, if the value had been updated by another thread in the meantime, it
returns false with the new value in expected.


18.7.4 The Low-Level Interface of Atomics

The low-level interface of atomics means using the atomic operations in a way
that we have `no guaranteed sequential consistency.` Thus, compilers and
hardware might (partially) reorder access on atomics (see Section 18.4.3, page
    986).

Beware again: Although I give an example, this area is a minefield. You need a
lot of expertise to know when memory reorderings are worth the effort, and
even experts often make mistakes in this area


An Example for the Low-Level Interface of Atomics

The store() operation performs a so-called release operation on the affected
memory location, which by default ensures that all prior memory operations,
whether atomic or not, become visible to other threads before the effect of
the store operation.

The load() operation performs a so-called acquire operation on the affected
memory location, which by default ensures that all following memory
operations, whether atomic or not, become visible to other threads after the
load operation.

As a consequence, because the setting of data happens before the provider()
  stores true in the readyFlag and the processing of data happens after the
  consumer() has loaded true as value of the readyFlag, the processing of data
  is guaranteed to happen after the data was provided.

This guarantee is provided because in all atomic operations, we use a default
memory order named memory_order_seq_cst, which stands for sequential
consistent memory order.

{
  long data;
  std::atomic<bool> readyFlag{false};

  // void thread1()
  void provider()
  {
    // after reading a character
    std::cout << "press <return>" << std::endl;
    std::cin.get();

    // provide some data
    data = 42;

    // and signal readiness
    readyFlag.store(true);
  }

  // void thread2()
  void consumer()
  {
    // wait for readiness and do something else
    while (!readyFlag.load())
    {
      std::cout.put('.').flush();
      std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    // and process provided data
    std::cout << "\nvalue : " << data << std::endl;
  }
}

We use `the default memory order`, which guarantees sequential consistency.
In fact, what we really call is:

readyFlag.store(true, `std::memory_order_seq_cst`);

while (!readyFlag.load(std::memory_order_seq_cst))

Thus, each operation has an optional argument to pass the memory order, which
by default is std::memory_order_seq_cst (sequential consistent memory order).

By passing other values as memory order, we can weaken `the order guarantees.`


However, relaxing all constraints on the order of atomic operations would
result in undefined behavior:

// ERROR: undefined behavior:
data = 42;
readyFlag.store(true,std::memory_order_relaxed);

The reason is that std::memory_order_relaxed doesn’t guarantee that all prior
memory operations become visible to other threads before the effect of the
store operation. Thus, the provider might write data after setting the ready
flag, so the consumer might read data while it gets written, which is a data
race.


No More Details

I don’t explain these low-level interfaces in more detail because this feature
is for real concurrency experts or those who want to become experts. So, you
should definitely use specific resources for that.

One good starting point is Anthony Williams book C++ Concurrency in Action
(see [Williams:C++Conc]), especially Chapters 5 and 7. Another is Hans Boehm’s
list of URLs for material about memory models (see [Boehm:C++MM]).

NOTE: is it worthwhile to study?


={============================================================================
*kt_dev_cxx_0000* cxx-wait cxx-sleep

// CLR and CCON

5.7.5 Blocking with Timers

All the blocking functions that end with _for() use a duration, whereas all
functions that end with _until() use a timepoint as argument. For example,

// *cxx-chrono*
note:
include <thread> to use std::this_thread

std::this_thread::sleep_for(chrono::seconds(10));

blocks the current thread, which might be the main thread for 10 seconds,

this_thread::sleep_until(chrono::system_clock::now()
  + chrono::seconds(10));

blocks the current thread until the system clock has reached a timepoint 10
seconds later than now.


Although these calls look the same, they are not! 

The time for a duration-based wait `is measured using a steady clock` internal
to the library, so 35 milliseconds means 35 milliseconds of elapsed time, even
if the system clock was adjusted (forward or back) during the wait. 

For all `_until() functions`, where you pass a timepoint, time adjustments might
have an effect.

the vagaries of system scheduling and the varying precisions of OS clocks
  means that the actual time between the thread issuing the call and returning
  from it may be much longer than 35 ms.


// CLR

All these timers do not guarantee to be exact. For any timer, there will be a
delay because the system only periodically checks for expired timers, and the
handling of timers and interrupts takes some time. Thus, durations of timers
will take their specified time plus a period that depends on the quality of
implementation and the current situation.


<bounded-or-unbounded>

#include <condition_variable>
#include <mutex>
#include <chrono>

std::condition_variable cv;
bool done;
std::mutex m;

bool wait_loop()
{
  auto const timeout= std::chrono::steady_clock::now()+
    std::chrono::milliseconds(500);

  std::unique_lock<std::mutex> lk(m);

  while(!done)
  {
    if(cv.wait_until(lk,timeout)==std::cv_status::timeout)
      break;
  }

  return done;
}

This is the recommended way to wait for condition variables with a time limit,
if you’re not passing a predicate to the wait. This way, the overall
length of the loop is `bounded.`

As you saw in section 4.1.1, you need to loop when using condition variables
if you don’t pass in the predicate, in order to handle spurious wakeups. 

<cxx-con-wait-unbounded>
If you use wait_for() `in a loop`, you might end up waiting almost the full
length of time before a spurious wake, and the next time through the wait time
starts again. This may repeat any number of times, making the total wait time
`unbounded.`


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-task-model cxx-future cxx-async

C++PL 42.4.

*cxx-task-model*
Focuses on specifying a simple kind of task: a task that does one thing given
arguments and produces one result. 

o "Hiding uses of the messier threads-and-locks level. `cxx-abstraction`"

o "Separating threading logic from application logic"

Would like to provide a lot of small tasks and `let the system worry about`
how to map their execution onto hardware resources and how to keep them out of
problems with data races, spurious wake-ups, excessive waits, etc.

The importance of these facilities is their simplicity. In a sequential
program, we usually write something like:

// perform a task given arguments and get the result

res = task(args);

The concurrent version becomes:

// perform a task given arguments

auto handle = async(task, args);  

// ... do something else ...

// get the result
res = handle.get()               


<shared-data-vs-call-and-return>
Communicating through shared data is pretty low level. In particular, the
programmer has to devise ways of knowing what work has and has not been done
by various tasks. In that regard, use of shared data is inferior to the notion
of call and return. On the other hand, some people are convinced that sharing
must be more efficient than copying arguments and returns. That can indeed be
so when large amounts of data are involved, but locking and unlocking are
relatively expensive operations. On the other hand, modern machines are very
good at copying data, especially compact data, such as vector elements. So
don’t choose shared data for communication because of “efficiency” without
thought and preferably not without measurement.

    
{cxx-future-and-cxx-promise}
`communication between tasks` is handled by a future/promise pair. A task
`puts` its result into a promise, and a task that needs the result `retrieves`
the result from the corresponding future:

task 1                             task 2:
---------------                    ------------------------------------------
get() -> future  <->  value   <->  promise    <- set_value(), set_exception()

The value is known as `shared state` 

In addition to the return value or exception, it contains the information
needed for two threads to safely exchange the information. For example:

o A ready bit to indicate whether a value or exception is ready to be
  extracted by a future.

An implementation can take action on a shared state:

o Make ready: `set the 'ready bit' and unblock` any waiting threads.

note `the absence of explicit mention of locks` in this code: 
we are able `to concentrate on tasks to be done, rather than on the mechanisms` 
used to manage their communication.


*cxx-future*

4.2 Waiting for one-off events with futures

The C++ Standard Library models this sort of `one-off event` with something
called a future. If a thread needs to wait for a specific one-off event, it
somehow obtains `a future representing this event`

// CXXSLR

a future can pass data from one thread to another only once. In fact, a
future’s major purpose is to deal with return values or exceptions of threads.

`A future is a handle to a shared state.` It is where a task can retrieve a result
deposited by a promise.

*cxx-future-cannot-be-reset*
o A future may have `data` associated with it or it may not.

o Wait for the future to become ready. Once an event has happened (and the
  future has become ready), `the future can't be reset. one-off event`

o Although futures are used to communicate between threads, the future objects
  themselves don’t provide synchronized accesses. If multiple threads need to
  access a single future object, they must protect access via a mutex or other
  synchronization mechanism


<cxx-future-unique-cxx-future-shared>
There are two sorts of futures in the C++ Standard Library, implemented as two
class templates declared in the `future header`: 

`unique futures` (std::future<>) and `shared futures` (std::shared_future<>). 

`These are modeled after` std::unique_ptr and std::shared_ptr. An instance of
std::future is the one and only instance that refers to its associated event,
  whereas multiple instances of std::shared_future may refer to the same
  event. In the latter case, all the instances will become ready at the same
  time, and they may all access any data associated with the event. 

This associated data is the reason these are templates; just like
std::unique_ptr and std::shared_ptr, the template parameter is the type of the
associated data.

The std:future<void>, std::shared_future<void> template specializations should
be used where there's no associated data.

<ex>

std::future fu{fu2};

Move constructor: fu gets fu2's shared state, if any; fu2 no longer has a shared
state; noexcept

fu.get()

For future<void>: like x=fu.get(), but don't move any value

fu.wait() 

Block until a value arrives

<ex>

// implement a version of wait_for_all():

template<typename T>
vector<T> wait_for_all(vector<future<T>>& vf)
{
    vector<T> res;
    for (auto& fu : vf)
        res.push_back(fu.get());
    return res;
}


<cxx-future-shared>

4.2.5 Waiting from multiple threads

Although std::future handles all the synchronization necessary to transfer data
from one thread to another, calls to the member functions of a particular
std::future instance `are not synchronized` with each other. If you access a
single std::future object from multiple threads without additional
synchronization, you have a data race *cxx-race* and undefined behavior. 

This is by design, `std::future models unique ownership` of the asynchronous
result, and the one-shot nature of get() makes such concurrent access pointless
anyway; only one thread can retrieve the value, because after the first call to
get() there’s no value left to retrieve.

If your fabulous design for your concurrent code requires that multiple
threads can wait for the same event, don’t despair just yet;
std::shared_future allows exactly that. 

Whereas std::future is only moveable, so ownership can be transferred between
instances, but only one instance refers to a particular asynchronous result at
a time, std::shared_future instances are copyable, so you can have multiple
objects referring to the same associated state.

o syncronization

multiple threads may each access their own copy of a std::shared_future<>
without further synchronization, even if they all refer to the same
asynchronous result.

Now, with std::shared_future, member functions on an individual object are
still unsynchronized, so to avoid data races when accessing a single object
from multiple threads, you must protect accesses with a lock. The preferred
way to use it would be to take a copy of the object instead and have each
thread access its own copy. Accesses to the shared asynchronous state from
multiple threads are safe if each thread accesses that state through its own
std::shared_future object. See figure 4.1.

o ownership

the ownership must be transferred into the std::shared_future using std::move,
leaving the std::future in an empty state, as if it was default constructed:

std::promise<int> p;
std::future<int> f(p.get_future());

assert(f.valid());

std::shared_future<int> sf(std::move(f));

assert(!f.valid());
assert(sf.valid());


{cxx-async}

a high-level interface allows you to start a thread including passing
arguments and dealing with results and exceptions, which is based on a couple
of low-level interfaces for each of these aspects. On the other hand, there
are also low-level features, such as mutexes or even atomics dealing with
relaxed memory orders.

*why-async*
the use of std::async makes it easy to divide algorithms into tasks that can
be run concurrently.

C++ SLR 18. Thus, you have the same behavior but the `chance` of better
performance because f might run in parallel before the outcome of f is needed.


*cxx-race* still can happen

Note, however, that this applies only when no data race occurs, which means
that two threads concurrently use the same data resulting in undefined
behavior


4.2.1 Returning values from background tasks

`std::thread doesn't provide an easy means of returning a value` from such a
task. This is where the std::async function template declared in the future
header, comes in.

{
  std::future<int> the_answer=std::async(find_the_answer_to_ltuae);
  do_other_stuff();
  std::cout << "The answer is "<< the_answer.get() << std::endl;
}

// no need to use *cxx-thread-join*

`std::async` start an asynchronous task for which you don't need the result
right away. Rather than giving you back a std::thread object to wait on,
`std::async returns a std::future object`, which will eventually `hold` the
return value of the function. 

When you need the value, you just call get() on the future, and the thread
blocks until the future is ready and then returns the value. 


namespace cxx_ccon 
{
  // /usr/include/c++/4.9/future

  template<typename _Fn, typename... _Args>
    future<typename result_of<_Fn(_Args...)>::type>
    async(launch __policy, _Fn&& __fn, _Args&&... __args);

  template<typename _Fn, typename... _Args>
    future<typename result_of<_Fn(_Args...)>::type>
    async(_Fn&& __fn, _Args&&... __args);


  /// async
  template<typename _Fn, typename... _Args>
    `future<typename result_of<_Fn(_Args...)>::type>`
    async(launch __policy, _Fn&& __fn, _Args&&... __args)
    {
      typedef typename result_of<_Fn(_Args...)>::type result_type;
      std::shared_ptr<__future_base::_State_base> __state;
      if ((__policy & (launch::async|launch::deferred)) == launch::async)
      {
        __state = __future_base::_S_make_async_state(std::__bind_simple(
              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));
      }
      else
      {
        __state = __future_base::_S_make_deferred_state(std::__bind_simple(
              std::forward<_Fn>(__fn), std::forward<_Args>(__args)...));
      }
      return future<result_type>(__state);
    }

  /// async, potential overload
  template<typename _Fn, typename... _Args>
    inline future<typename result_of<_Fn(_Args...)>::type>
    async(_Fn&& __fn, _Args&&... __args)
    {
      // *cxx-async-default*
      return async(`launch::async|launch::deferred`, std::forward<_Fn>(__fn),
          std::forward<_Args>(__args)...);
    }
}


*cxx-async-launch-policy*
By default, it's up to the implementation whether std::async starts a new
thread, or whether the task runs synchronously when the future is waited for.

You can specify which to use with an `additional parameter to std::async.` 

This is of the type std::launch:

o std::launch::deferred
to indicate that the function call is to be deferred until either wait() or
get() is called on the future

o `std::launch::async`
to indicate that the function must be run on its own thread, 

*cxx-async-default*
o `std::launch::deferred | std::launch::async` 
to indicate that the implementation may choose. This last option is the
default

If the function call is deferred, it `may never actually run` because it is
guaranteed that func1() never gets called without get() or wait()

// CXXSRL-18

If the asynchronous call is not possible here, the program will throw a
std::system_error exception (see Section 4.3.1, page 43) with the error code
resource_unavailable_try_again, which is equivalent to the POSIX errno EAGAIN
(see Section 4.3.2, page 45).


Why deffered?

explicitly requesting a deferred launch policy might help to simulate the
behavior of async() on a single-threaded environment or simplify debugging
(unless race conditions are the problem).

Here, with the call of f.get(), one of three things might happen:

o If func1() was started with async() in a separate thread and has already
  finished, you immediately get its result.

o If func1() was started but has not finished yet, get() blocks and waits for
  its end and yields the result.

o If func1() was not started yet, it will be forced to start now and, like a
  synchronous function call, get() will block until it yields the result.

This behavior is important because it ensures that the program still works
on a single-threaded environment or, if for any other reason, it was not
possible for async() to start a new thread.

Thus, the combination of

std::future<int> result1(std::async(func1)); 
...
result1.get();

allows you to optimize a program in a way that, if possible, func1() runs in
parallel while the next statements in the main thread are processed. If it is
not possible to run it in parallel, it will be called sequentially when get()
gets called. 
    
This means that, in any case, it is guaranteed that after get(), func1() was
called `either asynchronously or synchronously.`

see test_ccon for test cases.


*cxx-future-wait*
CXXSLR-18.1.2 

You can call get() for a future<> `only once.` After get(), the future is in
an invalid state, which can be checked only by calling valid() for the future.

But futures also provide an interface to wait for a background operation to
finish without processing its outcome.

f.wait()

Just calling wait() `forces the start of a thread` a future represents and waits
for the termination of the background operation:

std::future<...> f(std::async(func)); // try to call func asynchronously
...
f.wait(); // wait for func to be done (might start background task)

But futures also provide an interface to wait for a background operation to
finish without processing its outcome. This interface is callable more than
once and might be combined with a duration or timepoint to limit the amount of
waiting time.

Two other wait() functions exist for futures, but those functions 
`do not force` the thread to get started, if it hasn't started yet:


std::future<int> f=std::async(some_task);

if(f.wait_for(std::chrono::milliseconds(35))==std::future_status::ready)

do_something_with(f.get());

The wait functions all `return a status` to indicate whether the wait timed out
or the waited-for event occurred. 


f.wait_for()
  
you can wait for a limited time for an asynchronously running operation by
passing a duration:

std::future<...> f(std::async(func)); // try to call func asynchronously
...
f.wait_for(std::chrono::seconds(10)); // wait at most 10 seconds for func


f.wait_until()
  
you can wait until a specific timepoint has reached:

std::future<...> f(std::async(func)); // try to call func asynchronously
...
f.wait_until(std::system_clock::now()+std::chrono::minutes(1));


Both wait_for() and wait_until() return one of the following:

o `std::future_status::deferred` if async() deferred the operation and no calls
  to wait() or get() have yet forced it to start (both function return
  immediately in this case)

o std::future_status::timeout if the operation was started asynchronously but
  hasn't finished yet (if the waiting expired due to the passed timeout)

o `std::future_status::ready` if the operation has finished

By passing a zero duration or a timepoint that has passed, you can simply
"poll" to see whether a background task has started and/or is (still) running:


{cxx-future-scope} care-with-future-scope

CXXSLR-18.1 Using Launch Policies

With the async launch policy, you don't necessarily have to call get() anymore
because, if the lifetime of the returned future ends, the program will wait
for func1() to finish. Thus, if you don’t call get(), leaving the scope of the
future object (here the end of main()) will wait for the background task to
end.  Nevertheless, also calling get() here before a program ends makes the
behavior clearer.


CXXSLR-18.1 Waiting and polling

// outside declared because lifetime of accurateComputation() might exceed
// lifetime of bestResultInTime()

std::future<int> f;

int bestResultInTime()
{
    // define time slot to get the answer:
    auto tp = std::chrono::system_clock::now() + std::chrono::minutes(1);

    // start both a quick and an accurate computation:
    f = std::async (std::launch::async, accurateComputation);
    int guess = quickComputation();

    // give accurate computation the rest of the time slot:
    std::future_status s = f.wait_until(tp);

    // return the best computation result we have:
    if (s == std::future_status::ready) {
        return f.get();
    }
    else {
        return guess; // accurateComputation() continues
    }
}

Note that the future f can't be a local object declared inside
bestResultInTime() because when the time was too short to finish
accurateComputation(), bestResultInTime() returns and 
`the destructor of the future would block` until that asynchronous task has
finished.


namespace cxx_async
{
  void make_async()
  {
    auto f = std::async(std::launch::async, do_long);
  }
}

// if think that make_async() makes a thread and then execute next line right
// after make_async(), that's wrong. make_asymc() waits for async thread ends so
// sum is always 20.

TEST(CConAsync, check_scope)
{
  using namespace cxx_async;

  // since it's global
  sum = 0;

  make_async();

  sum += 10;

  EXPECT_THAT(sum, 20);
}


{with-exception}
What happens when an exception occurs? The good news is: Nothing special; get()
for futures also handles exceptions. In fact, when get() is called and the
background operation was or gets terminated by an exception, which was/is not
handled inside the thread, this exception gets propagated again.

#include <future>
#include <thread>
#include <chrono>
#include <random>
#include <iostream>
#include <exception>

using namespace std;

int doSomething (char c)
{
    default_random_engine dre(c);
    uniform_int_distribution<int> id(10, 1000);

    for(int i=0; i<10; ++i)
    {
        this_thread::sleep_for(chrono::milliseconds( id(dre) ));
        cout.put(c).flush();
    }

    return c;
}

int func1()
{
    return doSomething('.');
}

int func2()
{
    return doSomething('+');
}

int main()
{
    cout << "starting func1() in background"
        << " and func2() in foreground:" << endl;

    future<int> result1(std::async(func1));

    int result2 = func2();

    try 
    {
        int result = result1.get() + result2;

        cout << "\nresult of func1()+func2(): " << result << endl;
    }
    catch( const exception& e )
    {
        cerr << "\nEXCEPTION: " << e.what() << endl;
    }
}

With get(), the exception gets further propagated inside main().


note: see that build without -lpthread

keitee@debian-keitee:~/work$ ./cppbl.sh t_async_02.cpp 
keitee@debian-keitee:~/work$ ./a.out 
starting func1() in background and func2() in foreground:
++++++++++
EXCEPTION: Unknown error 4294967295

note: see that build without -lpthread and this use the previous which don't
have try and catch.

starting func1() in background and func2() in foreground:
++++++++++terminate called after throwing an instance of 'std::system_error'
  what():  Unknown error 4294967295
Aborted


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-promise cxx-promise

std::promise<T> provides a means of setting a value (of type T), which can
later be read through an associated std::future<T> object. 

A std::promise/std::future pair would provide one possible mechanism for this
facility; the waiting thread could block on the future, while the thread
providing the data could use the promise half of the pairing to set the
associated value and make the future ready.

You can obtain the std::future object associated with a given std::promise by
calling the `get_future()` member function, just like with std::packaged_task.
When the value of the promise is set (using the set_value() member function),
the future becomes ready and can be used to retrieve the stored value. 


A promise is the `handle` to a shared state. It is where a task can deposit its
result to be retrieved through a future.

*cxx-promise-operations*

promise pr {};       

Default constructor: pr has a shared state that is not yet ready

fu=pr.get_future()   fu is the future corresponding to pr

pr.set_value(x)      The result of the task is the value x
pr.set_value()       Set the result of the task for a void future

pr.set_exception(p)  

The result of the task is the exception pointed to by p; p is an exception_ptr


<cxx-future-move-cxx-promise-move> *cxx-move*
Only possible to transmit a single result value through a promise. That may
seem restrictive, but remember that `the value is moved into` and out of the
shared state, rather than copied, so that we can cheaply pass a collection of
objects. For example:

promise<map<string,int>> pr;
map<string,int>> m;

// ... fill m with a million <string,int> pairs ...

pr.set_value(m);

A task may then extract that map from a corresponding future at essentially
zero cost.


<ex>

In applications with very large numbers of network connections, it’s therefore
common to have a small number of threads (possibly only one) handling the
connections, each thread dealing with multiple connections at once. Consider
one of these threads handling the connections.

void process_connections(connection_set& connections)
{
  while(!done(connections))
  {
    for(connection_iterator
        connection=connections.begin(),end=connections.end();
        connection!=end;
        ++connection)
    {
      // This assumes that an incoming packet has some ID and a payload with
      // the actual data in it. `The ID is mapped to a std::promise`
      //
      // For incoming packets, the data associated with the future is the
      // payload of the data packet.

      if(connection->has_incoming_data())
      {
        data_packet data = connection->incoming();

        std::promise<payload_type>& p = connection->get_promise(data.id);
        p.set_value(data.payload);
      }

      // the promise associated with the outgoing data is set to true to
      // indicate successful transmission

      if(connection->has_outgoing_data())
      {
        outgoing_packet data = connection->top_of_outgoing_queue();

        connection->send(data.payload);

        // std::promise<bool> and how to associate data itself?

        data.promise.set_value(true);
      }
    }
  }
}

The CXXSLR says: 

There is no get_promise() operation to match get_future(). The use of the
promise is completely handled by the packaged_task.


{cxx-promise-save-exception}

4.2.4 Saving an exception for the future

If you pass in -1 to the square_root() function, it throws an exception, and
this gets seen by the caller:

double square_root(double x)
{
  if(x<0)
  {
    throw std::out_of_range(“x<0”);
  }
  return sqrt(x);
}

Now suppose that instead of just invoking square_root() from the current thread,

double y=square_root(-1);

you run the call as an asynchronous call:

std::future<double> f=std::async(square_root,-1);
double y=f.get();

If the function call invoked as part of std::async throws an exception, that
exception is stored in the future "in place of" a stored value, the future
becomes ready, and a call to get() rethrows that stored exception. The same
happens if you wrap the function in a std::packaged_task.

If you wish to store an exception rather than a value, you call the
set_exception() member function rather than set_value().

extern std::promise<double> some_promise;

try
{
    some_promise.set_value(calculate_value());
}
catch(...)
{
    some_promise.set_exception(std::current_exception());      // note: std::current_ex
}

the alternative here would be to use std::copy_exception() to store a new
exception directly without throwing:

some_promise.set_exception(std::copy_exception(std::logic_error("foo ")));

This is much cleaner than using a try/catch block if the type of the exception
is known, and it should be used in preference; not only does it simplify the
code, but it also provides the compiler with greater opportunity to optimize
the code.

note: ?

<broken-promise>
Another way to store an exception in a future is to destroy the std::promise
or std::packaged_task associated with the future 'without' calling either of
the set functions on the promise or invoking the packaged task. In either
case, the destructor of the std::promise or std::packaged_task will store a
std::future_error exception with an error code of
std::future_errc::broken_promise in the associated state if the future isn't
already ready; by creating a future you make a promise to provide a value or
exception, and by destroying the source of that value or exception without
providing one, you break that promise.


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-packaged-task

cxx-packaged-task

std::async is not the only way to associate a std::future with a task; you can
also do it by wrapping the task in an instance of the std::packaged_task<>
class template which is a higher-level abstraction

std::packaged_task<> ties a future to a function or callable object. 

A packaged_task holds a `task and a future/promise pair.`

task 1                             packaged_task: 
                                                                  task 2:
-----------------------            ------------------------------------------
get()  ->  future  <-> value  <->  promise  <- set_value(x)       <- return x
                                            <- set_exception(px)  <- throw x

When the std::packaged_task<> object is invoked, it calls the associated
function or callable object and makes the future ready, with the return value
stored as the associated data.

Pass a task (a function or a function object) that we want executed to a
packaged_task. When our task executes a return x, it causes a set_value(x) on
the packaged_task's promise. Similarly, a throw x causes a set_exception(px)
where px is an exception_ptr for x. 

the packaged_task executes its task, f(args), like this:

try {
   some_promise.set_value(f(args));
}
catch(...) {
   some_promise.set_exception(current_exception());
}


<ex>
packaged_task pt {f};

Construct pt holding f; f is moved into pt; use the default allocator;
explicit

pt()(args)     
    
Execute f(args); a return x in f() does a set_value(x) to pt's promise, a
throw x in f() does a set_exception(px) to pt's promise; px is an
exception_ptr to x

fu=pt.get_future()

fu is the future for pt's promise; throws future_error if called twice


<cxx-packaged-task-aim>
This can be used as a building block for thread pools or other task management
schemes, such as running each task on its own thread, or running them all
sequentially on a particular background thread. If a large operation can be
divided into `self-contained sub-tasks`, each of these can be wrapped in a
std::packaged_task<> instance, and then that instance passed to the task
scheduler or thread pool. This abstracts out the details of the tasks; the
scheduler 'just' deals with std::packaged_task<> instances rather than
individual functions.


namespace cxx_future
{
  int ff(int i)
  {
    if (i) return i;
    throw runtime_error("called as ff(0)");
  }
} // namespace

// The 'point' is that the packaged_task version works exactly like the version
// using 'ordinary' function calls even when the calls of the task (here ff) and
// the calls of the get()s are in 'different' 'threads'. We can concentrate on
// specifying the tasks 'rather' than thinking about threads and locks.
// 
// We can move the future, the packaged_task, or both around. Eventually, the
// packaged_task is invoked and its task deposits its result in the future
// without having to know either which thread executed it or which thread will
// receive the result. This is simple and general.
// 
// The packaged_tasks are actually easier for the server to use than ordinary
// functions because the handling of their exceptions has been taken care of.

TEST(CConFuture, PackagedTaskPoint)
{
  using namespace cxx_future;

  {
    std::packaged_task<int(int)> pt1{ff};
    std::packaged_task<int(int)> pt2{ff};

    // call pt
    pt1(1);
    pt2(0);   // this would cause exception

    // get futures
    auto f1 = pt1.get_future();
    EXPECT_THAT(f1.get(), 1);

    auto f2 = pt2.get_future();
    EXPECT_THROW(f2.get(), runtime_error);
  }
}


<see-future-type-and-callable-type>

The return type of the specified function signature identifies the type of the
std::future<> returned from the get_future() member function, whereas the
argument list of the function signature is used to specify the signature of
the packaged task’s function call operator. 

For example, a partial class definition for std::packaged_task
<std::string(std::vector<char>*,int)> would be as shown in the following
listing.

template<>
class packaged_task<std::string(std::vector<char>*,int)>
{
  public:
    template<typename Callable>
      explicit packaged_task(Callable&& f);

    std::future<std::string> get_future();

    void operator()(std::vector<char>*,int);
};


<ex>
Many GUI frameworks require that updates to the GUI be done from specific
threads, so if another thread needs to update the GUI, it must send a message
to the right thread in order to do so. std:packaged_task provides one way of
doing this `without requiring a custom message` for each and every GUI-related
activity.

std::mutex m;
std::deque<std::packaged_task<void()>> tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

// the GUI thread loops until a message has been received telling the GUI to
// shut down, repeatedly 'polling' for GUI messages to handle, such as user
// clicks, and for tasks on the task queue. If there are no tasks on the
// queue, it loops again; otherwise, it extracts the task from the queue, and
// then runs the task. The future associated with the task will then be made
// ready when the task completes.

std::thread gui_bg_thread(gui_thread);

void gui_thread()
{
  while(!gui_shutdown_message_received())
  {
    get_and_process_gui_message();

    std::packaged_task<void()> task;

    {
      std::lock_guard<std::mutex> lk(m);

      if(tasks.empty())
        continue;

      `task = std::move(tasks.front());`

      tasks.pop_front();
    }

    task();
  }
}


Posting a task on the queue is equally simple: a new packaged task is created
from the supplied function, the future is obtained from that task by calling
the get_future() member function, and the task is put on the list before the
future is returned to the caller. The code that posted the message to the GUI
thread can then wait for the future if it needs to know that the task has been
completed, or it can discard the future if it doesn't need to know.

this is simple case as uses a future as a completion indicator since no
associated data, future<void>.

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{
    std::packaged_task<void()> task(f);
    std::future<void> res = task.get_future();

    std::lock_guard<std::mutex> lk(m);
    tasks.push_back(std::move(task));
    return res;
}


={============================================================================
*kt_dev_cxx_0000* cxx-con-lock-based-data-structure

6.2.3 A thread-safe queue using fine-grained locks and
condition variables

Excecise to use finer-grained locking by having two mutexes for head and tail.

Listing 6.4 A simple single-threaded queue implementation

#include <memory>

template<typename T>
class queue
{
private:
    struct node
    {
        T data;
        std::unique_ptr<node> next;

        node(T data_):
            data(std::move(data_))
        {}
    };
    
    std::unique_ptr<node> head;
    node* tail;
    
public:
    queue():
        tail(nullptr)
    {}

    queue(const queue& other)=delete;
    queue& operator=(const queue& other)=delete;

    std::shared_ptr<T> try_pop()
    {
        if(!head)
        {
            return std::shared_ptr<T>();
        }
        std::shared_ptr<T> const res(
            std::make_shared<T>(std::move(head->data)));
        std::unique_ptr<node> const old_head=std::move(head);
        head=std::move(old_head->next);
        return res;
    }
    
    void push(T new_value)
    {
        std::unique_ptr<node> p(new node(std::move(new_value)));
        node* const new_tail=p.get();
        if(tail)
        {
            tail->next=std::move(p);
        }
        else
        {
            head=std::move(p);
        }
        tail=new_tail;
    }
};


Two problems to support concurrent access:

* push() modify head and tail and have to lock both.

* if there is a single item, then head == tail. if one do push() and the other
  do pop() which access the same. since can't tell if it's the same without
  reading both head and tail, have to lock both in pop() as well. 



How to solve? Having a dummy node avoids cases where need to access both head
and tail.

Listing 6.5 A simple queue with a dummy node

#include <memory>
template<typename T>
class queue
{
private:
    struct node
    {
        std::shared_ptr<T> data;
        std::unique_ptr<node> next;
    };
    
    std::unique_ptr<node> head;
    node* tail;
    
public:
    queue():
        head(new node),tail(head.get())
    {}

    queue(const queue& other)=delete;
    queue& operator=(const queue& other)=delete;

    std::shared_ptr<T> try_pop()
    {
        if(head.get()==tail)
        {
            return std::shared_ptr<T>();
        }
        std::shared_ptr<T> const res(head->data);
        std::unique_ptr<node> const old_head=std::move(head);
        head=std::move(old_head->next);
        return res;
    }

    // note:
    // The new node you create is going to be the new dummy node, so you don’t
    // need to supply the new_value to the constructor   

    void push(T new_value)
    {
        std::shared_ptr<T> new_data(
            std::make_shared<T>(std::move(new_value)));
        std::unique_ptr<node> p(new node);
        tail->data=new_data;
        node* const new_tail=p.get();
        tail->next=std::move(p);
        tail=new_tail;
    }
};


So, you can have one mutex for head and one for tail. Where do you put the
locks?

Listing 6.6 A thread-safe queue with fine-grained locking

#include <memory>
#include <mutex>

template<typename T>
class threadsafe_queue
{
    std::mutex head_mutex;
    std::mutex tail_mutex;
    
    node* get_tail()
    {
        std::lock_guard<std::mutex> tail_lock(tail_mutex);
        return tail;
    }

    std::unique_ptr<node> pop_head()
    {
        std::lock_guard<std::mutex> head_lock(head_mutex);
        if(head.get()==get_tail())
        {
            return nullptr;
        }
        std::unique_ptr<node> const old_head=std::move(head);
        head=std::move(old_head->next);
        return old_head;
    }
        
public:
    threadsafe_queue():
        head(new node),tail(head.get())
    {}

    threadsafe_queue(const threadsafe_queue& other)=delete;
    threadsafe_queue& operator=(const threadsafe_queue& other)=delete;

    std::shared_ptr<T> try_pop()
    {
        std::unique_ptr<node> old_head=pop_head();
        return old_head ? old_head->data : std::shared_ptr<T>();
    }
    
    void push(T new_value)
    {
        std::shared_ptr<T> new_data(
            std::make_shared<T>(std::move(new_value)));
        std::unique_ptr<node> p(new node);
        node* const new_tail=p.get();
        std::lock_guard<std::mutex> tail_lock(tail_mutex);
        tail->data=new_data;
        tail->next=std::move(p);
        tail=new_tail;
    }
};

Thankfully the lock on the tail_mutex in get_tail() solves everything. Because
the call to get_tail() locks the same mutex as the call to push(), there’s a
defined order between the two calls. Either the call to get_tail() occurs
before the call to push(), in which case it sees the old value of tail, or it
occurs after the call to push(), in which case it sees the new value of tail
and the new data attached to the previous value of tail.


It’s also important that the call to get_tail() occurs inside the lock on
head_mutex.

std::unique_ptr<node> pop_head()
{
  node* const old_tail=get_tail();

  // note:
  // here do not hold any locks on tail and head

  std::lock_guard<std::mutex> head_lock(head_mutex);
  if(head.get()==old_tail)
  {
    return nullptr;
  }
  std::unique_ptr<node> old_head=std::move(head);
  head=std::move(old_head->next);
  return old_head;
}

In this broken scenario, where the call to get_tail(0) is made outside the
scope of the lock, you might find that both head and tail have changed by the
time your initial thread can acquire the lock on head_mutex, and not only is
the returned tail node no longer the tail, but it’s no longer even part of the
list. 

This could then mean that the comparison of head to old_tail c fails, even if
head really is the last node. Consequently, when you update head d you may end
up moving head beyond tail and off the end of the list, destroying the data
structure. In the correct implementation from listing 6.6, you keep the call
to get_tail() inside the lock on head_mutex. This ensures that no other
threads can change head, and tail only ever moves further away (as new nodes
    are added in calls to push()), which is perfectly safe. head can never
pass the value returned from get_tail(), so the invariants are upheld.

// TODO: skip for the rest since they are about adding full interfaces.


6.3 Designing more complex lock-based data structures


={============================================================================
*kt_dev_cxx_0000* cxx-ccon-other-paradigm cxx-fsm

4.4.1 Functional programming with futures

The term functional programming (FP) refers to a style of programming where
the result of a function call `depends solely on the parameters` to that
function and `doesn’t depend on any external state.` The effect of the
functions are entirely limited to the return value.

This makes things easy to think about, especially when concurrency is
involved, because many of the problems associated with shared memory discussed
in chapter 3 disappear.

If there are no modifications to shared data, there can be no race conditions
and thus no need to protect shared data with mutexes either.


// cxx-sort-quick
// CCon, 4.4.1 Functional programming with futures
// Listing 4.12 A sequential implementation of Quicksort
// use the first than the middle

template<typename T>
std::list<T> sequential_quick_sort(std::list<T> input)
{
  if(input.empty())
    return input;

  std::list<T> result;

  // move the first of input to the first of result
  result.splice(result.begin(), input, input.begin());
  const T &pivot = *result.begin();

  // divide input into; 
  // one which are < pivot, pivot, >= pivot.

  auto divide_point = std::partition(input.begin(), input.end(),
      [&](const T &t)
      {
      return t < pivot;
      });

  // make two list; lower_part and input(higher_part)
  std::list<T> lower_part;
  lower_part.splice(lower_part.end(), input, input.begin(), divide_point);

  auto new_lower(sequential_quick_sort(std::move(lower_part)));
  auto new_higher(sequential_quick_sort(std::move(input)));

  // make coll: < p, p, p <=
  result.splice(result.begin(), new_lower);
  result.splice(result.end(), new_higher);
  return result;
}

TEST(CConFuture, SequentialQuickSort)
{
  std::list<int> input{30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 6};

  auto result = sequential_quick_sort(input);
  EXPECT_THAT(result,
      ElementsAreArray({2,5,6,6,10,12,13,15,17,29,30,31,33}));
}

template<typename T>
std::list<T> parallel_quick_sort(std::list<T> input)
{
  if(input.empty())
    return input;

  std::list<T> result;
  // move the first of input to the first of result
  result.splice(result.begin(), input, input.begin());
  const T &pivot = *result.begin();

  // divide input into two; one which are < pivot and the other which are >= pivot.
  auto divide_point = std::partition(input.begin(), input.end(),
      [&](const T &t)
      {
      return t < pivot;
      });

  // make two list; lower_part and input(higher_part)
  std::list<T> lower_part;
  lower_part.splice(lower_part.end(), input, input.begin(), divide_point);

  // only one more since can use main thread
  std::future<std::list<T>> new_lower(
      std::async(parallel_quick_sort<T>, std::move(lower_part))
      );
  auto new_higher(parallel_quick_sort(std::move(input)));

  result.splice(result.begin(), new_lower.get());
  result.splice(result.end(), new_higher);
  return result;
}

TEST(CConFuture, ParallelQuickSort)
{
  std::list<int> input{30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 6};

  auto result = parallel_quick_sort(input);
  EXPECT_THAT(result,
      ElementsAreArray({2,5,6,6,10,12,13,15,17,29,30,31,33}));
}


4.4.2 Synchronizing operations with message passing

Functional programming isn’t the only concurrent programming paradigm that
eschews(avoid) shared mutable data; another paradigm is CSP (Communicating
    Sequential Processes), where threads are conceptually entirely separate,
  with no shared data `but with communication channels` that allow messages to
  be passed between them.

The idea of CSP is simple: if there’s no shared data, each thread can be
reasoned about entirely independently, purely on the basis of how it behaves
`in response to the messages that it received.` Each thread is therefore
effectively a `state machine`: when it receives a message, it updates its
state in some manner and maybe sends one or more messages to other threads,
      with the processing performed depending on the initial state. 
  
One way to write such threads would be to formalize this and implement a
Finite State Machine model, but this isn’t the only way; the state machine can
be implicit in the structure of the application.

Imagine for a moment that you’re implementing the code for an ATM. One way to
handle everything would be to split the code into three independent threads:
one to handle the physical machinery, one to handle the ATM logic, and one to
communicate with the bank. These threads could communicate purely by passing
messages rather than sharing any data. 

For example, the thread handling the machinery would send a message to the
logic thread when the person at the machine entered their card or pressed a
button, and the logic thread would send a message to the machinery thread
indicating how much money to dispense, and so forth.

o class that has a member function to represent each state. 

o Each member function can then wait for specific sets of incoming messages
  and handle them when they arrive, possibly triggering a switch to another
  state.

o if a message is received that doesn’t match the specified type, it’s
  discarded, and the thread continues to wait until a matching message is
  received.

Figure 4.3 A simple state machine model for an ATM

it does give you a feel for the message-passing style of programming. There’s
no need to think about synchronization and concurrency issues, just which
messages may be received at any given point and which messages to send.

As you can see, this style of programming can greatly simplify the task of
designing a concurrent system, because each thread can be treated entirely
independently. It is thus an example of using multiple threads to separate
concerns and as such requires you to explicitly decide how to divide the tasks
between threads.


={============================================================================
*kt_dev_cxx_0000* cxx-fsm-case

From NDS VRM, view record manager, component. 

note:
call it dynamic fsm. one definition and multiple instances. one thread to run
all instacnes. 

fsm definition for a state transition table is like a class and instance is
like a object. 

This defines a fsm definition for each scenario type such as basic record and
play, review buffer play and record, and remider. Creates instance for each
type when request comes. from static definition to dynamic instance.

This fsm uses sesseion base which means that it creates a fsm instance for
each session and manage its state. That is why this fsm module creates its
data structure at runtime.

This function can send a messages which is async and or call a function. The
route to this function can come from other thread or from action function in
fsm.

This implies that the user who design a state machine 'must' know whether to
end function call in fsm action chain or to send a message.

For eaf, like static, this is state action for each state and there is no
check on return since eaf is void. 

This uses state and input(event) to define a fsm. 
Like static fsm, there should no gaps in state enumerators.
Supports timeout for each fsm instance.


<to-define-fsm>

// basic_play.c

// structure stored per playing program. Like session or context which is passed
// to fsm and to EAF to access context 

typedef struct BASIC_PLAY_ {

  // ...

  /* handle of finite state machine */
  VRM_FSM_INSTANCE_HANDLE fsm;

  //...

} BASIC_PLAY;


/* Stores the currently playing sessions */
static BASIC_PLAY BasicPlay[BASIC_PLAY_MAX_HANDLES_NUM];

// one handle for one definition. In this case basic_play.c
static VRM_FSM_DEFINITION_HANDLE fsm_definition_handle;


// defines event(input), state, and state machine

typedef enum E_PLAY_INP_ {
  E_PLAY_INPUT_NULL,

  /* request to start play job */
  E_PLAY_INPUT_START,

  /* acquire RMF resources */
  E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE,

  // ...

  E_PLAY_INPUT_LAST
} E_PLAY_INPUT;


/* Possible Play state machine states */
typedef enum E_PLAY_INTERNAL_STATE_
{
  E_PLAY_INT_STATE_NONE = 0,

  /* play is starting process */
  E_PLAY_INT_STATE_STARTING,

  /* play is allocating RMF resources */
  E_PLAY_INT_STATE_ALLOCATING_RESOURCES,

  // ...

  E_PLAY_INT_STATE_LAST
} E_PLAY_INTERNAL_STATE;


/* typedef for action function */ 
typedef void (*VRM_FSM_ACTION) (void* data);

// Use this macro for make array of VRM_FSM_ENTRY.
#define VRM_FSM_E(w,x,y,z) {(uint16_t)w,(uint16_t)x,(uint16_t)y,z,#w,#x}

typedef struct _fsm_entry {
  uint16_t state;         // state to which this transition belongs or VRM_FSM_ALL_STATES
  uint16_t input;         // input on which the transition works
  uint16_t new_state;     // new state
  VRM_FSM_ACTION action;  // action on this transition
  char *state_str;        // to support trace
  char *input_str;        // to support trace
} VRM_FSM_ENTRY;


static VRM_FSM_ENTRY PlayEntries[] = {

  VRM_FSM_E(
      `VRM_FSM_ALL_STATES`,                   /* (current) state */ 
      E_PLAY_INPUT_STOP,                    /* input */
      E_PLAY_INT_STATE_RELEASED_MEDIACONN,  /* new state */
      /* `action for new state` */
      (VRM_FSM_ACTION)PlayActionGeneralTrap ),/* action */

  // STATE_NONE & INPUT_START -> E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE

  VRM_FSM_E(  E_PLAY_INT_STATE_NONE,        /* state */
      E_PLAY_INPUT_START,                   /* input */
      E_PLAY_INT_STATE_STARTING,            /* new state */
      (VRM_FSM_ACTION) PlayActionStartingState ),   /* action */

  VRM_FSM_E(  E_PLAY_INT_STATE_STARTING,            /* state */
      E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE,            /* input */
      E_PLAY_INT_STATE_ALLOCATING_RESOURCES,        /* new state */
      (VRM_FSM_ACTION) PlayActionRmfAllocatingResourcesState ), 

  // ...
};


<to-init-fsm>

SYSTEM_STATUS PLAY_Init(void)
{
  VRM_FSM_DEFINITION_INFO fsm_info;

  // initialize FSM definition info structure

  `fsm_info.entries = PlayEntries;`   // maps to state transition table

  fsm_info.num_entries = (uint16_t)NELEMENTS(PlayEntries);
  fsm_info.timeouts = NULL;
  fsm_info.num_timeouts = 0u;

  // set fsm_definition_handle which is static global
  stat = `VRM_FSM_CreateDefinition` (&fsm_info, &`fsm_definition_handle`);

  /* initialize fields to null values */
  memset(BasicPlay, 0, (size_t)(sizeof(BASIC_PLAY) * BASIC_PLAY_MAX_HANDLES_NUM));

  for (i=0u; i < BASIC_PLAY_MAX_HANDLES_NUM; i++) {
    /* set session id to illegal -  indicates that entry is not in use */
    BasicPlay[i].hPlay = PLAY_HANDLE_ILLEGAL;
  }

  // ...
}


<to-create-fsm-instance>

SYSTEM_STATUS PLAY_Start( const PLAY_PARAMS *p_play_params,
  /* out */ PLAY_HANDLE *p_hPlay)
{
  BASIC_PLAY *pPlaySession = NULL; /* the object of the playback */

  /* allocate a new playback - if playback already exists -  will return its play object */
  if (SYSTEM_STATUS_IS_OK (stat)) {
    stat = PlayAllocateNew (p_play_params, &pPlaySession);
  }

  /* send fsm input to start */
  if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
    stat = PlaySendFSMInput (pPlaySession, E_PLAY_INPUT_START, ASYNCHRONOUS);
  }

  /*  returned play handle */
  if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
    *p_hPlay = pPlaySession -> hPlay;
  }
}

// find free entry from static BasicPlay[], initialise it, create and
// initialise fsm, set it back to play session and return it as session

static SYSTEM_STATUS PlayAllocateNew (	const PLAY_PARAMS	*p_play_params, 
    BASIC_PLAY **ppNew_play_session)
{
  /* search for a new place in the objects array */
  for (i = 0u; i < g_max_play_sessions ; i++) {
    if (BasicPlay[i].hPlay == PLAY_HANDLE_ILLEGAL) {
      stat = PLAY_STATUS_OK;
      new_index = i;
      break;
    } 
  } 

  // defines max number of plays 
  stat = PlayInitializeEntry (&(BasicPlay[new_index]), p_play_params); 

  /* set return value */
  if (SYSTEM_STATUS_IS_OK (stat)) {
    *ppNew_play_session = &(BasicPlay[new_index]);
  }
}

static SYSTEM_STATUS PlayInitializeEntry (BASIC_PLAY *pThis, const PLAY_PARAMS	*p_play_params)
{
  VRM_FSM_INIT	init; /* FSM initialization structure */

  pThis -> fsm = NULL;

  /* initialize fsm init data */ 
  memset( &init, 0, sizeof(VRM_FSM_INIT));
  init.fsm_definition_handle	= `fsm_definition_handle`;
  init.callback = (VRM_FSM_TRANS_CB)PlayActionFsmOnExit;
  init.init_state = (uint16_t)`E_PLAY_INT_STATE_NONE`;

  // *pass-play-session-to-each-fsm-instance*
  `init.data = (void *)(pThis);`

  // set fsm instance handle
  stat = `VRM_FSM_CreateInstance` (&init, &(pThis->fsm));

  if (SYSTEM_STATUS_IS_OK (stat)) {
    sprintf ((char *)name_str, "play:0x%x", pThis -> hPlay);
    stat = VRM_FSM_SetName (pThis -> fsm, name_str);
    VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
  }
}

// thread and q

stat = VRM_OS_THR_Create( &VrmSrvThread, VRM_SRV_THREAD_NAME, VrmSrvMain, NULL );

static void * VrmSrvMain(void* data)
{
  while( isRunVrmSrv )
  {
    /* Get a message from the queue */
    stat = SYSTEMITC_API_PendEvent(&VrmSrvItcQueueHandle, 
        SYSTEMITC_API_PEND_FOREVER);
    if (!SYSTEM_STATUS_IS_OK(stat)) {
      VRM_DIAG_ASSERT_ZERO ("error in SYSTEMITC_API_PendEvent, VRM terminate");
      break;
    }
    payloadsize = SYSTEMITC_API_MAX_PAYLOAD_SIZE;
    stat = SYSTEMITC_API_ReadEvent(&`VrmSrvItcQueueHandle`, 
        &event, (void*)payload , &payloadsize);
    if (!SYSTEM_STATUS_IS_OK(stat)) {
      VRM_DIAG_ASSERT_ZERO ("error in SYSTEMITC_API_ReadEvent, VRM terminate");
      break;
    }

    /* Dispatch the message */
    stat = VrmSrvReceiveMessage(event,payload,payloadsize);
  }
}

static SYSTEM_STATUS VrmSrvReceiveMessage (uint32_t event, 
    void *payload, uint32_t payloadsize)
{
  // partition a event into sub range
  moduleId = VRM_GET_MSG_SUBCOMP_ID(event);

  if (SYSTEM_STATUS_IS_OK(stat))
  {
    switch (moduleId){
      ...
      case E_VRM_SUBCOMP_ID_ENGINE_LIVE:
        stat = LIVE_ReceiveMessage (event, payload, payloadsize);
        break;
      case E_VRM_SUBCOMP_ID_ENGINE_PLAY:
        stat = PLAY_ReceiveMessage (event, payload, payloadsize);
        break;
        ...
      default:
          VRM_DIAG_ASSERT_ZERO ("Unexpected message type");
          stat = VRM_STATUS_FAILURE;
          break;
    }
  }

  return stat;
}


<to-send-event-to-fsm>

// this ends up to call PLAY_Start. different fsm which may be run on
// different thread
//
// VRM_FSM_E(  E_JOB_MAN_SRV_INT_ST_CREATED,               /* state */
//         E_JOB_MAN_SRV_INP_START_BYPASS_COMMIT_CALLED,              /* input */
//         E_JOB_MAN_SRV_INT_ST_STARTING,                /* new state */
//         (VRM_FSM_ACTION)JobManSrvStartingState ),       /* action */

SYSTEM_STATUS PLAY_Start( const PLAY_PARAMS    *p_play_params,
                            PLAY_HANDLE                *p_hPlay)
{
  /* send fsm input to start */
  if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
    stat = PlaySendFSMInput (pPlaySession, E_PLAY_INPUT_START, `ASYNCHRONOUS`);
  }
}


// note: This function can send a messages which is async and or call a
// function. The route to this function can come from thread or from action
// function in fsm.

static SYSTEM_STATUS PlaySendFSMInput(const BASIC_PLAY * pThis, 
    E_PLAY_INPUT fsm_input, bool is_async)

/* WARNING: if is_asynch is set to XFALSE this function will change the state
 * of the FSM, so no actions which are state dependant may be done by the
 * calling function after this function has been called. */

{
  SYSTEM_STATUS stat = PLAY_STATUS_OK;
  PLAY_FSM_MSG_PAYLOAD fsm_msg;

  if (pThis != NULL )
  {
    if (is_async == true) 
    {
      /* send message to handle state transitions */
      fsm_msg.play_input  = fsm_input;
      fsm_msg.play_handle = pThis->hPlay;
      stat = PlaySendMessage (E_PLAY_MSG_TYPE_FSM, &fsm_msg, sizeof (PLAY_FSM_MSG_PAYLOAD));
    } 
    else 
    {

      /* process the input by the FSM immediately */
      stat = `VRM_FSM_Input (pThis->fsm, (uint16_t)fsm_input);`
    }
  }
  return stat;
}


/* payload for msg E_PLAY_MSG_TYPE_FSM*/
typedef struct PLAY_FSM_MSG_PAYLOAD_
{
    E_PLAY_INPUT    play_input;
    PLAY_HANDLE     play_handle;
} PLAY_FSM_MSG_PAYLOAD;


// send to `VrmSrvItcQueueHandle`
// E_PLAY_MSG_TYPE_FSM = VRM_GET_SUBCOMP_INITIAL_VALUE(E_VRM_SUBCOMP_ID_ENGINE_PLAY)    /* message containing FSM input */

stat = PlaySendMessage (E_PLAY_MSG_TYPE_FSM, &fsm_msg, sizeof (PLAY_FSM_MSG_PAYLOAD));


SYSTEM_STATUS PLAY_ReceiveMessage(uint32_t event, 
    void *payload, uint32_t payloadsize)
{
  BASIC_PLAY    *pThis        = NULL; /* relevant playback object for the message */

  /* dispatch message to the appropriate message according to the private
   * play module msg type */

  if (SYSTEM_STATUS_IS_OK (stat)) {

    switch ((E_PLAY_MSG_TYPE)event) 
    {
      case E_PLAY_MSG_TYPE_FSM:
        if ((payload != NULL) && (payloadsize == sizeof(PLAY_FSM_MSG_PAYLOAD)))
        {
          p_fsm_payload = (PLAY_FSM_MSG_PAYLOAD *)payload;
        }

        // get pThis
        stat = PlayGetFromPlayHandle (p_fsm_payload -> play_handle, &pThis);

        stat = `PlaySendFSMInput (pThis, p_fsm_payload->play_input, SYNCHRONOUS);`

        break;

      case E_PLAY_MSG_TYPE_FSM_DESTROY:
        if ((payload != NULL) && (payloadsize == sizeof(PLAY_FSM_DESTROY_MSG_PAYLOAD)))
        {
          p_fsm_destroy_payload = (PLAY_FSM_DESTROY_MSG_PAYLOAD	*)payload;
        }
        else 
        {
          VRM_DIAG_ASSERT_ZERO("msg type mismatch");
          stat = PLAY_STATUS_FAILURE;
        }
        if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_destroy_payload != NULL))	{
          stat = VRM_FSM_DestroyInstance (p_fsm_destroy_payload->hFsm);
          VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
        }
        break;

      default:
        VRM_DIAG_ASSERT_ZERO  ("Unknown message type");
        break;
    }
  }
}


SYSTEM_STATUS VRM_FSM_Input(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t input)
{
  FSM_DEFINITION* def = NULL;
  FSM_T fsm = (FSM_T)fsm_h; 

  if (fsm == NULL) { 
    _fsm_error(par_err);
    stat = VRM_FSM_FAILURE;
  }

  /* check user is not calling this function from within an action function */ 
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if (fsm->in_action) {

      // in debug mode, _fsm_error() call VRM_DIAG_Abort and can call DIAG_About depending on vrm configuration 
      // value. in release mode, do nothing. so there is no harm to let it run. 

      _fsm_error(act_err); 
      /* stat = VRM_FSM_FAILURE; */

      /* in release mode, we will recover by: */
      return VRM_FSM_SetNextInput(fsm_h,input);
    }
  }

  if (SYSTEM_STATUS_IS_OK(stat)) {
    def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle);
  }

  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if ((input > def->max_input) || (input < def->min_input)) { 
      _fsm_error(par_err);  
      stat = VRM_FSM_FAILURE; 
    }
  } 

  if  (SYSTEM_STATUS_IS_OK(stat)) { 
    if (!fsm->input_available) {
      fsm->input_available = true;
      `fsm->input_offset = input - def->min_input;`
    }
    else { 
      stat = VRM_FSM_FAILURE; /* this sould not happen */  		 
      VRM_DIAG_ASSERT_ZERO("Internal FSM error");
    }
  }

  /* run FSM while there is input available */
  while (SYSTEM_STATUS_IS_OK(stat) && (true == fsm->input_available)) { 
    stat = `FSMRun(fsm_h);` 
  } 
}

static SYSTEM_STATUS FSMRun(VRM_FSM_INSTANCE_HANDLE fsm_h) 
{
  FSM_TRANS   *pTrans;
  uint16_t     offset;
  FSM_T       fsm = (FSM_T)fsm_h;
  VRM_FSM_ENTRY   cb_entry;
  FSM_DEFINITION* def = NULL;

  DIAG_DECLARE_FUNCTION("FSMRun");	 

  // note: to break invariant so that end the loop
  /* in any case reset input available flag */ 	
  fsm->input_available = false;

  def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle);

  // note: use previous state, so pTrans is made from it
  /* calculate offset in states table -> from old state (state_offset) & input */
  offset = (fsm->state_offset * def->num_inputs) + fsm->input_offset; 

  /* set a pointer to the table's entry */
  pTrans = def->table + offset;

  /* L.R. */
  if ( VRM_FSM_ILLEGAL_STATE == pTrans->new_state ) {	    
    DIAG_LOG_INFO( VRM_diag_segment_id,
        ("^__ Attention: Undefined fsm_entry !!!")); 					 
  }

  /* `Setup the callback if any` */
  if (fsm->init.callback != NULL) {
    cb_entry.state	= fsm->state_offset + def->min_state;
    cb_entry.input = fsm->input_offset + def->min_input;
    cb_entry.new_state = pTrans->new_state + def->min_state;
  }

  /* If there is a real new state, set it */
  if (pTrans->new_state != VRM_FSM_ILLEGAL_STATE) {

    // note: update state_offset(current)
    /* set the state_offset + initialize timeout if needed */
    stat = `FSMSetState((VRM_FSM_INSTANCE_HANDLE)fsm, pTrans->new_state);`

    if (SYSTEM_STATUS_IS_OK(stat)) { 
      fsm->in_action = true; // eaf guard start 

      /* `Carry out action` */
      // note: do not care return value from eaf which is also void function
      // *set-init-data-for-each-instance*
      if (pTrans->action) {
        (*pTrans->action)(fsm->init.data);
      }

      /* `Call the callback if any` */
      if (fsm->init.callback) {
        fsm->init.callback (fsm->init.data, &cb_entry);
      }

      fsm->in_action = false; // eaf guard end 
    }	
  }
}


<note>
VRM_FSM_SetNextInput() vs VRM_FSM_Input() 

* use input from argument when input is not set before or input from
VRM_FSM_SetNextInput().

fsm->in_action

check user is not calling this function from within an action function
// so in_cation is not for supporting multi-threads

VRM_FSM_SetNextInput() is called in eaf to set next input event to be
preocessed, say deferred event. Then when is this will be run?

For this VRM fsm, eafs until E_PLAY_INT_STATE_WAIT_PANEL_CONFIG calls
VRM_FSM_SetNextInput() to set next state and this enables that one async
message runs through to this state.

// first async message

!ENTER  -VRM_SERVER   		< T:VRM_SRV M:basic_play.c F:PLAY_ReceiveMessage L:1090 > |-> PLAY_ReceiveMessage
!ENTER  -VRM_SERVER   		< T:VRM_SRV M:basic_play.c F:PlaySendFSMInput L:4547 > |-> PlaySendFSMInput
!ENTER  -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:VRM_FSM_Input L:810 > |-> VRM_FSM_Input

!MIL    -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:FSMRun L:922 > VRM-FSM: play:0x100: E_PLAY_INT_STATE_NONE -> (E_PLAY_INPUT_START) -> E_PLAY_INT_STATE_STARTING 
!MIL    -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:FSMRun L:922 > VRM-FSM: play:0x100: E_PLAY_INT_STATE_STARTING -> (E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE) -> E_PLAY_INT_STATE_ALLOCATING_RESOURCES 
!MIL    -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:FSMRun L:922 > VRM-FSM: play:0x100: E_PLAY_INT_STATE_ALLOCATING_RESOURCES -> (E_PLAY_INPUT_RMF_RESOURCES_ALLOCATED) -> E_PLAY_INT_STATE_RESOURCES_ALLOCATED 
!MIL    -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:FSMRun L:922 > VRM-FSM: play:0x100: E_PLAY_INT_STATE_RESOURCES_ALLOCATED -> (E_PLAY_INPUT_PANEL_CONFIGURE) -> E_PLAY_INT_STATE_CONFIGURING 
!MIL    -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:FSMRun L:922 > VRM-FSM: play:0x100: E_PLAY_INT_STATE_CONFIGURING -> (E_PLAY_INPUT_WAIT_PANEL_CONFIG) -> E_PLAY_INT_STATE_WAIT_PANEL_CONFIG 

!EXIT   -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:VRM_FSM_Input L:858 > <-| VRM_FSM_Input : return_status = 0xb400000
!EXIT   -VRM_SERVER   		< T:VRM_SRV M:basic_play.c F:PlaySendFSMInput L:4569 > <-| PlaySendFSMInput : return_status = 0xb400000

// next async message

!ENTER  -VRM_SERVER   		< T:VRM_SRV M:basic_play.c F:PlaySendFSMInput L:4547 > |-> PlaySendFSMInput
!ENTER  -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:VRM_FSM_Input L:810 > |-> VRM_FSM_Input
!MIL    -VRM_SERVER   		< T:VRM_SRV M:fsm.c F:FSMRun L:922 > VRM-FSM: play:0x100: E_PLAY_INT_STATE_WAIT_PANEL_CONFIG -> (E_PLAY_INPUT_MCONN_CONFIGURED) -> E_PLAY_INT_STATE_CONFIGURED 

HOW?

SYSTEM_STATUS VRM_FSM_Input()
{
  /* run FSM while there is input available */
  while (SYSTEM_STATUS_IS_OK(stat) && (true == fsm->input_available)) { 
    stat = FSMRun(fsm_h); 
  } 

  return stat;
}

This while loops do the trick. Firstly, run the first eaf and this set next
state and exit. In the second iteration, run that agian until input_available
is true.


={============================================================================
*kt_dev_cxx_0000* cxx-fsm-comparison

<cxx-fsm-c++>

* naturally support class and instance
* event action function
* no table-driven

<cxx-fsm-dynamic>

* manually support class and instance
* event action function
* table-driven but one table. use state and event enums and one transiiton
  table.
* support all event that all state support

<cxx-fsm-static>

* support instance
* state action function which means more state or branches in action function
* to behave differently depending on input event to implement the same fsm
  compared with dynamic or C++ fsm.
* table-driven. use list of structures to define fsm which requires many
  changes in places


# ============================================================================
#{
={============================================================================
*kt_dev_blush_001*	accessing neighbors in array

2013.10. when had a problem solving which is to find a path in a maze, wrote a func like:

bool checkWhite( const Pos& pos)
{
	// upper-left
	if( A[pos.xpos-1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper
	else if ( A[pos.xpos][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper-right
	else if ( A[pos.xpos+1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// same-left
	else if ( A[pos.xpos-1][pos.ypos] == WHITE )
	{
		return true;
	}
	// same-right
	else if ( A[pos.xpos+1][pos.ypos] == WHITE )
	{
		return true;
	}
	// lower-left
	else if ( A[pos.xpos-1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower
	else if ( A[pos.xpos][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower-right
	else if ( A[pos.xpos+1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	else
		return false;
}

Although the above tried to give it some priority, this should be something like used in
*kt_dev_algo_006* :

int NeighborCount( Grid map, int row, int col)
{
	 int i, j, count = 0;

	 for( i = row-1; i <= row+1; i++ )
		  for( j = col-1; j <= col+1; j++ )
				if( map[i][j] == ALIVE )
					 count++;

	 // exclude one for itself
	 if( map[row][col] == ALIVE )
		  count--;

	 return count;
}


# ============================================================================
#{ design
={============================================================================
*kt_dev_design_001* generic structure access

Q: How to design generic interface to support different structures in size or format?

{one} 
As shown in *kt_linux_core_300* ipc: socket: LPI 56, socket system calls uses generic interface to
supports different address structures with common call signatures.

See {generic-address-structure} for more details and accept() is an example:

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

Here, since kernel do not know the type of structure and no type in call signature, uses lenth and
kernel use this to move addr structure between user and kernel space and to check size and report
back the size written.


{two}
This is the way that NDS CDI ioctl use.

note: capabilitySize is really no use since version(type) tells you what type it uses.
note: then why *CapEx structure? Appears that CDI limits the number of arguments in ioctl() to 3
although POSIX ioctl() supports ioctl with varying arguments. That's why it uses *CapEx structure to
use more arguments. Not sure the background of this limitation.

Q: what's call signature of ioctl in kernel?

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX_VERSION, uint32_t *version);

#define VIDEO_DECODER_CAP_V0     (0x00000001)
#define VIDEO_DECODER_CAP_V1     (0x00000002)
#define VIDEO_DECODER_CAP_V2     (0x00000004)
#define VIDEO_DECODER_CAP_V3     (0x00000008)

typedef struct {
  ...
} VideoDecoderCapsV2;

typedef struct {
  ...
} VideoDecoderCapsV3;

typedef struct {
   uint32_t    version;             // @in
   void        *capability;         // @out
   uint32_t    capabilitySize;      // @in
} VideoDecoderCapEx;

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX, VideoDecoderCapEx *arg);


{
  uint32_t                video_dec_caps_version;
  VideoDecoderCapsEx      video_decoder_caps;
  VideoDecoderCapsV0      caps_v0 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV1      caps_v1 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV2      caps_v2 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};

  if (ioctl(fd, VIDEO_DECODER_GET_CAPS_EX_VERSIONS, &video_dec_caps_version) == 0)
  {
    if (video_dec_caps_version & VIDEO_DECODER_CAP_V2)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V2;
      video_decoder_caps.capability = &caps_v2;
      video_decoder_caps.capabilitySize = sizeof(caps_v2);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v2.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
    else (video_dec_caps_version & VIDEO_DECODER_CAP_V1)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V1;
      video_decoder_caps.capability = &caps_v1;
      video_decoder_caps.capabilitySize = sizeof(caps_v1);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v1.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
  }
}


# ============================================================================
#{
={{===========================================================================
*kt_dev_uml_001*	aggragation

Two aggregations: weak and strong.

1) weak. white diamond-shaped arrowhead pointing towards the target or parent class.

2) strong. a black diamond-shaped arrowhead. composite aggragation.

# example

AddressBook <*>----------- ContactGroup
            1         0..*

(copied from *kt_dev_ecpp_011* )

# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...


={============================================================================
*kt_dev_ref_002* sites

http://eli.thegreenplace.net/


==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
