*kt_dev_env*		tw=100	 		

aWed 18 Dec 2013 09:50:53 GMT

KT KB. VIM. ECLIPSE. NETBEAN

|kt_dev_env_vim_000|	links
|kt_dev_env_vim_001|	install and version
|kt_dev_env_vim_002|	plugins {unite}
|kt_dev_env_vim_003|	key sheet 

PROG

|kt_dev_env_vim_015|	prog:tag:cscope
|kt_dev_env_vim_016|	prog:tag:ctag: vim-tag {marks} {jumps}
|kt_dev_env_vim_017|	prog:tag:gtag
|kt_dev_env_vim_018|	prog:build and error {makeprg}
|kt_dev_env_vim_019|	prog:completion
|kt_dev_env_vim_020|	prog:edit: match paren and others {%-match}
|kt_dev_env_vim_021|	prog:edit: shift and paste block {indention}
|kt_dev_env_vim_022|	prog:edit: adding and substracting
|kt_dev_env_vim_023|	prog:edit: man help in vim 

|kt_dev_env_vim_100|	edit: motion {text-object} {move-screen}
|kt_dev_env_vim_101|	edit: fold

|kt_dev_env_vim_200|	script

|kt_dev_env_vim_002|	config {vimrc}
|kt_dev_env_vim_003|	recovery, swap and backup
|kt_dev_env_vim_004|	color and syntax
|kt_dev_env_vim_005|	plugin: foldsearc
|kt_dev_env_vim_007|	search: global command and range
|kt_dev_env_vim_008|	search and substitute {vim-subst} {vim-global}
|kt_dev_env_vim_009|	regexp - char class
|kt_dev_env_vim_010|	regexp - word boundary
|kt_dev_env_vim_011|	regexp - escaped or meta char 	 kt_vim_reg_meta
|kt_dev_env_vim_012|	regexp - grouping
|kt_dev_env_vim_013|	regexp - alternation
|kt_dev_env_vim_014|	regexp - precedence
|kt_dev_env_vim_015|	regexp - examples
|kt_dev_env_vim_019|	history
|kt_dev_env_vim_020|	copy and paste between OSs and into cmd line	kt_vim_copy_paste
|kt_dev_env_vim_021|	select and copy {registers} {clipboard} {comment-multiple-lines}
|kt_dev_env_vim_021|	show whitespace
|kt_dev_env_vim_022|	format and wrap {tabstop}
|kt_dev_env_vim_024|	modes
|kt_dev_env_vim_025|	helps
|kt_dev_env_vim_027|	files and buffers
|kt_dev_env_vim_028|	windows and tab {vim-tab}
|kt_dev_env_vim_029|	run external program
|kt_dev_env_vim_030|	91 and 92 chars {change-encoding} {to-search-key-code}
|kt_dev_env_vim_031|	^M char
|kt_dev_env_vim_032|	change working dirs
|kt_dev_env_vim_033|	mapping 
|kt_dev_env_vim_034|	tool: ag bin and ag vim plugin


# emacs
#

|kt_dev_env_emacs_001|	install and version


# git
#
|kt_dev_env_git_000|		reference
|kt_dev_env_git_001|		basic
|kt_dev_env_git_002|		init, clone, and diff
|kt_dev_env_git_003|		log
|kt_dev_env_git_004|		undo
|kt_dev_env_git_005|		remote servers, push and pull.
|kt_dev_env_git_006|		tagging
|kt_dev_env_git_007|		tips
|kt_dev_env_git_008|		branching
|kt_dev_env_git_009|		remote branch
|kt_dev_env_git_010|		rebasing
|kt_dev_env_git_020|		other useful commands


# tools
#
|kt_dev_env_tool_001|	eclipse: to create a project from existing source tree 
|kt_dev_env_tool_002|	netbean: to create a project from existing source tree 
|kt_dev_env_tool_003|	total commander short cuts
|kt_dev_env_tool_004|	outlook keys
|kt_dev_env_tool_005|	ms-project: set delay


# ============================================================================
#{

==============================================================================
*kt_dev_env_vim_000*	links

unimpaired.vim : Pairs of handy bracket mappings
http://www.vim.org/scripts/script.php?script_id=1590

http://www.viemu.com/a-why-vi-vim.html
http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/

http://andrewradev.com/2011/06/08/vim-and-ctags/

==============================================================================
*kt_dev_env_vim_001*	install and version

{get-mercurial}

# Debian/Ubuntu
apt-get install mercurial

# to update your working copy.
hg checkout branchname or hg checkout tagname 

{install}

./configure --prefix=/home/kit --enable-cscope
make VIMRUNTIMEDIR=/home/kit/vim MAKE="make -e"
make install


{version}

can see options to used to build.
:ver

% gvim --version | egrep '\+lua'

{check-features}

compiled with if_lua. If :echo has("lua") returns 1, then you're done; otherwise, see below.

{build-from-source}

On Linux, your distribution's package manager may have a fairly outdated Vim build (for example,
Ubuntu 12.04 ships Vim 7.3.429). However, building Vim on Linux is not difficult. Remember to
specify --with-lua (or --with-features=huge).

http://vim.wikia.com/wiki/Building_Vim

For any platform:

It is easy to build Vim from the source code. In general, it takes four steps:

Get dependencies. On Unix-like systems, apt-get build-dep vim-gnome or similar can do this for you.

Get the Vim source code from Mercurial or a GitHub clone.  

Change to the directory with the Vim source code and run "make".  

Do a "make install" or manually copy necessary files to somewhere Vim knows to use. See :help
$VIMRUNTIME for details and our tip on manually locating your Vim files. 

Building Vim on Ubuntu

You need the required development packages on Ubuntu to build the GUI: 

sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev

$ cd vim7
$ cd src
$ make distclean
$ ./configure --with-features=huge --enable-gui=gnome2
./configure --prefix=/home/kit --enable-python3interp=yes --enable-luainterp=yes --with-features=huge --enable-gui=gnome2 --enable-cscope
$ make
$ sudo make install

See vim/src/auto/config.log for more detailed logs and ./configure --help for options which comes
from vim/src/auto/configure

<to-enable-python>

https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source

For 3.3:

Get python from python org, build and install. Then find out dir where config.c for python is. For
3.3, this is /usr/local/lib/python3.3/config-3.3m/. Do not need to change makefile.

Then use this:

./configure --prefix=/home/kit --enable-python3interp=yes --enable-luainterp=yes --with-features=huge --enable-gui=gnome2 --enable-cscope --with-python3-config-dir=/usr/local/lib/python3.3/config-3.3m

For 2.7 which is already installed:

/usr/lib/python2.7/config

If build failed since cannot find some files relating python then do:
apt-get install python-dev

The following NEW packages will be installed
  libssl-dev libssl-doc python-dev python2.7-dev

apt-get install lua5.2 liblua5.2-dev

./configure --prefix=/home/kit --enable-pythoninterp=yes --enable-luainterp=yes --with-features=huge --enable-gui=gnome2 --enable-cscope --with-python-config-dir=/usr/lib/python2.7/config


==============================================================================
*kt_dev_env_vim_002*	plugins {unite}

{unite}

help unite-action
help unite_default_key_mappings

http://majutsushi.github.io/tagbar/
http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/

This requires vimproc https://github.com/Shougo/vimproc.vim
git clone https://github.com/Shougo/vimproc.vim and build c files and add it to runtimepath


{unite-tag}

https://github.com/tsukkee/unite-tag
Get it downloaded and copy tag.vim to /home/kit/.vim/bundle/unite.vim/autoload/unite/sources where
unite installed.

{ycm}

https://github.com/Valloric/YouCompleteMe

1. Ensure that your version of Vim is at least 7.3.584 and that it has support for python2
scripting. Might need to build gvim.


{solarized-colorscheme}

Not working with neobundle and done manually by coyping into .vim/color

http://altercation/vim-colors-solarized

Option 1: Manual installation

Move solarized.vim to your .vim/colors directory. After downloading the vim script or package:

$ cd vim-colors-solarized/colors
$ mv solarized.vim ~/.vim/colors/

{status}

https://github.com/bling/vim-airline

{ctag-ctrlp}

http://blog.stwrt.ca/2012/10/31/vim-ctags

Vim + Ctags + Ctrlp

If you're using the Ctrlp plugin for vim, running :CtrlPTag will let you search through your tags
file and jump to where tags are defined. Very useful when you need to jump around a project in a
hurry.

http://kien.github.io/ctrlp.vim/

___________
basic usage

Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode.
Run :CtrlPBuffer or :CtrlPMRU to start CtrlP in find buffer or find MRU file mode.
Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time.

Check :help ctrlp-commands and :help ctrlp-extensions for other commands. Once CtrlP is open:

Press <F5> to purge the cache for the current directory to get new files, remove deleted files and
apply new ignore options.
* Press <c-f> and <c-b> to cycle between modes.
Press <c-d> to switch to filename search instead of full path.
Press <c-r> to switch to regexp mode.
* Use <c-j>, <c-k> or the arrow keys to navigate the result list.
* Use <c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new ver/hor split.
Use <c-n>, <c-p> to select the next/previous string in the prompt's history.
Use <c-y> to create a new file and its parent directories.
Use <c-z> to mark/unmark multiple files and <c-o> to open them.

Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help.

Submit two or more dots .. to go up the directory tree by one or multiple levels.
End the input with a colon : followed by a command to execute it after opening the file:
  Use :25 to jump to line 25.
  Use :/any\:\ string to jump to the first instance of any: string.
  Use :+setfiletype\ myfiletype|25 to set the filetype to myfiletype then jump to line 25.
  Use :diffthis when opening files marked by <c-z> to run :diffthis on the first 4 files.

___________
intallation

1. Clone the plugin into a separate directory:
$ cd ~/.vim
$ git clone https://github.com/kien/ctrlp.vim.git bundle/ctrlp.vim

2. Add to your ~/.vimrc:
set runtimepath^=~/.vim/bundle/ctrlp.vim

3. Run at Vim's command line:
:helptags ~/.vim/bundle/ctrlp.vim/doc

It's also handy to bind this to a keyboard shortcut. I use this in my ~/.vimrc:

nnoremap <leader>. :CtrlPTag<cr>

http://www.bestofvim.com/plugin/ctrl-p/ and for other extensions

" for ctrlp
" tag
nnoremap ,t :CtrlPTag<cr>
" func list
nnoremap ,c :CtrlPFunky<cr>
" file
nnoremap ,f :CtrlP<cr>
" buffer
nnoremap ,b :CtrlPBuffer<cr>
" mru
nnoremap ,m :CtrlPMRU<cr>
" dir
nnoremap ,d :CtrlPDir<cr>


{ctag-tagbar}

Vim + Ctags + Tagbar

http://majutsushi.github.io/tagbar/

Tagbar is another useful vim plugin for working with a tags file. Install it, and map a key to it (I
use ,b):

nnoremap <silent> <Leader>b :TagbarToggle<CR>

When the tagbar is toggled, it will pop up on the right side of the vim window and show the tags
picked up by ctags for the current file, organized by tag type, e.g. function, variable, class, etc.
This effectively gives you a birds-eye view of the code you're working on.


{ctag-rebuild}

<approach-one>
The following Vim key mapping is quite useful to rebuild the tag file in the directory of the
current source file:

:nmap ,t :!(cd %:p:h;ctags *.[ch])&

<approach-two>
This can be a pain in the ass to run regularly, so you might like to bind it to a vim keyboard
shortcut so you can run it every so often, or add some git hooks to run ctags every time you check
out, commit, or fetch with git

http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html


==============================================================================
*kt_dev_env_vim_003*	key sheet 

      " from {move-screen}
C-d	" down half screen. inoremap <C-d> <C-d>zz
C-u	" up half screen (backward). inoremap <C-u> <C-u>zz

C-^	" switch between the previous and the next in the list

==============================================================================
*kt_dev_env_vim_002*	config

{scriptnames}

:scrip[tnames]		List all sourced script names, in the order they were first sourced.


{set-font-for-gvim}

when use bigger screen with gvim, it is hard to read so need to change font. try 'edit->select font'
in the menu to see which is better then set it in .vimrc.

FreeMono, 12pt


{vimrc-linux}

# vars from ver

   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
      user exrc file: "$HOME/.exrc"
  system gvimrc file: "$VIM/gvimrc"
    user gvimrc file: "$HOME/.gvimrc"
    system menu file: "$VIMRUNTIME/menu.vim"
  fall-back for $VIM: "/usr/share/vim"


--
if has("gui_running")
  if has("gui_gtk2")
    set guifont=FreeMono\ 12
  endif
endif

" clipboard
set clipboard=unnamed
set clipboard=unnamedplus

" for user syntax
syntax enable

set incsearch

" set ignorecase
" for line number
set nu

set smartindent
set shiftwidth=4
set tabstop=4

" show autocomplete menus
set wildmenu

" show editing mode
set showmode

colorscheme desert

" help: auto-format
" set formatoptions+=a

set cursorline

set autoread
set hlsearch
set nowrapscan

set foldenable


{vimrc-windows}

:e $VIM\_vimrc
:echo $VIM

--
set nocompatible
filetype on
filetype plugin on
source $VIMRUNTIME/vimrc_example.vim
source $VIMRUNTIME/mswin.vim
behave mswin

set diffexpr=MyDiff()
function MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let eq = ''
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      let cmd = '""' . $VIMRUNTIME . '\diff"'
      let eq = '"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
endfunction

" for user syntax
syntax enable

set incsearch

" set ignorecase
" for line number
set nu

set smartindent
set shiftwidth=4
set tabstop=4

" show autocomplete menus
set wildmenu

" show editing mode
set showmode

colorscheme darkblue
" colorscheme desert

" help: auto-format
" set formatoptions+=a

" to highlight currentline
set cursorline

set autoread
set hlsearch
set nowrapscan

set foldenable
" set foldmethod=syntax
" set foldlevelstart=1
" set foldnestmax=5
" let g:is_bash=1
" let g:sh_fold_enabled=4
" let sh_fold_functions=1

" marks. to save the session info for up to 100 files and not to save global marks
"set viminfo='100,f0

au BufWinEnter,BufRead,BufNewFile *.nds set filetype=nds

" enable fold save and restore
au BufWinEnter *.nds silent loadview
au BufWinLeave *.nds mkview

" to see only matched line. do search first and hit \z
nnoremap \z :setlocal foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\\|\\|(getline(v:lnum+1)=~@/)?1:2 foldmethod=expr foldlevel=0 foldcolumn=2<CR>
--


{option-window}

Like option menu, opens a option window where can change options by using <Enter> to toggle

:options

To get help about options, use singled-quoted help

:help 'option-name'


==============================================================================
*kt_dev_env_vim_003*	recovery, swap and backup

where <filename> is the name of the file you were editing at the time of the crash:
vim -r <filename>

You can list the recoverable files:
vim -r

# .vimrc
# set backup " backup on
# set nobackup " backup off
# The 'directory' option controls where swap files go.

set backup
set backupdir=/home/NDS-UK/parkkt/vimback
set directory=/home/NDS-UK/parkkt/vimback


{swap-file}

(http://vimdoc.sourceforge.net/htmldoc/recover.html)
1. Vim stores the things you changed in a swap file.  Using the original file you started from plus the
swap file you can mostly recover your work.

You can see the name of the current swap file being used with the command:

:sw[apname]

The name of the swap file is normally the same as the file you are editing, with the extension
".swp".	  

The swap file is deleted as soon as Vim stops editing the file.

By setting the 'directory' option you can place the swap file in another place than where the edited
file is.

2. The swap file might be the result from a previous crash of Vim or the computer.  Check the dates
mentioned in the message.  If the date of the swap file is newer than the file you were editing, and
this line appears:

modified: YES 

Then you very likely have a crashed edit session that is worth recovering.


If the date of the file is newer than the date of the swap file, then either it was changed after
the crash (perhaps you recovered it earlier, but didn't delete the swap file?), or else the file was
saved before the crash but after the last write of the swap file (then you're lucky: you don't even
need that old swap file).  Vim will warn you for this with this extra line:

NEWER than swap file! 	

WHAT TO DO?

If dialogs are supported you will be asked to select one of five choices:

  Swap file ".main.c.swp" already exists! 
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: 

O  Open the file readonly.  Use this when you just want to view the file and
   don't need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.

E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe then sorry.

R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.

Q  Quit.  This avoids starting to edit the file.  Use this if there is another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When starting Vim with
   files in several windows, Vim quits only if there is a swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.

A  Abort.  Like Quit, but also abort further commands.  This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.

D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.
   
BACKUP

If you write to an existing file (but do not append) while the 'backup',
'writebackup' or 'patchmode' option is on, a backup of the original file is
made.


{keep-the-original}

To make Vim keep the original file, set the 'patchmode' option.  This specifies the extension used
for the first backup of a changed file.  Usually you would do this:

:set patchmode=.orig


==============================================================================
*kt_dev_env_vim_004*	color and syntax

{colorscheme}

:colorscheme evening

{color-syntax}

:syntax clear		# to disable
:syntax off			# to turn off

{user-syntax}

.vim/syntax/nds.vim

can use egrep style as below

syntax match ndsMesg02          /UAM_DCM_PARAM_DATA_INTERNAL_TYPE_STANDBY_\(IN\|OUT\)/
hi def link ndsMesg02 Type


==============================================================================
*kt_dev_env_005*	plugin: foldsearch

http://www.vim.org/scripts/script.php?script_id=2302

to see those ony matches with pattern

# not working
Fp KEY_PRESS\|VRM_JOB_START

Fp VRM_JOB_START\|TUNER_LOCKED\|hMC=0x304\|hMC=772
s/MCM_MEDIACONN_Run\|VRM_JOB_START\|hMC=0x36


==============================================================================
*kt_dev_env_006*	plugin: conque

Conque is a Vim plugin which allows you to run interactive programs, such as bash on linux or powershell.exe on Windows, inside a Vim buffer. In other words it is a terminal emulator which uses a Vim buffer to display the program output.
http://code.google.com/p/conque
:ConqueTermSplit



==============================================================================
*kt_dev_env_vim_008*	search and substitute

{search-direction}

/		" forward. note: this supports history and pattern. /the\> or /\<the\>
?		" backward
n		" [num]next forward
N		" next backward

*		" search a word under the cursor. forward
#		" search a word under the cursor. backward
g#/g* " search but don't put "\<" and "\>" around the word. so included non-exact matches.


{search-seleced-words}

select words using visual seleciton and yank. press '/' and 'ctrl-r *' to copy words into search.

Or

Use followings in vimrc(http://vim.wikia.com/wiki/Search_for_visually_selected_text):

Features

o Press * to search forwards for selected text, or # to search backwards.
o As normal, press n for next search, or N for previous.
o Handles multiline selection and search.
o Whitespace in the selection matches any whitespace when searching (searching
for "hello world" will also find "hello" at the end of a line, with "world" at
the start of the next line).  
o Each search is placed in the search history allowing you to easily repeat previous searches.  
o No registers are changed. 

" Search for selected text, forwards or backwards.
vnoremap <silent> * :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy/<C-R><C-R>=substitute(
  \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>
vnoremap <silent> # :<C-U>
  \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
  \gvy?<C-R><C-R>=substitute(
  \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
  \gV:call setreg('"', old_reg, old_regtype)<CR>


{search-settings}

:set ignorecase
:set noignorecase

:set hlsearch 	# set search highlight
:nohl[search]	# disable highlight but do not reset

:set incsearch		# inc search

:set nowrapscan	# stops the search at the end of file


{subst-using-search}

/four<Enter>	find the first string "four"
cwfive<Esc>	change the word to "five"
n		find the next "four"
.		repeat the change to "five'
n		find the next "four"
.		repeat the change
	  etc.


{range}

Specifier 	Description

number		an absolute line number
.		the current line
$		the last line in the file
%		the whole file. The same as 1,$
't		position of mark "t"
/pattern[/] 	the next line where text "pattern" matches.
?pattern[?] 	the previous line where text "pattern" matches
\/ 		the next line where the previously used search pattern matches
\?		the previous line where the previously used search pattern matches
\&		the next line where the previously used substitute pattern matches


{vim-subst}

# Part of the command word enclosed in the "[" & "]" can be omitted. 
# NOTE: only first search is a pattern. MAKE SENSE.
:substitute
:range s[ubstitute]/pattern/string/cgiI

For each line in the range replace a match of the pattern with the string where:

c	Confirm each substitution
g	Replace all occurrences in the line (without g - only first).
i	Ignore case for the pattern.
I	Don't ignore case for the pattern.

# the % means "all the lines of the file". "global" option, which tells Vim to replace every
# occurrence on a line, and not just the first occurrence.

:s/from/to/g                     # on the current line
:%s/from/to/g 
:%s/printf(/fprintf(stderr,/gc
:.,$s/yes/no/

# can use pattern in range and use other char instead of slash(/) which makes no need to use
# backslash to escape when there is a slash in search string
# ?pattern? means search backword and /pattern/ means forward.

:?^Chapter?,/^Chapter/s=grey=gray=g
:'t,'b                                   # use marks

# the new c option we are using means we want a 'c'onfirmation message for every replace.  replace
# with foo (y/n/a/q/l/^E/^Y)?  The "y" and "n" are self-explanatory, but what about the rest?
#
# a : to tell Vim to go ahead and replace all instances of the matched answer with a. from the current.  
# l : to tell Vim to make the current change and then stop, use l, for last.  ^E and ^Y allow
# you to scroll the text using Ctrl-e and Ctrl-y.

:0,10s/from/to/gc

# matching one or more terms. used alternation.
 
:%s/Kang\|Kodos/alien/gc

# it adds '|>' to the beginning of one line.
:s/^/|> /
:%s/^/|> /


{vim-global-command}

To find a match for a pattern and execute a command on them. Execute the Ex command cmd (default
":p") on the lines within [range] where pattern matches. If pattern is preceded with a ! - only
where match does not occur.

:range g[lobal][!]/pattern/cmd


The global commands work by first scanning through the [range] of of the lines and marking each line
where a match occurs. In a second scan the [cmd] is executed for each marked line with its line
number prepended. If a line is changed or deleted its mark disappears. 

The default for the [range] is the whole file.  

Note: Ex commands are all commands you are entering on the Vim command line like :s[ubstitute],
:co[py] , :d[elete], :w[rite] etc. Non-Ex commands (normal mode commands) can be also executed via
:norm[al]non-ex command

# '+' char used instead and do subst on C++ comment. not perfect
:g+//+s/foobar/barfoo/g

# to delete all lines containing the string "George Bush"
:g/George Bush/d

# print all matches
:g/George Bush/p

Copy all lines matching a pattern to register 'a'.  qaq is a trick to clear register a (qa starts
recording a macro to register a, then q stops recording, leaving a empty). y A is an Ex command
(:help :y). It yanks the current line into register A (append to register a).  

qaq:g/<pattern>/y A [KT] not work as copies a single line.


==============================================================================
*kt_dev_env_009*	regexp - char class

Note that the range represents just one character in the search pattern, that is [0123] and 0123 are not the same.

[a-z] 		# Matches a single lowercase letter
[A-Z] 		# Matches a single uppercase letter
[a-zA-Z] 	# Matches a single letter
[0-9] 		# Matches a single number
[a-zA-Z0-9] 	# Matches a single letter or number
[^a-f]		# not

"^" will lose its special meaning if it's not the first character in the range.

A negated character class means "match a character that's not listed and not don't match what is listed."
Note KT. therefore, 'q[^u]' don't match with 'Iraq'

In class, '-' and '^' are only meta char and '-' isn't meta if it comes the
first. 

# example

s:[65]:Dig:g

Before:
High 65 to 70. Southeast wind around 10

After:
High DigDig to 70. Southeast wind around 10

Note KT. because [65] matches both '6' and '5'. 

s:65:Dig:g

Before:
High 65 to 70. Southeast wind around 10

After:
High Dig to 70. Southeast wind around 10


==============================================================================
*kt_dev_env_010*	regexp - word boundary

That dang-tootin' #@!%* varmint's cost me $199.95!
^  " ^  " ^    "        ^     " ^"^  " ^"  ^ " ^"
#### #### ######        ####### # #### ##  ### ##

^ where \< is true, " where \> is true, # is words  

s:\<vi\>:VIM:g


==============================================================================
*kt_dev_env_011*	regexp - escaped or meta char 	 *kt_vim_reg_meta*

Quantifers ~
?	# optional. e.g. "colou?r" will match color or colour
* 	# matches 0 or more of the preceding characters, ranges or metacharacters(as many times as possible)
.* 	# matches everything including empty line
+ 	# matches 1 or more of the preceding characters...

e.g. ' +' is the same as '  *'.

in summary:

	min required	max to try	meaning
?	none		1		one optional
*	none		no limit	any amout ok
+	1		no limit	at least one

\{n,m}	matches from n to m of the preceding characters...
\{n}	matches exactly n times of the preceding characters...
\{,m}	matches at most m (from 0 to m) of the preceding characters...
\{n,}	matches at least n of of the preceding characters... where n and m are positive integers (>0)

\u\w		# matches 'MI', 'VRMS', 'EVENT_MGR_THREAD', etc..
\u\w\+		# similar to the above but matches more. this qualifiers are greedy. 

".*"		# matches everything between " and ". e.g. "$VIM/.gvimrc". You can check this with ":version"

non-greedy quantifiers:

\{-}	matches 0 or more of the preceding atom, as few as possible
\{-n,m}	matches 1 or more of the preceding characters...
\{-n,}	matches at lease or more of the preceding characters...
\{-,m}	matches 1 or more of the preceding characters...
where n and m are positive integers (>0)


".\{-}" match: let's use \{-} in place of * in our pattern.
this file is normally "$VIM/gvimrc". You can check this with ":version".
                      #############

/"[^"]\+"/ or /"\S\+"/ match:
this file is normally "$VIM/.gvimrc". You can check this with ":version".    
                      ##############                          ##########


metacharacters ~

# 	Matching
.	any character except new line 	  	 
\s	whitespace character. so '\s*$' means a blank line 	
\S	non-whitespace character
\d	digit 	
\D	non-digit
\x	hex digit 	
\X	non-hex digit
\o	octal digit 	
\O	non-octal digit
\h	head of word character (a,b,c...z,A,B,C...Z and _) 	
\H	non-head of word character
\p	printable character 	
\P	like \p, but excluding digits
\w	word character 	
\W	non-word character
\a	alphabetic character 	
\A	non-alphabetic character
\l	lowercase character 	
\L	non-lowercase character
\u	uppercase character 	
\U	non-uppercase character

# from python
\w
    When the LOCALE and UNICODE flags are not specified, matches any alphanumeric character and the underscore; this is equivalent to the set [a-zA-Z0-9_]. With LOCALE, it will match the set [0-9_] plus whatever characters are defined as alphanumeric for the current locale. If UNICODE is set, this will match the characters [0-9_] plus whatever is classified as alphanumeric in the Unicode character properties database.

\W
    When the LOCALE and UNICODE flags are not specified, matches any non-alphanumeric character; this is equivalent to the set [^a-zA-Z0-9_]. With LOCALE, it will match any character not in the set [0-9_], and not defined as alphanumeric for the current locale. If UNICODE is set, this will match anything other than [0-9_] and characters marked as alphanumeric in the Unicode character properties database.

\b
    Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of alphanumeric or underscore characters, so the end of a word is indicated by whitespace or a non-alphanumeric, non-underscore character. Note that \b is defined as the boundary between \w and \W, so the precise set of characters deemed to be alphanumeric depends on the values of the UNICODE and LOCALE flags. Inside a character range, \b represents the backspace character, for compatibility with Python's string literals.


==============================================================================
*kt_dev_env_012*	regexp - grouping

two uses for parentheses: 
to limit the scope of alternation, |, and 
to group multiple characters into larger units to which you can apply quantiers like question mark and star.

and back referencing is the third

# to swap two words
:s/\(one\) \(two\)/\2 \1/g 


==============================================================================
*kt_dev_env_013*	regexp - alternation

Note. usable in egrep

Using "\|" you can combine several expressions into one which matches any of its components. The first one matched will be used.

\(Date:\|Subject:\|From:\)\(\s.*\)

will parse various mail headings and their contents into \1 and \2, respectively. The thing to remember about VIM alternation that it is {not greedy}. It won't search for the longest possible match, it will use the first that matched. That means that the order of the items in the alternation is important!

# for egrep. all have the same result.
#
‘gr[ae]y'
‘gray|grey'
‘gr(a|e)y'

As in arithmetic expressions, regular expressions are executed in a certain order of precedence. 
Here the table of precedence, from highest to lowest:


==============================================================================
*kt_dev_env_014*	regexp - precedence

Precedence Regexp Description
1 \( \)			# grouping
2 \=,\+,*,\{n} etc.	# quantifiers
3 abc\t\.\w 		# sequence of characters/metacharacters, not containing quantifiers or grouping operators
4 \| 			# alternation


==============================================================================
*kt_dev_env_015*	regexp - examples

/^$/ 		# you match empty lines
/^.*$/ 		# An entire line 
/ */		# One or more spaces 

# use a different separator
#
Tip 1: frequently you need to do S&R in a text which contains UNIX file paths - text strings with slashes ("/") inside. Because S&R command uses slashes for pattern/replacement separation you have to escape every slash in your pattern, i.e. use "\/" for every "/" in your pattern:

s/\/dir1\/dir2\/dir3\/file/dir4\/dir5\/file2/g

To avoid this so-called "backslashitis" you can use different separators in S&R (I prefer ":")

s:/dir1/dir2/dir3/file:/dir4/dir5/file2:g
s:\<vi\>:VIM:g

# delete trailing spaces
:%s:\s\+$:

# show trailing wss
/\s\+$

# show all tabs
/\t

#
input to match:

NDS: ^[00:30:37]0946686637.742067 !ERROR -SPM_COMMON   < p:000000c8 t:2bb79520 T:no name M:spm_common.c F:SPM_COMMON_waitOnCondition L:02194 > Condition wait timed out!

$ grep "\!ERROR .* SPM_COMMON_waitOnCondition" LOG
no match because the second space.

$ grep "\!ERROR.* SPM_COMMON_waitOnCondition" LOG  
no match as before.

$ grep "\!ERROR.*SPM_COMMON_waitOnCondition" LOG  
match.

# 12 hours
12 ?? ?? ?? 9:17 am or 12:30 pm

9:45 pm
13:21 pm
9:45 am
23:31 pm
33323:31 pm
1:11 am

# this mathes all!
egrep '(1[012]|[0-9]):[0-5][0-9] am|pm' x  


==============================================================================
*kt_dev_env_vim_015*	prog:tag:cscope

If your version of Vim wasn't compiled with '--enable-cscope', you will need to reconfigure and
recompile Vim with that flag. 

The Cscope database (cscope.out) is generated the first time it is invoked. Subsequent use will
update the database based on file changes.

Cscope version 15.6 (http://cscope.sourceforge.net/)

the '-R' makes Cscope parse all subdirectories, not just the current directory)
the '-b' flag (which tells Cscope to just build the database, then exit. ??? ????? ?? ????)
the -q flag create inverted index database for quick search for large projects.
-s dir        Look in dir for additional source  files.
-U            Check file time stamps.

cscope -b -R -s/vobs/DARWIN_PLATFORM
cscope -q -b -R -s/vobs/CMS_INFORMATION_SERVICES -s/vobs/DARWIN_PLATFORM -s/vobs/CMS_MEDIA_SERVICES 

FILES
cscope.files
	 Default files containing -I, -p, -q, and -T options and the list of source files (overridden by
	 the -i option). 

cscope.out
	 Symbol cross-reference file (overridden by the -f option), which is put in the home directory if
	 it cannot be created in the current directory. 

cscope.in.out 
cscope.po.out
	 Default files containing the inverted index used for quick symbol searching (-q option). If you
	 use the -f option to rename the cross-reference file (so it's not cscope.out), the names for
	 these inverted index files will be created by adding .in and .po to the name you supply with -f.
	 For example, if you indicated -f xyz, then these files would be named xyz.in and xyz.po.


(in vim)
:cscope add /home/NDS-UK/parkkt/cc/parkkt_BSKYB_GM_002/cscope.out
:cscope find search-type search-string 
:cs f s player_api_events.c

0 or s: Find this C symbol (get header and source for a symbol)
1 or g: Find this definition (get header only)
2 or d: Find functions called by this function
3 or c: Find functions calling this function
4 or t: Find this text string
6 or e: Find this egrep pattern
7 or f: Find this file
8 or i: Find files #including this file


==============================================================================
*kt_dev_env_vim_016*	prog:tag:ctag: vim-tag

{vim-tags}

The <tags> file has to be generated by a program like ctags, before the tag commands can be used.
some text enclosed in vertical bars (for example, |help|). This indicates a hyperlink. there is the
notation *help.txt*. This name between "*" characters is used by the help system to define a tag
(hyperlink destination).

{tag-push-pop}

With the CTRL-] command, the keyword on which the cursor is standing is used as the tag. If the
cursor is not on a keyword, the first keyword to the right of the cursor is used. CTRL-t(pop) Jump
to [count] older entry in the tag stack (default 1).

The most obvious way to use this is while browsing through the call graph of a program. Consider
the following call graph:

	main  --->  FuncA  --->  FuncC
	      --->  FuncB

You can get from main to FuncA by using CTRL-] on the call to FuncA. Then you can CTRL-] to get to
FuncC. If you now want to go back to main you can use CTRL-T twice. Then you can CTRL-] to FuncB.

If the stack was full (it can hold up to 20 entries), the oldest entry is deleted and the older
entries shift one position up (their index number is decremented by one). 


{vim-marks} {bookmark}

Vim saves marks in .viminfo and remembers the position from before this jump. This position is
called a mark.

<file-marks>

If you edit another file and place marks there, these are specific for that file. Thus each file
has its own set of marks, they are local to the file. They are lowercase marks.

There are also marks with an uppercase letter. These are global, they can be used from any file. To
see where a specific mark is, give an argument to the ":marks" command:

:marks M
:delm M

{marks-predefined}

m{mark-name}	" make a mark 26 marks(a-z) (line and column)
'{mark-name}	" apostrophe ('). jump to the line of a mark. linewise
`{mark-name}	" backtick (`). jump to the exact pos of a mark (line and column) 

'0					" the last file edited

`` 				" jumps back and forth, between two points in the current buffer.
'' 				" same as above but linewise

`.					" jump to position where last change occurred in current buffer 
'[ or ]			" [ means start of the last change and ] means end of the last change
					" jump to beginning/end of previously changed or yanked text


:jumps

Your current location in the jump list is indicated with '>', and the first number in each row is a
count that can be used to jump to that position. Something like this:

 jump line  col file/text
   4   102    0 somefile.txt
   3    93    0 -invalid-
   2    23    0 the current line 23 is shown here
   1    89   34 the current line 89 is shown here
>  0    22   40 Display the jump list for the current window with:
   1    39    0 the current line 39 is shown here
   2   995    0 anotherfile.txt
   3    53  102 the current line 53 is shown here

[count] C-o				" go to [count] <older> pos in jump list
[count] C-i or Tab	" go to [count] <newer> pos in jump list


{marks-and-edit}

d'a 	delete from current line to line of mark a
d`a 	delete from current cursor position to position of mark a
c'a 	change text from current line to line of mark a
y`a 	yank text to unnamed buffer from cursor to position of mark a


{vim-ctag}

Exuberant Ctags
http://ctags.sourceforge.net/

<to-get-ctag>

sudo apt-get install ctags

<to-set-default>

Either by setting the environment variable CTAGS to your custom options, or putting them into a
.ctags file in your home directory. 

http://blog.stwrt.ca/2012/10/31/vim-ctags:

For example, here's my ~/.ctags file:

# Basic options
--recurse=yes
--tag-relative=yes
--exclude=.git

# Regex for Clojure
--langdef=Clojure
--langmap=Clojure:.clj
--regex-clojure=/\([ \t]*create-ns[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/n,namespace/
--regex-clojure=/\([ \t]*def[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/d,definition/
--regex-clojure=/\([ \t]*defn-?[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/f,function/
--regex-clojure=/\([ \t]*defmacro[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/m,macro/
--regex-clojure=/\([ \t]*definline[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/i,inline/
--regex-clojure=/\([ \t]*defmulti[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/a,multimethod definition/
--regex-clojure=/\([ \t]*defmethod[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/b,multimethod instance/
--regex-clojure=/\([ \t]*defonce[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/c,definition (once)/
--regex-clojure=/\([ \t]*defstruct[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/s,struct/
--regex-clojure=/\([ \t]*intern[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/v,intern/
--regex-clojure=/\([ \t]*ns[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/n,namespace/

 [KT] Clojure is language and looks like this is how define new language for ctag.


<to-generate-a-tag-file>

ctags -R .

To set the place to create a tag:

ctags -R -f ./.git/tags .

For some users that need more info of the symbols

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .

{Q} does it differ?

from ctags faq:
7. Why can't I jump to class::member?

Because, by default, ctags only generates tags for the separate identifiers found in the source
files. If you specify the --extra=+q option, then ctags will also generate a second, class-qualified
tag for each class member (data and function/method) in the form class::member for C++, and in the
form class.method for Eiffel and Java. 

<to-have-external-files-in-tags>

No matter which one you use, the generated tags file only contains the symbols in the files in your
project source tree, but not any external file, such as standard header files 

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q /usr/include

Why must we generate a tags file containing all the symbols in the system header? If we only
generate the tags file only for the header files that are related to our projects, would it be
faster? That's the point of this idea. We could first search for the header files that are included
in our projects, and then we use ctags to generate a tags file for these files and our source files,
in this way, a much smaller tags file that containing all the symbols that maybe useful for the
project is generated. The solution is:

#!/bin/sh
# ./ctags_with_dep.sh file1.c file2.c ... to generate a tags file for these files.
gcc -M $* | sed -e 's/[\\ ]/\n/g' | \
sed -e '/^$/d' -e '/\.o:[ \t]*$/d' | \
ctags -L - --c++-kinds=+p --fields=+iaS --extra=+q 

./ctags_with_dep.sh file1.c file2.c file3.cpp ...

The idea is that -M list header files, sed process this and pipe it into ctags using -L - option.

What if you have other directories besides the standard /usr/include that containing the header
files you need? You could do a little modification on this script. For example, you have some header
files in ~/include, then you could pass -I ~/include to the gcc command. Just like below:

gcc -M -I ~/include $* | sed -e 's/[\\ ]/\n/g' | \
sed -e '/^$/d' -e '/\.o:[ \t]*$/d' | \
ctags -L - --c++-kinds=+p --fields=+iaS --extra=+q 

The other way is that create a tag file for system headers once and use when it is needed.

:se tags+=/usr/include/tags

{Q} does this add it to the loaded tag database?

Here se is se[t] in vim and ctags read a tag file from the current directory so can set one in a
different directory and add it the database.

{ctag-staic-and-dynamic}

http://andrewradev.com/2011/06/08/vim-and-ctags/

I'm going to call the tags generated for your code “dynamic”, since you're probably constantly
making changes there. So, what happens when the tags are no longer correct? While you could
regularly invoke ctags on the working directory, that's going to get annoying pretty fast.
Thankfully, the tool has an -a flag that makes it append to a tag file instead of overwriting it.
That way, you can update the tags very quickly every time a file changes. With vim's autocommands,
this could work like this:

autocmd BufWritePost *
      \ if filereadable('tags') |
      \   call system('ctags -a '.expand('%')) |
      \ endif

Unfortunately, there's an issue with this approach. Ctags will only add new tags, it won't remove
ones that are no longer present. If you delete a function, it will still appear in the tag file.

That's where the autotag.vim plugin comes in. Whenever you save a file, it deletes all of its
entries and invokes ctags in append mode. I've been using it for a long time and I haven't noticed
any overhead at all, even on Windows boxes. Unfortunately, your vim build needs to have python
support to use it. Even if it doesn't, though, no errors are raised, which is nice if you use the
same vimfiles across different vim builds like I do.

autotag: http://www.vim.org/scripts/script.php?script_id=1343

{TODO}

15. How should I set up tag files for a multi-level directory hierarchy? 

http://ctags.sourceforge.net/faq.html


{ctag-in-vim}

:ta pattern		// search. accept regex

For example, :tag /^asserts_* would find all tags that start with ‘asserts_'. By default vim will
jump to the first result,

If you have multiple definitions for a tag, the default <C-]> behavior is to drop you off at the
first one it finds. By default, vim gives more priority to tags in the current file, which is often
what you want. While doing that, you'll also be shown a message:

tag 1 of x or more

There are various ways to jump through the rest of the matches:

:tn				// next result of the search from :ta
:tp				// prev
:ts				// select. show a list to select
:tags				// history. To show the tags you've traversed since you opened vim
:ltag 			// will load the tags into the location list window. 
					// You can then view that window by executing :lopen.


==============================================================================
*kt_dev_env_vim_017*	prog:tag:gtag

{build-gtag}

As for 2013.10, 6.2.9 latest

http://www.gnu.org/software/global/whatsnew.html
https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools

configure: error: curses library is required but not found.
If you are not going to use gtags-cscope, please try ./configure --disable-gtagscscop

<to-get-curses>
http://www.gnu.org/software/ncurses/
wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.9.tar.gz
./configure
sudo make install

$./configure --prefix=/home/keitee.park/ --disable-gtagscscope
# bin will be created uder the prefix

$ make
$ make install
	

{script-to-build-flist}

#!/bin/bash
echo "building a gtag list..."
find -L $1 -name '*.[ch]' -o -name '*.[ch]pp' > flist.out 
gtags -f ./flist.out


note: don't use incremental updating.


{gtag-outputs}

$ ls G*
GPATH   GRTAGS  GTAGS
`GTAGS' definition database
`GRTAGS' reference database
`GPATH' path name database 


{gtag-cmdline}

use global in a cmd line

to list all definitions

$ global AEM_JAVA_Invite_RegisterStateListener
vobs/DARWIN_PLATFORM/DARWIN_AEM_JAVA/src/natAemInviteImpl.c

# the [-x] for more details listing. locate a exact func
$ global -x AEM_JAVA_Invite_RegisterStateListener
AEM_JAVA_Invite_RegisterStateListener  100
vobs/DARWIN_PLATFORM/DARWIN_AEM_JAVA/src/natAemInviteImpl.c void
AEM_JAVA_Invite_RegisterStateListener(NDSJNI_ENV *env)

# The [-r] option locates object references. The `-x' option shows the details. Note: see callers.
$ global -rx AEM_JAVA_Invite_*StateListener


# The [-s] command locates symbols which are not defined in `GTAGS'. 
$ global -sx AEM_JAVA_Invite_*StateListener 
(no results)


# The [-g] command locates the lines which have specified pattern. same as GREP
# It is similar to egrep(1) but is far more convenient for source code reading, because it allows you to search through a project, and only in the source files. Additionally, you can use various options:

-O    search only in the text files. 
-o    search in both the source files and text files. 
-l    search only under the current directory. 

The -e, -G and -i options are available too. The usage is the same as egrep(1). You can even change
the output format of global(1) to the grep style using the `--result=grep' option. Of course, these
options can be used even by other commands.

$ global -gx AEM_JAVA_Invite_*StateListener 


# The [-f] command print a list of objects in specified file.

# The [-c] If you forget object names, you can use the `-c' (complete) command.

$ global -c AEM_JAVA_Invite_
AEM_JAVA_Invite_CreateIcon
AEM_JAVA_Invite_Delete
AEM_JAVA_Invite_DeregisterStateListener
AEM_JAVA_Invite_GetLaunchKey
AEM_JAVA_Invite_GetState
AEM_JAVA_Invite_ReadPixelFormatFromCfgFile
AEM_JAVA_Invite_RegisterStateListener


{using-global-in-vim}

# Please copy vim scripts from where installed to your plug-in directory.

$ cp /usr/local/share/gtags/gtags.vim $HOME/.vim/plugin
$ cp /usr/local/share/gtags/gtags-cscope.vim $HOME/.vim/plugin
	

# To go to main symbol, you can say. 
:Gtags main
:Gtags -r func1
:Gtags ^put_                # locate objects start with 'put_'


Input completion is available. In the command line, press CTL-D after some typings and Vim will show
a list of tag names that start with the string. Press TAB and Vim will complete the tag name.

:Gtags fuTAB
:Gtags func1            # 'nc1' is appended by vim

{vim-quickfix}

Vim execute global(1), parse the output, list located objects in quickfix window and load the first
entry. You can go to any entry using quickfix command. For help, :h quickfix

[http://vimdoc.sourceforge.net/htmldoc/if_cscop.html#cscopequickfix]

# update a window whenever do search
:set cscopequickfix=s-,c-,d-,i-,t-,e-

# add a window whenever do search
set cscopequickfix=s+,c+,d+,i+,t+,e+

:cn    go to the next entry. 
:cp    go to the previous entry. 
:cc N  go to the N'th entry. 
:cl[ist]    list all entries. 

# Suggested map:
#    map <C-n> :cn<CR>
#    map <C-p> :cp<CR>


{gtags-cscope}

gtags-cscope (fake cscope). You can use gtags-cscope(1) instead of cscope(1). For example, you can
deceive Vim editor using the following commands:

:set csprg=gtags-cscope			[note] need cscope enalbed gtag binary
:cs add GTAGS

After this, you can use built-in 'cs find' commands in the Vim editor. Though the deceit is not
perfect ('cs find d' is not implemented), this method might be more convenient than `gtags.vim' in
the point that you can use the tag stack facility of Vim.

# from .vimrc

" for gtag
if has('cscope')
  set cscopetag cscopeverbose
  
  if has('quickfix')
    set cscopequickfix=s+,c+,d+,i+,t+,e+
  endif
  
  " for gtag
  set csprg=gtags-cscope

  cnoreabbrev csa cs add
  cnoreabbrev csf cs find
  cnoreabbrev csk cs kill
  cnoreabbrev csr cs reset
  cnoreabbrev css cs show
  cnoreabbrev csh cs help
  cnoreabbrev csc call setqflist([])
  
  map <C-n> :cn<CR>
  map <C-p> :cp<CR>
endif

0 or s: Find this C symbol (get header and source for a symbol)
1 or g: Find this definition (get header only)
2 or d: Find functions called by this function
3 or c: Find functions calling this function
4 or t: Find this text string
6 or e: Find this egrep pattern
7 or f: Find this file
8 or i: Find files #including this file


==============================================================================
*kt_dev_env_vim_018*	prog:build and error

To build in vi, use makefile and simple makefile is:

# simple makefile from gmake

FILE = gen-list-linked.cpp
CC = g++ -std=c++0x

main : main.o
	echo 'bulid out'
	$(CC) -o out main.o

main.o : $(FILE)
	echo 'build $(FILE)'
	$(CC) -o main.o -c $(FILE)

clean :
	rm out main.o

To run make
:make

To get the error list. See {vim-quickfix}
:clist

To change the command when use :make
:set makeprg=gmake

To see the current value
:set makeprg


{makeprg-on-filetype}

http://tuxion.com/2011/09/30/vim-makeprg.html

This started out as a small post on how to preview markdown documents in Vim using makeprg, but
somehow I got carried away. More on the markdown thing in a bit.

When you type :make in Vim, the value of makeprg is executed in a subprocess. Traditionally this
value is set to make, but you can set this to anything you like. You can see the current value by
typing :set makeprg. When you combine this with Vim's support for filetype plugins, there's a decent
amount of value that I think is sometimes overlooked. So this article is an attempt to explain some
of the things you can do with makeprg and filetype detection.  

Filetype Plugins

A filetype plugin is like a global plugin, except that it sets options and defines mappings for the
current buffer only.

Using a filetype plugin, we can set makeprg to something useful depending on the type of a file it
happens to be. Adding your own filetype plugin is easy, just create a file of the form:
<filetype>.vim inside the ~/.vim/after/ftplugin directory. The after subdirectory is technically
optional, but I prefer it as it keeps things isolated from other installed plugins. The after
subdirectory is sourced last as Vim initializes itself, so putting your options there ensures they
aren't clobbered by other plugins.

For a given Vim buffer, you can see the filetype by typing :set ft. Some people put this information
in their statusline, which can be helpful if you're writing Vim plugins or just want to make sure
things are being detected correctly.

For example, if I want to define custom settings for the C filetype, I would create
~/.vim/after/ftplugin/c.vim and put my settings there. Any time a file of type C is loaded, my
settings are applied. We can use this mechanism to set a custom makeprg for certain filetypes.

Customizing makeprg for Markdown

I take all of my notes in Markdown, which is nearly plain text with a tiny amount of markup. This
allows me to quickly convert my personal notes into decent looking html documentation. It seems to
be a regular occurrence that my notes become the initial documentation for the project or subproject
that I'm working on. Many wiki's support Markdown, so it ends up saving me work by just keeping
everything in that format.

Even though Markdown's syntax is very lean and simple, I still end up forgetting some of it from
time to time. I find it useful to generate and view the HTML output for the buffer that I'm working
on periodically to make sure things look right. This is really easy by setting a custom makeprg for
the markdown filetype.  

The Hammer Plugin

Robert Gleeson wrote a Vim plugin called Hammer that basically does exactly what I explain here and
quite a bit more. It might be perfect for you, but for me it's much more than I need. I've had
problems when the version of Ruby on the system is not the same as what Vim was compiled with. Check
it out though, you might love it.  

A Simpler Approach

All I want is to type :make and have Vim generate an HTML version in /tmp that I can point my
browser to. So I put the following in ~/.vim/after/ftplugin/markdown.vim:

set makeprg=redcarpet\ %\ >/tmp/%<.html

Let's take a quick look at what's going on here:

The above setting is applied only when editing a markdown buffer. Personally, I use redcarpet to
parse markdown, but there are many others that you can substitute here. 

Spaces in option strings must be escaped so Vim knows when to stop parsing.
    % expands to the name of the file currently being edited.
    %< expands to the name of the file without the trailing extension. This allows us to change the
    %name of the file and add the html extension.

So the above command calls redcarpet on the filename and redirects the output to
/tmp/<filename>.html. That's it, super simple. Once this completes, I point my browser to file:/tmp
and load the file I'm interested in.

This same approach can be taken with ReStructured Text by putting the following in
~/.vim/after/ftplugin/rst.vim:

set makeprg=rst2html.py\ %\ /tmp/%<.html`
 
 [KT] bash alias do not work so make a script for that.

Extra Credit

For C, we could set makeprg to call gcc directly instead of make if a Makefile is not found in the
current working directory. I find this very helpful when creating a scratch source file to test
certain behaviour or a quick theory. Here's what the contents of ~/.vim/after/ftplugin/c.vim might
look like:

if !filereadable(expand("%:p:h")."/Makefile")
    setlocal makeprg=gcc\ -Wall\ -Wextra\ -o\ %<\ %
endif

Now when you load a file of type C and there is no Makefile, typing :make will compile your source
file into an executable of the same name (minus the extension). I use this all the time. You could
do the same thing for C++ by changing the filename to cpp.vim and changing gcc to g++.


==============================================================================
*kt_dev_env_vim_019*	prog:completion

{plugins}

"
" neocomplete

https://github.com/Shougo/neocomplete.vim

Requited by unite-tag. May need to build vim to enalbe lua features and creates caches background
using vimproc.

g:neocomplete#ctags_arguments
It is the dictionary of the character string to set a value to give as an argument of the commands
when buffer and include use a ctags command. The dictionary's key is filetype. If the key is "_", it
will be used for default.

Because it is complicated, refer to neocomplete#init#_variables() in autoload/neocomplete/init.vim
for the initial value.

" Initialize ctags arguments. "{{{
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments',
     \ '_', '')
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments', 'vim',
     \ '--extra=fq --fields=afmiKlnsStz ' .
     \ "--regex-vim='/function!? ([a-z#:_0-9A-Z]+)/\\1/function/'")
 call neocomplete#util#set_default_dictionary(
       \ 'g:neocomplete#ctags_arguments', 'c',
       \ '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' .
       \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
       \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments', 'cpp',
     \ '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '.
     \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
     \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
"}}}


{snippet}

What is the snippet? From snipmate:

Here's a simple example. Once installed, put this in a ~/.vim/snippets/javascript.snippet file:

snippet log
    console.log(${1});

Now when you're editing a .js file, typing log<TAB> will expand into console.log();, and put the
cursor in between the brackets. You're still in insert mode, so you just carry on typing your log
statement.


{ultisnips}

https://github.com/SirVer/ultisnips

.vim/bundle/ultisnips/UltiSnips/cpp.snippets


{when-do-not-use-other-plugins}

Vim's own implementation.

Vim documentation: insert

7. Insert mode completion				*ins-completion*

In Insert and Replace mode, there are several commands to complete part of a keyword or line that
has been typed.  This is useful if you are using complicated keywords (e.g., function names with
capitals and underscores).

These commands are not available when the |+insert_expand| feature was disabled at compile time.


Completion can be done for:

1. Whole lines						|i_CTRL-X_CTRL-L| [KT] works
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							   |i_CTRL-X_CTRL-]| [KT] works
7. file names						|i_CTRL-X_CTRL-F| [KT] works
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N|


 [KT] useful to repeat the same line which typed before. 

Completing whole lines					*compl-whole-line*
							               *i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the same characters as those in the
current line before the cursor.  Indent is ignored.  The matching line is inserted in front of the
cursor.  The 'complete' option is used to decide which buffers are searched for a match.  Both
loaded and unloaded buffers are used.

CTRL-L	or CTRL-P		Search backwards for next matching line.  This line replaces the previous
matching line.

CTRL-N		Search forward for next matching line.  This line replaces the previous matching line.

CTRL-X CTRL-L	After expanding a line you can additionally get the line next to it by typing CTRL-X
CTRL-L again, unless a double CTRL-X is used.  Only works for loaded buffers.


 [KT] works regardless of using completion plugin. uses tag file.

Completing tags						*compl-tag*
							            *i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same characters as before the
cursor.  The matching tag is inserted in front of the cursor.  Alphabetic characters and characters
in 'iskeyword' are used to decide which characters are included in the tag name (same as for a
keyword).  See also |CTRL-]|.  The 'showfulltag' option can be used to add context from around the
tag definition.  

CTRL-]	or CTRL-N		Search forwards for next matching tag.  This tag replaces the previous
matching tag.

CTRL-P		Search backward for previous matching tag.  This tag replaces the previous matching tag.

Can use this mapping:
inoremap <c-x><c-]> <c-]>


Completing file names					*compl-filename*
							               *i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the same characters as before the
cursor.  The matching file name is inserted in front of the cursor.  Alphabetic characters and
characters in 'isfname' are used to decide which characters are included in the file name.  Note:
the 'path' option is not used here (yet).

CTRL-F	or CTRL-N		Search forwards for next matching file name.  This file name replaces the
previous matching file name.

CTRL-P		Search backward for previous matching file name.  This file name replaces the previous
matching file name.

{omni-completion}

omni completion is based on a ctags file. If you want a “full” C language completion, you need to
first create a tags file scanning /usr/include, /usr/local/include and so on. In my laptop (AMD 64
900 MHz), executing this:

ctags -R -f ~/.vim/systags /usr/include /usr/local/include

takes almost 6 minutes and the generated file is as big as 791M. In addition if you install a new
development library, you will need to scan the .h files to add them to you tags file. Personally I
do not use omni completion as I do not think it is mature enough yet.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*

The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.

From vim7.4

./autoload/ccomplete.vim   " this shows how to access tag data
./autoload/xmlcomplete.vim
./autoload/csscomplete.vim
./autoload/adacomplete.vim
./autoload/clojurecomplete.vim
./autoload/javascriptcomplete.vim
./autoload/pythoncomplete.vim
./autoload/syntaxcomplete.vim
./autoload/sqlcomplete.vim
./autoload/phpcomplete.vim
./autoload/python3complete.vim
./autoload/htmlcomplete.vim
./autoload/rubycomplete.vim

Accessing tag data in vimscript
http://andrewradev.com/2011/06/08/vim-and-ctags/


==============================================================================
*kt_dev_env_vim_020*	prog:edit: match paren and others {%-match}

{add-more-to-match}

% cmd

Used alone, this jumps between open/close pairs based on the value of the matchpairs option.

But angle brackets - <> - aren't included by default. They may be set based on the filetype. The
HTML filetype plugin sets it, so if you're opening HTML files you'll be able to use % to jump
between matching angle brackets. But not for e.g. C++/Java.

To add angle brackets if they aren't jumped when using %, use:

:set matchpairs+=<:>

Now using % on angle brackets should jump to the matching bracket. See :help 'matchpairs' and :help
various-motions for more details. note: matchfit pulgin install.

{example-in-coding}

From http://www.viemu.com/a-why-vi-vim.html

to change from:

if(!entry.used && equivalent(entry.key(), qk.key) && (curcontext & entry.context))

to:

bool equiv = equivalent(entry.key(), qk.key);
if(!entry.used && equiv && (curcontext & entry.context))

move to the start of equivalent
c% equiv ESC
O bool equiv = p ;


The '%' motion moves from a parenthesis (or similar grouping character) to its matching one - but if
you're not positioned at one of these special characters, it will scan character by character
<to-the-right>, until the first one is found, and then moving to the character matching that one.
So, in the above situation, it will move to the right closing parenthesis!

Knowing about the 'c' command, which deletes the extents of the next motion (also copying it to the
clipboard) and enters insert mode, we can type just 'c%' ("change match") from the above case and we
get the following:


==============================================================================
*kt_dev_env_vim_021*	edit: prog: shift and paste block

The example shows the block improperly indented. How to fix?

if( q.is_valid() )
{
	while( g.it != end )
	{
		char_t ch = *g.it;
		if( !ch.isspace() )
	{
			return q.calc();
	}
	}
}

Place a cursor return statement and use >a} or >aB

if( q.is_valid() )
{
	while( g.it != end )
	{
		char_t ch = *g.it;
		if( !ch.isspace() )
		{
				return q.calc();
		}
	}
}


Or you can paste with auto-reindent (just ']p' in vim)
["x]]p	" Like "p", but adjust the indent to the current line.


{shift-operator}

>{motion}		" shift {motion} lines one 'shiftwidth' rightwards.
>>					" shift [count] lines one 'shiftwidth' rightwards.
[num]>>			" shift n lines
[num]<<
v{lines}[num]>	" shift selcted line at num times


{indention}

:set autoindent
:set smartindent
:set cindent

Another command to use for indentation is = (equal). It “filters” the text with an external program
(if specified) or with the internal C indentation routine. To specify an external filter, you have
to set the equalprg variable:

:set equalprog=indent

Note that the definition for filter is “program that accepts text at stantard input, changes it in
some way, and sends it to the standard output”. Not all programs match this criteria. Regardless of
the rutine used to filter the text, = indents the line where the cursor is placed or the selected
text if any.

Tip: G=gg indents the whole file. This is very useful when copy-pasting from another window, remote
session, etc, messes the indentation up. In the picture below, the left window shows a code copied
from the Internet and the right one, the same text after doing G=gg

You can always indent text blocks freely if the automatic indentation rules do not fit your taste.
In order to do this, use the <> commands. Applied twice on a text object they indent that text to
the left or to the right.


==============================================================================
*kt_dev_env_vim_022*	prog:edit: adding and substracting

Ctrl-a and Ctrl-x increments/decrements the number the cursor is placed on. This is especially good
because Vim understands different bases.

What is the hexadecimal representation of 1564 (decimal)? Just do the following:
0x0

And now 1564 Ctrl-a ESC (this tells Vim to do Ctrl-a 1564 times). This is what you get:
0x61c

Adding and subtracting ~

							*CTRL-A*
CTRL-A			Add [count] to the number or alphabetic character at or after the cursor.  {not in
Vi}

							*CTRL-X*
CTRL-X			Subtract [count] from the number or alphabetic character at or after the cursor.
{not in Vi}

The CTRL-A and CTRL-X commands work for (signed) decimal numbers, unsigned octal and hexadecimal
numbers and alphabetic characters.  This depends on the 'nrformats' option.


==============================================================================
*kt_dev_env_vim_023*	prog:edit: man help in vim 

We can place the cursor at the “printf” function call and press K. If we want to see the manual page
on the printf C function (Section 3 “System library calls”) we need to type 3K. Once you are done
with the manual, type ENTER to return to Vim.


K			Run a program to lookup the keyword under the cursor.  The name of the program is given
with the 'keywordprg' (kp) option (default is "man").  The keyword is formed of letters, numbers and
the characters in 'iskeyword'.  The keyword under or right of the cursor is used.  
         

The same can be done with the command >

 :!{program} {keyword}

There is an example of a program to use in the tools directory of Vim.  It is called 'ref' and does
a simple spelling check.

Special cases:
- If 'keywordprg' is empty, the ":help" command is used.  It's a good idea to include more
  characters in 'iskeyword' then, to be able to find more help.

- When 'keywordprg' is equal to "man", a count before "K" is inserted after the "man" command and
  before the keyword.  For example, using "2K" while the cursor is on "mkdir", results in: > !man 2
  mkdir


==============================================================================
*kt_dev_env_vim_024*	prog:undo

See :help new-undo-branches on a Vim 7 editor.  Vim supports undo branches. This means Vim can keep
track of the different changes you made to your text (or your code). In its simplest form, you can
use two commands, :earlier and :later to bring your code to a previous state. E.g:

:earlier 20s
:later 5m
:earlier 2h

The commands above bring the code to the state it was 20 seconds earlier, 5 minutes later and 2
hours later.  This is useful when making changes to code under no source control systems. Undo
branches is a new feature present in Vim since version 7. I recommend you to play with it and learn
how to get the maximum out of it.

The |:undolist| command can be used to get an idea of which undo branches
exist.  The |:undo| command now takes an argument to directly jump to a
specific position in this list.  The |changenr()| function can be used to
obtain the change number.


==============================================================================
*kt_dev_env_vim_100*	edit: motion {text-object} {move-screen}

{text-object}

You can find a long list of text objects from help text-objects. Only be used while in visual mode
or after an operator. operator-text-object

When the cursor is in the middle of a word and you want to delete that word. This is the third way
in vim: operator-motion, visual, and operator-text-object.

Instead of operating on the text between the cursor position before and after a movement command,
the text object is used as a whole.

daw		# delete <a> word
das		# delete <a> sentence

cis 

Consists of the "c" (change) operator and the "is" text object. This stands for "inner sentence".
There is also the "as" (a sentence) object.  The difference is that "as" includes the white space
after the sentence and "is" doesn't. If you would delete a sentence, you want to delete the white
space at the same time, thus use "das". 

ab, a(, a)	# a block
ib, i(, i)	# inner block
a<, a>		# a <> block
i<, i>		# inner <> block

Examples:

if( !entry.used && equiv && ( curcontext & entry.contexts))
            ^ cursor
				vib
if( !entry.used && equiv && ( curcontext & entry.contexts))
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ selected

<img src="whi-vi-img/why-vi-1.gif" alt=""/>
                 ^ cursor
					  vi>
<img src="whi-vi-img/why-vi-1.gif" alt=""/>
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ selected

Can be used with other operators such as cib, dib.


{operator-motion} help operator

There is a pattern here: operator-motion. You first type an operator command. For example, "d" is
the delete operator. Then you type a motion command like "4l" or "w". This way you can operate on
any text you can move over.

dw
d4w
d2e
d$
d2l

The motion commands can be used after an operator command, to have the command operate on the text
that was moved over. That is the text between the cursor position before and after the motion.
Operators are generally used to delete or change text.  The following operators are available:

c		" change
d		" delete
y		" yank into register (does not change the text)

~		" swap case (only if 'tildeop' is set)
g~		" swap case
gu		" make lowercase
gU		" make uppercase. gUw works on word section


{double-operator}

To make an operator work on lines, double it. The delete operator is "d", thus to delete a line you
use "dd". Similarly, "gugu" makes a whole line lowercase. This can be shortened to "guu".  "gUgU" is
shortened to "gUU" and "g~g~" to "g~~".


{change}

cw		# c2w. it's exception as the space after the word isn't included. see *04.2*
cc		# as dd, changes a whole line
c$		# as d$, 


shortcuts. Some operator-motion commands are used so often that they have been given a single letter
command:

	x  stands for  dl  (delete character under the cursor)
	X  stands for  dh  (delete character left of the cursor)
	D  stands for  d$  (delete to end of the line)
	C  stands for  c$  (change to end of the line)
	s  stands for  cl  (change one character)
	S  stands for  cc  (change a whole line)

	I	Start Insert mode after moving the cursor to the first non-blank in the line.
	A	Start Insert mode after moving the cursor to the end of the line.


{delete}

dG		# delete until the end of file
dgg


{replace-mode}

R		# enter replace-mode. can switch to insert-mode by <insert> key.
<BS>	# in replace-mode, when use <BS>, works likes undo.


{word-WORD}

For lower-case cmds, a word ends at a non-word character, such as a ".", "-" or ")".  To change what
Vim considers to be a word, see the 'iskeyword' option. For upper-case cmds, It is also possible to
move by 'whitespace' separated WORDs.

b			#
e, E     # end of word
ge, gE   # prev end of word


The 'iskeyword' option specifies which characters can appear in a word:

:set iskeyword
 	  iskeyword=@,48-57,_,192-255 

The "@" stands for all alphabetic letters.  "48-57" stands for ASCII characters 48 to 57, which are
the numbers 0 to 9.  "192-255" are the printable latin characters.  Sometimes you will want to
include a dash in keywords, so that commands like "w" consider "upper-case" to be one word.  You can
do it like this:

:set iskeyword+=-
:set iskeyword
 	  iskeyword=@,48-57,_,192-255,- 

To remove:

:set iskeyword-=_

{move-screen}

C-d	" down half screen
C-u	" up half screen (backward)

C-f	# down full screen
C-b	# up full screen (backward)

zz		# make the current line center
zb		# make the current line bottom
zt		# make the current line top

H		# move a cursor to the highest
M		# move a cursor to the middle
L		# move a cursor to the lowest


{line-move}

^			# to the first non-blank character of the line
0
[num]$	# to the end of a line

G			# to the last line of the file
gg			# to the top of the file
[num]G


{char-move}

[num]f[char]	# 'find' char to the right the cursor in the line.
[num]F[char]	# 'find' char to the left the cursor in the line.

[num]t[char]	# the same f cmd but before char
[num]T[char]	# 

[num];			# <Repeat> latest f, t, F or T [count] times.
,					# <Repeat> latest f, t, F or T in <opposite> direction [count] times.


{file-info}
ctrl-g


==============================================================================
*kt_dev_env_vim_101*	edit: fold

'foldmethod' option (abbreviated to 'fdm') is local to each window.

manual - folds must be defined by entering commands (such as zf)
indent - groups of lines with the same indent form a fold
syntax - folds are defined by syntax highlighting
expr   - folds are defined by a user-defined expression 

see :help fold-methods to learn the details of different fold methods.
see :help folding to learn the keyboard commands for manipulate folds.
see :help folds for help on the entire topic of folding.

:mkview				" to save folds
:loadview			" to restore folds

{manual-mode}

Use z? command in a normal mode

zf'a		   " fold lile from the current line to mark

v{motion}zf " fold using visual mode
V{motion}zf
va}zf		   " fold {} block containing the cursor. visual, {} selecion and zf

zf{motion}
zfa}		   " create a fold from the line with the first brace through the last. 
zfa{		   " This also works with other block enclosures

zf2j        " fold three lines

" 'fo' works backwards as well when the cursor is on line 101. '.' means current line.  :., 20 fo			
:20, 101 fo{ld}	

zd			" delete a fold. it's different from 'zo' as cannot do 'zc' after that.
zo			"	opens a fold at the cursor.
zc			" close

If we unfold the top level fold, the inner one is shown collapsed. The states of nested folds are
independent. zd and zD are used to deleted folds (the latter recursively), and zE deletes all the
folds in the current window. As a general rule, the capitalized version of all the commands (zC, zO)
applies the action recursively

" syntax mode
foldmethod=syntax

" move folds
zj																				# moves the cursor to the next fold.
zk																				# moves the cursor to the previous fold.
[z																				# move to start of open fold.
]z																				# move to end of open fold.


==============================================================================
*kt_dev_env_vim_300*	script

Vim documentation: usr_41

:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
 
Note:
The ":" characters are not really needed here.  You only need to use them when you type a command.
In a Vim script file they can be left out.  We will use them here anyway to make clear these are
colon commands and make them stand out from Normal mode commands.

Note:
You can try out the examples by yanking the lines from the text here and executing them with :@"


{vim-variable}

These variables are global. To see a list of currently defined variables use this command:

	:let

You can use global variables everywhere. This also means that when the variable "count" is used in
one script file, it might also be used in another file. This leads to confusion at least, and real
problems at worst.

To avoid this, you can use a variable local to a script file by prepending "s:". For example, one
script contains this code:


{vim-list}

List creation *E696* *E697*

A List is created with a comma separated list of items in square brackets.

Examples:
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

An item can be any expression. Using a List for an item creates a List of Lists: :let nestlist =
[[11, 12], [21, 22], [31, 32]]

An extra comma after the last item is ignored.

List manipulation:					*list-functions*

	count()			count number of times a value appears in a List

count({comp}, {expr} [, {ic} [, {start}]])			*count()*

		Return the number of times an item with value {expr} appears in |List| or |Dictionary| {comp}.
		If {start} is given then start with the item with this index.  {start} can only be used with a
		|List|.  When {ic} is given and it's non-zero then case is ignored.

let s:settings.plugin_groups = []
call add(s:settings.plugin_groups, 'core')
call add(s:settings.plugin_groups, 'web')
call add(s:settings.plugin_groups, 'javascript')

if count(s:settings.plugin_groups, 'core') "{{{
...
endif

{vim-function}

To redefine a function that already exists, use the ! for the ":function" command:

	:function!  Min(num1, num2, num3)


==============================================================================
*kt_dev_env_019*	history

:help command-line-window.

Command line window
q: 	# open with a command history from normal mode
q/ 	# open with a search history from normal mode (to search forward)
q? 	# open with a search history from normal mode (to search backward)

you can close it with Ctrl+W, C


==============================================================================
*kt_dev_env_vim_021*	select and copy {registers} {clipboard}

{selection}

v			# visual mode for chars
V			# visual mode for lines
ctrl-q	# visual mode for block. ctrl-v under linux.

{block-selection} {comment-multiple-lines}

To insert chars before/after block-selection and also to comment multiple lines

before:
name
comment
phone
email

Move to n of name, ctrl-q, jjj, I or $, enter text, and ESC

after:
vendor_name
vendor_comment
vendor_phone
vendor_email


{select-whole-file}
ggVG


edit ~

a		# to place the cursor 'a'fter the current position
s		# substitute the current character. will delete current character but 'r' will replace.
S		# substitute the current line. will delete current line.
r		# replace the current character. don't need <ESC> rreplace continuous characters

ct_	# when aa_bb_cc, to select 'aa'



{undo-redo}

u			# undo
ctrl-r	# redo
	
:view		# read only
:set ro

C-G		# fine info

:edit		# to reload the current file
:edit!	# to force the reload of the current file (you will lose your modifications)

{exit}
ZZ
:wqall	# save all and quit
:qall!


{paste-yank}

p		# paste after current cursor and line. [count]
P		# paste before current cursor position
xp		# swap two chars

:pu :put
:[line]pu[t] [x]	Put the text [from register x] after [line] (default current
line).  This always works |linewise|, thus this command can be used to put a
yanked block as new lines.


yw		# yank is operator. yank(copy) from a current to the end of word [count]
y2w
yy		# yank a line
2yy	# yank 2 lines 
y$

byw	# move to the beginning of a word

{vim-registers}

"a4yy		# copy the next 4 lines into the register named 'a'
"ap		# paste from 'a'
"bd
"bp

"fyas		# yank a sentence to f reg
"l3Y		# yank three lines to l reg
vjww"by	# yank visual selection to b reg
"wdaw		# to delete-a-word and write it in the w register:

to see list of registers
:reg[isters]	


{vim-clipboard}

"*		# is the canonical register for the clipboard on Windows. :help gui-clipboard

If use following in vimrc, which means that I don't have to explicitly type "* all the time when I
want to transfer text between Vim and the Windows clipboard. All deletes and yanks automatically go
to the clipboard.  If I want to copy or paste from another Windows application, then {all I need to
do is type p or P, not "*p or "*P}. 

:set clipboard=unnamed

Note: in vim 7.3.74 and higher you can do following to alias unnamed register to the + register,
which is the X Window clipboard. 

set clipboard=unnamedplus 

Under ubuntu, when use yank such as yw then it goes to + register only and when use selection and
yank it goes to + and * register. This * register can be copied into a terminal when use shift-ins
under the ubuntu but not for + register.

{copy-to-from-clipboard} {from-linux-to-win}

V<ctrl-c>	# under win. 
<ctrl-v>

"*y			# copy text into system clipboard.
"*p			# paste text from. Same as Ctrl-P

Under linux, yy don not copy a line to the clipboard so make sure it is in the clipboard to copy and
paste between linux and windows.

Works from guest linux to host windows. Not sure that is supported by virtualbox.

ctrl-ins    # to copy to clipboard
shift-ins   # to pasete into

{copy-to-from-vim-cmd-line}

You can type ctrl-r to insert a <register> when in insert mode, or when typing in the command or
search line. When you press Ctrl-R you will see "(quote) to prompt you to finish the command by
entering a register. For example, press Ctrl-R then a to insert the contents of the a register, or
Ctrl-R then "(this is a register name) to insert the contents of the unnamed register.

You can press v then move the cursor to visually select some text (say the text is "hello world").
If you press y the selected text is yanked (copied) into the <unnamed register(")> You can now type
:%s/ then <C-r>" (Ctrl-R quote), which would show the following in the command line: 


CTRL-r CTRL-w 	# to paste the word under the cursor into the command line
CTRL-r CTRL-a 	# to paste the WORD under the cursor into the command line
ctrl-r *		# to paste the content(from windows) into the command line.
ctrl-r +    # for xwin so can use any register.
i CTRL-R *		# paste clipboard with maintaining formatting. see i_CTRL-R


==============================================================================
*kt_dev_env_vim_021*	show whitespace {list-cmd}

{list-cmd}

Every tab is displayed as ^I.  And a $ is displayed at the end of each line, 

:set list
:set nolist
:set list!		# toggle


==============================================================================
*kt_dev_env_vim_022* 	format and wrap

{tapstop}

To insert space characters whenever the tab key is pressed 

:set tabstop=4
:set shiftwidth=4
:set expandtab

'wrap' and 'linebreak' control the display of text so the long line is a single line even if it is
diaplayed on multiple lines. To get vim to insert newlines in the file as you type, set textwidth to
the desired width (e.g. 80). Note: In help file, tw=xxx don't seem to work for me.


{textwidth}

:set tw=xxx

when use 'textwidth' it works well when typing in VIM but when copy text from external source then
it doesn't work; that's don't fit into textwidth setting of the current file. 

two solution to this:

gq}                     # to manucl format
gpap                    # <a> paragraph
gqG                     # formats the text starting from the current and to the end of the file. 
                        # It will automatically join consecutive lines when possible.

Note: 
A blank line, which contains white space, does NOT separate paragraphs. This is hard to
notice!

set formatoptions+=a    # vim to do it automatically. help auto-format

(this makes no use of following)
i CTRL-R *		# paste clipboard with maintaining formatting. see i_CTRL-R





==============================================================================
*kt_dev_env_vim_024*	modes

normal mode, edit mode, command mode.

==============================================================================
*kt_dev_env_vim_025*	helps

{help}

:help {subject}
:help CTRL-A		# for normal mode cmds
:help i_CTRL-H		# mode prefix. for insert mode cmds

shift-k (K) cmd. study.

:h {patt} then press Ctrl-D to list all topics that contain "patt".
:h {patt} then press Tab to scroll through the topics that start with "patt". 

Press CTRL-] to follow the link (jump to the quickref topic).
After browsing the quickref topic, press CTRL-T to go back to the previous topic.

Sometimes you want to know what a particular control key means to Vim. For example, to see all help
topics containing "ctrl-r", type :h ctrl-r then press Ctrl-D. The following examples show the help
for pressing various keys in different contexts. 




==============================================================================
*kt_dev_env_vim_024*	files and buffers

{args}

You can redefine the list of files without the need to exit Vim and start it again.

:args five.c six.c seven.h

To switch between two files in the same window.

ctrl-^		# switch between the previous and the next in the list


{file-cmds}
:saveas move.c


==============================================================================
*kt_dev_env_vim_024*	windows and tab

:close			# prevents you from accidentally exiting Vim when you close the last window.
:only 			# this closes all windows, except for the current one. 
:qall
:wall


ctrl-w ctrl-w	#
ctrl-w r       # rotate windows
ctrl-w - _     # max windows
ctrl-w =       # make windows equal in size


{vim-tab}

:tabnew										
:tabedit filename
:tabonly           # as with :only
gt                 # tabnext
gT                 # tabprevious
:tabmove 0


==============================================================================
*kt_dev_env_vim_024*	run external program

The "!!" command filters the current line through a filter.  In Unix the "date" command prints the
current time and date.  "!!date<Enter>" replaces the current line with the output of "date".  This
is useful to add a timestamp to a file.

:0read !date -u
:0read !date /t	# for windows


This inserts the current time and date in UTC format at the top of the file.  (Well, if you have a
date command that accepts the "-u" argument.)  Note the difference with using "!!date": that
replaced a line, while ":read !date" will insert a line.


==============================================================================
*kt_dev_env_vim_024*	 91 and 92 chars {to-search-key-code}

The content on your source web page was overzealously reformatted. The text was undoubtedly supposed
to use (straight) single quotes (ASCII 39/0x27, U+0027) instead of curly single quotes (U+2018 and
U+2019, which are 0x91 and 0x92 in CP1252 (also known as MS-ANSI and WINDOWS-1252; a common 8-bit
encoding on Windows)).

Vim is showing you the hex codes because they are not valid in whatever encoding Vim is using
(probably UTF-8). If you are editing text that has already been saved in a file, then you can reload
the file as CP1252 with 

:e ++enc=cp1252 

 [KT] for korean windows 949
:e ++enc=cp949 	

this should make the curly quotes visible. But there is no real reason to reload it as CP1252, just
delete the 0x91 and 0x92 characters and replace them with single quotes.

To change the hex 91/92 characters in you need to do:
:%s/[\x91\x92]/'/g


==============================================================================
*kt_dev_env_vim_024*	 ^M char

When open some file made by win apps such as putty, vim shows ^M at the end of line. Often people
explains that this happens when see windows file under linux because there is no CR(0xOD) in linux
and vim display it as ^M. So to remove this :%s/^V^M//g 

note: to enter ^M, press crtl-m.

This is not the case when seeing file putty made. Although putty log file has CR and LF, vim under
windows shows ^M. When checked filetype, vims uses fileformat=unix and that is why it displays ^M.
When copy this text to other vim windows in dos filetype, still show ^M because it has CR+CR+LR in
the end.

See vim help fileformat. Where is the fileformat when vim is loading file? 

http://vim.wikia.com/wiki/File_format


{when-use-diff}

If diff two files which are nearly the same, diff shows it's totally different. But used comp tool
and showed the expected result. why? 

The reason was the one is unix and the other was dos format. In vim, when tried to show tabs, do not
show difference and can see fileformat using :set ff.

Also diff -w shows the correct. also cat -v filename shows ^M char. Under ubunto, can get tool like
unix2dos:

sudo apt-get install tofrodos

which proves fromdos and todos


==============================================================================
*kt_dev_env_vim_032*	 change working dirs

To print the current working directory
:pwd

To change to the directory of the current file for all windows in vim
:cd %:p:h

To change to the directory of the current file
:cd %:h

To change to the directory of the current file [only] for the current window
:lcd %:p:h

In these commands, % gives the name of the current file, %:p gives its full path, and %:p:h gives
its directory (the "head" of the full path), that is, full path not including the filename. 

Sometimes it is helpful if your working directory is always the same as the file you are editing. To
achieve this, put the following in your vimrc: 

:set autochdir

==============================================================================
*kt_dev_env_vim_033*	mapping

http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29

{key-mapping}
____________
introduction

Key mapping refers to creating a shortcut for repeating a sequence of keys or commands. You can map
keys to execute frequently used key sequences or to invoke an Ex command or to invoke a Vim function
or to invoke external commands. 

The general syntax of a map command is: 

{cmd} {attr} {lhs} {rhs}

where
{cmd}  is one of ':map', ':map!', ':nmap', ':vmap', ':imap',
       ':cmap', ':smap', ':xmap', ':omap', ':lmap', etc.

{attr} is optional and one or more of the following: <buffer>, <silent>,
       <expr> <script>, <unique> and <special>.
       More than one attribute can be specified to a map.

{lhs}  left hand side, is a sequence of one or more keys that are being mapped.

{rhs}  right hand side, is the sequence of keys that the {lhs} keys are mapped to.

Examples:

map <F2> :echo 'Current time is ' . strftime('%c')<CR>
nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR>

Three steps to define maps:

The first step in creating a map is to decide the sequence of keys that needs to be mapped. When you
invoke a map, Vim will execute the sequence of keys [as-though] you entered it from the keyboard. You
can do this by manually entering the key sequence and verifying that they perform the desired
operation.

The second step is to decide the editing mode (insert mode, visual mode, command-line mode, normal
mode, etc.) in which the map should work. Instead of creating a map that works in all the modes, it
is better to define the map that works only in selected modes.

The third step is to find an unused key sequence that can be used to invoke the map. You can invoke
a map using either a single key or a sequence of keys. :help map-which-keys 

1.7 WHAT KEYS TO MAP					*map-which-keys*

If you are going to map something, you will need to choose which key(s) to use for the {lhs}. You
will have to avoid keys that are used for Vim commands, otherwise you would not be able to use those
commands anymore. Here are a few suggestions:

- Function keys <F2>, <F3>, etc..  Also the shifted function keys <S-F1>,
  <S-F2>, etc.  Note that <F1> is already used for the help command.
- Meta-keys (with the ALT key pressed).  Depending on your keyboard accented
  characters may be used as well. |:map-alt-keys|
- Use the '_' or ',' character and then any other character.  The "_" and ","
  commands do exist in Vim (see |_| and |,|), but you probably never use them.
- Use a key that is a synonym for another command.  For example: CTRL-P and
  CTRL-N.  Use an extra character to allow more mappings.
- The key defined by <Leader> and one or more other keys.  This is especially
  useful in scripts. |mapleader|

See the file "index" for keys that are not used and thus can be mapped without losing any builtin
function. You can also use ":help {key}^D" to find out if a key is used for some command.  ({key}
is the specific key you want to find out about, ^D is CTRL-D).

___________
slient maps

http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_2%29

When a map is invoked, the sequence of keys executed is displayed on the screen. If an Ex command is
invoked by the map, then you can see the Ex command at the Vim status line. To silently execute a
map, use the <silent> attribute for the map.

__________
map leader

If the key maps provided by all the Vim plugins start with a same key, then it is easier for a user
to distinguish between his own key maps and the ones provided by plugins. To facilitate this, Vim
provides a special keyword that can be used in a map command.

If the {lhs} key sequence of a map command starts with the string "<Leader>", then Vim replaces it
with the key set in the 'mapleader' variable.

The default setting for the 'mapleader' variable is backslash ('\'). Note that 'mapleader' is a Vim
variable and not a Vim option. The value of this variable can be changed using the 'let' command.
For example, to set it to '_' (underscore), you can use the following command in your vimrc file:

let mapleader = "_"

Vim replaces <Leader> with the 'mapleader' value only when defining the map and not when the map is
invoked. This means that after several map commands are defined if the 'mapleader' variable is
changed, it will not affect the previously defined maps. 

________________
listing key maps {vim-modes}

The ':map' command creates a key map that works in normal, visual, select and operator pending
modes. The ':map!' command creates a key map that works in insert and command-line mode. 

To display the mode specific maps, prefix the ':map' command with the letter representing the mode. 

:nmap - Display normal mode maps
:imap - Display insert mode maps
:vmap - Display visual and select mode maps
:smap - Display select mode maps
:xmap - Display visual mode maps
:cmap - Display command-line mode maps
:omap - Display operator pending mode maps

The following characters may be displayed before the {rhs} of the map: 

*  The {rhs} of the map is not re-mappable. Defined using the
	':noremap' or ':nnoremap' or ':inoremap', etc. commands.

To display all the key maps that start with a particular key sequence, enter the key sequence in the
above commands. For example, the following command displays all the normal mode maps that start with
'g'.

:nmap g

Typically the output of the above commands will span several pages. You can use the following set of
commands to redirect the output to the vim_maps.txt file:

:redir! > vim_maps.txt
:map
:map!
:redir END

_________________
removing a keymap

To permanently remove a map, you first need to locate the place where it is defined by using the
':verbose map {lhs}' command (replace {lhs} with the mapped key sequence). 

Another approach is to use the ':unmap' and ':unmap!' commands to remove the map

:unmap <F8>
:unmap! <F8>

:nnoremap [unite] <nop>

Note that after a key is unmapped using the ':unmap' command, it can be mapped again later. Also you
cannot unmap a key used by one of the Vim internal commands. Instead you have to map it to <Nop> to
disable it's functionality.

If you are trying to disable a key map defined by a plugin, make sure the unmap command is executed
after the key map is defined by the plugin. To do this in .vimrc, use autocmd:

autocmd VimEnter * unmap! <F8>

Filetype plugins can be a little tricky, because they can redefine mappings any time you open a file
of a certain type. You can just use a different autocmd event for this, e.g.:

autocmd FileType python unmap! <F8>

The mode-specific unmap commands are listed below:

nunmap - Unmap a normal mode map
vunmap - Unmap a visual and select mode map
xunmap - Unmap a visual mode map
sunmap - Unmap a select mode map
iunmap - Unmap an insert and replace mode map
cunmap - Unmap a command-line mode map
ounmap - Unmap an operator pending mode map

____________________
storing the key maps

If you want to restore the key maps across Vim instances, you need to save the map definition
command in a file.

One place to store the map commands is the $HOME/.vimrc or $HOME/_vimrc or $VIM/_vimrc file. If you
have <filetype-specific-key-maps>, then you can store them in the filetype specific plugin files.
The key maps defined by Vim plugins are stored in the plugin or script file itself.

When adding the map commands to a file, there is no need to prefix the commands with the ':' character. 

__________________
mode-specific maps

Commands                        Mode
--------                        ----
nmap, nnoremap, nunmap          Normal mode
imap, inoremap, iunmap          Insert and Replace mode
vmap, vnoremap, vunmap          Visual and Select mode
xmap, xnoremap, xunmap          Visual mode
smap, snoremap, sunmap          Select mode
cmap, cnoremap, cunmap          Command-line mode
omap, onoremap, ounmap          Operator pending mode

Note that the language specific mappings defined using the ':lmap' and ':lnoremap' commands are not
discussed here. For more information about this refer to the Vim help. 

:nnoremap <F5> :grep <C-R><C-W> *<CR> [KT] works and useful
maps the <F5> key to search for the keyword under the cursor in the current directory using the grep
command: 

From a normal mode map, you can get the keyword under the cursor using the expand('<cword>')
function or using the <C-R><C-W> command. For example, the following two map commands provide the
same functionality


:nnoremap ,b :ls<CR>:buffer<Space> [KT] works and useful
maps ',b' to display the buffer list and invoke the ':buffer' command. You can enter the desired
buffer number and hit <Enter> to edit the buffer. 

If you invoke an Ex command from a map, you have to add a <CR> or <Enter> or <Return> at the end of
the Ex command to execute the command. Otherwise the command will not be executed. ls command in the
above example.

 [KT] this example: ls<cr> shows buffer list and buffer<space> waits input from user. so select
 buffer when give bufnum<cr>.


:map! <F3> a<C-R>=strftime('%c')<CR><Esc>
maps the <F3> key to insert the current date and time in the current buffer. 

____________________
mapping mouse events {exe-and-expand-command}

:nnoremap <2-LeftMouse> :exe "tag ". expand("<cword>")<CR>
The above map uses the expand() function to get the keyword under the cursor and then invokes the
"tag" command with the current keyword. The "execute" command is used to concatenate the tag command
and the output of the expand() function

_______________
useful examples

you need to change a word such as "amount" into "{amount}":
:map <F5> i{<Esc>ea}<Esc>

Note:
When entering this command, you must enter <F5> by typing four characters.  Similarly, <Esc> is not
entered by pressing the <Esc> key, but by typing five characters.  Watch out for this difference
when reading the manual!

<F5>	The F5 key.  This is the trigger key that causes the command to be executed as the key is pressed.
i{<Esc>	Insert the { character.  The <Esc> key ends Insert mode.
e		Move to the end of the word.
a}<Esc>	Append the } to the word.


{trigger-key}

the trigger can be any string.  One key that can be used with mappings is the backslash.  Since you
probably want to define more than one mapping, add another character.  You could map "\p" to add
parentheses around a word, and "\c" to add curly braces, for example:

:map \p i(<Esc>ea)<Esc>
:map \c i{<Esc>ea}<Esc>

You need to type the \ and the p quickly after another, so that Vim knows they belong together.


{complicated-mapping}

This mapping yanks the visually selected text and searches for it in C files.  This is a complicated
mapping: 
vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>


==============================================================================
*kt_dev_env_vim_033*	tool: ag bin and ag vim plugin

https://github.com/ggreer/the_silver_searcher

To get a source of ag bin:

$ git clone https://github.com/ggreer/the_silver_searcher

{ag-ignore}

By default, ag will ignore files matched by patterns in .gitignore, .hgignore, or .agignore. These
files can be anywhere in the directories being searched. Ag also ignores files matched by the
svn:ignore property in subversion repositories. Finally, ag looks in $HOME/.agignore for ignore
patterns. Binary files are ignored by default as well.

If you want to ignore .gitignore, .hgignore, and svn:ignore but still take .agignore into account,
use -U.  Use the -t option to search all text files, -a to search all files, and -u to search all
including hidden files.



# ============================================================================
#{

==============================================================================
*kt_dev_env_git_000*		reference

{help}
https://www.kernel.org/pub/software/scm/git/docs/git.html

{book}

"Git from the bottom up":
http://ftp.newartisans.com/pub/git.from.bottom.up.pdf

http://git-scm.com/book

{gitk}

note: cannot show tree so use qgit instead.

you may want to take a look at a Tcl/Tk program called gitk that is distributed with Git. Gitk is
basically a visual git log tool, and it accepts nearly all the filtering options that git log does. 


git-gui

{qgit}

sudo apt-get install qgit

Had highlight on a current branch. show whole tree when select option to start.

{gitg}


==============================================================================
*kt_dev_env_git_001*		basic

The entire Pro Git book, written by Scott Chacon and published by Apress, is available here.

http://git-scm.com/book

Git has:

{difference-to-other-vcs} {snapshot}
These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the information they keep as a
set of files and the changes made to each file over time, as illustrated in Figure 1-4. 

-------------- checkins over time --------------->
version 1   version 2   version 3   version 4    version 5
file A      delta 1                 delta 2
file B                              delta 1      delta 2

Instead, Git thinks of its data more like a set of snapshots of a <mini-filesystem>. It is called
<snapshot>.


{nearly-every-operation-is-local}
This also means that there is very little you can't do if you're offline or off VPN. In Perforce,
for example, you can't do much when you aren't connected to the server; and in Subversion and CVS,
you can edit files, but you can't commit changes to your database (because your database is
offline). This may not seem like a huge deal, but you may be surprised what a big difference it
can make.

{integrity}
Everything in Git is check-summed. The mechanism that Git uses for this checksumming is called a
SHA-1 hash. 

{three-states} {committed-modified-staged}
three main states that your files can reside in: committed, modified, and staged. Committed means
that the data is safely stored in your local database. Modified means that you have changed the file
but have not committed it to your database yet. Staged means that you have marked a modified file in
its current version to go into your next commit snapshot.

{tracked-untracked}
Remember that each file in your working directory can be in one of two states: tracked or untracked.
Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged.
Untracked files are everything else 

{terminology}

	working directory(snapshot)             staging area          git direcotry(repository)
untracked  unmodified  modified
					<-------------------------------------------------------------
									 clone(checkout) the project

     <--------->
	  add/remove
               ------------>
					edit
									----------------------->
									 stage files(checkin)
																	  ----------------------->
																		commit
																		(make files unmodified)


The Git directory, [repository] is where Git stores the metadata and object database for your
project. This is the most important part of Git, and it is what is copied when you clone a
repository from another computer.

The [working-directory] is a single checkout of one version of the project. These files are pulled
out of the compressed database in the Git directory and placed on disk for you to use or modify.
This is snapshot or blob.

The [staging-area], or [index] is a simple file, generally contained in your Git directory, that
stores information about what will go into your next commit. It's sometimes referred to as the
index, but it's becoming standard to refer to it as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working directory.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot
permanently to your Git directory.

If a particular version of a file is in the git directory, it's considered committed. If it's
modified but has been added to the staging area, it is staged. And if it was changed since it was
checked out but has not been staged, it is modified. 


{install}

Recommend to install from source. For ubuntu, check if all necessry are installed.

sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev

get source from http://git-scm.com/download or http://code.google.com/p/git-core/

$ tar -zxf git-1.7.2.2.tar.gz
$ cd git-1.7.2.2
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install

or for binary install

apt-get install git


{config}
The first thing you should do when you install Git is to set your user name and e-mail address. This
is important because every Git commit uses this information, and it's immutably baked into the
commits you pass around:

git config --global user.name "John Doe"
git config --global user.email johndoe@example.com

git config --list

For color output
git config --global color.ui auto

{help}

git help ???
man git-???


==============================================================================
*kt_dev_env_git_002*		init, clone, and diff

{init-repo-in-existing-dirs}

Create an empty repository.

$ git init
Initialized empty Git repository in /home/kit/.git/

if it's a directory, the command adds all the files in that directory recursively.

$ git add *.c or $ git add *
$ git add README
$ git commit -m 'initial project version'

{clone-from-existing-repo}

The command is clone and not checkout. This is an important distinction - Git receives a copy of
nearly all data that the server has. Every version of every file for the history of the project is
pulled down when you run git clone. In fact, if your server disk gets corrupted, you can use any of
the clones on any client to set the server back to the state it was in when it was cloned

$ git clone git://github.com/schacon/grit.git

That creates a directory named grit, initializes a .git directory inside it, pulls down all the data
for that repository, and checks out a working copy of the latest version. 

If you want to clone the repository into a directory named something other than grit, you can
specify that as the next command-line option:

$ git clone git://github.com/schacon/grit.git mygrit


{clone-from-ssh} {github}

Why is Git always asking for my password?

If git prompts you for a username and password instead of your SSH key passphrase, you're using the
HTTPS clone URL for your repository.  

Why not use HTTPS?

HTTPS has some advantages, it's easier to set up than SSH and usually works through strict firewalls
and proxies. You can even set git to store your password so you don't have to enter it every time.
If you'd like to set that up, make sure you've upgraded to the latest version of git and check out
this guide.  

Switch to SSH via the command line

To change the URL via the command line:

Open the repository on github.com URL copy buttonClick the copy button next to the SSH clone URL
Open a command line and run git remote set-url origin with the new URL

git remote set-url origin git@github.com:user/repo.git


{clone-from-local-server}

Git has a number of different transfer protocols you can use. The previous example uses the git://
protocol, but you may also see http(s):// or user@server:/path.git, which uses the SSH transfer
protocol. Chapter 4 will introduce all of the available options the server can set up to access
your Git repository and the pros and cons of each.

For example, clone it from local rockford server:

kit@kit-vb:~$ git clone keitee.park@rockford:/home/keitee.park/mheg-proto my


{status}

The command tells you which branch you're on. For now, that is always master, which is the default; 

$ git status
# On branch master
nothing to commit (working directory clean)


{git-ignore}

Looks that git use patch from where run init command and show untracked files or dirs from there. It
is annoying when run status command. To list out what you don not want to see, can set this in this
file:

$ cat .gitignore 
cpp/
Downloads/
.*


The rules for the patterns you can put in the .gitignore file are as follows:

Blank lines or lines starting with # are ignored.
Standard glob patterns work.
You can end patterns with a forward slash (/) to specify a directory.
You can negate a pattern by starting it with an exclamation point (!).

# ignore all files in the build/ directory
build/


{when-modified-to-stage}

$ git status
# On branch master // [note] here see branch you are on
# Changes not staged for commit: ~
#   (use "git add <file>..." to update what will be committed)
#
#   modified:   benchmarks.rb
#

means that a file that is tracked has been modified in the working directory but not yet staged. To
stage it, you run the git add command (it's a multipurpose command - you use it to begin tracking
new files, to stage files, and to do other things like marking merge-conflicted files as resolved). 

When run add command to stage, it move to as

# On branch master
# Changes to be committed: # SEE 'TO BE' ~
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   MHEGApp.cpp

Modified the same and run status command again. Then

# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   work/Src/MHEGApp.cpp
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   work/Src/MHEGApp.cpp
#


{git-diff}

To see what you've changed but not yet staged, type git diff with no other arguments. show ONLY
changes that are still unstaged.

git diff


To see what you've staged that will go into your next commit, you can use git diff --cached. (In Git
versions 1.6.1 and later, you can also use git diff --staged, which may be easier to remember.) 

git diff --cached


git diff --name-only commit commit
git diff commit commit


{git-commit}

$ git commit
[master 312e37a] Stroy 182: fix benchmarks for speed
 1 file changed, 1 insertion(+)

--verbose
$ git commit -v

$ git commit -m "Stroy 182: fix benchmarks for speed"

the -a option to the git commit command makes Git automatically stage every file that is already
tracked before doing the commit, letting you skip the git add part:

$ git commit -a -m 'added new benchmarks'


==============================================================================
*kt_dev_env_git_003*		log

{git-log}

with no arguments, git log lists the commits made in that repository in reverse chronological order. 

$git log

helpful options is -p, which shows the diff introduced in each commit. You can also use -2, which
limits the output to only the last two entries:

$ git log -p -2
$ git log --pretty=oneline
git log --pretty=format:"%h - %an, %ar : %s" --graph


the time-limiting options such as --since and --until are very useful. 

$ git log --since=2.weeks

For graphs [note] shows the same as qgit
git log --graph --oneline --all


{git-show}

To see files changed in a commit

$ git show --name-only {commit}


==============================================================================
*kt_dev_env_git_004*		undo

From 2.4 Git Basics - Undoing Things

{change-last-commit}

If you've made no changes since your last commit, forget to add some files, or you mess up your
commit message. 

To change message:

$ git commit --amend

To stage missing file:

$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend


{unstaging-a-staged-file}

For example, let's say you've changed two files and want to commit them as two separate changes, but
you accidentally type git add * and stage them both. How can you unstage one of the two? The git
status command reminds you:

$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.txt
#       modified:   benchmarks.rb
#

it says "use git reset HEAD <file>... to unstage". So, let's use that advice to unstage the
benchmarks.rb file:

$ git reset HEAD benchmarks.rb
benchmarks.rb: locally modified

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   benchmarks.rb
#

The command is a bit strange, but it works. The benchmarks.rb file is modified but once again
unstaged.


{revert-back-and-discard-changes}

$ git checkout -- <filename>


{revert-merge}

When merge conflict happens, git modifies the file so will have modified status. How can undo this?
If you get conflicts, you can immediately get back to the state you were at before with:

kit@kit-vb:~/git-work$ git merge undo
Auto-merging readme
CONFLICT (content): Merge conflict in readme
Automatic merge failed; fix conflicts and then commit the result.
kit@kit-vb:~/git-work$ git status
# On branch master
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      readme
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.readme.swp
no changes added to commit (use "git add" and/or "git commit -a")

kit@kit-vb:~/git-work$ more readme 
<<<<<<< HEAD
1: changed first and changed by master.
=======
1: changed first and changed by undo and by undo
>>>>>>> undo
2: changed second.
3: added topic first.
4: added topic second.

kit@kit-vb:~/git-work$ git reset --merge

kit@kit-vb:~/git-work$ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.readme.swp
nothing added to commit but untracked files present (use "git add" to track)
kit@kit-vb:~/git-work$ 


==============================================================================
*kt_dev_env_git_005*		remote servers, push and pull.

{to-list-remotes}

$ git remote -v
bakkdoor  git://github.com/bakkdoor/grit.git
origin    git@github.com:mojombo/grit.git         # it means SSH url


{make-shortname-for-remotes}

$ git remote add [shortname] [url]:
$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin  git://github.com/schacon/ticgit.git
pb  git://github.com/paulboone/ticgit.git


{fetch}

To get data from your remote projects, pulls down all the data from that remote that you do not have
yet. After that, you can merge in or inspect.

$ git fetch [remote-name]
$ git fetch pb
From git://github.com/paulboone/ticgit
 * [new branch]      master     -> pb/master
 * [new branch]      ticgit     -> pb/ticgit

Paul's master branch is accessible locally as pb/master


{what-is-a-branch}

We will sometimes represent Git history using diagrams like the one below. Commits are shown as "o",
and the links between them with lines drawn with - / and \. Time goes left to right:

         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B

If we need to talk about a particular commit, the character "o" may be replaced with another letter
or number.

When we need to be precise, we will use the word <branch> to mean a line of development, and "branch
head" (or just <head>) to mean a reference to the most recent commit on a branch. In the example
above, the branch head named "A" is a pointer to one particular commit, but we refer to the line of
three commits leading up to that point as all being part of "branch A".

The head means the current branch or what is currently checked out.

However, when no confusion will result, we often just use the term "branch" both for branches and
for branch heads.

A branch is nothing more than a named reference to a commit.


{branch-head-and-detached-head}

Head is used by your repository to define what is currently checked out:

o If you checkout a branch, head symbolically refers to that branch, indicating that the branch name
should be updated a?er the next commit operation.

o If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a
detached head and occurs, for example, if you check out a tag name.


{origin-repo}

If you clone a repository, the command 'automatically' adds that remote repository under the name
'origin'. So, 

$ git fetch origin 

fetches any new work that has been pushed to that server since you cloned (or last fetched from) it. 

note:
It's important to note that the fetch command pulls the data to your local repository - it doesn't
automatically merge it with any of your work or modify what you're currently working on. You have to
merge it manually into your work when you're ready.

note:
origin is not a branch but a name of local repo for a remote repo.
 

{fetch-vs-pull}

$ git pull

If you have a branch set up to track a remote branch, you can use the git pull command to
automatically fetch and then merge a remote branch into your current branch. Othewise, should speficy:

$ git pull origin master

This may be an easier or more comfortable workflow for you; and by default, the git clone command
automatically sets up your <local-master-branch> to track the <remote-master-branch> on the server
you cloned from (assuming the remote has a 'master' branch). Running git pull generally fetches data
from the server you originally cloned from and automatically tries to merge it into the code
you're currently working on.

note:
So fetch is pulling data but do not merge but pull do merge automatically.


{push} {upstream} {reject}

To push it upstream.

$ git push [remote-name] [branch-name]
$ git push origin master


This command works only if you cloned from a server to which you have <write-access> and if nobody has
pushed in the meantime. If you and someone else clone at the same time and they push upstream and
then you push upstream, your push will rightly be <rejected>. You'll have to pull down their work
first and incorporate it into yours before you'll be allowed to push. 


{inspect-a-remote}

$ git remote show origin
* remote origin
  URL: git://github.com/schacon/ticgit.git
  Remote branch merged with 'git pull' while on branch master
    master
  Tracked remote branches
    master
    ticgit

The below shows the origin settings after setting the origin to track remote master by doing. See
{tracking-branch}:

$ git checkout -b origin remote/mater

kit@kit-vb:~/keitee/kb$ git remote show origin
* remote origin
  Fetch URL: https://github.com/keitee/kb.git
  Push  URL: https://github.com/keitee/kb.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    origin merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
kit@kit-vb:~/keitee/kb$ 


{remove-remote}

$ git remote rm paul
$ git remote
origin


==============================================================================
*kt_dev_env_git_006*		tagging

To tag specific points in history as being important and to mark release points (v1.0, and so on)

$ git tag                           # list
$ git tag -l 'v1.4.2.*'             # search a tag with pattern


{annotated-tag}

Git uses two main types of tags: lightweight and annotated. It's generally recommended that you
create annotated tags so you can have all this information;  

$ git tag -a v1.4 -m 'my version 1.4'

The -m specifies a tagging message

To see a tag

$ git show v1.4


{to-tag-a-specific-commit}

To tag that commit, you specify the commit checksum (or part of it) at the end of the command:

$ git tag -a v1.2 -m 'version 1.2' 9fceb02


==============================================================================
*kt_dev_env_git_007*		tips

{auto-completion}

For commands and options.

$ git co<tab><tab>

{alias}

$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status

This means that, for example, instead of typing git commit, you just need to type git ci.


$ git config --global alias.last 'log -1 HEAD'
$ git last

To run an external command,

$ git config --global alias.visual '!gitk'


==============================================================================
*kt_dev_env_git_008*		branching

>
 Why is it so special? The way Git branches is incredibly lightweight, making branching operations
 nearly instantaneous and switching back and forth between branches generally just as fast. 
<
As you may remember from Chapter 1, Git doesn't store data as a series of changesets or deltas, but
instead as a series of snapshots. {difference-to-other-vcs} *kt_dev_env_git_008*

Example history:

--------------------- time ----------------------------------------->

commit A      <------   commit B                  <-------   commit C
 (ptr to snapshot)       (ptr to the prev commit)
                         (ptr to snapshot)

 (snapshot A)            (snapshot B)                         (snapshot C)


{default-branch}

A branch in Git is simply a lightweight movable <pointer> to one of these commits. The default branch
name in Git is <master>. As you initially make commits, you're given a master branch that points to
the last commit you made. Every time you commit, it moves forward automatically.

                                                  <master>
commit a      <------   commit b       <-------   commit c


{create-new-branch}

$ git branch testing

																  <head>
                                                  <master>
commit a      <------   commit b       <-------   commit c
                                                  <testing>

How does Git know what branch you're currently on? It keeps a special pointer called [HEAD]. Note
that this is a lot different than the concept of HEAD in other VCSs you may be used to. Cannot have
the same branch name in the same repository.


{switch-branch} {checkout-command}

To switch to an existing branch, you run the git checkout command

$ git checkout testing

To make a branch and to swith to it in a single shot.

$ git checkout -b testing

                                                  <master>
commit a      <------   commit b       <-------   commit c
                                                  <testing>
																  <head>

Make a commit and see what happens:

                                                  <master>
commit a      <------   commit b       <-------   commit c    <------  commit d
                                                                       <testing>
																                       <head>
Switch back to master:

$ git checkout master

																  <head>
                                                  <master>
commit a      <------   commit b       <-------   commit c    <------  commit d
                                                                       <testing>

Two things done by doing this, essentially rewinds the your work:
o move the head back to point to master
o revert your working dirs back to the snapshot that master points to

note: switching head, branch, commit means changing working dirs.


Make a commit and see what happens:

																                       <head>
                                                                       <master>
commit a      <------   commit b       <-------   commit c    <------  commit e
                                                              <------  commit d
                                                                       <testing>

Now your project history has diverged. two lines of development 


{files-when-switch-branches}

When switching between branches, untracked and staged(uncommited) file remains the same between
branches. For tracked files, it is switched to the content for that commit and if that file exist
only for a certain branch, this will disapper in switching to.

When switching beteen branches without committing, git emits errors:

kit@kit-vb:~/git-work$ git checkout undo 
error: Your local changes to the following files would be overwritten by checkout:
	readme
Please, commit your changes or stash them before you can switch branches.
Aborting

Why? because the file will be overwitten and lost what has been done.


{branch-is-cheap}

Because a branch in Git is in actuality a simple file that contains the 40 character SHA-1 checksum
of the commit it points to, branches are cheap to create and destroy. Creating a new branch is as
quick and simple as writing 41 bytes to a file (40 characters and a newline).


{brancn-vs-tag}

A tag represents a version of a particular branch at a moment in time. A branch represents a
separate thread of development that may run concurrently with other development efforts on the same
code base. Changes to a branch may eventually be merged back into another branch to unify them.

note: KT. looks the same but tag is fixed one and branch is moving one?

Tag is very much like a branch that doesn't change - it's just a pointer to a specific commit. 


{merge-with-no-diverge} <upstrem>

           <master>      <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
					          <iss53> branch

Swith to master and merge hotfix to master:

$ git checkout master
$ git merge hotfix              # support auto-completion for branch name
Updating f42c576..3a0874c
Fast forward
 README |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)


The phrase "Fast forward" in that merge. Because the commit pointed to by the branch(hotfix) you
merged in was directly <upstream> of the commit(master) you're on, Git moves the pointer forward.
<no-diverge>. [note] KT. This means that simply apply changes up to hotfix and move master to where
hotfix was. Just overwrite with what hotfix has. No conflict.

So tree becomes:
                         <master>
                         <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
					          <iss53> branch

To switch back to the work you were doing before you were interrupted. However, first you'll delete
the hotfix branch, because you no longer need it - the master branch points at the same place. You
can delete it with the -d option to git branch:

$ git branch -d hotfix
Deleted branch hotfix (3a0874c).


{merge-with-diverge}

Switch back to your work-in-progress branch on issue #53 and continue working on it 

$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'

                         <master>
c0 <- c1 <- c2        <- c4
                      <- c3 <- c5
					                <iss53> branch
										 <head>

To merge in iss53 into master

$ git checkout master
$ git merge iss53
Merge made by recursive.
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

This looks a bit different than the hotfix merge because your development history has diverged from
some older point. <diverge> Because the commit on the branch you're on(master) isn't a
<direct-ancestor> of the branch you're merging in(iss53). Git do simple <three-way-merge> 

            # common     # snapshot to merge into
				# ancestor   <head>
                         <master>
c0 <- c1 <- c2        <- c4
                      <- c3 <- c5
					                <iss53> branch
                               # snapshot to merge in

Git creates a new snapshot that results from this three-way merge and automatically creates a
<new-commit> that points to it. This is referred to as a <merge-commit> and is special in that it
has more than one parent.

Git determines the best common ancestor to use for its merge base; this is different than CVS or
Subversion (before version 1.5), where the developer doing the merge has to figure out the best
merge base for themselves. 

                                              <master>
c0 <- c1 <- c2        <- c4                   <- c6
                      <- c3 <- c5
					                <iss53> branch <- c6

c6 has two ancestor.


{merge-conflict}

If you changed >the same part of the same file< differently in the two branches you're merging
together, Git won't be able to merge them cleanly. If your fix for issue #53 modified the same part
of a file as the hotfix, you'll get a merge conflict that looks something like this:

$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

Git has paused the process while you resolve the conflict. If you want to see which files are
unmerged at any point after a merge conflict, you can run git status:

[master*]$ git status
index.html: needs merge
# On branch master
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#   unmerged:   index.html
#


The output file from conflict contains: [note] git changes the file like this.

<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
  please contact us at support@github.com
</div>
>>>>>>> iss53:index.html


HEAD (your master branch, because that was what you had checked out when you ran your merge command)
is the top part of that block (everything above the =======), while the version in your iss53 branch
looks like everything in the bottom part.

In order to resolve the conflict, you have to either choose one side or the other or merge the
contents yourself. After you've resolved each of these sections in each conflicted file, run git add
on each file to mark it as resolved. Staging the file marks it as resolved in Git.  


{mergetool}

To use GUI tool after conflict happens.

$ git mergetool
$ git config --global merge.tool meld


For following conflict when merging topic to master:

kit@kit-vb:~/git-work$ more readme
1: changed first and added by topic. [note] git doesn't show changes made here
2: added second.
<<<<<<< HEAD
3: continue to add third.
4: continue to add forth.
=======
3: added topic first.
4: added topic second.
>>>>>>> topic

Meld shows:

Local: HEAD               Base:                Remote:
1: added first.           1: added first.      1: changed first and added by topic.
2: added second.          2: added second.     2: added second.
3: continue to add third.                      3: added topic first.
4: continue to add forth.                      4: added topic second.

So better to use meld?

Once resolved conflicts, run git status again to verify that all conflicts have been resolved. Run
git commit to finalize the merge commit. Can modify that message with details about how you resolved
the merge 


{check-before-merge}

Can do {revert-merge} when conflict happens and want to go back. Also, can check patch output before
merging. You are on undo topic barnch and want to see changes against master then:

kit@kit-vb:~/git-work$ git format-patch master --stdout
From 223da602d2e71c6d6708b52c80cd672c159b442d Mon Sep 17 00:00:00 2001
From: Kit Park <keitee.park@samsung.com>
Date: Tue, 22 Oct 2013 14:59:37 +0100
Subject: [PATCH 1/2] changed by undo

---
 readme | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/readme b/readme
index 3ba462e..a80c866 100644
--- a/readme
+++ b/readme
@@ -1,4 +1,4 @@
-1: changed first and added one by merge-test
+1: changed first and changed by undo
 2: changed second.
 3: added topic first.
 4: added topic second.
-- 
1.8.3.4


From fa9d05492f1f0357f5803edbf6232b73797b6d8f Mon Sep 17 00:00:00 2001
From: Kit Park <keitee.park@samsung.com>
Date: Tue, 22 Oct 2013 15:04:21 +0100
Subject: [PATCH 2/2] changed by undo undo

---
 readme | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/readme b/readme
index a80c866..67d833a 100644
--- a/readme
+++ b/readme
@@ -1,4 +1,4 @@
-1: changed first and changed by undo
+1: changed first and changed by undo and by undo
 2: changed second.
 3: added topic first.
 4: added topic second.
-- 
1.8.3.4

Stackoverflow also said that can apply this patch on master but cannot work for me.

git checkout master
git apply crazy.patch --check
[all good! cleanup...]
rm crazy.patch


{branch-management}

To list branches and * indicates that you currently have checked out.

$ git branch
  iss53
* master
  testing

To see the last commit on each branch

$ git branch -v --color
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes


To figure out what state your branches are in is to filter this list to branches that you have or
have not yet merged <into> the branch you're currently on.  --merged and --no-merged options

$ git branch --merged
  iss53
* master

Branches on this list without the * in front of them are generally fine to delete because you've
already incorporated their work into another branch


$ git branch --no-merged
  testing

This shows your other branch. Because it contains work that isn't merged in yet, trying to delete it
with git branch -d will fail:

$ git branch -d testing
error: The branch 'testing' is not an ancestor of your current HEAD.
If you are sure you want to delete it, run 'git branch -D testing'.


{branch-workflow}

Because Git uses a simple three-way merge, merging from one branch into another multiple times over
a long period is generally easy to do. 

master          - possibly only code that has been or will be released. 
develop or next - parellel branch. they work from or use to test stability.
topic           - short-lived. to make sure they pass all the tests and don't introduce bugs.

Easier to think about them as work silos, where sets of commits graduate to a more stable silo when
they're fully tested 


high stable: -> time
 master c1 --------------------------------------------------------->

 develop     c2 c3 c4 c5 ------------------------------------------->

 topic                    c6 c7 ------------------------------------>

low stable

Merging from topic -> develop -> master.

You can keep doing this for several levels of stability. For large projects.


{{topic-branch}}

Topic branches, however, are useful in projects of any size. A topic branch is a short-lived branch
that you create and use for a single particular feature or related work. This is something you've
likely never done with a VCS before because it's generally too expensive to create and merge
branches. 

This technique allows you to context-switch quickly and completely.

note: KT. not mean to use topic. can use any branch but think that use maniny develop or topic
level. Hence named after topic?


note:
It's important to remember when you're doing all this that these branches are completely local. When
you're branching and merging, everything is being done only in your Git repository. NO server
communication is happening.


==============================================================================
*kt_dev_env_git_009*		remote branch

{remote-master-and-local-master}

Remote branches act as bookmarks to remind you where the branches on your remote repositories were
the last time you connected to them.

After clone, your local git looks:

         <origin/master> # remote branch
c1 c2 c3 c4
         <msater>        # local branch

In the meantime, someone else pushes to git.ourcompany.com and updates its master branch, then your
histories move forward differently. Also, as long as you stay out of contact with your origin
server, your origin/master pointer doesn't move.

Remote:
c1 c2 c3 c4 c5 c6 c7 c8
                     <msater>

Local:
         <origin/master> # remote branch # it is still c4
c1 c2 c3 c4 c9 c10 c11 
                   <msater>        # local branch


To synchronize your work, you run a git fetch origin command. {fetch-pull} *kt_dev_env_git_005* This
command looks up which server origin is and fetches any data from it that you don't yet have, and
updates your local database, moving your origin/master pointer to its new, more up-to-date position.

Local:
                     <origin/master> # remote branch
			   c5 c6 c7 c8
c1 c2 c3 c4 c8 c9 c10 c11
                      <msater>        # local branch


{push}

Your local branches aren't automatically synchronized to the remotes you write to - you have to
explicitly push the branches you want to share. That way, you can use private branches for work you
don't want to share, and push up only the topic branches you want to collaborate on.

$ git push origin serverfix

If you didn't want it to be called serverfix on the remote, you could instead run to push your local
serverfix branch to the awesomebranch branch on the remote project.

$ git push origin serverfix:awesomebranch 


The next time one of your collaborators fetches from the server, they will get a reference to where
the server's version of serverfix is under the remote branch origin/serverfix:

$ git fetch origin
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (14/14), done.
remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15/15), done.
From git@github.com:schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix


To note that when you do a fetch that brings down new remote branches, you don't automatically have
local, editable copies of them. In other words, in this case, you don't have a new serverfix branch
- you only have an origin/serverfix pointer that you can't modify.

To merge this work into your <current-working-branch>, you can run

$ git merge origin/serverfix

OR

If you want your own serverfix branch that you can work on, you can base it off your remote branch:

$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
Switched to a new branch "serverfix"

(-b means to create a local branch and switch to it)

This gives you a local branch that you can work on that starts where origin/serverfix is.


{tracking-branch}

Checking out a local branch from a remote branch automatically creates what is called a tracking
branch. 

If you're on a tracking branch and type git push/pull, Git automatically knows which server and
branch to push to.

When you clone a repository, it generally automatically creates a <master-branch> that tracks
origin/master. 

However, you can set up other tracking branches if you wish - ones that don't track branches on
origin and don't track the master branch. The simple case is the example you just saw, running git
checkout -b [branch] [remotename]/[branch]. 

If you have Git version 1.6.2 or later, you can also use the --track shorthand:

$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.  Switched to a new
branch "serverfix"


{delete-remote-branch}

Suppose you're done with a remote branch.

$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
 - [deleted]         serverfix


==============================================================================
*kt_dev_env_git_010*		rebasing

In Git, there are two main ways to integrate changes from one branch into another: the merge and the
rebase.

{merge-way}

Like {merge-with-diverge}, use merge which do three-way merge between c2(recent common ancestor), c4,
c3 and crate a new snapshot(commit):

                         <experiment>
c0 <- c1 <- c2        <- c3               <- c5
                      <- c4               <- c5
			                <master> branch

{rebase-way}

Another way: you can take the patch of the change that was introduced in C3 and reapply it on top of
C4. In Git, this is called rebasing. Take changes from experiment and apply to master.

$ git checkout experiment                # note: two step which can be done in one. see below
$ git rebase master                      # git merge master in merge case

First, rewinding head to replay your work on top of it...
Applying: added staged command

                                          <experiment>
c0 <- c1 <- c2        <- c4               <- c3'
			                                 <master> branch

KT. essentially, remove diverge and do fast-forward merge.

Now, the snapshot pointed to by C3' is exactly the same as the one that was pointed to by C5 in the
merge example. 


{why-rebase}

But rebasing makes for a <cleaner-history>. If you examine the log of a rebased branch, it looks like
a linear history: it appears that all the work happened in series, even when it originally happened
in parallel

Often, you'll do this to make sure your commits apply cleanly on a remote branch - perhaps in a
project to which you're trying to contribute but that you don't maintain. That way, the maintainer
doesn't have to do any integration work - just a fast-forward or a clean apply.


Rebasing replays changes from one line of work onto another in the order they were introduced,
whereas merging takes the endpoints and merges them together.


{more-rebase-example}

(from git help)

git rebase [-i | --interactive] [options] [--onto <newbase>] [<upstream>] [<branch>]

If <branch> is specified, git rebase will perform an automatic git checkout <branch> before doing
anything else. Otherwise it remains on the current branch.

The current branch is reset to <upstream>, or <newbase> if the --onto option was supplied. This has
the exact same effect as git reset --hard <upstream> (or <newbase>). ORIG_HEAD is set to point at
the tip of the branch before the reset.

Starting point at which to create the new commits. If the --onto option is not specified, the
starting point is <upstream>. May be any valid commit, and not just an existing branch name.


Suppose you decide that you want to merge your client-side changes into your mainline for a release,
but you want to hold off on the server-side changes until it's tested further. 


C1 C2 C5 C6
         <master>
      C3 C4 C10
		      <server> # topic branch
		C8 C9
		   <client>    # topic branch


So want to apply C8 and C9 only to master.

$ git rebase --onto master server client

This basically says, >Check out the client branch, figure out the patches from the common ancestor
of the client and server branches, and then replay them onto master.< It's a bit complex; but the
result, shown in Figure 3-32, is pretty cool.

                <client>
C1 C2 C5 C6 C8' C9'
         <master>
      C3 C4 C10
		      <server> # topic branch

Now you can fast-forward your master branch (see Figure 3-33):

$ git checkout master
$ git merge client

                <client>
C1 C2 C5 C6 C8' C9'
                <master>
      C3 C4 C10
		      <server> # topic branch


Let's say you decide to pull in your server branch as well. You can rebase the server branch onto
the master branch without having to check it out first by running 

git rebase [basebranch] [topicbranch] 

- which checks out the topic branch (in this case, server) for you and replays it onto the base
  branch (master):

$ git rebase master server
$ git checkout master
$ git merge server

The end result is:

                <client>    <server>
C1 C2 C5 C6 C8' C9' C3' C4' C10'
                            <master>

Remove topic branches:

$ git branch -d client
$ git branch -d server


note: KT. rebasing is useful when use topic branches.


{peril-of-rebase}

Drawbacks, which can be summed up in a single line:
Do not rebase commits that you have pushed to a public repository.

When you rebase stuff, you're abandoning existing commits and creating new ones that are similar but
different. If you push commits somewhere and others pull them down and base work on them, and then
you rewrite those commits with git rebase and push them up again, your collaborators will have to
re-merge their work and things will get messy when you try to pull their work back into yours.

If you treat rebasing as a way to clean up and work with commits before you push them, and if you
only rebase commits that have never been available publicly, then you'll be fine. If you rebase
commits that have already been pushed publicly, and people may have based work on those commits,
then you may be in for some frustrating trouble.

(end of chap 3)


{rebase-interactive-and-squash}

What this does is take smaller commits and combine them into larger ones, which could be useful if
you're wrapping up the day's work or if you just want to package your changes differently.

                  <head>
C1 C2 C3 C4 C5 C6 C7 

Say want to mege from C4 to C7 into one C7.

git rebase -i HEAD~4      # select last 4 commit from head

# vim pops up and edit to choose what to do

pick 01d1124 Adding license	             # assume C7
s 6340aaa Moving license into its own file # squash this
s ebfd367 Jekyll has become self-aware.
s 30e0ccb Changed the tagline in the binary, too.

# quit vim and vim pops again to edit commit message. edit commit message and quit.

Tree will be:
         <head>
C1 C2 C3 C7 


==============================================================================
*kt_dev_env_git_011*		revision

From chap06.


==============================================================================
*kt_dev_env_git_020*		other useful commands

{list}

Lists all the files being tracked by your git repo.

git ls-tree --full-tree -r HEAD


# ============================================================================
#{

==============================================================================
*kt_dev_env_tool_001*	eclipse: to create a project from existing source tree 

1. create a c or c++ project depending on type.

2. create a folder. click 'advanced' and select 'link to alternate location(linked
folder)'. specify a directory on nfs or a local folder that has all source tree. this
effectively makes a 'linked folder' to a folder. 

Properties -> C++ General -> Code Analysis or Indexer


==============================================================================
*kt_dev_env_tool_002*	netbean: to create a project from existing source tree 

But without no makefiles and build settings.  

You can try and create an Application project (instead of a Project with Existing sources) and add
your source files to the project. Application projects creates and maintain their own makefiles. 

{code-assistance-and-#ifdef}
Project property -> C/C++ Compiler -> Preprocessor Definitions

{navigation}

https://netbeans.org/kb/docs/cnd/navigating-editing.html

For 7.3:

Ctrl-b 	 							Go to declaration/definition
Ctrl-Alt-b 	 						Go to overide/overridden
Alt-Left/Alt-Right/Ctrl-Q 		Go backward/forward/to last edit

Alt-F7 								Find usages

Ctrl-G 			Go to line
Alt-Shift-C 	Go to declaration
Ctrl-F9 			Evaluate expression

Finding, Searching, and Replacing

Ctrl-F3 		Search word at insert point
F3/Shift-F3 Find next/previous in file
Alt-Shift-U Find usages results
Alt-Shift-H Turn off search result highlights
Ctrl-I 		Jump to quick search field
Alt-Shift-L Copy file path

Navigating through Source Code

Ctrl-O/Alt-Shift-O 				Go to type/file
Alt-O 								Go to source
Ctrl-Shift-M 						Toggle add/remove bookmark
Ctrl-Shift-Period / Comma 		Next/previous bookmark
Ctrl-Period / Comma 				Next/previous usage/compile error
Alt-Shift-Period / Comma		Select next/previous element
Ctrl-Shift-1/2/3 					Select in Projects/Files/Favorites
Ctrl-[ 								Move caret to matching bracket
Ctrl-K/Ctrl-Shift K 				Next/previous word match
Alt Up / Down 						Next/previous marked occurrence


{jdk-path}

Error is:
"Cannot locate java installation in specified jdkhome C:\Program Files (x86)\Java\jdk1.6.0_25
Do you want to try to use default version ?"

Change this file:
C:\Program Files\NetBeans 7.x\etc\netbeans.conf

# Default location of JDK:
# (set by installer or commented out if launcher should decide)
#
# It can be overridden on command line by using --jdkhome <dir>
# Be careful when changing jdkhome.
# There are two NetBeans launchers for Windows (32-bit and 64-bit) and
# installer points to one of those in the NetBeans application shortcut 
# based on the Java version selected at installation time.
#
netbeans_jdkhome="C:\Program Files\Java\jre7"


==============================================================================
*kt_dev_env_tool_003*	total commander short cut

# search
#
CTRL+SHIFT+S Open Quick Filter dialog and reactivate last-used filter

# tab
#
CTRL+T Open new folder tab and activate it
CTRL+SHIFT+T Open new folder tab, but do not activate it
CTRL+U Exchange directories
CTRL+SHIFT+U Exchange directories and tabs
CTRL+V Paste from clipboard to current dir.

# drive
#
ALT+F1 change left drive
ALT+F2 change right drive

ALT+SHIFT+F5 Move to archive
SHIFT+F2 Compare file lists


F2 Reread source window
F3 List files
F4 Edit files
F5 Copy files
F6 Rename or move files
F7 Create directory
F8 or DEL Delete files to recycle bin /delete directly - according to configuration
F9 Activate menu above source window (left or right)

ALT+F3 Use alternate (external or internal) viewer
ALT+SHIFT+F3 Start Lister and load file with internal viewer (no plugins or multimedia)
ALT+F4 Exit | Minimize (with option MinimizeOnClose in wincmd.ini)
ALT+F5 Pack files
ALT+F6 Unpack specified files from archive under cursor, or selected archives (use Alt+F9 on Windows 95)
ALT+F7 Find
ALT+F8 Opens the history list of the command line
ALT+F9 Same as ALT+F6 (because ALT+F6 is broken on Windows 95)
ALT+SHIFT+F9 Test archives
ALT+F10 Opens a dialog box with the current directory tree
ALT+F11 Opens left current directory bar (breadcrumb bar)
ALT+F12 Opens right current directory bar (breadcrumb bar)
ALT+SHIFT+F11 Focus the button bar to use it with the keyboard
SHIFT+F1 Custom columns view menu
SHIFT+F3 List only file under cursor, when multiple files selected
SHIFT+F4 Create new text file and load into editor
SHIFT+F5 Copy files (with rename) in the same directory
SHIFT+CTRL+F5 Create shortcuts of the selected files
SHIFT+F6 Rename files in the same directory
SHIFT+F8/DEL Delete directly / delete to recycle bin - according to configuration
SHIFT+F10 Show context menu
SHIFT+ESC Minimizes Total Commander to an icon
ALT+left/right Go to previous/next dir of already visited dirs
ALT+down Open history list of already visited dirs (like the history list in a WWW browser)
NUM + expand selection (configurable: just files or files and folders)
NUM - shrink selection
NUM * invert selection (also with shift, see link)
NUM / restore selection
SHIFT+NUM + Like NUM +, but files and folders if NUM + selects just files (and vice versa)
SHIFT+NUM - Always removes the selection just from files (NUM - from files and folders)
SHIFT+NUM * Like NUM *, but files and folders if NUM * inverts selection of just files (and vice versa)
CTRL+NUM + select all (configurable: just files or files and folders)
CTRL+SHIFT+NUM +
select all (files and folders if CTRL+NUM + selects only files)
CTRL+NUM - deselect all (always files and folders)
CTRL+SHIFT+NUM -
deselect all (always files, no folders)
ALT+NUM + select all files with the same extension
ALT+NUM - remove selection from files with the same extension
CTRL+PgUp
or Backspace Change to parent directory (cd ..)
CTRL+< Jump to the root directory (most European keyboards)
CTRL+\ Jump to the root directory (US keyboard)
CTRL+PgDn Open directory/archive (also self extracting .EXE archives)
CTRL+left/right Open directory/archive and display it in the target window. If the cursor is not on a directory name, or the other panel is active, then the current directory is displayed instead.
CTRL+F1 File display 'brief' (only file names)
CTRL+SHIFT+F1 Thumbnails view (preview pictures)
CTRL+F2 File display 'full' (all file details)
CTRL+SHIFT+F2 Comments view (new comments are created with Ctrl+Z)
CTRL+F3 Sort by name
CTRL+F4 Sort by extension
CTRL+F5 Sort by date/time
CTRL+F6 Sort by size
CTRL+F7 Unsorted
CTRL+F8 Display directory tree
CTRL+SHIFT+F8 Cycle through separate directory tree states: one tree, two trees, off
CTRL+F9 Print file under cursor using the associated program
CTRL+F10 Show all files
CTRL+F11 Show only programs
CTRL+F12 Show user defined files
TAB Switch between left and right file list
SHIFT+TAB Switch between current file list and separate tree (if enabled)
Letter Redirect to command line, cursor jumps to command line
INSERT Select file or directory.
SPACE Select file or directory (as INSERT). If SPACE is used on an unselected directory under the cursor, the contents in this directory are counted and the size is shown in the "full" view instead of the string <DIR>. This can be disabled through 'Configuration' - 'Options' - 'Operation' - 'Selection with Space'.
ENTER Change directory / run program / run associated program / execute command line if not empty. If the source directory shows the contents of an archive, further information on the packed file is given.
SHIFT+ENTER 1. Runs command line / program under cursor with preceding command /c and leave the program's window open. Only works if NOCLOSE.EXE is in the Total Commander directory!
2. With ZIP files: use alternative choice of these (as chosen in Packer config): (Treat archives like directories <-> call associated program, i.e. winzip or quinzip)
3. In the list of last used dirs (History, Ctrl+D), open the directory on a new Tab.
ALT+SHIFT+ENTER
The contents of all directories in the current directory are counted. The sizes of the directories are then shown in the "full" view instead of the string <DIR>. Abort by holding down ESC key.
ALT+ENTER Show property sheet.
CTRL+A select all
CTRL+B Directory branch: Show contents of current dir and all subdirs in one list
CTRL+SHIFT+B Selected directory branch: Show selected files, and all in selected subdirs
CTRL+C Copy files to clipboard
CTRL+D Open directory hotlist ('bookmarks')
CTRL+F Connect to FTP server
CTRL+SHIFT+F Disconnect from FTP server
CTRL+I Switch to target directory
CTRL+L Calculate occupied space (of the selected files)
CTRL+M Multi-Rename-Tool
CTRL+SHIFT+M Change FTP transfer mode
CTRL+N New FTP connection (enter URL or host address)
CTRL+P Copy current path to command line
CTRL+Q Quick view panel instead of file window
CTRL+R Reread source directory
CTRL+S Open Quick Filter dialog and activate filter (deactivate with ESC or CTRL+F10)


CTRL+W Close currently active tab
CTRL+SHIFT+W Close all open tabs
CTRL+X Cut files to clipboard
CTRL+Z Edit file comment
CTRL+UP Open dir under cursor in new tab
CTRL+SHIFT+UP Open dir under cursor in other window (new tab)
CTRL+TAB Jump to next tab
CTRL+SHIFT+TAB
Jump to previous tab
 
ALTGR+Letter(s) or
CTRL+ALT+Letter(s)
Quick search for a file name (starting with specified letters) in the current directory
(Support hotkeys Ctrl+X, Ctrl+C, Ctrl+V and Ctrl+A; use Ctrl+S for search filter on/off)
 
Other keys: See command line


==============================================================================
*kt_dev_env_tool_004*	outlook keys

Switch to Inbox.
 CTRL+SHIFT+I
 
Switch to Outbox.
 CTRL+SHIFT+O
 
Choose the account from which to send a message.
 CTRL+TAB (with focus on the To box) and then TAB to the Accounts button
 
Check names.
 CTRL+K
 
Send.
 ALT+S
 
Reply to a message.  CTRL+R 
 
Reply all to a message.  CTRL+SHIFT+R ~
 
Forward a message.
 CTRL+F
 
Mark a message as not junk.
 CTRL+ ALT+J
 
Display blocked external content (in a message).
 CTRL+SHIFT+I
 
Post to a folder.
 CTRL+ SHIFT+S
 
Apply Normal style.
 CTRL+SHIFT+N
 
Check for new messages.
 CTRL+M or F9
 
Go to the previous message.
 UP ARROW
 
Go to the next message.
 DOWN ARROW
 
Create a new message (when in Mail).
 CTRL+N
 
Create a new message (from any Outlook view).
 CTRL+SHIFT+M
 
Open a received message.
 CTRL+O
 
Open the Address Book.
 CTRL+SHIFT+B
 
Convert an HTML or RTF message to plain text.
 CTRL+SHIFT+O
 
Add a Quick Flag to an unopened message.
 INSERT
 
Display the Flag for Follow Up dialog box.
 CTRL+SHIFT+G
 
Mark as read.
 CTRL+Q
 
Mark as unread.
 CTRL+U
 
Show the menu to download pictures, change automatic download settings, or add a sender to the Safe Senders List.
 CTRL+SHIFT+W
 
Find or replace.
 F4
 
Find next.
 SHIFT+F4
 
Send.
 CTRL+ENTER
 
Print.
 CTRL+P
 
Forward.
 CTRL+F
 
Forward as attachment.
 CTRL+ALT+F
 
Show the properties for the selected item.
 ALT+ENTER
 
  
Mark for Download.
 CTRL+ALT+M
 
Clear Mark for Download.
 CTRL+ALT+U
 
Display Send/Receive progress.
 CTRL+B (when a Send/Receive is in progress)
 

==============================================================================
*kt_dev_env_tool_005*	ms-project: set delay

http://office.microsoft.com/en-001/project-help/delay-a-task-HP045308316.aspx

Add delay to an assignment

On the View menu, click More Views, click Resource Allocation, and then click Apply.

The Resource Allocation view is a combination of the Resource Usage view (on the top) and the Detail
Gantt view (on the bottom).

    In the Resource Usage portion of the view, click the resource or assignment for which you want
    to examine slack and possibly delay.  Click the Detail Gantt portion of the view.  On the View
    menu, point to Table, and then click Schedule.  To make sure you don't delay any other tasks or
    the project finish date, review available slack before adding delay. In the Detail Gantt portion
    of the view, press TAB until the Free Slack and Total Slack fields are visible, and then review
    them to find tasks that have slack.

Slack is also shown graphically as thin bars adjoining the regular Gantt bar.

    In the Resource Usage portion of the view, click the field to the right of where you want to
    insert the Assignment Delay field.  On the Insert menu, click Column.  In the Field name box,
    click Assignment Delay, and then click OK.  In the Assignment Delay field for the assignment you
    want to delay, type or select the amount of time you want to delay the assignment.

This indicates how much time after the task's start date the resource is to wait before starting
work on this assignment.

 Notes 

    If the task is linked, delaying one of its assignments might change the scheduling of any
    successor tasks, which can affect the finish date of your project. It's best to delay
    assignments on tasks with free slack first, and delay them only up to the amount of available
    slack.  You can add delay to a task or assignment, check the effect on the resource allocation,
    and then adjust the delay further if necessary. If you want to add delay without changing the
    finish date of other tasks or the project finish date, review available slack and add delay only
    within that time. Note that leveling can automatically delay tasks or assignments. Resource
    leveling considers all resources with assignments in the project, and is generally preferable to
    manually delaying tasks.


==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
