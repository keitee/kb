*kt_dev_env*                                                       tw=100, utf-8

"Do one thing, and do it well" is a principle of Unix philosophy.

/^[#=]{ 
Use #{ for a group and ={ for a item

KT KB. vim, git, ECLIPSE. NETBEAN

#{ vim setup
|kt_dev_env_vim_000| links
|kt_dev_env_vim_001| vim-install
|kt_dev_env_vim_002| vim-set-plugins
|kt_dev_env_vim_002| vim-set-neobundle
|kt_dev_env_vim_003| vim-set-vimproc
|kt_dev_env_vim_002| vim-set-hack-font
|kt_dev_env_vim_004| vim-set-solarized
*kt_dev_env_vim_004* vim-set-solarized-terminal dircolors
|kt_dev_env_vim_005| plugins: status line
*kt_dev_env_vim_006* vim-set-unite
*kt_dev_env_vim_007* vim-set-tagbar-unite-tag (not use)
|kt_dev_env_vim_008| plugins: ycm
|kt_dev_env_vim_009| plugins: ctrlp
|kt_dev_env_vim_010| plugins: neocomplete
|kt_dev_env_vim_011| plugins: indent-guide
*kt_dev_env_vim_012* vim-set-ag
|kt_dev_env_vim_013| plugins: netrw: run browser on link in vim
|kt_dev_env_vim_003| key sheet 

|kt_dev_env_vim_097| key mapping: traverse a list  
|kt_dev_env_vim_098| key mapping: traverse a list  
|kt_dev_env_vim_099| key mapping 

#{ vim core
|kt_dev_env_vim_100| help
|kt_dev_env_vim_101| dot command {power}
|kt_dev_env_vim_102| chunk your undo
|kt_dev_env_vim_103| operator, text object and motion
|kt_dev_env_vim_104| operator pending mode
|kt_dev_env_vim_105| commands in insert mode
|kt_dev_env_vim_106| normal mode and insert normal mode
*kt_dev_env_vim_100* vim-cfg-remap-capslock
*kt_dev_env_vim_100* vim-cfg-reload-vimrc
|kt_dev_env_vim_108| use register in insert mode or command input
|kt_dev_env_vim_109| expression register

|kt_dev_env_vim_110| find out char code value
|kt_dev_env_vim_111| replace mode
|kt_dev_env_vim_112| visual mode
|kt_dev_env_vim_113| command mode: ex commands
|kt_dev_env_vim_114| command mode: normal commands
|kt_dev_env_vim_115| command completion, history, and command line window
|kt_dev_env_vim_116| vim-cmd-filename
*kt_dev_env_vim_117* vim-edit-fileformat
*kt_dev_env_vim_117* vim-edit-two-files
*kt_dev_env_vim_117* vim-edit-autowrite
|kt_dev_env_vim_117| exit, file and buffer
|kt_dev_env_vim_118| vim-window
*kt_dev_env_vim_118* vim-window-scroll
|kt_dev_env_vim_119| display and real line

|kt_dev_env_vim_120| mark, jumps and changes
*kt_dev_env_vim_121* vim-register vim-clipboard
*kt_dev_env_vim_122* vim-paste-into-command-line
*kt_dev_env_vim_000* regex
*kt_dev_env_vim_000* regex-ex
*kt_dev_env_vim_000* vim-regex
*kt_dev_env_vim_000* vim-regex-separator
|kt_dev_env_vim_122| vim-search
|kt_dev_env_vim_124| vim-search-highlight
*kt_dev_env_vim_127* vim-search-greedy-match
*kt_dev_env_vim_128* vim-search-selection
|kt_dev_env_vim_129| global command {power}

*kt_dev_env_vim_004* vim-syntax
*kt_dev_env_vim_130* vim-syntax-hide
*kt_dev_env_vim_130* vim-spell
|kt_dev_env_vim_131| vim-diff
|kt_dev_env_vim_132| yank current filename to a register. expand

|kt_dev_env_vim_140| shell: run external program and bang(!) 
|kt_dev_env_vim_141| vim-shell

|kt_dev_env_vim_150| format, wrap, tw
|kt_dev_env_vim_150| vim-textwidth
|kt_dev_env_vim_151| encoding and utf8
*kt_dev_env_vim_152* how: how to change word between '_'


#{ vim programming
|kt_dev_env_vim_200| prog: adding and substracting
|kt_dev_env_vim_201| vim-edit-tab-space
|kt_dev_env_vim_202| prog: match command

*kt_dev_env_vim_300* vim-tag-cscope
*kt_dev_env_vim_301* vim-tag-ctag
*kt_dev_env_vim_302* vim-tag-stack
|kt_dev_env_vim_302| prog: move in c
*kt_dev_env_vim_303* vim-tag-gtag
*kt_dev_env_vim_303* vim-tag-unite-gtag
*kt_dev_env_vim_304* vim-make 
*kt_dev_env_vim_304* vim-quickfix vim-location-list
*kt_dev_env_vim_305* vim-filetype
*kt_dev_env_vim_305* vim-make-external
*kt_dev_env_vim_305* vim-make-external-case
*kt_dev_env_vim_306* vim-filetype-nds
|kt_dev_env_vim_306| prog: build: man page in vim

|kt_dev_env_vim_320| prog: folding

|kt_dev_env_vim_300|	script

|kt_dev_env_vim_002|	config {vimrc}
|kt_dev_env_vim_003|	recovery, swap and backup
|kt_dev_env_vim_005|	plugin: foldsearc
|kt_dev_env_vim_008|	search and substitute {vim-subst} {vim-global}

#{ git
*kt_dev_env_0000* git-reference
*kt_dev_env_0000* git-install
*kt_dev_env_0000* git-vim
*kt_dev_env_0000* git-config-alias-help
*kt_dev_env_git_003* git-fugi: complement to command line
*kt_dev_env_git_014* git-fugi: working with the index
*kt_dev_env_git_014* git-fugi: resolving merge conflicts
*kt_dev_env_git_014* git-fugi: exploring the history of a git repository
*kt_dev_env_git_014* git-fugi: doc
*kt_dev_env_git_015* git-gitgutter
*kt_dev_env_0000* git-prompt

*kt_dev_env_0000* git-init git-clone
*kt_dev_env_0000* git-three-state
*kt_dev_env_0000* git-command-format
*kt_dev_env_0000* git-status
*kt_dev_env_0000* git-ignore
*kt_dev_env_0000* git-range
*kt_dev_env_0000* git-range-what-introduced
*kt_dev_env_0000* git-revision
*kt_dev_env_git_000* git-log
*kt_dev_env_0000* git-log-grep
*kt_dev_env_0000* git-log-order
*kt_dev_env_0000* git-log-no-pager
*kt_dev_env_0000* git-reflog-recover
*kt_dev_env_0000* git-reflog-list
*kt_dev_env_0000* git-pickaxe
*kt_dev_env_0000* git-commit-message
*kt_dev_env_0000* git-grep
*kt_dev_env_0000* git-grep-all-branches
*kt_dev_env_0000* git-grep-fun
*kt_dev_env_0000* git-completion
*kt_dev_env_0000* git-branch
*kt_dev_env_0000* git-branch-rename git-branch-delete git-branch-reset
*kt_dev_env_0000* git-branch-list
*kt_dev_env_0000* git-branch-tracking git-checkout
*kt_dev_env_0000* git-branch-topic
*kt_dev_env_0000* git-branch-check-commit-or-tag
*kt_dev_env_git_000* git-merge-conflict
*kt_dev_env_git_000* git-merge-base
*kt_dev_env_0000* git-merge-undo
*kt_dev_env_0000* git-merge-mergetool
*kt_dev_env_git_011* git-merge: mergetool: use meld
*kt_dev_env_git_011* git-merge: mergetool: local and remote
*kt_dev_env_git_011* git-merge: mergetool: use gvimdiff
*kt_dev_env_0000* git-diff
*kt_dev_env_0000* git-diff-tool
*kt_dev_env_0000* git-diff-not-range
*kt_dev_env_0000* git-diff-format
*kt_dev_env_0000* git-diff-patch
*kt_dev_env_0000* git-diff-format-patch
*kt_dev_env_git_000* git-tag
*kt_dev_env_git_000* git-tag-git-describe
*kt_dev_env_0000* git-rebase
*kt_dev_env_0000* git-rebase-onto
*kt_dev_env_0000* git-rebase-rewrite-history
*kt_dev_env_0000* git-commit-amend
*kt_dev_env_0000* git-rebase-recover
*kt_dev_env_0000* git-rebase-or-merge
*kt_dev_env_git_000* git-cherry-pick
*kt_dev_env_git_000* git-reset
*kt_dev_env_0000* git-reset-try-branches

*kt_dev_env_0000* git-stash
*kt_dev_env_0000* git-ls-files git-ls-tree
*kt_dev_env_0000* git-add git-rm git-mv
*kt_dev_env_git_000* git-clean
*kt_dev_env_0000* git-show
*kt_dev_env_0000* git-commit
*kt_dev_env_0000* git-commit-log
*kt_dev_env_0000* git-blame
*kt_dev_env_0000* git-bisect
*kt_dev_env_git_000* git-rev-parse

*kt_dev_env_git_000* git-fe-gitk

*kt_dev_env_0000* git-work-model
*kt_dev_env_0000* git-work-flow

*kt_dev_env_0000* git-remote
*kt_dev_env_0000* git-remote-change
*kt_dev_env_0000* git-fetch
*kt_dev_env_0000* git-pull 
*kt_dev_env_0000* git-pull-conflict
*kt_dev_env_0000* git-pull-rebase
*kt_dev_env_0000* git-push-refspec
*kt_dev_env_0000* git-push-errors-bare
*kt_dev_env_git_155* git-hook:
*kt_dev_env_git_155* git-hook: pre-push example
*kt_dev_env_git_155* git-update-ref:
*kt_dev_env_git_155* git-update-index:
*kt_dev_env_git_155* git-write-tree:
*kt_dev_env_git_155* git-commit-tree:

*kt_dev_env_0000* git-how: how to copy a file from a commit
*kt_dev_env_0000* git-how: how to check if a branch contains a commit
*kt_dev_env_0000* git-how: github fork projects and pull request

#{ tmux
*kt_dev_env_3000* tmx-install
*kt_dev_env_3000* tmx-basic

#{ windows
*kt_dev_env_4000* win-virtual-desktop
|kt_dev_env_tool_001| eclipse: to create a project from existing source tree 
|kt_dev_env_tool_002| netbean: to create a project from existing source tree 
|kt_dev_env_tool_003| total commander short cuts
|kt_dev_env_tool_004| outlook keys
|kt_dev_env_tool_005| ms-project: set delay
|kt_dev_env_tool_006| firefox short cuts


# ============================================================================
#{
={============================================================================
*kt_dev_env_vim_000* links

unimpaired.vim : Pairs of handy bracket mappings
http://www.vim.org/scripts/script.php?script_id=1590

http://www.viemu.com/a-why-vi-vim.html
http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/

http://andrewradev.com/2011/06/08/vim-and-ctags/

for articles and video casts by author of the paractical vim
http://vimcasts.org/

https://pragprog.com/book/dnvim/practical-vim


={============================================================================
*kt_dev_env_vim_001* vim-install

{get-source}
git clone https://github.com/vim/vim.git

{install}
cd src
make distclean  " if you build Vim before
./configure     " see below
make VIMRUNTIMEDIR=/home/kit/vim MAKE="make -e"
make install

<features>
# to check features
% gvim --version | egrep '\+lua'
%
+dialog_con_gui  +lua             +rightleft       +windows

In vim command input, :echo has("lua") returns 1, then you're done; otherwise, see below.


<build>
http://vim.wikia.com/wiki/Building_Vim

1. Get dependencies. apt-get build-dep vim-gnome or similar can do this for you.
2. Get the Vim source code from Mercurial or a GitHub clone.  
3. Change to the directory with the Vim source code and run "make".  

# Building Vim on Ubuntu
# 
# You need the required development packages on Ubuntu to build the GUI: 
# 
# sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev
# libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev
# 
# See vim/src/auto/config.log for more detailed logs and ./configure --help for options which comes
# from vim/src/auto/configure

<feature-python>
https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source

For 3.3:

Get python from python org, build and install. Then find out dir where config.c for python is. For
3.3, this is /usr/local/lib/python3.3/config-3.3m/. Do not need to change makefile.

Then use this:

./configure --prefix=/home/kit --enable-luainterp=yes --with-features=huge --enable-gui=gnome2 --enable-cscope 

--enable-python3interp=yes 
--with-python3-config-dir=/usr/local/lib/python3.3/config-3.3m

For 2.7 which is already installed:

/usr/lib/python2.7/config

If build failed since cannot find some files relating python then do:
apt-get install python-dev

The following NEW packages will be installed
  libssl-dev libssl-doc python-dev python2.7-dev

<feature-lua> and python2.7

apt-get install lua5.2 liblua5.2-dev

./configure --prefix=/home/kit/bin --enable-luainterp=yes \
--with-features=huge --enable-gui=gnome2 --enable-cscope \
--enable-pythoninterp=yes \
--with-python-config-dir=/usr/lib/python2.7/config

note:
Have to use absolute path in --prefix.

./configure --prefix=~/bin --enable-luainterp=yes \
--with-features=huge --enable-gui=gnome2 --enable-cscope \
--enable-pythoninterp=yes

note: 
When lua is installed but liblua??-dev is not installed then vim cannot be
built with lua feature.


={============================================================================
*kt_dev_env_vim_002* vim-set-plugins

{scriptnames}
List all sourced script names, in the order they were first sourced.

:scrip[tnames]



={============================================================================
*kt_dev_env_vim_002* vim-set-neobundle

https://github.com/Shougo/neobundle.vim

{install}
$ curl https://raw.githubusercontent.com/Shougo/neobundle.vim/master/bin/install.sh | sh

note: requires vimproc

NeoBundle assumes Github as the default location for plugins, so for most
plugins you can simply use NeoBundle 'username/plugin' rather than using the
absolute URL of the plugin. These calls should be made in your .vimrc file. Once
you have defined these, you must call NeoBundleInstall, and NeoBundle will clone
all of the repos into the desired folder (generally ~/.vim/bundle) and load them
into Vim. If you want to update these repositories, simply call NeoBundleUpdate.

note: requires to restart vim after NeoBundleUpdate.


={============================================================================
*kt_dev_env_vim_003* vim-set-vimproc

https://github.com/Shougo/vimproc.vim

# git clone https://github.com/Shougo/vimproc.vim and build c files and add it
# to runtimepath
# 
# Clone this repo Build vimproc's native extensions (see Building for details).
# Just run make.
# 
# Copy autoload/* and plugin/* files to your 'runtimepath' directory. see :help
# runtimepath.  note: this is ~/.vim/bundle/                


2015.09.03.

After updated all packages, unite failed to run "async" function and showed
error around vimproc in gather_candidates

The suggestion was:
Please re-compile vimproc: (cd ~/.vim/bundle/vimproc && make)

Do not copy .so file manually since should be done in bundle mechanism and
vimproc is already in runtimepath:

/home/kpark/.vim/bundle/vimproc

So build and leave to be loaded from there.


={============================================================================
*kt_dev_env_vim_002* vim-set-hack-font

https://github.com/chrissimpkins/Hack#user-content-quick-installation

Download zip file and install ttf files.
Hack-v2_020-ttf.zip


={============================================================================
*kt_dev_env_vim_004* vim-set-solarized

{solarized-colorscheme}
Not working with neobundle and done manually by coyping into .vim/color
https://github.com/altercation/vim-colors-solarized
http://ethanschoonover.com/solarized

Option 1: Manual installation

Move solarized.vim to your .vim/colors directory. After downloading the vim
script or package:

$ cd vim-colors-solarized/colors
$ mv solarized.vim ~/.vim/colors/


# set in vimrc

syntax enable
set background=dark
colorscheme solarized


={============================================================================
*kt_dev_env_vim_004* vim-set-solarized-terminal dircolors

IMPORTANT NOTE FOR TERMINAL USERS:

If you are going to use Solarized in Terminal mode (i.e. not in a GUI version
like gvim or macvim), please please please consider setting your terminal
emulator's colorscheme to used the Solarized palette. I've included palettes
for some popular terminal emulator as well as Xdefaults in the official
Solarized download available from Solarized homepage. If you use Solarized
without these colors, Solarized will need to be told to degrade its
colorscheme to a set compatible with the limited 256 terminal palette (whereas
by using the terminal's 16 ansi color values, you can set the correct,
specific values for the Solarized palette).

http://www.webupd8.org/2011/04/solarized-must-have-color-paletter-for.html

{dircolors}

#############################################################################
# Below are the color init strings for the basic file types. A color init
# string consists of one or more of the following numeric codes:
#
# Attribute codes:
#   00=none 01=bold 04=underscore 05=blink 07=reverse 08=concealed
# Text color codes:
#   30=black 31=red 32=green 33=yellow 34=blue 35=magenta 36=cyan 37=white
# Background color codes:
#   40=black 41=red 42=green 43=yellow 44=blue 45=magenta 46=cyan 47=white
#
# NOTES:
# - See http://www.oreilly.com/catalog/wdnut/excerpt/color_names.html
# - Color combinations
#   ANSI Color code       Solarized  Notes                Universal             SolDark              SolLight
#   ~~~~~~~~~~~~~~~       ~~~~~~~~~  ~~~~~                ~~~~~~~~~             ~~~~~~~              ~~~~~~~~
#   00    none                                            NORMAL, FILE          <SAME>               <SAME>
#   30    black           base02
#   01;30 bright black    base03     bg of SolDark
#   31    red             red                             docs & mm src         <SAME>               <SAME>
#   01;31 bright red      orange                          EXEC                  <SAME>               <SAME>
#   32    green           green                           editable text         <SAME>               <SAME>
#   01;32 bright green    base01                          unimportant text      <SAME>
#   33    yellow          yellow     unclear in light bg  multimedia            <SAME>               <SAME>
#   01;33 bright yellow   base00     fg of SolLight                             unimportant non-text
#   34    blue            blue       unclear in dark bg   user customized       <SAME>               <SAME>
#   01;34 bright blue     base0      fg in SolDark                                                   unimportant text
#   35    magenta         magenta                         LINK                  <SAME>               <SAME>
#   01;35 bright magenta  violet                          archive/compressed    <SAME>               <SAME>
#   36    cyan            cyan                            DIR                   <SAME>               <SAME>
#   01;36 bright cyan     base1                           unimportant non-text                       <SAME>
#   37    white           base2
#   01;37 bright white    base3      bg in SolLight
#   05;37;41                         unclear in Putty dark


// since light is better
// wget --no-check-certificate https://raw.github.com/seebi/dircolors-solarized/master/dircolors.ansi-dark
// mv dircolors.ansi-dark .dircolors
// eval `dircolors ~/.dircolors`

wget --no-check-certificate https://raw.github.com/seebi/dircolors-solarized/master/dircolors.ansi-light
mv dircolors.ansi-light .dircolors
eval `dircolors ~/.dircolors`


$ man dircolors

NAME
       dircolors - color setup for ls

       -p, --print-database
              output defaults

note:
No /etc/DIR_COLORS in debian.

As for where dircolors gets its settings from, when you don't specify a file
it just uses some builtin defaults.


{gonme}
git clone https://github.com/sigurdga/gnome-terminal-colors-solarized.git
cd gnome-terminal-colors-solarized

" can set it to light or dark using the following commands:

./set_dark.sh
./set_light.sh


{putty}
https://github.com/altercation/solarized/tree/master/putty-colors-solarized

PuTTY Tray can store sessions in text files as opposed to the Windows
registry. To modify an existing session to use Solarized colors, open the file
in a text editor and replace the lines beginning with Colour## (0-21) with the
version from solarized_dark_puttytray.txt or solarized_light_puttytray.txt.

https://puttytray.goeswhere.com/

Saves a session as a text which is made under "session" from where putty runs.

// solarized/putty-colors-solarized/solarized_light_puttytray.txt

Colour21\253,246,227\
Colour20\238,232,213\
Colour19\147,161,161\
Colour18\42,161,152\
Colour17\108,113,196\
Colour16\211,54,130\
Colour15\131,148,150\
Colour14\38,139,210\
Colour13\101,123,131\
Colour12\181,137,0\
Colour11\88,110,117\
Colour10\133,153,0\
Colour9\203,75,22\
Colour8\220,50,47\
Colour7\0,43,54\
Colour6\7,54,66\
Colour5\101,123,131\
Colour4\238,232,213\
Colour3\238,232,213\
Colour2\253,246,227\
Colour1\88,110,117\
Colour0\101,123,131\

// original value

Colour21\255,255,255\
Colour20\187,187,187\
Colour19\85,255,255\
Colour18\0,187,187\
Colour17\255,85,255\
Colour16\187,0,187\
Colour15\85,85,255\
Colour14\0,0,187\
Colour13\255,255,85\
Colour12\187,187,0\
Colour11\85,255,85\
Colour10\0,187,0\
Colour9\255,85,85\
Colour8\187,0,0\
Colour7\85,85,85\
Colour6\0,0,0\
Colour5\0,255,0\
Colour4\0,0,0\
Colour3\85,85,85\
Colour2\0,0,0\
Colour1\255,255,255\
Colour0\187,187,187\


={============================================================================
*kt_dev_env_vim_005* plugins: status line

{status}
https://github.com/bling/vim-airline


={============================================================================
*kt_dev_env_vim_006* vim-set-unite

{unite}
https://github.com/Shougo/unite.vim
http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/

note: requires vimproc 

:Unite [{options}] {sources}
      Unite can be invoked with one or more sources. This can be done by
      specifying the list on the command line, separated by spaces. The list of
      candidates (the matches found in the source by your filter string) will be
      ordered in the same order that you specify the {sources}.

      If {sources} are empty, you can input source name and args manually.

      For example:

      :Unite file buffer

      Will first list the files, then list the buffers.

      *unite-source-parameters*
      Unite can accept a list of strings, separated with ":", after the name of
      sources.  You must escape ":" and "\" with "\" in parameters themselves.
      "::" is an abbreviation argument.  It depends on the sources how the
      parameters are interpreted.

      Examples:
      "file:foo:bar": the parameters of source file are ["foo", "bar"].
      "file:foo\:bar": the parameter of source file is ["foo:bar"].
      "file:foo::bar": the parameters of source file are ["foo", "", "bar"].


<usage>
To browse a list of currently open buffers like |:ls| command.
>
:Unite buffer

To browse a list of files in the current working directory.
>
:Unite file

Or you can combine sources, to browse files and buffers.
>
:Unite file buffer

There are a number of command line flags (see |unite-options|), for example to
set an initial search term (foo) to filter files search.
>
:Unite -input=foo file

// ?
// You don't have to use |:execute| for dynamic arguments.  You can use evaluation
// cmdline by ``.  Note: In the evaluation, The special characters(spaces,  "\" and
//    ":") are escaped automatically.
// :Unite -buffer-name=search%`bufnr('%')` line:forward:wrap<CR>

Invoking unite will create a horizontal split buffer by default.
>
:Unite file

This example lists all the files in the current directory. You can select one in
the unite window by moving the cursor with normal Vim navigation, e.g. j and k.
Pressing Enter on a candidate and it will open it in a new buffer.

Enter will trigger the default `action`, which in the case of "file" is open,
      however alternate actions can be defined. 
      
These alternative actions can be invoked with `Tab`. See also |unite-actions| to
read on about different actions.


<filtering>
You can also narrow down the list of candidates with a keyword.  By entering
insert mode in a unite window, the cursor will jump to the unite prompt (" ") at
the top of the window. Typing at the unite prompt will filter the candidate
list.

You can also use the wild card "*" as an arbitrary character sequence.
>
*hisa

This example matches hisa, ujihisa, or ujihisahisa.

Two consecutive wild cards recursively match directories.
>
**/foo

This example would match bar/foo or buzz/bar/foo.

Multiple keywords can be used to narrow down the candidates. They are separated
by either a space " " or a pipe "|", and act like a logical AND. This example
matches "foobar" and "foobazbar", but not "foobaz"

foo bar
foo|bar


Specify negative conditions with a bang "!". This example matches candidates
that contain "foo" but not "bar".
>
foo !bar


Specify command execution `after-the-action` with a ":".
>
" Jump to line 3.
foo :3
" Search for "bar".
foo :/bar
" Execute :diffthis command.
foo :diffthis
<
See |unite_default_key_mappings| for other actions.


{source}
See :h unite-source for more. The source is where candidates comes from.

*file_rec/async*

Similar to |unite-source-file_rec|, but get files asynchronously with
|g:unite_source_rec_async_command|.

Note: Requires |vimproc|.
Note: Requires the "ag" or "find" command.
Note: If you edit one of the files in Vim, the source will update its cache.
"gtags/path" source is recommended.
https://github.com/hewes/unite-gtags

Source arguments:
1. the target directories splitted by newlines.


*file_rec/git*

Similar to |unite-source-file_rec|, but get files by "git ls-files" command. It
is faster than file_rec/async source.

Note: Requires vimproc.
Note: Requires git.
Note: Searches from current directory only.

Source arguments:
1. "git ls-files" arguments

Example: >
  nnoremap <silent> ,ug  :<C-u>Unite
  \ file_rec/git:--cached:--others:--exclude-standard<CR>


*grep/git*


*mapping*

Nominates Vim mappings as candidates.

Source arguments:
1. Buffer number.


*grep*

Nominates "grep" command output as candidates. This source requires |vimproc|.

Source arguments:

1. the `target` directories splitted by newlines.
2. "grep" options.
3. the narrowing pattern (if you omit it, |unite-options-input| or input prompt
is used).

note: ?
Max candidates: 100

Special Target:

%         : Current buffer name
#         : Alternate buffer name
$buffers  : All buffer names


Example:
>
  :Unite grep:~/.vim/autoload/unite/sources:-iR:file


Settings Example:
>
elseif executable('ag')
  " Use ag (the silver searcher)
  " https://github.com/ggreer/the_silver_searcher
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts =
  \ '-i --vimgrep --hidden --ignore ' .
  \ '''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'''
  let g:unite_source_grep_recursive_opt = ''
endif




file              Browse the list of files in the current directory
file_rec          Recursively list files under the current directory

file_mru          Recursively list files under the current directory
note: Please install https://github.com/Shougo/neomru.vim

directory         Nominates an input directory as a candidate.

" not consider since the workflow would not use a tab.
"
" buffer_tab        Nominates opened buffers only in the current tab as
" note: This source requires |tabpagebuffer|.  Please install http://github.com/Shougo/tabpagebuffer.vim

tab               Nominates opened tabs as candidates
bookmark          Nominates files or directories you bookmarked as candidates.
mapping           Nominates Vim mappings as candidates.
grep              Nominates "grep" command output as candidates.
output            Nominates executed Vim command as candidates.
find              Nominates "find" command output as candidates.
jump              Nominates results of |:jumps| command as candidates.
history/yank      Nominates yanked words.
change            Nominates results of |:changes| command as candidates.


<pass-arg-to-source>
Unite can accept a list of strings, separated with ":", after the name of sources. You must escape
":" and "\" with "\" in parameters themselves. "::" is an abbreviation argument. It depends on the
sources how the parameters are interpreted.

Examples:
"file:foo:bar": the parameters of source file are ["foo", "bar"].
"file:foo\:bar": the parameter of source file is ["foo:bar"].
"file:foo::bar": the parameters of source file are ["foo", "", "bar"].


<bang-on-source>
With large projects this may cause some performance problems. Normally it is recommended to use
unite-source-file_rec/async source, which requires vimproc. The mapping might look something like
this: 

nnoremap <leader>r :<C-u>Unite -start-insert file_rec/async:!<CR>

note: see how to use bang for a source

nnoremap <silent> [unite]<space> :<C-u>Unite -toggle -auto-resize \
    -buffer-name=mixed file_rec/async:! buffer file_mru bookmark<cr><c-u>


<order>
The order of sources in mapping reflected in the order of candidates.

shows file_rec first
nnoremap <C-u> :Unite -toggle -auto-resize -buffer-name=files file_rec/async file_mru <cr>

shows fime_mru first
nnoremap <C-u> :Unite -toggle -auto-resize -buffer-name=files file_mru file_rec/async<cr>

<normal-insert-modes>
If you start unite it splits the window horizontally and pops up from the top of Vim by default.
When run command, wait input in input mode and can filter the candidate. In normal mode, can use
usual keys to navigate. 'q' exit a windows in normal mode.

note: In short, input mode is to 'filter' the candidates.

note: The unite action file_rec does a recursive file matching by default without the need to set
wildcards.

<actions> :h unite-actions
Both Normal and Insert mode have mappings. For example, pressing a in Normal mode when the cursor is
over a file will cause Unite to show a list of file manipulation commands. This list of commands is
known as actions, and the list can be searched and invoked just like anything else in Unite.

Wildcards can be combined with actions. If I type :Unite file, then press * to mark all files, then
type a to list actions, and finally select above, Unite will open all of the marked files in split
windows.

Default actions

kind        action
----------  ----------
file        open
buffer      open
tab         open
directory   narrow
word        insert
jump_list   open
source      start


<where-to-start>
:UniteWithCurrentDir [{options}] {sources}
Equivalent to :Unite except that it targets the current directory for the initial narrowing text.

:UniteWithBufferDir [{options}] {sources}
Equivalent to :Unite except that it targets the buffer's directory for the initial narrowing text.

:UniteWithProjectDir [{options}] {sources}
Equivalent to :Unite except that it targets the project directory for the initial narrowing text.

nnoremap <silent> [unite]c  :<C-u>UniteWithCurrentDir
   \ -buffer-name=files buffer bookmark file<CR>

<filters> h: unite-filters


{unite-keys}
See :h unite-key-mappings for more.

<normal-mode-keys> 
seleced ones

{lhs}    {rhs}
-------- -----------------------------
i        |<Plug>(unite_insert_enter)|
a        In case when you selected a candidate, |<Plug>(unite_choose_action)|
         else |<Plug>(unite_append_enter)|

q        |<Plug>(unite_exit)|
Q        |<Plug>(unite_all_exit)|

<C-r>    |<Plug>(unite_restart)|    
note: restart "source". for example, can change "path" and re-read files.

<Space>  |<Plug>(unite_toggle_mark_current_candidate)|
<Tab>    |<Plug>(unite_choose_action)|

<C-l>    |<Plug>(unite_redraw)|
note: clear cache.

gg       |<Plug>(unite_cursor_top)|
G        |<Plug>(unite_cursor_bottom)|
j        |<Plug>(unite_loop_cursor_down)|
k        |<Plug>(unite_loop_cursor_up)|

g?       |<Plug>(unite_quick_help)|
note: shows these key mappings

.        |<Plug>(unite_narrowing_dot)|
note: narrowing?

<CR>     In case when you selected a candidate, runs default action
b        In case when you selected a candidate, runs bookmark action
d        In case when you selected a candidate, runs delete action
note: when tries, get an error saying no delete action.

e        In case when you selected a candidate, runs narrow action
t        In case when you selected a candidate, runs tabopen action
yy       In case when you selected a candidate, runs yank action
o        In case when you selected a candidate, runs open action
p        In case when you selected a candidate, runs preview action
x        In case when you selected a candidate, runs |<Plug>(unite_quick_match_default_action)|


{cache-size}
Specify the maximum number of files that |unite-source-file_rec| saves the
caches. The default value is 2000.

Q: file_rec and file_rec/async cannot find all files.
https://github.com/Shougo/unite.vim/issues/356
https://github.com/Shougo/unite.vim/issues/370

A: It is feature. cf: |g:unite_source_rec_max_cache_files|. And the default max
candidates are limited. You can custom it by

|unite#custom#source()|. >
        let g:unite_source_rec_max_cache_files = 0
        call unite#custom#source('file_rec,file_rec/async',
        \ 'max_candidates', 0)

And you must clear previous cache in file_rec sources. To clear cache, you must
execute |<Plug>(unite_redraw)| in unite buffer(in default it is mapped to
        <C-l>).


{custom-config}
Use to set options rather than using variables like this:

g:unite_kind_file_vertical_preview

If this variable is 1, Unite will open the preview window
vertically rather than horizontally.
Note: This variable is deprecated.  Please use
|unite#custom#profile()| instead.


So how?

unite#custom#profile({profile-name}, {option-name}, {value})

Set {profile-name} specialized {option-name} to {value}.

context  (Dictionary)

Specify option(key) and its value for unite buffer or predefined "default" buffer. 

Note: If you want to change default context, you should use "default" profile name.

Note: If you use single source in unite.vim commands with omitting profile name and buffer name,
"source/{source-name}" is used. Thus, you can define a source-specific profile. Valid key
context is in |unite-options|. 

However, "-" is substituted to "_", and "-" prefix is removed. This means that:

option "-start-insert" becomes "start_insert" in profile setting.


" Start insert mode in unite-action buffer.
call unite#custom#profile('action', 'context', {'start_insert' : 1})

" Set "-no-quit" automatically in grep unite source.
call unite#custom#profile('source/grep', 'context', {'no_quit' : 1})

" Use start insert by default.
call unite#custom#profile('default', 'context', {'start_insert' : 1})


={============================================================================
*kt_dev_env_vim_007* vim-set-tagbar-unite-tag (not use)

{unite-tag}
http://majutsushi.github.io/tagbar/
Uses ctag

https://github.com/tsukkee/unite-tag
Get it downloaded and copy tag.vim to
/home/kit/.vim/bundle/unite.vim/autoload/unite/sources where unite installed.


={============================================================================
*kt_dev_env_vim_008* plugins: ycm

{ycm}

https://github.com/Valloric/YouCompleteMe

1. Ensure that your version of Vim is at least 7.3.584 and that it has support for python2
scripting. Might need to build gvim.


={============================================================================
*kt_dev_env_vim_009* plugins: ctrlp

{ctag-ctrlp}

http://blog.stwrt.ca/2012/10/31/vim-ctags

Vim + Ctags + Ctrlp

If you're using the Ctrlp plugin for vim, running :CtrlPTag will let you search through your tags
file and jump to where tags are defined. Very useful when you need to jump around a project in a
hurry.

http://kien.github.io/ctrlp.vim/

___________
basic usage

Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode.
Run :CtrlPBuffer or :CtrlPMRU to start CtrlP in find buffer or find MRU file mode.
Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time.

Check :help ctrlp-commands and :help ctrlp-extensions for other commands. Once CtrlP is open:

Press <F5> to purge the cache for the current directory to get new files, remove deleted files and
apply new ignore options.
* Press <c-f> and <c-b> to cycle between modes.
Press <c-d> to switch to filename search instead of full path.
Press <c-r> to switch to regexp mode.
* Use <c-j>, <c-k> or the arrow keys to navigate the result list.
* Use <c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new ver/hor split.
Use <c-n>, <c-p> to select the next/previous string in the prompt's history.
Use <c-y> to create a new file and its parent directories.
Use <c-z> to mark/unmark multiple files and <c-o> to open them.

Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help.

Submit two or more dots .. to go up the directory tree by one or multiple levels.
End the input with a colon : followed by a command to execute it after opening the file:
  Use :25 to jump to line 25.
  Use :/any\:\ string to jump to the first instance of any: string.
  Use :+setfiletype\ myfiletype|25 to set the filetype to myfiletype then jump to line 25.
  Use :diffthis when opening files marked by <c-z> to run :diffthis on the first 4 files.

___________
intallation

1. Clone the plugin into a separate directory:
$ cd ~/.vim
$ git clone https://github.com/kien/ctrlp.vim.git bundle/ctrlp.vim

2. Add to your ~/.vimrc:
set runtimepath^=~/.vim/bundle/ctrlp.vim

3. Run at Vim's command line:
:helptags ~/.vim/bundle/ctrlp.vim/doc

It's also handy to bind this to a keyboard shortcut. I use this in my ~/.vimrc:

nnoremap <leader>. :CtrlPTag<cr>

http://www.bestofvim.com/plugin/ctrl-p/ and for other extensions

" for ctrlp
" tag
nnoremap ,t :CtrlPTag<cr>
" func list
nnoremap ,c :CtrlPFunky<cr>
" file
nnoremap ,f :CtrlP<cr>
" buffer
nnoremap ,b :CtrlPBuffer<cr>
" mru
nnoremap ,m :CtrlPMRU<cr>
" dir
nnoremap ,d :CtrlPDir<cr>


{ctag-tagbar}

Vim + Ctags + Tagbar

http://majutsushi.github.io/tagbar/

Tagbar is another useful vim plugin for working with a tags file. Install it, and map a key to it (I
use ,b):

nnoremap <silent> <Leader>b :TagbarToggle<CR>

When the tagbar is toggled, it will pop up on the right side of the vim window and show the tags
picked up by ctags for the current file, organized by tag type, e.g. function, variable, class, etc.
This effectively gives you a birds-eye view of the code you're working on.


{ctag-rebuild}

<approach-one>
The following Vim key mapping is quite useful to rebuild the tag file in the directory of the
current source file:

:nmap ,t :!(cd %:p:h;ctags *.[ch])&


={============================================================================
*kt_dev_env_vim_010* plugins: neocomplete

{plugins}

"
" neocomplete

https://github.com/Shougo/neocomplete.vim

Requited by unite-tag. May need to build vim to enalbe lua features and creates caches background
using vimproc.

g:neocomplete#ctags_arguments
It is the dictionary of the character string to set a value to give as an argument of the commands
when buffer and include use a ctags command. The dictionary's key is filetype. If the key is "_", it
will be used for default.

Because it is complicated, refer to neocomplete#init#_variables() in autoload/neocomplete/init.vim
for the initial value.

" Initialize ctags arguments. "{{{
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments',
     \ '_', '')
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments', 'vim',
     \ '--extra=fq --fields=afmiKlnsStz ' .
     \ "--regex-vim='/function!? ([a-z#:_0-9A-Z]+)/\\1/function/'")
 call neocomplete#util#set_default_dictionary(
       \ 'g:neocomplete#ctags_arguments', 'c',
       \ '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' .
       \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
       \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments', 'cpp',
     \ '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '.
     \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
     \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
"}}}


{snippet}

What is the snippet? From snipmate:

Here's a simple example. Once installed, put this in a ~/.vim/snippets/javascript.snippet file:

snippet log
    console.log(${1});

Now when you're editing a .js file, typing log<TAB> will expand into console.log();, and put the
cursor in between the brackets. You're still in insert mode, so you just carry on typing your log
statement.


{ultisnips}

https://github.com/SirVer/ultisnips

.vim/bundle/ultisnips/UltiSnips/cpp.snippets


{when-do-not-use-other-plugins}

Vim's own implementation.

Vim documentation: insert

7. Insert mode completion				*ins-completion*

In Insert and Replace mode, there are several commands to complete part of a keyword or line that
has been typed.  This is useful if you are using complicated keywords (e.g., function names with
capitals and underscores).

These commands are not available when the |+insert_expand| feature was disabled at compile time.


Completion can be done for:

1. Whole lines						|i_CTRL-X_CTRL-L| [KT] works
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							   |i_CTRL-X_CTRL-]| [KT] works
7. file names						|i_CTRL-X_CTRL-F| [KT] works
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N|


 [KT] useful to repeat the same line which typed before. 

Completing whole lines					*compl-whole-line*
							               *i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the same characters as those in the
current line before the cursor.  Indent is ignored.  The matching line is inserted in front of the
cursor.  The 'complete' option is used to decide which buffers are searched for a match.  Both
loaded and unloaded buffers are used.

CTRL-L	or CTRL-P		Search backwards for next matching line.  This line replaces the previous
matching line.

CTRL-N		Search forward for next matching line.  This line replaces the previous matching line.

CTRL-X CTRL-L	After expanding a line you can additionally get the line next to it by typing CTRL-X
CTRL-L again, unless a double CTRL-X is used.  Only works for loaded buffers.


 [KT] works regardless of using completion plugin. uses tag file.

Completing tags						*compl-tag*
							            *i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same characters as before the
cursor.  The matching tag is inserted in front of the cursor.  Alphabetic characters and characters
in 'iskeyword' are used to decide which characters are included in the tag name (same as for a
keyword).  See also |CTRL-]|.  The 'showfulltag' option can be used to add context from around the
tag definition.  

CTRL-]	or CTRL-N		Search forwards for next matching tag.  This tag replaces the previous
matching tag.

CTRL-P		Search backward for previous matching tag.  This tag replaces the previous matching tag.

Can use this mapping:
inoremap <c-x><c-]> <c-]>


Completing file names					*compl-filename*
							               *i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the same characters as before the
cursor.  The matching file name is inserted in front of the cursor.  Alphabetic characters and
characters in 'isfname' are used to decide which characters are included in the file name.  Note:
the 'path' option is not used here (yet).

CTRL-F	or CTRL-N		Search forwards for next matching file name.  This file name replaces the
previous matching file name.

CTRL-P		Search backward for previous matching file name.  This file name replaces the previous
matching file name.

{omni-completion}

omni completion is based on a ctags file. If you want a 'full' C language completion, you need to
first create a tags file scanning /usr/include, /usr/local/include and so on. In my laptop (AMD 64
900 MHz), executing this:

ctags -R -f ~/.vim/systags /usr/include /usr/local/include

takes almost 6 minutes and the generated file is as big as 791M. In addition if you install a new
development library, you will need to scan the .h files to add them to you tags file. Personally I
do not use omni completion as I do not think it is mature enough yet.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*

The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.

From vim7.4

./autoload/ccomplete.vim   " this shows how to access tag data
./autoload/xmlcomplete.vim
./autoload/csscomplete.vim
./autoload/adacomplete.vim
./autoload/clojurecomplete.vim
./autoload/javascriptcomplete.vim
./autoload/pythoncomplete.vim
./autoload/syntaxcomplete.vim
./autoload/sqlcomplete.vim
./autoload/phpcomplete.vim
./autoload/python3complete.vim
./autoload/htmlcomplete.vim
./autoload/rubycomplete.vim

Accessing tag data in vimscript
http://andrewradev.com/2011/06/08/vim-and-ctags/


={============================================================================
*kt_dev_env_vim_011* plugins: indent-guide

https://github.com/nathanaelkane/vim-indent-guides


={============================================================================
*kt_dev_env_vim_012* vim-set-ag

https://github.com/ggreer/the_silver_searcher

Build from source.
0. git clone https://github.com/ggreer/the_silver_searcher
1. apt-get install -y automake pkg-config libpcre3-dev zlib1g-dev liblzma-dev
2. ./build.sh
3. sudo make install


apt-get install silversearcher-ag

<ex>
To get the list of files.

ag --follow --nocolor --nogroup -g ''

<ex>
ag --follow --nocolor --nogroup -g ''           // agignore works
ag --follow --nocolor --nogroup -g <dir> ''     // agignore not works


{man}
SYNOPSIS
       ag [file-type] [options] PATTERN [PATH]

       -i --ignore-case:
            Match case insensitively.

       --vimgrep:
            Output results like vim's :vimgrep /pattern/g would (it reports
                every match on the line).

            Here's a ~/.vimrc configuration example:

                set grepprg=ag\ --vimgrep\ $*
                set grepformat=%f:%l:%c:%m

            Then use :grep to grep for something.
            Then use :copen :cn :cp etc.. to navigate through the matches.

       -f --follow
              Follow symlinks.

       --[no]color
              Print color codes in results. Enabled by `default`.

       --[no]group
              The  `default`,  --group,  lumps multiple matches in the same file
              together, and presents them under a  single  occurrence  of  the
              filename.  --nogroup  refrains from this, and instead places the
              filename at the start of each match line.

              note: single filename
              " use --group
              sctp/ipv6.c
              689:		return sizeof(struct sockaddr_in);
              690:	return sizeof(struct sockaddr_in6);
              998:	.sockaddr_len	   = sizeof(struct sockaddr_in6),
              
              " use --nogroup
              sctp/ipv6.c:689:		return sizeof(struct sockaddr_in);
              sctp/ipv6.c:690:	return sizeof(struct sockaddr_in6);
              sctp/ipv6.c:998:	.sockaddr_len	   = sizeof(struct sockaddr_in6),


       -g PATTERN
              Print filenames matching PATTERN.

       -C --context [LINES]
              Print lines before and after matches. Defaults to 2.

       --hidden
              Search hidden files. This option obeys ignore files.

       --ignore PATTERN:
            Ignore files/directories matching this pattern. Literal file and
            directory names are also allowed.

       -S --smart-case
              Match case-sensitively if there are  any  `uppercase`  letters  in
              PATTERN, case-insensitively otherwise. Enabled by `default`.

       -s --case-sensitive:
            Match case sensitively.

       --pager COMMAND
              Use a pager such as less. Use --nopager to override. This option
              is also ignored if output is piped to another program.

       -t --all-text
              Search all text files. This doesn't include hidden files.

       -u --unrestricted
              Search  all  files.  This ignores .agignore, .gitignore, etc. It
              searches binary and hidden files as well.

       -a --all-types
              Search all files. This doesn't include hidden files, and doesn´t
              respect any ignore files.

       -m --max-count NUM:
            Skip the rest of a file after NUM matches. Default is 10,000.

IGNORING FILES
       By  default, ag will ignore files whose names match patterns in .gitig‐
       nore, .hgignore, or .agignore. These  files  can  be  anywhere  in  the
       directories  being  searched.

       Finally, ag looks in  $HOME/.agignore  for  ignore  patterns. Binary
       files are ignored by `default` as well.

       <option-u>
       If you want to ignore .gitignore, .hgignore, and svn:ignore, but  still
       take .agignore into account, use -U.

       -U --skip-vcs-ignores:
            Ignore VCS ignore files (.gitignore, .hgignore, svn:ignore), but
            still use .agignore.

       Use the -t option to search all text files; -a to search all files; and
       -u to search all, including hidden files.


<keep-color>
$ ag getMediaRecord* | less
$ ag getMediaRecord* | less -r or -R

All doesn't work since it seems ag do not output color esc chars when use pipe.
Use the following commands to around this.

$ ag --pager "less -r" getMediaRecord*


alias ag='ag -C 4 -S --color-path="1;31" --color-match="1;35" --pager "less -r"'

<bug>
$ ag 'SystemClientEvent('     // causes terminal broken
$ ag 'SystemClientEvent\('    // works okay


{ack}
curl http://beyondgrep.com/ack-2.14-single-file > ~/bin/ack && chmod 0755 !#:3


={============================================================================
*kt_dev_env_vim_013* vim-set-netrw

<run-browser>
:let g:netrw_browsex_viewer= "iceweasel"

Use `gx` on a link in vim and vim gets blocked.

<explorer>
To enter explorer mode, enter the command :Explore and a file tree will appear.
You can navigate this tree using j and k and pressing enter.

Press i to toggle the appearance of the file tree. By default, explorer mode
will only show the contents of the current directory.

# ~/.vimrc
let g:netrw_liststyle=3

d     creates a new directory
%     creates and opens a new file
D     deletes a directory or file
R     renames a file
o     opens the file in a horizontal split
v     opens the file in a vertical split


==============================================================================
*kt_dev_env_vim_002*	config

{set-font-for-gvim}

when use bigger screen with gvim, it is hard to read so need to change font. try 'edit->select font'
in the menu to see which is better then set it in .vimrc.

FreeMono, 12pt


{vimrc-linux}

# vars from ver

   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
      user exrc file: "$HOME/.exrc"
  system gvimrc file: "$VIM/gvimrc"
    user gvimrc file: "$HOME/.gvimrc"
    system menu file: "$VIMRUNTIME/menu.vim"
  fall-back for $VIM: "/usr/share/vim"


--
if has("gui_running")
  if has("gui_gtk2")
    set guifont=FreeMono\ 12
  endif
endif

" clipboard
set clipboard=unnamed
set clipboard=unnamedplus

" for user syntax
syntax enable

set incsearch

" set ignorecase
" for line number
set nu

set smartindent
set shiftwidth=4
set tabstop=4

" show autocomplete menus
set wildmenu

" show editing mode
set showmode

colorscheme desert

" help: auto-format
" set formatoptions+=a

set cursorline

set autoread
set hlsearch
set nowrapscan

set foldenable


{vimrc-windows}

:e $VIM\_vimrc
:echo $VIM

--
set nocompatible
filetype on
filetype plugin on
source $VIMRUNTIME/vimrc_example.vim
source $VIMRUNTIME/mswin.vim
behave mswin

set diffexpr=MyDiff()
function MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let eq = ''
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      let cmd = '""' . $VIMRUNTIME . '\diff"'
      let eq = '"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
endfunction

" for user syntax
syntax enable

set incsearch

" set ignorecase
" for line number
set nu

set smartindent
set shiftwidth=4
set tabstop=4

" show autocomplete menus
set wildmenu

" show editing mode
set showmode

colorscheme darkblue
" colorscheme desert

" help: auto-format
" set formatoptions+=a

" to highlight currentline
set cursorline

set autoread
set hlsearch
set nowrapscan

set foldenable
" set foldmethod=syntax
" set foldlevelstart=1
" set foldnestmax=5
" let g:is_bash=1
" let g:sh_fold_enabled=4
" let sh_fold_functions=1

" marks. to save the session info for up to 100 files and not to save global marks
"set viminfo='100,f0

au BufWinEnter,BufRead,BufNewFile *.nds set filetype=nds

" enable fold save and restore
au BufWinEnter *.nds silent loadview
au BufWinLeave *.nds mkview

" to see only matched line. do search first and hit \z
nnoremap \z :setlocal foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\\|\\|(getline(v:lnum+1)=~@/)?1:2 foldmethod=expr foldlevel=0 foldcolumn=2<CR>
--


{option-window}

Like option menu, opens a option window where can change options by using <Enter> to toggle

:options

To get help about options, use singled-quoted help

:help 'option-name'


={============================================================================
*kt_dev_env_vim_097* sample dot vimrc files

https://github.com/whiteinge/dotfiles/blob/master/.vimrc

https://github.com/eddie/dotfiles/blob/master/vim/vimrc


={============================================================================
*kt_dev_env_vim_098* key mapping: traverse a list

Typing :bn and :bp can feel laborious. To speed things up a bit, I use these mappings from Tim
Pope's unimpaired.vim plugin: https://github.com/tpope/vim-unimpaired

nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

Vim already uses the [ and ] keys as prefixes for a series of related commands (see :h [ ), so these
mappings have a consistent feel to them. The unimpaired.vim plugin provides similar mappings for
scrolling through the argument( [a and ]a ), quickfix ([q and ]q ), location ( [l and ]l ), and tag
lists ( [t and ]t ). Check it out.

map <C-n> :cn<CR>
map <C-p> :cp<CR>


={============================================================================
*kt_dev_env_vim_099* key mapping

http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29

See notation when use mapping. Must enter <F5> by typing four characters. Similarly, <Esc> is not
entered by pressing the <Esc> key, but by typing five characters.


{key-mapping}
Key mapping refers to creating a shortcut for repeating a sequence of keys or commands. You can map
keys to execute frequently used key sequences or to invoke an Ex command or to invoke a Vim function
or to invoke external commands. 

The general syntax of a map command is: 

{cmd} {attr} {lhs} {rhs}

where
{cmd}  is one of ':map', ':map!', ':nmap', ':vmap', ':imap',
       ':cmap', ':smap', ':xmap', ':omap', ':lmap', etc.

{attr} is optional and one or more of the following: <buffer>, <silent>,
       <expr> <script>, <unique> and <special>.
       More than one attribute can be specified to a map.

{lhs}  left hand side, is a sequence of one or more keys that are being mapped.
{rhs}  right hand side, is the sequence of keys that the {lhs} keys are mapped to.
note: map lhs to rhs.

Examples:

map <F2> :echo 'Current time is ' . strftime('%c')<CR>
nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR>

Three steps to define maps:

The first step in creating a map is to decide the sequence of keys that needs to be mapped. When you
invoke a map, Vim will execute the sequence of keys as though you entered it from the keyboard. You
can do this by manually entering the key sequence and verifying that they perform the desired
operation.

The second step is to decide the editing mode; insert mode, visual mode, command-line mode, normal
mode, etc. in which the map should work. Instead of creating a map that works in all the modes, it
is better to define the map that works only in selected modes.

The third step is to find an unused key sequence that can be used to invoke the map. You can invoke
a map using either a single key or a sequence of keys. :help map-which-keys 


{what-keys-to-map} h: map-which-keys
If you are going to map something, you will need to choose which key(s) to use for the {lhs}. You
will have to avoid keys that are used for Vim commands, otherwise you would not be able to use those
commands anymore. Here are a few suggestions:

@ Function keys <F2>, <F3>, etc..  Also the shifted function keys <S-F1>, <S-F2>, etc.  Note that
<F1> is already used for the help command.

@ Meta-keys (with the ALT key pressed).  Depending on your keyboard accented characters may be used
as well. |:map-alt-keys|

@ Use the '_' or ',' character and then any other character.  The "_" and "," commands do exist in
Vim (see |_| and |,|), but you probably never use them.

@ Use a key that is a synonym for another command. For example: CTRL-P and CTRL-N. Use an extra
character to allow more mappings.

@ The key defined by <Leader> and one or more other keys. This is especially useful in scripts.
|mapleader|


<to-check-if-key-used>
See the file "index" for keys that are not used and thus can be mapped without losing any builtin
function. You can also use ":help {key}^D" to find out if a key is used for some command. {key} is
the specific key you want to find out about, ^D is CTRL-D.


{slient-key}
http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_2%29

When a map is invoked, the sequence of keys executed is displayed on the screen. If an Ex command is
invoked by the map, then you can see the Ex command at the Vim status line. To silently execute a
map, use the <silent> attribute for the map.


{leader-key}
If the key maps provided by all the Vim plugins start with a same key, then it is easier for a user
to distinguish between his own key maps and the ones provided by plugins. To facilitate this, Vim
provides a special keyword that can be used in a map command.

If the {lhs} key sequence of a map command starts with the string "<Leader>", then Vim replaces it
with the key set in the 'mapleader' variable.

The default setting for the 'mapleader' variable is backslash ('\'). Note that 'mapleader' is a Vim
variable and not a Vim option. The value of this variable can be changed using the 'let' command.
For example, to set it to '_' (underscore), you can use the following command in your vimrc file:

let mapleader = "_"

Vim replaces <Leader> with the 'mapleader' value only when defining the map and not when the map is
invoked. This means that after several map commands are defined if the 'mapleader' variable is
changed, it will not affect the previously defined maps. 

Vim provides the <Leader> key as a namespace for our own user-defined commands. Here is how we can
create our own custom mappings using <Leader> :

noremap <Leader>n nzz
noremap <Leader>N Nzz

note: nmap <silent> <leader>s :set spell<CR> and leader or Leader will work?

The default leader key is \ , so we could trigger these custom mappings by pressing \n and \N.


{list-key-maps} vim-modes
The ':map' command creates a key map that works in normal, visual, select and operator pending
modes. The ':map!' command creates a key map that works in insert and command-line mode. 

To display the mode specific maps, prefix the ':map' command with the letter representing the mode. 

:nmap - Display normal mode maps
:imap - Display insert mode maps
:vmap - Display visual and select mode maps
:smap - Display select mode maps
:xmap - Display visual mode maps
:cmap - Display command-line mode maps
:omap - Display operator pending mode maps

The following characters may be displayed before the {rhs} of the map: 

<noremap>
The {rhs} of the map is not re-mappable. Defined using the ':noremap' or ':nnoremap' or ':inoremap',
etc. commands.

To display all the key maps that start with a particular key sequence, enter the key sequence in the
above commands. For example, the following command displays all the normal mode maps that start with
'g'.

:nmap g

Typically the output of the above commands will span several pages. You can use the following set of
commands to redirect the output to the vim_maps.txt file:

<redirection>
:redir! > vim_maps.txt
:map
:map!
:redir END


{removing-keymap} to check if mapping exist
To permanently remove a map, you first need to locate the place where it is defined by using the
':verbose map {lhs}' command (replace {lhs} with the mapped key sequence). 

note: difference from the other way above? 

Another approach is to use the ':unmap' and ':unmap!' commands to remove the map

:unmap <F8>
:unmap! <F8>

:nnoremap [unite] <nop>

note that after a key is unmapped using the ':unmap' command, it can be mapped again later. Also you
cannot unmap a key used by one of the Vim internal commands. Instead you have to map it to <Nop> to
disable it's functionality.

If you are trying to disable a key map defined by a plugin, make sure the unmap command is executed
after the key map is defined by the plugin. To do this in .vimrc, use autocmd:

autocmd VimEnter * unmap! <F8>

Filetype plugins can be a little tricky, because they can redefine mappings any time you open a file
of a certain type. You can just use a different autocmd event for this, e.g.:

autocmd FileType python unmap! <F8>

The mode-specific unmap commands are listed below:

nunmap - Unmap a normal mode map
vunmap - Unmap a visual and select mode map
xunmap - Unmap a visual mode map
sunmap - Unmap a select mode map
iunmap - Unmap an insert and replace mode map
cunmap - Unmap a command-line mode map
ounmap - Unmap an operator pending mode map

____________________
storing the key maps

If you want to restore the key maps across Vim instances, you need to save the map definition
command in a file.

One place to store the map commands is the $HOME/.vimrc or $HOME/_vimrc or $VIM/_vimrc file. If you
have <filetype-specific-key-maps>, then you can store them in the filetype specific plugin files.
The key maps defined by Vim plugins are stored in the plugin or script file itself.

When adding the map commands to a file, there is no need to prefix the commands with the ':' character. 


{mode-specific-maps}
Commands                         Mode
--------                         ----
nmap, nnoremap, nunmap           Normal mode
imap, inoremap, iunmap           Insert and Replace mode
vmap, vnoremap, vunmap           Visual and Select mode
xmap, xnoremap, xunmap           Visual mode only
smap, snoremap, sunmap           Select mode only
cmap, cnoremap, cunmap           Command-line mode
omap, onoremap, ounmap           Operator pending mode
:map!  :noremap! :unmap!         Insert and Command-line
:map   :noremap  :unmap          Normal, Visual, Select, Operator-pending

Note that the language specific mappings defined using the ':lmap' and ':lnoremap' commands are not
discussed here. For more information about this refer to the Vim help. 

<example> 
@ maps the <F5> key to search for the keyword under the cursor in the current directory using the
grep command. note: works and useful

:nnoremap <F5> :grep <C-R><C-W> *<CR>

From a normal mode map, you can get the keyword under the cursor using the expand('<cword>')
function or using the <C-R><C-W> command. For example, the following two map commands provide the
same functionality

@ maps ',b' to show the buffer list and invoke the ':buffer' command to switch to the desired
buffer number and hit <Enter>.  note: see mutiple actions.

:nnoremap ,b :ls<CR>:buffer<Space>

If you invoke an Ex command from a map, you have to add a <CR> or <Enter> or <Return> at the end of
the Ex command to execute the command. Otherwise the command will not be executed. ls command in the
above example.

note: this example: ls<cr> shows buffer list and buffer<space> waits input from user. so select
buffer when give buffer_number<cr>.


:map! <F3> a<C-R>=strftime('%c')<CR><Esc>
maps the <F3> key to insert the current date and time in the current buffer. 


{useful-examples}
you need to change a word such as "amount" into "{amount}":

:map <F5> i{<Esc>ea}<Esc>


{trigger-key}
The trigger can be 'any' string. One key that can be used with mappings is the backslash. Since you
probably want to define more than one mapping, add another character. You could map "\p" to add
parentheses around a word, and "\c" to add curly braces, for example:

:map \p i(<Esc>ea)<Esc>
:map \c i{<Esc>ea}<Esc>

You need to type the \ and the p quickly after another, so that Vim knows they belong together.

note: is to expand the set of keys to map. \ is an example.

map <C-\>^] :GtagsCursor<CR>

note: can use this and C-o instead of using tag stack. However, it uses jump list rather than tag
stack so if you move around tags lists using C-n this will also in the jump list so not quite the
same as the tag stack.

map <C-]> :GtagsCursor<CR>


{exe-and-expand}
This map uses the expand() function to get the keyword under the cursor and then invokes the "tag"
command with the current keyword. The "execute" command is used to concatenate the tag command and
the output of the expand() function

:nnoremap <2-LeftMouse> :exe "tag ". expand("<cword>")<CR>

This mapping yanks the visually selected text and searches for it in C files. This is a complicated
mapping: 

vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>


# ============================================================================
#{
={============================================================================
*kt_dev_env_vim_100* helps

{help-doc}
http://vimdoc.sourceforge.net/htmldoc/usr_01.html#vimtutor


{help}

:help {subject}
:help CTRL-A         # for normal mode cmds
:help i_CTRL-H       # mode prefix. for insert mode cmds

shift-k (K) cmd. study.

<search-in-help>
:h {patt} then press Ctrl-D to list all topics that contain "patt".
:h {patt} then press Tab to scroll through the topics that start with "patt". 

Sometimes you want to know what a particular control key means to Vim. For example, to see all help
topics containing "ctrl-r", type :h ctrl-r then press Ctrl-D. 

<navigate-in-help>
<C-]>    " to follow the link (jump to the quickref topic). After browsing the quickref topic,
<C-T>    " to go back to the previous topic.


={============================================================================
*kt_dev_env_vim_101* dot command

The help says that "repeat last change" but need to understand what this change means. This includes
any changes by running any commands which 'create' a change such as normal mode commands and
i{insert some text}<ESC> command. For example, 'x', 'dd', '>G', and 'i change text esc'.

So the dot command is like a mini macro.


<example>
How to add ';' at the end of each line?

var foo = 1
var bar = 'a'
var foobar = foo + bar

1. run '$a;<ESC>' and 'j$.' on the rest. This still needs '$' to position a cursor to do the repeat.
Is there a better way to save more key strokes?

2. run 'A;<ESC>' and 'j.' on the rest. This saves one more by using the compound commands. Here
'A==$a'. See <compound-command> for more.

note: As shown in tip26, can use visual block mode to do the same. Position at 1 in line 1, <C-v>jj,
$, A;, <ESC>

<example>
Change:
var foo = "method("+argument1+","+argument2+")";

To:
var foo = "method(" + argument1 + "," + argument2 + ")";

1. 'f+', 's<SP>+<SP><ESC>', ';.', ';.'... See <motion-char-move> for f command.


<key>
The key is that can achieve an optimal editing strategy by making both the motion and the change
repeatable. note that focus on 'make' the change repeatable. Vim is optimized for repetition. In
order to exploit this, we have to be 'mindful' of how we compose our changes.

<example>
Change 'content' all to 'copy'.

...We're waiting for content before the site can go live...
...If you are content with this, let's go ahead with it...
...We'll launch as soon as we have the content...

Can use blindly substitude command but the point is we have to watch our for false matches. The
alternative is to use dot command instead.

1. Place cursor at content, '*', 'cwcopy<ESC>', n, ., ...


<dot-fomular>
The Ideal: One Keystroke to Move, One Keystroke to Execute

In all of these examples, using the dot command repeats the last change. But that's not the only
thing they share. A single keystroke is all that's required to move the cursor to its next target.
We're using one keystroke to move and one keystroke to execute. It can't really get any better than
that, can it? It's an ideal solution. We'll see this editing strategy coming up again and again, so
for the sake of convenience, we'll refer to this pattern as the Dot Formula.


={============================================================================
*kt_dev_env_vim_102* chunk your undo

u        " undo
<C-r>    " redo


{granularity-of-the-undo-command}
The key is that i{insert some text}<Esc> constitutes a change. In Vim, we can control the
granularity of the undo command. From the moment we enter Insert mode until we return to Normal
mode, everything we type (or delete) counts as a single change. So we can make the undo command
operate on words, sentences, or paragraphs just by moderating our use of the <Esc> key.

<by-sentence>
So how often should you leave Insert mode? It's a matter of preference, but I like to make each
"undoable chunk" correspond to a thought. As I write this text, I often pause at the end of a
sentence to consider what I'll write next.

<by-line>
If I'm in Insert mode with my cursor at the end of a line, the quickest way to open a new line is to
press <CR>. And yet I sometimes prefer to press <Esc>o just because I anticipate that I might want
that extra granularity from the undo command.

note:
Moving Around in Insert Mode Resets the Change

When I said that the undo command would revert all characters entered (or deleted) during a trip
into Insert mode and back, I was glossing over a small detail. If we use the <Up> , <Down> , <Left>
, or <Right> cursor keys while in Insert mode, a new undo chunk is created. It's just as though we
had switched back to Normal mode to move around with the h , j , k , or l commands, except that we
don't have to leave Insert mode. This also has implications on the operation of the dot command.


={============================================================================
*kt_dev_env_vim_103* operator, text object and motion

{operator} :h operator
Operator + Motion = Action

The {[prefix]operator}{motion} pattern. You first type an operator command. For example, 'd' is the
delete operator. Then you type a motion command like '4l' or 'w'. This way you can operate on any
text you can move over.

{text-object} :h text-objects
A special kind of motion. You can find a long list of text objects from help text-objects. Only be
used while in visual mode or after an operator.

Text objects are the next level up. If the f{char} and /pattern<CR> commands are like a flying kick
to the head, then text objects are like a scissors kick that strikes two targets with a single move.

<text-object-on-whole>
When the cursor is in the middle of a word and you want to delete that word. Instead of operating on
the text between the cursor position before and after a movement command, the text object is used as
a 'whole'. 

Unlike visual mode and motion, when we press vi}, Vim initiates Visual mode and then selects all of
the characters contained by the {} braces. Where the cursor is positioned to begin with doesn't
matter so long as it's located somewhere inside a block of curly braces when the i} text object is
invoked.

<bounded-text-object>
Words, sentences, and paragraphs are defined by boundaries, so I've labeled this category as bounded
text objects (Vim's documentation calls them "block" and "non-block" objects, but I find that to be
an unhelpful distinction).

iw    " Current word
aw    " Current word 'plus' one space
iW    " Current WORD
aW    " Current WORD plus one space
is    " Current sentence
as    " Current sentence plus one space
ip    " Current paragraph
ap    " Current paragraph plus one blank line

The example shows when 'aw' is useful. note that daw deletes a word including a space. If we used
diw instead, then we'd end up with two adjacent spaces

{start}  Improve your writing by deleting excellent adjectives.
                                           ^
daw      Improve your writing by deleting adjectives.

The example shows when 'iw' is useful.

{start}        Improve your writing by deleting excellent adjectives.
                                                 ^
ciwmost<Esc>   Improve your writing by deleting most adjectives.

As a general rule, we could say that the d{motion} command tends to work well with aw, as, and ap,
whereas the c{motion} command works better with iw and similar.


<inner-and-around>
Always either i or a. In general, we can say that the text objects prefixed with i select 'inside'
the delimiters, whereas those that are prefixed with a select everything including the delimiters.
As a mnemonic, think of i as inside and a as 'around' (or all). Can span multiple lines.

a) or ab       " A pair of (parentheses)
i) or ib       " Inside of (parentheses)
a} or aB       " A pair of {braces}
i} or iB       " Inside of {braces}
a]             " A pair of [brackets]
i]             " Inside of [brackets]
a>             " A pair of <angle brackets>
i>             " Inside of <angle brackets>
aâ             " A pair of 'single quotes'
iâ             " Inside of 'single quotes'
a"             " A pair of "double quotes"
i"             " Inside of "double quotes"
at             " A pair of <xml>tags</xml>
it             " Inside of <xml>tags</xml>


if( !entry.used && equiv && ( curcontext & entry.contexts))
            ^ cursor
if( !entry.used && equiv && ( curcontext & entry.contexts))
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ selected when run 'vib'

<img src="whi-vi-img/why-vi-1.gif" alt=""/>
                 ^ cursor
<img src="whi-vi-img/why-vi-1.gif" alt=""/>
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ selected when run 'vi>'

<text-object-in-command>
Visual mode makes for a nice introduction to text objects because it's easy to see what's happening.
But text objects reveal their true power when we use them in Operator-Pending mode.

Text objects are not motions themselves: we can't use them to navigate around the document. But we
can use text objects in Visual mode and in Operator- Pending mode. Remember this: whenever you see
{motion} as part of the syntax for a command, you can also use a text object.


<action-examples>
dw       " d{w} word. != daw since dw delete a word from the cursor but daw do as a whole
d4w
d2e
d$
d2l      " character
daw      " delete a word
das      " delete a sentence

gUaw     " gU{aw}, make uppercase a word
guaw
g~       " swap case

c        " change
c$

d        " delete
d$
dG       " delete to the end of file

y        " yank into register (does not change the text)
>        " shift right
<        " shift left
=        " autoindent
!        " filter {motion} lines through an external program

<on-current-line> double operator
Vim's grammar has just one more rule: when an operator command is invoked in duplicate, it acts upon
the current line. So dd deletes the current line, while >> indents it. The gU command is a special
case. We can make it act upon the current line by running either gUgU or the shorthand gUU.

cc       " change a whole current line
dd 
g~g~     " swap a case of a whole line

<compound-command> single letter command
Some operator motion commands are used so often that they have been given a single letter command:

x     dl  (delete character under the cursor)
X     dh  (delete character left of the cursor)
D     d$  (delete to end of the line)

note: The below all switch from Normal to Insert mode. Think about that and how it might affect the
dot command.

C     c$  (change to end of the line) note: change(delete and insert)
s     cl  (substitute, change one character)
S     cc  (substitute, change a whole line)
o     A<CR>
O     ko
I     start insert mode after moving the cursor to the first non-blank in the line.
A     start insert mode after moving the cursor to the end of the line.


<custom-operator-and-motion>
See page 25 in the practical vim.


{motion-char}
On the current line.

[num]f[char]   " 'find' char to the right the cursor in the line.
[num]F[char]   " 'find' char to the left the cursor in the line.

[num]t[char]   " the same f cmd but 'till' find the char. That is before the char to search
[num]T[char]   " 

[num];         " 'repeat' latest f, t, F or T [count] times.
,              " 'repeat' latest f, t, F or T in 'left' direction [count] times.

<example> 
{start}     I've been expecting you, Mister Bond.
f,          I've been expecting you, Mister Bond.
                                   ^
dt.         I've been expecting you.

In general, I tend to use f{char} and F{char} in Normal mode when I want to move the cursor quickly
within the current line, whereas I tend to use the t{char} and T{char} character search commands in
combination with d{motion} or c{motion}. To put it another way, I use f and F in Normal mode, and t
and T in Operator-Pending mode.

<tip>
But their efficiency varies depending on our choice of target. If we can make a habit of choosing
'less' common characters for use with the f{char} command, then weâll be more likely to strike our
target with a single move.

How to delete 'excellent' from the below?

Improve your writing by deleting excellent adjectives.

fx, daw but not fe...


{motion-line}
0     " to first character of real line
^     " to first 'nonblank' character of real line
$     " to end of real line
G     " to the last line of the file
gg    " to the top of the file


{motion-word} :h word-motions

w, W     " Forward to start of next word.               
b, B     " Backward to start of current/previous word
e, E     " Forward to end of current/next word
ge, gE   " Backward to end of previous word

<word-WORD>
A word consists of a sequence of letters, digits, and underscores, or as a sequence of other
nonblank characters separated with whitespace (see :h word). The definition of a WORD is simpler: it
consists of a sequence of nonblank characters separated with 'whitespace' (see :h WORD). 

e.g. we're going too slow

That example contains five WORDS and ten words since words stops at . and '.

<tip>
The 'iskeyword' option specifies which characters can appear in a word:

:set iskeyword
   iskeyword=@,48-57,_,192-255 

The "@" stands for all alphabetic letters. "48-57" stands for ASCII characters 48 to 57, which are
the numbers 0 to 9. "192-255" are the printable latin characters. Sometimes you will want to include
a dash in keywords, so that commands like "w" consider "upper-case" to be one word.  You can do it
like this:

:set iskeyword+=-
:set iskeyword
   iskeyword=@,48-57,_,192-255,- 

To remove:

:set iskeyword-=_

<key>
Which is better? Since word is wider than WORD, can move with fewer keys. Use WORD-wise motions if
you want to move faster, and use word-wise motions if you want a more fine-grained traversal. The
choice depends on cases.


{motion-search}
The serach is also motion.

before:
This phrase takes time but
eventually gets to the point.

after:
This phrase gets to the point.

To ways:
1. place cursor on t, "v, /g<CR>, h, d" note: can use serach in visual mode
2. "d/g<CR>"   note: not ":d/g<CR>"

The search command is an exclusive motion. That means that even though our cursor ends up on the "g"
at the start of the word "gets," that character is excluded from the delete operation (see :h
exclusive).


<repeatable-actions-and-how-to-reverse-them>
Intent                                 Act                  Repeat Reverse
Make a change                          {edit}                  .     u
Scan line for next character           f{char}/t{char}         ;     ,
Scan line for previous character       F{char}/T{char}         ;     ,
Scan document for next match           /pattern<CR>            n     N
Scan document for previous match       ?pattern<CR>            n     N
Perform substitution                   :s/target/replacement   &     u
Execute a sequence of changes          qx{changes}q            @x    u

<MAPPING>
To break the habit of using the arrow keys, try putting this in your vimrc file. This maps each of
the arrow keys to do nothing.

noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>


={============================================================================
*kt_dev_env_vim_104* operator pending mode

Normal, Insert, and Visual modes are readily identified, but Vim has other modes that are easy to
overlook. Operator-Pending mode is a case in point.

For example, we invoke it when we run the command dw. It lasts during the brief interval between
pressing d and w keys.

Operator-Pending mode is a state that accepts 'only' motion commands. It is activated when we invoke
an operator command, and then nothing happens until we provide a motion, which completes the
operation. While Operator-Pending mode is active, we can return to Normal mode in the usual manner
by pressing escape, which aborts the operation.

Many commands are invoked by two or more keystrokes (for examples, look up :h g, :h z , :h ctrl-w ,
or :h [ ), but in most cases, the first keystroke merely acts as a prefix for the second. These
commands don't initiate Operator-Pending mode. Instead, we can think of them as namespaces that
expand the number of available command mappings. Only the operator commands initiate
Operator-Pending mode.

Why, you might be wondering, is an entire mode dedicated to those brief moments between invoking
operator and motion commands, whereas the namespaced commands are merely an extension of Normal
mode? Good question! Because we can create custom mappings that initiate or target Operator-Pending
mode. In other words, it allows us to create custom operators and motions, which in turn allows us
to expand Vim's vocabulary.


={============================================================================
*kt_dev_env_vim_105* commands in insert mode

In Insert mode, the backspace key works just as you would expect: it deletes the character in front
of the cursor. The following chords are also available to us:

Keystrokes     Effect
<C-h>          delete back one character (backspace)
<C-w>          delete back one word
<C-u>          delete back to start of line

These commands are not unique to insert mode or even to Vim. We can also use them in Vim's command
line as well as in the bash shell. 

note: these works on text from where insert mode starts.


={============================================================================
*kt_dev_env_vim_106* normal mode and insert normal mode

{normal-mode-switch}
<Esc>    switch to Normal mode
<C-[>    switch to Normal mode


{insert-normal-mode} :h i_CTRL-O
When we're in Insert mode and we want to run only one Normal command and then continue where we left
off in Insert mode.

<C-o>    switch to Insert Normal mode

redraws the screen with the current line in the middle of the window, which puts me straight back
into Insert mode so that I can continue typing uninterrupted

<C-o>zz


={============================================================================
*kt_dev_env_vim_100* vim-cfg-remap-capslock

See Remap the Caps Lock Key in p30

For Vim users, the Caps Lock key is a menace. If Caps Lock is engaged and you
try using the k and j keys to move the cursor around, you'll instead trigger the
K and J commands. Briefly: K looks up the man page for the word under the
cursor, and J joins the current and next lines together. It's surprising how
quickly you can mangle the text in your buffer by accidentally enabling the Caps
Lock key!

Many Vim users remap the Caps Lock button to make it act like another key, such
as <Esc> or <Ctrl>.  On modern keyboards, the <Esc> key is difficult to reach,
whereas the Caps Lock key is handy.  Mapping Caps Lock to behave as an <Esc> key
    can save a lot of effort, especially since the <Esc> key is so heavily used
    in Vim. I prefer to map the Caps Lock button to behave instead as a <Ctrl>
    key.  The <C-[> mapping is synonymous with <Esc> , and it's easier to type
    when the <Ctrl> key is within easy reach.  Additionally, the <Ctrl> key can
    be used for many other mappings, both in Vim and in other programs too.

The simplest way to remap the Caps Lock key is to do it at the 'system' level. 


<check-code-value>
When use "xev" to find out the 'keycode' value for capslock key on ubuntu.

KeyRelease event, serial 38, synthetic NO, window 0x3800001,
    root 0x136, subw 0x0, time 16879367, (557,210), root:(559,305),
    state 0x2, 'keycode' 66 (keysym 0xffe5, Caps_Lock), same_screen YES,
    XLookupString gives 0 bytes: 
    XFilterEvent returns: False

http://c2.com/cgi/wiki?RemapCapsLock
Many people don't want a CapsLock key at all. They can change the CapsLock key
to a ControlKey by using the following lines in xmodmap:

$ cat .xmodmap 
clear Lock
keycode 66 = Control_L
add Control = Control_L       

note: Control_L and Control_R differs and keycode 66 is used which is system
dependant.


<where-to-put>
note: Have the above in "~/.xmodmap" and source it in ~/.bashrc. However,
whenever open a tab from gnometermial see errors as described below.

http://www.peterbe.com/plog/blogitem-041021-1
JW - 14 December 2014 [«« Reply to this]
For people stumbling upon this post, 4 years later:

The problem "please release the following keys within 2 seconds:" happens when
the xmodmap command is executed while the keys are held down. By adding the
commands to ~/.bashrc, they are executed 'each' time a terminal is opened,
causing this error to appear each time.

In fact, you only want to run the xmodmap command once, when you log in. So, add
it to ~/.bash_profile or ~/.profile instead (these are only run once)! Also make
sure you don't include .profile from .bashrc


<check-mapping> How to check key mappings?

$ xmodmap -pke
$ xmodmap -pke | ag '66'

This option indicates that the current keymap table  should  be printed  on the
standard output in the form of expressions that can be fed back to xmodmap.

note: As advised, added in ~/.bash_profile but found that this file is 'not'
source. Why?

http://askubuntu.com/questions/121073/why-bash-profile-is-not-getting-sourced-when-opening-a-terminal
~/.bash_profile is 'only' sourced by bash when started in interactive login
mode. That is typically only when you login at the console (Ctrl+Alt+F1..F6), or
connecting via ssh.

When you log in 'graphically', ~/.profile will be specifically sourced by the
script that launches gnome-session (or whichever desktop environment you're
        using). So ~/.bash_profile is not sourced at all when you log in
graphically.

When you open a terminal, the terminal starts bash in (non-login) interactive
mode, which means it will source ~/.bashrc.

The right place for you to put these environment variables is in ~/.profile, and
the effect should be apparent next time you log in.

Sourcing ~/.bash_profile from ~/.bashrc is the wrong solution. It's supposed to
be the other way around; ~/.bash_profile should source ~/.bashrc.

See DotFiles for a more thorough explanation, including some history of why it
is like it is.  http://mywiki.wooledge.org/DotFiles

note: When move to ~/.profile works as excepted. 

// .profile or .bash_profile
xmodmap ~/.xmodmap                                                              


<do-the-same-in-windows>
http://superuser.com/questions/949385/map-capslock-to-control-in-windows-10
Save x.reg and run it.

--
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
"Scancode Map"=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00
--


={============================================================================
*kt_dev_env_vim_100* vim-cfg-reload-vimrc

In general, to re-load the currently active .vimrc, use the following. see
Daily Vim

:so $MYVIMRC

If you want to know what your current vimrc is, just do the following.

:echo $MYVIMRC 


={============================================================================
*kt_dev_env_vim_108* use register in insert mode or command input

To paste text from a register while in insert mode. :h i_CTRL-R
<C-r>{register}


{in-insert-mode}
Keystrokes  Buffer Contents
yt,         Practical Vim, by Drew Neil         " copied "Practical Vim" since 't,'
            Read Drew Neil's
jA<SP>      Practical Vim, by Drew Neil         " still in insert mode
            Read Drew Neil's 
<C-r>0      Practical Vim, by Drew Neil
            Read Drew Neil's Practical Vim
.<Esc>      Practical Vim, by Drew Neil
            Read Drew Neil's Practical Vim.


{in-command-input}
Can use it in the vim command input line since it's the input mode.

When you press <C-r> you will see "(quote) to prompt you to finish the command by entering a
register. For example, <C-r> then 'a' to insert the contents of the 'a' register, or <C-r> then
"(this is a register name) to insert the contents of the unnamed register.

You can press v then move the cursor to visually select some text (say the text is "hello world").
If you press y the selected text is yanked (copied) into the <unnamed register(")> You can now type
:%s/<C-r>" (Ctrl-R quote) and then '"' or '0' which is the register name.

<C-r> <C-w>    " to paste the word under the cursor into the command line
<C-r> <C-a>    " to paste the WORD under the cursor into the command line. :h c_CTRL-R_CTRL-W

<tip>
try opening your vimrc file, place your cursor on a setting, and then type :help <C-r><C-w> to look
up the documentation for that setting.


{for-charwise-register}
If the 'textwidth' or 'autoindent' options are enabled, you might end up with unwanted line breaks
or extra indentation. The <C-r><C-p>{register} command is smarter. It inserts text literally and
fixes any unintended indentation (see :h i_CTRL-R_CTRL-P ). But it's a bit of a handful!  If I want
to paste a register containing multiple lines of text, I prefer to switch to Normal mode and use one
of the put commands


={============================================================================
*kt_dev_env_vim_109* expression register

Can evaluate a piece of Vim script code and return the result in 'insert' mode. The expression
register is addressed by the = symbol.

Keystrokes        Buffer Contents
A                 6 chairs, each costing $35, totals $
<C-r>=6*35<CR>    6 chairs, each costing $35, totals $210


={============================================================================
*kt_dev_env_vim_110* find out char code value

Find out the numeric code for any character in your document, just place the cursor on it and
trigger the 'ga' command. This outputs a message at the bottom of the screen, revealing the
character code in decimal and hexadecimal notations (see :h ga ).


={============================================================================
*kt_dev_env_vim_111* replace mode

Replace mode is identical to Insert mode, except that it overwrites existing text in the document.
Not all keyboards have an <Insert> key, but if yours does, then you can use it to toggle between
Insert and Replace modes. 'R' command.

f.          Typing in Insert mode extends the line. But in Replace mode
            the line length doesn't change.       ^^^
R, b<Esc>   Typing in Insert mode extends the line, but in Replace mode
            the line length doesn't change.


={============================================================================
*kt_dev_env_vim_112* visual mode

{difference}
From Normal mode, we trigger the change command first and then specify the range as a motion.
Whereas in Visual mode, we start off by making the selection and then trigger the change command.


{mode-selection}
v     " charwise mode
V     " linewise mode
<C-v> " blockwise mode. <C-q> for windows.
gv    " reselect the last visual selection. note: useful?
ggVG  " select whole file

<mode-switch>
Can switch between the different flavors of Visual mode by selecting mode and toggle between Normal
mode and Visual mode when selecting mode twice.

<toggle-end-of-selection>
o     " go to other end of highlighted text

Can use the o key to toggle the free end. This is really handy if halfway through defining a
selection we realize that we started in the wrong place. Rather than leaving Visual mode and
starting afresh, we can just hit o and redefine the bounds of the selection.


{operation-in-visual-mode}
There are commands for visual mode and sometimes do not work as expected. See tip23. For the
repeated work, use commands for normal mode and dot commands.

{start}  <a href="#">one</a>
         <a href="#">two</a>
         <a href="#">three</a>
vit      <a href="#">one</a>
         <a href="#">two</a>
         <a href="#">three</a>
U        <a href="#">ONE</a>
         <a href="#">two</a>
         <a href="#">three</a>

j.
         <a href="#">ONE</a>
         <a href="#">TWO</a>
         <a href="#">THRee</a>

Instead, use 'gUit' for the first and 'j.' for the rest.


={============================================================================
*kt_dev_env_vim_113* command mode: ex commands

This means that we can use Ex commands to make changes without having to move our cursor. But the
greatest feature that distinguishes Ex commands is their ability to be executed across many lines at
the same time. Ex commands strike far and wide. :h ex-cmd-index


{range}
The ex command has a form as :[range]{command} {address} and this range can be line number, pattern
or marks.

<example>
<!DOCTYPE html>
<html>
  <head><title>Practical Vim</title></head>
  <body><h1>Practical Vim</h1></body>
</html>

:[range]print

:1
:p

:$
:p

:3p

:[range]delete

:3d, then we would have jumped to line 3 and deleted it in a single move. The equivalent Normal mode
commands would be 3G followed by dd. So this is one example where an Ex command can be quicker than
a Normal mode command.

note: All range in a command moves cursor so current line changes after.

:{start},{end}
:2,5p

<current-line>
The '.' means the current line and the below print lines from 2 to the end of file.

:2
:.,$p

:2
:.,.+3p

<whole-file>
The '%' means the whole file and print all lines of a file.

:%p      " :1,$p

<pattern-range>
This conform to :{start},{end}p

:/<html>/,/<\/html>/p


{copy-and-move-command}
This seems useful with pre-defined range such as 1, $  but seems difficult with line numbers.

Symbol   Address
1        First line of the file
$        Last line of the file
0        Virtual line above first line of the file
.        Line where the cursor is placed
'm       Line containing mark m
'<       Start of visual selection
'>       End of visual selection
%        The entire file (shorthand for :1,$)

:[range]copy {address}
:[range]move {address}

:t          " t is synonym for copy
:'<,'>t0    " copy the visually selected lines to the start of the file

:t.         " duplicate the current line (similar to Normal mode yyp)

1. The one notable difference between these two techniques for duplicating the current line is that yyp
uses a register, whereas :t. doesn't. I'll 'sometimes' use :t. to duplicate a line when I don't want
to overwrite the current value in the default register.

2. Could have used a variant of yyp to duplicate the line we wanted, but it would require some extra
moving around. We would have to jump to the line we wanted to copy (6G), yank it (yy), snap back to
where we started (<C-o>), and use the put command (p) to duplicate the line. When duplicating a
distant line, the :t command is usually more efficient.

:'<,'>m$    " move visual selection to the end of file


={============================================================================
*kt_dev_env_vim_114* command mode: normal commands

If we want to run a Normal mode command on a series of consecutive lines, we can do so using the
:normal command.

:[range]normal {commands}

As with the example in dot command, need to add ';' at the end of each line. Suppose that there are
too many lines to handle and then normal command is better.

1. 'A;' on the first line, 'jVG' and :'<,'>normal .
2. Or for all lines, ':%normal A;'

Before executing the specified Normal mode command on each line, Vim moves the cursor to the
beginning of the line. So to comment out a whole file:

:%normal i//


={============================================================================
*kt_dev_env_vim_115* command completion and history

{auto-completion}

<C-d>    " list out possible matches. :h c_CTRL-D
<Tab>    " scroll forward
<S-Tab>  " scroll backward through the suggestions


{multiple-commands}
:write | !pwd


{history} 
By default, Vim records the last twenty commands. With memory becoming ever cheaper in today's
computers, we can probably afford to up this limit by changing the history option. Try adding this
line to your vimrc:

set history=200

Note that history is not recorded just for the current editing session. It 'persists' even when we
quit and relaunch Vim (see :h viminfo). Increasing the number of items recorded in history can be
really useful.

<MAPPING>
In addition to the <Up> and <Down> keys, we can also use the <C-p> and <C-n> chords to go backward
and forward through our command history. The advantage of using these mappings is that we don't need
to move our hands from the home row to use them. But there's a disadvantage to the <C-p> and <C-n>
commands: unlike <Up> and <Down>, they don't filter the command history. For example, :se<C-p>

We can get the best of both by creating the following custom mappings:

cnoremap <C-p> <Up>
cnoremap <C-n> <Down>


{command-line-window} :h h cmdwin
Opens a history window but a usual regular buffer which means that can move around and search

Command line window
q:       " open ex 'command' history window from normal mode
q/       " open a 'search' history window from normal mode (to search forward)
q?       " open a search history window from normal mode (to search backward)
<C-f>    " Switch from Command-Line mode to the command-line window
<C-w> c  " close


{command-line-edit}
How to move/edit command line in vim such as ':' prompt? 

:h cmdline-editing

for details. I am listing a few of the interesting non-arrow commands that do something similar to
what you want.

C-B: cursor to beginning of command-line
C-E: cursor to end of command-line
C-W: delete the word before the cursor [useful]
C-U: remove all characters between the cursor position and the beginning of the line

Thanks, that's great. I searched through that help doc and I'm not seeing a way to move back and
forth by word. Do you know if that's available? Ethan Jan 16 '10 at 0:23


={============================================================================
*kt_dev_env_vim_116* vim-cmd-filename

6. Ex special characters. :h cmdline-special

Note: These are special characters in the executed command line. If you want
to insert special things while typing you can use the CTRL-R command. For
example, "%" stands for the `current filename`, while CTRL-R % inserts the
current file name right away in insert mode. See |c_CTRL-R|.

In Ex commands, at places where a file name can be used, the following
characters have a special meaning. These can also be used in the expression
function expand() |expand()|.

The % Is replaced with the current file name.

:!ls "%"
:r !spell "%"

% gives the name of the current file,

To change to the directory of the current file for all windows in vim
:cd %:p:h

To change to the directory of the current file
:cd %:h

Examples, when the file name is "src/version.c", current dir "/home/mool/vim": >
  %:p          /home/mool/vim/src/version.c
  %:h          src
  %:p:h        /home/mool/vim/src
  %:p:h:h      /home/mool/vim

The %< built-in variable, that resolves to the file name without extension. To
switch from a header to a source you can do: 

:e %<.c


={============================================================================
*kt_dev_env_vim_117* vim-edit-fileformat

When open some file made by win apps such as putty, vim shows `^M` at the end
of line. Often people explains that this happens when see windows file under
linux because there is no CR(0xOD) in linux and vim display it as ^M. So to
remove this :%s/^V^M//g 

note: to enter ^M, press crtl-m.

This is not the case when seeing file putty made. Although putty log file has
CR and LF, vim under windows shows ^M. When checked filetype, vims uses
`fileformat`=unix and that is why it displays ^M. When copy this text to other
vim windows in dos filetype, still show ^M because it has CR+CR+LR in the end.

See vim help fileformat. Where is the fileformat when vim is loading file? 

http://vim.wikia.com/wiki/File_format


If diff two files which are nearly the same, diff shows it's totally
different. But used comp tool and showed the expected result. why? 

The reason was the one is unix and the other was dos format. In vim, when
tried to show tabs, do not show difference and can see fileformat using :set
ff.

Also diff -w shows the correct. also cat -v filename shows ^M char. Under
ubunto, can get tool like unix2dos:

sudo apt-get install tofrodos

which provides fromdos and todos


={============================================================================
*kt_dev_env_vim_117* vim-edit-two-files

CTRL-^   Edit the alternate file.  Mostly the alternate file is
         the previously edited file.  This is a quick way to
         toggle between two files.  It is equivalent to ":e #",
         except that it also works when there is no file name.

         If the 'autowrite' or 'autowriteall' option is on and
         the buffer was changed, write it.


={============================================================================
*kt_dev_env_vim_117* vim-edit-autowrite

'autowrite' 'aw' boolean (default off)

Write the contents of the file, if it has been modified, on each
:next, :rewind, :last, :first, :previous, :stop, :suspend, :tag, :!,
:make, CTRL-] and CTRL-^ command; and when a :buffer, CTRL-O, CTRL-I,
'{A-Z0-9}, or `{A-Z0-9} command takes one to another file.
Note that for some commands the 'autowrite' option is not used, see
'autowriteall' for that.


={============================================================================
*kt_dev_env_vim_117* exit, file and buffer

{buffer}
Instead, we're editing an in-memory representation of a file, which is called a buffer in Vim's
terminology.

<buffer-commands>
:ls
:bnext
:bprev
:b [num]


The % symbol indicates which of the buffers is visible in the current window, while the # symbol
represents the alternate file. We can quickly toggle between the current and alternate files by
pressing <C-^>. note: alternate between two; current and the previous buffer.
+ sign indicates that it has been modified.

<hidden-buffers> tip38
These are buffers which are modified when switches bufffers but not saved yet.
Options are:

:w[rite]    " write the contents of the buffer to disk
:e[dit]!    " read the file from disk back into the buffer (that is, revert changes)
:e          " reload the current file.
:qa[ll]!    " close all windows, discarding changes without warning
:wa[ll]     " write all modified buffers to disk


{file-commands}
:saveas move.c


{file-info}
<C-g>

{exit}
ZZ
Write current file, if modified, and quit. note: same as ":x"). If there are several windows for the
current file, the file is written if it was modified and the window is closed.

:wqall   " save all and quit
:qall!


={============================================================================
*kt_dev_env_vim_118* vim-window and tab

{open-new-window}
:new           " hori
:vnew          " vert

:h tabpage.txt


{windo}
Do a command in all buffers or windows in the current tab.

:windo set tw=100


{window}
In Vim's terminology, a window is a viewport onto a buffer. :h window

<C-w>v   " command to split the window vertically. :vsp[lit]
<C-w>s   " command to split the window horizentally. :sp[lit]

<window-switch>
For the complete list, see :h window-move-cursor.

<C-w>w   <C-w><C-w>  " Change focus between open windows. :h CTRL-W_w
<C-w>r               " Rotate place between open windows. 
<C-w>h               " Focus the window to the left
<C-w>j               " Focus the window below
<C-w>k               " Focus the window above
<C-w>l               " Focus the window to the right

The useful mapping is:

map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l


<window-close>
:cl[ose]    <C-w>c    " Close the active window. :quit
:on[ly]     <C-w>o    " Keep only the current window, closing all others

<window-size> :h window-resize
<C-w>=      " Equalize width and height of all windows
<C-w>_      " Maximize height of the active window
<C-w>|      " Maximize width of the active window

<window-rearrange> :h window-moving
<C-w> H     " move current window to far left
<C-w> J     " move current window to bottom
<C-w> K     " move current window to top
<C-w> L     " move current window to far right


{screen}
<C-d>       " down half screen :h scroll-down
<C-u>       " up half screen (backward)
<C-f>       " down full screen
<C-b>       " up full screen (backward)

zz          " make the current line center
zb          " make the current line bottom
zt          " make the current line top


{tab} :h tabpage
Vim's tab pages are not mapped to buffers in a one-to-one relationship. Instead, think of a tab page
as a container that can hold a collection of windows based on 'context'.

<tab-open>
:tabnew  or :tabedit " create a new tab page
:tabe[dit] filename
<C-w> T              " when multiple windows, moves the current window into a new tab page

:tabc[lose]          " Close the current tab page and all of its windows
:tabo[nly]           " Keep the active tab page, closing all others

<tab-switch>
{N}gt                " tab number N
gt                   " next tab
gT                   " prev tab

<tab-rearrange>
:tabmove {N}
:tabmove 0           " the current tab page is moved to the beginning
:tabmove             " the current tab page is moved to the end

<tab-and-working-directory>
Suppose that each tab represents a project or workspace and each project is in different directory.
To work on each project such as openning and searching files, need to have different working
directory for each tab. How?

1. Open a tab which inherits CWD from the previous and run :cd to set different CWD. Do not work
since it sets CWD for all opened tabs.

2. Use lcd command for each tab to have different CWD.

The :lcd {path} command lets us set the working directory locally for the current window. If we
create a new tab page and then use the :lcd command to switch to another directory, we can then
comfortably scope each tab page to a different project. note that :lcd applies locally to the
'current' window, not to the current tab page.


={============================================================================
*kt_dev_env_vim_118* vim-window-scroll

3. Scrolling relative to cursor *scroll-cursor*

The following commands reposition the edit window (the part of the buffer that
you see) while keeping the cursor on the same line:

*zz*
zz       Like "z.", but leave the cursor in the same column.
         Careful: If caps-lock is on, this command becomes
         "ZZ": write buffer and exit!  {not in Vi}

" scrolling {{{
   nnoremap <silent> n nzz
   nnoremap <silent> N Nzz
   nnoremap <silent> * *zz
   nnoremap <silent> # #zz
   nnoremap <silent> g* g*zz
   nnoremap <silent> g# g#zz
   nnoremap <silent> <C-o> <C-o>zz
   nnoremap <silent> <C-i> <C-i>zz
   nnoremap <silent> <C-d> <C-d>zz
   nnoremap <silent> <C-u> <C-u>zz
"}}}


<want-to-keep-the-column>
When use <C-d>zz in the middle of line, cursor goes to the beginning of line.
However, zz stays on the same column. To stay on the same column:

:set nostartofline
:set ve=all

'startofline' 'sol' boolean (default on)

When "on" the commands listed below move the cursor to the first non-blank of
the line. When off the cursor is kept in the same column (if possible). 

This applies to the commands: CTRL-D, CTRL-U, CTRL-B, CTRL-F, "G", "H", "M",
     "L", gg, and to the commands "d", "<<" and ">>" with a linewise operator,
     with "%" with a count and to buffer changing commands (CTRL-^, :bnext,
         :bNext, etc.).
       
Also for an Ex command that only has a line number, e.g., ":25" or ":+".  In
  case of buffer changing commands the cursor is placed at the column where it
  was the last time the buffer was edited.  NOTE: This option is set when
  'compatible' is set.


'virtualedit' 've' string (default "")
{not available when compiled without the |+virtualedit| feature}

   A comma separated list of these words:
       block    Allow virtual editing in Visual block mode.
       insert   Allow virtual editing in Insert mode.
       all      Allow virtual editing in all modes.
       onemore  Allow the cursor to move just past the end of the line

   Virtual editing means that the cursor can be positioned where there is
   no actual character.  This can be halfway into a tab or beyond the end
   of the line.  Useful for selecting a rectangle in Visual mode and
   editing a table.


={============================================================================
*kt_dev_env_vim_119* display and real line

Unlike many text editors, Vim makes a distinction between real lines and display lines. When the
'wrap' setting is enabled (and it's on by default), each line of text that exceeds the width of the
window will display as wrapped, ensuring that no text is truncated from view. As a result, a single
line in the file may be represented by multiple lines on the display.

j     " Down one real line
gj    " Down one display line
k     " Up one real line
gk    " Up one display line
0     " To first character of real line
g0    " To first character of display line
^     " To first 'nonblank' character of real line
g^    " To first nonblank character of display line
$     " To end of real line
g$    " To end of display line

Note the pattern: j, k, 0, and $ all interact with real lines, while prefixing any of these with g
tells Vim to act on display lines instead.

<useful>
When you learn to use the gj and gk commands, you'll appreciate that j and k may let you cover more
distance with fewer keystrokes.


={============================================================================
*kt_dev_env_vim_120* marks, jumps and changes

{marks}
A global mark is a kind of bookmark that allows us to jump between files. Marks
can be especially useful for snapping back to a file after exploring a codebase.

<local-and-global>
Lowercase letters create marks that are local to a buffer, whereas uppercase
letters create global marks.

<make-and-move>

m{mark}  " make a mark 26 marks(a-z) (line and column)
'{mark}  " apostrophe ('). jump to the line of a mark. linewise
`{mark}  " backtick (`). jump to the 'exact' position of a mark (line and column) 

Go with `{mark}. Whether you care about restoring the exact position or just
getting to the right line, this command will get you there.

d`a   " delete from current cursor position to position of mark a
y`a   " yank text to unnamed buffer from cursor to position of mark a

:marks
:delm {mark}

<automatic-marks>
``    " Position before the last jump within current file. Jump back and forth
        between two.
`.    " Location of last change. complement of change list
`^    " Location of last insertion. complement of change list
`[    " Start of last change or yank
`]    " End of last change or yank
`<    " Start of last visual selection
`>    " End of last visual selection

note: If uses 'bookmark' of vim plugins, then can only use these two tips wrt
mark and jumps?

<mark-then-snap-back>
The mm and `m commands make a handy pair. Respectively, they set the mark m and
jump to it.

<mark-before-any-command> global-mark
Global marks are only useful if we have the forethought to set them up correctly
in advance. With practice, you'll learn to recognize the scenarios where it
would be useful to set a global mark.

note: WHY?

Try to get into a 'habit' of setting a global mark before using any commands
that interact with the quickfix list, such as :grep, :vimgrep, and :make.


{jumps}
The motions move around within a file, whereas jumps can move 'between' files.

<C-o>       " go to older pos in jump list
<C-i>       " go to newer pos in jump list

If we run the :edit command to open a new file, then we can use the <C-o> and
<C-i> commands to jump back and forth between the two files.

<what-jump-is>
Moving directly to a line number with [count]G counts as a jump, but moving up
or down one line at a time does not. The sentence-wise and paragraphwise motions
are jumps, but the character-wise and word-wise motions are not. As a rule of
thumb, we could say that 'long'-range motions may be classified as a jump, but
short-range motions are just motions.

[count]G                         " Jump to line number
//pattern<CR>/?pattern<CR>/n/N   " Jump to next/previous occurrence of pattern
%                                " Jump to matching parenthesis
(/)                              " Jump to start of previous/next sentence
{/}                              " Jump to start of previous/next paragraph
gf                               " Jump to file name under the cursor

<C-]>                            " Jump to definition of keyword under the cursor
                                   (requires ctags)
'{mark}/`{mark}                  " Jump to a mark


<jump-list>
:jumps

Your current location in the jump list is indicated with '>', and the first
number in each row is a count that can be used to jump to that position.
Something like this:

 jump line  col file/text
   4   102    0 somefile.txt
   3    93    0 -invalid-
   2    23    0 the current line 23 is shown here
   1    89   34 the current line 89 is shown here
>  0    22   40 Display the jump list for the current window with:
   1    39    0 the current line 39 is shown here
   2   995    0 anotherfile.txt
   3    53  102 the current line 53 is shown here

<active-window>
Vim can maintain multiple jump lists at the same time. In fact, 'each' separate
'window' has its own jump list. If we're using split windows or multiple tab
pages, then the <C-o> and <C-i> commands will always be scoped to the jump list
of the active window.


{changes}
:changes

Using the g; and g, commands, we can traverse backward and forward through the
change list.

<which-one>
We can press g; again and again, and each time it takes us to a location that
was recorded earlier in the change list. The `., on the other hand, will always
take us to the last item in the change list.

<gi-command>
Can quickly carry on where we left off by pressing gi (:h gi ). gi is better
since it is a single move and that uses the `^ mark to restore the cursor
position and then switches back into Insert mode. Don't need to press a key to
insert mode.


{gf-command} :h gf
Can use the gf command to go to the filename under the cursor. Two things to set
up:

1. The suffixesadd option allows us to specify one or more file extensions,
    which Vim will attempt to use when looking up a filename with the gf command
    (:h 'suffixesadd'). We can set it up by running this command:

:set suffixesadd+=.rb

2. The gf use relative to the working directory. But what if we referenced
functionality that was provided by a third-party library? :h 'path'. When we use
the gf command, Vim checks each of the directories listed in
âpathâ to see if it contains a filename that matches the text
under the cursor.

:set path?
 path=.,/usr/include,,

whereas the empty string (delimited by two adjacent commas) stands for the
working directory.

<gf-and-jumps>
Each time we use the gf command, Vim adds a record to the jump list, so can use
<C-o> as in jump list.

<gf-and-filetype>
In the setup for this tip, I recommended launching Vim with plugins disabled.
That's because Vim is usually distributed with a Ruby file-type plugin, which
handles the setup of suffixesadd and path options for us.

The suffixesadd and path options can be set locally for each buffer, so they can
be configured in different ways for different file types. Vim is distributed
with file-type plugins for many other languages, so in practice you won't often
have to set these options yourself. Even so, it's worth understanding how the gf
command works. It makes each filepath in our document behave like a hyperlink,
        which makes it easier to navigate through a codebase.


={============================================================================
*kt_dev_env_vim_121* vim-register vim-clipboard

{unnamed-register}
Can specify which register we want to use by prefixing the command with
`"register`. If we don't specify a register, then Vim will use the unnamed
register which is addressed by the `"`. see :h quote_quote

xp

The x command cuts the character under the cursor, placing a copy of it in the
unnamed register.  Then the p command pastes the contents of the unnamed
register after the cursor position.  Taken together, the xp commands can be
considered as "Transpose the next two characters."


{use-register}
:reg[isters]
:reg "0           " can specify the register name to see that only

"ayiw
"a4yy             " copy the next 4 lines into the register named 'a'
"ap               " paste from 'a'
"bd
"bp
vjww"by           " yank visual selection to b reg
"wdaw             " to delete-a-word and write it in the w register:


{yank-register}
y2w
yy                " yank a line
2yy               " yank 2 lines 
byw               " move to the beginning of a word

The unnamed register is not reliable since can be overwritten by many cut
related command. So `yank register` which is addressed by the `0`, see :h
quote0, comes in and when use the y{motion} command, the specified text is
copied not only into the unnamed register but also into the yank register. The
below shows the use.


<ex>
yiw         collection = getCollection();
            process(somethingInTheWay, target);
jww         collection = getCollection();
            process(somethingInTheWay, target);
diw         collection = getCollection();
            process(, target);
"0P         collection = getCollection();
            process(collection, target);

<ex> Vim's put command has some unusual qualities.
This time, used visual selection and put command. No delete so preferable.
However, it has a side effect. When do "u, gv, p" which means undo, reselect
last selection, and put, what would happen?  Nothing. Why? Because when we use
Vim's p command in Visual mode, it does both: it gets the contents of the
unnamed register, and it sets the contents of the unnamed register. Think of
it this way: the visual selection in the document swaps places with the text
in the register.

yiw         collection = getCollection();       " unnamed is "collection" and "0 is "collection"
            process(somethingInTheWay, target);
jww         collection = getCollection();
            process(somethingInTheWay, target);
ve          collection = getCollection();
            process(somethingInTheWay, target);
p           collection = getCollection();       " unnamed is "somethingInTheWay" and "0 is "collection"
            process(collection, target);

<example> swap two words which use put's quirk property

{start}  I like chips and fish.
fc       I like chips and fish.
de       I like  and fish.
mm       I like  and fish.          " note: see the use of mark
                ^
ww       I like  and fish.
ve       I like  and fish.
p        I like  and chips.
`m       I like  and chips.
                ^
P        I like fish and chips.     " it is 'P'. If use 'p' then "like  fishand chips."

In this case, it would be quicker to delete "chips and fish" and then type out "fish and chips"
instead, using the c3w command for example. But this same technique can also be used to swap the
order of longer phrases.


{lowercase-and-uppercase-paste} *vim-how-to-enter-regigister-name*
The lowercase paste after for characterwise and below for linewise and the
uppercase do the opposite. Rather than remember this, can use <C-r>{register}
so that can paste text always in front of the current cursor position.

yiw            collection = getCollection();
               process(somethingInTheWay, target);
jww            collection = getCollection();
               process(somethingInTheWay, target);
ciw<C-r>0<Esc> collection = getCollection();
               process(collection, target);

As an added bonus, can use dot command to change the current word with
"collection" since the whole step is a change to repeat.

TODO: gp, gP


{named-register}
Vim has one named register for each letter of the alphabet. see :h
quote_alpha. Using a named register requires extra keystrokes, so for a simple
example like this we're better off using the yank register ("0).


{system-registers} <clipboard> :h quote+
To copy some text from inside of Vim and paste it into an external program

"+ register

In vim 7.3.74 and higher you can do following to 'alias' unnamed register to
the + register, which is the system clipboard. By doing this, don't need to
"+p to make it available to other application in the system and vice versa.

set clipboard=unnamedplus

note: this works as well between Windows and the guest Linux.


<primary-register> to and from vim and the shell
The X11 windowing system has a second kind of clipboard called the primary. This represents the
most recently selected text, and we can use the middle mouse button (if we have one) to paste from
it. The quotestar register maps to the primary clipboard and is addressed by the * symbol. :h
quotestar

From the shell, select text using a mouse and then:

Select text using a mouse  
" copy text to the primary, *. So have to use "* in vim. note: without selecting copy menu or
ctrl-ins.

Select text and CTRL-INS   " copy text to the primary and the clipboard.
SHIFT-INS                  " paste from the primary. Same as middle mouse click.

In Windows and Mac OS X, there is no primary clipboard, so we can use the "+ and "* registers
interchangeably: they both represent the system clipboard.

<from-vim-to-shell>
To copy text from vim to the shell, use "* in vim to copy and shift-ins in the shell to paste. Or
use + register by usual yank and use paste menu in a application. For gnome terminal, Ctrl-Shift-V
to paste.

Vim can be compiled with or without support for X11 clipboard integration.  To find out whether your
version of Vim has the feature enabled, run the :version command and look for xterm_clipboard.


{other-registers}
These are known collectively as the read-only registers. :h quote.

"%    " Name of the current file
"#    " Name of the alternate file
".    " Last inserted text
":    " Last Ex command
"/    " Last search pattern


={============================================================================
*kt_dev_env_vim_122* vim-paste-into-command-line

<C-r> <C-w>    " to paste the word under the cursor into the command line


={============================================================================
*kt_dev_env_vim_000* regex

https://www.gnu.org/software/grep/manual/grep.html#Regular-Expressions

This manual is for version 2.25 of GNU Grep.

3 Regular Expressions

A `regular-expression` is a pattern that describes a set of strings. Regular
expressions are constructed analogously to arithmetic expressions, by using
various operators to combine smaller expressions. grep understands three
different versions of regular expression syntax: “basic” (BRE), “extended” (ERE)
and “perl” (PCRE). 

In GNU grep, there is no difference in available functionality between the basic
and extended syntaxes. In other implementations, basic regular expressions are
less powerful. The following description applies to extended regular
expressions; differences for basic regular expressions are summarized
afterwards. 

Perl-compatible regular expressions give additional functionality, and are
documented in the pcresyntax(3) and pcrepattern(3) manual pages, but work only
if PCRE is available in the system. 


3.1 Fundamental Structure

The fundamental building blocks are the regular expressions that match a `single
character`. Most characters, including all letters and digits, are regular
expressions that match themselves. Any meta-character with special meaning may
be quoted by preceding it with a backslash.

A regular expression may be followed by one of several `repetition-operators`:

‘.’
    The period ‘.’ matches any single character.

‘?’
    The `preceding` item is optional and will be matched at most once.

‘*’
    The preceding item will be matched zero or more times.

‘+’
    The preceding item will be matched one or more times.

‘{n}’
    The preceding item is matched exactly n times.

‘{n,}’
    The preceding item is matched n or more times.

‘{,m}’
    The preceding item is matched at most m times. This is a GNU extension.

‘{n,m}’
    The preceding item is matched at least n times, but not more than m times.

The empty regular expression matches the empty string. Two regular expressions
may be concatenated; the resulting regular expression matches any string formed
by concatenating two substrings that respectively match the concatenated
expressions.

*regex-alternation* *regex-or*
Two regular expressions may be joined by the `infix-operator` ‘|’; the resulting
regular expression matches any string matching either `alternate` expression.

Repetition takes `precedence` over concatenation, which in turn takes precedence
over alternation. A whole expression may be enclosed in `parentheses` to
override these precedence rules and form a subexpression. An unmatched ‘)’
matches just itself. 


3.2 Character Classes and Bracket Expressions

A `bracket-expression` is a list of characters enclosed by ‘[’ and ‘]’. It
matches any `single character` in that list; if the first character of the list
is the caret ‘^’, then it matches any character not in the list. For example,
the regular expression ‘[0123456789]’ matches any single digit.


<ex>
s:[65]:Dig:g      " substitue 

High 65 to 70. Southeast wind around 10
->
High DigDig to 70. Southeast wind around 10

s:65:Dig:g

High 65 to 70. Southeast wind around 10
->
High Dig to 70. Southeast wind around 10


Within a bracket expression, a `range-expression` consists of two characters
separated by a hyphen. It matches any single character that sorts between the
two characters, inclusive. In the default C locale, the sorting sequence is the
native character order; for example, ‘[a-d]’ is equivalent to ‘[abcd]’. In other
locales, the sorting sequence is not specified, and ‘[a-d]’ might be equivalent
to ‘[abcd]’ or to ‘[aBbCcDd]’, or it might fail to match any character, or the
set of characters that it matches might even be erratic. To obtain the
traditional interpretation of bracket expressions, you can use the ‘C’ locale by
setting the LC_ALL environment variable to the value ‘C’.

Finally, certain named classes of characters are predefined within bracket
expressions, as follows. Their interpretation depends on the LC_CTYPE locale;
for example, ‘[[:alnum:]]’ means the character class of numbers and letters in
  the current locale.

‘[:alnum:]’
    Alphanumeric characters: ‘[:alpha:]’ and ‘[:digit:]’; in the ‘C’ locale and
    ASCII character encoding, this is the same as ‘[0-9A-Za-z]’.

‘[:alpha:]’
    Alphabetic characters: ‘[:lower:]’ and ‘[:upper:]’; in the ‘C’ locale and
    ASCII character encoding, this is the same as ‘[A-Za-z]’.

‘[:blank:]’
    Blank characters: space and tab.

‘[:cntrl:]’
    Control characters. In ASCII, these characters have octal codes 000 through
    037, and 177 (DEL). In other character sets, these are the equivalent
    characters, if any.

‘[:digit:]’
    Digits: 0 1 2 3 4 5 6 7 8 9.

‘[:graph:]’
    Graphical characters: ‘[:alnum:]’ and ‘[:punct:]’.

‘[:lower:]’
    Lower-case letters; in the ‘C’ locale and ASCII character encoding, this is
    a b c d e f g h i j k l m n o p q r s t u v w x y z.

‘[:print:]’
    Printable characters: ‘[:alnum:]’, ‘[:punct:]’, and space.

‘[:punct:]’
    Punctuation characters; in the ‘C’ locale and ASCII character encoding, this
    is ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~.

‘[:space:]’
    Space characters: in the ‘C’ locale, this is tab, newline, vertical tab,
          form feed, carriage return, and space. See Usage, for more discussion
            of matching newlines.

‘[:upper:]’
    Upper-case letters: in the ‘C’ locale and ASCII character encoding, this is
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z.

‘[:xdigit:]’
    Hexadecimal digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f.


Note that the brackets in these class names are part of the symbolic names, and
must be included in addition to the brackets delimiting the bracket expression.

If you mistakenly omit the outer brackets, and search for say, ‘[:upper:]’, GNU
grep prints a diagnostic and exits with status 2, on the assumption that you did
not intend to search for the nominally equivalent regular expression: ‘[:epru]’.
Set the POSIXLY_CORRECT environment variable to disable this feature.

Most meta-characters lose their special meaning inside bracket expressions.

‘]’
    ends the bracket expression if it’s not the first list item. So, if you want
    to make the ‘]’ character a list item, you must put it first.

‘[.’
    represents the open collating symbol.

‘.]’
    represents the close collating symbol.

‘[=’
    represents the open equivalence class.

‘=]’
    represents the close equivalence class.

‘[:’
    represents the open character class symbol, and should be followed by a
    valid character class name.

‘:]’
    represents the close character class symbol.

‘-’
    represents the range if it’s not first or last in a list or the ending point
    of a range.

‘^’
    represents the characters not in the list. If you want to make the ‘^’
    character a list item, place it anywhere but first.


3.3 The Backslash Character and Special Expressions

The ‘\’ character, when followed by certain ordinary characters, takes a special
meaning:

‘\b’
    Match the `empty-string` `at-the-edge` of a word.

‘\B’
    Match the empty string provided it’s not at the edge of a word.

‘\<’
    Match the empty string at the beginning of word.

‘\>’
    Match the empty string at the end of word.

note:
1. empty string do not mean space character. '\bcore' matches "pattern-core" and
"core"
2. \b and \<, \> do the same.


‘\w’
    Match `word-constituent`, it is a synonym for ‘[_[:alnum:]]’.

‘\W’
    Match non-word constituent, it is a synonym for ‘[^_[:alnum:]]’.

‘\s’
    Match whitespace, it is a synonym for ‘[[:space:]]’.

‘\S’
    Match non-whitespace, it is a synonym for ‘[^[:space:]]’.

For example, ‘\brat\b’ matches the separate word ‘rat’, ‘\Brat\B’ matches
‘crate’ but not ‘furry rat’. 

<vim>
See *whitespace* *white-space*

\s	whitespace character: <Space> and <Tab>		*/\s*
\S	non-whitespace character; opposite of \s	*/\S*
\d	digit:				[0-9]		*/\d*
\D	non-digit:			[^0-9]		*/\D*
\x	hex digit:			[0-9A-Fa-f]	*/\x*
\X	non-hex digit:			[^0-9A-Fa-f]	*/\X*
\o	octal digit:			[0-7]		*/\o*
\O	non-octal digit:		[^0-7]		*/\O*
\w	word character:			[0-9A-Za-z_]	*/\w*
\W	non-word character:		[^0-9A-Za-z_]	*/\W*
\h	head of word character:		[A-Za-z_]	*/\h*
\H	non-head of word character:	[^A-Za-z_]	*/\H*
\a	alphabetic character:		[A-Za-z]	*/\a*
\A	non-alphabetic character:	[^A-Za-z]	*/\A*
\l	lowercase character:		[a-z]		*/\l*
\L	non-lowercase character:	[^a-z]		*/\L*
\u	uppercase character:		[A-Z]		*/\u*
\U	non-uppercase character:	[^A-Z]		*/\U*

\e	matches <Esc>					*/\e*
\t	matches <Tab>					*/\t*
\r	matches <CR>					*/\r*
\b	matches <BS>					*/\b*
\n	matches an end-of-line				*/\n*

NOTE: Using the atom is faster than the [] form.


3.4 Anchoring

The caret ‘^’ and the dollar sign ‘$’ are meta-characters that respectively
match the empty string at the beginning and end of a line. They are termed
anchors, since they force the match to be “anchored” to beginning or end of a
line, respectively. 


3.5 Back-references and Subexpressions

The back-reference ‘\n’, where n is a single digit, matches the substring
`previously` matched by the nth parenthesized subexpression of the regular
expression. For example, ‘(a)\1’ matches ‘aa’. 

When used with alternation, if the group does not participate in the match then
the back-reference makes the whole match fail. For example, ‘a(.)|b\1’ will not
match ‘ba’. 

When multiple regular expressions are given with -e or from a file (‘-f file’),
back-references are local to each expression. 


3.6 Basic vs Extended Regular Expressions

In basic regular expressions the meta-characters ‘?’, `+`, ‘{’, ‘|’, ‘(’, and
    ‘)’ lose their special meaning; instead use the backslashed versions ‘\?’,
`\+`, ‘\{’, ‘\|’, ‘\(’, and ‘\)’.

Traditional egrep did not support the ‘{’ meta-character, and some egrep
  implementations support ‘\{’ instead, so portable scripts should avoid ‘{’ in
    ‘grep -E’ patterns and should use ‘[{]’ to match a literal ‘{’.

GNU grep -E attempts to support traditional usage by assuming that ‘{’ is not
  special if it would be the start of an invalid interval specification. 

For example, the command ‘grep -E '{1'’ searches for the two-character string
  ‘{1’ instead of reporting a syntax error in the regular expression. POSIX
    allows this behavior as an extension, but portable scripts should avoid it. 


={============================================================================
*kt_dev_env_vim_000* regex-ex

4 Usage

Here is an example command that invokes GNU grep:

grep -i 'hello.*world' menu.h main.c

This lists all lines in the files menu.h and main.c that contain the string
‘hello’ followed by the string ‘world’; this is because ‘.*’ matches zero or
more characters within a line. See Regular Expressions. The -i option causes
grep to ignore case, causing it to match the line ‘Hello, world!’, which it
would not otherwise match. See Invoking, for more details about how to invoke
grep.


Q: Why quote the pattern? A: From *sh-quote* :

<ex>
To prevent globbing by shell before passing params to grep command.

$ grep '[0-9][0-9]*$' report2 report7


Here are some common questions and answers about grep usage.

    1. How can I list just the names of matching files?

    grep -l 'main' *.c

    lists the names of all C files in the `current-directory` whose contents
    mention ‘main’.

    // *grep-option-l*
    // -l, --files-with-matches
    //        Suppress normal output; instead  print  the name of each input
    //        file from which output would normally have been printed. The
    //        scanning will stop on the first  match.


    2. How do I search directories recursively?

    grep -r 'hello' /home/gigi

    searches for ‘hello’ in `all-files` under the /home/gigi directory. For more
    control over which files are searched, use find, grep, and xargs. For
    example, the following command searches only C files:

    // *grep-option-r*
    // -R, -r, --recursive
    //        Read  all  files  under  each  directory, recursively; this is
    //        equivalent to the -d recurse option.

    find /home/gigi -name '*.c' -print0 | xargs -0r grep -H 'hello'

    // *grep-option-h*
    // -H, --with-filename
    //        Print  the  file  name for each match.  This is the `default` when
    //        there is more than one file to search.

    This differs from the command:

    grep -H 'hello' *.c

    which merely looks for ‘hello’ in all files in the current directory whose
    names end in ‘.c’. The ‘find ...’ command line above is more similar to the
    command:

    grep -rH --include='*.c' 'hello' /home/gigi

    // grep -nr --include *.c __setup ./
    // grep -nr --include *.c [a-z]*_initcall ./

    // *grep-option-n*
    // -n, --line-number
    //        Prefix each line of output with the 1-based line number within its
    //        input file.  (-n is specified by POSIX.)


    3. What if a pattern has a leading ‘-’?

    grep -e '--cut here--' *

    searches for all lines matching ‘--cut here--’. Without -e, grep would
    attempt to parse ‘--cut here--’ as a list of options.

    // -e PATTERN, --regexp=PATTERN
    //        Use  PATTERN  as  the  pattern.   This  can  be  used to specify
    //        multiple search patterns, or to protect a pattern beginning with
    //        a hyphen (-).  (-e is specified by POSIX.)


    4. Suppose I want to search for a whole word, not a part of a word?

    grep -w 'hello' *

    searches only for instances of ‘hello’ that are entire words; it does not
    match ‘Othello’. For more control, use ‘\<’ and ‘\>’ to match the start and
    end of words. For example:

    grep 'hello\>' *

    searches only for words ending in ‘hello’, so it matches the word ‘Othello’.


    5. How do I output context around the matching lines?

    grep -C 2 'hello' *

    prints two lines of context around each matching line.

    // -C NUM, -NUM, --context=NUM
    //      Print NUM lines of output context.  Places a line containing a group
    //      separator (--) between contiguous groups of matches.  With the -o or
    //      --only-matching option, this  has no effect and a warning is given.

    6. How do I force grep to print the name of the file?

    Append /dev/null:

    grep 'eli' /etc/passwd /dev/null

    gets you:

    /etc/passwd:eli:x:2098:1000:Eli Smith:/home/eli:/bin/bash

    Alternatively, use -H, which is a GNU extension:

    grep -H 'eli' /etc/passwd


    7. Why do people use strange regular expressions on ps output?

    ps -ef | grep '[c]ron'

    If the pattern had been written without the square brackets, it would have
    matched not only the ps output line for cron, but also the ps output line
    for grep. 

    $ ps -ef | grep cron
    :56:root      2376     1  0 00:01 ?        00:00:00 /usr/sbin/cron
    :116:keitee   4510  3744  0 01:07 pts/0    00:00:00 grep --color=auto -anH cron

    $ ps -ef | grep [c]ron
    :56:root      2376     1  0 00:01 ?        00:00:00 /usr/sbin/cron

    note:
    Shows `default-option`


    8. Why does grep report “Binary file matches”?

    If grep listed all matching “lines” from a binary file, it would probably
    generate output that is not useful, and it might even muck up your display.
    So GNU grep suppresses output from files that appear to be binary files. 
    
    // *grep-option-a*
    To force GNU grep to output lines even from files that appear to be binary,
       use the -a or ‘--binary-files=text’ option. 

    To eliminate the “Binary file matches” messages, use the -I or
    ‘--binary-files=without-match’ option.


    9.Why doesn’t ‘grep -lv’ print non-matching file names?

    ‘grep -lv’ lists the names of all files containing one or more lines that do
    not match. 
    
    To list the names of all files that contain no matching lines, use the -L or
    --files-without-match option.


    10. I can do “OR” with ‘|’, but what about “AND”?   *grep-and*

    grep 'paul' /etc/motd | grep 'franc,ois'

    finds all lines that contain both ‘paul’ and ‘franc,ois’.


    11. Why does the `empty-pattern` match every input line?

    The grep command searches for lines that contain strings that match a
    pattern. Every line contains the `empty-string`, so an empty pattern causes
    grep to find a match on each line. It is not the only such pattern: ‘^’,
         ‘$’, ‘.*’, and many other patterns cause grep to match every line.

    To match empty lines, use the pattern ‘^$’. To match blank lines, use the
    pattern ‘^[[:blank:]]*$’. To match no lines at all, use the command ‘grep -f
    /dev/null’.


    12. How can I search in both standard input and in files?

    Use the special file name ‘-’:

    cat /etc/passwd | grep 'alain' - /etc/motd


    13. How to express palindromes in a regular expression?

    It can be done by using back-references; for example, a palindrome of `4`
    characters can be written with a BRE:

    grep -w -e '\(.\)\(.\).\2\1' file

    It matches the word “radar” or “civic.”

    Guglielmo Bondioni proposed a single RE that finds all palindromes up to 19
    characters long using 9 subexpressions and 9 back-references:

    grep -E -e '^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?).?\9\8\7\6\5\4\3\2\1$' file

    Note this is done by using GNU ERE extensions; it might not be portable to
    other implementations of grep.


    14. Why is this back-reference failing?

    echo 'ba' | grep -E '(a)\1|b\1'

    This gives no output, because the first alternate ‘(a)\1’ does not match, as
    there is no ‘aa’ in the input, so the ‘\1’ in the second alternate has
    nothing to refer back to, meaning it will never match anything. (The second
        alternate in this example can only match if the first alternate has
        matched—making the second one superfluous.)


    15. How can I match across lines?

    Standard grep cannot do this, as it is fundamentally `line-based`.
    Therefore, merely using the [:space:] character class does not match
    newlines in the way you might expect.

    With the GNU grep option -z (--null-data), each input “line” is terminated
    by a null byte; see Other Options. Thus, you can match newlines in the
    input, but typically if there is a match the entire input is output, so this
    usage is often combined with output-suppressing options like -q, e.g.:

    printf 'foo\nbar\n' | grep -z -q 'foo[[:space:]]\+bar'

    If this does not suffice, you can transform the input before giving it to
    grep, or turn to awk, sed, perl, or many other utilities that are designed
    to operate across lines.


    // -z, --null-data
    //        `treat-the-input` as a set of lines, each  terminated  by  a  zero
    //        byte  (the  ASCII NUL character) instead of a newline.  Like the
    //        -Z or --null option, this option can be used with commands  like
    //        sort -z to process arbitrary file names.

    // -Z, --null
    //        Output  a  zero  byte  (the  ASCII NUL character) instead of the
    //        character that normally follows a file name.  For example,  grep
    //        -lZ  outputs  a  zero  byte  after each file name instead of the
    //        usual newline.  This option makes the output  unambiguous,  even
    //        in the presence of file names containing unusual characters like
    //        newlines.  This option can  be  used  with  commands  like  find
    //        -print0,  perl  -0,  sort  -z, and xargs -0 to process arbitrary
    //        file names, even those that contain newline characters.


    16. What do grep, fgrep, and egrep stand for?

    The name grep comes from the way line editing was done on Unix. For example,
    ed uses the following syntax to print a list of matching lines on the
      screen:

    global/regular expression/print
    g/re/p

    fgrep stands for Fixed grep; egrep stands for Extended grep.


<q-option>
To use the status in a script.

-q, --quiet, --silent
    Quiet; do not write anything to standard output. Exit immediately with zero
    status if any match is found, even if an error was detected. Also see the -s
    or --no-messages option. 

echo xx | grep -q '.gz$' && echo ture
echo xx.gz | grep -q '.gz$' && echo ture
ture

The script example:

##:zcat if this is a .gz, cat otherwise
F=cat
echo "$1" | grep -q '\.gz$' && F=zcat
$F "$1"


={============================================================================
*kt_dev_env_vim_000* vim-regex

Practical Vim 12. Tip 72.

*vim-smartcase*

Setting Case Sensitivity Globally

We can make Vim's search patterns case insensitive by enabling the `ignorecase`
setting.


Enabling Smarter Default Case Sensitivity

Vim provides an extra setting that makes an effort to predict our case
sensitivity intentions. This is the `smartcase` option. 

When enabled, `smartcase` has the effect of canceling out the `ignorecase`
setting any time that we include an uppercase character in our search pattern.
In other words, if our pattern is all lowercase, then the search will be case
insensitive. But as soon as we include an uppercase letter, the search becomes
case sensitive.

note: 'smartcase' 'scs' boolean (default off)

Does that sound complicated? Try it out and you’ll find that it feels quite
intuitive. And remember that we can always force case sensitivity or
insensitivity for an individual search by including the \C or \c items. 
  
Table 21, Tuning the Case Sensitivity of Search Patterns, on page 185,
illustrates a matrix of case sensitivity options. A similar table can be found
  in Vim’s built-in documentation by looking up :h /ignorecase .


Practical Vim 12. Tip 73.

*vim-pattern-swith*

Use the \v Pattern Switch for Regex Searches

Vim's regular expression syntax is closer in style to POSIX than to Perl.

note: 
Seems to mean Vim's default support is BRE.


We need to match a # character followed by either three or six hexadecimal
characters. That includes all numeric digits, plus the letters A through F in
upper- or lowercase.

Find Hex Colors with Magic Search

The following regular expression meets these requirements:

/#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)


Find Hex Colors with Very Magic Search

We can normalize the rules for all special symbols with the \v pattern switch.
This enables very magic search, where all characters assume a special meaning,
with the exception of “_”, uppercase and lowercase letters, and the digits 0
  through 9 (see :h \v ).

The \v pattern switch makes Vim’s regular expression engine behave much more
like that of Perl, Python, or Ruby. There are still differences, which we’ll
draw attention to throughout this chapter, but they’re easier to remember than
arbitrary rules about what must and must not be escaped.

Let’s rewrite that regular expression for matching hex colors, this time using
the \v pattern switch:

/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})

note:
Makes ERE?


Use the Hex Character Class to Further Refine the Pattern

We can make one further refinement to this pattern: instead of spelling out the
character collection [0-9a-fA-F] in full, we can replace it with the
`character-class` \x (see :h /character-classes ). This pattern has exactly the
same meaning as the previous one:

/\v#(\x{6}|\x{3})


Practical Vim 12. Tip 76.

Stake the Boundaries of a Word

/\v<the><CR>


*vim-regex-group*

Use Parentheses Without Capturing Their Contents

Sometimes we may want to use parentheses for grouping, while we may have no
interest in capturing the submatch. For example, take this pattern, which
matches both forms of my name:

/\v(And|D)rew Neil


In a very magic search, the naked < and > characters are interpreted as word
delimiters, but in magic, nomagic, and very nomagic searches we have to escape
them. Hence, to look up these items in Vim’s documentation, we must prepend a
slash: :h /\< . Note that if we wanted to match the angle bracket characters
literally in a very magic search, we would have to escape them.

<ex>
Swap two words

:s/\(one\) \(two\)/\2 \1/g 


={============================================================================
*kt_dev_env_vim_000* vim-regex-separator

Frequently you need to do S&R in a text which contains UNIX file paths
- text strings with slashes ("/") inside. Because S&R command uses slashes for
pattern/replacement separation you have to escape every slash in your pattern,
i.e. use "\/" for every "/" in your pattern:

s/\/dir1\/dir2\/dir3\/file/dir4\/dir5\/file2/g

To avoid this so-called "backslashitis" you can use different separators in
S&R (I prefer ":")

s:/dir1/dir2/dir3/file:/dir4/dir5/file2:g
s:\<vi\>:VIM:g

# delete trailing spaces
:%s:\s\+$:

# show trailing wss
/\s\+$

# show all tabs
/\t

#
input to match:

NDS: ^[00:30:37]0946686637.742067 !ERROR -SPM_COMMON   < p:000000c8 t:2bb79520 T:no name M:spm_common.c F:SPM_COMMON_waitOnCondition L:02194 > Condition wait timed out!

$ grep "\!ERROR .* SPM_COMMON_waitOnCondition" LOG
no match because the second space.

$ grep "\!ERROR.* SPM_COMMON_waitOnCondition" LOG  
no match as before.

$ grep "\!ERROR.*SPM_COMMON_waitOnCondition" LOG  
match.

# 12 hours
12 ?? ?? ?? 9:17 am or 12:30 pm

9:45 pm
13:21 pm
9:45 am
23:31 pm
33323:31 pm
1:11 am

# this mathes all!
egrep '(1[012]|[0-9]):[0-5][0-9] am|pm' x  



={============================================================================
*kt_dev_env_vim_122* vim-search

Practical Vim 13. Tip 79, 81.

<wrapscan>
If you ever need to search from the current cursor position to the end of the
document without wrapping around, you can disable the `wrapscan` option. see :h
'wrapscan'.

set nowrapscan


<incsearch>
Practical Vim 13. Tip 81.

By default, Vim sits idle as we prepare our search pattern, only springing into
action when we press <CR>. My favorite enhancement is enabled with the
`incsearch` setting. see :h 'incsearch'

:set incsearch    " inc search

<ex>
Suppose that we just want to check if the word "carrot" is present in the
current document without moving our cursor. If the word is found, we can just
press <Esc>, and we'll end up right back where we started.

<ex>
Suppose we were planning to follow the search command with a substitute command.
Do incsearch and found match. Use autocompletes to fill remainders in the
command line.

<C-r> <C-w>    " to paste the word under the cursor into the command line


<direction>
The / key, Vim scans the document forward. If we use the ? key searches backward
instead.


<repeat>
n       Jump to next match, preserving direction and offset
N       Jump to previous match, preserving direction and offset


Sometimes we might want to repeat a search using the same pattern but changing
the direction or offset.

/<CR>   Jump forward to next match of same pattern
?<CR>   Jump backward to previous match of same pattern


<history>
The search provides histories.


={============================================================================
*kt_dev_env_vim_124* vim-search-highlight

Practical Vim 13. Tip 80.

The `hlsearch` option which causes all matches to be highlighted throughout the
active document as well as in any other open split windows. :h 'hlsearch'

:set hlsearch     " to set search highlight
:set nohlsearch   " to disable
:noh[lsearch]     " to mute the search highlighting `temporarily`. see :h :noh


*vim-mapping*
Typing :noh <CR> to mute search highlighting is laborious. We can speed things
up by creating a mapping such as this:

nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>

<C-u> is scroll up. <C-l> clears and redraws the screen (see :h CTRL-L). This
mapping builds on top of the usual behavior by muting search highlighting.


={============================================================================
*kt_dev_env_vim_127* vim-search-greedy-match

Practical Vim 13. Tip 85.

<ex>
This string contains a 'quoted' word.
This string contains 'two' quoted 'words.'
This 'string doesn't make things easy.'

To:

This string contains a "quoted" word.
This string contains "two" quoted "words."
This "string doesn't make things easy."

<01> /\v'.+'

This string contains a 'quoted' word.
                       ^^^^^^^^
This string contains 'two' quoted 'words.'
                     ^^^^^^^^^^^^^^^^^^^^^
This 'string doesn't make things easy.'
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Since do `greedy-match`.

<02> /\v'[^']+'

This string contains a 'quoted' word.
                       ^^^^^^^^
This string contains 'two' quoted 'words.'
                     ^^^^^        ^^^^^^^^
This 'string doesn't make things easy.'
     ^^^^^^^^^^^^^^

How differentiates an apostrophe from a closing quote mark?

3. /\v'([^']|'\w)+'

Again,

*regex-alternation* *regex-or*
Two regular expressions may be joined by the `infix-operator` ‘|’; the resulting
regular expression matches any string matching either `alternate` expression.

Catch the fact that the apostrophe is followed immediately by a letter; not by a
space or punctuation mark.

This 'string doesn't make things easy.'
     ^^^^^^^^^^^^^^
To

This 'string doesn't make things easy.'
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Since `greedy-match` and `or`. Here are talking about `match` to use it with
other command such as `substitude` but not line.


={============================================================================
*kt_dev_env_vim_128* vim-search-selection

Practical Vim 13. Tip 86.

In Normal mode, the * command lets us search for the word under the cursor. This
is "Use selection for find" command.

If you look up :h visual-search , you’ll find this suggestion: Here is an idea
for a mapping that makes it possible to do a search for the selected text:

:vmap X y/<C-R>"<CR>

Note that special characters (like “.” and “*”) will cause problems.

Q: Why doesn't work? :vmap X y/\v<C-R>"<CR>

The y command yanks the current visual selection, and /<C-r>"<CR> brings up the
search prompt, pastes the contents of the default register, and then executes
the search. That solution is simple, but as the cautionary note in Vim’s
documentation says, it has limitations.


*vim-mapping*

xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

function! s:VSetSearch()
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
  let @s = temp
endfunction

You can either paste this into your vimrc file directly or install the visual
star search plugin.  https://github.com/nelstrom/vim-visual-star-search

As well as overriding the * command, we've customized the # command, which
searches backward for selected text. The xnoremap keyword specifies that the
mappings should apply to Visual mode but not to Select mode (see :h mapmode-x ).


={============================================================================
*kt_dev_env_vim_129* pattern: global command

The :global command is one of Vim's power tools for performing repetitive work efficiently.

The :global command takes the following form (see :h :g)

:[range] global[!] /{pattern}/ [cmd]

The :global command works by making two passes through the lines specified by [range]. In the first
pass, Vim marks each line that matches the specified {pattern}. Then on the second pass, the [cmd]
is executed for each marked line.

:global! or :vglobal (mnemonic: invert).

<defaults>
The default range for the :global command is the entire file (%). That sets it apart from most other
Ex commands, including :delete, :substitute, and :normal, whose range is the current line (.) by
default.

The {pattern} field integrates with search history. That means we can leave it blank and Vim will
automatically use the 'current' search pattern.

If we don't specify a [cmd], then Vim will use :print by default.

<example>
What if we wanted to throw away everything except for the contents of each <a> tag? In this file,

<ol>
  <li>
    <a href="/episodes/show-invisibles/">
      Show invisibles 
    </a>
  </li>
  <li>
    <a href="/episodes/tabs-and-spaces/">
      Tabs and Spaces 
    </a>
  </li>
  <li>
    <a href="/episodes/whitespace-preferences-and-filetypes/">
      Whitespace preferences and filetypes 
    </a>
  </li>
</ol>

1. Use pattern
/\v\<\/?\w+>
:g//d

The regular expression uses very magic mode. It matches an opening angle bracket (\<), followed by
an optional forward slash (\/?), and then one or more word characters (\w+) followed by an
end-ofword delimiter (>).

note: do not use pattern in global command since uses the previous search pattern.

The result:
      Show invisibles 
      Tabs and Spaces 
      Whitespace preferences and filetypes 

2. Use vglobal
:v/href/d

The result:
<a href="/episodes/show-invisibles/">
<a href="/episodes/tabs-and-spaces/">
<a href="/episodes/whitespace-preferences-and-filetypes/">

With a single command, we've condensed the file to the lines that interest us.


<example> collect TODO items

Markdown.dialects.Gruber = {
    lists: function() {
        // TODO: Cache this regexp for certain depths.
        function regex_for_depth(depth) { /* implementation */ }
    },
    "`": function inlineCode( text ) {
        var m = text.match( /(`+)(([\s\S]*?)\1)/ );
        if ( m && m[2] )
            return [ m[1].length + m[2].length ];
        else {
            // TODO: No matching end code found - warn!
            return [ 1, "`" ];
        }
    }
}

<tip> 
To list all TODO matches

:g/TODO

Here's an alternative strategy: let's yank each line containing the word TODO into a register. Then
we can paste the contents of that register into another file and keep them around for later.

1. note: empty the register. First we'll need to clear it by running qaq. Let's break that down: qa
tells Vim to start recording a macro into the a register, and then q stops the recording. We didn't
type anything while the macro was recording, so the register ends up empty.

2. Yank matched lines to the a register. note: Used uppercase A since it means 'append' line to the
register. If use 'a' instead then the register will have the last matched line.

:g/TODO/yank A
:reg a

3. Then paste, "ap

<alternative>
:g/TODO/t$

Simply copy it to the end of the file. After running this command, we could jump to the end of the
file to review the TODO items. This technique is more straightforward because it avoids messing
around with registers. But it won't work as neatly with the :argdo and :bufdo commands.

<alternative>
Could even combine the :global command with either :bufdo or :argdo to collect all TODO items from a
set of files. I'll leave that as an exercise for you, but look to Tip 96, on page 233, for a hint at
the workflow.


<example>
This technique is especially useful in cases where the :g/{pattern} matches a large number of lines.

Suppose that we want to sort the properties of each rule into alphabetical order. Can do by
selecting a block and run vim sort command.

{start}  html {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
         }
vi{      html {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
         }
:'<,'>sort html {
            border: 0;
            font-size: 100%;
            font: inherit;
            margin: 0;
            padding: 0;
            vertical-align: baseline;
         }

Suppose that we had a style sheet containing hundreds of rules. Wouldn't it be better if we could
automate the process somehow?

<solution>
:g/{/ .+1,/}/-1 sort

1. Ex commands can usually accept a range themselves. This is still true for the [cmd] in the
context of a :global command. So we could expand the template as follows:

:g/{pattern}/[range][cmd]

The [range] for our [cmd] can be set 'dynamically' using the match from :g/{pattern} as a reference
point. Normally the . address stands for the line that the cursor is positioned on. But in the
context of a :global command, it stands for each line in turn that matches the specified {pattern}.

:.+1,/}/-1 sort

If we strip out the offsets from our range, it becomes simply .,/}/. We can interpret this as "from
the current line up until the next line that matches the /}/ pattern." The +1 and -1 offsets simply
narrow the range to focus on the contents of the {} block.

We just need to position our cursor at the start of each {} block and then run the :.,/}/sort
command

/{/

Let's put our :global and [cmd] Ex commands back together:

:g/{/ .+1,/}/-1 sort

The { pattern matches the first line of each {} block. For every line that matches, the :sort
command is executed on a [range] that terminates at the end of the {} block.

A generalized form of this :global command goes like this:

:g/{start}/ .,{finish} [cmd]

<example>
We could use the same in combination with any Ex command. For example, suppose that we wanted to
indent the specified ranges. We could do so with the :> Ex command (see :h :>):

:g/{/ .+1,/}/-1 > 

Note that the :> command echoes a message each time it is invoked, whereas :sort doesn't. We can
mute these messages by prefixing our [cmd] with :silent (see :h :sil ):

:g/{/sil .+1,/}/-1 > 


={============================================================================
*kt_dev_env_vim_004* vim-syntax

From usr_44.txt

To check which syntax items are currently defined, use this command:

:syn[tax]

You can use this to check which items have actually been defined.  Quite useful
when you are experimenting with a new syntax file.  It also shows the colors
used for each item, which helps to find out what is what.

To list the items in a specific syntax group use:

:syntax list {group-name}


MATCHING CASE

Others, such as C, are case sensitive.  You need to tell which type you have
with the following commands:

:syntax case match
:syntax case ignore

The "match" argument means that Vim will match the case of syntax elements.
Therefore, "int" differs from "Int" and "INT".


*44.2*	Keywords

The most basic syntax elements are keywords.  To define a keyword, use the
following form:

:syntax keyword {group} {keyword} ...

The {group} is the name of a syntax group.  

With the ":highlight" command you can `assign colors` to a {group}.  

The {keyword} argument is an `actual keyword`.  Here are a few examples:

:syntax keyword xType int long char
:syntax keyword xStatement if then else endif

This example uses the group names "xType" and "xStatement".  By convention, each
group name is prefixed by the filetype for the language being defined.  This
example defines syntax for the x language.  In a syntax file for "csh" scripts
the name "cshType" would be used.  Thus the prefix is equal to the value of
'filetype'.

These commands cause the words "int", "long" and "char" to be highlighted one
way and the words "if", "then", "else" and "endif" to be highlighted another
way. 

Now you need to connect the x group names to standard Vim names.  You do this
with the following commands:

note:
connect `syntax group` to `vim name`

:highlight link xType Type
:highlight link xStatement Statement

This tells Vim to highlight "xType" like "Type" and "xStatement" like
"Statement". See |group-name| for the standard names.


<standard-name>
To be able to allow each user to pick his favorite set of colors, there must be
preferred names for highlight groups that are common for many languages.  These
are the suggested group names (if syntax highlighting works properly you can see
    the actual color, except for "Ignore"):

	*Comment	any comment

	*Statement	any statement
	 Conditional	if, then, else, endif, switch, etc.
	 Repeat		for, do, while, etc.
	 Label		case, default, etc.
	 Operator	"sizeof", "+", "*", etc.
	 Keyword	any other keyword
	 Exception	try, catch, throw

...


The x language allows for abbreviations.  For example, "next" can be
abbreviated to "n", "ne" or "nex".  You can define them by using this command:

:syntax keyword xStatement n[ext]

This doesn't match "nextone", keywords always match whole words only.


*44.3*	Matches

Consider defining something a bit more complex.  You want to match ordinary
identifiers.  To do this, you define a match `syntax item`.  This one matches
any word consisting of only lowercase letters:

:syntax match xIdentifier /\<\l\+\>/
 
Note:
keywords overrule any other syntax item.  Thus the keywords "if", "then", etc.,
         will be keywords, as defined with the ":syntax keyword" commands above,
         even though they also match the pattern for xIdentifier.

The part at the end is a `pattern`, like it's used for searching.  The // is
used to surround the pattern (like how it's done in a ":substitute" command).

You can use any other character, like a plus or a `quote`.

<ex> from cpp.vim
syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\
s*$"


Now define a match for a comment.  In the x language it is anything from # to
the end of a line:

:syntax match xComment /#.*/

Since you can use any search pattern, you can highlight very complex things with
a match item.


*44.4*	Regions

In the example x language, strings are enclosed in double quotation marks (").
To highlight strings you define a region.  You need a region start (double
    quote) and a region end (double quote).  The definition is as follows:

:syntax region xString start=/"/ end=/"/

The "start" and "end" directives define the patterns used to find the start
and end of the region.  But what about strings that look like this?

	"A string with a double quote (\") in it" 

This creates a problem: The double quotation marks in the middle of the string
will end the region.  You need to tell Vim to skip over any escaped double
quotes in the string.  Do this with the skip keyword:

:syntax region xString start=/"/ skip=/\\"/ end=/"/

The double backslash matches a single backslash, since the backslash is a
special character in search patterns.

When to use a region instead of a match?  The `main difference` is that a match
item is a single pattern, which must match as a whole.  A region starts as soon
as the "start" pattern matches.  Whether the "end" pattern is found or not
doesn't matter.  Thus when the item depends on the "end" pattern to match, you
cannot use a region.  Otherwise, regions are often simpler to define.  And it is
easier to use nested items, as is explained in the next section.


*44.5*	Nested items

Take a look at this comment:

	%Get input  TODO: Skip white space 

You want to highlight TODO in big yellow letters, `even though` it is in a
comment that is highlighted blue.  To let Vim know about this, you define the
following syntax groups:

:syntax keyword xTodo TODO contained
:syntax match xComment /%.*/ contains=xTodo

In the first line, the "contained" argument tells Vim that this keyword can
exist only inside another syntax item.  The next line has "contains=xTodo".
This indicates that the xTodo syntax element is inside it.  The result is that
the comment line as a whole is matched with "xComment" and made blue.  The word
TODO inside it is matched by xTodo and highlighted yellow (highlighting for
    xTodo was setup for this).


*44.11*	Installing a syntax file

When your new syntax file is ready to be used, drop it in a "syntax" directory
in 'runtimepath'.  For Unix that would be "~/.vim/syntax".  The name of the
syntax file must be equal to the file type, with ".vim" added.  Thus for the x
language, the full path of the file would be:

~/.vim/syntax/x.vim 

You must also make the file type be recognized. See |43.2|.


{colorscheme}

:colorscheme evening

{color-syntax}

:syntax clear		# to disable
:syntax off			# to turn off


={============================================================================
*kt_dev_env_vim_130* vim-syntax-hide

6. :syntax arguments *:syn-arguments*

The :syntax commands that define syntax items take a number of arguments.
The common ones are explained here.  The arguments may be given in any order
and may be mixed with patterns.

Not all commands accept all arguments.	This table shows which arguments
can `not` be used for all commands:

                contains  oneline   fold  display   extend  concealends~
:syntax keyword   -         -         -     -         -         -
:syntax match     yes       -         yes   yes       yes       -
:syntax region    yes       yes       yes   yes       yes       yes

These arguments can be used for all three commands:
   conceal
   cchar
   contained
   containedin
   nextgroup
   transparent
   skipwhite
   skipnl
   skipempty


conceal

When the "conceal" argument is given, the item is marked as concealable.
Whether or not it is actually concealed depends on the value of the
'conceallevel' option.  

The 'concealcursor' option is used to decide whether concealable items in the
current line are displayed unconcealed to be able to edit the line.

You can use matching, combined with syntax highlighting and the conceal feature
to actually `not show` matched characters inside lines.


cchar

The "cchar" argument defines the character shown in place of the item when it is
concealed (setting "cchar" only makes sense when the conceal argument is given.)
If "cchar" is not set then the default conceal character defined in the
'listchars' option is used.


'conceallevel' 'cole'
number (default 0)
local to window
{not available when compiled without the |+conceal| feature}

Determine how text with the "conceal" syntax attribute |:syn-conceal| is shown:

Valu  Effect 

0     Text is shown normally

1     Each block of concealed text is replaced with one
      character.  If the syntax item does not have a custom
      replacement character defined (see |:syn-cchar|) the
      character defined in 'listchars' is used (default is a
      space).
      It is highlighted with the "Conceal" highlight group.

2     Concealed text is completely hidden unless it has a
      custom replacement character defined (see
      |:syn-cchar|).

3     Concealed text is completely hidden.

Note: in the cursor line concealed text is not hidden, so that you can edit and
copy the text. This can be changed with the 'concealcursor' option.


'concealcursor' 'cocu' string (default: "")

Sets the modes in which text in the cursor line can also be concealed.  When the
current mode is listed then concealing happens just like in other lines.

  n      Normal mode
  v      Visual mode
  i      Insert mode
  c      Command line editing, for 'incsearch'

'v' applies to all lines in the Visual area, not only the cursor.

A useful value is "nc".  This is used in help files.  So long as you are moving
around text is concealed, but when starting to insert text or selecting a Visual
area the concealed text is displayed, so that you can see what you are doing.
Keep in mind that the cursor position is not always where it's displayed.  E.g.,
     when moving vertically it may change column.

note:
To prevent the cursor line from expanding.

set concealcursor=nc

<ex>
To hide the first 25 chars of each line.

:syn match Concealed '^.\{25\}' conceal
:set conceallevel=2

To hide only the lines with the punctuation of a date instead:

:syn match Concealed '^....-..-.. ..:..:..\..... ' conceal

To unhide:

:syn clear Concealed
:set conceallevel=0

What looks like this normally:

YYYY-MM-DD HH:MM:SS.USEC PID Name LogText
YYYY-MM-DD HH:MM:SS.USEC PID Name LogText

will look like this after executing the first two commands:

PID Name LogText
PID Name LogText

<ex>
:syn match Concealed '\/home.*\/src' conceal
:set conceallevel=0
:set concealcursor=nc

:syn match Concealed 'NDS: [:digit:]{10}\.[:digit:]{6}' 25\}' conceal
NDS: ^[2016:06:10 15:52:53]
0946701324.837014 !MIL    -EPG_TVG      		
< p:0x00000196 P:APP t:0x2df56520 T:no name 
M:ProgrammesRetriever F:createProgrammesList L:326 > T:PooledExecutor#4:Guide Programme 7 Title: The Big Bang Theory Start Time [2016:06:10 23:10:00]1465600200 Duration 1800

:syn match log_field_03 'p:0x[0-9]*' conceal
:syn match log_field_04 'P:[a-zA-Z]*' conceal
:syn match log_field_05 't:0x[0-9a-zA-Z]*' conceal
:syn match log_field_06 'T:[ a-zA-Z]*\b' conceal
:syn match log_field_07 'L:[0-9]*' conceal

:syn match log_field_01 '^[0-9:]*NDS: ' conceal
:syn match log_field_02 '[0-9]\{10\}.[0-9]\{6\}' conceal
:syn match log_field_03 '\t\{1,\}' conceal
:syn match log_field_08 '\<.*\>' conceal
:syn match log_field_09 '\<.*F:|$' conceal


={============================================================================
*kt_dev_env_vim_130* vim-spell

http://vimcasts.org/episodes/spell-checking/

:set spell
:set spell!
:windo set spell

nnoremap <silent> [unite]s :set spell!<cr>
note: do not have set spell by default becuase to have spell check as a separate
task.

<lang>
set spelllang=en_gb

This is local to buffer.

]s S     " move to next misspelled word. S only for bad word
[s S     " move back to next misspelled word

z=       " show suggestions

<file>
Name of the word list file where words are added for the |zg| and |zw| commands.
It must end in ".{encoding}.add".  You need to include the path, otherwise the
file is placed in the current directory.

set spellfile=~/.vim/spell/en.utf-8.add 
note: if there is no spell dir then create it manually.

zg       " add word under the cursor as a good word
         " add it to spellfile as it is
zw       " add word under the cursor as a bad word
         " add it to spellfile with ! char at the end

zug
zuw

These simply add entry to the file and when repeats this on the same words or
comment out for undoed words, this file gets bigger. So To clean up the comment
lines in all ".add" spell files do this: >

:runtime spell/cleanadd.vim


={============================================================================
*kt_dev_env_vim_131* vim-diff

#60. Comparing buffers with vimdiff

http://vimcasts.org/episodes/comparing-buffers-with-vimdiff/

<diff-between-buffers>

Using :diffthis to compare two buffers

The :diffthis command allows us to compare two (or more) buffers that are open
in an existing Vim session. If we have two split windows containing buffers that
we want to compare, then we can diff them by running:

:windo diffthis

:difft[his]
Make the current window part of the diff windows. This sets the options like for
"vimdiff".


We can turn diff mode off just as easily, by running:

:windo diffoff

:diffo[ff]
Switch off diff mode for the current window. Resets related options also when
'diff' was not set.


The nice thing about this technique is that we can use an unnamed buffer.
There's no need to write the text to a temporary file. In the video
demonstration, the buffer on the left corresponds to a file on my local
filesystem, while the buffer on the right has no associated file. This technique
would work just as well if neither buffer had been saved to disk, which makes it
pretty flexible.

note:
Diffs are local to the current tab page |tab-page|. You can't see diffs with a
window in another tab page.

note:
The differences shown are actually the differences in the 'buffer'. Thus if you
make changes after loading a file, these will be included in the displayed
diffs. You might have to do ":diffupdate" now and then, not all changes are
immediately taken into account.


<diff-move>

Getting around in diff mode

In diff mode, Vim provides two handy motions for getting around: [c and ]c jump
back and forward between changes. If you want to resolve the differences between
files, you can do so using the :diffget and :diffput commands.

]c       " move to next change
[c       " move back to next change


<diff-get-put>
Do not need to type ":".

do
[count]do
  
Same as ":diffget" without range. The "o" stands for "obtain". Note: this
doesn't work in Visual mode. If you give a [count], it is used as the [bufspec]
argument for ":diffget".

dp
[count]dp

Same as ":diffput" without range. Note: this doesn't work in Visual mode.  If
you give a [count], it is used as the [bufspec] argument for ":diffput".

:help :diffget
:help :diffput
:help do
:help dp


={============================================================================
*kt_dev_env_vim_132* yank current filename to a register. expand

Yank current filename to + register and paste it to use.

:let @+ = expand("%")

nmap cp :let @+ = expand("%")

:h expand for more detail.


={============================================================================
*kt_dev_env_vim_140* shell: run external program and bang(!) 

:!{cmd}              " Execute {cmd} with the shell
:read !{cmd}         " Execute {cmd} in the shell and insert its standard output below the cursor
:[range]write !{cmd} " Execute {cmd} in the shell with [range] lines as standard input
:[range]!{filter}    " Filter the specified [range] through external program {filter}


{run-shell-command}
:{range}!{cmd}

:2,$!sort -t',' -k2     " sort [2,$] lines on the second field.

<tip> :h :range!
For example, if we place our cursor on line 2 and then invoke !G, Vim opens a prompt with the :.,$!
range set up for us. We still have to type out the rest of the {filter} command, but it saves a
little work.


note that should be careful of the place of ! (bang) character since 
:write !sh     " okay
:write ! sh    " okay
:write! sh     " not okay


{redirect}
<write-command>
Refer to :h rename-files for a nice example of this command in use.

:write !{cmd}

<read-command>
:0read !date -u
:0read !date /t   " for windows
:r[ead] filename  " insert into the cursor position

:!!date<Enter>    " replaces the current line with the output of "date". 


={============================================================================
*kt_dev_env_vim_141* vim-shell
  
<foreground>
C-z      " to suspend vim and get back to the shell
fg       " to get back to vim

// :set shell?    " to check shell setting
// :sh            " to run shell in vim
// C-d            " to end the shell and return to vim


={============================================================================
*kt_dev_env_vim_150* format, wrap, tw

{display-and-numbered-line}
'wrap' and 'linebreak' control the display of text so the long line is a single line even if it is
diaplayed on multiple lines. To get vim to insert newlines in the file as you type, set textwidth to
the desired width (e.g. 80). note: In help file, tw=xxx don't seem to work for me.

:set wrap            " to eanble wrap

http://vimcasts.org/episodes/soft-wrapping-text/

By default Vim will break lines at exactly the width of the window, which causes some words to be
split across two lines. To prevent this from happening, you can enable 

:set linebreak

However, the linebreak setting will not work when the list setting is enabled. So to use linebreak
as expected, shall use the three:

:set wrap linebreak nolist

Rather than having to ensure that 3 separate options are configured correctly, I would prefer if I
could just issue the command :Wrap. This can be achieved by putting the following in your .vimrc
file:

command! -nargs=* Wrap set wrap linebreak nolist

note: see :h user-command


<move-in-displayed-lines>
Unlike many text editing environments, Vim makes a distinction between displayed lines, and numbered
lines. When wrap is enabled, each numbered line might be split across more than one display lines.
The k and j keys move up and down by numbered lines. If you want to move the cursor up and down by
display lines instead, you can use the commands gk and gj instead.

Hitting two keys in quick succession feels slow compared to pressing a single key whilst holding
down a modifier key. I have the following in my .vimrc file:

vmap <D-j> gj
vmap <D-k> gk
vmap <D-4> g$
vmap <D-6> g^
vmap <D-0> g^
nmap <D-j> gj
nmap <D-k> gk
nmap <D-4> g$
nmap <D-6> g^
nmap <D-0> g^

On the mac, this allows me to use j, k, $, 0 and ^ on display lines by holding down the command key.

<showbreak>
If you prefer not to show line numbers, there is another way. The showbreak option can be set to a
character which will lead each display line after the first one. It can be set as follows:

set showbreak="… " 
set showbreak="> " 

To insert the elipsis, press ctrl-vu followed by the numeric code for elipsis: 2026. Episode 1
covers unicode character insertion in a little more detail. ctrl-v u2026


={============================================================================
*kt_dev_env_vim_150* vim-textwidth

{local-to-buffer}
This is "local to buffer" and even when set it in vimrc as global, still don't
have it applied. Why?

Vim has this covered with the global vs. buffer-local options. As you describe,
    you're supposed to :set a global default in your ~/.vimrc, and some
    filetypes may override the global default with :setlocal.

For troubleshooting, try

:verbose set tw?

This should tell you the last place that modified the option value.

  textwidth=78
      Last set from ~/share/vim/vim74/ftplugin/help.vim


/share/vim/vim74/ftplugin/help.vim

" Vim filetype plugin file
" Language:         Vim help file
" Maintainer:       Nikolai Weibull <now@bitwi.se>
" Latest Revision:  2008-07-09

if exists("b:did_ftplugin")
  finish
endif
let b:did_ftplugin = 1

let s:cpo_save = &cpo
set cpo&vim

let b:undo_ftplugin = "setl fo< tw< cole< cocu<"

setlocal formatoptions+=tcroql textwidth=78
if has("conceal")
  setlocal cole=2 cocu=nc
endif

let &cpo = s:cpo_save
unlet s:cpo_save


{format}
:set tw=xxx

when use 'textwidth' it works well when typing in VIM but when copy text from
external source then it doesn't work; that's don't fit into textwidth setting of
the current file. 

two solution to this:

gq}                     # to manucl format
gpap                    # <a> paragraph
gqG                     # formats the text starting from the current and to the end of the file. 
                        # It will automatically join consecutive lines when possible.

Note: 
A blank line, which contains white space, does NOT separate paragraphs. This is
hard to notice!

set formatoptions+=a    # vim to do it automatically. help auto-format

(this makes no use of following)
i CTRL-R *              # paste clipboard with maintaining formatting. see i_CTRL-R


<colorcolumn>
This option was added in (g)vim 7.3 and can be used with if and filetype

set colorcolumn cc=100

={============================================================================
*kt_dev_env_vim_151* encoding and utf8

When tris to use {show-invisibles}, face two problems:

<1> cannot see the unicode chars in test file. need to change encoding format
to see these.

set encoding=utf-8

<2> Now able to see and enter unicode but see errors when loading vimrc:

$ gvim kt_dev_env.txt 
Error detected while processing /home/kpark/.vimrc:
line   67:
E474: Invalid argument: listchars=tab:â~V¸\ ,eol:Â¬

The solution is to add these in vimrc.

scriptencoding utf-8
set encoding=utf-8


{encoding}
:h encoding-names

The content on your source web page was overzealously reformatted. The text was undoubtedly supposed
to use (straight) single quotes (ASCII 39/0x27, U+0027) instead of curly single quotes (U+2018 and
U+2019, which are 0x91 and 0x92 in CP1252 (also known as MS-ANSI and WINDOWS-1252; a common 8-bit
encoding on Windows)).

Vim is showing you the hex codes because they are not valid in whatever encoding Vim is using
(probably UTF-8). If you are editing text that has already been saved in a file, then you can reload
the file as CP1252 with 

:e ++enc=cp1252 

 [KT] for korean windows 949
:e ++enc=cp949 	

this should make the curly quotes visible. But there is no real reason to reload it as CP1252, just
delete the 0x91 and 0x92 characters and replace them with single quotes.

To change the hex 91/92 characters in you need to do:
:%s/[\x91\x92]/'/g

To change the quote from compiler errors:


{how-to-convert-file-format}
utf8 is default. If you are editing a file encoded as latin1, you will find that 'fileencoding' for
that buffer is set to latin1. So you will need to manually set the fileencoding before saving the
file

:set fileencoding=utf8
:w myfilename

For more information :help mbyte-options and :help utf8


={============================================================================
*kt_dev_env_vim_152* how: how to change word between '_'

Suppose that want to change the function to 

gst_nexus_sink_event_locked() -> gst_nexus_sink_render_locked()

The problem is when use "cw" it regards it a whole since '_' is not a
delimeter to vim. How to solve?

Two:

* use "iskeyword"

'iskeyword' 'isk'	string (Vim default for MS-DOS and Win32:
					    "@,48-57,_,128-167,224-235"
				   otherwise:  "@,48-57,_,192-255"
				Vi default: "@,48-57,_")
			local to buffer
			{not in Vi}

Keywords are used in searching and recognizing with many commands: "w", "*",
         "[i", etc.  It is also used for "\k" in a |pattern|. 

See 'isfname' for a description of the format of this option. For C programs
you could use "a-z,A-Z,48-57,_,.,-,>". For a help file it is set to all
non-blank printable characters except '*', '"' and '|' (so that CTRL-] on a
        command finds the help for that command). When the 'lisp' option is on
the '-' character is always included. NOTE: This option is set to the Vi
default value when 'compatible' is set and to the Vim default value when
'compatible' is reset.

:set iskeyword-=_ 


* use "ct_" instead of "cw"


# ============================================================================
#{
={============================================================================
*kt_dev_env_vim_200* prog:edit: adding and substracting

<C-a> and <C-x> increments and decrements the number the cursor is placed on. This is especially
good because Vim understands different 'bases'. This command will "add [count] to the number at or
after the cursor"

The <C-a> and <C-x> commands work for (signed) decimal numbers, unsigned octal and hexadecimal
numbers and alphabetic characters. This depends on the 'nrformats' option.

set nrformats=

This will cause Vim to treat all numerals as decimal, regardless of whether they are padded with
zeros.

<example>
What is the hexadecimal representation of 1564 (decimal)? Just place the cursor at the line which
has 0x0.

0x0

And now '1564 C-a ESC' (this tells Vim to do Ctrl-a 1564 times). You get 0x61c


={============================================================================
*kt_dev_env_vim_201* vim-edit-tab-space

{tabs}
See the cast, http://vimcasts.org/episodes/tabs-and-spaces/ for details.

:set ts tabstop=4       " set the value of a tab char
:set sts softtabstop=4  " set the value to use when press backspace or <C-h>
:set sw shiftwidth=4    " set the value to use when use shift operator
                        " note that this is used when use "=" to format code
:set et expandtab       " toggle to expand a tab char to spaces. noexpandtab

When tabstop=4, softtabstop=0, expandtab, press a tab in insert mode and it will
be extended to 4 spaces. However, when use a backspace, will remove a space one
by one. By setting softtabstop=4, backspace will remove 4 spaces.

So if prefer spaces to tab, have tabstop, softtabstop, and shiftwidth have the
'same' value.


{show-invisibles}
http://vimcasts.org/episodes/show-invisibles/

:set list
:set nolist
:set list!     " toggle

Every tab is displayed as ^I and a $ is displayed at the end of each line. To
change this:

" for tab and eof char
:set listchars=tab:▸\ ,eol:¬

▸ is ctrl-v u25b8.      note: do not work for debian and me. why?
¬ is ctrl-v u00ac.
» is ctrl-v u00bb.      note: works well
« is ctrl-v u00ab.


{text-shift}
<shift-operator>
Use shiftwidth setting. note that can use dot operator to repeat

>{motion}      " increase the indentation on {motion}.
>G             " increase the indentation from the current line to EOF.
[num]>         " increase the indentation by [count] times.
[num]<
[num]>>

<ex>
The example shows the block improperly indented. How to fix?

if( q.is_valid() )
{
  while( g.it != end )
  {
    char_t ch = *g.it;
    if( !ch.isspace() )
  {
      return q.calc();
  }
  }
}

Place a cursor return statement and use >a} or >aB

if( q.is_valid() )
{
  while( g.it != end )
  {
    char_t ch = *g.it;
    if( !ch.isspace() )
    {
      return q.calc();
    }
  }
}


Or you can paste with auto-reindent (just ']p' in vim)
["x]]p	" Like "p", but adjust the indent to the current line.


{indention} {=-command}

:set autoindent
:set smartindent
:set cindent

Another command to use for indentation is = (equal). It 'filters' the text with an external program
(if specified) or with the internal C indentation routine. To specify an external filter, you have
to set the equalprg variable:

:set equalprog=indent

Note that the definition for filter is 'program that accepts text at stantard input, changes it in
some way, and sends it to the standard output'. Not all programs match this criteria. Regardless of
the rutine used to filter the text, = indents the line where the cursor is placed or the selected
text if any.

Tip: G=gg indents the whole file. This is very useful when copy-pasting from another window, remote
session, etc, messes the indentation up. In the picture below, the left window shows a code copied
from the Internet and the right one, the same text after doing G=gg

You can always indent text blocks freely if the automatic indentation rules do not fit your taste.
In order to do this, use the <> commands. Applied twice on a text object they indent that text to
the left or to the right.


={============================================================================
*kt_dev_env_vim_202* prog:edit: match command

<PLUGIN> matchit
Even though matchit ships with the Vim distribution, it's not enabled by default. The enhancements
provided by this plugin are very useful, so I'd recommend enabling it. Consult :h matchit-install
for more details.

vim/vim74/macros

filetype plugin on
runtime macros/matchit.vim


{plugin} surround
One of my favorite plugins is surround.vim by Tim Pope,a which makes wrapping a selection with a
pair of delimiters easy. For example, we could put the words New York in quote marks:

Keystrokes Buffer Contents
{start}  cities = ["London", "Berlin", New York]
vee      cities = ["London", "Berlin", New York]
S"       cities = ["London", "Berlin", "New York"]

The S" command is provided by surround.vim, and it can be read as "Surround the selection with a
pair of double quote marks." We could just as easily use S) or S} if we wanted to wrap the selection
with opening and closing parentheses or braces. We can also use surround.vim to change existing
delimiters. For example, we could change {London} to [London] with the cs}] command, which can be
read as "Change surrounding {} braces to [] brackets." Or we could go the other way with the cs]}
command. It's a powerful plugin. Check it out.

http://github.com/tpope/vim-surround


{match-command} see :h %
Use '%' alone, this jumps between open and close pairs based on the value of the matchpairs option.

<matchpairs-option>
But angle brackets - <> - aren't included by default. They may be set based on the filetype. The
HTML filetype plugin sets it, so if you're opening HTML files you'll be able to use % to jump
between matching angle brackets. But not for e.g. C++/Java.

To add angle brackets if they aren't jumped when using %, use:

:set matchpairs+=<:>

Now using % on angle brackets should jump to the matching bracket. See :help 'matchpairs' and :help
various-motions for more details.

<example>
The trick here is to use the % command before making any changes. When we use the % command, Vim
automatically sets a mark for the location from which we jumped. We can snap back to it by pressing
``.

{start}  cities = %w{London Berlin New\ York}
dt{      cities = {London Berlin New\ York}
%        cities = {London Berlin New\ York}
r]       cities = {London Berlin New\ York]
``       cities = {London Berlin New\ York]
r[       cities = [London Berlin New\ York]


{example-in-coding}

From http://www.viemu.com/a-why-vi-vim.html

to change from:

if(!entry.used && equivalent(entry.key(), qk.key) && (curcontext & entry.context))

to:

bool equiv = equivalent(entry.key(), qk.key);
if(!entry.used && equiv && (curcontext & entry.context))

move to the start of equivalent
c% equiv ESC
O bool equiv = p ;


if(!entry.used && equivalent(entry.key(), qk.key) && (curcontext & entry.context))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The '%' motion moves from a parenthesis (or similar grouping character) to its matching one - but if
you're not positioned at one of these special characters, it will scan character by character
<to-the-right>, until the first one is found, and then moving to the character matching that one.
So, in the above situation, it will move to the right closing parenthesis!

Knowing about the 'c' command, which deletes the extents of the next motion (also copying it to the
clipboard) and enters insert mode, we can type just 'c%' ("change match") from the above case. 


={============================================================================
*kt_dev_env_vim_300* vim-tag-cscope

If your version of Vim wasn't compiled with '--enable-cscope', you will need
to reconfigure and recompile Vim with that flag. 

The Cscope database (cscope.out) is generated the first time it is invoked.
Subsequent use will update the database based on file changes.

Cscope version 15.6 (http://cscope.sourceforge.net/)

cscope -b -R -s/vobs/DARWIN_PLATFORM
cscope -q -b -R -s/vobs/CMS_INFORMATION_SERVICES -s/vobs/DARWIN_PLATFORM
-s/vobs/CMS_MEDIA_SERVICES 

FILES
cscope.files
Default files containing -I, -p, -q, and -T options and the list of source
files (overridden by the -i option). 

cscope.out
Symbol cross-reference file (overridden by the -f option), which is put in the
home directory if it cannot be created in the current directory. 

cscope.in.out 
cscope.po.out
Default files containing the inverted index used for quick symbol searching
(-q option). If you use the -f option to rename the cross-reference file (so
    it's not cscope.out), the names for these inverted index files will be
created by adding .in and .po to the name you supply with -f.  For example, if
you indicated -f xyz, then these files would be named xyz.in and xyz.po.


(in vim)
:cscope add /home/NDS-UK/parkkt/cc/parkkt_BSKYB_GM_002/cscope.out
:cscope find search-type search-string 
:cs f s player_api_events.c

0 or s: Find this C symbol (get header and source for a symbol)
1 or g: Find this definition (get header only)
2 or d: Find functions called by this function
3 or c: Find functions calling this function
4 or t: Find this text string
6 or e: Find this egrep pattern
7 or f: Find this file
8 or i: Find files #including this file


={============================================================================
*kt_dev_env_vim_301* vim-tag-ctag

{install}
http://ctags.sourceforge.net/

<ubuntu>
sudo apt-get install ctags
sudo apt-get install exuberant-ctags

<version>
$ ctags --version
Exuberant Ctags 5.9~svn20110310, Copyright (C) 1996-2009 Darren Hiebert
  Compiled: Nov  9 2011, 17:40:39
  Addresses: <dhiebert@users.sourceforge.net>, http://ctags.sourceforge.net
  Optional compiled features: +wildcards, +regex


{generate-a-tag}

<use-list>
  -L <file>
       A list of source file names are read from the specified file.
       If specified as "-", then standard input is read.

note:
By using the same list file, can use it for both ctag and gtag.


// <use-recursive>
// 
// ctags -R .
// 
// To set the place to create a tag:
// 
// ctags -R -f ./.git/tags .
// ctags -R -f oem-hwei-7409.tags --c++-kinds=+p --fields=+iaS --extra=+q \
//          --tag-relative=yes /opt/oem-staging/huawei-bcm7409/usr/local
// 
// note: -f should be before than --fields
// 
// For some users that need more info of the symbols
// 
// ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .
// 
// <in-vim>
// :!ctags -R


{automatic-tag-creation}

:nnoremap <f5> :!ctags -R<CR>

but we still have to remember periodically to generate the tags file. Now
let's consider a couple of options for automating this process.

Practical Vim 16. Tip 102.

Vim's autocommand feature allows us to invoke a command on each occurrence of
an event, such as a buffer being created, opened, or written to file. We could
set up an autocommand that invokes ctags every time we save a file:

http://andrewradev.com/2011/06/08/vim-and-ctags/

<solution-one> plugin:autotag
1. The ctag has an -a flag that makes it append to a tag file instead of
overwriting it. That way you can update the tags very quickly every time a
file changes. With vim's autocommands, this could work like this:

autocmd BufWritePost *
      \ if filereadable('tags') |
      \   call system('ctags -a '.expand('%')) |
      \ endif

Unfortunately, there's an issue with this approach. Ctags will only add new
tags, it won't remove ones that are no longer present. If you delete a
function, it will still appear in the tag file.

That's where the autotag.vim plugin comes in. Whenever you save a file, it
deletes all of its entries and invokes ctags in append mode. I've been using
it for a long time and I haven't noticed any overhead at all, even on Windows
boxes. Unfortunately, your vim build needs to have python support to use it.
Even if it doesn't, though, no errors are raised, which is nice if you use the
same vimfiles across different vim builds like I do.

autotag: http://www.vim.org/scripts/script.php?script_id=1343

15. How should I set up tag files for a multi-level directory hierarchy? 
http://ctags.sourceforge.net/faq.html

<solution-two>
Most source control systems provide hooks that allow us to execute a script in
response to events on the repository. We can use these to instruct our source
control to re-index the repository every time we commit our code.


<consideration>
Using an autocommand to invoke ctags every time a buffer is saved ensures that
our tags file is always up-to-date, but at what cost? Re-indexing our codebase
on each commit strikes a good balance.  The code that we're actively working
on is the code we're least likely to want to navigate using tags.

note: think that it is a good balance to have the second solution and the way
to run it manually such as key mapping.

<ctag-options>
From ctags faq:
7. Why can't I jump to class::member?

Because, by default, ctags only generates tags for the separate identifiers
found in the source files. If you specify the --extra=+q option, then ctags
will also generate a second, class-qualified tag for each class member (data
    and function/method) in the form class::member for C++, and in the form
class.method for Eiffel and Java. 

// --exclude=[pattern]
--exclude=.git
--languages=-sql


{tags-for-external}
When ./ is used in the tags option, Vim replaces it with the path of the
currently active file. We can inspect the defaults:

:set tags?
   tags=./tags,tags

With these settings, Vim looks for a tags file in the directory of the current
file and in the 'working' directory.

The generated tags file only contains the symbols in the files in your project
source tree, but not any external file, such as standard header files 

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q /usr/include


<solution-one> add only files that used in the project
Why must we generate a tags file containing all the symbols in the system
header? If we only generate the tags file 'only' for the header files that are
'related' to our projects, would it be faster? That's the point of this idea.
We could first search for the header files that are included in our projects,
   and then we use ctags to generate a tags file for these files and our
   source files, in this way, a much smaller tags file that containing all the
   symbols that maybe useful for the project is generated. The solution is:

#!/bin/sh
# ./ctags_with_dep.sh file1.c file2.c ... to generate a tags file for these files.
gcc -M $* | sed -e 's/[\\ ]/\n/g' | \
sed -e '/^$/d' -e '/\.o:[ \t]*$/d' | \
ctags -L - --c++-kinds=+p --fields=+iaS --extra=+q 

./ctags_with_dep.sh file1.c file2.c file3.cpp ...

The idea is that -M list header files, sed process this and pipe it into ctags using -L option.

What if you have other directories besides the standard /usr/include that containing the header
files you need? You could do a little modification on this script. For example, you have some header
files in ~/include, then you could pass -I ~/include to the gcc command. Just like below:

gcc -M -I ~/include $* | sed -e 's/[\\ ]/\n/g' | \
sed -e '/^$/d' -e '/\.o:[ \t]*$/d' | \
ctags -L - --c++-kinds=+p --fields=+iaS --extra=+q 

<solution-two>
The other way is that create a tag file for system headers once and use when
it is needed.

:se tags+=/usr/include/tags

Here se is se[t] in vim and ctags read a tag file from the current directory
so can set one in a different directory and 'add' it the 'database'.


{tag-config}
Either by setting the environment variable CTAGS to your custom options, or putting them into a
.ctags file in your home directory. 

http://blog.stwrt.ca/2012/10/31/vim-ctags:

For example, here's my ~/.ctags file:

# Basic options
--recurse=yes
--tag-relative=yes
--exclude=.git

note: Clojure is language and looks like this is how define new language for ctag.
# Regex for Clojure
--langdef=Clojure
--langmap=Clojure:.clj
--regex-clojure=/\([ \t]*create-ns[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/n,namespace/
--regex-clojure=/\([ \t]*def[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/d,definition/
--regex-clojure=/\([ \t]*defn-?[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/f,function/
--regex-clojure=/\([ \t]*defmacro[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/m,macro/
--regex-clojure=/\([ \t]*definline[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/i,inline/
--regex-clojure=/\([ \t]*defmulti[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/a,multimethod definition/
--regex-clojure=/\([ \t]*defmethod[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/b,multimethod instance/
--regex-clojure=/\([ \t]*defonce[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/c,definition (once)/
--regex-clojure=/\([ \t]*defstruct[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/s,struct/
--regex-clojure=/\([ \t]*intern[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/v,intern/
--regex-clojure=/\([ \t]*ns[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/n,namespace/


={============================================================================
*kt_dev_env_vim_302* vim-tag-stack

Practical Vim 16. Tip 103.

Vim's ctags integration turns the keywords in our code into a kind of
hyperlink, allowing us to jump rapidly to a definition.

{hyperlink}
The hyperlink is a text enclosed in vertical bars (for example, |help|) and
the destination is the notation *help.txt*. 


{tag-stack}
With the <C-]>, push command, the keyword on which the cursor is standing is
used as the tag. If the cursor is not on a keyword, the first keyword to the
right of the cursor is used. <C-t>, pop to [count] older entry in the tag
stack (default 1).

The most obvious way to use this is while browsing through the call graph of a
program. Consider the following call graph:

             ---> <C-]>
     main  --->  FuncA  --->  FuncC
           --->  FuncB
             <--- <C-t>

If the stack was full (it can hold up to 20 entries), the oldest entry is
deleted and the older entries shift one position up (their index number is
    decremented by one). 


<tell-tag-file>
Tell Vim Where to Find the Tags File

The `tags` option specifies where Vim should look to find a tags file (:h 'tags').

When ./ is used in the `tags` option, Vim replaces it with the path of the
currently active file. We can inspect the defaults:

:set tags?
 tags=./tags,tags

With these settings, Vim looks for a tags file in the directory of the current
file and in the working directory.


<tag-files>
Under certain conditions, if a match is found in the first tags file, Vim
won't even look in the second file (see :h tags-option for more details).

Using Vim's default settings, we could keep a tags file in every subdirectory
of our project. Or we could keep it simple by creating a global tags file in
the project root directory.  If you run ctags often enough to keep the index
up-to-date, then your tags file (or files) could show up in every source code
check-in. To keep your commit history clean, tell your source control to
ignore tags files.


<use-tag-list>
If it has multiple matches, then the g<C-]> command presents us with a list of
choices from the tag match list: note: <C-]> shows up the list.

If a tag in the current buffer matches the keyword, it gets the highest
priority. :h tag-priority

Can choose which destination we want to jump to by typing its number and
pressing <CR>.

:tn   " next. note: see "key mapping: traverse a list"
:tp   " prev
:ts   " select. show a list to select

<use-excomman>
We don't have to move the cursor on top of a keyword to jump to its tag. Can
use Ex commands. 

For example, :tag {keyword} and :tjump {keyword} behave like the <C-]> and
g<C-]> commands, respectively (see :h :tag and :h :tjump ).

At times, typing these commands can be quicker than maneuvering the cursor
onto a keyword in the document; especially since Vim provides `tab-completion`
for all keywords in the tags file. Can accept a regular expression when used
in the form

:ta[g] /{pattern}    note: leading '/' char in pattern.
:ta /phone$
:ta /^asserts_*

// :tags " history. To show the tags you've traversed since you opened vim
// :ltag " will load the tags into the location list window. You can then view
// that window by executing :lopen.


={============================================================================
*kt_dev_env_vim_302* prog: move in c

{move-in-source}
note: these commands are effectively search.

gd    " will take you to the local declaration.
gD    " will take you to the global declaration.

Note that this is not guaranteed to work, Vim does not really check the syntax, it only searches for
a match with the keyword. If included files also need to be searched use the commands listed in
|include-search|. After this command |n| searches forward for the next match (not backward).


g*    " search for the word under the cursor (like *, but g* on 'rain' will find words like 'rainbow').
g#    " same as g* but in backward direction.

gg    " goes to the first line in the buffer (or provide a count before the command for a specific line).
G     " goes to the last line (or provide a count before the command for a specific line). 

gf    " will go to the file under the cursor 


={============================================================================
*kt_dev_env_vim_303* vim-tag-gtag

{build}
2016/3/27
    GLOBAL-6.5.4 was released. This is a bug fix release. 
2016/3/18
    GLOBAL-6.5.3 was released. 

2015/12/16
    GLOBAL-6.5.2 was released. See release note. 
New facilities:
o Improvements of gtags.conf
  - Including from another file: Label syntax is expanded. (:address@hidden:)
  - Variable substitution: B shell like variable substitution is available.
  - Addition of variables: 'bindir', 'datadir', 'libdir' and 'localstatedir'.
    By default, these variables has a value given by the configure script.
  - gtags.conf(5): Online manual of the configuration file.
o global: Now the -N(--nearness) option also works with the -P and -g command
  as well as the tag search command.
o gtags.vim: New custom variable 'Gtags_Close_When_Single' (default 0).
  If this variable is set to 1, quickfix window is closed when single tag.

2015/9/15
    GLOBAL-6.5.1 was released. See release note. 
New facilities:
o gtags(c, c++): New environment variable GTAGSFORCEENDBLOCK.
  If this variable is set, each '}' at the first column brings
  end of all blocks.
o gtags: New --skip-unreadable option.
  If this option is specified, gtags skips unreadable files
  instead of exiting the command.

2015/6/10
    GLOBAL-6.5 was released.
New facilities:
o global: New -N (--nearness=[start]) option.
        Nearness sort method is available for the output of tag search command.
        The result of nearness sort is concatenation of the followings ([1]-[n])
        in this order. The default of 'start' is the current directory.
        [1] Output of local search in the 'start' directory.
        [2] Output of local search in the parent directory except for [1].
        [3] Output of local search in the grandparent directory except for [1]-[2].
        (repeat until the project root directory)
        [n] Output of local search in the project root directory except for [1]-[n-1].
        In each directory, they are sorted by alphabetical order.
o global: Now the --literal option also works with the tag search command,
        -P command and -I command as well as the -g command.

2015/2/2
    GLOBAL-6.3.4 was released. This is a bug fix release


{install}
http://www.gnu.org/software/global/whatsnew.html
https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools

$ wget http://tamacom.com/global/global-6.5.4.tar.gz

// <to-get-curses>
// http://www.gnu.org/software/ncurses/
// wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.9.tar.gz
// ./configure
// sudo make install

configure: error: curses library is required but not found. If you are not going
to use gtags-cscope, please try ./configure --disable-gtagscscop

<<<<<<< HEAD
./configure --prefix=/home/kit/inst --disable-gtagscscope --with-sqlite3
=======
$./configure --prefix=/home/kit/kitbin --disable-gtagscscope
>>>>>>> ed3df92cac911b8f9e5cc90c5e822b783790096a
# bin will be created uder the prefix

$ make
$ make install

(build & install)
$ gtags --sqlite3


{gtag}
https://www.gnu.org/software/global/globaldoc_toc.html#gtags

<options>
--skip-unreadable
    Skip unreadable files. 


<build-tags-from-list>

‘-f’, ‘--file’ file
    Give a list of candidates of target files. Files which are not on the list
    are ignored. The argument file can be set to ‘-’ to accept a list of files
    from the standard input. File names must be separated by newline. You may
    use find(1). 

find . -type f -print >/tmp/list     // make a file set
vi /tmp/list                         // customize the file set
gtags -f /tmp/list

note: 
-f option only allows filenames but not directory which means list out every
files.

note: 
don't use incremental tag updating.


#!/bin/bash
echo "building a gtag list..."
find -L $1 -name '*.[ch]' -o -name '*.[ch]pp' > flist.out 
gtags -f ./flist.out

<build-tags-with-ignore>
.agignore

ag -U --nopager --follow --nocolor --nogroup -g '' > gtaglist.out


// <build-tags-with-skip>
// Copy gtags.conf from install directory to the project root and edit to add
// rules.
// 
// From man gtags
// 
//        ´$HOME/.globalrc´, ´gtags.conf´
//               Gtags load a configuration file according to the following  pri‐
//               ority (Lower number means higher priority).
//               (1) $GTAGSCONF
//               (2) [project root]/gtags.conf
//               (3) $HOME/.globalrc
//               (4) /etc/gtags.conf
//               (5) [sysconfdir]/gtags.conf
// 
// skip (comma separated list)
//     Gtags skips files and directories which are given in this list. As a special
//     exception, gtags collects values from multiple skip variables. If the value
//     ends with ‘/’, it is assumed as a directory and gtags skips all files under
//     it. The value may include glob patterns (*, ?, [...], [!...], [^...]). If
//     the value starts with ‘/’, it is assumed a relative path name from the root
//     directory of the project. You cannot use glob patterns for a path name. 
// 
// 
// $ gtags --config
// :skip=HTML/,HTML.pub/,tags,TAGS,ID,y.tab.c,y.tab.h,gtags.files,cscope.files,\
//       cscope.out,cscope.po.out,cscope.in.out,SCCS/,RCS/,CVS/,CVSROOT/,{arch}/,\
//       autom4te.cache/,*.orig,*.rej,*.bak,*~,#*#,*.swp,*.tmp,*_flymake.*,\
//       *_flymake:langmap=c\:.c.h,yacc\:.y,asm\:.s.S,java\:.java,cpp\:.c++.cc.hh.\
//       cpp.cxx.hxx.hpp.C.H,php\:.php.php3.phtml:
// 
// 
// From gtags.conf
// 
// #---------------------------------------------------------------------
// # Configuration for gtags(1)
// # See gtags(1).
// #---------------------------------------------------------------------
// common:\
// 	:skip=HTML/,HTML.pub/,tags,TAGS,ID,y.tab.c,y.tab.h,gtags.files,cscope.files,\
//    cscope.out,cscope.po.out,cscope.in.out,SCCS/,RCS/,CVS/,CVSROOT/,{arch}/,\
//    autom4te.cache/,*.orig,*.rej,*.bak,*~,#*#,*.swp,*.tmp,*_flymake.*,*_flymake:


<build-tags-recursively>

1. hierarchical searches by default.

GNU GLOBAL can treat a source tree containing sub-directories as a `project`.
Anywhere in the project, you can utilize a high performance tag database.

/home/user/
 |
 |-ROOT/      <- the root of source tree (GTAGS,GRTAGS,...)
    |

So can run "global" command in `any-dir-under` ROOT.


2. locates not only definitions but also references.

// Gtags recursively collects source files from the 'current' directory. So the
// point is that "gtags dir" specifies where tag files get created 'but' file
// details are based on where the current dir was when run tag commend.
// 
// $ pwd
// /source/DEVARCH
// $ gtags ~/source
// $ gl FutureContextCommonImpl        // works okay
// $ gl -r FutureContextCommonImpl     // not find any
// 
// $ pwd
// /source
// $ gtags ~/source
// $ gl FutureContextCommonImpl        // works okay
// $ gl -r FutureContextCommonImpl     // works okay


<build-tags>

gtags DEVARCH              // will create tag files in DEVARCH
gtags ~/source             // will create tag files in ~/source

$ ls G*
GPATH   GRTAGS  GTAGS
`GTAGS' definition database
`GRTAGS' reference database
`GPATH' path name database 


{use-multiple-tags}

1. approach one

If you want to locate symbols that are not defined in the source tree, then you
can specify library directories with GTAGSLIBPATH environment variable.

Should execute gtags(1) at each directory in the GTAGSLIBPATH. If GTAGS is not
found there, global ignores such directories.

export GTAGSLIBPATH=.:~/source:/home/kpark/gtags/toolchain

note: GTAGSROOT
The root directory of the project. Usually, it is recognized by existence of
‘GTAGS’. Use of this variable is not recommended. 

$ pwd
/develop/src/mh                                 # this is a source project

$ gtags
$ ls G*TAGS
GRTAGS  GTAGS

$ global mhl
uip/mhlsbr.c                                    # mhl() is found

$ global strlen                                 # strlen() is not found
$ (cd /usr/src/lib; gtags)                      # build tag for library source
$ (cd /usr/src/sys; gtags)                      # build tag for kernel source

$ export GTAGSLIBPATH=/usr/src/lib:/usr/src/sys       # note: has multiples
$ global strlen
../../../usr/src/lib/libc/string/strlen.c             # now found in library
$ global access
../../../usr/src/sys/kern/vfs_syscalls.c              # now found in kernel


2. approach two

Or, you can take a more straightforward way to do the same thing. In the
following example, we treat as if the system library and the kernel are part of
our project.

$ ln -s /usr/src/lib .
$ ln -s /usr/src/sys .
$ gtags
$ global strlen
lib/libc/string/strlen.c
$ global access
sys/kern/vfs_syscalls.c


3. approach three

Seems that <2> sometimes do not work but works anyway. The way based on the
second is 

~/gtags/proj-a/
   G* files
   link -> /dir-real-a-project

~/gtags/proj-b/
   G* files
   link -> /dir-real-b-project

note: use both since suppose that there is a folder which need to rebase then it
is waste to build whole external folders everytime when rebase. So use the
first approach to include external sources when necessary and the external
sources has tags built already.


{global-options}
5.1 global - print locations of given symbols

<path>
By default, you get `relative-paths` of the located files depending on current
directory when run global command. 

The -a option produces absolute path names. 

<scope>
<search-type>
The -O search only in the text files. 
The -o search in both the source files and text files. 

<default>
Shows `definition-tags`

$ global AEM_JAVA_Invite_RegisterStateListener
vobs/DARWIN_PLATFORM/DARWIN_AEM_JAVA/src/natAemInviteImpl.c


<details>
‘-x’, ‘--cxref’
    Use standard ctags cxref (with ‘-x’) format. 

The `x-command` for more details listing that locate a exact func with line and
filename.

$ global -lx threadFunc
threadFunc         22 detached_attrib.c threadFunc(void *x)
threadFunc         63 one_time_init.c  threadFunc(void *arg)
  

<reference-or-callers>
The -r option locates object references. note: see callers.

$ global -rx AEM_JAVA_Invite_*StateListener


<pattern>
‘-g’, ‘--grep’ pattern [files]
    Print all lines which match to the pattern. If files are given, this
    command searches in those files. 

    $ global -xg '#ifdef'
    #ifdef             1 DIR2/fileC.c #ifdef X

    $ global -gx AEM_JAVA_Invite_*StateListener 

‘-e’, ‘--regexp’ pattern
    Use pattern as the pattern; useful to protect patterns starting with ‘-’. 


<get-pathname>
The -P command locates path names which include the specified pattern.

$ global -P fileB
DIR1/fileB.c

$ global -P '1/'
DIR1/fileA.c
DIR1/fileB.c

$ global -P '\.c$'
DIR1/fileA.c
DIR1/fileB.c
DIR2/fileC.c


<search-symbols>

If you forget object names, you can use the -c (complete) command. 

note: 
How about "global AEM_JAVA_Invite_*"? The difference is that -c shows
candidate symbols but the usual global command shows all matches to a symbols.
So can use this option to figure out symbols to use.

$ global -c AEM_JAVA_Invite_
AEM_JAVA_Invite_CreateIcon
AEM_JAVA_Invite_Delete                    # this is what I need
AEM_JAVA_Invite_DeregisterStateListener

$ global -r AEM_JAVA_Invite_Delete


‘-S’, ‘--scope’ dir
    Print only tags which exist under dir directory. It is similar to the ‘-l’
    option, but you need not change directory. 

‘-l’, ‘--local’
    Print only tags which exist under the current directory. 


<no-definition-in-project>
The `-s command` locates symbols which are not defined in 'GTAGS'. 

‘-s’, ‘--symbol’
    Print other symbol tags. Other symbol means the reference to a symbol
    which has no definition. 

<faq>
Q3. I'm a C++ programmer. Why does not gtags pick up class names in *.h?

A3. GLOBAL treats *.h files as a C source file. If you want to treat them
    as a C++ source file, please set environment variable GTAGSFORCECPP.

  $ export GTAGSFORCECPP=


{in-vim}

3.5.3 Usage

# Please copy vim scripts from where installed to your plug-in directory.

$ cp $PREFIX/share/gtags/gtags.vim $HOME/.vim/plugin

note: not sure if it's copied when build and install gtags. There are other
gtags.vim in /home/kpark/.vim/bundle/unite-tag.


Use `quickfix` window.

Suggested map:

    map <C-n> :cn<CR>
    map <C-p> :cp<CR>

    :Gtags main     " to go to main
    :Gtags -r func1 " to go to the referenced point of func1, add the ‘-r’ option.
    :Gtags -s lbolt " to locate symbols which are not defined in GTAGS
    :Gtags -g int argc " to locate strings, try this:
    :Gtags -g "root"
    :Gtags -ge -C      " locate '-C'

    " to get a list of tags in specified files, use the ‘-f’ command.
    :Gtags -f main.c              " locate tags in main.c

    " If you are editing ‘main.c’ itself, you can use ‘%’ instead.
    :Gtags -f %                   " locate tags in main.c

    " You can use POSIX regular expressions.
    :Gtags ^put_                  " locate tags starting with 'put_'
    :Gtags -g fseek(.*SEEK_SET)   " locate fseek() using SEEK_SET


    " Input completion is available.
    " In the command line, press CTRL-D after some typing and Vim will show a
    " list of tag names that start with the string. Press <TAB> and Vim will
    " complete the tag name.

    :Gtags fu<TAB>
    :Gtags func1

You can use all options of global(1) except for ‘-c -n -p -q -u -v’ and all
long name options. They are sent to global(1) as is. For example:

    :Gtags -gi paTtern        <- matches both 'PATTERN' and 'pattern'

    :Gtags -POi make          <- matches Makefile but not makeit.c

About the other options, please see global - print locations of given symbols.
The GtagsCursor command brings you to the definition or reference of the
current token.

If the context of the current token is a definition then it is equivalent to
:Gtags -r current-token; if it is a reference to some definitions then it is
equivalent to :Gtags current-token; else it is equivalent to :Gtags -s
current-token.

    :GtagsCursor

Suggested map:

    map <C-\>^] :GtagsCursor<CR>

Though the mapping of :GtagsCursor to ^] seems suitable, it will bring an
inconvenience in the help screen.

note: this about help is true so cannot use C-] as a mapping.


" The Gtagsa (Gtags + append) command is almost the same as Gtags command.
" But it differs from Gtags in that it adds the results to the present list.
" If you want to get the union of ':Gtags -d foo' and ':Gtags -r foo' then
" you can invoke the following commands:
"
"       :Gtags  -d foo
"       :Gtagsa -r foo

" If you want to use the tag stack, please use gtags-cscope.vim.
" You can use the plug-in together with this script.


={============================================================================
*kt_dev_env_vim_303* vim-tag-unite-gtag

https://github.com/hewes/unite-gtags

This provides following `unite-source` 


Unite `gtags/context` 

Lists the references or definitions of a word. It executes global
--from-here=<location of cursor> -qe <word on cursor>

When your cursor is on a definition Unite lists references of it, otherwise
list definitions.

-e, --regexp pattern
    Use pattern as the pattern; useful to protect patterns starting with ‘-’. 

-q, --quiet
    Quiet mode.  note: do not have effect on output


Unite `gtags/ref`

Lists references of a word. It executes global -qrs -e <pattern> in internal.
You can specify <pattern> as an argument :Unite gtags/ref:<pattern>. When
exeucte this command with no arguments :Unite gtags/ref, unite-gtags uses
expand('<cword>') as pattern.


Unite `gtags/def`

Lists `definitions` of a word. It executes global -qd -e <pattern> in
internal.

-d, --definition
    Print locations of definitions. 

You can specify <pattern> as an argument :Unite gtags/def:<pattern>. When
exeucte this command with no arguments :Unite gtags/def, unite-gtags uses
expand('\<cword\>') as pattern.


Unite `gtags/grep`

Lists grep result of a word. It executes global -qg -e <pattern> in internal.

You can specify <pattern> as an argument :Unite gtags/grep:<pattern>. When
exeucte Unite with no arguments :Unite gtags/grep, `input prompt` is shown.
unite-gtags uses the input as <pattern>.


// Unite gtags/completion
// 
// Lists all tokens in GTAGS. It executes global -c and show results.
// 
// Default action on the Unite item is list_references. list_definitions is also
// available.


Unite `gtags/file` 

Lists `current file's` tokens in GTAGS. It executes global -f and show results.

You can specify <pattern> as an argument :Unite gtags/file:<pathname>. When
exeucte this command with no arguments :Unite gtags/file, unite-gtags uses
buffer_name("%") as filepath.


# {gtags-cscope}
# note: not that useful since no tab completion is supported.
# 
# gtags-cscope (fake cscope). You can use gtags-cscope(1) instead of cscope(1).
# For example, you can deceive Vim editor using the following commands:
# 
# :set csprg=gtags-cscope    " note need cscope enalbed gtag binary
# :cs add GTAGS
# 
# After this, you can use built-in 'cs find' commands in the Vim editor. Though
# the deceit is not perfect ('cs find d' is not implemented), this method might be
# more convenient than 'gtags.vim' in the point that you can use the tag stack
# facility of Vim.
# 
# # from .vimrc
# 
# " for gtag
# if has('cscope')
#   set cscopetag cscopeverbose
#   
#   if has('quickfix')
#     set cscopequickfix=s+,c+,d+,i+,t+,e+
#   endif
#   
#   " for gtag
#   set csprg=gtags-cscope
# 
#   cnoreabbrev csa cs add
#   cnoreabbrev csf cs find
#   cnoreabbrev csk cs kill
#   cnoreabbrev csr cs reset
#   cnoreabbrev css cs show
#   cnoreabbrev csh cs help
#   cnoreabbrev csc call setqflist([])
#   
#   map <C-n> :cn<CR>
#   map <C-p> :cp<CR>
# endif
# 
# 0 or s: Find this C symbol (get header and source for a symbol)
# 1 or g: Find this definition (get header only)
# 2 or d: Find functions called by this function
# 3 or c: Find functions calling this function
# 4 or t: Find this text string
# 6 or e: Find this egrep pattern
# 7 or f: Find this file
# 8 or i: Find files #including this file
# 
# 
# Vim execute global(1), parse the output, list located objects in quickfix window
# and load the first entry. You can go to any entry using quickfix command. For
# help, :h quickfix
# 
# # update a window whenever do search
# :set cscopequickfix=s-,c-,d-,i-,t-,e-
# 
# # add a window whenever do search
# set cscopequickfix=s+,c+,d+,i+,t+,e+


={============================================================================
*kt_dev_env_vim_304* vim-make 

Practical Vim 17. Tip 104.

<run-make>
: make!

The trailing ! character tells Vim to update the quickfix list without jumping
to the first item. Now suppose that we run :make and immediately realize that
we should have used the bang version. How can we get back to where we were
before we ran :make? Simple: use the <C-o> command to jump back to the
previous position in the jump list.


<makefile>
To run make in vi, use makefile and simple makefile is:

# simple makefile from gmake

FILE = gen-list-linked.cpp
CC = g++ -std=c++0x

main : main.o
     echo 'bulid out'
     $(CC) -o out main.o

main.o : $(FILE)
     echo 'build $(FILE)'
     $(CC) -o main.o -c $(FILE)

clean :
     rm out main.o

<set-make>
To change the command when use :make
:set makeprg=gmake

To have the same as "$ ZB_CFG=huawei.370 zb-make"
:set makeprg=ZB_CFG=huawei.370\ zb-make

To see the current value
:set makeprg

note: 
Once build is done, should manually open an quickfix window.

note: 
Window has warning and others. Need to search through. Any way to see only
errors?


={============================================================================
*kt_dev_env_vim_304* vim-quickfix vim-location-list

Practical Vim 17. Tip 105.

Calling an external compiler from Vim saves us from having to leave our editor
and if the compiler reports any errors, Vim provides the means for us to jump
between them quickly.

:h quickfix

<navigate>
The quickfix list holds a collection of locations from one or more files. Each
record could be an error raised by the compiler when running :make, or it could
be a search match from running :grep.  No matter how the list was forged, we
must be able to navigate these records.

:cn[ext]    " Jump to next item
:cp[rev]    " Jump to previous item
:cfirst     " Jump to first item
:clast      " Jump to last item
:cnfile     " Jump to first item in next file     note: what is the file here?
:cpfile     " Jump to last item in previous file
:cc N       " Jump to nth item
:copen      " Open the quickfix window.
:cclose     " Close the quickfix window
:cl[ist]    " list all items

note: They all begin with :c.


<multiple>
When we update the quickfix list, Vim doesn't overwrite the previous contents.
It saves the results of older quickfix lists, allowing us to refer back to them.
We can recall an older version of the quickfix list. 


Practical Vim 17. Tip 106.

Vim holds onto the last `ten lists` This can be a real time saver, especially
if the command takes a long time to run.

:cnewer     " To revert from an old quickfix list back to a newer one
:colder     "

note: See like "error list 4 of 5" in status 


{location-list}
For every command that populates the quickfix list, there's a variant that
places the results in a location list instead. While :make, :grep, and
:vimgrep use the quickfix list, `:lmake`, `:lgrep`, and `:lvimgrep` use the
location list. 

So what's the difference? At any given moment, there can be only one quickfix
list, but we can create `as many location` lists as we want.

Suppose that we've followed the steps in Tip 107, on page 265, so that running
:make in a JavaScript file passes the contents of the file through JSLint. Now
let's say that we've got two different JavaScript files open in split windows. 

We run :lmake to compile the contents of the active window, which saves any
error messages to the location list. Then we switch to the other window and
run :lmake again. Rather than overwriting the existing location list, Vim
creates a new one. Now we have two location lists, each containing errors for
a different JavaScript file.

note: They all begin with :l.

Any commands that interact with a location list will act on the list that is
bound to the currently active window. 

Compare this with the quickfix list, which is available globally throughout
Vim: no matter which tab page or window is active, when you run :copen, the
quickfix window will show the same list.


={============================================================================
*kt_dev_env_vim_305* vim-filetype

A1.3 Apply Customizations to Certain Types of Files

Our preferences may vary from one type of file to another. For example, suppose
that we work with a house style that advises two spaces for indentation
in Ruby and four-column-wide tabs for JavaScript. We could apply these
settings by putting the following lines in our vimrc:

if has("autocmd")
  filetype on
  autocmd FileType ruby setlocal ts=2 sts=2 sw=2 et
  autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noet
endif


The `autocmd` declaration tells Vim to listen for an event and to execute the
specified commands whenever that event fires (:h :autocmd). 

In this case we're listening for the FileType event, which is triggered when
Vim detects the type of the current file.

We can have more than one autocommand listening for the same event.  Suppose
that we want to use nodelint as the compiler for JavaScript files. We could
add this line to the example above:

autocmd FileType javascript compiler nodelint

Both autocommands would be executed each time the FileType event was triggered
on a JavaScript file.

Putting autocommands in the vimrc file works fine if you only have to make one
or two customizations for a file type. But if we wanted to apply lots of
settings to a particular kind of file, then it starts to look messy. 

The `ftplugin` is an alternative mechanism for applying customizations to file
types. Instead of declaring our JavaScript preferences in the vimrc using
autocommands, we could place them in a file called

~/.vim/after/ftplugin/javascript.vim:

setlocal ts=4 sts=4 sw=4 noet
compiler nodelint

This file is just like a regular vimrc, except that the settings will only be
applied to JavaScript files. We could also create a ftplugin/ruby.vim file for
Ruby customizations and another for each file type that we work with
regularly. For more details, look up :h ftplugin-name.

For the ftplugin mechanism to work, we must ensure that both file-type
detection and plugins are enabled. Check that this line is present in your
vimrc file: 

filetype plugin on

note:
How vim detect file type?

share/vim/vim74/filetype.vim has codes to detect file type like:

" JavaScript, ECMAScript
au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript


<read>
http://learnvimscriptthehardway.stevelosh.com/chapters/44.html

Create ftdetect/potion.vim in your plugin's repo. Put the following lines into
it:

au BufNewFile,BufRead *.pn set filetype=potion

This creates a single autocommand: a command to set the filetype of .pn files
to potion. Pretty straightforward.

Notice that we didn't use an autocommand group like we usually would. Vim
automatically wraps the contents of ftdetect/*.vim files in autocommand groups
                                              for you, so you don't need to
                                              worry about it.

Close the factorial.pn file and reopen it. Now run the previous command again:

:set filetype?

This time Vim displays filetype=potion. When Vim started up it loaded the
autocommand group inside ~/.vim/bundle/potion/ftdetect/potion.vim, and when it
opened factorial.pn the autocommand fired, setting the filetype to potion.

Now that we've taught Vim to recognize Potion files we can move on to actually
creating some useful behavior in our plugin.  Exercises

Read :help ft. Don't worry if you don't understand everything there.
Read :help setfiletype.

Modify the Potion plugin's ftdetect/potion.vim script to use setfiletype
instead of set filetype.


={============================================================================
*kt_dev_env_vim_305* vim-make-external

Practical Vim 17. Tip 107.

note: To see the current setting.
:set makeprg?

The `makeprg` setting allows us to specify the program that will be called
when we run :make (see :h 'makeprg'). We can instruct Vim to run nodelint as
follows:

:setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %

The % symbol is expanded to the path for the current file. So if we were
editing a file called ~/quickfix/fizzbuzz.js, then running :make inside Vim
would be equivalent to running this in the shell:

$ export NODE_DISABLE_COLORS=1
$ nodelint ~/quickfix/fizzbuzz.js

By default, nodelint highlights errors in red using ANSI color codes. Setting
NODE_DISABLE_COLORS=1 mutes the colors, which makes it easier to parse the
error messages.

Next, we have to make Vim `parse` the output from nodelint so that it can build
a quickfix list from the results. We can approach this problem in two ways:

1. we could configure nodelint so that its output resembled the error messages
generated by make, which Vim already understands, or 

2. we could teach Vim how to parse the default output from nodelint. We'll use
the latter technique.


Populate the Quickfix List Using Nodelint's Output

The `errorformat` setting allows us to teach Vim how to parse the output generated 
by running :make (see :h 'errorformat'). We can inspect the default value
by running the following:

:setglobal errorformat?

errorformat=%*[^"]"%f"%*\D%l: %m,"%f"%*\D%l: %m, ...[abridged]...

If you're familiar with scanf (in C), then you'll recognize the concept. Each
of the characters preceded by a `percent sign` has a special meaning: %f
stands for the filename, %l for the line number, and %m for the error message.
For the complete list, look up :h errorformat.


To parse the output from nodelint, we could set the error format as follows:

:setlocal efm=%A%f\,\ line\ %l\,\ character\ %c:%m,%Z%.%#,%-G%.%#

Now when we run :make, Vim will use this error format to parse the output from
nodelint. For each warning it will extract the filename, line number, and
column number to generate an address, which becomes a record in the quickfix
list.


Set Up `makeprg` and `errorformat` with a Single Command

This errorformat string is not something we would want to commit to memory.
Instead, we can save it to a file and then activate it with the :compiler
command, which is a convenient shortcut for setting both makeprg and
errorformat options (see :h :compiler):

:compiler nodelint

The :compiler command activates a compiler plugin, which sets the makeprg and
errorformat options to run and parse nodelint. It's roughly equivalent to
sourcing these lines of configuration:

// quickfix/ftplugin.javascript.vim
setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %
let &l:efm='%A'
let &l:efm.='%f\, '
let &l:efm.='line %l\, '
let &l:efm.='character %c:'
let &l:efm.='%m' . ','
let &l:efm.='%Z%.%#' . ','
let &l:efm.='%-G%.%#'

The internals of a compiler plugin are more elaborate, but this is a fair
approximation of what goes on. You can familiarize yourself with the compiler
plugins that are distributed with Vim by running this command:

:args $VIMRUNTIME/compiler/*.vim

note:
/share/vim/vim74/compiler/gcc.vim

Note that Vim doesn't ship with a nodelint compiler plugin, but we can easily
install one.4 If we wanted to always use nodelint as the compiler for
JavaScript files, we could either use an autocommand or a file-type plugin to
make it so.

In Vim's terminology, a compiler is any external program that does something
with our document and produces a list of errors or warnings. The :make command
simply invokes the external compiler and then parses the output to construct a
navigable quickfix list from them.


={============================================================================
*kt_dev_env_vim_305* vim-make-errorformat

Vim errorformat Demystified

Vim's errorformat is on of the more arcane part's of vim. It has constantly
had me tearing my hair out, if you've found this page there's a good chance
you are too. Judging from the google results I've seen this is quite a common
reaction.

Simple, single line formats are easy enough to work out with a little trial
and error, the problems start mounting when you need multiple formats
simultaneously, or worse, multi line error formats.

I believe this is more to do with the documentation than anything else.
Despite being extensive and containing many examples it actually does very
little to explain things. Once you understand a few key things though, it's
actually much simpler than it seems.

##An Array of Formats

The `efm` variable is a csv of error formats. Personally I prefer to visualize
it as an array. Let's look at an example from vim's documentation example
like:

:set efm=%EError\ %n,%Cline\ %l,%Ccolumn\ %c,%Z%m

You might intuitively think that this is a single error format, which is
exactly what I thought. It is in fact four completely separate error format's,
`delineated by commas` . Vim will loop through each pattern and see if the
current line matches it, breaking if it finds a match.

Let me repeat that, these are four separate error formats, understanding this
was my eureka moment, when I finally understood how it worked. The above
format could be written as:

:set efm=%Cline\ %l,%Ccolumn\ %c,%Z%m,%EError\ %n

set efm+=%EError\ %n
set efm=%Cline\ %l
set efm+=%Ccolumn\ %c
set efm+=%Z%m

This allows the `precedence order` to be adjusted by moving the lines up and
down. When you have to deal with multiple error formats this is incredibly
important.

Step by Step

Now for a real world example, recently I wanted to write a format that works
with the nunit/nant combo, the output looks like this:

[exec] 1) Test Failure : TestClass.IsTrue
[exec]   Custom error message goes here.
[exec]   Expected: True
[exec]   But was:  False
[exec]
[exec] at TestClass.IsTrue() in c:\projects\book projects\src\app\Test.cs:line 9

The first step to creating an error format is to get the `filename` and `line`:

set efm=%.%#\ at\ %.%#\ in\ %f:line\ %l

This is saying:

Find any text (%.%# is a wild card) until we get to " at ".
Then any text until we get to " in ".
Then the filename (%f) followed by a colon (:)
Finally the word "line " (whitespace sensitive) followed by the line number (%l)

If it's run against a failing test then the output will be:

47 src\app\Test.cs:9:


This works, we can easily jump to the file and location but there is no other
information. To `improve` this we have to use a `multiple formats` and use
multi line syntax. First we update the format:

set efm=%Z%.%#\ at\ %.%#\ in\ %f:line\ %l

"%Z" has been added to the start. This means it will only be considered if a
flag is set indicating we are in the middle of a multi line error. It is also
considered the end of the multi line error, the flag is turned off if this is
a match. Running it now will not produce a match.

To set the multi line flag we need to add another format:

set efm=%E%.%#Test\ Failure\ :%.%#
set efm+=%Z%.%#\ at\ %.%#\ in\ %f:line\ %l

The second line is mostly the same (note the += at the start). The first line
is a format saying the following:

  Set the `multi line flag`, `%E`, if this is a match
  Find any text until we get to "Test Failure : "
  Followed by any text.

If we run this now it still won't work. The multi line flag is turned off if a
non matching line is found. The simplest way to do this is to match any line:

set efm=%E%.%#Test\ Failure\ :%.%#
set efm+=%Z%.%#\ at\ %.%#\ in\ %f:line\ %l
set efm+=%C%.%#

The `%C` means it only matches if the multi line flag is on. It then uses a wild
card to match anything. Because this matches practically anything it is placed
last, giving it the lowest precedence. If the second and third lines were
switched then every line after the first error would be considered part of the
error, the file name and line number would never get matched.

The last part is to get all the information in between, we add a fourth pattern:

1
2
3
4

	

set efm=%E%.%#Test\ Failure\ :%.%#
set efm+=%Z%.%#\ at\ %.%#\ in\ %f:line\ %l
set efm+=%C%.%#[exec]\ %#%m
set efm+=%C%.%#

The added third line is saying:

    Only apply this if the multi line flag is set (%C)
    Find any text up to [exec]
    Find any space characters
    Append the rest of the line to the error message (%m)

The output will look like:

1

	

47 src\app\Test.cs:9: Custom error message goes here. Expected: true But was: false

To make this easier to manage it is a good idea to keep the error line it is matching in a comment:

1
2
3
4
5
6
7
8
9
10

	

"[exec] 1) Test Failure : TestClass.IsTrue
set efm=%E%.%#Test\ Failure\ :%.%#
"[exec] at TestClass.IsTrue() in c:\projects\book projects\src\app\Test.cs:l ine 9
set efm+=%Z%.%#\ at\ %.%#\ in\ %f:line\ %l
"[exec]   Custom error message goes here.
"[exec]   Expected: True
"[exec]   But was:  False
set efm+=%C%.%#[exec]\ %#%m
"[exec]
set efm+=%C%.%#

##More Errors

The above assumes that nunit errors are all we care about but there are many others, from the compiler itself and the build script itself being the two obvious ones. If the build script itself throws an error it looks like this:

1
2
3
4

	

c:\projects\project1\nant.build(23,5):
Error loading buildfile.

    The 'cscvffe' start tag on line 11 position 4 does not match the end tag of 'csc'. Line 23, position 5.

The error format for this is rather straight forward:

1
2
3
4
5
6

	

"c:\projects\project1\nant.build(23,5):
set efm=%E%f(%l\\,%c):
"Error loading buildfile.
"
"    The 'cscvffe' start tag on line 11 position 4 does not match the end tag of 'csc'. Line 23, position 5.
set efm+=%C%m

To get it to work with other errors though, it need to be arranged in order of specificity:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

	

"[exec] 1) Test Failure : TestClass.IsTrue
set efm=%E%.%#Test\ Failure\ :%.%#
"c:\projects\project1\nant.build(23,5):
set efm=%E%f(%l\\,%c):
"[exec] at TestClass.IsTrue() in c:\projects\book projects\src\app\Test.cs:l ine 9
set efm+=%Z%.%#\ at\ %.%#\ in\ %f:line\ %l
"[exec]   Custom error message goes here.
"[exec]   Expected: True
"[exec]   But was:  False
set efm+=%C%.%#[exec]\ %#%m
"Error loading buildfile.
"
"    The 'cscvffe' start tag on line 11 position 4 does not match the end tag of 'csc'. Line 23, position 5.
set efm+=%C%m
"[exec]
set efm+=%C%.%#

The start format goes near the top because it signifies the start of a new error no matter what. The message line is very generic though, so it has to go right near the bottom.

Error formats, and the quick list itself is one of those features that really makes vim shine, It just needs some customization for your particular tool set. Hopefully I've straightened out some misconceptions here.


={============================================================================
*kt_dev_env_vim_305* vim-make-external-case

note:
This uses external program other than make but do not parse output

http://tuxion.com/2011/09/30/vim-makeprg.html

When you type :make in Vim, the value of makeprg is executed in a subprocess.
Traditionally this value is set to make, but you can set this to anything you
like. You can see the current value by typing :set makeprg. When you combine
this with Vim's support for filetype plugins, there's a decent amount of value
that I think is sometimes overlooked. So this article is an attempt to explain
some of the things you can do with makeprg and filetype detection.  

Using a filetype plugin, we can set makeprg to something useful depending on
the type of a file it happens to be. Just create a file of the form:

<filetype>.vim inside the ~/.vim/after/ftplugin directory.

The `after` subdirectory is technically optional, but I prefer it as it keeps
things isolated from other installed plugins. The after subdirectory is
sourced last as Vim initializes itself, so putting your options there ensures
they aren't clobbered by other plugins.

For a given Vim buffer, you can see the filetype by typing :set ft. 

For example, if I want to define custom settings for the C filetype, I would
create ~/.vim/after/ftplugin/c.vim and put my settings there. Any time a file
of type C is loaded, my settings are applied. We can use this mechanism to set
a custom makeprg for certain filetypes.


Customizing makeprg for Markdown

I take all of my notes in Markdown, which is nearly plain text with a tiny
amount of markup. This allows me to quickly convert my personal notes into
decent looking html documentation. It seems to be a regular occurrence that my
notes become the initial documentation for the project or subproject that I'm
working on. Many wiki's support Markdown, so it ends up saving me work by just
keeping everything in that format.

Even though Markdown's syntax is very lean and simple, I still end up
forgetting some of it from time to time. I find it useful to generate and view
the HTML output for the buffer that I'm working on periodically to make sure
things look right. This is really easy by setting a custom makeprg for the
markdown filetype.  

The Hammer Plugin

Robert Gleeson wrote a Vim plugin called Hammer that basically does exactly
what I explain here and quite a bit more. It might be perfect for you, but for
me it's much more than I need. I've had problems when the version of Ruby on
the system is not the same as what Vim was compiled with. Check it out though,
    you might love it.  

A Simpler Approach

All I want is to type :make and have Vim generate an HTML version in /tmp that
I can point my browser to. So I put the following in

~/.vim/after/ftplugin/markdown.vim:

set makeprg=redcarpet\ %\ >/tmp/%<.html

Let's take a quick look at what's going on here:

The above setting is applied only when editing a markdown buffer. Personally,
    I use redcarpet to parse markdown, but there are many others that you can
    substitute here. 

Spaces in option strings must be escaped so Vim knows when to stop parsing.

% 
expands to the name of the file currently being edited.

%< 
expands to the name of the file without the trailing extension. This allows us
to change the name of the file and add the html extension.

So the above command calls redcarpet on the filename and redirects the output
to /tmp/<filename>.html. That's it, super simple. Once this completes, I point
my browser to file:/tmp and load the file I'm interested in.

This same approach can be taken with ReStructured Text by putting the
following in ~/.vim/after/ftplugin/rst.vim:

set makeprg=rst2html.py\ %\ /tmp/%<.html`
 
note:
bash alias do not work so make a script for that.

Extra Credit

For C, we could set makeprg to call gcc directly instead of make if a Makefile
is not found in the current working directory. I find this very helpful when
creating a scratch source file to test certain behaviour or a quick theory.
Here's what the contents of ~/.vim/after/ftplugin/c.vim might look like:

if !filereadable(expand("%:p:h")."/Makefile")
    setlocal makeprg=gcc\ -Wall\ -Wextra\ -o\ %<\ %
endif

Now when you load a file of type C and there is no Makefile, typing :make will
compile your source file into an executable of the same name (minus the
    extension). I use this all the time. You could do the same thing for C++
by changing the filename to cpp.vim and changing gcc to g++.


={============================================================================
*kt_dev_env_vim_306* vim-filetype-nds

/home/kit/.vim/after/ftplugin/nds.vim

" Vim filetype plugin file
" Language:	nds log
" Maintainer:	
" Last Change:	2016 June 28

" Only do this when not done yet for this buffer
" if exists("b:did_ftplugin")
"   finish
" endif

" au BufNewFile,BufRead *.nds setf nds
au BufNewFile,BufRead *.nds set filetype=nds

" NDS:                      " ndsFieldHeader
" ^[2016:06:10 15:52:53] 
" 0946701324.837014         " ndsFieldTime
" !MIL    -EPG_TVG      	
"                           " ndsFieldTab
" < p:0x00000196            " ndsFieldProcess
"   P:APP                   " ndsFieldProcessName
"   t:0x2df56520            " ndsFieldThread
"   T:no name               " ndsFieldThreadName 
"
" M:ProgrammesRetriever F:createProgrammesList L:326 >
" T:PooledExecutor#4:Guide Programme 7 Title: The Big \
"   Bang Theory Start Time \
"   [2016:06:10 23:10:00]1465600200 Duration 1800
" 
syn match ndsFieldHeader '^[0-9:]*NDS: ' conceal
syn match ndsFieldTime '[0-9]\{10\}.[0-9]\{6\}' conceal
syn match ndsFieldTab '\t\{1,\}' conceal
" syn match ndsFieldSpace '\s\{1,\}' conceal
syn match ndsFieldProcess '\<p:0x\w\+\>' conceal
syn match ndsFieldProcessName '\<P:\w\+\>' conceal
syn match ndsFieldThread '\<t:0x\w\+\>' conceal
syn match ndsFieldThreadName '\<T:\w\+\>' conceal

set concealcursor=nc
set conceallevel=3

" note: have to quote a space
setlocal makeprg=cat\ %
setlocal efm=%.%#\ M:%f\ %.%#\ L:%l

note:
Vim do not detect ft automatically but can set ft=nds and works.


{user-syntax}

.vim/syntax/nds.vim

can use egrep style as below

syntax match ndsMesg02          /UAM_DCM_PARAM_DATA_INTERNAL_TYPE_STANDBY_\(IN\|OUT\)/
hi def link ndsMesg02 Type


={============================================================================
*kt_dev_env_vim_306* vim-filetype-c

// ~/.vim/after/ftplugin/c.vim

" Vim filetype plugin file
" Language:	c
" Maintainer:	
" Last Change:	2016 June 28

" current
" note: not sure since it do not work for me.
" NeoBundle 'tyru/current-func-info.vim'
" nnoremap <C-g>f :echo cfi#format("%s", "")<CR>

" pulgin-commentary
" https://github.com/tpope/vim-commentary/issues/30
" to use '//' instead of '/* */'
"
" You can have // by default if you 
" setlocal commentstring=//\ %s in after/ftplugin/c.vim. 
" There is no support for a multiline mode.

setlocal commentstring=//\ %s
setlocal smartindent
setlocal shiftwidth=4
setlocal tabstop=4
setlocal softtabstop=4
setlocal expandtab


={============================================================================
*kt_dev_env_vim_305* vim-make-dispatch

http://dev.imshealth.com/blog/posts/vim-quickfix/
https://github.com/tpope/vim-dispatch


={============================================================================
*kt_dev_env_vim_306* prog: build: man page in vim

We can place the cursor at the 'printf' function call and press K. If we want to see the manual page
on the printf C function (Section 3 'System library calls') we need to type 3K. Once you are done
with the manual, type ENTER to return to Vim.

K

Run a program to lookup the keyword under the cursor. The name of the program is given
with the 'keywordprg' (kp) option (default is "man"). The keyword is formed of letters, numbers and
the characters in 'iskeyword'. The keyword under or right of the cursor is used.  


The same can be done with the command >

 :!{program} {keyword}

There is an example of a program to use in the tools directory of Vim.  It is called 'ref' and does
a simple spelling check.

Special cases:
- If 'keywordprg' is empty, the ":help" command is used.  It's a good idea to include more
  characters in 'iskeyword' then, to be able to find more help.

- When 'keywordprg' is equal to "man", a count before "K" is inserted after the "man" command and
  before the keyword.  For example, using "2K" while the cursor is on "mkdir", results in: > !man 2
  mkdir


={============================================================================
*kt_dev_env_vim_320* prog: folding

{foldmethod}
'foldmethod' option (abbreviated to 'fdm') is local to each 'window'.

manual - folds must be defined by entering commands (such as zf)
indent - groups of lines with the same indent form a fold
syntax - folds are defined by syntax highlighting
expr   - folds are defined by a user-defined expression 

:h fold-methods 
to learn the details of different fold methods.

:h folding 
to learn the keyboard commands for manipulate folds.

:h folds 
for help on the entire topic of folding.

<save-and-load-view>
:mkview        " to save folds
:loadview      " to restore folds


{manual-mode}
Use z? command in a normal mode

zf'a           " fold lile from the current line to mark

v{motion}zf    " fold using visual mode
V{motion}zf
va}zf          " fold {} block containing the cursor. visual, {} selecion and zf

zf{motion}
zfa}           " create a fold from the line with the first brace through the last. 
zfa{           " This also works with other block enclosures

zf2j           " fold three lines

:., 20 fo         " fo works backwards as well.
:20, 101 fo{ld}

zd             " delete a fold. it's different from 'zo' as cannot do 'zc' after that.
zo             " opens a fold at the cursor.
zr             " open all first-level folds in Vim
zR             " open all of the folds in the file. 
zc             " close

If we unfold the top level fold, the inner one is shown collapsed. The states of nested folds are
'independent'. zd and zD are used to deleted folds (the latter recursively), and zE deletes all the
folds in the current window. As a general rule, the capitalized version of all the commands (zC, zO)
applies the action recursively

" syntax mode
foldmethod=syntax

zj    " moves the cursor to the next fold.
zk    " moves the cursor to the previous fold.
[z    " move to start of open fold.
]z    " move to end of open fold.


={============================================================================
*kt_dev_env_vim_003*	recovery, swap and backup

where <filename> is the name of the file you were editing at the time of the crash:
vim -r <filename>

You can list the recoverable files:
vim -r

# .vimrc
# set backup " backup on
# set nobackup " backup off
# The 'directory' option controls where swap files go.

set backup
set backupdir=/home/NDS-UK/parkkt/vimback
set directory=/home/NDS-UK/parkkt/vimback


{swap-file}

(http://vimdoc.sourceforge.net/htmldoc/recover.html)
1. Vim stores the things you changed in a swap file.  Using the original file you started from plus the
swap file you can mostly recover your work.

You can see the name of the current swap file being used with the command:

:sw[apname]

The name of the swap file is normally the same as the file you are editing, with the extension
".swp".	  

The swap file is deleted as soon as Vim stops editing the file.

By setting the 'directory' option you can place the swap file in another place than where the edited
file is.

2. The swap file might be the result from a previous crash of Vim or the computer.  Check the dates
mentioned in the message.  If the date of the swap file is newer than the file you were editing, and
this line appears:

modified: YES 

Then you very likely have a crashed edit session that is worth recovering.


If the date of the file is newer than the date of the swap file, then either it was changed after
the crash (perhaps you recovered it earlier, but didn't delete the swap file?), or else the file was
saved before the crash but after the last write of the swap file (then you're lucky: you don't even
need that old swap file).  Vim will warn you for this with this extra line:

NEWER than swap file! 	

WHAT TO DO?

If dialogs are supported you will be asked to select one of five choices:

  Swap file ".main.c.swp" already exists! 
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: 

O  Open the file readonly.  Use this when you just want to view the file and
   don't need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.

E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe then sorry.

R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.

Q  Quit.  This avoids starting to edit the file.  Use this if there is another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When starting Vim with
   files in several windows, Vim quits only if there is a swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.

A  Abort.  Like Quit, but also abort further commands.  This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.

D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.
   
BACKUP

If you write to an existing file (but do not append) while the 'backup',
'writebackup' or 'patchmode' option is on, a backup of the original file is
made.


{keep-the-original}

To make Vim keep the original file, set the 'patchmode' option.  This specifies the extension used
for the first backup of a changed file.  Usually you would do this:

:set patchmode=.orig


==============================================================================
*kt_dev_env_005*	plugin: foldsearch

http://www.vim.org/scripts/script.php?script_id=2302

to see those ony matches with pattern

# not working
Fp KEY_PRESS\|VRM_JOB_START

Fp VRM_JOB_START\|TUNER_LOCKED\|hMC=0x304\|hMC=772
s/MCM_MEDIACONN_Run\|VRM_JOB_START\|hMC=0x36


==============================================================================
*kt_dev_env_vim_008*	search and substitute

{range}

Specifier 	Description

number		an absolute line number
.		the current line
$		the last line in the file
%		the whole file. The same as 1,$
't		position of mark "t"
/pattern[/] 	the next line where text "pattern" matches.
?pattern[?] 	the previous line where text "pattern" matches
\/ 		the next line where the previously used search pattern matches
\?		the previous line where the previously used search pattern matches
\&		the next line where the previously used substitute pattern matches


{vim-subst}

# Part of the command word enclosed in the "[" & "]" can be omitted. 
# NOTE: only first search is a pattern. MAKE SENSE.
:substitute
:range s[ubstitute]/pattern/string/cgiI

For each line in the range replace a match of the pattern with the string where:

c	Confirm each substitution
g	Replace all occurrences in the line (without g - only first).
i	Ignore case for the pattern.
I	Don't ignore case for the pattern.

# the % means "all the lines of the file". "global" option, which tells Vim to replace every
# occurrence on a line, and not just the first occurrence.

:s/from/to/g                     # on the current line
:%s/from/to/g 
:%s/printf(/fprintf(stderr,/gc
:.,$s/yes/no/

# can use pattern in range and use other char instead of slash(/) which makes no need to use
# backslash to escape when there is a slash in search string
# ?pattern? means search backword and /pattern/ means forward.

:?^Chapter?,/^Chapter/s=grey=gray=g
:'t,'b                                   # use marks

# the new c option we are using means we want a 'c'onfirmation message for every replace.  replace
# with foo (y/n/a/q/l/^E/^Y)?  The "y" and "n" are self-explanatory, but what about the rest?
#
# a : to tell Vim to go ahead and replace all instances of the matched answer with a. from the current.  
# l : to tell Vim to make the current change and then stop, use l, for last.  ^E and ^Y allow
# you to scroll the text using Ctrl-e and Ctrl-y.

:0,10s/from/to/gc

# matching one or more terms. used alternation.
 
:%s/Kang\|Kodos/alien/gc

# it adds '|>' to the beginning of one line.
:s/^/|> /
:%s/^/|> /


==============================================================================
*kt_dev_env_vim_024*	prog:undo

See :help new-undo-branches on a Vim 7 editor.  Vim supports undo branches. This means Vim can keep
track of the different changes you made to your text (or your code). In its simplest form, you can
use two commands, :earlier and :later to bring your code to a previous state. E.g:

:earlier 20s
:later 5m
:earlier 2h

The commands above bring the code to the state it was 20 seconds earlier, 5 minutes later and 2
hours later.  This is useful when making changes to code under no source control systems. Undo
branches is a new feature present in Vim since version 7. I recommend you to play with it and learn
how to get the maximum out of it.

The |:undolist| command can be used to get an idea of which undo branches
exist.  The |:undo| command now takes an argument to directly jump to a
specific position in this list.  The |changenr()| function can be used to
obtain the change number.


==============================================================================
*kt_dev_env_vim_300*	script

Vim documentation: usr_41

:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
 
Note:
The ":" characters are not really needed here.  You only need to use them when you type a command.
In a Vim script file they can be left out.  We will use them here anyway to make clear these are
colon commands and make them stand out from Normal mode commands.

Note:
You can try out the examples by yanking the lines from the text here and executing them with :@"


{vim-variable}

These variables are global. To see a list of currently defined variables use this command:

	:let

You can use global variables everywhere. This also means that when the variable "count" is used in
one script file, it might also be used in another file. This leads to confusion at least, and real
problems at worst.

To avoid this, you can use a variable local to a script file by prepending "s:". For example, one
script contains this code:


{vim-list}

List creation *E696* *E697*

A List is created with a comma separated list of items in square brackets.

Examples:
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

An item can be any expression. Using a List for an item creates a List of Lists: :let nestlist =
[[11, 12], [21, 22], [31, 32]]

An extra comma after the last item is ignored.

List manipulation:					*list-functions*

	count()			count number of times a value appears in a List

count({comp}, {expr} [, {ic} [, {start}]])			*count()*

		Return the number of times an item with value {expr} appears in |List| or |Dictionary| {comp}.
		If {start} is given then start with the item with this index.  {start} can only be used with a
		|List|.  When {ic} is given and it's non-zero then case is ignored.

let s:settings.plugin_groups = []
call add(s:settings.plugin_groups, 'core')
call add(s:settings.plugin_groups, 'web')
call add(s:settings.plugin_groups, 'javascript')

if count(s:settings.plugin_groups, 'core') "{{{
...
endif

{vim-function}

To redefine a function that already exists, use the ! for the ":function" command:

	:function!  Min(num1, num2, num3)


# ============================================================================
#{
={============================================================================
*kt_dev_env_0000* git-reference

{help}
https://www.kernel.org/pub/software/scm/git/docs/git.html

{book}
"Git from the bottom up":
http://ftp.newartisans.com/pub/git.from.bottom.up.pdf

http://git-scm.com/book

The Git Community Book
https://schacon.github.io/gitbook/index.html

{gui-client}
<qgit>
sudo apt-get install qgit

Had highlight on a current branch. show whole tree when select option to start.

<gitg>


={============================================================================
*kt_dev_env_0000* git-install

{install}
git clone https://github.com/git/git

apt-get install autoconf
make configure
./configure 
make

apt-get install asciidoc

# as root
sudo make install install-doc install-html

# when see "fatal: Unable to find remote helper for 'https'" install curl and
# rebuild git. 
sudo apt-get install libcurl4-openssl-dev


={============================================================================
*kt_dev_env_0000* git-vim

<1>
The row length should be limited to 72 columns. It can be automated by adding
this line to .vimrc:

" Limit line length of git commits to 72 cols
au FileType gitcommit set tw=72


<2>
~/share/vim/vim74/ftplugin/gitcommit.vim

Make vim spellcheck your git commits:

echo set spell >> ~/.vim/ftplugin/gitcommit.vim


{set-default-editor}
$ git config --global core.editor gvim

Do not work even if it launches gvim with commit log window but git emits error:

$ git commit -a
+linux
+neocomplete
Aborting commit due to empty commit message.

To fix this:
http://forums.udacity.com/questions/100228609/using-gvim-to-edit-your-git-commit-messages

$ git config --global core.editor "gvim -f"

From gvim help:
   -f  or  --nofork        Foreground: Do not fork when starting GUI

If you are using gvim, you need to make sure that it stays in the foreground,
   otherwise it will return control to git before you've had a chance to edit
   and save your message. Specifying the -f switch as part of the editor setting
   should enable this.

={============================================================================
*kt_dev_env_0000* git-config-alias-help

The first thing you should do when you install Git is to set your user name and
e-mail address. This is important because every Git commit uses this
information, and it's immutably baked into the commits you pass around:

git config --global user.name "Kit Park"
git config --global user.email tegipark@gmail.com

git config --list
git config --global --list

# for color output
git config --global color.ui auto

$ git config -l
user.name=Kit Park
user.email=tegipark@gmail.com
color.ui=auto
merge.tool=meld
push.default=simple
core.excludesfile=/home/kit/.gitignore
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true


{git-help}
git help ???
man git-???


{git-alias}
This means that, for example, instead of typing git commit, you just need to
type git ci.

git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.cl 'reset --hard HEAD'
git config --global alias.ls "log --oneline --decorate"
git config --global alias.ll "log --decorate --graph --pretty=format:'%C(auto)%h%Creset :%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"

To run an external command,
$ git config --global alias.visual '!gitk'

$ cat .gitconfig
...
[alias]
	co = checkout
	ci = commit
	st = status
	br = branch
	l = log -1 HEAD
	ll = log --oneline --decorate --graph


{config-structure}
$ more .git/config
...
[zb]
	build-dir = /data/builds
	default-config = pc
	build-type = debug
	one-time-setup = true

[zb "huawei.360"]
	build-type = debug
	host-config = host
   deploy-host = huawei


$ git config --list
...
zb.build-dir=/data/builds
zb.default-config=pc
zb.build-type=debug
zb.one-time-setup=true
zb.pc.build-type=debug
zb.pc.host-config=host

<get-set>
$ git config zb.huawei.360.deploy-host huawei 
$ git config zb.huawei.360.deploy-host 172.20.33.192

$ git config --bool zb.one-time-setup
true


={============================================================================
*kt_dev_env_git_003* git-fugi: complement to command line

#31. 1) A complement to command line git

http://vimcasts.org/episodes/fugitive-vim---a-complement-to-command-line-git/

Commands such as Gremove and Gmove map directly to git rm and git mv. I wasn't
sold on these at first, because I didn't mind using the git commands. But things
can get a little messy if you run these commands in the shell when the files
that you act upon are already open in your text editor. For example, if you run:

git mv original/path.txt destination/path.txt

When you switch back to your editor, you might end up with a window open trying
to edit the original/path.txt file, which no longer exists. Using the Gmove
command keeps things tidy, because it simultaneously handles the git index and
Vim buffers.


Using the :Git command, you can run any arbitrary git command from inside Vim.

I prefer to switch to the shell for anything that generates a log of output,
such as git log for example. But commands that generate little or no output are
  fair game for running from inside Vim. :Git checkout -b experimental for
  example.

At Vim's command line, the % symbol has a special meaning: it expands to the
full path of the current file. You can use this to run any git command that
expects a filepath as an argument, making the command act on the current file.
But fugitive also provides a few convenience methods, some of which are
summarized in this table:

git                     fugitive    action

:Git add %              :Gwrite     Stage the current file to the index

:Gwrite                 Write to the current file's path and stage the results.
                        When run in a work tree file, it is effectively git
                        add.  Elsewhere, it is effectively git-checkout.  A
                        great deal of effort is expended to behave sensibly
                        when the work tree or index version of the file is
                        open in another buffer.


:Git checkout %         :Gread      Revert current file to last checked in 
                                    version

:Gread [revision]       'empty' the buffer and |:read| a |fugitive-revision|.
                        When the argument is omitted, this is similar to
                        git-checkout on a work tree file or git-add on a stage
                        file, but without writing anything to disk.

note: See that "but 'without' writing anything to disk" which is different from
:Git checkout %


:Git rm %               :Gremove    Delete the current file and the 
                                    corresponding Vim buffer

:Git mv %               :Gmove      Rename the current file and the 
                                    corresponding Vim buffer

:Git mv % target_path   :Gmove target_path 


The :Gcommit command opens up a commit window in a split window. One advantage
to using this, rather than running git commit in the shell, is that you can use
Vim's keyword autocompletion when composing your commit message.

note: :h complete

:Gcommit [args]         A wrapper around git-commit.  If there is nothing
                        to commit, |:Gstatus| is called instead.  Unless the
                        arguments given would skip the invocation of an editor
                        (e.g., -m), a split window will be used to obtain a
                        commit message, or a new tab if -v is given.  Write
                        and close that window (:wq or |:Gwrite|) to finish the
                        commit.  Unlike when running the actual git-commit
                        command, it is possible (but unadvisable) to alter the
                        index with commands like git-add and git-reset while a
                        commit message is pending.


<fugi-gblame>

The :Gblame command opens a vertically split window containing annotations for
each line of the file: the last commit reference, with author and timestamp.
The split windows are bound, so that when you scroll one, the other window will
follow.

:Gblame [flags]         Run git-blame on the file and open the results in a
                        scroll bound vertical split.  You can give any of
                        ltfnsewMC as flags and they will be passed along to
                        git-blame.  The following maps, which work on the
                        cursor line commit where sensible, are provided:

                        g?    show this help
                        A     resize to end of author column
                        C     resize to end of commit column
                        D     resize to end of date/time column
                        q     close blame and return to blamed window
                        gq    q, then |:Gedit| to return to work tree version
                        <CR>  q, then open commit
                        o     open commit in horizontal split
                        O     open commit in new tab
                        -     reblame at commit
                        ~     reblame at [count]th first grandparent
                        P     reblame at [count]th parent (like HEAD^[count])

:[range]Gblame [flags]  Run git-blame on the given range.


={============================================================================
*kt_dev_env_git_014* git-fugi: working with the index

#32. 2) Working with the git index

http://vimcasts.org/episodes/fugitive-vim-working-with-the-git-index/

The fugitive plugin provides an interactive status window, where you can easily
stage and review your changes for the next commit. The :Gdiff command visualizes
the changes made to a file, by comparing the working copy with the index. In
this episode, we'll learn how to stage hunks of changes to the index without
using the git add --patch command.


The Gstatus window

The :Gstatus command opens a status window. The contents closely resemble the
output from running git status in the shell, but fugitive makes the window
interactive. You can jump directly between files with ctrl-n and ctrl-p.


:Gstatus

Bring up the output of git-status in the preview window. The following 'maps',
which work on the cursor line file where sensible, are provided:

                        g?    show this help
                        <C-N> next file
                        <C-P> previous file
                        <CR>  |:Gedit|
                        -     |:Git| add
                        -     |:Git| reset (staged files)
                        cA    |:Gcommit| --amend --reuse-message=HEAD
                        ca    |:Gcommit| --amend
                        cc    |:Gcommit|
                        cva   |:Gcommit| --amend --verbose
                        cvc   |:Gcommit| --verbose
                        D     |:Gdiff|
                        ds    |:Gsdiff|
                        dp    |:Git!| diff (p for patch; use :Gw to apply)
                        dp    |:Git| add --intent-to-add (untracked files)
                        dv    |:Gvdiff|
                        O     |:Gtabedit|
                        o     |:Gsplit|
                        p     |:Git| add --patch
                        p     |:Git| reset --patch (staged files)
                        q     close status
                        r     reload status
                        S     |:Gvsplit|

note:
"-" add/reset file (works in 'visual' mode too)
C   invoke :Gcommit

note:
While this status window is open, it gets updated when make changes to files
in the working directory and can use the commands above.


Working with the git index

The git index is where you put changes that you want to be included in the
next commit. If you are used to working with the command line git client, you
might think of the index as an abstract concept. But with fugitive, you can
actually read the index version of a file into a buffer by running:

:Gedit :path/to/file

If you run :Gedit with no arguments from a working tree file, it will open the
'index' version of that file. You can always open the index version of the
current file by running any one of the following:

:Gedit
:Gedit :0
:Gedit :%


:Gedit [revision]       |:edit| a |fugitive-revision|.
:Gsplit [revision]      |:split| a |fugitive-revision|.
:Gvsplit [revision]     |:vsplit| a |fugitive-revision|.
:Gtabedit [revision]    |:tabedit| a |fugitive-revision|.
:Gpedit [revision]      |:pedit| a |fugitive-revision|.
:Gsplit! [args]
:Gvsplit! [args]
:Gtabedit! [args]       Like |:Git!|, but open the resulting temp file in a
:Gpedit! [args]         split, tab, or preview window.


It helps to understand the lifecycle of the index file between two commits. To
begin with, the contents of the index and working copy files will be exactly
the same as the most recent commit. As you make changes to your working copy,
its contents begin to diverge from those of the index file. Staging a file
  updates the contents of the index file to match those of the working copy.
  When you commit your work, it is the contents of the index file that are
  saved with that commit object.


Comparing working copy with index version using :Gdiff

When you run:

:Gdiff

on a work tree file without any arguments, fugitive performs a vimdiff against
the index version of the file. This opens a 'vertical' split window, with the
'index' file on the 'left' and the working 'copy' on the 'right'. The files
always appear in that order, so you can commit that to memory.  


:Gdiff [revision]       Perform a |vimdiff| against the current file in the
                        given revision.  With no argument, the version in the
                        index is used (which means a three-way diff during a
                        merge conflict, making it a git-mergetool
                        alternative).  The newer of the two files is placed
                        to the 'right' or bottom, depending on 'diffopt' and
                        the width of the window relative to 'textwidth'.  Use
                        |do| and |dp| and write to the index file to simulate
                        "git add --patch".


<gwrite>

Wholesale reconciliation

The :Gread and :Gwrite commands can either add a file to the index or reset
the file, depending on where they are called from. The following table and
diagrams summarize the possibilities:

command     active window     affect

:Gwrite     working copy      stage file
:Gread      working copy      checkout file
:Gwrite     index             checkout file
:Gread      index             stage file


// from #33. 3) Resolving merge conflicts with vimdiff
Keeping one parent version in its entirety

In reality, it's often the case that one of the parent versions is to be kept
wholesale, and the other version is to be discarded. In this scenario, :Gwrite
command comes in handy. This overwrites the working tree and index copies with
the contents of the currently active file.

If you run :Gwrite from the target or merge version of a file, fugitive raises a
warning. This is to protect you from accidentally overwriting the working copy
and index files when you've carefully cherry picked the changes from the parent
versions. If you want to stage either of the parent versions in their entirety,
use :Gwrite! to show you really mean it.


Piecemeal reconciliation

Vim's built in :diffget and :diffput commands work a bit like :Gread and
:Gwrite, except that they are more granular. Whereas :Gread will completely
overwrite the current buffer with the contents of the other buffer, :diffget
will only pull in a patch at a time.

command   active window   affect
:diffput  working copy    stage hunk
:diffget  working copy    checkout hunk
:diffput  index           checkout hunk
:diffget  index           stage hunk

[c        jump to previous hunk
]c        jump to next hunk

To leave vimdiff mode, you just need to close the windows that are being
compared. The quickest way to do this is to run :only from the window that you
want to keep open.

:only     close all windows apart from the current one


={============================================================================
*kt_dev_env_git_014* git-fugi: resolving merge conflicts

#33. 3) Resolving merge conflicts with vimdiff

http://vimcasts.org/episodes/fugitive-vim-resolving-merge-conflicts-with-vimdiff/

:Gdiff on a conflicted file opens 3-way diff

When you run :Gdiff on a conflicted file, fugitive opens 3 split windows. They
always appear in this order:

 +------------------------------------------+
 | bufspec: //2   |         | bufspec: //3  |  
 |                |         |               |
 |                |         |               |
 | target         | working |         merge |
 | (HEAD)         | copy    |               |
 +------------------------------------------+

- the left window contains the version from the target(current) branch

- the middle window contains the working copy of the file, complete with
  conflict markers

- the right window contains the version from the merge branch


$ git checkout master
$ git merge feature


I discuss 'target' and 'merge' branches a lot in the screencast, so lets just make
sure that we're on the same page. The target branch is the one that is active
when you run git merge. Or in other words, it's the HEAD branch. 

The merge branch is the one that is named in the git merge command. In this
scenario the master branch is the target, and the feature branch is merged into
target, making it the merge branch.

note: target is current branch and merge is a branch to merge and cherry-pick.


Strategies for reconciling 3-way diffs

There are two basic strategies for reconciling a 3-way diff. You can either keep
your cursor in the 'middle' file, and run :diffget with the bufspec for the file
containing the change you want to keep. Or you can position your cursor on the
change that you want to keep, and run :diffput with the bufspec for the working
copy file. We’ll take a look at each of these strategies in turn, starting with
diffget.


Introducing buffspecs

In the context of a 2-way diff, the :diffget and :diffput commands are
'unambiguous'. If you ask Vim to get the diff from the other window, there is
only one place for it to look. When you do a 3-way merge, things get a little
more complex. This time, it would be 'ambiguous' if you were to tell Vim to
fetch the changes from the other window. You have to specify which buffer to
fetch the changes from by providing a [bufspec].

The buffspec could either be the buffer number, or a partial match for the
buffer's name. Buffer numbers are assigned sequentially, so they will differ
from session to session, but you can always be sure that they will uniquely
identify their buffer.

Fugitive follows a consistent naming convention when creating buffers for the
target and merge versions of a conflicted file. The parent file from the target
branch 'always' includes the string //2, while the parent from the merge branch
always contains //3. These partial matches are sufficient to uniquely identify
the target and merge parents when using the :diffget command.


Resolving a 3-way diff with :diffget

The :diffget command modifies the current buffer by pulling a change over from
one of the other buffers. In resolving a merge conflict, we want to treat target
and merge parents as reference copies, pulling hunks of changes from those into
the conflicted working copy. That means that we want to keep the middle buffer
active, and run diffget with a reference to the buffer containing the change
that we want to use.

    :diffget //2 - fetches the hunk from the target parent (on the 'left')
    :diffget //3 - fetches the hunk from the merge parent (on the 'right')

Note that Vim does not automatically recalculate the diff colors after you run
:diffget. You can tell Vim to do this by running :diffupdate.

Vim provides a couple of convenient shorthand mappings for these commands: do
performs a diffget, and dp does diffput. These mappings don't normally work in a
3-way diff, because the diffget and diffput commands both require an argument in
this context. But in the case of the diffput command, it's pretty easy to guess
what that argument is going to be.


={============================================================================
*kt_dev_env_git_014* git-fugi: exploring the history of a git repository

#35. 5) Exploring the history of a git repository 

http://vimcasts.org/episodes/fugitive-vim-exploring-the-history-of-a-git-repository/


:Glog [args]            Load all previous revisions of the 'current' file into
                        the quickfix list. Additional git-log arguments can
                        be given (for example, --reverse). If "--" appears as
                        an argument, no file specific filtering is done, and
                        previous commits rather than previous file revisions
                        are loaded.


Browsing past revisions of a file

The Glog command makes it easy to examine all previous revisions of a file. It
does this by loading each revision into its own buffer, and queuing them in the
quickfix list in chronological order.


You can filter the results

:Glog 	
load all previous revisions of the 'current' file into the quickfix list

:Glog -10 	
load the last ten previous revisions of the current file into the quickfix list

:Glog -10 --reverse 	
load the first ten revisions of the current file into the quickfix list in
reverse chronological order

:Glog -1 --until=yesterday 	
load the last version of the current file that was checked in before midnight
last night Browsing past commits


You can also use the :Glog command to review past commit objects, by appending a
trailing -- argument. By default, this will load all ancestral commit objects
into the quickfix list. If you supply a filepath after the -- argument, then the
list will be filtered to only include commit objects that touched the specified
file.

:Glog -- 	
load 'all' ancestral commit objects into the quickfix list

:Glog -- % 	
load 'all' ancestral commit objects that 'touched' the current file into the
quickfix list

note:
"--" uses to feed the result to quickfix.

Note that when fugitive loads a commit object into a buffer, it is interactive
in a number of ways. See episode 34 for more details.  Working with the quickfix
list

I recommend installing unimpaired.vim, another plugin by Tim Pope. This provides
lots of useful pairs of mappings, including a handful that make working with the
quickfix list much easier: unimpaired

[q 	:cprev 	jump to previous quickfix item
]q 	:cnext 	jump to next quickfix item
[Q 	:cfirst 	jump to first quickfix item
]Q 	:clast 	jump to last quickfix item


Searching the working tree with Ggrep

The Ggrep command is a wrapper for git grep. It uses the results to populate the
quickfix list, so you can easily navigate the result list from inside Vim.

If you want to search your working tree for the text ‘find me’, simply run:

:Ggrep 'find me'

The git grep command only looks inside files that are tracked by the git
repository. The fact that it only looks inside tracked files means that it skips
over any files or directories listed in the .gitignore file.  Searching
branches, tags and commits with Ggrep

git grep is not just limited to reading files on the filesystem. It can look
inside any git object. So using git grep, you can search all files in any of
your git branches without first having to switch to the branch.

:Ggrep findme 	search for ‘findme’ in working copy files (excluding untracked files)
:Ggrep --cached findme 	search for ‘findme’ in the index
:Ggrep findme branchname 	search for ‘findme’ in branch ‘branchname’
:Ggrep findme tagname 	search for ‘findme’ in tag ‘tagname’
:Ggrep findme SHA 	search for ‘findme’ in the commit/tag identified by SHA

When you open a file that belongs on another branch, fugitive will automatically
  create a read only buffer for it.  Searching for text in a commit message

If you want to search the text of commit messages, you can do so by passing the
--grep option to the git log command. For example, if you wanted to find commit
messages containing the text ‘findme’, you could run:

git log --grep=findme

You can also do this from inside of Vim using the :Glog wrapper. This table
summarizes a couple of ways you might use this:

:Glog --grep=findme -- 	search for ‘findme’ in all ancestral commit messages
:Glog --grep=findme -- % 	search for ‘findme’ in all ancestral commit messages that touch the currently active file


Searching for text added or removed by a commit

Git also makes it possible to search for text that was added or removed by a
commit using the pickaxe option. This is activated with the -S switch as
follows:

git log -Sfindme

This tells git to go through every commit, comparing the before and after state
of each file that was changed by that commit. If the specified string is present
in the file before, but absent from the file after the commit, then it counts as
a match. The converse is also true, so if the specified string was either added
or removed by the commit, then it will appear the git log results.

Here are a couple of examples demonstrating how the pickaxe option can be used
with :Glog: command 	action

:Glog -Sfindme -- 	search for ‘findme’ in the diff for each ancestral commit
:Glog -Sfindme -- % 	search for ‘findme’ in the diff for each ancestral commit that touches the currently active file


={============================================================================
*kt_dev_env_git_014* git-fugi: doc

*fugitive.txt*  A Git wrapper so awesome, it should be illegal

Author:  Tim Pope <http://tpo.pe/>
License: Same terms as Vim itself (see |license|)

This plugin is only available if 'compatible' is not set.

INTRODUCTION                                    *fugitive*

Whenever you edit a file from a Git repository, a set of commands is defined
that serve as a gateway to Git.

COMMANDS                                        *fugitive-commands*

These commands are local to the buffers in which they work (generally, buffers
that are part of Git repositories).

                                                *fugitive-:Git*
:Git [args]             Run an arbitrary git command. Similar to :!git [args]
                        but chdir to the repository tree first.

                                                *fugitive-:Git!*
:Git! [args]            Like |:Git|, but capture the output into a temp file,
                        and edit that temp file.

                                                *fugitive-:Gcd*
:Gcd [directory]        |:cd| relative to the repository.

                                                *fugitive-:Glcd*
:Glcd [directory]       |:lcd| relative to the repository.


:Gmerge [args]          Calls git-merge and loads errors and conflicted files
                        into the quickfix list.  Opens a |:Gcommit| style
                        split window for the commit message if the merge
                        succeeds.  If called during a merge conflict, the
                        conflicted files from the current index are loaded
                        into the quickfix list.

                                                *fugitive-:Gpull*
:Gpull [args]           Like |:Gmerge|, but for git-pull.

                                                *fugitive-:Gpush*
:Gpush [args]           Invoke git-push, load the results into the quickfix
                        list, and invoke |:cwindow| to reveal any errors.
                        |:Dispatch| is used if available for asynchronous
                        invocation.

                                                *fugitive-:Gfetch*
:Gfetch [args]          Like |:Gpush|, but for git-fetch.

                                                *fugitive-:Ggrep*
:Ggrep [args]           |:grep| with git-grep as 'grepprg'.

                                                *fugitive-:Glgrep*
:Glgrep [args]          |:lgrep| with git-grep as 'grepprg'.



:{range}Glog [args]     Use git-log -L to load previous revisions of the given
                        range of the current file into the quickfix list.  The
                        cursor is positioned on the first line of the first
                        diff hunk for each commit.

                                                *fugitive-:Gllog*
:Gllog [args]           Like |:Glog|, but use the location list instead of the
                        quickfix list.

:{range}Gread [revision]
                        |:read| in a |fugitive-revision| after {range}.

                                                *fugitive-:Gread!*
:Gread! [args]          Empty the buffer and |:read| the output of a Git
                        command.  For example, :Gread! show HEAD:%.

:{range}Gread! [args]  |:read| the output of a Git command after {range}.

:Gwrite {path}          You can give |:Gwrite| an explicit path of where in
                        the work tree to write.  You can also give a path like
                        :0:foo.txt or even :0 to write to just that stage in
                        the index.

                                                *fugitive-:Gwq*
:Gwq [path]             Like |:Gwrite| followed by |:quit| if the write
                        succeeded.

:Gwq! [path]            Like |:Gwrite|! followed by |:quit|! if the write
                        succeeded.


:Gsdiff [revision]      Like |:Gdiff|, but always split horizontally.

                                                *fugitive-:Gvdiff*
:Gvdiff [revision]      Like |:Gdiff|, but always split vertically.


:Gmove {destination}    Wrapper around git-mv that renames the buffer
                        afterward. The destination is relative to the current
                        directory except when started with a /, in which case
                        it is relative to the work tree. Add a ! to pass -f.

note: this wipes out old buffer and renames a buffer.


:Gremove                Wrapper around git-rm that 'deletes' the buffer
                        afterward. When invoked in an index file, --cached is
                        passed. Add a ! to pass -f and forcefully discard the
                        buffer.

note: this wipes out the buffer which is different from ":Git rm %"

                                                *fugitive-:Gblame*
:[range]Gbrowse         If the remote for the current branch is on GitHub,
                        open the current file, blob, tree, commit, or tag
                        (with git-web--browse) on GitHub.  Otherwise, open the
                        current file, blob, tree, commit, or tag in
                        git-instaweb (if you have issues, verify you can run
                        "git instaweb" from a terminal).  If a range is given,
                        it is appropriately appended to the URL as an anchor.

                        To use with GitHub FI, point g:fugitive_github_domains
                        at a list of domains:
>
                        let g:fugitive_github_domains = ['https://example.com']
~
:[range]Gbrowse!        Like :Gbrowse, but put the URL on the clipboard rather
                        than opening it.

:[range]Gbrowse {revision}
                        Like :Gbrowse, but for a given |fugitive-revision|.  A
                        useful value here is -, which ties the URL to the
                        latest commit rather than a volatile branch.

:[range]Gbrowse [...]@{remote}
                        Force using the given remote rather than the remote
                        for the current branch.  The remote is used to
                        determine which GitHub repository to link to.

MAPPINGS                                        *fugitive-mappings*

These maps are available everywhere.

                                                *fugitive-c_CTRL-R_CTRL-G*
<C-R><C-G>              On the command line, recall the path to the current
                        object (that is, a representation of the object
                        recognized by |:Gedit|).

                                                *fugitive-y_CTRL-G*
["x]y<C-G>              Yank the commit SHA and path to the current object.

These maps are available in Git objects.

                                                *fugitive-<CR>*
<CR>                    Jump to the revision under the cursor.

                                                *fugitive-o*
o                       Jump to the revision under the cursor in a new split.

                                                *fugitive-S*
S                       Jump to the revision under the cursor in a new
                        vertical split.

                                                *fugitive-O*
O                       Jump to the revision under the cursor in a new tab.

                                                *fugitive--*
-                       Go to the tree containing the current tree or blob.

                                                *fugitive-~*
~                       Go to the current file in the [count]th first
                        ancestor.

                                                *fugitive-P*
P                       Go to the current file in the [count]th parent.

                                                *fugitive-C*
C                       Go to the commit containing the current file.

                                                *fugitive-.*
.                       Start a |:| command line with the current revision
                        prepopulated at the end of the line.

                                                *fugitive-a*
a                       Show the current tag, commit, or tree in an alternate
                        format.

SPECIFYING REVISIONS                            *fugitive-revision*

Fugitive revisions are similar to Git revisions as defined in the "SPECIFYING
REVISIONS" section in the git-rev-parse man page.  For commands that accept an
optional revision, the default is the file in the index for work tree files
and the work tree file for everything else.  Example revisions follow.

note: "work tree" means git repository

Revision        Meaning ~
HEAD            .git/HEAD
master          .git/refs/heads/master
HEAD^{}         The commit referenced by HEAD
HEAD^           The parent of the commit referenced by HEAD
HEAD:           The tree referenced by HEAD
/HEAD           The file named HEAD in the work tree
Makefile        The file named Makefile in the work tree
HEAD^:Makefile  The file named Makefile in the parent of HEAD
:Makefile       The file named Makefile in the index (writable)
-               The current file in HEAD
^               The current file in the previous commit
~3              The current file 3 commits ago
:               .git/index (Same as |:Gstatus|)
:0              The current file in the index
:1              The current file's common ancestor during a conflict
:2              The current file in the target branch during a conflict
:3              The current file in the merged branch during a conflict
:/foo           The most recent commit with "foo" in the message

STATUSLINE                                      *fugitive-statusline*

                                                *fugitive#statusline()*
Add %{fugitive#statusline()} to your statusline to get an indicator including
the current branch and the currently edited file's commit.  If you don't have
a statusline, this one matches the default when 'ruler' is set:
>
    set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
<
                                                *fugitive#head(...)*
Use fugitive#head() to return the name of the current branch. If the current
HEAD is detached, fugitive#head() will return the empty string, unless the
optional argument is given, in which case the hash of the current commit will
be truncated to the given number of characters.


ABOUT

Grab the latest version or report a bug on GitHub:

http://github.com/tpope/vim-fugitive


={============================================================================
*kt_dev_env_git_015* git-gitgutter

https://github.com/airblade/vim-gitgutter

vim-gitgutter

A Vim plugin which shows a git diff in the 'gutter' (sign column). It shows
whether each line has been added, modified, and where lines have been removed.
You can also stage and revert individual hunks.


Features:

    Shows signs for added, modified, and removed lines.

    Ensures signs are always as up to date as possible (but without running more
        than necessary).

    Quick jumping between blocks of changed lines ("hunks").

    Stage/revert/preview individual hunks.

    Optional line highlighting.

    Fully customisable (signs, sign column, line highlights, mappings, extra
        git-diff arguments, etc).

    Can be toggled on/off.

    Preserves signs from other plugins.

    Easy to integrate diff stats into status line; built-in integration with
    vim-airline.

    Works with fish shell (in addition to the usual shells).


In the screenshot above you can see:

    Line 15 has been modified.
    Lines 21-24 are new.
    A line or lines were removed between lines 25 and 26.


Installation

Before installation, please check your Vim supports signs by running :echo
has('signs'). 1 means you're all set; 0 means you need to install a Vim with
signs support. If you're compiling Vim yourself you need the 'big' or 'huge'
feature set. MacVim supports signs.

Your vim shell option needs to point to a POSIX-compatible shell. For example if
you use Fish, add set shell=/bin/bash to your vimrc.

If you don't have a preferred installation method, I recommend installing
pathogen.vim, and then simply copy and paste:


Activation

You can explicitly turn vim-gitgutter off and on (defaults to on):

    turn off with :GitGutterDisable
    turn on with :GitGutterEnable
    toggle with :GitGutterToggle.

note:
  " to turn off vim-gitgutter by default
  let g:gitgutter_enabled = 0

You can turn the signs on and off (defaults to on):

    turn on with :GitGutterSignsEnable
    turn off with :GitGutterSignsDisable
    toggle with :GitGutterSignsToggle.

And you can turn line highlighting on and off (defaults to 'off'):

    turn on with :GitGutterLineHighlightsEnable
    turn off with :GitGutterLineHighlightsDisable
    toggle with :GitGutterLineHighlightsToggle.

Note that if you have line highlighting on and signs off, you will have an empty
sign column – more accurately, a sign column with invisible signs. This is
because line highlighting requires signs and Vim always shows the sign column
even if the signs are invisible.

If you switch off both line highlighting and signs, you won't see the sign
column. That is unless you have set let g:gitgutter_sign_column_always = 1 so
it's always there.

To keep your Vim snappy, vim-gitgutter will suppress itself when a file has
more than 500 changes. As soon as the number of changes falls below the limit
vim-gitgutter will show the signs again. You can configure the threshold with:

let g:gitgutter_max_signs = 500  " default value


Hunks

You can jump between hunks:

    jump to next hunk (change): ]c
    jump to previous hunk (change): [c.

Both of those take a preceding count.

To set your own mappings for these, for example ]h and [h:

nmap ]h <Plug>GitGutterNextHunk
nmap [h <Plug>GitGutterPrevHunk

You can stage or revert an individual hunk when your cursor is in it:

    stage the hunk with <Leader>hs or
    revert it with <Leader>hr.

The . command will work with both these if you install repeat.vim.

To set your own mappings for these, for example if you prefer the mnemonics
hunk-add and hunk-undo:

nmap <Leader>ha <Plug>GitGutterStageHunk
nmap <Leader>hu <Plug>GitGutterRevertHunk

And you can preview a hunk's changes with <Leader>hp. You can of course change
this mapping, e.g:

nmap <Leader>hv <Plug>GitGutterPreviewHunk

If you don't want vim-gitgutter to set up any mappings at all, use this:

let g:gitgutter_map_keys = 0


Finally, you can force vim-gitgutter to update its signs across all visible
buffers with :GitGutterAll.

See the customisation section below for how to change the defaults.


When are the signs updated?

By default the signs are updated as follows:
Event                       Reason for update               Configuration
Stop typing                 So the signs are real time      g:gitgutter_realtime
Switch buffer               To notice change to git index   g:gitgutter_eager
Switch tab                  To notice change to git index   g:gitgutter_eager
Focus the GUI               To notice change to git index   g:gitgutter_eager
Read a file into a buffer   To display initial signs        [always]
Save a buffer               So non-realtime signs are up to date  [always]
Change a file outside Vim   To notice git stash                   [always]


note: update time

The length of time Vim waits after you stop typing before it triggers the
plugin is governed by the setting updatetime. This defaults to 4000
milliseconds which is rather too long. I recommend around 750 milliseconds but
it depends on your system and your preferences. Note that in terminal Vim
pre-7.4.427 an updatetime of less than approximately 1000 milliseconds can
lead to random highlighting glitches; the lower the updatetime, the more
glitches.

If you experience a lag, you can trade speed for accuracy:

let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0

Note the realtime updating requires Vim 7.3.105 or higher.


Customisation

You can customise:

    The sign column's colours

    Whether or not the sign column is shown when there aren't any signs
    (defaults to no)

    The signs' colours and symbols

    Line highlights

    Extra arguments for git diff

    Key mappings

    Whether or not to escape grep (default to no)

    Whether or not vim-gitgutter is on initially (defaults to on)

    Whether or not signs are shown (defaults to yes)

    Whether or not line highlighting is on initially (defaults to off)

    Whether or not vim-gitgutter runs in "realtime" (defaults to yes)

    Whether or not vim-gitgutter runs eagerly (defaults to yes)

Please note that vim-gitgutter won't override any colours or highlights you've
set in your colorscheme.


Sign column
---------------
By default vim-gitgutter will make the sign column look like the line number
column.

To customise your sign column's background color, first tell vim-gitgutter to
leave it alone:

let g:gitgutter_override_sign_column_highlight = 0

And then either update your colorscheme's SignColumn highlight group or set it
in your vimrc:

highlight SignColumn ctermbg=whatever    " terminal Vim
highlight SignColumn guibg=whatever      " gVim/MacVim

By default the sign column will appear when there are signs to show and
disappear when there aren't. If you would always like the sign column to be
there, add let g:gitgutter_sign_column_always = 1 to your ~/.vimrc.  


Signs' colours and symbols
---------------
To customise the colours, set up the following highlight groups in your
colorscheme or ~/.vimrc:

GitGutterAdd          " an added line
GitGutterChange       " a changed line
GitGutterDelete       " at least one removed line
GitGutterChangeDelete " a changed line followed by at least one removed line

You can either set these with highlight GitGutterAdd {key}={arg}... or link
them to existing highlight groups with, say, highlight link GitGutterAdd
DiffAdd.


To customise the symbols, add the following to your ~/.vimrc:
---------------

let g:gitgutter_sign_added = 'xx'
let g:gitgutter_sign_modified = 'yy'
let g:gitgutter_sign_removed = 'zz'
let g:gitgutter_sign_removed_first_line = '^^'
let g:gitgutter_sign_modified_removed = 'ww'


plugin/gitgutter.vim

34:call s:set('g:gitgutter_sign_column_always',          0)
38:call s:set('g:gitgutter_sign_added',                '+')
39:call s:set('g:gitgutter_sign_modified',             '~')
40:call s:set('g:gitgutter_sign_removed',              '_')
47:call s:set('g:gitgutter_sign_modified_removed',     '~_')

42:  call s:set('g:gitgutter_sign_removed_first_line', 'â¾')
44:  let g:gitgutter_sign_removed_first_line = '_^'


Line highlights
---------------
Similarly to the signs' colours, set up the following highlight groups in your
colorscheme or ~/.vimrc:

GitGutterAddLine          " default: links to DiffAdd
GitGutterChangeLine       " default: links to DiffChange
GitGutterDeleteLine       " default: links to DiffDelete
GitGutterChangeDeleteLine " default: links to GitGutterChangeLineDefault, i.e.
DiffChange


Extra arguments for git diff
---------------

If you want to pass extra arguments to git diff, for example to ignore
whitespace, do so like this:

let g:gitgutter_diff_args = '-w'


Key mappings
---------------
To disable all key mappings:

let g:gitgutter_map_keys = 0

See above for configuring maps for hunk-jumping and staging/reverting.


Whether or not to escape grep
---------------
If you have grep aliased to something which changes its output, for example
grep --color=auto -H, you will need to tell vim-gitgutter to use raw grep:

let g:gitgutter_escape_grep = 1

To turn off vim-gitgutter by default

Add let g:gitgutter_enabled = 0 to your ~/.vimrc.
To turn off signs by default

Add let g:gitgutter_signs = 0 to your ~/.vimrc.
To turn on line highlighting by default

Add let g:gitgutter_highlight_lines = 1 to your ~/.vimrc.


FAQ
---------------

Why are the colours in the sign column weird?

Your colorscheme is configuring the SignColumn highlight group weirdly. Please
see the section above on customising the sign column.


There's a noticeable lag when vim-gitter runs; how can I avoid it?

By default vim-gitgutter runs often so the signs are as accurate as possible.
However on some systems this causes a noticeable lag. If you would like to
trade a little accuracy for speed, add this to your ~/.vimrc:

let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0


What happens if I also use another plugin which uses signs (e.g. Syntastic)?

Vim only allows one sign per line. Before adding a sign to a line,
                                     vim-gitgutter checks whether a sign has
                                       already been added by somebody else. If
                                       so it doesn't do anything. In other
                                       words vim-gitgutter won't overwrite
                                       another plugin's signs. It also won't
                                       remove another plugin's signs.


Why aren't any signs showing at all?

Here are some things you can check:

    Your git config is compatible with the version of git which your Vim is
    calling (:echo system('git --version')).  Your Vim supports signs (:echo
        has('signs') should give 1).  Your file is being tracked by git and
    has unstaged, saved changes.  If you use a non-POSIX shell, add set
    shell=/bin/bash to your ~/.vimrc.


Shameless Plug
---------------
If this plugin has helped you, or you'd like to learn more about Vim, why not
check out this screencast I wrote for PeepCode:

    Smash Into Vim

This was one of PeepCode's all-time top three bestsellers and is now available
at Pluralsight.

You can read reviews on my website.


={============================================================================
*kt_dev_env_0000* git-prompt

http://mediadoneright.com/content/ultimate-git-ps1-bash-prompt

BASH customizations should generally be made in your

~/.bash_aliases

file, use this file instead of directly editing ~/.bashrc. The reason for this
is it makes for better/safer updates or upgrades of Ubuntu. 

#  Customize BASH PS1 prompt to show current GIT repository and branch.
#  by Mike Stewart - http://MediaDoneRight.com

#  SETUP CONSTANTS
#  Bunch-o-predefined colors.  Makes reading code easier than escape sequences.
#  I don't remember where I found this.  o_O

# Reset
Color_Off="\[\033[0m\]"       # Text Reset

# Regular Colors
Black="\[\033[0;30m\]"        # Black
Red="\[\033[0;31m\]"          # Red
Green="\[\033[0;32m\]"        # Green
Yellow="\[\033[0;33m\]"       # Yellow
Blue="\[\033[0;34m\]"         # Blue
Purple="\[\033[0;35m\]"       # Purple
Cyan="\[\033[0;36m\]"         # Cyan
White="\[\033[0;37m\]"        # White

# Bold
BBlack="\[\033[1;30m\]"       # Black
BRed="\[\033[1;31m\]"         # Red
BGreen="\[\033[1;32m\]"       # Green
BYellow="\[\033[1;33m\]"      # Yellow
BBlue="\[\033[1;34m\]"        # Blue
BPurple="\[\033[1;35m\]"      # Purple
BCyan="\[\033[1;36m\]"        # Cyan
BWhite="\[\033[1;37m\]"       # White

# Underline
UBlack="\[\033[4;30m\]"       # Black
URed="\[\033[4;31m\]"         # Red
UGreen="\[\033[4;32m\]"       # Green
UYellow="\[\033[4;33m\]"      # Yellow
UBlue="\[\033[4;34m\]"        # Blue
UPurple="\[\033[4;35m\]"      # Purple
UCyan="\[\033[4;36m\]"        # Cyan
UWhite="\[\033[4;37m\]"       # White

# Background
On_Black="\[\033[40m\]"       # Black
On_Red="\[\033[41m\]"         # Red
On_Green="\[\033[42m\]"       # Green
On_Yellow="\[\033[43m\]"      # Yellow
On_Blue="\[\033[44m\]"        # Blue
On_Purple="\[\033[45m\]"      # Purple
On_Cyan="\[\033[46m\]"        # Cyan
On_White="\[\033[47m\]"       # White

# High Intensty
IBlack="\[\033[0;90m\]"       # Black
IRed="\[\033[0;91m\]"         # Red
IGreen="\[\033[0;92m\]"       # Green
IYellow="\[\033[0;93m\]"      # Yellow
IBlue="\[\033[0;94m\]"        # Blue
IPurple="\[\033[0;95m\]"      # Purple
ICyan="\[\033[0;96m\]"        # Cyan
IWhite="\[\033[0;97m\]"       # White

# Bold High Intensty
BIBlack="\[\033[1;90m\]"      # Black
BIRed="\[\033[1;91m\]"        # Red
BIGreen="\[\033[1;92m\]"      # Green
BIYellow="\[\033[1;93m\]"     # Yellow
BIBlue="\[\033[1;94m\]"       # Blue
BIPurple="\[\033[1;95m\]"     # Purple
BICyan="\[\033[1;96m\]"       # Cyan
BIWhite="\[\033[1;97m\]"      # White

# High Intensty backgrounds
On_IBlack="\[\033[0;100m\]"   # Black
On_IRed="\[\033[0;101m\]"     # Red
On_IGreen="\[\033[0;102m\]"   # Green
On_IYellow="\[\033[0;103m\]"  # Yellow
On_IBlue="\[\033[0;104m\]"    # Blue
On_IPurple="\[\033[10;95m\]"  # Purple
On_ICyan="\[\033[0;106m\]"    # Cyan
On_IWhite="\[\033[0;107m\]"   # White

# Various variables you might want for your PS1 prompt instead
Time12h="\T"
Time12a="\@"
PathShort="\w"
PathFull="\W"
NewLine="\n"
Jobs="\j"


# This PS1 snippet was adopted from code for MAC/BSD I saw from:
# http://allancraig.net/index.php?option=com_content&view=article&id=108:ps1-export-command-for-git&catid=45:general&Itemid=96
# I tweaked it to work on UBUNTU 11.04 & 11.10 plus made it mo' better
#
# Let me explain how it works
#
# This is the current time, with seconds. This is controlled by the variable:
# $Time12h and the color is set just before it as $IBlack
#
# This is the current directory, with home folder abr. In this case the color
# and look is controlled near the end of the snippet by the section with
# $Yellow$PathShort 
#
# Ok, this is controlled by the $Color_Off variables littered throughout.  
#
# Ok, this is the fun! Green parenthesis means you're on an unchanged branch.  
#    
# Red Curly Brackets means something's changed! You have a dirty branch. Either
# finish & commit or cleanup. ;-) 

export PS1=$IBlack$Time12h$Color_Off'$(git branch &>/dev/null;\
if [ $? -eq 0 ]; then \
  echo "$(echo `git status` | grep "nothing to commit" > /dev/null 2>&1; \
  if [ "$?" -eq "0" ]; then \
    # @4 - Clean repository - nothing to commit
    echo "'$Green'"$(__git_ps1 " (%s)"); \
  else \
    # @5 - Changes to working tree
    echo "'$IRed'"$(__git_ps1 " {%s}"); \
  fi) '$BYellow$PathShort$Color_Off'\$ "; \
else \
  # @2 - Prompt when not in GIT repo
  echo " '$Yellow$PathShort$Color_Off'\$ "; \
fi)'


={============================================================================
*kt_dev_env_0000* git-init git-clone

{init-repo-in-existing-dirs}
Create an empty repository.

$ git init
Initialized empty Git repository in /home/kit/.git/

If it's a directory, the command adds all the files in that directory
recursively.

$ git add *.c or $ git add *
$ git add README
$ git commit -m 'initial project version'


{clone-from-existing-repo}
The command is clone and not checkout. This is an important distinction - Git
receives a copy of nearly all data that the server has. Every version of every
file for the history of the project is pulled down when you run git clone. In
fact, if your server disk gets corrupted, you can use any of the clones on any
client to set the server back to the state it was in when it was cloned

$ git clone git://github.com/schacon/grit.git

That creates a directory named grit, initializes a .git directory inside it,
     pulls down all the data for that repository, and checks out a working copy
     of the latest version. 

If you want to clone the repository into a directory named something other than
grit, you can specify that as the next command-line option:

git clone git://github.com/schacon/grit.git mygrit
git clone https://github.com/keitee/kb


{no-password}
Why is Git always asking for my password?

To use no password, add ssh key to the github and set git to use ssh:

git remote set-url origin git@github.com:/keitee/kb.git
git remote set-url origin git@github.com:/keitee/vim.git

<when-no-password>
* remote origin
  Fetch URL: git@github.com:keitee/kb.git
  Push  URL: git@github.com:keitee/kb.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)

<when-ask-user-and-password>
* remote origin
  Fetch URL: https://github.com/keitee/vim
  Push  URL: https://github.com/keitee/vim
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (fast-forwardable)


<clone-from-local-server>
Git has a number of different transfer protocols you can use. The previous
example uses the git:// protocol, but you may also see http(s):// or
user@server:/path.git, which uses the SSH transfer protocol. Chapter 4 will
introduce all of the available options the server can set up to access your Git
repository and the pros and cons of each.

For example, clone it from local rockford server:

git clone keitee.park@rockford:/home/keitee.park/mheg-proto my

note: my can be anyname and if omits, then use the parent dir name of remote git
repository.


={============================================================================
*kt_dev_env_0000* git-submodule

https://git-scm.com/docs/git-submodule

DESCRIPTION

Inspects, updates and manages submodules.

A submodule allows you to keep `another Git repository` in a subdirectory of
your repository. The other repository has its own history, which does not
interfere with the history of the current repository. This can be used to have
external dependencies such as `third party libraries` for example.

When cloning or pulling a repository containing submodules however, these will
not be checked out by default; the `init` and `update` subcommands will maintain
submodules checked out and at appropriate revision in your working tree.

Submodules are composed from a so-called gitlink tree entry in the main
repository that refers to a particular commit object within the inner
repository that is completely separate. 

A record in the `.gitmodules` (see gitmodules[5]) file at the root of the source
tree assigns a logical name to the submodule and describes the default URL the
submodule shall be cloned from. The logical name can be used for overriding
this URL within your local repository configuration (see submodule init).

-rw-r--r--  1 kyoupark ccusers     4146 Jul  8 15:40 .gitmodules

Submodules are not to be confused with remotes, which are other repositories
of the same project; submodules are meant for different projects you would
like to make part of your source tree, while the history of the two projects
still stays completely independent and you cannot modify the contents of the
submodule from within the main project. If you want to merge the project
histories and want to treat the aggregated whole as a single project from then
on, you may want to add a remote for the other project and use the subtree
merge strategy, instead of treating the other project as a submodule.
Directories that come from both projects can be cloned and checked out as a
whole if you choose to go that route.


foreach

    Evaluates an arbitrary `shell command` in each checked out submodule. The
    command has access to the variables $name, $path, $sha1 and $toplevel:
    $name is the name of the relevant submodule section in .gitmodules, $path
    is the name of the submodule directory relative to the superproject, $sha1
    is the commit as recorded in the superproject, and $toplevel is the
    absolute path to the top-level of the superproject. 
    
    Any submodules defined in the superproject but not checked out are ignored
    by this command.

    Unless given --quiet, foreach prints the name of each submodule before
    evaluating the command. If --recursive is given, submodules are traversed
    recursively (i.e. the given shell command is evaluated in nested
        submodules as well). 
    
    A non-zero return from the command in any submodule causes the processing
    to terminate. This can be overridden by adding || : to the end of the
    command.

    As an example, git submodule foreach 'echo $path `git rev-parse HEAD’ will
    show the path and currently checked out commit for each submodule.


update

    Update the registered submodules to match what the superproject expects by
    cloning missing submodules and updating the working tree of the
    submodules. The "updating" can be done in several ways depending on
    command line options and the value of submodule.<name>.update
    configuration variable. Supported update procedures are:

    If the submodule is not yet initialized, and you just want to use the
    setting as stored in .gitmodules, you can automatically initialize the
    submodule with the `--init` option.


<ex>
#------------------------------------------------------------------------------
# Start with a pristine and up-to-date repo
#------------------------------------------------------------------------------

# All of the following assumes that you already have a clone of the STB_SW
# repository, that you are in the top-level directory (where the .git directory
# is) and that the correct SI branch is checked out.

# No guarantee that the steps in the following helper shell script are either
# necessary or sufficient, but they have worked for me so far.
# NB: The 'git reset --hard' will delete any uncommitted changes in the work area!

$ cat -n $(which git_stb_cleanout.sh)
     1  #!/bin/bash
     2
     3  if [ ! -d .git ]; then
     4      echo "No directory '.git' here. Is this a repo?"
     5      exit 1
     6  fi
     7
     8  function git_cleanout_here() {
     9      if [ ! -e .git ]; then
    10          echo "No file/dir '.git' here. Is this a repo?"
    11          return 1
    12      fi
    13      rm -rf ./deps
    14      git clean -dfx
    15      git reset --hard
    16      git status
    17      git describe --always
    18  }
    19
    20  export -f git_cleanout_here
    21
    22  git submodule foreach git_cleanout_here
    23  git submodule update --init
    24  git_cleanout_here
    25
    26  if [ -f .git/hooks/updateHooks.py ]; then
    27      .git/hooks/updateHooks.py
    28  elif [ -f ./initialise_hooks ]; then
    29      ./initialise_hooks
    30  else
    31      echo "Warning: Git hooks not initialised or updated."
    32  fi

$ git_stb_cleanout.sh
$ git pull --rebase
$ git submodule update --init  # in case the pull brought in submodule changes


={============================================================================
*kt_dev_env_git_000* git-internal

Chapter 9 Git Internals

Git is fundamentally a content-addressable filesystem with a VCS user
interface written on top of it.


Has a bunch of verbs that do low-level work and were designed to be chained
together UNIX style or called from scripts. These commands are generally
referred to as `plumbing` commands, and the more user-friendly commands are
called `porcelain` commands.

These commands aren't meant to be used manually on the command line, but
rather to be used as building blocks for new tools and custom scripts.


<git-directory>
When you run git init in a new or existing directory, Git creates the .git
directory, which is where almost everything that Git stores and manipulates is
located.

$ ls
HEAD
branches/
config
description
hooks/
index
info/
objects/
refs/

This leaves four important entries: the `HEAD` and `index` files and the
`objects` and `refs` directories. These are the core parts of Git. 

The objects directory stores all the content for your database, the refs
directory stores pointers into commit objects in that data (branches), the
HEAD file points to the branch you currently have checked out, and the index
file is where Git stores your staging area information. 


<git-object>
Content-addressable filesystem means that at the core of Git is a simple
key-value data store. You can insert any kind of content into it, and it will
give you back a key that you can use to retrieve the content again at any
time.

the plumbing command hash-object, which takes some data, stores it in your
.git directory, and gives you back the key the data is stored as.

$ echo ’test content’ | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4

The -w tells hash-object to store the object; otherwise, the command simply
tells you what the key would be. --stdin tells the command to read the content
from stdin;

$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4


You can pull the content back out of Git with the cat-file command.

Passing -p to it instructs the cat-file command to figure out the type of
content and display it nicely for you:

$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content


note: why need `tree`?

But remembering the SHA–1 key for each version of your file isn't practical;
plus, you aren't storing the filename in your system - `just the content` This
  object type is called a `blob`. 

You can have Git tell you the object type of any object in Git, given its
SHA–1 key, with cat-file -t:

$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob


<tree-object>
The tree object, which solves the problem of storing the filename and also
allows you to store a group of files together. 

Git stores content in a manner similar to a UNIX filesystem, but a bit
simplified. All the content is stored as tree and blob objects, with trees
corresponding to UNIX directory entries and blobs corresponding more or less
to inodes or file contents. 

A `single tree object` contains one or more tree entries, each of which contains
an SHA-1 pointer to a blob or subtree with its associated mode, type, and
filename.

note:
Needs a tree object for a single file or blob.

$ git cat-file -p masterˆ{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README
100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib


Git normally creates a tree by taking the state of your staging area or index
and writing a tree object from it. So, to create a tree object, you first have
to set up an index by staging some files.

Specify the mode, SHA–1, and filename

// version 1, test.txt
$ git update-index --add --cacheinfo 100644 \
83baae61804e65cc73a7201a7252750c76066a30 test.txt

Use the `write-tree` command to write the staging area out to a tree object.
write-tree automatically creates a tree object from the state of the index if
that tree doesn't yet exist:

$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579

$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30 test.txt

$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree

Can read trees into your staging area by calling read-tree.

note:
Skipped the full examples.


<commit-object>


={============================================================================
*kt_dev_env_0000* git-three-state

{difference-to-other-vcs} {snapshot}
These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the
information they keep as a set of files and the changes made to each file over
time, as illustrated in Figure 1-4. 

-------------- checkins over time --------------->
version 1   version 2   version 3   version 4    version 5
file A      delta 1                 delta 2
file B                              delta 1      delta 2

Instead, Git thinks of its data more like a set of `snapshots` of a mini
'filesystem'.


{nearly-every-operation-is-local}
This also means that there is very little you can't do if you're offline or off
VPN. In Perforce, for example, you can't do much when you aren't connected to
the server; and in Subversion and CVS, you can edit files, but you can't commit
changes to your database (because your database is offline). This may not seem
like a huge deal, but you may be surprised what a big difference it can make.


{integrity}
Everything in Git is check-summed. The mechanism that Git uses for this
checksumming is called a SHA-1 hash. 


{three-states} {committed-modified-staged}
Three main states that your files can reside in: committed, modified, and
staged. `committed` means that the data is safely stored in your 'local'
database.  `modified` means that you have changed the file but have not
committed it to your database yet. `staged` means that you have marked a
modified file in its current version to go into your next commit snapshot.

Remember that each file in your working directory can be in one of two states:
`tracked` or `untracked`. Tracked files are files that were in the last
snapshot; they can be unmodified, modified, or staged. Untracked files are
everything else 


   working                    staging area          git direcotry(repository)
directory(snapshot)

untracked  unmodified  modified
            <-------------------------------------------------------------
                           clone(checkout) the project

     <--------->
      add/remove
               ------------>
               edit
                   ------------------->
                   stage files(checkin)
                                     ----------------------->
                                     commit
                                     (make files unmodified)

The Git 'directory', 'repository' is where Git stores the metadata and object
database for your project. This is the most important part of Git, and it is
what is copied when you clone a repository from another computer.

The "working directory" is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and
placed on disk for you to use or modify. This is 'snapshot' or blob.

The `staging-area`, or `index` is a simple file, generally contained in your Git
directory, that stores information about what will go into your next commit.
It's becoming standard to refer to it as the staging area.

The basic Git workflow goes something like this:

* You modify files in your working directory.
* You stage the files, adding snapshots of them to your staging area.
* You do a commit, which takes the files as they are in the staging area and
  stores that snapshot permanently to your Git directory.

If a particular version of a file is in the git directory, it's committed. If
it's modified but has been added to the staging area, it is staged. And if it
was changed since it was checked out but has not been staged, it is modified. 


={============================================================================
*kt_dev_env_0000* git-command-format

git xxx [options] [<repository> [<refspec>...]]

<repository>
    The `remote-repository` that is the source of a fetch or pull operation.
    This parameter can be either a URL (see the section GIT URLS below) or the
    name of a remote (see the section REMOTES below).
    

<refspec>
    Specifies which refs to fetch and which local refs to update. When no
    <refspec>s appear on the command line, the refs to fetch are read from
    remote.<repository>.fetch variables instead (see git-fetch[1]).

    The format of a <refspec> parameter is an optional plus +, followed by the
    `source-ref` <src>, followed by a colon :, followed by the `destination-ref`
    <dst>. The colon can be omitted when <dst> is empty.

    tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests
    fetching everything `up-to-the` given tag.

    The `remote-ref` that matches <src> is fetched, and if <dst> is not empty
    string, the `local-ref` that matches it is fast-forwarded using <src>. If
    the optional plus + is used, the local ref is updated even if it does not
    result in a fast-forward update.

    Note
    When the remote branch you want to fetch is known to be rewound and rebased
    regularly, it is expected that its new tip will not be descendant of its
    previous tip (as stored in your remote-tracking branch the last time you
        fetched). You would want to use the + sign to indicate non-fast-forward
    updates will be needed for such branches. There is no way to determine or
    declare that a branch will be made available in a repository with this
    behavior; the pulling user simply must know this is the expected usage
    pattern for a branch.

    Note
    There is a difference between listing multiple <refspec> directly on git
    pull command line and having multiple remote.<repository>.fetch entries in
    your configuration for a <repository> and running a git pull command without
    any explicit <refspec> parameters. <refspec>s listed explicitly on the
    command line are always merged into the current branch after fetching. In
    other words, if you list more than one remote ref, git pull will create an
    Octopus merge. On the other hand, if you do not list any explicit <refspec>
    parameter on the command line, git pull will fetch all the <refspec>s it
    finds in the remote.<repository>.fetch configuration and merge only the
    first <refspec> found into the `current-branch`. This is because making an
    Octopus from remote refs is rarely done, while keeping track of multiple
    remote heads in one-go by fetching more than one is often useful. 


={============================================================================
*kt_dev_env_0000* git-status

{status}
The command tells you which branch you're on.

$ git status
# On branch master
nothing to commit (working directory clean)


{when-modified-to-stage}
$ git status
# On branch master                  " note: see branch you are on
# Changes not staged for commit: ~
#   (use "git add <file>..." to update what will be committed)
#
#   modified:   benchmarks.rb
#

Shows that a file that is tracked has been modified in the working directory but
not yet staged. To stage it, you run the `git-add`. 

note:
`git-add` is a multipurpose command - you use it to begin tracking new files, to
stage files, and to do other things like marking merge-conflicted files as
resolved). 

When run add command to stage, it move to as

# On branch master
# Changes to be committed:  ~          " note see 'to be'
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   MHEGApp.cpp

Modified the same file and run status command again. Then

# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   work/Src/MHEGApp.cpp
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
# modified:   work/Src/MHEGApp.cpp


<options>
       -s, --short
           Give the output in the short-format.

       -u[<mode>], --untracked-files[=<mode>]
           Show untracked files (Default: all).

           The mode parameter is optional, and is used to specify the handling of untracked files. The possible options are:

           ·    no - Show no untracked files

           ·    all - Also shows individual files in untracked directories.
               See git-config(1) for configuration variable used to change the default for when the option is not specified.

={============================================================================
*kt_dev_env_0000* git-ignore

https://git-scm.com/docs/gitignore

A `gitignore` file specifies intentionally `untracked files` that Git should
ignore. Files already tracked by Git are not affected

Each line in a gitignore file specifies a pattern. When deciding whether to
ignore a `path`, Git normally checks gitignore patterns from multiple sources,
with the following order of precedence, `from highest to lowest` (within one
level of precedence, the last matching pattern decides the outcome):

1. Patterns read from the command line for those commands that support them.

<project-ignore>
2. Patterns read from a .gitignore file in the same directory as the path, or in
any parent directory, with patterns in the higher level files (up to the
    toplevel of the work tree) being `overridden` by those in lower level files
down to the directory containing the file. These patterns match relative to the
location of the .gitignore file. A project normally includes such .gitignore
files in its repository, containing patterns for files generated as part of the
project build.

* Patterns which should be version-controlled and distributed to other
  repositories via clone (i.e., files that all developers will want to ignore)
  should go into a .gitignore file.

<repository-ignore>
3. Patterns read from `$GIT_DIR/info/exclude` file.

* Patterns which are specific to a particular repository but which do not need
  to be shared with other related repositories (e.g., auxiliary files that live
  inside the repository but are specific to one user’s workflow) should go
  into the $GIT_DIR/info/exclude file.

<user-ignore>
4. Patterns read from the file specified by the configuration variable
`core.excludesFile`.

* Patterns which a user wants Git to ignore in all situations (e.g., backup or
  temporary files generated by the user's editor of choice) generally go
  into a file specified by core.excludesFile in the user’s ~/.gitconfig. Its
  default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either
  not set or empty, $HOME/.config/git/ignore is used instead.


The underlying Git plumbing tools, such as git ls-files and git read-tree, read
gitignore patterns specified by command-line options, or from files specified by
command-line options. 

Higher-level Git tools, such as git status and git add, use patterns from the
sources specified above.

note:
http://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
`GIT_DIR` is the location of the .git folder. If this isn't specified, Git walks
up the directory tree until it gets to ~ or /, looking for a .git directory at
every step.


PATTERN FORMAT

    A blank line matches no files, so it can serve as a separator for
    readability.

    A line starting with # serves as a comment. Put a backslash ("\") in front
    of the first hash for patterns that begin with a hash.

    Trailing spaces are ignored unless they are quoted with backslash ("\").

    An optional prefix "!" which `negates` the pattern; any matching file
    excluded by a `previous pattern` will become included again. 
    
    It is not possible to re-include a file if a parent directory of that file
    is excluded. Git doesn’t list excluded directories for performance
    reasons, so any patterns on contained files have no effect, no matter
    where they are defined. Put a backslash ("\") in front of the first "!"
    for patterns that begin with a literal "!", for example,
      "\!important!.txt".

    *ignore-directory*
    If the pattern ends with a slash, it is removed for the purpose of the
    following description, but it would only find a match with a `directory`. In
    other words, foo/ will match a directory foo and paths underneath it, but
    will not match a regular file or a symbolic link foo (this is consistent
        with the way how pathspec works in general in Git).

    If the pattern does not contain a slash /, Git treats it as a `shell glob
    pattern` and checks for a match against the pathname relative to the
    location of the .gitignore file (relative to the toplevel of the work tree
        if not from a .gitignore file).

    Otherwise, Git treats the pattern as a shell glob suitable for consumption
    by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not
    match a / in the pathname. For example, "Documentation/*.html" matches
    "Documentation/git.html" but not "Documentation/ppc/ppc.html" or
    "tools/perf/Documentation/perf.html".

    A leading slash matches the beginning of the pathname. For example, "/*.c"
    matches "cat-file.c" but not "mozilla-sha1/sha1.c".


<ex>
$ cat .gitignore 
cpp/
Downloads/
.*
# ignore all files under the build/ directory. also matches x/x/x/build/x/x
build/


<ex>
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    #       Documentation/gitignore.html
    #       file.o
    #       lib.a
    #       src/internal.o
    [...]
    $ cat .git/info/exclude
    # ignore objects and archives, anywhere in the tree.
    *.[oa]
    $ cat Documentation/.gitignore
    # ignore generated html files,
    *.html
    # except foo.html which is maintained by hand
    !foo.html
    $ git status
    [...]
    # Untracked files:
    [...]
    #       Documentation/foo.html
    [...]


<ex>
#Ignore everything
*
#Don't ignore directories, so we can recurse into them
!*/
#The following file extensions are allowed in the repo
!*.awk
!*.ac
!*.c
!*.cc
*/*/mock/inc


={============================================================================
*kt_dev_env_0000* git-range

git diff [--options] <commit> [--] [<path>...]

For a more complete list of ways to spell <commit>, see "SPECIFYING REVISIONS"
section in gitrevisions[7]. 

{limit-search} 'useful' to locate related commit
The last really useful option to pass to `git-log` as a filter is a path. If you
specify a 'directory' or 'file', you can `limit` the log output to commits that
introduced a change to those files. This is always the last option and is
generally preceded by double dashes (--) to separate the paths from the options.

# shows commit logs
$ git log -- Polonium/Polonium.GSTNexus

# shows commit logs and changes
$ git log -p -- Polonium/Polonium.GSTNexus


{double-dot} 'exclusion'
This basically asks Git to resolve a range of commits that are `reachable-from`
one commit but aren't reachable from another.

A  B  E  F  <- master
      C  D  <- experiment

$ git log master..experiment        # git log experiment --not master
D
C

Means "all commits reachable by experiment that aren't reachable by master."
Shows what are unique commits to experiment branch.

The opposite shows what experiment do not have

$ git log experiment..master        # git log master --not experiment
F
E

<ex>
Show commits only in local master that are differences between master and
origin/master.

$ git log origin/master..master     # git log master --not origin/master

This notaion is more explanatory but not useful since cannot use 'completion'
feature.

git log master ^origin/master

<ex>
Can show no result depending on direction.

A  B        <- master
      C  D  <- experiment

$ git log master..experiment    # git log master..origin/master
D
C

$ git log experiment..master    # git log origin/master..master 
(no result)


* master 5777bd6 [behind 11] Fix for distcheck target is failing to compile.

$ git log origin/master..master 
(no result)

$ git log master..origin/master 
# shows commits that local master do not have


<ex>
$ git log 4b11ab0..HEAD -- Nickel/Nickel.System.GStreamer/


{multiple-points}
Want to specify 'more' than two branches to indicate your revision. Thus these
three commands are equivalent:

$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA

For instance, if you want to see all commits that are reachable from refA 'or'
refB but not from refC, you can type one of these:

$ git log refA refB ^refC
$ git log refA refB --not refC

This makes for a very powerful revision query system that should help you figure
out what is in branches in question.


{triple-dot} 'aggregation'
The last major `git-range` syntax is the `triple-dot`, which specifies 'all' the
commits that are reachable by 'either' of two references but 'not' by both of
them. Look back at the example above. If you want to see what is in master or
experiment but not any common references, you can run

A  B  E  F  <- master
      C  D  <- experiment

$ git log master...experiment
F
E
D
C

appearing in the traditional commit date 'ordering'.

A common switch to use with the log command in this case is --left-right, which
shows you which side of the range each commit is in. 

$ git log --left-right master...experiment
< F
< E
> D
> C

With these tools, you can much more easily let Git know what commit or commits
you want to inspect.


={============================================================================
*kt_dev_env_0000* git-range-what-introduced

{to-see-what-to-push}
This command shows you any commits in your current branch that aren't in the
master branch on your origin remote. The commits listed by this command are the
commits that will be pushed to the server.

You can also leave off one side of the syntax to have Git assume HEAD. For
example, you can get the same results as in the previous example by typing: 

$ git log origin/master..
$ git log origin/master..HEAD
$ git log origin/[branch]..HEAD


{to-see-what-to-merge}
To see exactly what you'll be introducing if you merge this topic into your
master branch.

$ git log --no-merges master..topic
$ git log topic --not master           # same as above
$ git log -p topic --not master        # patch format


={============================================================================
*kt_dev_env_0000* git-revision

{git-revision}
https://git-scm.com/docs/gitrevisions

<rev>^, e.g. HEAD^, v1.5.1^0

    A suffix ^ to a revision parameter means the first parent of that commit
    object. ^<n> means the <n>th `parent` (i.e. <rev>^ is equivalent to <rev>^1).
    As a special rule, <rev>^0 means the commit itself and is used when <rev> is
    the object name of a tag object that refers to a commit object.


<rev>~<n>, e.g. master~3

    A suffix ~<n> to a `revision-parameter` means the commit object that is the
    <n>th generation `ancestor` of the named commit object, following only the
    first parents. I.e. <rev>~3 is equivalent to <rev>^^^ which is equivalent to
    <rev>^1^1^1. See below for an illustration of the usage of this form.

Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents
of commit node A. Parent commits are ordered left-to-right.

G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     \|/    |
      B     C
       \   /
        \ /
         A

A =      = A^0
B = A^   = A^1     = A~1
C = A^2  = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2


From the GITR 7 Git Tools, Ancestry Reference.

The other main way to specify a commit is via its ancestry. If you place a ^ at
the end of a reference, Git resolves it to mean the parent of 'that' commit. 

$ git show HEAD^        // == HEAD~ ,

This means the parent of HEAD so the previous commit.
$ git show HEAD^2       // not the second from the HEAD but the 'second' parent


={============================================================================
*kt_dev_env_git_000* git-log

Shows the commit logs.

git log [<options>] [<revision range>] [[\--] <path>...]

With no arguments, git log lists the commits made in that repository in reverse
chronological order. This is from the most recent commits.


<default>
When 'no' revision range is specified, it 'defaults' to HEAD. i.e. the whole
history leading to the current commit and current branch.


<patch-format-and-specify-limit>
You can also use -2, which limits the output to only the last two entries. note:
last two means the latest two commits.

$ git log -2
$ git log -p -2

-p
-u
--patch
    Generate patch (see section on generating patches).


<stat> 'useful'
`--stat` option prints below each commit entry a list of modified files, how many
files were changed, and how many lines in those files were added and removed. It
also puts a summary of the information at the end.

$ git log --stat
commit 4092efb248db69311cc6efd65985818a2150c688
Author: kit <tegipark@gmail.com>
Date:   Fri Feb 6 00:50:05 2015 +0000

    2015.02.06 fh

 kt_dev_01.txt |  148 ++++++++-------------------------------------------------
 temp.txt      |  144 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 160 insertions(+), 132 deletions(-)

commit fa2cb0ad40dcc108dfdacdcedf7adc4bc3bfce3b
Author: Kit Park <kit.park@youview.com>
Date:   Thu Feb 5 17:15:32 2015 +0000

    2015.02.05 fo
...

<pretty>
$ git log --pretty=oneline

$ git log --pretty=format:"%h - %an, %ar : %s" --graph
$ git log --pretty=format:"%h - %an, %ar : %s" 
4092efb - kit, 2 days ago : 2015.02.06 fh
fa2cb0a - Kit Park, 2 days ago : 2015.02.05 fo
...

<graph>
Shows the same as qgit

// --oneline
//    This is a shorthand for "--pretty=oneline --abbrev-commit" used together.
//
// --all
//    Pretend as if all the refs in refs/ are listed on the command line as
//    <commit>.

git log --graph --oneline --all
git log --oneline --all

<decorate>
To see where the branch pointers are pointing:
$ git log --oneline --decorate


note: can use git-alias and see git-alias for more

git config --global alias.last 'log -1 HEAD'
// git config --global alias.ll 'log --oneline --decorate --graph'
git config --global alias.ll "log --decorate --graph --pretty=format:'%C(auto)%h%Creset :%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"


<ex>
If you want to see which commits modifying test files in the Git source code
history were committed by Junio Hamano and were not merges in the month of
October 2008, you can run something like this: "t/" is directory

$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
--before="2008-11-01" --no-merges -- t/


<use-author>
--author option allows you to filter on a specific author

git log --author='Kit Park'
git log -p --author='Kit Park'


<use-time>
The time-limiting options such as --since and --until are very useful. 

$ git log --since=2.weeks


<author-and-commit-date>
The git log shows the author date but not the date when the commit was made.

commit 2005aa038a516d963023e4a572ec0d0d63045142
Author: Darren Garvey <darren.garvey@youview.com>
Date:   Mon Feb 16 13:03:18 2015 +0000

Use --pretty option to see all.

git log --pretty=fuller Polonium/Polonium.GSTNexus/src/gstnexussink.c

--pretty[=<format>]
--format=<format>

    Pretty-print the contents of the commit logs in a given format, where
    <format> can be one of oneline, short, medium, full, fuller, email, raw,
    format:<string> and tformat:<string>. When <format> is none of the above,
    and has %placeholder in it, it acts as if --pretty=tformat:<format> were
    given.

    See the "PRETTY FORMATS" section for some additional details for each
    format. When =<format> part is omitted, it defaults to medium.

    Note: you can specify the default pretty format in the repository
    configuration (see git-config[1]).

commit 2005aa038a516d963023e4a572ec0d0d63045142
Author:     Darren Garvey <darren.garvey@youview.com>
AuthorDate: Mon Feb 16 13:03:18 2015 +0000
Commit:     Darren Garvey <darren.garvey@youview.com>
CommitDate: Wed Sep 9 19:42:30 2015 +0100


{log-on-multiple-branches}
git log <branch1> <branch2> <branch3>


={============================================================================
*kt_dev_env_0000* git-log-grep

{git-log-grep}
Search a pattern in `commit-messages` which is different from `git-grep` since
git-grep search through `commit-contents` but not message.

$ git log --grep PATTERN

Shows a diff as well.

// -p
// -u
// --patch
//    Generate patch (see section on generating patches).

$ git log -p --grep PATTERN


<all-match>
http://gitster.livejournal.com/30195.html

12:41 pm - Fun with "git log --grep"

Earlier I showed a somewhat advanced feature of "git grep" command, and hinted
that a limited subset of the feature is available also in "git log" to look for
commits that have specified strings in their commit log messages.

This entry is the promised follow-up.

First, we learn the very basic form:

    git log --grep=frotz --grep=nitfol --since=1.month

This finds the commits that happened within the last month and mentioned either
frotz 'or' nitfol in their commit log messages. As with the "git grep", giving
more than one patterns means "this or that".

Two options, "--author=name" and "--committer=name" are also supported
internally with the same "grep" mechanism. You can ask:

    git log --grep=frotz --author=Linus

to find changes written by Linus or mentioned frotz (the use of or semantics
    here often feels unintuitive and less useful, but we will come to that
    shortly).

The following attempt to overcome this does `not-work` as you expect, for two
reasons:

    git log --grep=frotz --and --author=Linus

One is simply because "git log" family does not support the --and option.

But a more fundamental reason why this does not work is because "grep" is
`line-oriented`. 

// "git grep -e frotz --and -e nitfol" looks for lines that have both frotz and
// nitfol, but obviously the line that records Linus's name does not have the word
// frotz; the above will never match.
// 
// That is partly the reason why "git log" family does not support --and option to
// begin with. The and semantics is not very useful in the context of "git log"
// command, and this is true even if we limit the discussion to the message part.
// 
// For example, even if we had --and option to "git log" family, this command line:
// 
//     git log --grep=frotz --and --grep=nitfol
// 
// will not find a commit if its log message has a line break in the sentence "This
// commit fixes the frotz feature and adds support for the nitfol feature"
// somewhere between the two words you are looking for.
// 
// Does that mean the "grep" feature in "git log" family can practically only find
// one item at a time and not very useful?

Not really. I did not explain "git grep --all-match" in the earlier entry, but
it is exactly what we want to use here, so we digress a bit.

We learned that this finds files with a line that has both frotz and nitfol:

    git grep -l -e frotz --and -e nitfol

But often you would want to see a file that has both frotz and nitfol, not
necessarily on the same line but anywhere in the same file. The above is not
what you want to use for that purpose.

There is an aspect of "grep" that cares only about the existence of matches with
the pattern in a 'file' (this is true not just with "git grep" but also is true
    with the regular "grep"). 

The exit status of the command is zero (success) if there is a match, and the -l
option shows the names of the files that have matches, but it does not actually
show the lines that matched. "git grep" extends this concept.

"git grep" allows you to say "I am looking for this or that patterns, but please
consider a file successfully matches with them only if you found matches with
all of the patterns", with the --all-match option (the regular "grep" does not
let you do this).  

Using this mechanism:

    git grep -l --all-match -e frotz -e nitfol

will give the names of the files that have both frotz and nitfol somewhere in
them. The matches do not have to be on the same line; they can be anywhere in
the same file.

The way "git log" family uses the grep mechanism is exactly for this "does the
whole thing has a match?" aspect , not "show me the lines that match these
criteria" aspect.  It allows you to use this mechanism like so:

    git log --all-match --grep=frotz --author=Linus

This will show commits that mention frotz and written by Linus.

note:
       --all-match
           Limit the commits output to ones that match all given --grep, instead
           of ones that match at least one.

$ git log --all-match --grep hlsdemux: --grep duration


={============================================================================
*kt_dev_env_0000* git-log-order

Commit Ordering

`By default`, the commits are shown in `reverse chronological order`

--date-order

    Show no parents before all of its children are shown, but otherwise show
    commits in the `commit timestamp order`

--reverse

    Output the commits in reverse order. Cannot be combined with
    --walk-reflogs.


<to-see-from-the-first-commits-to-apply>

$ git log origin/master..HEAD

So the default order is from the latest

$ git ll origin/master..HEAD
* f59ae87 (HEAD) DEVARCH-10916: OEM.Huawei.Scripts:         // top. latest
* f8d148e DEVARCH-10915: 
* 23df05c DEVARCH-10914: 
* 31febb4 DEVARCH-10913: 
* bf57e10 DEVARCH-10912: 
* 7414a2c DEVARCH-10911: 
* efabb14 DEVARCH-10910: 

However, would like to see from the point where commits starts to apply. replay.

$ git log --reverse origin/master..HEAD

note:
This works for git-show as well.

<case>
when use "git log --oneline --decorate" and shows `84f44d1` comes after
`c29cad4` However, `84f44d1` was made before bringing `c29cad4` in and
difference between HEAD and remote origin, gitk, and "git ll" shows the right
order. Confusing?

54dba33 (HEAD)
fb7c4ce (tag: DMS_BSKYB_HR015/D91.0.2, origin/DMS_BSKYB_HR015) 
751b91a (tag: DMS_BSKYB_HR015_FST/D91.0.1.1) CSCuz85222 VRM Component Test fix
84f44d1 (tag: B)
c29cad4 CSCva98193 - [MID-6902] R11 - Stress - R014.083.57.00 - PB.07(R11_89x)


log --decorate --graph

54dba33 : 
fb7c4ce : 
751b91a : 
c29cad4 : 
84f44d1 : 


--graph

    Draw a text-based graphical representation of the commit history on the
    left hand side of the output. This may cause extra lines to be printed in
    between commits, in order for the graph history to be drawn properly.
    Cannot be combined with --no-walk.

    This enables parent rewriting, see History Simplification below.

    This implies the `--topo-order option by default`, but the --date-order
    option may also be specified.


--topo-order

    Show no parents before all of its children are shown, and avoid showing
    commits on multiple lines of history intermixed.

    For example, in a commit history like this:

        ---1----2----4----7
    	\	       \
    	 3----5----6----8---

    where the numbers denote the order of commit timestamps, git rev-list and
    friends with --date-order show the commits in the timestamp order: 8 7 6 5
    4 3 2 1.

    With --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1);
    `some older commits are shown before newer ones` in order to avoid showing the
    commits from two parallel development track mixed together.


={============================================================================
*kt_dev_env_0000* git-log-no-pager

$ git --no-pager show --reverse origin/master..HEAD > out.txt

note:
The "--no-pager" is option for git but not "show" command.

$ git help
usage: git [--version] [--help] [-C <path>] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]


={============================================================================
*kt_dev_env_0000* git-reflog-recover

{recover-lost-stash}
Recover dropped stash in git

http://stackoverflow.com/questions/89332/recover-dropped-stash-in-git

If you have only just popped it and the terminal is still open, you will still
have the hash value printed by git stash pop on screen (thanks, Dolda).

Otherwise, you can find it using this:

git fsck --no-reflog | awk '/dangling commit/ {print $3}'

This will show you all the commits at the tips of your commit graph which are no
longer referenced from any branch or tag - every lost commit, including every
stash commit you've ever created, will be somewhere in that graph.

The easiest way to find the stash commit you want is probably to pass that list
to gitk:

gitk --all $( git fsck --no-reflog | awk '/dangling commit/ {print $3}' )

This will launch a repository browser showing you 'every' single commit in the
repository ever, regardless of whether it is reachable or not.

You can replace gitk there with something like git log --graph --oneline
--decorate if you prefer a nice graph on the console over a separate GUI app.

To spot stash commits, look for commit messages of this form:

WIP on somebranch: commithash Some old commit message

Once you know the hash of the commit you want, you can apply it as a stash:

git stash apply $stash_hash

Or you can use the context menu in gitk to create branches for any unreachable
commits you are interested in. After that, you can do whatever you want with
them with all the normal tools. When you're done, just blow those branches away 


{restore-last-commit}
http://gitready.com/advanced/2009/01/17/restoring-lost-commits.html

So you just did a git reset --hard HEAD^ and threw out your last commit and it
turns out you really did need those changes. Don't fear, git should still have
your commit. When you do a reset, the commit you threw out goes to a
`dangling-state`. It's still in git's datastore, waiting for the next garbage
collection to clean it up. So unless you've ran a git gc since you tossed it,
           you should be in the clear to restore it.

For these examples, I'm working with the code for this blog. From the top, we
just ran:

$ git show-ref -h HEAD
  7c61179cbe51c050c5520b4399f7b14eec943754 HEAD

note: the below is real output when run tha above.

$ git show-ref --head HEAD
53c849344458f858c75cd50ab924d61b867822fd HEAD
e3abcd196ed42eef28831c70c099a76ee0c273be refs/remotes/origin/HEAD

$ git reset --hard HEAD^
  HEAD is now at 39ba87b Fixing about and submit pages so they don't look stupid

$ git show-ref -h HEAD
  39ba87bf28b5bb223feffafb59638f6f46908cac HEAD

So our HEAD has been backed up by one commit. At this point if we wanted it back
we could just git pull, but we're assuming that only our local repository knows
about the commit. We need the SHA1 of the commit so we can bring it back. We can
prove that git 'knows' about the commit still with the fsck command:

$ git fsck --lost-found
  [... some blobs omitted ...]
  dangling commit 7c61179cbe51c050c5520b4399f7b14eec943754

note: the output of fsck

$ git fsck --lost-found                                              
Checking object directories: 100% (256/256), done.
Checking objects: 100% (278686/278686), done.
dangling blob 198960a3967375f15dde3e6912b5709df742e6ea
dangling commit e8e7005ed7f57c5a6c55427b1ec60f37e837f1a2
dangling commit 07265101674f742917e0c6a10e7d78fbf91b6889
dangling commit c8725150f8df2b3755aff66f2fc5489d84cb0d7a
dangling blob b1832250dc825697aab015fb3876a951cc098125
dangling commit 95a2029cca8c0d6445704c4144996ab3ecb8334a
dangling commit 6abd32af822769d7f5ba8a2c2dd2981a7054c57e
dangling commit 17109366374de1591f663ff5e206dc9f03f63230
dangling commit 9e5c93cb6b02beb16700cc3d36c8c026b4631972
dangling commit 8e5fc3451a2778aad439266b290885611ccf995e
dangling commit 686983d96f27cb54067e0cd87c38b20e49d8603e
...

You can also see the that git knows about the commit still by using the reflog
command:

$ git reflog
  39ba87b... HEAD@{0}: HEAD~1: updating HEAD
  7c61179... HEAD@{1}: pull origin master: Fast forward
  [... lots of other refs ...]

So, we now have our SHA1: 7c61179. If we want to get immediately apply it back
'onto' our current branch, doing a git merge will recover the commit:

$ git merge 7c61179
  Updating 39ba87b..7c61179
  Fast forward
    css/screen.css |    4 ++++
    submit.html    |    4 ++--
    2 files changed, 6 insertions(+), 2 deletions(-)

note: can use cherry-pick than merge

This command will bring your lost changes back and make sure that HEAD is
pointing at the commit.

From here you can continue to work as normal! You could also checkout the SHA1
'into' a new branch, but really a merge is the fastest and easiest way to
restore that lost commit once you have the hash. If you have other ways let us
know in the comments!

If you want some more options on what to do in this situation, Mathieu Martin's
illustrated guide to recovering lost commits with Git has plenty for you.

http://www.programblings.com/2008/06/07/the-illustrated-guide-to-recovering-lost-commits-with-git/


={============================================================================
*kt_dev_env_0000* git-reflog-list

https://gist.github.com/matthewmccullough/988077

# Put this in your .gitconfig file under the alias section
orphank = !gitk --all `git reflog | cut -c1-7`&
# Then run it by typing 'git orphank' on the command line.

# A text version of the same is
orphanl = !git log --pretty=oneline --abbrev-commit --graph --decorate `git reflog | cut -c1-7`

To prevent unambiguous SHA1 IDs, suggest using cut -d " " -f 1.
note: why? 
git reflog will write as many characters as necessary to the SHA1 ID to be unambiguous

orphanl command should be:
orphanl = !git log --pretty=oneline --abbrev-commit --graph --decorate `git reflog | cut -d " " -f 1`


={============================================================================
*kt_dev_env_0000* git-pickaxe

{git-pickaxe}
It's also possible to search for commits that introduce or remove a
`particular-line` of source code. This is called a pickaxe, and it takes the
form of -S"<string>". 

If you want to search using a regular expression instead of a string, you can
use the -G"<regex>" flag instead.

This is a very powerful debugging tool, as it lets you `locate` all of the
`commits` that affect a particular line of code. It can even show you when a
line was copied or moved to another file.


-S<string>

    Look for differences that change the number of occurrences of the specified
    string (i.e. addition/deletion) in a 'file'. Intended for the scripter’s
    use.

    It is useful when you're looking for an exact block of code (like a struct),
    and want to know the history of that block since it 'first' came into being:
    use the feature iteratively to feed the interesting block in the preimage
    back into -S, and keep going until you get the very first version of the
    block.  
    
-G<regex>

    Look for differences whose patch text contains added/removed lines that
    match <regex>.

    To illustrate the difference between -S<regex> --pickaxe-regex and
    -G<regex>, consider a commit with the following diff in the same file:

    +    return !regexec(regexp, two->ptr, 1, &regmatch, 0);
    ...
    -    hit = !regexec(regexp, mf2.ptr, 1, &regmatch, 0);

    While git log -G"regexec\(regexp" will show this commit, git log
    -S"regexec\(regexp" --pickaxe-regex will not (because the number of
          occurrences of that string did not change).

    See the pickaxe entry in gitdiffcore[7] for more information.


<ex> see difference with `git-grep`

$ git grep pes_stream_get_duration
src/concurrent_pes_writer.c:    chunk->duration = pes_stream_get_duration(data);
src/pes.c:GstClockTime pes_stream_get_duration(PesStream *stream)
src/pes.h:GstClockTime pes_stream_get_duration(PesStream* stream);

$ git log -S pes_stream_get_duration
commit 23b5d6607917a3fb8613cf31f37b234767b9c3e0
Author: xxx 
Date:   Tue Apr 21 10:36:25 2015 +0100

    Even though STB hardware supports several playpumps (see DEVARCH-8872),
    OEMs only make one playpump available to YouView. If we write each
    elementary stream into its own playpump, by the time we need to support
    audio description with DASH playback, we would need a total of 3
    playpumps. Therefore we implemented software-based multiplexing of
    multiple elementary streams to a single playpump.
    

The -S option which takes a string and only shows the 'commits' that introduced
a change to the code that added or removed that string. For instance, if you
wanted to find the last commit that added or removed a reference to a specific
function, you could call:

$ git log -S function_name
$ git log -p -S function_name


<ex>
http://www.philandstuff.com/2014/02/09/git-pickaxe.html

The git pickaxe

Posted on 09 February 2014

I care a lot about commit messages. I try to write them following Tim Pope's
example, using a short summary line, followed by one or more paragraphs of
explanation. It's not unusual for my commit message to be longer than the diff.
Why do I do this? Is it just some form of OCD? After all, who really reads
commit messages?

The reason I care about commit messages is because I'm an avid user of the git
pickaxe. If I'm ever confused about a line of code, and I want to know what was
going through the mind of the developer when they were writing it, the pickaxe
is the first tool I'll reach for. For example, let's say I was looking at this
line from our puppet-graphite module:

    exec <%= @root_dir %>/bin/carbon-cache.py --debug start

That --debug option looks suspect. I might think to myself: "Why are we running
carbon-cache in --debug mode? Isn't that wasteful? Do we capture the output? Why
was it added in the first place?" 

In order to answer these questions, I'd like to find the commit that 'added' the
switch. I could run git blame on the file, to find the `last-commit` that
`touched-the-line`. However that leads to a totally unrelated commit that had
nothing to do with my --debug flag issue.

note: this is difference between "git blane" and "git pickaxe"

So I still want to find the commit that added that --debug switch, but git blame
has got me nowhere. What next? It turns out there's an option to git log which
will find any commit which 'introduces' or 'removes' a string from `anywhere` in
its commit:

    git log -p -S --debug

This will show me every commit that either introduced or removed the string
--debug. (It's a slightly confusing example, because --debug is not being used
    as a command-line switch to git, but as a string argument to the -S switch
    instead. Nevertheless, git does the right thing.) The -p switch shows the
commit diff as well. There are in fact a few matches for this search, but the
third commit that comes up is the winner:

commit 5288d5804a3fc20dae4f3b2deeaa7f687595aff1
Author: Philip Potter <philip.g.potter@gmail.com>
Date:   Tue Dec 17 09:33:59 2013 +0000

    Re-add --debug option (reverts #11)

    The --debug option is somewhat badly named -- it *both* adds debug
    output, *and* causes carbon-cache to run in the foreground. Removing the
    option in #11 caused the upstart script to lose track of the process as
    carbon-cache started unexpectedly daemonizing.

    Ideally we want to have a way of running through upstart without the
    debug output, but this will fix the immediate problem.

diff --git a/templates/upstart/carbon-cache.conf b/templates/upstart/carbon-cache.conf
old mode 100644
new mode 100755
index 43a16ee..2322b2d
--- a/templates/upstart/carbon-cache.conf
+++ b/templates/upstart/carbon-cache.conf
@@ -12,4 +12,4 @@ pre-start exec rm -f '<%= @root_dir %>'/storage/carbon-cache.pid
 chdir '<%= @root_dir %>'
 env GRAPHITE_STORAGE_DIR='<%= @root_dir %>/storage'
 env GRAPHITE_CONF_DIR='<%= @root_dir %>/conf'
-exec python '<%= @root_dir %>/bin/carbon-cache.py' start
+exec python '<%= @root_dir %>/bin/carbon-cache.py' --debug start

note:
The another point is here that although can find a commit which added that
string, think about using commit log as a way to have full comment than comment
in a code.

Now I know exactly why --debug is there, and I know that I certainly don't want
to remove it. But what if my commit message had just been "Re-add --debug
option"? I'd be none the wiser. This is why I care so much about commit
messages: because I have the tools to quickly get from a piece of code to the
commit that introduced it, I spend much more time reading commit messages.

This example is also interesting because it raises another question: should this
explanation have been in a code comment instead? The --debug flag is inherently
confusing, and a comment could have answered my questions even quicker by being
right there in the file.

However, a 6-line comment in the file would be quite a bit of noise whenever you
weren't interested in the --debug switch, whereas a commit message can be as big
as it needs to be to make the explanation clear. Comments and commit messages
can be complementary: there could be a one-line comment saying that --debug
causes carbon-cache to stay in the foreground, and a more detailed explanation
in the commit message. In some ways I see commit messages as a type of expanded
commenting system which is available at your fingertips whenever you need it but
automatically hides when you just want to read the code.


={============================================================================
*kt_dev_env_0000* git-commit-message

Care when write commit message. If there is no line to separate the title from
commit message then git log shows the long title in the output.

01: DEVARCH-10941: Fix CANTST-17858: the spinner shown before 
02:    
03: Trials reported the issue that playing content in iPlayer shows the


={============================================================================
*kt_dev_env_0000* git-grep

To search through any `files` in `committed-tree` or the `working-directory` for
a string or 'regular' expression.

git grep ...
  [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <tree> ]
  [--] [<pathspec>...]

Advantages over normal searching commands like grep and ack. 

* It's really fast. 

* You can search through any tree in Git, not just the working directory. As we
  saw in the above example, we looked for terms in an older version of the Git
  source code, not the version that was currently checked out.  

By default, it will look through `the-files` in your working directory. You can
pass -n to print out the line numbers

$ git grep -n gmtime_r


<configs>
// Allow extended regular expressions
git config --global grep.extendRegexp true

// Always include line numbers
git config --global grep.lineNumber true

// [grep]
//  extendRegexp = true
//  lineNumber = true

// Group output like ack!
git config --global alias.g "grep --break --heading --line-number"

// [alias]
//  g = grep --break --heading --line-number


{search-branch}
git grep xxx <branch>

<tree>...
    Instead of searching tracked files in the working tree, search blobs in the
    given trees.

git grep -e <regexp> my_other_branch -- '*.js'


{show-function}
To see what method or function it thinks it has found a match in, you can pass
-p:

-p
--show-function

    Show the preceding line that 'contains' the function name of the match,
    unless the matching line is a function name itself. The name is determined
    in the same way as git diff works out patch hunk headers (see Defining a
        custom hunk-header in gitattributes[5]).

$ git grep -p gmtime_r *.c

date.c=static int match_multi_number(unsigned long num, const char *date, 
date.c: if (gmtime_r(&now, &now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *tm_
date.c: if (gmtime_r(&time, tm)) {

So here we can see that gmtime_r is called in the match_multi_number and
match_digit functions in the date.c file.


{complex-matches}
Look for complex combinations of strings with the `--and` flag. Use the
`--break` and `--heading` options which help split up the output into a more
readable format.

--break
    Print an empty line between matches from different files.

--heading
    Show the filename above the matches in that file instead of at the start of
    each shown line.

-e
    The next parameter is the pattern. This option has to be used for patterns
    starting with - and should be used in scripts passing user input to grep.
    Multiple patterns are combined by or.

-n
--line-number
    Prefix the line number to matching lines

$ git grep --break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0

$ git grep --break --heading \
-n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u<<20)

v1.8.0:cache.h
73:#define S_IFGITLINK 0160000
74:#define S_ISGITLINK(m) (((m) & S_IFMT) == S_IFGITLINK)

v1.8.0:strbuf.c
326:#define STRBUF_MAXLINK (2*PATH_MAX)


={============================================================================
*kt_dev_env_0000* git-grep-all-branches

{search-all}
That searches through all the commits, which should include all the branches.

git grep <regexp> $(git rev-list --all)

Note: chernjie suggested that git rev-list --all is an overkill.

A more refined command can be:

git branch -a | tr -d \* | xargs git grep <regexp>

Which will allow you to search only branches (including remote branches)


={============================================================================
*kt_dev_env_0000* git-grep-fun

http://gitster.livejournal.com/27674.html


={============================================================================
*kt_dev_env_0000* git-completion

https://git-scm.com/book/en/v1/Git-Basics-Tips-and-Tricks

Auto-Completion

If you use the Bash shell, Git comes with a nice auto-completion script you
can enable. Download it directly from the Git source code at
https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
. Copy this file to your home directory, and add this to your .bashrc file:

source ~/git-completion.bash

$ git co<tab><tab>


={============================================================================
*kt_dev_env_0000* git-branch

{branch-is-special}
Why is it so special? The way Git branches is incredibly lightweight, making
branching operations nearly instantaneous and switching back and forth between
branches generally just as fast. 

As you may remember from Chapter 1, Git doesn't store data as a series of
changesets or deltas, but instead as a series of snapshots.


{difference-to-other-vcs}

--------------------- time ----------------------------------------->

commit A      <------   commit B                  <-------   commit C
 (ptr to snapshot)       (ptr to the prev commit)
                         (ptr to snapshot)

 (snapshot A)            (snapshot B)                         (snapshot C)


{default-branch} master-branch
A branch in Git is simply a lightweight `movable-pointer` to one of these
commits. The default branch name in Git is 'master'. As you initially make
commits, you're given a master branch that points to the last commit you made.
Every time you commit, it moves forward automatically.

                                                  <master>
commit a      <------   commit b       <-------   commit c


{create-new-branch}
What happens if you create a new branch? Well, doing so creates a new pointer
for you to move around.

$ git branch testing
                                                   <HEAD>
                                                  <master>
commit a      <------   commit b       <-------   commit c
                                                  <testing>

To see where the branch pointers are pointing:

$ git log --oneline --decorate


{branch-and-head}
We will sometimes represent Git history using diagrams like the one below.
Commits are shown as "o", and the links between them with lines drawn with - /
and \. Time goes left to right:

         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B

If we need to talk about a particular commit, the character "o" may be
replaced with another letter or number.

We will use the word `branch` to mean a `line-of-development`, and `branch-head`
(or `HEAD`) to mean a reference to the most 'recent' commit on a branch. In
the example above, the branch head named "A" is a pointer to one particular
commit, but we refer to the line of three commits leading up to that point as
all being part of "branch A".

A branch is nothing more than a `named-reference` to a commit.

How does Git know what branch you're currently on? It keeps a special pointer
called 'HEAD'. Cannot have the same branch name in the same repository.


{switch-branch} checkout
To switch to an existing branch, you run the `git-checkout` command. This moves
HEAD to point to the testing branch.

$ git checkout testing

To 'make' a branch and to 'switch' to it in a single shot.

$ git checkout -b testing

                                                  <master>
commit a      <------   commit b       <-------   commit c
                                                  <testing>
                                                   <head>

Make a commit and see what happens:

                                                  <master>
commit a      <------   commit b       <-------   commit c    <------  commit d
                                                                       <testing>
                                                                        <head>
Switch back to master:

$ git checkout master

                                                   <head>
                                                  <master>
commit a      <------   commit b       <-------   commit c    <------  commit d
                                                                       <testing>

`git-checkout` means:

Move `HEAD` back to point to master branch in which populates `index` and
`working-directory` with the `snapshot` of master branch.


Make a commit and see what happens:
                                                                       <head>
                                                                       <master>
commit a      <------   commit b       <-------   commit c    <------  commit e
                                                              <------  commit d
                                                                       <testing>

Now your project history has diverged. two lines of development 


{errors-when-switch-branches} error when checkout
When switching beteen branches 'without' staging and committing, git emits
errors:

$ git checkout undo 
error: Your local changes to the following files would be overwritten by checkout:
	readme
Please, commit your changes or stash them before you can switch branches.
Aborting

Why? because the tracked file is modified and will be overwitten and lost what
has been done if not commited.

note: 
The untracked file 'remains' but the index and working tree will be updated. so
should commit if want to keep changes. If that file exist only for a certain
branch, this will disapper in switching to.

-f
--force
When switching branches, proceed even if the index or the working tree differs
from HEAD. This is used to throw away local changes.

// Q?
// When checking out paths from the index, do not fail upon unmerged entries;
// instead, unmerged entries are ignored.


{branch-is-cheap}
Because a branch in Git is in actuality a simple file that contains the 40
character SHA-1 checksum of the commit it points to, branches are cheap to
create and destroy. Creating a new branch is as quick and simple as writing 41
bytes to a file (40 characters and a newline).


{brancn-vs-tag}
A tag represents a version of a particular branch at a moment in time. A
branch represents a separate thread of development that may run concurrently
with other development efforts on the same code base. Changes to a branch may
eventually be merged back into another branch to unify them.

The tag is very much like a branch that doesn't change - it's just a pointer
to a specific commit. 


={============================================================================
*kt_dev_env_0000* git-branch-rename git-branch-delete git-branch-reset

{branch-rename}
git branch -m newname            # when want to rename current branch you are on
git branch -m oldname newname    


{branch-delete}
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).

<delete-remote-branch>
You can delete a remote branch using the --delete option to git push. If you
want to delete your serverfix branch from the 'server', you run the following:

$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
- [deleted] serverfix

Basically all this does is remove the pointer from the server. The Git server
will generally keep the data there for a while until a garbage collection
runs, so if it was accidentally deleted, it's often easy to recover.

$ git branch -a
  remotes/origin/propose/huawei

$ git push origin --delete propose/huawei

Or can use this form to delete a remote branch:

$ git push origin :review/DEVARCH-10262


{branch-reset}

(topic) ~/source/DEVARCH$ git ll -5 topic kit/fix-zinc-common-remove-sqlite 
* efa10d6 (topic) DEVARCH-10610: ...
| * bd8e4b9 (kit/fix-zinc-common-remove-sqlite) DASH: ...
|/  
* fabf2f2 (origin/master, master) DEVARCH-10605: 
* f7f82a5 DEVARCH-10547: Stuck at 

(topic) ~/source/DEVARCH$ git branch -f kit/fix-zinc-common-remove-sqlite topic 

(topic) ~/source/DEVARCH$ git ll -5 topic kit/fix-zinc-common-remove-sqlite 
* efa10d6 (topic, kit/fix-zinc-common-remove-sqlite) DEVARCH-10610: ...
*

git branch [--set-upstream | --track | --no-track] [-l] 
  [-f] <branchname> [<start-point>]

-f
--force

    Reset <branchname> to <startpoint> if <branchname> exists already. Without
    -f git branch refuses to change an existing branch. In combination with -d
    (or --delete), allow deleting the branch irrespective of its merged status.
    In combination with -m (or --move), allow renaming the branch even if the
    new branch name already exists.


={============================================================================
*kt_dev_env_0000* git-branch-list

{branch-list}
The * indicates `current-branch` that you currently have checked out and HEAD
points to.

$ git branch
  iss53
* master
  testing


<check-merge>
Among all branches, to figure out what branches are merged in your branch or
not, these option is to filter this list to branches that you have or have not
yet merged into the current branch.

With `--merged`, only branches merged into the named commit (i.e. the branches
    whose tip commits are `reachable-from` the named commit) will be listed.

With `--no-merged` only branches not merged into the named commit will be
listed. If the <commit> argument is missing it defaults to HEAD (i.e. the tip of
    the current branch).

$ git branch --merged
  iss53
* master

Branches on this list 'without' the * in front of them are generally fine to
delete because you've 'already' incorporated their work into another branch


$ git branch --no-merged
  testing

This shows your other branch. Because it contains work that isn't merged in
yet, trying to delete it with git branch -d will fail:

$ git branch -d testing
error: The branch 'testing' is not an ancestor of your current HEAD.
If you are sure you want to delete it, run 'git branch -D testing'.


{branch-remote}

--list or no arg

If --list is given, or if there are no non-option arguments, existing branches
are listed; the current branch will be highlighted with an asterisk.

   -r, --remotes
           List or delete (if used with -d) the remote-tracking branches.

   -a, --all
           List both remote-tracking branches and local branches.

$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

$ git branch -r


<v-option>
To see the 'last' commit on each branch

$ git branch -v --color
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes

<vv-option>
List out your local branches with more information including `tracking-branch`
and if your local branch is ahead, behind or both.

$ git branch -vv
iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
master 1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
testing 5ea463a trying something new

So here we can see that our iss53 branch is tracking origin/iss53 and is "ahead"
by two, meaning that we have two commits locally that are not pushed to the
server. 

We can also see that our master branch is tracking origin/ master and is up to
date. 

Next we can see that our serverfix branch is tracking the server-fix-good branch
on our teamone server and is ahead by three and behind by one, meaning that
there is one commit on the server we haven't merged in yet and three commits
locally that we haven't pushed. 

Finally we can see that our testing branch is not tracking any remote branch.


<fetch-all>
To note that ahead/behind numbers from -vv option are numbers since the last
time you fetched from each server. This command does not reach out to the
servers, it's telling you about what it has cached from these servers locally.

If you want totally up to date ahead and behind numbers, you'll need to fetch
from all your remotes right before running this. You could do that like this: 

$ git fetch --all; git branch -vv


={============================================================================
*kt_dev_env_0000* git-branch-ls-remote

<get-branch>
Used to get the list of remote branches without cloning.

The `ls-remote` command returns the SHA1 hash of the latest commit for that
reference, so it is quite easy to parse out and get to the exact commit you
need if you're doing some `scripting`. 

The --heads option lists only branch names since the command can list tags too.

       git-ls-remote - List references in a remote repository

       -h, --heads, -t, `--tags`
           Limit to only refs/heads and refs/tags, respectively. These options
           are not mutually exclusive; when given both, references stored in
           refs/heads and refs/tags are displayed.

       <repository>
           The "remote" repository to query. This parameter can be either a
           URL or the name of a remote (see the GIT URLS and REMOTES sections
           of git-fetch(1)).

$ git ls-remote --heads origin
f7abd1ac44367aff4056b3755e1bdff669aa279b	HEAD
acf12d1ec25a3bf0ed800eda4ad8470d9f4a9f26	refs/heads/14base
5d42e9f6d46160888a5f90729d0bc0285e844d2b	refs/heads/gpi
f7abd1ac44367aff4056b3755e1bdff669aa279b	refs/heads/master


={============================================================================
*kt_dev_env_0000* git-branch-tracking git-checkout

https://git-scm.com/docs/git-checkout

git-checkout - Switch branches or restore working tree files

From git-reset:

Switching branches or cloning goes through a similar process. When you checkout
a branch, it changes HEAD to point to the new branch ref, populates your Index
with the snapshot of that commit, then copies the contents of the Index into
your Working Directory.

note: The "untracked file" remains the same between checkouts

DESCRIPTION

Updates files in the working tree to match the version in the index or the
specified tree. If no paths are given, git checkout will also update HEAD to
set the specified branch as the current branch.


git checkout <branch>

To prepare for working on <branch>, switch to it by updating the index and the
files in the working tree, and by pointing HEAD at the branch. Local
modifications to the files in the working tree are kept, so that they can be
committed to the <branch>.



{tracking-branch}
Checking out a local branch from a remote branch automatically creates what is
called a `tracking-branch` or `upstream-branch`. So Git automatically knows
which server and branch to push to when do git-push or git-pull.

So tracking branch is not special and is a simple branch points to one in
remote. `tracking-branch` is a local branch to track remote branch.

When you clone a repository, it generally automatically creates a
`remote-master` branch that tracks origin/master.

--track

    When creating a new branch, set up "upstream" configuration. See "--track"
    in git-branch[1] for details.

    If no -b option is given, the name of the new branch will be derived from
    the remote-tracking branch, by looking at the local part of the refspec
    configured for the corresponding remote, and then stripping the initial
    part up to the "*". This would tell us to use "hack" as the local branch
    when branching off of "origin/hack" (or "remotes/origin/hack", or even
        "refs/remotes/origin/hack"). If the given name has no slash, or the
    above guessing results in an empty name, the guessing is aborted. You can
    explicitly give a name with -b in such a case.


<check-tracking>

[branch "topic"]
    remote = origin                // this is tracking branch
    merge = refs/heads/master

$ git config branch.topic.remote
origin

$ git branch -vv


<set-tracking>
// note: --track option is 'limited' since not able to choose local branch name
// to track remote.
//
// If you have Git version 1.6.2 or later, you can also use the --track
// shorthand:
// 
// git checkout --track origin/serverfix
// 
// As with example before, branch serverfix set up to track remote branch
// refs/remotes/origin/serverfix and switched to a new branch "serverfix"

git branch --set-upstream-to=origin/BSKYB_HR015_Int <branch>

-u <upstream>
--set-upstream-to=<upstream>
    Set up <branchname>'s tracking information so <upstream> is considered
    <branchname>'s upstream branch. If no <branchname> is specified, then it
    `defaults to the current branch`


{checkout-branch}
This is called "basing off"; starts a new feature branch, basing it off the
server's branch.

git checkout -b|-B <new_branch> [<start point>]

Specifying -b causes a new branch to be created as if git-branch[1] were called
and then checked out. In this case you can use the --track or --no-track
options, which will be passed to git branch. 

As a convenience, --track without -b implies branch creation; see the
description of --track below.

<start_point>
The name of a commit at which to start the new branch; see git-branch[1] for
details. `Defaults to HEAD`

$ git checkout -b tztv_2.2_local origin/tztv_2.2

Branch tztv_2.2_local set up to track remote branch tztv_2.2 from origin.
Switched to a new branch 'tztv_2.2_local'

With this command the local branch "tztv_2.2_local" is set to track the remote
branch "tztv_2.2"


$ git checkout tztv_2.2

Branch tztv_2.2 set up to track remote branch tztv_2.2 from origin. Switched
to a new branch 'tztv_2.2'


<checkout-with-making-local-branch>

If <branch> is `not-found` but there does exist a tracking branch in exactly one
remote (call it <remote>) with a matching name, treat as equivalent to

$ git checkout -b <branch> --track <remote>/<branch>

$ git co review/DEVARCH-8704/0

Branch xxx set up to track remote branch xxx from origin.
Switched to a new branch 'xxx'

This will `create-a-local-branch` "review/DEVARCH-8704/0" from remote, set up a
tracking branch, and switch to it.


<checkout-without-making-local-branch>
When use one other than branch, will make a `detached-HEAD` state. No local
branch made. So can see the changes without making a branch and deleing it
once used.

$ git co origin/review/DEVARCH-8704/0   # see "origin"
$ git co <remote-tag-name>

You are in `detached-HEAD` state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may do so
(now or later) by using -b with the checkout command again. Example:

git checkout -b new_branch_name

HEAD is now at 61b6bd8... DEVARCH-9355: Add yv-wait-for-idle helper tool


={============================================================================
*kt_dev_env_0000* git-branch-topic

Because Git uses a simple three-way merge, merging from one branch into
another multiple times over a long period is generally easy to do. 

master          - possibly only code that has been or will be released. 
develop or next - parellel branch. they work from or use to test stability.
topic           - short-lived. to make sure they pass all the tests and don't
                  introduce bugs.

Easier to think about them as work silos, where sets of commits graduate to a
more stable silo when they're fully tested 


high stable: -> time
 master c1 --------------------------------------------------------->

 develop     c2 c3 c4 c5 ------------------------------------------->

 topic                    c6 c7 ------------------------------------>

low stable

The merging is from topic -> develop -> master.

You can keep doing this for several levels of stability. For large projects.

<topic-branch>
Topic branches, however, are useful in projects of any size. A topic branch is
a short-lived branch that you create and use for a single particular feature
or related work. This is something you've likely never done with a VCS before
because it's generally too expensive to create and merge branches. 

This technique allows you to context-switch quickly and completely.

note:
It's important to remember when you're doing all this that these branches are
completely local. When you're branching and merging, everything is being done
only in your local repository. NO server communication is happening.


={============================================================================
*kt_dev_env_0000* git-branch-check-commit-or-tag

With --contains, shows only the branches that contain the named commit: in other
words, the branches whose tip commits are descendants of the named commit.

--contains [<commit>]
    Only list branches which contain the specified commit (HEAD if not
        specified). Implies --list.


<ex>
# $ git commit -v 96c6af219a3d019c9353db261f8c0ecbb378602c
# error: pathspec '96c6af219a3d019c9353db261f8c0ecbb378602c' \
#     did not match any file(s) known to git.

$ git branch --contains 96c6af219a3d019c9353db261f8c0ecbb378602c
$ (shows nothing)

$ git branch --contains C27.10.2-RC1
* export/PRODUCTION-FR15.0


={============================================================================
*kt_dev_env_git_000* git-merge-conflict

{merge-with-no-diverge} <upstrem>
The workflow is that make a hotfix to fix a issue and once verify it, them merge
it into the master.

           <master>      <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
                        <iss53> branch

Switch to master and merge hotfix to master:

$ git checkout master
$ git merge hotfix              # support auto-completion for branch name
Updating f42c576..3a0874c
Fast forward
 README |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)


The phrase "Fast forward" in that merge. Because the commit pointed to by the
branch(hotfix) you merged in was directly 'upstream' of the commit(master)
you're on, Git 'moves' the pointer forward. <no-diverge>. 

note: This means that simply apply changes up to hotfix and move master to where
hotfix was. Just overwrite with what hotfix has. 'no' conflict and 'no' commit
is created. <Q> applying and overwriting happens really?

note: merge "hotfix" `into` the current branch, master.

So tree becomes:
                        <master>
                        <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
                        <iss53> branch

To switch back to the work you were doing before you were interrupted. However,
   first you'll delete the hotfix branch, because you no longer need it - the
   master branch points at the same place. You can delete it with the -d option
   to git branch:


{merge-with-diverge}
Switch back to your work-in-progress branch on issue #53 and continue working on
it 

$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'

                         <master>
c0 <- c1 <- c2        <- c4
                      <- c3 <- c5
                              <iss53> branch
                              <head>

note: merge can be done in any direction.

It's worth noting here that the work you did in your hotfix branch is not
contained in the files in your iss53 branch. If you need to pull it in, you can
merge your master branch into your iss53 branch by running "git merge master",
      or you can wait to integrate those changes until you decide to pull the
      iss53 branch back into master later.

<merge-into-master>
Suppose you've decided that your issue #53 work is complete and ready to be
merged 'into' your master branch. To merge in iss53 into master

$ git checkout master
$ git merge iss53
Merge made by recursive.
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

This looks a bit different than the hotfix merge because your development
history has diverged from some older point. `diverged` because the commit on the
branch you're on(master) isn't a 'direct' ancestor of the branch you're merging
in(iss53). Git do simple <three-way-merge> using c2, c4, and c5.

            # common   # snapshot to merge into
            # ancestor <head>
                       <master>
c0 <- c1 <- [c2]      <- [c4]
                      <- c3 <- [c5]
                               <iss53> branch
                               # snapshot to merge in

<merge-commit>
Git creates a new snapshot that results from this three-way merge and
automatically creates a `new commit` that points to it. This is referred to as a
`merge-commit` and is special in that it has more than one parent. 

note: this is different from 'fast-forward' move that create no commit.

Git determines the best 'common' ancestor to use for its merge base; this is
different than CVS or Subversion (before version 1.5), where the developer doing
the merge has to figure out the best merge base for themselves. 

                                                <master>
c0 <- c1 <- c2        <- c4                     <- c6
                      <- c3 <- c5                |
                              <iss53> branch    <-

c6 has two ancestor.

$ git branch -d iss53

note: This assumes that there is no conflict between hotfix and iss53 branch.


{merge-conflict}
If you changed the `same-part` of the same file differently in the two branches
you're merging together, Git won't be able to merge them cleanly. If your fix
for issue #53 modified the same part of a file as the hotfix, you'll get a merge
conflict that looks something like this:

                        <master>
                        <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
                        <iss53> branch

$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

Git has paused the process while you resolve the conflict. If you want to see
which files are unmerged at any point after a merge conflict, you can run git
status:

$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   readme

no changes added to commit (use "git add" and/or "git commit -a")
$

<see-merge-conflict>
Git adds standard conflict-resolution `markers` to the files that have
conflicts, so you can 'open' them manually and resolve those conflicts. The
conflicted file contains section like:

note: this is version on master since HEAD and is on master

<div id="footer">contact : email.support@github.com</div>
=======                                                        # }
<div id="footer">                                              # { iss53 version
  please contact us at support@github.com
</div>
>>>>>>> iss53:index.html                                       # }

In order to resolve the conflict, you have to `either-choose` one side or the
other `or-merge` the contents yourself. After you've resolved each of these
sections in each conflicted file, run `git-add` on each file to mark it as
resolved. "Staging the file" marks it as resolved in Git.  


={============================================================================
*kt_dev_env_git_000* git-merge-base

git-merge-base - Find as good common ancestors as possible for a merge

SYNOPSIS

git merge-base [-a|--all] <commit> <commit>...
git merge-base [-a|--all] --octopus <commit>...
git merge-base --is-ancestor <commit> <commit>
git merge-base --independent <commit>...
git merge-base --fork-point <ref> [<commit>]

DESCRIPTION

git merge-base finds best 'common' ancestor(s) between two commits to use in a
three-way merge. One common ancestor is better than another common ancestor if
the latter is an ancestor of the former. A common ancestor that does not have
any better common ancestor is a best common ancestor, i.e. a merge base. Note
that there can be more than one merge base for a pair of commits.


={============================================================================
*kt_dev_env_0000* git-merge-undo

{merge-undo}
When merge conflict happens, git modifies the file so will have modified status.
How can undo this? If you get conflicts, you can immediately get back to the
state you were at before with:

$ git merge undo
Auto-merging readme
CONFLICT (content): Merge conflict in readme
Automatic merge failed; fix conflicts and then commit the result.

~/git-work$ git status
# On branch master
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      readme
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.readme.swp
no changes added to commit (use "git add" and/or "git commit -a")

$ more readme 
1: changed first and changed by master.
2: changed second.
3: added topic first.
4: added topic second.

$ git merge --abort     # for the latest git
$ git reset --merge

$ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.readme.swp
nothing added to commit but untracked files present (use "git add" to track)



={============================================================================
*kt_dev_env_0000* git-merge-mergetool

Instead of editing manually, can use GUI by running mergetool which is set in
config.

$ git config --global merge.tool gvimdiff
$ git config --global merge.tool meld

$ git mergetool

Then will run external merge tool with 'three' panes when merge.conflictstyle
has not been set.

LOCAL: HEAD version   | Merged    | REMOTE: merge-in version.

The file in the 'middle' is a failed merge which shows conflicts. So can select
either head version or merge-in version. Or can write up new one. The mergetool
runs 'mordal' mode and when close it, 'stage' it automatically unlike the merge
case.

Once resolved conflicts, run git status again to verify that all conflicts have
been resolved. Run git commit to 'finalize' the merge commit. Can modify that
message with details about how you resolved the merge 


When mergetool is invoked with this tool (either through the -t or --tool option
    or the merge.tool configuration variable) the configured command line will
be 'invoked' with 

$BASE set to the name of a temporary file containing the common base for the
merge, if available; 

$LOCAL set to the name of a temporary file containing the contents of the file
  on the current branch 

$REMOTE set to the name of a temporary file containing the contents of the file
to be merged
  
$MERGED set to the name of the file to which the merge tool should write the
result of the merge resolution.

If the custom merge tool correctly indicates the success of a merge resolution
with its exit code, then the configuration variable
mergetool.<tool>.trustExitCode can be set to true. Otherwise, git mergetool will
prompt the user to indicate the success of the resolution after the custom tool
has exited.

Setting the `mergetool.keepBackup` configuration variable to false causes git
mergetool to automatically remove the backup as files are successfully merged.

The creation of orig files can be disabled using:
git config --global mergetool.keepBackup false


={============================================================================
*kt_dev_env_git_011* git-merge: mergetool: use meld

http://blog.wuwon.id.au/2010/09/painless-merge-conflict-resolution-in.html

I have found that the tools and interfaces available for performing merges do
not equip programmers sufficiently to do them effectively. The usual merge
strategy of the human at the helm is to use the surrounding context to roughly
guess what the intended program is supposed to look like.

There are four important pieces of information involved in a merge, three of
which are necessary to resolve the merge. In this case, git has only given you
two of the required pieces.

      common base ()

  commit a ()         commit c ()
          1             2
          merge d ()

The git shows 1 (delta from a to d) and 2 (delta from c to d). This tip is to
see deltas from common base as well so that to see better context.

Suppose that mergetool is configured to use meld and when run:

git mergetool

This shows:

+-------------------------+
| LOCAL | base | REMOTE |
+-------------------------+

To see deltas from the base, set up followings which runs three meld instances.

gitmerge $BASE $LOCAL $REMOTE $MERGED
          $1    $2    $3      $4

#!/bin/sh
# gitmerge
#
meld $2 $1 &
sleep 0.5
meld $1 $3 &
sleep 0.5
meld $2 $4 $3

[merge]
    tool = mymeld
[mergetool "mymeld"]
    cmd = $HOME/bin/gitmerge $BASE $LOCAL $REMOTE $MERGED

git config --global merge.tool mymeld
git config --global mergetool.mymeld.cmd 'gitmerge $BASE $LOCAL $REMOTE $MERGED'


={============================================================================
*kt_dev_env_git_011* git-merge: mergetool: local and remote

$ git checkout master
$ git merge topic

LOCAL is master and REMOTE is topic

$ git checkout topic
$ git rebase master

LOCAL is master and REMOTE is topic

note: Why LOCAL is not topic in rebase case? Since rebase checkout to master
internally and LOCAL HEAD is master.

The LOCAL is HEAD and target which want to have as the final result of action.


={============================================================================
*kt_dev_env_git_011* git-merge: mergetool: use gvimdiff

https://github.com/whiteinge/dotfiles/blob/master/bin/diffconflicts

#!/bin/bash
# A better vimdiff mergetool for Git
#
# Git does a great job resolving merge conflicts automatically but there are
# times when human intervention is still needed. Git resolves all the conflicts
# that it is able to and finally wraps each conflict it cannot resolve within
# special markers which must be resolved by a human.
#
# The vertical format and lack of syntax highlighting in the plain conflict
# marker layout makes it difficult to spot subtle conflicts such as
# single-character changes and this is where a two-way diff really shines! To
# see this explained using screenshots, see:
# http://vim.wikia.com/wiki/A_better_Vimdiff_Git_mergetool
#
# This script, when used as a Git mergetool, opens each "side" of the conflict
# markers in a two-way vimdiff window. This combines all the awesome of Git's
# automatic merging savvy with the awesome and simplicity of a simple two-way
# diff.
#
# Add this mergetool to your ~/.gitconfig (you can substitute gvim for vim):
#
# git config --global merge.tool diffconflicts
# # git config --global mergetool.diffconflicts.cmd 'diffconflicts 
#     vim $BASE $LOCAL $REMOTE $MERGED'
# git config --global mergetool.diffconflicts.cmd 'diffconflicts 
#     gvim $BASE $LOCAL $REMOTE $MERGED'
# git config --global mergetool.diffconflicts.trustExitCode true
# git config --global mergetool.diffconflicts.keepBackup false
#
# [merge]
#   tool = diffconflicts
# [mergetool "diffconflicts"]
#   cmd = diffconflicts gvim $BASE $LOCAL $REMOTE $MERGED
#   trustExitCode = true
#   keepBackup = false
#
# The next time you perform a merge with conflicts, invoke this tool with the
# following command. (Of course you can set it as your default mergetool as
# well.)
#
# git mergetool --tool diffconflicts
#
# This tool will open 'three' tabs in Vim that each provide a different way to
# view the conflicts. You can resolve the conflicts in the first tab and save
# and exit the file. This will also mark the conflict as resolved in Git.
#
# <Tab1> is a two-way diff of just the conflicts. Resolve the conflicts here and
# save the file.
# +-----------------+
# | LCONFL | RCONFL |
# +-----------------+
#
# <Tab2> is a three-way diff of the original files and the merge 'base'. This is
# the traditional three-way diff. Although noisy, it is occasionally useful to
# view the three original states of the conflicting file before the merge.
# +-----------------------+
# | LOCAL | BASE | REMOTE |
# +-----------------------+
#
# <Tab3> is the in-progress merge that Git has written to the filesystem
# containing the conflict markers. I.e., the file you would normally edit by
# hand when not using a mergetool.
# +---------------------+
# | <<<<<<< HEAD        |
# | LCONFL              |
# | =======             |
# | RCONFL              |
# | >>>>>>> someref     |
# +---------------------+
#
# Workflow:
#
# 0. Starts with the conflicted file. (Seems when run mergetool, git generates
# LOCAL, BASE, REMOTE files)
#
# curr_time.c
# curr_time.c.BACKUP.5258.c 
# curr_time.c.REMOTE.5258.c
# curr_time.c.BASE.5258.c
# curr_time.c.LOCAL.5258.c
#
# 1. Save your changes to the LCONFL temporary file (the left window on the
# first tab; also the only file that isn't read-only).
#
# 2. The LOCAL, BASE, and REMOTE versions of the file are available in the
# second tabpage if you want to look at them.
#
# 3. When vimdiff exits 'cleanly', the file containing the conflict markers
# will be updated with the contents of your LCONFL file edits.
#
# NOTE: Use :cq to abort the merge and exit Vim with an error code.
# :help *:cq* *:cquit*
#
if [[ -z $@ || $# != "5" ]] ; then
  echo -e "Usage: $0 \$EDITOR \$BASE \$LOCAL \$REMOTE \$MERGED"
  exit 1
fi

cmd=$1
BASE="$2"
LOCAL="$3"
REMOTE="$4"
MERGED="$5"

# *Q* Why do these since would have the same value?
#
printf -v QBASE '%q' "${BASE}"
printf -v QLOCAL '%q' "${LOCAL}"
printf -v QREMOTE '%q' "${REMOTE}"
printf -v QMERGED '%q' "${MERGED}"

# Temporary files for left and right side
LCONFL="${MERGED}.REMOTE.$$.tmp"
RCONFL="${MERGED}.LOCAL.$$.tmp"

#
# $cmd -f -R -d "${fileone}" "${filetwo}" -c ":set noro" 
#
# creates 2way diff window which are all read-only and the left gets active.
# Then set the left writable by running ":set noro".
#
# | fileone, noro | filetwo, ro |
#
#
# Always delete our temp files; Git will handle it's own temp files
trap 'rm -f "'"${LCONFL}"'" "'"${RCONFL}"'"' SIGINT SIGTERM EXIT

# Remove the conflict markers for each 'side' and put each into a temp file
sed -r -e '/^<<<<<<< /,/^=======\r?$/d' -e '/^>>>>>>> /d' "${MERGED}" > "${LCONFL}"
sed -r -e '/^=======\r?$/,/^>>>>>>> /d' -e '/^<<<<<<< /d' "${MERGED}" > "${RCONFL}"

# *Q* Why creates temporary files since LOCAL and REMOTE file do not have
# markers already?
#
# Fire up vimdiff
#
# -d  Start in diff mode,
#
# -R  The 'readonly' option will be set for 'all' the files being edited. You
# can still edit the buffer, but will be prevented from accidentally overwriting
# a file.
#
# -f 'foreground'. If omitted, the GUI forks a new process and exits the current
# one. "-f" should be used when gvim is started by a program that will wait for
# the edit session to finish (e.g., mail or readnews). 
#
# -c {command} {command} will be executed after the first file has been read
# (and after autocommands and modelines for that file have been processed).
# "command" is interpreted as an Ex command.

# :[count]tabe[dit] 
# :[count]tabnew 
# Open a new tab page with an empty window, after the current
#
# :vert[ical] {cmd}
# Execute {cmd}. If it contains a command that splits a window, will be split
# vertically.
#
# :diffs[plit] {filename}
# Open a new window on the file {filename}. The options are set as for "vimdiff"
# for the current and the newly opened window.
#
# :[count]winc[md] {arg}
# Moves to the window below the current one. :wincmd j
#
# :tabfir[st]
# Go to the first tab page.
#
# :set noro
# noreadonly
#
# note:
# This creates:
#
#   -c ":tabe $1" -c ":vert diffs $2" -c ":vert diffs $3"
#
#   | $3 | $2 | $1 |
#
$cmd -f -R -d "${LCONFL}" "${RCONFL}" \
  -c ":set noro" \
  -c ":tabe $QLOCAL" -c ":vert diffs $QBASE" -c ":vert diffs $QREMOTE" \
  -c ":winc t" -c ":tabe $QMERGED" -c ":tabfir"

EC=$?

# Overwrite $MERGED only if vimdiff exits cleanly.
if [[ $EC == "0" ]] ; then
#  cat "${LCONFL}" > "${MERGED}"
  cat "${RCONFL}" > "${MERGED}"
fi

exit $EC


<modified>

+-----------------------+
| LOCAL | REMOTE |
+-----------------------+
+-----------------------+
| LOCAL | BASE | REMOTE |
+-----------------------+
+-----------------------+
| MERGED |
+-----------------------+

#!/bin/bash
#
if [[ -z $@ || $# != "5" ]] ; then
  echo -e "Usage: $0 \$EDITOR \$BASE \$LOCAL \$REMOTE \$MERGED"
  exit 1
fi

cmd=$1
BASE="$2"
LOCAL="$3"
REMOTE="$4"
MERGED="$5"

LCONFL="${LOCAL}"
RCONFL="${REMOTE}"

# Always delete our temp files; Git will handle it's own temp files
trap 'rm -f "'"${LCONFL}"'" "'"${RCONFL}"'"' SIGINT SIGTERM EXIT

# Fire up vimdiff
$cmd -f -R -d "${LCONFL}" "${RCONFL}" \
  -c ":set noro" \
  -c ":tabe $REMOTE" -c ":vert diffs $BASE" -c ":vert diffs $LOCAL" \
  -c ":winc t" -c ":tabe $MERGED" -c ":tabfir"

EC=$?

# Overwrite $MERGED only if vimdiff exits cleanly.
if [[ $EC == "0" ]] ; then
  cat "${LCONFL}" > "${MERGED}"
fi

exit $EC

note:
This makes 4way diff in the first window.

# Fire up vimdiff
$cmd -f -R -d "${LCONFL}" "${RCONFL}" \ -c ":set noro" \
  -c ":tabe $REMOTE" -c ":vert diffs $BASE" -c ":vert diffs $LOCAL" \
  -c ":winc t" -c ":tabe $MERGED" -c ":tabfir"


={============================================================================
*kt_dev_env_0000* git-diff

Show changes between the `working-tree` and `index` or a tree, changes between
the index and a tree, changes between two trees, changes between two blob
objects, or changes between two files on disk.

git diff [--options] [--] [<path>...]


{diff-between-index-and-working}
That command shows diff between the staging area, index, and your working
directory. The result tells you the changes you've made that you haven't 'yet'
staged. 

This form is to view the changes you made relative to the staging area for the
next commit. In other words, the differences are what you could tell Git to
further add to the index but you still haven't. You can stage these changes by
using git-add[1].

$ git diff
diff --git a/sample.c b/sample.c
index bb699af..1ee2e2c 100644
--- a/sample.c
+++ b/sample.c
@@ -74,9 +74,7 @@ outputError(Boolean useErr, int err, Boolean flushStdout,
     fflush(stderr);           /* In case stderr is not line-buffered */
 }
 
-/* Display error message including 'errno' diagnostic, and
-   return to caller */
-
+// Display error message including 'errno' diagnostic, and return to caller
 void
 errMsg(const char *format, ...)
 {
$ 

note:
That means that shows diff as if run the below and 'b' in diff is a destination.

$ git diff `from` `to`
$ git diff                          # = git diff index working-directory


{diff-between-staged-and-head}
See what you've staged that will 'go' into your next commit, you can use git
diff --staged. This command compares your staged changes to your last commit.
That is it shows diff only when 'staged' something:

$ git diff --cached or --staged     # = git diff index HEAD


{diff-between-commit-and-working}

git diff [--options] <commit> [--] [<path>...]

    This form is to view the changes you have in your working tree relative to
    the named <commit>. You can use HEAD to compare it with the latest commit,
    or a `branch` name to compare with the tip of a different branch.

$ git diff commit                   # = git diff commit working
$ git diff HEAD                     # = git diff HEAD working
$ git diff branch                   # = git diff branch working


{diff-between-local-and-remote}
As shown above, `from` and `to` can be used in different order. The both shows
the same result except that +/- sign depending on `to-direction`.

$ git diff topic1 topic2          # shows diff `to` topic2 
diff --git a/curr_time.c b/curr_time.c
index 84f6ddf..6ba7eb9 100644
--- a/curr_time.c
+++ b/curr_time.c
@@ -25,6 +25,9 @@
    date and time as for ctime(3), but without the trailing newline).
    Returns NULL on error. */
 
+// topic2 - A
+// topic2 - B

$ git diff topic2 topic1          # shows diff `to` topic1 
diff --git a/curr_time.c b/curr_time.c
index 6ba7eb9..84f6ddf 100644
--- a/curr_time.c
+++ b/curr_time.c
@@ -25,9 +25,6 @@
    date and time as for ctime(3), but without the trailing newline).
    Returns NULL on error. */
 
-// topic2 - A
-// topic2 - B

Why? "However, "diff" is about comparing two `endpoints`, not ranges"


<dif-filenames>
$ git diff --stat master origin/master


<diff-single-file>
$ git fetch
$ git diff master:kt_dev_01.txt  origin/master:kt_dev_01.txt  
$ git difftool topic:src/nexusMgr.c try-proposal:src/nexusMgr.c


{diff-path-means}
Instead of comparing with the tip of "test" branch, compare with the tip of the
current branch, but 'limit' the comparison to the file "test". The endpoint is
still snapshot.

$ git diff HEAD -- ./test


<word-diff>

$ git diff
diff --git a/curr_time.c b/curr_time.c
index 84f6ddf..3210b3a 100644
--- a/curr_time.c
+++ b/curr_time.c
@@ -40,7 +40,7 @@ currTime(const char *format)
 
     s = strftime(buf, BUF_SIZE, (format != NULL) ? format : "%c", tm);
     /* this is topic branch */
-    printf("time %s from strftime() \n", s );
+    printf("current time %s from strftime() \n", s );
 
     return (s == 0) ? NULL : buf;
 }

$ git diff --word-diff
diff --git a/curr_time.c b/curr_time.c
index 84f6ddf..3210b3a 100644
--- a/curr_time.c
+++ b/curr_time.c
@@ -40,7 +40,7 @@ currTime(const char *format)

    s = strftime(buf, BUF_SIZE, (format != NULL) ? format : "%c", tm);
    /* this is topic branch */
    [-printf("time-]{+printf("current time+} %s from strftime() \n", s );

    return (s == 0) ? NULL : buf;
}


={============================================================================
*kt_dev_env_0000* git-diff-tool

git difftool is a Git command that allows you to compare and edit files between
revisions using common diff tools. git difftool is a `frontend` to git diff and
accepts the same options and arguments. See git-diff[1].

note: make sure to have the latest git to use this option.

-d
--dir-diff

    Copy the modified files to a temporary location and perform a directory diff
    on them. This mode never prompts before launching the diff tool.

git difftool humax..origin/huawei/dn370t
git difftool -d origin/huawei/dn370t         # compare the current to dn370t
git difftool --tool=vimdiff --no-prompt

git config --global diff.tool vimdiff
git config --global difftool.prompt false

If you're just trying these commands out, then the prompt will seem annoying,
but there are cases where you might want to ignore a few files so it can be
  useful.


={============================================================================
*kt_dev_env_0000* git-diff-not-range

git diff [--options] <commit> <commit> [--] [<path>...]

    This is to view the changes between two arbitrary <commit>.

git diff [--options] <commit>..<commit> [--] [<path>...]

    This is `synonymous` to the previous form. If <commit> on one side is
    omitted, it will have the same effect as using `HEAD` instead.

git diff [--options] <commit>...<commit> [--] [<path>...]

    This form is to view the changes on the branch containing and up to the
    second <commit>, starting at a common ancestor of both <commit>. "git diff
    A...B" is equivalent to "git diff $(git-merge-base A B) B". You can omit any
    one of <commit>, which has the same effect as using HEAD instead.

Just in case if you are doing something exotic, it should be noted that all of
the <commit> in the above description, except in the last two forms that use
".." notations, can be any <tree>.

However, "diff" is about comparing two endpoints, not ranges, and the range
notations ("<commit>..<commit>" and "<commit>...<commit>") do `not-mean` a range
as defined in the "SPECIFYING RANGES" section in gitrevisions[7].

<ex>
master
C1    C2    C3    topic1
      C4    C5    topic2

To see what will be introduced when merge topic1:

git log master..topic1        # the same. C3, C2 note: reverse order
git log topic2..topic1        # the same

git merge-base topic1 topic2  # C1

git diff master               # shows C2, C3 since currently on topic1
git diff C1                   # the same

git diff master topic1        # shows C2, C3
git diff master..topic1       # shows C2, C3

git diff topic2..topic1       # shows C2, C3 but shows C4, C5 as deleted

git diff topic2...topic1      # shows C2, C3. WHY? since it is not `range`
git log topic2...topic1       # shows C2, C3, C4, C5


$ git diff topic2...topic1

This command shows you only the work your current topic1 branch has introduced
since its common ancestor, master. That is a very useful syntax to remember.

<ex>
That will produce the diff between the `tips`, `endpoint` of the two branches. 

$ git diff --name-only commit commit
$ git diff commit commit
$ git diff --name-only master branch


={============================================================================
*kt_dev_env_0000* git-diff-format

<default-format>
-p
-u
--patch
    Generate patch (see section on generating patches). This is the `default`.

Generating patches with -p

When "git-diff-index", "git-diff-tree", or "git-diff-files" are run with a -p
option, "git diff" without the --raw option, or "git log" with the "-p" option,
they do not produce the output described above; instead they produce a patch
  file. You can customize the creation of such patches via the GIT_EXTERNAL_DIFF
  and the GIT_DIFF_OPTS environment variables.

What the -p option produces is slightly different from the traditional diff
format:

$ git diff
diff --git a/sample.c b/sample.c
index bb699af..1ee2e2c 100644
--- a/sample.c
+++ b/sample.c

The index line includes the SHA-1 checksum before and after the change. The
<mode> is included if the file mode does not change; otherwise, separate lines
indicate the old and the new mode.


{combined-format}
Any diff-generating command can take the -c or --cc option to produce a
combined diff when showing a `merge`. This is the default format when showing
merges with git-diff[1] or git-show[1]. Note also that you can give the -m
option to any of these commands to force generation of diffs with individual
parents of a merge.

diff --combined describe.c
index fabadb8,cc95eb0..4866510

// note: followed by two-line from-file/to-file header

--- a/describe.c
+++ b/describe.c
@@@ -98,20 -98,12 +98,20 @@@
  return (a_date > b_date) ? -1 : (a_date == b_date) ? 0 : 1;
  }

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +    unsigned char sha1[20];
 +    struct commit *cmit;
      struct commit_list *list;
      static int initialized = 0;
      struct commit_name *n;

 +    if (get_sha1(arg, sha1) < 0)
 +       usage(describe_usage);
 +    cmit = lookup_commit_reference(sha1);
 +    if (!cmit)
 +       usage(describe_usage);
 +
      if (!initialized) {
         initialized = 1;
         for_each_ref(get_name);


<unified-diff-format>
Unlike the traditional unified diff format, which shows 'two' files A and B with
  a single column that has: - (minus - appears in A but removed in B), + (plus -
      missing in A but added to B), or " " (space - unchanged) prefix

<combined-diff-format>
This format compares two or 'more' files file1, file2,... with one file X, and
shows how X differs from each of fileN. One column for each of fileN is
prepended to the output line to note how X's line is different from it.

A - character in the column N means that the line appears in fileN but it does
not appear in the result. A + character in the column N means that the line
appears in the result, and fileN does not have that line: in other words, the
line was added, from the point of view of that parent.

In the above example output, the function signature was changed from both files
(hence two - removals from both file1 and file2, plus ++ to mean one line that
 was added does not appear in either file1 or file2). Also eight other lines are
the same from file1 but do not appear in file2 (hence prefixed with +).

note:
+ means that *do-not* appear in that file.


={============================================================================
*kt_dev_env_0000* git-diff-patch

To create a patch of the changes on the experimental branch and apply them to
the master. Suppose you are on master.

git diff `from-commit` `to-commit` > patch.diff
git diff `from-commit` > patch.diff           # = git diff from-commit HEAD
git diff 04a2 b36f > patch.diff


<merge-base>
Rather than creating a patch of the entire branch, we can let GIT determine the
'point' at which our experimental branch diverged from the master branch using
the git `merge-base` command:

git diff $(git merge-base <public branch> <experimental branch>) > <output file>

merge-base will determine the most recent common commit between 2 branches and
return SHA of the common commit. Will be defaulted to HEAD, and since the
experimental branch checked out, HEAD will be the most recent commit of the
experimental branch.

$ git diff $(git merge-base master experimental) > anotherPatch.diff


<apply-patch>
$ git apply patch.diff
$ git apply --check --verbose patch.diff


<no-history>
Although applying a patch in this way will exactly replicate content, no commit
history will be replicated. This means that even if the patch you create spans
several commits, it will appear as a `single` set of changes when applied.


={============================================================================
*kt_dev_env_0000* git-diff-format-patch

{format-patch}
Prepare 'each' commit with its patch in one file 'per' commit, formatted to
resemble UNIX mailbox format. The output of this command is convenient for
e-mail submission or for use with git am.

<usage>
Use to check before merge or to see diff between branches

Can check patch output before merging. You are 'on' undo topic barnch and want
to see changes 'against' master then:

note: when omit --stdout, *.patch file is made.

$ git format-patch master --stdout
From 223da602d2e71c6d6708b52c80cd672c159b442d Mon Sep 17 00:00:00 2001
From: Kit Park <keitee.park@samsung.com>
Date: Tue, 22 Oct 2013 14:59:37 +0100
Subject: [PATCH 1/2] changed by undo

---
 readme | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/readme b/readme
index 3ba462e..a80c866 100644
--- a/readme
+++ b/readme
@@ -1,4 +1,4 @@
-1: changed first and added one by merge-test
+1: changed first and changed by undo
 2: changed second.
 3: added topic first.
 4: added topic second.
-- 
1.8.3.4


From fa9d05492f1f0357f5803edbf6232b73797b6d8f Mon Sep 17 00:00:00 2001
From: Kit Park <keitee.park@samsung.com>
Date: Tue, 22 Oct 2013 15:04:21 +0100
Subject: [PATCH 2/2] changed by undo undo

---
 readme | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/readme b/readme
index a80c866..67d833a 100644
--- a/readme
+++ b/readme
@@ -1,4 +1,4 @@
-1: changed first and changed by undo
+1: changed first and changed by undo and by undo
 2: changed second.
 3: added topic first.
 4: added topic second.
-- 
1.8.3.4

<usage>
Use to create patch files to review or to pull into mainline.

Now you have two commits that you want to send to the mailing list. You use git
format-patch to generate the mbox-formatted files that you can e-mail to the
list - it turns each commit into an e-mail message with the first line of the
commit message as the subject and the rest of the message plus the patch that
the commit introduces as the body. The nice thing about this is that applying a
patch from an e-mail generated with format-patch preserves all the commit
information properly.

# worked on topic and made some commits

$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch


{apply}
Two ways: git apply or git am

note: format-patch do not create patches between branches whereas git diff does.
Any limitation?

note: appears that little use of making and applying a patch so leave it for
now.


={============================================================================
*kt_dev_env_git_000* git-tag

To tag specific points in history as being important and to mark release points
(v1.0, and so on)

$ git tag                           # list
$ git tag -l 'v1.4.2.*'             # search a tag with pattern

       -l <pattern>
       --list <pattern>

          List tags with names that match the given pattern (or all if no
              pattern is given). Running "git tag" without arguments also
          lists all tags. The pattern is a shell wildcard (i.e., matched using
              fnmatch(3)). Multiple patterns may be given; if any of them
          matches, the tag is shown.


       -d, --delete
           Delete existing tags with the given names.


$ git tag -l '*BLD_83*'
BSKYB_HR014_Int/BSKYB_INTEGRATION_BLD_83.01.00_BSKYB_HR014_Int
BSKYB_HR014_Int/BSKYB_INTEGRATION_BLD_83.01.01_BSKYB_HR014_Int
BSKYB_HR014_Int/BSKYB_INTEGRATION_BLD_83.02.00_BSKYB_HR014_Int
BSKYB_HR014_Int/BSKYB_INTEGRATION_BLD_83.03.00_BSKYB_HR014_Int
...


{annotated-tag}
Git uses two main types of tags: lightweight and `annotated`. It's generally
recommended that create annotated tags so you can have all this information;  

       -a, --annotate
           Make an unsigned, annotated tag object

$ git tag -a v1.4 -m 'my version 1.4'

The -m specifies a tagging message

# git-show - Show various types of objects
$ git show v1.4                               # to see a tag


{to-tag-a-commit}
To tag that commit, you specify the commit checksum (or part of it) at the end
of the command:

$ git tag -a v1.2 -m 'version 1.2' 9fceb02


{tag-is-local}
By default, the git push command doesn't transfer tags to remote servers. You
will have to explicitly push tags to a shared server after you have created
them.


{branch-from-tag}
$ git co -b <branch> <tag>
$ git co -b C27.5.0-RC2 C27.5.0-RC2


={============================================================================
*kt_dev_env_git_000* git-tag-git-describe

http://alblue.bandlem.com/2011/04/git-tip-of-week-tags.html

Descriptive labels

Git provides a couple of mechanisms for identifying changes by labels instead
of by unique hash values.

The first, we've already seen, is branches. When we switch between two
branches, we're really using the descriptive label to identify a specific
commit to switch to.

The second, which we'll introduce here, is tags. A tag is like a branch, in
that it identifies a specific commit with a descriptive label.  


Branches versus Tags

The difference between tags and branches? The workspace is (almost always)
associated with a branch, called master by default. When it is, a commit will
automatically update the master reference to point to that new commit; in
other words, `branches` are `mutable references`

A tag, on the other hand, is created to point to a specific commit and
thereafter does not change, even if the branch moves on. In other words,
`tags` are `immutable references`   
  

Annotated Tags

Git has two flavours of tags; annotated and non-annotated. When using them,
there is little difference between the two; both will allow you to refer to a
  specific commit in a repository.

An annotated tag creates an additional tag object in the Git repository, which
allows you to store information associated with the tag itself. This may
include release notes, the meta-information about the release, and optionally
a signature to verify the authenticity of the commit to which it points.


Examples

We can create a simple tag, based on the current repository's version, with:

    $ git tag example

This creates a lightweight tag as a reference in .git/refs/tags/example, which
points to the current commit. If we want to make it as an annotated tag, we
need to supply -a, and a message with -m:

    $ git tag -a v1 -m "Version 1 release"

This will create an (unsigned) annotated tag object, containing that message
and a pointer to the commit object. Now the reference in .git/refs/tags/v1
will point to the tag object, which then points to the commit.

If we wanted to guarantee the authenticity of the tag, we could use -s on the
git tag command. This uses gpg to sign, based on your email address - though
you can use -u to specify a different gpg identity instead. You can verify the
signature of an existing tag with -v.

Deleting tags are OK if you never made them publicly available, but you really
should avoid deleting tags once you've pushed them to a publicly readable
location. Similarly, you shouldn't change a tag once it has been released to
the wild either.


Contents and Describe

In order to see what the tag contains, you can use git show, as you can with
other git objects:


If the tag is an annotated tag, you'll see the message and the tag object,
followed by the commit. If the tag is a lightweight tag, then you'll see only
  the commit object.

A key difference between annotated and non-annotated tags is `git describe`
This gives an identifier of the repository, based off of the `nearest`
annotated tag. If we were to run now, we'd see a reference to the v1s
annotated tag:

$ git describe
v1s

If the current commit exactly matches that of a tag, then only the tag name is
printed. If there are changes, then git describe will print out the tag name,
a hyphen, the number of commits made, a hyphen, the letter 'g' and then the
  commit identifier. 
  
This allows anyone to use that explicit revision to identify the commit,
through the hash at the end. As such, it is often useful to include that in
  file versions as a means of identifying it at a later stage.


    $ git describe
    v1s-1-g24242c3

The letter g is added to denote a git managed version; so other repositories
can use the same format but substitute that letter for a different one.

If no annotated tags are found then it will print 

fatal: No names found, cannot describe anything. 
  
To allow describe to use non-annotated tags, run with git describe --tags.
It's also possible to get it to describe against a branch using git describe
--all, although this only makes sense if the branch is known remotely.


Pushing and Pulling

Since a tag (either annotated or lightweight) is just a reference on your
local repository, it is not sent up by default to the remote repository during
pushes. (This is one observable difference between Git and Hg.) Instead, you
can `git push` the tag individually, or you can run `git push --tags` which
will push all tags. 

For “release” tags (e.g. V1.0.0) it is conventional for these to be annotated
tags; it is relatively rare that you will push a lightweight tag to a central
repository.

For pulling, any tags associated with your current branch will be fetched when
you check it out. This may result in not having all the tags in your local
repository that the remote repository has. If you'd like to fetch them all,
you can do `git fetch --tags` to pull them all in, or git fetch tag to pull a
  single one.


Summary

Tags in git are lightweight references that point to an SHA hash of a commit.
Unlike branches, they are not mutable and once created should not be deleted.
Tags may be lightweight (in which case they refer to the commit directly) or
annotated (in which case they point to a tag object which points to the
    commit). Tags used to denote versioned releases typically use annotated
tags, and for many open source projects, the tags will also be signed. 


https://git-scm.com/docs/git-describe

The command finds the most recent tag that is reachable from a commit. If the
tag points to the commit, then only the tag is shown. Otherwise, it suffixes
the tag name with the number of additional commits on top of the tagged object
and the abbreviated object name of the most recent commit.

By default (without --all or --tags) git describe only shows annotated tags.
For more information about creating annotated tags see the -a and -s options
to git-tag[1].

--always
    Show uniquely abbreviated commit object as fallback.


={============================================================================
*kt_dev_env_git_000* git-rebase

In Git, there are two main ways to 'integrate' changes from one branch into
another: the merge and the rebase.

{use-merge}
The merge-with-diverge example, `merge-in` experiment onto master:

                      <experiment>
                     <- c4
c0 <- c1 <- c2       <- c3
                      <master>

$ git checkout master     // on master
$ git merge experiment    // `merge-in` experiment

                      <experiment>
                     <- c4              
                                       \
c0 <- c1 <- c2       <- c3             <- c5    # points to c3 and c4
                                       <master>

note:
Works like `pull-model`, create `merge-commit` and fast-forward master.


{use-rebase}
Take the 'patch' of the change that was introduced in C4 and `reapply` it on top
of C3. This is called rebase. Take changes from experiment and apply 'to'
master.

<how-rebase-work>
It works by going to the common ancestor (c2) of the two branches; experiment
and master which you're rebasing onto, getting the diff introduced by each
commit of the branch you're on (diff between c4 and c2).

# git checkout experiment

Saving those diffs to temporary files

# save diff from c2 to c4
          
Resetting the current branch to the same commit as the branch you are rebasing
onto (checkout 'to' master)

# git checkout master

finally applying each change in turn (apply temp diff to c3 which makes c4')

# apply diffs to master

                      <experiment>
c0 <- c1 <- c2        <- c4
                      <- c3
                      <master>

$ git checkout experiment   // on experiment
$ git rebase master         // `push-to` master. still on experiment.

                     <- c4
c0 <- c1 <- c2       <- c3         <- c4'
                      <master>      <experiment>
                                    `HEAD`

At this point, go back to the master and do `fast-forward`

$ git checkout master       // on master
$ git merge experiment

c0 <- c1 <- c2        <- c3         <- c4'
                                    <experiment>
                                    <master>
                                    `HEAD`

note:
Works like `push-model`. In merge, experiment branch remains the same but in
rebase, it removes that branch since it is now on the same line of development.

The snapshot c4' in rebase is exactly the same as C5 in the merge. 


{rebase-conflict}
As with merge, rebase can cause conflict. When tried the above scenario in
that test is master and experi is experiment at to mapping to the example.

$ git checkout experiment
$ git rebase master 

First, rewinding head to replay your work on top of it...
Applying: add foo func and call to it 
Using index info to reconstruct a base tree...
M   sample.c
Falling back to patching base and 3-way merge...
Auto-merging sample.c
CONFLICT (content): Merge conflict in sample.c
Failed to merge in the changes.
Patch failed at 0001 add foo func and call to it
The copy of the patch that failed is found in:
   /home/kpark/work/gitwork/.git/rebase-apply/patch

When you have resolved this problem, run "git rebase --continue".
If you prefer to skip this patch, run "git rebase --skip" instead.
To check out the original branch and stop rebasing, run "git rebase --abort".


note that rebase uses a temp branch

$ git st
rebase in progress; onto cfeeadd
You are currently rebasing branch 'experi' on 'cfeeadd'.
  (fix conflicts and then run "git rebase --continue")
  (use "git rebase --skip" to skip this patch)
  (use "git rebase --abort" to check out the original branch)

Unmerged paths:
  (use "git reset HEAD <file>..." to unstage)
  (use "git add <file>..." to mark resolution)

  both modified:   sample.c

Untracked files:
  (use "git add <file>..." to include in what will be committed)

  .sample.c.swp
  a.out

no changes added to commit (use "git add" and/or "git commit -a")


Once resolved the conflict, continue rebase:

$ git rebase --continue 

Applying: add foo func and call to it
Applying: add more in main
Using index info to reconstruct a base tree...
M   sample.c
Falling back to patching base and 3-way merge...
Auto-merging sample.c


See result

* a5102be65c add more in main                // C2. experiment. HEAD
* ef9b720087 add foo func and call to it     // C1
* cfeeaddadd add more handling of using bar  // master branch
* ... 

As can see, applied two commits 'from' experiment 'to' master and master branch
'remains' the same. So do fast-forward merge.

$ git checkout master 
Switched to branch 'master'

$ git merge experiment 
Updating cfeeadd..a5102be
Fast-forward
 sample.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

* a5102be65c add more in main                // experiment and master
* ef9b720087 add foo func and call to it
* cfeeaddadd add more handling of using bar     
* ... 


{why-rebase}
The rebase makes `single-history` by removing diverge in tree. If you examine
the log of a rebased branch, it looks like a linear history; it appears that all
the work happened in series even when it originally happened in parallel

Often, you'll do this to make sure your commits apply cleanly on a remote
branch - perhaps in a project to which you're trying to contribute but that
you don't maintain. That way, the maintainer doesn't have to do any
integration work - just a fast-forward or a clean apply.

note:
Means that the integration work is developer's role.

Rebasing 'replays' changes from one line of work 'to' another in the 'order'
they were introduced whereas merging takes the 'endpoints' and merges them
together.


={============================================================================
*kt_dev_env_0000* git-rebase-onto

From git help

git rebase [--onto <newbase>] [<upstream> [<branch>]]
# git rebase --onto <graft-point> <exclude-from> <include-from>

<reading>
https://matthew-brett.github.io/pydagogue/rebase_without_tears.html#manpage-names

Rebase without tears

Why I wrote this page

I'm looking at the git-rebase man page now. I may not be alone in finding it
hard to understand, and easy to forget. I have twice or three times worked out
how it worked, and then forgotten, and wished I had written something down to
explain it to myself. Here is that explanation. What is this "rebase" of which
you speak?

Actually it's a little difficult to explain. Rebasing is the process of taking a
fragment of git change history, and rewriting that history as if it had begun at
a different commit. It's easiest to explain by example, and there are some
examples later in this page. See also the Pro-Git chapter on rebasing Your
actual rebase

I like to think of rebase in its full form, because the full form helps to
remind me of what it is doing. Here's the full form of most rebase commands [1]:

git rebase --onto <graft-point> <exclude-from> <include-from>

I'm using different names from the git-rebase man page - see [2].

The man page uses:

<newbase> for my `graft-point`
<upstream> for my `exclude-from`
<branch> for my `include-from`

--onto <newbase>

    Starting point at which to create the new commits. If the --onto option is
    not specified, the starting point is <upstream>. 
    May be any valid commit, and not just an existing branch name.

    As a special case, you may use "A...B" as a shortcut for the merge base of A
    and B if there is exactly one merge base. You can leave out at most one of A
    and B, in which case it defaults to HEAD.

    # don't specify --onto, `graft-point` defaults to `exclude-from`

<upstream>
    Upstream branch to compare against. May be any valid commit, not just an
    existing branch name. Defaults to the `configured-upstream` for the current
    branch.

<branch>
    Working branch; defaults to HEAD.

    # don't specify an `include-from`, defaults to the current branch.

Which commits will rebase apply?

Rebase will apply all the commits found by:

git log <exclude-from>..<include-from>

These are the commits that are reachable from <include-from> that are not
reachable from <exclude-from>. Which branch does rebase modify?

rebase modifies the <include-from> branch. If you don't specify <include-from>
it will modify the default for <include-from>, that is, the current branch.

Basic example

Let’s go through the man page examples. Here’s a history tree:

      A---B---C topic
     /
D---E---F---G master

We want to take the novel contents of the topic branch (A, B, C) and regraft it
so that it starts at the master branch, like this:

              A'--B'--C' topic
             /
D---E---F---G master

Let's do something to ease the explanation, and tag the divergence point E thus:

git tag divergence-point topic~3 # E

Obviously that gives us:

     A---B---C topic
    /
    | F---G master
    |/
D---E  (tag) divergence-point

Reading the Your actual rebase command, we suspect the command we want is:

git rebase --onto master divergence-point topic

And indeed, that does give us what we want. However we had a to make a tag for
the divergence point, and that was a bit annoying. Can we get away without that?

Yes, because because the meaning of <exclude-from> <include-from> above is to
collect the commits that you are going to apply. See Which commits will rebase
apply? for an explanation. The commits wil be those shown by git log
<exclude-from>..<include-from>. 

I took the liberty of making a repository to match the history above. Here is
the result of git log --oneline master..topic, before the rebase:

8de3e90 C
9dcbae2 B
cc3741a A

And of course that is the same as git log --oneline divergence-point..topic. So
we could also do the rebase command with:

git rebase --onto master master topic

And, in fact, if you don't specify the --onto option, then rebase assumes you
want to graft onto the <exclude-from> position, so you could also do:

git rebase master topic         # will be on topic branch after running this?

and in fact, if you don't specify the <include-from> position, rebase assumes
that you want <include-from> to be the state of the current branch, so you could
also do:

git checkout topic              # unless you are on ``topic`` already
git rebase master


<ex>
Other examples

Here is another example from the git-rebase man page. We want to go from this:

o---o---o---o---o  master
     \
      o---o---o---o---o  next
                       \
                        o---o---o  topic

to this:

o---o---o---o---o  master
    |            \
    |             o'--o'--o'  topic
     \
      o---o---o---o---o  next

How? Let’s check the Your actual rebase command. Maybe it is this:

git rebase --onto master next topic

Yup, that's it! You understand rebase!

Now we want to go from this:

                        H---I---J topicB
                       /
              E---F---G  topicA
             /
A---B---C---D  master

to this:

             H'--I'--J'  topicB
            /
            | E---F---G  topicA
            |/
A---B---C---D  master

We check the Your actual rebase command. Could it be this?:

git rebase --onto master topicA topicB

Could it be anything else? Congratulations, you are now a rebase master.

Safety

Summary: always make a new branch before doing a rebase

You’ll see from Which branch does rebase modify? that when you a rebase you will
change the branch you are rebasing. As you remember from the Basic example, if
you do:

git rebase --onto master master topic

on this history graph:

      A---B---C topic
     /
D---E---F---G master

then you’ll get this:

              A'--B'--C' topic
             /
D---E---F---G master

If you only have branches master and topic then you have just orphaned commits
A, B, C which will in due course get cleaned out of your repository. You might
want to keep track of where you were before. You might want to do that in case
you made a mistake and need to retrace your steps. The easiest way to do this,
is to make a copy of the branch before doing the rebase, like this:

git branch topic-rebased topic
git rebase --onto master master topic-rebased

or, if you are already on topic and you want to use the shorthand form of
rebase:

git branch topic-rebased topic
git checkout topic-rebased
git rebase master

Now you have left topic to be a branch that records where you were before:

              A'--B'--C' topic-rebased
             /
D---E---F---G master
     \
      A---B---C topic

If you forget to make a new branch before rebase, and you do need to go back,
then you can use git reflog.

<ex>
You can also have your rebase replay on something other than the rebase target
branch.

         <master>
C1 C2 C5 C6

      C3 C4 C10
            <server>    # topic branch for server functionality
         C8 C9
            <client>    # topic branch for client functionality

Suppose you decide that you want to merge your client-side changes into your
mainline for a release, but you want to hold off on the server-side changes
until it's tested further. 

So want to apply C8 and C9 only to master.

$ git rebase --onto master server client

This basically says, "Check out the client branch, figure out the patches from
the common ancestor of the client and server branches, and then replay them
onto master." It's a bit complex; but the result is pretty cool. The git ref
says "make topic forked from branch master"

         <master>
C1 C2 C5 C6 C8' C9'
                <client>
      C3 C4 C10
            <server>          # topic branch

Now you can fast-forward your master branch:

$ git checkout master
$ git merge client

                <client>
C1 C2 C5 C6 C8' C9'
                <master>
      C3 C4 C10
            <server> # topic branch

<ex>
Let's say you decide to pull 'in' your server branch as well. You can rebase
the server branch onto the master branch 'without' having to check it out
first by running.

git rebase [<upstream>] [<branch>] == git rebase [target branch] [topic branch] 

which checks out the topic branch (in this case, server) for you and replays
it onto the base branch (master):

$ git checkout server
$ git rebase master

equals to:

$ git rebase master server

note: Does this mean that it moves target branch as well?

The end result is:

                <client>    <server>
C1 C2 C5 C6 C8' C9' C3' C4' C10'
                            <master>

Now remove topic branches:

$ git branch -d client
$ git branch -d server

note: So, rebasing is useful when use topic branches.


<reading>
https://blog.pivotal.io/labs/labs/git-rebase-onto
git rebase --onto master


={============================================================================
*kt_dev_env_0000* git-rebase-rewrite-history

Changing Multiple Commit Messages in CH 07 Rewriting History.

<ex>
Suppose that take smaller commits and 'combine' them into larger ones, which
could be useful if you're wrapping up the day's work or if you just want to
package your changes differently.

                  <head>
C1 C2 C3 C4 C5 C6 C7 
      ~4 ~3 ~2 ~1 ~0

Say want to merge from C4 to C7 into single one. Select commits from ~4 which
'includs' head but ~4. That is [~4, HEAD)

$ git rebase -i HEAD~4      // = $ git rebase -i HEAD~4 <current>
$ git rebase -i C4~1


Vim pops up and edit to choose what to do

The git log are:

1616841 - kit, 4 minutes ago : rebase five      # C7, HEAD
7b622e7 - kit, 5 minutes ago : rebase four      # C6
a6e0d20 - kit, 5 minutes ago : rebase three     # C5
3691dd1 - kit, 6 minutes ago : rebase two       # C4
99e3f70 - kit, 6 minutes ago : rebase one       # C3

# { vim screen 
pick 3691dd1 rebase two       note: reverse order from old to new
pick a6e0d20 rebase three
pick 7b622e7 rebase four 
pick 1616841 rebase five 

# Rebase 99e3f70..1616841 onto 99e3f70 (4 TODO item(s))
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
# } vim screen 


Successfully rebased and updated refs/heads/test.

note: Although the message when exit vim sounds done well, nothing has changed
since picked 'all'.


<squash-commits>
As the rebase message, squash = use commit, but meld into previous commit

C1 C2 C3 C4 C5 C6 C7 

git rebase -i HEAD~4

pick 3691dd1 rebase two       // note: reverse order from older
s a6e0d20 rebase three
s 7b622e7 rebase four 
s 1616841 rebase five 

Then quit vim and vim pops again to edit commit message. edit commit message
and quit.

Tree will be:
         <head>
C1 C2 C3 C8 

So the three commits were removed and merged into one 'new' commit which will
have contents from C4-C7.

3fabf21 - kit, 23 minutes ago : rebase from two to five
99e3f70 - kit, 23 minutes ago : rebase one


<reorder-remove-commits> by changing the order in rebase vim screen
Git 'rewinds' your branch to the parent of these commits, 'applies'(replay)
310154e and then f7f3f6d, and then 'stops'. You effectively change the order
of those commits and 'remove' the "added cat-file" commit completely.

From:

pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

to this:

pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit

note: When replaying commits, merge conflict can happen and replaying means
that it will create new commits for every commits to replay including 'pick'
one.


<split-commits> <modify-commits>
Suppose that Want to split C6 into two.

$ git log

C7
C6
C5
C4
...

$ git rebase -i HEAD~3

Vim pops up.

pick C5 
edit C6   # this to be split
pick C7 

When you save and exit the editor, rewinds to the parent of the first commit
in your list, applies C5 and C6 and drops you to the console.


Stopped at C6
You can amend the commit now, with

  git commit --amend

Once you are satisfied with your changes, run

  git rebase --continue


$ git st
# Not currently on any branch.  
note: here 'detached' state and no modified files in working directory.

# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)


$ git reset HEAD^
Unstaged changes after reset:
M   sample.c

or

$ git reset HEAD~ 
$ git diff


note: 
This is `git-reset-mixed` that is update HEAD and the index with the previous
and this is 'important' since C6 is 'already' replayed. 

When run git diff, shows 'modifiled' state since the index has the first
commit and the working directory has the second.


$ git st
# Not currently on any branch.
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#   modified:   sample.c
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
no changes added to commit (use "git add" and/or "git commit -a")


note:
Here can use stash before making changes to the version in working directory?


Split the version in working directory to the part one. Here can do whtever
you want and edited sample.c to split the commit

$ git commit -am "updated readme formatting"
[detached HEAD 0c5d9cd] updated readme formatting
 1 file changed, 1 insertion(+)

$ git st
# Not currently on any branch.
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)


Split the version in working directory to the part two. 

$ git commit -am "added blame"
[detached HEAD 709b103] added blame
 1 file changed, 1 insertion(+), 1 deletion(-)

$ git st
# Not currently on any branch.
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)


note: continue rebasing

$ git rebase --continue 
Successfully rebased and updated refs/heads/topic2.

$ git st
# On branch topic2
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)

$ git log
C7 
C62  
C61   
C5 

note: see the commit is splitted two and shows 4 in total.


={============================================================================
*kt_dev_env_0000* git-commit-amend

{amend-last-commit}
Suppose that edit a few files that we would like to commit in a single
snapshot, but then we forget to add one of the files the first time around.
Fixing the error is simply a matter of staging the other file and committing
with the --amend flag:

# edit hello.py and main.py

git add hello.py
git commit

# realize you forgot to add the changes from main.py. note that make changes
# before run amend command as you do normal commit.

git add main.py
git commit --amend --no-edit

The editor will be populated with the message from the previous commit and
including the --no-edit flag will allow you to make the amendment to your
commit 'without' changing its commit message. 

You can change it if necessary, otherwise just save and close the file as
usual. The resulting commit will replace the previous, and it will look like
we committed the changes to hello.py and main.py in a 'single' snapshot, commit.

So it lets you combine "staged changes" with "the previous commit" instead of
committing it as an entirely new snapshot. Also be used to simply edit the
previous commit message without changing its snapshot.


note: 
"git commit --amend" do what `git-reset-soft` do.

// note: 
// DO NOT USE "git commit --amend" in the middle of rebasing.
// 
// C1 C2 C3 C4 C5 C6 C7 
// 
// $ git rebase -i HEAD~4
// 
// // suppose that "edit" on C4 and stops at C4. make changes to C4
// 
// $ git commit --amend
// $ git rebase --continue
// 
// When --amend is done, rebase tries to replay from C4 but not C5. So may happen
// conflict.


={============================================================================
*kt_dev_env_0000* git-rebase-undo

Suppose that rebase pirate branch to master but wanted undo it.

git checkout pirate
git rebase master

How can I undo this whole thing and start over?

git reflog

If you run the git reflog command you will see the line where it says 

"checkout: moving from master to pirate" 

this is the point in time we would like to restore our state back (just before
    the rebase happened).

Now copy the sha that is on the same line as that comment and run

git reset <sha> --hard

<case>
Worked on a branch and wanted to base it on the latest from master. Done
something wrong with rebasing and ended up with having "merge branch". Here
shows how to 'undo' it and back to where it was.

// full sha of the tip

0531f00bd8636c4d9d3935ac07fdf626b4a29bf5

// git log

* 4334791 (HEAD, DEVARCH-9135-work) add some debug
*   88c842b Merge branch 'master' of git-dev:/DEVARCH into DEVARCH-9135-work
|\  
| * 99186fe (tag: C26.6.0-RC2, DEVARCH-9135) DEVARCH-7725: Make more robust
| * ad6e1ab DEVARCH-9333: Uranium.Client.System: Fix compiler warnings.
...
| * 8b92a9e DEVARCH-8955: Remove the use of 'friend boost::shared_ptr'
| * 92820f1 DEVARCH-8958: Fix unsafe pointer dereference 
* | 0531f00 add updates to unit test // note: this was tip of working branch.
* | 731b4e2 add fixes to system client events and wrapper
* | 3d07e6c add debug mesgs to system client events
|/  
* 235e95c DEVARCH-9191: Sodium: Enable generic error reporting.
* 152753a DEVARCH-9188: OEM.Humax: Fix up reverse patch-o-tronning.


// git reflog. see lots of entry with the same sha.
...
f790f3c HEAD@{162}: commit: DEVARCH-8092: Fix ctv.enhancedmetadata.Event
235e95c HEAD@{163}: rebase -i (start): checkout HEAD~3
0531f00 HEAD@{164}: checkout: moving from DEVARCH-9135-work to DEVARCH-9135
0531f00 HEAD@{165}: checkout: moving from DEVARCH-9135 to DEVARCH-9135-work
0531f00 HEAD@{166}: checkout: moving from DEVARCH-9135 to DEVARCH-9135
0531f00 HEAD@{167}: checkout: moving from DEVARCH-9135-work to DEVARCH-9135
0531f00 HEAD@{168}: checkout: moving from DEVARCH-9135 to DEVARCH-9135-work
0531f00 HEAD@{169}: commit: add updates to unit test
731b4e2 HEAD@{170}: checkout: moving from 731b4e2b0a to DEVARCH-9135
731b4e2 HEAD@{171}: checkout: moving from DEVARCH-9135 to tag-to-fix
...


={============================================================================
*kt_dev_env_0000* git-rebase-or-merge

Which one is better?

One point of view on this is that your repository's commit history is a
'record' of what actually happened. It's a historical document, valuable in
its own right, and shouldn't be tampered with. From this angle, changing the
commit history is almost blasphemous; you're lying about what actually
transpired. So what if there was a messy series of merge commits? That's how
it happened, and the repository should preserve that for posterity.

The opposing point of view is that the commit history is the 'story' of how
your project was made. You wouldn't publish the first draft of a book, and the
manual for how to maintain your software deserves careful editing. This is the
camp that uses tools like rebase and filter-branch to tell the story in the
way that's best for future readers.

Now, to the question of whether merging or rebasing is better: hopefully
you'll see that it's not that simple. Git is a powerful tool, and allows you
to do many things to and with your history, but every team and every project
is different. Now that you know how both of these things work, it's up to you
to decide which one is best for your particular situation.

<warning>
In general the way to get the best of both worlds is to rebase local changes
you've made but haven't shared yet before you push them in order to clean up
your story, but never rebase anything you've pushed somewhere.


={============================================================================
*kt_dev_env_git_000* git-cherry-pick

A cherry-pick in Git is like a rebase for a 'single' commit. It takes the patch
that was introduced in a commit and tries to reapply it on the branch you're
currently on. This is useful if you have a number of commits on a topic branch
and you want to integrate only one of them, or if you only have one commit on a
topic branch and you'd prefer to cherry-pick it rather than run rebase. 

            master
C1    C2    C3    
            C4(e43a6)   C5
                        topic

$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
3 files changed, 17 insertions(+), 3 deletions(-)

This pulls the same change introduced in e43a6 to master and you get a 'new'
commit because the date applied is different. Now your history looks like this:

                        master
C1    C2    C3          C6   
            C4(e43a6)   C5
                        topic

Now you can remove your topic branch and drop the commits you didn't want to
pull in.

note: master moves.


<conflict>
You are currently cherry-picking commit 938d0ac.
  (fix conflicts and run "git cherry-pick --continue")
  (use "git cherry-pick --abort" to cancel the cherry-pick operation)


<from-remote>
There normally isn't any need to undo a fetch, because doing a fetch only
updates the remote branch and none of your branches. If you're not prepared to
do a pull and merge in all the remote commits, you can use git cherry-pick to
  accept only the specific remote commits you want. Later, when you're ready to
    get everything, a git pull will merge in the rest of the commits.

Update: I'm not entirely sure why you want to avoid the use of git fetch. All
git fetch does is update your local copy of a remote branch. This local copy
doesn't have anything to do with any of your branches, and it doesn't have
anything to do with uncommitted local changes. I have heard of people who run
git fetch in a cron job because it's so safe.


={============================================================================
*kt_dev_env_git_000* git-revert

Given one or more existing commits, revert the changes that the related
patches introduce, and record some new commits that record them. This requires
your working tree to be clean (no modifications from the HEAD commit).

Note: git revert is used to record some new commits to reverse the effect of
some earlier commits (often only a faulty one). If you want to throw away all
uncommitted changes in your working directory, you should see git-reset[1],
particularly the --hard option. If you want to extract specific files as they
  were in another commit, you should see git-checkout[1], specifically the git
  checkout <commit> -- <filename> syntax. Take care with these alternatives as
  both will discard uncommitted changes in your working directory.


<commit>...

    Commits to revert. For a more complete list of ways to spell commit names,
see gitrevisions[7]. Sets of commits can also be given but no traversal is
  done by default, see git-rev-list[1] and its --no-walk option.


={============================================================================
*kt_dev_env_git_000* git-reset

From CH07, Reset demystified

{three-trees}
Git as a system manages and manipulates three trees in its normal operation:

Tree                    Role
-------------------------------------------------------------------
HEAD                    'last' commit snapshot, parent of next commit
Index                   Proposed next commit snapshot
Working Directory       Sandbox


{what-checkout-do}
Switching branches or cloning goes through a similar process. When you checkout
a branch, it changes HEAD to point to the new branch ref, populates your Index
with the snapshot of that commit, then copies the contents of the Index into
your Working Directory.

                        HEAD
                        master
v1    <-    v2    <-    v3

git reop

HEAD        index       working directory
v3          v3          v3


<soft> move only HEAD so go back before publishing a commit

$ git reset --soft HEAD~ 

            HEAD
            master
v1    <-    <v2>  <-    v3

git reop

HEAD        index       working directory
<v2>        v3          v3

Essentially 'undo' the last `git-commit`. `git-status` shows difference in
green since HEAD is different from index. 

note: *git-commit-amend* 
This is what "git commit --amend" do.

When you soft reset back to HEAD~, you are moving the branch back to where it
was, without changing the Index or Working Directory. You could now update the
Index and run git commit again to accomplish what git commit --amend would have
done


<mixed> move `HEAD` and update `index`. 'default'
$ git reset [--mixed] HEAD~ 

            HEAD
            master
v1    <-    <v2>  <-    v3

git reop

HEAD        index       working directory
<v2>        <v2>        v3

'undo' your last commit, but 'also' unstaged everything. You rolled back to
before you ran all your git add and git commit commands.

note: 
Careful when use mixed reset and "git commit --amend". This has the same effect
merging HEAD and HEAD~.

$ git reset HEAD~ 
$ git add .      
$ git commit --amend


<hard> undo all
"git reset --hard HEAD~"

            HEAD
            master
v1    <-    <v2>  <-    v3

git reop

HEAD        index       working directory
<v2>        <v2>        <v2>


{hard-dangerous}
This --hard is the only way to make the `git-reset` dangerous, and one of the
very few cases where Git will actually destroy data. 

Since it forcibly overwrites files in the `working-directory`. In this
particular case, we still have the v3 version of our file in a commit in our git
DB, and we could get it back by looking at our reflog, but if we had not
committed it (means not in the repo), Git still would have overwritten the file
and it would be unrecoverable.


{defaults}
`git-reset` simply remove the staged changes. For example, suppose that a file
staged already and changes it after. What would happen when 'unstage' it? would
you lost the changes made after staged? NO. The working copy remains the same
but the staged is gone.

WHY?

https://git-scm.com/docs/git-reset
The <tree-ish>/<commit> defaults to HEAD in all forms.


{reset-file}

From 2.4 Git Basics - Undoing Things

<unstaging>
For example, let's say you've changed two files and want to commit them as two
separate changes, but you accidentally type git add * and stage them both. How
can you unstage one of the two? The git status command reminds you:

$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.txt
#       modified:   benchmarks.rb
#

it says "use git reset HEAD <file>... to unstage". So, let's use that advice to
unstage the benchmarks.rb file:

$ git reset HEAD benchmarks.rb
benchmarks.rb: locally modified

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   benchmarks.rb
#


<ex> from a 'specific' commit

If you specify a path, `git-reset` will not move HEAD, and 'limit' its actions
to a specific file or set of files. This actually sort of makes sense since HEAD
is just a pointer, and you can't point to part of one commit and part of
another. But the Index and Working directory can be 'partially' updated. 

<ex>
The below example is a bit different from the gitpro book.

To unstage from a commit:
                        HEAD
                        master
v1    <-    v2    <-    v3

git reop

HEAD        index       working directory
v3          v3          v3


$ git reset v1 file       # v1 is a commit


                        HEAD
                        master
v1    <-    v2    <-    v3

git reop

HEAD        index       working directory
v1          <v1>          v3

$ git status

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

  modified:   version.txt           # v1. since the index has changed

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   version.txt           # v3, working directory, has v2 as well.

$ git add version.txt  

<Q> What will happen? will make a new commit? nothing happens and status shows
none because:

HEAD        index       working directory
v3          <v3>          v3


{discard-changes}
$ git checkout -- <filename>


={============================================================================
*kt_dev_env_0000* git-reset-try-branches

The real use case.

Suppose that there are some commits made on topic branches and want to build and
try out them.

         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B

The problem is that the build system has a limit to use branch name to seperate
each build. So make a branch, make commits on them, and tries to build them,
then this would regarded as a seperate build so would trigger a whole build.

However, would like to try some commits without full build and that means to use
the same branch name. How?

$ git co topic-branch

# make commits

$ git co master
$ git reset --hard topic-branch

# build and run

This essentially moves around HEAD to whatever to try in the repo.


={============================================================================
*kt_dev_env_0000* git-stash

Stashing takes the dirty state of your your modified tracked files and staged
changes, and saves it on a stack of unfinished changes that you can reapply at
any time.

note: Save two things; staged and tracked but 'not' untracked. When apply the
stash, all goes to 'unstaged' area by default. 

note: After stashing, your working directory is clean since all changes are
stashed.


{stash-save}

save [-p|--patch] 
  [-k|--[no-]keep-index] 
  [-u|--include-untracked] 
  [-a|--all] [-q|--quiet] [<message>]

If do not give the name, git will make one as shown. 

WIP xxx: {commit which was the base when stashed} {commnet}. 

Better to use message to have clear label for that since use the base commit's
one when use save only.

$ git stash save
stash@{0}: WIP on master: d926edd new third

$ git stash save "temp work on master"
stash@{0}: On master: temp work on master

<untracked-or-all>
If the --include-untracked option is used, all untracked files are also
stashed and then cleaned up with git clean, leaving the working directory in a
very clean state. 

If the --all option is used instead then the ignored files are stashed and
cleaned in addition to the untracked files.

note: 
Careful with this `git-clean`, since it's designed to remove files from your
working directory that are not tracked. If you change your mind, there is often
no retrieving the content of those files. A safer option is to run git stash
--all to remove everything but save it in a stash.


{stash-list} like stack since 0 is the 'latest'

$ git stash list

stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log


{stash-apply}
Like pop, but do not remove the state from the stash list. If you don't
specify a stash, Git assumes the most recent stash and tries to apply it:

$ git stash apply

<to-apply-staged-changes>
The file you staged before was 'not' restaged. To do that, you must run the
git stash apply command with a --index option to tell the command to try to
reapply the staged changes. 

<apply-conflict>
When make changes to the stashed file and want to apply the different stash.
Git gives you merge conflicts if anything no longer applies cleanly. (This
    means when the current working directory is different from the stashed
    base. So cannot apply stash cleanly)

$ git stash apply stash@{0}
error: Your local changes to the following files would be overwritten by merge:
   not-staged.c
   test_file.c
Please, commit your changes or stash them before you can merge.
Aborting

To return to the clean state or to have the clean commit:

git reset --hard <tag/branch/commit id>

Then apply stash.


<apply-single-file>
Like checkout, see diff and copy a file from stash to working directory.

git diff HEAD stash@{0} -- <filename>

git checkout stash@{0} -- <filename>


<stash-branch>
If you stash some work, leave it there for a while, and continue on the branch
from which you stashed the work, you may have a problem reapplying the work.
If the apply tries to modify a file that you've since modified, you'll get a
merge conflict and will have to try to resolve it. 

If you want an 'easier' way to test the stashed changes again, you can run git
stash branch, which creates a new branch for you, checks out the commit you
were on when you stashed your work, reapplies your work, stash, there, and
then drops the stash if it applies successfully:

$ git stash branch testchanges
Switched to a new branch "testchanges"
# On branch testchanges
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)

This is a nice shortcut to recover stashed work easily and work on it in a new
branch.

note: seems that it's not working as expected as below.

$ git stash branch test
   readme
Switched to a new branch 'test'
error: Your local changes to the following files would be overwritten by merge:
   readme
Please, commit your changes or stash them before you can merge.
Aborting
Index was not unstashed.
$


{unapply}
Un-applying a Stash

In some use case scenarios you might want to apply stashed changes, do some
work, but then un-apply those changes that originally came from the stash. Git
does not provide such a stash unapply command, but it is possible to achieve
the effect by simply retrieving the patch associated with a stash and applying
it in reverse:

//  -R, --reverse
//    Apply the patch in reverse.

$ git stash show -p stash@{0} | git apply -R

Again, if you don't specify a stash, Git assumes the most recent stash:

$ git stash show -p | git apply -R

You may want to create an alias and effectively add a stash-unapply command to
your Git. For example:

$ git config --global alias.stash-unapply '!git stash show -p | git apply -R'
$ git stash apply
$ #... work work work
$ git stash-unapply

note: 
This works fine when there were no changes made since apply. Otherwise, git
emits conflict errors.


{drop}
Stash stack. To remove it, you can run git stash drop with the name of the
stash to remove:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log

$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)

You can also run git stash pop to apply the stash and then immediately drop it
from your stack.

Delete all of the stored stashes with:

$ git stash clear


{git-show-on-stash}

git show [<stash>]

Show the changes recorded in the stash as a diff between the stashed state and
its `original-parent`

When no <stash> is given, shows the latest one. By default, the command shows
the diffstat, but it will accept any format known to git diff. e.g., git stash
show -p stash@{1} to view the second most recent stash in patch form.

$ git stash show stash@{0}
 Polonium/Polonium.NexusInspect/Makefile.am                 |  2 +-
 Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c |  4 ++--
 Polonium/Polonium.NexusInspect/src/nexus-inspect.c         | 48 ++++++++-
 Polonium/Polonium.NexusInspect/src/nexus-inspect.h         | 26 +++++++++
 Polonium/Polonium.NexusInspect/src/nexus-release.c         | 24 +++++++++
 5 files changed, 61 insertions(+), 43 deletions(-)

$ git diff stash@{0} stash@{1}


{do-not-use-stash}
https://codingkilledthecat.wordpress.com/2012/04/27/git-stash-pop-considered-harmful/
Don't use stashing at all. One of Git's biggest strengths is that commits and
branches are cheap. Instead of creating stashes, why not just create a new
branch and commit your changes on it?

note: 
This fails when there are modified files from which stashed the work. Need to
clean working directory. So looks like a shortcut of branch and stash pop.
Better use branch in the first place.

note:
The stash show give me confusing picture and cost me a day to resolve due to
different result of diff. The problem is:

$ git diff stash@{0} 

Shows diff from stash@{0} to working directory. However:

$ git show stash@{0} or gitk stash@{0}

Shows difference from the parent where stash was made.


={============================================================================
*kt_dev_env_0000* git-ls-files git-ls-tree

<ls-files>

git-ls-files - Show information about files in the index and the working tree

git ls-files [OPTINS] [<file>...]

This merges the file listing in the directory cache index with the actual
working directory list, and shows different combinations of the two.

One or more of the options below may be used to determine the files shown:

-c
--cached
    Show cached files in the output (default)


<ls-tree>

git-ls-tree - List the contents of a tree object

Lists the contents of a given tree object, like what "/bin/ls -a" does in the
current working directory. 

Lists all the files being tracked by your git repo.

git ls-tree --full-tree -r HEAD


={============================================================================
*kt_dev_env_0000* git-add git-rm git-mv

{add-variants}

See differences between "add .", "add -u", "add -A".

add .  :  add untracked 'new' and tracked 'modified' file to the stage but
          'not' removed one.

add -u : add only tracked files.

add -A : is a handy shortcut for doing both.

<1> git add .
$ git add --ignore-removal . (has the same)

$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    modified:   change-me
#    deleted:    delete-me
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    add-me
no changes added to commit (use "git add" and/or "git commit -a")

$ git add .
warning: You ran 'git add' with neither '-A (--all)' or '--ignore-removal',
whose behaviour will change in Git 2.0 with respect to paths you removed.
Paths like 'delete-me' that are
removed from your working tree are ignored with this version of Git.

* 'git add --ignore-removal <pathspec>', which is the current default,
  ignores paths you removed from your working tree.

* 'git add --all <pathspec>' will let you also record the removals.

Run 'git status' to check the paths you removed from your working tree.


$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#    new file:   add-me
#    modified:   change-me
#
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    deleted:    delete-me
#

<2>
git add -u (for only tracked files)

$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    modified:   change-me
#    deleted:    delete-me
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    add-me
no changes added to commit (use "git add" and/or "git commit -a")

$ git add -u

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#    modified:   change-me
#    deleted:    delete-me
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    add-me


{add-patch}
-p
--patch

    Interactively choose hunks of patch between the index and the work tree
    and add them to the index. This gives the user a chance to review the
    difference before adding modified contents to the index.

    This effectively runs add --interactive, but bypasses the initial command
    menu and directly jumps to the patch subcommand. See “Interactive mode”
    for details.


{rm}
When accidentally staged it, like a large log file or a bunch of .a compiled
files. To do this, use the --cached option:

$ git rm --cached README


{mv}
If you want to rename a file in Git, you can run something like

$ git mv file_from file_to


={============================================================================
*kt_dev_env_git_000* git-clean

git-clean - Remove `untracked-files` from the working tree

Cleans the working tree by recursively removing files that are not under
version control, starting from the current directory.

<really>
Normally, only files unknown to git are removed, but if the -x option is
specified, `ignored files are also removed` This can, for example, be useful
to remove all build products.

       -d
           Remove untracked `directories` in addition to untracked files. If an
           untracked directory is managed by a different git repository, it is
           not removed by default. Use -f option twice if you really want to
           remove such a directory.

       -f, --force
           If the git configuration variable clean.requireForce is not set to
           false, git clean will refuse to run unless given -f or -n.

note:  -n, --dry-run
           Don't actually remove anything, just show what would be done.

       -x
           Don't use the standard ignore rules read from .gitignore (per
           directory) and $GIT_DIR/info/exclude, but do still use the ignore
           rules given with -e options. This allows removing all untracked
           files, including build products. This can be used (possibly in
           conjunction with git reset) to create a pristine working directory
           to test a clean build.

       -X
           Remove only files ignored by git. This may be useful to rebuild
           everything from scratch, but keep manually created files.

Cleaning also has a few other helpful options: if you want to perform a normal
clean and clear out all the files that git usually ignores, the -x flag will
help immensely. If you just want to trash the ignored files and nothing else,
     use the -X option.

The problem with using git is that it will nuke all the files it doesn't know
about. That might include log files, debug files, and in my case, Eclipse
project files as well...setting up .gitignore is a pain!

How to clean working dirs with having files manually created?

1) Can use .gitignore file and use -X.
2) Can use shell script.


={============================================================================
*kt_dev_env_0000* git-show

Shows one or more objects (blobs, trees, tags and commits).

For commits it shows the log message and textual diff. It also presents the
merge commit in a special format as produced by git diff-tree --cc.

For tags, it shows the tag message and the referenced objects.

For trees, it shows the names (equivalent to git ls-tree with --name-only).

For plain blobs, it shows the plain contents.

The command takes options applicable to the git diff-tree command to control how
the changes the commit introduces are shown.

This manual page describes only the most frequently used options.


{to-see-files}
To see files changed in a commit

$ git show --name-only {commit}

$ git show e433e8e
commit e433e8e2e5332becd98b82bda07986803580ecf2
Merge: acb2870 f8a541e
Author: xxxx
Date:   Tue Feb 17 09:08:44 2015 +0000

    Merge branch ...
    
    Conflicts:
       ...
       

={============================================================================
*kt_dev_env_0000* git-commit

git-commit - Record changes to the repository

DESCRIPTION

Stores the current contents of the index in a new commit along with a log
message from the user describing the changes.


$ git commit
[master 312e37a] Stroy 182: fix benchmarks for speed
 1 file changed, 1 insertion(+)

-v
--verbose

    Show unified diff between the HEAD commit and what would be committed at the
    bottom of the commit message template to help the user describe the commit
    by reminding what changes the commit has. Note that this diff output doesn't
    have its lines prefixed with #. This diff will not be a part of the commit
    message.

    If specified twice, show in addition the unified diff between what would be
    committed and the worktree files, i.e. the unstaged changes to tracked
    files.

$ git commit -v

-m <msg>
--message=<msg>

    Use the given <msg> as the commit message. If multiple -m options are given,
    their values are concatenated as separate paragraphs.

$ git commit -m "Stroy 182: fix benchmarks for speed"

<a-option>
the -a option to the git commit command makes Git automatically stage every file
that is already tracked 'before' doing the commit, letting you skip the git add
part:

-a
--all

    Tell the command to automatically stage files that have been modified and
    deleted, but new files you have not told Git about are not affected.

$ git commit -am 'added new benchmarks'


={============================================================================
*kt_dev_env_0000* git-commit-log

Next, try to make each commit a logically separate changeset. If you can, try to
make your changes digestible; don't code for a whole weekend on five different
issues and then submit them all as one massive commit on Monday.

So try to make things easier on your fellow developers when they have to review
your changes. This approach also makes it easier to pull out or revert one of
the changesets if you need to later.


{commit-message}
It's also a good idea to use the imperative present tense in these messages. In
other words, use commands.

<template>
Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary. Wrap it to about 72 characters or
so. In some contexts, the first line is treated as the subject of an email and
the rest of the text as the body.  The blank line separating the summary from
the body is critical (unless you omit the body entirely); tools like rebase can
get confused if you run the two together.

Further paragraphs come after blank lines.

- Bullet points are okay, too

- Typically a hyphen or asterisk is used for the bullet, preceded by a single
space, with blank lines in between, but conventions vary here

<from-git-project>
commit 51334bb094e085728ffe2b603fa3fe41dd80c075
Author: Luke Diamand <luke@diamand.org>
Date:   Sat Jan 17 20:56:38 2015 +0000

    git-p4: support excluding paths on sync
    
    The clone subcommand has long had support for excluding
    subdirectories, but sync has not. This is a nuisance,
    since as soon as you do a sync, any changed files that
    were initially excluded start showing up.
    
    Move the "exclude" command-line option into the parent
    class; the actual behavior was already present there so
    it simply had to be exposed.
    
    Signed-off-by: Luke Diamand <luke@diamand.org>
    Reviewed-by: Pete Wyckoff <pw@padd.com>
    Signed-off-by: Junio C Hamano <gitster@pobox.com>



={============================================================================
*kt_dev_env_0000* git-blame

Debugging with Git: File Annotation

If you track down a bug in your code and want to know when it was introduced and
why, file annotation is often your best tool. It shows you what commit was the
'last' to 'modify' each line of any file. So, if you see that a method in your
code is buggy, you can annotate the file with git blame to see when each line of
the method was last edited and by whom. This example uses the -L option to limit
the output to lines 12 through 22:


DESCRIPTION

Annotates each line in the given file with information from the revision which
last modified the line. Optionally, start annotating from the given revision.

When specified one or more times, -L restricts annotation to the requested
lines.

-L <start>,<end>
-L :<funcname>

    Annotate only the given line range. May be specified multiple times.
    Overlapping ranges are allowed.

    <start> and <end> are optional. “-L <start>” or “-L <start>,” spans from
    <start> to end of file. “-L ,<end>” spans from start of file to <end>.

The report does 'not' tell you anything about lines which have been deleted or
replaced; you need to use a tool such as git diff or the "pickaxe" interface
briefly mentioned in the following paragraph.


<ex>

$ git blame -L :gst_nexus_sink_on_error Polonium/Polonium.GSTNexus/src/gstnexussink.c

$ git blame -L 12,22 simplegit.rb
^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 12) def show(tree = 'master')
^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 13) command("git show #{tree}")
^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 14) end
^4832fe2 (Scott Chacon 2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 16) def log(tree = 'master')
79eaf55d (Scott Chacon 2008-04-06 10:15:08 -0700 17) command("git log #{tree}")
9f6560e4 (Scott Chacon 2008-03-17 21:52:20 -0700 18) end
...

Also note the ^4832fe2 commit lines, which designate that those lines were in
this file's original commit. That commit is when this file was first added to
this project, and those lines have been unchanged since. This is a tad
confusing, because now you've seen at least three different ways that Git uses
the ^ to modify a commit SHA-1, but that is what it means here.


{moved-or-removed} option -C

One of the interesting features of this is that you can ask it to figure out all
sorts of code movement as well. If you pass -C to git blame, Git analyzes the
file you're annotating and tries to figure out where snippets of code within it
'originally' came from if they were copied from elsewhere. For example, say you
are refactoring a file named GITServerHandler.m into multiple files, one of
which is GITPackUpload.m. By blaming GITPackUpload.m with the -C option, you can
see where sections of the code originally came from:

$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144) //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m (Scott 2009-03-24 146) NSString *parentSha;
ad11ac80 GITPackUpload.m (Scott 2009-03-24 147) GITCommit *commit = [g
ad11ac80 GITPackUpload.m (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m (Scott 2009-03-24 149) //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151) if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152) [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)

This is really useful. Normally, you get as the original commit the commit where
you copied the code over, because that is the first time you touched those lines
in this file. Git tells you the original commit where you wrote those lines,
   even if it was in another file.


={============================================================================
*kt_dev_env_0000* git-bisect

Annotating a file helps if you know where the issue is to begin with. If you
don't know what is breaking, and there have been dozens or hundreds of commits
since the last state where you know the code worked, you'll likely turn to git
bisect for help. The bisect command does a binary search through your commit
history to help you identify as quickly as possible which commit introduced an
issue.

You can bisect the code to find out. First you run git bisect start to get
things going, and then you use git bisect bad to tell the system that the
current commit you're on is broken. Then, you must tell bisect when the last
known good state was, using git bisect good [good_commit]:

$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo


<ex>
10:57:00 (topic) ~/source/DEVARCH$ git ll -15 topic WWI
* aa8e93d (WWI) DEVARCH-10586: Nickel.System.GStreamer: fix gstmediaroutertest test failure
note: bad. this is where it not works

* 1f08fe5 (origin/master) DEVARCH-10579: YV MediaRouter: Support HTTP 404 error for DASH play
* e9ad241 () DEVARCH-10577: Rubidium.Client.System: remove SystemClientLocator that is not used
* a27ca55 DEVARCH-10575: Add DBusPolicies to allow Zinc.DeviceManager.Identity access from sandbox5
* 10ab654 DEVARCH-10573: Rubidium.JsCore.Client.API: rename createDeviceManager to devicemanager
* f5c58b8 DEVARCH-10574: Implement Identity in the Rubidium Client
* 3cc3433 Rubidium.System: implement Identity system API for the STB
note: this is where is picked to start

* 29e6b41 () DEVARCH-9510: OIPF: Add application/oipfDrmAgent support
* 3e09b19 DEVARCH-10571: Vanadium.WebKit.VideoElement: Expose APIs for DRM error propagation
* 23b0fdb DEVARCH-10569: OIPF: Re-factor existing OIPF implementation (video/broadcast)
* 7c49a5f (tag: C27) DEVARCH-10495: Polonium.GstNexus: Support setting video window before READY state
* 99ac006 (HEAD, topic) DEVARCH-10459: Polonium.GstNexus: use a GstStructure for destination video window
* 5709787 () DEVARCH-9380: YV MediaRouter: Use consistent User-Agent header in HTTP requests
note: good. this is where it works

* c6f5b9b DEVARCH-10526: Nickel.System.GStreamer: change logging level from INFO to TRACE
* 08f47e9 () DEVARCH-10503: Forward "release" property from the tsnexusbin to nexussink
*
10:57:26 (topic) ~/source/DEVARCH$ git bisect start
10:58:12 (topic|BISECTING) ~/source/DEVARCH$ git bisect bad WWI
10:58:17 (topic|BISECTING) ~/source/DEVARCH$ git bisect good 5709787
Bisecting: 5 revisions left to test after this (roughly 3 steps)
[3cc343337cb16a0b2fa4719a491b8ab21650bc5b] Rubidium.System: implement Identity system API for the STB


Git figured out that about 12 commits came between the commit you marked as the
last good commit (v1.0) and the current bad version, and it checked out the
middle one for you. At this point, you can run your 'test' to see if the issue
exists as of this commit. If it does, then it was introduced sometime before
this middle commit; if it doesn't, then the problem was introduced sometime
after the middle commit. It turns out there is no issue here, and you 'tell' Git
that by typing git bisect good and 'continue' your journey:

$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing

Now you're on another commit, halfway between the one you just tested and your
bad commit. You run your test again and find that this commit is broken, so you
tell Git that with git bisect bad:

$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table

This commit is fine, and now Git has all the information it needs to determine
where the issue was introduced. It tells you the SHA-1 of the first bad commit
and show some of the commit information and which files were modified in that
commit so you can figure out what happened that may have introduced this bug:

$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config

When you're finished, you should run git bisect reset to reset your HEAD to
where you were before you started, or you'll end up in a weird state:

$ git bisect reset

This is a powerful tool that can help you check hundreds of commits for an
introduced bug in minutes. In fact, if you have a script that will exit 0 if the
project is good or non-0 if the project is bad, you can fully automate git
bisect. First, you again tell it the scope of the bisect by providing the known
bad and good commits. You can do this by listing them with the bisect start
command if you want, listing the known bad commit first and the known good
commit second:

$ git bisect start HEAD v1.0
$ git bisect run test-error.sh

Doing so automatically runs test-error.sh on each checked-out commit until Git
finds the first broken commit. You can also run something like make or make
tests or whatever you have that runs automated tests for you.


={============================================================================
*kt_dev_env_git_000* git-rev-parse

git-rev-parse - Pick out and massage parameters

SYNOPSIS

git rev-parse [ --option ] <args>...

DESCRIPTION

Many Git porcelainish commands take mixture of flags (i.e. parameters that begin
    with a dash -) and parameters meant for the underlying git rev-list command
they use internally and flags and parameters for the other commands they use
downstream of git rev-list. This command is used to distinguish between them.

<from-SO>
git rev-parse is an ancillary plumbing command primarily used for manipulation.

One common usage of git rev-parse is to print the SHA1 hashes given a revision
specifier. In addition, it has various options to format this output such as
--short for printing a shorter unique SHA1.

There are other use cases as well (in scripts and other tools built on top of
    git) that I've used for:

    --verify to verify that the specified object is a valid git object.

    --git-dir for displaying the abs/relative path of the the .git directory.

    Checking if you're currently within a repository using --is-inside-git-dir
    or within a work-tree using --is-inside-work-tree

    Checking if the repo is a bare using --is-bare-repository

    Printing SHA1 hashes of branches (--branches), tags (--tags) and the refs
    can also be filtered based on the remote (using --remote)

    --parse-opt to normalize arguments in a script (kind of similar to getopt)
    and print an output string that can be used with eval

Massage just implies that it is possible to convert the info from one form into
another i.e. a transformation command. These are some quick examples I can think
of:

    a branch or tag name into the commit's SHA1 it is pointing to so that it can
    be passed to a plumbing command which only accepts SHA1 values for the
    commit.

    a revision range A..B for git log or git diff into the equivalent arguments
    for the underlying plumbing command as B ^A


<ex>
--show-toplevel
    Show the absolute path of the top-level directory.

--git-dir
    Show $GIT_DIR if defined. Otherwise show the path to the .git directory. The
    path shown, when relative, is relative to the current working directory.

    If $GIT_DIR is not defined and the current directory is not detected to lie
    in a Git repository or work tree print a message to stderr and exit with
    nonzero status.

dir="`git rev-parse --git-dir`"


<ex>
Get SHA of HEAD.

git rev-parse HEAD


={============================================================================
*kt_dev_env_0000* git-fe-gitk

gitk [<options>] [<revision range>] [\--] [<path>...]

$ gitk --all &
--all
    Show all refs (branches, tags, etc.).

The yellow dot next to the top commit indicates that is the snapshot currently
in my working folder (referred to as HEAD) 

<reload>
http://gitolite.com/gitk.html#bcpc
If you're doing stuff on the command line in another screen, and want those changes reflected in
gitk, hit F5(update).

F5 updates the refs and shows you their new values while still showing you the old ones. It is most
useful after operations like rebase, because you can compare the previous branch head with the new
one.

Shift-F5, on the other hand, is a total reload, throwing away everything that was previously shown.

<diff>
At any time, the bottom left pane shows a "diff", usually of the current commit shown in the top
pane. The bottom right pane (by default) shows a list of files in this "diff".

spacebar: move forward 1 page in the diff view
backspace/delete: ditto, but backward
"f": move to next file in the diff. Both the bottom left and right panes will show a change when you do this.
"b": ditto, but previous file
click a file in the bottom right pane: scrolls the left pane to show that file's changes

5.1 running a diff between two arbitrary commits

left click on the "new" commit
navigate using the scrollbar (no keyboard shortcut, AFAICT) to some other commit
right-click and choose "Diff this -> selected"

Now you can browse that diff using the keyboard or mouse. Note that any movement that selects a
different commit (like pressing an arrow key) will change the view to show that commit, so while
examining this "diff", stick to these keys.


<to-see-commits-only>
$ gitk -- path

Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect
to revision names use "--" to separate the paths from any preceding options.

<to-see-branch>
$ gitk branch


={============================================================================
*kt_dev_env_0000* git-work-model

{centralized}
In centralized systems, there is generally a single collaboration model-the
centralized workflow. One central hub, or repository, can accept code, and
everyone synchronizes their work to it. A number of developers are nodes -
consumers of that hub - and synchronize to that one place.

This means that if two developers clone from the hub and both make changes, the
first developer to push their changes back up can do so with no problems. The
second developer must merge in the first one's work before pushing changes up,
       so as not to overwrite the first developer's changes. This concept is as
       true in Git as it is in Subversion (or any CVCS), and this model works
       perfectly well in Git.

Git won't let users overwrite each other. note: push conflict. She is told that
she's trying to push non-fast-forward changes and that she won't be able to do
so until she fetches and merges.


{integration-manager} github
A workflow where each developer has write access to their own public repository
and read access to everyone else's. This scenario often includes a canonical
repository that represents the "official" project. To contribute to that
project, you create your own public clone of the project and push your changes
to it. Then, you can send a request to the maintainer of the main project to
pull in your changes. The maintainer can then add your repository as a remote,
     test your changes locally, merge them into their branch, and push back to
     their repository.

This is a very common workflow with hub-based tools like GitHub or GitLab.

One of the main advantages of this approach is that you can continue to work,
    and the maintainer of the main repository can pull in your changes at any
    time. Contributors don't have to wait for the project to incorporate their
    changes - each party can work at their own pace.

Many groups switch to Git because of this ability to have multiple teams working
in parallel, merging the different lines of work late in the process. The
ability of smaller subgroups of a team to collaborate via remote branches
without necessarily having to involve or impede the entire team is a huge
benefit of Git. 


{dictator-and-lieutenants}
This is a variant of a multiple-repository workflow. It's generally used by huge
projects with hundreds of collaborators; one famous example is the Linux kernel.

Various integration managers are in charge of certain parts of the repository;
they're called lieutenants. All the lieutenants have one integration manager
known as the benevolent dictator.

This kind of workflow isn't common, but can be useful in very big projects, or
in highly hierarchical environments.


={============================================================================
*kt_dev_env_0000* git-work-flow

A good work flow:

JIRATICKET=<JIRA Ticket no>

git pull --rebase # update to master

git checkout -b $JIRATICKET # You did create a JIRA ticket, didn't you?

<do your coding>

git rebase --onto master # Someone else might have changed something

zg-pushwhat # review commit messages

<create-pr> push a local branch to origin to create a PR

// to see what actually will happen
git push -n origin $JIRATICKET:review/$JIRATICKET 

// You need the branch to create the pull request
git push origin $JIRATICKET:review/$JIRATICKET

// Create pull request on Stash (see bottom of page).
// receive feedback

// Update a PR in stash
// to see what actually will happen
git push -nf $JIRATICKET:review/$JIRATICKET 

// Force push updates the PR in stash
git push -f $JIRATICKET:review/$JIRATICKET 

// Push to master
git push -nf origin review/$JIRATICKET:master

// Update master
git co master
git pull --rebase origin master 

// Merge PR. Merge master into your PR to merge
git push -f origin master:review/$JIRATICKET 


={============================================================================
*kt_dev_env_0000* git-remote

Manage the set of repositories ("remotes") whose branches you track.

{git-remote}

$ git remote show origin
* remote origin
  URL: git://github.com/schacon/ticgit.git
  Remote branch merged with 'git pull' while on branch master
    master
  Tracked remote branches
    master
    ticgit


<list>
$ git remote -v
bakkdoor  git://github.com/bakkdoor/grit.git
origin    git@github.com:mojombo/grit.git          // means SSH url


{add-delete-rename-remotes}
The shortname is reference to remote.

$ git remote add [shortname] [url]:
$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin  git://github.com/schacon/ticgit.git
pb  git://github.com/paulboone/ticgit.git

$ git remote rename pb paul

$ git remote rm paul


{remote-and-local-master}
The clone command automatically add shortname and sets up your local master
branch to track the remote master branch or whatever the default branch is
called on the server you cloned from. That is it creates origin/master.

note:
`origin` is not a branch but a name(shortname) of a `remote-repository`

origin/master  : remote master (branch)
master         : local master (branch)


note: 
remote branch can be any including remote master and is local branch.

The remote branches act as bookmarks to remind you where the branches on your
remote repositories were the 'last' time you connected to them. They take the
form "remote/branch" and remote branch is also 'local' branch but to 'point' to
remote.


After clone, your local git looks:

         <origin/master> # remote branch
c1 c2 c3 c4
         <msater>        # local branch


note: remote branch is not updated automatically

In the meantime, someone else pushes to git.ourcompany.com and updates its
master branch, then your histories move forward differently. Also, as long as
you stay out of contact with your origin server, your origin/master pointer
doesn't move.

Remote:
c1 c2 c3 c4 c5 c6 c7 c8
                     <msater>

Local:
         <origin/master>            # remote master branch which is still on c4
c1 c2 c3 c4 c9 c10 c11 
                   <msater>         # local master branch


note: fetch updates remote branch

You run a `fetch-origin`. This command looks up which server origin is and
fetches any data from it that you don't 'yet' have, and updates your local
database, moving your origin/master pointer to its new, more up-to-date
position.

$ git fetch origin

Local:
                     <origin/master>   # remote branch
            c5 c6 c7 c8
c1 c2 c3 c4 c8 c9 c10 c11
                      <msater>         # local branch


<branch-head-and-detached-head>
`HEAD` is used by your repository to define what is currently checked out:

* If you checkout a branch, head symbolically refers to that branch, indicating
  that the branch name should be updated after the next commit operation.

* If you checkout a specific commit, HEAD refers to that commit only. This is
  referred to as a `detached-head` and occurs, for example, if you check out a tag
  name.


={============================================================================
*kt_dev_env_0000* git-remote-change

<set-url>

    Changes URLs for the remote. Sets first URL for remote <name> that matches
    regex <oldurl> (first URL if no <oldurl> is given) to <newurl>. If <oldurl>
    doesn't match any URL, an error occurs and nothing is changed.

// View the upstream/remote name

git remote show

// Assuming your upstream is known as "origin", you can view the old upstream
// URL by the following command. This shows the "url" in the config.

git config remote.origin.url
ssh://git@stash.dev.youview.co.uk/tvos/devarch.git


// git clone ssh://git@stash.dev.youview.co.uk/tvos/devarch.git DEVARCH

// Assuming your upstream is known as "origin", change to new Stash URL

git remote set-url origin ssh://git@stash.dev.co.uk/tvos/zinc-git-tools.git

// View the new URL
git config remote.origin.url

[remote "origin"]
fetch = +refs/heads/*:refs/remotes/origin/*
url = ssh://jongwoo.chae@168.219.241.167:29418/training1

The remote configuration is achieved using the remote.origin.url and
remote.origin.fetch configuration variables. (See git-config[1]).

<possible-error>
error: some local refs could not be updated; try running
 'git remote prune origin' to remove any old, conflicting branches


={============================================================================
*kt_dev_env_git_000* git-fetch

To sum, git-fetch update origin/master

DESCRIPTION

Fetch branches and/or tags (collectively, "refs") from one or more other
repositories, along with the objects necessary to complete their histories.

Remote-tracking branches are 'updated' (see the description of <refspec> below
    for ways to control this behavior).

When no remote is specified, by default the origin remote will be used, unless
there's an upstream branch configured for the current branch.


To get data from your remote projects, pulls down all the data from that remote
that you do not have yet. After that, you can merge in or inspect. 

$ git fetch origin
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (14/14), done.
remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15/15), done.
From git@github.com:schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix


<fetch-inspect>
Fetches all the changesets to your local remote repository and means you can now
refer to the changes as "origin/master" you can operate on it with any 'local'
branch. Inspect them and merge to your branch that you are currently on.

$ git fetch origin                     // get the latest from remote

$ git diff master origin/master        // diff local master and remote
$ git log master..origin/master        // diff local master and remote

$ git merge origin/master              // merge remote into local master


<ex>
Fetch selectively?

git fetch origin refs/tags/ee_master_fast_track_*:refs/tags/ee_master_fast_track_*


={============================================================================
*kt_dev_env_0000* git-pull 

If you have a branch set up to track a remote branch, you can use the git pull
command to automatically 'fetch' and then 'merge' a remote branch into your
'current' branch. 

$ git pull
$ git pull origin master
$ git pull origin <branch-name-you-want-to-pull>

note: 
Generally it's better to simply use the fetch and merge commands explicitly as
the magic of git pull can often be confusing.


{merge}
The fetch brings down new remote branches, you don't automatically have local,
editable copies of them. In other words, in this case, you don't have a new
serverfix branch but you only have an origin/serverfix pointer that you can't
modify.

<1>
To merge this work into your 'current' working branch, you can run:

$ git merge origin/serverfix

OR

<2>
To create a seperate serverfix branch(local) that track remote and you can work
on, you can base it off your remote branch:

$ git checkout -b serverfix origin/serverfix

Two things: 
'branch' serverfix set up to track remote branch refs/remotes/origin/serverfix. 

'switched' to a new branch "serverfix" That is -b means to create a local branch
and switch to it.


={============================================================================
*kt_dev_env_0000* git-pull-conflict

{remote-use-scenario}
From home(user one), commited changes to the file. From office(user two), have that file staged
which has changes made before changes made from home. So the user two is out of sync since it is
based on the commit which is now old.

So when uesr two tried 'pull' and then:

:~/keitee/kb$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 1 (delta 0)
Unpacking objects: 100% (3/3), done.
From github.com:keitee/kb
   d07bb38..c5e2a81  master     -> origin/master
Updating d07bb38..c5e2a81
error: Your local changes to the following files would be overwritten by merge:~
	kt_dev_02.txt
Please, commit your changes or stash them before you can merge.~
Aborting

:~/keitee/kb$ git status
# On branch master
# Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. ~
#   (use "git pull" to update your local branch)
#
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   kt_dev_01.txt
#	modified:   kt_dev_02.txt
#	modified:   kt_dev_env.txt
#	modified:   kt_linux.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#

Made a commit as suggested and then it updated a local repository. By doing pull, do merger to sync
between local and remote. This is safe since git said it is fast forward.

:~/keitee/kb$ git pull
Auto-merging kt_dev_02.txt
(git runs vim to log why merge happens)
Merge made by the 'recursive' strategy.
 kt_dev_02.txt | 280 ++++++++++++++++++++++++++++++++++++++------------------------------
 1 file changed, 153 insertions(+), 127 deletions(-)


={============================================================================
*kt_dev_env_0000* git-pull-rebase

git pull [options] [<repository> [<refspec>...]]

DESCRIPTION

Incorporates changes from a remote repository into the current branch. In its
default mode, git pull is shorthand for git fetch followed by git merge
FETCH_HEAD.

More precisely, git pull runs git fetch with the given parameters and calls
git merge to merge the retrieved branch heads 'into' the current branch. With
--rebase, it runs git rebase 'instead' of git merge.

note:
This is why git-pull page has "Options related to merging".

<repository> should be the name of a remote repository as passed to
git-fetch[1]. <refspec> can name an arbitrary remote ref (for example, the name
    of a tag) but usually it is the name of a branch in the remote repository.

Default values for <repository> and <branch> are read from the "remote" and
"merge" configuration for the current branch as set by git-branch[1] --track


From CH03 Rebase when you rebase.

{peril-of-rebase}
If you pull, create a merge commit. Furthermore, push this back up to the
server, will 'reintroduce' all commits which are dropped and can further confuse
people. This is a problem in figure 3-39.

The advise: Do 'not' rebase commits that you have pushed to a public repository.

When you rebase stuff, you're 'abandoning' existing commits and creating new
ones that are similar but 'different'. If you push commits somewhere and others
pull them down and base work on them, and then you rewrite those commits with
git rebase and push them up again. 
     
THEN your collaborators will have to re-merge their work and things will get
'messy' when you try to pull their work back into yours.

For example, fetch and merge the new remote branch into your work, making your
history look something like this:

local:

C1  <- teamone/master
    \            
      C2  -   C3 <- master

To figure 3-37

remote: 

      C5   
   /      \
C1 <- C4 <- C6    <- master

local:

      C5  
    /    \
C1  - C4  -   C6   <- teamone/master
    \            \
      C2  -   C3  -  C7    <- master

the person who pushed the merged work decides to go back and rebase their work
instead; they do a git push --force to 'overwrite' the history on the server.
You then fetch from that server, bringing down the new commits.

figure 3-38

remote: 

C1 <- C5   <- C4' <- master
          \
     (C4) <- (C6)          // (these) are no longer available

local:

      C5  -   C4'          <- teamone/master
    /    \
C1  - C4  -   C6
    \            \
      C2  -   C3  -  C7    <- master

Now you're both in a pickle. If you do a "git pull", you'll create a merge
commit which includes both lines of history due to C4'. 

note: two lines to C4' and C6. C6 line is supposed to be gone. 

If you run a git log when your history looks like this, you'll see two commits
that have the same author, date, and message, which will be confusing.

Furthermore, if you push this history back up to the server, you'll reintroduce
all those rebased commits to the central server, which can further confuse
people. It's pretty safe to assume that the other developer doesn't want C4 and
C6 to be in the history; that's why she rebased in the first place.


{pull-rebase}
Git has some further magic that might help you out. If someone on your team
force pushes changes that overwrite work that you've based work on, your
challenge is to *figure out* what is yours and what they've rewritten.

Git can often successfully figure out what is 'uniquely' yours and apply them
back on top of the new branch. For instance, in the previous scenario, if
instead of doing a merge, 

If you run followings (rebase master onto teamone/master) then git figure out
'unique' commits which have not been rewritten into the target branch and apply
them.

git checkout master
git fetch                   // update remote master, teamone/master
git rebase teamone/master   // rebase to teamone/master

remote: 

C1 <- C5   <- C4' <- master
          \
     (C4) <- (C6)      # these are no longer available

local:

      C5  -   C4'          <- teamone/master
    /    \
C1  - C4  -   C6
    \            \
      C2  -   C3  -  C7    <- master

local:

         teamone/master
               |
C1  - C5  -   C4' -  C2'  -   C3'  <- master

git checkout teamone/master
git merge master

                                      teamone/master
C1  - C5  -   C4' -  C2'  -   C3'  <- master

note:
After all, this commands get all updates since the last update, update and move
remote master. Then replay changes from master.


{pull-rebase}
For the same example above, can also simplify this by running a git pull
--rebase.

git checkout master
git fetch                   // update remote master, teamone/master
git rebase teamone/master   // = git rebase teamone/master master


git checkout master         // 'suppose' that master is tracking "remote/master"
git pull --rebase           // on master and replay onto remote/master
                                 
         remote/master
               |
C1  - C5  -   C4' -  C2'  -   C3'  <- master

If you treat rebasing as a way to clean up and work with commits 'before' you
push them, and if you only rebase commits that have 'never' been available
publicly, then you'll be fine. 


<rebase-when-specify-tracking-branch>
note: "origin" is repository

git pull --rebase origin master


<why-pull-rebase>
Rebasing is a common way to integrate upstream changes into your local
repository. Pulling in upstream changes with git merge results in a
superfluous merge commit every time you want to see how the project has
progressed. 

On the other hand, rebasing is like saying, "want to base (have) my changes
'on' what everybody has already done."

<pull-rebase-config>
If you are using git pull and want to make --rebase the default, you can set
the pull.rebase config value with something like 

git config --global pull.rebase true.

// .gitconfig
[pull]
  rebase = true


{rebase-workflow}
1. Suppose that clone a remote and make a branch to work

-------------------- origin/master
-------------------- master
-------------------- branch


2. The remote udpated by other team members while working on branch.

---------------------------------------- remote/master
-------------------- origin/master
-------------------- master
-------------------- C1 C2 C3 C4 branch


3. Finishes the work and want to base the work on the latest to make sure that
the work do not break or conflict with commits that others already made.


Q: How to base branch on the latest and to verify that the work do not break?


4. Update master and assume no changes on master

---------------------------------------- remote/master
-------------------- origin/master
-------------------- master
-------------------- C1 C2 C3 C4 branch

git checkout branch
git fetch 
git rebase origin/master

or

git checkout branch
git pull --rebase

---------------------------------------- remote/master
-------------------- origin/master
-------------------- master
---------------------------------------- C1 C2 C3 C4 branch


={============================================================================
*kt_dev_env_0000* git-push-refspec

Your local branches aren't automatically synchronized to the remotes you write
to - you have to explicitly push the branches you want to share. That way, you
can use private branches for work you don't want to share, and push up only the
topic branches you want to collaborate on.

To push it upstream.

$ git checkout 

$ // change and make commits

$ git push [remote-name] [branch-name]
$ git push [-all] [<repository> [<refspec>...]]
$ git push origin master

<to-mster>
// can use push-as-different-name to push directly from a local branch
$ git push origin local-branch:master

Or to push a local branch which isn't in the remote

The remote (local) branch is automatically created when you 'push' it to the
remote server:

This command works only if you cloned from a server to which you have 'write'
access and if 'nobody' has pushed in the meantime. If you and someone else clone
at the same time and they push upstream and then you push upstream, your push
will rightly be 'rejected'. You'll have to pull down their work first and
incorporate it into yours before you'll be allowed to push. 


{refspec}
Specify what destination ref to update with what source object. The format of a
<refspec> parameter is an optional plus +, followed by the source object <src>,
  followed by a colon :, followed by the destination ref <dst>.

The <src> is often the name of the branch you would want to push, but it can be
any arbitrary "SHA-1 expression", such as master~4 or HEAD (see
    gitrevisions[7]).

The <dst> tells which ref on the remote side is updated with this push.
Arbitrary expressions cannot be used here, an actual ref must be named. If git
push [<repository>] without any <refspec> argument is set to update some ref at
the destination with <src> with remote.<repository>.push configuration variable,
    :<dst> part can be omitted---such a push will update a ref that <src>
    normally updates without any <refspec> on the command line. Otherwise,
    missing :<dst> means to update the 'same' ref as the <src>.

The object referenced by <src> is used to update the <dst> reference on the
remote side. By default this is only allowed if <dst> is not a tag (annotated or
    lightweight), and then only if it can fast-forward <dst>. By having the
optional leading +, you can tell Git to update the <dst> ref even if it is not
allowed by default (e.g., it is not a fast-forward.) This does not attempt to
merge <src> into <dst>. See EXAMPLES below for details.

tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>.


<delete-remote-branch>
this is why the below delete remote branch

$ git push origin :review/DEVARCH-10262

Pushing an empty <src> allows you to delete the <dst> ref from the remote
repository.

The special refspec : (or +: to allow non-fast-forward updates) directs Git to
push "matching" branches: for every branch that exists on the local side, the
remote side is updated if a branch of the same name already exists on the remote
side.


workflow
--------
Since the first developer has already pushed, the second isn't allowed to push
because the first has pushed in the meantime.

Although Subversion automatically does such a merge on the server if 'different'
files are edited, in Git you must merge the commits locally. The second has to
fetch the first's changes and merge them in before he will be allowed to push. 

note: this is true even if it is different file.

Got push rejected and do fetch. Then the first's repo looks like:

                        master
CP    <-    C2    <-    C3
                  <-    C4
                        origin/master

$ git checkout master

Update local master with the remote and may happen merge conflict.

$ git merge origin/master          // C5 merge commit 

                                 master
CP    <-    C2    <-    C3    <- C5
                  <-    C4    <-
                        origin/master

The first test his code, commit them and then can push "master" branch to the
remote:

$ git push origin master

                                 master
CP    <-    C2    <-    C3    <- C5
                  <-    C4    <-
                                 origin/master

In the meantime, the second has been working on a topic branch. She's created a
topic branch called issue54 and done three commits on that branch. She hasn't
fetched John's changes yet, so her commit history looks like this:

                  master                           issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                  origin/master

To sync up, she run:

$ git fetch origin

The second's reop looks like:

                  master                           issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                     \  
                  C3    <-    C5                   # C5 points both C4 and C3
                              origin/master


{sync-check-push} determine what is introduced in the remote
The second thinks her topic branch is ready, but she wants to know 'what' she has to merge into her
work so that she can push. She runs git log to find out:

$ git log --no-merges issue54..origin/master       # commits on origin/master but not on issue54

commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
...

Knows that there is one commit to merge.

$ git checkout master

She can merge either origin/master or issue54 first; they're both upstream, so the order doesn't
matter. The end snapshot should be identical no matter which order she chooses; only the history
will be slightly different. She chooses to merge in issue54 first:

$ git merge issue54

No problem since it is FF merge. Now merge in the first's work:

$ git merge origin/master

                                                   issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                     \                                \ master
               <- C3    <-    C5                 <-   C11 
                              origin/master

This is merge with diverge so creates a merge commit, C11.

Now origin/master is 'reachable' from the first's master branch, so she should be able to successfully
push (assuming the first hasn't pushed again in the meantime): 
  
note: reachable means that master becomes upstream of origin/master.

$ git push origin master

                                                   issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                     \                                \ master
               <- C3    <-    C5                 <-   C11 
                                                        origin/master


{when-use-working-branch}

--ff-only
Refuse to merge and exit with a non-zero status unless the current HEAD is already up-to-date or the
merge can be resolved as a fast-forward.

--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge
commit. This is the 'default' behavior.

$ git checkout master
$ git merge --ff-only <review branch>
$ git push origin master


{set-tracking-when-push} when use a local branch that do not come from the remote
-u, --set-upstream
For every branch that is up to date or successfully pushed, add upstream
(tracking) reference, used by argument-less git-pull(1) and other commands. For
more information, see branch.<name>.merge in git-config(1).

$ git push -u origin 14base


<when-push-rejected>
Suppose that already pushed the commit and wanted to change its message. Used --amend and changed
message. When tried to push it again to remote, this will be rejected.

How to solve?

1. If it is safe to push it such as its review purpose so no one is based off, then can use

git push --force or -f origin master

2. Can make a proper commit and push it. However, want to change only message? Is there any way to
make a commit with only message? Use

git commit --allow-empty

This opens an editor to have message and a new commit which has no difference with the parent but
has new message. 


<push-default>
When the command line does not specify where to push with the <repository> argument, it defaults to
origin.

When the command line does not specify what to push with <refspec>... arguments or --all, --mirror,
     --tags options, the command finds the default <refspec> by consulting remote.*.push
     configuration, and if it is not found, honors push.default configuration to decide what to push
     for the meaning of push.default).


push.default

Defines the action git push should take if no refspec is explicitly given. Different values are
well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch
        source is equal to the push destination), upstream is probably what you want. Possible
values are:

o current - push the current branch to update a branch with the same name on the receiving end.
Works in both central and non-central workflows.

o simple - in centralized workflow, work like upstream with an added safety to refuse to push if the
upstream branch's name is different from the local one.

When pushing to a remote that is different from the remote you normally pull from, work as current.
This is the safest option and is suited for beginners.

This mode has become the default in Git 2.0.

git config --global push.default current


{push-as-different-name}
This is a bit of a shortcut. Git automatically expands the serverfix branchname
out to refs/heads/serverfix:refs/heads/serverfix, which means, "Take my
serverfix local branch and push it to update the remote's serverfix branch."

So this means the same thing:

$ git push origin serverfix
$ git push origin serverfix: serverfix

This push a branch as a differnt name:

$ git push origin serverfix:awesomebranch

The next time one of your collaborators fetches from the server, they will get a
reference to where the server's version of serverfix is under the remote branch
origin/serverfix:

<ex>
Use to collaboration using topic branch.

There is a bit of a problem - she needs to push the merged work in her featureB
branch to the featureBee branch on the server. She can do so by specifying the
local branch followed by a colon (:) followed by the remote branch to the git
push command:

$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
fba9af8..cd685d1 featureB -> featureBee

note: why? since the other has already pushed the branch to a server for a issue or task that works
together but I have worked on different branch, so maps them.

This is called a refspec. See "The Refspec" for a more detailed discussion of Git refspecs and
different things you can do with them.


{push-dry}
-n
--dry-run
    Do everything except actually send the updates.

$ git push -n origin kit/DEVARCH-10262:review/DEVARCH-10262
***************************************************************************
NOTICE TO USERS

...
***************************************************************************
To gitolite@git-dev:/DEVARCH
 * [new branch]      kit/DEVARCH-10262 -> review/DEVARCH-10262
 *
$ git push origin kit/DEVARCH-10262:review/DEVARCH-10262
***************************************************************************
NOTICE TO USERS

...
***************************************************************************
Counting objects: 13, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (13/13), 9.53 KiB | 0 bytes/s, done.
Total 13 (delta 11), reused 0 (delta 0)
To gitolite@git-dev:/DEVARCH
 * [new branch]      kit/DEVARCH-10262 -> review/DEVARCH-10262
 

={============================================================================
*kt_dev_env_0000* git-push-errors-bare

<push-errors-01>
kit@kit-vb:~/mheg-remote-git/mag/mheg$ git push
Counting objects: 19, done.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (11/11), 3.44 KiB | 0 bytes/s, done.
Total 11 (delta 8), reused 0 (delta 0)
remote: error: refusing to update checked out branch: refs/heads/master
remote: error: By default, updating the current branch in a non-bare repository
remote: error: is denied, because it will make the index and work tree inconsistent
remote: error: with what you pushed, and will require 'git reset --hard' to match
remote: error: the work tree to HEAD.
remote: error: 
remote: error: You can set 'receive.denyCurrentBranch' configuration variable to
remote: error: 'ignore' or 'warn' in the remote repository to allow pushing into
remote: error: its current branch; however, this is not recommended unless you
remote: error: arranged to update its work tree to match what you pushed in some
remote: error: other way.
remote: error: 
remote: error: To squelch this message and still keep the default behaviour, set
remote: error: 'receive.denyCurrentBranch' configuration variable to 'refuse'.
To keitee.park@magnum:/dsk1/git/tizen-mheg.git
 ! [remote rejected] master -> master (branch is currently checked out)
error: failed to push some refs to 'keitee.park@magnum:/dsk1/git/tizen-mheg.git'

kit@kit-vb:~/mheg-remote-git/mag/mheg$ git remote -v
origin keitee.park@magnum:/dsk1/git/tizen-mheg.git (fetch)
origin keitee.park@magnum:/dsk1/git/tizen-mheg.git (push)

kit@kit-vb:~/mheg-remote-git/mag/mheg$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

kit@kit-vb:~/mheg-remote-git/mag/mheg$ git remote show origin 
* remote origin
  Fetch URL: keitee.park@magnum:/dsk1/git/tizen-mheg.git
  Push  URL: keitee.park@magnum:/dsk1/git/tizen-mheg.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (fast-forwardable)
kit@kit-vb:~/mheg-remote-git/mag/mheg$ 


Why this happen?

<bare-and-non-bare>
http://bitflop.com/document/111

Git bare vs. non-bare repositories

Posted by: Kim N. Lesmer on 09.10.2010

The Git revision control system has something called a "bare" and a "non-bare" repository. This
article deals with the issue and also compares the Git design to the design of Mercurial and Bazaar.

NB! The article isn't relevant to Git prior to version 1.7.0.

The other day I was working with Git and I got the following error after having tried to push some
changes back to a remote repository that I had created.

remote: error: refusing to update checked out branch: refs/heads/master
remote: error: By default, updating the current branch in a non-bare repository
remote: error: is denied, because it will make the index and work tree inconsistent
remote: error: with what you pushed, and will require 'git reset --hard' to match
remote: error: the work tree to HEAD.
remote: error:
remote: error: You can set 'receive.denyCurrentBranch' configuration variable to
remote: error: 'ignore' or 'warn' in the remote repository to allow pushing into
remote: error: its current branch; however, this is not recommended unless you
remote: error: arranged to update its work tree to match what you pushed in some
remote: error: other way.
remote: error:
remote: error: To squelch this message and still keep the default behaviour, set
remote: error: 'receive.denyCurrentBranch' configuration variable to 'refuse'.

I didn't understand this error and being used to how Mercurial works, this didn't make any sense, so
I did some diggin.

In the ideal world of distributed revision control there is no central repository. People just pull
from whomever they want changes from and no pushes exist. That is actually how the Linux Kernel is
being developed.

In the real world a central repository with push access is sometimes necessary and all the different
distributed revision control systems allows this, but the way they deal with a push are very
different.

In a distributed revision control system you work with a local repository that contains 'both' the
working tree and the revision history.

In Git you can create such a repository with the following command:

$ mkdir my_repo
$ cd my_repo
$ git init

In all three example the working tree resides in the directory itself and the revision history and
system files resides in a hidden sub-directory. People then normally pull changes from eachother.

In Git the hidden sub-directory is called .git, in Bazaar it is called .bzr, and in Mercurial it is
called .hg.

In Mercurial and Bazaar when you initialize a repository it can serve as a remote repository by
default, and anyone with write access to the repository can push changes into it.

In Git that's not possible unless the repository is initialized as a "bare" repository.

<bare-and-non-bare>
A "bare" repository in Git just contains the version control information and no working files (no
    tree) and it doesn't contain the special .git sub-directory. Instead, it contains all the
contents of the .git sub-directory directly in the main directory itself.

A "non-bare" repository in Git is the same as the normal repository in Mercurial and Bazaar. It has
a bunch of working files (the tree), and a hidden directory containing the version control
information.

In Git (from version 1.7.0 and above) the repository has to be "bare" (no working files) in order to
accept a push.

From a technical point of view you can (in theory) push and pull between repositories whether they
are "bare" or not. Git has an index, which basically tells it what the head of the current branch
looks like. If you push to a "non-bare" repository, Git will look at the working files, compare them
to the index, and see that they differ - so it will think that the working files have changed.

"bare" repositories exist in Git as a way of having a central (mainly remote) repository that a
number of people can push to. If you want to transfer changes from a "non-bare" repository to
another, the correct way is to pull from the destination rather than push from the target.

In Git you should only use a "bare" repository to clone and pull from, and push to. It doesn't have
a checked out tree, so it just does what the "server" notionally does in a centralized VCS - records
commits, branches, etc when you push to it, and gives you the latest versions when you clone or pull
from it.

In Mercurial any repository can serve as a remote repository as mentioned, but push changes only
affects the version control and not the working tree unless someone physically access the remote
repository (making it local from his or hers perspective) and updates the tree manually.

So in Git a push isn't possible unless the repository is "bare" (no working files) and in Mercurial
a push is only affecting the version control (not any working files).

In Bazaar on the other hand any repository can serve as a remote repository, and any push changes
also affects the working tree.

From a distributed technical point of view IMHO the Bazaar system is poorly designed and the way
both Git and Mercurial addresses the issue is much safer.

In Git and Mercurial a repository with a working tree is expected to contain files that someone is
working on. It isn't looked upon as a remote repository, but as a local distributed repository no
matter where it resides physically. And this makes perfect sense from a distributed point of view.

In Mercurial if an empty repository is cloned and files are added and then pushed back into the
remote repository then the remote repository will contain no working files (no tree) until and
unless someone updates the repository manually.

If you want a Git repository to function like a remote backup, you have to create the repository as
a "bare" repository. Meaning: Don't insist on having a working tree on your remote backup copy -
only use it as a backup. It is not meant to contain any working files and it will not contain any.

A quick rule of thumb is to never push into a repository that has a work tree attached to it, until
you REALLY know what you are doing no matter what distributed revision control system you are using.

As long as you don't need to physically work on the remote repository then having a working tree
remotely doesn't make sense anyway and you don't need it. And if you do need to work on the remote
repository then pull changes in rather than accept pushes.

Any repository that someone is working on is not something that should receive changes without their
approval since such changes might create problems.

If you want to have Git working as a remote backup repository, you have to create the remote
repository as a bare repository:

$ mkdir my_remote_backup_repo
$ cd my_remote_backup_repo
$ git --bare init

Now you can clone that remote repository and push files back into it, but you wont have a working
tree in the remote location.

Question: How do I turn an existing "non-bare" repository into a "bare" repository in Git (taken
    from the Git wiki)?

Answer: A safe method is to let Git handle all the internal settings for you by doing something like
this:

$ git clone --bare -l non_bare_repo new_bare_repo

Question: How do I do the opposite? (Turn an existing "bare" repository into a "non-bare" repository
    in Git)?

Answer: You just clone it and delete the original.

See http://sitaramc.github.com/concepts/bare.html for futher information on Git bare and non-bare
repositories.

Linus Thorvalds gives a great talk about Git and distributed revision control on Google Talk.

If you have any comments or corrections feel free to email them to me.


<non-bare-remote-repository>

drwxrwxr-x 15 kit kit  4096 Feb 27 11:06 .
drwxrwxr-x  6 kit kit  4096 Feb 27 11:05 ..
-rw-rw-r--  1 kit kit  2921 Feb 27 11:06 CMakeLists.txt
drwxrwxr-x  6 kit kit  4096 Feb 27 11:06 data
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 debug
drwxrwxr-x  8 kit kit  4096 Feb 27 11:07 .git
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 images
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 include
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 mah
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 main
drwxrwxr-x  2 kit kit 24576 Feb 27 11:06 mh5dec
drwxrwxr-x  2 kit kit 16384 Feb 27 11:06 mh5eng
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 mh5gpi
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 mhv
-rwxrwxr-x  1 kit kit   142 Feb 27 11:06 org.tizen.mhegproto.manifest
-rwxrwxr-x  1 kit kit   538 Feb 27 11:06 org.tizen.mhegproto.xml
-rwxrwxr-x  1 kit kit   523 Feb 27 11:06 org.tizen.mhegproto.xml.in
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 packaging
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 pfm


<bare-remote-repository>

keitee.park@magnum /dsk1/git/tizen-mheg-bare.git
$ ls -al
total 40
drwxrwsr-x  7 keitee.park av 4096 Feb 27 11:04 .
drwxrwsr-x 19 root        av 4096 Feb 27 11:03 ..
drwxrwsr-x  2 keitee.park av 4096 Feb 27 11:04 branches
-rw-rw-r--  1 keitee.park av   66 Feb 27 11:04 config
-rw-rw-r--  1 keitee.park av   73 Feb 27 11:04 description
-rw-rw-r--  1 keitee.park av   23 Feb 27 11:04 HEAD
drwxrwsr-x  2 keitee.park av 4096 Feb 27 11:04 hooks
drwxrwsr-x  2 keitee.park av 4096 Feb 27 11:04 info
drwxrwsr-x  4 keitee.park av 4096 Feb 27 11:04 objects
drwxrwsr-x  4 keitee.park av 4096 Feb 27 11:04 refs

As you can see, there is a working directory and .git folder for non-bare case.


<how-to-use-bare>

1> create bare remote repository.
git clone keitee.park@magnum:/dsk1/git/tizen-mheg-bare.git mag_prev

2> clone it from the remote which has nothing.
3> add files, commit and push.

This is how it looks like when cloned it from bare-case.

kit@kit-vb:~/mheg-remote-git/mag_bare$ git remote -v
origin	keitee.park@magnum:/dsk1/git/tizen-mheg-bare.git (fetch)
origin	keitee.park@magnum:/dsk1/git/tizen-mheg-bare.git (push)

kit@kit-vb:~/mheg-remote-git/mag_bare$ git branch -a
* master
  remotes/origin/master

After have moved to bare-case, push to remote works well.


{push-errors-02}
error: insufficient permission for adding an object to repository database ./objects

The problem is taht there is no problem for team members to clone it and the repo is bare one. But
have got this error. This happens because that the repo was not created to be shared. To do that the
repo should be created:

git --bare init --shared=all 

Or, can change permissons manually on existing repo:

chomd -R g+w <dir>
chmod -R g+s <dir>

$ cat HbbTVTizen.git/config 
[core]
	repositoryformatversion = 0
	filemode = true
	bare = true
	sharedrepository = 2

Looks like that this 'sharedrepository' is the one when created with --shared.

git clone keitee.park@magnum:/dsk1/git/tizen-mheg-shared.git mag_shared


={============================================================================
*kt_dev_env_git_155* git-hook:

https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks

8.3 Customizing Git - Git Hooks

Git Hooks

Like many other Version Control Systems, Git has a way to fire off custom
scripts when certain important actions occur. There are two groups of these
hooks: client-side and server-side. Client-side hooks are triggered by
operations such as committing and merging, while server-side hooks run on
network operations such as receiving pushed commits. You can use these hooks for
all sorts of reasons.  


Installing a Hook

The hooks are all stored in the hooks subdirectory of the Git directory. In most
projects, that's `.git/hooks`. 

When you initialize a new repository with git init, Git populates the hooks
directory with a bunch of example scripts, many of which are useful by
themselves; but they also document the input values of each script. All the
examples are written as shell scripts, with some Perl thrown in, but `any`
properly named executable scripts will work fine - you can write them in Ruby
or Python or what have you. If you want to use the bundled hook scripts,
you'll have to rename them; their file names all end with .sample.


$ ls .git/hooks/
applypatch-msg.sample      commit-msg.sample          post-update.sample         
pre-applypatch.sample      pre-commit.sample          prepare-commit-msg.sample  
pre-rebase.sample          update.sample


To enable a hook script, put a file in the hooks subdirectory of your Git
directory that is named appropriately and is executable. From that point
forward, it should be called. We'll cover most of the major hook filenames here.


Client-Side Hooks

There are a lot of client-side hooks. This section splits them into
committing-workflow hooks, email-workflow scripts, and everything else.


Committing-Workflow Hooks

The first four hooks have to do with the committing process.

<pre-commit-hook>
The pre-commit hook is run first, before you even type in a commit message. It’s
used to inspect the snapshot that’s about to be committed, to see if you’ve
forgotten something, to make sure tests run, or to examine whatever you need to
inspect in the code. Exiting non-zero from this hook aborts the commit, although
you can bypass it with git commit --no-verify. You can do things like check for
code style (run lint or something equivalent), check for trailing whitespace
(the default hook does exactly this), or check for appropriate documentation on
new methods.

The prepare-commit-msg hook is run before the commit message editor is fired up
but after the default message is created. It lets you edit the default message
before the commit author sees it. This hook takes a few parameters: the path to
the file that holds the commit message so far, the type of commit, and the
commit SHA-1 if this is an amended commit. This hook generally isn’t useful for
normal commits; rather, it’s good for commits where the default message is
auto-generated, such as templated commit messages, merge commits, squashed
commits, and amended commits. You may use it in conjunction with a commit
template to programmatically insert information.

The commit-msg hook takes one parameter, which again is the path to a temporary
file that contains the commit message written by the developer. If this script
exits non-zero, Git aborts the commit process, so you can use it to validate
your project state or commit message before allowing a commit to go through. In
the last section of this chapter, We’ll demonstrate using this hook to check
that your commit message is conformant to a required pattern.

After the entire commit process is completed, the post-commit hook runs. It
doesn’t take any parameters, but you can easily get the last commit by running
git log -1 HEAD. Generally, this script is used for notification or something
similar.


Other Client Hooks

The pre-rebase hook runs before you rebase anything and can halt the process by
exiting non-zero. You can use this hook to disallow rebasing any commits that
have already been pushed. The example pre-rebase hook that Git installs does
this, although it makes some assumptions that may not match with your workflow.

The post-rewrite hook is run by commands that replace commits, such as git
commit --amend and git rebase (though not by git filter-branch). Its single
argument is which command triggered the rewrite, and it receives a list of
rewrites on stdin. This hook has many of the same uses as the post-checkout and
post-merge hooks.

After you run a successful git checkout, the post-checkout hook runs; you can
use it to set up your working directory properly for your project environment.
This may mean moving in large binary files that you don’t want source
controlled, auto-generating documentation, or something along those lines.

The post-merge hook runs after a successful merge command. You can use it to
restore data in the working tree that Git can’t track, such as permissions data.
This hook can likewise validate the presence of files external to Git control
that you may want copied in when the working tree changes.

The pre-push hook runs during git push, after the remote refs have been updated
but before any objects have been transferred. It receives the name and location
of the remote as parameters, and a list of to-be-updated refs through stdin. You
can use it to validate a set of ref updates before a push occurs (a non-zero
    exit code will abort the push).

Git occasionally does garbage collection as part of its normal operation, by
invoking git gc --auto. The pre-auto-gc hook is invoked just before the garbage
collection takes place, and can be used to notify you that this is happening, or
to abort the collection if now isn’t a good time.


note:
However, git hooks are repository specific. How to make it global?

In "Effortless Ctags with Git" Tim Pope demonstrates how to set up hooks for the
post-commit post-merge, and post-checkout events. The beauty of this solution is
that it uses global hooks, so configuring each individual repository on your
system is unnecessary.

Effortless Ctags with Git

From http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html

By tpope

08 Aug 2011

In case you've been living under a programming rock, Ctags (specifically
    Exuberant Ctags, not the BSD version shipped with OS X) indexes source code
to make it easy to jump to functions, variables, classes, and other identifiers
in (among other editors) Vim (see :help tags). The major downside to Ctags is
having to manually rebuild that index all the time. That’s where the
not-so-novel idea of re-indexing from various Git commit hooks comes in.


Git hooks are repository specific. Some would recommend using a script to
install said hooks into a given repository. But for me, that's too manual. Let's
set up a default set of hooks that Git will use as a template 'when' creating or
cloning a repository (requires Git 1.7.1 or newer):

Note
It's important to note that client-side hooks are not copied when you clone a
repository. If your intent with these scripts is to enforce a policy, you'll
probably want to do that on the server side; see the example in An Example
Git-Enforced Policy.

git config --global init.templatedir '~/.git_template'
mkdir -p ~/.git_template/hooks


TEMPLATE DIRECTORY

The template directory contains files and directories that will be copied to the
$GIT_DIR after it is created.

The template directory will be one of the following (in order):

    the argument given with the --template option;

    the contents of the $GIT_TEMPLATE_DIR environment variable;

    the init.templateDir configuration variable; or

    the default template directory: /usr/share/git-core/templates.

The default template directory includes some directory structure, suggested
"exclude patterns" (see gitignore[5]), and sample hook files (see githooks[5]).

Now onto the first hook, which isn't actually a hook at all, but rather a script
the 'other' hooks will call. Place in .git_template/hooks/ctags and mark as
executable:

// $ git rev-parse --git-dir
// .git

#!/bin/sh
set -e
PATH="/usr/local/bin:$PATH"
dir="`git rev-parse --git-dir`"
trap 'rm -f "$dir/$$.tags"' EXIT
git ls-files | \
  ctags --tag-relative -L - -f"$dir/$$.tags" --languages=-javascript,sql
mv "$dir/$$.tags" "$dir/tags"

Making this a 'separate' script makes it easy to invoke .git/hooks/ctags for a
one-off re-index
    
or git config --global alias.ctags '!.git/hooks/ctags', then git ctags, as well
as easy to edit for that special case repository that needs a different set of
options to ctags. 

For example, I might want to re-enable indexing for JavaScript or SQL files,
    which I've disabled here because I've found both to be of limited value and
      noisy in the warning department.

I stick the tags file in .git dir because if fugitive.vim is installed, Vim will
be configured to look for it there automatically, regardless of your current
working directory. Plus, you don't need to worry about adding it to .gitignore.

Here come the hooks. Mark all 'four' of them executable and place them in
.git_template/hooks. 


Use this same content for the first three: post-commit, post-merge, and
post-checkout (actually my post-checkout hook includes hookup as well).

# post-commit
#!/bin/sh
.git/hooks/ctags >/dev/null 2>&1 &

I've forked it into the background so that my Git workflow remains as
latency-free as possible.

One more hook that oftentimes gets overlooked: post-rewrite. This is fired after
git commit --amend and git rebase, but the former is already covered by
post-commit. Here’s mine:

#!/bin/sh
case "$1" in
  rebase) exec .git/hooks/post-merge ;;
esac

Once you get this all set up, you can use git init in existing repositories to
copy these hooks in.

So what does this get you? Any new repositories you create or clone will be
immediately indexed with Ctags and set up to re-index every time you check out,
            commit, merge, or rebase. Basically, you'll never have to manually
              run Ctags on a Git repository again.


={============================================================================
*kt_dev_env_git_155* git-hook: pre-push example

#!/bin/bash

remote="$1"
url="$2"

z40=0000000000000000000000000000000000000000

IFS=' '

validate_subject() {
    local commit=$1
    local subject=$(git log -n 1 --pretty=format:%s $commit)

    [[ $subject =~ ^DEVARCH-[0-9]+:\ .+ ]] || {
        echo -e "\E[1;31mThe commit subject does not match \"DEVARCH-xxxx: <subject>\"";
        echo -e "\E[1;31m $commit $subject"
        tput sgr0
        exit 1;
    }
}

echo -e "\E[1;31mThe git hook pre-push runs\E[m";

while read local_ref local_sha remote_ref remote_sha
do
    if [[ "$local_sha" != $z40 && "$remote_ref" = "refs/heads/master" ]]; then
        # We only care about validating commits to master
        if [ "$remote_sha" = $z40 ]
        then
            # New branch, examine all commits
            range="$local_sha"
        else
            # Update to existing branch, examine new commits
            range="$remote_sha..$local_sha"
        fi

        for revision in $(git rev-list $range);
        do
            validate_subject $revision
        done
    fi
done

exit 0


={============================================================================
*kt_dev_env_git_155* git-update-ref:

NAME

git-update-ref - Update the object name stored in a ref safely

SYNOPSIS

git update-ref [-m <reason>] (-d <ref> [<oldvalue>] | [--no-deref]
    [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])

DESCRIPTION

Given two arguments, stores the <newvalue> in the <ref>, possibly dereferencing
the symbolic refs. E.g. git update-ref HEAD <newvalue> updates the current
branch head to the new object.


={============================================================================
*kt_dev_env_git_155* git-update-index:

NAME

git-update-index - Register file contents in the working tree to the index

SYNOPSIS

git update-index
        [--refresh] [-q] [--unmerged] [--ignore-missing]
        [--] [<file>...]

DESCRIPTION

Modifies the index or directory cache. Each file mentioned is updated into the
index and any unmerged or needs updating state is cleared.

See also git-add[1] for a more user-friendly way to do some of the most common
operations on the index.

The way git update-index handles files it is told about can be modified using
the various options:


--refresh

    Looks at the current index and checks to see if merges or updates are needed
    by checking stat() information.


={============================================================================
*kt_dev_env_git_155* git-write-tree:

NAME

git-write-tree - Create a tree object from the current index

SYNOPSIS

git write-tree [--missing-ok] [--prefix=<prefix>/]

DESCRIPTION

Creates a tree object using the current index. The name of the new tree object
is 'printed' to standard output.

The index must be in a fully merged state.

Conceptually, git write-tree sync()s the current index contents into a set of
tree files. In order to have that match what is actually in your directory right
now, you need to have done a git update-index phase before you did the git
write-tree.


={============================================================================
*kt_dev_env_git_155* git-commit-tree:

NAME

git-commit-tree - Create a new commit object

SYNOPSIS

git commit-tree <tree> [(-p <parent>)...]
git commit-tree [(-p <parent>)...] [-S[<keyid>]] [(-m <message>)...]
    [(-F <file>)...] <tree>

DESCRIPTION

This is usually not what an end user wants to run directly. See git-commit[1]
instead.

Creates a new commit object based on the provided tree object and emits the new
commit object id on stdout. The log message is read from the standard input,
unless -m or -F options are given.

A commit object may have any number of parents. With exactly one parent, it is
an ordinary commit. Having more than one parent makes the commit a merge between
several lines of history. Initial (root) commits have no parents.

While a tree represents a particular directory state of a working directory, a
commit represents that state in "time", and explains how to get there.

Normally a commit would identify a new "HEAD" state, and while Git doesn’t care
where you save the note about that state, in practice we tend to just write the
result to the file that is pointed at by .git/HEAD, so that we can always see
what the last committed state was.


={============================================================================
*kt_dev_env_0000* git-how: how to copy a file from a commit

"checkout -- file" is to checkout file 'out' of the index; to copy to working
directory.

1. From git checkout help

If you want to check out all C source files out of the index, you can say

$ git checkout -- '*.c'

2. From git status message

use "git checkout -- <file>..." to discard changes in working directory)

3. To discard-changes

$ git checkout -- <filename>

4.  To copy a file from the exisiting commit:

git checkout otherbranch myfile.txt

5. To copy a file from the stash:

git checkout stash@{0} -- <filename>
git checkout stash@{0} <filename>         // note: same

6.  note: the current dir and the path should match.

/Polonium.NexusInspect/src$ rm nexus-inspect.c 
/Polonium.NexusInspect/src$ git co stash@{0} Polonium.NexusInspect/src/nexus-inspect.c 
/nexus-inspect.c' did not match any file(s) known to git.
/Polonium.NexusInspect/src$ git co stash@{0} -- Polonium.NexusInspect/src/nexus-inspect.c 
/nexus-inspect.c' did not match any file(s) known to git.
/Polonium.NexusInspect/src$ cd ..
/Polonium.NexusInspect$ cd ..

$ ls
Polonium.NexusInspect
$ git co stash@{0} Polonium.NexusInspect/src/nexus-inspect.c 


={============================================================================
*kt_dev_env_0000* git-how: how to check if a branch contains a commit

git fetch && git branch -r --contains <commit-id>

With --contains, shows only the branches that contain the named commit (in
        other words, the branches whose tip commits are descendants of the
        named commit). 

Or

git log --grep


={============================================================================
*kt_dev_env_0000* git-how: github fork projects and pull request

{fork-projects}
If you want to contribute to an existing project to which you do 'not' have push access, you can
"fork" the project. What this means is that GitHub will make a copy of the project that is entirely
yours; it lives in your user's namespace, and you can push to it.

<pull-request> note: from a project owner's POV, it's pull.
This way, projects don't have to worry about adding users as collaborators to give them push access.
People can fork a project, push to it, and contribute their changes back to the original repository
by creating what's called a Pull Request. 

This opens up a discussion thread with code review, and the owner and the contributor can then
communicate about the change 'until' the owner is happy with it, at which point the owner can merge it
in. To fork a project, visit the project page and click the "Fork" button.

When done, you'll be taken to your new project page, with your own 'writeable' copy of the code.


{workflow}
GitHub is designed around a particular collaboration workflow, centered on pull requests and topic
branches workflow.

Here's how it generally works:

0. Clone our fork of the project locally
1. Create a topic branch from master. <pull-request-branch>
2. Make some commits to improve the project.
3. Push this branch to your GitHub project.
4. Open a Pull Request on GitHub.
5. Discuss, and optionally continue committing.
6. The project owner merges or closes the Pull Request.

note: So, pull-request is a code-review process.


{pull-requst-as-patch} but not series of patches
Unlike most mailing list-based projects that think of patch series, most GitHub projects think about
Pull Request 'branches' as iterative conversations around a proposed change, culminating in a
unified diff that is applied by merging.

For instance, as example at Figure 6-15, you'll notice that the contributor did not rebase his
commit and send another Pull Request. Instead they added new commits and pushed them to the existing
'branch'. This way if you go back and look at this Pull Request in the future, you can easily find
all of the context of why decisions were made. Pushing the "Merge" button on the site purposefully
creates a merge commit that references the Pull Request so that it's easy to go back and research
the original conversation if necessary.

note: So works in a branch until the final patch will be made through discussion, making commits and
also has full history. Can think that the review system is integrated with git and possible since
branch is cheap in git.

TODO: continue on KEEPING UP WITH UPSTREAM


# ============================================================================
#{ tmux
={============================================================================
*kt_dev_env_3000* tmux-install

https://tmux.github.io/

<check-version>
tmux -V

<update>
https://www.sitepoint.com/tmux-a-simple-start/

Ubuntu/Debian

There is a Ubuntu package so, sudo apt-get install tmux will work, but the
installed package is 1.7 and we really want 1.8. To get 1.8, do the following
(thanks to this article):

$ sudo add-apt-repository ppa:pi-rho/dev
$ sudo apt-get update
$ sudo apt-get install tmux


={============================================================================
*kt_dev_env_3000* tmux-basic

<prefix>
CTRL-b by default.

note:
1. Consider remapping CAPSLOCK to CONTROL within your operating system.
2. Consider remapping CTRL-b to CTRL-a within your operating system.

<ex>
Can rebind this by putting the following in ~/.tmux.conf:
set -g prefix Ctrl-a

<ex>
# remap prefix to Control + a
set -g prefix C-a
unbind C-b
bind C-a send-prefix

# force a reload of the config file
unbind r
bind r source-file ~/.tmux.conf

# quick pane cycling
unbind ^A
bind ^A select-pane -t :.+

<ex>
# Remap window navigation to vim
unbind-key j
bind-key j select-pane -D
unbind-key k
bind-key k select-pane -U
unbind-key h
bind-key h select-pane -L
unbind-key l
bind-key l select-pane -R

<ex>
# Set a Ctrl-b shortcut for reloading your tmux config
bind r source-file ~/.tmux.conf

# Rename your terminals
set -g set-titles on
set -g set-titles-string '#(whoami)::#h::#(curl ipecho.net/plain;echo)'


# Status bar customization
set -g status-utf8 on
set -g status-bg black
set -g status-fg white
set -g status-interval 5
set -g status-left-length 90
set -g status-right-length 60
set -g status-left "#[fg=Green]#(whoami)#[fg=white]::#[fg=blue] \
(hostname - s)#[fg=white]::##[fg=yellow]#(curl ipecho.net/plain;echo)"

set -g status-justify left
set -g status-right '#[fg=Cyan]#S #[fg=white]%a %d %b %R' 


<shortcut-and-command>
Two ways: use shortcut or command.

# Via shortcut
$ CTRL-b s

# Via tmux command
$ tmux ls

tmux 	[-2Cluv] [-c shell-command] [-f file] [-L socket-name] \
  [-S socket-path] [command [flags]]


<session-window-pane>
A tmux session is, put simply, and container for windows and panes. A window
contains one or more panes.


<status>
[0] 0:bash*
[`session`] `windows`


<session>
tmux new -s session_name
    creates a new tmux session named session_name

tmux attach -t session_name
    attaches to an existing tmux session named session_name
tmux a
    attaches t the first available session.

tmux switch -t session_name
    switches to an existing session named session_name

tmux list-sessions
tmux ls
    lists existing tmux sessions

tmux detach (prefix + d)

tmux kill-session -t session-name

note: 
You can kill windows the same way, but using kill-window instead. You can also
kill tmux altogether with killall tmux.


<window>
note:
Likes a tab.

CTRL-b c Create new window
CTRL-b d Detach current client
CTRL-b l Move to previously selected window
CTRL-b n    Move to the next window
CTRL-b p    Move to the previous window
CTRL-b &    Kill the current window
CTRL-b ,    Rename the current window
CTRL-b w    List windows

CTRL-b %    Split the current pane into two, left and right.
CTRL-b "    Split the current pane into two, top and bottom.

CTRL-b q    Show pane numbers (used to switch between panes)
CTRL-b o    Switch to the next pane
       x    `kill pane`
       z    toggle pane `zoom`

CTRL-b ?    List all keybindings


# force a reload of the config file
unbind r
bind r source-file ~/.tmux.conf

<useful-commands>
tmux list-keys
    lists out every bound key and the tmux command it runs

tmux list-commands
    lists out every tmux command and its arguments

tmux info
    lists out every session, window, pane, its pid, etc. 

tmux source-file ~/.tmux.conf
    reloads the current tmux configuration (based on a default tmux config) 


note:
When use vim in tmux window/pane.

Seamlessly Navigate Vim and tmux Splits
https://robots.thoughtbot.com/seamlessly-navigate-vim-and-tmux-splits


<copy-mode>
First, I set tmux to use vi keys:

setw -g mode-keys vi

Then I change the default keybinds to suit my workflow. As explained in the
man page, the default keys to enter and exit copy mode are [ and ]
respectively. I reset those in my .tmux.conf to more intuitive and Vim-like
keys:

unbind [
bind Escape copy-mode
unbind p
bind p paste-buffer
bind-key -t vi-copy 'v' begin-selection
bind-key -t vi-copy 'y' copy-selection

note:
This is for pasting within tmux

Ctrlt,Escape   # enter copy mode
# move cursor to the start or end of the desired text string
v                        # to activate highlighting
# move cursor to cover the requisite string
y                        # to capture the string
q                        # exit copy mode
Ctrlt,p       # put/paste the text in the desired location


={============================================================================
*kt_dev_env_3000* tmux-concept

http://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/

If you've ever worked with remote servers or a Raspberry Pi over ssh you can
guess where this will be useful: When you lose your ssh connection the tmux
session will simply be detached but will keep running on the server in the
background including all the processes that run within your session. To
continue your session simply ssh to the server again and attach to the running
session.

But tmux is not only helpful when working on a remote machine. Not only for
its window management features but also for the session handling. Personally I
find myself detaching from sessions when I’m switching context. I’ll just
start a new session for my new task and attach to the old session whenever I
want to continue with my old task.

You see that tmux basically offers two big features: Window management in your
terminal and session management. 


Just a small hint: Look into tmuxinator. It let's you re-recreate complex tmux
layouts using a simple config file.


={============================================================================
*kt_dev_env_3000* tmux-multi

Remote Pair Programming Made Easy with SSH and tmux
http://www.hamvocke.com/blog/remote-pair-programming-with-tmux/

wemux enhances tmux to make multi-user terminal multiplexing both easier and
more powerful. It allows users to host a wemux server and have clients join in
either: 
https://github.com/zolrath/wemux


# ============================================================================
#{
={============================================================================
*kt_dev_env_4000* win-virtual-desktop

WINDOWS-Tab 
to open the Task View. In the bottom-right corner you'll see a plus sign with
'New desktop' written underneath. Click this to create a second desktop. 


WINDOWS-Ctrl and use the left and right arrow keys 
to flick seamlessly between desktops.


If you close a desktop, any applications or windows on that desktop won't
close, but will instead move automatically to the next available desktop. Any
application that allows for multiple instances of itself, such as the Chrome
browser, lets you run different program windows on multiple desktops.


If you want to move a window or application from one desktop to another, make
sure you're currently on the correct desktop, then press Windows-Tab and drag
and drop the window onto one of the desktops shown at the bottom of the
screen.  


By default, if you press Alt-Tab to switch tasks, only the windows and
applications currently running on that desktop will appear. The Taskbar will
also only show programs that are open on the desktop you’re currently using.
You can change this behaviour using the options in Settings, System,
Multi-tasking (just type 'Multi' into the Start search). In the 'Virtual
  desktops' section of this Settings menu, you can change both options from
  'Only the desktop I'm using' to 'All desktops'. This will let you access any
  window or application with Alt-Tab or the Taskbar, with Windows switching
  automatically to the correct desktop as you select the program.


={============================================================================
*kt_dev_env_tool_001*	eclipse: to create a project from existing source tree 

1. create a c or c++ project depending on type.

2. create a folder. click 'advanced' and select 'link to alternate location(linked
folder)'. specify a directory on nfs or a local folder that has all source tree. this
effectively makes a 'linked folder' to a folder. 

Properties -> C++ General -> Code Analysis or Indexer


==============================================================================
*kt_dev_env_tool_002*	netbean: to create a project from existing source tree 

But without no makefiles and build settings.  

You can try and create an Application project (instead of a Project with Existing sources) and add
your source files to the project. Application projects creates and maintain their own makefiles. 

{code-assistance-and-#ifdef}
Project property -> C/C++ Compiler -> Preprocessor Definitions

{navigation}

https://netbeans.org/kb/docs/cnd/navigating-editing.html

For 7.3:

Ctrl-b 	 							Go to declaration/definition
Ctrl-Alt-b 	 						Go to overide/overridden
Alt-Left/Alt-Right/Ctrl-Q 		Go backward/forward/to last edit

Alt-F7 								Find usages

Ctrl-G 			Go to line
Alt-Shift-C 	Go to declaration
Ctrl-F9 			Evaluate expression

Finding, Searching, and Replacing

Ctrl-F3 		Search word at insert point
F3/Shift-F3 Find next/previous in file
Alt-Shift-U Find usages results
Alt-Shift-H Turn off search result highlights
Ctrl-I 		Jump to quick search field
Alt-Shift-L Copy file path

Navigating through Source Code

Ctrl-O/Alt-Shift-O 				Go to type/file
Alt-O 								Go to source
Ctrl-Shift-M 						Toggle add/remove bookmark
Ctrl-Shift-Period / Comma 		Next/previous bookmark
Ctrl-Period / Comma 				Next/previous usage/compile error
Alt-Shift-Period / Comma		Select next/previous element
Ctrl-Shift-1/2/3 					Select in Projects/Files/Favorites
Ctrl-[ 								Move caret to matching bracket
Ctrl-K/Ctrl-Shift K 				Next/previous word match
Alt Up / Down 						Next/previous marked occurrence


{jdk-path}

Error is:
"Cannot locate java installation in specified jdkhome C:\Program Files (x86)\Java\jdk1.6.0_25
Do you want to try to use default version ?"

Change this file:
C:\Program Files\NetBeans 7.x\etc\netbeans.conf

# Default location of JDK:
# (set by installer or commented out if launcher should decide)
#
# It can be overridden on command line by using --jdkhome <dir>
# Be careful when changing jdkhome.
# There are two NetBeans launchers for Windows (32-bit and 64-bit) and
# installer points to one of those in the NetBeans application shortcut 
# based on the Java version selected at installation time.
#
netbeans_jdkhome="C:\Program Files\Java\jre7"


==============================================================================
*kt_dev_env_tool_003*	total commander short cut

# search
#
CTRL+SHIFT+S Open Quick Filter dialog and reactivate last-used filter

# tab
#
CTRL+T Open new folder tab and activate it
CTRL+SHIFT+T Open new folder tab, but do not activate it
CTRL+U Exchange directories
CTRL+SHIFT+U Exchange directories and tabs
CTRL+V Paste from clipboard to current dir.

# drive
#
ALT+F1 change left drive
ALT+F2 change right drive

ALT+SHIFT+F5 Move to archive
SHIFT+F2 Compare file lists


F2 Reread source window
F3 List files
F4 Edit files
F5 Copy files
F6 Rename or move files
F7 Create directory
F8 or DEL Delete files to recycle bin /delete directly - according to configuration
F9 Activate menu above source window (left or right)

ALT+F3 Use alternate (external or internal) viewer
ALT+SHIFT+F3 Start Lister and load file with internal viewer (no plugins or multimedia)
ALT+F4 Exit | Minimize (with option MinimizeOnClose in wincmd.ini)
ALT+F5 Pack files
ALT+F6 Unpack specified files from archive under cursor, or selected archives (use Alt+F9 on Windows 95)
ALT+F7 Find
ALT+F8 Opens the history list of the command line
ALT+F9 Same as ALT+F6 (because ALT+F6 is broken on Windows 95)
ALT+SHIFT+F9 Test archives
ALT+F10 Opens a dialog box with the current directory tree
ALT+F11 Opens left current directory bar (breadcrumb bar)
ALT+F12 Opens right current directory bar (breadcrumb bar)
ALT+SHIFT+F11 Focus the button bar to use it with the keyboard
SHIFT+F1 Custom columns view menu
SHIFT+F3 List only file under cursor, when multiple files selected
SHIFT+F4 Create new text file and load into editor
SHIFT+F5 Copy files (with rename) in the same directory
SHIFT+CTRL+F5 Create shortcuts of the selected files
SHIFT+F6 Rename files in the same directory
SHIFT+F8/DEL Delete directly / delete to recycle bin - according to configuration
SHIFT+F10 Show context menu
SHIFT+ESC Minimizes Total Commander to an icon
ALT+left/right Go to previous/next dir of already visited dirs
ALT+down Open history list of already visited dirs (like the history list in a WWW browser)
NUM + expand selection (configurable: just files or files and folders)
NUM - shrink selection
NUM * invert selection (also with shift, see link)
NUM / restore selection
SHIFT+NUM + Like NUM +, but files and folders if NUM + selects just files (and vice versa)
SHIFT+NUM - Always removes the selection just from files (NUM - from files and folders)
SHIFT+NUM * Like NUM *, but files and folders if NUM * inverts selection of just files (and vice versa)
CTRL+NUM + select all (configurable: just files or files and folders)
CTRL+SHIFT+NUM +
select all (files and folders if CTRL+NUM + selects only files)
CTRL+NUM - deselect all (always files and folders)
CTRL+SHIFT+NUM -
deselect all (always files, no folders)
ALT+NUM + select all files with the same extension
ALT+NUM - remove selection from files with the same extension
CTRL+PgUp
or Backspace Change to parent directory (cd ..)
CTRL+< Jump to the root directory (most European keyboards)
CTRL+\ Jump to the root directory (US keyboard)
CTRL+PgDn Open directory/archive (also self extracting .EXE archives)
CTRL+left/right Open directory/archive and display it in the target window. If the cursor is not on a directory name, or the other panel is active, then the current directory is displayed instead.
CTRL+F1 File display 'brief' (only file names)
CTRL+SHIFT+F1 Thumbnails view (preview pictures)
CTRL+F2 File display 'full' (all file details)
CTRL+SHIFT+F2 Comments view (new comments are created with Ctrl+Z)
CTRL+F3 Sort by name
CTRL+F4 Sort by extension
CTRL+F5 Sort by date/time
CTRL+F6 Sort by size
CTRL+F7 Unsorted
CTRL+F8 Display directory tree
CTRL+SHIFT+F8 Cycle through separate directory tree states: one tree, two trees, off
CTRL+F9 Print file under cursor using the associated program
CTRL+F10 Show all files
CTRL+F11 Show only programs
CTRL+F12 Show user defined files
TAB Switch between left and right file list
SHIFT+TAB Switch between current file list and separate tree (if enabled)
Letter Redirect to command line, cursor jumps to command line
INSERT Select file or directory.
SPACE Select file or directory (as INSERT). If SPACE is used on an unselected directory under the cursor, the contents in this directory are counted and the size is shown in the "full" view instead of the string <DIR>. This can be disabled through 'Configuration' - 'Options' - 'Operation' - 'Selection with Space'.
ENTER Change directory / run program / run associated program / execute command line if not empty. If the source directory shows the contents of an archive, further information on the packed file is given.
SHIFT+ENTER 1. Runs command line / program under cursor with preceding command /c and leave the program's window open. Only works if NOCLOSE.EXE is in the Total Commander directory!
2. With ZIP files: use alternative choice of these (as chosen in Packer config): (Treat archives like directories <-> call associated program, i.e. winzip or quinzip)
3. In the list of last used dirs (History, Ctrl+D), open the directory on a new Tab.
ALT+SHIFT+ENTER
The contents of all directories in the current directory are counted. The sizes of the directories are then shown in the "full" view instead of the string <DIR>. Abort by holding down ESC key.
ALT+ENTER Show property sheet.
CTRL+A select all
CTRL+B Directory branch: Show contents of current dir and all subdirs in one list
CTRL+SHIFT+B Selected directory branch: Show selected files, and all in selected subdirs
CTRL+C Copy files to clipboard
CTRL+D Open directory hotlist ('bookmarks')
CTRL+F Connect to FTP server
CTRL+SHIFT+F Disconnect from FTP server
CTRL+I Switch to target directory
CTRL+L Calculate occupied space (of the selected files)
CTRL+M Multi-Rename-Tool
CTRL+SHIFT+M Change FTP transfer mode
CTRL+N New FTP connection (enter URL or host address)
CTRL+P Copy current path to command line
CTRL+Q Quick view panel instead of file window
CTRL+R Reread source directory
CTRL+S Open Quick Filter dialog and activate filter (deactivate with ESC or CTRL+F10)


CTRL+W Close currently active tab
CTRL+SHIFT+W Close all open tabs
CTRL+X Cut files to clipboard
CTRL+Z Edit file comment
CTRL+UP Open dir under cursor in new tab
CTRL+SHIFT+UP Open dir under cursor in other window (new tab)
CTRL+TAB Jump to next tab
CTRL+SHIFT+TAB
Jump to previous tab
 
ALTGR+Letter(s) or
CTRL+ALT+Letter(s)
Quick search for a file name (starting with specified letters) in the current directory
(Support hotkeys Ctrl+X, Ctrl+C, Ctrl+V and Ctrl+A; use Ctrl+S for search filter on/off)
 
Other keys: See command line


==============================================================================
*kt_dev_env_tool_004*	outlook keys

Switch to Inbox.
 CTRL+SHIFT+I
 
Switch to Outbox.
 CTRL+SHIFT+O
 
Choose the account from which to send a message.
 CTRL+TAB (with focus on the To box) and then TAB to the Accounts button
 
Check names.
 CTRL+K
 
Send.
 ALT+S
 
Reply to a message.  CTRL+R 
 
Reply all to a message.  CTRL+SHIFT+R ~
 
Forward a message.
 CTRL+F
 
Mark a message as not junk.
 CTRL+ ALT+J
 
Display blocked external content (in a message).
 CTRL+SHIFT+I
 
Post to a folder.
 CTRL+ SHIFT+S
 
Apply Normal style.
 CTRL+SHIFT+N
 
Check for new messages.
 CTRL+M or F9
 
Go to the previous message.
 UP ARROW
 
Go to the next message.
 DOWN ARROW
 
Create a new message (when in Mail).
 CTRL+N
 
Create a new message (from any Outlook view).
 CTRL+SHIFT+M
 
Open a received message.
 CTRL+O
 
Open the Address Book.
 CTRL+SHIFT+B
 
Convert an HTML or RTF message to plain text.
 CTRL+SHIFT+O
 
Add a Quick Flag to an unopened message.
 INSERT
 
Display the Flag for Follow Up dialog box.
 CTRL+SHIFT+G
 
Mark as read.
 CTRL+Q
 
Mark as unread.
 CTRL+U
 
Show the menu to download pictures, change automatic download settings, or add a sender to the Safe Senders List.
 CTRL+SHIFT+W
 
Find or replace.
 F4
 
Find next.
 SHIFT+F4
 
Send.
 CTRL+ENTER
 
Print.
 CTRL+P
 
Forward.
 CTRL+F
 
Forward as attachment.
 CTRL+ALT+F
 
Show the properties for the selected item.
 ALT+ENTER
 
  
Mark for Download.
 CTRL+ALT+M
 
Clear Mark for Download.
 CTRL+ALT+U
 
Display Send/Receive progress.
 CTRL+B (when a Send/Receive is in progress)
 

==============================================================================
*kt_dev_env_tool_005*	ms-project: set delay

http://office.microsoft.com/en-001/project-help/delay-a-task-HP045308316.aspx

Add delay to an assignment

On the View menu, click More Views, click Resource Allocation, and then click Apply.

The Resource Allocation view is a combination of the Resource Usage view (on the top) and the Detail
Gantt view (on the bottom).

    In the Resource Usage portion of the view, click the resource or assignment for which you want
    to examine slack and possibly delay.  Click the Detail Gantt portion of the view.  On the View
    menu, point to Table, and then click Schedule.  To make sure you don't delay any other tasks or
    the project finish date, review available slack before adding delay. In the Detail Gantt portion
    of the view, press TAB until the Free Slack and Total Slack fields are visible, and then review
    them to find tasks that have slack.

Slack is also shown graphically as thin bars adjoining the regular Gantt bar.

    In the Resource Usage portion of the view, click the field to the right of where you want to
    insert the Assignment Delay field.  On the Insert menu, click Column.  In the Field name box,
    click Assignment Delay, and then click OK.  In the Assignment Delay field for the assignment you
    want to delay, type or select the amount of time you want to delay the assignment.

This indicates how much time after the task's start date the resource is to wait before starting
work on this assignment.

 Notes 

    If the task is linked, delaying one of its assignments might change the scheduling of any
    successor tasks, which can affect the finish date of your project. It's best to delay
    assignments on tasks with free slack first, and delay them only up to the amount of available
    slack.  You can add delay to a task or assignment, check the effect on the resource allocation,
    and then adjust the delay further if necessary. If you want to add delay without changing the
    finish date of other tasks or the project finish date, review available slack and add delay only
    within that time. Note that leveling can automatically delay tasks or assignments. Resource
    leveling considers all resources with assignments in the project, and is generally preferable to
    manually delaying tasks.


={============================================================================
*kt_dev_env_tool_006* firefox short cuts

https://support.mozilla.org/en-US/kb/keyboard-shortcuts-perform-firefox-tasks-quickly#w_search

{search}
Find                 Ctrl + F
Find Again           F3 Ctrl + G
Find Previous        Shift + F3 Ctrl + Shift + G
Quick Find within link-text only '
Quick Find                       /
Close the Find or Quick Find bar Esc - when the Find or Quick Find bar is focused 


={============================================================================
*kt_dev_env_tool_007* eclipse: basics

1. C+ mouse click on variables     
will have to options; open declaration and open declaration type.

2. C+o
To see methods in the current file.

3. C+S+T
To search types. Can use pattern and PEC for PlayerEventCA

4. C+T
To list all classes which implemented this interface.

5. C+S+U, C+S+G
To search a function in the current file and C+S+G for global.



==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
