*kt_dev_env*                                                          tw=100, utf-8

"Do one thing, and do it well" is a principle of Unix philosophy.

/^[#=]{ 
Use #{ for a group and ={ for a item

KT KB. vim, git, ECLIPSE. NETBEAN

#{ vim setup
|kt_dev_env_vim_000| links
|kt_dev_env_vim_001| install and build
|kt_dev_env_vim_002| plugins: neobundle
|kt_dev_env_vim_003| plugins: vimproc
|kt_dev_env_vim_004| plugins: solarized
|kt_dev_env_vim_005| plugins: status line
|kt_dev_env_vim_006| plugins: unite
|kt_dev_env_vim_007| plugins: unite and tag
|kt_dev_env_vim_008| plugins: ycm
|kt_dev_env_vim_009| plugins: ctrlp
|kt_dev_env_vim_010| plugins: neocomplete
|kt_dev_env_vim_011| plugins: indent-guide
|kt_dev_env_vim_012| plugins: ag or ack
|kt_dev_env_vim_013| plugins: netrw: run browser on link in vim
|kt_dev_env_vim_003| key sheet 

|kt_dev_env_vim_097| key mapping: traverse a list  
|kt_dev_env_vim_098| key mapping: traverse a list  
|kt_dev_env_vim_099| key mapping 

#{ vim core
|kt_dev_env_vim_100| help
|kt_dev_env_vim_101| dot command {power}
|kt_dev_env_vim_102| chunk your undo
|kt_dev_env_vim_103| operator, text object and motion
|kt_dev_env_vim_104| operator pending mode
|kt_dev_env_vim_105| commands in insert mode
|kt_dev_env_vim_106| normal mode and insert normal mode
|kt_dev_env_vim_107| remap caps lock key
|kt_dev_env_vim_108| use register in insert mode or command input
|kt_dev_env_vim_109| expression register

|kt_dev_env_vim_110| find out char code value
|kt_dev_env_vim_111| replace mode
|kt_dev_env_vim_112| visual mode
|kt_dev_env_vim_113| command mode: ex commands
|kt_dev_env_vim_114| command mode: normal commands
|kt_dev_env_vim_115| command completion, history, and command line window
|kt_dev_env_vim_116| current filename
|kt_dev_env_vim_117| exit, file and buffer
|kt_dev_env_vim_118| window and tab
|kt_dev_env_vim_119| display and real line

|kt_dev_env_vim_120| mark, jumps and changes
|kt_dev_env_vim_121| copy and paste
|kt_dev_env_vim_122| search:
|kt_dev_env_vim_123| search: incsearch
|kt_dev_env_vim_124| search: highlight
|kt_dev_env_vim_125| search: count matches
|kt_dev_env_vim_126| search: work on search matches
|kt_dev_env_vim_127| search: make a pattern using command line window
|kt_dev_env_vim_128| search: for the visual selection
|kt_dev_env_vim_129| global command {power}

|kt_dev_env_vim_130| spell
|kt_dev_env_vim_131| vimdiff
|kt_dev_env_vim_132| yank current filename to a register. expand

|kt_dev_env_vim_140| shell: run external program and bang(!) 
|kt_dev_env_vim_141| shell: foreground and background

|kt_dev_env_vim_150| format, wrap, tw
|kt_dev_env_vim_151| encoding and utf8
*kt_dev_env_vim_152* how: how to change word between '_'


#{ vim programming
|kt_dev_env_vim_200| prog: adding and substracting
|kt_dev_env_vim_201| prog: tab and shift
|kt_dev_env_vim_202| prog: match command

|kt_dev_env_vim_300| prog: tag: cscope
|kt_dev_env_vim_301| prog: tag: ctag
|kt_dev_env_vim_302| prog: move in c
|kt_dev_env_vim_303| prog: tag: gtag
|kt_dev_env_vim_304| prog: build: quickfix
|kt_dev_env_vim_305| prog: build: makeprg and filetype
|kt_dev_env_vim_306| prog: build: man page in vim

|kt_dev_env_vim_320| prog: folding

|kt_dev_env_vim_300|	script

|kt_dev_env_vim_002|	config {vimrc}
|kt_dev_env_vim_003|	recovery, swap and backup
|kt_dev_env_vim_004|	color and syntax
|kt_dev_env_vim_005|	plugin: foldsearc
|kt_dev_env_vim_008|	search and substitute {vim-subst} {vim-global}
|kt_dev_env_vim_009|	regexp - char class
|kt_dev_env_vim_010|	regexp - word boundary
|kt_dev_env_vim_011|	regexp - escaped or meta char 	 kt_vim_reg_meta
|kt_dev_env_vim_012|	regexp - grouping
|kt_dev_env_vim_013|	regexp - alternation
|kt_dev_env_vim_014|	regexp - precedence
|kt_dev_env_vim_015|	regexp - examples
|kt_dev_env_vim_022|	format and wrap {tabstop}
|kt_dev_env_vim_031|	^M char
|kt_dev_env_vim_034|	tool: ag bin and ag vim plugin

#{ git
|kt_dev_env_git_000| reference
|kt_dev_env_git_001| install
|kt_dev_env_git_002| config, alias and help
|kt_dev_env_git_003| terminology
|kt_dev_env_git_004| init and clone
|kt_dev_env_git_005| status
|kt_dev_env_git_006| ignore
|kt_dev_env_git_007| git-log
|kt_dev_env_git_008| unstage and discard changes
|kt_dev_env_git_009| auto completion
|kt_dev_env_git_010| git-branch
*kt_dev_env_git_011* git-branch: rename, delete
*kt_dev_env_git_012* git-branch: list
*kt_dev_env_git_013* git-branch: checkout and tracking
*kt_dev_env_git_014* git-branch: merge or rebase
|kt_dev_env_git_011| merge workflow. mergetool
|kt_dev_env_git_012| generate patch and apply
|kt_dev_env_git_013| merge: undo merge attempt
|kt_dev_env_git_015| tag
|kt_dev_env_git_016| rebase:
|kt_dev_env_git_017| 
|kt_dev_env_git_018| 
|kt_dev_env_git_019| git-rebase: rewriting-history
|kt_dev_env_git_020| rebase: undo
|kt_dev_env_git_021| rebase: revase vs merge
|kt_dev_env_git_022| git-cherry-pick
|kt_dev_env_git_023| git-reset

|kt_dev_env_git_029| recover and dangling
|kt_dev_env_git_030| git-stash
|kt_dev_env_git_031| config: use gvim as default editor
|kt_dev_env_git_032| list
|kt_dev_env_git_033| add, rm, mv and clean
|kt_dev_env_git_034| diff, difftool
|kt_dev_env_git_035| show
|kt_dev_env_git_036| commit

|kt_dev_env_git_100| case: determine what is introduced. commit ranges.
|kt_dev_env_git_038| grep

|kt_dev_env_git_050| gitk

|kt_dev_env_git_100| different workflows
|kt_dev_env_git_101| commit guideline

|kt_dev_env_git_150| remote: local, remote master
|kt_dev_env_git_151| 
|kt_dev_env_git_152| remote: fetch and pull
|kt_dev_env_git_153| remote: pull --rebase
|kt_dev_env_git_154| git-push
|kt_dev_env_git_155| 
|kt_dev_env_git_156| 
|kt_dev_env_git_157| remote: branch inspect, show, and ls-remote
|kt_dev_env_git_158| remote: push errors. bare
|kt_dev_env_git_159| remote: pull conflict

|kt_dev_env_git_200| git-how: how to copy a file from a commit
*kt_dev_env_git_201* git-how: how to check if a branch contains a commit

|kt_dev_env_git_300| github: fork projects and pull request


#{ tools
|kt_dev_env_tool_001| eclipse: to create a project from existing source tree 
|kt_dev_env_tool_002| netbean: to create a project from existing source tree 
|kt_dev_env_tool_003| total commander short cuts
|kt_dev_env_tool_004| outlook keys
|kt_dev_env_tool_005| ms-project: set delay
|kt_dev_env_tool_006| firefox short cuts


# ============================================================================
#{
={============================================================================
*kt_dev_env_vim_000* links

unimpaired.vim : Pairs of handy bracket mappings
http://www.vim.org/scripts/script.php?script_id=1590

http://www.viemu.com/a-why-vi-vim.html
http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/

http://andrewradev.com/2011/06/08/vim-and-ctags/

for articles and video casts by author of the paractical vim
http://vimcasts.org/

https://pragprog.com/book/dnvim/practical-vim


={============================================================================
*kt_dev_env_vim_001* install and build

{get-source}
# Debian/Ubuntu
apt-get install mercurial

# to get your working copy.
hg clone https://vim.googlecode.com/hg/ vim

# to update to the latest
cd vim
hg pull
hg update


{install}
cd src
make distclean  # if you build Vim before
make
sudo make install
./configure --prefix=/home/kit --enable-cscope
make VIMRUNTIMEDIR=/home/kit/vim MAKE="make -e"
make install

<features>
# to check features
% gvim --version | egrep '\+lua'
%
+dialog_con_gui  +lua             +rightleft       +windows

In vim command input, :echo has("lua") returns 1, then you're done; otherwise, see below.


<build>
http://vim.wikia.com/wiki/Building_Vim

1. Get dependencies. On Unix-like systems, apt-get build-dep vim-gnome or similar can do this for
you.
2. Get the Vim source code from Mercurial or a GitHub clone.  
3. Change to the directory with the Vim source code and run "make".  

Building Vim on Ubuntu

You need the required development packages on Ubuntu to build the GUI: 

sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev
libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev

See vim/src/auto/config.log for more detailed logs and ./configure --help for options which comes
from vim/src/auto/configure

<feature-python>
https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source

For 3.3:

Get python from python org, build and install. Then find out dir where config.c for python is. For
3.3, this is /usr/local/lib/python3.3/config-3.3m/. Do not need to change makefile.

Then use this:

./configure --prefix=/home/kit --enable-luainterp=yes --with-features=huge --enable-gui=gnome2 --enable-cscope 

--enable-python3interp=yes 
--with-python3-config-dir=/usr/local/lib/python3.3/config-3.3m

For 2.7 which is already installed:

/usr/lib/python2.7/config

If build failed since cannot find some files relating python then do:
apt-get install python-dev

The following NEW packages will be installed
  libssl-dev libssl-doc python-dev python2.7-dev

<feature-lua> and python2.7

apt-get install lua5.2 liblua5.2-dev

./configure --prefix=/home/kit  --enable-luainterp=yes --with-features=huge --enable-gui=gnome2 --enable-cscope 
--enable-pythoninterp=yes
--with-python-config-dir=/usr/lib/python2.7/config


={============================================================================
*kt_dev_env_vim_002* plugins: neobundle

https://github.com/Shougo/neobundle.vim

{install}
$ curl https://raw.githubusercontent.com/Shougo/neobundle.vim/master/bin/install.sh | sh

note: requires vimproc

NeoBundle assumes Github as the default location for plugins, so for most
plugins you can simply use NeoBundle 'username/plugin' rather than using the
absolute URL of the plugin. These calls should be made in your .vimrc file. Once
you have defined these, you must call NeoBundleInstall, and NeoBundle will clone
all of the repos into the desired folder (generally ~/.vim/bundle) and load them
into Vim. If you want to update these repositories, simply call NeoBundleUpdate.

note: requires to restart vim after NeoBundleUpdate.


={============================================================================
*kt_dev_env_vim_003* plugins: vimproc

https://github.com/Shougo/vimproc.vim

# git clone https://github.com/Shougo/vimproc.vim and build c files and add it
# to runtimepath
# 
# Clone this repo Build vimproc's native extensions (see Building for details).
# Just run make.
# 
# Copy autoload/* and plugin/* files to your 'runtimepath' directory. see :help
# runtimepath.  note: this is ~/.vim/bundle/                


2015.09.03.

After updated all packages, unite failed to run "async" function and showed
error around vimproc in gather_candidates

The suggestion was:
Please re-compile vimproc: (cd ~/.vim/bundle/vimproc && make)

Do not copy .so file manually since should be done in bundle mechanism and
vimproc is already in runtimepath:

/home/kpark/.vim/bundle/vimproc

So build and leave to be loaded from there.


={============================================================================
*kt_dev_env_vim_004* plugins: solarized

{solarized-colorscheme}
Not working with neobundle and done manually by coyping into .vim/color
https://github.com/altercation/vim-colors-solarized
http://ethanschoonover.com/solarized

Option 1: Manual installation

Move solarized.vim to your .vim/colors directory. After downloading the vim script or package:

$ cd vim-colors-solarized/colors
$ mv solarized.vim ~/.vim/colors/


={============================================================================
*kt_dev_env_vim_005* plugins: status line

{status}
https://github.com/bling/vim-airline


={============================================================================
*kt_dev_env_vim_006* plugins: unite

{unite}
https://github.com/Shougo/unite.vim
http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/

note: requires vimproc 

:Unite [options] source [source]

{source}
See :h unite-source for more and here are some. The source is where candidates comes from.

file              Browse the list of files in the current directory
file_rec          Recursively list files under the current directory

file_mru          Recursively list files under the current directory
note: Please install https://github.com/Shougo/neomru.vim

file_rec/async    Similar to |unite-source-file_rec|, but get files asynchronously.
file_rec/git      Similar to |unite-source-file_rec|, but get files by "git
directory         Nominates an input directory as a candidate.

" not consider since the workflow would not use a tab.
"
" buffer_tab        Nominates opened buffers only in the current tab as
" note: This source requires |tabpagebuffer|.  Please install http://github.com/Shougo/tabpagebuffer.vim

tab               Nominates opened tabs as candidates
bookmark          Nominates files or directories you bookmarked as candidates.
mapping           Nominates Vim mappings as candidates.
grep              Nominates "grep" command output as candidates.
output            Nominates executed Vim command as candidates.
find              Nominates "find" command output as candidates.
jump              Nominates results of |:jumps| command as candidates.
history/yank      Nominates yanked words.
change            Nominates results of |:changes| command as candidates.


<pass-arg-to-source>
Unite can accept a list of strings, separated with ":", after the name of sources. You must escape
":" and "\" with "\" in parameters themselves. "::" is an abbreviation argument. It depends on the
sources how the parameters are interpreted.

Examples:
"file:foo:bar": the parameters of source file are ["foo", "bar"].
"file:foo\:bar": the parameter of source file is ["foo:bar"].
"file:foo::bar": the parameters of source file are ["foo", "", "bar"].


<bang-on-source>
With large projects this may cause some performance problems. Normally it is recommended to use
unite-source-file_rec/async source, which requires vimproc. The mapping might look something like
this: 

nnoremap <leader>r :<C-u>Unite -start-insert file_rec/async:!<CR>

note: see how to use bang for a source

nnoremap <silent> [unite]<space> :<C-u>Unite -toggle -auto-resize \
    -buffer-name=mixed file_rec/async:! buffer file_mru bookmark<cr><c-u>


<order>
The order of sources in mapping reflected in the order of candidates.

shows file_rec first
nnoremap <C-u> :Unite -toggle -auto-resize -buffer-name=files file_rec/async file_mru <cr>

shows fime_mru first
nnoremap <C-u> :Unite -toggle -auto-resize -buffer-name=files file_mru file_rec/async<cr>

<normal-insert-modes>
If you start unite it splits the window horizontally and pops up from the top of Vim by default.
When run command, wait input in input mode and can filter the candidate. In normal mode, can use
usual keys to navigate. 'q' exit a windows in normal mode.

note: In short, input mode is to 'filter' the candidates.

note: The unite action file_rec does a recursive file matching by default without the need to set
wildcards.

<actions> :h unite-actions
Both Normal and Insert mode have mappings. For example, pressing a in Normal mode when the cursor is
over a file will cause Unite to show a list of file manipulation commands. This list of commands is
known as actions, and the list can be searched and invoked just like anything else in Unite.

Wildcards can be combined with actions. If I type :Unite file, then press * to mark all files, then
type a to list actions, and finally select above, Unite will open all of the marked files in split
windows.

Default actions

kind        action
----------  ----------
file        open
buffer      open
tab         open
directory   narrow
word        insert
jump_list   open
source      start


<where-to-start>
:UniteWithCurrentDir [{options}] {sources}
Equivalent to :Unite except that it targets the current directory for the initial narrowing text.

:UniteWithBufferDir [{options}] {sources}
Equivalent to :Unite except that it targets the buffer's directory for the initial narrowing text.

:UniteWithProjectDir [{options}] {sources}
Equivalent to :Unite except that it targets the project directory for the initial narrowing text.

nnoremap <silent> [unite]c  :<C-u>UniteWithCurrentDir
   \ -buffer-name=files buffer bookmark file<CR>

<filters> h: unite-filters


{unite-keys}
See :h unite-key-mappings for more.

<normal-mode-keys> 
seleced ones

{lhs}    {rhs}
-------- -----------------------------
i        |<Plug>(unite_insert_enter)|
a        In case when you selected a candidate, |<Plug>(unite_choose_action)|
         else |<Plug>(unite_append_enter)|

q        |<Plug>(unite_exit)|
Q        |<Plug>(unite_all_exit)|

<C-r>    |<Plug>(unite_restart)|    
note: restart "source". for example, can change "path" and re-read files.

<Space>  |<Plug>(unite_toggle_mark_current_candidate)|
<Tab>    |<Plug>(unite_choose_action)|

<C-l>    |<Plug>(unite_redraw)|
note: clear cache.

gg       |<Plug>(unite_cursor_top)|
G        |<Plug>(unite_cursor_bottom)|
j        |<Plug>(unite_loop_cursor_down)|
k        |<Plug>(unite_loop_cursor_up)|

g?       |<Plug>(unite_quick_help)|
note: shows these key mappings

.        |<Plug>(unite_narrowing_dot)|
note: narrowing?

<CR>     In case when you selected a candidate, runs default action
b        In case when you selected a candidate, runs bookmark action
d        In case when you selected a candidate, runs delete action
note: when tries, get an error saying no delete action.

e        In case when you selected a candidate, runs narrow action
t        In case when you selected a candidate, runs tabopen action
yy       In case when you selected a candidate, runs yank action
o        In case when you selected a candidate, runs open action
p        In case when you selected a candidate, runs preview action
x        In case when you selected a candidate, runs |<Plug>(unite_quick_match_default_action)|


{cache-size}
Specify the maximum number of files that |unite-source-file_rec| saves the
caches. The default value is 2000.

Q: file_rec and file_rec/async cannot find all files.
https://github.com/Shougo/unite.vim/issues/356
https://github.com/Shougo/unite.vim/issues/370

A: It is feature. cf: |g:unite_source_rec_max_cache_files|. And the default max
candidates are limited. You can custom it by

|unite#custom#source()|. >
        let g:unite_source_rec_max_cache_files = 0
        call unite#custom#source('file_rec,file_rec/async',
        \ 'max_candidates', 0)

And you must clear previous cache in file_rec sources. To clear cache, you must
execute |<Plug>(unite_redraw)| in unite buffer(in default it is mapped to
        <C-l>).


{custom-config}
Use to set options rather than using variables like this:

g:unite_kind_file_vertical_preview

If this variable is 1, Unite will open the preview window
vertically rather than horizontally.
Note: This variable is deprecated.  Please use
|unite#custom#profile()| instead.


So how?

unite#custom#profile({profile-name}, {option-name}, {value})

Set {profile-name} specialized {option-name} to {value}.

context  (Dictionary)

Specify option(key) and its value for unite buffer or predefined "default" buffer. 

Note: If you want to change default context, you should use "default" profile name.

Note: If you use single source in unite.vim commands with omitting profile name and buffer name,
"source/{source-name}" is used. Thus, you can define a source-specific profile. Valid key
context is in |unite-options|. 

However, "-" is substituted to "_", and "-" prefix is removed. This means that:

option "-start-insert" becomes "start_insert" in profile setting.


" Start insert mode in unite-action buffer.
call unite#custom#profile('action', 'context', {'start_insert' : 1})

" Set "-no-quit" automatically in grep unite source.
call unite#custom#profile('source/grep', 'context', {'no_quit' : 1})

" Use start insert by default.
call unite#custom#profile('default', 'context', {'start_insert' : 1})


={============================================================================
*kt_dev_env_vim_007* plugins: unite and tags

{unite-tag}
http://majutsushi.github.io/tagbar/
https://github.com/tsukkee/unite-tag
Get it downloaded and copy tag.vim to
/home/kit/.vim/bundle/unite.vim/autoload/unite/sources where unite installed.


={============================================================================
*kt_dev_env_vim_008* plugins: ycm

{ycm}

https://github.com/Valloric/YouCompleteMe

1. Ensure that your version of Vim is at least 7.3.584 and that it has support for python2
scripting. Might need to build gvim.


={============================================================================
*kt_dev_env_vim_009* plugins: ctrlp

{ctag-ctrlp}

http://blog.stwrt.ca/2012/10/31/vim-ctags

Vim + Ctags + Ctrlp

If you're using the Ctrlp plugin for vim, running :CtrlPTag will let you search through your tags
file and jump to where tags are defined. Very useful when you need to jump around a project in a
hurry.

http://kien.github.io/ctrlp.vim/

___________
basic usage

Run :CtrlP or :CtrlP [starting-directory] to invoke CtrlP in find file mode.
Run :CtrlPBuffer or :CtrlPMRU to start CtrlP in find buffer or find MRU file mode.
Run :CtrlPMixed to search in Files, Buffers and MRU files at the same time.

Check :help ctrlp-commands and :help ctrlp-extensions for other commands. Once CtrlP is open:

Press <F5> to purge the cache for the current directory to get new files, remove deleted files and
apply new ignore options.
* Press <c-f> and <c-b> to cycle between modes.
Press <c-d> to switch to filename search instead of full path.
Press <c-r> to switch to regexp mode.
* Use <c-j>, <c-k> or the arrow keys to navigate the result list.
* Use <c-t> or <c-v>, <c-x> to open the selected entry in a new tab or in a new ver/hor split.
Use <c-n>, <c-p> to select the next/previous string in the prompt's history.
Use <c-y> to create a new file and its parent directories.
Use <c-z> to mark/unmark multiple files and <c-o> to open them.

Run :help ctrlp-mappings or submit ? in CtrlP for more mapping help.

Submit two or more dots .. to go up the directory tree by one or multiple levels.
End the input with a colon : followed by a command to execute it after opening the file:
  Use :25 to jump to line 25.
  Use :/any\:\ string to jump to the first instance of any: string.
  Use :+setfiletype\ myfiletype|25 to set the filetype to myfiletype then jump to line 25.
  Use :diffthis when opening files marked by <c-z> to run :diffthis on the first 4 files.

___________
intallation

1. Clone the plugin into a separate directory:
$ cd ~/.vim
$ git clone https://github.com/kien/ctrlp.vim.git bundle/ctrlp.vim

2. Add to your ~/.vimrc:
set runtimepath^=~/.vim/bundle/ctrlp.vim

3. Run at Vim's command line:
:helptags ~/.vim/bundle/ctrlp.vim/doc

It's also handy to bind this to a keyboard shortcut. I use this in my ~/.vimrc:

nnoremap <leader>. :CtrlPTag<cr>

http://www.bestofvim.com/plugin/ctrl-p/ and for other extensions

" for ctrlp
" tag
nnoremap ,t :CtrlPTag<cr>
" func list
nnoremap ,c :CtrlPFunky<cr>
" file
nnoremap ,f :CtrlP<cr>
" buffer
nnoremap ,b :CtrlPBuffer<cr>
" mru
nnoremap ,m :CtrlPMRU<cr>
" dir
nnoremap ,d :CtrlPDir<cr>


{ctag-tagbar}

Vim + Ctags + Tagbar

http://majutsushi.github.io/tagbar/

Tagbar is another useful vim plugin for working with a tags file. Install it, and map a key to it (I
use ,b):

nnoremap <silent> <Leader>b :TagbarToggle<CR>

When the tagbar is toggled, it will pop up on the right side of the vim window and show the tags
picked up by ctags for the current file, organized by tag type, e.g. function, variable, class, etc.
This effectively gives you a birds-eye view of the code you're working on.


{ctag-rebuild}

<approach-one>
The following Vim key mapping is quite useful to rebuild the tag file in the directory of the
current source file:

:nmap ,t :!(cd %:p:h;ctags *.[ch])&

<approach-two>
This can be a pain in the ass to run regularly, so you might like to bind it to a vim keyboard
shortcut so you can run it every so often, or add some git hooks to run ctags every time you check
out, commit, or fetch with git

http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html


={============================================================================
*kt_dev_env_vim_010* plugins: neocomplete

{plugins}

"
" neocomplete

https://github.com/Shougo/neocomplete.vim

Requited by unite-tag. May need to build vim to enalbe lua features and creates caches background
using vimproc.

g:neocomplete#ctags_arguments
It is the dictionary of the character string to set a value to give as an argument of the commands
when buffer and include use a ctags command. The dictionary's key is filetype. If the key is "_", it
will be used for default.

Because it is complicated, refer to neocomplete#init#_variables() in autoload/neocomplete/init.vim
for the initial value.

" Initialize ctags arguments. "{{{
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments',
     \ '_', '')
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments', 'vim',
     \ '--extra=fq --fields=afmiKlnsStz ' .
     \ "--regex-vim='/function!? ([a-z#:_0-9A-Z]+)/\\1/function/'")
 call neocomplete#util#set_default_dictionary(
       \ 'g:neocomplete#ctags_arguments', 'c',
       \ '-R --sort=1 --c-kinds=+p --fields=+iaS --extra=+q ' .
       \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
       \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
call neocomplete#util#set_default_dictionary(
     \ 'g:neocomplete#ctags_arguments', 'cpp',
     \ '--language-force=C++ -R --sort=1 --c++-kinds=+p --fields=+iaS --extra=+q '.
     \ '-I __wur,__THROW,__attribute_malloc__,__nonnull+,'.
     \   '__attribute_pure__,__attribute_warn_unused_result__,__attribute__+')
"}}}


{snippet}

What is the snippet? From snipmate:

Here's a simple example. Once installed, put this in a ~/.vim/snippets/javascript.snippet file:

snippet log
    console.log(${1});

Now when you're editing a .js file, typing log<TAB> will expand into console.log();, and put the
cursor in between the brackets. You're still in insert mode, so you just carry on typing your log
statement.


{ultisnips}

https://github.com/SirVer/ultisnips

.vim/bundle/ultisnips/UltiSnips/cpp.snippets


{when-do-not-use-other-plugins}

Vim's own implementation.

Vim documentation: insert

7. Insert mode completion				*ins-completion*

In Insert and Replace mode, there are several commands to complete part of a keyword or line that
has been typed.  This is useful if you are using complicated keywords (e.g., function names with
capitals and underscores).

These commands are not available when the |+insert_expand| feature was disabled at compile time.


Completion can be done for:

1. Whole lines						|i_CTRL-X_CTRL-L| [KT] works
2. keywords in the current file				|i_CTRL-X_CTRL-N|
3. keywords in 'dictionary'				|i_CTRL-X_CTRL-K|
4. keywords in 'thesaurus', thesaurus-style		|i_CTRL-X_CTRL-T|
5. keywords in the current and included files		|i_CTRL-X_CTRL-I|
6. tags							   |i_CTRL-X_CTRL-]| [KT] works
7. file names						|i_CTRL-X_CTRL-F| [KT] works
8. definitions or macros				|i_CTRL-X_CTRL-D|
9. Vim command-line					|i_CTRL-X_CTRL-V|
10. User defined completion				|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. Spelling suggestions				|i_CTRL-X_s|
13. keywords in 'complete'				|i_CTRL-N|


 [KT] useful to repeat the same line which typed before. 

Completing whole lines					*compl-whole-line*
							               *i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the same characters as those in the
current line before the cursor.  Indent is ignored.  The matching line is inserted in front of the
cursor.  The 'complete' option is used to decide which buffers are searched for a match.  Both
loaded and unloaded buffers are used.

CTRL-L	or CTRL-P		Search backwards for next matching line.  This line replaces the previous
matching line.

CTRL-N		Search forward for next matching line.  This line replaces the previous matching line.

CTRL-X CTRL-L	After expanding a line you can additionally get the line next to it by typing CTRL-X
CTRL-L again, unless a double CTRL-X is used.  Only works for loaded buffers.


 [KT] works regardless of using completion plugin. uses tag file.

Completing tags						*compl-tag*
							            *i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same characters as before the
cursor.  The matching tag is inserted in front of the cursor.  Alphabetic characters and characters
in 'iskeyword' are used to decide which characters are included in the tag name (same as for a
keyword).  See also |CTRL-]|.  The 'showfulltag' option can be used to add context from around the
tag definition.  

CTRL-]	or CTRL-N		Search forwards for next matching tag.  This tag replaces the previous
matching tag.

CTRL-P		Search backward for previous matching tag.  This tag replaces the previous matching tag.

Can use this mapping:
inoremap <c-x><c-]> <c-]>


Completing file names					*compl-filename*
							               *i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the same characters as before the
cursor.  The matching file name is inserted in front of the cursor.  Alphabetic characters and
characters in 'isfname' are used to decide which characters are included in the file name.  Note:
the 'path' option is not used here (yet).

CTRL-F	or CTRL-N		Search forwards for next matching file name.  This file name replaces the
previous matching file name.

CTRL-P		Search backward for previous matching file name.  This file name replaces the previous
matching file name.

{omni-completion}

omni completion is based on a ctags file. If you want a 'full' C language completion, you need to
first create a tags file scanning /usr/include, /usr/local/include and so on. In my laptop (AMD 64
900 MHz), executing this:

ctags -R -f ~/.vim/systags /usr/include /usr/local/include

takes almost 6 minutes and the generated file is as big as 791M. In addition if you install a new
development library, you will need to scan the .h files to add them to you tags file. Personally I
do not use omni completion as I do not think it is mature enough yet.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*

The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.

From vim7.4

./autoload/ccomplete.vim   " this shows how to access tag data
./autoload/xmlcomplete.vim
./autoload/csscomplete.vim
./autoload/adacomplete.vim
./autoload/clojurecomplete.vim
./autoload/javascriptcomplete.vim
./autoload/pythoncomplete.vim
./autoload/syntaxcomplete.vim
./autoload/sqlcomplete.vim
./autoload/phpcomplete.vim
./autoload/python3complete.vim
./autoload/htmlcomplete.vim
./autoload/rubycomplete.vim

Accessing tag data in vimscript
http://andrewradev.com/2011/06/08/vim-and-ctags/


={============================================================================
*kt_dev_env_vim_011* plugins: indent-guide

https://github.com/nathanaelkane/vim-indent-guides


={============================================================================
*kt_dev_env_vim_012* plugins: ag or ack

https://github.com/ggreer/the_silver_searcher

Build from source.
0. clone
1. apt-get install -y automake pkg-config libpcre3-dev zlib1g-dev liblzma-dev
2. ./build.sh
3. sudo make install


{use}
https://github.com/ggreer/the_silver_searcher/blob/master/doc/ag.1.md

ag [] [] PATTERN [PATH]

--[no]color: Print color codes in results. Enabled by default.

--[no]group: The default, --group, lumps multiple matches in the same file together, and presents
them under a single occurrence of the filename. --nogroup refrains from this, and instead places
the filename at the start of each match line.

" when not use --nogroup
sctp/ipv6.c
689:		return sizeof(struct sockaddr_in);
690:	return sizeof(struct sockaddr_in6);
998:	.sockaddr_len	   = sizeof(struct sockaddr_in6),

" when use --nogroup
sctp/ipv6.c:689:		return sizeof(struct sockaddr_in);
sctp/ipv6.c:690:	return sizeof(struct sockaddr_in6);
sctp/ipv6.c:998:	.sockaddr_len	   = sizeof(struct sockaddr_in6),

-C --context [LINES]: Print lines before and after matches. Defaults to 2.

-S --smart-case: Match case-sensitively if there are any uppercase letters in PATTERN,
  case-insensitively otherwise. Enabled by default.

<keep-color>
$ ag getMediaRecord* | less
$ ag getMediaRecord* | less -r or -R

All doesn't work since it seems ag do not output color esc chars when use pipe. Use the following
commands to around this.

$ ag --pager "less -r" getMediaRecord*


alias ag='ag -C 4 -S --color-path="1;31" --color-match="1;35" --pager "less -r"'

<bug>
$ ag 'SystemClientEvent('     // causes terminal broken
$ ag 'SystemClientEvent\('    // works okay


{ack}
curl http://beyondgrep.com/ack-2.14-single-file > ~/bin/ack && chmod 0755 !#:3


={============================================================================
*kt_dev_env_vim_013* plugins: netrw: run browser on link in vim

:let g:netrw_browsex_viewer= "iceweasel"

use gx on a link in vim 

Q: seems that vim gets blocked while a brower is running.


==============================================================================
*kt_dev_env_vim_003*	key sheet 

      " from {move-screen}
C-d	" down half screen. inoremap <C-d> <C-d>zz
C-u	" up half screen (backward). inoremap <C-u> <C-u>zz

C-^	" switch between the previous and the next in the list


==============================================================================
*kt_dev_env_vim_002*	config

{scriptnames}

:scrip[tnames]		List all sourced script names, in the order they were first sourced.


{set-font-for-gvim}

when use bigger screen with gvim, it is hard to read so need to change font. try 'edit->select font'
in the menu to see which is better then set it in .vimrc.

FreeMono, 12pt


{vimrc-linux}

# vars from ver

   system vimrc file: "$VIM/vimrc"
     user vimrc file: "$HOME/.vimrc"
      user exrc file: "$HOME/.exrc"
  system gvimrc file: "$VIM/gvimrc"
    user gvimrc file: "$HOME/.gvimrc"
    system menu file: "$VIMRUNTIME/menu.vim"
  fall-back for $VIM: "/usr/share/vim"


--
if has("gui_running")
  if has("gui_gtk2")
    set guifont=FreeMono\ 12
  endif
endif

" clipboard
set clipboard=unnamed
set clipboard=unnamedplus

" for user syntax
syntax enable

set incsearch

" set ignorecase
" for line number
set nu

set smartindent
set shiftwidth=4
set tabstop=4

" show autocomplete menus
set wildmenu

" show editing mode
set showmode

colorscheme desert

" help: auto-format
" set formatoptions+=a

set cursorline

set autoread
set hlsearch
set nowrapscan

set foldenable


{vimrc-windows}

:e $VIM\_vimrc
:echo $VIM

--
set nocompatible
filetype on
filetype plugin on
source $VIMRUNTIME/vimrc_example.vim
source $VIMRUNTIME/mswin.vim
behave mswin

set diffexpr=MyDiff()
function MyDiff()
  let opt = '-a --binary '
  if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
  if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
  let arg1 = v:fname_in
  if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
  let arg2 = v:fname_new
  if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
  let arg3 = v:fname_out
  if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
  let eq = ''
  if $VIMRUNTIME =~ ' '
    if &sh =~ '\<cmd'
      let cmd = '""' . $VIMRUNTIME . '\diff"'
      let eq = '"'
    else
      let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
    endif
  else
    let cmd = $VIMRUNTIME . '\diff'
  endif
  silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3 . eq
endfunction

" for user syntax
syntax enable

set incsearch

" set ignorecase
" for line number
set nu

set smartindent
set shiftwidth=4
set tabstop=4

" show autocomplete menus
set wildmenu

" show editing mode
set showmode

colorscheme darkblue
" colorscheme desert

" help: auto-format
" set formatoptions+=a

" to highlight currentline
set cursorline

set autoread
set hlsearch
set nowrapscan

set foldenable
" set foldmethod=syntax
" set foldlevelstart=1
" set foldnestmax=5
" let g:is_bash=1
" let g:sh_fold_enabled=4
" let sh_fold_functions=1

" marks. to save the session info for up to 100 files and not to save global marks
"set viminfo='100,f0

au BufWinEnter,BufRead,BufNewFile *.nds set filetype=nds

" enable fold save and restore
au BufWinEnter *.nds silent loadview
au BufWinLeave *.nds mkview

" to see only matched line. do search first and hit \z
nnoremap \z :setlocal foldexpr=(getline(v:lnum)=~@/)?0:(getline(v:lnum-1)=~@/)\\|\\|(getline(v:lnum+1)=~@/)?1:2 foldmethod=expr foldlevel=0 foldcolumn=2<CR>
--


{option-window}

Like option menu, opens a option window where can change options by using <Enter> to toggle

:options

To get help about options, use singled-quoted help

:help 'option-name'


={============================================================================
*kt_dev_env_vim_097* sample dot vimrc files

https://github.com/whiteinge/dotfiles/blob/master/.vimrc

https://github.com/eddie/dotfiles/blob/master/vim/vimrc


={============================================================================
*kt_dev_env_vim_098* key mapping: traverse a list

Typing :bn and :bp can feel laborious. To speed things up a bit, I use these mappings from Tim
Pope's unimpaired.vim plugin: https://github.com/tpope/vim-unimpaired

nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

Vim already uses the [ and ] keys as prefixes for a series of related commands (see :h [ ), so these
mappings have a consistent feel to them. The unimpaired.vim plugin provides similar mappings for
scrolling through the argument( [a and ]a ), quickfix ([q and ]q ), location ( [l and ]l ), and tag
lists ( [t and ]t ). Check it out.

map <C-n> :cn<CR>
map <C-p> :cp<CR>


={============================================================================
*kt_dev_env_vim_099* key mapping

http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29

See notation when use mapping. Must enter <F5> by typing four characters. Similarly, <Esc> is not
entered by pressing the <Esc> key, but by typing five characters.


{key-mapping}
Key mapping refers to creating a shortcut for repeating a sequence of keys or commands. You can map
keys to execute frequently used key sequences or to invoke an Ex command or to invoke a Vim function
or to invoke external commands. 

The general syntax of a map command is: 

{cmd} {attr} {lhs} {rhs}

where
{cmd}  is one of ':map', ':map!', ':nmap', ':vmap', ':imap',
       ':cmap', ':smap', ':xmap', ':omap', ':lmap', etc.

{attr} is optional and one or more of the following: <buffer>, <silent>,
       <expr> <script>, <unique> and <special>.
       More than one attribute can be specified to a map.

{lhs}  left hand side, is a sequence of one or more keys that are being mapped.
{rhs}  right hand side, is the sequence of keys that the {lhs} keys are mapped to.
note: map lhs to rhs.

Examples:

map <F2> :echo 'Current time is ' . strftime('%c')<CR>
nnoremap <silent> <F2> :lchdir %:p:h<CR>:pwd<CR>

Three steps to define maps:

The first step in creating a map is to decide the sequence of keys that needs to be mapped. When you
invoke a map, Vim will execute the sequence of keys as though you entered it from the keyboard. You
can do this by manually entering the key sequence and verifying that they perform the desired
operation.

The second step is to decide the editing mode; insert mode, visual mode, command-line mode, normal
mode, etc. in which the map should work. Instead of creating a map that works in all the modes, it
is better to define the map that works only in selected modes.

The third step is to find an unused key sequence that can be used to invoke the map. You can invoke
a map using either a single key or a sequence of keys. :help map-which-keys 


{what-keys-to-map} h: map-which-keys
If you are going to map something, you will need to choose which key(s) to use for the {lhs}. You
will have to avoid keys that are used for Vim commands, otherwise you would not be able to use those
commands anymore. Here are a few suggestions:

@ Function keys <F2>, <F3>, etc..  Also the shifted function keys <S-F1>, <S-F2>, etc.  Note that
<F1> is already used for the help command.

@ Meta-keys (with the ALT key pressed).  Depending on your keyboard accented characters may be used
as well. |:map-alt-keys|

@ Use the '_' or ',' character and then any other character.  The "_" and "," commands do exist in
Vim (see |_| and |,|), but you probably never use them.

@ Use a key that is a synonym for another command. For example: CTRL-P and CTRL-N. Use an extra
character to allow more mappings.

@ The key defined by <Leader> and one or more other keys. This is especially useful in scripts.
|mapleader|


<to-check-if-key-used>
See the file "index" for keys that are not used and thus can be mapped without losing any builtin
function. You can also use ":help {key}^D" to find out if a key is used for some command. {key} is
the specific key you want to find out about, ^D is CTRL-D.


{slient-key}
http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_2%29

When a map is invoked, the sequence of keys executed is displayed on the screen. If an Ex command is
invoked by the map, then you can see the Ex command at the Vim status line. To silently execute a
map, use the <silent> attribute for the map.


{leader-key}
If the key maps provided by all the Vim plugins start with a same key, then it is easier for a user
to distinguish between his own key maps and the ones provided by plugins. To facilitate this, Vim
provides a special keyword that can be used in a map command.

If the {lhs} key sequence of a map command starts with the string "<Leader>", then Vim replaces it
with the key set in the 'mapleader' variable.

The default setting for the 'mapleader' variable is backslash ('\'). Note that 'mapleader' is a Vim
variable and not a Vim option. The value of this variable can be changed using the 'let' command.
For example, to set it to '_' (underscore), you can use the following command in your vimrc file:

let mapleader = "_"

Vim replaces <Leader> with the 'mapleader' value only when defining the map and not when the map is
invoked. This means that after several map commands are defined if the 'mapleader' variable is
changed, it will not affect the previously defined maps. 

Vim provides the <Leader> key as a namespace for our own user-defined commands. Here is how we can
create our own custom mappings using <Leader> :

noremap <Leader>n nzz
noremap <Leader>N Nzz

note: nmap <silent> <leader>s :set spell<CR> and leader or Leader will work?

The default leader key is \ , so we could trigger these custom mappings by pressing \n and \N.


{list-key-maps} vim-modes
The ':map' command creates a key map that works in normal, visual, select and operator pending
modes. The ':map!' command creates a key map that works in insert and command-line mode. 

To display the mode specific maps, prefix the ':map' command with the letter representing the mode. 

:nmap - Display normal mode maps
:imap - Display insert mode maps
:vmap - Display visual and select mode maps
:smap - Display select mode maps
:xmap - Display visual mode maps
:cmap - Display command-line mode maps
:omap - Display operator pending mode maps

The following characters may be displayed before the {rhs} of the map: 

<noremap>
The {rhs} of the map is not re-mappable. Defined using the ':noremap' or ':nnoremap' or ':inoremap',
etc. commands.

To display all the key maps that start with a particular key sequence, enter the key sequence in the
above commands. For example, the following command displays all the normal mode maps that start with
'g'.

:nmap g

Typically the output of the above commands will span several pages. You can use the following set of
commands to redirect the output to the vim_maps.txt file:

<redirection>
:redir! > vim_maps.txt
:map
:map!
:redir END


{removing-keymap} to check if mapping exist
To permanently remove a map, you first need to locate the place where it is defined by using the
':verbose map {lhs}' command (replace {lhs} with the mapped key sequence). 

note: difference from the other way above? 

Another approach is to use the ':unmap' and ':unmap!' commands to remove the map

:unmap <F8>
:unmap! <F8>

:nnoremap [unite] <nop>

note that after a key is unmapped using the ':unmap' command, it can be mapped again later. Also you
cannot unmap a key used by one of the Vim internal commands. Instead you have to map it to <Nop> to
disable it's functionality.

If you are trying to disable a key map defined by a plugin, make sure the unmap command is executed
after the key map is defined by the plugin. To do this in .vimrc, use autocmd:

autocmd VimEnter * unmap! <F8>

Filetype plugins can be a little tricky, because they can redefine mappings any time you open a file
of a certain type. You can just use a different autocmd event for this, e.g.:

autocmd FileType python unmap! <F8>

The mode-specific unmap commands are listed below:

nunmap - Unmap a normal mode map
vunmap - Unmap a visual and select mode map
xunmap - Unmap a visual mode map
sunmap - Unmap a select mode map
iunmap - Unmap an insert and replace mode map
cunmap - Unmap a command-line mode map
ounmap - Unmap an operator pending mode map

____________________
storing the key maps

If you want to restore the key maps across Vim instances, you need to save the map definition
command in a file.

One place to store the map commands is the $HOME/.vimrc or $HOME/_vimrc or $VIM/_vimrc file. If you
have <filetype-specific-key-maps>, then you can store them in the filetype specific plugin files.
The key maps defined by Vim plugins are stored in the plugin or script file itself.

When adding the map commands to a file, there is no need to prefix the commands with the ':' character. 


{mode-specific-maps}
Commands                         Mode
--------                         ----
nmap, nnoremap, nunmap           Normal mode
imap, inoremap, iunmap           Insert and Replace mode
vmap, vnoremap, vunmap           Visual and Select mode
xmap, xnoremap, xunmap           Visual mode only
smap, snoremap, sunmap           Select mode only
cmap, cnoremap, cunmap           Command-line mode
omap, onoremap, ounmap           Operator pending mode
:map!  :noremap! :unmap!         Insert and Command-line
:map   :noremap  :unmap          Normal, Visual, Select, Operator-pending

Note that the language specific mappings defined using the ':lmap' and ':lnoremap' commands are not
discussed here. For more information about this refer to the Vim help. 

<example> 
@ maps the <F5> key to search for the keyword under the cursor in the current directory using the
grep command. note: works and useful

:nnoremap <F5> :grep <C-R><C-W> *<CR>

From a normal mode map, you can get the keyword under the cursor using the expand('<cword>')
function or using the <C-R><C-W> command. For example, the following two map commands provide the
same functionality

@ maps ',b' to show the buffer list and invoke the ':buffer' command to switch to the desired
buffer number and hit <Enter>.  note: see mutiple actions.

:nnoremap ,b :ls<CR>:buffer<Space>

If you invoke an Ex command from a map, you have to add a <CR> or <Enter> or <Return> at the end of
the Ex command to execute the command. Otherwise the command will not be executed. ls command in the
above example.

note: this example: ls<cr> shows buffer list and buffer<space> waits input from user. so select
buffer when give buffer_number<cr>.


:map! <F3> a<C-R>=strftime('%c')<CR><Esc>
maps the <F3> key to insert the current date and time in the current buffer. 


{useful-examples}
you need to change a word such as "amount" into "{amount}":

:map <F5> i{<Esc>ea}<Esc>


{trigger-key}
The trigger can be 'any' string. One key that can be used with mappings is the backslash. Since you
probably want to define more than one mapping, add another character. You could map "\p" to add
parentheses around a word, and "\c" to add curly braces, for example:

:map \p i(<Esc>ea)<Esc>
:map \c i{<Esc>ea}<Esc>

You need to type the \ and the p quickly after another, so that Vim knows they belong together.

note: is to expand the set of keys to map. \ is an example.

map <C-\>^] :GtagsCursor<CR>

note: can use this and C-o instead of using tag stack. However, it uses jump list rather than tag
stack so if you move around tags lists using C-n this will also in the jump list so not quite the
same as the tag stack.

map <C-]> :GtagsCursor<CR>


{exe-and-expand}
This map uses the expand() function to get the keyword under the cursor and then invokes the "tag"
command with the current keyword. The "execute" command is used to concatenate the tag command and
the output of the expand() function

:nnoremap <2-LeftMouse> :exe "tag ". expand("<cword>")<CR>

This mapping yanks the visually selected text and searches for it in C files. This is a complicated
mapping: 

vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ *.c *.h"<CR>


# ============================================================================
#{
={============================================================================
*kt_dev_env_vim_100* helps

{help-doc}
http://vimdoc.sourceforge.net/htmldoc/usr_01.html#vimtutor


{help}

:help {subject}
:help CTRL-A         # for normal mode cmds
:help i_CTRL-H       # mode prefix. for insert mode cmds

shift-k (K) cmd. study.

<search-in-help>
:h {patt} then press Ctrl-D to list all topics that contain "patt".
:h {patt} then press Tab to scroll through the topics that start with "patt". 

Sometimes you want to know what a particular control key means to Vim. For example, to see all help
topics containing "ctrl-r", type :h ctrl-r then press Ctrl-D. 

<navigate-in-help>
<C-]>    " to follow the link (jump to the quickref topic). After browsing the quickref topic,
<C-T>    " to go back to the previous topic.


={============================================================================
*kt_dev_env_vim_101* dot command

The help says that "repeat last change" but need to understand what this change means. This includes
any changes by running any commands which 'create' a change such as normal mode commands and
i{insert some text}<ESC> command. For example, 'x', 'dd', '>G', and 'i change text esc'.

So the dot command is like a mini macro.


<example>
How to add ';' at the end of each line?

var foo = 1
var bar = 'a'
var foobar = foo + bar

1. run '$a;<ESC>' and 'j$.' on the rest. This still needs '$' to position a cursor to do the repeat.
Is there a better way to save more key strokes?

2. run 'A;<ESC>' and 'j.' on the rest. This saves one more by using the compound commands. Here
'A==$a'. See <compound-command> for more.

note: As shown in tip26, can use visual block mode to do the same. Position at 1 in line 1, <C-v>jj,
$, A;, <ESC>

<example>
Change:
var foo = "method("+argument1+","+argument2+")";

To:
var foo = "method(" + argument1 + "," + argument2 + ")";

1. 'f+', 's<SP>+<SP><ESC>', ';.', ';.'... See <motion-char-move> for f command.


<key>
The key is that can achieve an optimal editing strategy by making both the motion and the change
repeatable. note that focus on 'make' the change repeatable. Vim is optimized for repetition. In
order to exploit this, we have to be 'mindful' of how we compose our changes.

<example>
Change 'content' all to 'copy'.

...We're waiting for content before the site can go live...
...If you are content with this, let's go ahead with it...
...We'll launch as soon as we have the content...

Can use blindly substitude command but the point is we have to watch our for false matches. The
alternative is to use dot command instead.

1. Place cursor at content, '*', 'cwcopy<ESC>', n, ., ...


<dot-fomular>
The Ideal: One Keystroke to Move, One Keystroke to Execute

In all of these examples, using the dot command repeats the last change. But that's not the only
thing they share. A single keystroke is all that's required to move the cursor to its next target.
We're using one keystroke to move and one keystroke to execute. It can't really get any better than
that, can it? It's an ideal solution. We'll see this editing strategy coming up again and again, so
for the sake of convenience, we'll refer to this pattern as the Dot Formula.


={============================================================================
*kt_dev_env_vim_102* chunk your undo

u        " undo
<C-r>    " redo


{granularity-of-the-undo-command}
The key is that i{insert some text}<Esc> constitutes a change. In Vim, we can control the
granularity of the undo command. From the moment we enter Insert mode until we return to Normal
mode, everything we type (or delete) counts as a single change. So we can make the undo command
operate on words, sentences, or paragraphs just by moderating our use of the <Esc> key.

<by-sentence>
So how often should you leave Insert mode? It's a matter of preference, but I like to make each
"undoable chunk" correspond to a thought. As I write this text, I often pause at the end of a
sentence to consider what I'll write next.

<by-line>
If I'm in Insert mode with my cursor at the end of a line, the quickest way to open a new line is to
press <CR>. And yet I sometimes prefer to press <Esc>o just because I anticipate that I might want
that extra granularity from the undo command.

note:
Moving Around in Insert Mode Resets the Change

When I said that the undo command would revert all characters entered (or deleted) during a trip
into Insert mode and back, I was glossing over a small detail. If we use the <Up> , <Down> , <Left>
, or <Right> cursor keys while in Insert mode, a new undo chunk is created. It's just as though we
had switched back to Normal mode to move around with the h , j , k , or l commands, except that we
don't have to leave Insert mode. This also has implications on the operation of the dot command.


={============================================================================
*kt_dev_env_vim_103* operator, text object and motion

{operator} :h operator
Operator + Motion = Action

The {[prefix]operator}{motion} pattern. You first type an operator command. For example, 'd' is the
delete operator. Then you type a motion command like '4l' or 'w'. This way you can operate on any
text you can move over.

{text-object} :h text-objects
A special kind of motion. You can find a long list of text objects from help text-objects. Only be
used while in visual mode or after an operator.

Text objects are the next level up. If the f{char} and /pattern<CR> commands are like a flying kick
to the head, then text objects are like a scissors kick that strikes two targets with a single move.

<text-object-on-whole>
When the cursor is in the middle of a word and you want to delete that word. Instead of operating on
the text between the cursor position before and after a movement command, the text object is used as
a 'whole'. 

Unlike visual mode and motion, when we press vi}, Vim initiates Visual mode and then selects all of
the characters contained by the {} braces. Where the cursor is positioned to begin with doesn't
matter so long as it's located somewhere inside a block of curly braces when the i} text object is
invoked.

<bounded-text-object>
Words, sentences, and paragraphs are defined by boundaries, so I've labeled this category as bounded
text objects (Vim's documentation calls them "block" and "non-block" objects, but I find that to be
an unhelpful distinction).

iw    " Current word
aw    " Current word 'plus' one space
iW    " Current WORD
aW    " Current WORD plus one space
is    " Current sentence
as    " Current sentence plus one space
ip    " Current paragraph
ap    " Current paragraph plus one blank line

The example shows when 'aw' is useful. note that daw deletes a word including a space. If we used
diw instead, then we'd end up with two adjacent spaces

{start}  Improve your writing by deleting excellent adjectives.
                                           ^
daw      Improve your writing by deleting adjectives.

The example shows when 'iw' is useful.

{start}        Improve your writing by deleting excellent adjectives.
                                                 ^
ciwmost<Esc>   Improve your writing by deleting most adjectives.

As a general rule, we could say that the d{motion} command tends to work well with aw, as, and ap,
whereas the c{motion} command works better with iw and similar.


<inner-and-around>
Always either i or a. In general, we can say that the text objects prefixed with i select 'inside'
the delimiters, whereas those that are prefixed with a select everything including the delimiters.
As a mnemonic, think of i as inside and a as 'around' (or all). Can span multiple lines.

a) or ab       " A pair of (parentheses)
i) or ib       " Inside of (parentheses)
a} or aB       " A pair of {braces}
i} or iB       " Inside of {braces}
a]             " A pair of [brackets]
i]             " Inside of [brackets]
a>             " A pair of <angle brackets>
i>             " Inside of <angle brackets>
a             " A pair of 'single quotes'
i             " Inside of 'single quotes'
a"             " A pair of "double quotes"
i"             " Inside of "double quotes"
at             " A pair of <xml>tags</xml>
it             " Inside of <xml>tags</xml>


if( !entry.used && equiv && ( curcontext & entry.contexts))
            ^ cursor
if( !entry.used && equiv && ( curcontext & entry.contexts))
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ selected when run 'vib'

<img src="whi-vi-img/why-vi-1.gif" alt=""/>
                 ^ cursor
<img src="whi-vi-img/why-vi-1.gif" alt=""/>
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ selected when run 'vi>'

<text-object-in-command>
Visual mode makes for a nice introduction to text objects because it's easy to see what's happening.
But text objects reveal their true power when we use them in Operator-Pending mode.

Text objects are not motions themselves: we can't use them to navigate around the document. But we
can use text objects in Visual mode and in Operator- Pending mode. Remember this: whenever you see
{motion} as part of the syntax for a command, you can also use a text object.


<action-examples>
dw       " d{w} word. != daw since dw delete a word from the cursor but daw do as a whole
d4w
d2e
d$
d2l      " character
daw      " delete a word
das      " delete a sentence

gUaw     " gU{aw}, make uppercase a word
guaw
g~       " swap case

c        " change
c$

d        " delete
d$
dG       " delete to the end of file

y        " yank into register (does not change the text)
>        " shift right
<        " shift left
=        " autoindent
!        " filter {motion} lines through an external program

<on-current-line> double operator
Vim's grammar has just one more rule: when an operator command is invoked in duplicate, it acts upon
the current line. So dd deletes the current line, while >> indents it. The gU command is a special
case. We can make it act upon the current line by running either gUgU or the shorthand gUU.

cc       " change a whole current line
dd 
g~g~     " swap a case of a whole line

<compound-command> single letter command
Some operator motion commands are used so often that they have been given a single letter command:

x     dl  (delete character under the cursor)
X     dh  (delete character left of the cursor)
D     d$  (delete to end of the line)

note: The below all switch from Normal to Insert mode. Think about that and how it might affect the
dot command.

C     c$  (change to end of the line) note: change(delete and insert)
s     cl  (substitute, change one character)
S     cc  (substitute, change a whole line)
o     A<CR>
O     ko
I     start insert mode after moving the cursor to the first non-blank in the line.
A     start insert mode after moving the cursor to the end of the line.


<custom-operator-and-motion>
See page 25 in the practical vim.


{motion-char}
On the current line.

[num]f[char]   " 'find' char to the right the cursor in the line.
[num]F[char]   " 'find' char to the left the cursor in the line.

[num]t[char]   " the same f cmd but 'till' find the char. That is before the char to search
[num]T[char]   " 

[num];         " 'repeat' latest f, t, F or T [count] times.
,              " 'repeat' latest f, t, F or T in 'left' direction [count] times.

<example> 
{start}     I've been expecting you, Mister Bond.
f,          I've been expecting you, Mister Bond.
                                   ^
dt.         I've been expecting you.

In general, I tend to use f{char} and F{char} in Normal mode when I want to move the cursor quickly
within the current line, whereas I tend to use the t{char} and T{char} character search commands in
combination with d{motion} or c{motion}. To put it another way, I use f and F in Normal mode, and t
and T in Operator-Pending mode.

<tip>
But their efficiency varies depending on our choice of target. If we can make a habit of choosing
'less' common characters for use with the f{char} command, then well be more likely to strike our
target with a single move.

How to delete 'excellent' from the below?

Improve your writing by deleting excellent adjectives.

fx, daw but not fe...


{motion-line}
0     " to first character of real line
^     " to first 'nonblank' character of real line
$     " to end of real line
G     " to the last line of the file
gg    " to the top of the file


{motion-word} :h word-motions

w, W     " Forward to start of next word.               
b, B     " Backward to start of current/previous word
e, E     " Forward to end of current/next word
ge, gE   " Backward to end of previous word

<word-WORD>
A word consists of a sequence of letters, digits, and underscores, or as a sequence of other
nonblank characters separated with whitespace (see :h word). The definition of a WORD is simpler: it
consists of a sequence of nonblank characters separated with 'whitespace' (see :h WORD). 

e.g. we're going too slow

That example contains five WORDS and ten words since words stops at . and '.

<tip>
The 'iskeyword' option specifies which characters can appear in a word:

:set iskeyword
   iskeyword=@,48-57,_,192-255 

The "@" stands for all alphabetic letters. "48-57" stands for ASCII characters 48 to 57, which are
the numbers 0 to 9. "192-255" are the printable latin characters. Sometimes you will want to include
a dash in keywords, so that commands like "w" consider "upper-case" to be one word.  You can do it
like this:

:set iskeyword+=-
:set iskeyword
   iskeyword=@,48-57,_,192-255,- 

To remove:

:set iskeyword-=_

<key>
Which is better? Since word is wider than WORD, can move with fewer keys. Use WORD-wise motions if
you want to move faster, and use word-wise motions if you want a more fine-grained traversal. The
choice depends on cases.


{motion-search}
The serach is also motion.

before:
This phrase takes time but
eventually gets to the point.

after:
This phrase gets to the point.

To ways:
1. place cursor on t, "v, /g<CR>, h, d" note: can use serach in visual mode
2. "d/g<CR>"   note: not ":d/g<CR>"

The search command is an exclusive motion. That means that even though our cursor ends up on the "g"
at the start of the word "gets," that character is excluded from the delete operation (see :h
exclusive).


<repeatable-actions-and-how-to-reverse-them>
Intent                                 Act                  Repeat Reverse
Make a change                          {edit}                  .     u
Scan line for next character           f{char}/t{char}         ;     ,
Scan line for previous character       F{char}/T{char}         ;     ,
Scan document for next match           /pattern<CR>            n     N
Scan document for previous match       ?pattern<CR>            n     N
Perform substitution                   :s/target/replacement   &     u
Execute a sequence of changes          qx{changes}q            @x    u

<MAPPING>
To break the habit of using the arrow keys, try putting this in your vimrc file. This maps each of
the arrow keys to do nothing.

noremap <Up> <Nop>
noremap <Down> <Nop>
noremap <Left> <Nop>
noremap <Right> <Nop>


={============================================================================
*kt_dev_env_vim_104* operator pending mode

Normal, Insert, and Visual modes are readily identified, but Vim has other modes that are easy to
overlook. Operator-Pending mode is a case in point.

For example, we invoke it when we run the command dw. It lasts during the brief interval between
pressing d and w keys.

Operator-Pending mode is a state that accepts 'only' motion commands. It is activated when we invoke
an operator command, and then nothing happens until we provide a motion, which completes the
operation. While Operator-Pending mode is active, we can return to Normal mode in the usual manner
by pressing escape, which aborts the operation.

Many commands are invoked by two or more keystrokes (for examples, look up :h g, :h z , :h ctrl-w ,
or :h [ ), but in most cases, the first keystroke merely acts as a prefix for the second. These
commands don't initiate Operator-Pending mode. Instead, we can think of them as namespaces that
expand the number of available command mappings. Only the operator commands initiate
Operator-Pending mode.

Why, you might be wondering, is an entire mode dedicated to those brief moments between invoking
operator and motion commands, whereas the namespaced commands are merely an extension of Normal
mode? Good question! Because we can create custom mappings that initiate or target Operator-Pending
mode. In other words, it allows us to create custom operators and motions, which in turn allows us
to expand Vim's vocabulary.


={============================================================================
*kt_dev_env_vim_105* commands in insert mode

In Insert mode, the backspace key works just as you would expect: it deletes the character in front
of the cursor. The following chords are also available to us:

Keystrokes     Effect
<C-h>          delete back one character (backspace)
<C-w>          delete back one word
<C-u>          delete back to start of line

These commands are not unique to insert mode or even to Vim. We can also use them in Vim's command
line as well as in the bash shell. 

note: these works on text from where insert mode starts.


={============================================================================
*kt_dev_env_vim_106* normal mode and insert normal mode

{normal-mode-switch}
<Esc>    switch to Normal mode
<C-[>    switch to Normal mode


{insert-normal-mode} :h i_CTRL-O
When we're in Insert mode and we want to run only one Normal command and then continue where we left
off in Insert mode.

<C-o>    switch to Insert Normal mode

redraws the screen with the current line in the middle of the window, which puts me straight back
into Insert mode so that I can continue typing uninterrupted

<C-o>zz


={============================================================================
*kt_dev_env_vim_107* remap caps lock key

See Remap the Caps Lock Key in p30

For Vim users, the Caps Lock key is a menace. If Caps Lock is engaged and you try using the k and j
keys to move the cursor around, you'll instead trigger the K and J commands. Briefly: K looks up the
man page for the word under the cursor, and J joins the current and next lines together. It's
surprising how quickly you can mangle the text in your buffer by accidentally enabling the Caps Lock
key!

Many Vim users remap the Caps Lock button to make it act like another key, such as <Esc> or <Ctrl>.
On modern keyboards, the <Esc> key is difficult to reach, whereas the Caps Lock key is handy.
Mapping Caps Lock to behave as an <Esc> key can save a lot of effort, especially since the <Esc> key
is so heavily used in Vim. I prefer to map the Caps Lock button to behave instead as a <Ctrl> key.
The <C-[> mapping is synonymous with <Esc> , and it's easier to type when the <Ctrl> key is within
easy reach.  Additionally, the <Ctrl> key can be used for many other mappings, both in Vim and in
other programs too.

The simplest way to remap the Caps Lock key is to do it at the system level. The methods differ on
OS X, Linux, and Windows, so rather than reproducing instructions here for each system, I suggest
that you consult Google. Note that this customization won't just affect Vim: it applies system-wide.
If you take my advice, you'll throw away the Caps Lock key forever. You won't miss it, I promise.

When use "xev" to find out the keycode value for capslock key on ubuntu.

KeyRelease event, serial 38, synthetic NO, window 0x3800001,
    root 0x136, subw 0x0, time 16879367, (557,210), root:(559,305),
    state 0x2, keycode 66 (keysym 0xffe5, Caps_Lock), same_screen YES,
    XLookupString gives 0 bytes: 
    XFilterEvent returns: False

http://c2.com/cgi/wiki?RemapCapsLock
Many people don't want a CapsLock key at all. They can change the CapsLock key to a ControlKey by
using the following lines in xmodmap:

clear Lock
keycode 66 = Control_L
add Control = Control_L       

note: Control_L and Control_R differs and keycode 66 is used which is system dependant.

note: Have the above in "~/.xmodmap" and source it in ~/.bashrc. However, whenever open a tab from
gnometermial see errors as described below.

http://www.peterbe.com/plog/blogitem-041021-1
JW - 14 December 2014 [ Reply to this]
For people stumbling upon this post, 4 years later:

The problem "please release the following keys within 2 seconds:" happens when the xmodmap command
is executed while the keys are held down. By adding the commands to ~/.bashrc, they are executed
each time a terminal is opened, causing this error to appear each time.

In fact, you only want to run the xmodmap command once, when you log in. So, add it to
~/.bash_profile or ~/.profile instead (these are only run once)! Also make sure you don't include
.profile from .bashrc (which I unfortunately did and spent much time figuring out...) 

note: How to check key mappings?

xmodmap -pke    

This option indicates that the current keymap table  should  be printed  on the standard output in
the form of expressions that can be fed back to xmodmap.

note: As advised, added in ~/.bash_profile but found that this file is 'not' source. Why?

http://askubuntu.com/questions/121073/why-bash-profile-is-not-getting-sourced-when-opening-a-terminal
~/.bash_profile is 'only' sourced by bash when started in interactive login mode. That is typically
only when you login at the console (Ctrl+Alt+F1..F6), or connecting via ssh.

When you log in 'graphically', ~/.profile will be specifically sourced by the script that launches
gnome-session (or whichever desktop environment you're using). So ~/.bash_profile is not sourced at
all when you log in graphically.

When you open a terminal, the terminal starts bash in (non-login) interactive mode, which means it
will source ~/.bashrc.

The right place for you to put these environment variables is in ~/.profile, and the effect should
be apparent next time you log in.

Sourcing ~/.bash_profile from ~/.bashrc is the wrong solution. It's supposed to be the other way
around; ~/.bash_profile should source ~/.bashrc.

See DotFiles for a more thorough explanation, including some history of why it is like it is.
http://mywiki.wooledge.org/DotFiles

note: When move to ~/.profile works as excepted. 


={============================================================================
*kt_dev_env_vim_108* use register in insert mode or command input

To paste text from a register while in insert mode. :h i_CTRL-R
<C-r>{register}


{in-insert-mode}
Keystrokes  Buffer Contents
yt,         Practical Vim, by Drew Neil         " copied "Practical Vim" since 't,'
            Read Drew Neil's
jA<SP>      Practical Vim, by Drew Neil         " still in insert mode
            Read Drew Neil's 
<C-r>0      Practical Vim, by Drew Neil
            Read Drew Neil's Practical Vim
.<Esc>      Practical Vim, by Drew Neil
            Read Drew Neil's Practical Vim.


{in-command-input}
Can use it in the vim command input line since it's the input mode.

When you press <C-r> you will see "(quote) to prompt you to finish the command by entering a
register. For example, <C-r> then 'a' to insert the contents of the 'a' register, or <C-r> then
"(this is a register name) to insert the contents of the unnamed register.

You can press v then move the cursor to visually select some text (say the text is "hello world").
If you press y the selected text is yanked (copied) into the <unnamed register(")> You can now type
:%s/<C-r>" (Ctrl-R quote) and then '"' or '0' which is the register name.

<C-r> <C-w>    " to paste the word under the cursor into the command line
<C-r> <C-a>    " to paste the WORD under the cursor into the command line. :h c_CTRL-R_CTRL-W

<tip>
try opening your vimrc file, place your cursor on a setting, and then type :help <C-r><C-w> to look
up the documentation for that setting.


{for-charwise-register}
If the 'textwidth' or 'autoindent' options are enabled, you might end up with unwanted line breaks
or extra indentation. The <C-r><C-p>{register} command is smarter. It inserts text literally and
fixes any unintended indentation (see :h i_CTRL-R_CTRL-P ). But it's a bit of a handful!  If I want
to paste a register containing multiple lines of text, I prefer to switch to Normal mode and use one
of the put commands


={============================================================================
*kt_dev_env_vim_109* expression register

Can evaluate a piece of Vim script code and return the result in 'insert' mode. The expression
register is addressed by the = symbol.

Keystrokes        Buffer Contents
A                 6 chairs, each costing $35, totals $
<C-r>=6*35<CR>    6 chairs, each costing $35, totals $210


={============================================================================
*kt_dev_env_vim_110* find out char code value

Find out the numeric code for any character in your document, just place the cursor on it and
trigger the 'ga' command. This outputs a message at the bottom of the screen, revealing the
character code in decimal and hexadecimal notations (see :h ga ).


={============================================================================
*kt_dev_env_vim_111* replace mode

Replace mode is identical to Insert mode, except that it overwrites existing text in the document.
Not all keyboards have an <Insert> key, but if yours does, then you can use it to toggle between
Insert and Replace modes. 'R' command.

f.          Typing in Insert mode extends the line. But in Replace mode
            the line length doesn't change.       ^^^
R, b<Esc>   Typing in Insert mode extends the line, but in Replace mode
            the line length doesn't change.


={============================================================================
*kt_dev_env_vim_112* visual mode

{difference}
From Normal mode, we trigger the change command first and then specify the range as a motion.
Whereas in Visual mode, we start off by making the selection and then trigger the change command.


{mode-selection}
v     " charwise mode
V     " linewise mode
<C-v> " blockwise mode. <C-q> for windows.
gv    " reselect the last visual selection. note: useful?
ggVG  " select whole file

<mode-switch>
Can switch between the different flavors of Visual mode by selecting mode and toggle between Normal
mode and Visual mode when selecting mode twice.

<toggle-end-of-selection>
o     " go to other end of highlighted text

Can use the o key to toggle the free end. This is really handy if halfway through defining a
selection we realize that we started in the wrong place. Rather than leaving Visual mode and
starting afresh, we can just hit o and redefine the bounds of the selection.


{operation-in-visual-mode}
There are commands for visual mode and sometimes do not work as expected. See tip23. For the
repeated work, use commands for normal mode and dot commands.

{start}  <a href="#">one</a>
         <a href="#">two</a>
         <a href="#">three</a>
vit      <a href="#">one</a>
         <a href="#">two</a>
         <a href="#">three</a>
U        <a href="#">ONE</a>
         <a href="#">two</a>
         <a href="#">three</a>

j.
         <a href="#">ONE</a>
         <a href="#">TWO</a>
         <a href="#">THRee</a>

Instead, use 'gUit' for the first and 'j.' for the rest.


={============================================================================
*kt_dev_env_vim_113* command mode: ex commands

This means that we can use Ex commands to make changes without having to move our cursor. But the
greatest feature that distinguishes Ex commands is their ability to be executed across many lines at
the same time. Ex commands strike far and wide. :h ex-cmd-index


{range}
The ex command has a form as :[range]{command} {address} and this range can be line number, pattern
or marks.

<example>
<!DOCTYPE html>
<html>
  <head><title>Practical Vim</title></head>
  <body><h1>Practical Vim</h1></body>
</html>

:[range]print

:1
:p

:$
:p

:3p

:[range]delete

:3d, then we would have jumped to line 3 and deleted it in a single move. The equivalent Normal mode
commands would be 3G followed by dd. So this is one example where an Ex command can be quicker than
a Normal mode command.

note: All range in a command moves cursor so current line changes after.

:{start},{end}
:2,5p

<current-line>
The '.' means the current line and the below print lines from 2 to the end of file.

:2
:.,$p

:2
:.,.+3p

<whole-file>
The '%' means the whole file and print all lines of a file.

:%p      " :1,$p

<pattern-range>
This conform to :{start},{end}p

:/<html>/,/<\/html>/p


{copy-and-move-command}
This seems useful with pre-defined range such as 1, $  but seems difficult with line numbers.

Symbol   Address
1        First line of the file
$        Last line of the file
0        Virtual line above first line of the file
.        Line where the cursor is placed
'm       Line containing mark m
'<       Start of visual selection
'>       End of visual selection
%        The entire file (shorthand for :1,$)

:[range]copy {address}
:[range]move {address}

:t          " t is synonym for copy
:'<,'>t0    " copy the visually selected lines to the start of the file

:t.         " duplicate the current line (similar to Normal mode yyp)

1. The one notable difference between these two techniques for duplicating the current line is that yyp
uses a register, whereas :t. doesn't. I'll 'sometimes' use :t. to duplicate a line when I don't want
to overwrite the current value in the default register.

2. Could have used a variant of yyp to duplicate the line we wanted, but it would require some extra
moving around. We would have to jump to the line we wanted to copy (6G), yank it (yy), snap back to
where we started (<C-o>), and use the put command (p) to duplicate the line. When duplicating a
distant line, the :t command is usually more efficient.

:'<,'>m$    " move visual selection to the end of file


={============================================================================
*kt_dev_env_vim_114* command mode: normal commands

If we want to run a Normal mode command on a series of consecutive lines, we can do so using the
:normal command.

:[range]normal {commands}

As with the example in dot command, need to add ';' at the end of each line. Suppose that there are
too many lines to handle and then normal command is better.

1. 'A;' on the first line, 'jVG' and :'<,'>normal .
2. Or for all lines, ':%normal A;'

Before executing the specified Normal mode command on each line, Vim moves the cursor to the
beginning of the line. So to comment out a whole file:

:%normal i//


={============================================================================
*kt_dev_env_vim_115* command completion and history

{auto-completion}

<C-d>    " list out possible matches. :h c_CTRL-D
<Tab>    " scroll forward
<S-Tab>  " scroll backward through the suggestions


{multiple-commands}
:write | !pwd


{history} 
By default, Vim records the last twenty commands. With memory becoming ever cheaper in today's
computers, we can probably afford to up this limit by changing the history option. Try adding this
line to your vimrc:

set history=200

Note that history is not recorded just for the current editing session. It 'persists' even when we
quit and relaunch Vim (see :h viminfo). Increasing the number of items recorded in history can be
really useful.

<MAPPING>
In addition to the <Up> and <Down> keys, we can also use the <C-p> and <C-n> chords to go backward
and forward through our command history. The advantage of using these mappings is that we don't need
to move our hands from the home row to use them. But there's a disadvantage to the <C-p> and <C-n>
commands: unlike <Up> and <Down>, they don't filter the command history. For example, :se<C-p>

We can get the best of both by creating the following custom mappings:

cnoremap <C-p> <Up>
cnoremap <C-n> <Down>


{command-line-window} :h h cmdwin
Opens a history window but a usual regular buffer which means that can move around and search

Command line window
q:       " open ex 'command' history window from normal mode
q/       " open a 'search' history window from normal mode (to search forward)
q?       " open a search history window from normal mode (to search backward)
<C-f>    " Switch from Command-Line mode to the command-line window
<C-w> c  " close


{command-line-edit}
How to move/edit command line in vim such as ':' prompt? 

:h cmdline-editing

for details. I am listing a few of the interesting non-arrow commands that do something similar to
what you want.

C-B: cursor to beginning of command-line
C-E: cursor to end of command-line
C-W: delete the word before the cursor [useful]
C-U: remove all characters between the cursor position and the beginning of the line

Thanks, that's great. I searched through that help doc and I'm not seeing a way to move back and
forth by word. Do you know if that's available? Ethan Jan 16 '10 at 0:23


={============================================================================
*kt_dev_env_vim_116* current filename

6. Ex special characters. *cmdline-special*

Note: These are special characters in the executed command line. If you want to insert special
things while typing you can use the CTRL-R command. For example, "%" stands for the current file
name, while CTRL-R % inserts the current file name right away. See |c_CTRL-R|.

In Ex commands, at places where a file name can be used, the following characters have a special
meaning. These can also be used in the expression function expand() |expand()|.

% Is replaced with the current file name.

:!ls "%"
:r !spell "%"


={============================================================================
*kt_dev_env_vim_117* exit, file and buffer

{buffer}
Instead, we're editing an in-memory representation of a file, which is called a buffer in Vim's
terminology.

<buffer-commands>
:ls
:bnext
:bprev
:b [num]


The % symbol indicates which of the buffers is visible in the current window, while the # symbol
represents the alternate file. We can quickly toggle between the current and alternate files by
pressing <C-^>. note: alternate between two; current and the previous buffer.
+ sign indicates that it has been modified.

<hidden-buffers> tip38
These are buffers which are modified when switches bufffers but not saved yet.
Options are:

:w[rite]    " write the contents of the buffer to disk
:e[dit]!    " read the file from disk back into the buffer (that is, revert changes)
:e          " reload the current file.
:qa[ll]!    " close all windows, discarding changes without warning
:wa[ll]     " write all modified buffers to disk


{file-commands}
:saveas move.c


{file-info}
<C-g>

{exit}
ZZ
Write current file, if modified, and quit. note: same as ":x"). If there are several windows for the
current file, the file is written if it was modified and the window is closed.

:wqall   " save all and quit
:qall!


={============================================================================
*kt_dev_env_vim_118* window and tab

{open-new-window}
:new           " hori
:vnew          " vert

:h tabpage.txt


{windo}
Do a command in all buffers or windows in the current tab.

:windo set tw=100


{window}
In Vim's terminology, a window is a viewport onto a buffer. :h window

<C-w>v   " command to split the window vertically. :vsp[lit]
<C-w>s   " command to split the window horizentally. :sp[lit]

<window-switch>
For the complete list, see :h window-move-cursor.

<C-w>w   <C-w><C-w>  " Change focus between open windows. :h CTRL-W_w
<C-w>r               " Rotate place between open windows. 
<C-w>h               " Focus the window to the left
<C-w>j               " Focus the window below
<C-w>k               " Focus the window above
<C-w>l               " Focus the window to the right

The useful mapping is:

map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l

<window-close>
Ex Command  Normal Command    Effect
:cl[ose]    <C-w>c            " Close the active window. :quit
:on[ly]     <C-w>o            " Keep only the active window, closing all others     note: <USEFUL>

<window-size> :h window-resize
<C-w>=      " Equalize width and height of all windows
<C-w>_      " Maximize height of the active window
<C-w>|      " Maximize width of the active window

<window-rearrange> :h window-moving
<C-w> H     " move current window to far left
<C-w> J     " move current window to bottom
<C-w> K     " move current window to top
<C-w> L     " move current window to far right


{screen}
<C-d>       " down half screen :h scroll-down
<C-u>       " up half screen (backward)
<C-f>       " down full screen
<C-b>       " up full screen (backward)

zz          " make the current line center
zb          " make the current line bottom
zt          " make the current line top


{tab} :h tabpage
Vim's tab pages are not mapped to buffers in a one-to-one relationship. Instead, think of a tab page
as a container that can hold a collection of windows based on 'context'.

<tab-open>
:tabnew  or :tabedit " create a new tab page
:tabe[dit] filename
<C-w> T              " when multiple windows, moves the current window into a new tab page

:tabc[lose]          " Close the current tab page and all of its windows
:tabo[nly]           " Keep the active tab page, closing all others

<tab-switch>
{N}gt                " tab number N
gt                   " next tab
gT                   " prev tab

<tab-rearrange>
:tabmove {N}
:tabmove 0           " the current tab page is moved to the beginning
:tabmove             " the current tab page is moved to the end

<tab-and-working-directory>
Suppose that each tab represents a project or workspace and each project is in different directory.
To work on each project such as openning and searching files, need to have different working
directory for each tab. How?

1. Open a tab which inherits CWD from the previous and run :cd to set different CWD. Do not work
since it sets CWD for all opened tabs.

2. Use lcd command for each tab to have different CWD.

The :lcd {path} command lets us set the working directory locally for the current window. If we
create a new tab page and then use the :lcd command to switch to another directory, we can then
comfortably scope each tab page to a different project. note that :lcd applies locally to the
'current' window, not to the current tab page.

% gives the name of the current file,

To change to the directory of the current file for all windows in vim
:cd %:p:h

To change to the directory of the current file
:cd %:h

see :h cmdline-special

Examples, when the file name is "src/version.c", current dir "/home/mool/vim": >
  %:p          /home/mool/vim/src/version.c
  %:h          src
  %:p:h        /home/mool/vim/src
  %:p:h:h      /home/mool/vim


={============================================================================
*kt_dev_env_vim_119* display and real line

Unlike many text editors, Vim makes a distinction between real lines and display lines. When the
'wrap' setting is enabled (and it's on by default), each line of text that exceeds the width of the
window will display as wrapped, ensuring that no text is truncated from view. As a result, a single
line in the file may be represented by multiple lines on the display.

j     " Down one real line
gj    " Down one display line
k     " Up one real line
gk    " Up one display line
0     " To first character of real line
g0    " To first character of display line
^     " To first 'nonblank' character of real line
g^    " To first nonblank character of display line
$     " To end of real line
g$    " To end of display line

Note the pattern: j, k, 0, and $ all interact with real lines, while prefixing any of these with g
tells Vim to act on display lines instead.

<useful>
When you learn to use the gj and gk commands, you'll appreciate that j and k may let you cover more
distance with fewer keystrokes.


={============================================================================
*kt_dev_env_vim_120* marks, jumps and changes

{marks}
A global mark is a kind of bookmark that allows us to jump between files. Marks
can be especially useful for snapping back to a file after exploring a codebase.

<local-and-global>
Lowercase letters create marks that are local to a buffer, whereas uppercase
letters create global marks.

<make-and-move>

m{mark}  " make a mark 26 marks(a-z) (line and column)
'{mark}  " apostrophe ('). jump to the line of a mark. linewise
`{mark}  " backtick (`). jump to the 'exact' position of a mark (line and column) 

Go with `{mark}. Whether you care about restoring the exact position or just
getting to the right line, this command will get you there.

d`a   " delete from current cursor position to position of mark a
y`a   " yank text to unnamed buffer from cursor to position of mark a

:marks
:delm {mark}

<automatic-marks>
``    " Position before the last jump within current file. Jump back and forth
        between two.
`.    " Location of last change. complement of change list
`^    " Location of last insertion. complement of change list
`[    " Start of last change or yank
`]    " End of last change or yank
`<    " Start of last visual selection
`>    " End of last visual selection

note: If uses 'bookmark' of vim plugins, then can only use these two tips wrt
mark and jumps?

<mark-then-snap-back>
The mm and `m commands make a handy pair. Respectively, they set the mark m and
jump to it.

<mark-before-any-command> global-mark
Global marks are only useful if we have the forethought to set them up correctly
in advance. With practice, you'll learn to recognize the scenarios where it
would be useful to set a global mark.

note: WHY?

Try to get into a 'habit' of setting a global mark before using any commands
that interact with the quickfix list, such as :grep, :vimgrep, and :make.


{jumps}
The motions move around within a file, whereas jumps can move 'between' files.

<C-o>       " go to older pos in jump list
<C-i>       " go to newer pos in jump list

If we run the :edit command to open a new file, then we can use the <C-o> and
<C-i> commands to jump back and forth between the two files.

<what-jump-is>
Moving directly to a line number with [count]G counts as a jump, but moving up
or down one line at a time does not. The sentence-wise and paragraphwise motions
are jumps, but the character-wise and word-wise motions are not. As a rule of
thumb, we could say that 'long'-range motions may be classified as a jump, but
short-range motions are just motions.

[count]G                         " Jump to line number
//pattern<CR>/?pattern<CR>/n/N   " Jump to next/previous occurrence of pattern
%                                " Jump to matching parenthesis
(/)                              " Jump to start of previous/next sentence
{/}                              " Jump to start of previous/next paragraph
gf                               " Jump to file name under the cursor

<C-]>                            " Jump to definition of keyword under the cursor
                                   (requires ctags)
'{mark}/`{mark}                  " Jump to a mark


<jump-list>
:jumps

Your current location in the jump list is indicated with '>', and the first
number in each row is a count that can be used to jump to that position.
Something like this:

 jump line  col file/text
   4   102    0 somefile.txt
   3    93    0 -invalid-
   2    23    0 the current line 23 is shown here
   1    89   34 the current line 89 is shown here
>  0    22   40 Display the jump list for the current window with:
   1    39    0 the current line 39 is shown here
   2   995    0 anotherfile.txt
   3    53  102 the current line 53 is shown here

<active-window>
Vim can maintain multiple jump lists at the same time. In fact, 'each' separate
'window' has its own jump list. If we're using split windows or multiple tab
pages, then the <C-o> and <C-i> commands will always be scoped to the jump list
of the active window.


{changes}
:changes

Using the g; and g, commands, we can traverse backward and forward through the
change list.

<which-one>
We can press g; again and again, and each time it takes us to a location that
was recorded earlier in the change list. The `., on the other hand, will always
take us to the last item in the change list.

<gi-command>
Can quickly carry on where we left off by pressing gi (:h gi ). gi is better
since it is a single move and that uses the `^ mark to restore the cursor
position and then switches back into Insert mode. Don't need to press a key to
insert mode.


{gf-command} :h gf
Can use the gf command to go to the filename under the cursor. Two things to set
up:

1. The suffixesadd option allows us to specify one or more file extensions,
    which Vim will attempt to use when looking up a filename with the gf command
    (:h 'suffixesadd'). We can set it up by running this command:

:set suffixesadd+=.rb

2. The gf use relative to the working directory. But what if we referenced
functionality that was provided by a third-party library? :h 'path'. When we use
the gf command, Vim checks each of the directories listed in
path to see if it contains a filename that matches the text
under the cursor.

:set path?
 path=.,/usr/include,,

whereas the empty string (delimited by two adjacent commas) stands for the
working directory.

<gf-and-jumps>
Each time we use the gf command, Vim adds a record to the jump list, so can use
<C-o> as in jump list.

<gf-and-filetype>
In the setup for this tip, I recommended launching Vim with plugins disabled.
That's because Vim is usually distributed with a Ruby file-type plugin, which
handles the setup of suffixesadd and path options for us.

The suffixesadd and path options can be set locally for each buffer, so they can
be configured in different ways for different file types. Vim is distributed
with file-type plugins for many other languages, so in practice you won't often
have to set these options yourself. Even so, it's worth understanding how the gf
command works. It makes each filepath in our document behave like a hyperlink,
        which makes it easier to navigate through a codebase.


={============================================================================
*kt_dev_env_vim_121* copy and paste

{unnamed-register}
Can specify which register we want to use by prefixing the command with "{register}. If we don't
specify a register, then Vim will use the unnamed register which is addressed by the " symbol. see
:h quote_quote

xp

The x command cuts the character under the cursor, placing a copy of it in the unnamed register.
Then the p command pastes the contents of the unnamed register after the cursor position.  Taken
together, the xp commands can be considered as "Transpose the next two characters."


{use-register}
:reg[isters]
:reg "0           " can specify the register name to see that only

"ayiw
"a4yy    " copy the next 4 lines into the register named 'a'
"ap      " paste from 'a'
"bd
"bp
vjww"by  " yank visual selection to b reg
"wdaw    " to delete-a-word and write it in the w register:


{yank-register}
y2w
yy    " yank a line
2yy   " yank 2 lines 
byw   " move to the beginning of a word

The unnamed register is not reliable since can be overwritten by many cut related command. So yank
register which is addressed by the 0 symbol (see :h quote0) comes in and when use the y{motion}
command, the specified text is copied not only into the unnamed register but also into the yank
register. The below shows the use.

<example>
yiw         collection = getCollection();
            process(somethingInTheWay, target);
jww         collection = getCollection();
            process(somethingInTheWay, target);
diw         collection = getCollection();
            process(, target);
"0P         collection = getCollection();
            process(collection, target);

<example> Vim's put command has some unusual qualities.
This time, used visual selection and put command. No delete so preferable. However, it has a side
effect. When do "u, gv, p" which means undo, reselect last selection, and put, what would happen?
Nothing. Why? Because when we use Vim's p command in Visual mode, it does both: it gets the contents
of the unnamed register, and it sets the contents of the unnamed register. Think of it this way: the
visual selection in the document swaps places with the text in the register.

yiw         collection = getCollection();       " unnamed is "collection" and "0 is "collection"
            process(somethingInTheWay, target);
jww         collection = getCollection();
            process(somethingInTheWay, target);
ve          collection = getCollection();
            process(somethingInTheWay, target);
p           collection = getCollection();       " unnamed is "somethingInTheWay" and "0 is "collection"
            process(collection, target);

<example> swap two words which use put's quirk property

{start}  I like chips and fish.
fc       I like chips and fish.
de       I like  and fish.
mm       I like  and fish.          " note: see the use of mark
                ^
ww       I like  and fish.
ve       I like  and fish.
p        I like  and chips.
`m       I like  and chips.
                ^
P        I like fish and chips.     " it is 'P'. If use 'p' then "like  fishand chips."

In this case, it would be quicker to delete "chips and fish" and then type out "fish and chips"
instead, using the c3w command for example. But this same technique can also be used to swap the
order of longer phrases.


{lowercase-and-uppercase-paste}
The lowercase paste after for characterwise and below for linewise and the uppercase do the
opposite. Rather than remember this, can use <C-r>{register} so that can paste text always in front
of the current cursor position.

yiw            collection = getCollection();
               process(somethingInTheWay, target);
jww            collection = getCollection();
               process(somethingInTheWay, target);
ciw<C-r>0<Esc> collection = getCollection();
               process(collection, target);

As an added bonus, can use dot command to change the current word with "collection" since the whole
step is a change to repeat.

TODO: gp, gP


{named-register}
Vim has one named register for each letter of the alphabet. see :h quote_alpha.  Using a named
register requires extra keystrokes, so for a simple example like this we're better off using the
yank register ("0).


{system-registers}
<clipboard> :h quote+
To copy some text from inside of Vim and paste it into an external program

"+ register

<tip> In vim 7.3.74 and higher you can do following to 'alias' unnamed register to the + register,
which is the system clipboard. By doing this, don't need to "+p to make it available to other
application in the system and vice versa.

set clipboard=unnamedplus

note: this works as well between Windows and the guest Linux.


<primary-register> to and from vim and the shell
The X11 windowing system has a second kind of clipboard called the primary. This represents the
most recently selected text, and we can use the middle mouse button (if we have one) to paste from
it. The quotestar register maps to the primary clipboard and is addressed by the * symbol. :h
quotestar

From the shell, select text using a mouse and then:

Select text using a mouse  
" copy text to the primary, *. So have to use "* in vim. note: without selecting copy menu or
ctrl-ins.

Select text and CTRL-INS   " copy text to the primary and the clipboard.
SHIFT-INS                  " paste from the primary. Same as middle mouse click.

In Windows and Mac OS X, there is no primary clipboard, so we can use the "+ and "* registers
interchangeably: they both represent the system clipboard.

<from-vim-to-shell>
To copy text from vim to the shell, use "* in vim to copy and shift-ins in the shell to paste. Or
use + register by usual yank and use paste menu in a application. For gnome terminal, Ctrl-Shift-V
to paste.

Vim can be compiled with or without support for X11 clipboard integration.  To find out whether your
version of Vim has the feature enabled, run the :version command and look for xterm_clipboard.


{other-registers}
These are known collectively as the read-only registers. :h quote.

"%    " Name of the current file
"#    " Name of the alternate file
".    " Last inserted text
":    " Last Ex command
"/    " Last search pattern


={============================================================================
*kt_dev_env_vim_122* search:

{search}

/        " forward. note: this supports history and pattern. /the\> or /\<the\>
?        " backward
*        " search a word under the cursor. forward
#        " search a word under the cursor. backward
g#/g*    " search but don't put "\<" and "\>" around the word which means to include non-exact matches.

<search-repeat>
Vim will just reuse the pattern from the previous search. Also this can be used to change the search
direction with the same pattern.

/<CR>    " Jump forward to next match of same pattern
?<CR>    " Jump backward to previous match of same pattern

<search-history>
The search provides histories.


<SETTING>
:set nowrapscan   " stops the search at the end of file. :h 'wrapscan'


={============================================================================
*kt_dev_env_vim_123* search: incsearch

{incsearch} :h 'incsearch'
:set incsearch    " inc search

<example>
Suppose that we just want to check if the word "carrot" is present in the current document without
moving our cursor. If the word is found, we can just press <Esc>, and we'll end up right back where
we started.

<example>
Suppose we were planning to follow the search command with a substitute command. Do inc search and
found match. Use autocompletes to fill remainders in the command line.

<C-r> <C-w>    " to paste the word under the cursor into the command line


={============================================================================
*kt_dev_env_vim_124* search: highlight

:h 'hlsearch'

:set hlsearch     " to set search highlight
:set nohlsearch   " to disable
:noh[lsearch]     " to mute the search highlighting temporarily. see :h :noh

<MAPPING>
Typing :noh <CR> to mute search highlighting is laborious. We can speed things up by creating a
mapping such as this:

nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>

note: <C-u> is scroll up

Normally, <C-l> clears and redraws the screen (see :h CTRL-L). This mapping builds on top of the
usual behavior by muting search highlighting.


={============================================================================
*kt_dev_env_vim_125* search: count matches

It simply counts the number of matches for the 'current' search patten and then echoes the result
below the command line.

:%s///gn


={============================================================================
*kt_dev_env_vim_126* search: work on search matches

Suppose that want to run a command on search matches and dot commands to repeat. Tip84.

/\vX(ht)?ml\C<CR>
gufl

<PLUGIN>
http://github.com/kana/vim-textobj-lastpat

The ideal Dot Formula requires a single keystroke to move and a single keystroke to execute the
change. The example in Tip 84, on page 206, used three keystrokes just to move (// <CR> ), which
falls short of the ideal. It's surprising that Vim doesn't have a more convenient built-in motion
for operating 'on' search matches.

With the judicious use of Vim script, we can add this functionality to Vim. My favorite solution is
  the textobj-lastpat plugin, by Kana Natsuno, which adds an i/ text object for operating on search
  matches. Using this, we can make the same change as before just by running gUi/. Instead of
  needing three keystrokes (// <CR> ) to jump to the next match, we can get there in just one: n .
  In other words, we can achieve an ideal Dot Formula.


={============================================================================
*kt_dev_env_vim_127* search: make a pattern using command line window

From:
This string contains a 'quoted' word.
This string contains 'two' quoted 'words.'
This 'string doesn't make things easy.'

To:
This string contains a "quoted" word.
This string contains "two" quoted "words."
This "string doesn't make things easy."

1. /\v'.+' note: different when use /'.+'

This string contains 'two' quoted 'words.'
                     ^^^^^^^^^^^^^^^^^^^^^
Broad match since it's greedy match. ".+" means any char which is one or more times.

2. /\v'[^']+'

This 'string doesn't make things easy.'
     ^^^^^^^^^^^^^^

3. /\v'([^']|'\w)+'

Catch the fact that the apostrophe is followed immediately by a letter; not by a space or
punctuation mark. note: see how OR works here.

Instead of pressing /<Up> to prefill the search field with our last pattern, can use command line
window. See {command-line-window}

{start}           \v'[^']+'
f[                \v'[^']+'
                     ^
c%(<C-r>")<Esc>   \v'([^'])+'          note: c% makes \v'+'
i|'\w<Esc>        \v'([^']|'\w)+'

When we've got the pattern looking how we want it, we just press the <CR> key to execute the search.

4. /\v'(([^']|'\w)+)'

We want to capture everything inside the quotes by wrapping it in parentheses. The search
highlighting won't look any different from the last time, but for each match, the text inside quotes
will be assigned to the \1 capture register.

:%s//"\1"/g

<key>
Being able to edit the command line directly is great for simple edits. If we have the 'incsearch'
setting enabled, then we get the added bonus of live feedback as we edit the command line. We lose
this perk as soon as we call up the command-line window. But with the full power of Vim's modal
editing at our fingertips, this is a fair trade-off.


={============================================================================
*kt_dev_env_vim_128* search: for the visual selection

This is "Use selection for find" command.

<MAPPING>
xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

function! s:VSetSearch()
  let temp = @s
  norm! gv"sy
  let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
  let @s = temp
endfunction

You can either paste this into your vimrc file directly or install the visual star search plugin.
https://github.com/nelstrom/vim-visual-star-search

As well as overriding the * command, we've customized the # command, which searches backward for
selected text. The xnoremap keyword specifies that the mappings should apply to Visual mode but not
to Select mode (see :h mapmode-x ).


={============================================================================
*kt_dev_env_vim_129* pattern: global command

The :global command is one of Vim's power tools for performing repetitive work efficiently.

The :global command takes the following form (see :h :g)

:[range] global[!] /{pattern}/ [cmd]

The :global command works by making two passes through the lines specified by [range]. In the first
pass, Vim marks each line that matches the specified {pattern}. Then on the second pass, the [cmd]
is executed for each marked line.

:global! or :vglobal (mnemonic: invert).

<defaults>
The default range for the :global command is the entire file (%). That sets it apart from most other
Ex commands, including :delete, :substitute, and :normal, whose range is the current line (.) by
default.

The {pattern} field integrates with search history. That means we can leave it blank and Vim will
automatically use the 'current' search pattern.

If we don't specify a [cmd], then Vim will use :print by default.

<example>
What if we wanted to throw away everything except for the contents of each <a> tag? In this file,

<ol>
  <li>
    <a href="/episodes/show-invisibles/">
      Show invisibles 
    </a>
  </li>
  <li>
    <a href="/episodes/tabs-and-spaces/">
      Tabs and Spaces 
    </a>
  </li>
  <li>
    <a href="/episodes/whitespace-preferences-and-filetypes/">
      Whitespace preferences and filetypes 
    </a>
  </li>
</ol>

1. Use pattern
/\v\<\/?\w+>
:g//d

The regular expression uses very magic mode. It matches an opening angle bracket (\<), followed by
an optional forward slash (\/?), and then one or more word characters (\w+) followed by an
end-ofword delimiter (>).

note: do not use pattern in global command since uses the previous search pattern.

The result:
      Show invisibles 
      Tabs and Spaces 
      Whitespace preferences and filetypes 

2. Use vglobal
:v/href/d

The result:
<a href="/episodes/show-invisibles/">
<a href="/episodes/tabs-and-spaces/">
<a href="/episodes/whitespace-preferences-and-filetypes/">

With a single command, we've condensed the file to the lines that interest us.


<example> collect TODO items

Markdown.dialects.Gruber = {
    lists: function() {
        // TODO: Cache this regexp for certain depths.
        function regex_for_depth(depth) { /* implementation */ }
    },
    "`": function inlineCode( text ) {
        var m = text.match( /(`+)(([\s\S]*?)\1)/ );
        if ( m && m[2] )
            return [ m[1].length + m[2].length ];
        else {
            // TODO: No matching end code found - warn!
            return [ 1, "`" ];
        }
    }
}

<tip> 
To list all TODO matches

:g/TODO

Here's an alternative strategy: let's yank each line containing the word TODO into a register. Then
we can paste the contents of that register into another file and keep them around for later.

1. note: empty the register. First we'll need to clear it by running qaq. Let's break that down: qa
tells Vim to start recording a macro into the a register, and then q stops the recording. We didn't
type anything while the macro was recording, so the register ends up empty.

2. Yank matched lines to the a register. note: Used uppercase A since it means 'append' line to the
register. If use 'a' instead then the register will have the last matched line.

:g/TODO/yank A
:reg a

3. Then paste, "ap

<alternative>
:g/TODO/t$

Simply copy it to the end of the file. After running this command, we could jump to the end of the
file to review the TODO items. This technique is more straightforward because it avoids messing
around with registers. But it won't work as neatly with the :argdo and :bufdo commands.

<alternative>
Could even combine the :global command with either :bufdo or :argdo to collect all TODO items from a
set of files. I'll leave that as an exercise for you, but look to Tip 96, on page 233, for a hint at
the workflow.


<example>
This technique is especially useful in cases where the :g/{pattern} matches a large number of lines.

Suppose that we want to sort the properties of each rule into alphabetical order. Can do by
selecting a block and run vim sort command.

{start}  html {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
         }
vi{      html {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
         }
:'<,'>sort html {
            border: 0;
            font-size: 100%;
            font: inherit;
            margin: 0;
            padding: 0;
            vertical-align: baseline;
         }

Suppose that we had a style sheet containing hundreds of rules. Wouldn't it be better if we could
automate the process somehow?

<solution>
:g/{/ .+1,/}/-1 sort

1. Ex commands can usually accept a range themselves. This is still true for the [cmd] in the
context of a :global command. So we could expand the template as follows:

:g/{pattern}/[range][cmd]

The [range] for our [cmd] can be set 'dynamically' using the match from :g/{pattern} as a reference
point. Normally the . address stands for the line that the cursor is positioned on. But in the
context of a :global command, it stands for each line in turn that matches the specified {pattern}.

:.+1,/}/-1 sort

If we strip out the offsets from our range, it becomes simply .,/}/. We can interpret this as "from
the current line up until the next line that matches the /}/ pattern." The +1 and -1 offsets simply
narrow the range to focus on the contents of the {} block.

We just need to position our cursor at the start of each {} block and then run the :.,/}/sort
command

/{/

Let's put our :global and [cmd] Ex commands back together:

:g/{/ .+1,/}/-1 sort

The { pattern matches the first line of each {} block. For every line that matches, the :sort
command is executed on a [range] that terminates at the end of the {} block.

A generalized form of this :global command goes like this:

:g/{start}/ .,{finish} [cmd]

<example>
We could use the same in combination with any Ex command. For example, suppose that we wanted to
indent the specified ranges. We could do so with the :> Ex command (see :h :>):

:g/{/ .+1,/}/-1 > 

Note that the :> command echoes a message each time it is invoked, whereas :sort doesn't. We can
mute these messages by prefixing our [cmd] with :silent (see :h :sil ):

:g/{/sil .+1,/}/-1 > 


={============================================================================
*kt_dev_env_vim_130* spell

http://vimcasts.org/episodes/spell-checking/

:set spell
:set spell!
:windo set spell

nnoremap <silent> [unite]s :set spell!<cr>
note: do not have set spell by default becuase to have spell check as a separate task.

set spelllang=en_gb

<spelllang>
This is local to buffer.

]s S     " move to next misspelled word. S only for bad word
[s S     " move back to next misspelled word

z=       " show suggestions

<spellfile>
Name of the word list file where words are added for the |zg| and |zw| commands.  It must end in
".{encoding}.add".  You need to include the path, otherwise the file is placed in the current
directory.

set spellfile=~/.vim/spell/en.utf-8.add 
note: if there is no spell dir then create it manually.

zg       " add word under the cursor as a good word
         " add it to spellfile as it is
zw       " add word under the cursor as a bad word
         " add it to spellfile with ! char at the end

zug
zuw

These simply add entry to the file and when repeats this on the same words or comment out for undoed
words, this file gets bigger. So To clean up the comment lines in all ".add" spell files do this: >

:runtime spell/cleanadd.vim


={============================================================================
*kt_dev_env_vim_131* vimdiff

gvimdiff file1 file2

]c       " move to next change
[c       " move back to next change

<diff-between-buffers>
Diffs are local to the current tab page |tab-page|. You can't see diffs with a window in another tab
page. This does make it possible to have several

The differences shown are actually the differences in the buffer. Thus if you make changes after
loading a file, these will be included in the displayed diffs. You might have to do ":diffupdate"
now and then, not all changes are immediately taken into account.

:difft[his]
Make the current window part of the diff windows.  This sets the options like for "vimdiff".

:diffo[ff]
Switch off diff mode for the current window.  Resets related options also when 'diff' was not set.

The workflow is that two windows; one for old and the other for the latest and diff both by running
the following that means to add these to <diff-mode>:

+------------------- the same tab ----------------------+
+--- buffer from file ---+--- temp buffer from paste ---+

:windo diffthis

Also works on buffers and means that can use any temporary buffers.


={============================================================================
*kt_dev_env_vim_132* yank current filename to a register. expand

Yank current filename to + register and paste it to use.

:let @+ = expand("%")

nmap cp :let @+ = expand("%")

:h expand for more detail.


={============================================================================
*kt_dev_env_vim_140* shell: run external program and bang(!) 

:!{cmd}              " Execute {cmd} with the shell
:read !{cmd}         " Execute {cmd} in the shell and insert its standard output below the cursor
:[range]write !{cmd} " Execute {cmd} in the shell with [range] lines as standard input
:[range]!{filter}    " Filter the specified [range] through external program {filter}


{run-shell-command}
:{range}!{cmd}

:2,$!sort -t',' -k2     " sort [2,$] lines on the second field.

<tip> :h :range!
For example, if we place our cursor on line 2 and then invoke !G, Vim opens a prompt with the :.,$!
range set up for us. We still have to type out the rest of the {filter} command, but it saves a
little work.


note that should be careful of the place of ! (bang) character since 
:write !sh     " okay
:write ! sh    " okay
:write! sh     " not okay


{redirect}
<write-command>
Refer to :h rename-files for a nice example of this command in use.

:write !{cmd}

<read-command>
:0read !date -u
:0read !date /t   " for windows
:r[ead] filename  " insert into the cursor position

:!!date<Enter>    " replaces the current line with the output of "date". 


={============================================================================
*kt_dev_env_vim_141* shell: foreground and background

C-z      " to suspend vim and get back to the shell
fg       " to get back to vim


:set shell?    " to check shell setting
:sh            " to run shell in vim
C-d            " to end the shell and return to vim


={============================================================================
*kt_dev_env_vim_150* format, wrap, tw

{display-and-numbered-line}
'wrap' and 'linebreak' control the display of text so the long line is a single line even if it is
diaplayed on multiple lines. To get vim to insert newlines in the file as you type, set textwidth to
the desired width (e.g. 80). note: In help file, tw=xxx don't seem to work for me.

:set wrap            " to eanble wrap

http://vimcasts.org/episodes/soft-wrapping-text/

By default Vim will break lines at exactly the width of the window, which causes some words to be
split across two lines. To prevent this from happening, you can enable 

:set linebreak

However, the linebreak setting will not work when the list setting is enabled. So to use linebreak
as expected, shall use the three:

:set wrap linebreak nolist

Rather than having to ensure that 3 separate options are configured correctly, I would prefer if I
could just issue the command :Wrap. This can be achieved by putting the following in your .vimrc
file:

command! -nargs=* Wrap set wrap linebreak nolist

note: see :h user-command


<move-in-displayed-lines>
Unlike many text editing environments, Vim makes a distinction between displayed lines, and numbered
lines. When wrap is enabled, each numbered line might be split across more than one display lines.
The k and j keys move up and down by numbered lines. If you want to move the cursor up and down by
display lines instead, you can use the commands gk and gj instead.

Hitting two keys in quick succession feels slow compared to pressing a single key whilst holding
down a modifier key. I have the following in my .vimrc file:

vmap <D-j> gj
vmap <D-k> gk
vmap <D-4> g$
vmap <D-6> g^
vmap <D-0> g^
nmap <D-j> gj
nmap <D-k> gk
nmap <D-4> g$
nmap <D-6> g^
nmap <D-0> g^

On the mac, this allows me to use j, k, $, 0 and ^ on display lines by holding down the command key.

<showbreak>
If you prefer not to show line numbers, there is another way. The showbreak option can be set to a
character which will lead each display line after the first one. It can be set as follows:

set showbreak=" " 
set showbreak="> " 

To insert the elipsis, press ctrl-vu followed by the numeric code for elipsis: 2026. Episode 1
covers unicode character insertion in a little more detail. ctrl-v u2026


{textwidth}

:set tw=xxx

when use 'textwidth' it works well when typing in VIM but when copy text from external source then
it doesn't work; that's don't fit into textwidth setting of the current file. 

two solution to this:

gq}                     # to manucl format
gpap                    # <a> paragraph
gqG                     # formats the text starting from the current and to the end of the file. 
                        # It will automatically join consecutive lines when possible.

Note: 
A blank line, which contains white space, does NOT separate paragraphs. This is hard to
notice!

set formatoptions+=a    # vim to do it automatically. help auto-format

(this makes no use of following)
i CTRL-R *              # paste clipboard with maintaining formatting. see i_CTRL-R


<colorcolumn>
This option was added in (g)vim 7.3 and can be used with if and filetype

set colorcolumn cc=100

={============================================================================
*kt_dev_env_vim_151* encoding and utf8

When tris to use {show-invisibles}, face two problems:

<1> cannot see the unicode chars in test file. need to change encoding format
to see these.

set encoding=utf-8

<2> Now able to see and enter unicode but see errors when loading vimrc:

$ gvim kt_dev_env.txt 
Error detected while processing /home/kpark/.vimrc:
line   67:
E474: Invalid argument: listchars=tab:~V\ ,eol:

The solution is to add these in vimrc.

scriptencoding utf-8
set encoding=utf-8


{encoding}
:h encoding-names

The content on your source web page was overzealously reformatted. The text was undoubtedly supposed
to use (straight) single quotes (ASCII 39/0x27, U+0027) instead of curly single quotes (U+2018 and
U+2019, which are 0x91 and 0x92 in CP1252 (also known as MS-ANSI and WINDOWS-1252; a common 8-bit
encoding on Windows)).

Vim is showing you the hex codes because they are not valid in whatever encoding Vim is using
(probably UTF-8). If you are editing text that has already been saved in a file, then you can reload
the file as CP1252 with 

:e ++enc=cp1252 

 [KT] for korean windows 949
:e ++enc=cp949 	

this should make the curly quotes visible. But there is no real reason to reload it as CP1252, just
delete the 0x91 and 0x92 characters and replace them with single quotes.

To change the hex 91/92 characters in you need to do:
:%s/[\x91\x92]/'/g

To change the quote from compiler errors:


{how-to-convert-file-format}
utf8 is default. If you are editing a file encoded as latin1, you will find that 'fileencoding' for
that buffer is set to latin1. So you will need to manually set the fileencoding before saving the
file

:set fileencoding=utf8
:w myfilename

For more information :help mbyte-options and :help utf8


={============================================================================
*kt_dev_env_vim_152* how: how to change word between '_'

Suppose that want to change the function to 

gst_nexus_sink_event_locked() -> gst_nexus_sink_render_locked()

The problem is when use "cw" it regards it a whole since '_' is not a
delimeter to vim. How to solve?

Two:

* use "iskeyword"

'iskeyword' 'isk'	string (Vim default for MS-DOS and Win32:
					    "@,48-57,_,128-167,224-235"
				   otherwise:  "@,48-57,_,192-255"
				Vi default: "@,48-57,_")
			local to buffer
			{not in Vi}

Keywords are used in searching and recognizing with many commands: "w", "*",
         "[i", etc.  It is also used for "\k" in a |pattern|. 

See 'isfname' for a description of the format of this option. For C programs
you could use "a-z,A-Z,48-57,_,.,-,>". For a help file it is set to all
non-blank printable characters except '*', '"' and '|' (so that CTRL-] on a
        command finds the help for that command). When the 'lisp' option is on
the '-' character is always included. NOTE: This option is set to the Vi
default value when 'compatible' is set and to the Vim default value when
'compatible' is reset.

:set iskeyword-=_ 


* use "ct_" instead of "cw"


# ============================================================================
#{
={============================================================================
*kt_dev_env_vim_200* prog:edit: adding and substracting

<C-a> and <C-x> increments and decrements the number the cursor is placed on. This is especially
good because Vim understands different 'bases'. This command will "add [count] to the number at or
after the cursor"

The <C-a> and <C-x> commands work for (signed) decimal numbers, unsigned octal and hexadecimal
numbers and alphabetic characters. This depends on the 'nrformats' option.

set nrformats=

This will cause Vim to treat all numerals as decimal, regardless of whether they are padded with
zeros.

<example>
What is the hexadecimal representation of 1564 (decimal)? Just place the cursor at the line which
has 0x0.

0x0

And now '1564 C-a ESC' (this tells Vim to do Ctrl-a 1564 times). You get 0x61c


={============================================================================
*kt_dev_env_vim_201* prog:edit: tabs and shift

{tabs}
See the cast, http://vimcasts.org/episodes/tabs-and-spaces/ for details.

:set ts tabstop=4       " set the value of a tab char
:set sts softtabstop=4  " set the value to use when press backspace or <C-h>
:set sw shiftwidth=4    " set the value to use when use shift operator
                        " note that this is used when use "=" to format code
:set et expandtab       " toggle to expand a tab char to spaces. noexpandtab

When tabstop=4, softtabstop=0, expandtab, press a tab in insert mode and it will
be extended to 4 spaces. However, when use a backspace, will remove a space one
by one. By setting softtabstop=4, backspace will remove 4 spaces.

So if prefer spaces to tab, have tabstop, softtabstop, and shiftwidth have the
'same' value.


{show-invisibles}
http://vimcasts.org/episodes/show-invisibles/

:set list
:set nolist
:set list!     " toggle

Every tab is displayed as ^I and a $ is displayed at the end of each line. To change this:

" for tab and eof char
set listchars=tab:\ ,eol:

 is ctrl-v u25b8.      note: do not work for debian and me. why?
 is ctrl-v u00ac.
 is ctrl-v u00bb.      note: works well
 is ctrl-v u00ab.


{text-shift}
<shift-operator>
Use shiftwidth setting. note that can use dot operator to repeat

>{motion}      " increase the indentation on {motion}.
>G             " increase the indentation from the current line until the end of the file.
[num]>         " increase the indentation by [count] times.
[num]<
[num]>>

<example>
The example shows the block improperly indented. How to fix?

if( q.is_valid() )
{
  while( g.it != end )
  {
    char_t ch = *g.it;
    if( !ch.isspace() )
  {
      return q.calc();
  }
  }
}

Place a cursor return statement and use >a} or >aB

if( q.is_valid() )
{
  while( g.it != end )
  {
    char_t ch = *g.it;
    if( !ch.isspace() )
    {
      return q.calc();
    }
  }
}


Or you can paste with auto-reindent (just ']p' in vim)
["x]]p	" Like "p", but adjust the indent to the current line.


{indention} {=-command}

:set autoindent
:set smartindent
:set cindent

Another command to use for indentation is = (equal). It 'filters' the text with an external program
(if specified) or with the internal C indentation routine. To specify an external filter, you have
to set the equalprg variable:

:set equalprog=indent

Note that the definition for filter is 'program that accepts text at stantard input, changes it in
some way, and sends it to the standard output'. Not all programs match this criteria. Regardless of
the rutine used to filter the text, = indents the line where the cursor is placed or the selected
text if any.

Tip: G=gg indents the whole file. This is very useful when copy-pasting from another window, remote
session, etc, messes the indentation up. In the picture below, the left window shows a code copied
from the Internet and the right one, the same text after doing G=gg

You can always indent text blocks freely if the automatic indentation rules do not fit your taste.
In order to do this, use the <> commands. Applied twice on a text object they indent that text to
the left or to the right.


={============================================================================
*kt_dev_env_vim_202* prog:edit: match command

<PLUGIN> matchit
Even though matchit ships with the Vim distribution, it's not enabled by default. The enhancements
provided by this plugin are very useful, so I'd recommend enabling it. Consult :h matchit-install
for more details.

vim/vim74/macros

filetype plugin on
runtime macros/matchit.vim


{plugin} surround
One of my favorite plugins is surround.vim by Tim Pope,a which makes wrapping a selection with a
pair of delimiters easy. For example, we could put the words New York in quote marks:

Keystrokes Buffer Contents
{start}  cities = ["London", "Berlin", New York]
vee      cities = ["London", "Berlin", New York]
S"       cities = ["London", "Berlin", "New York"]

The S" command is provided by surround.vim, and it can be read as "Surround the selection with a
pair of double quote marks." We could just as easily use S) or S} if we wanted to wrap the selection
with opening and closing parentheses or braces. We can also use surround.vim to change existing
delimiters. For example, we could change {London} to [London] with the cs}] command, which can be
read as "Change surrounding {} braces to [] brackets." Or we could go the other way with the cs]}
command. It's a powerful plugin. Check it out.

http://github.com/tpope/vim-surround


{match-command} see :h %
Use '%' alone, this jumps between open and close pairs based on the value of the matchpairs option.

<matchpairs-option>
But angle brackets - <> - aren't included by default. They may be set based on the filetype. The
HTML filetype plugin sets it, so if you're opening HTML files you'll be able to use % to jump
between matching angle brackets. But not for e.g. C++/Java.

To add angle brackets if they aren't jumped when using %, use:

:set matchpairs+=<:>

Now using % on angle brackets should jump to the matching bracket. See :help 'matchpairs' and :help
various-motions for more details.

<example>
The trick here is to use the % command before making any changes. When we use the % command, Vim
automatically sets a mark for the location from which we jumped. We can snap back to it by pressing
``.

{start}  cities = %w{London Berlin New\ York}
dt{      cities = {London Berlin New\ York}
%        cities = {London Berlin New\ York}
r]       cities = {London Berlin New\ York]
``       cities = {London Berlin New\ York]
r[       cities = [London Berlin New\ York]


{example-in-coding}

From http://www.viemu.com/a-why-vi-vim.html

to change from:

if(!entry.used && equivalent(entry.key(), qk.key) && (curcontext & entry.context))

to:

bool equiv = equivalent(entry.key(), qk.key);
if(!entry.used && equiv && (curcontext & entry.context))

move to the start of equivalent
c% equiv ESC
O bool equiv = p ;


if(!entry.used && equivalent(entry.key(), qk.key) && (curcontext & entry.context))
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The '%' motion moves from a parenthesis (or similar grouping character) to its matching one - but if
you're not positioned at one of these special characters, it will scan character by character
<to-the-right>, until the first one is found, and then moving to the character matching that one.
So, in the above situation, it will move to the right closing parenthesis!

Knowing about the 'c' command, which deletes the extents of the next motion (also copying it to the
clipboard) and enters insert mode, we can type just 'c%' ("change match") from the above case. 


={============================================================================
*kt_dev_env_vim_300* tool: tag: cscope

If your version of Vim wasn't compiled with '--enable-cscope', you will need to reconfigure and
recompile Vim with that flag. 

The Cscope database (cscope.out) is generated the first time it is invoked. Subsequent use will
update the database based on file changes.

Cscope version 15.6 (http://cscope.sourceforge.net/)

the '-R' makes Cscope parse all subdirectories, not just the current directory)
the '-b' flag (which tells Cscope to just build the database, then exit. ??? ????? ?? ????)
the -q flag create inverted index database for quick search for large projects.
-s dir        Look in dir for additional source  files.
-U            Check file time stamps.

cscope -b -R -s/vobs/DARWIN_PLATFORM
cscope -q -b -R -s/vobs/CMS_INFORMATION_SERVICES -s/vobs/DARWIN_PLATFORM -s/vobs/CMS_MEDIA_SERVICES 

FILES
cscope.files
Default files containing -I, -p, -q, and -T options and the list of source files (overridden by
the -i option). 

cscope.out
Symbol cross-reference file (overridden by the -f option), which is put in the home directory if
it cannot be created in the current directory. 

cscope.in.out 
cscope.po.out
Default files containing the inverted index used for quick symbol searching (-q option). If you
use the -f option to rename the cross-reference file (so it's not cscope.out), the names for
these inverted index files will be created by adding .in and .po to the name you supply with -f.
For example, if you indicated -f xyz, then these files would be named xyz.in and xyz.po.


(in vim)
:cscope add /home/NDS-UK/parkkt/cc/parkkt_BSKYB_GM_002/cscope.out
:cscope find search-type search-string 
:cs f s player_api_events.c

0 or s: Find this C symbol (get header and source for a symbol)
1 or g: Find this definition (get header only)
2 or d: Find functions called by this function
3 or c: Find functions calling this function
4 or t: Find this text string
6 or e: Find this egrep pattern
7 or f: Find this file
8 or i: Find files #including this file


={============================================================================
*kt_dev_env_vim_301* prog: tag: ctag

{install}
http://ctags.sourceforge.net/

<ubuntu>
sudo apt-get install ctags
sudo apt-get install exuberant-ctags

<version>
$ ctags --version
Exuberant Ctags 5.9~svn20110310, Copyright (C) 1996-2009 Darren Hiebert
  Compiled: Nov  9 2011, 17:40:39
  Addresses: <dhiebert@users.sourceforge.net>, http://ctags.sourceforge.net
  Optional compiled features: +wildcards, +regex


{generate-a-tag-file}
ctags -R .

To set the place to create a tag:

ctags -R -f ./.git/tags .
ctags -R -f oem-hwei-7409.tags --c++-kinds=+p --fields=+iaS --extra=+q --tag-relative=yes /opt/oem-staging/huawei-bcm7409/usr/local

note: -f should be before than --fields

For some users that need more info of the symbols

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .

<in-vim>
:!ctags -R

{automatic-tag-creation}

:nnoremap <f5> :!ctags -R<CR>

Vim's autocommand feature allows us to invoke a command on each occurrence of an event, such as a
buffer being created, opened, or written to file. We could set up an autocommand that invokes ctags
every time we save a file:

http://andrewradev.com/2011/06/08/vim-and-ctags/

<solution-one> plugin:autotag
1. The ctag has an -a flag that makes it append to a tag file instead of overwriting it. That way
you can update the tags very quickly every time a file changes. With vim's autocommands, this could
work like this:

autocmd BufWritePost *
      \ if filereadable('tags') |
      \   call system('ctags -a '.expand('%')) |
      \ endif

Unfortunately, there's an issue with this approach. Ctags will only add new tags, it won't remove
ones that are no longer present. If you delete a function, it will still appear in the tag file.

That's where the autotag.vim plugin comes in. Whenever you save a file, it deletes all of its
entries and invokes ctags in append mode. I've been using it for a long time and I haven't noticed
any overhead at all, even on Windows boxes. Unfortunately, your vim build needs to have python
support to use it. Even if it doesn't, though, no errors are raised, which is nice if you use the
same vimfiles across different vim builds like I do.

autotag: http://www.vim.org/scripts/script.php?script_id=1343

15. How should I set up tag files for a multi-level directory hierarchy? 
http://ctags.sourceforge.net/faq.html

<solution-two>
Most source control systems provide hooks that allow us to execute a script in response to events on
the repository. We can use these to instruct our source control to re-index the repository every
time we commit our code.

http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html
In "Effortless Ctags with Git" Tim Pope demonstrates how to set up hooks for the post-commit
post-merge, and post-checkout events. The beauty of this solution is that it uses global hooks, so
configuring each individual repository on your system is unnecessary.

<consideration>
Using an autocommand to invoke ctags every time a buffer is saved ensures that our tags file is
always up-to-date, but at what cost? Re-indexing our codebase on each commit strikes a good balance.
The code that we're actively working on is the code we're least likely to want to navigate using
tags.

note: think that it is a good balance to have the second solution and the way to run it manually
such as key mapping.

<ctag-options>
From ctags faq:
7. Why can't I jump to class::member?

Because, by default, ctags only generates tags for the separate identifiers found in the source
files. If you specify the --extra=+q option, then ctags will also generate a second, class-qualified
tag for each class member (data and function/method) in the form class::member for C++, and in the
form class.method for Eiffel and Java. 

--exclude=.git
--languages=-sql


{tags-for-external}
When ./ is used in the tags option, Vim replaces it with the path of the currently active file. We
can inspect the defaults:

:set tags?
   tags=./tags,tags

With these settings, Vim looks for a tags file in the directory of the current file and in the
'working' directory.

The generated tags file only contains the symbols in the files in your project source tree, but not
any external file, such as standard header files 

ctags -R --c++-kinds=+p --fields=+iaS --extra=+q /usr/include


<solution-one> add only files that used in the project
Why must we generate a tags file containing all the symbols in the system header? If we only
generate the tags file 'only' for the header files that are 'related' to our projects, would it be
faster? That's the point of this idea. We could first search for the header files that are included
in our projects, and then we use ctags to generate a tags file for these files and our source files,
in this way, a much smaller tags file that containing all the symbols that maybe useful for the
project is generated. The solution is:

#!/bin/sh
# ./ctags_with_dep.sh file1.c file2.c ... to generate a tags file for these files.
gcc -M $* | sed -e 's/[\\ ]/\n/g' | \
sed -e '/^$/d' -e '/\.o:[ \t]*$/d' | \
ctags -L - --c++-kinds=+p --fields=+iaS --extra=+q 

./ctags_with_dep.sh file1.c file2.c file3.cpp ...

The idea is that -M list header files, sed process this and pipe it into ctags using -L option.

What if you have other directories besides the standard /usr/include that containing the header
files you need? You could do a little modification on this script. For example, you have some header
files in ~/include, then you could pass -I ~/include to the gcc command. Just like below:

gcc -M -I ~/include $* | sed -e 's/[\\ ]/\n/g' | \
sed -e '/^$/d' -e '/\.o:[ \t]*$/d' | \
ctags -L - --c++-kinds=+p --fields=+iaS --extra=+q 

<solution-two>
The other way is that create a tag file for system headers once and use when it is needed.

:se tags+=/usr/include/tags

Here se is se[t] in vim and ctags read a tag file from the current directory so can set one in a
different directory and 'add' it the 'database'.


{tag-config}
Either by setting the environment variable CTAGS to your custom options, or putting them into a
.ctags file in your home directory. 

http://blog.stwrt.ca/2012/10/31/vim-ctags:

For example, here's my ~/.ctags file:

# Basic options
--recurse=yes
--tag-relative=yes
--exclude=.git

note: Clojure is language and looks like this is how define new language for ctag.
# Regex for Clojure
--langdef=Clojure
--langmap=Clojure:.clj
--regex-clojure=/\([ \t]*create-ns[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/n,namespace/
--regex-clojure=/\([ \t]*def[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/d,definition/
--regex-clojure=/\([ \t]*defn-?[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/f,function/
--regex-clojure=/\([ \t]*defmacro[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/m,macro/
--regex-clojure=/\([ \t]*definline[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/i,inline/
--regex-clojure=/\([ \t]*defmulti[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/a,multimethod definition/
--regex-clojure=/\([ \t]*defmethod[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/b,multimethod instance/
--regex-clojure=/\([ \t]*defonce[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/c,definition (once)/
--regex-clojure=/\([ \t]*defstruct[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/s,struct/
--regex-clojure=/\([ \t]*intern[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/v,intern/
--regex-clojure=/\([ \t]*ns[ \t]+([-[:alnum:]*+!_:\/.?]+)/\1/n,namespace/

<options>
-R
Equivalent to --recurse

--tag-relative[=yes|no]

Indicates that the file paths recorded in the tag file should be relative to the directory
containing the tag file, rather than relative to the current directory, unless the files supplied on
the command line are specified with absolute paths. This option must appear before the first file
name. The default is yes when running in etags mode, no otherwise

--exclude=[pattern]

-L file
Read from file a list of file names for which tags should be generated. If file is specified as "", then file names are read from standard input.


{tag-hyperlink}
The tag file has to be generated by a program like ctags, before the tag commands can be used. The
hyperlink is a text enclosed in vertical bars (for example, |help|) and the destination is the
notation *help.txt*. 


{tag-stack-push-pop}
With the <C-]>, push command, the keyword on which the cursor is standing is used as the tag. If the
cursor is not on a keyword, the first keyword to the right of the cursor is used. <C-t>, pop to
[count] older entry in the tag stack (default 1).

The most obvious way to use this is while browsing through the call graph of a program. Consider
the following call graph:

             ---> <C-]>
     main  --->  FuncA  --->  FuncC
           --->  FuncB
             <--- <C-t>

If the stack was full (it can hold up to 20 entries), the oldest entry is deleted and the older
entries shift one position up (their index number is decremented by one). 

<navigate-tag-list>
If it has multiple matches, then the g<C-]> command presents us with a list of choices from the tag
match list: note: <C-]> shows up the list.

If a tag in the current buffer matches the keyword, it gets the highest priority. :h tag-priority

:tn   " next. note: see "key mapping: traverse a list"
:tp   " prev
:ts   " select. show a list to select

:tags " history. To show the tags you've traversed since you opened vim
:ltag " will load the tags into the location list window.  You can then view that window by executing :lopen.

We don't have to move the cursor on top of a keyword to jump to its tag. Can use Ex commands. At
times, typing these commands can be quicker than maneuvering the cursor onto a keyword in the
document; especially since Vim provides tab-completion for all keywords in the tags file. Can accept
a regular expression when used in the form 

:ta[g] /{pattern}    note: leading '/' char in pattern.
:ta /phone$
:ta /^asserts_*


={============================================================================
*kt_dev_env_vim_302* prog: move in c

{move-in-source}
note: these commands are effectively search.

gd    " will take you to the local declaration.
gD    " will take you to the global declaration.

Note that this is not guaranteed to work, Vim does not really check the syntax, it only searches for
a match with the keyword. If included files also need to be searched use the commands listed in
|include-search|. After this command |n| searches forward for the next match (not backward).


g*    " search for the word under the cursor (like *, but g* on 'rain' will find words like 'rainbow').
g#    " same as g* but in backward direction.

gg    " goes to the first line in the buffer (or provide a count before the command for a specific line).
G     " goes to the last line (or provide a count before the command for a specific line). 

gf    " will go to the file under the cursor 


={============================================================================
*kt_dev_env_vim_303* prog: tag: gtag

{why}
1. hierarchical searches by default.
GNU GLOBAL can treat a source tree containing sub-directories as a project.
Anywhere in the project, you can utilize a high performance tag database.

/home/user/
 |
 |-ROOT/      <- the root of source tree (GTAGS,GRTAGS,...)
    |

So can run "global" command in 'any' dir under ROOT.

2. locates not only definitions but also references.


{build}
2015/6/10
    GLOBAL-6.5 was released.

New facilities:
o global: New -N (--nearness=[start]) option.
        Nearness sort method is available for the output of tag search command.
        The result of nearness sort is concatenation of the followings ([1]-[n])
        in this order. The default of 'start' is the current directory.
        [1] Output of local search in the 'start' directory.
        [2] Output of local search in the parent directory except for [1].
        [3] Output of local search in the grandparent directory except for [1]-[2].
        (repeat until the project root directory)
        [n] Output of local search in the project root directory except for [1]-[n-1].
        In each directory, they are sorted by alphabetical order.
o global: Now the --literal option also works with the tag search command,
        -P command and -I command as well as the -g command.

2015/2/2
    GLOBAL-6.3.4 was released. This is a bug fix release

http://www.gnu.org/software/global/whatsnew.html
https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools

configure: error: curses library is required but not found. If you are not going to use
gtags-cscope, please try ./configure --disable-gtagscscop

<to-get-curses>
http://www.gnu.org/software/ncurses/
wget http://ftp.gnu.org/pub/gnu/ncurses/ncurses-5.9.tar.gz
./configure
sudo make install


$./configure --prefix=/home/kpark/ --disable-gtagscscope
# bin will be created uder the prefix

$ make
$ make install


{gtag}

<config>
note: there are gtag and global config.

skip (comma separated list)


<use-file-list> script-to-build-flist
find . -type f -print >/tmp/list     # make a file set
vi /tmp/list                         # customize the file set
gtags -f /tmp/list

note: -f option only allows filenames but not directory which means list out
every files.

#!/bin/bash
echo "building a gtag list..."
find -L $1 -name '*.[ch]' -o -name '*.[ch]pp' > flist.out 
gtags -f ./flist.out

note: don't use incremental tag updating.


<the-point-to-start>
Gtags recursively collects source files from the 'current' directory. So the
point is that "gtags dir" specifies where tag files get created but file
details are based on where the current dir was when run tag commend.

gtags DEVARCH              # will create tag files in DEVARCH
gtags ~/source             # will create tag files in ~/source

$ pwd
/source/DEVARCH
$ gtags ~/source
$ gl FutureContextCommonImpl        // works okay
$ gl -r FutureContextCommonImpl     // not find any

$ pwd
/source
$ gtags ~/source
$ gl FutureContextCommonImpl        // works okay
$ gl -r FutureContextCommonImpl     // works okay


<gtag-outputs>
$ ls G*
GPATH   GRTAGS  GTAGS
`GTAGS' definition database
`GRTAGS' reference database
`GPATH' path name database 

note: the size differnece for the same tree
-rw-r--r--  1 kpark kpark  3211264 Feb 18 09:08 GPATH
-rw-r--r--  1 kpark kpark 18718720 Feb 18 09:08 GRTAGS
-rw-r--r--  1 kpark kpark  3907584 Feb 18 09:08 GTAGS
-rw-r--r--  1 kpark kpark 33285064 Feb 17 09:40 tags


{use-external-tags}

1. approach one

If you want to locate symbols that are not defined in the source tree, then you
can specify library directories with GTAGSLIBPATH environment variable.

Should execute gtags(1) at each directory in the GTAGSLIBPATH. If GTAGS is not
found there, global ignores such directories.

export GTAGSLIBPATH=.:~/source:/home/kpark/gtags/toolchain

note: GTAGSROOT
The root directory of the project. Usually, it is recognized by existence of
GTAGS. Use of this variable is not recommended. 

$ pwd
/develop/src/mh                                 # this is a source project

$ gtags
$ ls G*TAGS
GRTAGS  GTAGS

$ global mhl
uip/mhlsbr.c                                    # mhl() is found

$ global strlen                                 # strlen() is not found
$ (cd /usr/src/lib; gtags)                      # build tag for library source
$ (cd /usr/src/sys; gtags)                      # build tag for kernel source

$ export GTAGSLIBPATH=/usr/src/lib:/usr/src/sys       # note: has multiples
$ global strlen
../../../usr/src/lib/libc/string/strlen.c             # now found in library
$ global access
../../../usr/src/sys/kern/vfs_syscalls.c              # now found in kernel


2. approach two

Or, you can take a more straightforward way to do the same thing. In the
following example, we treat as if the system library and the kernel are part of
our project.

$ ln -s /usr/src/lib .
$ ln -s /usr/src/sys .
$ gtags
$ global strlen
lib/libc/string/strlen.c
$ global access
sys/kern/vfs_syscalls.c


3. approach three

Seems that <2> sometimes do not work but works anyway. The way based on the
second is 

~/gtags/proj-a/
   G* files
   link -> /dir-real-a-project

~/gtags/proj-b/
   G* files
   link -> /dir-real-b-project

note: use both since suppose that there is a folder which need to rebase then it
is waste to build whole external folders everytime when rebase. So use the
first approach to include external sources when necessary and the external
sources has tags built already.


{global-options}

<relative-path>
By default, you get relative paths of the located files depending on current
directory when run global command. 

The -a option produces absolute path names. 
The -l search only under the current directory. note: to scope search
The -S, --scope dir
Print only tags which exist under dir directory. It is similar to the -l option, but you need not
change directory. 

<search-type>
The -O search only in the text files. 
The -o search in both the source files and text files. 

<default>
Shows definition tags

$ global AEM_JAVA_Invite_RegisterStateListener
vobs/DARWIN_PLATFORM/DARWIN_AEM_JAVA/src/natAemInviteImpl.c

<details>
The -x for more details listing that locate a exact func with line and filename.

$ global -lx threadFunc
threadFunc         22 detached_attrib.c threadFunc(void *x)
threadFunc         63 one_time_init.c  threadFunc(void *arg)
  
<reference-or-callers>
The -r option locates object references. note: see callers.

$ global -rx AEM_JAVA_Invite_*StateListener

<pattern-search>
The -g command locates the lines which have specified pattern. same as GREP It is similar to
egrep(1) but is far more convenient for source code reading, because it allows you to search through
a project, and 'only' in the source files. Additionally, you can use various options:

$ global -gx AEM_JAVA_Invite_*StateListener 

<get-pathname>
The -P command locates path names which include the specified pattern.

$ global -P fileB
DIR1/fileB.c

$ global -P '1/'
DIR1/fileA.c
DIR1/fileB.c

$ global -P '\.c$'
DIR1/fileA.c
DIR1/fileB.c
DIR2/fileC.c

<search-symbols>
If you forget object names, you can use the -c (complete) command. 

note: how about "global AEM_JAVA_Invite_*" The difference is that -c shows candidate symbols but the
usual global command shows all matches to a symbols. So can use this option to figure out symbols to
use.

$ global -c AEM_JAVA_Invite_
AEM_JAVA_Invite_CreateIcon
AEM_JAVA_Invite_Delete                    # this is what I need
AEM_JAVA_Invite_DeregisterStateListener

$ global -r AEM_JAVA_Invite_Delete

<no-definition-in-project>
The [-s] command locates symbols which are not defined in 'GTAGS'. 
-s, --symbol
Print other symbol tags. Other symbol means the reference to a symbol which has no definition. 


{use-in-vim}

3.5.3 Usage

# Please copy vim scripts from where installed to your plug-in directory.

$ cp $PREFIX/share/gtags/gtags.vim $HOME/.vim/plugin

note: not sure if it's copied when build and install gtags. There are other
gtags.vim in /home/kpark/.vim/bundle/unite-tag.

$ cp $PREFIX/share/gtags/gtags-cscope.vim $HOME/.vim/plugin

# To go to main symbol, you can say. 
:Gtags main
:Gtags -r func1
:Gtags ^put_                  # locate objects start with 'put_'

Input completion is available. In the command line, press C-D after some typings
and Vim will show a list of tag names that start with the string. Press TAB and
Vim will complete the tag name.

:Gtags fuTAB
:Gtags func1                  # 'nc1' is appended by vim

The output will be shown in quickfix window so can use quickfix move keys.

Suggested map:
    map <C-n> :cn<CR>
    map <C-p> :cp<CR>


note: To our regret, the tag stack facility is not available. If you want to use
the facility, please try gtags-cscope.vim.


The GtagsCursor command brings you to the definition or reference of the current
token.

If the context of the current token is a definition then it is equivalent to :Gtags -r
current-token; if it is a reference to some definitions then it is equivalent to :Gtags
current-token; else it is equivalent to :Gtags -s current-token.

:GtagsCursor

Suggested map:

map <C-\>^] :GtagsCursor<CR>

Though the mapping of :GtagsCursor to ^] seems suitable, it will bring an inconvenience in the help
screen. note: this about help is true so cannot use C-] as a mapping.


{gtags-faq}
Q3. I'm a C++ programmer. Why does not gtags pick up class names in *.h?

A3. GLOBAL treats *.h files as a C source file. If you want to treat them
    as a C++ source file, please set environment variable GTAGSFORCECPP.

        $ export GTAGSFORCECPP=


{gtags-unite}
https://github.com/hewes/unite-gtags

Usage

This source provides following sub commands for Unite

    Unite gtags/context
    Unite gtags/ref
    Unite gtags/def
    Unite gtags/grep
    Unite gtags/completion


Unite gtags/context
-------------------
Unite gtags/context lists the references or definitions of a word. It executes
global --from-here=<location of cursor> -qe <word on cursor>

When your cursor is on a definition Unite lists references of it, otherwise list
definitions.

-e, --regexp pattern
    Use pattern as the pattern; useful to protect patterns starting with -. 

-q, --quiet
    Quiet mode.  note: do not have effect on output


Unite gtags/ref 
---------------
lists references of a word. It executes global -qrs -e <pattern> in internal.
You can specify <pattern> as an argument :Unite gtags/ref:<pattern>. When
exeucte this command with no arguments :Unite gtags/ref, unite-gtags uses
expand('<cword>') as pattern.


Unite gtags/def
---------------
lists definitions of a word. It executes global -qd -e <pattern> in internal.

-d, --definition
    Print locations of definitions. 

You can specify <pattern> as an argument :Unite gtags/def:<pattern>. When
exeucte this command with no arguments :Unite gtags/def, unite-gtags uses
expand('\<cword\>') as pattern.


Unite gtags/grep
----------------
lists grep result of a word. It executes global -qg -e <pattern> in internal.

You can specify <pattern> as an argument :Unite gtags/grep:<pattern>. When
exeucte Unite with no arguments :Unite gtags/grep, input prompt is shown.
unite-gtags uses the input as <pattern>.


Unite gtags/completion
----------------------
lists all tokens in GTAGS. It executes global -c and show results.

Default action on the Unite item is list_references. list_definitions is also
available.


Unite gtags/file
----------------
Unite gtags/file lists current file's tokens in GTAGS. It executes global -f and
show results.

You can specify <pattern> as an argument :Unite gtags/file:<pathname>. When
exeucte this command with no arguments :Unite gtags/file, unite-gtags uses
buffer_name("%") as filepath.


# {gtags-cscope}
# note: not that useful since no tab completion is supported.
# 
# gtags-cscope (fake cscope). You can use gtags-cscope(1) instead of cscope(1).
# For example, you can deceive Vim editor using the following commands:
# 
# :set csprg=gtags-cscope    " note need cscope enalbed gtag binary
# :cs add GTAGS
# 
# After this, you can use built-in 'cs find' commands in the Vim editor. Though
# the deceit is not perfect ('cs find d' is not implemented), this method might be
# more convenient than 'gtags.vim' in the point that you can use the tag stack
# facility of Vim.
# 
# # from .vimrc
# 
# " for gtag
# if has('cscope')
#   set cscopetag cscopeverbose
#   
#   if has('quickfix')
#     set cscopequickfix=s+,c+,d+,i+,t+,e+
#   endif
#   
#   " for gtag
#   set csprg=gtags-cscope
# 
#   cnoreabbrev csa cs add
#   cnoreabbrev csf cs find
#   cnoreabbrev csk cs kill
#   cnoreabbrev csr cs reset
#   cnoreabbrev css cs show
#   cnoreabbrev csh cs help
#   cnoreabbrev csc call setqflist([])
#   
#   map <C-n> :cn<CR>
#   map <C-p> :cp<CR>
# endif
# 
# 0 or s: Find this C symbol (get header and source for a symbol)
# 1 or g: Find this definition (get header only)
# 2 or d: Find functions called by this function
# 3 or c: Find functions calling this function
# 4 or t: Find this text string
# 6 or e: Find this egrep pattern
# 7 or f: Find this file
# 8 or i: Find files #including this file
# 
# 
# Vim execute global(1), parse the output, list located objects in quickfix window
# and load the first entry. You can go to any entry using quickfix command. For
# help, :h quickfix
# 
# # update a window whenever do search
# :set cscopequickfix=s-,c-,d-,i-,t-,e-
# 
# # add a window whenever do search
# set cscopequickfix=s+,c+,d+,i+,t+,e+


={============================================================================
*kt_dev_env_vim_304* prog: build: quickfix

{quickfix}
Calling an external compiler from Vim saves us from having to leave our editor and if the compiler
reports any errors, Vim provides the means for us to jump between them quickly.

:h quickfix

<run-make>
:make!

The trailing ! character tells Vim to update the quickfix list without jumping to the first item.

<makefile>
To run make in vi, use makefile and simple makefile is:

# simple makefile from gmake

FILE = gen-list-linked.cpp
CC = g++ -std=c++0x

main : main.o
     echo 'bulid out'
     $(CC) -o out main.o

main.o : $(FILE)
     echo 'build $(FILE)'
     $(CC) -o main.o -c $(FILE)

clean :
     rm out main.o

<set-make>
To change the command when use :make
:set makeprg=gmake

To have the same as "$ ZB_CFG=huawei.370 zb-make"
:set makeprg=ZB_CFG=huawei.370\ zb-make

To see the current value
:set makeprg

<navigate-list>
The quickfix list holds a collection of locations from one or more files. Each
record could be an error raised by the compiler when running :make, or it could
be a search match from running :grep.  No matter how the list was forged, we
must be able to navigate these records.

:cn[ext]    " Jump to next item
:cp[rev]    " Jump to previous item
:cfirst     " Jump to first item
:clast      " Jump to last item
:cnfile     " Jump to first item in next file note: what is the file here?
:cpfile     " Jump to last item in previous file
:cc N       " Jump to nth item
:copen      " Open the quickfix window. note: can use move keys in the window
:cclose     " Close the quickfix window
:cl[ist]    " list all items

note: Once build is done, should manually open an window.
note: Window has warning and others. Need to search through. Possible to see only errors?


<recall-list>
When we update the quickfix list, Vim doesn't overwrite the previous contents. It saves the results
of older quickfix lists, allowing us to refer back to them. We can recall an older version of the
quickfix list. Vim holds onto the last ten lists. This can be a real time saver, especially if the
command takes a long time to run.

:cnewer  " To revert from an old quickfix list back to a newer one
:colder  "


{location-list}
For every command that populates the quickfix list, there's a variant that places the results in a
location list instead. While :make, :grep, and :vimgrep use the quickfix list, :lmake, :lgrep, and
:lvimgrep use the location list. So what's the difference? At any given moment, there can be only
one quickfix list, but we can create as 'many' location lists as we want.

Suppose that we've followed the steps in Tip 107, on page 265, so that running :make in a JavaScript
file passes the contents of the file through JSLint. Now let's say that we've got two different
JavaScript files open in split windows. 

We run :lmake to compile the contents of the active window, which saves any error messages to the
location list. Then we switch to the other window and run :lmake again. Rather than overwriting the
existing location list, Vim creates a new one. Now we have two location lists, each containing
errors for a different JavaScript file.

Any commands that interact with a location list (:lnext, :lprev, and so on) will act on the list
that is bound to the currently active window. Compare this with the quickfix list, which is
available globally throughout Vim: no matter which tab page or window is active, when you run
:copen, the quickfix window will show the same list.


={============================================================================
*kt_dev_env_vim_305* prog: build: makeprg and filetype

{makeprg-on-filetype}
http://tuxion.com/2011/09/30/vim-makeprg.html

This started out as a small post on how to preview markdown documents in Vim using makeprg, but
somehow I got carried away. More on the markdown thing in a bit.

When you type :make in Vim, the value of makeprg is executed in a subprocess. Traditionally this
value is set to make, but you can set this to anything you like. You can see the current value by
typing :set makeprg. When you combine this with Vim's support for filetype plugins, there's a decent
amount of value that I think is sometimes overlooked. So this article is an attempt to explain some
of the things you can do with makeprg and filetype detection.  

Filetype Plugins

A filetype plugin is like a global plugin, except that it sets options and defines mappings for the
current buffer only.

Using a filetype plugin, we can set makeprg to something useful depending on the type of a file it
happens to be. Adding your own filetype plugin is easy, just create a file of the form:
<filetype>.vim inside the ~/.vim/after/ftplugin directory. The after subdirectory is technically
optional, but I prefer it as it keeps things isolated from other installed plugins. The after
subdirectory is sourced last as Vim initializes itself, so putting your options there ensures they
aren't clobbered by other plugins.

For a given Vim buffer, you can see the filetype by typing :set ft. Some people put this information
in their statusline, which can be helpful if you're writing Vim plugins or just want to make sure
things are being detected correctly.

For example, if I want to define custom settings for the C filetype, I would create
~/.vim/after/ftplugin/c.vim and put my settings there. Any time a file of type C is loaded, my
settings are applied. We can use this mechanism to set a custom makeprg for certain filetypes.

Customizing makeprg for Markdown

I take all of my notes in Markdown, which is nearly plain text with a tiny amount of markup. This
allows me to quickly convert my personal notes into decent looking html documentation. It seems to
be a regular occurrence that my notes become the initial documentation for the project or subproject
that I'm working on. Many wiki's support Markdown, so it ends up saving me work by just keeping
everything in that format.

Even though Markdown's syntax is very lean and simple, I still end up forgetting some of it from
time to time. I find it useful to generate and view the HTML output for the buffer that I'm working
on periodically to make sure things look right. This is really easy by setting a custom makeprg for
the markdown filetype.  

The Hammer Plugin

Robert Gleeson wrote a Vim plugin called Hammer that basically does exactly what I explain here and
quite a bit more. It might be perfect for you, but for me it's much more than I need. I've had
problems when the version of Ruby on the system is not the same as what Vim was compiled with. Check
it out though, you might love it.  

A Simpler Approach

All I want is to type :make and have Vim generate an HTML version in /tmp that I can point my
browser to. So I put the following in ~/.vim/after/ftplugin/markdown.vim:

set makeprg=redcarpet\ %\ >/tmp/%<.html

Let's take a quick look at what's going on here:

The above setting is applied only when editing a markdown buffer. Personally, I use redcarpet to
parse markdown, but there are many others that you can substitute here. 

Spaces in option strings must be escaped so Vim knows when to stop parsing.
    % expands to the name of the file currently being edited.
    %< expands to the name of the file without the trailing extension. This allows us to change the
    %name of the file and add the html extension.

So the above command calls redcarpet on the filename and redirects the output to
/tmp/<filename>.html. That's it, super simple. Once this completes, I point my browser to file:/tmp
and load the file I'm interested in.

This same approach can be taken with ReStructured Text by putting the following in
~/.vim/after/ftplugin/rst.vim:

set makeprg=rst2html.py\ %\ /tmp/%<.html`
 
 [KT] bash alias do not work so make a script for that.

Extra Credit

For C, we could set makeprg to call gcc directly instead of make if a Makefile is not found in the
current working directory. I find this very helpful when creating a scratch source file to test
certain behaviour or a quick theory. Here's what the contents of ~/.vim/after/ftplugin/c.vim might
look like:

if !filereadable(expand("%:p:h")."/Makefile")
    setlocal makeprg=gcc\ -Wall\ -Wextra\ -o\ %<\ %
endif

Now when you load a file of type C and there is no Makefile, typing :make will compile your source
file into an executable of the same name (minus the extension). I use this all the time. You could
do the same thing for C++ by changing the filename to cpp.vim and changing gcc to g++.


={============================================================================
*kt_dev_env_vim_306* prog: build: man page in vim

We can place the cursor at the 'printf' function call and press K. If we want to see the manual page
on the printf C function (Section 3 'System library calls') we need to type 3K. Once you are done
with the manual, type ENTER to return to Vim.

K

Run a program to lookup the keyword under the cursor. The name of the program is given
with the 'keywordprg' (kp) option (default is "man"). The keyword is formed of letters, numbers and
the characters in 'iskeyword'. The keyword under or right of the cursor is used.  


The same can be done with the command >

 :!{program} {keyword}

There is an example of a program to use in the tools directory of Vim.  It is called 'ref' and does
a simple spelling check.

Special cases:
- If 'keywordprg' is empty, the ":help" command is used.  It's a good idea to include more
  characters in 'iskeyword' then, to be able to find more help.

- When 'keywordprg' is equal to "man", a count before "K" is inserted after the "man" command and
  before the keyword.  For example, using "2K" while the cursor is on "mkdir", results in: > !man 2
  mkdir


={============================================================================
*kt_dev_env_vim_320* prog: folding

{foldmethod}
'foldmethod' option (abbreviated to 'fdm') is local to each 'window'.

manual - folds must be defined by entering commands (such as zf)
indent - groups of lines with the same indent form a fold
syntax - folds are defined by syntax highlighting
expr   - folds are defined by a user-defined expression 

:h fold-methods 
to learn the details of different fold methods.

:h folding 
to learn the keyboard commands for manipulate folds.

:h folds 
for help on the entire topic of folding.

<save-and-load-view>
:mkview        " to save folds
:loadview      " to restore folds


{manual-mode}
Use z? command in a normal mode

zf'a           " fold lile from the current line to mark

v{motion}zf    " fold using visual mode
V{motion}zf
va}zf          " fold {} block containing the cursor. visual, {} selecion and zf

zf{motion}
zfa}           " create a fold from the line with the first brace through the last. 
zfa{           " This also works with other block enclosures

zf2j           " fold three lines

:., 20 fo         " fo works backwards as well.
:20, 101 fo{ld}

zd             " delete a fold. it's different from 'zo' as cannot do 'zc' after that.
zo             " opens a fold at the cursor.
zr             " open all first-level folds in Vim
zR             " open all of the folds in the file. 
zc             " close

If we unfold the top level fold, the inner one is shown collapsed. The states of nested folds are
'independent'. zd and zD are used to deleted folds (the latter recursively), and zE deletes all the
folds in the current window. As a general rule, the capitalized version of all the commands (zC, zO)
applies the action recursively

" syntax mode
foldmethod=syntax

zj    " moves the cursor to the next fold.
zk    " moves the cursor to the previous fold.
[z    " move to start of open fold.
]z    " move to end of open fold.


={============================================================================
*kt_dev_env_vim_003*	recovery, swap and backup

where <filename> is the name of the file you were editing at the time of the crash:
vim -r <filename>

You can list the recoverable files:
vim -r

# .vimrc
# set backup " backup on
# set nobackup " backup off
# The 'directory' option controls where swap files go.

set backup
set backupdir=/home/NDS-UK/parkkt/vimback
set directory=/home/NDS-UK/parkkt/vimback


{swap-file}

(http://vimdoc.sourceforge.net/htmldoc/recover.html)
1. Vim stores the things you changed in a swap file.  Using the original file you started from plus the
swap file you can mostly recover your work.

You can see the name of the current swap file being used with the command:

:sw[apname]

The name of the swap file is normally the same as the file you are editing, with the extension
".swp".	  

The swap file is deleted as soon as Vim stops editing the file.

By setting the 'directory' option you can place the swap file in another place than where the edited
file is.

2. The swap file might be the result from a previous crash of Vim or the computer.  Check the dates
mentioned in the message.  If the date of the swap file is newer than the file you were editing, and
this line appears:

modified: YES 

Then you very likely have a crashed edit session that is worth recovering.


If the date of the file is newer than the date of the swap file, then either it was changed after
the crash (perhaps you recovered it earlier, but didn't delete the swap file?), or else the file was
saved before the crash but after the last write of the swap file (then you're lucky: you don't even
need that old swap file).  Vim will warn you for this with this extra line:

NEWER than swap file! 	

WHAT TO DO?

If dialogs are supported you will be asked to select one of five choices:

  Swap file ".main.c.swp" already exists! 
  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: 

O  Open the file readonly.  Use this when you just want to view the file and
   don't need to recover it.  You might want to use this when you know someone
   else is editing the file, but you just want to look in it and not make
   changes.

E  Edit the file anyway.  Use this with caution!  If the file is being edited
   in another Vim, you might end up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe then sorry.

R  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.

Q  Quit.  This avoids starting to edit the file.  Use this if there is another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When starting Vim with
   files in several windows, Vim quits only if there is a swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.

A  Abort.  Like Quit, but also abort further commands.  This is useful when
   loading a script that edits several files, such as a session with multiple
   windows.

D  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when it doesn't contain changes, or when the file itself is
   newer than the swap file.
      On Unix this choice is only offered when the process that created the
   swap file does not appear to be running.
   
BACKUP

If you write to an existing file (but do not append) while the 'backup',
'writebackup' or 'patchmode' option is on, a backup of the original file is
made.


{keep-the-original}

To make Vim keep the original file, set the 'patchmode' option.  This specifies the extension used
for the first backup of a changed file.  Usually you would do this:

:set patchmode=.orig


==============================================================================
*kt_dev_env_vim_004*	color and syntax

{colorscheme}

:colorscheme evening

{color-syntax}

:syntax clear		# to disable
:syntax off			# to turn off

{user-syntax}

.vim/syntax/nds.vim

can use egrep style as below

syntax match ndsMesg02          /UAM_DCM_PARAM_DATA_INTERNAL_TYPE_STANDBY_\(IN\|OUT\)/
hi def link ndsMesg02 Type


==============================================================================
*kt_dev_env_005*	plugin: foldsearch

http://www.vim.org/scripts/script.php?script_id=2302

to see those ony matches with pattern

# not working
Fp KEY_PRESS\|VRM_JOB_START

Fp VRM_JOB_START\|TUNER_LOCKED\|hMC=0x304\|hMC=772
s/MCM_MEDIACONN_Run\|VRM_JOB_START\|hMC=0x36


==============================================================================
*kt_dev_env_006*	plugin: conque

Conque is a Vim plugin which allows you to run interactive programs, such as bash on linux or powershell.exe on Windows, inside a Vim buffer. In other words it is a terminal emulator which uses a Vim buffer to display the program output.
http://code.google.com/p/conque
:ConqueTermSplit



==============================================================================
*kt_dev_env_vim_008*	search and substitute

{search-settings}

:set ignorecase
:set noignorecase





{subst-using-search}

/four<Enter>	find the first string "four"
cwfive<Esc>	change the word to "five"
n		find the next "four"
.		repeat the change to "five'
n		find the next "four"
.		repeat the change
	  etc.


{range}

Specifier 	Description

number		an absolute line number
.		the current line
$		the last line in the file
%		the whole file. The same as 1,$
't		position of mark "t"
/pattern[/] 	the next line where text "pattern" matches.
?pattern[?] 	the previous line where text "pattern" matches
\/ 		the next line where the previously used search pattern matches
\?		the previous line where the previously used search pattern matches
\&		the next line where the previously used substitute pattern matches


{vim-subst}

# Part of the command word enclosed in the "[" & "]" can be omitted. 
# NOTE: only first search is a pattern. MAKE SENSE.
:substitute
:range s[ubstitute]/pattern/string/cgiI

For each line in the range replace a match of the pattern with the string where:

c	Confirm each substitution
g	Replace all occurrences in the line (without g - only first).
i	Ignore case for the pattern.
I	Don't ignore case for the pattern.

# the % means "all the lines of the file". "global" option, which tells Vim to replace every
# occurrence on a line, and not just the first occurrence.

:s/from/to/g                     # on the current line
:%s/from/to/g 
:%s/printf(/fprintf(stderr,/gc
:.,$s/yes/no/

# can use pattern in range and use other char instead of slash(/) which makes no need to use
# backslash to escape when there is a slash in search string
# ?pattern? means search backword and /pattern/ means forward.

:?^Chapter?,/^Chapter/s=grey=gray=g
:'t,'b                                   # use marks

# the new c option we are using means we want a 'c'onfirmation message for every replace.  replace
# with foo (y/n/a/q/l/^E/^Y)?  The "y" and "n" are self-explanatory, but what about the rest?
#
# a : to tell Vim to go ahead and replace all instances of the matched answer with a. from the current.  
# l : to tell Vim to make the current change and then stop, use l, for last.  ^E and ^Y allow
# you to scroll the text using Ctrl-e and Ctrl-y.

:0,10s/from/to/gc

# matching one or more terms. used alternation.
 
:%s/Kang\|Kodos/alien/gc

# it adds '|>' to the beginning of one line.
:s/^/|> /
:%s/^/|> /

==============================================================================
*kt_dev_env_009*	regexp - char class

Note that the range represents just one character in the search pattern, that is [0123] and 0123 are not the same.

[a-z] 		# Matches a single lowercase letter
[A-Z] 		# Matches a single uppercase letter
[a-zA-Z] 	# Matches a single letter
[0-9] 		# Matches a single number
[a-zA-Z0-9] 	# Matches a single letter or number
[^a-f]		# not

"^" will lose its special meaning if it's not the first character in the range.

A negated character class means "match a character that's not listed and not don't match what is listed."
Note KT. therefore, 'q[^u]' don't match with 'Iraq'

In class, '-' and '^' are only meta char and '-' isn't meta if it comes the
first. 

# example

s:[65]:Dig:g

Before:
High 65 to 70. Southeast wind around 10

After:
High DigDig to 70. Southeast wind around 10

Note KT. because [65] matches both '6' and '5'. 

s:65:Dig:g

Before:
High 65 to 70. Southeast wind around 10

After:
High Dig to 70. Southeast wind around 10


==============================================================================
*kt_dev_env_010*	regexp - word boundary

That dang-tootin' #@!%* varmint's cost me $199.95!
^  " ^  " ^    "        ^     " ^"^  " ^"  ^ " ^"
#### #### ######        ####### # #### ##  ### ##

^ where \< is true, " where \> is true, # is words  

s:\<vi\>:VIM:g


==============================================================================
*kt_dev_env_011*	regexp - escaped or meta char 	 *kt_vim_reg_meta*

Quantifers ~
?	# optional. e.g. "colou?r" will match color or colour
* 	# matches 0 or more of the preceding characters, ranges or metacharacters(as many times as possible)
.* 	# matches everything including empty line
+ 	# matches 1 or more of the preceding characters...

e.g. ' +' is the same as '  *'.

in summary:

	min required	max to try	meaning
?	none		1		one optional
*	none		no limit	any amout ok
+	1		no limit	at least one

\{n,m}	matches from n to m of the preceding characters...
\{n}	matches exactly n times of the preceding characters...
\{,m}	matches at most m (from 0 to m) of the preceding characters...
\{n,}	matches at least n of of the preceding characters... where n and m are positive integers (>0)

\u\w		# matches 'MI', 'VRMS', 'EVENT_MGR_THREAD', etc..
\u\w\+		# similar to the above but matches more. this qualifiers are greedy. 

".*"		# matches everything between " and ". e.g. "$VIM/.gvimrc". You can check this with ":version"

non-greedy quantifiers:

\{-}	matches 0 or more of the preceding atom, as few as possible
\{-n,m}	matches 1 or more of the preceding characters...
\{-n,}	matches at lease or more of the preceding characters...
\{-,m}	matches 1 or more of the preceding characters...
where n and m are positive integers (>0)


".\{-}" match: let's use \{-} in place of * in our pattern.
this file is normally "$VIM/gvimrc". You can check this with ":version".
                      #############

/"[^"]\+"/ or /"\S\+"/ match:
this file is normally "$VIM/.gvimrc". You can check this with ":version".    
                      ##############                          ##########


metacharacters ~

# 	Matching
.	any character except new line 	  	 
\s	whitespace character. so '\s*$' means a blank line 	
\S	non-whitespace character
\d	digit 	
\D	non-digit
\x	hex digit 	
\X	non-hex digit
\o	octal digit 	
\O	non-octal digit
\h	head of word character (a,b,c...z,A,B,C...Z and _) 	
\H	non-head of word character
\p	printable character 	
\P	like \p, but excluding digits
\w	word character 	
\W	non-word character
\a	alphabetic character 	
\A	non-alphabetic character
\l	lowercase character 	
\L	non-lowercase character
\u	uppercase character 	
\U	non-uppercase character

# from python
\w
    When the LOCALE and UNICODE flags are not specified, matches any alphanumeric character and the underscore; this is equivalent to the set [a-zA-Z0-9_]. With LOCALE, it will match the set [0-9_] plus whatever characters are defined as alphanumeric for the current locale. If UNICODE is set, this will match the characters [0-9_] plus whatever is classified as alphanumeric in the Unicode character properties database.

\W
    When the LOCALE and UNICODE flags are not specified, matches any non-alphanumeric character; this is equivalent to the set [^a-zA-Z0-9_]. With LOCALE, it will match any character not in the set [0-9_], and not defined as alphanumeric for the current locale. If UNICODE is set, this will match anything other than [0-9_] and characters marked as alphanumeric in the Unicode character properties database.

\b
    Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of alphanumeric or underscore characters, so the end of a word is indicated by whitespace or a non-alphanumeric, non-underscore character. Note that \b is defined as the boundary between \w and \W, so the precise set of characters deemed to be alphanumeric depends on the values of the UNICODE and LOCALE flags. Inside a character range, \b represents the backspace character, for compatibility with Python's string literals.


==============================================================================
*kt_dev_env_012*	regexp - grouping

two uses for parentheses: 
to limit the scope of alternation, |, and 
to group multiple characters into larger units to which you can apply quantiers like question mark and star.

and back referencing is the third

# to swap two words
:s/\(one\) \(two\)/\2 \1/g 


==============================================================================
*kt_dev_env_013*	regexp - alternation

Note. usable in egrep

Using "\|" you can combine several expressions into one which matches any of its components. The first one matched will be used.

\(Date:\|Subject:\|From:\)\(\s.*\)

will parse various mail headings and their contents into \1 and \2, respectively. The thing to remember about VIM alternation that it is {not greedy}. It won't search for the longest possible match, it will use the first that matched. That means that the order of the items in the alternation is important!

# for egrep. all have the same result.
#
gr[ae]y'
gray|grey'
gr(a|e)y'

As in arithmetic expressions, regular expressions are executed in a certain order of precedence. 
Here the table of precedence, from highest to lowest:


==============================================================================
*kt_dev_env_014*	regexp - precedence

Precedence Regexp Description
1 \( \)			# grouping
2 \=,\+,*,\{n} etc.	# quantifiers
3 abc\t\.\w 		# sequence of characters/metacharacters, not containing quantifiers or grouping operators
4 \| 			# alternation


==============================================================================
*kt_dev_env_015*	regexp - examples

/^$/ 		# you match empty lines
/^.*$/ 		# An entire line 
/ */		# One or more spaces 

# use a different separator
#
Tip 1: frequently you need to do S&R in a text which contains UNIX file paths - text strings with slashes ("/") inside. Because S&R command uses slashes for pattern/replacement separation you have to escape every slash in your pattern, i.e. use "\/" for every "/" in your pattern:

s/\/dir1\/dir2\/dir3\/file/dir4\/dir5\/file2/g

To avoid this so-called "backslashitis" you can use different separators in S&R (I prefer ":")

s:/dir1/dir2/dir3/file:/dir4/dir5/file2:g
s:\<vi\>:VIM:g

# delete trailing spaces
:%s:\s\+$:

# show trailing wss
/\s\+$

# show all tabs
/\t

#
input to match:

NDS: ^[00:30:37]0946686637.742067 !ERROR -SPM_COMMON   < p:000000c8 t:2bb79520 T:no name M:spm_common.c F:SPM_COMMON_waitOnCondition L:02194 > Condition wait timed out!

$ grep "\!ERROR .* SPM_COMMON_waitOnCondition" LOG
no match because the second space.

$ grep "\!ERROR.* SPM_COMMON_waitOnCondition" LOG  
no match as before.

$ grep "\!ERROR.*SPM_COMMON_waitOnCondition" LOG  
match.

# 12 hours
12 ?? ?? ?? 9:17 am or 12:30 pm

9:45 pm
13:21 pm
9:45 am
23:31 pm
33323:31 pm
1:11 am

# this mathes all!
egrep '(1[012]|[0-9]):[0-5][0-9] am|pm' x  


==============================================================================
*kt_dev_env_vim_024*	prog:undo

See :help new-undo-branches on a Vim 7 editor.  Vim supports undo branches. This means Vim can keep
track of the different changes you made to your text (or your code). In its simplest form, you can
use two commands, :earlier and :later to bring your code to a previous state. E.g:

:earlier 20s
:later 5m
:earlier 2h

The commands above bring the code to the state it was 20 seconds earlier, 5 minutes later and 2
hours later.  This is useful when making changes to code under no source control systems. Undo
branches is a new feature present in Vim since version 7. I recommend you to play with it and learn
how to get the maximum out of it.

The |:undolist| command can be used to get an idea of which undo branches
exist.  The |:undo| command now takes an argument to directly jump to a
specific position in this list.  The |changenr()| function can be used to
obtain the change number.


==============================================================================
*kt_dev_env_vim_300*	script

Vim documentation: usr_41

:let i = 1
	:while i < 5
	:  echo "count is" i
	:  let i += 1
	:endwhile
 
Note:
The ":" characters are not really needed here.  You only need to use them when you type a command.
In a Vim script file they can be left out.  We will use them here anyway to make clear these are
colon commands and make them stand out from Normal mode commands.

Note:
You can try out the examples by yanking the lines from the text here and executing them with :@"


{vim-variable}

These variables are global. To see a list of currently defined variables use this command:

	:let

You can use global variables everywhere. This also means that when the variable "count" is used in
one script file, it might also be used in another file. This leads to confusion at least, and real
problems at worst.

To avoid this, you can use a variable local to a script file by prepending "s:". For example, one
script contains this code:


{vim-list}

List creation *E696* *E697*

A List is created with a comma separated list of items in square brackets.

Examples:
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

An item can be any expression. Using a List for an item creates a List of Lists: :let nestlist =
[[11, 12], [21, 22], [31, 32]]

An extra comma after the last item is ignored.

List manipulation:					*list-functions*

	count()			count number of times a value appears in a List

count({comp}, {expr} [, {ic} [, {start}]])			*count()*

		Return the number of times an item with value {expr} appears in |List| or |Dictionary| {comp}.
		If {start} is given then start with the item with this index.  {start} can only be used with a
		|List|.  When {ic} is given and it's non-zero then case is ignored.

let s:settings.plugin_groups = []
call add(s:settings.plugin_groups, 'core')
call add(s:settings.plugin_groups, 'web')
call add(s:settings.plugin_groups, 'javascript')

if count(s:settings.plugin_groups, 'core') "{{{
...
endif

{vim-function}

To redefine a function that already exists, use the ! for the ":function" command:

	:function!  Min(num1, num2, num3)


==============================================================================
*kt_dev_env_vim_024*	 ^M char

When open some file made by win apps such as putty, vim shows ^M at the end of line. Often people
explains that this happens when see windows file under linux because there is no CR(0xOD) in linux
and vim display it as ^M. So to remove this :%s/^V^M//g 

note: to enter ^M, press crtl-m.

This is not the case when seeing file putty made. Although putty log file has CR and LF, vim under
windows shows ^M. When checked filetype, vims uses fileformat=unix and that is why it displays ^M.
When copy this text to other vim windows in dos filetype, still show ^M because it has CR+CR+LR in
the end.

See vim help fileformat. Where is the fileformat when vim is loading file? 

http://vim.wikia.com/wiki/File_format


{when-use-diff}

If diff two files which are nearly the same, diff shows it's totally different. But used comp tool
and showed the expected result. why? 

The reason was the one is unix and the other was dos format. In vim, when tried to show tabs, do not
show difference and can see fileformat using :set ff.

Also diff -w shows the correct. also cat -v filename shows ^M char. Under ubunto, can get tool like
unix2dos:

sudo apt-get install tofrodos

which proves fromdos and todos


==============================================================================
*kt_dev_env_vim_032*	 change working dirs



==============================================================================
*kt_dev_env_vim_033*	tool: ag bin and ag vim plugin

https://github.com/ggreer/the_silver_searcher

To get a source of ag bin:

$ git clone https://github.com/ggreer/the_silver_searcher

{ag-ignore}

By default, ag will ignore files matched by patterns in .gitignore, .hgignore, or .agignore. These
files can be anywhere in the directories being searched. Ag also ignores files matched by the
svn:ignore property in subversion repositories. Finally, ag looks in $HOME/.agignore for ignore
patterns. Binary files are ignored by default as well.

If you want to ignore .gitignore, .hgignore, and svn:ignore but still take .agignore into account,
use -U.  Use the -t option to search all text files, -a to search all files, and -u to search all
including hidden files.


# ============================================================================
#{
={============================================================================
*kt_dev_env_git_000* reference

{help}
https://www.kernel.org/pub/software/scm/git/docs/git.html


{book}
"Git from the bottom up":
http://ftp.newartisans.com/pub/git.from.bottom.up.pdf

http://git-scm.com/book


{gui-client}
<qgit>
sudo apt-get install qgit

Had highlight on a current branch. show whole tree when select option to start.

<gitg>


={============================================================================
*kt_dev_env_git_001* install

{install}
git clone https://github.com/git/git

apt-get install autoconf
make configure
./configure 
make

apt-get install asciidoc

# as root
sudo make install install-doc install-html

# when see "fatal: Unable to find remote helper for 'https'" install curl and
# rebuild git. 
sudo apt-get install libcurl4-openssl-dev


={============================================================================
*kt_dev_env_git_002* config, alias and help

{git-config}
The first thing you should do when you install Git is to set your user name and e-mail address. This
is important because every Git commit uses this information, and it's immutably baked into the
commits you pass around:

git config --global user.name "Kit Park"
git config --global user.email tegipark@gmail.com

git config --list

# for color output
git config --global color.ui auto

$ git config -l
user.name=Kit Park
user.email=tegipark@gmail.com
color.ui=auto
merge.tool=meld
push.default=simple
core.excludesfile=/home/kit/.gitignore
core.repositoryformatversion=0
core.filemode=true
core.bare=false
core.logallrefupdates=true


{git-help}
git help ???
man git-???


{git-alias}
This means that, for example, instead of typing git commit, you just need to type git ci.

$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status

To run an external command,
$ git config --global alias.visual '!gitk'

$ cat .gitconfig
...
[alias]
	co = checkout
	ci = commit
	st = status
	br = branch
	l = log -1 HEAD
	ll = log --oneline --decorate --graph


{config-structure}

$ more .git/config
...
[zb]
	build-dir = /data/builds
	default-config = pc
	build-type = debug
	one-time-setup = true
[zb "pc"]
	build-type = debug
	host-config = host

$ git config --list
...
zb.build-dir=/data/builds
zb.default-config=pc
zb.build-type=debug
zb.one-time-setup=true
zb.pc.build-type=debug
zb.pc.host-config=host

$ git config zb.huawei.370.deploy-host huawei 
$ git config zb.huawei.370.deploy-host 172.20.33.192

$ git config --bool zb.one-time-setup
true


={============================================================================
*kt_dev_env_git_003* terminology

{difference-to-other-vcs} {snapshot}
These systems (CVS, Subversion, Perforce, Bazaar, and so on) think of the information they keep as a
set of files and the changes made to each file over time, as illustrated in Figure 1-4. 

-------------- checkins over time --------------->
version 1   version 2   version 3   version 4    version 5
file A      delta 1                 delta 2
file B                              delta 1      delta 2

Instead, Git thinks of its data more like a set of snapshots of a mini 'filesystem'. It is called
'snapshot'.


{nearly-every-operation-is-local}
This also means that there is very little you can't do if you're offline or off VPN. In Perforce,
for example, you can't do much when you aren't connected to the server; and in Subversion and CVS,
you can edit files, but you can't commit changes to your database (because your database is
offline). This may not seem like a huge deal, but you may be surprised what a big difference it
can make.


{integrity}
Everything in Git is check-summed. The mechanism that Git uses for this checksumming is called a
SHA-1 hash. 


{three-states} {committed-modified-staged}
Three main states that your files can reside in: committed, modified, and staged. Committed means
that the data is safely stored in your 'local' database. Modified means that you have changed the file
but have not committed it to your database yet. Staged means that you have marked a modified file in
its current version to go into your next commit snapshot.


{tracked-untracked}
Remember that each file in your working directory can be in one of two states: tracked or untracked.
Tracked files are files that were in the last snapshot; they can be unmodified, modified, or staged.
Untracked files are everything else 


{terminology}

   working directory(snapshot)             staging area          git direcotry(repository)
untracked  unmodified  modified
            <-------------------------------------------------------------
                           clone(checkout) the project

     <--------->
      add/remove
               ------------>
               edit
                   ----------------------->
                   stage files(checkin)
                                                ----------------------->
                                                commit
                                                (make files unmodified)

The Git 'directory', 'repository' is where Git stores the metadata and object database for your
project. This is the most important part of Git, and it is what is copied when you clone a
repository from another computer.

The "working directory" is a single checkout of one version of the project. These files are pulled
out of the compressed database in the Git directory and placed on disk for you to use or modify.
This is 'snapshot' or blob.

The "staging area", or 'index' is a simple file, generally contained in your Git directory, that
stores information about what will go into your next commit. It's becoming standard to refer to it
as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working directory.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot
permanently to your Git directory.

If a particular version of a file is in the git directory, it's considered committed. If it's
modified but has been added to the staging area, it is staged. And if it was changed since it was
checked out but has not been staged, it is modified. 


={============================================================================
*kt_dev_env_git_004* init, clone

{init-repo-in-existing-dirs}
Create an empty repository.

$ git init
Initialized empty Git repository in /home/kit/.git/

if it's a directory, the command adds all the files in that directory recursively.

$ git add *.c or $ git add *
$ git add README
$ git commit -m 'initial project version'


{clone-from-existing-repo}
The command is clone and not checkout. This is an important distinction - Git receives a copy of
nearly all data that the server has. Every version of every file for the history of the project is
pulled down when you run git clone. In fact, if your server disk gets corrupted, you can use any of
the clones on any client to set the server back to the state it was in when it was cloned

$ git clone git://github.com/schacon/grit.git

That creates a directory named grit, initializes a .git directory inside it, pulls down all the data
for that repository, and checks out a working copy of the latest version. 

If you want to clone the repository into a directory named something other than grit, you can
specify that as the next command-line option:

$ git clone git://github.com/schacon/grit.git mygrit


<clone-from-ssh> github
Why is Git always asking for my password?

If git prompts you for a username and password instead of your SSH key passphrase, you're using the
HTTPS clone URL for your repository.  

Why not use HTTPS?

HTTPS has some advantages, it's easier to set up than SSH and usually works through strict firewalls
and proxies. You can even set git to store your password so you don't have to enter it every time.
If you'd like to set that up, make sure you've upgraded to the latest version of git and check out
this guide.  

<to-set-git-protocol>
To change the URL via the command line:

git remote set-url origin git@github.com:/keitee/kb

note: this don't ask password when registered ssh key.


<clone-from-local-server>
Git has a number of different transfer protocols you can use. The previous example uses the git://
protocol, but you may also see http(s):// or user@server:/path.git, which uses the SSH transfer
protocol. Chapter 4 will introduce all of the available options the server can set up to access
your Git repository and the pros and cons of each.

For example, clone it from local rockford server:

git clone keitee.park@rockford:/home/keitee.park/mheg-proto my

note: my can be anyname and if omits, then use the parent dir name of remote git repository.


={============================================================================
*kt_dev_env_git_005* status

{status}
The command tells you which branch you're on. For now, that is always master, which is the default; 

$ git status
# On branch master
nothing to commit (working directory clean)


{when-modified-to-stage}
$ git status
# On branch master                  " note: see branch you are on
# Changes not staged for commit: ~
#   (use "git add <file>..." to update what will be committed)
#
#   modified:   benchmarks.rb
#

means that a file that is tracked has been modified in the working directory but not yet staged. To
stage it, you run the git add command (it's a multipurpose command - you use it to begin tracking
new files, to stage files, and to do other things like marking merge-conflicted files as resolved). 

When run add command to stage, it move to as

# On branch master
# Changes to be committed:  ~          " note see 'to be'
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   MHEGApp.cpp

Modified the same file and run status command again. Then

# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   work/Src/MHEGApp.cpp
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
# modified:   work/Src/MHEGApp.cpp


{short}
-s, --short
Give the output in the short-format.


={============================================================================
*kt_dev_env_git_006* ignore

{git-ignore}
Looks that git use patch from where run init command and show untracked files or dirs from there. It
is annoying when run status command. To list out what you don not want to see, can set this in this
file:

$ cat .gitignore 
cpp/
Downloads/
.*


The rules for the patterns you can put in the .gitignore file are as follows:

Blank lines or lines starting with # are ignored.
Standard glob patterns work.
You can end patterns with a forward slash (/) to specify a directory.
You can negate a pattern by starting it with an exclamation point (!).

# ignore all files in the build/ directory
build/


{ignore-order}
Git normally checks gitignore patterns from multiple sources, with the following order of
precedence, from highest to lowest (within one level of precedence, the last matching pattern
    decides the outcome):

Patterns read from the command line for those commands that support them.

Patterns read from a .gitignore file in the same directory as the path, or in any parent directory,
         with patterns in the higher level files (up to the toplevel of the work tree) being
         overridden by those in lower level files down to the directory containing the file. These
         patterns match relative to the location of the .gitignore file. A project normally includes
         such .gitignore files in its repository, containing patterns for files generated as part of
         the project build.

Patterns read from $GIT_DIR/info/exclude.

Patterns read from the file specified by the configuration variable core.excludesfile.

git config --global core.excludesfile '/home/kit/.gitignore'

Which file to place a pattern in depends on how the pattern is meant to be used.

Patterns which should be version-controlled and distributed to other repositories via clone (i.e.,
    files that all developers will want to ignore) should go into a .gitignore file.

Patterns which are specific to a particular repository but which do not need to be shared with other
related repositories (e.g., auxiliary files that live inside the repository but are specific to one
    user's workflow) should go into the $GIT_DIR/info/exclude file.

Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files
    generated by the user's editor of choice) generally go into a file specified by
core.excludesfile in the user's ~/.gitconfig. Its default value is $XDG_CONFIG_HOME/git/ignore.  If
$XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead.


http://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
GIT_DIR is the location of the .git folder. If this isn't specified, Git walks up the directory tree
until it gets to ~ or /, looking for a .git directory at every step.


={============================================================================
*kt_dev_env_git_007* git-log

{log}
git log [<options>] [<revision range>] [[\--] <path>...]

With no arguments, git log lists the commits made in that repository in reverse
chronological order. This is from the most recent commits.

<revision range>
Show only commits in the specified revision range. When 'no' <revision range>
is specified, it 'defaults' to HEAD (i.e. the whole history leading to the
        current commit). origin..HEAD specifies all the commits reachable from
the current commit (i.e. HEAD), but not from origin. For a complete list of
ways to spell <revision range>, see the Specifying Ranges section of
gitrevisions[7].

note: means that works on current branch.


<patch-format-and-specify-limit>
You can also use -2, which limits the output to only the last two entries. note:
last two means the latest two commits.

$ git log -2
$ git log -p -2

<stat> 'useful'
--stat option prints below each commit entry a list of modified files, how many
files were changed, and how many lines in those files were added and removed. It
also puts a summary of the information at the end.

$ git log --stat
commit 4092efb248db69311cc6efd65985818a2150c688
Author: kit <tegipark@gmail.com>
Date:   Fri Feb 6 00:50:05 2015 +0000

    2015.02.06 fh

 kt_dev_01.txt |  148 ++++++++-------------------------------------------------
 temp.txt      |  144 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 160 insertions(+), 132 deletions(-)

commit fa2cb0ad40dcc108dfdacdcedf7adc4bc3bfce3b
Author: Kit Park <kit.park@youview.com>
Date:   Thu Feb 5 17:15:32 2015 +0000

    2015.02.05 fo
...

<pretty>
$ git log --pretty=oneline

$ git log --pretty=format:"%h - %an, %ar : %s" --graph
$ git log --pretty=format:"%h - %an, %ar : %s" 
4092efb - kit, 2 days ago : 2015.02.06 fh
fa2cb0a - Kit Park, 2 days ago : 2015.02.05 fo
...

<graph>
Shows the same as qgit

// --oneline
//    This is a shorthand for "--pretty=oneline --abbrev-commit" used together.
//
// --all
//    Pretend as if all the refs in refs/ are listed on the command line as
//    <commit>.

git log --graph --oneline --all
git log --oneline --all

<decorate>
To see where the branch pointers are pointing:
$ git log --oneline --decorate


note: can use git-alias and see git-alias for more

alias.last=log -1 HEAD
alias.ll=log --oneline --decorate --graph


{example}
If you want to see which commits modifying test files in the Git source code
history were committed by Junio Hamano and were not merges in the month of
October 2008, you can run something like this: "t/" is directory

$ git log --pretty="%h - %s" --author=gitster --since="2008-10-01" \
--before="2008-11-01" --no-merges -- t/


{git-log-grep}
Search a pattern in commit 'messages' which is different from git-grep since
git-grep search through commit 'contents' but not message.

$ git log --grep PATTERN

Shows a diff as well.

// -p
// -u
// --patch
//    Generate patch (see section on generating patches).

$ git log -p --grep PATTERN


{git-log-search-commits} 'useful' to locate related commit

<use-file-or-directory>
The last really useful option to pass to git log as a filter is a path. If you
specify a 'directory' or 'file', you can limit the log output to commits that
introduced a change to those files. This is always the last option and is
generally preceded by double dashes (--) to separate the paths from the options.

$ git log -- Polonium/Polonium.GSTNexus

<use-string> 

note: some says it is to search function

Another really helpful filter is the -S option which takes a string and only
shows the commits that introduced a change to the code that added or removed
that string. For instance, if you wanted to find the last commit that added or
removed a reference to a specific function, you could call:

$ git log -S function_name

// -S<string>
// 
//     Look for differences that change the number of occurrences of the
//     specified string (i.e. addition/deletion) in a file. Intended for the
//     scripters use.
// 
//     It is useful when youre looking for an exact block of code (like a
//     struct), and want to know the history of that block since it first came
//     into being: use the feature iteratively to feed the interesting block in
//     the preimage back into -S, and keep going until you get the very first
//     version of the block.


note: how differ with git-grep

$ git grep pes_stream_get_duration
src/concurrent_pes_writer.c:    chunk->duration = pes_stream_get_duration(data);
src/pes.c:GstClockTime pes_stream_get_duration(PesStream *stream)
src/pes.h:GstClockTime pes_stream_get_duration(PesStream* stream);

$ git log -S pes_stream_get_duration
commit 23b5d6607917a3fb8613cf31f37b234767b9c3e0
Author: xxx 
Date:   Tue Apr 21 10:36:25 2015 +0100

    Even though STB hardware supports several playpumps (see DEVARCH-8872),
    OEMs only make one playpump available to YouView. If we write each
    elementary stream into its own playpump, by the time we need to support
    audio description with DASH playback, we would need a total of 3
    playpumps. Therefore we implemented software-based multiplexing of
    multiple elementary streams to a single playpump.
    
    This commit introduces such multiplexing mechanism. Note that transport
    streams (including HLS) will still use the old code path.

$ git log -p -S pes_stream_get_duration

<use-author>
--author option allows you to filter on a specific author

git log --author='Kit Park'
git ll --author='Kit Park'
git log -p --author='Kit Park'

<use-time>
The time-limiting options such as --since and --until are very useful. 

$ git log --since=2.weeks


<author-and-commit-date>
The git log shows the author date but not the date when the commit was made.

commit 2005aa038a516d963023e4a572ec0d0d63045142
Author: Darren Garvey <darren.garvey@youview.com>
Date:   Mon Feb 16 13:03:18 2015 +0000

Use --pretty option to see all.

git log --pretty=fuller Polonium/Polonium.GSTNexus/src/gstnexussink.c

--pretty[=<format>]
--format=<format>

    Pretty-print the contents of the commit logs in a given format, where
    <format> can be one of oneline, short, medium, full, fuller, email, raw,
    format:<string> and tformat:<string>. When <format> is none of the above,
    and has %placeholder in it, it acts as if --pretty=tformat:<format> were
    given.

    See the "PRETTY FORMATS" section for some additional details for each
    format. When =<format> part is omitted, it defaults to medium.

    Note: you can specify the default pretty format in the repository
    configuration (see git-config[1]).

commit 2005aa038a516d963023e4a572ec0d0d63045142
Author:     Darren Garvey <darren.garvey@youview.com>
AuthorDate: Mon Feb 16 13:03:18 2015 +0000
Commit:     Darren Garvey <darren.garvey@youview.com>
CommitDate: Wed Sep 9 19:42:30 2015 +0100


={============================================================================
*kt_dev_env_git_008* unstage and discard changes

From 2.4 Git Basics - Undoing Things

{unstaging}
For example, let's say you've changed two files and want to commit them as two separate changes, but
you accidentally type git add * and stage them both. How can you unstage one of the two? The git
status command reminds you:

$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.txt
#       modified:   benchmarks.rb
#

it says "use git reset HEAD <file>... to unstage". So, let's use that advice to unstage the
benchmarks.rb file:

$ git reset HEAD benchmarks.rb
benchmarks.rb: locally modified

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       modified:   README.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#       modified:   benchmarks.rb
#

note: the reset command simply remove the staged changes. For example, suppose that a file staged
already and changes it after. what would happen when 'unstage' it? would you lost the changes made
after staged? NO. The working copy remains the same but the staged is gone.


{discard-changes}
$ git checkout -- <filename>


={============================================================================
*kt_dev_env_git_009* auto completion

{auto-completion}
For commands and options.

$ git co<tab><tab>


={============================================================================
*kt_dev_env_git_010* git-branch:  

{branch-is-special}
Why is it so special? The way Git branches is incredibly lightweight, making
branching operations nearly instantaneous and switching back and forth between
branches generally just as fast. 

As you may remember from Chapter 1, Git doesn't store data as a series of
changesets or deltas, but instead as a series of snapshots.


{difference-to-other-vcs}

--------------------- time ----------------------------------------->

commit A      <------   commit B                  <-------   commit C
 (ptr to snapshot)       (ptr to the prev commit)
                         (ptr to snapshot)

 (snapshot A)            (snapshot B)                         (snapshot C)


{default-branch} master-branch
A branch in Git is simply a lightweight movable 'pointer' to one of these
commits. The default branch name in Git is 'master'. As you initially make
commits, you're given a master branch that points to the last commit you made.
Every time you commit, it moves forward automatically.

                                                  <master>
commit a      <------   commit b       <-------   commit c


{create-new-branch}
What happens if you create a new branch? Well, doing so creates a new pointer
for you to move around.

$ git branch testing
                                                   <HEAD>
                                                  <master>
commit a      <------   commit b       <-------   commit c
                                                  <testing>

To see where the branch pointers are pointing:

$ git log --oneline --decorate


{branch-and-head}
We will sometimes represent Git history using diagrams like the one below.
Commits are shown as "o", and the links between them with lines drawn with - /
and \. Time goes left to right:

         o--o--o <-- Branch A
        /
 o--o--o <-- master
        \
         o--o--o <-- Branch B

If we need to talk about a particular commit, the character "o" may be
replaced with another letter or number.

When we need to be precise, we will use the word 'branch' to mean a line of
development, and "branch head" (or just 'head') to mean a reference to the
most 'recent' commit on a branch. In the example above, the branch head named
"A" is a pointer to one particular commit, but we refer to the line of three
commits leading up to that point as all being part of "branch A".

The head means the current branch or what is currently checked out. However,
    when no confusion will result, we often just use the term "branch" both
    for branches and for branch heads. A branch is nothing more than a named
    reference to a commit.

How does Git know what branch you're currently on? It keeps a special pointer
called 'HEAD'. Cannot have the same branch name in the same repository.


{switch-branch} checkout
To switch to an existing branch, you run the git checkout command. This moves
HEAD to point to the testing branch.

$ git checkout testing

To 'make' a branch and to 'switch' to it in a single shot.

$ git checkout -b testing

                                                  <master>
commit a      <------   commit b       <-------   commit c
                                                  <testing>
                                                   <head>

Make a commit and see what happens:

                                                  <master>
commit a      <------   commit b       <-------   commit c    <------  commit d
                                                                       <testing>
                                                                        <head>
Switch back to master:

$ git checkout master

                                                   <head>
                                                  <master>
commit a      <------   commit b       <-------   commit c    <------  commit d
                                                                       <testing>

Two things done by doing this, essentially rewinds the your work:
1. move the head back to point to master
2. revert your working dirs back to the snapshot that master 'points' to

note: switching head, branch, commit means changing working dirs.

Make a commit and see what happens:
                                                                       <head>
                                                                       <master>
commit a      <------   commit b       <-------   commit c    <------  commit e
                                                              <------  commit d
                                                                       <testing>

Now your project history has diverged. two lines of development 


{errors-when-switch-branches} error when checkout
To prepare for working on <branch>, switch to it by updating the index and the
files in the working tree, and by pointing HEAD at the branch. Local
modifications to the files in the working tree are kept, so that they can be
committed to the <branch>.

When switching beteen branches 'without' staging and committing, git emits
errors:

$ git checkout undo 
error: Your local changes to the following files would be overwritten by checkout:
	readme
Please, commit your changes or stash them before you can switch branches.
Aborting

Why? because the tracked file is modified and will be overwitten and lost what
has been done if not commited.

note: untracked file 'remains' and the index and working tree will be updated.
so should commit if want to keep changes. If that file exist only for a
certain branch, this will disapper in switching to.

-f
--force
When switching branches, proceed even if the index or the working tree differs
from HEAD. This is used to throw away local changes.

When checking out paths from the index, do not fail upon unmerged entries;
instead, unmerged entries are ignored.


{branch-is-cheap}
Because a branch in Git is in actuality a simple file that contains the 40
character SHA-1 checksum of the commit it points to, branches are cheap to
create and destroy. Creating a new branch is as quick and simple as writing 41
bytes to a file (40 characters and a newline).


{brancn-vs-tag}
A tag represents a version of a particular branch at a moment in time. A
branch represents a separate thread of development that may run concurrently
with other development efforts on the same code base. Changes to a branch may
eventually be merged back into another branch to unify them.

The tag is very much like a branch that doesn't change - it's just a pointer
to a specific commit. 


={============================================================================
*kt_dev_env_git_011* git-branch: rename, delete

{branch-rename}
git branch -m newname            " when want to rename current branch you are on
git branch -m oldname newname    


{branch-delete}
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).

<remote>
You can delete a remote branch using the --delete option to git push. If you
want to delete your serverfix branch from the 'server', you run the following:

$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
- [deleted] serverfix

Basically all this does is remove the pointer from the server. The Git server
will generally keep the data there for a while until a garbage collection
runs, so if it was accidentally deleted, it's often easy to recover.

$ git branch -a
  remotes/origin/propose/huawei

$ git push origin --delete propose/huawei


={============================================================================
*kt_dev_env_git_012* git-branch: list

{branch-list}
To list branches and * indicates that you currently have checked out. i.e.,
   the branch that HEAD points to.

$ git branch
  iss53
* master
  testing

<check-commit>
To see the 'last' commit on each branch

$ git branch -v --color
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes

<check-merge>
To figure out what state your branches are in is to filter this list to
branches that you have or have not yet merged <into> the branch you're
currently on. --merged and --no-merged options

With --merged, only branches merged into the named commit (i.e. the branches
        whose tip commits are reachable from the named commit) will be listed.

With --no-merged only branches not merged into the named commit will be
listed. If the <commit> argument is missing it defaults to HEAD (i.e. the tip
        of the current branch).

$ git branch --merged
  iss53
* master

Branches on this list 'without' the * in front of them are generally fine to
delete because you've 'already' incorporated their work into another branch


$ git branch --no-merged
  testing

This shows your other branch. Because it contains work that isn't merged in
yet, trying to delete it with git branch -d will fail:

$ git branch -d testing
error: The branch 'testing' is not an ancestor of your current HEAD.
If you are sure you want to delete it, run 'git branch -D testing'.


{branch-remote}

-a
--all
    Show both remote-tracking branches and local branches.

-r
--remotes
    Show the remote-tracking branches.

git branch -a 


={============================================================================
*kt_dev_env_git_013* git-branch: checkout and tracking

<checkout-with-making-local-branch>
git co review/DEVARCH-8704/0

Branch xxx set up to track remote branch xxx from origin.
Switched to a new branch 'xxx'

This will make a local "review/DEVARCH-8704/0" from remote, set up a tracking
branch, and switch to it.


<checkout-without-making-local-branch>

git co origin/review/DEVARCH-8704/0

note: see "origin" which is different from the above

This will checkout to this and make a 'detached' head state. No local branch
made. So can see the changes without making a branch and deleing it once used.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

git checkout -b new_branch_name

HEAD is now at 61b6bd8... DEVARCH-9355: Add yv-wait-for-idle helper tool


{tracking-branch}
Checking out a local branch from a remote branch automatically creates what is
called a tracking branch or 'upstream' branch. If you're on a tracking branch
and type git push/pull, Git automatically knows which server and branch to
push to.

So tracking branch is not special and is a simple branch points to one in
remote.

When you clone a repository, it generally automatically creates a
remote-master-branch that tracks origin/master. origin/master is remote
master. 

note: The point is that shall be a local branch to track remote branch. Hence
tracking branch.


<basing-off>
The simple case is the example you just saw, running git

git checkout -b [branch] [remotename]/[branch]. 

note: This is called "basing off"; starts a new feature branch, basing it off
the server's branch.

If you have Git version 1.6.2 or later, you can also use the --track
shorthand:

git checkout --track origin/serverfix

note: --track option is 'limited' since not able to choose local branch name
to track remote.

As with example before, branch serverfix set up to track remote branch
refs/remotes/origin/serverfix and switched to a new branch "serverfix"


# {set-upstream}
# The --set-upstream is out of date.
# 
# git branch --set-upstream-to origin/my_branch
# git branch -u origin/my_branch                     // for short


<ex>
You can download a remote branch using "git checkout". Download a remote
branch(tztv_2.2) and create a local branch(tztv_2.2_local) with the
contents(commits).

$ git checkout -b tztv_2.2_local origin/tztv_2.2

Branch tztv_2.2_local set up to track remote branch tztv_2.2 from origin.
Switched to a new branch 'tztv_2.2_local'

With this command the local branch "tztv_2.2_local" is set to track the remote
branch "tztv_2.2"

You can also try without "-b" option like. This mean if git cannot find a
branch in local but find one in remote, it will create one to track the
remote?

$ git checkout tztv_2.2

Branch tztv_2.2 set up to track remote branch tztv_2.2 from origin. Switched
to a new branch 'tztv_2.2'


{check-tracking-in-config}
Can see tracking details in git config.

$ cat .git/config
[core]
repositoryformatversion = 0
filemode = true
bare = false
logallrefupdates = true
[remote "origin"]
fetch = +refs/heads/*:refs/remotes/origin/*
url = ssh://jongwoo.chae@168.219.241.167:29418/training1
[branch "master"]
remote = origin
merge = refs/heads/master
[branch "tztv_2.2_local"]
remote = origin
merge = refs/heads/tztv_2.2


={============================================================================
*kt_dev_env_git_014* git-branch: merge or rebase

{branch-workflow}
Because Git uses a simple three-way merge, merging from one branch into
another multiple times over a long period is generally easy to do. 

master          - possibly only code that has been or will be released. 
develop or next - parellel branch. they work from or use to test stability.
topic           - short-lived. to make sure they pass all the tests and don't
                  introduce bugs.

Easier to think about them as work silos, where sets of commits graduate to a
more stable silo when they're fully tested 


high stable: -> time
 master c1 --------------------------------------------------------->

 develop     c2 c3 c4 c5 ------------------------------------------->

 topic                    c6 c7 ------------------------------------>

low stable

The merging is from topic -> develop -> master.

You can keep doing this for several levels of stability. For large projects.

<topic-branch>
Topic branches, however, are useful in projects of any size. A topic branch is
a short-lived branch that you create and use for a single particular feature
or related work. This is something you've likely never done with a VCS before
because it's generally too expensive to create and merge branches. 

This technique allows you to context-switch quickly and completely.

note: 
not mean to use topic. can use any branch but think that use maniny develop or
topic level. Hence named after topic?


note:
It's important to remember when you're doing all this that these branches are
completely local. When you're branching and merging, everything is being done
only in your local repository. NO server communication is happening.


={============================================================================
*kt_dev_env_git_011* merge workflow

{merge-with-no-diverge} <upstrem>
The workflow is that make a hotfix to fix a issue and once verify it, them merge it into the master.

           <master>      <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
                        <iss53> branch

Switch to master and merge hotfix to master:

$ git checkout master
$ git merge hotfix              # support auto-completion for branch name
Updating f42c576..3a0874c
Fast forward
 README |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)


The phrase "Fast forward" in that merge. Because the commit pointed to by the branch(hotfix) you
merged in was directly 'upstream' of the commit(master) you're on, Git 'moves' the pointer forward.
<no-diverge>. 

note: This means that simply apply changes up to hotfix and move master to where hotfix was. Just
overwrite with what hotfix has. 'no' conflict and 'no' commit is created. <Q> applying and
overwriting happens really?


note: merge "hotfix" into the current branch that you are on and is master in this example.

So tree becomes:
                        <master>
                        <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
                        <iss53> branch

To switch back to the work you were doing before you were interrupted. However, first you'll delete
the hotfix branch, because you no longer need it - the master branch points at the same place. You
can delete it with the -d option to git branch:


{merge-with-diverge}
Switch back to your work-in-progress branch on issue #53 and continue working on it 

$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'

                         <master>
c0 <- c1 <- c2        <- c4
                      <- c3 <- c5
                              <iss53> branch
                              <head>

note: merge can be done in any direction.
It's worth noting here that the work you did in your hotfix branch is not contained in the files in
your iss53 branch. If you need to pull it in, you can merge your master branch into your iss53
branch by running git merge master, or you can wait to integrate those changes until you decide to
pull the iss53 branch back into master later.

<merge-into-master>
Suppose you've decided that your issue #53 work is complete and ready to be merged 'into' your master
branch. To merge in iss53 into master

$ git checkout master
$ git merge iss53
Merge made by recursive.
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

This looks a bit different than the hotfix merge because your development history has diverged from
some older point. 'diverged' Because the commit on the branch you're on(master) isn't a 'direct'
ancestor of the branch you're merging in(iss53). Git do simple <three-way-merge> using c2, c4, and
c5.

            # common   # snapshot to merge into
            # ancestor <head>
                       <master>
c0 <- c1 <- [c2]      <- [c4]
                      <- c3 <- [c5]
                               <iss53> branch
                               # snapshot to merge in

<merge-commit>
Git creates a new snapshot that results from this three-way merge and automatically creates a 'new'
commit that points to it. This is referred to as a 'merge' commit and is special in that it has more
than one parent. 

note: this is different from 'fast-forward' move that create no commit.

Git determines the best 'common' ancestor to use for its merge base; this is different than CVS or
Subversion (before version 1.5), where the developer doing the merge has to figure out the best
merge base for themselves. 

                                                <master>
c0 <- c1 <- c2        <- c4                     <- c6
                      <- c3 <- c5                |
                              <iss53> branch    <-

c6 has two ancestor.

$ git branch -d iss53

note: This assumes that there is no conflict between hotfix and iss53 branch.


{merge-conflict}
If you changed "the same part of the same file" differently in the two branches you're merging
together, Git won't be able to merge them cleanly. If your fix for issue #53 modified the same part
of a file as the hotfix, you'll get a merge conflict that looks something like this:

                        <master>
                        <hotfix> branch
c0 <- c1 <- c2        <- c4
                      <- c3
                        <iss53> branch

$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

Git has paused the process while you resolve the conflict. If you want to see which files are
unmerged at any point after a merge conflict, you can run git status:

$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

	both modified:   readme

no changes added to commit (use "git add" and/or "git commit -a")
$

<see-merge-conflict>
Git adds standard conflict-resolution markers to the files that have conflicts, so you can 'open'
them manually and resolve those conflicts. The conflicted file contains section like:

note: this is version on master since HEAD and is on master

<div id="footer">contact : email.support@github.com</div>
=======                                                        # }
<div id="footer">                                              # { iss53 version
  please contact us at support@github.com
</div>
>>>>>>> iss53:index.html                                       # }

In order to resolve the conflict, you have to either choose one side or the other or merge the
contents yourself. After you've resolved each of these sections in each conflicted file, run git add
on each file to mark it as resolved. "Staging the file" marks it as resolved in Git.  

<use-mergetool>
Instead of editing manually, can use GUI by running mergetool.

$ git mergetool

Then will run external merge tool with 'three' panes.

Local: HEAD version     Base: common base version  Remote: merge-in version.

So can select either head version or merge-in version. Or can write up new one. The mergetool runs
'mordal' mode and when close it, stage it automatically unlike the merge case.

<finish-merge>
Once resolved conflicts, run git status again to verify that all conflicts have been resolved. Run
git commit to 'finalize' the merge commit. Can modify that message with details about how you resolved
the merge 

<config-mergetool>
To set GUI tool to reslove merge conflict.

$ git config --global merge.tool gvimdiff

<as-a-git-merge-tool>
https://github.com/whiteinge/dotfiles/blob/master/bin/diffconflicts

#!/bin/bash
# A better vimdiff mergetool for Git
#
# Git does a great job resolving merge conflicts automatically but there are
# times when human intervention is still needed. Git resolves all the conflicts
# that it is able to and finally wraps each conflict it cannot resolve within
# special markers which must be resolved by a human.
#
# The vertical format and lack of syntax highlighting in the plain conflict
# marker layout makes it difficult to spot subtle conflicts such as
# single-character changes and this is where a two-way diff really shines!
# To see this explained using screenshots, see:
# http://vim.wikia.com/wiki/A_better_Vimdiff_Git_mergetool
#
# This script, when used as a Git mergetool, opens each "side" of the conflict
# markers in a two-way vimdiff window. This combines all the awesome of Git's
# automatic merging savvy with the awesome and simplicity of a simple two-way
# diff.
#
# Add this mergetool to your ~/.gitconfig (you can substitute gvim for vim):
#
# git config --global merge.tool diffconflicts
## git config --global mergetool.diffconflicts.cmd 'diffconflicts vim $BASE $LOCAL $REMOTE $MERGED'
# git config --global mergetool.diffconflicts.cmd 'diffconflicts gvim $BASE $LOCAL $REMOTE $MERGED'
# git config --global mergetool.diffconflicts.trustExitCode true
# git config --global mergetool.diffconflicts.keepBackup false
#
# The next time you perform a merge with conflicts, invoke this tool with the
# following command. (Of course you can set it as your default mergetool as
# well.)
#
# git mergetool --tool diffconflicts
#
# This tool will open three tabs in Vim that each provide a different way to
# view the conflicts. You can resolve the conflicts in the first tab and save
# and exit the file. This will also mark the conflict as resolved in Git.
#
# Tab1 is a two-way diff of just the conflicts. Resolve the conflicts here
# and save the file.
# +--------------------------------+
# | LCONFL | RCONFL |
# +--------------------------------+
#
# Tab2 is a three-way diff of the original files and the merge base. This is
# the traditional three-way diff. Although noisy, it is occasionally useful
# to view the three original states of the conflicting file before the merge.
# +--------------------------------+
# | LOCAL | BASE | REMOTE |
# +--------------------------------+
#
# Tab3 is the in-progress merge that Git has written to the filesystem
# containing the conflict markers. I.e., the file you would normally edit by
# hand when not using a mergetool.
# +--------------------------------+
# | <<<<<<< HEAD |
# | LCONFL |
# | ======= |
# | RCONFL |
# | >>>>>>> someref |
# +--------------------------------+
#
# Workflow:
#
# note: here can save the merge result.
#
# 1. Save your changes to the LCONFL temporary file (the left window on the
# first tab; also the only file that isn't read-only).
#
# 2. The LOCAL, BASE, and REMOTE versions of the file are available in the
# second tabpage if you want to look at them.
#
# 3. When vimdiff exits 'cleanly', the file containing the conflict markers
# will be updated with the contents of your LCONFL file edits.
#
# NOTE: Use :cq to abort the merge and exit Vim with an error code.
#
if [[ -z $@ || $# != "5" ]] ; then
  echo -e "Usage: $0 \$EDITOR \$BASE \$LOCAL \$REMOTE \$MERGED"
  exit 1
fi

cmd=$1
BASE="$2"
LOCAL="$3"
REMOTE="$4"
MERGED="$5"

printf -v QBASE '%q' "${BASE}"
printf -v QLOCAL '%q' "${LOCAL}"
printf -v QREMOTE '%q' "${REMOTE}"
printf -v QMERGED '%q' "${MERGED}"

# Temporary files for left and right side
# note: these seems to be files generated by git.
#
# | local fname(remote contents) | remote fname(local contents, ro) |
#LCONFL="${MERGED}.LOCAL.$$.tmp"
#RCONFL="${MERGED}.REMOTE.$$.tmp"

LCONFL="${MERGED}.REMOTE.$$.tmp"
RCONFL="${MERGED}.LOCAL.$$.tmp"

# LCONFL="${MERGED}.REMOTE.$$.tmp"
# RCONFL="${MERGED}.LOCAL.$$.tmp"
#
# and 
#
# $cmd -f -R -d "${LCONFL}" "${RCONFL}" \
#
# makes | remote fname(remote contents) | local fname(local contents, ro) |
#
# $cmd -f -R -d "${RCONFL}" "${LCONFL}" \
#
# makes | local fname(local contents) | remote fname(remote contents, ro) |
#
# note: this is better since cursor will be in the left

# Always delete our temp files; Git will handle it's own temp files
trap 'rm -f "'"${LCONFL}"'" "'"${RCONFL}"'"' SIGINT SIGTERM EXIT

# Remove the conflict markers for each 'side' and put each into a temp file
sed -r -e '/^<<<<<<< /,/^=======\r?$/d' -e '/^>>>>>>> /d' "${MERGED}" > "${LCONFL}"
sed -r -e '/^=======\r?$/,/^>>>>>>> /d' -e '/^<<<<<<< /d' "${MERGED}" > "${RCONFL}"

# Fire up vimdiff
#
# -d  Start in diff mode,
#
# -R  Readonly mode.  The 'readonly' option will be set for all the files being edited. You can
# still edit the buffer, but will be prevented from accidentally overwriting a file.
#
# -f  'f' stands for "foreground".  If omitted, the GUI forks a new process and exits the current
# one.  "-f" should be used when gvim is started by a program that will wait for the edit session to
# finish (e.g., mail or readnews). 
#
# -c {command} {command} will be executed after the first file has been read (and after autocommands
# and modelines for that file have been processed). "command" is interpreted as an Ex command.
#
# :[count]tabe[dit] 
# :[count]tabnew 
# Open a new tab page with an empty window, after the current
#
# :vert[ical] {cmd}
# Execute {cmd}. If it contains a command that splits a window, will be split vertically.
#
# :diffs[plit] {filename}
# Open a new window on the file {filename}. The options are set as for "vimdiff" for the current and
# the newly opened window.
#
# :[count]winc[md] {arg}
# Moves to the window below the current one. :wincmd j
#
# :tabfir[st]  Go to the first tab page.
#
$cmd -f -R -d "${LCONFL}" "${RCONFL}" \
  -c ":set noro" \
  -c ":tabe $QLOCAL" -c ":vert diffs $QBASE" -c ":vert diffs $QREMOTE" \
  -c ":winc t" -c ":tabe $QMERGED" -c ":tabfir"

EC=$?

# Overwrite $MERGED only if vimdiff exits cleanly.
if [[ $EC == "0" ]] ; then
#  cat "${LCONFL}" > "${MERGED}"
  cat "${RCONFL}" > "${MERGED}"
fi

exit $EC


<debug-output>
+ [[ -z gvim ./sample_BASE_3505.c ./sample_LOCAL_3505.c ./sample_REMOTE_3505.c sample.c ]]
+ [[ 5 != \5 ]]
+ cmd=gvim
+ BASE=./sample_BASE_3505.c
+ LOCAL=./sample_LOCAL_3505.c
+ REMOTE=./sample_REMOTE_3505.c
+ MERGED=sample.c
+ printf -v QBASE %q ./sample_BASE_3505.c
+ printf -v QLOCAL %q ./sample_LOCAL_3505.c
+ printf -v QREMOTE %q ./sample_REMOTE_3505.c
+ printf -v QMERGED %q sample.c
+ LCONFL=sample.c.LOCAL.3567.tmp
+ RCONFL=sample.c.REMOTE.3567.tmp
+ trap 'rm -f "sample.c.LOCAL.3567.tmp" "sample.c.REMOTE.3567.tmp"' SIGINT SIGTERM EXIT
+ sed -r -e '/^<<<<<<< /,/^=======\r?$/d' -e '/^>>>>>>> /d' sample.c
+ sed -r -e '/^=======\r?$/,/^>>>>>>> /d' -e '/^<<<<<<< /d' sample.c

// this makes | remote (w) | local (ro) |
+ gvim -f -R -d sample.c.REMOTE.3567.tmp sample.c.LOCAL.3567.tmp -c ':set noro' 

// this makes | remote | base | local |
-c ':tabe ./sample_LOCAL_3505.c' -c ':vert diffs ./sample_BASE_3505.c' -c ':vert diffs ./sample_REMOTE_3505.c'
-c ':winc t' -c ':tabe sample.c' -c :tabfir


={============================================================================
*kt_dev_env_git_012* generate patch and apply

{format-patch}
Prepare each commit with its patch in one file per commit, formatted to resemble UNIX mailbox
format. The output of this command is convenient for e-mail submission or for use with git am.

<usage>
Use to check before merge or to see diff between branches

Can check patch output before merging. You are 'on' undo topic barnch and want to see changes
'against' master then:

note: when omit --stdout, *.patch file is made.

$ git format-patch master --stdout
From 223da602d2e71c6d6708b52c80cd672c159b442d Mon Sep 17 00:00:00 2001
From: Kit Park <keitee.park@samsung.com>
Date: Tue, 22 Oct 2013 14:59:37 +0100
Subject: [PATCH 1/2] changed by undo

---
 readme | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/readme b/readme
index 3ba462e..a80c866 100644
--- a/readme
+++ b/readme
@@ -1,4 +1,4 @@
-1: changed first and added one by merge-test
+1: changed first and changed by undo
 2: changed second.
 3: added topic first.
 4: added topic second.
-- 
1.8.3.4


From fa9d05492f1f0357f5803edbf6232b73797b6d8f Mon Sep 17 00:00:00 2001
From: Kit Park <keitee.park@samsung.com>
Date: Tue, 22 Oct 2013 15:04:21 +0100
Subject: [PATCH 2/2] changed by undo undo

---
 readme | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/readme b/readme
index a80c866..67d833a 100644
--- a/readme
+++ b/readme
@@ -1,4 +1,4 @@
-1: changed first and changed by undo
+1: changed first and changed by undo and by undo
 2: changed second.
 3: added topic first.
 4: added topic second.
-- 
1.8.3.4

<usage>
Use to create patch files to review or to pull into mainline.

Now you have two commits that you want to send to the mailing list. You use git format-patch to
generate the mbox-formatted files that you can e-mail to the list - it turns each commit into an
e-mail message with the first line of the commit message as the subject and the rest of the message
plus the patch that the commit introduces as the body. The nice thing about this is that applying a
patch from an e-mail generated with format-patch preserves all the commit information properly.

# worked on topic and made some commits

$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch


{apply}
Two ways: git apply or git am

note: format-patch do not create patches between branches whereas git diff does. Any limitation?

note: appears that little use of making and applying a patch so leave it for now.


={============================================================================
*kt_dev_env_git_013* merge: undo merge attempt

{revert-merge}
When merge conflict happens, git modifies the file so will have modified status. How can undo this?
If you get conflicts, you can immediately get back to the state you were at before with:

~/git-work$ git merge undo
Auto-merging readme
CONFLICT (content): Merge conflict in readme
Automatic merge failed; fix conflicts and then commit the result.

~/git-work$ git status
# On branch master
# You have unmerged paths.
#   (fix conflicts and run "git commit")
#
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
#
#	both modified:      readme
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.readme.swp
no changes added to commit (use "git add" and/or "git commit -a")

~/git-work$ more readme 
1: changed first and changed by master.
2: changed second.
3: added topic first.
4: added topic second.

$ git merge --abort     # for the latest git
$ git reset --merge

kit@kit-vb:~/git-work$ git status
# On branch master
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#	.readme.swp
nothing added to commit but untracked files present (use "git add" to track)



={============================================================================
*kt_dev_env_git_015* git-tag

To tag specific points in history as being important and to mark release points
(v1.0, and so on)

$ git tag                           # list
$ git tag -l 'v1.4.2.*'             # search a tag with pattern


{annotated-tag}
Git uses two main types of tags: lightweight and annotated. It's generally
recommended that you create annotated tags so you can have all this information;  

       -a, --annotate
           Make an unsigned, annotated tag object

$ git tag -a v1.4 -m 'my version 1.4'

The -m specifies a tagging message

To see a tag

$ git show v1.4


{to-tag-a-commit} tag later
To tag that commit, you specify the commit checksum (or part of it) at the end
of the command:

$ git tag -a v1.2 -m 'version 1.2' 9fceb02


{tag-is-local}
By default, the git push command doesn't transfer tags to remote servers. You
will have to explicitly push tags to a shared server after you have created
them.


{branch-from-tag}
$ git co -b <branch> <tag>
$ git co -b C27.5.0-RC2 C27.5.0-RC2


={============================================================================
*kt_dev_env_git_016* rebase

In Git, there are two main ways to 'integrate' changes from one branch into another: the merge and
the rebase.

{use-merge}
Like an example in merge-with-diverge, merge experiment into master:

                      <experiment>
                     <- c4
c0 <- c1 <- c2       <- c3
                      <master>

$ git checkout master               // on master
$ git merge experiment              // take input and merge onto current

                      <experiment>
                     <- c4              
                                       \
c0 <- c1 <- c2       <- c3             <- c5    # points to c3 and c4
                                       <master> branch


{use-rebase-and-merge}
Another way: you can take the patch of the change that was introduced in C4 and 'reapply' it on top of
C3. This is called rebasing. Take changes from experiment and apply to master.

It works by going to the common ancestor (c2) of the two branches; the one you're on (experiment)
and the one you're rebasing onto (master), getting the diff introduced by each commit of the branch
you're on (diff between c4 and c2), saving those diffs to temporary files, resetting the current
branch to the same commit as the branch you are rebasing onto(checkout to master), and finally
applying each change in turn (apply temp diff to c3 which makes c4')

                      <experiment>
c0 <- c1 <- c2        <- c4
                      <- c3
                      <master>

$ git checkout experiment           // on experiment
$ git rebase master                 // rebase current 'to' master. still on experiment.

                     <- c4
c0 <- c1 <- c2       <- c3         <- c4'
                      <master>      <experiment>

                      At this point, you can go back to the master and do a fast-forward merge.

$ git checkout master               // on master
$ git merge experiment

                                    <experiment>
c0 <- c1 <- c2        <- c3         <- c4'
                                    <master> branch

note:
The above 4 step are necessary.

note:
The rebase has different sementics than merge:

$ git merge master                  // merge to current
$ git rebase master                 // rebase to master

Now, the snapshot pointed to by C4' is exactly the same as the one that was pointed to by C5 in the
merge example. 

note:
The single line has the same result from the git reference.

$ git checkout experiment           // on experiment
$ git rebase master                 // rebase current 'to' master. still on experiment.

$ git rebase master experiment


$ git rebase master experiment      // when on test branch and no conflict
First, rewinding head to replay your work on top of it...
Applying: experi: add 1st line in main
Applying: experi: add 2st line in main


{rebase-conflict}
As with merge, rebase can cause conflict. When tried the above scenario in that test is master and
experi is experiment at to mapping to the example.

$ git checkout experiment
$ git rebase master 
First, rewinding head to replay your work on top of it...
Applying: add foo func and call to it        // note: the first commit, C1, since the common parent
Using index info to reconstruct a base tree...
M	sample.c
Falling back to patching base and 3-way merge...
Auto-merging sample.c
CONFLICT (content): Merge conflict in sample.c
Failed to merge in the changes.
Patch failed at 0001 add foo func and call to it
The copy of the patch that failed is found in:
   /home/kpark/work/gitwork/.git/rebase-apply/patch

When you have resolved this problem, run "git rebase --continue".
If you prefer to skip this patch, run "git rebase --skip" instead.
To check out the original branch and stop rebasing, run "git rebase --abort".

$ git st
rebase in progress; onto cfeeadd
You are currently rebasing branch 'experi' on 'cfeeadd'.    # note: seems that made a temp branch
  (fix conflicts and then run "git rebase --continue")
  (use "git rebase --skip" to skip this patch)
  (use "git rebase --abort" to check out the original branch)

Unmerged paths:
  (use "git reset HEAD <file>..." to unstage)
  (use "git add <file>..." to mark resolution)

  both modified:   sample.c

Untracked files:
  (use "git add <file>..." to include in what will be committed)

  .sample.c.swp
  a.out

no changes added to commit (use "git add" and/or "git commit -a")

<continue>
Once resolved the conflict, continue rebase:

$ git rebase --continue 
Applying: add foo func and call to it
Applying: add more in main
Using index info to reconstruct a base tree...
M	sample.c
Falling back to patching base and 3-way merge...
Auto-merging sample.c

<see-result>
* a5102be65c402bfe96598edb6d7456f948f86f32 add more in main                // C2. experiment. HEAD
* ef9b72008785c8b3e80ec04ffe2b6507f9cb2e4e add foo func and call to it     // C1
* cfeeaddadd5249b1a8ec4d291d8881ba4b2d39f0 add more handling of using bar  // master branch
* ... 

As can see, applied two commits from experiment 'to' master and master branch 'remains' the same. So
do fast-forward merge.

$ git checkout master 
Switched to branch 'master'

$ git merge experiment 
Updating cfeeadd..a5102be
Fast-forward
 sample.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

* a5102be65c402bfe96598edb6d7456f948f86f32 add more in main                // experiment and master
* ef9b72008785c8b3e80ec04ffe2b6507f9cb2e4e add foo func and call to it
* cfeeaddadd5249b1a8ec4d291d8881ba4b2d39f0 add more handling of using bar     
* ... 


{why-rebase}
The rebase makes for a 'single' history by removing diverge in tree. If you examine the log of a
rebased branch, it looks like a linear history: it appears that all the work happened in series even
when it originally happened in parallel

Often, you'll do this to make sure your commits apply cleanly on a remote branch - perhaps in a
project to which you're trying to contribute but that you don't maintain. That way, the maintainer
doesn't have to do any integration work - just a fast-forward or a clean apply.

Rebasing 'replays' changes from one line of work 'onto' another in the order they were introduced
whereas merging takes the endpoints and merges them together.


={============================================================================
*kt_dev_env_git_019* git-rebase: rewriting-history

{advanced-rebase}

# from git help
# 
# git rebase [-i | --interactive] [options] [--onto <newbase>] [<upstream>] [<branch>]
# 
# If <branch> is specified, git rebase will perform an automatic git checkout <branch> before doing
# anything else. Otherwise it remains on the current branch.
# 
# The current branch is reset to <upstream>, or <newbase> if the --onto option was supplied. This
# has the exact same effect as git reset --hard <upstream> (or <newbase>). ORIG_HEAD is set to point
# at the tip of the branch before the reset.
# 
# Starting point at which to create the new commits. If the --onto option is not specified, the
# starting point is <upstream>. May be any valid commit, and not just an existing branch name.

<description>
You can also have your rebase replay on something other than the rebase target branch.

         <master>
C1 C2 C5 C6

      C3 C4 C10
            <server>    # topic branch for server functionality
         C8 C9
            <client>    # topic branch for client functionality

<one>
Suppose you decide that you want to merge your client-side changes into your mainline for a release,
but you want to hold off on the server-side changes until it's tested further. 

So want to apply C8 and C9 only to master.

$ git rebase --onto master server client

<Q> why 'server' in command when want to pull in client only? Looks because client had diverged from
server as well but cannot find any more detail from the reference. This means that the branch to
pull in must be the last in command?

This basically says, "Check out the client branch, figure out the patches from the common ancestor
of the client and server branches, and then replay them onto master." It's a bit complex; but the
result is pretty cool. The git ref says "make topic forked from branch master"

         <master>
C1 C2 C5 C6 C8' C9'
                <client>
      C3 C4 C10
            <server>          # topic branch

Now you can fast-forward your master branch:

$ git checkout master
$ git merge client

                <client>
C1 C2 C5 C6 C8' C9'
                <master>
      C3 C4 C10
            <server> # topic branch

<two>
Let's say you decide to pull 'in' your server branch as well. You can rebase the server branch onto
the master branch 'without' having to check it out first by running.

git rebase [basebranch] [topicbranch] 

which checks out the topic branch (in this case, server) for you and replays it onto the base branch
(master):

$ git checkout server
$ git rebase master

$ git checkout master
$ git merge server

or

$ git rebase master server

$ git checkout master
$ git merge server

The end result is:

                <client>    <server>
C1 C2 C5 C6 C8' C9' C3' C4' C10'
                            <master>

Now remove topic branches:

$ git branch -d client
$ git branch -d server

note: So, rebasing is useful when use topic branches.


{rebase-and-rewrite}
Changing Multiple Commit Messages in Ch 07 Rewriting History.

What this does is take smaller commits and 'combine' them into larger ones, which could be useful if
you're wrapping up the day's work or if you just want to package your changes differently.

                  <head>
C1 C2 C3 C4 C5 C6 C7 

Say want to mege from C4 to C7 into one C7.

git rebase -i HEAD~4      # select last 4 commit 'including' head

Vim pops up and edit to choose what to do

The log are:

1616841 - kit, 4 minutes ago : rebase five      # C7, HEAD
7b622e7 - kit, 5 minutes ago : rebase four      # C6
a6e0d20 - kit, 5 minutes ago : rebase three     # C5
3691dd1 - kit, 6 minutes ago : rebase two       # C4
99e3f70 - kit, 6 minutes ago : rebase one       # C3

<one>
# { vim screen 
pick 3691dd1 rebase two       note: reverse order from old to new
pick a6e0d20 rebase three
pick 7b622e7 rebase four 
pick 1616841 rebase five 

# Rebase 99e3f70..1616841 onto 99e3f70 (4 TODO item(s))
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
# } vim screen 


Successfully rebased and updated refs/heads/test.

note: Although the message when exit vim sounds done well, nothing has changed since picked 'all'.


{squashing-commits}
As the rebase message, squash = use commit, but meld into previous commit

C1 C2 C3 C4 C5 C6 C7 

git rebase -i HEAD~4

pick 3691dd1 rebase two       // note: reverse order from older
s a6e0d20 rebase three
s 7b622e7 rebase four 
s 1616841 rebase five 

Then quit vim and vim pops again to edit commit message. edit commit message and quit.

Tree will be:
         <head>
C1 C2 C3 C8 

So the three commits were removed and merged into one 'new' commit.

3fabf21 - kit, 23 minutes ago : rebase from two to five           // note: this will have C4-C7.
99e3f70 - kit, 23 minutes ago : rebase one


{reordering-commits} by changing the order in rebase vim screen
Git 'rewinds' your branch to the parent of these commits, 'applies'(replay) 310154e and then
f7f3f6d, and then 'stops'. You effectively change the order of those commits and remove the "added
cat-file" commit completely.

From:

pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

to this:

pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit

note: When replaying commits, merge conflict can happen and replaying means that it will create new
commits for every commits to replay including 'pick' one.


{spliting-commits} modifying commits
Want to split it into two commits: "updated README formatting" for the first, and "added blame" for
the second.

Then, when the script drops you to the command line, you reset that commit, take the changes that
have been reset, and create multiple commits out of them. 

$ git rebase -i HEAD~3
Stopped at da355b8... updated readme formatting and added blame
You can amend the commit now, with

	git commit --amend

Once you are satisfied with your changes, run

	git rebase --continue


pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame      // this to be split
pick a5f4a0d added cat-file

When you save and exit the editor, rewinds to the parent of the first commit in your list, applies
the first commit and the second, and 'drops' you to the console.


$ git st
# Not currently on any branch.  note: here 'detached' state and no modified files in working directory.
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)


$ git reset HEAD^
Unstaged changes after reset:
M	sample.c

or

$ git reset HEAD~ 
$ git diff


note: this is 'important' to get back the previous into the stage since the second is 'already'
replayed. this take the privious to the stages and now shows 'modifiled' state.

When run git diff, this shows the diff which are introduced from the privious in the staged to the
stopped, the second, in working).


$ git st
# Not currently on any branch.
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#	modified:   sample.c
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
no changes added to commit (use "git add" and/or "git commit -a")


note: Do what you want. Split part one. Here can do whtever you want and edited sample.c to split
the commit

$ git commit -am "updated readme formatting"
[detached HEAD 0c5d9cd] updated readme formatting
 1 file changed, 1 insertion(+)

$ git st
# Not currently on any branch.
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)


note: split part two. Here can do whtever you want and edited sample.c to split the commit

$ git commit -am "added blame"
[detached HEAD 709b103] added blame
 1 file changed, 1 insertion(+), 1 deletion(-)

$ git st
# Not currently on any branch.
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)


note: continue rebasing

$ git rebase --continue 
Successfully rebased and updated refs/heads/topic2.

$ git st
# On branch topic2
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
nothing added to commit but untracked files present (use "git add" to track)

$ git log
e8da604 - kit, 6 minutes ago : added cat-file
709b103 - kit, 31 seconds ago : added blame
0c5d9cd - kit, 81 seconds ago : updated readme formatting
532b821 - kit, 7 minutes ago : changed my name a bit

note: see the commit is splitted two and shows 4 in total.


{amend-last-commit}
Example: We edit a few files that we would like to commit in a single snapshot, but then we forget
to add one of the files the first time around. Fixing the error is simply a matter of staging the
other file and committing with the --amend flag:

// edit hello.py and main.py
git add hello.py
git commit

// realize you forgot to add the changes from main.py. note that make changes
// before run amend command as you do normal commit.

git add main.py
git commit --amend --no-edit

--no-edit flag will allow you to make the amendment to your commit without changing its commit
message. 

The editor will be populated with the message from the previous commit and
including the --no-edit flag will allow you to make the amendment to your commit
'without' changing its commit message. 

You can change it if necessary, otherwise just save and close the file as usual.
The resulting commit will replace the previous, and it will look like we
committed the changes to hello.py and main.py in a 'single' snapshot.

So it lets you combine "staged changes" with "the previous commit" instead of committing it as an
entirely new snapshot. Also be used to simply edit the previous commit message without changing its
snapshot.


note: Use the --amend option to edit the last commit such as whatever can to with a commit but not
in rebasing. Since amend do make a new commit and when use in rebasing, make new commit and may have
conflict when replaying the rest commits.


note: The amend in the middle of rebasing.

C1 C2 C3 C4 C5 C6 C7 
$ git rebase -i HEAD~4

// suppose that "edit" on C4 and stops at C4. make changes to C4

$ git commit --amend
$ git rebase --continue

When --amend is done, rebase tries to replay from C4 but not C5. So may happen conflict.


note: So rebasing is to make a temporary branch and to replay commits on to that branch, and swaps
it with the original commits when done. 


={============================================================================
*kt_dev_env_git_020* rebase: undo

Suppose that rebase pirate branch to master but wanted undo it.

git checkout pirate
git rebase master

How can I un-do this whole thing and start over?

git reflog

If you run the git reflog command you will see the line where it says 

"checkout: moving from master to pirate" 

this is the point in time we would like to restore our state back (just before the rebase happened).

Now copy the sha that is on the same line as that comment and run

git reset <sha> --hard

<case>
Worked on a branch and wanted to base it on the latest from master. Done something wrong with
rebasing and ended up with having "merge branch". Here shows how to 'undo' it and back to where it
was.

// full sha of the tip

0531f00bd8636c4d9d3935ac07fdf626b4a29bf5

// git log

* 4334791 (HEAD, DEVARCH-9135-work) add some debug
*   88c842b Merge branch 'master' of git-dev:/DEVARCH into DEVARCH-9135-work
|\  
| * 99186fe (tag: C26.6.0-RC2, DEVARCH-9135) DEVARCH-7725: Make SoupSessionInterposerTest more robust
| * ad6e1ab DEVARCH-9333: Uranium.Client.System: Fix compiler warnings.
...
| * 8b92a9e DEVARCH-8955: Remove the use of 'friend boost::shared_ptr' when hiding constructors
| * 92820f1 DEVARCH-8958: Fix unsafe pointer dereference in Uranium.Client.System: SystemClientUtils
* | 0531f00 add updates to unit test            // note: this was tip of working branch.
* | 731b4e2 add fixes to system client events and wrapper
* | 3d07e6c add debug mesgs to system client events
|/  
* 235e95c DEVARCH-9191: Sodium: Enable generic error reporting based on OEM name.
* 152753a DEVARCH-9188: OEM.Humax: Fix up reverse patch-o-tronning.


// git reflog. see lots of entry with the same sha.
...
f790f3c HEAD@{162}: commit: DEVARCH-8092: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()
235e95c HEAD@{163}: rebase -i (start): checkout HEAD~3
0531f00 HEAD@{164}: checkout: moving from DEVARCH-9135-work to DEVARCH-9135
0531f00 HEAD@{165}: checkout: moving from DEVARCH-9135 to DEVARCH-9135-work
0531f00 HEAD@{166}: checkout: moving from DEVARCH-9135 to DEVARCH-9135
0531f00 HEAD@{167}: checkout: moving from DEVARCH-9135-work to DEVARCH-9135
0531f00 HEAD@{168}: checkout: moving from DEVARCH-9135 to DEVARCH-9135-work
0531f00 HEAD@{169}: commit: add updates to unit test
731b4e2 HEAD@{170}: checkout: moving from 731b4e2b0a2d8e3ac1392404003500342b3ea8b4 to DEVARCH-9135
731b4e2 HEAD@{171}: checkout: moving from DEVARCH-9135 to tag-to-fix
...


={============================================================================
*kt_dev_env_git_021* rebase: rebase vs merge

Which one is better?

One point of view on this is that your repository's commit history is a 'record' of what actually
happened. It's a historical document, valuable in its own right, and shouldn't be tampered with.
From this angle, changing the commit history is almost blasphemous; you're lying about what actually
transpired. So what if there was a messy series of merge commits? That's how it happened, and the
repository should preserve that for posterity.

The opposing point of view is that the commit history is the 'story' of how your project was made. You
wouldn't publish the first draft of a book, and the manual for how to maintain your software
deserves careful editing. This is the camp that uses tools like rebase and filter-branch to tell the
story in the way that's best for future readers.

Now, to the question of whether merging or rebasing is better: hopefully you'll see that it's not
that simple. Git is a powerful tool, and allows you to do many things to and with your history, but
every team and every project is different. Now that you know how both of these things work, it's up
to you to decide which one is best for your particular situation.

<point>
In general the way to get the best of both worlds is to rebase local changes you've made but haven't
shared yet before you push them in order to clean up your story, but never rebase anything you've
pushed somewhere.


={============================================================================
*kt_dev_env_git_022* git-cherry-pick

{cherry-pick-from-remote}
There normally isn't any need to undo a fetch, because doing a fetch only updates the remote branch
and none of your branches. If you're not prepared to do a pull and merge in all the remote commits,
    you can use git cherry-pick to accept only the specific remote commits you want. Later, when
    you're ready to get everything, a git pull will merge in the rest of the commits.

Update: I'm not entirely sure why you want to avoid the use of git fetch. All git fetch does is
update your local copy of a remote branch. This local copy doesn't have anything to do with any of
your branches, and it doesn't have anything to do with uncommitted local changes. I have heard of
people who run git fetch in a cron job because it's so safe.


{cherry-pick}
A cherry-pick in Git is like a rebase for a 'single' commit. It takes the patch
that was introduced in a commit and tries to reapply it on the branch you're
currently on. This is useful if you have a number of commits on a topic branch
and you want to integrate only one of them, or if you only have one commit on a
topic branch and you'd prefer to cherry-pick it rather than run rebase. 

            master
C1    C2    C3    
            C4(e43a6)   C5
                        topic

$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
3 files changed, 17 insertions(+), 3 deletions(-)

This pulls the same change introduced in e43a6 to master and you get a 'new' commit because the date
applied is different. Now your history looks like this:

                        master
C1    C2    C3          C6   
            C4(e43a6)   C5
                        topic

Now you can remove your topic branch and drop the commits you didn't want to pull in.

note: master moves.


<conflict>
You are currently cherry-picking commit 938d0ac.
  (fix conflicts and run "git cherry-pick --continue")
  (use "git cherry-pick --abort" to cancel the cherry-pick operation)


={============================================================================
*kt_dev_env_git_023* git-reset

From Ch07, Reset demystified

{three-trees}
Git as a system manages and manipulates three trees in its normal operation:

Tree                    Role
-------------------------------------------------------------------
HEAD                    'last' commit snapshot, parent of next commit
Index                   Proposed next commit snapshot
Working Directory       Sandbox


{soft-mixed-hard}
Switching branches or cloning goes through a similar process. When you checkout
a branch, it changes HEAD to point to the new branch ref, populates your Index
with the snapshot of that commit, then copies the contents of the Index into
your Working Directory.

                        HEAD
                        master
v1    <-    v2    <-    v3

git reop

HEAD        index       working directory
v3          v3          v3

<soft> move only HEAD so go back before publishing a commit
$ git reset --soft HEAD~ 

            HEAD
            master
v1    <-    <v2>  <-    v3

git reop

HEAD        index       working directory
<v2>        v3          v3

It essentially 'undo' the last git commit command. git status shows difference
in green since HEAD is different from index. 

When you reset back to HEAD~, you are moving the branch back to where it was,
     without changing the Index or Working Directory. You could now update the
     Index and run git commit again to accomplish what git commit --amend would
     have done

<mixed> move HEAD and update index. 'default'
$ git reset [--mixed] HEAD~ 

            HEAD
            master
v1    <-    <v2>  <-    v3

git reop

HEAD        index       working directory
<v2>        <v2>        v3

'undo' your last commit, but also unstaged everything. You rolled back to before
you ran all your git add and git commit commands.

<hard> undo all
"git reset --hard HEAD~"

            HEAD
            master
v1    <-    <v2>  <-    v3

git reop

HEAD        index       working directory
<v2>        <v2>        <v2>


{hard-dangerous}
It's important to note that this --hard is the only way to make the reset command dangerous, and one
of the very few cases where Git will actually destroy data. 
  
Any other invocation of reset can be easily undone, but the --hard cannot, since it forcibly
overwrites files in the Working Directory. In this particular case, we still have the v3 version of
our file in a commit in our git DB, and we could get it back by looking at our reflog, but if we had
not committed it (means not in the repo), Git still would have overwritten the file and it would be
unrecoverable.


{reset-on-file}
If you specify a path, reset will not move HEAD1, and 'limit' the remainder of its actions to a
specific file or set of files. This actually sort of makes sense  HEAD is just a pointer, and you
can't point to part of one commit and part of another. But the Index and Working directory can be
partially updated. note: the below example is a bit different from the gitpro book.

To unstage:

$ git reset file

To unstage from a commit:
                        HEAD
                        master
v1    <-    v2    <-    v3

git reop

HEAD        index       working directory
v3          v3          v3


$ git reset v1 file       # v1 is a commit


                        HEAD
                        master
v1    <-    v2    <-    v3

git reop

HEAD        index       working directory
v3          <v1>          v3

$ git status

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

  modified:   version.txt                # note: v1. since the index has changed

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   version.txt                # note: v3. since git see difference from index

$ git add version.txt  

<Q> what will happen? will make a new commit? nothing happens and status shows none because:

HEAD        index       working directory
v3          <v3>          v3


={============================================================================
*kt_dev_env_git_029* recover and dangling

{to-check}
$ git commit -v 96c6af219a3d019c9353db261f8c0ecbb378602c
error: pathspec '96c6af219a3d019c9353db261f8c0ecbb378602c' did not match any file(s) known to git.

$ git branch --contains 96c6af219a3d019c9353db261f8c0ecbb378602c
$ note: shows nothing


{recover-stash}
Recover dropped stash in git

http://stackoverflow.com/questions/89332/recover-dropped-stash-in-git

If you have only just popped it and the terminal is still open, you will still have the hash value
printed by git stash pop on screen (thanks, Dolda).

Otherwise, you can find it using this:

git fsck --no-reflog | awk '/dangling commit/ {print $3}'

This will show you all the commits at the tips of your commit graph which are no longer referenced
from any branch or tag - every lost commit, including every stash commit you've ever created, will
be somewhere in that graph.

The easiest way to find the stash commit you want is probably to pass that list to gitk:

gitk --all $( git fsck --no-reflog | awk '/dangling commit/ {print $3}' )

This will launch a repository browser showing you 'every' single commit in the repository ever,
regardless of whether it is reachable or not.

You can replace gitk there with something like git log --graph --oneline --decorate if you prefer a
nice graph on the console over a separate GUI app.

To spot stash commits, look for commit messages of this form:

WIP on somebranch: commithash Some old commit message

Once you know the hash of the commit you want, you can apply it as a stash:

git stash apply $stash_hash

Or you can use the context menu in gitk to create branches for any unreachable commits you are
interested in. After that, you can do whatever you want with them with all the normal tools. When
you're done, just blow those branches away 


{dangling}
http://gitready.com/advanced/2009/01/17/restoring-lost-commits.html

So, you just did a git reset --hard HEAD^ and threw out your last commit. Well, it turns out you
really did need those changes. Don't fear, git should still have your commit. When you do a reset, the
commit you threw out goes to a 'dangling' state. Its still in git's datastore, waiting for the next
garbage collection to clean it up. So unless you've ran a git gc since you tossed it, you should be
in the clear to restore it.

For these examples, I'm working with the code for this blog. From the top, we just ran:

$ git show-ref -h HEAD
  7c61179cbe51c050c5520b4399f7b14eec943754 HEAD

note: the below is real output when run tha above.
$ git show-ref --head HEAD
53c849344458f858c75cd50ab924d61b867822fd HEAD
e3abcd196ed42eef28831c70c099a76ee0c273be refs/remotes/origin/HEAD

$ git reset --hard HEAD^
  HEAD is now at 39ba87b Fixing about and submit pages so they don't look stupid

$ git show-ref -h HEAD
  39ba87bf28b5bb223feffafb59638f6f46908cac HEAD

So our HEAD has been backed up by one commit. At this point if we wanted it back we could just git
pull, but we're assuming that only our local repository knows about the commit. We need the SHA1 of
the commit so we can bring it back. We can prove that git 'knows' about the commit still with the
fsck command:

$ git fsck --lost-found
  [... some blobs omitted ...]
  dangling commit 7c61179cbe51c050c5520b4399f7b14eec943754

note: the output of fsck

$ git fsck --lost-found                                              
Checking object directories: 100% (256/256), done.
Checking objects: 100% (278686/278686), done.
dangling blob 198960a3967375f15dde3e6912b5709df742e6ea
dangling commit e8e7005ed7f57c5a6c55427b1ec60f37e837f1a2
dangling commit 07265101674f742917e0c6a10e7d78fbf91b6889
dangling commit c8725150f8df2b3755aff66f2fc5489d84cb0d7a
dangling blob b1832250dc825697aab015fb3876a951cc098125
dangling commit 95a2029cca8c0d6445704c4144996ab3ecb8334a
dangling commit 6abd32af822769d7f5ba8a2c2dd2981a7054c57e
dangling commit 17109366374de1591f663ff5e206dc9f03f63230
dangling commit 9e5c93cb6b02beb16700cc3d36c8c026b4631972
dangling commit 8e5fc3451a2778aad439266b290885611ccf995e
dangling commit 686983d96f27cb54067e0cd87c38b20e49d8603e
...

You can also see the that git knows about the commit still by using the reflog command:

$ git reflog
  39ba87b... HEAD@{0}: HEAD~1: updating HEAD
  7c61179... HEAD@{1}: pull origin master: Fast forward
  [... lots of other refs ...]

So, we now have our SHA1: 7c61179. If we want to get immediately apply it back onto our current
branch, doing a git merge will recover the commit:

$ git merge 7c61179
  Updating 39ba87b..7c61179
  Fast forward
    css/screen.css |    4 ++++
    submit.html    |    4 ++--
    2 files changed, 6 insertions(+), 2 deletions(-)

note: can use cherry-pick than merge

This command will bring your lost changes back and make sure that HEAD is pointing at the commit.

From here you can continue to work as normal! You could also checkout the SHA1 'into' a new branch,
     but really a merge is the fastest and easiest way to restore that lost commit once you have the
     hash. If you have other ways let us know in the comments!

If you want some more options on what to do in this situation, Mathieu Martin's illustrated guide to
recovering lost commits with Git has plenty for you.

http://www.programblings.com/2008/06/07/the-illustrated-guide-to-recovering-lost-commits-with-git/


={============================================================================
*kt_dev_env_git_030* git-stash

Stashing takes the dirty state of your 'working' directory - that is, your
modified tracked files and staged changes - and saves it on a stack of
unfinished changes that you can reapply at any time.

note: Save two things; staged and tracked but 'not' untracked. When apply the stash, all goes to
'unstaged' area by default. 
note: After stashing, your working directory is clean since all changes are stashed.

<to-stash-untracked>
If you specify --include-untracked or -u, Git will also stash any untracked files you have created.

<to-apply-staged-changes>
The file you staged before was not restaged. To do that, you must run the git stash apply command
with a --index option to tell the command to try to reapply the staged changes. 


{save}
If do not give the name, git will make it as shown. WIP xxx: {commit which was the base when
stashed} {commnet}. Better to use message to have clear label for that since use the base commit's
one when use save only.

$ git stash save
stash@{0}: WIP on master: d926edd new third

$ git stash save "temp work on master"
stash@{0}: On master: temp work on master

<save-all> than clean
Be pretty careful with this git clean command, since it's designed to remove files from your working
directory that are not tracked. If you change your mind, there is often no retrieving the content of
those files. A safer option is to run git stash --all to remove everything but save it in a stash.


{list} like stack since 0 is the 'latest'
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log


{apply}
Like pop, but do not remove the state from the stash list. If you don't specify
a stash, Git assumes the most recent stash and tries to apply it:

$ git stash apply


{unapply}
Un-applying a Stash

In some use case scenarios you might want to apply stashed changes, do some
work, but then un-apply those changes that originally came from the stash. Git
does not provide such a stash unapply command, but it is possible to achieve the
effect by simply retrieving the patch associated with a stash and applying it in
reverse:

//  -R, --reverse
//    Apply the patch in reverse.

$ git stash show -p stash@{0} | git apply -R

Again, if you don't specify a stash, Git assumes the most recent stash:

$ git stash show -p | git apply -R

You may want to create an alias and effectively add a stash-unapply command to
your Git. For example:

$ git config --global alias.stash-unapply '!git stash show -p | git apply -R'
$ git stash apply
$ #... work work work
$ git stash-unapply

note: 
This works fine when there were no changes made since apply. Otherwise, git
emits conflict errors.


<apply-conflict>
When make changes to the stashed file and want to apply the different stash. Git gives you merge
conflicts if anything no longer applies cleanly. (This means when the current working directory is
different from the stashed base. So cannot apply stash cleanly)

$ git stash apply stash@{0}
error: Your local changes to the following files would be overwritten by merge:
   not-staged.c
   test_file.c
Please, commit your changes or stash them before you can merge.
Aborting

To return to the clean state or to have the clean commit:

git reset --hard <tag/branch/commit id>

Then apply stash.


<apply-single-file>
Like checkout, see diff and copy a file from stash to working directory.

git diff HEAD stash@{0} -- <filename>

git checkout stash@{0} -- <filename>


<stash-branch>
If you stash some work, leave it there for a while, and continue on the branch from which you
stashed the work, you may have a problem reapplying the work. If the apply tries to modify a file
that you've since modified, you'll get a merge conflict and will have to try to resolve it. 

If you want an 'easier' way to test the stashed changes again, you can run git stash branch, which
creates a new branch for you, checks out the commit you were on when you stashed your work,
        reapplies your work, stash, there, and then drops the stash if it applies successfully:

$ git stash branch testchanges
Switched to a new branch "testchanges"
# On branch testchanges
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#      modified:   index.html
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)

This is a nice shortcut to recover stashed work easily and work on it in a new branch.

note: seems that it's not working as expected as below.

$ git stash branch test
   readme
Switched to a new branch 'test'
error: Your local changes to the following files would be overwritten by merge:
   readme
Please, commit your changes or stash them before you can merge.
Aborting
Index was not unstashed.
$

note:
https://codingkilledthecat.wordpress.com/2012/04/27/git-stash-pop-considered-harmful/
Don't use stashing at all. One of Git's biggest strengths is that commits and branches are cheap.
Instead of creating stashes, why not just create a new branch and commit your changes on it?

KT. This fails when there are modified files from which stashed the work. Need to clean working
directory. So looks like a shortcut of branch and stash pop. Better use branch in the first place.


{drop}
Stash stack. To remove it, you can run git stash drop with the name of the stash to remove:

$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log

$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)

You can also run git stash pop to apply the stash and then immediately drop it from your stack.

Delete all of the stored stashes with:

$ git stash clear


{show}
git show [<stash>]

Show the changes recorded in the stash as a diff between the stashed state and
its 'original' parent.

When no <stash> is given, shows the latest one. By default, the command shows
the diffstat, but it will accept any format known to git diff. e.g., git stash
show -p stash@{1} to view the second most recent stash in patch form.

$ git stash show stash@{0}
 Polonium/Polonium.NexusInspect/Makefile.am                 |  2 +-
 Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c |  4 ++--
 Polonium/Polonium.NexusInspect/src/nexus-inspect.c         | 48 ++++++++-
 Polonium/Polonium.NexusInspect/src/nexus-inspect.h         | 26 +++++++++
 Polonium/Polonium.NexusInspect/src/nexus-release.c         | 24 +++++++++
 5 files changed, 61 insertions(+), 43 deletions(-)


$ git diff stash@{0} stash@{1}


={============================================================================
*kt_dev_env_git_031* config: use gvim as default editor

$ git config --global core.editor gvim

However, this do not work even if it launches gvim with commit log window but git emits error:

$ git commit -a
+linux
+neocomplete
Aborting commit due to empty commit message.

To fix this:
http://forums.udacity.com/questions/100228609/using-gvim-to-edit-your-git-commit-messages

$ git config --global core.editor "gvim -f"

From gvim help:
   -f  or  --nofork        Foreground: Do not fork when starting GUI


={============================================================================
*kt_dev_env_git_032* git list

{list}
Lists all the files being tracked by your git repo.

git ls-tree --full-tree -r HEAD


={============================================================================
*kt_dev_env_git_033* add and clean

{add}
See differences between "add .", "add -u", "add -A".

add .  : add untracked *new file* and tracked *modified file* to the stage but not removed one.
add -u : add only tracked files.
add -A : is a handy shortcut for doing both.

<1> git add .
$ git add --ignore-removal . (has the same)

$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    modified:   change-me
#    deleted:    delete-me
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    add-me
no changes added to commit (use "git add" and/or "git commit -a")

$ git add .
warning: You ran 'git add' with neither '-A (--all)' or '--ignore-removal',
whose behaviour will change in Git 2.0 with respect to paths you removed.
Paths like 'delete-me' that are
removed from your working tree are ignored with this version of Git.

* 'git add --ignore-removal <pathspec>', which is the current default,
  ignores paths you removed from your working tree.

* 'git add --all <pathspec>' will let you also record the removals.

Run 'git status' to check the paths you removed from your working tree.


$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#    new file:   add-me
#    modified:   change-me
#
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    deleted:    delete-me
#

<2>
git add -u (for only tracked files)

$ git status
# On branch master
# Changes not staged for commit:
#   (use "git add/rm <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    modified:   change-me
#    deleted:    delete-me
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    add-me
no changes added to commit (use "git add" and/or "git commit -a")

$ git add -u

$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#    modified:   change-me
#    deleted:    delete-me
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#    add-me

{rm}
When accidentally staged it, like a large log file or a bunch of .a compiled files. To do this, use
the --cached option:

$ git rm --cached README


{mv}
If you want to rename a file in Git, you can run something like

$ git mv file_from file_to


{clean}
git-clean - Remove 'untracked' files from the working tree

Cleans the working tree by recursively removing files that are not under version control, starting
from the current directory.

<really>
Normally, only files unknown to git are removed, but if the -x option is specified, ignored files
are also removed. This can, for example, be useful to remove all build products.

       -d
           Remove untracked directories in addition to untracked files. If an
           untracked directory is managed by a different git repository, it is
           not removed by default. Use -f option twice if you really want to
           remove such a directory.

       -f, --force
           If the git configuration variable clean.requireForce is not set to
           false, git clean will refuse to run unless given -f or -n.

note:  -n, --dry-run
           Don't actually remove anything, just show what would be done.

       -x
           Don't use the standard ignore rules read from .gitignore (per
           directory) and $GIT_DIR/info/exclude, but do still use the ignore
           rules given with -e options. This allows removing all untracked
           files, including build products. This can be used (possibly in
           conjunction with git reset) to create a pristine working directory
           to test a clean build.

       -X
           Remove only files ignored by git. This may be useful to rebuild
           everything from scratch, but keep manually created files.

Cleaning also has a few other helpful options: if you want to perform a normal clean and clear out
all the files that git usually ignores, the -x flag will help immensely. If you just want to trash
the ignored files and nothing else, use the -X option.

The problem with using git is that it will nuke all the files it doesn't know about. That might
include log files, debug files, and in my case, Eclipse project files as well...setting up
.gitignore is a pain!

How to clean working dirs with having files manually created?
1) Can use .gitignore file and use -X.
2) Can use shell script.


={============================================================================
*kt_dev_env_git_034* diff, difftool

{combined-format}
This is the default format and a combined diff format looks like this:

It is followed by two-line from-file/to-file header

--- a/file
+++ b/file

- static void describe(char *arg)
 -static void describe(struct commit *cmit, int last_one)
++static void describe(char *arg, int last_one)
  {
 +    unsigned char sha1[20];
 +    struct commit *cmit;
      struct commit_list *list;
      static int initialized = 0;
      struct commit_name *n;

 +    if (get_sha1(arg, sha1) < 0)
 +       usage(describe_usage);
 +    cmit = lookup_commit_reference(sha1);
 +    if (!cmit)
 +       usage(describe_usage);
 +
      if (!initialized) {
         initialized = 1;
         for_each_ref(get_name);


Unlike the traditional unified diff format, which shows 'two' files A and B with a single column
  that has - (minus - appears in A but removed in B), + (plus - missing in A but added to B), or " "
  (space - unchanged) prefix, this format compares two or 'more' files file1, file2,... with one
  file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to
  the output line to note how X's line is different from it.

A - character in the column N means that the line appears in fileN but it does not appear in the
result. A + character in the column N means that the line appears in the result, and fileN does not
have that line (in other words, the line was added, from the point of view of that parent).

In the above example output, the function signature was changed from both files (hence two -
    removals from both file1 and file2, plus ++ to mean one line that was added does not appear in
    either file1 or file2). Also eight other lines are the same from file1 but do not appear in
file2 (hence prefixed with +).


{diff-between-index-and-working}
That command shows diff between the staging area, index, and  your working directory. The result
tells you the changes you've made that you haven't yet staged. 

note: 'diff' shows the patch format by default.

$ git diff
diff --git a/sample.c b/sample.c
index bb699af..1ee2e2c 100644
--- a/sample.c
+++ b/sample.c
@@ -74,9 +74,7 @@ outputError(Boolean useErr, int err, Boolean flushStdout,
     fflush(stderr);           /* In case stderr is not line-buffered */
 }
 
-/* Display error message including 'errno' diagnostic, and
-   return to caller */
-
+// Display error message including 'errno' diagnostic, and return to caller
 void
 errMsg(const char *format, ...)
 {
$ 

note:
That means that shows diff as if run the below and 'b' in diff is a destination.

$ git diff "from" "to"
$ git diff == git diff "index" "working directory"


{diff-between-staged-and-head}
See what you've staged that will 'go' into your next commit, you can use git diff --staged. This
command compares your staged changes to your last commit:

$ git diff --cached or --staged     # == git diff index HEAD


{diff-between-commit-and-working}
git diff [--options] <commit> [--] [<path>]

This form is to view the changes you have in your working tree relative to the named <commit>. You
can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a
different branch.

$ git diff commit                   # == git diff commit working


{diff-between-local-and-remote}
note:
As shown above, "from" and "to" can be used in different order. So 

$ git diff master origin/master  # shows diff to goes to "origin/master"
$ git diff origin/master master  # shows diff to goes to "master"

$ git fetch
$ git diff master origin/master
diff --git a/kt_dev_01.txt b/kt_dev_01.txt
index 4e8bdd1..51a3cb1 100644
--- a/kt_dev_01.txt
+++ b/kt_dev_01.txt
@@ -36,7 +36,7 @@ KT KB. DEVELOPMENT.
 
 #{ GCC
 |kt_dev_gcc_000| gcc compile script
-|kt_dev_gcc_001| error: two or more data types in declaration specifiers {prepr
+|kt_dev_gcc_001| error: two or more data types in declaration specifiers <bool>
 |kt_dev_gcc_002| error: ISO C++ forbids declaration of 'UseStatic' with no type
 |kt_dev_gcc_003| error: invalid conversion from 'Singleton*' to 'MySingleton*' 
 |kt_dev_gcc_004| error: variable-sized object 'out' may not be initialised
@@ -3655,7 +3655,6 @@ sam01.cpp:6:0: warning: "MYBOOL" redefined [enabled by def
...

<to-see-filenames-changed>
$ git fetch
$ git diff --name-only master origin/master

<to-see-single-file-diff>
$ git fetch
$ git diff master:kt_dev_01.txt  origin/master:kt_dev_01.txt  
$ git difftool topic:src/nexusMgr.c try-proposal:src/nexusMgr.c

<to-see-commits-between-local-and-fetch>
This shows 'commits' that were downloaded from the remote. In other words, differences to goes to
remote. This is based on double-dot notation.

$ git fetch
$ git log master..origin      # commits to 'become' origin.

$ git log HEAD..origin        # if you're not on master branch.

To get the diff format:

$ git log -p master..origin 

The below shows the same result except that log has a commit details.

$ git diff master..origin 


{diff-between-commits}
git diff --name-only commit commit
git diff commit commit


{diff-between-branches}
That will produce the diff between the 'tips' of the two branches. 

$ git diff --name-only master..branchName

git diff branch_1..branch_2
git diff branch_1...branch_2
git diff branch1 branch2


{word-diff-option}
When useful?

git diff --word-diff


{difftool}
note: make sure to have the latest git to use this option.

-d
--dir-diff

Copy the modified files to a temporary location and perform a directory diff on them. This mode
never prompts before launching the diff tool.

git difftool humax..origin/huawei/dn370t
git difftool -d origin/huawei/dn370t         # compare the current to dn370t


{git-diff-and-patch}
To create a patch of the changes on the experimental branch and apply them to the master. Suppose
you are on master.

git diff from-commit to-commit > output-file

note: here deals with 'commit' and if either from-commit or to-commit are omitted, they will be
assumed to be HEAD

git diff 04a2 b36f > patch.diff

<merge-base>
Rather than creating a patch of the entire branch, we can let GIT determine the 'point' at which our
experimental branch diverged from the master branch using the git merge-base command:

git diff $(git merge-base <public branch> <experimental branch>) > <output file>

git merge-base will determine the most recent common commit between 2 branches. It will be defaulted
to HEAD, and since the experimental branch checked out, HEAD will be the most recent commit of the
experimental branch.

$ git diff $(git merge-base master experimental) > anotherPatch.diff

<apply-patch>

$ git apply patch.diff

<no-history>
Although applying a patch in this way will exactly replicate content, no commit history will be
replicated. This means that even if the patch you create spans several commits, it will appear as a
single set of changes when applied.


={============================================================================
*kt_dev_env_git_035* show


{git-show}
To see files changed in a commit

$ git show --name-only {commit}

$ git show e433e8e
commit e433e8e2e5332becd98b82bda07986803580ecf2
Merge: acb2870 f8a541e
Author: xxxx
Date:   Tue Feb 17 09:08:44 2015 +0000

    Merge branch ...
    
    Conflicts:
       ...


={============================================================================
*kt_dev_env_git_036* commit

$ git commit
[master 312e37a] Stroy 182: fix benchmarks for speed
 1 file changed, 1 insertion(+)

--verbose
$ git commit -v

$ git commit -m "Stroy 182: fix benchmarks for speed"

<a-option>
the -a option to the git commit command makes Git automatically stage every file that is already
tracked 'before' doing the commit, letting you skip the git add part:

$ git commit -am 'added new benchmarks'


={============================================================================
*kt_dev_env_git_100* case: see what is to be introduced

How to specify or query ranges of commits using range specifications.

{double-dot} 'exclusion'
This basically asks Git to resolve a range of commits that are 'reachable' from
one commit but aren't reachable from another.

A  B  E  F  <- master
      C  D  <- experiment

Means "all commits reachable by experiment that aren't reachable by master."
shows what are needed to become experiment. what is in your branch.

$ git log master..experiment        # git log experiment --not master
D
C

The opposite: shows what experiment do not have. what is not in your branch

$ git log experiment..master        # git log master --not experiment
F
E

note: show commits only in local master that are differences between master and
origin/master.

$ git log origin/master..master     # git log master --not origin/master

note: this notaion is more explanatory but not useful since cannot use
'completion' feature.

git log master ^origin/master


<ex>
* master 5777bd6 [behind 11] Fix for distcheck target is failing to compile.

$ git log origin/master..master 
// shows nothing

$ git log master..origin/master 
// shows commits ahead of local master


{multiple-points}
Want to specify 'more' than two branches to indicate your revision. Thus these three commands are
equivalent:

$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA

For instance, if you want to see all commits that are reachable from refA 'or' refB but not from
refC, you can type one of these:

$ git log refA refB ^refC
$ git log refA refB --not refC

This makes for a very powerful revision query system that should help you figure out what is in
branches in question.


{triple-dot} 'aggregation'
The last major range-selection syntax is the triple-dot syntax, which specifies 'all' the commits that
are reachable by 'either' of two references but 'not' by both of them. Look back at the example
above. If you want to see what is in master or experiment but not any common references, you can run

$ git log master...experiment
F
E
D
C

appearing in the traditional commit date 'ordering'.

A common switch to use with the log command in this case is --left-right, which shows you which side
of the range each commit is in. 

$ git log --left-right master...experiment
< F
< E
> D
> C

With these tools, you can much more easily let Git know what commit or commits you want to inspect.


{to-see-what-to-push}
This command shows you any commits in your current branch that aren't in the master branch on your
origin remote. The commits listed by this command are the commits that will be transferred to the
server.

You can also leave off one side of the syntax to have Git assume HEAD. For example, you can get the
same results as in the previous example by typing git log origin/master..

$ git log origin/master..HEAD
$ git log origin/[branch]..HEAD


{to-see-what-to-merge}
To see exactly what you'll be introducing if you merge this topic into your master branch.

$ git log --no-merges master..topic
$ git log topic --not master           # same as above
$ git log -p topic --not master        # patch format


{different-in-diff-context}

master
C1    C2    C3    topic1
      C4    C5    topic2

To see what will be introduced when merge topic1:

git log master..topic1        # the same. C3, C2 note: reverse order
git log topic2..topic1        # the same

git merge-base topic1 topic2  # C1

git diff master               # shows C2, C3 since currently on topic1
git diff C1                   # the same

git diff master topic         # shows C2, C3
git diff master..topic1       # shows C2, C3
git diff topic2..topic1       # the end result is the same but shows deleting C4, C5

git diff topic2...topic1      # shows C2, C3

The range in diff context is different. 

<one>
If master is a direct ancestor of your topic branch, this isn't a problem; but if the two histories
have diverged, the diff will look like you're adding all the new stuff in your topic branch and
'removing' everything unique to the master branch. note: this is what you get from double dot.

<two> 
This command shows you only the work your current topic1 branch has introduced since its common
ancestor with master. That is a very useful syntax to remember.

$ git diff topic2...topic1


{revision-selection}
From the GITR 7 Git Tools, Ancestry Reference.

The other main way to specify a commit is via its ancestry. If you place a ^ at the end of a
reference, Git resolves it to mean the parent of 'that' commit. 


$ git show HEAD^        // == HEAD~ ,

This means the parent of HEAD so the previous commit.
$ git show HEAD^2       // not the second from the HEAD but the second parent


={============================================================================
*kt_dev_env_git_038* grep

To search through any 'committed' tree or the working directory for a string or 'regular'
expression.

Advantages over normal searching commands like grep and ack. 

The first is that it's really fast. 

The second is that you can search through any tree in Git, not just the working directory. As we saw
in the above example, we looked for terms in an older version of the Git source code, not the
version that was currently checked out.  

By default, it will look through the files in your working directory. You can pass -n to print out
the line numbers

$ git grep -n gmtime_r

To see what method or function it thinks it has found a match in, you can pass -p:

$ git grep -p gmtime_r *.c
date.c=static int match_multi_number(unsigned long num, char c, const char *date, 
date.c: if (gmtime_r(&now, &now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_
date.c: if (gmtime_r(&time, tm)) {

Look for complex combinations of strings with the --and flag. Use the --break and --heading options
which help split up the output into a more readable format.

$ git grep --break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0

$ git grep --break --heading \
-n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u<<20)

v1.8.0:cache.h
73:#define S_IFGITLINK 0160000
74:#define S_ISGITLINK(m) (((m) & S_IFMT) == S_IFGITLINK)


={============================================================================
*kt_dev_env_git_050* gitk

gitk [<options>] [<revision range>] [\--] [<path>...]

$ gitk --all &
--all
    Show all refs (branches, tags, etc.).

The yellow dot next to the top commit indicates that is the snapshot currently in my working folder
(referred to as HEAD) 

<reload>
http://gitolite.com/gitk.html#bcpc
If you're doing stuff on the command line in another screen, and want those changes reflected in
gitk, hit F5(update).

F5 updates the refs and shows you their new values while still showing you the old ones. It is most
useful after operations like rebase, because you can compare the previous branch head with the new
one.

Shift-F5, on the other hand, is a total reload, throwing away everything that was previously shown.

<diff>
At any time, the bottom left pane shows a "diff", usually of the current commit shown in the top
pane. The bottom right pane (by default) shows a list of files in this "diff".

spacebar: move forward 1 page in the diff view
backspace/delete: ditto, but backward
"f": move to next file in the diff. Both the bottom left and right panes will show a change when you do this.
"b": ditto, but previous file
click a file in the bottom right pane: scrolls the left pane to show that file's changes

5.1 running a diff between two arbitrary commits

left click on the "new" commit
navigate using the scrollbar (no keyboard shortcut, AFAICT) to some other commit
right-click and choose "Diff this -> selected"

Now you can browse that diff using the keyboard or mouse. Note that any movement that selects a
different commit (like pressing an arrow key) will change the view to show that commit, so while
examining this "diff", stick to these keys.


<to-see-commits-only>
$ gitk -- path

Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect
to revision names use "--" to separate the paths from any preceding options.

<to-see-branch>
$ gitk branch


={============================================================================
*kt_dev_env_git_100* different workflows

{centralized}
In centralized systems, there is generally a single collaboration model-the centralized workflow.
One central hub, or repository, can accept code, and everyone synchronizes their work to it. A
number of developers are nodes - consumers of that hub - and synchronize to that one place.

This means that if two developers clone from the hub and both make changes, the first developer to
push their changes back up can do so with no problems. The second developer must merge in the first
one's work before pushing changes up, so as not to overwrite the first developer's changes. This
concept is as true in Git as it is in Subversion (or any CVCS), and this model works perfectly well
in Git.

Git won't let users overwrite each other. note: push conflict. She is told that she's trying to push
non-fast-forward changes and that she won't be able to do so until she fetches and merges.


{integration-manager} github
A workflow where each developer has write access to their own public repository and read access to
everyone else's. This scenario often includes a canonical repository that represents the "official"
project. To contribute to that project, you create your own public clone of the project and push
your changes to it. Then, you can send a request to the maintainer of the main project to pull in
your changes. The maintainer can then add your repository as a remote, test your changes locally,
     merge them into their branch, and push back to their repository.

This is a very common workflow with hub-based tools like GitHub or GitLab.

One of the main advantages of this approach is that you can continue to work, and the maintainer of
the main repository can pull in your changes at any time. Contributors don't have to wait for the
project to incorporate their changes - each party can work at their own pace.

Many groups switch to Git because of this ability to have multiple teams working in parallel,
     merging the different lines of work late in the process. The ability of smaller subgroups of a
     team to collaborate via remote branches without necessarily having to involve or impede the
     entire team is a huge benefit of Git. 


{dictator-and-lieutenants}
This is a variant of a multiple-repository workflow. It's generally used by huge projects with
hundreds of collaborators; one famous example is the Linux kernel.

Various integration managers are in charge of certain parts of the repository; they're called
lieutenants. All the lieutenants have one integration manager known as the benevolent dictator.

This kind of workflow isn't common, but can be useful in very big projects, or in highly
hierarchical environments.


={============================================================================
*kt_dev_env_git_101* commit guideline

{small-commit}
Next, try to make each commit a logically separate changeset. If you can, try to make your changes
digestible; don't code for a whole weekend on five different issues and then submit them all as one
massive commit on Monday.

So try to make things easier on your fellow developers when they have to review your changes. This
approach also makes it easier to pull out or revert one of the changesets if you need to later.


{commit-message}
It's also a good idea to use the imperative present tense in these messages. In other words, use
commands.

<template>
Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some
contexts, the first line is treated as the subject of an email and the rest of the text as the body.
The blank line separating the summary from the body is critical (unless you omit the body entirely);
tools like rebase can get confused if you run the two together.

Further paragraphs come after blank lines.

- Bullet points are okay, too

- Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank
lines in between, but conventions vary here

<from-git-project>
commit 51334bb094e085728ffe2b603fa3fe41dd80c075
Author: Luke Diamand <luke@diamand.org>
Date:   Sat Jan 17 20:56:38 2015 +0000

    git-p4: support excluding paths on sync
    
    The clone subcommand has long had support for excluding
    subdirectories, but sync has not. This is a nuisance,
    since as soon as you do a sync, any changed files that
    were initially excluded start showing up.
    
    Move the "exclude" command-line option into the parent
    class; the actual behavior was already present there so
    it simply had to be exposed.
    
    Signed-off-by: Luke Diamand <luke@diamand.org>
    Reviewed-by: Pete Wyckoff <pw@padd.com>
    Signed-off-by: Junio C Hamano <gitster@pobox.com>


={============================================================================
*kt_dev_env_git_150* remote: local, remote master

{list-remotes}
$ git remote -v
bakkdoor  git://github.com/bakkdoor/grit.git
origin    git@github.com:mojombo/grit.git          // means SSH url


{add-delete-rename-remotes}
The shortname is reference to remote.

$ git remote add [shortname] [url]:
$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin  git://github.com/schacon/ticgit.git
pb  git://github.com/paulboone/ticgit.git

$ git remote rename pb paul

$ git remote rm paul


{remote-and-local-master}
The clone command automatically add shortname and sets up your local master branch to track the
remote master branch (or whatever the default branch is called) on the server you cloned from. That
is it creates origin/master.

note:
origin is not a branch but a name(shortname) of a remote repo.

origin/master  : remote master (branch)
master         : local master (branch)


note: remote branch can be any including remote master and is local branch.

The remote branches act as bookmarks to remind you where the branches on your remote repositories
were the 'last' time you connected to them. They take the form "remote/branch" and remote branch is
also 'local' branch but to 'point' to remote.


After clone, your local git looks:

         <origin/master> # remote branch
c1 c2 c3 c4
         <msater>        # local branch


note: remote branch is not updated automatically

In the meantime, someone else pushes to git.ourcompany.com and updates its master branch, then your
histories move forward differently. Also, as long as you stay out of contact with your origin
server, your origin/master pointer doesn't move.

Remote:
c1 c2 c3 c4 c5 c6 c7 c8
                     <msater>

Local:
         <origin/master>            # remote master branch which is still on c4
c1 c2 c3 c4 c9 c10 c11 
                   <msater>         # local master branch


note: fetch updates remote branch

You run a fetch origin command. This command looks up which server origin is and fetches any data
from it that you don't 'yet' have, and updates your local database, moving your origin/master
pointer to its new, more up-to-date position.

$ git fetch origin

Local:
                     <origin/master>   # remote branch
            c5 c6 c7 c8
c1 c2 c3 c4 c8 c9 c10 c11
                      <msater>         # local branch


<branch-head-and-detached-head>
Head is used by your repository to define what is currently checked out:

o If you checkout a branch, head symbolically refers to that branch, indicating that the branch name
should be updated after the next commit operation.

o If you checkout a specific commit, HEAD refers to that commit only. This is referred to as a
detached head and occurs, for example, if you check out a tag name.


={============================================================================
*kt_dev_env_git_151* 


={============================================================================
*kt_dev_env_git_152* remote: fetch and pull 

{fetch}
To get data from your remote projects, pulls down all the data from that remote that you do not have
yet. After that, you can merge in or inspect. 

$ git fetch origin
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (14/14), done.
remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15/15), done.
From git@github.com:schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix

Fetches all the changesets to your 'local' repository and means you can now refer to the changes as
"origin/master" you can operate on it with any 'local' branch. Inspect them and merge to your branch
that you are currently on.

$ git fetch origin                     // get the latest from remote
$ git diff master origin/master        // diff local master and remote
$ git merge origin/master              // merge remote into local master

TODO: is there any way what it would look like when do merge? --no-commit option?


{pull}
If you have a branch set up to track a remote branch, you can use the git pull command to
automatically 'fetch' and then 'merge' a remote branch into your 'current' branch. 

$ git pull
$ git pull origin master
$ git pull origin <branch-name-you-want-to-pull>

note: Generally it's better to simply use the fetch and merge commands explicitly as the magic of
git pull can often be confusing.


{merge}
The fetch brings down new remote branches, you don't automatically have local, editable copies of
them. In other words, in this case, you don't have a new serverfix branch but you only have an
origin/serverfix pointer that you can't modify.

<1>
To merge this work into your 'current' working branch, you can run:

$ git merge origin/serverfix

OR

<2>
To create a seperate serverfix branch(local) that track remote and you can work on, you can base it
off your remote branch:

$ git checkout -b serverfix origin/serverfix

Two things: 'branch' serverfix set up to track remote branch refs/remotes/origin/serverfix.
'switched' to a new branch "serverfix" That is -b means to create a local branch and switch to it.


={============================================================================
*kt_dev_env_git_153* rebase: pull --rebase and workflow

From CH03 Rebase when you rebase.

{peril-of-rebase}
If you pull, create a merge commit. Furthermore, push this back up to the
server, will 'reintroduce' all commits which are dropped and can further confuse
people. This is a problem in figure 3-39.

The advise: Do 'not' rebase commits that you have pushed to a public repository.

When you rebase stuff, you're 'abandoning' existing commits and creating new
ones that are similar but 'different'. If you push commits somewhere and others
pull them down and base work on them, and then you rewrite those commits with
git rebase and push them up again. 
     
THEN your collaborators will have to re-merge their work and things will get
'messy' when you try to pull their work back into yours.

For example, fetch and merge the new remote branch into your work, making your
history look something like this:

local:

C1  <- teamone/master
    \            
      C2  -   C3 <- master

To figure 3-37

remote: 

      C5   
   /      \
C1 <- C4 <- C6    <- master

local:

      C5  
    /    \
C1  - C4  -   C6   <- teamone/master
    \            \
      C2  -   C3  -  C7    <- master

the person who pushed the merged work decides to go back and rebase their work
instead; they do a git push --force to 'overwrite' the history on the server.
You then fetch from that server, bringing down the new commits.

figure 3-38

remote: 

C1 <- C5   <- C4' <- master
          \
     (C4) <- (C6)          // (these) are no longer available

local:

      C5  -   C4'          <- teamone/master
    /    \
C1  - C4  -   C6
    \            \
      C2  -   C3  -  C7    <- master

Now you're both in a pickle. If you do a "git pull", you'll create a merge
commit which includes both lines of history due to C4'. 

If you run a git log when your history looks like this, you'll see two commits
that have the same author, date, and message, which will be confusing.
Furthermore, if you push this history back up to the server, you'll reintroduce
all those rebased commits to the central server, which can further confuse
people. It's pretty safe to assume that the other developer doesn't want C4 and
C6 to be in the history; thats why she rebased in the first place.

<magic>
Git has some further magic that might help you out. If someone on your team
force pushes changes that overwrite work that you've based work on, your
challenge is to *figure out* what is yours and what they've rewritten.

Git can often successfully figure out what is 'uniquely' yours and apply them
back on top of the new branch. For instance, in the previous scenario, if
instead of doing a merge, 

If you run followings (rebase master onto teamone/master) then git figure out
'unique' commits which have not been rewritten into the target branch and apply
them.

git fetch                           // update remote master, teamone/master
git rebase teamone/master           // on master and rebase to teamone/master

remote: 

C1 <- C5   <- C4' <- master
          \
     (C4) <- (C6)      # these are no longer available

local:

      C5  -   C4'          <- teamone/master
    /    \
C1  - C4  -   C6
    \            \
      C2  -   C3  -  C7    <- master

local:

         teamone/master
               |
C1  - C5  -   C4' -  C2'  -   C3'  <- master

note:
After all, this commands get all updates since the last update, update and move
remote master. Then replay changes from master.


{pull-rebase}
You can also simplify this by running a git pull --rebase

For the same example above, suppose you are on master.

git pull --rebase                // on master and replay onto remote/master
                                 
         remote/master
               |
C1  - C5  -   C4' -  C2'  -   C3'  <- master

If you treat rebasing as a way to clean up and work with commits 'before' you push them, and if you
only rebase commits that have 'never' been available publicly, then you'll be fine. 


<why-pull-rebase>
Rebasing is a common way to integrate upstream changes into your local repository. Pulling in
upstream changes with git merge results in a superfluous merge commit every time you want to see how
the project has progressed. 

On the other hand, rebasing is like saying, "want to base (have) my changes 'on' what everybody has
already done."

<pull-rebase-config>
If you are using git pull and want to make --rebase the default, you can set the pull.rebase config
value with something like git config --global pull.rebase true.


{rebase-workflow}
1. Suppose that clone a remote and make a branch to work

-------------------- origin/master
-------------------- master
-------------------- branch


2. The remote udpated by other team members while working on branch.

---------------------------------------- remote/master
-------------------- origin/master
-------------------- master
-------------------- C1 C2 C3 C4 branch


3. Finishes the work and want to base the work on the latest to make sure that the work do not break
or conflict with commits that others already made.


Q: How to base branch on the latest and to verify that the work do not break?


4. Update master and assume no changes on master

---------------------------------------- remote/master
-------------------- origin/master
-------------------- master
-------------------- C1 C2 C3 C4 branch

git checkout branch
git fetch 
git rebase origin/master

or

git checkout branch
git pull --rebase

---------------------------------------- remote/master
-------------------- origin/master
-------------------- master
---------------------------------------- C1 C2 C3 C4 branch


={============================================================================
*kt_dev_env_git_154* git-push

Your local branches aren't automatically synchronized to the remotes you write
to - you have to explicitly push the branches you want to share. That way, you
can use private branches for work you don't want to share, and push up only the
topic branches you want to collaborate on.

To push it upstream.

$ git checkout 

$ // change and make commits

$ git push [remote-name] [branch-name]
$ git push [-all] [<repository> [<refspec>...]]
$ git push origin master

Or to push a local branch which isn't in the remote

The remote (local) branch is automatically created when you 'push' it to the
remote server:

This command works only if you cloned from a server to which you have 'write'
access and if 'nobody' has pushed in the meantime. If you and someone else clone
at the same time and they push upstream and then you push upstream, your push
will rightly be 'rejected'. You'll have to pull down their work first and
incorporate it into yours before you'll be allowed to push. 

<refspec>...

Specify what destination ref to update with what source object. The format of a <refspec> parameter
is an optional plus +, followed by the source object <src>, followed by a colon :, followed by the
destination ref <dst>.

The <src> is often the name of the branch you would want to push, but it can be any arbitrary "SHA-1
expression", such as master~4 or HEAD (see gitrevisions[7]).

The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot
be used here, an actual ref must be named. If git push [<repository>] without any <refspec> argument
is set to update some ref at the destination with <src> with remote.<repository>.push configuration
variable, :<dst> part can be omitted---such a push will update a ref that <src> normally updates
without any <refspec> on the command line. Otherwise, missing :<dst> means to update the 'same' ref
as the <src>.

The object referenced by <src> is used to update the <dst> reference on the remote side. By default
this is only allowed if <dst> is not a tag (annotated or lightweight), and then only if it can
fast-forward <dst>. By having the optional leading +, you can tell Git to update the <dst> ref even
if it is not allowed by default (e.g., it is not a fast-forward.) This does not attempt to merge
<src> into <dst>. See EXAMPLES below for details.

tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>.

Pushing an empty <src> allows you to delete the <dst> ref from the remote repository.
note: ??

The special refspec : (or +: to allow non-fast-forward updates) directs Git to push "matching"
branches: for every branch that exists on the local side, the remote side is updated if a branch of
the same name already exists on the remote side.


workflow
--------
Since the first developer has already pushed, the second isn't allowed to push
because the first has pushed in the meantime.

Although Subversion automatically does such a merge on the server if 'different'
files are edited, in Git you must merge the commits locally. The second has to
fetch the first's changes and merge them in before he will be allowed to push. 

note: this is true even if it is different file.

Got push rejected and do fetch. Then the first's repo looks like:

                        master
CP    <-    C2    <-    C3
                  <-    C4
                        origin/master

$ git checkout master

Update local master with the remote and may happen merge conflict.

$ git merge origin/master          // C5 merge commit 

                                 master
CP    <-    C2    <-    C3    <- C5
                  <-    C4    <-
                        origin/master

The first test his code, commit them and then can push "master" branch to the
remote:

$ git push origin master

                                 master
CP    <-    C2    <-    C3    <- C5
                  <-    C4    <-
                                 origin/master

In the meantime, the second has been working on a topic branch. She's created a
topic branch called issue54 and done three commits on that branch. She hasn't
fetched John's changes yet, so her commit history looks like this:

                  master                           issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                  origin/master

To sync up, she run:

$ git fetch origin

The second's reop looks like:

                  master                           issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                     \  
                  C3    <-    C5                   # C5 points both C4 and C3
                              origin/master


{sync-check-push} determine what is introduced in the remote
The second thinks her topic branch is ready, but she wants to know 'what' she has to merge into her
work so that she can push. She runs git log to find out:

$ git log --no-merges issue54..origin/master       # commits on origin/master but not on issue54

commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
...

Knows that there is one commit to merge.

$ git checkout master

She can merge either origin/master or issue54 first; they're both upstream, so the order doesn't
matter. The end snapshot should be identical no matter which order she chooses; only the history
will be slightly different. She chooses to merge in issue54 first:

$ git merge issue54

No problem since it is FF merge. Now merge in the first's work:

$ git merge origin/master

                                                   issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                     \                                \ master
               <- C3    <-    C5                 <-   C11 
                              origin/master

This is merge with diverge so creates a merge commit, C11.

Now origin/master is 'reachable' from the first's master branch, so she should be able to successfully
push (assuming the first hasn't pushed again in the meantime): 
  
note: reachable means that master becomes upstream of origin/master.

$ git push origin master

                                                   issue54
C1    <- C2    <- C4    <-    C8    <- C9    <-    C10
                     \                                \ master
               <- C3    <-    C5                 <-   C11 
                                                        origin/master


{when-use-working-branch}

--ff-only
Refuse to merge and exit with a non-zero status unless the current HEAD is already up-to-date or the
merge can be resolved as a fast-forward.

--ff
When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge
commit. This is the 'default' behavior.

$ git checkout master
$ git merge --ff-only <review branch>
$ git push origin master


{set-tracking-when-push} when use a local branch that do not come from the remote
-u, --set-upstream
For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used
by argument-less git-pull(1) and other commands. For more information, see branch.<name>.merge in
git-config(1).

$ git push -u origin 14base


<when-push-rejected>
Suppose that already pushed the commit and wanted to change its message. Used --amend and changed
message. When tried to push it again to remote, this will be rejected.

How to solve?

1. If it is safe to push it such as its review purpose so no one is based off, then can use

git push --force or -f origin master

2. Can make a proper commit and push it. However, want to change only message? Is there any way to
make a commit with only message? Use

git commit --allow-empty

This opens an editor to have message and a new commit which has no difference with the parent but
has new message. 


<push-default>
When the command line does not specify where to push with the <repository> argument, it defaults to
origin.

When the command line does not specify what to push with <refspec>... arguments or --all, --mirror,
     --tags options, the command finds the default <refspec> by consulting remote.*.push
     configuration, and if it is not found, honors push.default configuration to decide what to push
     for the meaning of push.default).


push.default

Defines the action git push should take if no refspec is explicitly given. Different values are
well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch
        source is equal to the push destination), upstream is probably what you want. Possible
values are:

o current - push the current branch to update a branch with the same name on the receiving end.
Works in both central and non-central workflows.

o simple - in centralized workflow, work like upstream with an added safety to refuse to push if the
upstream branch's name is different from the local one.

When pushing to a remote that is different from the remote you normally pull from, work as current.
This is the safest option and is suited for beginners.

This mode has become the default in Git 2.0.

git config --global push.default current


{push-as-different-name}
This is a bit of a shortcut. Git automatically expands the serverfix branchname
out to refs/heads/serverfix:refs/heads/serverfix, which means, "Take my
serverfix local branch and push it to update the remote's serverfix branch."

So this means the same thing:

$ git push origin serverfix
$ git push origin serverfix: serverfix

This push a branch as a differnt name:

$ git push origin serverfix:awesomebranch

The next time one of your collaborators fetches from the server, they will get a
reference to where the server's version of serverfix is under the remote branch
origin/serverfix:

<ex>
Use to collaboration using topic branch.

There is a bit of a problem - she needs to push the merged work in her featureB
branch to the featureBee branch on the server. She can do so by specifying the
local branch followed by a colon (:) followed by the remote branch to the git
push command:

$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
fba9af8..cd685d1 featureB -> featureBee

note: why? since the other has already pushed the branch to a server for a issue or task that works
together but I have worked on different branch, so maps them.

This is called a refspec. See "The Refspec" for a more detailed discussion of Git refspecs and
different things you can do with them.


{push-dry}
-n
--dry-run
    Do everything except actually send the updates.

$ git push -n origin kit/DEVARCH-10262:review/DEVARCH-10262
***************************************************************************
NOTICE TO USERS

...
***************************************************************************
To gitolite@git-dev:/DEVARCH
 * [new branch]      kit/DEVARCH-10262 -> review/DEVARCH-10262
 *
$ git push origin kit/DEVARCH-10262:review/DEVARCH-10262
***************************************************************************
NOTICE TO USERS

...
***************************************************************************
Counting objects: 13, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (13/13), 9.53 KiB | 0 bytes/s, done.
Total 13 (delta 11), reused 0 (delta 0)
To gitolite@git-dev:/DEVARCH
 * [new branch]      kit/DEVARCH-10262 -> review/DEVARCH-10262


={============================================================================
*kt_dev_env_git_155* git-push: hook and pre-push check

https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks

8.3 Customizing Git - Git Hooks

Git Hooks

Like many other Version Control Systems, Git has a way to fire off custom
scripts when certain important actions occur. There are two groups of these
hooks: client-side and server-side. Client-side hooks are triggered by
operations such as committing and merging, while server-side hooks run on
network operations such as receiving pushed commits. You can use these hooks for
all sorts of reasons.  


Installing a Hook

The hooks are all stored in the hooks subdirectory of the Git directory. In most
projects, that's .git/hooks. When you initialize a new repository with git init,
Git populates the hooks directory with a bunch of example scripts, many of which
  are useful by themselves; but they also document the input values of each
  script. All the examples are written as shell scripts, with some Perl thrown
  in, but any properly named executable scripts will work fine  you can write
  them in Ruby or Python or what have you. If you want to use the bundled hook
  scripts, you'll have to rename them; their file names all end with .sample.


$ ls .git/hooks/
applypatch-msg.sample      commit-msg.sample          post-update.sample         
pre-applypatch.sample      pre-commit.sample          prepare-commit-msg.sample  
pre-rebase.sample          update.sample


To enable a hook script, put a file in the hooks subdirectory of your Git
directory that is named appropriately and is executable. From that point
forward, it should be called. We'll cover most of the major hook filenames here.


Client-Side Hooks

There are a lot of client-side hooks. This section splits them into
committing-workflow hooks, email-workflow scripts, and everything else.


Committing-Workflow Hooks

The first four hooks have to do with the committing process.

The pre-commit hook is run first, before you even type in a commit message. Its
used to inspect the snapshot thats about to be committed, to see if youve
forgotten something, to make sure tests run, or to examine whatever you need to
inspect in the code. Exiting non-zero from this hook aborts the commit, although
you can bypass it with git commit --no-verify. You can do things like check for
code style (run lint or something equivalent), check for trailing whitespace
(the default hook does exactly this), or check for appropriate documentation on
new methods.

The prepare-commit-msg hook is run before the commit message editor is fired up
but after the default message is created. It lets you edit the default message
before the commit author sees it. This hook takes a few parameters: the path to
the file that holds the commit message so far, the type of commit, and the
commit SHA-1 if this is an amended commit. This hook generally isnt useful for
normal commits; rather, its good for commits where the default message is
auto-generated, such as templated commit messages, merge commits, squashed
commits, and amended commits. You may use it in conjunction with a commit
template to programmatically insert information.

The commit-msg hook takes one parameter, which again is the path to a temporary
file that contains the commit message written by the developer. If this script
exits non-zero, Git aborts the commit process, so you can use it to validate
your project state or commit message before allowing a commit to go through. In
the last section of this chapter, Well demonstrate using this hook to check
that your commit message is conformant to a required pattern.

After the entire commit process is completed, the post-commit hook runs. It
doesnt take any parameters, but you can easily get the last commit by running
git log -1 HEAD. Generally, this script is used for notification or something
similar.


Other Client Hooks

The pre-rebase hook runs before you rebase anything and can halt the process by
exiting non-zero. You can use this hook to disallow rebasing any commits that
have already been pushed. The example pre-rebase hook that Git installs does
this, although it makes some assumptions that may not match with your workflow.

The post-rewrite hook is run by commands that replace commits, such as git
commit --amend and git rebase (though not by git filter-branch). Its single
argument is which command triggered the rewrite, and it receives a list of
rewrites on stdin. This hook has many of the same uses as the post-checkout and
post-merge hooks.

After you run a successful git checkout, the post-checkout hook runs; you can
use it to set up your working directory properly for your project environment.
This may mean moving in large binary files that you dont want source
controlled, auto-generating documentation, or something along those lines.

The post-merge hook runs after a successful merge command. You can use it to
restore data in the working tree that Git cant track, such as permissions data.
This hook can likewise validate the presence of files external to Git control
that you may want copied in when the working tree changes.

The pre-push hook runs during git push, after the remote refs have been updated
but before any objects have been transferred. It receives the name and location
of the remote as parameters, and a list of to-be-updated refs through stdin. You
can use it to validate a set of ref updates before a push occurs (a non-zero
    exit code will abort the push).

Git occasionally does garbage collection as part of its normal operation, by
invoking git gc --auto. The pre-auto-gc hook is invoked just before the garbage
collection takes place, and can be used to notify you that this is happening, or
to abort the collection if now isnt a good time.

note:
However, git hooks are repository specific. How to make it global?

From http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html

Git hooks are repository specific. Some would recommend using a script to
install said hooks into a given repository. But for me, that's too manual. Let's
set up a default set of hooks that Git will use as a template 'when' creating or
cloning a repository (requires Git 1.7.1 or newer):

Note
It's important to note that client-side hooks are not copied when you clone a
repository. If your intent with these scripts is to enforce a policy, you'll
probably want to do that on the server side; see the example in An Example
Git-Enforced Policy.

git config --global init.templatedir '~/.git_template'
mkdir -p ~/.git_template/hooks


TEMPLATE DIRECTORY

The template directory contains files and directories that will be copied to the
$GIT_DIR after it is created.

The template directory will be one of the following (in order):

    the argument given with the --template option;

    the contents of the $GIT_TEMPLATE_DIR environment variable;

    the init.templateDir configuration variable; or

    the default template directory: /usr/share/git-core/templates.

The default template directory includes some directory structure, suggested
"exclude patterns" (see gitignore[5]), and sample hook files (see githooks[5]).

Now onto the first hook, which isn't actually a hook at all, but rather a script
the 'other' hooks will call. Place in .git_template/hooks/ctags and mark as
executable:

#!/bin/sh
set -e
PATH="/usr/local/bin:$PATH"
dir="`git rev-parse --git-dir`"
trap 'rm -f "$dir/$$.tags"' EXIT
git ls-files | \
  ctags --tag-relative -L - -f"$dir/$$.tags" --languages=-javascript,sql
mv "$dir/$$.tags" "$dir/tags"

Making this a separate script makes it easy to invoke .git/hooks/ctags for a
one-off re-index (or git config --global alias.ctags '!.git/hooks/ctags', then
    git ctags), as well as easy to edit for that special case repository that
needs a different set of options to ctags. For example, I might want to
re-enable indexing for JavaScript or SQL files, which Ive disabled here because
Ive found both to be of limited value and noisy in the warning department.

I stick the tags file in .git because if fugitive.vim is installed, Vim will be configured to look for it there automatically, regardless of your current working directory. Plus, you dont need to worry about adding it to .gitignore.

Here come the hooks. Mark all four of them executable and place them in .git_template/hooks. Use this same content for the first three: post-commit, post-merge, and post-checkout (actually my post-checkout hook includes hookup as well).

#!/bin/sh
.git/hooks/ctags >/dev/null 2>&1 &

Ive forked it into the background so that my Git workflow remains as latency-free as possible.

One more hook that oftentimes gets overlooked: post-rewrite. This is fired after git commit --amend and git rebase, but the former is already covered by post-commit. Heres mine:

#!/bin/sh
case "$1" in
  rebase) exec .git/hooks/post-merge ;;
esac

Once you get this all set up, you can use git init in existing repositories to copy these hooks in.

So what does this get you? Any new repositories you create or clone will be immediately indexed with Ctags and set up to re-index every time you check out, commit, merge, or rebase. Basically, youll never have to manually run Ctags on a Git repository again.

={============================================================================
*kt_dev_env_git_156* 


={============================================================================
*kt_dev_env_git_157* remote: branch inspect, show, and ls-remote

{branch} inspect-remote
To show branch

git branch 

--list or no arg
If --list is given, or if there are no non-option arguments, existing branches are listed; the
current branch will be highlighted with an asterisk.

   -r, --remotes
           List or delete (if used with -d) the remote-tracking branches.

   -a, --all
           List both remote-tracking branches and local branches.

$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

$ git branch -r

<vv-option>
This will list out your local branches with more information including what each branch is tracking
and if your local branch is ahead, behind or both.

$ git branch -vv
iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets
master 1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
testing 5ea463a trying something new

So here we can see that our iss53 branch is tracking origin/iss53 and is "ahead" by two, meaning
that we have two commits locally that are not pushed to the server. 

We can also see that our master branch is tracking origin/ master and is up to date. 

Next we can see that our serverfix branch is tracking the server-fix-good branch on our teamone
server and is ahead by three and behind by one, meaning that there is one commit on the server we
haven't merged in yet and three commits locally that we haven't pushed. 

Finally we can see that our testing branch is not tracking any remote branch.


{fetch-all}
It's important to note that these numbers (from -vv option) are only since the last time you fetched
from each server. This command does not reach out to the servers, it's telling you about what it has
cached from these servers locally. If you want totally up to date ahead and behind numbers, you'll
need to fetch from all your remotes right before running this. You could do that like this: 

$ git fetch --all; git branch -vv


{remote-show}
show [shortname]

$ git remote show origin
* remote origin
  URL: git://github.com/schacon/ticgit.git
  Remote branch merged with 'git pull' while on branch master
    master
  Tracked remote branches
    master
    ticgit

<ls-remote>
The ls-remote command returns the SHA1 hash of the latest commit for that reference, so it is quite
easy to parse out and get to the exact commit you need if you're doing some scripting. The --heads
option lists only branch names since the command can list tags too.

$ git ls-remote --heads origin
$ git ls-remote origin 
f7abd1ac44367aff4056b3755e1bdff669aa279b	HEAD
acf12d1ec25a3bf0ed800eda4ad8470d9f4a9f26	refs/heads/14base
5d42e9f6d46160888a5f90729d0bc0285e844d2b	refs/heads/gpi
f7abd1ac44367aff4056b3755e1bdff669aa279b	refs/heads/master


={============================================================================
*kt_dev_env_git_158* remote: push errors. bare

<push-errors-01>
kit@kit-vb:~/mheg-remote-git/mag/mheg$ git push
Counting objects: 19, done.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (11/11), 3.44 KiB | 0 bytes/s, done.
Total 11 (delta 8), reused 0 (delta 0)
remote: error: refusing to update checked out branch: refs/heads/master
remote: error: By default, updating the current branch in a non-bare repository
remote: error: is denied, because it will make the index and work tree inconsistent
remote: error: with what you pushed, and will require 'git reset --hard' to match
remote: error: the work tree to HEAD.
remote: error: 
remote: error: You can set 'receive.denyCurrentBranch' configuration variable to
remote: error: 'ignore' or 'warn' in the remote repository to allow pushing into
remote: error: its current branch; however, this is not recommended unless you
remote: error: arranged to update its work tree to match what you pushed in some
remote: error: other way.
remote: error: 
remote: error: To squelch this message and still keep the default behaviour, set
remote: error: 'receive.denyCurrentBranch' configuration variable to 'refuse'.
To keitee.park@magnum:/dsk1/git/tizen-mheg.git
 ! [remote rejected] master -> master (branch is currently checked out)
error: failed to push some refs to 'keitee.park@magnum:/dsk1/git/tizen-mheg.git'

kit@kit-vb:~/mheg-remote-git/mag/mheg$ git remote -v
origin keitee.park@magnum:/dsk1/git/tizen-mheg.git (fetch)
origin keitee.park@magnum:/dsk1/git/tizen-mheg.git (push)

kit@kit-vb:~/mheg-remote-git/mag/mheg$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

kit@kit-vb:~/mheg-remote-git/mag/mheg$ git remote show origin 
* remote origin
  Fetch URL: keitee.park@magnum:/dsk1/git/tizen-mheg.git
  Push  URL: keitee.park@magnum:/dsk1/git/tizen-mheg.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (fast-forwardable)
kit@kit-vb:~/mheg-remote-git/mag/mheg$ 


Why this happen?

<bare-and-non-bare>
http://bitflop.com/document/111

Git bare vs. non-bare repositories

Posted by: Kim N. Lesmer on 09.10.2010

The Git revision control system has something called a "bare" and a "non-bare" repository. This
article deals with the issue and also compares the Git design to the design of Mercurial and Bazaar.

NB! The article isn't relevant to Git prior to version 1.7.0.

The other day I was working with Git and I got the following error after having tried to push some
changes back to a remote repository that I had created.

remote: error: refusing to update checked out branch: refs/heads/master
remote: error: By default, updating the current branch in a non-bare repository
remote: error: is denied, because it will make the index and work tree inconsistent
remote: error: with what you pushed, and will require 'git reset --hard' to match
remote: error: the work tree to HEAD.
remote: error:
remote: error: You can set 'receive.denyCurrentBranch' configuration variable to
remote: error: 'ignore' or 'warn' in the remote repository to allow pushing into
remote: error: its current branch; however, this is not recommended unless you
remote: error: arranged to update its work tree to match what you pushed in some
remote: error: other way.
remote: error:
remote: error: To squelch this message and still keep the default behaviour, set
remote: error: 'receive.denyCurrentBranch' configuration variable to 'refuse'.

I didn't understand this error and being used to how Mercurial works, this didn't make any sense, so
I did some diggin.

In the ideal world of distributed revision control there is no central repository. People just pull
from whomever they want changes from and no pushes exist. That is actually how the Linux Kernel is
being developed.

In the real world a central repository with push access is sometimes necessary and all the different
distributed revision control systems allows this, but the way they deal with a push are very
different.

In a distributed revision control system you work with a local repository that contains 'both' the
working tree and the revision history.

In Git you can create such a repository with the following command:

$ mkdir my_repo
$ cd my_repo
$ git init

In all three example the working tree resides in the directory itself and the revision history and
system files resides in a hidden sub-directory. People then normally pull changes from eachother.

In Git the hidden sub-directory is called .git, in Bazaar it is called .bzr, and in Mercurial it is
called .hg.

In Mercurial and Bazaar when you initialize a repository it can serve as a remote repository by
default, and anyone with write access to the repository can push changes into it.

In Git that's not possible unless the repository is initialized as a "bare" repository.

<bare-and-non-bare>
A "bare" repository in Git just contains the version control information and no working files (no
    tree) and it doesn't contain the special .git sub-directory. Instead, it contains all the
contents of the .git sub-directory directly in the main directory itself.

A "non-bare" repository in Git is the same as the normal repository in Mercurial and Bazaar. It has
a bunch of working files (the tree), and a hidden directory containing the version control
information.

In Git (from version 1.7.0 and above) the repository has to be "bare" (no working files) in order to
accept a push.

From a technical point of view you can (in theory) push and pull between repositories whether they
are "bare" or not. Git has an index, which basically tells it what the head of the current branch
looks like. If you push to a "non-bare" repository, Git will look at the working files, compare them
to the index, and see that they differ - so it will think that the working files have changed.

"bare" repositories exist in Git as a way of having a central (mainly remote) repository that a
number of people can push to. If you want to transfer changes from a "non-bare" repository to
another, the correct way is to pull from the destination rather than push from the target.

In Git you should only use a "bare" repository to clone and pull from, and push to. It doesn't have
a checked out tree, so it just does what the "server" notionally does in a centralized VCS - records
commits, branches, etc when you push to it, and gives you the latest versions when you clone or pull
from it.

In Mercurial any repository can serve as a remote repository as mentioned, but push changes only
affects the version control and not the working tree unless someone physically access the remote
repository (making it local from his or hers perspective) and updates the tree manually.

So in Git a push isn't possible unless the repository is "bare" (no working files) and in Mercurial
a push is only affecting the version control (not any working files).

In Bazaar on the other hand any repository can serve as a remote repository, and any push changes
also affects the working tree.

From a distributed technical point of view IMHO the Bazaar system is poorly designed and the way
both Git and Mercurial addresses the issue is much safer.

In Git and Mercurial a repository with a working tree is expected to contain files that someone is
working on. It isn't looked upon as a remote repository, but as a local distributed repository no
matter where it resides physically. And this makes perfect sense from a distributed point of view.

In Mercurial if an empty repository is cloned and files are added and then pushed back into the
remote repository then the remote repository will contain no working files (no tree) until and
unless someone updates the repository manually.

If you want a Git repository to function like a remote backup, you have to create the repository as
a "bare" repository. Meaning: Don't insist on having a working tree on your remote backup copy -
only use it as a backup. It is not meant to contain any working files and it will not contain any.

A quick rule of thumb is to never push into a repository that has a work tree attached to it, until
you REALLY know what you are doing no matter what distributed revision control system you are using.

As long as you don't need to physically work on the remote repository then having a working tree
remotely doesn't make sense anyway and you don't need it. And if you do need to work on the remote
repository then pull changes in rather than accept pushes.

Any repository that someone is working on is not something that should receive changes without their
approval since such changes might create problems.

If you want to have Git working as a remote backup repository, you have to create the remote
repository as a bare repository:

$ mkdir my_remote_backup_repo
$ cd my_remote_backup_repo
$ git --bare init

Now you can clone that remote repository and push files back into it, but you wont have a working
tree in the remote location.

Question: How do I turn an existing "non-bare" repository into a "bare" repository in Git (taken
    from the Git wiki)?

Answer: A safe method is to let Git handle all the internal settings for you by doing something like
this:

$ git clone --bare -l non_bare_repo new_bare_repo

Question: How do I do the opposite? (Turn an existing "bare" repository into a "non-bare" repository
    in Git)?

Answer: You just clone it and delete the original.

See http://sitaramc.github.com/concepts/bare.html for futher information on Git bare and non-bare
repositories.

Linus Thorvalds gives a great talk about Git and distributed revision control on Google Talk.

If you have any comments or corrections feel free to email them to me.


<non-bare-remote-repository>

drwxrwxr-x 15 kit kit  4096 Feb 27 11:06 .
drwxrwxr-x  6 kit kit  4096 Feb 27 11:05 ..
-rw-rw-r--  1 kit kit  2921 Feb 27 11:06 CMakeLists.txt
drwxrwxr-x  6 kit kit  4096 Feb 27 11:06 data
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 debug
drwxrwxr-x  8 kit kit  4096 Feb 27 11:07 .git
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 images
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 include
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 mah
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 main
drwxrwxr-x  2 kit kit 24576 Feb 27 11:06 mh5dec
drwxrwxr-x  2 kit kit 16384 Feb 27 11:06 mh5eng
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 mh5gpi
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 mhv
-rwxrwxr-x  1 kit kit   142 Feb 27 11:06 org.tizen.mhegproto.manifest
-rwxrwxr-x  1 kit kit   538 Feb 27 11:06 org.tizen.mhegproto.xml
-rwxrwxr-x  1 kit kit   523 Feb 27 11:06 org.tizen.mhegproto.xml.in
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 packaging
drwxrwxr-x  2 kit kit  4096 Feb 27 11:06 pfm


<bare-remote-repository>

keitee.park@magnum /dsk1/git/tizen-mheg-bare.git
$ ls -al
total 40
drwxrwsr-x  7 keitee.park av 4096 Feb 27 11:04 .
drwxrwsr-x 19 root        av 4096 Feb 27 11:03 ..
drwxrwsr-x  2 keitee.park av 4096 Feb 27 11:04 branches
-rw-rw-r--  1 keitee.park av   66 Feb 27 11:04 config
-rw-rw-r--  1 keitee.park av   73 Feb 27 11:04 description
-rw-rw-r--  1 keitee.park av   23 Feb 27 11:04 HEAD
drwxrwsr-x  2 keitee.park av 4096 Feb 27 11:04 hooks
drwxrwsr-x  2 keitee.park av 4096 Feb 27 11:04 info
drwxrwsr-x  4 keitee.park av 4096 Feb 27 11:04 objects
drwxrwsr-x  4 keitee.park av 4096 Feb 27 11:04 refs

As you can see, there is a working directory and .git folder for non-bare case.


<how-to-use-bare>

1> create bare remote repository.
git clone keitee.park@magnum:/dsk1/git/tizen-mheg-bare.git mag_prev

2> clone it from the remote which has nothing.
3> add files, commit and push.

This is how it looks like when cloned it from bare-case.

kit@kit-vb:~/mheg-remote-git/mag_bare$ git remote -v
origin	keitee.park@magnum:/dsk1/git/tizen-mheg-bare.git (fetch)
origin	keitee.park@magnum:/dsk1/git/tizen-mheg-bare.git (push)

kit@kit-vb:~/mheg-remote-git/mag_bare$ git branch -a
* master
  remotes/origin/master

After have moved to bare-case, push to remote works well.


{push-errors-02}
error: insufficient permission for adding an object to repository database ./objects

The problem is taht there is no problem for team members to clone it and the repo is bare one. But
have got this error. This happens because that the repo was not created to be shared. To do that the
repo should be created:

git --bare init --shared=all 

Or, can change permissons manually on existing repo:

chomd -R g+w <dir>
chmod -R g+s <dir>

$ cat HbbTVTizen.git/config 
[core]
	repositoryformatversion = 0
	filemode = true
	bare = true
	sharedrepository = 2

Looks like that this 'sharedrepository' is the one when created with --shared.

git clone keitee.park@magnum:/dsk1/git/tizen-mheg-shared.git mag_shared


={============================================================================
*kt_dev_env_git_159* remote: pull conflict

{remote-use-scenario}
From home(user one), commited changes to the file. From office(user two), have that file staged
which has changes made before changes made from home. So the user two is out of sync since it is
based on the commit which is now old.

So when uesr two tried 'pull' and then:

:~/keitee/kb$ git pull
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 1 (delta 0)
Unpacking objects: 100% (3/3), done.
From github.com:keitee/kb
   d07bb38..c5e2a81  master     -> origin/master
Updating d07bb38..c5e2a81
error: Your local changes to the following files would be overwritten by merge:~
	kt_dev_02.txt
Please, commit your changes or stash them before you can merge.~
Aborting

:~/keitee/kb$ git status
# On branch master
# Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. ~
#   (use "git pull" to update your local branch)
#
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   kt_dev_01.txt
#	modified:   kt_dev_02.txt
#	modified:   kt_dev_env.txt
#	modified:   kt_linux.txt
#
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#

Made a commit as suggested and then it updated a local repository. By doing pull, do merger to sync
between local and remote. This is safe since git said it is fast forward.

:~/keitee/kb$ git pull
Auto-merging kt_dev_02.txt
(git runs vim to log why merge happens)
Merge made by the 'recursive' strategy.
 kt_dev_02.txt | 280 ++++++++++++++++++++++++++++++++++++++------------------------------
 1 file changed, 153 insertions(+), 127 deletions(-)


={============================================================================
*kt_dev_env_git_200* git-how: how to copy a file from a commit

"checkout -- file" is to checkout file 'out' of the index; to copy to working
directory.

1. From git checkout help

If you want to check out all C source files out of the index, you can say

$ git checkout -- '*.c'

2. From git status message

use "git checkout -- <file>..." to discard changes in working directory)

3. To discard-changes

$ git checkout -- <filename>

4.  To copy a file from the exisiting commit:

git checkout otherbranch myfile.txt

5. To copy a file from the stash:

git checkout stash@{0} -- <filename>
git checkout stash@{0} <filename>         // note: same

6.  note: the current dir and the path should match.

/Polonium.NexusInspect/src$ rm nexus-inspect.c 
/Polonium.NexusInspect/src$ git co stash@{0} Polonium.NexusInspect/src/nexus-inspect.c 
/nexus-inspect.c' did not match any file(s) known to git.
/Polonium.NexusInspect/src$ git co stash@{0} -- Polonium.NexusInspect/src/nexus-inspect.c 
/nexus-inspect.c' did not match any file(s) known to git.
/Polonium.NexusInspect/src$ cd ..
/Polonium.NexusInspect$ cd ..

$ ls
Polonium.NexusInspect
$ git co stash@{0} Polonium.NexusInspect/src/nexus-inspect.c 


={============================================================================
*kt_dev_env_git_201* git-how: how to check if a branch contains a commit

git fetch && git branch -r --contains <commit-id>

With --contains, shows only the branches that contain the named commit (in
        other words, the branches whose tip commits are descendants of the
        named commit). 

Or

git log --grep


={============================================================================
*kt_dev_env_git_300* github: fork projects and pull request

{fork-projects}
If you want to contribute to an existing project to which you do 'not' have push access, you can
"fork" the project. What this means is that GitHub will make a copy of the project that is entirely
yours; it lives in your user's namespace, and you can push to it.

<pull-request> note: from a project owner's POV, it's pull.
This way, projects don't have to worry about adding users as collaborators to give them push access.
People can fork a project, push to it, and contribute their changes back to the original repository
by creating what's called a Pull Request. 

This opens up a discussion thread with code review, and the owner and the contributor can then
communicate about the change 'until' the owner is happy with it, at which point the owner can merge it
in. To fork a project, visit the project page and click the "Fork" button.

When done, you'll be taken to your new project page, with your own 'writeable' copy of the code.


{workflow}
GitHub is designed around a particular collaboration workflow, centered on pull requests and topic
branches workflow.

Here's how it generally works:

0. Clone our fork of the project locally
1. Create a topic branch from master. <pull-request-branch>
2. Make some commits to improve the project.
3. Push this branch to your GitHub project.
4. Open a Pull Request on GitHub.
5. Discuss, and optionally continue committing.
6. The project owner merges or closes the Pull Request.

note: So, pull-request is a code-review process.


{pull-requst-as-patch} but not series of patches
Unlike most mailing list-based projects that think of patch series, most GitHub projects think about
Pull Request 'branches' as iterative conversations around a proposed change, culminating in a
unified diff that is applied by merging.

For instance, as example at Figure 6-15, you'll notice that the contributor did not rebase his
commit and send another Pull Request. Instead they added new commits and pushed them to the existing
'branch'. This way if you go back and look at this Pull Request in the future, you can easily find
all of the context of why decisions were made. Pushing the "Merge" button on the site purposefully
creates a merge commit that references the Pull Request so that it's easy to go back and research
the original conversation if necessary.

note: So works in a branch until the final patch will be made through discussion, making commits and
also has full history. Can think that the review system is integrated with git and possible since
branch is cheap in git.

TODO: continue on KEEPING UP WITH UPSTREAM


# ============================================================================
#{
={============================================================================
*kt_dev_env_tool_001*	eclipse: to create a project from existing source tree 

1. create a c or c++ project depending on type.

2. create a folder. click 'advanced' and select 'link to alternate location(linked
folder)'. specify a directory on nfs or a local folder that has all source tree. this
effectively makes a 'linked folder' to a folder. 

Properties -> C++ General -> Code Analysis or Indexer


==============================================================================
*kt_dev_env_tool_002*	netbean: to create a project from existing source tree 

But without no makefiles and build settings.  

You can try and create an Application project (instead of a Project with Existing sources) and add
your source files to the project. Application projects creates and maintain their own makefiles. 

{code-assistance-and-#ifdef}
Project property -> C/C++ Compiler -> Preprocessor Definitions

{navigation}

https://netbeans.org/kb/docs/cnd/navigating-editing.html

For 7.3:

Ctrl-b 	 							Go to declaration/definition
Ctrl-Alt-b 	 						Go to overide/overridden
Alt-Left/Alt-Right/Ctrl-Q 		Go backward/forward/to last edit

Alt-F7 								Find usages

Ctrl-G 			Go to line
Alt-Shift-C 	Go to declaration
Ctrl-F9 			Evaluate expression

Finding, Searching, and Replacing

Ctrl-F3 		Search word at insert point
F3/Shift-F3 Find next/previous in file
Alt-Shift-U Find usages results
Alt-Shift-H Turn off search result highlights
Ctrl-I 		Jump to quick search field
Alt-Shift-L Copy file path

Navigating through Source Code

Ctrl-O/Alt-Shift-O 				Go to type/file
Alt-O 								Go to source
Ctrl-Shift-M 						Toggle add/remove bookmark
Ctrl-Shift-Period / Comma 		Next/previous bookmark
Ctrl-Period / Comma 				Next/previous usage/compile error
Alt-Shift-Period / Comma		Select next/previous element
Ctrl-Shift-1/2/3 					Select in Projects/Files/Favorites
Ctrl-[ 								Move caret to matching bracket
Ctrl-K/Ctrl-Shift K 				Next/previous word match
Alt Up / Down 						Next/previous marked occurrence


{jdk-path}

Error is:
"Cannot locate java installation in specified jdkhome C:\Program Files (x86)\Java\jdk1.6.0_25
Do you want to try to use default version ?"

Change this file:
C:\Program Files\NetBeans 7.x\etc\netbeans.conf

# Default location of JDK:
# (set by installer or commented out if launcher should decide)
#
# It can be overridden on command line by using --jdkhome <dir>
# Be careful when changing jdkhome.
# There are two NetBeans launchers for Windows (32-bit and 64-bit) and
# installer points to one of those in the NetBeans application shortcut 
# based on the Java version selected at installation time.
#
netbeans_jdkhome="C:\Program Files\Java\jre7"


==============================================================================
*kt_dev_env_tool_003*	total commander short cut

# search
#
CTRL+SHIFT+S Open Quick Filter dialog and reactivate last-used filter

# tab
#
CTRL+T Open new folder tab and activate it
CTRL+SHIFT+T Open new folder tab, but do not activate it
CTRL+U Exchange directories
CTRL+SHIFT+U Exchange directories and tabs
CTRL+V Paste from clipboard to current dir.

# drive
#
ALT+F1 change left drive
ALT+F2 change right drive

ALT+SHIFT+F5 Move to archive
SHIFT+F2 Compare file lists


F2 Reread source window
F3 List files
F4 Edit files
F5 Copy files
F6 Rename or move files
F7 Create directory
F8 or DEL Delete files to recycle bin /delete directly - according to configuration
F9 Activate menu above source window (left or right)

ALT+F3 Use alternate (external or internal) viewer
ALT+SHIFT+F3 Start Lister and load file with internal viewer (no plugins or multimedia)
ALT+F4 Exit | Minimize (with option MinimizeOnClose in wincmd.ini)
ALT+F5 Pack files
ALT+F6 Unpack specified files from archive under cursor, or selected archives (use Alt+F9 on Windows 95)
ALT+F7 Find
ALT+F8 Opens the history list of the command line
ALT+F9 Same as ALT+F6 (because ALT+F6 is broken on Windows 95)
ALT+SHIFT+F9 Test archives
ALT+F10 Opens a dialog box with the current directory tree
ALT+F11 Opens left current directory bar (breadcrumb bar)
ALT+F12 Opens right current directory bar (breadcrumb bar)
ALT+SHIFT+F11 Focus the button bar to use it with the keyboard
SHIFT+F1 Custom columns view menu
SHIFT+F3 List only file under cursor, when multiple files selected
SHIFT+F4 Create new text file and load into editor
SHIFT+F5 Copy files (with rename) in the same directory
SHIFT+CTRL+F5 Create shortcuts of the selected files
SHIFT+F6 Rename files in the same directory
SHIFT+F8/DEL Delete directly / delete to recycle bin - according to configuration
SHIFT+F10 Show context menu
SHIFT+ESC Minimizes Total Commander to an icon
ALT+left/right Go to previous/next dir of already visited dirs
ALT+down Open history list of already visited dirs (like the history list in a WWW browser)
NUM + expand selection (configurable: just files or files and folders)
NUM - shrink selection
NUM * invert selection (also with shift, see link)
NUM / restore selection
SHIFT+NUM + Like NUM +, but files and folders if NUM + selects just files (and vice versa)
SHIFT+NUM - Always removes the selection just from files (NUM - from files and folders)
SHIFT+NUM * Like NUM *, but files and folders if NUM * inverts selection of just files (and vice versa)
CTRL+NUM + select all (configurable: just files or files and folders)
CTRL+SHIFT+NUM +
select all (files and folders if CTRL+NUM + selects only files)
CTRL+NUM - deselect all (always files and folders)
CTRL+SHIFT+NUM -
deselect all (always files, no folders)
ALT+NUM + select all files with the same extension
ALT+NUM - remove selection from files with the same extension
CTRL+PgUp
or Backspace Change to parent directory (cd ..)
CTRL+< Jump to the root directory (most European keyboards)
CTRL+\ Jump to the root directory (US keyboard)
CTRL+PgDn Open directory/archive (also self extracting .EXE archives)
CTRL+left/right Open directory/archive and display it in the target window. If the cursor is not on a directory name, or the other panel is active, then the current directory is displayed instead.
CTRL+F1 File display 'brief' (only file names)
CTRL+SHIFT+F1 Thumbnails view (preview pictures)
CTRL+F2 File display 'full' (all file details)
CTRL+SHIFT+F2 Comments view (new comments are created with Ctrl+Z)
CTRL+F3 Sort by name
CTRL+F4 Sort by extension
CTRL+F5 Sort by date/time
CTRL+F6 Sort by size
CTRL+F7 Unsorted
CTRL+F8 Display directory tree
CTRL+SHIFT+F8 Cycle through separate directory tree states: one tree, two trees, off
CTRL+F9 Print file under cursor using the associated program
CTRL+F10 Show all files
CTRL+F11 Show only programs
CTRL+F12 Show user defined files
TAB Switch between left and right file list
SHIFT+TAB Switch between current file list and separate tree (if enabled)
Letter Redirect to command line, cursor jumps to command line
INSERT Select file or directory.
SPACE Select file or directory (as INSERT). If SPACE is used on an unselected directory under the cursor, the contents in this directory are counted and the size is shown in the "full" view instead of the string <DIR>. This can be disabled through 'Configuration' - 'Options' - 'Operation' - 'Selection with Space'.
ENTER Change directory / run program / run associated program / execute command line if not empty. If the source directory shows the contents of an archive, further information on the packed file is given.
SHIFT+ENTER 1. Runs command line / program under cursor with preceding command /c and leave the program's window open. Only works if NOCLOSE.EXE is in the Total Commander directory!
2. With ZIP files: use alternative choice of these (as chosen in Packer config): (Treat archives like directories <-> call associated program, i.e. winzip or quinzip)
3. In the list of last used dirs (History, Ctrl+D), open the directory on a new Tab.
ALT+SHIFT+ENTER
The contents of all directories in the current directory are counted. The sizes of the directories are then shown in the "full" view instead of the string <DIR>. Abort by holding down ESC key.
ALT+ENTER Show property sheet.
CTRL+A select all
CTRL+B Directory branch: Show contents of current dir and all subdirs in one list
CTRL+SHIFT+B Selected directory branch: Show selected files, and all in selected subdirs
CTRL+C Copy files to clipboard
CTRL+D Open directory hotlist ('bookmarks')
CTRL+F Connect to FTP server
CTRL+SHIFT+F Disconnect from FTP server
CTRL+I Switch to target directory
CTRL+L Calculate occupied space (of the selected files)
CTRL+M Multi-Rename-Tool
CTRL+SHIFT+M Change FTP transfer mode
CTRL+N New FTP connection (enter URL or host address)
CTRL+P Copy current path to command line
CTRL+Q Quick view panel instead of file window
CTRL+R Reread source directory
CTRL+S Open Quick Filter dialog and activate filter (deactivate with ESC or CTRL+F10)


CTRL+W Close currently active tab
CTRL+SHIFT+W Close all open tabs
CTRL+X Cut files to clipboard
CTRL+Z Edit file comment
CTRL+UP Open dir under cursor in new tab
CTRL+SHIFT+UP Open dir under cursor in other window (new tab)
CTRL+TAB Jump to next tab
CTRL+SHIFT+TAB
Jump to previous tab
 
ALTGR+Letter(s) or
CTRL+ALT+Letter(s)
Quick search for a file name (starting with specified letters) in the current directory
(Support hotkeys Ctrl+X, Ctrl+C, Ctrl+V and Ctrl+A; use Ctrl+S for search filter on/off)
 
Other keys: See command line


==============================================================================
*kt_dev_env_tool_004*	outlook keys

Switch to Inbox.
 CTRL+SHIFT+I
 
Switch to Outbox.
 CTRL+SHIFT+O
 
Choose the account from which to send a message.
 CTRL+TAB (with focus on the To box) and then TAB to the Accounts button
 
Check names.
 CTRL+K
 
Send.
 ALT+S
 
Reply to a message.  CTRL+R 
 
Reply all to a message.  CTRL+SHIFT+R ~
 
Forward a message.
 CTRL+F
 
Mark a message as not junk.
 CTRL+ ALT+J
 
Display blocked external content (in a message).
 CTRL+SHIFT+I
 
Post to a folder.
 CTRL+ SHIFT+S
 
Apply Normal style.
 CTRL+SHIFT+N
 
Check for new messages.
 CTRL+M or F9
 
Go to the previous message.
 UP ARROW
 
Go to the next message.
 DOWN ARROW
 
Create a new message (when in Mail).
 CTRL+N
 
Create a new message (from any Outlook view).
 CTRL+SHIFT+M
 
Open a received message.
 CTRL+O
 
Open the Address Book.
 CTRL+SHIFT+B
 
Convert an HTML or RTF message to plain text.
 CTRL+SHIFT+O
 
Add a Quick Flag to an unopened message.
 INSERT
 
Display the Flag for Follow Up dialog box.
 CTRL+SHIFT+G
 
Mark as read.
 CTRL+Q
 
Mark as unread.
 CTRL+U
 
Show the menu to download pictures, change automatic download settings, or add a sender to the Safe Senders List.
 CTRL+SHIFT+W
 
Find or replace.
 F4
 
Find next.
 SHIFT+F4
 
Send.
 CTRL+ENTER
 
Print.
 CTRL+P
 
Forward.
 CTRL+F
 
Forward as attachment.
 CTRL+ALT+F
 
Show the properties for the selected item.
 ALT+ENTER
 
  
Mark for Download.
 CTRL+ALT+M
 
Clear Mark for Download.
 CTRL+ALT+U
 
Display Send/Receive progress.
 CTRL+B (when a Send/Receive is in progress)
 

==============================================================================
*kt_dev_env_tool_005*	ms-project: set delay

http://office.microsoft.com/en-001/project-help/delay-a-task-HP045308316.aspx

Add delay to an assignment

On the View menu, click More Views, click Resource Allocation, and then click Apply.

The Resource Allocation view is a combination of the Resource Usage view (on the top) and the Detail
Gantt view (on the bottom).

    In the Resource Usage portion of the view, click the resource or assignment for which you want
    to examine slack and possibly delay.  Click the Detail Gantt portion of the view.  On the View
    menu, point to Table, and then click Schedule.  To make sure you don't delay any other tasks or
    the project finish date, review available slack before adding delay. In the Detail Gantt portion
    of the view, press TAB until the Free Slack and Total Slack fields are visible, and then review
    them to find tasks that have slack.

Slack is also shown graphically as thin bars adjoining the regular Gantt bar.

    In the Resource Usage portion of the view, click the field to the right of where you want to
    insert the Assignment Delay field.  On the Insert menu, click Column.  In the Field name box,
    click Assignment Delay, and then click OK.  In the Assignment Delay field for the assignment you
    want to delay, type or select the amount of time you want to delay the assignment.

This indicates how much time after the task's start date the resource is to wait before starting
work on this assignment.

 Notes 

    If the task is linked, delaying one of its assignments might change the scheduling of any
    successor tasks, which can affect the finish date of your project. It's best to delay
    assignments on tasks with free slack first, and delay them only up to the amount of available
    slack.  You can add delay to a task or assignment, check the effect on the resource allocation,
    and then adjust the delay further if necessary. If you want to add delay without changing the
    finish date of other tasks or the project finish date, review available slack and add delay only
    within that time. Note that leveling can automatically delay tasks or assignments. Resource
    leveling considers all resources with assignments in the project, and is generally preferable to
    manually delaying tasks.


={============================================================================
*kt_dev_env_tool_006* firefox short cuts

https://support.mozilla.org/en-US/kb/keyboard-shortcuts-perform-firefox-tasks-quickly#w_search

{search}
Find                 Ctrl + F
Find Again           F3 Ctrl + G
Find Previous        Shift + F3 Ctrl + Shift + G
Quick Find within link-text only '
Quick Find                       /
Close the Find or Quick Find bar Esc - when the Find or Quick Find bar is focused 


={============================================================================
*kt_dev_env_tool_007* eclipse: basics

1. C+ mouse click on variables     
will have to options; open declaration and open declaration type.

2. C+o
To see methods in the current file.

3. C+S+T
To search types. Can use pattern and PEC for PlayerEventCA

4. C+T
To list all classes which implemented this interface.

5. C+S+U, C+S+G
To search a function in the current file and C+S+G for global.



==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
