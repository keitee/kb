*kt_dev_qt*                                                                tw=100

kt.dev.qt

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_qt_0001| qt-book
|kt_dev_qt_0001| qt-install
|kt_dev_qt_0001| qt-tutorial
|kt_dev_qt_0001| qt-event
|kt_dev_qt_0001| qt-qenum
|kt_dev_qt_0001| qt-logging
|kt_dev_qt_0001| qt-meta-object
|kt_dev_qt_0001| qt-slot qt-thread
|kt_dev_qt_0001| qt-property
|kt_dev_qt_0001| qt-dbus
|kt_dev_qt_0001| qt-creator-command
|kt_dev_qt_0001| qt-creator-project
|kt_dev_qt_0001| qt-edit-navigate
|kt_dev_qt_0001| qt-edit-encoding
|kt_dev_qt_0001| qt-edit-view


={============================================================================
|kt_dev_qt_0001| qt-book

http://wiki.qt.io/Books

Learning Qt 5 (Video)
Authors: Symeon Huang
Publish: April 2017
ISBN: 978-1787285972

An easy to follow, example-based, comprehensive introduction to all the major
features in Qt Available from Packt


={============================================================================
|kt_dev_qt_0001| qt-install

https://wiki.qt.io/Install_Qt_5_on_Ubuntu

Adjust permission, run the installer and follow the instruction to complete
the installation.

chmod +x qt-opensource-linux-x64-5.7.0.run
./qt-opensource-linux-x64-5.7.0.run

this will show up a dialog of online installation

http://doc.qt.io/qt-5/linux.html
Requirements for Development Host

The Qt installers for Linux assume that a C++ compiler, debugger, make, and
other development tools are provided by the host operating system. In
addition, building graphical Qt applications requires OpenGL libraries and
headers installed. Most Linux distributions do not install all of these by
default, but setting up a development environment is still straightforward.

Use the following commands to install the basic requirements for building Qt
applications:

note:
if there is no libgl1-mesa-dev, then see build errors

sudo apt-get install build-essential libgl1-mesa-dev


={============================================================================
|kt_dev_qt_0001| qt-tutorial

https://wiki.qt.io/Qt_for_Beginners

<attribute-or-property> *qt-property*

Qt extends this system of attributes and getters and setters to something called
property. A property is a value of any type that can be accessed, be modified or
constant, and can notify a change. The property system is useful, especially in
the third part (QML). For now, we will use "attribute" or "property" to do the
same thing.


<qt-object> *qt-parent*

QObject is the most basic class in Qt. Most of classes in Qt inherit from this
class. QObject provides some very powerful capabilities like:

o object name : you can set a name, as a string, to an object and search for
  objects by names.

o parenting system (described in the following section)

o signals and slots (described in the next chapter)

o event management


Parenting system

Parenting system is a convenient way of dealing with objects in Qt, especially
widgets. Any object that inherits from QObject can have a parent and children.
This hierarchy tree makes many things convenient:

o When an object is destroyed, all of its children are destroyed as well. So,
  calling delete becomes optional in certain cases.

o All QObjects have findChild and findChildren methods that can be used to
  search for children of a given object.

o Child widgets in a QWidget automatically appear inside the parent widget.


<tut-01>

main.cpp:

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  QPushButton button(" Hello Qt Widget");

  // o The following snippet that creates a QPushButton inside a QPushButton:
  // o button(parent) <- button2(child)
  // o button2 is on `top` of button

  QPushButton button2(" Other", &button);

  button.setToolTip(" Hello Tootip");

  QFont font("Hack");
  button.setFont(font);

  button.setIcon(QIcon::fromTheme("face-smile"));

  button.show();

  return a.exec();
}


<tut-02>

main.cpp:

#include "mainwindow.h"
#include <QApplication>
#include <QPushButton>

/*

Project Type: Qt Widgets Application

Creates a Qt application for the desktop. Includes a Qt Designer-based main
window.

Preselects a desktop Qt for building the application if available.

The following code is used to display a button inside a MainWindow:

Unlike Tutorial 1, uses `MainWindow` which has window `panel` and add a button to
it. 

*/

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    MainWindow w;

    QPushButton *button = new QPushButton("Hello Qt Tutorial 2", &w);
    button->setGeometry(20, 20, 180, 30);

    w.show();

    return a.exec();
}


<tut-06>

#ifndef WINDOW_H
#define WINDOW_H

#include <QWidget>
#include <QPushButton>
#include <QKeyEvent>

namespace Ui {
class Window;
}

class Window : public QWidget
{
    Q_OBJECT

public:
    explicit Window(QWidget *parent = nullptr);
    ~Window();

protected:
    virtual void keyPressEvent(QKeyEvent *event) override;
    virtual bool event(QEvent *e) override;
    virtual void mousePressEvent(QMouseEvent *event) override;
    virtual void customEvent(QEvent *event) override;

// private slots:
//   void slotButtonClicked(bool checked);

private:
    Ui::Window *ui;
    QPushButton *m_button;
};

#endif // WINDOW_H


window.cpp:


={============================================================================
|kt_dev_qt_0001| qt-event

<qt-event>

https://doc.qt.io/qt-5/qevent.html

Detailed Description

The QEvent class is the base class of all event classes. Event objects contain
event parameters.

*qt-mainloop*

Qt's main event loop (QCoreApplication::exec()) fetches native window system
events `from the event queue`, translates them into QEvents, and sends the
translated events to QObjects.

In general, events come from the underlying window system (spontaneous() returns
true), but it is also possible to manually send events using
QCoreApplication::sendEvent() and QCoreApplication::postEvent() (spontaneous()
returns false).

`QObjects receive events by having their QObject::event() function called.` The
function can be reimplemented in subclasses to customize event handling and add
additional event types; QWidget::event() is a notable example. By default,
events are dispatched to event handlers like QObject::timerEvent() and
QWidget::mouseMoveEvent(). QObject::installEventFilter() allows an object to
intercept events destined for another object.

The basic QEvent contains only an event type parameter and an "accept" flag. The
accept flag set with accept(), and cleared with ignore(). It is set by default,
but don't rely on this as subclasses may choose to clear it in their
constructor.


Qt/5.12.3/Src/qtbase/src/corelib/kernel/qeventloop.cpp

// Src/qtbase/src/corelib/thread/qthread.cpp

/*!
    Enters the event loop and waits until exit() is called, returning the value
    that was passed to exit(). The value returned is 0 if exit() is called via
    quit().

    This function is meant to be called from within run(). It is necessary to
    call this function to start event handling.

    \sa quit(), exit()
*/
int QThread::exec()
{
  Q_D(QThread);
  QMutexLocker locker(&d->mutex);
  d->data->quitNow = false;
  if (d->exited) {
    d->exited = false;
    return d->returnCode;
  }
  locker.unlock();

  QEventLoop eventLoop;
  int returnCode = eventLoop.exec();

  locker.relock();
  d->exited = false;
  d->returnCode = -1;
  return returnCode;
}


https://doc.qt.io/archives/qq/qq11-events.html

The Origins of Events

Events can be divided into three categories based on how they are created and
how they are dispatched:

o Spontaneous events are generated by the window system. They are put in a
  system queue and processed one after the other by the event loop.

*qt-event-postevent*
o Posted events are generated by Qt or by the application. They are queued by
  Qt and `processed by the event loop.`

  void QCoreApplication::postEvent(QObject *receiver, QEvent *event, 
      int priority = Qt::NormalEventPriority)

*qt-event-sendevent*
o Sent events are generated by Qt or by the application, but they are sent
  `directly to the target object.`

  bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event);


<qt-event-loop>

When we call QApplication::exec() at the end of our main() function, the
application enters Qt's event loop. Conceptually, the event loop looks like
this:

    while (!exit_was_called) {
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
        while (!spontaneous_event_queue_is_empty) {
            process_next_spontaneous_event();
        }
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
    }
    
First, the event loop processes any posted events until the queue is empty.
Then, it processes the spontaneous events until there are none left. Finally, it
processes any posted events that were generated during the processing of the
spontaneous events.

*qt-event-sendevent*
Sent events are not handled by the event loop. They are delivered directly to
the object.

Let's see how this works in practice with paint events. When a widget is made
visible for the first time, or when it's made visible after being obscured, the
window system generates a (spontaneous) paint event to ask the program to redraw
the widget. The event loop eventually picks up the event and dispatches it to
the widget that needs to be redrawn.

Not all paint events are generated by the window system. When you call
QWidget::update() to redraw a widget, the widget posts a paint event to itself.
The paint event is queued and eventually dispatched by the event loop.

If you're impatient and can't wait for the event loop to redraw a widget, you
could in theory call paintEvent() directly to force an immediate repaint. But in
practice this isn't always possible because paintEvent() is a protected
function. This would also bypass any existing event filter. For that reason, Qt
provides a mechanism for sending events directly rather than posting them.
QWidget::repaint() uses this mechanism to force an immediate repaint.

One advantage of posting events as opposed to sending them is that posting gives
Qt the opportunity `to compress them.` If you call update() ten times in
succession on the same widget without returning to the event loop, the ten
events generated by update() will automatically be merged into a single event
with the union of the regions specified in all their QPaintEvents. Compressible
event types include paint events, move events, resize events, layout hint
events, and language change events.

Finally, note that you can call QApplication::sendPostedEvents() at any time to
force Qt to process an object's posted events at the time of the call.


Event Handling and Filtering

Events in Qt can be processed on five different levels.

o Reimplementing a specific event handler. 
QObject and QWidget provide many specific event handlers for different types of
events (for example, paintEvent() for paint events).

o Reimplementing QObject::event(). 
The event() function is the entry point for all of an object's events. The
default implementations in QObject and QWidget simply forward the events to the
specific event handlers.

o Installing an event filter on a QObject.
An event filter is an object that receives another object's events before they
reach the intended target.

o Installing an event filter on qApp.
Exceptionally, an event filter on qApp monitors all events sent to all objects
in the application.

o Reimplementing QApplication::notify().
Qt's event loop and sendEvent() call this function to dispatch events to
receiver. By reimplementing it, you get to see events before anybody else.


Some event types can be `propagated`. This means that if a target doesn't handle
an event, Qt tries to find another receiver for the event and calls
QApplication::notify() with the new target. For example, key events are
propagated; if the widget that has the focus doesn't handle a certain key, Qt
dispatches the same event to the parent widget, then to the parent's parent, and
so on `until it reaches the top-level widget.`


keyPressEvent() is called whenever a key is pressed, and again when a key has
been held down long enough for it to auto-repeat. The Tab and Shift+Tab keys are
only passed to the widget if they are not used by the focus-change mechanisms.
To force those keys to be processed by your widget, you must reimplement
QWidget::event().


https://doc.qt.io/qt-5/qwidget.html#keyPressEvent

void QWidget::keyPressEvent(QKeyEvent *event)

This event handler, for event event, can be reimplemented in a subclass to
receive key press events for the widget.

A widget must call setFocusPolicy() to accept focus initially and have focus in
order to receive a key press event.

If you reimplement this handler, it is very important that you call the base
class implementation if you do not act upon the key.

The default implementation closes popup widgets if the user presses the key
sequence for QKeySequence::Cancel (typically the Escape key). Otherwise the
event is ignored, so that the widget's parent can interpret it.

Note that QKeyEvent starts with isAccepted() == true, so you do not need to call
QKeyEvent::accept() - just do not call the base class implementation if you act
upon the key.

See also keyReleaseEvent(), setFocusPolicy(), focusInEvent(), focusOutEvent(),
event(), QKeyEvent, and Tetrix Example.


https://doc.qt.io/archives/qq/qq11-events.html

Accept or Ignore?

Events that can be propagated have an accept() and an ignore() function that you
can call to tell Qt that you "accept" or "ignore" the event. If an event handler
calls accept() on an event, the event won't be propagated further; if an event
handler calls ignore(), Qt tries to find another receiver.

If you're like most Qt developers, you probably never really bothered calling
accept() and ignore() in your programs. And rightly so. Qt is designed in such a
way that you `normally never need to call them.` The default value is "accept",
and the default event handler implementations in QWidget call ignore(). 
  
If you want to accept the event, you just need to reimplement the event
handler and avoid calling the QWidget implementation. If you want to ignore
the event, simply pass it on to the QWidget implementation. The following code
snippet illustrates the point:

    void MyFancyWidget::keyPressEvent(QKeyEvent *event)
    {
        if (event->key() == Key_Escape) {
            doEscape();
        } else {
            QWidget::keyPressEvent(event);
        }
    }
    
In this example, if the user presses Esc, we call doEscape() and the event is
accepted (the default). The event won't be propagated to the parent widget. If
the user presses any other key, we call QWidget's default implementation:

    void QWidget::keyPressEvent(QKeyEvent *event)
    {
        event->ignore();
    }
    
Thanks to the ignore() call, the event will be propagated to the parent widget.

void Window::keyPressEvent(QKeyEvent *event)
{
  if (event->key() == Qt::Key_Escape)
  {
    // it will output to Qt Editor output window
    std::cout << "keyPressEvent:Key_Esacpe" << std::endl;
  }
}


If for some reason you handle the event in event() instead of in a specific
handler such as keyPressEvent(), the procedure is somewhat different. The
event() function returns a bool that tells the caller whether the event was
accepted or not (true means "accept"). 

Calling accept() or ignore() on an event from event() is pointless. The "accept"
flag is a communication mechanism between the specific event handlers and
event(), whereas the bool return value of event() is used to communicate with
QApplication::notify(). The default event() implementation in QWidget converts
the "accept" flag into a bool as follows:

    bool QWidget::event(QEvent *event)
    {
        switch (e->type()) {
        case QEvent::KeyPress:
            keyPressEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
        case QEvent::KeyRelease:
            keyReleaseEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
            ...
        }
        return true;
    }

https://doc.qt.io/qt-5/qobject.html#event

bool QObject::event(QEvent *e)

This virtual function receives events to an object and should return true if the
event e was recognized and processed.

The event() function can be reimplemented to customize the behavior of an
object.

Make sure you call the parent event class implementation for all the events you
did not handle.

Example:

class MyClass : public QWidget
{
    Q_OBJECT

public:
    MyClass(QWidget *parent = 0);
    ~MyClass();

    bool event(QEvent* ev) override
    {
        if (ev->type() == QEvent::PolishRequest) {
            // overwrite handling of PolishRequest if any
            doThings();
            return true;
        } else  if (ev->type() == QEvent::Show) {
            // complement handling of Show if any
            doThings2();
            QWidget::event(ev);
            return true;
        }
        // Make sure the rest of events are handled
        return QWidget::event(ev);
    }
};

*/

bool Window::event(QEvent *e)
{
  // if (event->key() == Qt::Key_Escape)
  {
    // it will output to Qt Editor output window
    // std::cout << "Window::event: " << std::endl;
  }
  // Make sure the rest of events are handled
  return QWidget::event(e);
}


/*
note: it's on "Window"

Synthetic Events

Qt applications can generate their own events, either of predefined types or of
custom types. This is done by creating an instance of QEvent (or a subclass) and
calling QApplication::postEvent() or QApplication::sendEvent().

Both functions take a QObject * and a QEvent * as arguments. If you call
postEvent(), you must create the event object using new and Qt will
automatically delete it after it is processed. If you call sendEvent(), you must
create the event on the stack. Here's an example of posting an event:

    QApplication::postEvent(mainWin, 
      new QKeyEvent(QEvent::KeyPress, Key_X, 'X', 0));
    
Here's an example of sending an event:

    QKeyEvent event(QEvent::KeyPress, Key_X, 'X', 0);
    QApplication::sendEvent(mainWin, &event);
    
Qt applications rarely need to call postEvent() or sendEvent() directly because
most events are generated automatically by Qt or by the window system when
necessary. In most of the cases where you want to send an event, Qt includes a
high-level function that does it for you (for example, update() and repaint()).


https://doc.qt.io/qt-5/qcoreapplication.html#postEvent

static
void QWidget::mouseReleaseEvent(QMouseEvent *event)

This event handler, for event event, can be reimplemented in a subclass to
receive mouse release events for the widget.

void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority = Qt::NormalEventPriority)

Adds the event event, with the object receiver as the receiver of the event, to
an event queue and returns immediately.

note: "The event must be allocated on the heap" 

since the post event queue will take ownership of the event and delete it once
it has been posted. It is not safe to access the event after it has been posted.

When control returns to the main event loop, all events that are stored in the
queue will be sent using the notify() function.

Events are sorted in descending priority order, i.e. events with a high priority
are queued before events with a lower priority. The priority can be any integer
value, i.e. between INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for
more details. Events with equal priority will be processed in the order posted.

*/

void Window::mousePressEvent(QMouseEvent *event)
{
  {
    std::cout << "Window::mousePressEvent: post key event" << std::endl;
    QApplication::postEvent(this, 
        new QKeyEvent(QEvent::KeyPress, Qt::Key_Escape, 0, 0));
  }

  {
    std::cout << "Window::mousePressEvent: post custom event" << std::endl;
    const QEvent::Type MyEvent = (QEvent::Type)1234;
    QApplication::postEvent(this, new QEvent(MyEvent));
  }
}

*qt-event-custom*
Custom Event Types

Qt lets you create your own event types. This technique is particularly useful
in multithreaded applications, as a means of communicating with the GUI thread;
see Chapter 17 of C++ GUI Programming with Qt 3 (p. 359) for an example.

Custom types can also be useful in single-threaded applications, as an
inter-object communication mechanism. 

The main reason why you would use events rather than standard "function calls,
or signals and slots", 
   
`is that events can be used both synchronously and asynchronously` (depending
    on whether you call sendEvent() or postEvents()), *qt-slot* whereas
calling a function or `invoking a slot is always synchronous.` 

Another advantage of events is that they can be filtered.  More on this in the
next section.

Here's a code snippet that shows how to post a custom event:

    const QEvent::Type MyEvent = (QEvent::Type)1234;
    ...
    QApplication::postEvent(obj, new QCustomEvent(MyEvent));
    
The event must be of type QCustomEvent (or a subclass). The argument to the
constructor is the type of event. Values under 1024 are reserved by Qt for
predefined event types; other values can be used by applications.

`To handle custom event types, reimplement the customEvent() function`:

    void MyLineEdit::customEvent(QCustomEvent *event)
    {
        if (event->type() == MyEvent) {
            myEvent();
        } else {
            QLineEdit::customEvent(event);
        }
    }


https://doc.qt.io/qt-5/qobject.html#customEvent

[virtual protected]
void QObject::customEvent(QEvent *event)

This event handler can be reimplemented in a subclass `to receive custom events.`

Custom events are user-defined events with a type value at least as large as the
QEvent::User item of the QEvent::Type enum, and is typically a QEvent subclass.
The event is passed in the event parameter.

See also event() and QEvent.


void Window::customEvent(QEvent *event)
{
  if (event->type() == ((QEvent::Type)1234))
  {
    std::cout << "Window::customEvent: got custom event" << std::endl;
  }
}

Window::~Window()
{
  delete ui;
}


={============================================================================
|kt_dev_qt_0001| qt-qenum

https://qml.guide/enums-in-qt-qml/

class StateMachine : public QObject
{
  Q_OBJECT

    enum State {
      RunningSuperState,
      StartingDiscoveryState,
      DiscoveringState,
      StoppingDiscoveryState,
      FinishedState
    };
  Q_ENUM(State)
};

To use enums in QML.


={============================================================================
|kt_dev_qt_0001| qt-logging


// qt-logging

/*
https://doc.qt.io/qt-5/debug.html

Warning and Debugging Messages

Qt includes global macros for writing out warning and debug text. You can use
them for the following purposes:

qDebug() is used for writing custom debug output.
qInfo() is used for informational messages.
qWarning() is used to report warnings and recoverable errors in your application.
qCritical() is used for writing critical error messages and reporting system errors.
qFatal() is used for writing fatal error messages shortly before exiting.


<controlled-by-compilation-flag>

qDebug(), qInfo(), and qWarning() are debugging tools. They can be compiled away
by defining QT_NO_DEBUG_OUTPUT, QT_NO_INFO_OUTPUT, or QT_NO_WARNING_OUTPUT
during compilation.


Qt Logging Framework - KDAB

http://www.kdab.com/wp-content/uploads/stories/slides/Day2/KaiKoehne_Qt%20Logging%20Framework%2016_9_0.pdf

Logs message, message type, file, line, function

Macros since Qt 5.0:

#define qDebug \
 QMessageLogger(__FILE__, __LINE__, \
 Q_FUNC_INFO).debug

qFatal aborts

The QMessageLogger class generates log messages.

QMessageLogger is used to generate messages for the Qt logging framework.
Usually one uses it through qDebug(), qInfo(), qWarning(), qCritical, or
qFatal() functions, which are actually `macros`: 


For example qDebug() expands to 
QMessageLogger(__FILE__, __LINE__, Q_FUNC_INFO).debug() for debug builds, and 
QMessageLogger(0, 0, 0).debug() for release builds.

*/

TEST(Qt, Logging)
{
  // two ways of logging
  {
    // ctor logging
    qDebug("Hello qDebug");
    qWarning("Hello qWarning");
    qCritical("Hello qCritical");

    // this causes abort()
    // qFatal("Hello qFatal");

    // stream logging
    qDebug() << "Hello qDebug";
    qWarning() << "Hello qWarning";
    qCritical() << "Hello qCritical";
  }


  // printf() style logging

  {
    QString message{"Hello stream logging"};
    qDebug("QString: %s", message.toUtf8().constData());
  }

  // QTextStream manipulators
  // https://doc.qt.io/qt-5/qtextstream.html
  {
    qDebug().nospace() << "RGB: " << hex << uppercasedigits 
      << 0xff << 0x33 << 0x33;
  }
}


/*

Categorized logging (Qt 5.2)

Split up logging messages in hierarchical categories.

Category is identified by it's name
 category.subcategory.subsubcategory[...]

Logging of messages can be enabled or disabled based on the category and
message type, at runtime.

#define Q_DECLARE_LOGGING_CATEGORY(name) \
   extern const QLoggingCategory &name();

#define Q_LOGGING_CATEGORY(name, ...) \
   const QLoggingCategory &name() \
   { \
       static const QLoggingCategory category(__VA_ARGS__); \
       return category; \
   }

Note: The qCDebug(), qCWarning(), qCCritical() macros prevent arguments from
being evaluated if the respective message types are not enabled for the
category, so explicit checking is not needed:

    // usbEntries() will only be called if driverUsb category is enabled
    qCDebug(driverUsb) << "devices: " << usbEntries();


#if !defined(QT_NO_DEBUG_OUTPUT)
#  define qCDebug(category, ...) \
    for (bool qt_category_enabled = category().isDebugEnabled(); qt_category_enabled; qt_category_enabled = false) \
        QMessageLogger(QT_MESSAGELOG_FILE, QT_MESSAGELOG_LINE, QT_MESSAGELOG_FUNC, category().categoryName()).debug(__VA_ARGS__)
#else
#  define qCDebug(category, ...) QT_NO_QDEBUG_MACRO()
#endif
 
*/

Q_LOGGING_CATEGORY(lcEditor1, "qtc.editor.1");

TEST(Qt, LoggingCategory)
{
  {
    // QLoggingCategory lcEditor("qtc.editor");

    qCDebug(lcEditor1) << "1. Hello debug category logging";
    qCWarning(lcEditor1) << "1. Hello warning category logging";
    qCCritical(lcEditor1) << "1. Hello critical category logging";
    qCDebug(lcEditor1, "%s", "1. Hello debug category logging");
  }

  {
    QLoggingCategory lcEditor2("qtc.editor.2");

    qCDebug(lcEditor2) << "2. Hello debug category logging";
    qCWarning(lcEditor2) << "2. Hello warning category logging";
    qCCritical(lcEditor2) << "2. Hello critical category logging";
    qCDebug(lcEditor2, "%s", "2. Hello debug category logging");
  }

  // QLoggingCategory(const char *, QtMsgType severityLevel) (Qt 5.4)
  //
  // Disables message types < severityLevel. ???
  //
  // enum QtMsgType
  //
  // This enum describes the messages that can be sent to a message handler
  // (QtMessageHandler). You can use the enum to identify and associate the
  // various message types with the appropriate actions.
  // 
  // Constant	Value	Description
  // QtDebugMsg	0	A message generated by the qDebug() function.
  // QtInfoMsg	4	A message generated by the qInfo() function.
  // QtWarningMsg	1	A message generated by the qWarning() function.
  // QtCriticalMsg	2	A message generated by the qCritical() function.
  // QtFatalMsg	3	A message generated by the qFatal() function.
  // QtSystemMsg	QtCriticalMsg	 
  // QtInfoMsg was added in Qt 5.5.
  // enum QtMsgType { QtDebugMsg, QtWarningMsg, QtCriticalMsg, QtFatalMsg, QtInfoMsg, QtSystemMsg = QtCriticalMsg };


  // qtc.editor.3: 3. Hello warning category logging
  // qtc.editor.3: 3. Hello critical category logging
  // qtc.editor.3: 3. Hello info category logging
  // qtc.editor.3 isCriticalEnabled
  // qtc.editor.3 isCriticalEnabled
  // qtc.editor.3 isInfoEnabled
  // qtc.editor.3 isWarningEnabled

  {
    // all but debug. why not see DebugMsg?
    QLoggingCategory cat("qtc.editor.3", QtInfoMsg);

    qCDebug(cat) << "3. Hello debug category logging";
    qCWarning(cat) << "3. Hello warning category logging";
    qCCritical(cat) << "3. Hello critical category logging";
    qCInfo(cat) << "3. Hello info category logging";
    qCDebug(cat, "%s", "3. Hello debug category logging");

    // from qCX macros, how is this possible?
    //
    // for (bool qt_category_enabled = cat().isCriticalEnabled(); qt_category_enabled; qt_category_enabled = false)
    // 
    // since:
    //
    // #define QLOGGINGCATEGORY_H
    //
    // // allows usage of both factory method and variable in qCX macros
    // QLoggingCategory &operator()() { return *this; }
    // const QLoggingCategory &operator()() const { return *this; }

    for (bool qt_category_enabled = cat.isCriticalEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat.categoryName() << " isCriticalEnabled" << std::endl;

    for (bool qt_category_enabled = cat().isCriticalEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isCriticalEnabled" << std::endl;

    for (bool qt_category_enabled = cat().isDebugEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isDebugEnabled" << std::endl;

    for (bool qt_category_enabled = cat().isInfoEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isInfoEnabled" << std::endl;

    // use of isEnabled()
    for (bool qt_category_enabled = cat().isEnabled(QtWarningMsg); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isWarningEnabled" << std::endl;
  }


  // qtc.editor.4: 4. Hello warning category logging
  // qtc.editor.4: 4. Hello critical category logging
  // qtc.editor.4 isCriticalEnabled
  // qtc.editor.4 isWarningEnabled

  {
    // all but debug. why not see DebugMsg?
    QLoggingCategory cat("qtc.editor.4", QtWarningMsg);

    qCDebug(cat) << "4. Hello debug category logging";
    qCWarning(cat) << "4. Hello warning category logging";
    qCCritical(cat) << "4. Hello critical category logging";
    qCInfo(cat) << "4. Hello info category logging";
    qCDebug(cat, "%s", "4. Hello debug category logging");

    for (bool qt_category_enabled = cat().isCriticalEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isCriticalEnabled" << std::endl;

    for (bool qt_category_enabled = cat().isDebugEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isDebugEnabled" << std::endl;

    for (bool qt_category_enabled = cat().isInfoEnabled(); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isInfoEnabled" << std::endl;

    // use of isEnabled()
    for (bool qt_category_enabled = cat().isEnabled(QtWarningMsg); qt_category_enabled; qt_category_enabled = false)
      std::cout << cat().categoryName() << " isWarningEnabled" << std::endl;
  }
}


<qt-logging-handler>

/*
 
https://doc.qt.io/qt-5/qtglobal.html#qInstallMessageHandler

QtMessageHandler <QtGlobal>::qInstallMessageHandler(QtMessageHandler handler)

Installs a Qt message handler which has been defined previously. Returns a
pointer to the previous message handler.

The message handler is a function that prints out debug messages, warnings,
critical and fatal error messages. The Qt library (debug mode) contains hundreds
of warning messages that are printed when internal errors (usually invalid
function arguments) occur. Qt built in release mode also contains such warnings
unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during
compilation. If you implement your own message handler, you get total control of
these messages.

The default message handler prints the message to the standard output under X11
or to the debugger under Windows. If it is a fatal message, the application
aborts immediately.

Only one message handler can be defined, since this is usually done on an
application-wide basis to control debug output.

To restore the message handler, call qInstallMessageHandler(0).

Example:

#include <qapplication.h>
#include <stdio.h>
#include <stdlib.h>

void myMessageOutput(QtMsgType type, const QMessageLogContext &context, const QString &msg)
{
    QByteArray localMsg = msg.toLocal8Bit();
    const char *file = context.file ? context.file : "";
    const char *function = context.function ? context.function : "";
    switch (type) {
    case QtDebugMsg:
        fprintf(stderr, "Debug: %s (%s:%u, %s)\n", localMsg.constData(), file, context.line, function);
        break;
    case QtInfoMsg:
        fprintf(stderr, "Info: %s (%s:%u, %s)\n", localMsg.constData(), file, context.line, function);
        break;
    case QtWarningMsg:
        fprintf(stderr, "Warning: %s (%s:%u, %s)\n", localMsg.constData(), file, context.line, function);
        break;
    case QtCriticalMsg:
        fprintf(stderr, "Critical: %s (%s:%u, %s)\n", localMsg.constData(), file, context.line, function);
        break;
    case QtFatalMsg:
        fprintf(stderr, "Fatal: %s (%s:%u, %s)\n", localMsg.constData(), file, context.line, function);
        break;
    }
}

int main(int argc, char **argv)
{
    qInstallMessageHandler(myMessageOutput);
    QApplication app(argc, argv);
    ...
    return app.exec();
}

Finally, the QtMsgType definition identifies the various messages that can be
generated and sent to a Qt message handler; QtMessageHandler is a type
definition for a pointer to a function with the signature void
myMessageHandler(QtMsgType, const QMessageLogContext &, const char *).
QMessageLogContext class contains the line, file, and function the message was
logged at. This information is created by the QMessageLogger class.

*/


={============================================================================
|kt_dev_qt_0001| qt-meta-object


https://wiki.qt.io/Qt_for_Beginners

The Meta Object

Qt provides a meta-object system. Meta-object (literally "over the object") is a
way to achieve some programming paradigms that are normally impossible to
achieve with pure C++ like:

Introspection : capability of examining a type at run-time Asynchronous function
calls

*qt-moc*
To use such meta-object capabilities in an application, one can subclass QObject
and mark it so that the "meta-object compiler (moc)" can interpret and translate
it.

Code produced by moc includes signals and slots signatures, methods that are
used to retrieve meta-information from those marked classes, properties
handling... `All this information can be accessed using the following method`:

const QMetaObject * QObject::`metaObject` () const

QMetaObject class contains all the methods that deal with meta-objects.


https://doc.qt.io/qt-5/metaobjects.html

The Meta-Object System

Qt's meta-object system provides the signals and slots mechanism for
inter-object communication, run-time type information, and the dynamic property
system.

The meta-object system is based on three things:

The QObject class provides a base class for objects that can take advantage of
the meta-object system.

The Q_OBJECT macro inside the private section of the class declaration is used
to enable meta-object features, such as dynamic properties, signals, and slots.

The Meta-Object Compiler (moc) supplies each QObject subclass with the necessary
code to implement meta-object features.  The moc tool reads a C++ source file.
If it finds one or more class declarations that contain the Q_OBJECT macro, it
produces another C++ source file which contains the meta-object code for each of
those classes. This generated source file is either #include'd into the class's
source file or, more usually, compiled and linked with the class's
implementation.

In addition to providing the signals and slots mechanism for communication
between objects (the main reason for introducing the system), the meta-object
code provides the following additional features:

`QObject::metaObject()` returns the associated meta-object for the class.


https://doc.qt.io/qt-5/qmetaobject.html

Detailed Description

The Qt Meta-Object System in Qt is responsible for the signals and slots
inter-object communication mechanism, runtime type information, and the Qt
property system. A single QMetaObject instance is created for each QObject
subclass that is used in an application, and this instance stores all the
meta-information for the QObject subclass. This object is available as
QObject::metaObject().

This class is not normally required for application programming, but it is
useful if you write meta-applications, such as scripting engines or GUI
builders.

The functions you are most likely to find useful are these:

className() returns the name of a class.

superClass() returns the superclass's meta-object.

method() and methodCount() provide information about a class's meta-methods
(signals, slots and other invokable member functions).

enumerator() and enumeratorCount() and provide information about a class's
enumerators.

propertyCount() and property() provide information about a class's properties.

constructor() and constructorCount() provide information about a class's
meta-constructors.


The index functions indexOfConstructor(), indexOfMethod(), indexOfEnumerator(),
and indexOfProperty() map names of constructors, member functions, enumerators,
or properties to indexes in the meta-object. For example, Qt uses
  indexOfMethod() internally when you connect a signal to a slot.

Classes can also have a list of name--value pairs of additional class
information, stored in QMetaClassInfo objects. The number of pairs is returned
by classInfoCount(), single pairs are returned by classInfo(), and you can
search for pairs with indexOfClassInfo().


The most important macro is Q_OBJECT. 

Signal-Slot connections and their syntax cannot be interpreted by a regular C++
compiler. The moc is provided to translate the QT syntax like "connect",
"signals", "slots", etc into regular C++ syntax. This is done by specifying the
  Q_OBJECT macro in the header containing class definitions that use such
  syntax.

mywidget.h

class MyWidget : public QWidget
{
 Q_OBJECT
 public:
  MyWidget(QWidget *parent = 0);
}


Others marker macros for moc are

signals
public / protected / private slots

that mark the different methods that need to be extended.

SIGNAL and SLOT are also two very important and useful macros. When a signal is
emitted, the meta-object system is used to compare the signature of the signal,
to check the connection, and to find the slot using it's signature. These macros
are actually used to convert the provided method signature into a string that
matches the one stored in the meta-object.


Creating custom signals and slots

This chapter covers the second part of signals and slots: implementing custom
signals and slots.

Creating custom slots and signals is really simple. Slots are like normal
methods, but with small decorations around, while signals need little to no
implementation at all.

Creating custom signals and slots is very simple. It is described by the
following checklist:

add Q_OBJECT macro

add signals section, and write signals prototypes

add public slots or protected slots or private slots sections, and write slots
prototypes

implement slots as normal methods

establish connections


Creating custom slots

In order to implement a slot, we first need to make the class be able to send
signals and have slots (see the previous chapter). This is done by setting the
Q_OBJECT macro in the class declaration (often in the header).

After that, a slot should be declared in the corresponding section, and
implemented as a normal method.

Finally, slots are connected to signals.

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
  m_button = new QPushButton("Hello World", this);
  m_button->setCheckable(true);

  // set the counter to 0
  m_counter = 0;

  // note: have to have this. If not, do not increase counter and not exit app.

  connect(m_button, SIGNAL(clicked(bool)),
      this, SLOT(slotButtonClicked(bool)));

  // Connecting the newly created signal to the quit slot is done as usual:

  connect(this, SIGNAL(counterReached()),
      QApplication::instance(), SLOT(quit()));
}

MainWindow::~MainWindow()
{
}

/*

We also add our custom slot. Since we are trying to react from the button being
checked, and since the corresponding signal is

void QPushButton::clicked(bool checked)

`checked` makes a button "pressed down" when clicked and need to click it
again to make "pressed up".

*/

void MainWindow::slotButtonClicked(bool checked)
{
  if (checked)
  {
    m_button->setText("Checked");
  }
  else
  {
    m_button->setText("Hello Qt World!");
  }

  ++m_counter;

  // what if emits a signal which is not connected? nothing happens.
  emit signalNotConnected();

  if (m_counter == 10)
  {
    emit counterReached();
  }
}


={============================================================================
|kt_dev_qt_0001| qt-slot qt-thread

https://doc.qt.io/qt-5/qobject.html

Notice that the Q_OBJECT macro is `mandatory` for any object that implements
signals, slots or properties. You also need to run the Meta Object Compiler on
the source file. We strongly recommend the use of this macro in all subclasses
of QObject regardless of whether or not they actually use signals, slots and
properties, since failure to do so may lead certain functions to exhibit
strange behavior.


<qt-thread-affinity> *qt-mainloop*
Thread Affinity

A QObject instance is said to have a thread affinity, or that it lives in a
certain thread. When a QObject receives a `queued signal` or a `posted event`,
`the slot or event handler will run in the thread` that the object lives in.

Note: If a QObject has no thread affinity (that is, if thread() returns zero),
or if it lives in a thread that has no running event loop, then it cannot
receive queued signals or posted events.

By default, a QObject lives in the thread in which it is created. An object's
thread affinity can be queried using thread() and changed using
moveToThread().

https://wiki.qt.io/Threads_Events_QObjects


<ex>
https://stackoverflow.com/questions/28055749/event-loops-and-signal-slot-processing-when-using-multithreading-in-qt

I've been having some problems with using QThreads which made me explore
different combinations before I've found the right one. However I still don't
fully understand what is really happening in the four cases shown below when
it comes to event loops and signal-slot processing.

I added some comments to OUTPUT section, but as you can see I'm not sure if my
assumptions about what caused observed behaviors are correct. Also I'm not
sure if case 3 is something that might be used in real code. Here is my test
code (only the main.cpp differs for each case):

worker.h:

#include <QObject>
#include <QDebug>
#include <QThread>

class Worker : public QObject
{
    Q_OBJECT
public:
    explicit Worker(QObject *parent = 0) { this->isRunning_ = false;}
    bool isRunning() const { return isRunning_; }

signals:
    void processingFinished();
    void inProgress();

public slots:
    void process()
    {
        this->isRunning_ = true;
        qDebug() << this << "processing started";
        for (int i = 0; i < 5; i++)
        {
            QThread::usleep(1000);
            emit this->inProgress();
        }
        qDebug() << this << "processing finished";
        this->isRunning_ = false;
        emit this->processingFinished();
    }

private:
    bool isRunning_;
};


workermanager.h:

#include "worker.h"

class WorkerManager : public QObject
{
    Q_OBJECT
public:
    explicit WorkerManager(QObject *parent = 0) :
        QObject(parent) {}

public slots:
    void process()
    {
        QThread *thread = new QThread();
        Worker  *worker = new Worker();

        connect(thread,SIGNAL(started()),worker,SLOT(process()));
        connect(worker,SIGNAL(processingFinished()),this,SLOT(slot1()));
        connect(worker,SIGNAL(inProgress()),this,SLOT(slot2()));
        worker->moveToThread(thread);

        qDebug() << "starting";
        thread->start();
        QThread::usleep(500);
        while(worker->isRunning()) { }
        qDebug() << "finished";
    }

    void slot1() { qDebug() << "slot1"; }
    void slot2() { qDebug() << "slot2"; }
};


main.cpp (case 1 - no separate thread for workerManager):

#include <QCoreApplication>
#include "workermanager.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    WorkerManager* workerManager = new WorkerManager;    
    workerManager->process();
    qDebug() << "end";
    return a.exec();
}

OUTPUT - both slot1 and slot2 called at a.exec() (??? - using main event loop?):

starting 
Worker(0x112db20) processing started 
Worker(0x112db20) processing finished 
finished 
end
slot2 
slot2 
slot2 
slot2 
slot2 
slot1 


main.cpp (case 2 - workerManager moved to separate thread, but thread not started):

#include <QCoreApplication>
#include "workermanager.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    WorkerManager* workerManager = new WorkerManager;
    QThread *thread = new QThread();   
    workerManager->moveToThread(thread);       
    workerManager->process();
    qDebug() << "end";
    return a.exec();
}

OUTPUT - neither slot1 nor slot2 was called - (??? event loop associated with
    thread receives signals but since thread was not started slots are not
    called?):

starting 
Worker(0x112db20) processing started 
Worker(0x112db20) processing finished 
finished 
end


main.cpp (case 3 - workerManager moved to separate thread, thread started but
    workerManager::process() called via workerManager->process()):

#include <QCoreApplication>
#include "workermanager.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    WorkerManager* workerManager = new WorkerManager;
    QThread *thread = new QThread();   
    workerManager->moveToThread(thread); 
    thread->start();     
    workerManager->process();
    qDebug() << "end";
    return a.exec();
}

OUTPUT - slot2 called while Worker still executing its process() (???):

starting 
Worker(0x197bb20) processing started 
slot2 
slot2 
slot2 
slot2 
Worker(0x197bb20) processing finished 
finished 
end 
slot2 
slot1 


main.cpp (case 4 - workerManager moved to separate thread, thread started but
    workerManager::process() called using started() signal from thread):

#include <QCoreApplication>
#include "workermanager.h"

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    WorkerManager* workerManager = new WorkerManager;
    QThread *thread = new QThread();    
    workerManager->moveToThread(thread);
    QObject::connect(thread,SIGNAL(started()),workerManager,SLOT(process()));
    thread->start();
    qDebug() << "end";
    return a.exec();
}

OUTPUT - all events processed after reaching a.exec() (???):

end 
starting 
Worker(0x7f1d700013d0) processing started 
Worker(0x7f1d700013d0) processing finished 
finished 
slot2 
slot2 
slot2 
slot2 
slot2 
slot1 


All results you got are perfectly correct. I'll try to explain how this works.

An event loop is an internal loop in Qt code that processes system and user
events. Event loop of main thread is started when you call a.exec(). Event
loop of another thread is started by default implementation of QThread::run.

When Qt decides it's time to process an event, it executes its event handler.
While event handler is working, Qt has no chance to process any other event
(unless given directly by QApplication::processEvents() or some other
 methods). Once the event handler is finished, control flow returns to the
event loop and Qt may execute another handler to process another event.

Signals and slots are not the same as events and event handlers in Qt
terminology. But slots are handled by event loops somewhat similarily. If you
have control flow in your code(such as in main function) you can execute any
slot immediately just as any other C++ function. But when Qt does that it can
only do that from an event loop. It should be noted that signals are always
sent immediately, while slot execution may be delayed.

Now let's see what happens in each case.

Case 1
WorkerManager::process is executed directly at the program start. New thread
is started and Worker::process is executed immediately in the new thread.
WorkerManager::process continues execution until Worker is done, freezing all
other actions (including slot processing) in main thread. After
WorkerManager::process is finished, control flow goes to QApplication::exec.
Qt establishes connection to the other thread, receives messages about slot
invokation and invokes all of them consequently.

Case 2
Qt by default executes slots of an object in the thread this object belongs
to. Main thread will not execute slots of WorkerManager because it belongs to
another thread. However this thread is never started. Its event loop is never
finished. Invokations of slot1 and slot2 are left forever in Qt's queue
waiting for you to start the thread. Sad story.

Case 3
In this case WorkerManager::process is executed in main thread because you
invoke it directly from main thread. Meanwhile, WorkerManager's thread is
started. Its event loop is launched and waiting for events.
WorkerManager::process starts Worker's thread and executes Worker::exec in it.
Worker starts sending signals to WorkerManager. WorkerManager's thread almost
immediately starts to execute appropriate slots. At this point it seems
awkward that WorkerManager::slot2 and WorkerManager::process are executed
simultaneously. But it's perfectly fine, at least if WorkerManager is
thread-safe. Shortly after Worker is done, WorkerManager::process is finished
and a.exec() is executed but has not much to process.

Case 4
Main function just launches WorkerManager's thread and immediately goes to
a.exec(), resulting in  end as first line in the output. a.exec() processes
something and ensures program execution but doesn't execute WorkerManager's
slots because it belongs to another thread. WorkerManager::process is executed
in WorkerManager's thread from its event loop. Worker's thread is started and
Worker::process starts sending signals from Worker's thread to WorkerManager's
thread. Unfortunately the latter is busy executing WorkerManager::process.
When Worker is done, WorkerManager::process also finishes and WorkerManager's
thread immediately executes all queued slots.

The largest problem in your code is usleep and infinite loops. You should
almost never use those when working with Qt. I understand that a sleep in
Worker::process is just a placeholder for some real calculation. But you
should remove sleep and infinite loop from WorkerManager. Use
WorkerManager::slot1 to detect Worker's termination. If you develop a GUI
application there would be no need to move WorkerManager to another thread.
All its methods (without sleep) will be executed fast and will not freeze the
GUI.


void QObject::deleteLater()

Schedules this object for deletion.

The object will be deleted when control returns to the event loop. If the
event loop is not running when this function is called (e.g. deleteLater() is
    called on an object before QCoreApplication::exec()), the object will be
deleted once the event loop is started. If deleteLater() is called after the
main event loop has stopped, the object will not be deleted. Since Qt 4.8, if
deleteLater() is called on an object that lives in a thread with no running
event loop, the object will be destroyed when the thread finishes.

Note that entering and leaving a new event loop (e.g., by opening a modal
    dialog) will not perform the deferred deletion; for the object to be
deleted, the control must return to the event loop from which deleteLater()
was called. This does not apply to objects deleted while a previous, nested
event loop was still running: the Qt event loop will delete those objects as
soon as the new nested event loop starts.


<qt-event-loop>

QApplication is a very important class. It takes care of input arguments, but
also a lot of other things, and most notably, the event loop. The event loop is
a loop that waits for user input in GUI applications.

When calling app.exec() the event loop is launched.


<qt-slot-qt-signal> <tut-03>

/*

o As with Tutorial 2, uses `MainWindow` but add a button in ctor and which is do
the same.

o Use signal and connect

https://wiki.qt.io/Qt_for_Beginners

Subclassing QWidget

Until now, we have put all of our code in the main function. This was not a
problem for our simple examples, but for more and more complex applications we
might want to split our code into different classes. What is often done is to
create a class that is used to display a window, and implement all the widgets
that are contained in this window as attributes of this class.

Please note that there is no need for writing a destructor for deleting
m_button. With the parenting system, when the Window instance is out of the
stack, the m_button is automatically deleted.


Signals and slots

https://doc.qt.io/qt-5/signalsandslots.html

Signals and slots are used for communication `between objects.`

we have an alternative to the callback technique: We use signals and slots. A
signal is emitted when a particular event occurs. Qt's widgets have many
predefined signals, but we can always subclass widgets to add our own signals to
them. `A slot is a function` that is called in response to a particular signal.
Qt's widgets have many pre-defined slots, but it is common practice to subclass
widgets and add your own slots so that you can handle the signals that you are
interested in

o The signals and slots mechanism is type safe: 
  The signature of a signal `must match` the signature of the receiving slot.

  (In fact a `slot may have a shorter signature` than the signal it receives
  because it can ignore extra arguments.)

o `The string-based SIGNAL and SLOT syntax` will detect type mismatches at
  `runtime`

o Signals and slots are loosely coupled: 
  A class which emits a signal neither knows nor cares which slots receive the
  signal. It does not know or care whether anything is receiving the signals
  it emits.

*qt-signal-to-signal*
o You can connect as many signals as you want to a single slot, and a signal
  can be connected to as many slots as you need. It is even possible to
  connect a signal directly to another signal. (This will emit the second
  signal immediately whenever the first is emitted.)

o `Signals are public access functions` and can be emitted `from anywhere`, but we
  recommend to only emit them from the class that defines the signal and its
  subclasses.

o When a signal is emitted, the slots connected to it are usually executed
  immediately, `just like a normal function call` When this happens, the signals
  and slots mechanism is totally `independent of any GUI event loop.` Execution
  of the code following the emit statement will occur once all slots have
  returned.  

  The situation is slightly different when using `queued connections`; in such a
  case, the code following the emit keyword will continue immediately, and the
  slots will be executed later.

  enum Qt::ConnectionType
  
  This enum describes the types of connection that can be used between signals and
  slots. In particular, it determines whether a particular signal is delivered to
  a slot immediately or queued for delivery at a later time.
  
  Description
  
  Qt::AutoConnection	
  
  (Default) If the receiver lives in the thread that emits the signal,
    Qt::DirectConnection is used. Otherwise, Qt::QueuedConnection is used. The
    connection type is determined when the signal is emitted.

  Qt::QueuedConnection

  A delayed function call. Signaling object sends an event to the receiving
  object

o If several slots are connected to one signal, the slots will be executed one
  after the other, `in the order they have been connected`, when the signal is
  emitted.

*qt-moc*
o `Signals are automatically generated by the moc` and must not be implemented in
  the .cpp file. They can never have return types (i.e. use void).

  Note that muse use .cpp since if not, moc do not run and will see link
  errors for signal funtions which is not generated by moc.

  The Q_OBJECT macro is expanded by the preprocessor to declare several member
  functions that are implemented by the moc; if you get compiler errors along
  the lines of "undefined reference to vtable for LcdNumber", you have probably
  forgotten to run the moc or to include the moc output in the link command.

o Slots can be used for receiving signals, but they are also normal member
  functions: their only special feature is that signals can be connected to
  them

// o However, as slots, they can be invoked by any component, `regardless of` its
//   access level, via a signal-slot connection. This means that a signal emitted
//   from an instance of an arbitrary class can cause a private slot to be invoked
//   in an instance of an unrelated class.
//   (From SO) From another class, you can't call a private slot as a function, but
//   if you emit a signal connected to that private slot, you can invoke it."
//   ??? since fails on QObject::connect() when use private slot.

o You can also define slots to be virtual, which we have found quite useful in
  practice.

o slot is overloaded; Qt will select the appropriate version when you connect a
  signal to the slot. With callbacks, you'd have to find five different names
  and keep track of the types yourself.

o Can use function pointer

  connect(sender, &QObject::destroyed, this, &MyObject::objectDestroyed);

  Note that signal and slot arguments are not checked by the compiler when using
  this QObject::connect() overload.

o Can also connect to functors or C++11 lambdas:

  connect(sender, &QObject::destroyed, 
      this, [=](){ this->m_objects.remove(sender); });


<qt-slot-debug> <qt-signal-debug>

QObject::dumpObjectTree() dumps the parent/child relationships of all descendant
objects

if(QObject::connect(m_blercuController1.data(), &ComSkyBleRcuController1Interface::stateChanged,
      this, &BleRcuCmdHandler::onStateChanged))
{
  qCritical() << "KT: connect(stateChanged1) is okay";
  m_blercuController1->dumpObjectInfo();
}
else
{
  qCritical() << "KT: connect(stateChanged1) is not okay";
  m_blercuController1->dumpObjectInfo();
}

KT: connect(stateChanged1) is okay
OBJECT ComSkyBleRcuController1Interface::unnamed
  SIGNALS OUT
        signal: destroyed(QObject*)
          <functor or function pointer>
        signal: destroyed()
        signal: objectNameChanged(QString)
        signal: DeviceAdded(QDBusObjectPath,QString)
          <functor or function pointer>
        signal: DeviceRemoved(QDBusObjectPath,QString)
          <functor or function pointer>
        signal: Ready()
        signal: pairingChanged(bool)
          <functor or function pointer>
        signal: stateChanged(uint)
          <functor or function pointer>
  SIGNALS IN
          <-- QDBusServiceWatcher::unnamed _q_serviceOwnerChanged(QString,QString,QString)
[blercu]#


// ex from https://doc.qt.io/qt-5/signalsandslots.html
// shows it's object based

class Counter : public QObject
{
  Q_OBJECT

  public:
    Counter() { m_value = 0; }

    int value() const { return m_value; }

    public slots:
      void setValue(int value);

  signals:
    void valueChanged(int newValue);

  private:
    int m_value;
};

void Counter::setValue(int value)
{
  if (value != m_value) {
    m_value = value;
    emit valueChanged(value);
  }
}

TEST(Qt, SlotAndSignal)
{
  // Calling a.setValue(12) makes a emit a valueChanged(12) signal, which b will
  // receive in its setValue() slot, i.e. b.setValue(12) is called. Then b emits
  // the same valueChanged() signal, but since no slot has been connected to b's
  // valueChanged() signal, `the signal is ignored`
  //
  // Note that the setValue() function sets the value and emits the signal only
  // if value != m_value. This prevents infinite looping in the case of cyclic
  // connections (e.g., if b.valueChanged() were connected to a.setValue()).

  {
    Counter a, b;
    QObject::connect(&a, &Counter::valueChanged,
        &b, &Counter::setValue);

    a.setValue(12);     // a.value() == 12, b.value() == 12
    EXPECT_THAT(a.value(), 12);
    EXPECT_THAT(b.value(), 12);

    b.setValue(48);     // a.value() == 12, b.value() == 48
    EXPECT_THAT(a.value(), 12);
    EXPECT_THAT(b.value(), 48);
  }
}

o This example illustrates that objects can work together without needing to
know any information about each other. 

<qt-moc-error>

The Q_OBJECT macro is expanded by the preprocessor to declare several member
functions that are implemented by the moc; if you get compiler errors along the
lines of "undefined reference to vtable for LcdNumber", you have probably
forgotten to run the moc or to include the moc output in the link command.


Observer pattern is used everywhere in GUI applications, and often leads to some
boilerplate code. Qt was created with the idea of removing this boilerplate code
and providing a nice and clean syntax, and the signal and slots mechanism is the
answer.

Instead of having observable objects and observers, and registering them, Qt
provides two high level concepts: signals and slots.

o A signal is a message that an object can send, most of the time to inform of a
status change.

o A slot is a function that is used to accept and respond to a signal.

In order to respond to a signal, a slot must be connected to a signal. Qt
provides the method QObject::connect. It is used this way, with the two macros
SIGNAL and SLOT

FooObjectA *fooA = new FooObjectA();
FooObjectB *fooB = new FooObjectB();

QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz()));

assuming that FooObjectA have a bared signal, and FooObjectB have a baz slot.

You have to write the signature of the signal and the slot inside the two macros
SIGNAL and SLOT.

Remark : Basically, signals and slots are methods, that might or might not have
arguments, but that never return anything. While the notion of a signal as a
method is unusual, a slot is actually a real method, and can be called as usual
in other methods, or whilst responding to a signal.


Transmitting information

The signals and slots mechanism is useful to respond to buttons clicks, but it
can do much more than that. For example, It can also be used to communicate
information. Let's say while playing a song, a progress bar is needed to show
how much time remains before the song is over. A media player might have a class
that is used to check the progress of the media. An instance of this class might
periodically send a tick signal, with the progress value. This signal can be
connected to a QProgressBar, that can be used to display the progress.

The hypothetical class used to check the progress might have a signal that have
this signature :

void MediaProgressManager::tick(int miliseconds);

and we know from the documentation, that the QProgressBar has this slot:

void QProgressBar::setValue(int value);

You can see that the signal and the slot have the same kind of parameters,
    especially the type. If you connect a signal to a slot that does not share
    the same kind of parameters, when the connection is done (at run-time) you
    will get a warning like:

QObject::connect: Incompatible sender/receiver arguments

This is because the signal transmits the information to the slot using the
parameters. The first parameter of the signal is passed to the first one of the
slot, and the same for second, third, and so forth.

The code for the connection will look like this:

MediaProgressManager *manager = new MediaProgressManager();
QProgressBar *progress = new QProgressBar(window);

QObject::connect(manager, SIGNAL (tick(int)), progress, SLOT (setValue(int)));

You can see that you have to `provide a signature inside the SIGNAL and SLOT`
macro, providing the type of the values that are passed through the signals. You
may also provide the name of the variable if you want. (It is actually even
better).


Features of signals and slots

A signal can be connected to several slots

Many signals can be connected to a slot

A signal can be connected to a signal: it is signal relaying. The second signal
is sent if the first signal is sent.


Responding to an event

Let's try to actually make something with this app, like being able to close it
while clicking on the button. 

o We already know that QPushButton provides the clicked signal. 

o We also have to know that QApplication provides the quit slot, that closes the
application.

In order to make a click on a button close the app, we have to connect the
signal clicked of the button to the quit slot of QApplication instance. We can
modify the code from the previous chapter to do this, but before that, you might
wonder how to access to the QApplication instance while you are in another
class. Actually, it is pretty simple, since there exists a static function in
QApplication, with the following signature, that is used to get it:

QApplication * QApplication::instance()

*/

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  MainWindow w;

  // QPushButton *button = new QPushButton("Hello Qt Tutorial 2", &w);
  // button->setGeometry(20, 20, 180, 30);

  w.show();

  return a.exec();
}


<tut-04>

/*

https://wiki.qt.io/Qt_for_Beginners

Transmitting information with signals and slots

Here is a simpler example for information transmission. It only displays a
progress bar and a slider (created by QSlider) inside a window, and while the
slider is moved, the value of the progress bar is synced with a very simple
connection.

The interesting signals and slots are:

void QSlider::valueChanged(int value);
void QProgressBar::setValue(int value);

QSlider automatically emits the signal valueChanged with the new value passed as
a parameter when the value is changed, and the method setValue of QProgressBar,
is used, as we have seen, to set the value of the progress bar.

*/

main.cpp:

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  // MainWindow w;
  // w.show();

  // create a container window
  QWidget window;
  window.setFixedSize(200, 80);

  // create a progress bar
  QProgressBar *progressBar = new QProgressBar(&window);
  progressBar->setRange(0, 100);
  progressBar->setValue(0);
  progressBar->setGeometry(10, 10, 180, 30);

  // create a horizontal silder
  QSlider *slider = new QSlider(&window);
  slider->setOrientation(Qt::Horizontal);
  slider->setRange(0, 100);
  slider->setValue(0);
  slider->setGeometry(10, 40, 180, 30);

  window.show();

  // connection
  QObject::connect(slider, SIGNAL(valueChanged(int)),
      progressBar, SLOT(setValue(int)));

  return a.exec();
}


<tut-05>

mainwindow.h:

#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QPushButton>

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = 0);
    ~MainWindow();


/*

Emitting custom signals

Based on the previous example, we want to close the application if the button is
clicked (checked or unchecked) 10 times. We first need to implement a counter
that will count the number of clicks. 

Now, we have to create a custom signal that is used to notify other components,
that the counter has reached 10. In order to declare a signal, we have to add a

note: Even if the signal is declared as a method, there is `no need to implement`
it. The meta-object compiler is used to do this.

*/

signals:
    void counterReached();
    void signalNotConnected();

private slots:
    void slotButtonClicked(bool checked);

private:
    QPushButton *m_button;
    int m_counter;
};

#endif // MAINWINDOW_H


mainwindow.cpp:


={============================================================================
|kt_dev_qt_0001| qt-property

https://doc.qt.io/qt-5/properties.html#

To declare a property, use the Q_PROPERTY() macro in a class that inherits
QObject.

Q_PROPERTY(type name
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)])
           [RESET resetFunction]
           [NOTIFY `notifySignal`]
           [REVISION int]
           [DESIGNABLE bool]
           [SCRIPTABLE bool]
           [STORED bool]
           [USER bool]
           [CONSTANT]
           [FINAL])

A property behaves like a class data member, but it has additional features
accessible through the Meta-Object System.

A READ accessor function is required `if no MEMBER variable was specified.` It
is for reading the property value. Ideally, a const function is used for this
purpose, and it must return either the property's type or a const reference to
that type. e.g., QWidget::focus is a read-only property with READ function,
QWidget::hasFocus().

A WRITE accessor function is optional. It is for setting the property value.
It must return void and must take exactly one argument, either of the
property's type or a pointer or reference to that type. e.g., QWidget::enabled
has the WRITE function QWidget::setEnabled(). Read-only properties do not need
WRITE functions. e.g., QWidget::focus has no WRITE function.

A MEMBER variable association is required if no READ accessor function is
specified. This makes the given member variable readable and writable without
the need of creating READ and WRITE accessor functions. It's still possible to
use READ or WRITE accessor functions in addition to MEMBER variable
association (but not both), if you need to control the variable access.

A NOTIFY signal is optional. If defined, it should specify one existing signal
in that class that is emitted whenever the value of the property changes.
NOTIFY signals for MEMBER variables must take zero or one parameter, which
must be of the same type as the property. The parameter will take the new
value of the property. The NOTIFY signal should only be emitted when the
property has really been changed, to avoid bindings being unnecessarily
re-evaluated in QML, for example. 

Qt emits automatically that signal when needed for MEMBER properties that do
not have an explicit setter.

note: seems that it means that's the case only when use MEMBER and have to use
emit signal for other cases.


A property can be read and written using the generic functions
QObject::property() and QObject::setProperty()

https://doc.qt.io/qt-5/qobject.html

`QVariant`` QObject::property(const char *name) const

Returns the value of the object's name property.

`If no such property exists, the returned variant is invalid.`

Information about all available properties is provided through the
metaObject() and dynamicPropertyNames().


bool QObject::setProperty(const char *name, const QVariant &value)

Sets the value of the object's name property to value.

If the property is defined in the class using Q_PROPERTY then true is returned
on success and false otherwise. If the property is not defined using
Q_PROPERTY, and `therefore not listed in the meta-object`, it is added as a
dynamic property and false is returned.

Information about all available properties is provided through the
metaObject() and dynamicPropertyNames().

Dynamic properties can be queried again using property() and can be removed by
setting the property value to an invalid QVariant. Changing the value of a
dynamic property causes a QDynamicPropertyChangeEvent to be sent to the
object.


but setting the property this way requires that you know about the class at
compile time. Accessing properties by name lets you access classes you don't
know about at compile time. You `can discover a class's properties at run time`
by querying its QObject, QMetaObject, and QMetaProperties.

QObject *object = ...
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i=0; i<count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    ...
}

In the above snippet, QMetaObject::property() is used to get metadata about
each property defined in some unknown class. The property name is fetched from
the metadata and passed to QObject::property() to get the value of the
property in the current object.


*qt-meta-object*
Note that dynamic properties are added on a per instance basis, i.e., they are
added to QObject, `not QMetaObject.`

Suggest QMetaObject is per class?

The Qt Meta-Object System in Qt is responsible for the signals and slots
inter-object communication mechanism, runtime type information, and the Qt
property system. A single QMetaObject instance is created for each QObject
`subclass` that is used in an application, and this instance stores all the
meta-information for the QObject subclass. This object is available as
QObject::metaObject().


Here are some typical examples of property declarations taken from class QWidget.

Q_PROPERTY(bool focus READ hasFocus)
Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled)
Q_PROPERTY(QCursor cursor READ cursor WRITE setCursor RESET unsetCursor)

Here is an example showing how `to export member variables as Qt properties` using
the MEMBER keyword. Note that a NOTIFY signal must be specified to allow QML
property bindings.

    Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)
    Q_PROPERTY(qreal spacing MEMBER m_spacing NOTIFY spacingChanged)
    Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)
    ...
signals:
    void colorChanged();
    void spacingChanged();
    void textChanged(const QString &newText);

private:
    QColor  m_color;
    qreal   m_spacing;
    QString m_text;


<ex>
When miss out Q_PROPERTY() for added property, see this warning from:

class BleRcuController1Adaptor : public DBusAbstractAdaptor
{
  Q_OBJECT
  Q_CLASSINFO("D-Bus Interface", "com.sky.blercu.Controller1")
    ...
  public:
  Q_PROPERTY(quint32 Status)
    ...
};


See this message:

odd, no meta property for "Status"


void DBusAbstractInterface::onPropertiesChanged(const QString& interfaceName,
                                                const QVariantMap& changedProperties,
                                                const QStringList& invalidatedProperties)
{
  Q_UNUSED(invalidatedProperties);

  // sanity check the interface is correct
  if (Q_UNLIKELY(interfaceName != QDBusAbstractInterface::interface())) {
    qInfo() << "odd, received PropertiesChanged signal from wrong interface";
    return;
  }

  // iterate through the changed properties
  QVariantMap::const_iterator it = changedProperties.begin();
  for (; it != changedProperties.end(); ++it) {

    const QString &propName = it.key();
    const QVariant &propValue = it.value();

    // try and find the meta index of the named property
    const int propIndex = metaObject()->indexOfProperty(propName.toLatin1().constData());
    if (propIndex < 0) {
      qInfo("odd, no meta property for %s.%s",
          qPrintable(interfaceName), qPrintable(propName));
      continue;
    }

    // check if the property has the notify flag, if not ignore the change
    const QMetaProperty propMeta = metaObject()->property(propIndex);
    if (!propMeta.hasNotifySignal()) {
      qDebug("skipping property change notification for %s.%s",
          qPrintable(interfaceName), qPrintable(propName));
      continue;
    }

    const QMetaMethod notifyMethod = propMeta.notifySignal();
    if (Q_UNLIKELY(!notifyMethod.isValid())) {
      qWarning("odd, invalid property notify signal for %s.%s",
          qPrintable(interfaceName), qPrintable(propName));
      continue;
    }

    // invoke the notify signal
    invokeNotifySignal(notifyMethod, propName, propValue, propMeta.userType());
  }

  // TODO: handle invalidatedProperties as well
}


={============================================================================
|kt_dev_qt_0001| qt-dbus

https://doc.qt.io/qt-5/qdbusservicewatcher.html

Detailed Description

A QDBusServiceWatcher object can be used to notify the application about an
`ownership change` of a service name on the bus. It has three watch modes:

Watching for service registration only.
Watching for service unregistration only.
Watching for any kind of service ownership change (the default mode).

Besides being created or deleted, services may change owners without a
unregister/register operation happening. So the serviceRegistered() and
serviceUnregistered() signals may not be emitted if that happens.

This class is more efficient than using the
QDBusConnectionInterface::serviceOwnerChanged() signal because it allows one
to receive only the signals for which the class is interested in.

Ending a service name with the character '*' will match all service names
within the specified namespace.

For example "com.example.backend1*" will match

com.example.backend1
com.example.backend1.foo
com.example.backend1.foo.bar

Substrings in the same domain will not be matched, i.e "com.example.backend12".

<ex>

{
  // create a dbus service watcher object so we can detect if the bluez daemon
  // (bluetoothd) falls off the bus or arrives back on the bus
 
  m_bluezServiceWatcher =
    QSharedPointer<QDBusServiceWatcher>::create("org.bluez", m_bluezDBusConn);

  // connect to the added / remove service signals
  QObject::connect(m_bluezServiceWatcher.data(), &QDBusServiceWatcher::serviceRegistered,
      this, &BleRcuManagerImpl::onBluezServiceRegistered,
      Qt::QueuedConnection);
  QObject::connect(m_bluezServiceWatcher.data(), &QDBusServiceWatcher::serviceUnregistered,
      this, &BleRcuManagerImpl::onBluezServiceUnregistered,
      Qt::QueuedConnection);
}


org.freedesktop.DBus.ObjectManager

GetManagedObjects()
Returns the subordinate objects paths and their supported interfaces and properties.

arguments

returns
a{oa{sa{sv}}}


InterfacesAdded
Signal indicating interfaces have been added to an object

parameters: oa{sa{sv}}
1. Object path gaining the new interfaces
2. Dictionary of interfaces names and their properties

InterfacesRemoved
Signal indicating interfaces have been removed from an object

parameters: oas
1. Object path loosing the interfaces
2. List of interface names

<ex>

// QDBusConnectionInterface *QDBusConnection::interface() const
// Returns a QDBusConnectionInterface object that represents the D-Bus server
// interface on this connection.
// 
// https://doc.qt.io/qt-5/qdbusconnectioninterface.html
//
// Detailed Description
//
// Inherits:	QDBusAbstractInterface
//
// The D-Bus bus server daemon provides one special interface
// org.freedesktop.DBus that allows clients to access certain properties of
// the bus, such as the current list of clients connected. The
// QDBusConnectionInterface class provides access to that interface.
// 
// The most common uses of this class are to register and unregister service
// names on the bus using the registerService() and unregisterService()
// functions, query about existing names using the isServiceRegistered(),
// registeredServiceNames() and serviceOwner() functions, and to receive
// notification that a client has registered or de-registered through the
// serviceRegistered(), serviceUnregistered() and serviceOwnerChanged()
// signals.

As with QDBusConnectionInterface, can have class for ObjectManager interface

class DBusObjectManagerInterface: public QDBusAbstractInterface
  {
    Q_OBJECT

    public:
      static inline const char *staticInterfaceName()
      { return "org.freedesktop.DBus.ObjectManager"; }

    public:
      DBusObjectManagerInterface(const QString &service, const QString &path,
          const QDBusConnection &connection,
          QObject *parent = nullptr);
      ~DBusObjectManagerInterface();

      public slots:
        inline QDBusPendingReply<DBusManagedObjectList> GetManagedObjects()
        {
          QList<QVariant> argumentList;
          return asyncCallWithArgumentList(QStringLiteral("GetManagedObjects"), argumentList);
        }

signals:
      void InterfacesAdded(const QDBusObjectPath &objectPath, DBusInterfaceList interfacesAndProperties);
      void InterfacesRemoved(const QDBusObjectPath &objectPath, const QStringList &interfaces);
  };


// -----------------------------------------------------------------------------
/**
 *	@brief Registers the types used for this dbus interface
 *
 *	The function contains an atomic check to ensure that the types are only
 *	registered once
 *
 */
static void registerObjectManagerTypes()
{
  static QAtomicInteger<bool> isDone(false);

  if (isDone.testAndSetAcquire(false, true)) {
    qDBusRegisterMetaType<DBusInterfaceList>();
    qDBusRegisterMetaType<DBusManagedObjectList>();
  }
}

DBusObjectManagerInterface::DBusObjectManagerInterface(const QString &service,
                                                       const QString &path,
                                                       const QDBusConnection &connection,
                                                       QObject *parent)
  : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
{
  registerObjectManagerTypes();
}

DBusObjectManagerInterface::~DBusObjectManagerInterface()
{}


$ dbus-send  --system --type=method_call --print-reply --dest='org.freedesktop.DBus' / org.freedesktop.DBus.ListNames


<qt-dbus-adaptor>
https://doc.qt.io/qt-5/usingadaptors.html

Using Qt D-Bus Adaptors

Adaptors are special classes that are attached to any QObject-derived class
and `provide the interface to the external world using D-Bus.` 

Adaptors are intended to be lightweight classes 
`whose main purpose is to relay calls to and from the real object`, 
possibly validating or converting the input from the external world and, thus,
protecting the real object.

Unlike multiple inheritance, adaptors can be added at any time to any object
(but not removed), which allows for greater flexibility when `exporting`
existing classes. Another advantage of adaptors is to provide similar but not
identical functionality in methods of the same name in different interfaces, a
case which can be quite common when adding a new version of a standard
interface to an object.

In order to use an adaptor, one must create a class which inherits
`QDBusAbstractAdaptor`. 

*qt-moc*
Since that is a standard QObject-derived class, the Q_OBJECT macro must appear
in the declaration and `the source file must be processed with the moc tool.`

The class must also contain one Q_CLASSINFO entry with the "D-Bus Interface"
name, `declaring which interface it is exporting.` Only one entry per class is
supported.

Any public slot in the class will be accessible through the bus over messages
of the MethodCall type. (See Declaring Slots in D-Bus Adaptors for more
    information). 

Signals in the class will be automatically `relayed over D-Bus.` However, not
all types are allowed signals or slots' parameter lists: see The Qt D-Bus Type
System for more information.

Also, any property declared with Q_PROPERTY `will be automatically exposed` over
`the Properties interface on D-Bus.` Since the QObject property system does not
allow for non-readable properties, it is not possible to declare write-only
properties using adaptors.


https://doc.qt.io/qt-5/qdbusabstractadaptor.html

Detailed Description

The QDBusAbstractAdaptor class is the starting point for all objects intending
to provide interfaces to the external world using D-Bus. This is accomplished
by attaching a one or more classes derived from QDBusAbstractAdaptor to a
normal QObject and then registering that QObject with
QDBusConnection::registerObject. QDBusAbstractAdaptor objects are intended to
be light-weight wrappers, mostly just relaying calls into the real object (its
    parent) and the signals from it.

Each QDBusAbstractAdaptor-derived class should define the D-Bus interface it
is implementing using the Q_CLASSINFO macro in the class definition. Note that
only one interface can be exposed in this way.

QDBusAbstractAdaptor uses the standard QObject mechanism of signals, slots and
properties to determine what signals, methods and properties to export to the
bus. Any signal emitted by QDBusAbstractAdaptor-derived classes will be
automatically be relayed through any D-Bus connections the object is
registered on.

Classes derived from QDBusAbstractAdaptor must be created on the heap using
the new operator and must not be deleted by the user (they will be deleted
    automatically when the object they are connected to is also deleted).


QObject::Q_CLASSINFO(Name, Value)

This macro associates extra information to the class, which is available using
QObject::metaObject(). Qt makes only limited use of this feature, in the
Active Qt, Qt D-Bus and Qt QML.

The extra information takes the form of a Name string and a Value literal
string.


*qt-proxy-ex* example from complexping

the pong adaptor defines `property`:

class Pong : public QDBusAbstractAdaptor
{
  Q_OBJECT
    Q_CLASSINFO("D-Bus Interface",
        "org.example.QtDBus.ComplexPong.Pong")
    Q_PROPERTY(QString value READ value WRITE setValue)

  public:
    QString m_value;
    QString value() const;
    void setValue(const QString &newValue);
};


the ping client uses:

{
  // method call time=1571906439.566168 sender=:1.888 -> destination=org.example.QtDBus.PingExample serial=9 
  //  `path=/; interface=org.freedesktop.DBus.Properties; member=Get`
  //    string "org.example.QtDBus.ComplexPong.Pong"
  //    string "value"
  // method return time=1571906439.566688 sender=:1.889 -> destination=:1.888 serial=4 reply_serial=9
  //    variant       string "initial value"

  QVariant reply = iface->property("value");
  if (!reply.isNull())
    printf("value property = %s\n", qPrintable(reply.toString()));
}

{
  // method call time=1571906585.509050 sender=:1.892 -> destination=org.example.QtDBus.PingExample serial=10 
  //  `path=/; interface=org.freedesktop.DBus.Properties; member=Set`
  //    string "org.example.QtDBus.ComplexPong.Pong"
  //    string "value"
  //    variant       string "this is message from ping"
  // method return time=1571906585.509573 sender=:1.893 -> destination=:1.892 serial=5 reply_serial=10

  iface->setProperty("value", line.mid(6));
}


<qt-dbus-chat>

$ more org.example.chat.xml
<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
  <interface name="org.example.chat">
    <signal name="message">
      <arg name="nickname" type="s" direction="out"/>
      <arg name="text" type="s" direction="out"/>
    </signal>
    <signal name="action">
      <arg name="nickname" type="s" direction="out"/>
      <arg name="text" type="s" direction="out"/>
    </signal>
  </interface>
</node>


<qt-qdbusxml2cpp>
https://doc.qt.io/qt-5/qdbusxml2cpp.html

$ /home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -h
Usage: /home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp [options] xml-or-xml-file [interfaces ...]
Produces the C++ code to implement the interfaces defined in the input xml file.

If the file name given to the options -a and -p does not end in .cpp or .h, the
program will automatically append the suffixes and produce both files.

You can also use a colon (:) to separate the header name from the source file
name, as in '-a filename_p.h:filename.cpp'.

If you pass a dash (-) as the argument to either -p or -a, the output is written
to the standard output.

Options:
  -h, --help                   Displays this help.
  -v, --version                Displays version information.

  `-a, --adaptor <filename>     Write the adaptor code to <filename>`

  -c, --classname <classname>  Use <classname> as the class name for the
                               generated classes
  -i, --include <filename>     Add #include to the output
  -l <classname>               When generating an adaptor, use <classname> as
                               the parent class
  -m, --moc                    Generate #include "filename.moc" statements in
                               the .cpp files
  -N, --no-namespaces          Don't use namespaces

  `-p, --proxy <filename>       Write the proxy code to <filename>`

  -V, --verbose                Be verbose.

Arguments:
  xml-or-xml-file              XML file to use.
  interfaces                   List of interfaces to use.


note:
must use one from the qt installation but not from /usr/bin. otherwise, see
error:

could not find a Qt installation of ''

// used
$ /home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -i chat_adaptor.h -a :chat_adaptor.cpp org.example.chat.xml
makes `chat_adaptor.cpp` which has ctor and dtor

// used
$ /home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -a chat_adaptor.h: org.example.chat.xml
makes `chat_adaptor.h` which has declarations

$ /home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -a chat_adaptor.h org.example.chat.xml
makes chat_adaptor.h which has all code


/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -a chat_adaptor.h org.example.chat.xml
 *
 * qdbusxml2cpp is Copyright (C) 2019 The Qt Company Ltd.
 *
 * This is an auto-generated file.
 * This file may have been hand-edited. Look for HAND-EDIT comments
 * before re-generating it.
 */

#ifndef CHAT_ADAPTOR_H
#define CHAT_ADAPTOR_H

#include <QtCore/QObject>
#include <QtCore/QMetaObject>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>

/*
 * Adaptor class for interface org.example.chat
 */
class ChatAdaptor: public QDBusAbstractAdaptor
{
    Q_OBJECT
    Q_CLASSINFO("D-Bus Interface", "org.example.chat")
    Q_CLASSINFO("D-Bus Introspection", ""
"  <interface name=\"org.example.chat\">\n"
"    <signal name=\"message\">\n"
"      <arg direction=\"out\" type=\"s\" name=\"nickname\"/>\n"
"      <arg direction=\"out\" type=\"s\" name=\"text\"/>\n"
"    </signal>\n"
"    <signal name=\"action\">\n"
"      <arg direction=\"out\" type=\"s\" name=\"nickname\"/>\n"
"      <arg direction=\"out\" type=\"s\" name=\"text\"/>\n"
"    </signal>\n"
"  </interface>\n"
        "")
public:
    ChatAdaptor(QObject *parent);
    virtual ~ChatAdaptor();

public: // PROPERTIES
public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void action(const QString &nickname, const QString &text);
    void message(const QString &nickname, const QString &text);
};

#endif
/*
 * Implementation of adaptor class ChatAdaptor
 */

ChatAdaptor::ChatAdaptor(QObject *parent)
    : QDBusAbstractAdaptor(parent)
{
    // constructor
    setAutoRelaySignals(true);
}

ChatAdaptor::~ChatAdaptor()
{
    // destructor
}


// make chat_interface.cpp only
/home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -i chat_interface.h -p :chat_interface.cpp org.example.chat.xml

// make chat_interface.h only
/home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -p chat_interface.h: org.example.chat.xml

// make chat_interface.h which has all
/home/keitee/Qt/5.12.3/gcc_64/bin/qdbusxml2cpp -p chat_interface.h org.example.chat.xml


/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -p chat_interface.h org.example.chat.xml
 *
 * qdbusxml2cpp is Copyright (C) 2019 The Qt Company Ltd.
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef CHAT_INTERFACE_H
#define CHAT_INTERFACE_H

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

/*
 * Proxy class for interface org.example.chat
 */
class OrgExampleChatInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "org.example.chat"; }

public:
    OrgExampleChatInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = nullptr);

    ~OrgExampleChatInterface();

public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void action(const QString &nickname, const QString &text);
    void message(const QString &nickname, const QString &text);
};

namespace org {
  namespace example {
    typedef ::OrgExampleChatInterface chat;
  }
}
#endif
/*
 * Implementation of interface class OrgExampleChatInterface
 */

OrgExampleChatInterface::OrgExampleChatInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
{
}

OrgExampleChatInterface::~OrgExampleChatInterface()
{
}


<qt-dbus-proxy-ex>

<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node>
  <interface name="org.example.sender">

    <property name="Powered" type="b" access="readwrite"/>

  </interface>
</node>


which produces proxy code when runs qdbusxml2cpp:

class OrgExampleSenderInterface: public QDBusAbstractInterface
{
    Q_OBJECT

public:
    OrgExampleSenderInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = nullptr);

    ~OrgExampleSenderInterface();

    Q_PROPERTY(bool Powered READ powered WRITE setPowered)
    inline bool powered() const
    { return qvariant_cast< bool >(property("Powered")); }
    inline void setPowered(bool value)
    { setProperty("Powered", QVariant::fromValue(value)); }
};


// -----------------------------------------------------------------------------
/**
 *	@class BluezAdapterInterface
 *	@brief Proxy class for dbus interface org.bluez.Adapter1
 *
 *	This header was originally generated by the qdbusxml2cpp tool based on
 *	org.bluez.Adapter1.xml interface specification.
 *
 *	It has been modified in the following ways:
 *	  - Inherited from DBusAbstractInterface rather than QDBusAbstractInterface
 *	  - Added notify signals to some of the properties
 *	  - Move the construct and destructor bodies into this header file
 *
 */
class BluezAdapterInterface : public DBusAbstractInterface
{
  Q_OBJECT

  public:
    static inline const char *staticInterfaceName()
    { return "org.bluez.Adapter1"; }

  public:
    BluezAdapterInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = nullptr)
      : DBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
    { }

    ~BluezAdapterInterface()
    { }

    Q_PROPERTY(QString Address READ address)
      inline QString address() const
      { return qvariant_cast< QString >(property("Address")); }

    Q_PROPERTY(QString Alias READ alias WRITE setAlias NOTIFY aliasChanged)
      inline QString alias() const
      { return qvariant_cast< QString >(property("Alias")); }
    inline void setAlias(const QString &value)
    { setProperty("Alias", QVariant::fromValue(value)); }

    Q_PROPERTY(quint32 Class READ deviceClass NOTIFY deviceClassChanged)
      inline quint32 deviceClass() const
      { return qvariant_cast< quint32 >(property("Class")); }

    Q_PROPERTY(bool Discoverable READ discoverable WRITE setDiscoverable NOTIFY discoverableChanged)
      inline bool discoverable() const
      { return qvariant_cast< bool >(property("Discoverable")); }
    inline void setDiscoverable(bool value)
    { setProperty("Discoverable", QVariant::fromValue(value)); }

    Q_PROPERTY(uint DiscoverableTimeout READ discoverableTimeout WRITE setDiscoverableTimeout NOTIFY discoverableTimeoutChanged)
      inline uint discoverableTimeout() const
      { return qvariant_cast< uint >(property("DiscoverableTimeout")); }
    inline void setDiscoverableTimeout(uint value)
    { setProperty("DiscoverableTimeout", QVariant::fromValue(value)); }

    Q_PROPERTY(bool Discovering READ discovering NOTIFY discoveringChanged)
      inline bool discovering() const
      { return qvariant_cast< bool >(property("Discovering")); }

    Q_PROPERTY(QString Modalias READ modAlias NOTIFY modAliasChanged)
      inline QString modAlias() const
      { return qvariant_cast< QString >(property("Modalias")); }

    Q_PROPERTY(QString Name READ name NOTIFY nameChanged)
      inline QString name() const
      { return qvariant_cast< QString >(property("Name")); }

    Q_PROPERTY(bool Pairable READ pairable WRITE setPairable NOTIFY pairableChanged)
      inline bool pairable() const
      { return qvariant_cast< bool >(property("Pairable")); }
    inline void setPairable(bool value)
    { setProperty("Pairable", QVariant::fromValue(value)); }

    Q_PROPERTY(quint32 PairableTimeout READ pairableTimeout WRITE setPairableTimeout NOTIFY pairableTimeoutChanged)
      inline quint32 pairableTimeout() const
      { return qvariant_cast< quint32 >(property("PairableTimeout")); }
    inline void setPairableTimeout(quint32 value)
    { setProperty("PairableTimeout", QVariant::fromValue(value)); }

    Q_PROPERTY(bool Powered READ powered WRITE setPowered NOTIFY poweredChanged)
      inline bool powered() const
      { return qvariant_cast< bool >(property("Powered")); }
    inline void setPowered(bool value)
    { setProperty("Powered", QVariant::fromValue(value)); }

    Q_PROPERTY(QStringList UUIDs READ uuids NOTIFY uuidsChanged)
      inline QStringList uuids() const
      { return qvariant_cast< QStringList >(property("UUIDs")); }

    public slots:
      inline QDBusPendingReply<> RemoveDevice(const QDBusObjectPath &device)
      {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(device);
        return asyncCallWithArgumentList(QStringLiteral("RemoveDevice"), argumentList);
      }

    inline QDBusPendingReply<> SetDiscoveryFilter(const QVariantMap &properties)
    {
      QList<QVariant> argumentList;
      argumentList << QVariant::fromValue(properties);
      return asyncCallWithArgumentList(QStringLiteral("SetDiscoveryFilter"), argumentList);
    }

    inline QDBusPendingReply<> StartDiscovery()
    {
      QList<QVariant> argumentList;
      return asyncCallWithArgumentList(QStringLiteral("StartDiscovery"), argumentList);
    }

    inline QDBusPendingReply<> StopDiscovery()
    {
      QList<QVariant> argumentList;
      return asyncCallWithArgumentList(QStringLiteral("StopDiscovery"), argumentList);
    }

signals:
    void aliasChanged(const QString& newAlias);
    void deviceClassChanged(quint32 deviceClass);
    void discoverableChanged(bool discoverable);
    void discoverableTimeoutChanged(uint newDiscoverableTimeout);
    void discoveringChanged(bool discovering);
    void modAliasChanged(const QString& newModAlias);
    void nameChanged(const QString& newName);
    void pairableChanged(bool pairable);
    void pairableTimeoutChanged(uint newPairableTimeout);
    void poweredChanged(bool powered);
    void uuidsChanged(const QStringList &newUuids);
};



<qt-dbus-peer-to-peer>

class BleRcuControllerAdaptorTest : public ::testing::Test
{
  public:
    void SetUp()
    {
      m_mockController = QSharedPointer<MockBleRcuController>::create();

      m_dbusServer = new QDBusServer();

      /* 
      https://doc.qt.io/qt-5/qdbusserver.html#details

      void QDBusServer::setAnonymousAuthenticationAllowed(bool value)
      If value is set to true, an incoming connection can proceed even if the
      connecting client is not authenticated as a user.

      By default, this value is false.
      */

      m_dbusServer->setAnonymousAuthenticationAllowed(true);

      m_newConnectionReady = false;

      /* 
      void QDBusServer::newConnection(const QDBusConnection &connection);

      This signal is emitted when a new client connection connection is
      established to the server.
      */

      QObject::connect(m_dbusServer, &QDBusServer::newConnection,
          std::bind(&BleRcuControllerAdaptorTest::onNewConnection, this, std::placeholders::_1));

      processEventsFor(10);

      /*
      QDBusConnection QDBusConnection::connectToPeer(const QString &address, const QString &name);

      Opens a peer-to-peer connection on address address and associate with it
      the connection name name. Returns a QDBusConnection object associated
      with that connection.
      This function was introduced in Qt 4.8.
      */

      // for some reason the name of the server has to be unique, use a UUID as conventient for now
      
      const QUuid name = QUuid::createUuid();
      m_dbusConn = QSharedPointer<QDBusConnection>::create(QDBusConnection::connectToPeer(m_dbusServer->address(), name.toString()));

      // if all goes to plan then onNewConnection() should be called, wait for
      // that to happen before proceeding
      std::function<bool()> lambda = [this]() {
        return m_newConnectionReady;
      };

      ASSERT_TRUE(processEventsUtil(lambda, 1000));
      ASSERT_TRUE(m_dbusConn->isConnected());
    }

    void TearDown()
    {
      m_dbusConn.reset();

      m_dbusServer->deleteLater();
      m_dbusServer = nullptr;

      m_mockController.reset();
    }

  protected:
    QDBusServer *m_dbusServer;
    QSharedPointer<QDBusConnection> m_dbusConn;
    bool m_newConnectionReady;

    QSharedPointer<MockBleRcuController> m_mockController;

  protected:
    const QString m_deviceObjPath = QStringLiteral("/com/sky/blercu/monkeycontroller");
    const QString m_interfaceName = QStringLiteral("com.sky.blercu.Controller1");

  protected:
    void onNewConnection(const QDBusConnection &connection)
    {
      QDBusConnection newConn(connection);

      // will be owned by m_mockController and therefore automatically
      // deleted with the mock controller is destructed (no memory leak here)
      BleRcuController1Adaptor *adaptor = new BleRcuController1Adaptor(m_mockController.data(),
          QDBusObjectPath(m_deviceObjPath));
      adaptor->registerConnection(newConn);

      if (!newConn.registerObject(m_deviceObjPath, m_mockController.data()))
        qCritical("failed to register blercucontroller adaptor object");

      // indicate the next connection is ready
      m_newConnectionReady = true;
    }

  protected:
    QDBusMessage constructGetPropertyMethod(const QString &name)
    {
      QDBusMessage request = QDBusMessage::createMethodCall("", m_deviceObjPath, "org.freedesktop.DBus.Properties", "Get");
      request << m_interfaceName;
      request << name;
      return request;
    }

    QDBusVariant getPropertyFromDBus(const QString &name)
    {
      // construct the request
      QDBusMessage request = constructGetPropertyMethod(name);

      // perform the request
      QDBusMessage reply = m_dbusConn->call(request, QDBus::BlockWithGui);
      EXPECT_EQ(reply.type(), QDBusMessage::ReplyMessage);

      // check the reply
      QList<QVariant> results = reply.arguments();
      EXPECT_EQ(results.length(), 1);
      EXPECT_TRUE(results.first().canConvert<QDBusVariant>());

      return results.first().value<QDBusVariant>();
    }
};

TEST_F(BleRcuControllerAdaptorTest, testPairingProperty)
{
  const QList<bool> values = { true, false };

  for (bool value : values) {

    // expect the the device name will be queried
    EXPECT_CALL(*m_mockController, isPairing())
      .WillOnce(::testing::Return(value));

    // get the property
    const QDBusVariant pairingVar = getPropertyFromDBus("Pairing");

    // check it
    const QVariant pairing = pairingVar.variant();
    EXPECT_TRUE(pairing.canConvert<bool>());
    EXPECT_EQ(pairing.toBool(), value);
  }
}


# ============================================================================
#{
={============================================================================
|kt_dev_qt_0001| qt-creator-command

kyoupark@kit-debian64:~$ cat ~/.local/share/applications/DigiaQt-qtcreator-community.desktop
[Desktop Entry]
Type=Application
Exec=/home/kyoupark/Qt/Tools/QtCreator/bin/qtcreator
Name=Qt Creator (Community)
GenericName=The IDE of choice for Qt development.
Icon=QtProject-qtcreator
StartupWMClass=qtcreator
Terminal=false
Categories=Development;IDE;Qt;
MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs;


={============================================================================
|kt_dev_qt_0001| qt-creator-project

http://doc.qt.io/qtcreator/creator-project-creating.html

In addition, you can import projects as generic projects that do not use
qmake, Qbs, or CMake. This enables you to use Qt Creator as a code editor and
to fully control the steps and commands used to build the project.


Device	
An embedded device or a mobile device. For more information, see Target
Platforms.

Kit	
Qt Creator groups build and run specific settings as kits to make
cross-platform development easier. Each kit consists of a set of values that
define one environment, such as a device, tool chain, Qt version, and debugger
command to use. Configure kits at Tools > Options > Build & Run > Kits.

Import Project

Import Existing Project
Import an existing project that does not use any of the supported build
systems: qmake, Qbs, CMake, or Autotools. This enables you to use Qt Creator
as a code editor


={============================================================================
|kt_dev_qt_0001| qt-edit-navigate

{code-model}
http://doc.qt.io/qtcreator/creator-clang-codemodel.html

Activating Clang Code Model

If you build Qt Creator yourself, ensure that the plugin is also built, as described in the Qt Creator README file.

To activate the plugin:

Select Help > About Plugins > C++ > ClangCodeModel to enable the plugin.

Restart Qt Creator to be able to use the plugin.


Checking Code Syntax

As you write code, Qt Creator checks code syntax. When Qt Creator spots a
syntax error in your code it underlines it and shows error details when you
move the mouse pointer over the error. Similarly, when you are working on an
instance of a JavaScript object notation (JSON) entity, Qt Creator underlines
errors in JSON data structure.


When using the Clang code model, errors and warnings are additionally marked
with icons and annotated. If a Clang fix-it is available, you can execute it
by clicking the  icon and pressing Enter.

To specify the position where the annotations are displayed, select 

Tools > Options > Text Editor > Display > Annotations next to lines, 
      
and then select whether to display the annotations directly next to the code,
aligned to the right of the code, or in the right margin.


Searching with the Locator

To activate the locator:

Press Ctrl+K (Cmd+K on macOS).

Using Locator Filters

The locator enables you to browse not only files, but any items defined by
locator filters. By default, the locator contains filters for:

Locating any open document (o)

Locating files anywhere on your file system (f)

Locating files belonging to your project (p), such as source, header resource, and .ui files, or to any project (a)

Locating class (c), `enum, and function (m) definitions` in your project or
anywhere referenced from your project (:)

Locating symbols in the current document (.)
Locating a specific line and column in the document displayed in your editor
(l <line_number>:<column_number>)

Opening help topics, including Qt documentation (?)

Performing web searches (r)
Running text editing macros that you record and save (rm). For more
information, see Using Text Editing Macros

Executing shell commands (!)
Executing version control system commands (git). For more information, see
Using Version Control Systems

Running external tools (x)

To use a specific locator filter, `type the assigned prefix followed by space.`
The prefix is usually a single character. Then type the search string
(typically, a filename or class name) or the command to execute.

Filters locating files also accept paths, such as tools/*main.cpp. 
                                                         
Filters locating class and function definitions also accept namespaces, such
as Utils::*View.


To jump to a line and column in the current file, select the line and column
indicator (5) or press Ctrl+L (or Cmd+L on macOS) to open the locator. Enter
the line number and column number in the locator, separated by a colon (:).


Moving to Symbol Definition or Declaration

You can move directly to the definition or the declaration of a symbol by
holding the Ctrl key and clicking the symbol. If you have multiple splits
opened, you can open the link in the next split by holding Ctrl and Alt while
clicking the symbol.

To enable this moving function, select Tools > Options > Text Editor >
Behavior > Enable mouse navigation.

You can also select the symbol and press F2, or right-click the symbol and
select Follow Symbol Under Cursor to move to its definition or declaration.

This feature is supported for namespaces, classes, functions, variables,
include statements, and macros.

To switch between the definition and declaration of a function, place the
cursor on either and press `Shift+F2` or right-click and select Switch Between
Function Declaration/Definition. For example, this allows you to navigate from
anywhere within a function body directly to the function declaration.

Links are opened in the same split by default. To open links in the next
split, prepend Ctrl+E to the shortcut. For example, press Ctrl+E,F2 to follow
the symbol in the next split. If necessary, the view is automatically split.
To change the default behavior, select Tools > Options > Text Editor > Display
> Always open links in another split. Additional symbols are displayed and
switching between definition and declaration is done in another split. If you
change the default behavior, the shortcuts for opening link targets in the
next split are used to open them in the current split.


Generic Highlighting

Generic highlighting is based on highlight definition files that are provided
by the Kate Editor. You can download highlight definition files for use with
Qt Creator. For more information about the definition files, see
KDE-Files.org.


={============================================================================
|kt_dev_qt_0001| qt-edit-encoding

<edit-encoding>
To show the file encoding of the current file on the editor toolbar (6),
select Tools > Options > Text Editor > Display > Display file encoding. To
  change the encoding, click it on the toolbar and select new encoding in the
  Text Encoding dialog. To reload the file with the selected encoding, select
  Reload with Encoding. To save the file with the new encoding, select Save
  with Encoding.


={============================================================================
|kt_dev_qt_0001| qt-edit-view

You can view multiple files simultaneously in the following ways:

To split the editor view into a top and bottom view, select Window > Split, press Ctrl+E, 2, or select the  (Split) button and then select Split.
Split command creates views below the currently active editor view.

To split the editor view into adjacent views, select Window > Split Side by Side, press Ctrl+E, 3, or select Split > Split Side by Side.
Side by side split command creates views to the right of the currently active editor view.

To open the editor in a detached window, press Ctrl+E, 4, or select Window > Open in New Window.
The new window behaves basically in the same way as the editor area in the main window. For example, you can split this window, as well. Documents are opened in the currently active editor window.

To move between split views and detached editor windows, select Window > Go to Next Split or Window or press Ctrl+E, O.

To remove a split view, place the cursor within the view you want to remove and select Window > Remove Current Split, press Ctrl+E, 0, or select the  (Remove Split) button. To remove all but the currently selected split view, select Window > Remove All Splits or press Ctrl+E, 1.


={============================================================================
|kt_dev_qt_0001| qt-edit-reparse

Reparsing Externally Changed Files

If source files are modified from outside Qt Creator, the opened files will be
reparsed automatically. For all other files, you can use Tools > C++ > Reparse
Externally Changed Files to update the code model.


==============================================================================
Copyrightobjdump see |ktkb|                        vim:tw=100:ts=3:ft=help:norl:
