*kt_dev_qt*                                                                tw=100

kt.dev.qt

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_qt_0001| qt-book
|kt_dev_qt_0001| qt-install
|kt_dev_qt_0001| qt-creator-command
|kt_dev_qt_0001| qt-creator-project
|kt_dev_qt_0001| qt-edit-navigate
|kt_dev_qt_0001| qt-edit-encoding
|kt_dev_qt_0001| qt-edit-view


={============================================================================
|kt_dev_qt_0001| qt-book

http://wiki.qt.io/Books

Learning Qt 5 (Video)
Authors: Symeon Huang
Publish: April 2017
ISBN: 978-1787285972

An easy to follow, example-based, comprehensive introduction to all the major
features in Qt Available from Packt


={============================================================================
|kt_dev_qt_0001| qt-install

https://wiki.qt.io/Install_Qt_5_on_Ubuntu

Adjust permission, run the installer and follow the instruction to complete
the installation.

chmod +x qt-opensource-linux-x64-5.7.0.run
./qt-opensource-linux-x64-5.7.0.ru

http://doc.qt.io/qt-5/linux.html
Requirements for Development Host

The Qt installers for Linux assume that a C++ compiler, debugger, make, and
other development tools are provided by the host operating system. In
addition, building graphical Qt applications requires OpenGL libraries and
headers installed. Most Linux distributions do not install all of these by
default, but setting up a development environment is still straightforward.

Use the following commands to install the basic requirements for building Qt
applications:

note:
if there is no libgl1-mesa-dev, then see build errors

sudo apt-get install build-essential libgl1-mesa-dev


={============================================================================
|kt_dev_qt_0001| qt-tutorial

https://wiki.qt.io/Qt_for_Beginners

<qt-event-loop>

QApplication is a very important class. It takes care of input arguments, but
also a lot of other things, and most notably, the event loop. The event loop is
a loop that waits for user input in GUI applications.

When calling app.exec() the event loop is launched.


<attribute-or-property>

Qt extends this system of attributes and getters and setters to something called
property. A property is a value of any type that can be accessed, be modified or
constant, and can notify a change. The property system is useful, especially in
the third part (QML). For now, we will use "attribute" or "property" to do the
same thing.


<qt-object>

QObject is the most basic class in Qt. Most of classes in Qt inherit from this
class. QObject provides some very powerful capabilities like:

o object name : you can set a name, as a string, to an object and search for
  objects by names.

o parenting system (described in the following section)

o signals and slots (described in the next chapter)

o event management


Parenting system

Parenting system is a convenient way of dealing with objects in Qt, especially
widgets. Any object that inherits from QObject can have a parent and children.
This hierarchy tree makes many things convenient:

When an object is destroyed, all of its children are destroyed as well. So,
calling delete becomes optional in certain cases.

All QObjects have findChild and findChildren methods that can be used to search
for children of a given object.

Child widgets in a QWidget automatically appear inside the parent widget.


<tut-01>

main.cpp:

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  QPushButton button(" Hello Qt Widget");

  // o The following snippet that creates a QPushButton inside a QPushButton:
  // o button(parent) <- button2(child)
  // o button2 is on top of button

  QPushButton button2(" Other", &button);

  button.setToolTip(" Hello Tootip");

  QFont font("Hack");
  button.setFont(font);

  button.setIcon(QIcon::fromTheme("face-smile"));

  button.show();

  return a.exec();
}


<tut-02>

main.cpp:

#include "mainwindow.h"
#include <QApplication>
#include <QPushButton>

/*

Project Type: Qt Widgets Application

Creates a Qt application for the desktop. Includes a Qt Designer-based main
window.

Preselects a desktop Qt for building the application if available.

The following code is used to display a button inside a MainWindow:

Unlike Tutorial 1, uses `MainWindow` which has window panel and add a button to
it. 

*/

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    MainWindow w;

    QPushButton *button = new QPushButton("Hello Qt Tutorial 2", &w);
    button->setGeometry(20, 20, 180, 30);

    w.show();

    return a.exec();
}


<tut-03>

/*

https://wiki.qt.io/Qt_for_Beginners

Subclassing QWidget

Until now, we have put all of our code in the main function. This was not a
problem for our simple examples, but for more and more complex applications we
might want to split our code into different classes. What is often done is to
create a class that is used to display a window, and implement all the widgets
that are contained in this window as attributes of this class.

Please note that there is no need for writing a destructor for deleting
m_button. With the parenting system, when the Window instance is out of the
stack, the m_button is automatically deleted.


Signals and slots

Observer pattern is used everywhere in GUI applications, and often leads to some
boilerplate code. Qt was created with the idea of removing this boilerplate code
and providing a nice and clean syntax, and the signal and slots mechanism is the
answer.

Instead of having observable objects and observers, and registering them, Qt
provides two high level concepts: signals and slots.

o A signal is a message that an object can send, most of the time to inform of a
status change.

o A slot is a function that is used to accept and respond to a signal.

In order to respond to a signal, a slot must be connected to a signal. Qt
provides the method QObject::connect. It is used this way, with the two macros
SIGNAL and SLOT

FooObjectA *fooA = new FooObjectA();
FooObjectB *fooB = new FooObjectB();

QObject::connect(fooA, SIGNAL (bared()), fooB, SLOT (baz()));

assuming that FooObjectA have a bared signal, and FooObjectB have a baz slot.

You have to write the signature of the signal and the slot inside the two macros
SIGNAL and SLOT.

Remark : Basically, signals and slots are methods, that might or might not have
arguments, but that never return anything. While the notion of a signal as a
method is unusual, a slot is actually a real method, and can be called as usual
in other methods, or whilst responding to a signal.


Transmitting information

The signals and slots mechanism is useful to respond to buttons clicks, but it
can do much more than that. For example, It can also be used to communicate
information. Let's say while playing a song, a progress bar is needed to show
how much time remains before the song is over. A media player might have a class
that is used to check the progress of the media. An instance of this class might
periodically send a tick signal, with the progress value. This signal can be
connected to a QProgressBar, that can be used to display the progress.

The hypothetical class used to check the progress might have a signal that have
this signature :

void MediaProgressManager::tick(int miliseconds);

and we know from the documentation, that the QProgressBar has this slot:

void QProgressBar::setValue(int value);

You can see that the signal and the slot have the same kind of parameters,
    especially the type. If you connect a signal to a slot that does not share
    the same kind of parameters, when the connection is done (at run-time) you
    will get a warning like:

QObject::connect: Incompatible sender/receiver arguments

This is because the signal transmits the information to the slot using the
parameters. The first parameter of the signal is passed to the first one of the
slot, and the same for second, third, and so forth.

The code for the connection will look like this:

MediaProgressManager *manager = new MediaProgressManager();
QProgressBar *progress = new QProgressBar(window);

QObject::connect(manager, SIGNAL (tick(int)), progress, SLOT (setValue(int)));

You can see that you have to `provide a signature inside the SIGNAL and SLOT`
macro, providing the type of the values that are passed through the signals. You
may also provide the name of the variable if you want. (It is actually even
better).


Features of signals and slots

o A signal can be connected to several slots (1:N)

o Many signals can be connected to a slot (N:1)

o A signal can be connected to a signal: it is signal relaying. The second
  signal is sent if the first signal is sent.


Responding to an event

Let's try to actually make something with this app, like being able to close it
while clicking on the button. We already know that QPushButton provides the
clicked signal. We also have to know that QApplication provides the quit slot,
that closes the application.

In order to make a click on a button close the app, we have to connect the
signal clicked of the button to the quit slot of QApplication instance. We can
modify the code from the previous chapter to do this, but before that, you might
wonder how to access to the QApplication instance while you are in another
class. Actually, it is pretty simple, since there exists a static function in
QApplication, with the following signature, that is used to get it:

QApplication * QApplication::instance()

*/

window.cpp:

Window::Window(QWidget *parent) :
  QWidget(parent),
  ui(new Ui::Window)
{
  ui->setupUi(this);

  // setFixedSize(100, 50);
  m_button = new QPushButton("Hello World", this);
  m_button->setGeometry(10, 10, 180, 30);

  // do the connection
  connect(m_button, SIGNAL(clicked()), QApplication::instance(), SLOT(quit()));
}

Window::~Window()
{
  delete ui;
}


<tut-04>

/*

https://wiki.qt.io/Qt_for_Beginners

Transmitting information with signals and slots

Here is a simpler example for information transmission. It only displays a
progress bar and a slider (created by QSlider) inside a window, and while the
slider is moved, the value of the progress bar is synced with a very simple
connection.

The interesting signals and slots are:

void QSlider::valueChanged(int value);
void QProgressBar::setValue(int value);

QSlider automatically emits the signal valueChanged with the new value passed as
a parameter when the value is changed, and the method setValue of QProgressBar,
is used, as we have seen, to set the value of the progress bar.

*/

main.cpp:

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  // MainWindow w;
  // w.show();

  // create a container window
  QWidget window;
  window.setFixedSize(200, 80);

  // create a progress bar
  QProgressBar *progressBar = new QProgressBar(&window);
  progressBar->setRange(0, 100);
  progressBar->setValue(0);
  progressBar->setGeometry(10, 10, 180, 30);

  // create a horizontal silder
  QSlider *slider = new QSlider(&window);
  slider->setOrientation(Qt::Horizontal);
  slider->setRange(0, 100);
  slider->setValue(0);
  slider->setGeometry(10, 40, 180, 30);

  window.show();

  // connection
  QObject::connect(slider, SIGNAL(valueChanged(int)),
      progressBar, SLOT(setValue(int)));

  return a.exec();
}


<tut-05>

mainwindow.h:

#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QPushButton>

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = 0);
    ~MainWindow();


/*

Emitting custom signals

Based on the previous example, we want to close the application if the button is
clicked (checked or unchecked) 10 times. We first need to implement a counter
that will count the number of clicks. 

Now, we have to create a custom signal that is used to notify other components,
that the counter has reached 10. In order to declare a signal, we have to add a

note: Even if the signal is declared as a method, there is `no need to implement`
it. The meta-object compiler is used to do this.

*/

signals:
    void counterReached();
    void signalNotConnected();

private slots:
    void slotButtonClicked(bool checked);

private:
    QPushButton *m_button;
    int m_counter;
};

#endif // MAINWINDOW_H


mainwindow.cpp:

/*

https://wiki.qt.io/Qt_for_Beginners

The Meta Object

Qt provides a meta-object system. Meta-object (literally "over the object") is a
way to achieve some programming paradigms that are normally impossible to
achieve with pure C++ like:

Introspection : capability of examining a type at run-time
Asynchronous function calls

To use such meta-object capabilities in an application, one can subclass QObject
and mark it so that the "meta-object compiler (moc)" can interpret and translate
it.

Code produced by moc includes signals and slots signatures, methods that are
used to retrieve meta-information from those marked classes, properties
handling... All this information can be accessed using the following method:

const QMetaObject * QObject::metaObject () const

QMetaObject class contains all the methods that deal with meta-objects.

Important macros

The most important macro is Q_OBJECT. Signal-Slot connections and their syntax
cannot be interpreted by a regular C++ compiler. The moc is provided to
translate the QT syntax like "connect", "signals", "slots", etc into regular C++
syntax. This is done by specifying the Q_OBJECT macro in the header containing
class definitions that use such syntax.

mywidget.h

class MyWidget : public QWidget
{
 Q_OBJECT
 public:
  MyWidget(QWidget *parent = 0);
}


Others marker macros for moc are

signals
public / protected / private slots

that mark the different methods that need to be extended.

SIGNAL and SLOT are also two very important and useful macros. When a signal is
emitted, the meta-object system is used to compare the signature of the signal,
to check the connection, and to find the slot using it's signature. These macros
are actually used to convert the provided method signature into a string that
matches the one stored in the meta-object.

{
https://doc.qt.io/qt-5/signalsandslots.html

Signals

Signals are emitted by an object when its internal state has changed in some way
that might be interesting to the object's client or owner. Signals are public
access functions and can be emitted from anywhere, but we recommend to only emit
them from the class that defines the signal and its subclasses.

When a signal is emitted, the slots connected to it are usually executed
immediately, just like a normal function call. When this happens, the signals
and slots mechanism is `totally independent of any GUI event loop.` Execution of
the code following the emit statement will occur once all slots have returned.
The situation is slightly different when using `queued connections`; in such a
case, the code following the emit keyword will continue immediately, and the
slots will be executed later.

If several slots are connected to one signal, the slots will be executed one
after the other, in the order they have been connected, when the signal is
emitted.

Signals are automatically generated by the moc and must not be implemented in
the .cpp file. They can never have return types (i.e. use void).

A note about arguments: Our experience shows that signals and slots are more
reusable if they do not use special types. If QScrollBar::valueChanged() were to
use a special type such as the hypothetical QScrollBar::Range, it could only be
connected to slots designed specifically for QScrollBar. Connecting different
input widgets together would be impossible.

enum Qt::ConnectionType

This enum describes the types of connection that can be used between signals and
slots. In particular, it determines whether a particular signal is delivered to
a slot immediately or queued for delivery at a later time.

Description

Qt::AutoConnection	

(Default) If the receiver lives in the thread that emits the signal,
  Qt::DirectConnection is used. Otherwise, Qt::QueuedConnection is used. The
  connection type is determined when the signal is emitted.
}

Creating custom signals and slots

This chapter covers the second part of signals and slots: implementing custom
signals and slots.

Creating custom slots and signals is really simple. Slots are like normal
methods, but with small decorations around, while signals need little to no
implementation at all.

Creating custom signals and slots is very simple. It is described by the
following checklist:

add Q_OBJECT macro

add signals section, and write signals prototypes

add public slots or protected slots or private slots sections, and write slots
prototypes

implement slots as normal methods

establish connections


Creating custom slots

In order to implement a slot, we first need to make the class be able to send
signals and have slots (see the previous chapter). This is done by setting the
Q_OBJECT macro in the class declaration (often in the header).

After that, a slot should be declared in the corresponding section, and
implemented as a normal method.

Finally, slots are connected to signals.

*/

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
  m_button = new QPushButton("Hello World", this);
  m_button->setCheckable(true);

  // set the counter to 0
  m_counter = 0;

  // note: have to have this. If not, do not increase counter and not exit app.

  connect(m_button, SIGNAL(clicked(bool)),
      this, SLOT(slotButtonClicked(bool)));

  // Connecting the newly created signal to the quit slot is done as usual:

  connect(this, SIGNAL(counterReached()),
      QApplication::instance(), SLOT(quit()));
}

MainWindow::~MainWindow()
{
}

/*

We also add our custom slot. Since we are trying to react from the button being
checked, and since the corresponding signal is

void QPushButton::clicked(bool checked)

`checked` makes a button "pressed down" when clicked and need to click it
again to make "pressed up".

*/

void MainWindow::slotButtonClicked(bool checked)
{
  if (checked)
  {
    m_button->setText("Checked");
  }
  else
  {
    m_button->setText("Hello Qt World!");
  }

  ++m_counter;

  // what if emits a signal which is not connected? nothing happens.
  emit signalNotConnected();

  if (m_counter == 10)
  {
    emit counterReached();
  }
}


<tut-06>

#ifndef WINDOW_H
#define WINDOW_H

#include <QWidget>
#include <QPushButton>
#include <QKeyEvent>

namespace Ui {
class Window;
}

class Window : public QWidget
{
    Q_OBJECT

public:
    explicit Window(QWidget *parent = nullptr);
    ~Window();

protected:
    virtual void keyPressEvent(QKeyEvent *event) override;
    virtual bool event(QEvent *e) override;
    virtual void mousePressEvent(QMouseEvent *event) override;
    virtual void customEvent(QEvent *event) override;

// private slots:
//   void slotButtonClicked(bool checked);

private:
    Ui::Window *ui;
    QPushButton *m_button;
};

#endif // WINDOW_H


window.cpp:

/*
<qt-event>

https://doc.qt.io/qt-5/qevent.html

Detailed Description

The QEvent class is the base class of all event classes. Event objects contain
event parameters.

Qt's main event loop (QCoreApplication::exec()) fetches native window system
events from the event queue, translates them into QEvents, and sends the
translated events to QObjects.

In general, events come from the underlying window system (spontaneous() returns
true), but it is also possible to manually send events using
QCoreApplication::sendEvent() and QCoreApplication::postEvent() (spontaneous()
returns false).

`QObjects receive events by having their QObject::event() function called.` The
function can be reimplemented in subclasses to customize event handling and add
additional event types; QWidget::event() is a notable example. By default,
events are dispatched to event handlers like QObject::timerEvent() and
QWidget::mouseMoveEvent(). QObject::installEventFilter() allows an object to
intercept events destined for another object.

The basic QEvent contains only an event type parameter and an "accept" flag. The
accept flag set with accept(), and cleared with ignore(). It is set by default,
but don't rely on this as subclasses may choose to clear it in their
constructor.


https://doc.qt.io/archives/qq/qq11-events.html

The Origins of Events

Events can be divided into three categories based on how they are created and
how they are dispatched:

Spontaneous events are generated by the window system. They are put in a system
queue and processed one after the other by the event loop.

Posted events are generated by Qt or by the application. They are queued by Qt
and `processed by the event loop.`

Sent events are generated by Qt or by the application, but they are sent
`directly to the target object.`

When we call QApplication::exec() at the end of our main() function, the
application enters Qt's event loop. Conceptually, the event loop looks like
this:

    while (!exit_was_called) {
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
        while (!spontaneous_event_queue_is_empty) {
            process_next_spontaneous_event();
        }
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
    }
    
First, the event loop processes any posted events until the queue is empty.
Then, it processes the spontaneous events until there are none left. Finally, it
processes any posted events that were generated during the processing of the
spontaneous events.

Sent events are not handled by the event loop. They are delivered directly to
the object.

Let's see how this works in practice with paint events. When a widget is made
visible for the first time, or when it's made visible after being obscured, the
window system generates a (spontaneous) paint event to ask the program to redraw
the widget. The event loop eventually picks up the event and dispatches it to
the widget that needs to be redrawn.

Not all paint events are generated by the window system. When you call
QWidget::update() to redraw a widget, the widget posts a paint event to itself.
The paint event is queued and eventually dispatched by the event loop.

If you're impatient and can't wait for the event loop to redraw a widget, you
could in theory call paintEvent() directly to force an immediate repaint. But in
practice this isn't always possible because paintEvent() is a protected
function. This would also bypass any existing event filter. For that reason, Qt
provides a mechanism for sending events directly rather than posting them.
QWidget::repaint() uses this mechanism to force an immediate repaint.

One advantage of posting events as opposed to sending them is that posting gives
Qt the opportunity to compress them. If you call update() ten times in
succession on the same widget without returning to the event loop, the ten
events generated by update() will automatically be merged into a single event
with the union of the regions specified in all their QPaintEvents. Compressible
event types include paint events, move events, resize events, layout hint
events, and language change events.

Finally, note that you can call QApplication::sendPostedEvents() at any time to
force Qt to process an object's posted events at the time of the call.


Event Handling and Filtering

Events in Qt can be processed on five different levels.

o Reimplementing a specific event handler. 
QObject and QWidget provide many specific event handlers for different types of
events (for example, paintEvent() for paint events).

o Reimplementing QObject::event(). 
The event() function is the entry point for all of an object's events. The
default implementations in QObject and QWidget simply forward the events to the
specific event handlers.

o Installing an event filter on a QObject.
An event filter is an object that receives another object's events before they
reach the intended target.

o Installing an event filter on qApp.
Exceptionally, an event filter on qApp monitors all events sent to all objects
in the application.

o Reimplementing QApplication::notify().
Qt's event loop and sendEvent() call this function to dispatch events. By
reimplementing it, you get to see events before anybody else.


Some event types can be `propagated`. This means that if a target doesn't handle
an event, Qt tries to find another receiver for the event and calls
QApplication::notify() with the new target.  For example, key events are
propagated; if the widget that has the focus doesn't handle a certain key, Qt
dispatches the same event to the parent widget, then to the parent's parent, and
so on until it reaches the top-level widget.

*/

Window::Window(QWidget *parent) :
  QWidget(parent),
  ui(new Ui::Window)
{
  ui->setupUi(this);

  m_button = new QPushButton("Key Event", this);
  m_button->setGeometry(10, 10, 180, 30);

  // Q: do not work. why?
  // connect(m_button, SIGNAL(clicked()), 
  //     this, SLOT((slotButtonClicked)));
}

/*

keyPressEvent() is called whenever a key is pressed, and again when a key has
been held down long enough for it to auto-repeat. The Tab and Shift+Tab keys are
only passed to the widget if they are not used by the focus-change mechanisms.
To force those keys to be processed by your widget, you must reimplement
QWidget::event().


https://doc.qt.io/qt-5/qwidget.html#keyPressEvent

void QWidget::keyPressEvent(QKeyEvent *event)

This event handler, for event event, can be reimplemented in a subclass to
receive key press events for the widget.

A widget must call setFocusPolicy() to accept focus initially and have focus in
order to receive a key press event.

If you reimplement this handler, it is very important that you call the base
class implementation if you do not act upon the key.

The default implementation closes popup widgets if the user presses the key
sequence for QKeySequence::Cancel (typically the Escape key). Otherwise the
event is ignored, so that the widget's parent can interpret it.

Note that QKeyEvent starts with isAccepted() == true, so you do not need to call
QKeyEvent::accept() - just do not call the base class implementation if you act
upon the key.

See also keyReleaseEvent(), setFocusPolicy(), focusInEvent(), focusOutEvent(),
event(), QKeyEvent, and Tetrix Example.


https://doc.qt.io/archives/qq/qq11-events.html

Accept or Ignore?

Events that can be propagated have an accept() and an ignore() function that you
can call to tell Qt that you "accept" or "ignore" the event. If an event handler
calls accept() on an event, the event won't be propagated further; if an event
handler calls ignore(), Qt tries to find another receiver.

If you're like most Qt developers, you probably never really bothered calling
accept() and ignore() in your programs. And rightly so. Qt is designed in such a
way that you normally never need to call them. The default value is "accept",
and the default event handler implementations in QWidget call ignore(). If you
want to accept the event, you just need to reimplement the event handler and
avoid calling the QWidget implementation. If you want to ignore the event,
simply pass it on to the QWidget implementation. The following code snippet
illustrates the point:

    void MyFancyWidget::keyPressEvent(QKeyEvent *event)
    {
        if (event->key() == Key_Escape) {
            doEscape();
        } else {
            QWidget::keyPressEvent(event);
        }
    }
    
In this example, if the user presses Esc, we call doEscape() and the event is
accepted (the default). The event won't be propagated to the parent widget. If
the user presses any other key, we call QWidget's default implementation:

    void QWidget::keyPressEvent(QKeyEvent *event)
    {
        event->ignore();
    }
    
Thanks to the ignore() call, the event will be propagated to the parent widget.

*/

void Window::keyPressEvent(QKeyEvent *event)
{
  if (event->key() == Qt::Key_Escape)
  {
    // it will output to Qt Editor output window
    std::cout << "keyPressEvent:Key_Esacpe" << std::endl;
  }
}


/*

If for some reason you handle the event in event() instead of in a specific
handler such as keyPressEvent(), the procedure is somewhat different. The
event() function returns a bool that tells the caller whether the event was
accepted or not (true means "accept"). 

Calling accept() or ignore() on an event from event() is pointless. The "accept"
flag is a communication mechanism between the specific event handlers and
event(), whereas the bool return value of event() is used to communicate with
QApplication::notify(). The default event() implementation in QWidget converts
the "accept" flag into a bool as follows:

    bool QWidget::event(QEvent *event)
    {
        switch (e->type()) {
        case QEvent::KeyPress:
            keyPressEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
        case QEvent::KeyRelease:
            keyReleaseEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
            ...
        }
        return true;
    }

https://doc.qt.io/qt-5/qobject.html#event

bool QObject::event(QEvent *e)

This virtual function receives events to an object and should return true if the
event e was recognized and processed.

The event() function can be reimplemented to customize the behavior of an
object.

Make sure you call the parent event class implementation for all the events you
did not handle.

Example:

class MyClass : public QWidget
{
    Q_OBJECT

public:
    MyClass(QWidget *parent = 0);
    ~MyClass();

    bool event(QEvent* ev) override
    {
        if (ev->type() == QEvent::PolishRequest) {
            // overwrite handling of PolishRequest if any
            doThings();
            return true;
        } else  if (ev->type() == QEvent::Show) {
            // complement handling of Show if any
            doThings2();
            QWidget::event(ev);
            return true;
        }
        // Make sure the rest of events are handled
        return QWidget::event(ev);
    }
};

*/

bool Window::event(QEvent *e)
{
  // if (event->key() == Qt::Key_Escape)
  {
    // it will output to Qt Editor output window
    // std::cout << "Window::event: " << std::endl;
  }
  // Make sure the rest of events are handled
  return QWidget::event(e);
}


/*
note: it's on "Window"

Synthetic Events

Qt applications can generate their own events, either of predefined types or of
custom types. This is done by creating an instance of QEvent (or a subclass) and
calling QApplication::postEvent() or QApplication::sendEvent().

Both functions take a QObject * and a QEvent * as arguments. If you call
postEvent(), you must create the event object using new and Qt will
automatically delete it after it is processed. If you call sendEvent(), you must
create the event on the stack. Here's an example of posting an event:

    QApplication::postEvent(mainWin, 
      new QKeyEvent(QEvent::KeyPress, Key_X, 'X', 0));
    
Here's an example of sending an event:

    QKeyEvent event(QEvent::KeyPress, Key_X, 'X', 0);
    QApplication::sendEvent(mainWin, &event);
    
Qt applications rarely need to call postEvent() or sendEvent() directly because
most events are generated automatically by Qt or by the window system when
necessary. In most of the cases where you want to send an event, Qt includes a
high-level function that does it for you (for example, update() and repaint()).


https://doc.qt.io/qt-5/qcoreapplication.html#postEvent

static
void QWidget::mouseReleaseEvent(QMouseEvent *event)

This event handler, for event event, can be reimplemented in a subclass to
receive mouse release events for the widget.

void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority = Qt::NormalEventPriority)

Adds the event event, with the object receiver as the receiver of the event, to
an event queue and returns immediately.

note: "The event must be allocated on the heap" 

since the post event queue will take ownership of the event and delete it once
it has been posted. It is not safe to access the event after it has been posted.

When control returns to the main event loop, all events that are stored in the
queue will be sent using the notify() function.

Events are sorted in descending priority order, i.e. events with a high priority
are queued before events with a lower priority. The priority can be any integer
value, i.e. between INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for
more details. Events with equal priority will be processed in the order posted.

*/

void Window::mousePressEvent(QMouseEvent *event)
{
  {
    std::cout << "Window::mousePressEvent: post key event" << std::endl;
    QApplication::postEvent(this, 
        new QKeyEvent(QEvent::KeyPress, Qt::Key_Escape, 0, 0));
  }

  {
    std::cout << "Window::mousePressEvent: post custom event" << std::endl;
    const QEvent::Type MyEvent = (QEvent::Type)1234;
    QApplication::postEvent(this, new QEvent(MyEvent));
  }
}

/*

Custom Event Types

Qt lets you create your own event types. This technique is particularly useful
in multithreaded applications, as a means of communicating with the GUI thread;
see Chapter 17 of C++ GUI Programming with Qt 3 (p. 359) for an example.

Custom types can also be useful in single-threaded applications, as an
inter-object communication mechanism. The main reason why you would use events
rather `than standard "function calls, or signals and slots"`, is that events can
be used both synchronously and asynchronously (depending on whether you call
sendEvent() or postEvents()), whereas calling a function or invoking a slot is
always synchronous. Another advantage of events is that they can be filtered.
More on this in the next section.

Here's a code snippet that shows how to post a custom event:

    const QEvent::Type MyEvent = (QEvent::Type)1234;
    ...
    QApplication::postEvent(obj, new QCustomEvent(MyEvent));
    
The event must be of type QCustomEvent (or a subclass). The argument to the
constructor is the type of event. Values under 1024 are reserved by Qt for
predefined event types; other values can be used by applications.

`To handle custom event types, reimplement the customEvent() function`:

    void MyLineEdit::customEvent(QCustomEvent *event)
    {
        if (event->type() == MyEvent) {
            myEvent();
        } else {
            QLineEdit::customEvent(event);
        }
    }


https://doc.qt.io/qt-5/qobject.html#customEvent

[virtual protected]
void QObject::customEvent(QEvent *event)

This event handler can be reimplemented in a subclass to receive custom events.
Custom events are user-defined events with a type value at least as large as the
QEvent::User item of the QEvent::Type enum, and is typically a QEvent subclass.
The event is passed in the event parameter.

See also event() and QEvent.

*/

void Window::customEvent(QEvent *event)
{
  if (event->type() == ((QEvent::Type)1234))
  {
    std::cout << "Window::customEvent: got custom event" << std::endl;
  }
}

Window::~Window()
{
  delete ui;
}


# ============================================================================
#{
={============================================================================
|kt_dev_qt_0001| qt-creator-command

kyoupark@kit-debian64:~$ cat ~/.local/share/applications/DigiaQt-qtcreator-community.desktop
[Desktop Entry]
Type=Application
Exec=/home/kyoupark/Qt/Tools/QtCreator/bin/qtcreator
Name=Qt Creator (Community)
GenericName=The IDE of choice for Qt development.
Icon=QtProject-qtcreator
StartupWMClass=qtcreator
Terminal=false
Categories=Development;IDE;Qt;
MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs;


={============================================================================
|kt_dev_qt_0001| qt-creator-project

http://doc.qt.io/qtcreator/creator-project-creating.html

In addition, you can import projects as generic projects that do not use
qmake, Qbs, or CMake. This enables you to use Qt Creator as a code editor and
to fully control the steps and commands used to build the project.


Device	
An embedded device or a mobile device. For more information, see Target
Platforms.

Kit	
Qt Creator groups build and run specific settings as kits to make
cross-platform development easier. Each kit consists of a set of values that
define one environment, such as a device, tool chain, Qt version, and debugger
command to use. Configure kits at Tools > Options > Build & Run > Kits.

Import Project

Import Existing Project
Import an existing project that does not use any of the supported build
systems: qmake, Qbs, CMake, or Autotools. This enables you to use Qt Creator
as a code editor


={============================================================================
|kt_dev_qt_0001| qt-edit-navigate

{code-model}
http://doc.qt.io/qtcreator/creator-clang-codemodel.html

Activating Clang Code Model

If you build Qt Creator yourself, ensure that the plugin is also built, as described in the Qt Creator README file.

To activate the plugin:

Select Help > About Plugins > C++ > ClangCodeModel to enable the plugin.

Restart Qt Creator to be able to use the plugin.


Checking Code Syntax

As you write code, Qt Creator checks code syntax. When Qt Creator spots a
syntax error in your code it underlines it and shows error details when you
move the mouse pointer over the error. Similarly, when you are working on an
instance of a JavaScript object notation (JSON) entity, Qt Creator underlines
errors in JSON data structure.


When using the Clang code model, errors and warnings are additionally marked
with icons and annotated. If a Clang fix-it is available, you can execute it
by clicking the  icon and pressing Enter.

To specify the position where the annotations are displayed, select 

Tools > Options > Text Editor > Display > Annotations next to lines, 
      
and then select whether to display the annotations directly next to the code,
aligned to the right of the code, or in the right margin.


Searching with the Locator

To activate the locator:

Press Ctrl+K (Cmd+K on macOS).

Using Locator Filters

The locator enables you to browse not only files, but any items defined by
locator filters. By default, the locator contains filters for:

Locating any open document (o)

Locating files anywhere on your file system (f)

Locating files belonging to your project (p), such as source, header resource, and .ui files, or to any project (a)

Locating class (c), `enum, and function (m) definitions` in your project or
anywhere referenced from your project (:)

Locating symbols in the current document (.)
Locating a specific line and column in the document displayed in your editor
(l <line_number>:<column_number>)

Opening help topics, including Qt documentation (?)

Performing web searches (r)
Running text editing macros that you record and save (rm). For more
information, see Using Text Editing Macros

Executing shell commands (!)
Executing version control system commands (git). For more information, see
Using Version Control Systems

Running external tools (x)

To use a specific locator filter, `type the assigned prefix followed by space.`
The prefix is usually a single character. Then type the search string
(typically, a filename or class name) or the command to execute.

Filters locating files also accept paths, such as tools/*main.cpp. 
                                                         
Filters locating class and function definitions also accept namespaces, such
as Utils::*View.


To jump to a line and column in the current file, select the line and column
indicator (5) or press Ctrl+L (or Cmd+L on macOS) to open the locator. Enter
the line number and column number in the locator, separated by a colon (:).


Moving to Symbol Definition or Declaration

You can move directly to the definition or the declaration of a symbol by
holding the Ctrl key and clicking the symbol. If you have multiple splits
opened, you can open the link in the next split by holding Ctrl and Alt while
clicking the symbol.

To enable this moving function, select Tools > Options > Text Editor >
Behavior > Enable mouse navigation.

You can also select the symbol and press F2, or right-click the symbol and
select Follow Symbol Under Cursor to move to its definition or declaration.

This feature is supported for namespaces, classes, functions, variables,
include statements, and macros.

To switch between the definition and declaration of a function, place the
cursor on either and press `Shift+F2` or right-click and select Switch Between
Function Declaration/Definition. For example, this allows you to navigate from
anywhere within a function body directly to the function declaration.

Links are opened in the same split by default. To open links in the next
split, prepend Ctrl+E to the shortcut. For example, press Ctrl+E,F2 to follow
the symbol in the next split. If necessary, the view is automatically split.
To change the default behavior, select Tools > Options > Text Editor > Display
> Always open links in another split. Additional symbols are displayed and
switching between definition and declaration is done in another split. If you
change the default behavior, the shortcuts for opening link targets in the
next split are used to open them in the current split.


Generic Highlighting

Generic highlighting is based on highlight definition files that are provided
by the Kate Editor. You can download highlight definition files for use with
Qt Creator. For more information about the definition files, see
KDE-Files.org.


={============================================================================
|kt_dev_qt_0001| qt-edit-encoding

<edit-encoding>
To show the file encoding of the current file on the editor toolbar (6),
select Tools > Options > Text Editor > Display > Display file encoding. To
  change the encoding, click it on the toolbar and select new encoding in the
  Text Encoding dialog. To reload the file with the selected encoding, select
  Reload with Encoding. To save the file with the new encoding, select Save
  with Encoding.


={============================================================================
|kt_dev_qt_0001| qt-edit-view

You can view multiple files simultaneously in the following ways:

To split the editor view into a top and bottom view, select Window > Split, press Ctrl+E, 2, or select the  (Split) button and then select Split.
Split command creates views below the currently active editor view.

To split the editor view into adjacent views, select Window > Split Side by Side, press Ctrl+E, 3, or select Split > Split Side by Side.
Side by side split command creates views to the right of the currently active editor view.

To open the editor in a detached window, press Ctrl+E, 4, or select Window > Open in New Window.
The new window behaves basically in the same way as the editor area in the main window. For example, you can split this window, as well. Documents are opened in the currently active editor window.

To move between split views and detached editor windows, select Window > Go to Next Split or Window or press Ctrl+E, O.

To remove a split view, place the cursor within the view you want to remove and select Window > Remove Current Split, press Ctrl+E, 0, or select the  (Remove Split) button. To remove all but the currently selected split view, select Window > Remove All Splits or press Ctrl+E, 1.


={============================================================================
|kt_dev_qt_0001| qt-edit-reparse

Reparsing Externally Changed Files

If source files are modified from outside Qt Creator, the opened files will be
reparsed automatically. For all other files, you can use Tools > C++ > Reparse
Externally Changed Files to update the code model.


==============================================================================
Copyrightobjdump see |ktkb|                        vim:tw=100:ts=3:ft=help:norl:
