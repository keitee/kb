#include "window.h"
#include "ui_window.h"
#include <iostream>

/*

https://doc.qt.io/qt-5/qevent.html

Detailed Description

The QEvent class is the base class of all event classes. Event objects contain
event parameters.

Qt's main event loop (QCoreApplication::exec()) fetches native window system
events from the event queue, translates them into QEvents, and sends the
translated events to QObjects.

In general, events come from the underlying window system (spontaneous() returns
true), but it is also possible to manually send events using
QCoreApplication::sendEvent() and QCoreApplication::postEvent() (spontaneous()
returns false).

QObjects receive events by having their QObject::event() function called. The
function can be reimplemented in subclasses to customize event handling and add
additional event types; QWidget::event() is a notable example. By default,
events are dispatched to event handlers like QObject::timerEvent() and
QWidget::mouseMoveEvent(). QObject::installEventFilter() allows an object to
intercept events destined for another object.

The basic QEvent contains only an event type parameter and an "accept" flag. The
accept flag set with accept(), and cleared with ignore(). It is set by default,
but don't rely on this as subclasses may choose to clear it in their
constructor.


https://doc.qt.io/archives/qq/qq11-events.html

The Origins of Events

Events can be divided into three categories based on how they are created and
how they are dispatched:

Spontaneous events are generated by the window system. They are put in a system
queue and processed one after the other by the event loop.

Posted events are generated by Qt or by the application. They are queued by Qt
and processed by the event loop.

Sent events are generated by Qt or by the application, but they are sent
directly to the target object.

When we call QApplication::exec() at the end of our main() function, the
application enters Qt's event loop. Conceptually, the event loop looks like
this:

    while (!exit_was_called) {
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
        while (!spontaneous_event_queue_is_empty) {
            process_next_spontaneous_event();
        }
        while (!posted_event_queue_is_empty) {
            process_next_posted_event();
        }
    }
    
First, the event loop processes any posted events until the queue is empty.
Then, it processes the spontaneous events until there are none left. Finally, it
processes any posted events that were generated during the processing of the
spontaneous events.

Sent events are not handled by the event loop. They are delivered directly to
the object.

Let's see how this works in practice with paint events. When a widget is made
visible for the first time, or when it's made visible after being obscured, the
window system generates a (spontaneous) paint event to ask the program to redraw
the widget. The event loop eventually picks up the event and dispatches it to
the widget that needs to be redrawn.

Not all paint events are generated by the window system. When you call
QWidget::update() to redraw a widget, the widget posts a paint event to itself.
The paint event is queued and eventually dispatched by the event loop.

If you're impatient and can't wait for the event loop to redraw a widget, you
could in theory call paintEvent() directly to force an immediate repaint. But in
practice this isn't always possible because paintEvent() is a protected
function. This would also bypass any existing event filter. For that reason, Qt
provides a mechanism for sending events directly rather than posting them.
QWidget::repaint() uses this mechanism to force an immediate repaint.

One advantage of posting events as opposed to sending them is that posting gives
Qt the opportunity to compress them. If you call update() ten times in
succession on the same widget without returning to the event loop, the ten
events generated by update() will automatically be merged into a single event
with the union of the regions specified in all their QPaintEvents. Compressible
event types include paint events, move events, resize events, layout hint
events, and language change events.

Finally, note that you can call QApplication::sendPostedEvents() at any time to
force Qt to process an object's posted events at the time of the call.


Event Handling and Filtering

Events in Qt can be processed on five different levels.

o Reimplementing a specific event handler. 
QObject and QWidget provide many specific event handlers for different types of
events (for example, paintEvent() for paint events).

o Reimplementing QObject::event(). 
The event() function is the entry point for all of an object's events. The
default implementations in QObject and QWidget simply forward the events to the
specific event handlers.

o Installing an event filter on a QObject.
An event filter is an object that receives another object's events before they
reach the intended target.

o Installing an event filter on qApp.
Exceptionally, an event filter on qApp monitors all events sent to all objects
in the application.

o Reimplementing QApplication::notify().
Qt's event loop and sendEvent() call this function to dispatch events. By
reimplementing it, you get to see events before anybody else.


Some event types can be `propagated`. This means that if a target doesn't handle
an event, Qt tries to find another receiver for the event and calls
QApplication::notify() with the new target.  For example, key events are
propagated; if the widget that has the focus doesn't handle a certain key, Qt
dispatches the same event to the parent widget, then to the parent's parent, and
so on until it reaches the top-level widget.

*/

Window::Window(QWidget *parent) :
  QWidget(parent),
  ui(new Ui::Window)
{
  ui->setupUi(this);

  m_button = new QPushButton("Key Event", this);
  m_button->setGeometry(10, 10, 180, 30);

  // Q: do not work. why?
  // connect(m_button, SIGNAL(clicked()), 
  //     this, SLOT((slotButtonClicked)));
}

/*

keyPressEvent() is called whenever a key is pressed, and again when a key has
been held down long enough for it to auto-repeat. The Tab and Shift+Tab keys are
only passed to the widget if they are not used by the focus-change mechanisms.
To force those keys to be processed by your widget, you must reimplement
QWidget::event().


https://doc.qt.io/qt-5/qwidget.html#keyPressEvent

void QWidget::keyPressEvent(QKeyEvent *event)

This event handler, for event event, can be reimplemented in a subclass to
receive key press events for the widget.

A widget must call setFocusPolicy() to accept focus initially and have focus in
order to receive a key press event.

If you reimplement this handler, it is very important that you call the base
class implementation if you do not act upon the key.

The default implementation closes popup widgets if the user presses the key
sequence for QKeySequence::Cancel (typically the Escape key). Otherwise the
event is ignored, so that the widget's parent can interpret it.

Note that QKeyEvent starts with isAccepted() == true, so you do not need to call
QKeyEvent::accept() - just do not call the base class implementation if you act
upon the key.

See also keyReleaseEvent(), setFocusPolicy(), focusInEvent(), focusOutEvent(),
event(), QKeyEvent, and Tetrix Example.


https://doc.qt.io/archives/qq/qq11-events.html

Accept or Ignore?

Events that can be propagated have an accept() and an ignore() function that you
can call to tell Qt that you "accept" or "ignore" the event. If an event handler
calls accept() on an event, the event won't be propagated further; if an event
handler calls ignore(), Qt tries to find another receiver.

If you're like most Qt developers, you probably never really bothered calling
accept() and ignore() in your programs. And rightly so. Qt is designed in such a
way that you normally never need to call them. The default value is "accept",
and the default event handler implementations in QWidget call ignore(). If you
want to accept the event, you just need to reimplement the event handler and
avoid calling the QWidget implementation. If you want to ignore the event,
simply pass it on to the QWidget implementation. The following code snippet
illustrates the point:

    void MyFancyWidget::keyPressEvent(QKeyEvent *event)
    {
        if (event->key() == Key_Escape) {
            doEscape();
        } else {
            QWidget::keyPressEvent(event);
        }
    }
    
In this example, if the user presses Esc, we call doEscape() and the event is
accepted (the default). The event won't be propagated to the parent widget. If
the user presses any other key, we call QWidget's default implementation:

    void QWidget::keyPressEvent(QKeyEvent *event)
    {
        event->ignore();
    }
    
Thanks to the ignore() call, the event will be propagated to the parent widget.

*/

void Window::keyPressEvent(QKeyEvent *event)
{
  if (event->key() == Qt::Key_Escape)
  {
    // it will output to Qt Editor output window
    std::cout << "keyPressEvent:Key_Esacpe" << std::endl;
  }
}


/*

If for some reason you handle the event in event() instead of in a specific
handler such as keyPressEvent(), the procedure is somewhat different. The
event() function returns a bool that tells the caller whether the event was
accepted or not (true means "accept"). 

Calling accept() or ignore() on an event from event() is pointless. The "accept"
flag is a communication mechanism between the specific event handlers and
event(), whereas the bool return value of event() is used to communicate with
QApplication::notify(). The default event() implementation in QWidget converts
the "accept" flag into a bool as follows:

    bool QWidget::event(QEvent *event)
    {
        switch (e->type()) {
        case QEvent::KeyPress:
            keyPressEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
        case QEvent::KeyRelease:
            keyReleaseEvent((QKeyEvent *)event);
            if (!((QKeyEvent *)event)->isAccepted())
                return false;
            break;
            ...
        }
        return true;
    }

https://doc.qt.io/qt-5/qobject.html#event

bool QObject::event(QEvent *e)

This virtual function receives events to an object and should return true if the
event e was recognized and processed.

The event() function can be reimplemented to customize the behavior of an
object.

Make sure you call the parent event class implementation for all the events you
did not handle.

Example:

class MyClass : public QWidget
{
    Q_OBJECT

public:
    MyClass(QWidget *parent = 0);
    ~MyClass();

    bool event(QEvent* ev) override
    {
        if (ev->type() == QEvent::PolishRequest) {
            // overwrite handling of PolishRequest if any
            doThings();
            return true;
        } else  if (ev->type() == QEvent::Show) {
            // complement handling of Show if any
            doThings2();
            QWidget::event(ev);
            return true;
        }
        // Make sure the rest of events are handled
        return QWidget::event(ev);
    }
};

*/

bool Window::event(QEvent *e)
{
  // if (event->key() == Qt::Key_Escape)
  {
    // it will output to Qt Editor output window
    // std::cout << "Window::event: " << std::endl;
  }
  // Make sure the rest of events are handled
  return QWidget::event(e);
}


/*
note: it's on "Window"

Synthetic Events

Qt applications can generate their own events, either of predefined types or of
custom types. This is done by creating an instance of QEvent (or a subclass) and
calling QApplication::postEvent() or QApplication::sendEvent().

Both functions take a QObject * and a QEvent * as arguments. If you call
postEvent(), you must create the event object using new and Qt will
automatically delete it after it is processed. If you call sendEvent(), you must
create the event on the stack. Here's an example of posting an event:

    QApplication::postEvent(mainWin, 
      new QKeyEvent(QEvent::KeyPress, Key_X, 'X', 0));
    
Here's an example of sending an event:

    QKeyEvent event(QEvent::KeyPress, Key_X, 'X', 0);
    QApplication::sendEvent(mainWin, &event);
    
Qt applications rarely need to call postEvent() or sendEvent() directly because
most events are generated automatically by Qt or by the window system when
necessary. In most of the cases where you want to send an event, Qt includes a
high-level function that does it for you (for example, update() and repaint()).


https://doc.qt.io/qt-5/qcoreapplication.html#postEvent

static
void QWidget::mouseReleaseEvent(QMouseEvent *event)

This event handler, for event event, can be reimplemented in a subclass to
receive mouse release events for the widget.

void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority = Qt::NormalEventPriority)

Adds the event event, with the object receiver as the receiver of the event, to
an event queue and returns immediately.

note: "The event must be allocated on the heap" 

since the post event queue will take ownership of the event and delete it once
it has been posted. It is not safe to access the event after it has been posted.

When control returns to the main event loop, all events that are stored in the
queue will be sent using the notify() function.

Events are sorted in descending priority order, i.e. events with a high priority
are queued before events with a lower priority. The priority can be any integer
value, i.e. between INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for
more details. Events with equal priority will be processed in the order posted.

*/

void Window::mousePressEvent(QMouseEvent *event)
{
  {
    std::cout << "Window::mousePressEvent: post key event" << std::endl;
    QApplication::postEvent(this, 
        new QKeyEvent(QEvent::KeyPress, Qt::Key_Escape, 0, 0));
  }

  {
    std::cout << "Window::mousePressEvent: post custom event" << std::endl;
    const QEvent::Type MyEvent = (QEvent::Type)1234;
    QApplication::postEvent(this, new QEvent(MyEvent));
  }
}

/*

Custom Event Types

Qt lets you create your own event types. This technique is particularly useful
in multithreaded applications, as a means of communicating with the GUI thread;
see Chapter 17 of C++ GUI Programming with Qt 3 (p. 359) for an example.

Custom types can also be useful in single-threaded applications, as an
inter-object communication mechanism. The main reason why you would use events
rather than standard "function calls, or signals and slots", is that events can
be used both synchronously and asynchronously (depending on whether you call
sendEvent() or postEvents()), whereas calling a function or invoking a slot is
always synchronous. Another advantage of events is that they can be filtered.
More on this in the next section.

Here's a code snippet that shows how to post a custom event:

    const QEvent::Type MyEvent = (QEvent::Type)1234;
    ...
    QApplication::postEvent(obj, new QCustomEvent(MyEvent));
    
The event must be of type QCustomEvent (or a subclass). The argument to the
constructor is the type of event. Values under 1024 are reserved by Qt for
predefined event types; other values can be used by applications.

To handle custom event types, reimplement the customEvent() function:

    void MyLineEdit::customEvent(QCustomEvent *event)
    {
        if (event->type() == MyEvent) {
            myEvent();
        } else {
            QLineEdit::customEvent(event);
        }
    }


https://doc.qt.io/qt-5/qobject.html#customEvent

[virtual protected]
void QObject::customEvent(QEvent *event)

This event handler can be reimplemented in a subclass to receive custom events.
Custom events are user-defined events with a type value at least as large as the
QEvent::User item of the QEvent::Type enum, and is typically a QEvent subclass.
The event is passed in the event parameter.

See also event() and QEvent.

*/

void Window::customEvent(QEvent *event)
{
  if (event->type() == ((QEvent::Type)1234))
  {
    std::cout << "Window::customEvent: got custom event" << std::endl;
  }
}

Window::~Window()
{
  delete ui;
}
