*kt_dev_02*		tw=100

/^[#=]{ 

aTue 07 Jan 2014 05:07:39 GMT

Keywords:
{Q} for questions to find out more
{DN} for design considerations
{LL} for lessons learned

KT KB. DEVELOPMENT.

#{ QUESTIONS
|kt_dev_quiz_001| bits: how to swap two vars without using a temp {xor-swap-algorithm}
|kt_dev_quiz_002| bits: how to find a item in array that appear an odd number of times.
|kt_dev_quiz_003| array and string: how to determine if a string has all unique characters. 
|kt_dev_quiz_004| array and string: reverse a string {two-pointers}
|kt_dev_quiz_005| array and string: reverse a string without duplicates
|kt_dev_quiz_006| array and string: to check if it's anagram of the other. {anagram}
|kt_dev_quiz_007| 
|kt_dev_quiz_008| 
|kt_dev_quiz_009| i = i+j means? (from me)
|kt_dev_quiz_010| intersects between rectangles (interview)
|kt_dev_quiz_011| find a path in a maze {freopen}
|kt_dev_quiz_012| get msb position
|kt_dev_quiz_013| get the longest sequence (interview) {the-longest-increasing-sequence}
|kt_dev_quiz_014| code review task
|kt_dev_quiz_015| sorting and searching questions from {ref-004}
|kt_dev_quiz_016| cycle detection {tortoise-and-hare}
|kt_dev_quiz_017| power of two (interview)
|kt_dev_quiz_018| linked list questions from {ref-004} {runner-technique} {tortoise-and-hare}
|kt_dev_quiz_019| array and string questions from {ref-004}
|kt_dev_quiz_020| coding task

#{ PROBLEM SLOVING
|kt_dev_quiz_100| codility: equilibrium index of a sequence
|kt_dev_quiz_101| codility: TapeEquilibrium 
|kt_dev_quiz_102| codility: absolute distinct count of this array
|kt_dev_quiz_103| codility: codility: how much water between walls? {two-pointers}
|kt_dev_quiz_104| codility: frog jump
|kt_dev_quiz_105| codility: find missing element. PermMissingElem
|kt_dev_quiz_106| codility: frog river
|kt_dev_quiz_107| codility: max counters

#{ TRAIN
|kt_dev_quiz_200| codility: train: lesson 01: time complexity
|kt_dev_quiz_201| codility: train: lesson 02: counting elements
|kt_dev_quiz_300| problems: repairman

#{ ALGORITHM
|kt_dev_algo_000| sentinel
|kt_dev_algo_001| stack {bracket-matching}
|kt_dev_algo_002| simple list {abstract-data-type}
|kt_dev_algo_003| general list {contiguous-vs-linked} {list-contiguous-and-linked}
|kt_dev_algo_004| queue {queue-circular-array}
|kt_dev_algo_005| array: index shift
|kt_dev_algo_006| the game of life
|kt_dev_algo_007| recursion
|kt_dev_algo_008| search: binary search {big-o-notation}
|kt_dev_algo_009| sort {mergesort} {quicksort} {find-middle-in-a-linked-list}
|kt_dev_algo_010| search: table and hash {radixsort}
|kt_dev_algo_011| binary tree {binary-search-tree} {treesort}
|kt_dev_algo_012| avl tree 
|kt_dev_algo_013| comparison of methods

#{ CASES
|kt_dev_algo_100| dobble linked list 

#{ DISCUSSION
|kt_dev_algo_300| C++ map insertion and lookup performance and storage overhead

#{ GLIBC
|kt_dev_glib_000| glib sites
|kt_dev_glib_001| atoi, htoi {getchar}
|kt_dev_glib_002| atof 
|kt_dev_glib_003| itoa
|kt_dev_glib_004| printf
|kt_dev_glib_005| strcpy and strncpy
|kt_dev_glib_006| strlen
|kt_dev_glib_007| fopen
|kt_dev_glib_008| isdigit
|kt_dev_glib_101| general tips


# ============================================================================
#{ QUESTIONS
={============================================================================
*kt_dev_quiz_001*	bits: how to swap two vars without using a temp

It's the standard a=a+b, b=a-b, a=a-b problem. We hired the guy who said, well, "if they're
integers, then I'd do it by a=a|b, b=a^b, a=a^b. But I don't know how to do it if they're strings."

logical OR is + and XOR is -. why? THIS IS WRONG!.

From Cracking the coding interview, p430,

| -- | ------ | ----
     a        b 

a=a+b, b=a-b, a=a-b

void swap_ari( int& first, int& second )
{
	first  = first + second;
	second = first - second; // first org
	first  = first - second; // second
}

void swap_ari_two( int& first, int& second )
{
	first  = first - second; // diff
	second = first + second; // first
	first  = second - first; // second
}

void swap_bit( int& first, int& second )
{
	first  = first | second;
	second = first ^ second; // first org
	first  = first ^ second; // second
}

void swap_bit_two( int& first, int& second )
{
	first  = first ^ second;
	second = first ^ second; // first org
	first  = first ^ second; // second
}

int _tmain(int argc, _TCHAR* argv[])
{
	int a =  9, b = 4;

	swap_ari( a , b );
	cout << "a = " << a << ", b= " << b << endl;

	a = 9; b = 4;

	swap_ari_two( a , b );
	cout << "a = " << a << ", b= " << b << endl;

	a = 9; b = 4;

	swap_bit( a , b );
	cout << "a = " << a << ", b= " << b << endl;

	a = 9; b = 4;

	swap_bit_two( a , b );
	cout << "a = " << a << ", b= " << b << endl;
	return 0;
}

note: swap_bit_two uses <xor-swap-algorithm> xor yield 0 when bits are the same. xor has two
properties: 

x^x = 0
x^0 = x

x = 1010; y = 0011;           # before

x =  1001 =  1010  ^ 0011     # x = x^y
y =  1010 = [1001] ^ 0011     # y = x^y # y = (x^y)^y = (x^0) # get x
x = [0011] =  1001 ^ [1010]   # x = x^y # x = (x^y)^x = (y^0) # get y

x = 0011; y = 1010;           # after

The algorithm typically corresponds to three machine code instructions.

Pseudocode 	IBM System/370 assembly 	x86 assembly
X := X XOR Y 	XR    R1,R2 				xor      eax, ebx
Y := X XOR Y 	XR    R2,R1 				xor      ebx, eax
X := X XOR Y 	XR    R1,R2 				xor      eax, ebx

In the above System/370 assembly code sample, R1 and R2 are distinct registers, and each XR
operation leaves its result in the register named in the first argument. Using x86 assembly, values
X and Y are in registers eax and ebx (respectively), and xor places the result of the operation in
the first register.


={============================================================================
*kt_dev_quiz_002*	bits: how to find a item in array that appear an odd number of times

Amazon phone interview question. 02/05/2013

//
// You are going to be passed as input an array with an interesting property: the array contains
// non-negative numbers that appear an even number of times throughout the array, save one, that
// appears an odd number of times.
//
// Your code should accept the array as input and return the number that appears an odd number of
// times as output.
//
// [1, 3, 1]   // returns 3
// [2, 4, 6, 8, 10, 12, 10, 8, 6, 4, 12, 12, 4, 2, 4]    // returns 12
// [1, 0, 1, 0, 1, 4, 4, 0, 3, 7, 0, 3, 7]    // returns 1
//

[1, 3, 1]
0001, 0011, 0001
0001 ^ 0011 ^ 0001
(0001 ^ 0001) ^ 0011 = 0000 ^ 0011 = 0011 (3)


{point}
KT: This uses the same as {xor-swap-algorithm}, that is, x^x = 0.

00	0      Y xor Y = 0  (2 times)
01 1      0 xor Y = Y  (3 times)
10 1      Y xor Y = 0  (4 times)
11 0      0 xor Y = Y  (5 times)

If do xor even times, becomes 0.

{use-xor}
{
  int result = 0;

  for( auto element : int_arr )
    result ^= element;

  cout << "result is " << result << endl;
}
	
{use-stl}
{
  int int_arr[] = {2, 4, 6, 8, 10, 12, 10, 8, 6, 4, 12, 12, 4, 2, 4};
  multiset< int > mset( begin(int_arr), end(int_arr));

  for( auto element : mset )
  {
    if( mset.count(element) % 2 )
      cout << element << " has " << mset.count(element) << " occurance" << endl;
  }
}

{codes-stl}
int find_odd_stl(int* arr, int size)
{
	 std::multiset< int> mset( begin(arr), end(arr) ); // {sizeof-problem}

	 std::multiset< int>::const_iterator cit = mset.cbegin();

	 while( cit != mset.cend() )
	 {
		  if( mset.count( *cit )%2 )
				return *cit;

		  ++cit;
	 }
}


==============================================================================
*kt_dev_quiz_003*	array and string: how to determine if a string has all unique characters.

From Cracking the coding interview, p172,

Q. implement an algorithm to determine if a string has all unique characters. what if you cannot use
additional data structures?

Note: 

<1> Questions to ask for clarity. ASCII or UNICODE? Assume ASCII. If it's alphabet then it reduce
space to require so clarify specification.

<2> One simple optimization. return false if the length of input string is greater than the number
of uniques chars in the set; ASCII.


{code-c}
// false when there are multi chars
bool does_have_unique(char* str)
{
  if(!str)
    return false;

  bool bset[256] = {false};

  while(*str)
  {
    if(bset[*str])
      return false;
    else
      bset[*str] = true;

    ++str;
  }

  return true;
}


{code-cpp}
#include <iostream>

using namespace std;

// time O(n) and space O(1)
//
bool isUniqueCharSet( string &s )
{
  int sizeString = s.size();

  // ASCII is 256
  if( sizeString > 256 ) return false;

  bool bitset[256] = {false};

  for(int i = 0; i < sizeString; ++i )
  {
    int charValue = s[i];

    // already found
    if( bitset[charValue] ) // {Q} can use bitset[ s[i] ] ?
      return false;
    else
      bitset[charValue] = true;
  }

  return true;
}

/*
 * when string uses [ONLY] the lower case alphabet. int has 32 bits and save space.
 */
bool isUniqueCharSet( string &s )
{
  int sizeString = s.size();

  if( sizeString > 26 ) return false;

  int bitset = 0;

  for(int i = 0; i < sizeString; ++i )
  {
    int charValue = s[i] - 'a';

    // already found
    if( bitset & (1 << charValue) )
      return false;
    else
      bitset |= ( 1 << charValue);
  }

  return true;
}

int _tmain(int argc, _TCHAR* argv[])
{
  string input1 = "abcdefghijklmnopqa";
  string input2 = "abcdefghijklmnopqr";

  cout << "input1 is " << isUniqueCharSet( input1 ) << endl;
  cout << "input2 is " << isUniqueCharSet( input2 ) << endl;

  return 0;
}

Alternatively, can use STL multiset and count(). but not better than above in time and space. 


==============================================================================
*kt_dev_quiz_004* array and string: reverse a string

From Cracking the coding interview, p173,

Q. implement a function void reverse(char* str) in C/C++ which reverse a null-terminated string.

2014.02. approach was that loops an array to get a size, alloc and copy input and copy one by one
from the end of copied array while end ptr of copied input > start ptr of input array. Same time but
more space that c-version.

<c-version> if use c only and no additional memory
#include < iostream>
#include < string>

using namespace std;

void reverse_c(char* str)
{
  if(!str) return;

  char* end = str;
  char temp = 0;

  // find end of the string
  while(*end)
    ++end;

  // <wrong> since needs two set two char back.
  // char str[] = "hello";
  // (gdb) p str 
  // $1 = "hello"
  // (gdb) p /x str // before reverse
  // $2 = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x0}
  // (gdb) p /x str // after reverse
  // $3 = {0x0, 0x6f, 0x6c, 0x6c, 0x65, 0x68}
  // while(*end++)
  //   ;

  // not work when empty string input
  // while(*++end)
  //   ;

  // [DN] set one char back, since last char is null and will cover when str has one length
  // a b c \0
  // 0 1 2 3 
  --end;

  // [DN] swap chars from the start of string with the end of the string, until the pointers meet in
  // the middle note: str < end
  while(str < end)
  {
    temp = *str;
    *str++ = *end; // [DN] 
    *end-- = temp;
  }
}

<cpp-version> if use arg as a output
void reverse_cpp(char* str)
{
  if(!str) return;

  char *end = nullptr;

  std::string istr(str);
  std::string rstr( istr.rbegin(), istr.rend());

  // {Q} really need const_cast? Yes see {string-and-c-str} in *kt_dev_01* Otherwise, got an error:
  // error: invalid conversion from ‘const char*’ to ‘char*’ [-fpermissive]
  end = const_cast<char*> (rstr.c_str()); 

  while(*end)
  {
    *str++ = *end++;
  }
}

<cpp-version> if returns a string
string reverse_cpp_two(char* str)
{
  if(!str) return string();
  string istr(str);

  // {sizeof-problem} note: the below causes error as with sizeof operator problem in called function.
  // return string( begin(str), end(str) );

  return string( istr.crbegin(), istr.crend() );   # return temp(unnamed) string object
}

int _tmain(int argc, _TCHAR* argv[])
{
  char arr[] = "KYOUNG TAEK PARK";

  cout << "before: " << arr << endl;
  reverse_c(arr);
  cout << "after : " << arr << endl;
  cout << "---------" << endl;

  cout << "before: " << arr << endl;
  reverse_cpp(arr);
  cout << "after : " << arr << endl;
  cout << "---------" << endl;

  cout << "before: " << arr << endl;
  cout << "after : " << reverse_cpp_two(arr) << endl;

  return 0;
}

All cpp versions use additional memory which is string so c version is better choice.


==============================================================================
*kt_dev_quiz_005* array and string: reverse a string without duplicates

From the internet

Write a program to reverse a string with all its duplicates removed. Only the last instance of a
character in the reverse string has to appear. Also, the following conditions are to be satisfied:
Assume only Capital Letters.

Minimum Time, Minimum Space, Minimum Lines of Code

string reverse(string instr);

before: JTVAKAVISHAAAL
inter : JTVAKISHL
after : LHSIKAVTJ


#include < iostream>
#include < string>

using namespace std;

string reverse(string instr)
{
  if(instr.empty()) return string();

  string outstr = "";
  int input_size = instr.size();	
  int bitset = 0, value = 0;

  for( int index=0; index < input_size; ++index)
  {
    value = instr[index] - 'A';

    // seen first.
    // Note: only count the first occurance as it will be the last in the
    // reverse.
    if( !(bitset & (1<<value)) )
    {
      //outstr.append( 1, instr[index] );
      outstr += instr[index];
      bitset |= (1<<value);
    }
  }

  return string( outstr.rbegin(), outstr.rend());
}

int _tmain(int argc, _TCHAR* argv[])
{
  string input1 = "JTVAKAVISHAAAL";
  string input2 = "AVISHAL";

  cout << "before: " << input1 << endl;	
  cout << "after : " << reverse(input1) << endl;
  cout << "---------" << endl;

  cout << "before: " << input2 << endl;	
  cout << "after : " << reverse(input2) << endl;
  cout << "---------" << endl;

  return 0;
}

Output:

before: JTVAKAVISHAAAL
after : LHSIKAVTJ
---------
before: AVISHAL
after : LHSIVA
---------


==============================================================================
*kt_dev_quiz_006* array and string: to check if it's anagram of the other.

From Cracking the coding interview, p174,

Q. Given two strings, write a method to decide if one is a anagram(permutation) of the other. 

bool func(string &one, string &two);

Note: questions to ask for clarity.
1. case sensitive? such as God or dog?
2. whitespace is significant? such as "god   " and "dog".
3. ASCII?

Assume that all are the case. Optimization? 

<1> If they are different lengths then they cannot be anagrams.


{code-cpp}
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// simple, clean and easy to understand
//
bool anagram_one(string& one, string& two)
{
  // input error check
  if( one.size() != two.size() ) return false;

  sort(one.begin(), one.end());
  sort(two.begin(), two.end());

  return ( one == two );
}

// if efficiency is very important
//
bool anagram_two(const string& one, const string& two)
{
  // input error check
  int oneSize = one.size(), twoSize = two.size();

  if( oneSize != twoSize ) return false;

  // assume ASCII set
  int charSet[256] = {0};

  // iterate one string to count num of each char
  for( int nIndex = 0; nIndex < oneSize; ++nIndex )
  {
    ++charSet[one[nIndex]];
  }

  // do not cover when there are multiple same chars but different occurances?
  for( int nIndex = 0; nIndex < twoSize; ++nIndex )
  {
    // seen first, then not the anagram
    if( charSet[two[nIndex]] == 0 )
      return false;
  }

  return true;
}


int _tmain(int argc, _TCHAR* argv[])
{
  string input1 ="PARK";
  string input2 ="APRK";

  if(anagram_one( input1, input2 ))
    cout << "they are anagram" << endl;
  else
    cout << "they aren't anagram" << endl;

  string input3 ="PARK";
  string input4 ="APRK";

  if(anagram_two( input1, input2 ))
    cout << "they are anagram" << endl;
  else
    cout << "they aren't anagram" << endl;

  return 0;
}


={{===========================================================================
*kt_dev_quiz_009* i = i+j means? (from me)

Its meaning depends on its type as type decides operations that can be used on that type. If it's
arith type, this means addition. what if these are of class type?


={{===========================================================================
*kt_dev_quiz_010* intersects between rectangles (interview)

From NDS CF office interview. 

Problem: implement the intersects method contained within the rectangle class below. The method
should return true if the supplied rectangle intersects with the internally represented rectangle.

Solution:

(x1,y1)
   +--------+
   |        |
   |        |        (x3,y3)
   +--------+           +--------+
            (x2,y2)     |        |
                        |        |
                        +--------+
                                 (x4,y4)

- ---------------------------------------> x axis
  x1        x2          x3       x4

Points:
1> The both x and y must overlaps at the same time.
2> The both when (x1,x2) < (x3,x4) or when (x1, x2) > (x3,x4)
3> If it is a rectangle, can assume that x1 is always smaller than x2.
4> whether to include '==' in overlapping cases?

isect( x1, x2, x3, x4 )
{
  if( x1 <= x3 <= x2 or x1 <= x4 <= x2 ) return true;
}

iset(x...) and isect(y...) then overlaps.


struct point {
  unsigned int x;
  unsigned int y;
};

struct rect {
  point upp;
  point bot;
};

void printrect( const char* name, const rect &r)
{
  std::cout << "rect : " << name << ": {" << r.upp.x << ", " << r.upp.y << "} - > {" << r.bot.x << ", " << r.bot.y << "}" << std::endl;
}

bool isinrange( const unsigned int x1, const unsigned int x2, const unsigned int z)
{
  return ( ((x1 < z ) && ( z < x2)) || ((x2 < z ) && ( z < x1)) );
}

bool intersect( const rect& r1, const rect& r2)
{
  bool xi = false, yi = false;

  xi = isinrange( r1.upp.x, r1.bot.x, r2.upp.x ) || isinrange( r1.upp.x, r1.bot.x, r2.bot.x );
  /*
     if(( r1.upp.x < r2.upp.x < r1.bot.x ) || ( r1.bot.x < r2.upp.x < r1.upp.x ) || \
     ( r1.upp.x < r2.bot.x < r1.bot.x ) || ( r1.bot.x < r2.bot.x < r1.upp.x ))
     xi = true;
   */
  yi = isinrange( r1.upp.y, r1.bot.y, r2.upp.y ) || isinrange( r1.upp.y, r1.bot.y, r2.bot.y );
  /*
     if(( r1.upp.y < r2.upp.y < r1.bot.y ) || ( r1.bot.y < r2.upp.y < r1.upp.y ) || \
     ( r1.upp.y < r2.bot.y < r1.bot.y ) || ( r1.bot.y < r2.bot.y < r1.upp.y ))
     yi = true;
   */
  return (xi && yi);
}

int _tmain(int argc, _TCHAR* argv[])
{
  char* cp;

  bool ret = false;

  rect one ={10,10,20,20};
  rect two ={15,15,25,25};

  printrect("one", one );
  printrect("two", two );

  ret = intersect(one, two);

  std::cout << "ret is %d\n" << ret << std::endl;

  cp = func1("this is a test string.");

  std::cout << "cp is:" << cp << std::endl;
}


==============================================================================
*kt_dev_quiz_011* find a path in a maze

From SS.

You are given an N*N matrix with white, black, or gray cells. You have to find a white path from
(1, 1) to (N, N). 

Here (1, 1) means the top-leftmost cell and (N, N) means th bottom-rightmost cell. You can move from
one cell to an 

o horizontally, vertically, or diagonally adjacent cells.

o You cannot visit a cell more than once. # condition

o one gray cell is given and your path must visit the gray cell in the path. 

The cells (1, 1) and (N, N) cannot be the gray cell. Your path does not have to be the shortest
path. Given an N*N matrix with white cells, black cells, and a gray cell. Generate a program that
finds a white-cell path from (1, 1) to (N, N) which visits the gray cell in the middle of the path.

o should visit green cell first.

This problem can be difficult for some special cases. To ease the problem, there are not more than
four white cells adjacent to the gray one. For partial points, a considerable part of the test cases
will be rather easy. 

In three of the test cases, just finding a path from (1, 1) to the gray cell and then finding a path
from the gray cell to (N, N) will always find a successful path. 

And in other three of the test cases, only ** two white cells will be adjacent to the gray cell. It
will be guaranteed that all of the test cases will have a solution. That is, it will be always
possible to find a valid path.

  
[Constraints]
5=N=100.

[Input]
10 test cases are given. In each case, the first line has N, the dimension of the matrix, and the
next N lines show the shape of the matrix. 

o A black cell is represented by 1, a white cell by 0, and the gray cell by 2. 
  
[Output]
Write the 10 answers in 10 lines. Each line starts with #x where x means the index of a case, puts
a space, and then prints a path. A path is represented by the coordinates of cells visited in order.
A coordinate is represented by row column. For example, in the matrix below, the only successful
path is (1, 1)->(2, 1)->(3, 2)->(3, 3); it is represented in the output as 1 1 2 1 3 2 3 3.


<code-frame>

#include<iostream>

using namespace std;

int A[101][101], N;
int Answer1[10001], Answer2[10001], AnswerN;

int main(int argc, char** argv)
{
	int test_case;
	/*
	   freopen function below opens input.txt file in read only mode, and afterward,
	   the program will read from input.txt file instead of standard(keyboard) input.
	   To test your program, you may save input data in input.txt file,
	   and use freopen function to read from the file when using scanf function.
	   You may remove the comment symbols(//) in the below statement and use it.
	   But before submission, you must remove the freopen function or rewrite comment symbols(//).
	 */
	// freopen("input.txt", "r", stdin);


	/*
	   Your program should handle 10 test cases given.
	 */
	for(test_case = 1; test_case <= 10; ++test_case)
	{
		int i, j;

		/*
		   Read each test case from standard input.
		   The dimension of the matrix will be stored in variable N,
		   and the matrix will be stored in an array A[1..N][1..N].
		 */
		cin >> N;
		for(i = 1; i <= N; i++)
		{
			for (j = 1; j <= N; j++)
			{
				cin >> A[i][j];
			}
		}


		/////////////////////////////////////////////////////////////////////////////////////////////
		/*
		   Implement your algorithm here.
		   The length of the path will be stored in variable AnswerN,
		   and the coordinates will be stored in arrays (Answer1[1..AnswerN], Answer2[1..AnswerN]).
		 */
		/////////////////////////////////////////////////////////////////////////////////////////////
		AnswerN = 1;
		Answer1[1] = Answer2[1] = 0;


		// Print the answer to standard output(screen).
		cout << "#" << test_case;
		for(i = 1; i <= AnswerN; i++) cout << " " << Answer1[i] << " " << Answer2[i];
		cout << endl;
	}

	return 0; //Your program should return 0 on normal termination.
}


<test-cases>

5
0 0 0 0 0
1 1 1 1 0
0 0 0 0 0
0 1 1 1 1
2 0 0 0 0
10
0 1 0 1 0 1 0 0 0 1
0 1 0 1 0 1 1 1 0 1
0 0 0 0 0 1 0 0 0 1
0 1 0 1 1 1 0 1 1 1
0 1 2 1 0 0 0 0 0 1
1 1 0 1 0 1 1 1 1 1
0 1 0 0 0 0 0 1 0 1
0 1 1 1 0 1 1 1 0 1
0 0 0 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 0
15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 1 0 0 0 1 0 1 0 1 0 1 0
0 1 0 0 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 0 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 1
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1
0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1
0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1
0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1
0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1
0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
29
0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0
0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1 0 1 0 1 0
0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 1 1 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1 0 1 0
0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0
0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0
0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 0
0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0
0 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 0 1 1 1 0
0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0
0 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1 0
0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
0 1 0 0 0 1 0 1 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 1 0 1 0 0 0
0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 1
0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 1 0 0 0
0 1 0 1 0 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1 0
0 1 0 1 0 0 0 0 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 0
1 1 1 1 1 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 1
0 0 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0
1 1 1 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 0
0 0 0 1 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 1 0 1 0 1 0 0 0
0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 0
0 1 0 0 0 0 0 1 0 0 0 1 0 1 1 1 0 0 0 1 0 0 0 1 0 1 0 1 0
1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 1
0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0

There are more up to 99.
  

={============================================================================
*kt_dev_quiz_012* get msb position

From SS in which a problem to get how many bits are the same between two integers. For example:

A = 35 = 10 0011
B =  9 =    1001

Ans = 2 because only counts bit positions which are valid position in both integers.

<code-example>
#include <iostream>

using namespace std;

unsigned int A, B, Answer;

int main(int argc, char** argv)
{
  int test_case;

  freopen("input.txt", "r", stdin);

  for(test_case = 1; test_case <= 10; test_case++)
  {
    cin >> A; cin >> B;

    if( (A <0) || (B<0))
      return -1;

    int shift = 0, msb = 0, target = 0;
    Answer = 0;

    // only think about the samaller
    target = min(A, B);

    // get msb position. assumes the first 10 bits.
    for(shift = 0; shift < 10; shift++)
    {
      if( target & (1<<shift))
        msb = shift;
    }

    for( shift = 0; shift <= msb; shift++)
    {
      if( (A & (1<<shift)) == (B & (1<<shift)) )
        Answer++;
    }

    cout << "#" << test_case << " " << Answer << endl;
  }

  return 0;//
}

o To make it generic, scan for '1' from the msb of the input and stops when found it.
o Get size of the int type and use it.


={{===========================================================================
*kt_dev_quiz_013* get the number of occurance in sequence {interview}

From Park-in when have a interview at BB. When input is "AAABBBCCCCDDD" then write func that returns
C and 4

<code-example>
#include < iostream>

#define GT(a,b)	((a)>(b))

void getLargestOccurance(int size, const char* input)
{
   if( size==0 || input==nullptr )
      return;

   unsigned int countCurrent = 1, countMax = 1; 
   char charCurrent = input[0], charMax = 0;

   for(int i = 1; i < size; ++i )
   {
     if( charCurrent^input[i] ) 
     {
       if( GT( countCurrent, countMax ))
       {
         countMax = countCurrent;
         charMax 	= charCurrent;
       }

       charCurrent = input[i];
       countCurrent = 1;
     }
     else
       countCurrent++;
   }

   std::cout << "max: (" << charMax << ", " << countMax << ")" << std::endl;
}

int main()
{
   //const char* input = "AAABBCCCCDDD";
   //const char input[] = "AAABBCCCCDDD";
   const char input[] = "AAABBCCCCDDDEEFFFFFFFFFFFFFFFFFFHHHSSSSSSSSSS";

   getLargestOccurance(sizeof(input)/sizeof(input[0]), input);
}


<follow-ups>
Follow-up questions:

1. how to handle when there are many with the same length?
2. how to modify to print the first when there are many with the same length? {Q} the same largest
length?

3. how to draw out complexity?
4. is there any other way to reduce complexity?


<second-approach-from-me>
Use multimap< occurance, char* > and get the end iterator-1 which is the biggest occurance because
it is ordered map. From iterator, get it.first which is a key_type and use find(key_type) to get the
iterator to the first element of the same occurance.

This requires O(n) to scan through the input and O(logn) to use find() since map uses red-black
tree.

<suggested-solution>

 0-1-2-3-4-5-6-7-8-9 -10-11-...
 -----------------------------
 1 2 3 4 5 6 7 8 9 10 11 12
 <-------> <-------->

 inspect [current i(6) + current max(5) -1]. so skip over.

If first sequence ends and see a new character; say x was the first character of new sequence and
inspect array[current i + the current max(first occurance)-1], say y, since array index starts from
0 and count starts from 1:

1) if it is different, then means there is no bigger sequences than the first between position x and
y-1. So SKIP this block by current max and continue this. Starts from [current i + current max]

2) if it is the same, then means there might be a bigger sequence than the first and start from the
current index and scan through until a sequence ends because it could be either a bigger sequence or
a different sequence with the same character. If the occurance is bigger then the previous, update
occurance and string.

If think only the first or last sequence of the same occurance by keeping the first or the last,
then it is less than O(n) since it is skipping characters while scanning. So better than using a
map.

If requires to maintain the set of the same occurance, then need to data structure to hold and it
depends on requirements such as searching, insertion and deletion.

{Q} How about this?
AAAAA-BBCCC-CCCC...
      *     *

void getLargestOccurance(int size, const char* input)
{
  if( size==0 || input==nullptr )
    return;

  unsigned int countCurrent = 1, countMax = 1; 
  char charCurrent = input[0], charMax = 0;

  for(int i = 1; i < size; )
  {
    if( charCurrent^input[i] ) 
    {
      // do not need. if( GT( countCurrent, countMax ))
      {
        countMax = countCurrent;
        charMax 	= charCurrent;
      }

      if( arr[i] == arr[i+countmax-1] )
      {
        charCurrent = input[i];
        countCurrent = 1;
      }
      else
        i += countMax;
    }
    else
      countCurrent++;
  }

  std::cout << "max: (" << charMax << ", " << countMax << ")" << std::endl;
}


={{===========================================================================
*kt_dev_quiz_014* code review task {interview}

Code Review Task

Code Review:
systematic examination (often as peer review) of computer source code intended to find and fix
mistakes overlooked in the initial development phase, improving both the overall quality of software
and the developers' skills.

The aim of this task is to examine a piece of code that your colleague has written. You must
critically analyse and report on the quality of the code and review it for any mistakes, bugs or
issues that you feel are present. You can make any comments, improvements or suggestions that you
feel are appropriate about style, design and logic.

Please write any review comments inline in the code below in bold red text.

There is no time or word limit but try to not spend too long completing the task. Treat it as if it
were a real review in your day as a developer.

This example is massively contrived and intentionally badly coded; don't expect code like this in
your day to day life.


General Comments On Code:

#include <cstdio>
#include <cstring>
#include <map>
#include <iostream>
#include <string>

/*
// Read file in
// Stock, TimeInterval, Volume Traded, High, Low.
VOD.L 1 100 184.0 183.7
BT.L 1 14 449.4 448.2 
VOD.L 2 434 184.1 182.4
BT.L 2 234 449.8 449.5
..

// Find the total volume traded for each stock
// Find the high and low for each stock.

// Write file a to stdout
// Per stock per interval output the %volume traded in that interval as a percentage of the whole day
// Stock, Interval, %Vol for day.

VOD.L,1,2.0
BT.L,1,1.1
VOD.L,2,8.2
BT.L,2,19.0

// Write file b to stdout
// Stock, day high, day low
VOD.L,186.7,182.4
BT.L,445.3,450.9
*/

using namespace std;
typedef basic_string<char> string;

class	CHighLow
{
public:
	CHighLow() : nCurLow(0), nCurHigh(0) {};

	void	add(int nHigh, int nLow)
	{
		if (nHigh > nCurHigh)
			nCurHigh = nHigh;
			
		if (nLow < nCurLow)
			nCurLow = nLow;
	}
	
	int		nCurLow;
	int		nCurHigh;
};

int main(int argc, char* argv[])
{
	if (!strcmp("version", argv[1]))
	{
		cerr << "Using version 1.0 VWAPer" << endl;
		return 0;
	}
		
	FILE*	file = fopen(argv[2], "r");
	
	cerr << "Reading file" << argv[2] << endl;
	
	char	line[256];
	char	Stocks[1000][10];
	int	Intervals[1000];
	int	Volumes[1000];
	float	Highs[1000];
	float	Lows[1000];
	
	int	i = 0;
	int	sum = 0;
	
	// read input file
	while (fgets(line, 256, file))
	{
		sscanf(line, "%s %d %d %f %f", 
         Stocks[i], &Intervals[i], 
         &Volumes[i], &Highs[i], &Lows[i++]);
   }
	
	cerr << "Calculating total volumes" << endl;
	
	// [KT] for each stock, loop through all inputs and add volumes to get the total. Given map used,
	// the same stock lines in the input will be merged into the one stock.

	map<std::string, int>		TotalVolumes;
	
	for (int s = 0; s <= i; ++s)
	{
		std::string	stockname = Stocks[s];
	
		for (int j =0; j <= i; ++j)
		{
			if (!strcmp(Stocks[j], stockname.c_str()))
			{
				TotalVolumes[stockname] += Volumes[j];
			}
		}
	}
	
	cerr << "Calculating high lows" << endl;
	
	map<std::string, CHighLow>	HighLows;
	
	for (int s = 0; s <= i; ++s)
	{
		HighLows[Stocks[s]].add(Highs[s], Lows[s]);
	}
	
	cerr << "Writing files" << endl;
	
	// [KT] However here write out each stock so need to maintain duplicated stocks.
	
	// write file a
	for (int s = 0; s <= i; ++s)
	{
		cout << Stocks[s] << "," << Intervals[s] << "," 
			<< TotalVolumes[Stocks[s]] / Volumes[s] * 100 << endl;
	}
	
	// write file b
	map<std::string, CHighLow>::iterator itr = HighLows.begin();
	while (itr != HighLows.end())
	{
		cout << (*itr).first << "," << (*itr).second.nCurLow << "," << (*itr).second.nCurHigh << endl;
		++itr;
	}
	
	return 1;
}


{review-by-kit}

1. map a file to stdin: freopen( argv[1], "r", stdin ); See {freopen} and use string getline
2. use cpp way throughout to have consistency so use a class to cal and hold totalvolume, high and
low and. uses a map< stockname, class or object > since these values are for each stock summing up
duplicates.

3. how about getting volume % for every stock of input which has duplicates? Or, for 3 and 4, use
multimap? 

No seems to be better to use sequential container such as vector for a whole input and have two maps
out of it to rempove duplicates. If space is important then could have one map for both; total
volume and highlow.


{review-by-ian}

General Comments On Code:

<1> 
File header is missing. If it is a real situation, I would strongly complaining like "no comment on
each classes and functions at all"

#include <cstdio>
#include <cstring>
#include <map>
#include <iostream>
#include <string>

/*
// Read file in
// Stock, TimeInterval, Volume Traded, High, Low.
VOD.L 1 100 184.0 183.7
BT.L 1 14 449.4 448.2 
VOD.L 2 434 184.1 182.4
BT.L 2 234 449.8 449.5
..

// Find the total volume traded for each stock
// Find the high and low for each stock.

// Write file a to stdout
// Per stock per interval output the %volume traded in that interval as a percentage of the whole day
// Stock, Interval, %Vol for day.
VOD.L,1,2.0
BT.L,1,1.1
VOD.L,2,8.2
BT.L,2,19.0

// Write file b to stdout
// Stock, day high, day low
VOD.L,186.7,182.4
BT.L,445.3,450.9
*/

using namespace std;
<2>
I would prefer not to use std namespace. Consider using standard library with 'std::' prefix.

typedef basic_string<char> string;
<3>
In most of case this type definition is not necessary.

class	CHighLow
{
public:
	CHighLow() : nCurLow(0), nCurHigh(0) {};
	<4>
	Setting the initial value of nCurLow to zero is wrong. Define a constant variable like
	'MAX_PRICE' with large integer value and set it to nCurLow. Otherwise, you need to add another
	comparison in add() function. For a case when there is an input with value 0.

	void	add(int nHigh, int nLow)
	<5>
	As the high and low values are float value, change the type of parameters to float
	{
		<6> Need to check if nHigh is lower than nLow and handle the case properly
		if (nHigh > nCurHigh)
			nCurHigh = nHigh;
			
		if (nLow < nCurLow)
			nCurLow = nLow;

		<7> If you set nCurLow to zero, this would not be working at all. You need to assign nLow to
			nCurLow if nCurLow is zero for it. However I would prefer setting initial value with
			maximum value.  
	}
	

	int		nCurLow;
	int		nCurHigh;
	<8>
	As the input has floating point, define those variables as float. Prefer a prefix m_ for the
	names of member variables. Member variables should be under the private keyword 
};


int main(int argc, char* argv[])
{
	if (!strcmp("version", argv[1]))
	{
		cerr << "Using version 1.0 VWAPer" << endl;
		return 0;
	}
	<9>
	This comparison is ambiguous. Please put comments explaining why the first argument should not be
	'version'

	FILE*	file = fopen(argv[2], "r");

	<10>
	Consider using ifstream. You did not check if there is the second argument. Otherwise you will
	see a segmentation fault when argv[2] is null.

	cerr << "Reading file" << argv[2] << endl;

	<11> 
	Add a white space after the log message otherwise file and argv[2] will be put together so file
	name will be looking weird.

	char	line[256];

	<12> 
	If you are sure a line is not longer than 256 bytes this is ok, however please define a constant
	variable like MAX_LINE_LENGTH rather than just using the number.


	char	Stocks[1000][10];
	<13>
	Like above comment, you should define MAX_STOCK_NAME_LENGTH instead of putting 10.  You assume
	the input file has 1000 lines at most. This is limitation. I will suggest better design later.
	Anyway define MAX_INPUT_LINE_COUNT as above.

	int	Intervals[1000];
	int	Volumes[1000];
	float	Highs[1000];
	float	Lows[1000];

	int	i = 0;
	int	sum = 0;
	<14>	sum is not used at all. Delete this.
	
	// Replace 256 to MAX_LINE_LENGTH. If you use ifstream, getLine function can replace this. If you use
	// ifstream, cin can replace sscanf

	while (fgets(line, 256, file))
	{
		sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], &Highs[i], &Lows[i++]);

	<15> [KT] this is big thing
	You made big mistake here. Increasing i in the parameter is very dangerous. The evaluation order
	of function parameter is undefined in spec and usually they are evaluated in reverse order in
	most of compilers. Therefore i will be increased firstly and the data for
	Stocks,Intervals,Volumes and Highs will be stored in the next row. The data will be totally
	mangled. Increase i in the separated line.

	}
	
	cerr << "Calculating total volumes" << endl;
	
	map<std::string, int>		TotalVolumes;
	
	for (int s = 0; s <= i; ++s)
	// change 's <=i' to 's < i'
	{
		std::string	stockname = Stocks[s];
		// No reason to create string object. Please avoid unnecessary object creation and memory copy
	
		for (int j =0; j <= i; ++j)
		// Change 'j <=i' to 'j < i'
		{
			if (!strcmp(Stocks[j], stockname.c_str()))
			// So this just can be comparing Stocks[j] and Stocks[s]
			{
				TotalVolumes[stockname] += Volumes[j];
				// Map can work with char* even though it's key is string type. Just use Stocks[s] here.
				// [KT] may disagree since will cause creating a temp string objects.
			}
		}
	}

	This double looping is really bad idea especially when the input file is huge. Exponential
	complexity is expected and we can avoid this problem by adopting a new design. I will describe
	later.


	cerr << "Calculating high lows" << endl;
	
	map<std::string, CHighLow>	HighLows;
	// You use this type of map later again. Set a typedef for the readability.
	
	for (int s = 0; s <= i; ++s)
	// Change 's <=i' to 's < i'
	{
		HighLows[Stocks[s]].add(Highs[s], Lows[s]);
	}
	// Calculating high and low value could be done while reading file. Running another loop is not
	// necessary. 

	
	cerr << "Writing files" << endl;
	
	for (int s = 0; s <= i; ++s)
	// Change s <=i to s < i
	{
		cout << Stocks[s] << "," << Intervals[s] << "," 
			<< TotalVolumes[Stocks[s]] / Volumes[s] * 100 << endl;

	// <xx> You don't want to devide by zero when Volume[s] is zero. Check the volume in advance and
	// handle the case properly.
	}

	
	map<std::string, CHighLow>::iterator itr = HighLows.begin();
	// Writing the whole definition of map is stressful always. Prefer using typedef as I mentioned
	// before.

	while (itr != HighLows.end())
	// For this simple iteration, for( ; itr != HighLows.end() ; ++itr) is useful. You would never
	// need to worry about not increasing the iterator with it.
	{
		cout << (*itr).first << "," << (*itr).second.nCurLow << "," << 
			(*itr).second.nCurHigh << endl;
		
		++itr;
	}

	return 1;
}


<design-suggestion>

You can slightly improve collecting and writing logic by adopting a wrapper class. So you can call
add() function to collect, and can do 'cout << highLowMapper' for printing out.

class CHighLowMapper
{
	public:
		CHighLowMapper() {};
		void add(const char* stock, int nHigh, int nLow) {
			m_HighLows[stock].add(nHigh, nLow);
		}

		friend ostream& operator<<(ostream& os, const CHighLowMapper& hlm) {
			HLMap::const_iterator itr = hlm.m_HighLows.begin();
			while (itr != hlm.m_HighLows.end())
			{
				cout << (*itr).first << "," << (*itr).second.nCurLow << "," 
					<< (*itr).second.nCurHigh << endl;
				++itr;
			}
			return os;
		}

	private:
		typedef map<std::string, CHighLow> HLMap;
		HLMap    m_HighLows;
};


The double looping to calculate the total volume must be replaced with better logic. Here is a class
to collect volume information and accumulate the total volume for each stock. Therefore the required
information can be collected in the file reading loop. This class overrides operator >> therefore
users are able to printout the result using cout. CVolumeCollector takes maxSize for the vector
reservation. If flexibility and scalability are more important than performance, you can omit it.

class CVolumeCollector
{
	public:
		struct VolumeInfo{
			string stock;
			int interval;
			int volume;
		};

      CVolumeCollector(int maxSize = 0) {
		if(maxSize > 0) {
                m_volumeInfoList.reserve(maxSize);
             }
      };

		void add(const char* stock, int interval, int volume) {
			VolumeInfo vi;
			vi.stock = stock;
			vi.interval = interval;
			vi.volume = volume;

			m_volumeInfoList.push_back(vi);
			m_volumes[stock] += volume;
		}

		const int getVolumeForStock(const string& stock) const {
			int totalVolume = 0;
			VolMap::const_iterator itr = m_volumes.find(stock);
			if(itr != m_volumes.end()) {
				totalVolume = itr->second;
			}
			return totalVolume;
		}

		friend ostream& operator<<(ostream& os, const CVolumeCollector& vc) {
			VolInfoVec::const_iterator itr = vc.m_volumeInfoList.begin();
			while(itr != vc.m_volumeInfoList.end()) {
				cout << (*itr).stock << "," << (*itr).interval << "," 
					<< vc.getVolumeForStock((*itr).stock) / (*itr).volume * 100 
					<< endl;
				++itr;
			}
			return os;
		}

	private:
		typedef map<string, int> VolMap;
		VolMap  m_volumes;

		typedef vector< VolumeInfo > VolInfoVec;
		VolInfoVec m_volumeInfoList;
};

Using CVolumeCollector and CHighLowMapper described above, the main function is much simpler and
well structured.

int main(int argc, char* argv[])
{
	// omitted
	char	line[MAX_LINE_LENGTH];
	
	CHighLowMapper hlm;
	CVolumeCollector vc(MAX_INPUT_FILE);
	while (fgets(line, MAX_LINE_LENGTH, file))
	{
		char stock[MAX_STOCK_NAME_LENGTH];
		int interval;
		int volume;
		float high;
		float low;
		sscanf(line, "%s %d %d %f %f", stock, &interval, &volume, &high, &low);
		hlm.add(stock, high, low);
		vc.add(stock, interval, volume);
	}
	cout  << "Writing files"  << endl;
	// write file a
	cout << vc;
	// write file b
	cout << hlm;
	return 1;
}


==============================================================================
*kt_dev_quiz_015* sorting and searching questions from {ref-004}

1. You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B.
Write a method to merge B into A in sorted order.

Our logic should invlove simply comparing elements of A and B and inserting them in order, until we
have exhausted all elements in A and in B. The issue is that if insert an element into the front of
A, then we will have to shift the existing elements backwards. Better to insert elements into the
back where there is empty space. In short, combine in mergesort but from back.

void merge( int* a, int* b, int lastA, int lastB )
{
	int indexA = lastA-1, indexB = lastB-1;
	int indexMerged = lastB+lastA-1;

	while( indexA >= 0 && indexB >= 0 )
	{
		if( a[indexA] > b[indexB] )
		{
			a[indexMerged] = a[indexA];
			indexMerged--;
			indexA--;
		}
		else
		{
			a[indexMerged] = a[indexB];
			indexMerged--;
			indexB--;
		}
	}
	
	while( indexB >= 0 )
			a[indexMerged] = a[indexB];
			indexMerged--;
			indexB--;
}


2. Write a method to sort an array of strings so that all the anagrams are next to each other.

Ask us to group the strings in an array that the anagrams appear next to each other. Note that no
specific ordering of the words is required.

One way to do this is to use any standard sorting and modify the comparator. What's the easiest way
of checking if two words are anagrams? Could count occurrences of chars or could sort the string.


But do not actually need to fully sort the array. Only need to group the strings in the array by
anagram. Can do this by using a hash table which maps from the sorted version of a word to a list of
its anagrams. So, for example, 'acre' will map to the list {acre, race, care}. Once we've grouped
all the words into these list by anagram, can then put them back into the array.

public void sort( String[] array )
{
	Hashtable< String, LinkedList< String >> hash = new Hashtable< String, LinkedList< String >>();

	// group words by anagram
	for( String s : array ) {
		String key = sortChars(s);
		if( !hash.containsKey(key))
			hash.put( key, new LinkedList<String>());

		LInkedList< String > anagrams = hash.get(key);
		anagrams.push(s);
	}

	// convert hash table to array
	int index = 0;
	for( String key : hash.keySet())
	{
		LinkedList< String > list = hash.get(key);
		for( String t : list ) {
			array[index] = t;
			index++;
		}
	}
}

If use STL, then can code:

bool isAnagram( string a, sting b )
{
	if( a.size() != b.size() ) return false;

	sort( a.begin(), a.end() );
	sort( b.begin(), b.end() );

	return a == b;
}

func( vector< string > &svec )
{
	sort( svec.begin(), svec.end(), isAnagram );
}

However, question is how the final vector looks like?


3. Given a sorted array of n integers that has been rotated an unknown unmber of times, wrtie code
to find an element in the array. You may assume that the array was originally sorted in increasing
order.

EXAMPLE
input: find 5 in {15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14}
output: 8 (the index of 5 in the array)

The complication is that the array is rotated and may have an inflection point and consider
following examples:

A1{10, 15, 20,  0,  5}
A2{50,  5, 20, 30, 40}

See that 5 appears on different side so comparing x with the midpoint is insufficient. However, if
you look a bit DEEPER, one half of the array must be ordered (regardless of how much it is rotated.) 
This is key observation which allows us to determine whether should search the left or right half.

 [KT] The rotation breaks sorted array but there is still one half ordered.

For example of searching 5 in A1, look at the left element, 10, and middle, 20. Since 10 < 20, the
left half must be ordered and since 5 is not in left half, must search the right half.

So determine the ordered half and see if a key is in the the ordered half. If so, do binary search
or sequential if n is small. If not, do sequential on the opposite half.

The tricky is if the left and the middle are identical, as in the example array

{2, 2, 2, 3, 4, 2}
       m

    m
2 2 2 2 3 4 (left)
4 2 2 2 2 3
3 4 2 2 2 2
2 3 4 2 2 2 
2 2 3 4 2 2 
2 2 2 3 4 2 (right)
2 2 2 2 3 4 (left)

In this case, check if the rightmost element is different. If it is, can search just the right side.
Otherwise, we have no choice but to search both halves.

public int search( int a[], int left, int right, int x ) {
	int mid = ( left + right )/2;

	// check mid first
	if( x == a[mid] )
		return mid;

	if( right < left )
		return -1;

	// left is ordered
	if( a[left] < a[mid] )
	{
		if( x >= a[left] && x <= a[mid] ) 		// is in the left and search it
			return search( a, left, mid-1, x );
		else
			return search( a, mid+1, right,x );	// is not in the left and search the right
	}
	// right is ordered
	else if( a[mid] < a[left] )
	{
		if( x >= a[mid] && x <= a[right] )		// search right
			return search(a, mid+1, right, x );
		elser
			return search(a, left, mid-1, x );	// search left
	}
	// left is all repeats
	else if( a[left] == a[mid] )
	{
		if( a[mid] != a[right])
			return search(a, mid+1, right, x);			// search right
		else
		{
			int result = search(a, left, mid-1, x );	// search left
			if( result == -1 )
				return search(a, mid+1, right, x );		// search right
			else
				return result;
		}
	}

	return -1;
}

This will run in O(logn) if all the elements are unique. However, with many duplicates is actually
O(n). This is because with many duplicates, will often have to search both.

 [KT] If n is large, can use iterative binary1 search on ordered half.


4. Imagine you have a 20GB file with one string per line. Explain how you would sort the file.

In this case, it suggests that they don't want you to bring all the data into memory. We'll divide
the fine into chunks which are x MB each where x is the amount of memory we have available. Each
chunk is sorted separately and then saved back to the file system.

Once all the chunks are sorted, we then merge the chunks, one by one. At the end, we have a fully
sorted file. This is known as external sort.

 [KT] For sorting chunks, load it to a memeory and use quicksort as it is good for contig memory and
 can use mergesort for merging sorted chunks which are in file system. 


<5> Given a sorted array of string which is interspersed with empty string, write a method to find
the location of a given string.

EXAMPLE
input: find 'ball' in { "at", "", "", "", "ball", "", "", "cor", "", "", "dad", "", "" }
output: 4 (the index of 4 in the array)


{A} Can implement simple modification of binary search. All we need to do is fix the comparison
against mid, in case mid is an empty string. Simply move mid to the closest non-empty string. 

public int searchR( String[] strings, String str, int first, int last )
{
	int mid = (last+first)/2;

	// if mid is empty, find closest non-empty string in both direction.
	if( strings[mid].isEmpty())
	{
		int left = mid-1;
		int right = mid+1;

		while(true)
		{
			if(left < first && right > last)
				return -1;
			else if( right <= last && !strings[right].isEmpty())
			{
				mid = right; break;
			}
			else if( left >= first && !strings[left].isEmpty())
			{
				mid = left; break;
			}

			right++; left--;
		}
	}

	// check for string, and recurse if necessary
	if( str.equals( strings[mid] ))		// found
		return mid;
	else if( strings[mid].compareTo(str) < 0)
		return searchR( strings, str, mid+1, last );		// search right
	else
		return searchR( strings, str, first, mid-1 );	// search left
}

public int search( String[] strings, String str )
{
	if( strings == null || str == null || str == "" )
		return -1;

	return searchR( strings, str, 0, strings.length-1 );
}


Careful consideration should be given to the situation when someone searches for the empty string.
Should we find the location( which is an O(n) operation)? Or should we handle this as an error?
There is no correct answer here. This is an issue you should raise with your interviewer. Simply
asking this question will demonstrate that you are a careful coder.

 [KT] Is it possible since do not know how to identify a empty string between them?



<6> Given MxN matrix in which each row and column is sorted, write a method to find an element.

{A} If do binary search on every row, then O(M logN). This is a good approach to mention to your
interviewer before you proceed with a better algorithm.

[approach-one] use first and last element.

Use these observations:
- if the start of col is greater than x, x is to the left of the col. exclude col.
- if the end of col is less than x, x is to the right of the col.

- if the start of row is greater than x, x is above that row.
- if the end of row is less than x, x is below that row.

15 20 40  85
20 35 80  95
30 55 95  105
40 80 100 120

Use 1 and 4 condition and repeatedly apply these to search for 55. Eleminate row and col from
top-right of array and so EQ check on the first at each iteration which is top-right. See that
top-right is both the start of col and the end of row.

bool findElement( int [][] matrix, int elem )
{
	int row = 0;
	int col = matrix[0].length -1;

	while( row < matrix.length && col >= 0 )
	{
		if( matrix[row][col] == elem )
			return true;
		else if( matrix[row][col] > elem )	// start of col
			col--;
		else 											// end of row
			row++;
	}
	return false;
}


[approach-two]
This more directly looks like binary search. More complicated but it applies many of the same
learnings.

The observation is that when see 95, all elements in sub rectangle are less than 95 and this is true
along the diagonal. So do binary search on the diagonal.

15 20 70 |85
20 35 80 |95
30 55 95 |105
----------
40 80 100 120

In search for 85, it cannot be in top-left and bot-right sub rectangle and continue for other sub
rectangles.

 15  20  * [70]  85
 20  35  *  80  [95]
***************
[30] 55  * [95] 105
 40 [80] * 100  120

static Coordinate findElement( int matrix[][], int x )
{
	Coordinate origin = new Coordinate(0, 0);
	Coordinate dest = new Coordinate( matrix.length-1, matrix[0].length-1 );

	return findElement(matrix, origin, dest, x );
}

// origin is top-left and dest is bot-right
public Coordinate findElement( int [][] matrix, Coordinate origin, Coordinate dest, int x )
{
	if( !origin.inbounds( matrix ) || !dest.inbounds(matrix) )
		return null;

	// EQ on origin
	if( matrix[origin.row][origin.col] == x )
		return origin;

	else if( !origin.isBefore(dest))
		return null;

	// get start and end of diagonal since the grid may not be square, the end of the diagonal may
	// not equal dest.
	Coordinate start = (Coordinate) origin.clone();
	int diagDist = Math.min( dest.row - origin.row, dest.col - origin.col );
	Coordinate end = new Coordinate( start.row + diagDist, start.col + diagDist );

	// do binary search on the diagonal, looking for the first element greater than x
	// but seems wrong. think of searcing 25.
	Coordinate p = new Coordinate(0,0);

	while( start.isBefore(end))
	{
		p.setToAverage( start, end );

		if( x > matrix[p.row][p.col] )
		{
			start.row = p.row+1; start.col = p.col+1;
		}
		else
		{
			end.row = p.row-1; end.col = p.col-1;
		}
	}

	return partitionAndSearch( matrix, origin, dest, start, x );
}

public Coordinate partitionAndSearch( int [][] matrix, Coordinate origin, Coordinate dest,
		Coordinate pivot, int elem )
{
	// origin and dest for low-left sub rectangle
	Coordinate lowerLeftOrigin	 =  new Coordinate( pivot.row, origin.col );
	Coordinate lowerLeftDest	 =  new Coordinate( dest.row, pivot.col-1 );

	// origin and dest for up-right sub rectangle
	Coordinate upperRightOrigin =  new Coordinate( origin.row, pivot.col );
	Coordinate upperRightDest 	=  new Coordinate( pivot.row-1, dest.col );

	Coordinate lowerLeft = findElement( matrix, lowerLeftOrigin, lowerLeftDest, elem );
	if( lowerLeft == null )
		return findElement(matrix, upperrightorigin, upperRightDest, elem );

	return lowerLeft;
}



<7> A circus is designing a tower routine consisting of people standing atop one another's shoulder.
For practical and aesthetic reasons, each person must be both shorter and lighter than the person
below him or her. Given the heights and weights of each person in the circus, write a method to
compute the largest possible number of people in such a tower.

We have a list of pairs of items. Find the longest sequence such that both the first and second
items are in increasing order. Apply the simple-and-generalize approach and can relate this problem
to finding the-longest-increasing-sequence in an array.

If the elements do not need to stay in the same(relative) order, then we would simply sort the
array. This makes the problem too trivial, so let's assume that the elements need to stay in the
same order.

The first recursive approach:

Array: 13, 14, 10, 11, 12
Longest(0 through 0) : 13
Longest(0 through 1) : 13, 14
Longest(0 through 2) : 13, 14
Longest(0 through 3) : 13, 14 or 10, 11
Longest(0 through 4) : 10, 11, 12

The different approach: Rather then trying to find the longest increasing subsequence across
elements 0 through i, can find the longest subsequence which [ends] with element i. 

Array: 13, 14, 10, 11, 12
Longest(ending with A[0]) : 13
Longest(ending with A[1]) : 13, 14
Longest(ending with A[2]) : 10
Longest(ending with A[3]) : 10, 11
Longest(ending with A[4]) : 10, 11, 12

For the real problem, sort the list of people by their hights and then apply the second approach on
their weights. The solution is the exact implementation of the second and to build a array of list
where a list is sequence. This scans from 0 for every element.

 [KT] The approach in *kt_dev_quiz_013* looks better than this.



<8> Imagine you are reading a stream of integers. Periodically, you wish to be able to look up the
rank of a number x (the number of values less than or equal to x). 

Implement the data structures and algorithms to support these operations.

That is, implement the method track(int x), which is called when each number is generated, and the
method getRankOfNumber(int x), which returns the number of values less than or equal to x (not
including x itself).


{A} A easy way would be to have an array that holds all the elements in sorted order and to run
binary search and return the index. As with contiguous list, not efficient whenever insert elements
and sort it. This is what BST sloves. To find the rank of a number, we could do an inorder
traversal and this is exactly {treesort}. However, this is about getting the number of nodes less
than x. Two solutions?

1) build BST when element comes in and do inorder traversal. when visit, if not the same, increase
visit count and if the same, stop and print/return count because inorder outputs sorted.

2) In the book, it have left count per each node and increase it whenever inserting on left happens
since it means that element which is less is inserted. That is, build a BST with left count as add
new elements to the tree. When getting the rank, traverse a tree by adding left count when move left
and 1 when move right since it need to add node itself before move to right. 

						20[4] ()

			15[3] ()				25[2] ()

	10[1] () 			23[0] ()

5[0] () 	13[0] () 		24[0] ()

where [x] means left count and for 24, the count is 6.

class RankNode {
	int left_size = 0;
	RankNode left, right;
	int data = 0;

public void insert(int d) {
	if ( d <= data ) 
	{
		if( left != null ) left.insert(d);
		else left = new RankNode(d);
		left_size++; // [KT]
	}
	else 
	{
		if( right != null ) right.insert(d);
		else right = new RankNode(d);
	}
}

public int getRank(int d) {
	if( d == data )
	{ return left_size; }
	else if( d < data )
	{
		if( left == null ) return -1;
		else return left.getRank(d);
	}
	else
	{
		int right_rank = right == null ? -1 : right.getRank(d);
		if( right_rank == -1 ) return -1;
		else return left_size + 1 + right_rank;	// [KT]
	}
}

};

Handled the case in which d is not found in the tree and return -1 up the tree. It is important that
you handle cases like that.


={{===========================================================================
*kt_dev_quiz_016*	cycle detection

{example-one}
From {find-middle-in-a-linked-list} in mergesort, this is to find the middle of the simple list.
When entries are odd numbers, the first half is one larger. If think it using the number of node:

middle	current	diff
0			1			1
1			3			2
2			5			3
3			7			4
...

This shows that middle or slow node moves at one element and current or fast moves two. However this
assumes that there is no cycle in the single linked list. This is similar with the tortoise-and-hare
but different because tries to find the middle and starts from 0 and 1 with checks.

void Divide(List* list, List* secondhalf)
{
   ListNode *current, *midpoint;

   if((midpoint = list->head) == NULL )	// must use ()
      secondhalf->head = NULL;
   else
   {
      for( current = midpoint->next; current; )
      {
         current = current->next;
         // cannot move two in a single shot since do not know when one is the end.
         if(current)
         {
            midpoint = midpoint->next;
            current = current->next;
         }
      }
		// breaks up a list into two
      secondhalf->head = midpoint->next;	// the second half
      midpoint->next = NULL;					// the first half
   }
}


{example-two}
From http://stackoverflow.com/questions/494830/how-to-determine-if-a-linked-list-has-a-cycle-using-only-two-memory-locations

This is known as "floyd's cycle finding algorithm or the tortoise and the hare algorithm" and has
O(n) for time and O(1) for space.

function boolean hasLoop(Node startNode) {

  Node slowNode = Node fastNode1 = Node fastNode2 = startNode;

  // see how to move two using three variables in while statement.
  // f2(first) -> [f1 -> f2] -> [f1 -> f2 ] -> 
  while (slowNode && fastNode1 = fastNode2.next() && fastNode2 = fastNode1.next()){

    if (slowNode == fastNode1 || slowNode == fastNode2) return true;

    slowNode = slowNode.next();
  }

  return false;
}

The list covers all cases so do not need to check if startNode is null and ListSize.

slow 	fast1	fast2
0		1		2			: compare slow with fast1 and fast2
1		3		4
2		5		6
3		7		8
...

From {Q} below, thought that this approach won't detect the case that a difference is more than 2
such as:

Node0 -> Node1 -> Node2 -> Node3 -> Node4 -> ...
                        -> Node0 : cannot detect this

This is wrong since if contines loop, there is a point when nodes are the same:

0	1 	2
1	0	1

Therefore as long as there is a cycle out of step, then will eventually find it since there should
be wraps. In other words, if there is a loop, hare will go forever and will meet toroise.

{Q} not sure what this mean since hare will catch tortoise in the end if there is a loop.

what happens if we advance the fastNode by three at a time instead of two? Can't we detect that
fastNode has crossed slowNode. Obviously the equality check (which we are currently using for
detecting this) need not necessarily work with advances of three. What do you think? Wont this
(hop more steps at a time) be a better algorithm? –  Lazer Apr 3 '10 at 2:49
	
@Lazer - there's a risk for small loops that both pointers wrap like that –  Flexo Oct 7 '11 at
10:46 

{Q} what is the benefit of comparing fastnode1? since cannot exist both cases. For example, 0 and 1
and 0 and 2. 


{example-three}
http://codingfreak.blogspot.com/2012/09/detecting-loop-in-singly-linked-list_22.html

tortoise := firstNode  
hare := firstNode  
  
forever:  
  
  if hare == end   
    return 'No Loop Found'  
  
  hare := hare.next  
  
  if hare == end  
    return 'No Loop Found'  
  
  hare = hare.next  
  tortoise = tortoise.next  
  
  if hare == tortoise  
    return 'Loop Found'


bool hasLoop(List* list)
{
  ListNode *hare = *tor = list->head;

  while( tor && hare = hare->next && hare = hare->next )
  {
    if( tor == hare )
      return true;

    tor = tor->next;
  }

  return false;
}

Tha above has errors and should be coded as below. Can you find where and why?

<code-example>
bool hasLoop(List* list)
{
  ListNode *tor = list->head;
  ListNode *hare = list->head;

  while( tor && (hare = hare->next) && (hare = hare->next) )
  {
    if( tor == hare )
      return true;

    tor = tor->next;
  }

  return false;
}


Irrespective of the shape of the cycle, one thing is clear - that the Tortoise can never catch up
with the Hare if there is no loop.  If the two has to meet, the Hare has to catch up with the
Tortoise from behind.

With that established, consider the two possibilities

    Hare is one step behind Tortoise
    Hare is two step behind Tortoise

All greater distances will reduce to One or Two. Let us assume always Tortoise moves first  (it
could be even other way).

In the first case were the distance between Hare and Tortoise is one step. Tortoise moves one step
forward and the distance between Hare and Tortoise becomes 2. Now Hare moves 2 steps forward meeting
up with Tortoise.

In the second case were the distance between Hare and Tortoise is two steps. Tortoise moves one step
forward and the distance between Hare and Tortoise becomes 3. Now Hare moved 2 steps forward which
makes the distance between Hare and Tortoise as 1. It is similar to first case which we already
proved that both Hare and Tortoise will meet up in next step.

Let the length of the loop be 'n' and there are 'p' variables before the loop. Hare traverses the
loop twice in 'n' moves, they are guaranteed to meet in O(n).

 [KT] The point is that there is a loop when hare meets tortoise.


={{===========================================================================
*kt_dev_quiz_017*	power of two

From google phone interview, quick calculation of 2^24.

2^10 = 10^3 = 1K
2^20 = 10^6 = 1000K = 1M = million
2^24 = 2^4 * 2^20 = 16M


==============================================================================
*kt_dev_quiz_018*	linked list questions from {ref-004}

single-or-double

When you are dicussing a linked list in an interview, must understand whether it is a singly linked
list or a doubly linked list.

delete-a-node-in-a-list

Given a node n, find the previous node prev and set prev.next equal to n.next. If the list is doubly
linked, must also update n.next to set n.next.prev equal to n.prev. Also important to check for the
null pointer, to update the head or tail as necessary, or to do memory management.


<2-1> Write code to remove duplicates from an unsorted linked list. Follow up. How would you solve
this problem if a temporary buffer is not allowed?

A simple hash table will work well here. Simply iterate through the linked list, adding each element
to a hash table. When discover a duplicate element, remove the element and continue iterating. Can
do this all in one pass since we are using a linked list.

public static void deleteDups( LinkedListNode n )
{
	Hashtable table = new Hashtable();

	LinkedListNode prev = null;

	while( n != null )
	{
		if( table.containsKey(n.data))
		{
			prev.next = n.next;
		}
		else
		{
			table.put(n.data, true );
			prev = n;
		}

		n = n.next;
	}
}

This takes O(n) time. [KT] Can use stl::set and should delete duplicate node. 

If do not have a buffer, can iterate with two pointers; current which iterates through the linked
list, and runner which checks all subsequent nodes for duplicates.

public static void deleteDups( LinkedListNode head )
{
	if( head == null ) return;

	LinkedListNode current = head;

	while( current != null )
	{
		LinkedListNode runner = current;
		while( runner.next != null )
		{
			if( runner.next.data == current.data )
				runner.next = runner.next.next;
			else
				runner = runner.next;
		}

		current = current.next;
	}
}

This runs in O(1) space and O(n2) time. This is called [runner-technique] which is the second
pointer used in many linked list problems.


<2-2> Implement an algorithm to find the kth to last element of a singly linked list.

If the size of the linked list is known, the kth to last is the (length-k) th element. Just iterate
through the list to find this element. Because this solution is so trivial, we can almost be sure
that this is not what the interviewer intended. [KT] The solutions in this book looks odd and don't
get why since iterating through from the head is better and ture when do not know the size as when
know the size.


<2-3> Implement an algorithm to delete a node in the middle of a singly linked list, given only access
to that node.

You are not given the head of the list and only have access to that node. The solution is to copy
the data from the next node over to the current and delete the next node.

public static boolean deleteNode( LinkedListNode n ) {
	if( n == null || n.next == null )
		return false;

	LinkedListNode next = n.next;
	n.data = next.data;
	n.next = next.next;

	// must delete next;
	return true;
}

This connot solve if the node to be deleted is the last node since it do not have next. That is okay
as long as you can point that out. Can add a dummy node.


<2-4> Write a code to partition a linked list around a value x, such that all nodes less than x come
before all nodes greater than or equal to x.

If this were an array, be careful about how we shifted elements since array shift are very
expensive. However in a linked list the situation is much easier and can create two different linked
lists; before and after list. Once completed splitting and reached the end, merge the two list.

ListNode* partition( List* list, int x )
{
	ListNode* beforeStart = null;
	ListNode* beforeEnd = null;
	ListNode* afterStart = null;
	ListNode* afterEnd = null;

	ListNode* node = list->header;

	while(node != null)
	{
		// save next node
		ListNode* next = node->next;
		
		// break a link but not needed
		node->next = null;

		if( node->data < x )
		{
			// insert node into the before list
			if( beforeStart == null )
			{ beforeStart = node; beforeEnd = beforeStart; }
			else
			{ beforeEnd->next = node; beforeEnd = node; }
		}
		else
		{
			// insert node into the after list
			if( afterStart == null )
			{ afterStart = node; afterEnd = afterStart; }
			else
			{ afterEnd->next = node; afterEnd = node; }
		}

		node = next;
	}

	if( beforeStart == null )
		return afterStart;

	// merge before and after list
	beforeEnd->next = afterStart;
	return beforeStart;
}

If it bugs you to keep four different variables, can get rid of some with a minor hit to the
efficiency. This drop comes because have to traverse the list an extra time. The big-O time will
remain the same though and we get shorter and cleaner code. Instead of inserting nodes into the end
of list, inserts node into the front of them.

ListNode* partition( List* list, int x )
{
	ListNode* beforeStart = null;
	ListNode* afterStart = null;

	ListNode* node = list->header;

	while(node != null)
	{
		// save next node
		ListNode* next = node->next;
		
		if( node->data < x )
		{
			node->next = beforeStart;
			beforeStart = node;
		}
		else
		{
			node->next = afterStart;
			afterStart = node;
		}

		node = next;
	}

	if( beforeStart == null )
		return afterStart;

	// find end of before list and merge them
	ListNode* head = beforeStart;		// node = beforeStart; to use node variable.
	while( beforeStart->next != null )
		beforeStart = beforeStart.next;

	beforeStart->next = afterStart;
	return head;
}

[KT] Thought about modification of BST since it has the left which is less and the right which is
greater than node entry. For example, use fixed entry value of root and node either left or right.
Not recursive since need only the right and the left. After all, this has two pointers and is the
same as above. Also think {mergesort}


<2-5> You have two numbers represented by a linked list, where each node contains a single digit.
The digits are stored in reverse order, such that the 1's digit is at the head of the list. Write a
function that adds the two numbers and returns the sum as a linked list.

The book's approach is to use how addition works and can do this process recursively by adding node
by node, carrying over any excess to the next node.

 7 -> 1 -> 6 -> X
+5 -> 9 -> 2 -> X
------------
 2 -> 1 -> 9
 ----------> pass carry forward

Be careful to handle the condition when one list is shorter than another.

LinkedListNode addLists( LinkedListNode lone, LinkedListNode ltwo, int carry )
{
	// done if both lists are null and the carry is 0, no need to check on carry
	if( lone == null && ltwo == null && carry == 0 )
		return null;

	LinkdedListNode result = new LinkedListNode( carry, null, null );

	int value = carry;

	if( lone != null )
		value += lone.data;

	if( ltwo != null )
		value += ltwo.data;

	result.data = value % 10;
	
	if( lone != null || ltwo != null || value >= 10 )
	{
		LinkedListNode more = addLists( lone == null ? null : lone.next,
				ltwo == null ? null : ltwo.next,
				value >= 10 ? 1 : 0 );

		result.setNext(more);
	}

	return result;
}

<code-example>

#include <iostream>
#include <cstdlib>

typedef int ListEntry;

typedef struct node
{
	ListEntry 	entry;
	node*			pnext;
} ListNode;

typedef struct {
   int   count;
	ListNode*	header;
} List;

ListNode* MakeListNode( ListEntry entry )
{
	ListNode* pnode = NULL;

	if( (pnode = (ListNode*) malloc( sizeof(ListNode))) == NULL )
	{
		std::cout << "no more memory" << std::endl;
		return NULL;
	}

	pnode->entry = entry;
	pnode->pnext = NULL;

	return pnode;
}

void CreatList( List* list )
{ 
   list->count = 0;
   list->header = NULL; 
}	

bool ListEmpty( List* list )
{ return ( list->header == NULL ); }

// add only at the end
bool ListAdd( List* list, ListEntry entry )
{
	ListNode* pnode, *pend;

	if( (pnode = MakeListNode(entry)) == NULL )
	{
		std::cout << "add: mem is full" << std::endl;
		return false;
	}

   if( ListEmpty( list ) )
   {
      list->header = pnode;
   }
   else
   {
      for( pend = list->header; pend->pnext; pend = pend->pnext )
         ;

      pend->pnext = pnode;
   }

   list->count++;

   std::cout << "add: added " << entry << ", count " << list->count << std::endl;

	return true;
}

typedef void(*TRAVERSEFUNC)(ListEntry);	

void ListTraverse( List* list, TRAVERSEFUNC func)
{
	ListNode* pnode;

	if( ListEmpty(list) )
	{
		std::cout << "list is empty" << std::endl;
		return;
	}
	
	pnode = list->header;

	while(pnode)
	{
		func(pnode->entry);
		pnode = pnode->pnext;
	}
}

void EntryPrint(ListEntry item)
{
   std::cout << "item is: " << item << std::endl;
}

ListNode* sumLists( ListNode *one, ListNode *two, ListEntry carry )
{
	if( one == NULL && two == NULL )
		return NULL;

	ListNode* pnode = MakeListNode( carry );
	if(!pnode)
	{
		std::cout << "sumLists: mem is full" << std::endl;
		return NULL;
	}

	if( one != NULL )
		carry += one->entry;

	if( two != NULL )
		carry += two->entry;

	pnode->entry = carry % 10;

// This was an attempt to reduce one recursive call because the book's approach make a one last call
// when both input node is null. For example
//
// 1->2->X
// 3->4->5->X // here a call made to X on this list
//
// However, this cause a crash because when one of both is null, cannot use one->pnext or
// two->pnext.
//
// {LL} When use recursive, must careful about NULL and accessing data from NULL.
//
//	if( one->pnext != NULL || two->pnext != NULL )
//		pnode->pnext = sumLists( one->pnext, two->pnext, carry >= 10 ? 1 : 0 );
//

	if( one != NULL || two != NULL )
		pnode->pnext = sumLists( one == NULL ? NULL : one->pnext, two == NULL ? NULL : two->pnext, 
				carry >= 10 ? 1 : 0 );

	return pnode;
}

int main()
{
	int item = 0;

	// first
	List first;
	CreatList(&first);

	std::cout << "type in 2 numbers." << std::endl;

	for(int i=0; i < 2; i++)
	{
		std::cin >> item;
		ListAdd(&first, item );
	}		

	// second
	List second;
	CreatList(&second);

	std::cout << "type in 3 numbers." << std::endl;

	for(int i=0; i < 3; i++)
	{
		std::cin >> item;
		ListAdd(&second, item );
	}		

	std::cout << "first:" << std::endl;
	ListTraverse(&first, EntryPrint);

	std::cout << "=======" << std::endl;
	std::cout << "second:" << std::endl;
	ListTraverse(&second, EntryPrint);

	// sum
	List sum;
	CreatList(&sum);

	sum.header = sumLists( first.header, second.header, 0 );

	ListTraverse(&sum, EntryPrint);
}


[KT] If there is no need to build a list for a result, simply follow a list and build number and do
integer addition.

1's			10's			100's
10^0			10^1			10^2
node*10^0	node*10^1	node*10^2


<follow-up> Suppose the digits are stored in forward order. Repeat the above problem.

Two complications:

- One list may be shorter then the other. For example, 1->2->3->4 and 5->6->7. Need to know that the
5 should be matched with the 2, not the 1. How? Compare the length of the lists and pad the shorter
list with zeros.

- In the previous, the successive results were added to the tail, ie., passed carry forward. In this
case results are added to the head, ie., passed backward. This time recursive call must return the
carry as well. Can solve this by creating a wrapper class, PartialSum.


1 -> 2 -> 3 -> X
4 -> 5 -> 6 -> X
h
               sum
          sum+val+carry
     sum+val+carry
sum+val+carry

So PartialSums is one to pass backward sum and carry.


public class PartialSum {
	public LinkedListNode sum = null;
	public int carry = 0;
}

LinkedListNode padList( LinkedListNode l, int padding )
{
	LinkedListNode head = l;

	for( int i = 0; i < padding; i++ )
	{
		LinkedListNode n = new LinkedListNode( 0, null, null );
		// if it is single linked list 
		// head.prev = n;
		n.next = head;
		head = n;
	}
}

LinkedListNode insertBefore( LinkedListNode list, int data )
{
	LinkedListNode node = new LinkedListNode( data, null, null );

	if( list != null )
	{
		// list.prev = node;
		node.next = list;
	}

	return node;
}

// See how the recursive is used to start from the end node.
PartialSum addListsHelper( LinkedListNode l1, LinkedListNode l2 )
{
	if( l1 == null && l2 == null )
	{
		PartialSum sum = new PartialSum();
		return sum;
	}

	// add smaller digit recursively up to null
	PartialSum sum = addListsHelper( l1.next, l2.next );

	// add carry to current data
	int val = sum.carry + l1.data + l2.data;

	// insert sum of current digit. Initially, sum.sum is null.
	LinkedListNode full_result = insertBefore( sum.sum, val%10 );

	// return sum so far and the carry value
	sum.sum = full_result;
	sum.carry = val / 10;

	return sum;
}

// see that there is no carry arg
LinkedListNode addLists( LinkedListNode l1, LinkedListNode l2 )
{
	int len1 = length(l1); int len2 = length(l2);

	// pad the shorter list with zeros
	if( len1 < len2 )
		l1 = padList( l1, len2-len1);
	else
		l2 = padList( l2, len1-len2);

	PartialSum sum = addListsHelper( l1, l2 );

	if( sum.carry == 0 )
		return sum.sum;
	else
	{
		LinkedListNode result = insertBefore( sum.sum, sum.carry );
		return result;
	}
}

See have pulled insertBefore(), padList() into their own methods. This makes the code cleaner and
easier to read. Wise thing to do in your interview.


<2-6> Given a circular linked list, implement an algorithm which returns the node at the beginning
of the loop.

This is a modification of a classic interview problem: detect if a linked list has a loop. Let's
apply the pattern matching approach. See {tortoise-and-hare}. 


==============================================================================
*kt_dev_quiz_019*	array and string questions from {ref-004}

{1-4} Write a method to replace all spaces in a string with '%20'. You may assume that the string
has sufficient space at the end of the string to hold the additional characters, and that you are
given the 'true' length of the string.

EXAMPLE
input:   "Mr John Smith    "
output:  "Mr%20John%20Smith"

A common approach is to edit the string straight from the end and work backwards because we have
extra buffer at the end.

o If cannot use extra space and have to use input to edit, then use two pass approach like
reference. One pass to find out how many spaces are needed; this is new length. Two pass to replace
chars.

o If can use extra space then use one pass approach to copy and replace chars.

<ref-code>
public void replaceSpaces( char[] str, int length ) {

  int spaceCount = 0, newLength, i = 0;
  for( i = 0; i < length; i++ ) {
    if( str[i] == ' ' )
      spaceCount++;
  }

  newLength = length + spaceCount*2;

  str[newLength] = '\0';

  for( i = length-1; i >= 0; i-- )
  {
    if( str[i] == ' ' )
    {
      str[newLength-1] = '0'; 
      str[newLength-2] = '2'; 
      str[newLength-3] = '%'; 
      newLength = newLength-3;
    }
    else
    {
      str[newLength-1] = str[i];
      newLength = newLength-1;
    }
  }
}

{1-5} Implement a method to perform basic string compression using counts of repeated characters.
For example, the string aabcccccaaa would becomre a2b1c5a3. If the compressed string would not
become smaller than the original string, your method should return the original string.

<ref-code> poor
public String compressBad( String str )
{
  String mystr = "";
  char last = str.charAt(0);
  int count = 1;

  for( int i = 1; i < str.length(); i++ )
  {
    if( str.charAt(i) == last )
      count++;
    else
    {
      mystr += last + "" + count;   // why need ""?
      last = str.charAt(i);
      count = 1;
    }
  }

  // since the last sequence wouldn't be set in the compressed string yet.
  return mystr + last + count;
}

This does not handle the case when the compressed string is longer than the original string but it
otherwise works. Efficient? This is O(n + k^2) where k is the number of sequence because string
concatenation happens whenever there is a sequence and string + operates in O(n^2). See
{inefficient-concatnation}

<ref-code> better
String compressBetter(String str)
{
  // check if compression would create a longer string.
  int size = countCompression(str);
  if( size >= str.length())
    return str;

  StringBuffer mystr = new StringBuffer();
  char last = str.charAt(0);
  int count = 1;
  for( int i = 1; i < str.length(); i++ )
  {
    if( str.charAt(i) == last )
      count++;
    else
    {
      mystr.append(last);
      mystr.append(count);
      // mystr += last + "" + count;   // why need ""?
      last = str.charAt(i);
      count = 1;
    }
  }

  mystr.append(last);
  mystr.append(count);
  return mystr.toString();
}

int countCompression(String str)
{
  char last = str.charAt(0);
  int size = 0;
  int count = 1;

  for( int i = 1; i < str.length(); i++ )
  {
    if( str.charAt(i) == last )
      count++;
    else
    {
      last = str.charAt(i);
      size += 1 + String.valueOf(count).length();
      count = 1;
    }
  }
  
  // valueOf returns string representation of count since count could be big and needs more spaces
  // in character representation.
  //
  size += 1 + String.valueOf(count).length();
  return size;
}

This runs on O(n) space and time. If cannot use StringBuffer then create a char array.


==============================================================================
*kt_dev_quiz_020*	coding task

For Kantar media, second phase after phone call and used via email.

The test is as follow. Please send the code and results to me within 24 hours if you can.

A sample daily viewing file called sample.SWD, which contains the following fields (start position,
character length).

·         Home ID (0,7)
·         Individual ID (7,2)
·         Channel ID (9,4) {the corresponding channel description is in StnDesc.txt}
·         Start time - hhmmss (13,6)
·         End time - hhmmss (19,6)
·         TV set ID (25,1)

- Please extract the viewing distribution (number of viewing statements) by minute and identify any
unusual patterns.

- Please find out the percentage of unmatched tuning (i.e. Channel ID 49) to the total tuning across
the whole day.

- Please find out the top 10 channels based on the volume of viewing.

<sample.swd>
10001340100491938001945591
10001340100491951002049591
10001340100492055002108591
10001340100492124002135591
10001340100492145002156591
10001340100492204002205591
10001340100492211002222591
10001340100492230002236591
10001340200491938001945591
10001340200491951002049591
10001340200492055002108591
10001340200492124002135591
10001340200492145002156591
...

<stndesc.txt>
1;BBC1 London
2;BBC2 London
3;ITV London
4;Pick TV
5;Dave
6;ITV2
7;ITV3
8;ITV4
9;Challenge TV
10;ITV2+1
11;E4
12;E4+1
...

<code-submitted>

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>

class viewEntry
{
  public:
    viewEntry(): viewCount(0), viewVolume(0), cid(0) {}
    unsigned int viewCount;
    unsigned long long viewVolume;
    unsigned int cid;
};

class Viewing
{
  private:
    const int MINUTES_A_DAY;
    unsigned int viewTotal;

    std::vector<int> minutes; 

    typedef std::map<unsigned int, viewEntry> VIEWS;
    VIEWS views;

    unsigned int _getMinutes(std::string time);
    void _countViews( unsigned int line, unsigned int start, unsigned int end );
    unsigned int _getPercent(unsigned int minute, unsigned int max);

  public:
    Viewing( std::ifstream &ifs );

    void getTop10();

    void getPercent(int channel);

    void getDistribution(unsigned int percent, unsigned int max);
};

// Note: Used 25 hours since the data have entries such as 25:59:59
Viewing::Viewing( std::ifstream &ifs ) : viewTotal(0), MINUTES_A_DAY(1560)
{
  unsigned int lineno = 0;
  std::string line, chname, cid, stime, etime;
  unsigned int icid = 0, istime = 0, ietime = 0;

  for(int i = 0; i <= MINUTES_A_DAY; i++)
    minutes.push_back(0);

  // build data
  while(std::getline( ifs, line))
  {
    cid = line.substr(9,4);
    stime = line.substr(13,6);
    etime = line.substr(19,6);

    icid = std::stoi(cid);
    istime = _getMinutes(stime);
    ietime = _getMinutes(etime);

    // handle invalid entries
    if( icid == 950 )
      continue;

    // build views map
    auto& entry = views[icid];
    entry.viewCount++; 
    entry.viewVolume += (ietime-istime);
    entry.cid = icid;

    // build distribution vector
    _countViews( lineno, _getMinutes(stime), _getMinutes(etime));

    lineno++;
  }
}

unsigned int Viewing::_getMinutes(std::string time)
{
  return std::stoi(time.substr(0,2))*60 + std::stoi(time.substr(2,2));
}

void Viewing::_countViews(unsigned int line, unsigned int start, unsigned int end)
{
  if(start > MINUTES_A_DAY || end > MINUTES_A_DAY)
  {
    std::cout << "countViews: error: time is out of a day limit. line: " << line << std::endl;
    return;
  }

  for(int idx = start+1; idx <= end; idx++)
  {
    minutes[idx] += 1;
  }
  
  viewTotal++;
}

unsigned int Viewing::_getPercent(unsigned int minute, unsigned int max)
{
  return (minutes[minute]*100 / max);
}

// Please find out the top 10 channels based on the volume of viewing
// Note: here assumes that this is rarely used and if not, need to consider having a running
// structure rather than a temporay.
void Viewing::getTop10()
{
  VIEWS::iterator views_it = views.begin();
  typedef std::map<int, int> VOLUMES;
  VOLUMES volumes;

  for(views_it; views_it != views.end(); ++views_it)
  {
    volumes[views_it->second.viewVolume] = views_it->second.cid;
  }

  int i = 0;
  VOLUMES::iterator volumes_it = volumes.end();
  for(--volumes_it, i; i < 10; i++)
  {
    std::cout << i+1 << "th channel is " << (*volumes_it).second << std::endl;
    --volumes_it;
  }
}

// Please find out the percentage of unmatched tuning (i.e. Channel ID 49) to the total tuning across the whole day.
void Viewing::getPercent(int channel)
{
  auto& entry = views[channel];
  double result = (entry.viewCount*100/viewTotal);
  std::cout << "The channel " << channel << " has " << result << " % in total" << std::endl;
}


// Please extract the viewing distribution (number of viewing statements) by minute and identify any unusual patterns.
// Note: Assumes that viewing distribution means that the number of viewes in a specific minute and
// that it is unusal when it is over the specified percentage in the scaled down space. Here used
// 50% and 4000 as a max.
void Viewing::getDistribution(unsigned int percent, unsigned int max)
{
  for(unsigned int i = 1; i <= MINUTES_A_DAY; i++)
  {
    unsigned int scaled_percent = 0;

    if( (scaled_percent = _getPercent(i, max)) > percent )
      std::cout << i << " minutes has " << scaled_percent << " % viewers in the scaled-down space."  << std::endl;
  }
}

// Note: Generally no error handling, design, and space/time cosideration since no requirement was given. Aim
// to get the answer and to run in a rather quick fashion since was told it's about 30 minute task. 
int main()
{
  std::string line;
  int lnum = 0;
  std::ifstream ifs("sample.SWD", std::ifstream::in );

  if( ifs.is_open() )
  {
    Viewing view(ifs);

    std:: cout << "==================================================" << std::endl;
    std:: cout << "Q 01" << std::endl;
    std:: cout << "==================================================" << std::endl;
    view.getTop10();
    std:: cout << "==================================================" << std::endl;
    std:: cout << "Q 02" << std::endl;
    std:: cout << "==================================================" << std::endl;
    view.getPercent(49);
    std:: cout << "==================================================" << std::endl;
    std:: cout << "Q 03" << std::endl;
    std:: cout << "==================================================" << std::endl;
    view.getDistribution(50, 4000);

    ifs.close();
  }
  else
    std:: cout << "file is not opened" << std::endl;
}

// <The output from a run>
// ==================================================
// Q 01
// ==================================================
// 1th channel is 49
// 2th channel is 52
// 3th channel is 45
// 4th channel is 3
// 5th channel is 1
// 6th channel is 2
// 7th channel is 96
// 8th channel is 69
// 9th channel is 73
// 10th channel is 67
// ==================================================
// Q 02
// ==================================================
// The channel 49 has 35 % in total
// ==================================================
// Q 03
// ==================================================
// 1211 minutes has 51 % viewers in the scaled-down space.
// 1213 minutes has 51 % viewers in the scaled-down space.
// 1214 minutes has 51 % viewers in the scaled-down space.
// 1216 minutes has 51 % viewers in the scaled-down space.
// 1217 minutes has 51 % viewers in the scaled-down space.
// 1218 minutes has 51 % viewers in the scaled-down space.
// 1219 minutes has 52 % viewers in the scaled-down space.
// 1220 minutes has 51 % viewers in the scaled-down space.
// 1221 minutes has 51 % viewers in the scaled-down space.
// 1222 minutes has 52 % viewers in the scaled-down space.
// 1223 minutes has 51 % viewers in the scaled-down space.
// 1224 minutes has 52 % viewers in the scaled-down space.
// 1225 minutes has 51 % viewers in the scaled-down space.
// 1226 minutes has 51 % viewers in the scaled-down space.
// 1227 minutes has 51 % viewers in the scaled-down space.
// 1231 minutes has 51 % viewers in the scaled-down space.
// 1232 minutes has 52 % viewers in the scaled-down space.
// 1233 minutes has 52 % viewers in the scaled-down space.
// 1234 minutes has 53 % viewers in the scaled-down space.
// 1235 minutes has 53 % viewers in the scaled-down space.
// 1236 minutes has 52 % viewers in the scaled-down space.
// 1237 minutes has 52 % viewers in the scaled-down space.
// 1238 minutes has 52 % viewers in the scaled-down space.
// 1239 minutes has 53 % viewers in the scaled-down space.
// 1240 minutes has 52 % viewers in the scaled-down space.
// 1241 minutes has 53 % viewers in the scaled-down space.
// 1242 minutes has 53 % viewers in the scaled-down space.
// 1243 minutes has 53 % viewers in the scaled-down space.
// 1244 minutes has 53 % viewers in the scaled-down space.
// 1245 minutes has 53 % viewers in the scaled-down space.
// 1246 minutes has 53 % viewers in the scaled-down space.
// 1247 minutes has 53 % viewers in the scaled-down space.
// 1248 minutes has 53 % viewers in the scaled-down space.
// 1249 minutes has 53 % viewers in the scaled-down space.
// 1250 minutes has 54 % viewers in the scaled-down space.
// 1251 minutes has 53 % viewers in the scaled-down space.
// 1252 minutes has 53 % viewers in the scaled-down space.
// 1253 minutes has 53 % viewers in the scaled-down space.
// 1254 minutes has 54 % viewers in the scaled-down space.
// 1255 minutes has 52 % viewers in the scaled-down space.
// 1257 minutes has 52 % viewers in the scaled-down space.
// 1258 minutes has 52 % viewers in the scaled-down space.
// 1262 minutes has 51 % viewers in the scaled-down space.
// 1263 minutes has 51 % viewers in the scaled-down space.
// 1264 minutes has 53 % viewers in the scaled-down space.
// 1265 minutes has 52 % viewers in the scaled-down space.
// 1266 minutes has 53 % viewers in the scaled-down space.
// 1267 minutes has 53 % viewers in the scaled-down space.
// 1268 minutes has 53 % viewers in the scaled-down space.
// 1269 minutes has 54 % viewers in the scaled-down space.
// 1270 minutes has 54 % viewers in the scaled-down space.
// 1271 minutes has 54 % viewers in the scaled-down space.
// 1272 minutes has 54 % viewers in the scaled-down space.
// 1273 minutes has 54 % viewers in the scaled-down space.
// 1274 minutes has 54 % viewers in the scaled-down space.
// 1275 minutes has 55 % viewers in the scaled-down space.
// 1276 minutes has 54 % viewers in the scaled-down space.
// 1277 minutes has 54 % viewers in the scaled-down space.
// 1278 minutes has 54 % viewers in the scaled-down space.
// 1279 minutes has 54 % viewers in the scaled-down space.
// 1280 minutes has 54 % viewers in the scaled-down space.
// 1281 minutes has 54 % viewers in the scaled-down space.
// 1282 minutes has 55 % viewers in the scaled-down space.
// 1283 minutes has 55 % viewers in the scaled-down space.
// 1284 minutes has 54 % viewers in the scaled-down space.
// 1285 minutes has 54 % viewers in the scaled-down space.
// 1286 minutes has 54 % viewers in the scaled-down space.
// 1287 minutes has 54 % viewers in the scaled-down space.
// 1288 minutes has 55 % viewers in the scaled-down space.
// 1289 minutes has 54 % viewers in the scaled-down space.
// 1290 minutes has 54 % viewers in the scaled-down space.
// 1291 minutes has 53 % viewers in the scaled-down space.
// 1292 minutes has 53 % viewers in the scaled-down space.
// 1293 minutes has 54 % viewers in the scaled-down space.
// 1294 minutes has 54 % viewers in the scaled-down space.
// 1295 minutes has 54 % viewers in the scaled-down space.
// 1296 minutes has 54 % viewers in the scaled-down space.
// 1297 minutes has 54 % viewers in the scaled-down space.
// 1298 minutes has 52 % viewers in the scaled-down space.
// 1299 minutes has 53 % viewers in the scaled-down space.
// 1300 minutes has 53 % viewers in the scaled-down space.
// 1301 minutes has 53 % viewers in the scaled-down space.
// 1302 minutes has 53 % viewers in the scaled-down space.
// 1303 minutes has 53 % viewers in the scaled-down space.
// 1304 minutes has 53 % viewers in the scaled-down space.
// 1305 minutes has 53 % viewers in the scaled-down space.
// 1306 minutes has 53 % viewers in the scaled-down space.
// 1307 minutes has 53 % viewers in the scaled-down space.
// 1308 minutes has 53 % viewers in the scaled-down space.
// 1309 minutes has 52 % viewers in the scaled-down space.
// 1310 minutes has 53 % viewers in the scaled-down space.
// 1311 minutes has 52 % viewers in the scaled-down space.
// 1312 minutes has 52 % viewers in the scaled-down space.
// 1313 minutes has 52 % viewers in the scaled-down space.
// 1314 minutes has 53 % viewers in the scaled-down space.
// 1315 minutes has 52 % viewers in the scaled-down space.
// 1316 minutes has 52 % viewers in the scaled-down space.
// 1317 minutes has 52 % viewers in the scaled-down space.


# ============================================================================
#{ PROBLEM SLOVING
==============================================================================
*kt_dev_quiz_100* codility: equilibrium index of a sequence

The equilibrium index of a sequence is an index such that the sum of elements at lower indexes is
equal to the sum of elements at higher indexes. For example, in a sequence A:

A[0]=-7 A[1]=1 A[2]=5 A[3]=2 A[4]=-4 A[5]=3 A[6]=0    [-7, 1, 5, 3, -4, 3, 0]

3 is an equilibrium index, because: A[0]+A[1]+A[2]=A[4]+A[5]+A[6]

6 is also an equilibrium index, because: A[0]+A[1]+A[2]+A[3]+A[4]+A[5]=0 (The sum of zero elements
is zero) 

7 is not an equilibrium index - because it is not a valid index of sequence A. If you still have
doubts, here is a precise definition: 

The integer k is an equilibrium index of a sequence A[0],A[1]..,A[n-1] if and only if 0<= k and
sum(A[0..(k-1)])=sum(A[(k+1)..(n-1)]). Assume the sum of zero elements is equal to zero.

Write a function

int equi(int A[], int n);

that, given a sequence, returns its equilibrium index (any) or -1 if no equilibrium index exists.
Assume that the sequence may be very long. 

The problem can be solved by using various approaches, the most common being simply to follow the
equilibrium definition:

// while moving index, continues to sum right and left sum.
//
int equi ( int A[], int n ) {

  int k, m, lsum, rsum; 

  for(k = 0; k < n; ++k) { 
    lsum = 0; rsum = 0;
    for(m = 0; m < k; ++m) lsum += A[m]; 
    for(m = k + 1; m < n; ++m) rsum += A[m];  
    if (lsum == rsum) return k;
  } 
  return -1; 
} 

Unfortunately, this approach has two disadvantages:

o it fails on large input data sets, since the time complexity is O(n2)
o it fails on large input values (for example if the input array contains values like MIN/MAX_INT)
due to the arithmetic overflows

We can fix the first problem with a better algorithm, and the second problem with a better data-type
(for example, using long long type instead of int for sum computations). The key observation for
better running time is to update the left/right sums in constant time instead of recomputing them
from the scratch. O(n)

<code-example>
int equi(int arr[], int n) {

  if (n==0) return -1; 

  long long sum = 0;
  int i; 

  for(i=0;i<n;i++) sum+=(long long) arr[i]; 

  long long sum_left = 0;    

  for(i=0;i<n;i++) {
    long long sum_right = sum - sum_left - (long long) arr[i];

    if (sum_left == sum_right)
      return i;

    sum_left += (long long) arr[i];
  } 

  return -1; 
} 

<code-example> 
This is what I wrote when try to implement the point above. To be revise like reference code and
shows that requires careful reading of question since equilibrium index is not part of both sum. For
example

      [0] [ ] [ ] ... [ ]
   ->     <------------->
   lsum   rsum

      [0] [1] [ ] ... [ ]
   ----->     <------------->
   lsum   rsum

      [0] [1] [2] [3] ... [ ]
   --------->     <------------->
   lsum   rsum

int equi(int arr[], int n) 
{
  if (n==0) return -1; 

  long long rsum = 0, lsum = 0;

  for(int i=0;i<n;i++) rsum +=(long long) arr[i]; 

  for(int i=0;i<n;i++) {
    rsum -= arr[i];
    lsum += arr[i];

    if ( lsum == rsum )
      return i;
  } 

  return -1; 
} 


#include <iostream>

int tequi( int A[], int n )
{
  if( !n || !A )
    return -1;

  long long sum = 0, rsum = 0, lsum = 0;

  for(int i=0; i<n; i++)
    sum += A[i];

  for(int i=0; i<n; i++)
  {
    rsum = sum - lsum - A[i];

    if( lsum == rsum )
      return i;

    lsum += A[i];
  }
}

int main()
{
  int arr[] = {-7, 1, 5, 3, -4, 3, 0};

  int ret = tequi( arr, sizeof(arr)/sizeof(int) );

  std::cout << ret << std::endl;

  return 0;
}


==============================================================================
*kt_dev_quiz_101* codility: TapeEquilibrium 
https://codility.com/train/

Task description

A non-empty zero-indexed array A consisting of N integers is given. Array A represents numbers on a
tape.

Any integer P, such that 0 < P < N, splits this tape into two non−empty parts: 
A[0], A[1], ..., A[P − 1] and A[P], A[P + 1], ..., A[N − 1].

The difference between the two parts is the value of: 
|(A[0] + A[1] + ... + A[P − 1]) − (A[P] + A[P + 1] + ... + A[N − 1])|

In other words, it is the absolute difference between the sum of the first part and the sum of the
second part.

For example, consider array A such that:

  A[0] = 3
  A[1] = 1
  A[2] = 2
  A[3] = 4
  A[4] = 3

We can split this tape in four places:

  P = 1, difference = |3 − 10| = 7
  P = 2, difference = |4 − 9| = 5
  P = 3, difference = |6 − 7| = 1
  P = 4, difference = |10 − 3| = 7

Write a function:

    int solution(vector<int> &A); 

that, given a non-empty zero-indexed array A of N integers, returns the minimal difference that can be achieved.

For example, given:

  A[0] = 3
  A[1] = 1
  A[2] = 2
  A[3] = 4
  A[4] = 3

the function should return 1, as explained above.

Assume that:

N is an integer within the range [2..100,000];
each element of array A is an integer within the range [−1,000..1,000].

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage
required for input arguments).

Elements of input arrays can be modified.

// you can also use includes, for example:
// #include <algorithm>
#include <iostream>
#include <climits>
 
int solution(vector<int> &A) 
{
  // write your code in C++98
  if( !A.size() )
    return -1;

  long long sum = 0, rsum = 0, lsum = 0;
  int cmin = INT_MAX;

  for(int i=0; i<A.size(); i++)
    sum += A[i];

  lsum = A[0];

  for(int i=1; i<A.size(); i++)
  {
    rsum = sum - lsum;

    if( abs(lsum-rsum) < cmin )
      cmin = abs(lsum-rsum);

    lsum += A[i];
  }

  return cmin;
}


==============================================================================
*kt_dev_quiz_102* codility: absolute distinct count of this array

A non-empty zero-indexed array A consisting of N numbers is given. The absolute distinct count of
this array is the number of distinct absolute values among the elements of the array.

For example, consider array A such that:

A[0] = -5    A[1] = -3    A[2] = -1
A[3] =  0    A[4] =  3    A[5] =  6

The absolute distinct count of this array is 5, because there are 5 distinct absolute values among
the elements of this array, namely 0, 1, 3, 5 and 6.

Write a function:

int absDistinct(int A[], int N);

that, given a non-empty zero-indexed array A consisting of N numbers, returns absolute distinct
count of array A.

For example, given array A such that:

A[0] = -5    A[1] = -3    A[2] = -1
A[3] =  0    A[4] =  3    A[5] =  6

the function should return 5, as explained above.

Assume that:

N is an integer within the range [1..100,000]; each element of array A is an integer within the
range [-2,147,483,648..2,147,483,647]; array A is sorted in non-decreasing order.

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage
required for input arguments).

Elements of input arrays can be modified.

<cpp-version>
See that abs is not defined.

#include <iostream>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

bool absLessThan(int a, int b)
{
  return abs(a) < abs(b);
}

bool absEqual(int a, int b)
{
  return abs(a) == abs(b);
}

int absDistinct(int A[], int N)
{
  if(N==0)
    return -1;

  vector<int> ivec;
  int count = 0;

  for(int i = 0; i < N; ++i)
    ivec.push_back( *(A+i) );

  sort( ivec.begin(), ivec.end(), absLessThan );
  auto it_end_unique = unique( ivec.begin(), ivec.end(), absEqual );

  auto it_begin = ivec.begin();

  while( it_begin != it_end_unique )
  {
    ++it_begin;
    ++count;
  }

  return count;
}

<cpp-version>
int absDistinct_set(int A[], int N)
{
  if(N==0)
    return -1;

  set<int> iset;

  for(int i = 0; i < N; ++i)
    iset.insert( abs(*(A+i)) );

  return iset.size();
}

int _tmain(int argc, _TCHAR* argv[])
{
  int iarray[] = {-5, -3, -1, 0, 3, 6};

  int ret = absDistinct(iarray, 6);
  cout << ret << endl;

  ret = absDistinct_set(iarray, 6);
  cout << ret << endl;

  return 0;
}

<cpp-version>
https://codility.com/train/AbsDistinct 

// you can also use includes, for example:
// #include <algorithm>
#include <set>

int solution(const vector<int> &A) {
    // write your code in C++98
    int size = A.size();
    
    if( !size )
        return -1;
        
    std::set<int> iset;
    
    for( int i = 0; i <  size; i++ )
        iset.insert( abs(A[i]) );
        
    return iset.size();
}

Test score: 100% 100 out of 100 points 
Detected time complexity: O(N) or O(N*log(N))
  
{Q} How to implement it using c? 2014.02. How about running the modified binary search that use abs
comparison on each item? May be nlogn? That may be the same as set version?

2014.04.12. cannot use binary search since when move index from the start, no way to set bottom and
top.

i = 0, bs(1, n-1)
i = 1, bs(2, n-1)    // missing 0th.
...

So shall use data structures to put inputs like set. or BST?


==============================================================================
*kt_dev_quiz_103* codility: how much water between walls?

From online: http://qandwhat.runkite.com/i-failed-a-twitter-interview/

<question>
"Consider the following picture:"
              _ _
7             7 7 _
6   _         # # 6
5   5         # # #
4   #       4 # # #
3 _ #     3 # # # #
2 2 #   2 # # # # #
1 # # 1 # # # # # #
  -----------------
  0 1 2 3 4 5 6 7 8

In this picture we have walls of different heights. This picture is represented by an array of
integers, where the value at each index is the height of the wall. The picture above is represented
with an array as [2,5,1,2,3,4,7,7,6].

Now imagine it rains. How much water is going to be accumulated in puddles between walls?
              _ _
7             7 7 _
6   _         # # 6
5   5 * * * * # # #
4   # * * * 4 # # #
3 _ # * * 3 # # # #
2 2 # * 2 # # # # #
1 # # 1 # # # # # #
  -----------------
  0 1 2 3 4 5 6 7 8

We count volume in square blocks of 1X1. So in the picture above, everything to the left of index 1
spills out. Water to the right of index 7 also spills out. We are left with a puddle between 1 and 6
and the volume is 10. 

<KT> 2014.04.12. Initial thought by drawings is that
1> only have waters when there is down-and-up, i.e., 5-1-2. 
2> there are as many as down-and-ups in a array. 
3> when goes down including the start from 0 index, set the hightest.
3> when goes up, check with the previous heightest to see which is less than, then there is water up
to the less on hight.

This has the same flaw as the author's initial try has since only get the part.

The first thing I tried to do was to figure out how much water we would have at any given index.
This stroke a resemblance with Calculus and integrals, so I immediately remembered that looking for
local maximums could be of use. And indeed, in the picture above, the water above index 2 is bounded
by the smaller of the two surrounding maximums at index 1 and 6. 

I was thinking out loud: "What if we found all the local maximums, and filled in water between them.
Would that work?"

"Yeah, that should work" replied Justin.

So I went ahead and coded this solution. Then Justin asked me for a bunch of test cases which I
provided. All the test cases we talked about seemed to work.

"Do you have questions for me?" Justin asked. "How did I do?" "Reasonably well. Your solution does 2
passes, but there is a more interesting one that does only 1"

The second I hung up I realized my solution was wrong. Think about this input:

[2, 5, 1, 3, 1, 2, 1, 7, 7, 6]

My solution solved between the local maximums and looked like this: 

7               # # _
6   _           # # #
5   #           # # #
4   #           # # #
3 _ # * #       # # #
2 # # * # * # * # # #
1 # # 1 # # # # # # #
  --------------- ---
  0 1 2 3 4 5 6 7 7 8

But the result should have been one puddle between the two taller towers: 

7               # # _
6   _           # # #
5   # * * * * * # # #
4   # * * * * * # # #
3 _ # * # * * * # # #
2 # # * # * # * # # #
1 # # 1 # # # # # # #
  --------------- ---
  0 1 2 3 4 5 6 7 7 8

Now I ask myself: what have I learned from this? Realistically - not much. I am upset that the
interviewer didn't ask me the right questions to guide me towards the right train of thought. I
don't know why Justin told me "this should work," when my solution in fact didn't. I know that this
should have come up in the test cases he asked for, but since I missed the flaw when coming up with
the algorithm, I didn't think of testing for it. 

The logic is as follows:

If we traverse the list from left to right, the amount of water at each index is at most the largest
value we have discovered so far. That means that if we knew for a fact that there is something
larger or equal to it somewhere on the right, we would know exactly how much water we can hold
without spilling. Same goes for traversing in the opposite direction: if we know we have found
something larger on the left than the largest thing on the right, we can safely fill up water.

With this in mind, one solution would be to first find the absolute maximum value, traverse from the
left to the maximum, and then traverse from the right to the maximum. This solution does 2 passes:
one to find the maximum, and the other is split into two subtraversals.

<two-pass-beg> Why two pass? For one pass, find the first high and see if there is larger or equal to
it. The calculate the water between two points. But if not find larger or equal to it then? More
than two pass? Need to loop in the first pass? This could be difficult since if the first high do
not have the larger or equal to it in the list then need to try the second high and so on.

No. This approach is to find the max in the list and have two traversals to the max. 

left ...              max ... right
sum towards to max -> *
                        <- sum towards to max

So one pass to find the max ine list and two pass to sum waters.
<two-pass-end> 

The solution in one pass (shown in the gist) avoids finding the maximum value by moving two pointers
from the opposite ends of the array towards each other. If the largest value found to the left of
the left pointer is smaller than the largest value found to the right of the right pointer, then
move the left pointer one index to the right. Otherwise move the right pointer one index to the
left. Repeat until the two pointers intersect. This is a wordy explanation, but the code is really
simple.

class Ideone
{
  public static void main (String[] args) throws java.lang.Exception
  {
    int[] myIntArray = {2, 5, 1, 2, 3, 4, 7, 7, 6};
    System.out.println(calculateVolume(myIntArray));
  }

  public static int calculateVolume(int[] land) {
    int leftMax = 0;
    int rightMax = 0;
    int left = 0;
    int right = land.length - 1;
    int volume = 0;

    while(left < right) {

      // update current max for left and right.
      if(land[left] > leftMax) {
        leftMax = land[left];
      }
      if(land[right] > rightMax) {
        rightMax = land[right];
      }

      // decide to which direction it start to sum. Should from the lesser. If equals, from right
      // but do not matter when start from left.
      if(leftMax >= rightMax) {
        volume += rightMax - land[right];
        right--;
      } else {
        volume += leftMax - land[left];
        left++;
      }
    }

    return volume;
  }

}


==============================================================================
*kt_dev_quiz_104* codility: frog jump

A small frog wants to get to the other side of the road. The frog is currently located at position X
and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed
distance, D.

Count the minimal number of jumps that the small frog must perform to reach its target.

Write a function:

int solution(int X, int Y, int D); 

that, given three integers X, Y and D, returns the minimal number of jumps from position X to a
position equal to or greater than Y.

For example, given:

  X = 10
  Y = 85
  D = 30

the function should return 3, because the frog will be positioned as follows:

  after the first jump, at position 10 + 30 = 40
  after the second jump, at position 10 + 30 + 30 = 70
  after the third jump, at position 10 + 30 + 30 + 30 = 100

Assume that:

X, Y and D are integers within the range [1..1,000,000,000];
X ≤ Y.

Complexity:

expected worst-case time complexity is O(1);
expected worst-case space complexity is O(1).


<first-attempt>
int frog( int x, int y, int d )
{
  long long sum = 0;
  int jump;

  for( jump=1; sum < y; jump++ )
  {
    sum = x + d*jump;
    std::cout << "-> " << sum << ":" << jump << std::endl;
  }

  std::cout << "-! " << sum << ":" << jump << std::endl;

  return jump;
}

int main()
{
  int ret = frog( 10, 85, 30 );

  std::cout << ret << std::endl;

  return 0;
}

Have wondered why frog() returns 4 not 3 in the dawn? Thought 4 is right. Later, saw it again on the
same day and didn't get why thought 4 is right. Thing is that increase happens after the body.

j=1 : 10 + 30 = 40
j=2 : 10 + 60 = 70
j=3 : 10 + 90 = 100


Code: 11:55:32 UTC, cpp, final, score: 33.00 

Detected time complexity: O(Y-X)
test	                     time	   result
example 
example test	            0.020 s.	OK
simple1 
simple test	               0.020 s.	OK
simple2	                  0.020 s.	OK
extreme_position 
no jump needed	            0.020 s.	WRONG ANSWER got 1 expected 0
small_extreme_jump 
one big jump	            0.020 s.	OK
many_jump1 
many jumps, D = 2	         0.980 s.	TIMEOUT ERROR running time: >0.98 sec., time limit: 0.10 sec.
many_jump2 
many jumps, D = 99	      1.020 s.	TIMEOUT ERROR running time: >1.02 sec., time limit: 0.10 sec.
many_jump3 
many jumps, D = 1283	      0.990 s.	TIMEOUT ERROR running time: >0.99 sec., time limit: 0.10 sec.
big_extreme_jump 
maximal number of jumps	   1.010 s.	TIMEOUT ERROR running time: >1.01 sec., time limit: 0.10 sec.
small_jumps 
many small jumps	         0.290 s.	TIMEOUT ERROR running time: >0.29 sec., time limit: 0.10 sec.


Have missed the condition which is O(1) and unit test cases. How to solve?

<second-attempt>
int frog( int X, int Y, int D )
{
  long long sum = 0;
  int jump = -1;

  if( X == Y )
  {
    jump = 0;
  }
  else if (X < Y)
  {
    int diff = Y-X;

    if( (diff / D)  == 0)
    {
      jump = 1;
    }
    else if( ((diff/D) > 0) && ((diff%D) == 0) )
    {
      jump = diff/D;
    }
    else if( ((diff/D) > 0) && ((diff%D) != 0) )
    {
      jump = (diff/D)+1;
    }
  }

  return jump;
}

score: 100 of 100. Detected time complexity:O(1)

X==Y : no jump
X<Y  : ----------------------
        X         Y   D         
        
   (Y-X)/D == 0. needs one jump.
   (Y-X)/D > 0. needs more jump.
      -----------------------
        X         Y
             D   D
      (Y-X)%D == 0. fall exactly on Y.
      (Y-X)%D != 0. +1 jump.

Lesson learned. Read the question carefully such as 'greater or equal', 'X <= Y', and O(1).


==============================================================================
*kt_dev_quiz_105*	codility: find missing element. PermMissingElem

A zero-indexed array A consisting of N different integers is given. The array contains integers in
the range [1..(N + 1)], which means that exactly one element is missing.

Your goal is to find that missing element.

Write a function:

    int solution(int A[], int N);

that, given a zero-indexed array A, returns the value of the missing element.

For example, given array A such that:

  A[0] = 2
  A[1] = 3
  A[2] = 1
  A[3] = 5

the function should return 4, as it is the missing element.

Assume that:

N is an integer within the range [0..100,000]; the elements of A are all distinct; each element of
array A is an integer within the range [1..(N + 1)].

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(1), beyond input storage (not counting the storage
    required for input arguments).

Elements of input arrays can be modified.

<first-attempt>
#include <iostream>
int solution(vector<int> &A) 
{
  // write your code in C++98
  if( !A.size() )
    return 0;

  long long isum = 0;

  for( unsigned int i = 0; i < A.size(); i++ )
    isum += A[i];

  long long csum = 0;

  for( unsigned int i = 1; i <= A.size()+1; i++ )
    csum += i;

  return csum - isum;
}

score: 90 of 100
Detected time complexity: O(N)

test 	time 	result
Example tests
example
example test 	0.020 s. 	OK

Correctness tests

empty_and_single
empty list and single element 	0.020 s. 	WRONG ANSWER got 0 expected 1
<Q> why is this?

missing_first_or_last the first or the last element is missing 	0.020 s. 	OK
single single element 	0.020 s. 	OK
double two elements 	0.020 s. 	OK
simple simple test 	0.020 s. 	OK

Performance tests
medium1        medium test, length = ~10,000 	0.020 s. 	OK
medium2        medium test, length = ~10,000 	0.020 s. 	OK
large_range    range sequence, length = ~100,000 	0.030 s. 	OK
large1         large test, length = ~100,000 	0.040 s. 	OK
large2         large test, length = ~100,000 	0.030 s. 	OK

<analysis>
This is about permutation. For example, {1,2,3,4,5} can have

{1,2,3,4} is missing 5
{2,3,4,5} is missing 1
{1,3,4,5} is missing 2

Reversely, 
if 3 inputs are given, then it's one of permutation of 4. 
if 2 inputs are given, then it's one of permutation of 3. 
if 1 inputs are given, then it's one of permutation of 2. 
if 0 inputs are given, then it's one of permutation of 1. 

<second-attempt>
#include <iostream>
int solution(vector<int> &A) 
{
  // write your code in C++98
  if( !A.size() )
    return 1;        <DN> return 1;

  long long isum = 0;

  for( unsigned int i = 0; i < A.size(); i++ )
    isum += A[i];

  long long csum = 0;

  for( unsigned int i = 1; i <= A.size()+1; i++ )  <DN> <=
    csum += i;

  return csum - isum;
}

score: 100 of 100


{same-but-different}

PermCheck

A non-empty zero-indexed array A consisting of N integers is given.

A permutation is a sequence containing each element from 1 to N once, and only once.

For example, array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
    A[3] = 2

is a permutation, but array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3

is not a permutation.

The goal is to check whether array A is a permutation.

Write a function:

    int solution(int A[], int N); 

that, given a zero-indexed array A, returns 1 if array A is a permutation and 0 if it is not.

For example, given array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3
    A[3] = 2

the function should return 1.

Given array A such that:

    A[0] = 4
    A[1] = 1
    A[2] = 3

the function should return 0.

Assume that:

N is an integer within the range [1..100,000]; each element of array A is an integer within the
range [1..1,000,000,000].

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage
required for input arguments).

Elements of input arrays can be modified.


==============================================================================
*kt_dev_quiz_106* codility: frog river

FrogRiverOne 

A small frog wants to get to the other side of a river. The frog is currently located at position 0,
and wants to get to position X. Leaves fall from a tree onto the surface of the river.

You are given a non-empty zero-indexed array A consisting of N integers representing the falling
leaves. A[K] represents the position where one leaf falls at time K, measured in minutes.

The goal is to find the earliest time when the frog can jump to the other side of the river. The
frog can cross only when leaves appear at every position across the river from 1 to X.

For example, you are given integer X = 5 and array A such that:

  A[0] = 1
  A[1] = 3
  A[2] = 1
  A[3] = 4
  A[4] = 2
  A[5] = 3
  A[6] = 5
  A[7] = 4

In minute 6, a leaf falls into position 5. This is the earliest time when leaves appear in every
position across the river.

Write a function:

    int solution(int X, int A[], int N); 

that, given a non-empty zero-indexed array A consisting of N integers and integer X, returns the
earliest time when the frog can jump to the other side of the river.

If the frog is never able to jump to the other side of the river, the function should return -1.

For example, given X = 5 and array A such that:

  A[0] = 1
  A[1] = 3
  A[2] = 1
  A[3] = 4
  A[4] = 2
  A[5] = 3
  A[6] = 5
  A[7] = 4

the function should return 6, as explained above. Assume that:

N and X are integers within the range [1..100,000];
each element of array A is an integer within the range [1..X].

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(X), beyond input storage (not counting the storage
required for input arguments).

Elements of input arrays can be modified.

{code-sample}
#include <iostream>
#include <vector>

int solution( int X, std::vector<int> &A )
{
  if( A.empty() || X==1 )
    return -1;

  bool *pbitset = new bool[X];
  unsigned int idx;
  unsigned int count=0;

  for(idx=0; idx < X; idx++)
    pbitset[idx] = false;

  for(idx=0; idx < A.size(); idx++)
  {
    if( pbitset[A[idx]-1] == false )
    {
      pbitset[A[idx]-1] = true;
      count++;

      std::cout << "idx: " << idx << ", pbitset[" << A[idx]-1 << "] = " << pbitset[A[idx]-1]
        << ", count: " << count << std::endl;

      if( count == X )
      {
        delete[] pbitset; return idx;
      }
    }
  }

  delete[] pbitset; return -1;
}

int main()
{
  std::vector<int> A2 = { 1,3,1,4,2,3,5,4 };
  std::cout << solution( 5, A2 ) << std::endl;

  std::vector<int> A3 = { 1,3,1,4,2,3,5,4 };
  std::cout << solution( 1, A3 ) << std::endl;

  std::vector<int> A4 = { };
  std::cout << solution( 5, A4 ) << std::endl;

  std::vector<int> A5 = { 1 };
  std::cout << solution( 5, A5 ) << std::endl;
}


{first-attempt}
#include <iostream>
#include <vector>

int solution( int X, std::vector<int> &A )
{
  if( A.empty() || X==1 )
    return -1;

  bool *pbitset = new bool(X);
 
  int idx;                        
  int count=0;

  // bitset{0, X-1}
  for(idx=0; idx < X; idx++)
    pbitset[idx] = false;

  for(idx=0; idx < A.size(); idx++)    <DN> signed and unsigned warning.
  {
    // wasn't set before?
    if( pbitset[A[idx]-1] == false )
    {
      // set it and increase count
      pbitset[A[idx]-1] = true;
      count++;

      // are all position set?
      if( count == X )                 <DN> signed and unsigned warning.
      {
        delete pbitset; return idx;
      }
    }
  }

  delete pbitset; return -1;
}

Failed on 25%:

simple simple test        0.020 s.     OK
single single element     0.020 s.     WRONG ANSWER got -1 expected 0
extreme_frog frog never across the river     0.020 s.     OK

small_random1 3 random permutation, X = 50     0.020 s.     RUNTIME ERROR
tested program terminated unexpectedly

stdout:

[MONITOR DEBUG] open("/dev/tty", 2306) denied
[MONITOR] syscall open was blocked!
*** glibc detected *** ./user.e: free(): invalid next size (fast): 0x09cc9008 ***
======= Backtrace: =========
/lib/libc.so.6(+0x6c12a)[0x401c512a]
/lib/libc.so.6(+0x6d988)[0x401c6988]
/lib/libc.so.6(cfree+0x6d)[0x401c9afd]
/usr/lib/libstdc++.so.6(_ZdlPv+0x1f)[0x4007554f]
./user.e[0x804905c]
/lib/libc.so.6(__libc_start_main+0xe6)[0x4016fbc6]
./user.e[0x8048971]
======= Memory map: ========
[MONITOR DEBUG] open("/proc/self/maps", 0x0000) - opening /proc/ files is disabled!
[MONITOR] syscall tgkill was blocked!
[MONITOR] syscall tgkill was blocked!

Two DNs:
o signed and unsigned that complier warns aying mismatch between signed and unsigned. No such error
when run with GCC 4.6.3.

o this is wrong since it allocate a single bool but not array. Failed on other many test cases with
the same error. {Q} Okay since allocation is wrong. But why no such error on GCC 4.6.3. This sites
uses C++98 so may be new initialize way in C++11?

{second-attempt}
#include <iostream>
#include <vector>

int solution( int X, std::vector<int> &A )
{
  if( A.empty() || X==1 )
    return -1;

  bool *pbitset = new bool(X);
 
  int idx;                        
  int count=0;

  for(idx=0; idx < X; idx++)
    pbitset[idx] = false;

  for(idx=0; idx < A.size(); idx++)
  {
    if( pbitset[A[idx]-1] == false )
    {
      pbitset[A[idx]-1] = true;
      count++;

      if( count == X )
      {
        delete[] pbitset; return idx;  <DN>
      }
    }
  }

  delete[] pbitset; return -1;
}

Still failed with the same error. Why? Now I see why.


{third-attempt}
#include <iostream>
#include <vector>

int solution( int X, std::vector<int> &A )
{
  if( A.empty() || X==1 )
    return -1;

  bool *pbitset = new bool[X];   <DN>
 
  int idx;                        
  int count=0;

  for(idx=0; idx < X; idx++)
    pbitset[idx] = false;

  for(idx=0; idx < A.size(); idx++)
  {
    if( pbitset[A[idx]-1] == false )
    {
      pbitset[A[idx]-1] = true;
      count++;

      if( count == X )
      {
        delete[] pbitset; return idx;
      }
    }
  }

  delete[] pbitset; return -1;
}

90 out of 100 points. Detected time complexity: O(N). Failed on:

single single element     0.020 s.     WRONG ANSWER got -1 expected 0

{Q} why?


{final-attempt}
#include <iostream>
#include <vector>

int solution( int X, std::vector<int> &A )
{
  if( A.empty() || X==0 )
    return -1;

  bool *pbitset = new bool[X];
 
  int idx;                        
  int count=0;

  // bitset{0, X-1}
  for(idx=0; idx < X; idx++)
    pbitset[idx] = false;

  for(idx=0; idx < A.size(); idx++)
  {
    // wasn't set before?
    if( (A[idx]-1 < X) && pbitset[A[idx]-1] == false )   <DN>
    {
      // set it and increase count
      pbitset[A[idx]-1] = true;
      count++;

      // are all position set?
      if( count == X )
      {
        delete pbitset; return idx;
      }
    }
  }

  delete pbitset; return -1;
}

int main()
{
  std::vector<int> A2 = { 1,3,1,4,2,3,5,4 };
  std::cout << solution( 5, A2 ) << std::endl;

  std::vector<int> A3 = { 2,3,4,5,1,3,5,4 };
  std::cout << solution( 1, A3 ) << std::endl;

  std::vector<int> A4 = { };
  std::cout << solution( 5, A4 ) << std::endl;

  std::vector<int> A5 = { 1 };
  std::cout << solution( 5, A5 ) << std::endl;

  std::vector<int> A6 = { 2 };
  std::cout << solution( 1, A6 ) << std::endl;

  std::vector<int> A7 = { 1 };
  std::cout << solution( 1, A7 ) << std::endl;

  return 0;
}

100 out of 100 points. Detected time complexity: O(N) 


{bitset-attempt}
#include <iostream>
#include <vector>
#include <bitset>

const size_t size = sizeof(unsigned long)*8;
typedef std::bitset<size> my_bitset;

int solution( int X, std::vector<int> &A )
{
  if( A.empty() || X==1 )
    return -1;

  my_bitset bitvec(X);
  bitvec.reset();

  int idx;
  int count=0;

  std::cout << "bitvec size: " << bitvec.size() << std::endl;

  for(idx=0; idx < A.size(); idx++)
  {
    if( bitvec[A[idx]-1] == false )
    {
      bitvec[A[idx]-1] = true;
      count++;

      std::cout << "idx: " << idx << ", bitvec[" << A[idx]-1 << "] = " << bitvec[A[idx]-1]
        << ", count: " << count << std::endl;

      if( count == X )
        return idx;
    }
  }

  return -1;
}

int main()
{
  std::vector<int> A2 = { 1,3,1,4,2,3,5,4 };
  std::cout << solution( 5, A2 ) << std::endl;

  std::vector<int> A3 = { 1,3,1,4,2,3,5,4 };
  std::cout << solution( 1, A3 ) << std::endl;

  std::vector<int> A4 = { };
  std::cout << solution( 5, A4 ) << std::endl;

  std::vector<int> A5 = { 1 };
  std::cout << solution( 5, A4 ) << std::endl;
}


={{===========================================================================
*kt_dev_quiz_107* codility: max counters

After train lession 02:

You are given N counters, initially set to 0, and you have two possible operations on them:

increase(X) − counter X is increased by 1,
max_counter − all counters are set to the maximum value of any counter.

A non-empty zero-indexed array A of M integers is given. This array represents consecutive
operations:

if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X),
if A[K] = N + 1 then operation K is max_counter.

For example, given integer N = 5 and array A such that:

    A[0] = 3
    A[1] = 4
    A[2] = 4
    A[3] = 6
    A[4] = 1
    A[5] = 4
    A[6] = 4

the values of the counters after each consecutive operation will be:

    (0, 0, 1, 0, 0)
    (0, 0, 1, 1, 0)
    (0, 0, 1, 2, 0)
    (2, 2, 2, 2, 2)
    (3, 2, 2, 2, 2)
    (3, 2, 2, 3, 2)
    (3, 2, 2, 4, 2)

The goal is to calculate the value of every counter after all operations.

Assume that the following declarations are given:

    struct Results {
      int * C;
      int L;
    }; 

Write a function:

struct Results solution(int N, int A[], int M); 

that, given an integer N and a non-empty zero-indexed array A consisting of M integers, returns a
sequence of integers representing the values of the counters.

The sequence should be returned as:

a structure Results (in C), or
a vector of integers (in C++), or
a record Results (in Pascal), or
an array of integers (in any other programming language).

For example, given:

    A[0] = 3
    A[1] = 4
    A[2] = 4
    A[3] = 6
    A[4] = 1
    A[5] = 4
    A[6] = 4

the function should return [3, 2, 2, 4, 2], as explained above.

Assume that:

N and M are integers within the range [1..100,000];
each element of array A is an integer within the range [1..N + 1].

Complexity:

expected worst-case time complexity is O(N+M);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage
required for input arguments).

Elements of input arrays can be modified.


={{===========================================================================
*kt_dev_quiz_200* codility: train: lesson 01: time complexity

Time complexity

Use of time complexity makes it easy to estimate the running time of a program. Performing an
accurate calculation of a program’s operation time is a very labour-intensive process (it depends on
the compiler and the type of computer or speed of the processor). Therefore, we will not make an
accurate measurement; just a measurement of a certain order of magnitude. Complexity can be viewed
as the maximum number of regular operations that a program may execute. Regular operations are
single additions, multiplications, assignments etc. We may leave some operations uncounted and
concentrate on those that are performed the largest number of times. Such operations are referred to
as <dominant>. The number of dominant operations is considered on the basis of the specific input
data. We usually want to know how the performance time depends on a specific <aspect> of the data.
This is most frequently the data size, but it can also be the size of a square matrix or the value
of some input variable.

1.1 : Which is the dominant operation?
1 def dominant(N):
2  result = 0
3  for i in xrange(N):
4     result += 1
5  return result

The operation in line 4 is dominant and will be executed N times. The complexity is recorded in
Big-O notation: in this case O(N) - linear complexity. 

The complexity specifies <the order of magnitude> within which the program will perform its
operations. More precisely, in the case of O(N), the program may perform c · N operations, where c
is a constant; however, it may not perform N^2 operations, for example, since this involves a
different order of magnitude of data. In other words, when calculating the complexity we omit
constants: i.e. regardless of whether the loop is executed 20 · N times or N/5 times, we still have
a complexity of O(N), even though the running time of the program may vary. When analyzing the
complexity we must look for specific, malicious examples of data that the program will take a long
time to process.

1.1. Comparison of different time complexities

Let’s compare some basic time complexities.

1.2 : Constant time - O(1).
1 def constant(N):
2  result = N * N
3  return result

There is always a fixed number of operations.


1.3 : Logarithmic time - O(log N).
1 def logarithmic(N):
2  result = 0
3  while (N > 1):
4     N = N // 2
5     result += 1
6  return result

The value of N is halved on each iteration of the loop. If N = 2^X then log N = X. How long would
the program below take to execute, depending on the input data?


1.4 : Linear time - O(N).
1 def linear(N, A):
2  for i in xrange(N):
3     if A[i] == 0:
4        return 0
5  return 1

Let’s note that if the first value of array A is 0 then the program will end immediately. But
remember, when analyzing time complexity we should check for malicious cases. The program will take
the longest time to execute if array A does not contain any 0.


1.5 : Quadratic time - O(N^2).
1 def quadratic(N):
2  result = 0
3  for i in xrange(N):
4     for j in xrange(i, N):
5        result += 1
6  return result

The result of the function equals 1/2 · ( N · ( N + 1)) (the explanation is in the exercises). When
we omit the constants we get quadratic time complexity. Sometimes the complexity depends on more
variables (see example below).

1.6 : Linear time - O(N + M).
1 def linear2(N, M):
2  result = 0
3  for i in xrange(N):
4     result += i
5  for j in xrange(M):
6     result += j
7  return result

Exponential and factorial time

It is worth knowing that there are other types of time complexity such as factorial time O(N!) and
exponential time O(2^N). Algorithms with such complexities can solve problems only for very small
values of N, because they would take too long to execute for large values of N.

1.2. Time limit

Nowadays, an average computer can perform 10^8 operations in less than a second. Sometimes we have
the information we need about the expected time complexity, but sometimes we do not (for example,
Codility specifies the expected time complexity). The time limit set for online tests is
usually 1 - 10 seconds. We can therefore estimate the expected complexity. During contests, we are
often given a limit on the size of data, and therefore we can guess the time complexity within which
the task should be solved. This is usually a great convenience because we can look for a solution
that works in a specific complexity instead of worrying about a faster solution. For example, if:

• N <= 1 000 000, the expected time complexity is O(N) or O(N log N),
• N <= 10 000, the expected time complexity is O(N^2),
• N <= 500, the expected time complexity is O(N^3).

Of course, these limits are not precise. They are just approximations, and will vary depending
on the specific task.


1.3. Space complexity

Memory limits provide information about the expected space complexity. You can estimate the number
of variables that you can declare in your programs. In short, if you have constant numbers of
variables, you also have constant space complexity: in Big-O notation this is O(1). If you need to
declare array with N elements, you have linear space complexity - O(N). 

More specifically, space complexity is the amount of memory needed to perform the computation. It
includes all the variables, both global and local, dynamic pointer data-structures and, in the case
of recursion, the contents of the stack. Depending on the convention, input data may also be
included. It is more tricky to calculate than the time complexity because not all of these variables
and data-structures may be needed at the same time. Global variables exist and occupy memory all the
time; local variables (and additional information kept on the stack) will exist only during
invocation of the procedure. The existence of the dynamic pointer data-structures is explicitly
controlled by the program.


1.4. Exercise

Problem: You are given an integer N. Count the total of 1 + 2 + ...  + N.
Solution: The task can be solved in several ways. A first person, who knows nothing about time
complexity, may implement an algorithm in which the result is incremented by 1:

1.7 : Solution A - time complexity O(n^2).
1 def solution_A(N):
2  result = 0
3  for i in xrange(N):              <KT> for(i < N)
4     for j in xrange(i + 1):
5        result += 1
6  return result

A second person may increment the result respectively by 1, 2,..., N. This algorithm is much faster:

1.8 : Solution B - time complexity O(n).
1 def solution_B(N):
2  result = 0
3  for i in xrange(N):
4     result += (i + 1)
5  return result

But the third person’s solution is even quicker. Let us write the sequence 1, 2,..., N and repeat
the same sequence underneath it, but in reverse order. Then just add the numbers from the same
columns:

1     2     3     ...      N-1   N
N     N-1   N-2   ...      2     1
N+1   N+1   N+1   ...      N+1   N+1

The result in each column is N + 1, so we can easily count the final result:

1.9 : Solution C - time complexity O(1).
1 def solution_C(N):
2  result = N * (N + 1) // 2
3  return result


={{===========================================================================
*kt_dev_quiz_201*	codility: train: lesson 02: counting elements

Chapter 2

Counting elements

A numerical sequence can be stored in an array in various ways. In the standard approach, the
consecutive numbers a0, a1 ,...,an-1 are usually put into the corresponding consecutive indexes of
the array:

A[0] = a0 A[1] = a1 ... A[n-1] = an-1

We can also store the data in a slightly different way, by making an array of counters. Each number
may be counted in the array by using an index that corresponds to the value of the given number.

a0 a1 a2 a3 a4 a5 
0  0  4  2  4  5

count [] 2 0 1 0 2 1
index    0 1 2 3 4 5    // values

Notice that we do not place elements directly into a cell; rather, we simply count their
occurrences. It is important that the array in which we count elements is sufficiently large. If we
know that all the elements are in the set {0, 1,..., x}, then the array used for counting should be
of size x + 1.

The limitation here may be available memory. Usually, we are not able to create arrays of 10^9
integers, because this would require more than one gigabyte of available memory. Counting the
number of negative integers can be done in two ways. The first method is to add some big number to
each value: so that, all values would be greater than or equal to zero. That is, we shift the
representation of zero by some arbitrary amount to accommodate all the negative numbers we need. In
the second method, we simply create a second array for counting negative numbers.

2.1. Exercises

Problem: You are given an integer m such that ( 1 <= m <= 1 000 000) and a non-empty, zero-
indexed array A of <n> integers: a0, a1,..., an-1 such that ( 0 <= ai <= m). Count the number of
occurrences of the values 0, 1,..., m.

Solution: The simple way is to iterate through the whole array, searching for each value 0, 1 ,...,
m separately, but that produces a time complexity of O(nm). The better approach is to count the
elements in the array.

2.1 : Counting elements.
1 def counting(A, m):
2  n = len(A)
3  count = [0] * (m + 1)
4  for k in xrange(n):
5     count[A[k]] += 1
6  return count

With this approach, the time complexity is O(n + m).


={{===========================================================================
*kt_dev_quiz_300*	problems: repairman

{desc}
On every morning, a repairman is assigned the jobs for the day. The particular repairman we are
interested in has taken charge of jobs located on a straight road. For convenience, assume that the
N jobs are given at locations xi (i=1,...,N) on a straight line. He should start at one of these
locations and he must visit all the locations to complete the jobs. 

For a client requesting a job located at [xi], the time when he waits for a repairman is assumed to
be proportional to the distance [di] in which the repairman travels to arrive at xi from the
starting location. So, to reduce the waiting times of clients, the repairman should minimize the sum
of distances di. 

Our problem is slightly more complicated because there is a weight [wi] for the job at location xi
which represents the importance of the client. Thus the repairman should minimize the weighted sum
of distances wi di. 

More precisely, given locations (or coordinates) xi and weights wi of points on a line, the
repairman starts at one of these points, say s, and visits all the points at least once. Let di be
the distance in which the repairman travels to visit a point of location xi for the first time. We
may find the moving route of the repairman that minimizes 

SUMiWiDi (math summation where i means input)

{problem}
The minimum value is denoted by T(s) for a specific starting point. Consequently, we can compute
T(s) for each starting location s. The problem is to find a starting location [s] such that T(s) is
minimized over all the locations and to print the minimum value. 

For example, given points on a line, as in Figure 1, if the repairman starts at location 6, then the
red arrows represent a route to minimize the total weighted distance and the minimum value is 180.


Wi:     1       2       10 3  5          1 
 -------*-------*-------*--*--*----------*--------
Xi:     1       6       12 13 14         24
                ------------------------->
        <---------------------------------

180 = 2*0 + 10*6 + 3*(6+1) + 5*(6+1+1) + 1*(6+1+1+10) + 1*(6+1+1+10+23)

 [KT] Not sure why this should add all points every time such as 6+1+1.

But if the repairman starts at location 12 as in Figure 2, then a route minimizing the total
weighted distance is represented by the red arrows below and the minimum value is 86. Also this is
the minimum of T(s) over all the locations s. 

Wi:     1       2       10 3  5          1 
 -------*-------*-------*--*--*----------*--------
Xi:     1       6       12 13 14         24
                        ------> 
        <----------------------
        --------------------------------->


Time Limit: 1 second for 20 cases. If your program exceeds this time limit, the answers that have
been already printed are ignored and the score becomes 0.

So, it may be better to print a wrong answer when a specific test case might cause your program to
exceed the time limit. One guide for the time limit excess would be the size of the input.

[Input]
There can be more than one test case in the input file. The first line has C, the # of test cases.
Then the totally C test cases are provided in the following lines (1≤C≤20). In each test case, the
first line contains one integer N representing the number of points on a line (2≤N≤1,000). In the
second line, the N integers xi representing the locations of the points are given (1≤x_i≤1,000,000).
These integers are distinct and given in increasing order. In the third line, the N integers wi
representing the weights of the points are given (1≤wi≤1,000).

[Output]
The output for each test case should contain two lines. For the T-th test case, "Case #T" should be
printed out in the first line. The second line should contain the integer, representing the minimum
value for the starting location s to minimize T(s). This integer may be so large that it cannot be
stored in 4-byte integer variables. So you can use 64-bit integer (long long type) variables. 

[I/O Example]
Input
2                             // There are 2 test cases
6                             // Starting Case 1
1 6 12 13 14 24               // xi
1 2 10 3 5 1                  // wi
15                            // Starting Case 2
5 34 45 49 51 52 53 56 63 81 84 88 93 99 106
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

Output
Case #1
86
Case #2
630


{winner-code} 
This file should be .cpp to build and run since it mixes C and CPP.

#include <stdio.h>
#include <map>
#include <vector>
#include <set>

using namespace std;

typedef long long lint;

int T, N;

int xi[1000];
int wi[1000];

#define abs(a) (((a) > 0)?(a):-(a))
#define min(a,b) (((a) < (b))?(a):(b))

// {Q} does the order matter? for example, abs(s-e) or abs(e-s)
#define TIME(s,e) (abs(xi[e] - xi[s]))

lint sum(int s, int e, lint time = 0);
lint sum(int s1, int s2, int s3, lint time = 0);

lint sum(int s, int e, lint time)
{
  if(s == e)
  {
    return 0;
  }
  int dx = ((e > s)? 1:-1);
  lint res = 0;

  // [1] 
  // here time is sum of absolute distance of between points and res is the sum of weighted
  // distance.
  //
  // for s < e case
  // s == 0  : i == 1,   dx == 1
  //         TIME(1,0), abs(0-1) res = time*wi[1];
  //
  // for s > e case
  // s == N-1: i == N-2, dx == -1 
  //           TIME(N-2, N-1), res = time*wi[N-2]
  //
  // this is a code to implement the summation above but it is cool to use one single function for
  // both direction. This dx variable is direction.
  //
  // ->  s     e: abs(e-s), abs(1-0), abs(1-0)*w[1]
  //
  //     0th   1th    2th    n-1 : N array
  // ----*-----*------*------*---
  //
  //               <-  e     s: abs(e-s), abs((n-2)-(n-1)), abs((n-2)-(n-1))*w[n-2]
  //
  // [2] no exit condition in for loop
  //
  for(int i = s + dx; ; i+=dx)
  {
    time += TIME(i, i - dx);
    res += time*(lint)wi[i];
    if( i == e )
    {
      return res;
    }
  }

  return res;
}

lint sum(int s1, int s2, int s3, lint time)
{
	// (s2 - s1)*(s3 - s1) < 0
	lint d1 = sum(s1, s2, time);
	//lint d2 = sum(s2, s3);
	lint d3 = sum (s1, s3, time + 2*TIME(s2, s1));

	return d1 + d3;
}

pair<lint, lint> search(int s, int e)
{
  lint dMin = sum(s, e);
  int ind = s;

  if(s == e)
  {
    return make_pair(0, 0);
  }
  int dx = ((e > s)? 1:-1);

  lint sumT = 0;
  lint time = 0;

  for(int i = s + dx; i != e; i += dx)
  {
    lint res = sum(i, s, e);

    if(res < dMin || res == dMin && abs(i - s) > abs(ind - s))
    {
      dMin = res;
      ind = i;
    }
  }

  if(ind != s)
  {
    pair<lint, lint> res = search(ind, s);	
    sumT += res.first;
    time += res.second + TIME(ind, s);		

    //printf("%d->%d->%d\n", ind, s, e);
  }

  sumT += sum(ind, e, time);
  time += TIME(ind, e);

  return make_pair(sumT, time);
}

int main()
{
  scanf("%d", &T);

  for(int t = 0; t < T; ++ t)
  {
    scanf("%d", &N);

    for(int n = 0; n < N; ++ n)
    {
      scanf("%d", xi + n); 
    }

    for(int n = 0; n < N; ++ n)
    {
      scanf("%d", wi + n); 
    }

    pair<lint, lint> res1 = search(0, N - 1);
    pair<lint, lint> res2 = search(N - 1, 0);

    printf("Case #%d\n", t + 1);
    printf("%lli\n", min(res1.first, res2.first));
  }
}

# ============================================================================
#{ ALGORITHM
==============================================================================
*kt_dev_algo_000*	sentinel

{hedge-or-sentinel}

From {ref-001}. A hedge or sentinel is an extra entry put into a data structure so that boundary
conditions need not be treated as a [special-case]. For example of this life game, need to check if
it is in the array when counting neighbours. Can avoid complicated checks by having extra lows and
columns:

arr[MAXROW+2][MAXCOL+2];

0 1 2 3 .... MAX MAX+1
1 X
2
3
.
.
MAX
MAX+1

Where all operation performs in range of [1, MAX] dimension and no need to boundary check when doing
for X.


==============================================================================
*kt_dev_algo_001*	stack

A stack is a version of a list that is particularly useful in applications involving reversing. This
is contiguous stack implementation with handling errors. See {stack-stl} for STL example.


{stack-contiguous-implementation}
This uses contiguous and is [traversable] stack. [KT] push and pop (insertion and deletion) happens
at the the end of storage and use index. no overhead of moving elements.

<do> write a contiguous stack implementation which have following interfaces.

void CreatStack( Stack* stack );
bool StackFull( Stack* stack );
bool StackEmpty( Stack* stack );
bool StackPush( Stack* stack, EntryType entry );
void StackPop( Stack* stack );
EntryType StackTop( Stack* stack );
void StackTraverse( Stack* stack, void(*func)(EntryType));

<code-own>
Used stack-stl interface which means top() returns an element and pop() removes an element without
getting it from a stack. Some points are: use top var which is size or count of a stack and top
index as well. Use top in pop and top funcs. 

#include < iostream>

#define MAXENTRY 10

typedef int EntryType;

typedef struct {
	int top;		// count
	EntryType entry[MAXENTRY];
} Stack;

void CreatStack( Stack* stack )
{
	stack->top = 0;
	for( int i=0; i < MAXENTRY; i++ )
		stack->entry[i] = (EntryType)0;
}	

bool StackFull( Stack* stack )
{
	return ( stack->top >= MAXENTRY );
}

bool StackEmpty( Stack* stack )
{
	return ( stack->top <= 0 );
}

bool StackPush( Stack* stack, EntryType entry )
{
	if( StackFull(stack) )
	{
		std::cout << "stack is full" << std::endl;
		return false;
	}

	stack->entry[ stack->top++ ] = entry;
	return true;
}

void StackPop( Stack* stack )
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}

	stack->top--;
}

EntryType StackTop( Stack* stack )
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return (EntryType)0;
	}

	return stack->entry[stack->top-1];
}

typedef void(*TRAVERSEFUNC)(EntryType);	


void StackTraverse( Stack* stack, TRAVERSEFUNC func)
//void StackTraverse( Stack* stack, void(*func)(EntryType))
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}
	
	for(int i=0; i < stack->top; i++)
	{
		func(stack->entry[i]);
	}
}

void EntryPrint(EntryType item)
{
	std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	Stack stack;
	CreatStack(&stack);
	std::cout << "type in 10 integer numbers." << std::endl;

	for(int i=0; i < MAXENTRY; i++)
	{
		std::cin >> item;
		StackPush(&stack, item );
	}		

	std::cout << "top is " << StackTop(&stack) << std::endl;
	std::cout << "top is " << StackTop(&stack) << std::endl;
	
	StackPop(&stack);
	StackPop(&stack);

	StackTraverse(&stack, EntryPrint);
}


<code-from-ref-001>
typedef char StackEntry;

typedef struct stack {
	 int top;
	 StackEntry entry[MAXSTACK];
} Stack;

void CreateStack( Stack* s );
{ s->top = 0; }

Boolean StackEmpty( Stack* s );
{ return s->top <= 0; }

Boolean StackFull( Stack* s );
{ return s->top >= MAXSTACK; }

void Push( StackEntry item, Stack* s );
{
   if( StackFull(s) )
      Error("stack is full");
   else
      s->entry[s->top++] = item;
}

void Pop( StackEntry *item, Stack* s );
{
   if( StackEmpty(s) )
      Error("stack is empty");
   else
      *item = s->entry[--s->top];
}

// returned the top item without being removed. the stack remains unchanged.
void Top( StackEntry *item, Stack* s );   
void TraverseStack( Stack*s, void(*Visit)());

<code-from-class-example>
typedef char Stack_entry;

Error_code Stack::push( const Stack_entry& item )
{
	 Error_code outcome = success;

	 if( count >= maxstack )
		  outcome = overflow;
	 else
		  entry[count+1] = item;

	 return outcome;
}

Stack::Stack();
Error_code Stack::pop()
{
	 Error_code outcome = success;

	 if( count == 0 )
		  outcome = underflow;
	 else --count; // note: 

	 return outcome;
}

Error_code Stack::top( Stack_entry& item ) const
{
	 Error_code outcome = success;

	 if( count == 0 )
		  outcome = underflow;
	 else
		  item = entry[count-1];

	 return outcome;
}

bool Stack::empty() const;


{stack-linked-implementation}
Implement stack as linked structure. To pop, better to make all addition and deletion at the
beginning of the structure. Why? Since this is one-way list, if to use the end to add, poping and
pusing requires tracing all the way from its head. This has a [header] variable that points to its
first node.

<do> write a linked list stack implementation which do addition and deletion [at-the-beginning] and
has following interfaces.

typedef struct node {
	...
} Node;

typedef struct stack {
	...
} Stack;

Node* MakeNode( StackEntry item );

<code-example>
#include < iostream>
#include < cstdlib>

typedef int EntryType;

typedef struct node
{
  EntryType 	entry;
  node*			pnext;
} Node;

typedef struct {
  Node*	top;	// header
} Stack;

Node* MakeNode( EntryType entry )
{
  Node* pnode = NULL;

  if( (pnode = (Node*) malloc( sizeof(Node))) == NULL )
  {
    std::cout << "no more memory" << std::endl;
    return NULL;
  }

  pnode->entry = entry;
  pnode->pnext = NULL;

  return pnode;
}

void CreatStack( Stack* stack )
{ stack->top = NULL; }	

bool StackEmpty( Stack* stack )
{ return ( stack->top == NULL ); }

bool StackPush( Stack* stack, EntryType entry )
{
  Node* pnode;

  if( (pnode = MakeNode(entry)) == NULL )
  {
    std::cout << "mem is full" << std::endl;
    return false;
  }

  pnode->entry = entry;
  pnode->pnext = stack->top;

  stack->top = pnode;

  return true;
}

void StackPop( Stack* stack )
{
  Node* pnode = NULL;

  if( StackEmpty(stack) )
  {
    std::cout << "stack is empty" << std::endl;
    return;
  }

  pnode = stack->top->pnext;
  free(stack->top);

  // removed since covered already when stack top is null and that is stack is empty.
  // if(stack->top)
  //   free(stack->top);
  // else
  // {
  //   std::cout << "stack->top is null" << std::endl;
  //   return;
  // }

  stack->top = pnode;
}

EntryType StackTop( Stack* stack )
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return (EntryType)0;
	}

	return stack->top->entry;
}

typedef void(*TRAVERSEFUNC)(EntryType);	

void StackTraverse( Stack* stack, TRAVERSEFUNC func)
{
	Node* pnode;

	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}
	
	pnode = stack->top;

	while(pnode)
	{
		func(pnode->entry);
		pnode = pnode->pnext;
	}
}

void EntryPrint(EntryType item)
{
	std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	Stack stack;
	CreatStack(&stack);

	std::cout << "type in 5 numbers." << std::endl;

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		StackPush(&stack, item );
	}		

	std::cout << "top is " << StackTop(&stack) << std::endl;
	std::cout << "top is " << StackTop(&stack) << std::endl;
	
//	StackPop(&stack);
//	StackPop(&stack);

	StackTraverse(&stack, EntryPrint);

	for(int i=0; i < 5; i++)
		StackPop(&stack);

	if( StackEmpty(&stack) )
		std::cout << "main: stack is empty" << std::endl;
	else
		std::cout << "main: stack is not empty" << std::endl;
}


{case-app-one} {reverse-polish-calculator}
We shall write '?' to denote an instruction to read an operand from a user and push it onto the
stack; + , -, * , and / represent arithmetic operations which pops data; and = is an instruction to
print the top of the stack (but not pop it off). Further, we write a, b, c, and d to denote
numerical values such as 3.14 or -7. 

? a ? b + = 

mean read and store the numbers a and b, calculate and store their sum, and then print the sum. 

? a ? b + ? c ? d + * = 

request four numerical operands, and the result printed is the value of (a + b) * (c + d).

? a ? b ? c - = * ? d + = 

mean push the numbers a, b, c onto the stack, replace the pair b, c by b - c and print its value,
calculate a * (b - c), push d onto the stack, and finally calculate and print (a * (b - c)) + d. 

The advantage of a reverse Polish calculator is that any expression, no matter how complicated, can
be specified without the use of parentheses.

<code-example>

#include < iostream>
#include < cctype> // for tolower

typedef double Stack_entry;

const int maxstack=10;
enum class Error_code { success, overflow, underflow };

class Stack {
  public:
    Stack();
    bool empty() const;
    Error_code pop();
    Error_code top(Stack_entry &item) const;
    Error_code push(const Stack_entry &item);

  private:
    int count;
    Stack_entry entry[maxstack];
};


Stack::Stack(): count(0)
{
}

bool Stack::empty() const
{
  bool outcome = true;
  if( count > 0 ) outcome = false;
  return outcome;
  // return count == 0 ? true : false;
}

Error_code Stack::pop()
{
  Error_code outcome = Error_code::success;
  if( count == 0 )
    outcome = Error_code::underflow;
  else count--;

  return outcome;
}

Error_code Stack::top(Stack_entry &item) const
{
  Error_code outcome = Error_code::success;

  if( count == 0 )
    outcome = Error_code::underflow;
  else
    //item = entry[count--];
    item = entry[count-1];

  return outcome;
}

Error_code Stack::push(const Stack_entry &item)
{
  Error_code outcome = Error_code::success;
  if( count >= maxstack )
    outcome = Error_code::overflow;
  else
    entry[count++] = item;

  return outcome;
}

char get_command()
{
  char command;
  bool waiting = true;
  std::cout << "select command and press <enter>: ";

  while( waiting )
  {
    std::cin >> command;
    command = tolower(command);

    if( command == '?' || command == '=' || command == '+' ||
        command == '-' || command == '*' || command == '/' ||
        command == 'q' )
      waiting = false;
    else
    {
      std::cout << "please enter a valid command: " << std::endl
        << "[?] push to stack, [=] print top " << std::endl
        << "[+] [-] [*] [/] are arith ops " << std::endl
        << "[Q] quit. " << std::endl;
    }
  }
  return command;
}

bool do_command( char command, Stack& numbers)
{
  double p, q;

  switch(command) {

    case '?':
      std::cout << "enter a real number: " << std::flush;
      std::cin >> p; // [note] read numbers
      if( numbers.push(p) == Error_code::overflow )
        std::cout << "stack full." << std::endl;

      break;

    case '=':      // [note] there is no pop
      if( numbers.top(p) == Error_code::underflow )
        std::cout << "stack empty." << std::endl;
      else
        std::cout << p << std::endl;

      break;

    case '+':      // [note] same for other ops
      if( numbers.top(p) == Error_code::underflow )
        std::cout << "stack empty." << std::endl;
      else
      {
        numbers.pop();
        if( numbers.top(q) == Error_code::underflow )
        {
          std::cout << "stack has just one entry." << std::endl;
          numbers.push(q);
        }
        else
        {
          numbers.pop();
          if( numbers.push( p+q ) == Error_code::overflow )
            std::cout << "stack full." << std::endl;
        }
      }
      break;

    case 'q':
      std::cout << "calc finished.\n";
      return false;
  }

  return true;
}


int main()
{
  Stack stored_numbers;

  while( do_command(get_command(), stored_numbers ));
}

This works fine but can be re-written using cpp strings.
				

{case-app-two} {bracket-matching}
{a = (1 + v(b[3 + c[4]]))     // no matching 
{ a = (b[0) + 1]; }           // the number of brackets matches but no matching
{( )[( )]}                    // matches but not leagal

How stack can be used here?

Whenever see any closing bracket ), ], or }, it must correspond to the last unmatched opening
bracket, which should be in stack and now be retrieved and removed from storage. Finally, at the end
of the program, we must check that no unmatched opening brackets are left over.

int main()
{
  Stack openings;
  char current;
  bool is_matched=true;

  while( is_matched && ( current = std::cin.get()) != '\n' )   // <std-cin-get>
  {
    if( current == '{' || current == '(' || current == '[' )
      openings.push(current);

    if( current == '}' || current == ')' || current == ']' )
    {
      if( openings.empty() )
      {
        std::cout << "unmatched closing bracket " << current << " detected" << std::endl;
        is_matched = false;
      }
      else
      {
        char match;
        openings.top(match);
        openings.pop();

        is_matched = ( current == '}' && match == '{' )
          || ( current == ')' && match == '(' )
          || ( current == ']' && match == '[' );

        if(!is_matched)
          std::cout << "bad match " << match << current << std::endl;
      }
    }
  } // while end

  // there should be no itmes in a stack if it is a match.
  if(!openings.empty())
    std::cout << "unmatched opening bracket(s) detected" << std::endl; 
}

<nested-parentheses>
http://ilovefoobar.wordpress.com/tag/codility/
Nested Parentheses where you will write a code to find if parentheses are properly nested on not.
If your have brackets like this ” ( ) ” or ” ( ( ) ) ( ) ” then it means that it is properly nested
but if you have bracket like this ” ( ( ) ” or ” ) ) ) ( ( ( ” then it means that its not properly
nested. And I was supposed to handle String of length 200,000 characters.

1. Remove all spaces from String.

2. Count the length of String, and find out if its odd or even number. If string is odd number then
it is not properly nested.  
<KT> 1 and 2 are input check which is good. But don't need these in the c approach.

3. If String is even number then run a loop and remove all matching ” () ” character from the
string.  

4. Now check the length of String, if length is zero then String is properly nested else its not.
<KT> This is the same check as size of stack in the c approach.

class Solution
{
  public int nesting ( String S )
  {
    int result = 1;

    if(S.contains(" "))
    {
        S = S.replaceAll(" ","");
    }

    while(S.contains("()"))
    {
        S = S.replaceAll("\\(\\)", "");
    }

    if(S.length() != 0)
    {
        result = 0;
    }

    return result;
  }
}


==============================================================================
*kt_dev_algo_002*	simple list

{abstract-data-type} {ADT}
Drawing a spearation between the logical structure of our data and its implementation will help us
in designing probgrams. If there is no speration, for example, can implement reverse polish
calculator by replacing stack code with manipulating array and count directly. Problem?

o How to change it to list implementation from array?
o Use unnecessary effort verifying the details of codes rather than being able to concentrate on
logic to solve problem, that is, the ways in which the stack is being used. This is programmer's
failure to recognize the general concept of stack and to distinguish between this and
implementation.

 [KT] can use this reverse polish calculator to see if someone can use data type such as stack to
 solve these case problems.

<encapsulation> 
In general, data is said to be [encapsulated] if it can only be accessed by a controlled set of
functions. Without encapsulation, the operation on a data structure almost always depend on a
[precondition] of data members.

The mathematical definition of type is:
A type is a set, and the elements of the set are called the values of the type. 

ADT has two parts: First is a description of the way in which the components are related to each
other, and second is a statement of the operation. ADT is logical data structure such as list or
stack and physical implementation can vary as there are many different implementation of stack.

<simple-list-adt-definition>
A simple list of elements of type T is a finite sequence of elements of T together with the
operations.

1. create the list, leaving it empty.
2. determine whether the list is empty or not.
3. determine whether the list is full or not.
4. find the size of the list.
5. add a new entry at the end of the list, provided the list is not full.
6. traverse the list, performing a given operation with each entry.
7. clear the list to make it empty.

<stages-of-refinement>
<- concept and algorithm ------->
math      ADT              data           implementation                application
concept                    structure 

sequence  general list
          stack            ...
          queue            physical                                     line of people

                           linear         array

                           circular       array with counter            airport simulation
                                          array with flag
                                          array with skipped entry

                           linked         simple with two pointers
                                          circular with tail pointers
                                          array with two cursors


{list-data-structure}
A list is dynamic-data-structure because its size can change, while an array is a
static-data-structure because it has a fixed size.

{list-contiguous-implementation}
<do> write a contiguous list implementation which have following interfaces.

void CreateList(List*);
void ClearList(List*);
bool ListEmpty(const List*);
bool ListFull(const List*);
int ListSize(const List*);
vold AddList(ListEntry x, List* list)
void TraverseList(List* list, void(*visit)(ListEntry));

<code-example>
The ListEntry can be anything. typedef T ListEntry;

typedef struct cell {
	int row, col;
} Cell;

typedef Cell 	ListEntry;
typedef int 	ListEntry;

typedef struct list {
	int         count;
	ListEntry   entry[MAXLIST];
} List;

// add an entry [at-the-end]
//
vold AddList(ListEntry x, List* list)
{
	if(ListFull(list))
		Warning("attempt to insert at the end of a full list.");
	else
		list->entry[list->count++] = x;
}

// run function on every entry in a list
//
void TraverseList(List* list, void(*visit)(ListEntry));
{ 
	for( int i = 0; i < list->count; i++)
		(*visit)(list->entry[i]);
}

Here, there is no function to remove and if remove an entry at random position, it is expensive as
have to move elements. This is the same as contiguous stack.


{list-linked-implementation}
A problem that never arises with contiguous. How do we find the beginning of the list? [header] is a
pointer variable that locates the beginning of the list. See {stack-linked-implementation} in
comparison.

typedef struct node {
	ListEntry   entry;
	struct node *next;
} Node;

typedef struct list {
	 int     count;   // there is no need to keep an counter but for size function.
	 Node*   header;  // header
} List;

Can implement to add a node either in the beginning or in the end. If it has remove function, then
less expansive than contiguous-implementation but need to search through from the header. To find
the end, traverse until next is null.

<code-example>
#include < iostream>
#include < cstdlib>

typedef int EntryType;

typedef struct node
{
  EntryType 	entry;
  node*			pnext;
} Node;

typedef struct {
  int   count;
  Node*	header;
} List;

Node* MakeNode( EntryType entry )
{
  Node* pnode = NULL;

  if( (pnode = (Node*) malloc( sizeof(Node))) == NULL )
  {
    std::cout << "no more memory" << std::endl;
    return NULL;
  }

  pnode->entry = entry;
  pnode->pnext = NULL;

  return pnode;
}

void CreatList( List* list )
{ 
  list->count = 0;
  list->header = NULL; 
}	

bool ListEmpty( List* list )
{ return ( list->header == NULL ); }

// add only at the end. see there are approaches to find end; one is to use pnext and the other is
// to use count. How about having a Node* end in the List struct to have a current end?

bool AddList( List* list, EntryType entry )
{
  Node* pnode, *pend;

  if( (pnode = MakeNode(entry)) == NULL )
  {
    std::cout << "add: mem is full" << std::endl;
    return false;
  }

  if( ListEmpty( list ) )
  {
    list->header = pnode;
  }
  else
  {
#ifdef USE_PNEXT
    // search the end using pnext
    for( pend = list->header; pend->pnext; pend = pend->pnext )
      ;

#else

    // search the end using count
    pend = list->header;
    for( int current = 1; current < list->count; current++) // [KT] less than
      pend = pend->pnext;

#endif

    // do not need since done in MakeNode()
    // pnode->entry = entry;

    pend->pnext = pnode;
  }

  list->count++;

  std::cout << "add: added " << entry << ", count " << list->count << std::endl;

  return true;
}

typedef void(*TRAVERSEFUNC)(EntryType);	

void TraverseList( List* list, TRAVERSEFUNC func)
{
  Node* pnode;

  if( ListEmpty(list) )
  {
    std::cout << "list is empty" << std::endl;
    return;
  }

  pnode = list->header;

  while(pnode)
  {
    func(pnode->entry);
    pnode = pnode->pnext;
  }
}

void EntryPrint(EntryType item)
{
  std::cout << "item is: " << item << std::endl;
}

int main()
{
  int item = 0;

  List list;
  CreatList(&list);

  std::cout << "type in 5 numbers." << std::endl;

  for(int i=0; i < 5; i++)
  {
    std::cin >> item;
    AddList(&list, item );
  }		

  TraverseList(&list, EntryPrint);
}


{DN}
The stack and simple list are essentially the same implementation in terms of contiguous and linked
implementation.


==============================================================================
*kt_dev_algo_003*	general list

To support [random-access] as oppose to a simple list that supports only addition at the end:

void InsertList( position p, ListEntry x, List* list);
// the entry in position p of list has been returned as x and deleted from list.
void DeleteList( position p, ListEntry* x, List* list);

void RetrieveList( position p, ListEntry* x, List* list);	// list remain unchanged
void ReplaceList( position p, ListEntry x, List* list);		// list remain unchanged

As with list and others, the general list has two kind of implementation: contiguous and linked. For
contiguous, shift later elements to support inserting and deleting in any position. For both, need
to scan from the first every time. 


<do> So think about linked case here. Add InsertList and deleteList to the simple list using
SetPosition which is utility function.

count/size ; sizeof()
 1   2   3   4   5  ...

[ ] [ ] [ ] [ ] [ ] ...

 0   1   2   3   4  ...
index/pos


void SetPosition( Position p, List* list, ListNode** current)
{
	 int count;
	 ListNode* q;

	 if( p < 0 || p >= list->count )
		  Error("attempt to set a position not in the list");
	 else 
	 {
		  q = list->head;
		  for( count = 1; count <= p; count++ )
				q = q->next;
		  *current = q;
	 }
}


<code-example-one>

From the ref-001. Points:

1> Should handle when add an entry to the the first position since this Insert() will replace addList call.
2> Should have the previous pos(p-1) for pos insertion.


void InsertList( Position p, ListEntry x, List* list )
{
   ListNode *newnode, *current;

   // check if pos is in [0...count-1]
   if( p < 0 || p > list->count )
      Error("attempt to set a position not in the list");
   else 
   {
      newnode = MakeListNode(x);
      // [PO] cannot be the same as if( ListEmpty(list) ) since if so, only handle that case.
      if( p == 0 )   
      {
         newnode->next = list->head;
         list->head = newnode;
      }
      else
      {
         SetPosition( p-1, list, &current );
         newnode->next = current->next;
         current->next = newnode;
      }
      list->count++;
   }
}

 [KT] This has a flaw. If call this when a list empty, that is, pos=0, count=0, then ends up
 accessing NULL. Can be fixed.

 if( p < 0 || p >= list->count )
   Error("attempt to set a position not in the list");


<code-example-two>

The above example has mismatch between count and pos, that is:

count 1 2 3 4 5
pos   0 1 2 3 4

The following uses the same range for both count and pos. Make a note for that always need to handle
the first node separately and [the-previous] node to insert in the list.

#include < iostream>
#include < cstdlib>

typedef int EntryType;
typedef int Position;

typedef struct node
{
	EntryType 	entry;
	node*			pnext;
} Node;

typedef struct {
   int   count;
	Node*	header;
} List;

Node* MakeNode( EntryType entry )
{
	Node* pnode = NULL;

	if( (pnode = (Node*) malloc( sizeof(Node))) == NULL )
		return NULL;

	pnode->entry = entry;
	pnode->pnext = NULL;

	return pnode;
}

void CreatList( List* list )
{ 
   list->count = 0;
   list->header = NULL; 
}	

bool ListEmpty( List* list )
{ return ( list->header == NULL ); }

// add only at the end
bool ListAdd( List* list, EntryType entry )
{
	Node* pnode, *pend;

	if( (pnode = MakeNode(entry)) == NULL )
	{
		std::cout << "add: mem is full" << std::endl;
		return false;
	}

   if( ListEmpty( list ) )
   {
      list->header = pnode;
   }
   else
   {
      // search the end using pnext
      for( pend = list->header; pend->pnext; pend = pend->pnext )
         ;

      pnode->entry = entry;

      pend->pnext = pnode;
   }

   list->count++;

   std::cout << "add: added " << entry << ", count " << list->count << std::endl;

	return true;
}

// support random-access
bool SetPosition( List* list, Position pos, Node** ppNode)
{
   Node* pnode;
   int current;

   // check if pos  is in [1...count]
   if( pos < 1 || pos > list->count )
   {
      std::cout << "error: attempt to insert in a position" << pos << " not in the list" << std::endl;
      return false;
   }

   pnode = list->header;

   #ifdef RETURN_THE_PREVIOUS
   for( current=1; current < pos; current++ )
   #endif
   for( current=1; current <= pos; current++ )
      pnode = pnode->pnext;

   *ppNode = pnode;
}

 [KT] Compared the previous, this has a protection. If call this when a list empty, that is, pos=1,
 count=0, then error happens and return. Cannot use this when a list is empty. Why? Looks okay.

bool InsertList( List* list, EntryType entry, Position pos )
{
   Node* pnewnode, *pnode;

   // check if pos  is in [1...count]
   if( pos < 1 || pos > list->count ) // [KT]
   {
      std::cout << "error: attempt to insert in a position not in the list" << std::endl;
      return false;
   }

   // get a new node
   pnewnode = MakeNode(entry);
   if(pnewnode==NULL)
   {
		std::cout << "error: no more memory" << std::endl;
      return false;
   }

   if( pos == 1 ) // [KT]
   {
      pnewnode->pnext = list->header;
      list->header = pnewnode;
   }
   else
   {
      #ifdef RETURN_THE_PREVIOUS
      // get the prev node of pos node
      SetPosition( list, pos, &pnode );
      #endif

      SetPosition( list, pos-1, &pnode );

      // insert a new node between pos-1 and pos node
      pnewnode->pnext   = pnode->pnext; 
      pnode->pnext      = pnewnode;
   }

   list->count++;
}

bool DeleteList( List* list, EntryType entry, Position pos )
{
}

typedef void(*TRAVERSEFUNC)(EntryType);	

void ListTraverse( List* list, TRAVERSEFUNC func)
{
	Node* pnode;

	if( ListEmpty(list) )
	{
		std::cout << "list is empty" << std::endl;
		return;
	}
	
	pnode = list->header;

	while(pnode)
	{
		func(pnode->entry);
		pnode = pnode->pnext;
	}
}

void EntryPrint(EntryType item)
{
   std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	List list;
	CreatList(&list);

	std::cout << "type in 5 numbers." << std::endl;

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		ListAdd(&list, item );
	}		

   InsertList(&list, 10, 6);
   InsertList(&list, 10, 1);  // expects an error
   InsertList(&list, 20, 6);

	ListTraverse(&list, EntryPrint);
}


{improved-search-list}

For cases refering to the same entry several times as an example, this can be improved by keeping
the current position which is the last-used position; [locality-of-reference] that is, if one entry
is accessed, is it likely that it will next be accessed again:

typedef int Position;

// See {list-linked-implementation} for comparison
//
typedef struct list {
	 int count;
	 ListNode*  head; 
	 Position   currentpos; ~
	 ListNode*  current; ~
} List;

void SetPosition( Position p, List* list )
{
	 if( p < 0 || p >= list->count )
		  Error("attempt to set a position not in the list");
	 else 
	 {
		  if( p < list->currentpos )
		  {
				list->currentpos = 0;
				list->current = list->head;	// since it has one-way direction
		  }

		  for( ; list->currentpos != p; list->currentpos++ )
				list->current = list->current->next;
	 }
}


This improves its efficiency than the previous but the changes needed to the various functions are
minor: For repeated references to the same position, neither if and for will be excuted; that is
when p equals to currentpos. So takes almost no time. For forward move, will be very fast and for
backward move, operates the same way as the previous.


{doubly-linked-list}

Not a simple DL list but supports [random-access] which is more complicated than thought.

typedef struct listnode {
	 ListEntry entry;
	 struct listnode* next;
	 struct listnode* prev;
} ListNode;

typedef struct list {
	 int count; 				// [KT] count [1..n] and pos[0..n-1]. no header
	 ListNode*  current; ~
	 Position   currentpos; ~
} List;

// set current to the position in 0.. count-1. see no return of ppNode and no run when
// pos==currentpos.
void SetPosition( Position p, List* list )
{
	 if( p < 0 || p >= list->count )
		  Error("attempt to set a position not in the list.");
    // move forward
	 else if( list->currentpos < p )
	 {
		  for(; list->currentpos != p; list->currentpos++ )
				list->current = list->current->next;
	 }
    // move backward
	 else if( list->currentpos > p )
	 {
		  for(; list->currentpos != p; list->currentpos-- )
				list->current = list->current->prev;
	 }
}

 [KT] Like the first, the below has a flaw when the list is empty. But can use this func to add when
 the list is empty.

void InsertList( Position p, ListEntry x, List* list)
{
  ListNode* newnode, *following;

  if( p < 0 || p > list->count )
    Error("attempt to set a position not in the list.");
  else
  {
    newnode = MakeListNode(x);

    // insert at the beginning as it is not circular. This means that: first node's prev is null.
    //
    if( p == 0 )		
    {
      newnode->prev = NULL;

      if( list->count == 0 )	// list is empty
        newnode->next = NULL;
      else
      {
        Setposition( 0, list );	// [note] set current to pos 0
        newnode->next = list->current;
        list-current->prev = newnode; 
      }
    }
    else				// insert later in the list
    {
      // [KT] For DL, need the prev and the current(following) regardless of return pos from
      // SetPostion.
      SetPosition( p-1, list );		

      /* is temp really required?
       *
       *             cur(pos-1)  pos(end)
       * [prev next] [prev next] [prev next]
       * 
       *                 new [prev next]
       *
       * if do without temp(following) then
       *
       * cur->next = new;
       * cur->next->prev = new;
       * new->prev = cur;
       * new->next = cur->next; but cur->next is already changed.
       *
       * new->next = cur->next;
       * new->prev = cur;
       * cur->next->prev = new;
       * cur->next = new;
       *
       * seems okay. [NO] because cur->next is null when inserting at the end. REALLY?
       *
       *                 pos-1   pos
       *                 cur     following
       *         [0]     [1]     [2] 
       *          next -> next -> next -> null
       * null <- prev <- prev <- prev
       *
       */
      following = list->current->next;

      // insert between current and following
      newnode->next = following;
      newnode->prev = list->current;
      list->current->next = newnode;

      // this check is required when inserting at the end because cur->next is null
      if(following)		
        following->prev = newnode;
    }

    list->current = newnode;
    list->currentpos = p;
    list->count++;
  }
}


{list-contiguous-and-linked} {contiguous-vs-linked}
In summary, contiguous storage is generally preferable when:

o the records are individually very small
o the size of list is known when the program is written
o few insertion or deletion need to be made except at the end of the list
o random access is important

linked storage proves superior when:

o the records are large
o the size of list is not known when the program is written
o flexibility is needed in inserting, deleting and rearranging the entries.


            Searching   Insertion/deletion other then the end
Contiguous: O(1)        O(n)  
Linked    : O(n)        O(1)

  
==============================================================================
*kt_dev_algo_004*	queue

The queue has head(front) and tail(rear).

{queue-contiguous-implementations}
<approach-one> 
Use single index and use always index 0 as a head and the end as a tail. However, use first entry
and then move all the remaining entries one position up. Poor choice.

<approach-two>
Use array and two indices to keep track of both the front and the rear. However, has a defect that
both are increased but never decreased. Space problem. If can relocate queue regularly, two indices
and straight-line storage implementation is very efficient.

// 
// code-example
//
#include < iostream>

#define MAXSIZE 5

typedef int EntryType;

typedef struct {
   EntryType   data[MAXSIZE];
   int         head;
   int         tail;
} Queue;

void CreateQueue(Queue* queue)
{
   queue->head = queue->tail = 0;
}

bool QueueEmpty(Queue* queue)
{
   if( queue->head == queue->tail )
   {
      std::cout << "empty(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

bool QueueFull(Queue* queue)
{
   if( queue->tail >= MAXSIZE )
   {
      std::cout << "full(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

void AddQueue( Queue* queue, EntryType entry )
{
   if( QueueFull(queue) )
      return;

   queue->data[queue->tail++] = entry;
}

void DelQueue( Queue* queue, EntryType* pentry )
{
   if( QueueEmpty(queue) )
      return;

   *pentry = queue->data[queue->head++];
}

void TraverseQueue( Queue* queue, void(*f)(int, EntryType))
{
   int current, end;

   for( current = queue->head, end = queue->tail; current < end; current++ )
      f(current, queue->data[current]);
}

void PrintEntry(int pos, EntryType entry)
{
   std::cout << " " << pos << " : [" << entry << "]" << std::endl;
}

int main()
{
   Queue queue;

   CreateQueue(&queue);

   QueueEmpty(&queue);

   AddQueue(&queue, 10);
   AddQueue(&queue, 11);
   AddQueue(&queue, 12);

   TraverseQueue(&queue, PrintEntry);

   AddQueue(&queue, 13);
   AddQueue(&queue, 14);
   AddQueue(&queue, 15);

   TraverseQueue(&queue, PrintEntry);

   return 0;
}

empty when head,tail is (0,0)
 0th : [10]
 1th : [11]
 2th : [12]
 3th : [13]
 4th : [14] // entry[tail++] = e;
full (0,5) 5%MAXSIZE = 0. Then head,tail is (0,0) so there is no way to tell empty or full

To solve space problem, use [circular-array] and decide boundary condition to indicate if a queue is
full or empty. However, there is no way, by looking at the indicies ALONE, to tell a full queue from
an empty one.

q which has one item
... [] ...
    rear
    front

q which is empty after removing one, that is, increase front index
... [] [] [] ...
    rear
       front

q which has one empty position left
... [] [] [] ...
    rear  front

q which is full after adding one, that is, increase rear index
... [] [] [] ...
    rear
       front

addQ is to insert item and inc rear and subQ is to remove item and dec front. See the result of the
code example. To solve that there is no difference between full and empty, there are three
approaches:

<approach-one> {queue-circular-array} {interview}
Use circular array, two indicies and [one position left vacant].

... [] [*] [] ...
    rear
	        front

so empty when rear == front and full when rear == front-2. [KT] That is wrong and was difficult that
thought. Maybe quiz.

From 8.4.3 in DATA STRUCTURES IN C++ (Google eBook) N. S. KUTTI, P. Y. PADHYE, think [virtual-head]
which means a real head and head which means vacant element. The head is always virtual head+1. The
head and virtual head moves along as rear do and there is no need to move elements to keep vacant
element. In short, do not think about virtual head. Just think that plus one more index when do
operations: inQ deQ and check full. This always have one vacant.

...[vh] [h] [t] ...
...[* ] [h] [t] ...


 0  1  2  3  4
[f][h][ ][ ][r]

(r,f)             full  empty                   full
(0,4) (0,3) (0,2) (0,1) (0,0) (1,0) (2,0) (3,0) (4,0)
-4    -3    -2    -1    0     1     2     3     4			rear-front
 1     2     3     4    5     6     7     8     9			+QSIZE(5)
 1     2     3     4    0     1     2     3     4			(rear-front+QSIZE)%QSIZE

init: head=tail=0;                       // can be any index
empt: return head==tail;
full: return (tail+1)%QSIZE == head;
leng: length = (rear+QSIZE-front)%QSIZE;  // can get any time
// do not think about this: haed: head = (front+1)%QSIZE;

//
// code-example
//
#include < iostream>

#define MAXSIZE 5

typedef int EntryType;

typedef struct {
   EntryType   data[MAXSIZE];
   int         head;
   int         tail;
} Queue;

void CreateQueue(Queue* queue)
{
   queue->head = queue->tail = 0;
}

bool QueueEmpty(Queue* queue)
{
   if( queue->head == queue->tail )
   {
      std::cout << "empty(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

bool QueueFull(Queue* queue)
{
   if( (queue->tail+1)%MAXSIZE == queue->head ) // ~
   {
      std::cout << "full(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

void AddQueue( Queue* queue, EntryType entry )
{
  if( QueueFull(queue) )
    return;

  queue->tail = (queue->tail+1)%MAXSIZE; // ~
  queue->data[queue->tail] = entry;      // ~

// std::cout << "add(" << queue->tail << ")" << std::endl;

// queue->data[queue->tail+1] = entry; 
// queue->tail = (queue->tail+1)%MAXSIZE;
//
// This do not work. Why? As this example, made it full and done three deletions then head, tail
// would be head(3) and tail(4). This means q has one item.
//
// 0 1 2 3 4 -> 0 1 2 3 4 
//   * * * *            * 
//                    h t
//
// Now when calls add, q is not full and add three items add [5] and set tail=0; this will overwrite
// queue->head because it is next to queue.entry. add [0] and set tail=1; add [1] and set tail=2;
//
// This mangles queue structure and causes a problem when delete items. The point is that since it
// has vacant entry and it do add and increase one step before than circular queue with count
// implementaion and the order of operation is different.
//
// circular q with vacant                       circular q with count
// when t==3, t=4 from mod and inc; and [4]=x   when t==4, [4]=x; t=0 from mod and inc
}

void DelQueue( Queue* queue, EntryType* pentry )
{
  if( QueueEmpty(queue) )
    return;

  queue->head = (queue->head+1)%MAXSIZE;
  *pentry = queue->data[queue->head];

//   std::cout << "del(" << queue->head << ")" << std::endl;

//   do not work as before.
//   *pentry = queue->data[queue->head+1];
//   queue->head = (queue->head+1)%MAXSIZE;
}

// this is differnt from the straight line implementation
void TraverseQueue( Queue* queue, void(*f)(int,int, EntryType))
{
  int count=0, current=0;

  // See *kt_dev_algo_005*
  // int length = abs( queue->tail - queue->head)%MAXSIZE; // this do not works.
  int length = ( queue->tail - queue->head + MAXSIZE )%MAXSIZE;

  // std::cout << "trav(" << queue->head+1 << "," << queue->tail+1 << ")" << std::endl;

  for( current = queue->head+1, count=0; count < length; count++, current++ )
  {
    current = current%MAXSIZE;
    f(current, length, queue->data[current]);
  }
}

void PrintEntry(int pos, int length, EntryType entry)
{
  std::cout << " " << pos << ":" << length << " : [" << entry << "]" << std::endl;
}

int main()
{
  Queue queue;
  EntryType entry;

  CreateQueue(&queue);

  QueueEmpty(&queue);

  AddQueue(&queue, 10);
  AddQueue(&queue, 11);
  AddQueue(&queue, 12);

  TraverseQueue(&queue, PrintEntry);

  AddQueue(&queue, 13);
  AddQueue(&queue, 14);
  AddQueue(&queue, 15);

  TraverseQueue(&queue, PrintEntry);

  DelQueue(&queue, &entry);
  std::cout << "del " << entry << std::endl;

  DelQueue(&queue, &entry);
  std::cout << "del " << entry << std::endl;

  DelQueue(&queue, &entry);
  std::cout << "del " << entry << std::endl;

  AddQueue(&queue, 100);
  AddQueue(&queue, 101);
  AddQueue(&queue, 102);

  TraverseQueue(&queue, PrintEntry);

  DelQueue(&queue, &entry);
  std::cout << "del " << entry << std::endl;

  DelQueue(&queue, &entry);
  std::cout << "del " << entry << std::endl;

  AddQueue(&queue, 300);
  AddQueue(&queue, 301);
  AddQueue(&queue, 302);

  TraverseQueue(&queue, PrintEntry);

  return 0;
}


<approach-two> 
Use circular array, two indicies and new variable: [a bool flag] for full or empty. The flag is
toggle: For a case from a book, if q becomes diff(front-rear) == 1 while flag == full then q becomes
empty. Or int variable to indicate.

<approach-three>
Use circular array, two indicies and new variable: a counter(length) 

typedef T QueueEntry; // application-program dependent

typedef struct queue {
	int count; // 0 .. MAXQUEUE-1
	int front;
	int rear;
	QueueEntry entry[MAXQUEUE];
} Queue;

void CreatQueue(Queue* q)
{
	q->count = q->front = 0;
	q->rear = -1; [emptiness]
}

/* Or Insert. add an entry as its last */
void Append(QueueEntry x, Queue* q)
{
	if( QueueFull(q))
		Error(...);
	else
	{
		q->count++;
      // if use rear=-1 when init
		q->rear = (q->rear+1) % MAXQUEUE;
		q->entry[ q->rear ] = x;
      // if use rear=0 when init
		q->entry[ q->rear ] = x;
		q->rear = (q->rear+1) % MAXQUEUE;
	}
}

/* Or Delete. delete the first entry and note that *x */
void Serve(QueueEntry *x, Queue* q)
{
	if( QueueEmpty(q) )
		Error(...);
	else
	{
		q->count--;
		*x = q->entry[ q->front ];
		q->front = (q->front+1) % MAXQUEUE;
	}
}

Boolean QueueFull(Queue* q)
{
	return q->count >= MAXQUEUE;
}

Boolean QueueEmpty(Queue* q)
{
	return q->count <= 0;
}

int QueueSize(Queue* q)
{	
	return q->count;
}

Also can have ClearQueue, QueueFront, and TraverseQueue.


 [KT] seems do not need emptiness when init. As front and rear always increases, fetch first and
 increase or decrease later. This is the same as the array implementation except mod operation to
 make it circular.

// 
// code-example
// 
#include < iostream>

#define MAXSIZE 5

typedef int EntryType;

typedef struct {
   EntryType   data[MAXSIZE];
   int         count;
   int         head;
   int         tail;
} Queue;

void CreateQueue(Queue* queue)
{
   queue->head = queue->tail = queue->count = 0;
}

bool QueueEmpty(Queue* queue)
{
   if( queue->count == 0 )
   {
      std::cout << "empty(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}

bool QueueFull(Queue* queue)
{
   if( queue->count >= MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}

// the same as the array implementation except mod operation to make it circular
void AddQueue( Queue* queue, EntryType entry )
{
   if( QueueFull(queue) )
      return;

   std::cout << "add(" << queue->tail << ")" << std::endl;
   queue->data[queue->tail++] = entry;
   queue->tail = (queue->tail)%MAXSIZE;

   queue->count++;
}

void DelQueue( Queue* queue, EntryType* pentry )
{
   if( QueueEmpty(queue) )
      return;

   *pentry = queue->data[queue->head++];
   queue->head = (queue->head)%MAXSIZE;

   queue->count--;
}

// changed
void TraverseQueue( Queue* queue, void(*f)(int,int, EntryType))
{
   int count=0, current=0;
   int length = queue->count;

   // std::cout << "trav(" << queue->head+1 << "," << queue->tail+1 << ")" << std::endl;

   for( current = queue->head, count=0; count < length; count++, current++ )
   {
      current = current%MAXSIZE;
      f(current, length, queue->data[current]);
   }
}

void PrintEntry(int pos, int length, EntryType entry)
{
   std::cout << " " << pos << ":" << length << " : [" << entry << "]" << std::endl;
}

int main()
{
   Queue queue;
   EntryType entry;

   CreateQueue(&queue);

   QueueEmpty(&queue);

   AddQueue(&queue, 10);
   AddQueue(&queue, 11);
   AddQueue(&queue, 12);

   TraverseQueue(&queue, PrintEntry);

   AddQueue(&queue, 13);
   AddQueue(&queue, 14);
   AddQueue(&queue, 15);

   TraverseQueue(&queue, PrintEntry);

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   AddQueue(&queue, 100);
   AddQueue(&queue, 101);
   AddQueue(&queue, 102);

   TraverseQueue(&queue, PrintEntry);

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   AddQueue(&queue, 300);
   AddQueue(&queue, 301);
   AddQueue(&queue, 302);

   TraverseQueue(&queue, PrintEntry);

   return 0;
}


{queue-linked-implementations}
Unlike contiguous queue, NO space problem and NO emptiness/fullness problem. So no full check and
only care about emptiness:

1) addition when queue is empty must be treated separately since
addition to an empty queue requires setting both the front and the rear to the new node, whereas
addition to nonempty requires changing only the rear. 

2) deletion when queue goes empty must be treated. 

typedef T QueueEntry;

typedef struct queuenode {
	QueueEntry entry;
	struct queuenode *next;
} QueueNode;

typedef struct queue {
	QueueNode* front;
	QueueNode* rear;
} Queue;

void CreateQueue(Queue *q)
{
	// this is a empty condition
	q->front = q->rear = NULL;
}

//
// QueueNode* pentry = (QueueNode*) malloc( sizeof(QueueNode) );
// AppendNode( pentry, q );
//
// [KT] this reveals that it is linked implementation. not well in hiding. the following is better?
//
// QueueItem* pitem = (QueueItem*) malloc( sizeof(QueueItem) );
// AppendQueue( pitem, q );
//
void AppendNode(QueueNode *p, Queue* q)
{
	if(!p)
		Error(...)
	else if( QueueEmpty(q) )
		q->front = q->rear = p;
	else
	{
		q->rear->next = p;
		q->rear = p;
	}
}

// 
// QueueNode* pentry;
// ServeNode( &pentry, q);
// ..
// use entry
// ..
// free(pentry);
//
void ServeNode(QueueNode**p, Queue* q)
{
	if( QueueEmpty(q) )
		Error(...);
	else
	{
		*p = q->front;
		q->front = q->front->next;
		
		// if q is empty, front is already null so mark rear null as well. Here empty condition is
      // when both are null but not the same.
		if( QueueEmpty(q) )
			q->rear = NULL;
	}
}


{queue-circularly-linked}
This is a linked list in which the node at the tail of the list, instead of having a null, points
back to the node at the head. Need only one pointer tail to access both ends of the list.


==============================================================================
*kt_dev_algo_005*	array: index shift

{example-one}

From *kt_dev_algo_007*	recursion:

4x4
00 01 02 03 : down diff -3. 4th covers 1 pos. -> 0th
10 11 12 13 : down diff -2. 5th covers 2         1th
20 21 22 23 : down diff -1. 6th covers 3         2th
30 31 32 33 : down diff  0. 0th covers 4         3th
            : down diff  1. 1th covers 3         4th
				: down diff  2. 2th covers 2         5th
				: down diff  3. 3th covers 1         6th

#define BOARDSIZE 	4						// 4x4 space
#define DIAGONAL		(2*BOARDSIZE-1)	// up or down diagonal size. 7
#define DOWNOFFSET	(BOARDSIZE-1)		// down diagonal offset. BOARDSIZE-1

bool downfree[ DIAGONAL ];

downfree[ queenrow - col + DOWNOFFSET ] = false;

Since array index cannot be negative, need to shift index into positive. Here -3...3 to 0...6 and
used DOWNOFFSET(3).

-3 -2 -1 0 1 2 3
 0  1  2 3 4 5 6 	// array[7];


{example-two}

From circular-queue, rear-front can have -4...4 and to get the length of queue can shift. Here
there is one vacant element.

 0  1  2  3  4
[f][h][ ][ ][r]

(r,f)                   empty                   full
(0,4) (0,3) (0,2) (0,1) (0,0) (1,0) (2,0) (3,0) (4,0)
-4    -3    -2    -1    0     1     2     3     4			rear-front
 1     2     3     4    5     6     7     8     9			+QSIZE(5)
 1     2     3     4    0     1     2     3     4			(rear-front+QSIZE)%QSIZE

 0     1     2     3    4     5     6     7     8			+QSIZE-1(4)
 
The difference is that there is one vacant element so used QSIZE to shift but not QSIZE-1. 0th is
not used.


==============================================================================
*kt_dev_algo_006*	the game of life

From {ref-001}. In short, the rule as to the neighbour count is:

o if 3 and the dead cell, gets live in the next run.
o if > 4 and the live cell, gets dead in the next run.
o if 2, makes no change.
o if 0, 1, gets dead. makes no change.

{first-version}

Grid map, newmap; // [MAXROW+2][MAXCOL+2]

do 
{
	 for( row = 1; row <= MAXROW; row++ )	// why starts from 1? see {hedge-or-sentinel}
		  for( col = 1; col <= MAXCOL; col++ )
				switch( NeighborCount( map, row, col )) 
				{
					 case 0: case 1:
					 newmap[row][col] = DEAD; break;

					 case 2:
					 newmap[row][col] = map[row][col]; break;

					 case 3:
					 newmap[row][col] = ALIVE; break;

					 case 4: case 5: case 6: case 7: case 8:
					 newmap[row][col] = DEAD; break;
				}

		CopyMap(map, newmap);
		WriteMap(map);

} while( UserSaysYes());

This approach is:

 map (current gen) -> cal and updated newmap(next gen) -> copy newmap to map
 ... repeats
	
MAXROW x MAXCOL = 20 x 60 = 1200. This amounts to about 18,000 statements.


{second-version}

Question is that is it necessary to calculate the number of neighbors of every cell at every
generation? No and improvements are:

o no copy from newmap to map.
o no cal for a whole map but for neighboring cells.

Grid map, numbernbrs;	// [MAXROW+2][MAXCOL+2]
List newlive, newdie;
List maylive, maydie;

while(UserSaysYes())
{
	 // current generation
	 // Vivify it in [map] and add it from [maylive] to [newlive] when it is dead and 3
	 TraverseList( &maylive, Vivify );
	 TraverseList( &maydie, Kill );
	 ClearList( &maylive );
	 ClearList( &maydie );

	 WriteMap( map );		// print to user

	 // next generation
	 // while traversing [newlive], cal neighbor count and update [numbernbrs]. Add it to [maylive]
	 // or [maydie]
	 TraverseList( &newlive, AddNeighbors );
	 TraverseList( &newdie, SubstractNeighbors );
	 ClearList( &newlive );
	 ClearList( &newdie );
}

{postpone-difficulty}

The subtle problem is that maylive/maydie can have multiple same entry and spurious entry and some
should be changed later because [numbernbrs] is not fully updated while traversing lists. This
difficluty is handled later when running vivify call because we have now completed neighbor counts,
that is [numbernbrs]. 

{loop-invariant}

The {loop-invariant} is a statement that is true at the beginning of every iteration of the loop. In
this example, that is:

At the beginning of the main loop, list maylive contains only dead cells, and list maydie contains
only living cells, but the list may contain duplicates or spurious entries whose counts are wrong.
The list newlive and newdie are empty.

The purpose of loop invariant is to capture the essence of the dynamic process. It is not always
easy to find.

{performance}

The amount of computation is no longer proportional to the size of the grid but to the number of
changes being made. Has about 2900 statements which is 6 times faster than the first. Is it
worthwhile although it is more complicated and costly to maintain? Usually there is
{space-and-time-trade-offs}. Depends on.


==============================================================================
*kt_dev_algo_007*	recursion

The recursion is [divide-and-conquer] as it reduce the large problem to one or more problems of a
similar nature but a smaller size. 

Must determine the [stopping-rule], the smallest case because there must be some way that the
recursion stops.


{the-tower-of-hanoi}

The idea is to concentrate not on the first step, but rather on the hardest step: moving the bottom
disk because condition is that only one disk can be moved at a time and the bottom, largest, one can
never be on top of any other.

Move( disk, start, finish, temp );

When there are 64 disks:

Move( 63, 1, 2, 3);                             // 63th disk
printf("move disk 64 from tower 1 to 3.\n");    // 64th disk
Move( 63, 2, 3, 1);                             // 63th disk

The stopping rule is when there is no disk to be moved, there is nothing to do.

#define DISKS	64

void Move(int count, int start, int finish, int temp)
{
	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
		  printf("move a disk from tower %d to %d.\n", start, finish );
		  Move( count-1, temp, finish, start );
	}
}

int main()
{
	 Move( DISKS, 1, 3, 2 );
	 return 0;
}

The number of non-leaves, that is the number of moves for 64 is 2^64-1. This is about 5x10^11 years
where 2x10^10 is 20 billion years

{recursion-tree}

This is a tool to visualize recursive call in which node represents recursion call. The time
requirement is the total number of nodes, vertices, in a recursion tree since traverse all nodes and
the space(stack space) is the depth of tree, not the number of nodes.

                                                          Move(3, 1,3,2) ()

                             Move(2, 1,2,3) ()                                              ...

         Move(1, 1,3,2) ()                      Move(1, 3,2,1) ()          

Move(0, 1,2,3) ()  Move(0, 2,3,1) ()   Move(0, 3,1,2) ()  Move(0, 1,2,3) ()


To get this in programming, can think of:

#include < iostream>

using namespace std;

#define DISKS	3

unsigned int depthRecursion;

void PrintDepth( bool dash, unsigned int depth )
{
	for( unsigned int i=0; i <= depth; ++i)
	{
		if(dash)
			cout << "--";
		else
			cout << "  ";
	}

	if(dash)
		cout << "(" << depth << ") ";
	else
		cout << "      ";
}

void Move(int count, int start, int finish, int temp)
{
	 depthRecursion++;
	 PrintDepth( true, depthRecursion );

	 cout << "Move(" << count << "," << start << "," << finish << "," << temp << ")" << endl;

	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
	 	  PrintDepth( false, depthRecursion );
		  cout << "move a disk " << count << " from tower " << start << " to " << finish << endl;
		  Move( count-1, temp, finish, start );
	 }

	 depthRecursion--;
}

int main()
{
	 Move( DISKS, 1, 3, 2 );
	 return 0;
}

kt@kt-ub-vb:~/c++$ ./a.out 
----(1) Move(3,1,3,2)
------(2) Move(2,1,2,3)
--------(3) Move(1,1,3,2)                        // { (1, s,f,t)
----------(4) Move(0,1,2,3)                      //    { (0, s,f,t)
              move a disk 1 from tower 1 to 3
----------(4) Move(0,2,3,1)                      //    } (0, s,f,t)
            move a disk 2 from tower 1 to 2
--------(3) Move(1,3,2,1)	                      // } (1, s,f,t)

----------(4) Move(0,3,1,2)
              move a disk 1 from tower 3 to 2
----------(4) Move(0,1,2,3)

          move a disk 3 from tower 1 to 3
------(2) Move(2,2,3,1)

--------(3) Move(1,2,1,3)
----------(4) Move(0,2,3,1)
              move a disk 1 from tower 2 to 1
----------(4) Move(0,3,1,2)

            move a disk 2 from tower 2 to 3
--------(3) Move(1,1,3,2)
----------(4) Move(0,1,2,3)
              move a disk 1 from tower 1 to 3
----------(4) Move(0,2,3,1)

Here counts is disks which are 1, 2, 3 and when follows the messages, get a problem solved. Note
that PrintDepth is correct showing the same depth of recursion in column.


{eight-queen-puzzle}

From {ref-001} and C version. The chess rules is that a queen can take another queen that is on the
same row, the same column, or the same diagonal.

<key-step>

This is formulating or outlining that use recursion to mean contiune to the next stage and repeat
the task.

This is naive approach when 8x8 board:

void AddQueen()
{
	 for( every unguarded position p on the board )
	 {
		  place a queen in position p;
		  queen++;

		  if( queen == 8 )
				print the configuration;
		  else
				AddQueen();

		  remove the queen from position p;
		  queen--;
	 }
}
 
4x4 eample

 dead end    dead end    solution    solution
  0 1 2 3     0 1 2 3     0 1 2 3     0 1 2 3 
0 Q ? ? ?   0 Q ? ? ?   0 X Q ? ?   0     Q   
1 X X Q ?   1 X X X Q   1 X X X Q   1 Q       
2 X X X X   2 X Q X X   2 Q X X X   2       Q 
3           3 X X X X   3 X X Q X   3   Q     

<backtrack> <postponing-the-work>

When reach a dead end, must backtrack by going back to the most recent choice we have made and
trying another possibility. Usally called [backtracking-algorithm] which attempt to complete a
search for a solution by constructing [partial-solution] and which proves useful in situation where
many possibilities may first appear such as scheduling problems and a compiler parsing to determine
the meaning of a statement. 

<data-structure>

To choose the data structure to represent data to solve a problem. In this case, array.

<observations>

observation-01: mark guarded and unguarded. 
If scan the board to see if a position is guarded whenever place a queen, would involve considerable
searching. As do on a paper, if can mark guarded posion when place a queen, can look for unguarded
position in the next stage. So reduced searching but a problem arise.

When remove a queen, should not necessrily change a position from false to true(unguarded) because
some other queen still guard that posiotion. So can use int array instead to count and position is
unguarded if and only if it has a count of 0. Better than the first approach but involves
considerable searching and calculation. How to improve? Need more observations.

observation-02: only one queen in each row

int queencol[ rows ] gives the column containing a queen and this covers vertical and horizental
positions.

observation-03: use [difference] for downwards and [sum] for upwards.

4x4
00 01 02 03 : down diff -3. 4th covers 1 pos. -> 0th
10 11 12 13 : down diff -2. 5th covers 2         1th
20 21 22 23 : down diff -1. 6th covers 3         2th
30 31 32 33 : down diff  0. 0th covers 4         3th
            : down diff  1. 1th covers 3         4th
				: down diff  2. 2th covers 2         5th
				: down diff  3. 3th covers 1         6th

The down and up diagonal examples are:

00 11 22 33 : down, 30 21 12 03 : up. where these are xy index in a array. 

The obseravtion here is that the main down diagonal has the same difference: 00 11 22 33 and otheres
are between -3..3. Since there is no minus index in array use offset to map 0..6 (shifted)

up diagonal are ones to upper-right. As down diagonal, cannot use difference because cannot uniquely
identify up diagonals. For example, 00 and 33 have 0 in difference. Therefore, use sum instead.

Try one example

  0 1 2 3
0 Q ? ? ?
1 X X Q ?
2 X X X X
3        

pos 00:Q: queencol[0] = 0. down diff 0 and 0th. up 0th.
pos 12:Q: queencol[1] = 2. down diff -1 and 6th. up sum 3.
    dead: backtrack. unset down 6th and up 3th. there is no duplicates in set/unset up and down diagonal
because pos on the same diagonal will not tried.

Therefore, no need to have int array for marking guarded and unguarded cells for a whole board.
Hence reduced calaulations and searching.

<analysis>

The navie approach which place 8 queens and reject illegal configutation every time when place a
queen. This is C(64, 8) = 64!/8!(64-8)! = 4,426,165,368. This is [combination] notation in math.

The [observation-02] cuts this to 8^8 = 16,777,216
The [observation-03] cuts this to 8! = 40,320

This shows the effectiveness of [backtrack] as reduce a recursion tree to manageable step. The
actual number of cases the program consider will be much less than this.

<code-program>

#include <iostream>

using namespace std;

#define BOARDSIZE 	4						// 4x4 space
#define DIAGONAL		(2*BOARDSIZE-1)	// up or down diagonal size
#define DOWNOFFSET	(BOARDSIZE-1)		// down diagonal offset. BOARDSIZE-1

// to set a column where queen is for a each row. For example,
//
//   0 1 2
// 0 Q
// 1 X X Q
//
// queencol has {0, 2, .. } means that row 0 has 0, row 1 has 2. this is the answer when finish.
//
int queencol[ BOARDSIZE ];					

// row where queen is and also means the number of queens has been put. recursion depth and
// horizental
int queenrow = -1;							

// bitset to mark guarded(occupied) or upguarded position for column, up and down diagonal
// for [backtrack]
bool colfree[ BOARDSIZE ];		// cloumn is guarded? vertical.
bool upfree[ DIAGONAL ];
bool downfree[ DIAGONAL ];

void PrintDepth( bool dash, unsigned int depth )
{
	for( unsigned int i=0; i <= depth; ++i)
	{
		if(dash)
			cout << "-";
		else
			cout << " ";
	}

	if(dash)
		cout << "(" << depth << ") ";
	else
		cout << "    ";
}

void WriteBoard()
{
	cout << "solution {";

	for( int i=0; i < BOARDSIZE; ++i)
		cout << queencol[i] << ",";

	cout << "}" << endl;
}

void AddQueen()
{
	 int col=0;

	 queenrow++;
	 PrintDepth(true, queenrow);
	 cout << "AddQueen(" << queenrow << ", " << col << ")" << endl;

	 for( col = 0; col < BOARDSIZE; col++ )
	 {
		  // check if colfree, upfree and downfree are unguarded
		  //
		  if( colfree[ col ] && upfree[ queenrow + col ] && downfree[ queenrow - col + DOWNOFFSET ] )
		  {
				// put a queen in position( queenrow, col )
				//
				PrintDepth(false, queenrow);
				cout << "added a queen(" << queenrow << ", " << col << ")" << endl;

				queencol[ queenrow ] = col;

				colfree[ col ] = false;
				upfree[ queenrow + col ] = false;
				downfree[ queenrow - col + DOWNOFFSET ] = false;

				if( queenrow == BOARDSIZE-1 ) // termination condition
					 WriteBoard();					// print out and should not terminate program to see all
					                           // solutions
				else 									// proceed recursively
					 AddQueen();

				PrintDepth(false, queenrow);
				cout << "removed a queen(" << queenrow << ", " << col << ")" << endl;

				// backtrack by removing the queen
				colfree[ col ] = true;
				upfree[ queenrow + col ] = true;
				downfree[ queenrow - col + DOWNOFFSET ] = true;
		  }
	 } // for end

	 queenrow--;
}

int main()
{
	 int i;
	 
	 // init bitsets
	 for(i = 0; i < BOARDSIZE; i++)
		  colfree[i] = true;	// unguarded

	 for(i = 0; i < DIAGONAL; i++)
	 {
		  upfree[i] = downfree[i] = true;
	 }

	 AddQueen();
	 return 0;
}

The output when run 4x4:

-(0) AddQueen(0, 0)
     added a queen(0, 0)
--(1) AddQueen(1, 0)
      added a queen(1, 2)
---(2) AddQueen(2, 0)
      removed a queen(1, 2)
      added a queen(1, 3)
---(2) AddQueen(2, 0)
       added a queen(2, 1)
----(3) AddQueen(3, 0)
       removed a queen(2, 1)
      removed a queen(1, 3)
     removed a queen(0, 0)
     added a queen(0, 1)
--(1) AddQueen(1, 0)
      added a queen(1, 3)
---(2) AddQueen(2, 0)
       added a queen(2, 0)
----(3) AddQueen(3, 0)
        added a queen(3, 2)
solution {1,3,0,2,}
        removed a queen(3, 2)
       removed a queen(2, 0)
      removed a queen(1, 3)
     removed a queen(0, 1)
     added a queen(0, 2)
--(1) AddQueen(1, 0)
      added a queen(1, 0)
---(2) AddQueen(2, 0)
       added a queen(2, 3)
----(3) AddQueen(3, 0)
        added a queen(3, 1)
solution {2,0,3,1,}
        removed a queen(3, 1)
       removed a queen(2, 3)
      removed a queen(1, 0)
     removed a queen(0, 2)
     added a queen(0, 3)
--(1) AddQueen(1, 0)
      added a queen(1, 0)
---(2) AddQueen(2, 0)
       added a queen(2, 2)
----(3) AddQueen(3, 0)
       removed a queen(2, 2)
      removed a queen(1, 0)
      added a queen(1, 1)
---(2) AddQueen(2, 0)
      removed a queen(1, 1)
     removed a queen(0, 3)


{designing-recursive}

o find the key step to divide a problem into parts
o find a stopping rule
o outline your algorithm
o check it with a small case
o draw a recursion tree.


{when-not-to-use-recursion} {tail-recursion}

The tail recursion when the last-executed statment is a recursive call waste space as do unnecessary
recusive call. Because when return, restore stack but terminates immediately. For this case, can
change it to iterative one. 

<example-one>

void Move(int count, int start, int finish, int temp)
{
	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
		  printf("move a disk %d from tower %d to %d.\n", count, start, finish );
		  Move( count-1, temp, finish, start );
	}
}


void Move(int count, int start, int finish, int temp)
{
	 int swap;

	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
		  printf("move a disk %d from tower %d to %d.\n", count, start, finish );
		  count--;
		  swap = start;   // swap(start, temp) how does it work???
		  start = temp;
		  temp = swap; 
	}
}


<factorial>

This is a function of non-negative integer and is defined

n! = 1          if n = 0
     n x (n-1)! if n > 0

1 when n=0
1 wnen n=1
2 when n=2
6 when n=3
...

The recursive ones:

int fact(int val)
{
	 if( val > 1 )
		 return fact(val-1)*val; 
	
	return 1;
}

// overflow when val is -1
int fact(int val)
{
	if( val == 0 )
		return 1;
	else
		return fact(val-1)*val;
}

Why is iterative ones better? Use less space and also often time as well. Looking at recursion tree,
it dwaws a chain, not a tree.

n! - (n-1)! - (n-2)! - ... - 2! - 1! - 0!

The iterative ones:
can do by reading the recursion tree [from bottom to top] instead of top to bottom. But not always as
seen at below.

1  when n=0
1  wnen n=1
2  when n=2
6  when n=3. 3x2!
24 when n=4. 4x3!
...

// what's the product value when n < 2 ?
int factorial( int n )
{
	 int count, product;
	 for( product=1, count=2; count <= n; count++)
		  product *= count;

	 return product;
}

Or use 4x3x2x1 from {ref-005}

int fact(int val)
{
	 int ret = 1;

	 while( val > 1 )
		  ret *= val--;
	
	return ret;
}


<fibonacci>

The definition is:

F0 = 0.
F1 = 1.
Fn = Fn-1 + Fn-2 for n >= 2

int fibonacci(int n)
{
	 if( n <= 0 )
		  return 0;
	 else if( n==1 )
		  return 1;
	 else
		  return fibonacci(n-1) + fibonacci(n-2);
}

Far more wasteful example when use recursive because when see recursion tree, after F5, it is done
but lost although it is required later in calculating other nodes. Fn grows exponentially with n. 

The interative version is:

current   one back(fn-1)   two back(fn-2)
2       = 1              + 0
3       = 2              + 1
4       = 3              + 2
5       = 4              + 3
6       = 5              + 4
...

int fibonacci(int n)
{
	 int n;
	 int twoback; // second previous Fi-2
	 int oneback; // previous number Fi-1
	 int current; // current Fi

	 if( n <= 0 )
		  return 0;
	 else if( n==1 )
		  return 1;
	 else
	 {
		  twoback = 0;
		  oneback = 1;

		  for( i=2; i <= n; i++ )
		  {
				current = twoback + oneback;
				twoback = oneback;
				oneback = current;
		  }

		  return current;
	 }
}


<make-a-decision>

The good starting point is to study a recursion tree.

o if it has a simple form like a chain, the iterative may be better. Such as factorial and can do by
reading the recursion tree from bottom to top instead of top to bottom.

o if it has duplicate tasks, use other data structure other than stack. fibonacci iterative version.

So use recursion when the tree appears quite bushy, with little duplication of tasks.


={============================================================================
*kt_dev_algo_008*	search: binary search

{internal-and-external}
The case when to search records in files on disk or tape, external to the computer memory. The
external searching. The records to be searched are stored entirely within the computer memory.
Internal searching.

{target}
The key for which we are searching is called the target of the search. Here concerned only with
internal search and contiguous list.

{search-analysis}
Two premises:

The number of comparisons of keys give us the most useful information when wish to estimate the
computer time to require or to compare it with some other method. This is more useful than the total
running time which is too [dependant] on programming variations and machines. This number of
comparisions of keys is [measure] of analysis.

Use average behavior and means to take each possibility once and average the results. Limit our
attention to where all the possibilities are equally likely.

{ordered-list-adt}
An ordered list is a list in which each entry contains a key, such that the keys are in order. That
is, if entry i comes before entry j in the list, then the key of entry i is less than or equal to
the key of entry j. [min...max]

... [c] ...
  <  |  =>

void InsertOrder(List* list, ListEntry x)
{
  int current;
  ListEntry currententry;

  // searching.
  for( current=0; current < ListSize(*list); current++ )
  {
    currententry = RetrieveList(*list, current);
    if( LE(x.key, currententry.key )) or if( GT( current, insert ))
      break;
  }

  // inserting. use SetPostion( current-1 );
  InsertList(list, x, current);
}


{binary-search} 
The keys in the list are already [sorted] into order. In only twenty steps, will locate any requested
key in a list containing more than a millions keys. This requires [random-access] so shall limit only
for [contiguous-implementation].

One study showed that about 90 percent of professional programmers fail to code binary search
correctly, even after working on it for a full hour.

<one-the-forgetful-version>

<do>
Write a binary search to return a postion in [bot...top] array(contig. list) when found and -1 when
not found.

int RecBinary1( List list, KeyType target, int bottom, int top );
int RecBinary1( int array[], int target, int bottom, int top );

This is one to forget the possibility that the target might be found quickly and continue, whether
target has been found or not, to search [until] when there is only one item, that is, the length or
count is 1. Then see either hit the target or not found. In other words, it makes unnecessary
iterations because fails to recognize that it can found the target before continuing to iterate to
when count is 1.


#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

typedef {
  ...
    KeyType key;	// can map any key to any entry
  ...
} ListEntry;

typedef struct list {
  int count;
  ListEntry entry[MAXLIST];
} List;

For convenience,

1 2 3 4 5 6 7 8 9 10 array index
1 2 3 4 5 6 7 8 9 10 keys

<comparison-and-first-occurance>
Depending on what comparison is used, differ on if it will find the first occurance or not when
there are many occurances in the input.

approach 01

if( GT(key, middle) ) bot = middle+1;
else top = middle;

   <=   |      > 
      middle
         (------------ do not include a middle
--------]

approach 02

if( LT(key, middle) ) top = middle-1;
else bot = middle;

   <   |     => 
      middle
         [------------ 
--------) do not include a middle

The first approach means that it will find the [first] occurance of the target if it appears more
than once in the list since it removes the upper and the lower part still remains in search. For
example, think when search 2 in the list and middle is ^:

..2222...
   ^

int RecBinary1( List list, KeyType target, int bottom, int top ) 
{ 
  int middle = -1;   // {DN} used only single var but not two.

  if( bottom < top )
  {
    middle = (top + bottom)/2;

    // {DN} used GT; means that get the first occurance and do not include the middle for next
    // interation
    if( GT( target, list.entry[ middle ].key ))
      middle = RecBinary1( list, target, middle+1, top ); // remove lower half

    // used =<; means include the middle for next iteration so not middle-1 because should have a
    // middle in the search range
    else
      middle = RecBinary1( list, target, bottom, middle ); // remove upper half
  }
  // {DN} should use 'else if' not 'if' here. Otherwise, do if for every retrun from recursive call
  else if( bottom == top )	// the list has only one entry
  {
    if( EQ( target, list.entry[ top ].key ))
      middle = top;		// {DN} to pass up
  }

  return middle;
}

To adjust the params to standard conventions:

int RecBinary1Search(List list, KeyType target)
{ return RecBinary1( list, target, 0, list.count-1 ); }

This is tail-recursion so convert it into a iterative loop. [KT] Here top and bottom are actually
indexes and when top == bottom, means there is one item left. How to check empty list? Used count-1
and check on -1:

int Binary1Search( List list, KeyType target )
{
  int bottom, middle, top;

  top = list.count-1;    // array size-1
  bottom = 0;

  while( bottom < top )
  {
    middle = ( bottom + top )/2;

    if( GT( target, list.entry[middle].key ))
      bottom = middle+1;
    else
      top = middle;
  }

  // search for an emptry list always fails
  if( top == -1 )
    return -1;

  if( EQ( target, list.entry[top].key ))
    return top;
  else
    return -1;
}

<code-example>
Used the simple array and moved up the check of empty list since this is a check on input but not on
calc during running.

#include < iostream>

using namespace std;

#define EQ(a,b) ((a) == (b))
#define GT(a,b) ((a) > (b))

typedef struct list {
  int count;
  int entry[10];
} List;

int Binary1Search( List list, int target )
{
  int bottom, middle, top;

  top = list.count-1;
  bottom = 0;

  // search for an emptry list always fails
  if( top == -1 )
  {
    cout << "list is empty" << endl;
    return -1;
  }

  while( bottom < top )
  {
    middle = ( bottom + top )/2;
    cout << "middle is " << middle << endl;

    if( GT( target, list.entry[middle]))
      bottom = middle+1;
    else
      top = middle;
  }

  if( EQ( target, list.entry[top]))
    return top;
  else
    return -1;
}

int main()
{
  int ret;
  List arr;

  for(int i=0; i < 10; ++i)
    arr.entry[i] = i;

  arr.count = 10;
  //arr.count = 0;

  ret = Binary1Search( arr, 4 );

  cout << "ret = " << ret << endl;

  return 0;
}


<two-the-equality-version>
To improve the forgetful version, check at each stage to see if it has found the target. This has
only LT and GT on checks and the equality, that is, found in the middle, is found when LT or GT is
false.

This may return [any-instance] of the target if target appears more than once in the list.

See that there is no EQ check in this function. When there is only one element but still not equal
then becomes bot > top and the last recursion returns -1. Hence not found. Otherwise, return middle
which means found.

int RecBinary2( List list, KeyType target, int bottom, int top )
{
  int middle = -1;

  if( bottom <= top )		// {DN} <=. when bottom == top, middle, bottom, and top are the same.
  {
    middle = (top+bottom)/2;

    if( LT( target, list.entry[ middle ].key ))
      middle = RecBinary2( list, target, bottom, middle-1); // {DN} middle-1
    else if ( GT( target, list.entry[ middle ].key ))
      middle = RecBinary2( list, target, middle+1, top);		// {DN} middle+1
  }

  return middle;
}

int Binary2Search( List list, KeyType target )
{
  int bottom, middle, top;

  top = list.count-1;
  bottom = 0;

  while( bottom <= top )
  {
    middle = (bottom+top)/2;

    if( EQ( target, list.entry[middle].key ))
      return middle;
    else if( LT( target, list.entry[middle].key ))
      top = middle-1;
    else // if ( GT( target, list.entry[middle].key ))
      bottom = middle+1;
  }

  return -1;
}

<binary-search-comparison-which-is-better> {comparison-tree}
Which one of these will do fewer comparisons? Binary2 will if found in the beginning of the search
but do 2 comparisons at each iteration.

Can draw a comparison tree to compare.

                   (5) ; root node representing a key
     '<='                       '>'
     (3)                        (8)
'<='       '>'
(2)        (4)
      '<='      '>'
...   (4)       (5)
    '=' '!='  '=' '!='
... [4] [F]   [5] [F]

For n=10, Binary1 does slightly fewer comparisons both for successful and for unsuccessful searches.
However, an optimizing compiler may not do as much work as two full comparisons. In that case,
Binary2 may be slightly better choice.

<binary-search-logn>
Sequential search needs O(n) and binary search needs O(logn) [comparisons] which is excellent since
log n grows very slowly as n increases.

These are only approximate. For large values of n, the difference between log n and log(n+1) is
insignificant and (n+1)/n is very nearly 1. Hence can simply results as:

						Successful 		Unsuccessful search
Binary1Search 		logn + 1			logn + 1
Binary2Search 		2logn-3			2logn

All four cases are proportional to logn and the coefficients of logn are the number of comparisons
inside the loop.

To conclude, two points:

o For large problems, Binary1(the-forgetful-version) is better and for small problems sequential
search is better since when looks at logn and n graph, logn is bigger for small n. Binary2 may be
better when there is optimizing compiler.

o Binary1 pickes up the first occurance when there are many same occurances but Binary2 don't.

<big-o-notation>
To present the operation count or running time for algorithm

O(1) to mean computing time that is bounded by a constant (not dependent on n)
O(n) to mean that the time is directly propotional to n. called liner time.
O(n2) called quadratic time
O(n3) called cubic time
O(2n) called exponential

<other-version>
See how to check empty list when this is array. However, this is not necessary when see the other
example code below. Why? Can have checks to see if start or end are negative than simply on end.

#include < iostream>

#define GT(x,y) ((x)>(y))
#define EQ(x,y) ((x)==(y))

int bsearch_one( int* list, int start, int end, int target )
{
  int pos = -1;

  // when the list is empty
  if( end == -1 )
  {
    std::cout << "list is empty" << std::endl;
    return pos;
  }

  while( start < end )
  {
    int middle = (start+end)/2;

    if( GT(target, list[middle] ) )
    {
      start = middle+1;
    }
    else
      end = middle;
  }

  // can remove check on start == end
  if( start == end )
  {
    if( EQ( target, list[end] ))
      pos = end;
  }

  return pos;
}

int main()
{
  int ret = -1;

  int brr[] = {};
  int bsize = ( sizeof(brr)/sizeof(brr[0]));

  // bsearch_one( , , length-1, );
  ret = bsearch_one( brr, 0, bsize-1, 15 );    ~
    std::cout << "returned pos is " << ret << std::endl; 

  int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
  int size = ( sizeof(arr)/sizeof(arr[0]));

  ret = bsearch_one( arr, 0, size-1, 15 );
  std::cout << "returned pos is " << ret << std::endl; 

  ret = bsearch_one( arr, 0, size-1, 17 );
  std::cout << "returned pos is " << ret << std::endl; 

  ret = bsearch_one( arr, 0, size-1, 2 );
  std::cout << "returned pos is " << ret << std::endl; 

  ret = bsearch_one( arr, 0, size-1, 99 );
  std::cout << "returned pos is " << ret << std::endl; 
}


//
// From p120 in cracking the coding interview. This is the Binary2.
//
int binary_search(int arr[], int length, int sought)
{
  // indexes
  int low = 0;
  int high = length-1;

  // int high = sizeof(arr)/sizeof(int)-1; Note: THIS DOESN'T WORK!
  int mid;

  // Note for condition.
  while( low <= high )
  {
    mid = (low+high)/2;

    if(arr[mid] < sought)
      low = mid+1; // exclues mid by +1
    else if( arr[mid] > sought)
      high = mid-1; // excludes mid by -1. throw upper
    else
      return mid;
  }

  return -1; //error
}


/* example from Primus. what is the type of text?
 */

auto begin = text.begin(), end = text.end();
auto middle = text.begin() + (end-begin)/2;

// while there are still elements to look at and we haven't yet found sought.
while( middle != end && *middle != sought )
{
	if( sought < *middle )
	    end = middle;              # throw upper
	else
		 begin = middle+1;

	middle = begin + ( end - begin )/2;
}

// when no found, begin, end, and middle are the same.


==============================================================================
*kt_dev_algo_009*	sort

Here consider only internal sorting. Analysis concentrate on two actions: comparison and changing
pointers or moving entries. 

The question from {ref-004}: 

Given a very large array of Person objects, sort the people in increasing order of age.

We are given two interesting bits of knowledge here. 1: A large array, so efficiency is very
important. 2: Sorting based on ages, so we know the values are in a small range.

By scanning through the various sorting algorithms, we might notice that bucket sort(radixsort)
would be a perfect candidate for this problem. In fact, can make the buckets small(just 1 year
each) and get O(n) running time.

The merge, quick, and bucket are the most commonly used in interviews.


{insertion-sort}
From {ordered-list-adt}, the ordered list is ADT which has three more operations: retrieve, insert
and sort. The retrieval is the same as searching and finding the place where to insert is searching.
Also it must be ordered after insertion and deletion.

<why-sequential-is-better>
For a [contiguous] ordered list and ordered insertion, then do binary search to find the position
sinces it is ordered and move entries. Finally insert new entry into the list. Since so much time is
needed to move entries no matter how the search is done, it turns out in many cases to be just as
fast to use sequential search as binary search: the search and the movement of entries can be
combined in a single loop, thereby reducing the overhead.

{Q} how can use binary search to find a position which is less than or greater than a key? Think
that unsorted set and sorted set and do binary search on sorted set with an entry from unsorted set.
To do this, change binary search function to return any of bot, top, or middle whether or not binary
search found a key since the returned position is either the last occurance of the key or the
position which is less than big entry in the sorted set. <= [m] > when use GT in binary search. Then
make a space at the position by moving down and insert.

Move one entries from unsorted list to sorted list and use two observations: a list of length 1 is
automatically ordered.

init order     ...

[hen] sorted   [cow]           [cat]
$cow$ unsorted [hen] sorted    [cow]
$cat$          $cat$ unsoerted [hen] sorted
$ram$          $ram$           $ram$ unsorted
$ewe$          $ewe$           $ewe$
$dog$          $dog$           $dog$


<do>

Write the below function using int array:
void InsertionSort(int* arr, int length);

<ref-example>

// contiguous version from the book
void InsertionSort(List* list)
{
  Position    fu;      // the start of unsorted
  Position    place;
  ListEntry   current;

  // fu-2 (place-1)
  // fu-1 (place)   sorted
  // fu   (place+1) unsorted

  for( fu = 1; fu < list->count; fu++ )
  {
    // [DN] This 'if' is important. if the first unsorted entry is less than the last sorted entry,
    // then should be before the last sorted. Otherwise do not need to insert. Save it and find
    // pos to insert

    if( LT( list->entry[fu].key, list->entry[ fu-1 ].key ))
    {
      current = list->entry[fu];

      // search from the end of ordered list. Here do move and search in the same loop.
      for( place = fu-1; place >= 0; place-- )
      {
        // move down
        list->entry[ place+1 ] = list->entry[ place ];

        // since already compared with place(fu-1) so from place-1, can save one comparison
        // [DN] Here assumes that place is signed and so must have place==0 check. If not, when
        // place is 0 and can access entry[-1].
        if( place == 0 || LT( list->entry[ place-1 ].key, current.key ))
          break;
      }

      list->entry[place] = current;
    }
  }
}

<code-example> 

 -> Search from the beginning. If see smaller than key, continue and if not, stop.
 0 1 2 3 4 5 6 7 ...
      <- Search from the end. If see smaller than key, stop and if not, continue.

#include <iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

bool sort_insert( int* array, int length )
{
  bool status = false;
  int posUnsorted = 0;
  int posSorted = 0;
  int itemUnsorted = 0;

  // when the list is empty
  // if( length == 0 )
  // {
  //   std::cout << "input is empty" << std::endl;
  //   return false;
  // }

  if( length > 1 )
  {
    // move forward through unsorted part to pick up a unsorted
    for( posUnsorted = 1; posUnsorted < length; posUnsorted++ )
    {
      // only if a unsorted is greater then the last sorted
      if( LT( array[ posUnsorted ], array[ posUnsorted-1]))
      {
        // save unsorted item
        itemUnsorted = array[posUnsorted];

        // search back through sorted part to find a place to insert
        // [KT] Here also assumes signed int but it will do the same comparison which is already done in
        // the if. Therefore, have one more comparison than the ref example.

        for( posSorted = posUnsorted-1; posSorted >= 0; posSorted-- )
        {
          if( GT(itemUnsorted, array[posSorted] ))
            break;

          // move down items.
          array[posSorted+1] = array[posSorted];
        }

        array[posSorted+1] = itemUnsorted;
      }
    }

    status = true;
  }

  return status;
}

int main()
{
  // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
  int arr[] = { 33, 2, 31, 5, 30, 6, 12, 10, 13, 15, 17, 29, 3 };
  int size = ( sizeof(arr)/sizeof(arr[0]));

  bool ret = sort_insert( arr, size );

  std::cout << "{ "; 

  for(int idx = 0; idx < size; idx++)
    std::cout << arr[idx] << ", "; 

  std::cout << "}" << std::endl; 
}

<code-eample>
Here used unsigned for position. Careful about array index: if there is no check on sorted==1 then
use a minus index.

#include < iostream>

#define LT(x,y) ((x)<(y))
#define GT(x,y) ((x)>(y))

void isort( int length, int* arr )
{
  for( int idx = 1; idx < length; idx++)
  {
    // need to find a place in the sorted
    if( LT( arr[idx], arr[idx-1] ))
    {
      // save it
      int temp = arr[idx];
      int sorted;

      // scan back in the sorted
      for( sorted = idx; sorted > 0; sorted--)
      {
        // move
        arr[sorted] = arr[sorted-1];

        if( sorted ==1 || GT(temp, arr[sorted-2]))
          break;

      }
      arr[sorted-1] = temp;
      // std::cout << "arr[" << sorted << "] = " << temp << std::endl;
    }
  }
}

int main()
{
  // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
  int arr[] = { 33, 2, 31, 5, 30, 6, 12, 10, 13, 15, 17, 29, 3 };
  int size = ( sizeof(arr)/sizeof(arr[0]));

  isort( size, arr );

  std::cout << "{ "; 

  for(int idx = 0; idx < size; idx++)
    std::cout << arr[idx] << ", "; 

  std::cout << "}" << std::endl; 
}

<comparison-which-is-better>
The ref-example is better since it will one less comparison in inner for loop using checks on place==0 and
the number of comparison is sorted-1.

Key observations: 
1) a list of length 1 is automatically ordered.
2) search and insert only when the first of unsorted < the last of sorted. If not, it is sorted and
just increase a loop.
3) variable naming is important since manage array index is tricky and confusing. also index of
unsorted list is only needed.

For efficiency:
Can save one comparison. move down first and compare with sorted-1.


{selection-sort}
The insertion-sort has major disadvantage: even after most entries have been sorted properly into
the first part of the list, the insertion of a later entry may require that many of them should be
moved because the position of each entry is not a [final-position]. Far more efficient if an entry
being moved could be placed in its final position. 

Scan unsorted list to find the one that comes last in order (largest, alphabetical in this case).
Swap this with the last one of the unsorted list. Repeat this until no more items in the unsorted
list.

$hen$ scan and $hen$ *  $ewe$    ...
$cow$ swap     $cow$    $cow$
$cat$          $cat$    $cat$
$ram$ *        $dog$    $dog$ unsorted
$ewe$          $ewe$ *  [hen] sorted
$dog$ *        [ram]    [ram]

From {ref-004}, can do the opposite. Find the smallest and swap it with the first. Repeat it until
it is sorted.


<do>
Write the below function using int array:

void SelectionSort(int* arr, int length);

// find the position of the largest key in the sublist
Position MaxKey(int begin, int end, int* arr);

// swap two entries in the contiguous list
void Swap(int begin, int end, int* arr);


<ref-example>
void SelectionSort(List* list);

Position MaxKey(Position low, Position high, List* list);

void Swap(Position low, Position high, List* list);

<code-example>
#include < iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

typedef int Position;
typedef int Entry;

// expects start and end in index
Position findPosofMax( Position start, Position end, int* array)
{
  Entry 	entry		= -1;	// [DN] see init
  Position posMax	= -1;

  for ( Position current = start; current <= end ; current++) {
    if( GT( array[current], entry ))
    {
      posMax 	= current;
      entry 	= array[current];
    }
  }

  return posMax;
}

// expects start and end in index
void swapEntry( Position x, Position y, int* array)
{
  int xval = array[x];

  array[x] = array[y];
  array[y] = xval;
}

// expects the length of array. NO if in for loop.
void sortSelection(int length, int* array)
{
  for( ;length > 1; length--) {
    Position posMax = findPosofMax( 0, length-1, array );
    // std::cout << "posMax:length-1 = (" << posMax << ", " << length-1 << ")" << std::endl;
    swapEntry( posMax, length-1, array );
  }
}

int main()
{
  // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
  int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 3 };
  int size = ( sizeof(arr)/sizeof(arr[0]));

  sortSelection(size, arr );

  std::cout << "{ "; 

  for(int idx = 0; idx < size; idx++)
    std::cout << arr[idx] << ", "; 

  std::cout << "}" << std::endl; 
}

<insertion-vs-selection>
The selection sort is useful for contiguous list with large entries for which movement of entries is
expensive since it uses fewer moves. The selection do more on searching keys.

If the entries are small, or if the list is linked, so that only pointers need be changed to sort
the list, then insertion-sort is usually faster than selection-sort. The insertion do more on
moving. For many applications, insertion can prove to be the best choice as easy to write and
maintain, runs efficiently for short list. Even for long list, if they are nearly in the correct
order, insertion will be very efficient. 

The selection do comparisons: (n-1)x(n-2)x(n-3)x...x2x1 = n(n-1)/2 = O(n2). But the insertion do
O(n2) for worst case.


{devide-and-conquer-sort}
Sort(list)
{
  if the list has length greater than 1 then
  {
    partition the list into lowlist and highlist
    Sort(lowlist);
    Sort(highlist);
    Combine(lowlist, highlist);
  }
}

It is much easier to sort short list than long ones. Two methods which has two basic actions:
partitioning and combining. mergesort does more work in combining and quicksort does more work in
partitioning.


{mergesort} <mergesort-nlogn>
This is recursion-tree of 7 numbers. Combine() or merge part do most of work and sort. This is an
excellent method for [external-sorting], linked list in random order but spends significant time
finding the center of the list. For contiguous list, not an unqualified success because needs one of
extra space(temp) to merge, computer time, or programming effort in merging two contiguous list. 

The best time is O(nlogn)

                     start[down]   finish[up]
           26 33 35 29 19 12 22 () 12 19 22 26 29 33 35
           list        second

      26 33 35 29 () 26 29 33 35             19 12 22 () 12 19 22
      list  second                           list

  26 33 () 26 33   35 29 () 29 35        ...
  list             list

26 [] 33 []        35 [] 29 [] 

where [] is leaf and () is node

<merge-linked> not contiguous list
// sort linked list and the keys in all the entries are sorted into increasing order.
void MergeSort(List* list);

// divide the list into two parts. If list has an odd number of entries, then its first half will be
// one entry larger than its second
void Divide(List* list, List* secondhalf);

// merge two list producing a thrid list. first and second are ordered linked list. out is an
// ordered list containing all entries that were in first and second. The first and second have been
// destroyed.
void Merge(List* list, List* second, List* out);

<ref-example>
From the reference book. Here list and secondhalf are list structure having a head so not a problem
when run recursive tree.

void MergeSort(List* list)
{
	List secondhalf;

	if( ListSize(list) > 1 )					// is there a need to sort? 2 at least
	{
		Divide( list, &secondhalf );
		MergeSort(list);							// when list size is 2, be called with 1 and has no effect
		MergeSort(&secondhalf);
		Merge( list, &secondhalf, list );	// see list used as out
	}
}

<find-middle-in-a-linked-list> <tortous-and-hare-approach>
This is interesting since it shows how to find the middle of the simple list. When entries are odd
numbers, the first half is [one-larger]. 

For 4 entries:

[ ] [ ] [ ] [ ] x
m/c 
 ----------------
     c   c
     m       c
 ----------------
	          c  c
				 nothing
 ----------------
				    end

[ ] [ ] x
        [ ] [ ] x

For 5 entries:

[ ] [ ] [ ] [ ] [ ] x
m/c 
 ----------------
     c   c
     m       c        (1, 3)
 ----------------
	          c  c
         m          c (2, 5)
 ----------------
                    end

[ ] [ ] [ ]x
            [ ] [ ] x

For 6 entries:

m/c 
 ----------------
     c   c
     m       c
 ----------------
	          c  c
         m          c
 ----------------
                    c  c
						  notining
 ----------------
                       end

[ ] [ ] [ ]x
            [ ] [ ] [ ]x

<better-names>
o void Divide(List* in_left, List* out_right) seems better since it will divide in_left list into
in_left for left half and out_right for right half

o Here do not consider the size change of list when divide because it is okay as long as input list
has more than one entry.

void Divide(List* list, List* secondhalf)
{
  ListNode *current, *midpoint;

  if((midpoint = list->head) == NULL )	// must use ()
    secondhalf->head = NULL;
  else
  {
    for( current = midpoint->next; current; )
    {
      current = current->next;
      // cannot move two in a single shot since do not know when one is the end.
      if(current)
      {
        midpoint = midpoint->next;
        current = current->next;
      }
    }
    // breaks up a list into two
    secondhalf->head = midpoint->next;	// the second half
    midpoint->next = NULL;					// the first half
  }
}

<move-two-for-fast>
Divide( List* left, List* right )
{
  ListNode *pmid, *pcur;

  pmid = pcur = left->head;

  while( pcur )
  {
    pcur = pcur->next;

    if( pcur )
    {
      pmid = pmid->next;
      pcur = pcur->next;
    }
  }
  ...
}

This do not work as expected and see the below to see why.

Divide( List* left, List* right )
{
  ListNode *pmid, *pcur;

  pmid = pcur = left->head;

  while( pcur )
  {
    pcur = pcur->next;     [inc]

    if( pcur )
    {
      pmid = pmid->next;
      pcur = pcur->next;   [inc]
    }
  }
  ...
}

This would seem okay since there are two moves for the fast but not for the first time when enters a
loop. The difference from the reference code is:

Divide( List* left, List* right )
{
  ListNode *pmid, *pcur;

  pmid = pcur = left->head;

  for( pcur = pcur->next; pcur; )   [inc]
  {
    pcur = pcur->next;              [inc]

    if( pcur )
    {
      pmid = pmid->next;
      pcur = pcur->next;            [inc]
    }
  }
  ...
}

Divide( List* left, List* right )
{
  ListNode *pmid, *pcur;

  pmid = pcur = left->head;

  pcur = pcur->next;       [inc]

  while( pcur )
  {
    pcur = pcur->next;     [inc]

    if( pcur )
    {
      pmid = pmid->next;
      pcur = pcur->next;   [inc]
    }
  }
  ...
}

Two points:
o See the difference between for and while statement; The for statement makes a clean code but can
make a mistake.
o See that the fast always makes two moves.

<combine>
See that first and out can be the same list since first used one step before out list

// Seems better to have void Combine(List* left, List* right, List* out);
void Merge(List* first, List* second, List* out)
{
  ListNode *p1, *p2;      // pointers to traverse first and second list
  ListNode *lastsorted;   // always points to last node of sorted list

  // [DN] if one of both lists is null, then no need to merge
  if( !first->head )
    *out = *second;
  else if( !second->head )
    *out = *first;
  else
  {
    p1 = first->head; p2 = second->head;

    // [DN]
    // firstly set the head of the merged output list which had one sorted item since already made one comparison.
    if( LE(p1->entry.key, p2->entry.key))
    {
      *out = *first;
      p1 = p1->next;
    }
    else
    {
      *out = *second;
      p2 = p2->next;
    }

    lastsorted = out->head;

    // sort and build the merged list
    while(p1&&p2)
    {
      if( LE(p1->entry.key, p2->entry.key))
      {
        lastsorted->next = p1;	// make a link
        lastsorted = p1;			// move a pointer
        p1 = p1->next;				// move to next candidate
      }
      else
      {
        lastsorted->next = p2;
        lastsorted = p2;
        p2 = p2->next;
      }
    }

    // [DN]
    // whichever lists is used up, if all items are added to the sorted list and reached to the
    // end then simply add remaining list to that end because the remaining list is bigger than
    // the lastsorted. For example, think [26,29,33,35] and [12,19,22] in the above example tree.
    if(p1)
      lastsorted->next = p1;
    else
      lastsorted->next = p2;
  }
}

<merge-contiguous>
This is a java code from {ref-004}.

void MergeSort(int[] array, int low, int high)
{
  if (low < high)		// 2 at least
  {
    int middle = (low+high)/2;
    MergeSort( array, low, middle );      // sort left
    MergeSort( array, middle+1, high );   // sort right
    Merge( array, low, middle, high );    // merge them
  }
}

small                 big
low        middle     high
[0.........x..........x]
left        right(middle+1)

void Merge( int[] array, int low, int middle, int high )
{
	int[] = helper = new int[array.length];

	for( int i = low; i <= high; i++ )
		helper[i] = array[i];

	int helperLeft = low, helperRight = middle+1;
	int current = low;

	while( helperLeft <= middle && helperRight <= high )
	{
		if( helper[helperLeft] <= helper[helperRight])	// [KT] used <=
		{
			array[current] = helper[helperLeft];
			helperLeft++;
		}
		else
		{
			array[current] = helper[helperRight];
			helperRight++;
		}

		current++;
	}

	// Similar to the linked version, should handle the remaining items. Why Left? Since all items
	// are already copied to the temp array and if done for the left part which has items with small
	// keys then no need to do the right part. So only check on left part.

	int remaining = middle - helperLeft;
	for( int i = 0; i <= remaining; i++ )
		array[current+i] = helper[helperLeft+i];
}


<code-eample>
When tried to do the same myself, got crashes.

#include < iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

typedef int Position;
typedef int Entry;

unsigned int depthRecursion;
void PrintDepth( bool dash, unsigned int depth )
{
  for( unsigned int i=0; i <= depth; ++i)
  {
    if(dash)
      std::cout << "--";
    else
      std::cout << "  ";
  }

  if(dash)
    std::cout << "(" << depth << ") ";
  else
    std::cout << "      ";
}

// see the use of the same array in recursion but within the [start,end] for each iteration.
void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
  // have temp space for unsorted
  Entry out[length];
  int posLeft = start, posRight = middle+1;

  // [KT] got a crash when not init with start like int posCurrent;
  int posCurrent = start;

  PrintDepth( false, depthRecursion );
  std::cout << "Mege(" << length << ", " << start << ", " << middle << ", " << end << ")" << std::endl;
	
  // copy entries from array and out
  for(int pos = start; pos <= end; pos++)
    out[pos] = array[pos];

  // sort and copy entries
  while( posLeft <= middle && posRight <= end )
  {
    // [KT] use of LT which is different from the above but not matter. This sort cover the same
    // elements.
    if( LT( out[posLeft], out[posRight] ))
    {
      // [KT] use of posCurrent
      array[posCurrent] = out[posLeft];
      posLeft++;
    }
    else
    {
      array[posCurrent] = out[posRight];
      posRight++;
    }

    posCurrent++;

    // refactored
    // if( LT( out[posLeft], out[posRight] ))
    //		array[posCurrent++] = out[posLeft++];
    // else
    //		array[posCurrent++] = out[posRight++];
  }
	
  // [KT] 1st crash error since posCurrent can bigger if middle is big enough since used pos <=
  // middle but not pos <= remaining
  //for( int pos = middle - posLeft; pos <= middle;)
  //	array[posCurrent++] = out[pos++];

  // [KT] 2nd crash error as the same above.
  //for( int pos = middle - posLeft; pos <= middle; pos++)
  //	array[posCurrent+pos] = out[posLeft+pos];

  // copy remaining entries in the left if they are. Only need to check on the left because the
  // right is already in array.
  int remaining = middle - posLeft;
  for( int pos = 0; pos <= remaining; pos++)
    array[posCurrent+pos] = out[posLeft+pos];
}

// this includes [start, end] and need length arg since need to have temp space.
void sortMerge( Entry* array, Position length, Position start, Position end )
{
  if( start < end )
  {
    depthRecursion++;
    PrintDepth( true, depthRecursion );

    int middle = (start + end )/2;

    // PrintDepth( false, depthRecursion );
    std::cout << "sortMerge(" << length << ", " << start << ", " << middle << ", " << end << ")" << std::endl;

    sortMerge( array, length, start, middle ); // [start, middle]
    sortMerge( array, length, middle+1, end ); // [middle+1, end]
    Merge( array, length, start, middle, end);

    depthRecursion--;
  }
}


int main()
{
  // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
  int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 3 };
  int size = ( sizeof(arr)/sizeof(arr[0]));

  sortMerge( arr, size, 0, size-1 );

  std::cout << "{ "; 

  for(int idx = 0; idx < size; idx++)
    std::cout << arr[idx] << ", "; 

  std::cout << "}" << std::endl; 
}


{Q}
In an attempt to save sapce in Merge and changed to have a temp[start,end]. But didn't work as
planned. More wriedly, why size in main changes? Cannot reduce the size of temp array since combine
call use position left and right without adjustment when the sub array near to the right end which
has big start and end. So use the same length and the eaiser code.

void sortMerge( Entry* array, Position length, Position start, Position end )
{
  if( start < end )
  {
    depthRecursion++;
    PrintDepth( true, depthRecursion );

    int middle = (start + end )/2;

    // PrintDepth( false, depthRecursion );
    std::cout << "sortMerge(" << length << ", " << start << ", " << middle << ", " << end << ")" << std::endl;

    //sortMerge( array, length, start, middle );
    //sortMerge( array, length, middle+1, end );
    sortMerge( array, middle-start+1, start, middle );
    sortMerge( array, end-(middle+1)-1, middle+1, end );
    Merge( array, length, start, middle, end);

    depthRecursion--;
  }
}


int main()
{
  // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
  // int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 3 };
  int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 6 };
  int size = ( sizeof(arr)/sizeof(arr[0]));

  std::cout << "size: " << size << std::endl;

  sortMerge( arr, size, 0, size-1 );

  std::cout << "size: " << size << std::endl;

  std::cout << "{ "; 

  for(int idx = 0; idx < size; idx++)
    std::cout << arr[idx] << ", "; 

  std::cout << "}" << std::endl; 
}

size: 13
----(1) sortMerge(13, 0, 6, 12)
------(2) sortMerge(7, 0, 3, 6)
--------(3) sortMerge(4, 0, 1, 3)
----------(4) sortMerge(2, 0, 0, 1)
                Mege(2, 0, 0, 1)
----------(4) sortMerge(0, 2, 2, 3)
                Mege(0, 2, 2, 3)
              Mege(4, 0, 1, 3)
--------(3) sortMerge(1, 4, 5, 6)
----------(4) sortMerge(2, 4, 4, 5)
                Mege(2, 4, 4, 5)
              Mege(1, 4, 5, 6)
            Mege(7, 0, 3, 6)
------(2) sortMerge(4, 7, 9, 12)
--------(3) sortMerge(3, 7, 8, 9)
----------(4) sortMerge(2, 7, 7, 8)
                Mege(2, 7, 7, 8)
              Mege(3, 7, 8, 9)
--------(3) sortMerge(1, 10, 11, 12)
----------(4) sortMerge(2, 10, 10, 11)
                Mege(2, 10, 10, 11)
              Mege(1, 10, 11, 12)
            Mege(4, 7, 9, 12)
          Mege(13, 0, 6, 12)
size: 2 ~
{ 2, 5, }


<excution-tree-or-recursion-tree>
----(1) sortMerge(13, 0, 6, 12)
------(2) sortMerge(13, 0, 3, 6)
--------(3) sortMerge(13, 0, 1, 3)
----------(4) sortMerge(13, 0, 0, 1)
                Mege(13, 0, 0, 1)
----------(4) sortMerge(13, 2, 2, 3)
                Mege(13, 2, 2, 3)
              Mege(13, 0, 1, 3)
--------(3) sortMerge(13, 4, 5, 6)
----------(4) sortMerge(13, 4, 4, 5)
                Mege(13, 4, 4, 5)
              Mege(13, 4, 5, 6)
            Mege(13, 0, 3, 6)
------(2) sortMerge(13, 7, 9, 12)
--------(3) sortMerge(13, 7, 8, 9)
----------(4) sortMerge(13, 7, 7, 8)
                Mege(13, 7, 7, 8)
              Mege(13, 7, 8, 9)
--------(3) sortMerge(13, 10, 11, 12)
----------(4) sortMerge(13, 10, 10, 11)
                Mege(13, 10, 10, 11)
              Mege(13, 10, 11, 12)
            Mege(13, 7, 9, 12)
          Mege(13, 0, 6, 12)
{ 2, 5, 6, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33, }


{quicksort}
This is great [for-contiguous-list] and the contiguous list is the most important application for
quicksort because prove to be fast and has the advantage over contiguous mergesort of not requiring
extra space, complicated and difficult programming effort. Unlike mergesort, the size of the sublist
cannot be predicted in advance. Poor worst case, O(n2) and excellent average case O(nlogn).

It uses swapping entries and keep sublists(subsets) in the same list so no extra space. It is sorted
during partition and choose different pivot for each sublist. The sublists are not sorted and entry
is not in the final position during running. [DN] The final step of combining sorted list is not
necessary.

<partioning> <choice-of-pivot> <worst-case>
There are several methods but the algorithm we develop is much simpler and easier to understand, and
not slow; in fact it does the smallest possible number of key comparisons of any partitioning
algorithm. This algorithm uses the middle as a pivot and swap it to the first, and do partitioning.
So any can be a pivot because can choose any entry and swap it with the first entry before
beginning the loop. 

The first is often a poor choice for pivot when the list is already sorted and one of the sublists
will be empty. Hence the careful choice of pivot to make this worst case unlikey: use near the
center of list as a pivot in the hope that it will partition the keys so that about half come on
each side of the pivot. 

The average when applied to lists in random order turns out to be the best of any sorting
algorithms.

[KT] Why is it better to have about half on each side? Otherwise, will end up with long and narrow
comparison tree, meaning a chain which is a bad case for recursion. The worst case is when the keys
are in their natural order or in their reverse order if choose the pivot as the first or the last
key. 

To allow for the possibility that more than one entry has key equal to p, the left of pivotpos have
keys strictly less than p and the right have greater than or equal to p.

|  < p   | p |    >= p      |
low                      high

Suppose that pivot starts in the first position and leave it there temporarily then the list has
following property in the middle of loop: loop invariant

| p |  < p  *|   >= p   |* ?   |
low         lastsmall    i

When inspect i, there are two cases: if the entry is >= p then simply increase i and maintain the
property. if the entry < p then restore the property by increasing pivotpos(lastsmall) and swapping
it with entry i.

| p |  < p   |*| >= p   |*| ?  |
low           lastsmall  i

When loop ends, will have:

| p |           < p     |      >= p  | 
low                    lastsmall     

Then swap(low, lastsmall) and get 

|      < p     | p |      >= p       | 

 [DN] The important property is to have sublists which are < and >= and each sublist is not sorted.
 Hence swapping is possible.

<ref-example>
Choose the first number on a list as the pivot:

[26] 33 35 29 19 12 22 [pivot]

less than 26    more than 26
[19] 12 22      [33] 35 29

...

// execution-trace
Sort( 26, 33, 35, 29, 19, 12, 22 )
  Partition into ( 19, 12, 22 ) and ( 33, 35, 29 ); pivot = 26
  Sort( 19, 12, 22 )
    Partition into ( 12 ) and ( 22 ); pivot = 19
    Sort(12)
    Sort(22)
    Combine into (12,19,22)

  Sort( 33, 35, 29 )
    Partition into ( 29 ) and ( 35 ); pivot = 33
    Sort(29)
    Sort(35)
    Combine into (29,33,35)

	Combine into (12,19,22,26,29,33,35)

// recustion-tree
The two calls to Sort as each level are shown as the children of the vertex and the sublist which
need no sorting, are drawn as the leaves.

           () 26

     () 19      () 33

 []12 []22   []29 []35

<ref-code>
// excludes a pivot itself when calls next
void RecQuickSort( List* list, Position low, Position high )
{
  Position pivotpos;

  if( low < high )
  {
    pivotpos = Partition( list, low, high );
    RecQuickSort( list, low, pivotpos-1 );
    RecQuickSort( list, pivotpos+1, high );
  }
}

// this returns the last index of less-than sublist
Position Partition(List* list, Position low, Position high)
{
  ListEntry pivot;
  Position i, lastsmall, pivotpos;

  Swap( low, (low+high)/2, list );
  pivot = list->entry[low];
  pivotpos = low;
  for( i=low+1; i <= high; i++ )
    if( LT( list->entry[i].key, pivot.key ))
      Swap( ++pivotpos, i, list );

  Swap(low, pivotpos, list);
  return pivotpos;
}

<code-example>
#include <iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

typedef int Position;
typedef int Entry;

unsigned int depthRecursion;
void PrintDepth( bool dash, unsigned int depth )
{
  for( unsigned int i=0; i <= depth; ++i)
  {
    if(dash)
      std::cout << "--";
    else
      std::cout << "  ";
  }

  if(dash)
    std::cout << "(" << depth << ") ";
  else
    std::cout << "      ";
}

// expects start and end in index
void swapEntry( Position x, Position y, int* array)
{
  int xval = array[x];

  array[x] = array[y];
  array[y] = xval;
}

Position buildPartion( Entry* array, Position start, Position end )
{
  Position idx, posPivot;
  Entry entryPivot;

  // [DN] use the center as a pivot
  swapEntry( start, (start+end)/2, array );

  // [DN] from start+1 since start is a pivot
  for( idx = start+1, posPivot = start, entryPivot = array[start]; idx <= end; idx++ )
  {
    if( LT( array[idx], entryPivot ))
      swapEntry( ++posPivot, idx, array );  // [DN] Happes swap on the same index
  }

  // [DN] swap back
  swapEntry( start, posPivot, array );

  PrintDepth( false, depthRecursion );
  std::cout << "buildPartion(" << start << ", " << end << ") returned posPivot = " << posPivot << std::endl;

  // this posPivot varies depending on input
  return posPivot;
}

// expects the length of array
void sortQuick( Entry* array, Position start, Position end )
{
	Position posPivot;

	if( start < end )
	{
		depthRecursion++;
		PrintDepth( true, depthRecursion );

		std::cout << "sortQuick(" << start << ", " << end << ")" << std::endl;

		posPivot = buildPartion( array, start, end );
		sortQuick( array, start, posPivot-1 );  // [DN] See +1 and -1.
		sortQuick( array, posPivot+1, end );

		depthRecursion--;
	}
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
	int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 6 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

   sortQuick( arr, 0, size-1 );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
      std::cout << arr[idx] << ", "; 

   std::cout << "}" << std::endl; 
}

<recustion-tree>
----(1) sortQuick(0, 12)
          buildPartion(0, 12) returned posPivot = 5
------(2) sortQuick(0, 4)
            buildPartion(0, 4) returned posPivot = 1
--------(3) sortQuick(2, 4)
              buildPartion(2, 4) returned posPivot = 2
----------(4) sortQuick(3, 4)
                buildPartion(3, 4) returned posPivot = 3
------(2) sortQuick(6, 12)
            buildPartion(6, 12) returned posPivot = 7
--------(3) sortQuick(8, 12)
              buildPartion(8, 12) returned posPivot = 8
----------(4) sortQuick(9, 12)
                buildPartion(9, 12) returned posPivot = 12
------------(5) sortQuick(9, 11)
                  buildPartion(9, 11) returned posPivot = 10

{ 2, 5, 6, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33, }

Compared with the mergesort, see that it has rather simple tree. Hence better.

<when-input-is-already-sorted>
----(1) sortQuick(0, 12)
swap: x == y
swap: x == y
swap: x == y
swap: x == y
swap: x == y
swap: x == y
          buildPartion(0, 12) returned posPivot = 6
------(2) sortQuick(0, 5)
swap: x == y
swap: x == y
            buildPartion(0, 5) returned posPivot = 2
--------(3) sortQuick(0, 1)
swap: x == y
swap: x == y
              buildPartion(0, 1) returned posPivot = 0
--------(3) sortQuick(3, 5)
swap: x == y
              buildPartion(3, 5) returned posPivot = 4
------(2) sortQuick(7, 12)
swap: x == y
swap: x == y
            buildPartion(7, 12) returned posPivot = 9
--------(3) sortQuick(7, 8)
swap: x == y
swap: x == y
              buildPartion(7, 8) returned posPivot = 7
--------(3) sortQuick(10, 12)
swap: x == y
              buildPartion(10, 12) returned posPivot = 11

{ 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33, }


<when-is-not-sorted>
----(1) sortQuick(0, 12)
swap: x == y
          buildPartion(0, 12) returned posPivot = 5
------(2) sortQuick(0, 4)
swap: x == y
            buildPartion(0, 4) returned posPivot = 2
--------(3) sortQuick(0, 1)
swap: x == y
swap: x == y
              buildPartion(0, 1) returned posPivot = 1
--------(3) sortQuick(3, 4)
swap: x == y
swap: x == y
              buildPartion(3, 4) returned posPivot = 3
------(2) sortQuick(6, 12)
            buildPartion(6, 12) returned posPivot = 7
--------(3) sortQuick(8, 12)
swap: x == y
              buildPartion(8, 12) returned posPivot = 8
----------(4) sortQuick(9, 12)
swap: x == y
swap: x == y
swap: x == y
                buildPartion(9, 12) returned posPivot = 12
------------(5) sortQuick(9, 11)
                  buildPartion(9, 11) returned posPivot = 10
{ 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33, }


{heapsort}
Some kind of input can make quicksort misbehave badly and heapsort overcomes this problem. Like the
pecking order in a corporate hierarchy and each employee supervises exactly two others.

When putting 2-tree into a list, found that:

The left and right children of the node with position k are in positions 2k+1 and 2k+2 of the list.
If these positions are beyond the end of the list, then these children do not exist. means leaf.
(this is about position)

The heap is a list in which each entry contains a key, and, for all positions k in the list, the key
a position k is at least [as-large-as-the-key] in positions 2k+1 and 2k+2, provided these positions
exist in the list. (this is about key)

The sample heap as a 2-tree and a list

                () y
        () r          () p
  () d     () f    () b   () k
() a () c


[y r p d f b k a c]

The first entry must be the largest key in the heap. Heapsort has two phases: arrange a list to make
a heap and remove the top of the heap and promote another entry to take its place.

For second phase, move the first entry to the last position: save the last to current, move the
first to the last, and place the current to the right position while building the heap. Decrease a
counter lu(last unsorted). 

This means that heap sort needs random-access and only for contiguous list.

void HeapSort(List* list)
{
	Position lu;
	ListEntry current;

	BuildHeap(list);

	for( lu = list->count-1; lu >=1; lu-- )
	{
		current = list->entry[lu];
		list->entry[lu] = list->entry[0];
		InsertHeap( current, 0, lu-1, list );
	}
}

[y r p d f b k a c]
[  r p d f b k a | y] c = c
[r f p d c b k a | y] 
[p f k d c b a | r y] 
...
[a | b c d f k p r y]

// see the left and right child of low and promote the bigger into low. also loop throuth the list.

void InsertHeap( ListEntry current, Position low, Position high, List* list )
{
	Position large;
	large = 2*low+1;	// index of left child

	while( large <= high )
	{
		// LT(left, right) and choose bigger one
		if( large < high && LT(list->entry[large].key, list->entry[large+1].key ))
			large++;

		// if current is bigger then
		if( GE( current.key, list->entry[large].key ))
			break;
		else
		{
			list->entry[low] = list->entry[large];
			low = large;
			large = 2*low+1;
		}
	}

	// when current is bigger or is out of index meaning there is no child
	list->entry[low] = current;
}

// p326. 2-tree with one node automatically satisfies heap and therefore not worry about leaves of
// the tree. Idea is if begin at the midpoint of the list and work our way back toward the start,
// can use InsertHeap to insert each entry into the partial heap consisting all later entries.

void BuildHeap(List* list)
{
	Position low;

	for(low = list->count/2-1; low >= 0; low-- )
		InsertHeap( list->entry[low], low, list->count, list );
}

 0 1 2 3 4 5 6 7 8
[y r p d f b k a c] low=3, list->count=9 IH( [3], 3, 9 ) : 3, 6, 7 
                    low=2, list->coutt=9 IH( [2], 2, 9 ) : 2, 4, 5
                    low=1, list->coutt=9 IH( [1], 1, 9 ) : 1, 2, 3, 4, 5, 6, 7
                    low=0, list->coutt=9 IH( [0], 0, 9 ) : 0, 1, 2, 3, 4, 5, 6, 7


<heapsort-application> {priority-queue}

The priority queue. each contains a key called priority and queue has two operations: insert and
remove the entry having largest (or smallest) key.

If represent a priority queue as a [sorted] contiguous list, in which case removal is immediate but
insertion take time proportional to n. Or represent it as an [unsorted], in which case insertion is
rapid but removal is slow.

The representation of a priority queue as a heap proves advantageous [for large n] since it is
represented efficiently in contiguous storage and is guaranteeded to need only logarithmic time for
both insertion and deletion.


{sort-summary}

o in choosing a method, take into account the ways in which the keys will usually be arranged before
sorting, the size of application, the amount of time available for programming, the need to save
computer time and space. Futhermore, see statistical analysis such as standard deviation and
empirical testing.

o merge, quick and heapsort are powerful and efficient but more difficult to program when applied to
large lists.

o heapsort is like an insurance: usually slower than quicksort but guarantees that sorting will be
completed in O(nlogn) comparison of keys, something that quicksort cannot always do.


==============================================================================
*kt_dev_algo_010*	table and hash

{logn-barrier}
As seen in binary search, by use of key comparisons alone, impossible to complete a search of n
items in fewer than logn on average: <binary-search-comparison-which-is-better>

The table lookup and searching share the same purpose: information retrieval. Searching uses key
comparison, whereas table lookup do not. Here assumes that each entry has only [one-key]. The table
look-up is O(1) and can be more efficient than any searching method. Provides functions from set of
keys to location of the entry.

Here study ways to implement and access tables in contiguous storage.

{index-function} {access-table}
Think a representation of rectangular array in a computer since computer storage is in a contiguous
sequence. m x n where the columns from 0 to n-1:

Entry(i,j) goes to position ni+j

A formular of this kind is called index function. In this case it is for rectangular array. If there
is a table having [pre-calculated-index] then used for all later references. This is called
an [access-table] to eliminate the calculations.

rectangular array and access table

[cost]    ->   [0]     [costareatear] 
[area]         [4]      0   4   8 
[tear]         [8]

This index function describes mapping meaning that can represent various shape of array. For example,
triangular matrix(table).


{multiple-access-table}
Consider the problem faced by the telephone company in accessing the records of its customers. To
publish the telephone book, the records must be sorted alphabetically by the name but to process
long-distance charges, the accounts must be sorted by telephone number. The company could keep
three(or more) set of its records, one sorted by name, one by number, and one by address. Doing this
would, however, not only be very wasteful of storage but it would introduce endless headaches if one
set of records were updated but another was not.

There is no reason why the records themselves need to be sorted according to one key rather than
another and also no difference whether the records are in array or in dynamic storage with the
access tables holding pointers to records.

index 	name 		address 		phone
1			Hill 		High...		2829478
2			Baker		17 King 		2884285
...
7			Moody		High King 	2822214

access tables

name 		address 		phone
2			3           5 
6        7           7
1        1           1
5        4           4
4        2           2
7        5           3
3        6           6


{table-adt}
This table is ADT which has domain(index set) and the codomain(bast type or value type). A table
with index set I and base type T is a function from I into T; which maps elements of domain to one
of codomain.

Index function and access tables are implementation methods for more general tables. Compared with
list which is sequence, table is the set and the function.


{radixsort}
Very efficient sorting method for linked list that uses a table and queue.

The idea is to consider the key one character at a time and to divide entries into as many sublists
as there are possibilities for the given character from the key. For example, if keys are words or
other alpabetic strings, divide the list into 26 sublists at each stage. 

<DN> That is, set up a table of 26 lists and distribute the entries into the list. Here use index to
find corresponding list. Hence table.

<approach-one>
A person sorting words by working on only one column like mechanical card sorter might first
distribute the words into 26 lists according to the initial letter, then devide each sublist into
further sublist according to the second letter, and so on. (means do second list within the first).
This causes multiplicity of sublist.

<approach-two>
To eliminates multiplicity of sublists: partition the items into the table of sublists first by the
least significant position and to the most. When the list has been partitioned by the most
significant plae and recombined, will be sorted. 

<DN> why sorted? because uses alphabet order which is sorted so will be sorted by distributing keys
into sublist according to alphabet order.

init 			by 3th 		by 2nd 		by 1st
rat 			mop { 		map { 		car 
mop			map 			rap 			cat
cat 			top 			car 			cot
map 			rap }			tar 			map
car 			car {			rat 			mop
top 			tar } 		cat }			rap
cot 			rat { 		mop { 		rat
tar 			cat 			top 			tar
rap 			cot } 		cot }			top 

The order of the words in each sublist remains the same as it was before the partition.

<approach-three>
To eliminates multiplicity of sublists: partition the items into the table of sublists first
by the most significant position and to the least. Not the same as the LSB case.

init 			by 1st char		by 2nd 		by 1st
rat 			cat  		      cat  		   cat { not sorted
mop			car  		      car 			car
cat 			cot  		      map 			cot }
map 			mop 			   rat 			map
car 			map 			   rap 			mop
top 			rat  		      tar 			rat {
cot 			rap  		      cot 		   rap }
tar 			top  		      mop 			tar
rap 			tar  		      top 			top 

<ref-example>
Set up an array of 28 linked queues which is a table SDT. position 0 corresponds to a blank
character, position 1 through 26 to the letters and position 27 to any other character that appears
in the key. 

<DN> Why queue?  since entries are always inserted at the end of a sublist and removed from the
beginning.

Traverse the linked list and add each item to the end of the appropriate queue. After partitioned,
recombine the queues into one list.

<assumptions>
o No case, ASCII

// this is EntryType and means that each entry has char array[KEYSIZE].
typedef char QueueEntry[KEYSIZE];

// shall set up array of 28 linked queue. position 0 corresponds to a blank character, position 1-26
// to the letters (no case), position 27 to any other character which is non-alphabet.
int QueuePosition(char c)
{
  if( c == '' ) return 0;
  else if( isalpha(c) )
    return tolower(c) - 'a' +1;
  else
    return 27;
}

// recombine all queues into one list
void Rethread(List* list, Queue queues[] )
{
  int i;
  Node* x;

  for( i=0; i < MAXQARRAY; i++ )
    while( !QueueEmpty( &queues[i] ))
    {
      ServeNode( &x, &queues[i] );
      InsertList( ListSize(list), x, list );
    }
}

void RadixSort(List *list)
{
  int i, j;
  Node *x;
  Queue queues[MAXQARRAY];

  for( i=0; i < MAXQARRAY; i++ )
    CreateQueue(&queue[i]);

  // j is a index for LSB so sould j start from KEYSIZE-1? This seems to be a typo in a book.
  for( j=KEYSIZE-2; j >= 0; j-- )
  {
    // get out a node from list and put it back to the corresponding queue. <DN> this means that linked
    // list and linked queue shares the same node structure.
    while( !ListEmpty(list) )
    {
      // get the first node from a list. DeleteList( pos, ListEntry*, List*) and see general list. 
      DeleteList( 0, &x, list );

      // insert a node into the queue based on LSB char.
      AppendNode( x, &queue[ QueuePosition( x->entry[j]) ]);
    }

    // connect 28 queues together as a single list
    Rethread( list, queue );
  }
}

<analysis>
The radix sort is proportional to nk, where n is the number of items and k is the number of
characters in a key. The time for all our other sorting methods denpends on n but not directly on
the length of a key.

To compare the relative performance with the best time of mergesort which is nlogn. So the relative
size of nk vs nlogn:

If the keys are long but there are few of them, then k is large and n is relatively small, then
other methods such as mergesort will outperform radixsort. If k is small and there are a large
number of keys, then radixsort will be faster than any other methods.


{hash-table}
For cases where the key is no longer an index that can be used directly as in array indexing. Hash
table is to allow many of the different possible keys that might occur to be mapped to the same
location under the action of index function. This index function is hash function which map several
different keys to the same index. This is collision. So two questions: find good hash function and
how to resolve collisions.
 
{hash-function}
Need even distribution of the keys but do not know in advance what keys will occur. There is nothing
random about a hash function. Three methods that can be put together in various way to build a hash
function. All about even distribution to avoid collisions.

<truncation>
Use part of key directly as the index. For example, for key 62538194, use 394 which is 1, 2 and 5
digits as the index. This is very fast but often fail to get even distribution.

<folding>
Partition the key into several parts and combine in convenient way. For example, 62538194 maps to
625+381+94 = 1100 which is truncated to 100. Since all information in the key is used, often have
better spread than truncation.

<modular>
Divide by the size of the index range and take remainder as the result. The spread depends very much
on the modulus( in this case, the size of the hash array). If the modulus is a power of a small
integer like 2 or 10, then many keys tend to map to the same index, while other indices remain
unused. The best is to use prime numbers: not 1000 or 1024 but use 997 or 1009.

This is the best since can get good spread and ensures that the result is in the proper range at the
same time. 

int Hash( Key s )
{
	unsigned h = 0;

	while(*s)
		h += *s++;

	return h % HASHSIZE;
}


{collision-resolution}
There are many ways to do. rehasing uses a second hash to obtain the second position to consider.

{summary}
Four different methods of information retrieval: sequential and binary search for list. table lookup
and hashing for table. 

For speed and convenience, Ordinary lookup in contiguous table is superior but there are many
applications to which it is inapplicable: when keys is sparse, when insertion or deletion are
frequent.


={============================================================================
*kt_dev_algo_011*	binary tree

The linked list have great advantages over contiguous implementation but have one weak feature:
{list-contiguous-and-linked} they are sequential list; that is, have to move through them only one
position at a time, not random access.

Tree overcome this and is valuable for problems of information retrieval.


{adt-definition} # binary-tree
A binary tree is either empty, or consist of a node called the 'root' together with two binary tree
called the 'left-subtree' and the 'right-subtree' of the root.

The left and right are important for binary tree and has recursive nature that allows empty binary
tree and the empty tree is base case for recursive and determine when to stop.

2-tree is different from binary tree since 2-tree has always 0 or 2 children but never 1.

Excercise: get all fourteen binary trees with four nodes.


{traversal-orders}
There are many different traversal orders for trees and reduced to 'three' by permitting only the ways
in which the left subtree is traversed before the right.

The (V)isiting a node, traversing the left subtree L, and the right subtree R. note. notice visit,
traverse and subtree in wording since traverse is not visit.

VLR(preorder) LVR(inorder) LRV(postorder)
^              ^             ^

Do this order for every node and it has recursive nature. For example, traverse the following tree

  ()1
    ()2
  ()3
()4  ()5

pre 12345, in 14352 and post 45321


{linked-implementation}
A binary tree has a natural implementation in linked strorage. The root variable enable us to find
the tree and it will point to the root of the tree.

{Q} is this typedef okay? Yes, it is.

typedef struct treenode TreeNode;
typedef struct treenode {
  TreeEntry entry; // application dependant
  TreeNode  *left;
  TreeNode  *right;
} TreeNode;

// TreeNode* ttree; CreateTree(&ttree);
void CreateTree( TreeNode** root )
{ *root = NULL; }

Bool TreeEmpty( TreeNode* root )
{ return root == NULL; }

void Preorder( TreeNode* root, void (*Visit)(TreeEntry x))
{
  if(root)
  {
    Visit(root->entry);
    Preorder( root->left, Visit);
    Preorder( root->right, Visit);
  }
}

void Inorder( TreeNode* root, void (*Visit)(TreeEntry x))
{
  if(root)
  {
    Inorder( root->left, Visit);
    Visit(root->entry);
    Inorder( root->right, Visit);
  }
}


{binary-search-tree}
In {ref-004}, when given a binary tree question, many candidates assumes that it means binary search
tree. Be sure to ask whether or not the tree is a binary search tree(BST). A BST imposes the
'condition' that, for all nodes, the left children are less than or equal to the current node, which
is less than all the right nodes. BST is a 'special' kind of a binary tree.

The searching through the linked list always reduce to a sequential search and contiguous list is
much slower when frequently need to make changes in the list. The binary search tree is excellent
solution to this problem:

Can we find an implementation for ordered list in which we can search quickly (as with binary search
on a contiguous list) and in which we can make insertions and deletions quickly (as with a linked
list)?

By making the entries of an [ordered-list] into the nodes of a binary tree, O(logn) for search and
O(logn) for insertion and deletion as with binary search. The main design is to store the nodes as a
binary tree with the structure of comparison tree itself, with links used to describe the relations
of the tree. See {list-contiguous-and-linked}

This is especially appropriate when random access, traversal in predetermined order, and flexibility
are all required.

<adt-definition>
The binary search tree is a binary tree that is either empty or in which every node contains a
key(entry) and satisfies the conditions:

1. The key in the 'left' child of a node (if it exists) is 'less' than the key in its parent node.
2. The key in the 'right' child of a node (if it exists) is 'greater' than the key in its parent node.
3. The left and right subtrees of the root are again binary search tree.

This ensures that 'no' two entries in a binary search tree can have 'equal' keys since keys are strictly
less or greater. Possible to change the definition to allow entries with equal keys, but doing so
make the algorithm complicated.

<comparison-trees>
This is a BST and here 0 means NULL for left or right subtree.

              Jim
     Dot              Ron
  Amy     Guy     Kay     Tim
0   Ann Eva Jan Jon Kim Roy Tom
    0 0 0 0 0 0 0 0 0 0 0 0 0 0
 
Preorder: Jim Dot Amy Ann Guy Eva Jan Ron Kay Jon Kim Tim Toy Tom
Inoder  : Amy Ann Dot Eva Guy Jan Jim Jon Kay Kim Ron Roy Tim Tom

<tree-search>
The search in a linked binary search tree and termination condition is if we find the key and if
not, then continue searching until hit an empty subtree. This is based closely on binary search so
do the same comparisons as binary search do. O(log n)

// Returns node pointer if an entry in the binary search tree has key equal to target; that is when
// root is not null and LT and GT are false. Otherwise, returns NULL which is a leaf. See returning
// root up the chain and 'else if (GT)' but not 'else'. Strictly less or greater. 
TreeNode* TreeSearch( TreeNode* root, KeyType target )
{
  if(root)
  {
    if( LT( target, root->entry.key) )
      root = TreeSearch( root->left, target );
    else if( GT(target, root->entry.key) )            // note. else if
      root = TreeSearch( root->right, target );
  }

  return root;    // return null or node ptr for a equal key
}

// Recursion removal version as it is tail recursion. returns node if found; otherwise, return null.
// Q: Why use 'position' variable? Seems that it is okay not to use position and use root.
TreeNode* TreeSearch( TreeNode* root, KeyType target)
{
  TreeNode* position = root;

  // note 1. Already checked equal case in while so no need to the same in if and else clause Why?
  // since run only equal case in recursion version and exit call when equal but here use while
  // instead. In other words, NE is hidden(implicit) case in recursion version.  

  // note 2. This finds equal (remember binary search has two versions) and when reaches a leaf then
  // means 'not found'.

  while( position && NE( target, position->entry.key ))
  {
    if( LT(target, position->entry.key ))
      position = position->left;
    else
      position = position->right;
  }

  return position;
}

Can think when there is only one in the binary search is when reaches at the leaf node which has
imaginary left and right null node.

<random-binary-search-tree>
The same keys which are letters in this case can have quite different shapes of trees depending how
a tree is made. In other words, how it is inserted into a tree range from the best which is bushiest
meaning fewerer > tree-height, comparison, or recursion depth < to the wortst which is a single chain
and is equal to sequential search. 

"dbacfeg" ->               d()                "abcdefg" -> ?
                       b()     f()
                     a() c() e() g()

Remember that binary search requires ordered list. The search performance of BST 'depends' on how a
tree constructed. The TreeInsert can handle the random input and when the input is ordered, BST
degenerates to the worst case, single chain. Think a tree shape when use TreeInsert with ordered
input. The worst case is extremely unlikely in practice so TreeSearch performs nearly as well as
binary search. For random order, it is 39% slower than the optimum of (logn) comparisons. Still
better than sequential search. {Q} is it average? Yes, it is.

This tree handles random input order and hence called random BST.

<tree-insert> which supports the random input
>
 The worst of a random binary search tree is when the keys are inserted into an initially empty tree
 in their natural order, sorted. This will produce a chain, a tree with a single line. The same
 holds if the keys are in reverse order or if they are nearly but not quite sorted into order.
 TreeInsert should never be used with keys that are 'already' sorted into order.

If the keys are equal, we shall adopt the convention of inserting the duplicate key into the 'right'
subtree. It inserts a new key that duplicates a previous key on the right side of the old entry.
TreeSearch, the searching function will always find the 'first' entry of duplicated keys.

note. Looks like searching will find the first entry regardless of right or left for duplicated
keys.

Example, "e, b, d, f, a, g, c"
          0  1

// See how return value is used; used to set left or right of the previous node. and return of a
// function. Also this shall be used once searching to insert is done. That is search and insert.
TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
  if(!root)
  {
    root = newnode;
    root->left = root->right = NULL;
  }
  else if( LT(newnode->key.entry, root->key.entry ) )
    root->left = TreeInsert( root->left, newnode);
  else                                                      // note else
    root->right = TreeInsert( root->right, newnode);

  return root;
}

In regard to performance, TreeInsert will be very much the same as that of TreeSearch to find a
place to insert: O(logn)


{treesort}
The inorder(LVR) traversal of binary search tree always give the sorted order for the keys. So
simply takes the entries to be sorted, use TreeInsert to build them into a binary search tree, and
use inorder traversal to put them out in order.

Notice the similarity with quicksort. The quicksort is usually an excellent method and treesort
makes the same comparisons as does quicksort. In the average, on a randomly ordered list of n,
treesort performs:

1.39 nlogn + O(n)

<why-bst-is-useful-for-a-stream>

For a case, see <8> in *kt_dev_quiz_015* 

Treesort has one advantage over quicksort: Quicksort needs to have access to all the items to be
sorted but with treesort, the nodes need not all be available at the start of the process, but are
built into the tree one by one as they become available since as each node comes in it goes into its
final position in the linked list. 

This is major advantage that 1) search tree remains avaiable for later [insertions-and-deletions], and
that 2) can be searched in logarithmic time, whereas all previous sorting either requires contiguous
list or produce linked list for sequential search. 2) comes from BST.

As quicksort, the major drawback is the worst case when input is already sorted, or are nearly so.


<code-example>

#include < iostream>
#include < string>
#include < cstdlib>

#define LT(a,b) ((a) < (b))

typedef struct {
	int key;
} TreeEntry;

typedef struct treenode {
	TreeEntry entry; // application dependant
	treenode  *left;
	treenode  *right;
} TreeNode;

TreeNode* MakeTreeNode(int key)
{
	TreeNode* pnode = NULL;

	if( (pnode = (TreeNode*) malloc(sizeof(TreeNode))) == NULL )
	{
		std::cout << "MakeTreeNode: out of memory" << std::endl;
		return pnode;
	}

	pnode->entry.key = key;
	pnode->left = pnode->right = NULL;

	return pnode;
}

void CreateTree( TreeNode** root )
{ *root = NULL; }

TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
	if(!root)
	{
		root = newnode;
		root->left = root->right = NULL;
		std::cout << "inserted: " << root->entry.key << std::endl;
	}
	else if( LT(newnode->entry.key, root->entry.key) )
		root->left = TreeInsert( root->left, newnode);
	else
		root->right = TreeInsert( root->right, newnode);
	
	return root;
}

void TreeInorder( TreeNode* root, void (*Visit)(TreeEntry x))
{
	if(root)
	{
		TreeInorder( root->left, Visit);
		Visit(root->entry);
		TreeInorder( root->right, Visit);
	}
}

void PrintTreeNode( TreeEntry entry )
{
	std::cout << ":" << entry.key << std::endl;
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
   int arr[] = { 33, 2, 31, 5, 30, 6, 12, 10, 13, 15, 17, 29, 3 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

	TreeNode *proot, *pnode;
	CreateTree( &proot );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
	{
      std::cout << "insert " << arr[idx] << " into a tree" << std::endl; 
		pnode = MakeTreeNode( arr[idx] );
		// [KT] this is an error and it is not a problem of call-by-value in *kt_dev_cpp_014* but this
		// is always to insert new to the null root sicne proot is not updated. Hence no output when
		// traversing.
		// TreeInsert( proot, pnode ); 	
		proot = TreeInsert( proot, pnode );
	}

	TreeInorder( proot, PrintTreeNode );

   std::cout << "}" << std::endl; 
}


{Q} can change these to use reference?


<tree-delete>

Why care about deleting a node in a tree? because it is one of advantages treesort provides and
which is that search remains avaialbe after insertion and deletion. It is more complicated when the
node to be deleted has both left and right subtrees nonempty. One possible solution to following
questions:

1. To which of the subtree, should the parent of the deleted node now point? Right or left subtree?
Here in this book, attach the right subtree in place of the deleted node.

2. To which node of the right subtree, should the former left subtree be attached? Since every key
in the left subtree precedes every key of the right subtree, must be as far to the left as possible.
(remember The left subtree is also a tree.) This point can be found by taking left branches until an
empty left subtree is found.

TreeNode* x;					// pointer to a parent node of a node to delete;
DeleteNodeTree(&x->left); 	// equals to DeleteNodeTree(&(x->left));

// The parameter p is the address of actual node(not a copy) in a tree since the object is to update
// the BST, the actual parameter is the address of one of the links of the tree.

void DeleteNodeTree( TreeNode** p )
{
	// r points node to delete
	TreeNode* r = *p, *q;

	if( r == NULL )
		Error("attempt to delete a nonexistent node from binary search tree");
	// when a node has only either left or right subtree, attach subtree to a parent
	else if( r->right == NULL )
	{
		*p = r->left;	// reattach left subtree
		free(r);
	}
	else if( r->left == NULL )
	{
		*p = r->right;	// reattach right subtree. *p now points to r->right.
		free(r);			// release the node. *r points the previois node so okay to free.
	}
	// when a node has both subtrees [KT] this is interesting parts.
	else
	{
		// get to the leftmost node of the right subtree. starts from the right of r node. see how it
		// moves a tree. loop stops at a node with an empty left subtree, but not to end at the empty
		// subtree itself.
		for( q = r->right; q->left; q = q->left )
			;

		q->left = r->left;	// reattach left subtree
		*p = r->right;			// reattach right subtree
		free(r);
	}
}

For many cases, not given a pointer to a node to delete but instead given a key for which the
corresponding node must be deleted. So combine search and delete function.

void DeleteKeyTree( TreeNode** root, TreeNode** keyposition, KeyType target )
{
	if(*root == NULL)
		Error("attempt to delete a nonexistent node from binary search tree");
	else if ( EQ( target, (*root)->entry.key ) )
	{
		*keyposition = *root;
		DeleteNodeTree(root);
	} else if( LT( target, (*root)->entry.key ))
		DeleteKeyTree( root, keyposition, target);
	else
		DeleteKeyTree( root, keyposition, target);
}	


<tree-balance>

This delete function is far from optimal as it can greatly increase the height of the tree. Two
examples:

     (r)                       (x)    
   (b) (x)    delete r       (b) (y)  
 (a)     (y)               (a)      (z) 
           (z)                       

       (r)    delete r          (z)
    (c)  (z)                  (y)
  (b)  (y)                  (x)
(a)  (x)                  (c)
                        (b)
							(a)

The second example increases its height. Thus the time required for a later search can substantially
increase, even though the total size of the tree has decreased. Hence to optimise the use of binary
search tree, need methods to make the left and right subtree more nearly balanced. To reduce height,
need to make it balanced.

Is it worthwhile, on average, to keep a binary search tree balanced or rebalance it? The average
cost of not balancing a binary search tree is approximately 39% more comparisons because not
balanced tree becomes random binary search tree. See 9.3.6 in {ref-001}


{build-bst-with-ordered-input}

<ref-example>
		 
The complete binary tree of 1...31 in the order in which they are received:
													(16)															2^4
						(8)													(24)								2^3
			(4)					(12)						(20)							(28)				2^2
	(2)		(6)		(10)		(14)			(18)			(22)			(26)			(30)		2^1
(1) (3)	(5) (7)	(9) (11)	(13) (15)	(17) (19)	(21) (23)	(25) (27) 	(29) (31) 	2^0


// lastnode
When node number 1 arrives, is a leaf and therefore its left and right pointers should both be NULL.
When node number 2 arrives, goes above node 1 and should remember where node 1 is. 
When node number 3 arrives, is a leaf but is in the right of node 2 and remember node 2. 

												(4)*				(4)* 				level 3
 			(2)*		(2)*			(2)	   		(2)						level 2	
(1)*	(1)		(1)	(3)	(1)	(3)   	(1)	(3) 		(5)* 		level 1 
n=1	n=2		n=3			n=4				n=5

where * is a node that must be remembered as the tree grows

Must keep a list of all nodes previously processed? No and need only to remember one node on each
level, the last node processed on that level. pointers in lastnode array that will quite small. For
example, 20 levels can have 2^20-1 > 1,000,000 nodes.

For some nodes, the right link should not permanently NULL since the node to insert may be the right
child of some previois node. For some, it may be left child, in which case its parent node has not
yet arrived. Can tell which case occurs by looking at lastnode. If level is the level of new node
then parent level is level+1. Look at lastnode[level+1] and if the right is still null, its right
must be the new node and if not, the right is aleady arrived and the new node must be the left of
some future node.  

// true when x is odd number
#define ODD(x)	((x)/2*2 != (x))

// find the highest power of 2 that devides count. requires x != 0. 
// returns level = 0,1,2,3,4,5...
// count: 	4 			12 		20
// level, x 0 4		0 12		0 20
//        	1 2		1 6		1 10
//        	2 1		2 3		2 5

int Power2(int x)
{
	int level;

	// run when x is even
	for(level=0; !ODD(x); level++)
		x/=2;

	return level;
}

<tree-insert> which assumes the ordered input

void Insert( TreeNode *newnode, int count, TreeNode *lastnode[] )
{
	int level = Power2(count)+1;
	newnode->right = NULL;
	newnode->left 	= lastnode[level-1];							// previous level
	lastnode[level] = newnode;										// level
	
	// for example, when n=6
	if(lastnode[level+1] && !lastnode[level+1]->right )	// parent level
		lastnode[level+1]->right = newnode;
}

// If there is information available, GetNode creates a TreeNode, copies the information into the
// node, and returns a pointer to this TreeNode. Otherwise, returns NULL. This is to obtain each new
// node.
TreeNode *GetNode();

// the root is the highest node in the tree; hence its pointer is the highest entry not equal to
// NULL in the lastnode array.
TreeNode *FindRoot(TreeNode *lastnode[])
{
	int level;

	for( level = MAXHEIGHT-1; level > 0 && !lastnode[level]; level--)
		;

	if( level <= 0 )
		return NULL;
	else
		return lastnode[level];
}

// The nearly completed BST has been initialized. must tie in any subtrees that may not yet be
// connected properly after all the nodes have been received. The difficulty is that some nodes in
// the upper part of tree may still have their right links set to null, even though further nodes
// have come in that belong in their right subtrees. Any node for which the right child is still
// null will be one of the nodes in lastnode. Its right child should be set to the highest node in
// lastnode that is not already in its left subtree.
void ConnectSubtree( TreeNode *lastnode[] )
{
	TreeNode *p;
	int level, templevel;

	// find the root
	for( level = MAXHEIGHT-1; level > 2 && !lastnode[level]; level--)
		;

	while( level > 2 )	// level 1 and 2 are already okay
	{
		if( lastnode[level]->right )
			level--;		// search for highest dangling node
		else 				// right subtree is undefined
		{
			p = lastnode[level]->left;
			templevel = level-1;
			do {			// find highest entry not in left subtree
				p = p->right;
			} while( p && p == lastnode[--templevel]);

			lastnode[level]->right = lastnode[templevel];
			level = templevel;
		}
	}
}

TreeNode *BuildTree(void)
{
	TreeNode *newnode;
	int count = 0;
	int level;

	TreeNode* lastnode[ MAXHEIGHT ];

	for( level = 0; level < MAXHEIGHT; level++ )
		lastnode[level] = NULL;

	while((newnode = GetNode()) != NULL )
		Insert( newnode, ++count, lastnode );

	// after all the nodes have been inserted into the new tree, find the root of the tree and then
	// connect any right subtrees that may be dangling. For example, n=5 and 21 node.
	newnode = FindRoot(lastnode);
	ConnectSubtree( lastnode );

	return newnode;
}

This algorithm produces a binary tree that is not always completed balanced. For n=32, it will
become the root of the tree and all 31 node will be in its left. 5 steps from the root to leaf.
Hence one comparison more than necessary will usually be done and it is not really a high price.

This algorithm is never more than one level away from optimality. There are sophisticated methods
for building a binary tree that is as balanced as possible but recommend a simpler method, one that
does not need to know in advance how many nodes are in the tree. For many practical purposes, this
should prove sufficient.


==============================================================================
*kt_dev_algo_012*	avl tree

{avl-tree}

In many application, insertions and deletions occur continually with no predictable order. AVL tree
is a method to keep the tree very nearly balanced at all times for all search, insertion and
deletions to optimise search times even in the worst case. In almost all cases, AVL tree closely
approximates that of ideal, completely balanced binary search tree. O(logn).


{splay-tree}

Like hospital example, want to keep records that are newly inserted or frequently accessed very
close to the root, while records that are inactive may be placed far off, near or in the leaves.

Also cannot shut down the hospital for an hour to rebuild the tree into the desired shape, so do
self-adjusting data that automatically changes its shape to meet the above.


==============================================================================
*kt_dev_algo_013*	comparison of methods

Three(five) imporant efficiency criteria when choosing algorithms: p330 in {ref-001}

1) use of space
2) computer time
3) programming effort

4) statistical analysis. to see difference between worst and best case.
5) empirical testing

# ============================================================================
#{ CASES
==============================================================================
*kt_dev_algo_100*	double linked list

// size of hash table.
#define MHV_HASH_SIZE 3

// hash function for handles.
#define HASH(handle) (((uint32_t)(handle)) % MHV_HASH_SIZE)

typedef struct SPfmListHead_
{
  struct SPfmListHead_ *nxt, *prv;
} SPfmListHead;

static SPfmListHead m_apstStreamHashTable[MHV_HASH_SIZE];

<DN-one>
This double linked list has an entry which has also a double linked list.

m_apstStreamHashTable

     prev           prev          prev
      |               |             |
    [0]             [1]           [2]   : headers
    |               |             |
   next            next          next 

     prev           prev          prev
      |               |             |
    [E]             [E]           [E]   : entries
    <- prev
       next ->
    |               |             |
   next            next          next 

<DN-two>
The hash table is simple mod operation. % HASH_SIZE and handles is an counter whcih increase by one.
So all handles will belongs one of {0,1,2} when HASH_SIZE is 3.

<DN-three>
This is implemented as circular but no use of it.

<DN-four>
Typical list structure has following structures and can define the entry as we want. However, how
can we use this List for different entry structure?

typedef struct listnode {
     ListEntry entry;
     struct listnode* next;
     struct listnode* prev;
} ListNode;

typedef struct list {
     ListNode*  current;
   ...
} List;


{generic-support} 
Here, trick is to have ListNode as the first member for <any> entry structure and to have a link to
that member. This build a linked list on that. In this example, it uses is as the first member, uses
its offset, and use type cast to what want to have. Why the first member? Because need to get the
start address of the object. This is C way since it assumes that memory layout or internal representation.  

typedef struct listnode {     <DN> no entry in a node
     struct listnode* next;
     struct listnode* prev;
} ListNode;

typedef struct list {
     ListNode*  current;
   ...
} List;

typedef struct {
  ListNode node;
  ...
} A_type_entry;

typedef struct {
  ListNode node;
  ...
} B_type_entry;

<init>

for( ii=0; ii < MHV_HASH_SIZE; ii++ )
{
  PFM_INIT_LIST_HEAD(m_apstStreamHashTable + ii);
}

void PFM_INIT_LIST_HEAD(SPfmListHead *ptr)
{
  ptr->nxt = ptr;
  ptr->prv = ptr;
}

<add>

typedef struct _SMhvStream
{
    SPfmListHead list;  // [DN] this is the first member of a structure
    ...
    SPfmListHead subs;
    SPfmListHead triggers;
    ...
} SMhvStream;

p = (SMhvStream *)blkAlloc(&m_StreamHashBlockCtrl);

PFM_INIT_LIST_HEAD(&p->subs);
PFM_INIT_LIST_HEAD(&p->triggers);

pfmListAddTail(m_apstStreamHashTable + HASH(p->handle), &(p->list));
/* add to stream. */
pfmListAddTail(&p->subs, &ev->strlist);

// Add an item to the tail of a list.
// @param   list    The list to modify
// @param   entry   The entry to add at the tail of list.
void pfmListAddTail(SPfmListHead * list, SPfmListHead * entry)
{
  entry->nxt = list;
  entry->prv = (list)->prv;
  list->prv->nxt = entry;
  (list)->prv = entry;
}

// Add an item to the head of a list.
// @param   list    The list to modify
// @param   entry   The entry to add at the start of list.
void pfmListAddHead(SPfmListHead * list, SPfmListHead * entry)
{
  entry->nxt = list->nxt;
  entry->prv = list;
  list->nxt->prv = entry;
  list->nxt = entry;
}

// Remove an item from its list.
// @param   item    The item to remove.
void pfmListRemove(SPfmListHead * item)
{
  item->nxt->prv = item->prv;
  item->prv->nxt = (item)->nxt;
}

<search> simple sequential search from each head

SPfmListHead *item;

for( int ii=0; ii < MHV_HASH_SIZE; ii++ )
{
  pfmForEach(item, m_apstStreamHashTable + HASH(h))
  {
    SMhvStream *p;
    p = pfmListEntry(item, SMhvStream, list);
    if (p != NULL) // should p ever be NULL?
    {
      use p;
    }
  }
}

#define pfmForEach(item, head) \
    for (item = (head)->nxt; item != (head); item = item->nxt)

#define pfmListEntry(item, type, member) \
    ((type *)((void*)((uint8_t *)(item)-(size_t)(&((type *)0)->member))))
                     |                                                |     : get memeber offset
             |                                                         |    : type cast to void*
                                                                            : type cast to type*


# ============================================================================
#{ DISCUSSION
==============================================================================
*kt_dev_algo_300*	C++ map insertion and lookup performance and storage overhead

http://stackoverflow.com/questions/1822114/c-map-insertion-and-lookup-performance-and-storage-overhead

The question is:

I would like to store a mapping of an integer key to a float value in-memory.  I have roughly 130
million keys (and, accordingly, 130 million values). My focus is on lookup performance -- I have to
do many, many millions of lookups.  The C++ STL library has a map class for associative arrays of
	this sort. I have several questions about map.  What is the storage overhead of map for a dataset
		of the size mentioned above? How does storage overhead scale, in general, with map? It looks
		like the underlying data structure for map is a red-black, balanced binary tree. It sounds
		like the real-world performance for this is O(log n) for insertion and retrieval. It mentions
		O(1) for a hinted insertion. My input is pre-sorted, so I believe I should be able to provide
		a hint for insertion events. How would I provide this hint, using the methods listed here? Is
		there an STL container that provides better lookup performance?  Are there other
		publicly-available, open-source frameworks with an associate array class that uses an
		underlying data structure that would perform better than STL map? If writing my own container
		class would provide better lookup performance, what data structures might I research? I am
		using GCC 4 for this task, running under either Linux or Mac OS X. I apologize in advance if
		these are dumb questions. Thank you for your advice.


Given what you've said, I'd think very hard about using an std::vector<pair<int, float> >, and using
std::lower_bound, std::upper_bound, and/or std::equal_range to look up values.

While the exact overhead of std::map can (and does) vary, there's little or no room for question
that it will normally consume extra memory and look up values more slowly than a binary search in a
vector. As you've noted, it's normally (and almost unavoidably) implemented as some sort of balanced
tree, which imposes overhead for the pointers and the balancing information, and typically means
each node is allocated separately as well. Since your nodes are pretty small (typically 8 bytes)
that extra data is likely to be at least as much as what you're actually storing (i.e. at least 100%
		overhead). Separate allocations often mean poor locality of reference, which leads to poor
cache usage.

Edit: Looking just at implementations of std::map, it's probably worth noting that most use a
red-black tree. If you were going to use an std::map, an implementation that uses an AVL tree would
probably suit your purposes better -- an AVL tree has slightly tighter constraints on balancing.
This gives slightly faster lookup at the expense of slightly slower insertion and deletion (since it
		has to re-balance more often to maintain its stricter interpretation of "balanced"). As long
as your data remains constant during use, however, an std::vector is still almost certainly better.

One other possibility worth noting: if your keys are at least fairly even distributed, you might
want to try looking up using interpolation instead of bisection. i.e. instead of always starting at
the middle of the vector, you do a linear interpolation to guess at the most likely starting point
for the lookup. Of course, if your keys follow some known non-linear distribution, you can use a
	matching interpolation instead.

Edit 2: Assuming the keys are reasonably even distributed, the interpolation search has a complexity
of O(log log N). For 130 million keys, that works out to around 4 probes to find an item. To do
significantly better than that with (normal/non-perfect) hashing, you need a good algorithm, and you
need to keep the load factor in the table around 75% or so -- i.e. you need to allow for something
like 32 million extra (empty) spots in your table to improve the expected complexity from four
probes to three. I may just be old fashioned, but that strikes me as a lot of extra storage to use
for such a small speed improvement.

OTOH, it's true that this is nearly the ideal situation for perfect hashing -- the set is known
	ahead of time, and the key is quite small (important, since hashing is normally linear on the key
			size). Even so, unless the keys are distributed pretty unevenly, I wouldn't expect any huge
	improvement -- a perfect hash function is often (usually?) fairly complex.  share|improve this
	answer
	
definitely just use a binary search in the vector. Least memory, fastest too. –  Will Nov 30 '09 at
20:33
	
What about insertions? To use binary search, you'll have to keep the array sorted. Random
insertions in a vector are not particularly efficient. –  Raphaël Saint-Pierre Nov 30 '09 at 20:36
	
@RaphealSP: yes, if the data were dynamic (i.e. you need to support insertions/deletions during
		use), a sorted vector isn't a good choice. He notes, however, that the data starts out sorted,
	which I took as indicating that he's just reading in data, but not modifying it afterwards. –
		Jerry Coffin Nov 30 '09 at 20:41
	 
I am only inserting once. I do not need to modify my input set afterwards. –  Alex Reynolds Nov 30
'09 at 20:45 


# ============================================================================
#{ GLIBC
==============================================================================
*kt_dev_glib_000* glib sites

http://www.gnu.org/software/libc/libc.html
https://sourceware.org/glibc/wiki/GlibcGit

git clone git://sourceware.org/git/glibc.git

o use tabstop=6 for better view.


={============================================================================
*kt_dev_glib_001* atoi, htoi

{man-page}
<atoi>
NAME
       atoi, atol, atoll, atoq - convert a string to an integer

SYNOPSIS
       #include <stdlib.h>

       int atoi(const char *nptr);
       long atol(const char *nptr);
       long long atoll(const char *nptr);
       long long atoq(const char *nptr);

DESCRIPTION
       The atoi() function converts the initial portion of the string  pointed
       to by nptr to int.  The behavior is the same as
       
           strtol(nptr, (char **) NULL, 10);

       except that atoi() does not detect errors.

       The atol() and atoll() functions behave the same as atoi(), except that
       they convert the initial portion of the string to their return type  of
       long or long long.  atoq() is an obsolete name for atoll().

RETURN VALUE
       The converted value.

<strtol>
NAME
       strtol, strtoll, strtoq - convert a string to a long integer

SYNOPSIS
       #include <stdlib.h>

       long int strtol(const char *nptr, char **endptr, int base);
       long long int strtoll(const char *nptr, char **endptr, int base);

DESCRIPTION
       The strtol() function converts the initial part of the string  in  nptr
       to  a  long  integer  value  according to the given 'base', which must be
       between 2 and 36 inclusive, or be the special value 0.

       // note. handle leading white space, 0x, and sign
       The string may begin with an arbitrary amount of white space (as deter‐
       mined by isspace(3)) followed by a single optional '+' or '-' sign.  If
       base is zero or 16, the string may then include a "0x" prefix, and  the
       number  will  be read in base 16; otherwise, a zero base is taken as 10
       (decimal) unless the next character is '0', in which case it  is  taken
       as 8 (octal).

       The  remainder  of  the  string is converted to a long int value in the
       obvious manner, stopping at the first character which is  not  a  valid
       digit  in the given base.  (In bases above 10, the letter 'A' in either
       upper or lower case represents 10, 'B' represents  11,  and  so  forth,
       with 'Z' representing 35.)

       // note see how return and error are handled.
       If endptr is not NULL, strtol() stores the address of the first [invalid]
       character in *endptr.  If there were no digits at all, strtol()  stores
       the  original value of nptr in *endptr (and returns 0).  In particular,
       if *nptr is not '\0' but **endptr is '\0' on return, the entire  string
       is valid.

       The  strtoll()  function  works  just  like  the  strtol() function but
       returns a long long integer value.

RETURN VALUE
       The strtol() function returns the result of the conversion, unless  the
       value  would  underflow  or overflow.  If an underflow occurs, strtol()
       returns LONG_MIN.  If an overflow occurs,  strtol()  returns  LONG_MAX.
       In  both  cases,  errno is set to ERANGE.  Precisely the same holds for
       strtoll()  (with  LLONG_MIN  and  LLONG_MAX  instead  of  LONG_MIN  and
       LONG_MAX).

ERRORS
       EINVAL (not in C99) The given base contains an unsupported value.

       ERANGE The resulting value was out of range.

       The  implementation  may also set errno to EINVAL in case no conversion
       was performed (no digits seen, and 0 returned).

EXAMPLE
       The  program  shown  below demonstrates the use of strtol().  The first
       command-line argument specifies a string  from  which  strtol()  should
       parse  a  number.  The second (optional) argument specifies the base to
       be used for the conversion.  (This argument  is  converted  to  numeric
       form  using atoi(3), a function that performs no error checking and has
       a simpler interface than strtol().)  Some examples of the results  pro‐
       duced by this program are the following:

           $ ./a.out 123
           strtol() returned 123

           $ ./a.out '    123'
           strtol() returned 123

           $ ./a.out 123abc
           strtol() returned 123
           Further characters after number: abc

           $ ./a.out 123abc 55
           strtol: Invalid argument

           $ ./a.out ''
           No digits were found

           $ ./a.out 4000000000
           strtol: Numerical result out of range

   Program source

       #include <stdlib.h>
       #include <limits.h>
       #include <stdio.h>
       #include <errno.h>

       int
       main(int argc, char *argv[])
       {
           int base;
           char *endptr, *str;
           long val;

           if (argc < 2) {
               fprintf(stderr, "Usage: %s str [base]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           str = argv[1];
           base = (argc > 2) ? atoi(argv[2]) : 10;

           errno = 0;    /* To distinguish success/failure after call */
           val = strtol(str, &endptr, base);

           /* Check for various possible errors */
           if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))
                   || (errno != 0 && val == 0)) {
               perror("strtol");
               exit(EXIT_FAILURE);
           }

           if (endptr == str) {
               fprintf(stderr, "No digits were found\n");
               exit(EXIT_FAILURE);
           }

           /* If we got here, strtol() successfully parsed a number */
           printf("strtol() returned %ld\n", val);

           if (*endptr != '\0')        /* Not necessarily an error... */
               printf("Further characters after number: %s\n", endptr);

           exit(EXIT_SUCCESS);
       }


<code-from-ansic>
From p43.

// This is 'naive' implementation since no error handlings and return 0 when failed to convert.
// Compare to strtol

int atoi(char s[])
{
  int n, i;

  // Why there is no check on the end of string input? '0' is not the same as 0(NULL) and when see
  // any other than numbers, for loops ends.
  for(n = 0, i = 0; s[i] >= '0' && s[i] <= '9'; i++)
    n = n*10 + (s[i]-'0');

  return n;
}

int getint(int *pn)
{
  int c, sign;

  // skip white spaces
  while( isspace(c = getc() ))
      ;

  // not a number
  if( !isdigit(c) && c != EOF && c != '+' && c != '-' )
  {
    ungetc(c);
    return 0;
  }

  sign = (c == '-') ? -1 : 1;

  if( c == '+' || c == '-' )
    c = getc();

  for( *pn = 0; isdigit(c); c = getc() )
    *pn = *pn * 10 + (c - '0');

  *pn *= sign;

  if( c != EOF )
    ungetc(c);

  return c;
} 

To make it compile in gcc:

int getint(int *pn)
{
  int c, sign;

  // skip white spaces
  while( isspace(c = getchar() ))
      ;

  // not a number
  if( !isdigit(c) && c != EOF && c != '+' && c != '-' )
  {
    ungetc(c, stdin);
    return 0;
  }

  sign = (c == '-') ? -1 : 1;

  if( c == '+' || c == '-' )
    c = getchar();

  for( *pn = 0; isdigit(c); c = getchar() )
    *pn = *pn * 10 + (c - '0');

  *pn *= sign;

  if( c != EOF )
    ungetc(c, stdin);

  return c;
} 

<getchar-and-eof>
From ansic 1.5.1, "we can't use char since c must be big enough to hold EOF in addition to any
possible char. Therefore we use int"

GETS(3)                    Linux Programmer's Manual
int getchar(void);

int main(int argc, char* argv[])
{
  // int c;
  char c;

  printf("EOF (0x%x)\n", EOF);

  c = getchar();

  while( c != EOF )
  {
    putchar(c);
    c = getchar();
  }
}

kt@kt-ub-vb:~/work$ ./a.out 
EOF (0xffffffff)
a b v <1>
a b v <2>
(waiting input)

For <1>, a b v (ENTER) then <2> comes. This means that when press ENTER, input stream ends and is
ready to process. The getchar and putchar runs on this stream and only runs when press ENTER.

EOF is an integer defined in stdio.h but the specific numeric value doesn't matter as long as it is
not the same as any char value. This is why use symbolic constant.

<code-online>
// A utility function to check whether x is numeric
bool isNumericChar(char x)
{
  return (x >= '0' && x <= '9')? true: false;
}

// A simple atoi() function. If the given string contains any invalid character, then this function
// returns 0
int myAtoi(char *str)
{
  if (*str == NULL)
    return 0;

  int res = 0;  // Initialize result
  int sign = 1;  // Initialize sign as positive
  int i = 0;  // Initialize index of first digit

  // If number is negative, then update sign
  if (str[0] == '-')
  {
    sign = -1;
    i++;  // Also update index of first digit
  }

  // Iterate through all digits of input string and update result
  for (; str[i] != '\0'; ++i)
  {
    if (isNumericChar(str[i]) == false)
      return 0; // You may add some lines to write error message to error stream
    res = res*10 + str[i] - '0';
  }

  // Return result with sign
  return sign*res;
}

<code-glibc>
Here only consider usual char type which is not wide char and 10 base. So disregard followings:

#ifdef USE_NUMBER_GROUPING
# ifdef USE_WIDE_CHAR

// stdlib/atio.c
int
atoi (const char *nptr)
{
  return (int) strtol (nptr, (char **) NULL, 10);
}

// stdlib/strtol.c
INT
strtol (nptr, endptr, base)
     const STRING_TYPE *nptr;
     STRING_TYPE **endptr;
     int base;
{
  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, _NL_CURRENT_LOCALE);
}

// stdlib/strtol_l.c
// The interesting bit are: base handling, overflow handling,
//
INT
INTERNAL (__strtol_l) (nptr, endptr, base, group, loc)
     const STRING_TYPE *nptr;
     STRING_TYPE **endptr;
     int base;
     int group;
     __locale_t loc;
{
  const STRING_TYPE *s;
  UCHAR_TYPE c;
  const STRING_TYPE *save, *end;

  unsigned LONG int i;
  int overflow;

  save = s = nptr;

  /* Skip white space.  */
  while (ISSPACE (*s))
    ++s;

  /* Check for a sign.  */
  negative = 0;
  if (*s == L_('-'))
  {
    negative = 1;
    ++s;
  }
  else if (*s == L_('+'))
    ++s;

  /* Recognize number prefix and if BASE is zero, figure it out ourselves.  */
  // skip
  
  /* Save the pointer so we can check later if anything happened.  */
  // so handled the sign from s
  save = s;

  end = NULL;

  /* Avoid runtime division; lookup cutoff and limit.  */
  cutoff = cutoff_tab[base - 2];
  cutlim = cutlim_tab[base - 2];

  overflow = 0;
  i = 0;
  c = *s;

  // this is for QUAD
  if (sizeof (long int) != sizeof (LONG int))
  {
    unsigned long int j = 0;
    // same as cutoff_tab
    unsigned long int jmax = jmax_tab[base - 2];

    // scan through each char
    for (;c != L_('\0'); c = *++s)
    {
      // is it possible case?
      if (s == end)
        break;

      // convert to digit
      if (c >= L_('0') && c <= L_('9'))
        c -= L_('0');
      else if (ISALPHA (c))
        c = TOUPPER (c) - L_('A') + 10;
      else
        break;

      // cannot bigger than base
      if ((int) c >= base)
        break;
      /* Note that we never can have an overflow.  */
      else if (j >= jmax)
      {
        /* We have an overflow.  Now use the long representation.  */
        i = (unsigned LONG int) j;
        goto use_long;
      }
      // make a digit in corresponding unit
      else
        j = j * (unsigned long int) base + c;
    } // for end

    i = (unsigned LONG int) j;
  }
  // this is usual case
  else
    for (;c != L_('\0'); c = *++s)
    {
      if (s == end)
        break;

      if (c >= L_('0') && c <= L_('9'))
        c -= L_('0');
      else if (ISALPHA (c))
        c = TOUPPER (c) - L_('A') + 10;
      else
        break;

      // when c is alphabet
      if ((int) c >= base)
        break;

      /* Check for overflow.  */
      if (i > cutoff || (i == cutoff && c > cutlim))
        overflow = 1;
      else
      {
use_long:
        i *= (unsigned LONG int) base;
        i += c;
      }
    }

  /* Check if anything actually happened.  */
  // nothing converted
  if (s == save)
    goto noconv;

  /* Store in ENDPTR the address of one character
     past the last character we converted.  */
  if (endptr != NULL)
    *endptr = (STRING_TYPE *) s;

  /* Return the result of the appropriate sign.  */
  return negative ? -i : i;
}

// the bellow is the pre-calculated table for each base and the value are the
// max value for division and remainder. for example, cutoff = cutoff_tab[base
// - 2]; get the value for base 10.

/* Define tables of maximum values and remainders in order to detect
   overflow.  Do this at compile-time in order to avoid the runtime
   overhead of the division.  */
extern const unsigned long __strtol_ul_max_tab[] attribute_hidden;
extern const unsigned char __strtol_ul_rem_tab[] attribute_hidden;

#define DEF(TYPE, NAME)							   \
  const TYPE NAME[] attribute_hidden =					   \
  {									   \
    F(2), F(3), F(4), F(5), F(6), F(7), F(8), F(9), F(10), 		   \
    F(11), F(12), F(13), F(14), F(15), F(16), F(17), F(18), F(19), F(20),  \
    F(21), F(22), F(23), F(24), F(25), F(26), F(27), F(28), F(29), F(30),  \
    F(31), F(32), F(33), F(34), F(35), F(36)				   \
  }

#if !UNSIGNED && !defined (USE_WIDE_CHAR) && !defined (QUAD)
# define F(X)	ULONG_MAX / X
  DEF (unsigned long, __strtol_ul_max_tab);
# undef F
# define F(X)	ULONG_MAX % X
  DEF (unsigned char, __strtol_ul_rem_tab);
# undef F
#endif

/* Define some more readable aliases for these arrays which correspond
   to how they'll be used in the function below.  */
#define jmax_tab	__strtol_ul_max_tab
#if defined(QUAD) && __WORDSIZE == 32
# define cutoff_tab	__strtol_ull_max_tab
# define cutlim_tab	__strtol_ull_rem_tab
#else
# define cutoff_tab	__strtol_ul_max_tab
# define cutlim_tab	__strtol_ul_rem_tab
#endif

#ifdef QUAD
...
#else
# define LONG long


{htoi}

From ansic, exercise 2-3. 
Write the function htoi(s), which converts a string of hexadecimal digits (including an 'optional'
0x or 0X) into its equivalent integer value. The allowable digits are 0 through 9, a through f,
and A through F.

<mine>
int mhtoi(char s[])
{
  int n, i = 0, v = 0;

  // optional 0x or 0X
  if(s[0] == '0' && ( s[1] == 'x' || s[1] == 'X' ))
    i = 2;

  // isxdigit()
  // checks for a hexadecimal digits, that is, one of 
  // 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.
   
  for(n = 0; isxdigit(s[i]); i++)
  {
    if( s[i] >= '0' && s[i] <= '9' )
      v = s[i] - '0';
    else if( s[i] >= 'a' && s[i] <= 'f' )
      v = s[i] - 'a' + 10;
    else 
      v = s[i] - 'A' + 10;

    n = n*16 + v;
  }

  return n;
}

int main(int argc, char* argv[])
{	
  printf("0x4A is %d\n", mhtoi("0x4A"));
  printf("0x4a is %d\n", mhtoi("0x4a"));
  printf("4a is %d\n", mhtoi("4a"));
  printf("0x157DCE is %d\n", mhtoi("0x157DCE"));
} 

<online>
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_3
<1>
/*
 * I've tried hard to restrict the solution code to use only what
 * has been presented in the book at this point (page 46). As a
 * result, the implementation may seem a little naive. Error
 * handling is a problem. I chose to adopt atoi's approach, and
 * return 0 on error. Not ideal, but the interface doesn't leave
 * Richard Heathfield much choice.
 *
 * I've used unsigned int to keep the behaviour well-defined even
 * if overflow occurs. After all, the exercise calls for conversion
 * to 'an integer', and unsigned ints are integers!
 */

/* These two header files are only needed for the test driver */
#include <stdio.h>
#include <stdlib.h>

/* Here's a helper function to get Richard Heathfield around the problem of not
 * having strchr
 */
// note this is interesting to get decimal value of hex char
int hexalpha_to_int(int c)
{
  char hexalpha[] = "aAbBcCdDeEfF";
  int i;
  int answer = 0;

  for(i = 0; answer == 0 && hexalpha[i] != '\0'; i++)
  {
    if(hexalpha[i] == c)
    {
      answer = 10 + (i / 2);
    }
  }

  return answer;
}

unsigned int htoi(const char s[])
{
  unsigned int answer = 0;
  int i = 0;
  int valid = 1;
  int hexit;

  if(s[i] == '0')
  {
    ++i;
    if(s[i] == 'x' || s[i] == 'X')
    {
      ++i;
    }
  }

  while(valid && s[i] != '\0')
  {
    answer = answer * 16;
    if(s[i] >= '0' && s[i] <= '9')
    {
      answer = answer + (s[i] - '0');
    }
    else
    {
      hexit = hexalpha_to_int(s[i]);
      if(hexit == 0)
      {
        valid = 0;
      }
      else
      {
        answer = answer + hexit;
      }
    }

    ++i;
  }

  if(!valid)
  {
    answer = 0;
  }

  return answer;
}

/* Solution finished. This bit's just a test driver, so
 * I've relaxed the rules on what's allowed.
 */

int main(void)
{
  char *endp = NULL;
  char *test[] =
  {
    "F00",
    "bar",
    "0100",
    "0x1",
    "0XA",
    "0X0C0BE",
    "abcdef",
    "123456",
    "0x123456",
    "deadbeef",
    "zog_c"
  };

  unsigned int result;
  unsigned int check;

  size_t numtests = sizeof test / sizeof test[0];

  size_t thistest;

  for(thistest = 0; thistest < numtests; thistest++)
  {
    result = htoi(test[thistest]);
    check = (unsigned int)strtoul(test[thistest], &endp, 16);

    if((*endp != '\0' && result == 0) || result == check)
    {
      printf("Testing %s. Correct. %u\n", test[thistest], result);
    }
    else
    {
      printf("Testing %s. Incorrect. %u\n", test[thistest], result);
    }
  }

  return 0;
}


Testing F00. Correct. 3840
Testing bar. Correct. 0             // this is wrong since strtol do for "ba" as mine.
Testing 0100. Correct. 256
Testing 0x1. Correct. 1
Testing 0XA. Correct. 10
Testing 0X0C0BE. Correct. 49342
Testing abcdef. Correct. 11259375
Testing 123456. Correct. 1193046
Testing 0x123456. Correct. 1193046
Testing deadbeef. Correct. 3735928559
Testing zog_c. Correct. 0

<2>
#include <stdio.h>
#define HEX_LO(N) ((N) >= 'a' && (N) <= 'f')
#define HEX_HI(N) ((N) >= 'A' && (N) <= 'F')
#define HEX_NU(N) ((N) >= '0' && (N) <= '9')
#define IS_HEX(N) (HEX_LO(N) || HEX_HI(N) || HEX_NU(N))

unsigned long htoi(char []);
int main(void)
{
  int i;

  char *test[11] = {
    "F00",
    "bar",
    "0100",
    "0x1",
    "0XA",
    "0X0C0BE",
    "abcdef",
    "123456",
    "0x123456",
    "deadbeef",
    "zog_c"
  };

  for(i =0; i < 11; ++i) {
    printf("%10s %10lu\n",test[i], htoi(test[i]));
  }
  return 0;
}

unsigned long htoi(char hexstr[])
{
  int i;
  long num;
  num = 0;
  i = 0;
  char j;
  if(hexstr[0] == '0' && (hexstr[1] == 'x' || hexstr[1] =='X')) i = 2;

  while(hexstr[i] != '\0') {
    j = hexstr[i];
    if(! IS_HEX(j)) return 0;
    if(HEX_LO(j)) num = num * 16 + 10 + j - 'a';
    else if(HEX_HI(j)) num = num * 16 + 10 + j - 'A';
    else num = num * 16 + j - '0';
    i++;
  }
  return num;
}

kt@kt-ub-vb:~/work$ ./a.out 
       F00       3840
       bar          0      // here again
      0100        256
       0x1          1
       0XA         10
   0X0C0BE      49342
    abcdef   11259375
    123456    1193046
  0x123456    1193046
  deadbeef 3735928559
     zog_c          0


={============================================================================
*kt_dev_glib_002* atof

{man-page}
<atof>
NAME
       atof - convert a string to a double

SYNOPSIS
       #include <stdlib.h>

       double atof(const char *nptr);

DESCRIPTION
       The  atof() function converts the initial portion of the string pointed
       to by nptr to double.  The behavior is the same as

           strtod(nptr, (char **) NULL);

       except that atof() does not detect errors.

RETURN VALUE
       The converted value.

<strtod>       
NAME
       strtod, strtof, strtold - convert ASCII string to floating-point number

SYNOPSIS
       #include <stdlib.h>

       double strtod(const char *nptr, char **endptr);
       float strtof(const char *nptr, char **endptr);
       long double strtold(const char *nptr, char **endptr);

DESCRIPTION
       The strtod(), strtof(), and strtold() functions convert the initial
       portion of the string pointed to by nptr to double, float, and long
       double representation, respectively.

{code-glibc}
Here only consider usual char type which is not wide char and 10 base. So disregard followings:

// stdlib/atof.c
/* Convert a string to a double.  */
double
atof (const char *nptr)
{
  return strtod (nptr, (char **) NULL);
}

// stdlib/strtod.c
FLOAT
STRTOF (nptr, endptr)
     const STRING_TYPE *nptr;
     STRING_TYPE **endptr;
{
  return INTERNAL(STRTOF_L) (nptr, endptr, 0, _NL_CURRENT_LOCALE);
}

# ifdef USE_WIDE_CHAR
#  define STRTOF wcstod
#  define STRTOF_L __wcstod_l
# else
#  define STRTOF strtod
#  define STRTOF_L __strtod_l <use>
# endif

// stdlib/strtod_l.c

/* Return a floating point number with the value of the given string NPTR.
   Set *ENDPTR to the character after the last used one.  If the number is
   smaller than the smallest representable number, set `errno' to ERANGE and
   return 0.0.  If the number is too big to be represented, set `errno' to
   ERANGE and return HUGE_VAL with the appropriate sign.  */
FLOAT
____STRTOF_INTERNAL (nptr, endptr, group, loc)
     const STRING_TYPE *nptr;
     STRING_TYPE **endptr;
     int group;
     __locale_t loc;
{
  // more than 1000 lines
}


==============================================================================
*kt_dev_glib_003* itoa

{man-page}
<itoa>
NONE since it is not part of glibc and should use sprintf instead.

{code-example}
This only handles 10 base.

char* itoa(int n)
{
  char* ret = NULL;
  int nchar = 0;
  bool negative = false;

  if( n < 0 )
  {
    n = -n;
    negative = true;
    nchar++;
  }

  // how many spaces are needed?
  int temp = n;
  do {
    nchar++;
    temp /= 10;
  } while(temp);

  ret = new char[nchar+1];
  ret[nchar] = 0;

  // convert number to string
  if(negative)
    ret[0] = '-';

  int i = nchar-1;

  do {
    ret[i--] = n%10 + '0';
    n /= 10;
  } while(n);

  return ret;
}

{code-example}
From internet.
https://android.googlesource.com/kernel/lk/+/qcom-dima-8x74-fixes/lib/libc
/* Copyright (c) 2012, The Linux Foundation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * * Redistributions of source code must retain the above copyright
 *  notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 *  with the distribution.
 *   * Neither the name of The Linux Foundation nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int
itoa(int num, unsigned char* str, int len, int base)
{
  int sum = num;
  int i = 0;
  int digit;

  if (len == 0)
    return -1;

  do
  {
    // sign will remain after %
    digit = sum % base;

    if (digit < 0xA)
      str[i++] = '0' + digit;
    else
      str[i++] = 'A' + digit - 0xA; // what is it?

    sum /= base;

  }while (sum && (i < (len - 1)));

  if (i == (len - 1) && sum)
    return -1;

  str[i] = '\0';
  strrev(str); // reverse a string

  return 0;
}


==============================================================================
*kt_dev_glib_004* printf

// stdio-common/printf.c
/* Write formatted output to stdout from the format string FORMAT.  */
/* VARARGS1 */
int
__printf (const char *format, ...)
{
  va_list arg;
  int done;

  va_start (arg, format);
  done = vfprintf (stdout, format, arg);
  va_end (arg);

  return done;
}

#undef _IO_printf
ldbl_strong_alias (__printf, printf);


={============================================================================
*kt_dev_glib_005* strcpy and strncpy

{reference-code}
/* strcpy: copy t to s; pointer version 
 * lib: The strcpy() and strncpy() functions return a pointer to the destination string dest
 */
void strcpy( char *s, char *t )
{
	 while( *s++ = *t++ ) 
		  ;
}

{man-page}
#include <string.h>

char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);

DESCRIPTION
The strcpy() function copies the string pointed to by src, 'including' the terminating null byte
('\0'), to the buffer pointed to by dest. The strings may not overlap, and the destination string
dest must be large enough to receive the copy.

The  strncpy()  function  is similar, except that at most n bytes of src are copied.

       Warning: If there is no null byte among the first n bytes of src, the string  placed
       in dest will not be null-terminated.

       If the length of src is less than n, strncpy() pads the remainder of dest with null
       bytes.

       A simple implementation of strncpy() might be:

           char *
           strncpy(char *dest, const char *src, size_t n)
           {
               size_t i;

               for (i = 0; i < n && src[i] != '\0'; i++)
                   dest[i] = src[i];
               for ( ; i < n; i++)
                   dest[i] = '\0';

               return dest;
           }

NOTES
       Some  programmers consider strncpy() to be inefficient and error prone.  If the pro‐
       grammer knows (i.e., includes code to test!)  that the size of dest is greater  than
       the length of src, then strcpy() can be used.

       If  there  is  no  terminating null byte in the first n characters of src, strncpy()
       produces an unterminated string in dest.  Programmers often prevent this mistake  by
       forcing termination as follows:

           strncpy(buf, str, n);
           if (n > 0)
               buf[n - 1]= '\0';

BUGS
       If  the  destination  string  of a strcpy() is not large enough, then anything might
       happen.  Overflowing fixed-length string buffers is a favorite cracker technique for
       taking  complete  control  of  the machine.  Any time a program reads or copies data
       into a buffer, the program first needs to check that there's enough space.  This may
       be unnecessary if you can show that overflow is impossible, but be careful: programs
       can get changed over time, in ways that may make the impossible possible.

<KT> 
strcpy can be a problem in two points:
1) there is no null in src. do not know when stop copying.
2) dest is not large enough.

strncpy can be a problem.
1) there is no null in n bytes of src then dest is not null terminated. 


{glibc}
// string/strcpy.c
/* Copy SRC to DEST.  */
char *
strcpy (dest, src)
     char *dest;
     const char *src;
{
  char c;
  char *s = (char *) src;

  // this is offset between src and dest. then why -1? because used in do-loop below and increase s
  // anyway so need to -1.
  //
  // src
  // [ ] [ ] [ ] [ ]
  //                     by off
  //     [ ] [ ] [ ] [ ]
  //     dst
  //
  const ptrdiff_t off = dest - s - 1;

  do
  {
    c = *s++;
    s[off] = c;
  }
  while (c != '\0');

  return dest;
}


// string/strncpy.c
char *
STRNCPY (char *s1, const char *s2, size_t n)
{
  char c;
  char *s = s1;

  --s1;

  if (n >= 4)
  {
    size_t n4 = n >> 2;

    for (;;)
    {
      c = *s2++;
      *++s1 = c;
      if (c == '\0')
        break;
      c = *s2++;
      *++s1 = c;
      if (c == '\0')
        break;
      c = *s2++;
      *++s1 = c;
      if (c == '\0')
        break;
      c = *s2++;
      *++s1 = c;
      if (c == '\0')
        break;
      if (--n4 == 0)
        goto last_chars;
    }
    n = n - (s1 - s) - 1;
    if (n == 0)
      return s;
    goto zero_fill;
  }

last_chars:
  n &= 3;
  if (n == 0)
    return s;

  do
  {
    c = *s2++;
    *++s1 = c;
    if (--n == 0)
      return s;
  }
  while (c != '\0');

zero_fill:
  do
    *++s1 = '\0';
  while (--n > 0);

  return s;
}


={============================================================================
*kt_dev_glib_006* strlen

{man-page}
NAME
       strlen - calculate the length of a string

SYNOPSIS
       #include <string.h>
       size_t strlen(const char *s);

DESCRIPTION
       The  strlen()  function  calculates the length of the string s, excluding the terminating
       null byte ('\0').

RETURN VALUE
       The strlen() function returns the number of characters in s.

CONFORMING TO
       SVr4, 4.3BSD, C89, C99.

SEE ALSO
       string(3), strnlen(3), wcslen(3), wcsnlen(3)

{glibc}
string/strlen.c

/* Return the length of the null-terminated string STR. Scan for
   the null terminator <DN> quickly by testing four bytes at a time.  */

size_t
strlen (str) const char *str;
{
  const char *char_ptr;
  const unsigned long int *longword_ptr;
  unsigned long int longword, himagic, lomagic;

  /* Handle the first few characters by reading one character at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  // [KT] this moves a pointer until found the alignment boundary and return if found null before
  // the boundary.
  for (char_ptr = str; ((unsigned long int) char_ptr & (sizeof (longword) - 1)) != 0; ++char_ptr)
    if (*char_ptr == '\0')
      return char_ptr - str;

  /* All these elucidatory comments refer to 4-byte longwords,
     but the theory applies equally well to 8-byte longwords.  */
  longword_ptr = (unsigned long int *) char_ptr;

  /* Bits 31, 24, 16, and 8 of this number are zero. Call these bits
     the "holes." Note that there is a hole just to the left of
     each byte, with an extra at the end:

    bits:  01111110 11111110 11111110 11111111
    bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD

    The 1-bits make sure that carries propagate to the next 0-bit.
    The 0-bits provide holes for carries to fall into.  */

  himagic = 0x80808080L; 
  lomagic = 0x01010101L;

  // [KT]
  // if (sizeof (longword) > 4)
  // {
  //   /* 64-bit version of the magic.  */
  //   /* Do the shift in two steps to avoid a warning if long has 32 bits.  */
  //   himagic = ((himagic << 16) << 16) | himagic;
  //   lomagic = ((lomagic << 16) << 16) | lomagic;
  // }
  // if (sizeof (longword) > 8)
  //   abort ();

  /* Instead of the traditional loop which tests each character,
     we will test a longword at a time. The tricky part is testing
     if *any of the four* bytes in the longword in question are zero.  */
  for (;;)
  {
    longword = *longword_ptr++;
    // [KT] '&' is left-to-right and '~' is higher.
   
    /* Which of the bytes was the zero?  If none of them were, it was
       a misfire; continue the search.  */
    if (((longword - lomagic) & ~longword & himagic) != 0)
    {
      const char *cp = (const char *) (longword_ptr - 1);

      if (cp[0] == 0)
        return cp - str;
      if (cp[1] == 0)
        return cp - str + 1;
      if (cp[2] == 0)
        return cp - str + 2;
      if (cp[3] == 0)
        return cp - str + 3;
    }
    // [KT] removed the checks for sizeof(longword) > 4
  }
}

<case-one> char arr[] = {"abcdefghijkl"};

skipped a(0x61) and read four bytes as little endian.
                                       .         .         .         .
0x65646362; longword         "0110 0101 0110 0100 0110 0011 0110 0010
0x01010101; lomagic          "        1 0000 0001 0000 0001 0000 0001
0x64636261; longword-lomagic "0110 0100 0110 0011 0110 0010 0110 0001 
0x9A9B9C9D; ~logword         "1001 1010 1001 1011 1001 1100 1001 1101
0x80808080; himagic          "1000 0000 1000 0000 1000 0000 1000 0000
0x0       ; & result

<case-two> char arr[] = {"abcde"};

skipped first two and read three chars and null.

0x656463; longword       
0x00656463;                " <0000-0000> 110 0101 0110 0100 0110 0011
0x01010101; lomagic          "        1 0000 0001 0000 0001 0000 0001
0xFF646362; longword-lomagic:"1111 1111 0110 0100 0110 0011 0110 0010
0xFF9A9B9C; ~logword        :"1111 1111 1001 1010 1001 1011 1001 1100
0x80808080; himagic         :"1000 0000 1000 0000 1000 0000 1000 0000
0x80000000;                  "1000 0000 0000 0000 0000 0000 0000 0000

So if there is a null byte in the sequence then this byte will become 0x80 and if not, the end
result will be 0x0. So if the result is null, keep scanning.

<DN> There is no NULL pointer check on the input string. Of course, one can also argue that not
checking for NULL is fine as well. There is an asumption that there is an NULL in the input.


={============================================================================
*kt_dev_glib_007* fopen

fopen works for all:

char fname1[] = "./input.txt";
char fname2[] = ".//input.txt";
char fname3[] = ".///input.txt";
char fname4[] = "./if/comp.sh";
char fname5[] = "./if//comp.sh";
char fname6[] = "./if///comp.sh";


={============================================================================
*kt_dev_glib_008* isdigit

include/ctype.h

/* The spec says that isdigit must only match the decimal digits.  We
   can check this without a memory access.  */
#  undef isdigit
#  define isdigit(c) ({ int __c = (c); __c >= '0' && __c <= '9'; })

note that if there is no second part, x && y, then emits compile error.

if(({ int __c = (c); __c >= '0' && __c <= '9'; }))


={============================================================================
*kt_dev_glib_009* strcat

<ansic-example>
/* strcat: concatenate t to end of s; s must be big enough 
 * note lib version returns a pointer of resulting string
 */
void strcat( char s[], char t[] )
{
  int i, j;

  i = j = 0;
  while( s[i] != '\0' )	/* find end of s */
    i++;

  while( (s[i++] = t[j++]) != '\0' )	/* copy t */
    ;
}


={============================================================================
*kt_dev_glib_101* general tips

o use tabstop=6 to view
o each function has a single c file so search file than using a tag since tag search do not work for
some.

<def-wide>
#ifdef USE_WIDE_CHAR
# include <wctype.h>
# define L_(Ch) L##Ch
# define UCHAR_TYPE wint_t
# define STRING_TYPE wchar_t
# define ISSPACE(Ch) __iswspace_l ((Ch), loc)
# define ISALPHA(Ch) __iswalpha_l ((Ch), loc)
# define TOUPPER(Ch) __towupper_l ((Ch), loc)
#else
# if defined _LIBC \
   || defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
#  define IN_CTYPE_DOMAIN(c) 1
# else
#  define IN_CTYPE_DOMAIN(c) isascii(c)
# endif
# define L_(Ch) Ch   <use>
# define UCHAR_TYPE unsigned char
# define STRING_TYPE char
# define ISSPACE(Ch) __isspace_l ((Ch), loc)
# define ISALPHA(Ch) __isalpha_l ((Ch), loc)
# define TOUPPER(Ch) __toupper_l ((Ch), loc)
#endif


# ============================================================================
#{
==============================================================================
*kt_dev_ref*	references

{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

{ref-003} design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

{ref-005} C++ primer, 5th Ed.

==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
