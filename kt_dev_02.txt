*kt_dev_02*		tw=100

aTue 07 Jan 2014 05:07:39 GMT

Keywords:
{Q} for questions to find out more
{design-note} for design considerations

KT KB. DEVELOPMENT.

|kt_dev_quiz_001|	bits: how to swap two vars without using a temp {xor-swap-algorithm}
|kt_dev_quiz_002|	bits: how to find a item in array that appear an odd number of times.
|kt_dev_quiz_003|	array and string: how to determine if a string has all unique characters. 
|kt_dev_quiz_004|	array and string: reverse a string
|kt_dev_quiz_005|	array and string: reverse a string without duplicates
|kt_dev_quiz_006|	array and string: to check if it's anagram(permutation) of the other.
|kt_dev_quiz_007|	codility: equilibrium index of a sequence
|kt_dev_quiz_008|	codility: absolute distinct count of this array
|kt_dev_quiz_009|	i = i+j means? (from me)
|kt_dev_quiz_010|	intersects between rectangles (interview)
|kt_dev_quiz_011|	find a path in a maze {freopen}
|kt_dev_quiz_012|	get msb position
|kt_dev_quiz_013|	get the number of occurance in sequence
|kt_dev_quiz_014|	code review task
|kt_dev_quiz_015|	sorting and searching questions from {ref-004}


|kt_dev_algo_000|	sentinel
|kt_dev_algo_001|	stack {abstract-data-type}
|kt_dev_algo_002|	simple list
|kt_dev_algo_003|	general list
|kt_dev_algo_004|	queue {queue-circular-array}
|kt_dev_algo_005|	array: index shift
|kt_dev_algo_006|	the game of life
|kt_dev_algo_007|	recursion
|kt_dev_algo_008|	search: binary search {big-o-notation}
|kt_dev_algo_009|	sort {mergesort} {quicksort}
|kt_dev_algo_010|	search: table and hash {radixsort}
|kt_dev_algo_011|	binary tree {binary-search-tree} {treesort}
|kt_dev_algo_012|	avl tree 

|kt_dev_algo_050|	questions from {ref-004}: sorting and searching


|kt_dev_algo_100|	discussion: C++ map insertion and lookup performance and storage overhead


# ============================================================================
#{

==============================================================================
*kt_dev_quiz_001*	bits: how to swap two vars without using a temp

It's the standard a=a+b, b=a-b, a=a-b problem. We hired the guy who said, well, "if they're
integers, then I'd do it by a=a|b, b=a^b, a=a^b. But I don't know how to do it if they're strings."

logical OR is + and XOR is -. why? THIS IS WRONG!.

From Cracking the coding interview, p430,

| -- | ------ | ----
     a        b 

a=a+b, b=a-b, a=a-b

void swap_ari( int& first, int& second )
{
	first  = first + second;
	second = first - second; // first org
	first  = first - second; // second
}

void swap_ari_two( int& first, int& second )
{
	first  = first - second; // diff
	second = first + second; // first
	first  = second - first; // second
}

void swap_bit( int& first, int& second )
{
	first  = first | second;
	second = first ^ second; // first org
	first  = first ^ second; // second
}

void swap_bit_two( int& first, int& second )
{
	first  = first ^ second;
	second = first ^ second; // first org
	first  = first ^ second; // second
}

int _tmain(int argc, _TCHAR* argv[])
{
	int a =  9, b = 4;

	swap_ari( a , b );
	cout << "a = " << a << ", b= " << b << endl;

	a = 9; b = 4;

	swap_ari_two( a , b );
	cout << "a = " << a << ", b= " << b << endl;

	a = 9; b = 4;

	swap_bit( a , b );
	cout << "a = " << a << ", b= " << b << endl;

	a = 9; b = 4;

	swap_bit_two( a , b );
	cout << "a = " << a << ", b= " << b << endl;
	return 0;
}

Note: swap_bit_two uses [xor-swap-algorithm]. xor yield 0 when bits are the same. This means,

x = 1010; y = 0011;

x =  1001 =  1010  ^ 0011   (x^y)
y =  1010 = [1001] ^ 0011   (x^y) # y = x = (x^y)^y = (x^0)
x = [0011] =  1001 ^ [1010] (x^y) # x = y = (x^y)^x = (y^0)

x = 0011; y = 1010;

The algorithm typically corresponds to three machine code instructions.

Pseudocode 	IBM System/370 assembly 	x86 assembly
X := X XOR Y 	XR    R1,R2 				xor      eax, ebx
Y := X XOR Y 	XR    R2,R1 				xor      ebx, eax
X := X XOR Y 	XR    R1,R2 				xor      eax, ebx

In the above System/370 assembly code sample, R1 and R2 are distinct registers, and each XR
operation leaves its result in the register named in the first argument. Using x86 assembly, values
X and Y are in registers eax and ebx (respectively), and xor places the result of the operation in
the first register.


==============================================================================
*kt_dev_quiz_002*	bits: how to find a item in array that appear an odd number of times

Amazon phone interview question. 02/05/2013

//
// You are going to be passed as input an array with an interesting property: the array contains
// non-negative numbers that appear an even number of times throughout the array, save one, that
// appears an odd number of times.
//
// Your code should accept the array as input and return the number that appears an odd number of
// times as output.
//
// [1, 3, 1]   // returns 3
// [2, 4, 6, 8, 10, 12, 10, 8, 6, 4, 12, 12, 4, 2, 4]    // returns 12
// [1, 0, 1, 0, 1, 4, 4, 0, 3, 7, 0, 3, 7]    // returns 1
//

[1, 3, 1]
0001, 0011, 0001
0001 ^ 0011 ^ 0001
(0001 ^ 0001) ^ 0011 = 0000 ^ 0011 = 0011 (3)


{point}

KT: This uses the same as {xor-swap-algorithm}, that is, x^x = 0.

00	0      Y xor Y = 0  (2 times)
01 1      0 xor Y = Y  (3 times)
10 1      Y xor Y = 0  (4 times)
11 0      0 xor Y = Y  (5 times)

If do xor even times, becomes 0.

{use-xor}

	int result = 0;

	for( auto element : int_arr )
		result ^= element;

	cout << "result is " << result << endl;
	
{use-stl}

	int int_arr[] = {2, 4, 6, 8, 10, 12, 10, 8, 6, 4, 12, 12, 4, 2, 4};
	multiset< int > mset( begin(int_arr), end(int_arr));

	for( auto element : mset )
	{
		if( mset.count(element) % 2 )
			cout << element << " has " << mset.count(element) << " occurance" << endl;
	}

{codes-stl}

int find_odd_stl(int* arr, int size)
{
	 std::multiset< int> mset( begin(arr), end(arr) ); // {Q} {sizeof-problem}?

	 std::multiset< int>const_interator cit = mset.cbegin();

	 while( cit != mset.cend() )
	 {
		  if( mset.count( *cit )%2 )
				return *cit;

		  ++cit;
	 }
}


==============================================================================
*kt_dev_quiz_003*	array and string: how to determine if a string has all unique characters.

From Cracking the coding interview, p172,

Q. implement an algorithm to determine if a string has all unique characters. what if you cannot use
additional data structures?

Note: 

<1> Questions to ask for clarity. ASCII or UNICODE? Assume ASCII. If it's alphabet then it reduce
space to require so clarify specification.

<2> One simple optimization. return false if the length of input string is greater than the number
of uniques chars in the set; ASCII.


{code-c}

// false when there are multi chars
bool does_have_unique(char* str)
{
	if(!str)
		return false;

	bool bset[256] = {false};

	while(*str)
	{
		if(bset[*str])
			return false;
		else
			bset[*str] = true;

		++str;
	}

	return true;
}


{code-cpp}

#include < iostream>

using namespace std;

/*
 * time O(n) and space O(1)
 */
bool isUniqueCharSet( string &s )
{
	int sizeString = s.size();

	// ASCII is 256
	if( sizeString > 256 ) return false;

	bool bitset[256] = {false};

	for(int i = 0; i < sizeString; ++i )
	{
		int charValue = s[i];

		// already found
		if( bitset[charValue] ) // {Q} can use bitset[ s[i] ] ?
			return false;
		else
			bitset[charValue] = true;
	}

	return true;
}

/*
 * when string uses [ONLY] the lower case alphabet. int has 32 bits and save space.
 */
bool isUniqueCharSet( string &s )
{
	int sizeString = s.size();

	if( sizeString > 26 ) return false;

	int bitset = 0;

	for(int i = 0; i < sizeString; ++i )
	{
		int charValue = s[i] - 'a';

		// already found
		if( bitset & (1 << charValue) )
			return false;
		else
			bitset |= ( 1 << charValue);
	}

	return true;
}

int _tmain(int argc, _TCHAR* argv[])
{
	string input1 = "abcdefghijklmnopqa";
	string input2 = "abcdefghijklmnopqr";

	cout << "input1 is " << isUniqueCharSet( input1 ) << endl;
	cout << "input2 is " << isUniqueCharSet( input2 ) << endl;

	return 0;
}

Alternatively, can use STL multiset and count(). but not better than above in time and space. 


==============================================================================
*kt_dev_quiz_004* array and string: reverse a string

From Cracking the coding interview, p173,

Q. implement a function void reverse(char* str) in C/C++ which reverse a null-terminated string.

#include < iostream>
#include < string>

using namespace std;

void reverse_c(char* str)
{
	if(!str) return;

	char* end = str;
	char temp = 0;

	// find end of the string
	while(*end)
		++end;

	// [missed] set one char back, since last char is null and will cover when str has one length
	//  a b c \0
	// 0 1 2 3 
	--end;

	// swap chars from the start of string with the end of the string,
	// until the pointers meet in the middle
	// Note: str < end
	
	while(str < end)
	{
		temp = *str;
		*str++ = *end; // [note] 
		*end-- = temp;
	}
}

void reverse_cpp(char* str)
{
	if(!str) return;

	char *end = nullptr;

	std::string istr(str);
	std::string rstr( istr.rbegin(), istr.rend());

	end = const_cast<char*> (rstr.c_str()); // {Q} really need const_cast?

	while(*end)
	{
		*str++ = *end++;
	}
}

// if returns a string

string reverse_cpp_two(char* str)
{
	if(!str) return string();
	string istr(str);

	// {sizeof-problem} note: the below causes error as with sizeof operator problem in called function.
	// return string( begin(str), end(str) );
	
	return string( istr.crbegin(), istr.crend() );   # return temp(unnamed) string object
}

int _tmain(int argc, _TCHAR* argv[])
{
	char arr[] = "KYOUNG TAEK PARK";

	cout << "before: " << arr << endl;
	reverse_c(arr);
	cout << "after : " << arr << endl;
	cout << "---------" << endl;

	cout << "before: " << arr << endl;
	reverse_cpp(arr);
	cout << "after : " << arr << endl;
	cout << "---------" << endl;

	cout << "before: " << arr << endl;
	cout << "after : " << reverse_cpp_two(arr) << endl;

	return 0;
}


==============================================================================
*kt_dev_quiz_005* array and string: reverse a string without duplicates

From the internet

Write a program to reverse a string with all its duplicates removed. Only the
last instance of a character has to appear. Also, the following conditions are
to be satisfied: (Assume only Capital Letters).

Minimum Time, Minimum Space, Minimum Lines of Code


before: JTVAKAVISHAAAL
inter : JTVAKISHL
after : LHSIKAVTJ


#include < iostream>
#include < string>

using namespace std;

string reverse(string instr)
{
	if(instr.empty()) return string();

	string outstr = "";
	int input_size = instr.size();	
	int bitset = 0, value = 0;

	for( int index=0; index < input_size; ++index)
	{
		value = instr[index] - 'A';

		// seen first.
		// Note: only count the first occurance as it will be the last in the
		// reverse.
		if( !(bitset & (1<<value)) )
		{
			//outstr.append( 1, instr[index] );
			outstr += instr[index];
			bitset |= (1<<value);
		}
	}

	return string( outstr.rbegin(), outstr.rend());
}

int _tmain(int argc, _TCHAR* argv[])
{
	string input1 = "JTVAKAVISHAAAL";
	string input2 = "AVISHAL";

	cout << "before: " << input1 << endl;	
	cout << "after : " << reverse(input1) << endl;
	cout << "---------" << endl;

	cout << "before: " << input2 << endl;	
	cout << "after : " << reverse(input2) << endl;
	cout << "---------" << endl;

	return 0;
}

Output:

before: JTVAKAVISHAAAL
after : LHSIKAVTJ
---------
before: AVISHAL
after : LHSIVA
---------


==============================================================================
*kt_dev_quiz_006* array and string: to check if it's anagram(permutation) of the other.

From Cracking the coding interview, p174,

Q. Given two strings, write a method to decide if one is a permutation of the other. 
bool func(string &one, string &two);

Note: questions to ask for clarity.
1. case sensitive? such as God or dog?
2. whitespace is significant? such as "god   " and "dog".
3. ASCII?

Assume that all are the case. Optimization? if they are different lengths then they cannot be
anagrams.


{code-cpp}

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

// simple, clean and easy to understand
//
bool anagram_one(string& one, string& two)
{
	// input error check
	if( one.size() != two.size() ) return false;

	sort(one.begin(), one.end());
	sort(two.begin(), two.end());

	return ( one == two );
}

// if efficiency is very important
//
bool anagram_two(const string& one, const string& two)
{
	// input error check
	int oneSize = one.size(), twoSize = two.size();

	if( oneSize != twoSize ) return false;

	// assume ASCII set
	int charSet[256] = {0};

	// iterate one string to count num of each char
	for( int nIndex = 0; nIndex < oneSize; ++nIndex )
	{
		++charSet[one[nIndex]];
	}

	for( int nIndex = 0; nIndex < twoSize; ++nIndex )
	{
		// seen first, then not the anagram
		if( charSet[two[nIndex]] == 0 )
			return false;
	}

	return true;
}


int _tmain(int argc, _TCHAR* argv[])
{
	string input1 ="PARK";
	string input2 ="APRK";

	if(anagram_one( input1, input2 ))
		cout << "they are anagram" << endl;
	else
		cout << "they aren't anagram" << endl;


	string input3 ="PARK";
	string input4 ="APRK";

	if(anagram_two( input1, input2 ))
		cout << "they are anagram" << endl;
	else
		cout << "they aren't anagram" << endl;

	return 0;
}


==============================================================================
*kt_dev_quiz_007* codility: equilibrium index of a sequence

The equilibrium index of a sequence is an index such that the sum of elements at lower indexes is
equal to the sum of elements at higher indexes. For example, in a sequence A:

A[0]=-7 A[1]=1 A[2]=5 A[3]=2 A[4]=-4 A[5]=3 A[6]=0

3 is an equilibrium index, because: A[0]+A[1]+A[2]=A[4]+A[5]+A[6]

6 is also an equilibrium index, because: A[0]+A[1]+A[2]+A[3]+A[4]+A[5]=0 (The sum of zero elements
is zero) 

7 is not an equilibrium index - because it is not a valid index of sequence A. If you still have
doubts, here is a precise definition: The integer k is an equilibrium index of a sequence
A[0],A[1]..,A[n-1] if and only if 0<= k and sum(A[0..(k-1)])=sum(A[(k+1)..(n-1)]). Assume the sum of
zero elements is equal to zero.

Write a function

int equi(int A[], int n)

that, given a sequence, returns its equilibrium index (any) or -1 if no equilibrium index exists.
Assume that the sequence may be very long. 

The problem can be solved by using various approaches, the most common being simply to follow the
equilibrium definition:

// while moving index, continues to sum right and left sum.
//
int equi ( int A[], int n ) {

	 int k, m, lsum, rsum; 

	 for(k = 0; k < n; ++k) { 
		  lsum = 0; rsum = 0;
		  for(m = 0; m < k; ++m) lsum += A[m]; 
		  for(m = k + 1; m < n; ++m) rsum += A[m];  
		  if (lsum == rsum) return k;
	 } 
	 return -1; 
} 

Unfortunately, this approach has two disadvantages:

o it fails on large input data sets, since the time complexity is O(n2)
o it fails on large input values (for example if the input array contains values like MIN/MAX_INT)
due to the arithmetic overflows

We can fix the first problem with a better algorithm, and the second problem with a better data-type
(for example, using long long type instead of int for sum computations). The key observation for
better running time is to update the left/right sums in constant time instead of recomputing them
from the scratch.

O(n)

int equi(int arr[], int n) {
	 
	 if (n==0) return -1; 

	 long long sum = 0;
	 int i; 

	 for(i=0;i<n;i++) sum+=(long long) arr[i]; 

	 long long sum_left = 0;    

	 for(i=0;i<n;i++) {
		  long long sum_right = sum - sum_left - (long long) arr[i];

		  if (sum_left == sum_right)
		  		return i;

		  sum_left += (long long) arr[i];
	 } 

	 return -1; 
} 


==============================================================================
*kt_dev_quiz_008* codility: absolute distinct count of this array

A non-empty zero-indexed array A consisting of N numbers is given. The absolute distinct count of
this array is the number of distinct absolute values among the elements of the array.

For example, consider array A such that:

A[0] = -5    A[1] = -3    A[2] = -1
A[3] =  0    A[4] =  3    A[5] =  6

The absolute distinct count of this array is 5, because there are 5 distinct absolute values among
the elements of this array, namely 0, 1, 3, 5 and 6.

Write a function:

int absDistinct(int A[], int N);

that, given a non-empty zero-indexed array A consisting of N numbers, returns absolute distinct
count of array A.

For example, given array A such that:

A[0] = -5    A[1] = -3    A[2] = -1
A[3] =  0    A[4] =  3    A[5] =  6

the function should return 5, as explained above.

Assume that:

N is an integer within the range [1..100,000]; each element of array A is an integer within the
range [-2,147,483,648..2,147,483,647]; array A is sorted in non-decreasing order.

Complexity:

expected worst-case time complexity is O(N);
expected worst-case space complexity is O(N), beyond input storage (not counting the storage
required for input arguments).

Elements of input arrays can be modified.


#include <iostream>
#include <algorithm>
#include <vector>
#include <set>

using namespace std;

bool absLessThan(int a, int b)
{
	return abs(a) < abs(b);
}

bool absEqual(int a, int b)
{
	return abs(a) == abs(b);
}

int absDistinct(int A[], int N)
{
	if(N==0)
		return -1;

	vector<int> ivec;
	int count = 0;

	for(int i = 0; i < N; ++i)
		ivec.push_back( *(A+i) );

	sort( ivec.begin(), ivec.end(), absLessThan );
	auto it_end_unique = unique( ivec.begin(), ivec.end(), absEqual );

	auto it_begin = ivec.begin();

	while( it_begin != it_end_unique )
	{
		++it_begin;
		++count;
	}

	return count;
}

int absDistinct_set(int A[], int N)
{
	if(N==0)
		return -1;

	set<int> iset;

	for(int i = 0; i < N; ++i)
		iset.insert( abs(*(A+i)) );

	return iset.size();
}


int _tmain(int argc, _TCHAR* argv[])
{
	int iarray[] = {-5, -3, -1, 0, 3, 6};

	int ret = absDistinct(iarray, 6);
	cout << ret << endl;

	ret = absDistinct_set(iarray, 6);
	cout << ret << endl;

	return 0;
}


==============================================================================
*kt_dev_quiz_009* i = i+j means? (from me)

its meaning depends on its type as type decides operations that can be used on that type.
if it's arith type, this means addition. what if these are of class type?


==============================================================================
*kt_dev_quiz_010* intersects between rectangles (interview)

From NDS interview. 

Problem: implement the intersects method contained within the rectangle class below. The method
should return true if the supplied rectangle intersects with the internally represented rectangle.

Solution:

(x1,y1)
   +--------+
	|        |
	|        |        (x3,y3)
	+--------+           +--------+
	       (x2,y2)    	|        |
                     	|        |
                     	+--------+
                     	       (x4,y4)

- ---------------------------------------> x axis

struct point {
	unsigned int x;
	unsigned int y;
};

struct rect {
	point upp;
	point bot;
};

void printrect( const char* name, const rect &r)
{
	std::cout << "rect : " << name << ": {" << r.upp.x << ", " << r.upp.y << "} - > {" << r.bot.x << ", " << r.bot.y << "}" << std::endl;
}

bool isinrange( const unsigned int x1, const unsigned int x2, const unsigned int z)
{
	return ( ((x1 < z ) && ( z < x2)) || ((x2 < z ) && ( z < x1)) );
}

bool intersect( const rect& r1, const rect& r2)
{
	bool xi = false, yi = false;

	xi = isinrange( r1.upp.x, r1.bot.x, r2.upp.x ) || isinrange( r1.upp.x, r1.bot.x, r2.bot.x );
	/*
	if(( r1.upp.x < r2.upp.x < r1.bot.x ) || ( r1.bot.x < r2.upp.x < r1.upp.x ) || \
		 ( r1.upp.x < r2.bot.x < r1.bot.x ) || ( r1.bot.x < r2.bot.x < r1.upp.x ))
		 xi = true;
	*/
	yi = isinrange( r1.upp.y, r1.bot.y, r2.upp.y ) || isinrange( r1.upp.y, r1.bot.y, r2.bot.y );
	/*
	if(( r1.upp.y < r2.upp.y < r1.bot.y ) || ( r1.bot.y < r2.upp.y < r1.upp.y ) || \
		 ( r1.upp.y < r2.bot.y < r1.bot.y ) || ( r1.bot.y < r2.bot.y < r1.upp.y ))
		 yi = true;
	*/
	return (xi && yi);
}

int _tmain(int argc, _TCHAR* argv[])
{
	char* cp;

	bool ret = false;

	rect one ={10,10,20,20};
	rect two ={15,15,25,25};

	printrect("one", one );
	printrect("two", two );

	ret = intersect(one, two);

	std::cout << "ret is %d\n" << ret << std::endl;

	cp = func1("this is a test string.");

	std::cout << "cp is:" << cp << std::endl;
}


==============================================================================
*kt_dev_quiz_011* find a path in a maze

From SS.

You are given an N*N matrix with white, black, or gray cells. You have to find a white path from
(1, 1) to (N, N). 

Here (1, 1) means the top-leftmost cell and (N, N) means th bottom-rightmost cell. You can move from
one cell to an 

o horizontally, vertically, or diagonally adjacent cells.

o You cannot visit a cell more than once. # condition

o one gray cell is given and your path must visit the gray cell in the path. 

The cells (1, 1) and (N, N) cannot be the gray cell. Your path does not have to be the shortest
path. Given an N*N matrix with white cells, black cells, and a gray cell. Generate a program that
finds a white-cell path from (1, 1) to (N, N) which visits the gray cell in the middle of the path.

o should visit green cell first.

This problem can be difficult for some special cases. To ease the problem, there are not more than
four white cells adjacent to the gray one. For partial points, a considerable part of the test cases
will be rather easy. 

In three of the test cases, just finding a path from (1, 1) to the gray cell and then finding a path
from the gray cell to (N, N) will always find a successful path. 

And in other three of the test cases, only ** two white cells will be adjacent to the gray cell. It
will be guaranteed that all of the test cases will have a solution. That is, it will be always
possible to find a valid path.

  
[Constraints]
5=N=100.

[Input]
10 test cases are given. In each case, the first line has N, the dimension of the matrix, and the
next N lines show the shape of the matrix. 

o A black cell is represented by 1, a white cell by 0, and the gray cell by 2. 
  
[Output]
Write the 10 answers in 10 lines. Each line starts with #x where x means the index of a case, puts
a space, and then prints a path. A path is represented by the coordinates of cells visited in order.
A coordinate is represented by row column. For example, in the matrix below, the only successful
path is (1, 1)->(2, 1)->(3, 2)->(3, 3); it is represented in the output as 1 1 2 1 3 2 3 3.


<code-frame>

#include<iostream>

using namespace std;

int A[101][101], N;
int Answer1[10001], Answer2[10001], AnswerN;

int main(int argc, char** argv)
{
	int test_case;
	/*
	   freopen function below opens input.txt file in read only mode, and afterward,
	   the program will read from input.txt file instead of standard(keyboard) input.
	   To test your program, you may save input data in input.txt file,
	   and use freopen function to read from the file when using scanf function.
	   You may remove the comment symbols(//) in the below statement and use it.
	   But before submission, you must remove the freopen function or rewrite comment symbols(//).
	 */
	// freopen("input.txt", "r", stdin);


	/*
	   Your program should handle 10 test cases given.
	 */
	for(test_case = 1; test_case <= 10; ++test_case)
	{
		int i, j;

		/*
		   Read each test case from standard input.
		   The dimension of the matrix will be stored in variable N,
		   and the matrix will be stored in an array A[1..N][1..N].
		 */
		cin >> N;
		for(i = 1; i <= N; i++)
		{
			for (j = 1; j <= N; j++)
			{
				cin >> A[i][j];
			}
		}


		/////////////////////////////////////////////////////////////////////////////////////////////
		/*
		   Implement your algorithm here.
		   The length of the path will be stored in variable AnswerN,
		   and the coordinates will be stored in arrays (Answer1[1..AnswerN], Answer2[1..AnswerN]).
		 */
		/////////////////////////////////////////////////////////////////////////////////////////////
		AnswerN = 1;
		Answer1[1] = Answer2[1] = 0;


		// Print the answer to standard output(screen).
		cout << "#" << test_case;
		for(i = 1; i <= AnswerN; i++) cout << " " << Answer1[i] << " " << Answer2[i];
		cout << endl;
	}

	return 0; //Your program should return 0 on normal termination.
}


<test-cases>

5
0 0 0 0 0
1 1 1 1 0
0 0 0 0 0
0 1 1 1 1
2 0 0 0 0
10
0 1 0 1 0 1 0 0 0 1
0 1 0 1 0 1 1 1 0 1
0 0 0 0 0 1 0 0 0 1
0 1 0 1 1 1 0 1 1 1
0 1 2 1 0 0 0 0 0 1
1 1 0 1 0 1 1 1 1 1
0 1 0 0 0 0 0 1 0 1
0 1 1 1 0 1 1 1 0 1
0 0 0 0 0 0 0 0 0 1
1 1 1 1 1 1 1 1 1 0
15
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 1 0 0 0 1 0 1 0 1 0 1 0
0 1 0 0 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 0 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 0 1
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1
0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1
0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 0 1
0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 1
0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1
0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1
0 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
29
0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0
0 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1 0 1 0 1 0
0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 1 1 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 0 1 1 1 0 1 0 1 0
0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0
0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0
0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0
0 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 1 1 1 1 0 1 0 1 1 1 1 1 0
0 1 0 0 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0
0 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1 1 1 0 1 0 1 1 1 0
0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0
0 1 1 1 1 1 0 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1 0
0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
0 1 0 0 0 1 0 1 0 0 0 1 0 1 1 1 0 0 0 0 0 0 0 1 0 1 0 0 0
0 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 1
0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 1 0 1 0 0 0 0 0 1 0 0 0
0 1 0 1 0 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 1 1 0 1 0
0 1 0 1 0 0 0 0 0 1 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 1 0 1 0
1 1 1 1 1 1 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 1 0 1 0 1 0 1 1
0 0 0 0 0 0 0 0 0 1 0 1 0 1 1 1 0 0 0 1 0 0 0 1 0 0 0 1 0
1 1 1 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 0 1 0 1 0
0 0 0 1 0 1 0 1 0 0 0 0 0 1 1 1 0 1 0 0 0 1 0 1 0 1 0 0 0
0 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 0
0 1 0 0 0 0 0 1 0 0 0 1 0 1 1 1 0 0 0 1 0 0 0 1 0 1 0 1 0
1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 1 0 1 1
0 0 0 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0

There are more up to 99.
  

==============================================================================
*kt_dev_quiz_012* get msb position

From SS in which a problem to get how many bits are the same between two integers. For example:

A = 35 = 10 0011
B =  9 =    1001
Ans = 2 because only count bit position which are position in both integers.


#include <iostream>

using namespace std;

unsigned int A, B, Answer;

int main(int argc, char** argv)
{
	int test_case;

	freopen("input.txt", "r", stdin);
	
	//A = 35; B = 9;
	
	for(test_case = 1; test_case <= 10; test_case++)
	{
		cin >> A; cin >> B;

		if( (A <0) || (B<0))
			return -1;
			 
		int shift = 0, msb = 0, target = 0;
		Answer = 0;

		target = min(A, B);

		// get msb position
		for(shift = 0; shift < 10; shift++)
		{
			if( target & (1<<shift))
				msb = shift;
		}

		for( shift = 0; shift <= msb; shift++)
		{
			if( (A & (1<<shift)) == (B & (1<<shift)) )
				Answer++;
		}
		
		cout << "#" << test_case << " " << Answer << endl;
	}

	return 0;//
}

==============================================================================
*kt_dev_quiz_013* get the number of occurance in sequence {interview}

From Park-in when have a interview at BB. When input is "AAABBBCCCCDDD" then write func that returns
C and 4

<code-eample>

#include < iostream>

#define GT(a,b)	((a)>(b))

void getLargestOccurance(int size, const char* input)
{
   if( size==0 || input==nullptr )
      return;

   unsigned int countCurrent = 1, countMax = 1; 
	char charCurrent = input[0], charMax = 0;

   for(int i = 1; i < size; ++i )
   {
     if( charCurrent^input[i] ) 
     {
		  if( GT( countCurrent, countMax ))
		  {
			  	countMax = countCurrent;
				charMax 	= charCurrent;
		  }
			  
        charCurrent = input[i];
        countCurrent = 1;
     }
     else
        countCurrent++;
   }

	std::cout << "max: (" << charMax << ", " << countMax << ")" << std::endl;
}

int main()
{
   //const char* input = "AAABBCCCCDDD";
   //const char input[] = "AAABBCCCCDDD";
   const char input[] = "AAABBCCCCDDDEEFFFFFFFFFFFFFFFFFFHHHSSSSSSSSSS";

   getLargestOccurance(sizeof(input)/sizeof(input[0]), input);
}


<follow-ups>

Follow-up questions:

1. how to handle when there are many with the same length?
2. how to modify to print the first when there are many with the same length?
3. how to draw out complexity?
4. is there any other way to reduce complexity?


<second-approach-from-me>

Use multimap< occurance, char* > and get the end iterator-1 which is the biggest occurance because
it is ordered map. Use find() to get the iterator to the first element of the same occurance.

This requires O(n) to scan through the input and O(logn) to use find() since map uses red-black
tree.

<suggested-solution>

If first sequence ends meaning see a new character, see the first character and character[current +
the current max(first occurance)-1] since array index starts from 0 and count starts from 1:
	if it is different, then means there is/are new sequences which are less than the first. So
	continue looking sequence by skipping with the current max occurance. 

	if it is the same, then means it is bigger sequence than the first and find the end and update
	the max occurance. If the occurance is bigger then the previous, update occurance and string.

If think only the first or last sequence of the same occurance, then it is less than O(n) since it
is skipping characters while scanning. So better than using a map.

If requires to maintain the set of the same occurance, then need to data structure to hold and it
depends on requirements such as searching, insertion and deletion.


==============================================================================
*kt_dev_quiz_014* code review task {interview}

Code Review Task

Code Review:
systematic examination (often as peer review) of computer source code intended to find and fix
mistakes overlooked in the initial development phase, improving both the overall quality of software
and the developers' skills.

The aim of this task is to examine a piece of code that your colleague has written. You must
critically analyse and report on the quality of the code and review it for any mistakes, bugs or
issues that you feel are present. You can make any comments, improvements or suggestions that you
feel are appropriate about style, design and logic.

Please write any review comments inline in the code below in bold red text.

There is no time or word limit but try to not spend too long completing the task. Treat it as if it
were a real review in your day as a developer.

This example is massively contrived and intentionally badly coded; don't expect code like this in
your day to day life.


General Comments On Code:

#include <cstdio>
#include <cstring>
#include <map>
#include <iostream>
#include <string>

/*
// Read file in
// Stock, TimeInterval, Volume Traded, High, Low.
VOD.L 1 100 184.0 183.7
BT.L 1 14 449.4 448.2 
VOD.L 2 434 184.1 182.4
BT.L 2 234 449.8 449.5
..

// Find the total volume traded for each stock
// Find the high and low for each stock.

// Write file a to stdout
// Per stock per interval output the %volume traded in that interval as a percentage of the whole day
// Stock, Interval, %Vol for day.

VOD.L,1,2.0
BT.L,1,1.1
VOD.L,2,8.2
BT.L,2,19.0

// Write file b to stdout
// Stock, day high, day low
VOD.L,186.7,182.4
BT.L,445.3,450.9
*/

using namespace std;
typedef basic_string<char> string;

class	CHighLow
{
public:
	CHighLow() : nCurLow(0), nCurHigh(0) {};

	void	add(int nHigh, int nLow)
	{
		if (nHigh > nCurHigh)
			nCurHigh = nHigh;
			
		if (nLow < nCurLow)
			nCurLow = nLow;
	}
	
	int		nCurLow;
	int		nCurHigh;
};

int main(int argc, char* argv[])
{
	if (!strcmp("version", argv[1]))
	{
		cerr << "Using version 1.0 VWAPer" << endl;
		return 0;
	}
		
	FILE*	file = fopen(argv[2], "r");
	
	cerr << "Reading file" << argv[2] << endl;
	
	char	line[256];
	char	Stocks[1000][10];
	int	Intervals[1000];
	int	Volumes[1000];
	float	Highs[1000];
	float	Lows[1000];
	
	int	i = 0;
	int	sum = 0;
	
	// read input file
	while (fgets(line, 256, file))
	{
		sscanf(line, "%s %d %d %f %f", 
         Stocks[i], &Intervals[i], 
         &Volumes[i], &Highs[i], &Lows[i++]);
   }
	
	cerr << "Calculating total volumes" << endl;
	
	// [KT] for each stock, loop through all inputs and add volumes to get the total. Given map used,
	// the same stock lines in the input will be merged into the one stock.

	map<std::string, int>		TotalVolumes;
	
	for (int s = 0; s <= i; ++s)
	{
		std::string	stockname = Stocks[s];
	
		for (int j =0; j <= i; ++j)
		{
			if (!strcmp(Stocks[j], stockname.c_str()))
			{
				TotalVolumes[stockname] += Volumes[j];
			}
		}
	}
	
	cerr << "Calculating high lows" << endl;
	
	map<std::string, CHighLow>	HighLows;
	
	for (int s = 0; s <= i; ++s)
	{
		HighLows[Stocks[s]].add(Highs[s], Lows[s]);
	}
	
	cerr << "Writing files" << endl;
	
	// [KT] However here write out each stock so need to maintain duplicated stocks.
	
	// write file a
	for (int s = 0; s <= i; ++s)
	{
		cout << Stocks[s] << "," << Intervals[s] << "," 
			<< TotalVolumes[Stocks[s]] / Volumes[s] * 100 << endl;
	}
	
	// write file b
	map<std::string, CHighLow>::iterator itr = HighLows.begin();
	while (itr != HighLows.end())
	{
		cout << (*itr).first << "," << (*itr).second.nCurLow << "," << (*itr).second.nCurHigh << endl;
		++itr;
	}
	
	return 1;
}


{review-by-kit}

1. map a file to stdin: freopen( argv[1], "r", stdin ); See {freopen} and use string getline
2. use cpp way throughout to have consistency so use a class to cal and hold totalvolume, high and
low and. uses a map< stockname, class or object > since these values are for each stock summing up
duplicates.

3. how about getting volume % for every stock of input which has duplicates? Or, for 3 and 4, use
multimap? 

No seems to be better to use sequential container such as vector for a whole input and have two maps
out of it to rempove duplicates. If space is important then could have one map for both; total
volume and highlow.


{review-by-ian}

General Comments On Code:

<1> 
File header is missing. If it is a real situation, I would strongly complaining like "no comment on
each classes and functions at all"

#include <cstdio>
#include <cstring>
#include <map>
#include <iostream>
#include <string>

/*
// Read file in
// Stock, TimeInterval, Volume Traded, High, Low.
VOD.L 1 100 184.0 183.7
BT.L 1 14 449.4 448.2 
VOD.L 2 434 184.1 182.4
BT.L 2 234 449.8 449.5
..

// Find the total volume traded for each stock
// Find the high and low for each stock.

// Write file a to stdout
// Per stock per interval output the %volume traded in that interval as a percentage of the whole day
// Stock, Interval, %Vol for day.
VOD.L,1,2.0
BT.L,1,1.1
VOD.L,2,8.2
BT.L,2,19.0

// Write file b to stdout
// Stock, day high, day low
VOD.L,186.7,182.4
BT.L,445.3,450.9
*/

using namespace std;
<2>
I would prefer not to use std namespace. Consider using standard library with 'std::' prefix.

typedef basic_string<char> string;
<3>
In most of case this type definition is not necessary.

class	CHighLow
{
public:
	CHighLow() : nCurLow(0), nCurHigh(0) {};
	<4>
	Setting the initial value of nCurLow to zero is wrong. Define a constant variable like
	'MAX_PRICE' with large integer value and set it to nCurLow. Otherwise, you need to add another
	comparison in add() function. For a case when there is an input with value 0.

	void	add(int nHigh, int nLow)
	<5>
	As the high and low values are float value, change the type of parameters to float
	{
		<6> Need to check if nHigh is lower than nLow and handle the case properly
		if (nHigh > nCurHigh)
			nCurHigh = nHigh;
			
		if (nLow < nCurLow)
			nCurLow = nLow;

		<7> If you set nCurLow to zero, this would not be working at all. You need to assign nLow to
			nCurLow if nCurLow is zero for it. However I would prefer setting initial value with
			maximum value.  
	}
	

	int		nCurLow;
	int		nCurHigh;
	<8>
	As the input has floating point, define those variables as float. Prefer a prefix m_ for the
	names of member variables. Member variables should be under the private keyword 
};


int main(int argc, char* argv[])
{
	if (!strcmp("version", argv[1]))
	{
		cerr << "Using version 1.0 VWAPer" << endl;
		return 0;
	}
	<9>
	This comparison is ambiguous. Please put comments explaining why the first argument should not be
	'version'

	FILE*	file = fopen(argv[2], "r");

	<10>
	Consider using ifstream. You did not check if there is the second argument. Otherwise you will
	see a segmentation fault when argv[2] is null.

	cerr << "Reading file" << argv[2] << endl;

	<11> 
	Add a white space after the log message otherwise file and argv[2] will be put together so file
	name will be looking weird.

	char	line[256];

	<12> 
	If you are sure a line is not longer than 256 bytes this is ok, however please define a constant
	variable like MAX_LINE_LENGTH rather than just using the number.


	char	Stocks[1000][10];
	<13>
	Like above comment, you should define MAX_STOCK_NAME_LENGTH instead of putting 10.  You assume
	the input file has 1000 lines at most. This is limitation. I will suggest better design later.
	Anyway define MAX_INPUT_LINE_COUNT as above.

	int	Intervals[1000];
	int	Volumes[1000];
	float	Highs[1000];
	float	Lows[1000];

	int	i = 0;
	int	sum = 0;
	<14>	sum is not used at all. Delete this.
	
	// Replace 256 to MAX_LINE_LENGTH. If you use ifstream, getLine function can replace this. If you use
	// ifstream, cin can replace sscanf

	while (fgets(line, 256, file))
	{
		sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], &Highs[i], &Lows[i++]);

	<15> [KT] this is big thing
	You made big mistake here. Increasing i in the parameter is very dangerous. The evaluation order
	of function parameter is undefined in spec and usually they are evaluated in reverse order in
	most of compilers. Therefore i will be increased firstly and the data for
	Stocks,Intervals,Volumes and Highs will be stored in the next row. The data will be totally
	mangled. Increase i in the separated line.

	}
	
	cerr << "Calculating total volumes" << endl;
	
	map<std::string, int>		TotalVolumes;
	
	for (int s = 0; s <= i; ++s)
	// change 's <=i' to 's < i'
	{
		std::string	stockname = Stocks[s];
		// No reason to create string object. Please avoid unnecessary object creation and memory copy
	
		for (int j =0; j <= i; ++j)
		// Change 'j <=i' to 'j < i'
		{
			if (!strcmp(Stocks[j], stockname.c_str()))
			// So this just can be comparing Stocks[j] and Stocks[s]
			{
				TotalVolumes[stockname] += Volumes[j];
				// Map can work with char* even though it's key is string type. Just use Stocks[s] here.
				// [KT] may disagree since will cause creating a temp string objects.
			}
		}
	}

	This double looping is really bad idea especially when the input file is huge. Exponential
	complexity is expected and we can avoid this problem by adopting a new design. I will describe
	later.


	cerr << "Calculating high lows" << endl;
	
	map<std::string, CHighLow>	HighLows;
	// You use this type of map later again. Set a typedef for the readability.
	
	for (int s = 0; s <= i; ++s)
	// Change 's <=i' to 's < i'
	{
		HighLows[Stocks[s]].add(Highs[s], Lows[s]);
	}
	// Calculating high and low value could be done while reading file. Running another loop is not
	// necessary. 

	
	cerr << "Writing files" << endl;
	
	for (int s = 0; s <= i; ++s)
	// Change s <=i to s < i
	{
		cout << Stocks[s] << "," << Intervals[s] << "," 
			<< TotalVolumes[Stocks[s]] / Volumes[s] * 100 << endl;

	// <xx> You don't want to devide by zero when Volume[s] is zero. Check the volume in advance and
	// handle the case properly.
	}

	
	map<std::string, CHighLow>::iterator itr = HighLows.begin();
	// Writing the whole definition of map is stressful always. Prefer using typedef as I mentioned
	// before.

	while (itr != HighLows.end())
	// For this simple iteration, for( ; itr != HighLows.end() ; ++itr) is useful. You would never
	// need to worry about not increasing the iterator with it.
	{
		cout << (*itr).first << "," << (*itr).second.nCurLow << "," << 
			(*itr).second.nCurHigh << endl;
		
		++itr;
	}

	return 1;
}


<design-suggestion>

You can slightly improve collecting and writing logic by adopting a wrapper class. So you can call
add() function to collect, and can do 'cout << highLowMapper' for printing out.

class CHighLowMapper
{
	public:
		CHighLowMapper() {};
		void add(const char* stock, int nHigh, int nLow) {
			m_HighLows[stock].add(nHigh, nLow);
		}

		friend ostream& operator<<(ostream& os, const CHighLowMapper& hlm) {
			HLMap::const_iterator itr = hlm.m_HighLows.begin();
			while (itr != hlm.m_HighLows.end())
			{
				cout << (*itr).first << "," << (*itr).second.nCurLow << "," 
					<< (*itr).second.nCurHigh << endl;
				++itr;
			}
			return os;
		}

	private:
		typedef map<std::string, CHighLow> HLMap;
		HLMap    m_HighLows;
};


The double looping to calculate the total volume must be replaced with better logic. Here is a class
to collect volume information and accumulate the total volume for each stock. Therefore the required
information can be collected in the file reading loop. This class overrides operator >> therefore
users are able to printout the result using cout. CVolumeCollector takes maxSize for the vector
reservation. If flexibility and scalability are more important than performance, you can omit it.

class CVolumeCollector
{
	public:
		struct VolumeInfo{
			string stock;
			int interval;
			int volume;
		};

      CVolumeCollector(int maxSize = 0) {
		if(maxSize > 0) {
                m_volumeInfoList.reserve(maxSize);
             }
      };

		void add(const char* stock, int interval, int volume) {
			VolumeInfo vi;
			vi.stock = stock;
			vi.interval = interval;
			vi.volume = volume;

			m_volumeInfoList.push_back(vi);
			m_volumes[stock] += volume;
		}

		const int getVolumeForStock(const string& stock) const {
			int totalVolume = 0;
			VolMap::const_iterator itr = m_volumes.find(stock);
			if(itr != m_volumes.end()) {
				totalVolume = itr->second;
			}
			return totalVolume;
		}

		friend ostream& operator<<(ostream& os, const CVolumeCollector& vc) {
			VolInfoVec::const_iterator itr = vc.m_volumeInfoList.begin();
			while(itr != vc.m_volumeInfoList.end()) {
				cout << (*itr).stock << "," << (*itr).interval << "," 
					<< vc.getVolumeForStock((*itr).stock) / (*itr).volume * 100 
					<< endl;
				++itr;
			}
			return os;
		}

	private:
		typedef map<string, int> VolMap;
		VolMap  m_volumes;

		typedef vector< VolumeInfo > VolInfoVec;
		VolInfoVec m_volumeInfoList;
};

Using CVolumeCollector and CHighLowMapper described above, the main function is much simpler and
well structured.

int main(int argc, char* argv[])
{
	// omitted
	char	line[MAX_LINE_LENGTH];
	
	CHighLowMapper hlm;
	CVolumeCollector vc(MAX_INPUT_FILE);
	while (fgets(line, MAX_LINE_LENGTH, file))
	{
		char stock[MAX_STOCK_NAME_LENGTH];
		int interval;
		int volume;
		float high;
		float low;
		sscanf(line, "%s %d %d %f %f", stock, &interval, &volume, &high, &low);
		hlm.add(stock, high, low);
		vc.add(stock, interval, volume);
	}
	cout  << "Writing files"  << endl;
	// write file a
	cout << vc;
	// write file b
	cout << hlm;
	return 1;
}


==============================================================================
*kt_dev_quiz_015* sorting and searching questions from {ref-004}

1. You are given two sorted arrays, A and B, where A has a large enough buffer at the end to hold B.
Write a method to merge B int A in sorted order.

2. Write a method to sort an array of strings so that all the anagrams are next to each other.


# ============================================================================
#{

==============================================================================
*kt_dev_algo_000*	sentinel

{hedge-or-sentinel}

From {ref-001}. A hedge or sentinel is an extra entry put into a data structure so that boundary
conditions need not be treated as a [special-case]. For example of this life game, need to check if
it is in the array when counting neighbours. Can avoid complicated checks by having extra lows and
columns:

arr[MAXROW+2][MAXCOL+2];

0 1 2 3 .... MAX MAX+1
1 X
2
3
.
.
MAX
MAX+1

Where all operation performs in range of [1, MAX] dimension and no need to boundary check when doing for X.


==============================================================================
*kt_dev_algo_001*	stack

A stack is a version of a list that is particularly useful in applications involving reversing. This
is contiguous stack implementation with handling errors. See {stack-stl} for STL example.

{stack-contiguous-implementation}

This uses contiguous and is [traversable] stack. [KT] push and pop (insertion and deletion) happens
at the the end of storage and use index. no overhead of moving elements.

<do> write a contiguous stack implementation which have following interfaces.

void CreatStack( Stack* stack );
bool StackFull( Stack* stack );
bool StackEmpty( Stack* stack );
bool StackPush( Stack* stack, EntryType entry );
void StackPop( Stack* stack );
EntryType StackTop( Stack* stack );
void StackTraverse( Stack* stack, void(*func)(EntryType));

<code-own>

Used stack-stl interface and some points are: use top var name. use top in pop and top funcs. 

#include < iostream>

#define MAXENTRY 10

typedef int EntryType;

typedef struct {
	int top;		// count
	EntryType entry[MAXENTRY];
} Stack;

void CreatStack( Stack* stack )
{
	stack->top = 0;
	for( int i=0; i < MAXENTRY; i++ )
		stack->entry[i] = (EntryType)0;
}	

bool StackFull( Stack* stack )
{
	return ( stack->top >= MAXENTRY );
}

bool StackEmpty( Stack* stack )
{
	return ( stack->top <= 0 );
}

bool StackPush( Stack* stack, EntryType entry )
{
	if( StackFull(stack) )
	{
		std::cout << "stack is full" << std::endl;
		return false;
	}

	stack->entry[ stack->top++ ] = entry;
	return true;
}

void StackPop( Stack* stack )
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}

	stack->top--;
}

EntryType StackTop( Stack* stack )
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return (EntryType)0;
	}

	return stack->entry[stack->top-1];
}

typedef void(*TRAVERSEFUNC)(EntryType);	


void StackTraverse( Stack* stack, TRAVERSEFUNC func)
//void StackTraverse( Stack* stack, void(*func)(EntryType))
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}
	
	for(int i=0; i < stack->top; i++)
	{
		func(stack->entry[i]);
	}
}

void EntryPrint(EntryType item)
{
	std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	Stack stack;
	CreatStack(&stack);
	std::cout << "type in 10 integer numbers." << std::endl;

	for(int i=0; i < MAXENTRY; i++)
	{
		std::cin >> item;
		StackPush(&stack, item );
	}		

	std::cout << "top is " << StackTop(&stack) << std::endl;
	std::cout << "top is " << StackTop(&stack) << std::endl;
	
	StackPop(&stack);
	StackPop(&stack);

	StackTraverse(&stack, EntryPrint);
}


<code-from-ref-001>

typedef char StackEntry;

typedef struct stack {
	 int top;
	 StackEntry entry[MAXSTACK];
} Stack;

void CreateStack( Stack* s );
{ s->top = 0; }

Boolean StackEmpty( Stack* s );
{ return s->top <= 0; }

Boolean StackFull( Stack* s );
{ return s->top >= MAXSTACK; }

void Push( StackEntry item, Stack* s );
{
   if( StackFull(s) )
      Error("stack is full");
   else
      s->entry[s->top++] = item;
}

void Pop( StackEntry *item, Stack* s );
{
   if( StackEmpty(s) )
      Error("stack is empty");
   else
      *item = s->entry[--s->top];
}

// returned the top item without being removed. the stack remains unchanged.
void Top( StackEntry *item, Stack* s );   
void TraverseStack( Stack*s, void(*Visit)());


{code-from-class-example}

typedef char Stack_entry;

Error_code Stack::push( const Stack_entry& item )
{
	 Error_code outcome = success;

	 if( count >= maxstack )
		  outcome = overflow;
	 else
		  entry[count+1] = item;

	 return outcome;
}

Stack::Stack();
Error_code Stack::pop()
{
	 Error_code outcome = success;

	 if( count == 0 )
		  outcome = underflow;
	 else --count; // note: 

	 return outcome;
}

Error_code Stack::top( Stack_entry& item ) const
{
	 Error_code outcome = success;

	 if( count == 0 )
		  outcome = underflow;
	 else
		  item = entry[count-1];

	 return outcome;
}

bool Stack::empty() const;


{stack-linked-implementation}

Implement stack as linked structure. To pop, better to make all addition and deletion at the
beginning of the structure. Why? Since this is one-way list, if to use the end to add, poping and
pusing requires tracing all the way from its head. This has a [header] variable that points to its
first node.

<do> write a linked list stack implementation which do addition and deletion at the beginning and
has following interfaces.

typedef struct node {
	...
} Node;

typedef struct stack {
	...
} Stack;

Node* MakeNode( StackEntry item );

<code-example>

#include < iostream>
#include < cstdlib>

typedef int EntryType;

typedef struct node
{
	EntryType 	entry;
	node*			pnext;
} Node;

typedef struct {
	Node*	top;	// header
} Stack;

Node* MakeNode( EntryType entry )
{
	Node* pnode = NULL;

	if( (pnode = (Node*) malloc( sizeof(Node))) == NULL )
	{
		std::cout << "no more memory" << std::endl;
		return NULL;
	}

	pnode->entry = entry;
	pnode->pnext = NULL;

	return pnode;
}

void CreatStack( Stack* stack )
{ stack->top = NULL; }	

bool StackEmpty( Stack* stack )
{ return ( stack->top == NULL ); }

bool StackPush( Stack* stack, EntryType entry )
{
	Node* pnode;

	if( (pnode = MakeNode(entry)) == NULL )
	{
		std::cout << "mem is full" << std::endl;
		return false;
	}

	pnode->entry = entry;
	pnode->pnext = stack->top;

	stack->top = pnode;

	return true;
}

void StackPop( Stack* stack )
{
	Node* pnode = NULL;

	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}

	pnode = stack->top->pnext;
	
	if(stack->top)
		free(stack->top);
	else
	{
		std::cout << "stack->top is null" << std::endl;
		return;
	}

	stack->top = pnode;
}

EntryType StackTop( Stack* stack )
{
	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return (EntryType)0;
	}

	return stack->top->entry;
}

typedef void(*TRAVERSEFUNC)(EntryType);	

void StackTraverse( Stack* stack, TRAVERSEFUNC func)
{
	Node* pnode;

	if( StackEmpty(stack) )
	{
		std::cout << "stack is empty" << std::endl;
		return;
	}
	
	pnode = stack->top;

	while(pnode)
	{
		func(pnode->entry);
		pnode = pnode->pnext;
	}
}

void EntryPrint(EntryType item)
{
	std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	Stack stack;
	CreatStack(&stack);

	std::cout << "type in 5 numbers." << std::endl;

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		StackPush(&stack, item );
	}		

	std::cout << "top is " << StackTop(&stack) << std::endl;
	std::cout << "top is " << StackTop(&stack) << std::endl;
	
//	StackPop(&stack);
//	StackPop(&stack);

	StackTraverse(&stack, EntryPrint);

	for(int i=0; i < 5; i++)
		StackPop(&stack);

	if( StackEmpty(&stack) )
		std::cout << "main: stack is empty" << std::endl;
	else
		std::cout << "main: stack is not empty" << std::endl;
}


{abstract-data-type} {ADT}

Drawing a spearation between the logical structure of our data and its implementation will help us
in designing probgrams. If there is no speration, for example, can implement reverse polish
calculator by replacing stack code with manipulating array and count directly. Problem?

o How to change it to list implementation from array?
o Use unnecessary effort verifying the details of codes rather than being able to concentrate on
logic to solve problem, that is, the ways in which the stack is being used. This is programmer's
failure to recognize the general concept of stack and to distinguish between this and
implementation.

 [KT] can use this reverse polish calculator to see if someone can use data type such as stack to
 solve these case problems.

<encapsulation> 

In general, data is said to be [encapsulated] if it can only be accessed by a controlled set of
functions. Without encapsulation, the operation on a data structure almost always depend on a
[precondition] of data members.

The mathematical definition of type is:
A type is a set, and the elements of the set are called the values of the type. 

ADT has two parts: First is a description of the way in which the components are related to each
other, and second is a statement of the operation. ADT is logical data structure such as list or
stack and physical implementation can vary as there are many different implementation of stack.

<simple-list-adt-definition>

A simple list of elements of type T is a finite sequence of elements of T together with the
operations.

1. create the list, leaving it empty.
2. determine whether the list is empty or not.
3. determine whether the list is full or not.
4. find the size of the list.
5. add a new entry at the end of the list, provided the list is not full.
6. traverse the list, performing a given operation with each entry.
7. clear the list to make it empty.

<stages-of-refinement>

<- concept and algorithm ------->
math      ADT      data structure    implementation               application
concept 

sequence  general list
          stack    ...
          queue    physical                                       line of people

	                linear           array

			          circular         array with counter            airport simulation
			                           array with flag
						                  array with skipped entry

			          linked           simple with two pointers
			                           circular with tail pointers
						                  array with two cursors


{case-app-one} {reverse-polish-calculator}

We shall write '?' to denote an instruction to read an operand and push it onto the stack; + , -, *
, and / represent arithmetic operations; and = is an instruction to print the top of the stack (but
not pop it off). Further, we write a, b, c, and d to denote numerical values such as 3.14 or -7. 

? a ? b + = 

mean read and store the numbers a and b, calculate and store their sum, and then print the sum. 

? a ? b + ? c ? d + * = 

request four numerical operands, and the result printed is the value of (a + b) * (c + d).

? a ? b ? c - = * ? d + = 

mean push the numbers a, b, c onto the stack, replace the pair b, c by b - c and print its value,
calculate a * (b - c), push d onto the stack, and finally calculate and print (a * (b - c)) + d. 

The advantage of a reverse Polish calculator is that any expression, no matter how complicated, can
be specified without the use of parentheses.

<code-eample>

#include < iostream>
#include < cctype> // for tolower

typedef double Stack_entry;

const int maxstack=10;
enum class Error_code { success, overflow, underflow };

class Stack {
	public:
	Stack();
	bool empty() const;
	Error_code pop();
	Error_code top(Stack_entry &item) const;
	Error_code push(const Stack_entry &item);

	private:
	int count;
	Stack_entry entry[maxstack];
};


Stack::Stack(): count(0)
{
}

bool Stack::empty() const
{
	bool outcome = true;
	if( count > 0 ) outcome = false;
	return outcome;
	// return count == 0 ? true : false;
}

Error_code Stack::pop()
{
	Error_code outcome = Error_code::success;
	if( count == 0 )
		outcome = Error_code::underflow;
	else count--;

	return outcome;
}

Error_code Stack::top(Stack_entry &item) const
{
	Error_code outcome = Error_code::success;

	if( count == 0 )
		outcome = Error_code::underflow;
	else
		//item = entry[count--];
		item = entry[count-1];

	return outcome;
}

Error_code Stack::push(const Stack_entry &item)
{
	Error_code outcome = Error_code::success;
	if( count >= maxstack )
		outcome = Error_code::overflow;
	else
		entry[count++] = item;
	
	return outcome;
}

char get_command()
{
	char command;
	bool waiting = true;
	std::cout << "select command and press <enter>: ";

	while( waiting )
	{
		std::cin >> command;
		command = tolower(command);

		if( command == '?' || command == '=' || command == '+' ||
			command == '-' || command == '*' || command == '/' ||
			command == 'q' )
			waiting = false;
		else
		{
			std::cout << "please enter a valid command: " << std::endl
					<< "[?] push to stack, [=] print top " << std::endl
					<< "[+] [-] [*] [/] are arith ops " << std::endl
					<< "[Q] quit. " << std::endl;
		}
	}
	return command;
}

bool do_command( char command, Stack& numbers)
{
	double p, q;

	switch(command) {

		case '?':
		std::cout << "enter a real number: " << std::flush;
		std::cin >> p; // [note] read numbers
		if( numbers.push(p) == Error_code::overflow )
			std::cout << "stack full." << std::endl;

		break;

		case '=':      // [note] there is no pop
		if( numbers.top(p) == Error_code::underflow )
			std::cout << "stack empty." << std::endl;
		else
			std::cout << p << std::endl;

		break;

		case '+':      // [note] same for other ops
		if( numbers.top(p) == Error_code::underflow )
			std::cout << "stack empty." << std::endl;
		else
		{
			numbers.pop();
			if( numbers.top(q) == Error_code::underflow )
			{
				std::cout << "stack has just one entry." << std::endl;
				numbers.push(q);
			}
			else
			{
				numbers.pop();
				if( numbers.push( p+q ) == Error_code::overflow )
					std::cout << "stack full." << std::endl;
			}
		}
		break;

		case 'q':
		std::cout << "calc finished.\n";
		return false;
	}

	return true;
}


int main()
{
	Stack stored_numbers;

	while( do_command(get_command(), stored_numbers ));
}

This works fine but can be re-written using cpp strings.
				

{case-app-two} {bracket-matching}

{a = (1 + v(b[3 + c[4]]))     // no matching 
{ a = (b[0) + 1]; }           // the number of brackets matches but no matching
{( )[( )]}                    // matches but not leagal

How stack can be used here?

Whenever see any closing bracket ), ], or }, it must correspond to the last unmatched opening
bracket, which should be in stack and now be retrieved and removed from storage. Finally, at the end
of the program, we must check that no unmatched opening brackets are left over.

int main()
{
	 Stack openings;
	 char current;
	 bool is_matched=true;

	 while( is_matched && ( current = std::cin.get()) != '\n' )
	 {
		  if( current == '{' || current == '(' || current == '[' )
				openings.push(current);

		  if( current == '}' || current == ')' || current == ']' )
		  {
				if( openings.empty() )
				{
					 std::cout << "unmatched closing bracket " << current << " detected" << std::endl;
					 is_matched = false;
				}
				else
				{
					 char match;
					 openings.top(match);
					 openings.pop();

					 is_matched = ( current == '}' && match == '{' )
					 	|| ( current == ')' && match == '(' )
					 	|| ( current == ']' && match == '[' );

					 if(!is_matched)
						  std::cout << "bad match " << match << current << std::endl;
				}
		  }
		  
	 }

	 // there should be no itmes in a stack if it is a match.
	 if(!openings.empty())
		  std::cout << "unmatched opening bracket(s) detected" << std::endl; 
}


==============================================================================
*kt_dev_algo_002*	simple list

{list-data-structure}

A list is dynamic-data-structure because its size can change, while an array is a
static-data-structure because it has a fixed size.

{list-contiguous-implementation}

<do> write a contiguous list implementation which have following interfaces.

void CreateList(List*);
void ClearList(List*);
bool ListEmpty(const List*);
bool ListFull(const List*);
int ListSize(const List*);
vold AddList(ListEntry x, List* list)
void TraverseList(List* list, void(*visit)(ListEntry));


<code-example>

The ListEntry can be anything. typedef T ListEntry;

typedef struct cell {
	int row, col;
} Cell;

typedef Cell ListEntry;

typedef struct list {
	int         count;
	ListEntry   entry[MAXLIST];
} List;

// add an entry at the end
//
vold AddList(ListEntry x, List* list)
{
	if(ListFull(list))
		Warning("attempt to insert at the end of a full list.");
	else
		list->entry[list->count++] = x;
}

// run function on every entry in a list
//
void TraverseList(List* list, void(*visit)(ListEntry));
{ 
	for( int i = 0; i < list->count; i++)
		(*visit)(list->entry[i]);
}

Here, there is no function to remove and if there is, it is expensive as have to move elements.


{list-linked-implementation}

A problem that never arises with contiguous. How do we find the beginning of the list? [header] is a
pointer variable that locates the beginning of the list. See {stack-linked-implementation} in
comparison.

typedef struct node {
	ListEntry   entry;
	struct node *next;
} Node;

typedef struct list {
	 int     count;   // there is no need to keep an counter but for size function.
	 Node*   header;  // header
} List;

Can implement to add a node either in the beginning or in the end. If it has remove function, then
less expansive than contiguous-implementation but need to search through from the header. To find
the end, traverse until next is null.

<code-example>

#include < iostream>
#include < cstdlib>

typedef int EntryType;

typedef struct node
{
	EntryType 	entry;
	node*			pnext;
} Node;

typedef struct {
   int   count;
	Node*	header;
} List;

Node* MakeNode( EntryType entry )
{
	Node* pnode = NULL;

	if( (pnode = (Node*) malloc( sizeof(Node))) == NULL )
	{
		std::cout << "no more memory" << std::endl;
		return NULL;
	}

	pnode->entry = entry;
	pnode->pnext = NULL;

	return pnode;
}

void CreatList( List* list )
{ 
   list->count = 0;
   list->header = NULL; 
}	

bool ListEmpty( List* list )
{ return ( list->header == NULL ); }

// add only at the end
bool ListAdd( List* list, EntryType entry )
{
	Node* pnode, *pend;

	if( (pnode = MakeNode(entry)) == NULL )
	{
		std::cout << "add: mem is full" << std::endl;
		return false;
	}

   if( ListEmpty( list ) )
   {
      list->header = pnode;
   }
   else
   {
      #ifdef USE_PNEXT
      // search the end using pnext
      for( pend = list->header; pend->pnext; pend = pend->pnext )
         ;

      #else

      // search the end using count
      pend = list->header;
      for( int current = 1; current < list->count; current++) // [KT] less than
         pend = pend->pnext;

      #endif

      pnode->entry = entry;

      pend->pnext = pnode;
   }

   list->count++;

   std::cout << "add: added " << entry << ", count " << list->count << std::endl;

	return true;
}

typedef void(*TRAVERSEFUNC)(EntryType);	

void ListTraverse( List* list, TRAVERSEFUNC func)
{
	Node* pnode;

	if( ListEmpty(list) )
	{
		std::cout << "list is empty" << std::endl;
		return;
	}
	
	pnode = list->header;

	while(pnode)
	{
		func(pnode->entry);
		pnode = pnode->pnext;
	}
}

void EntryPrint(EntryType item)
{
   std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	List list;
	CreatList(&list);

	std::cout << "type in 5 numbers." << std::endl;

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		ListAdd(&list, item );
	}		

	ListTraverse(&list, EntryPrint);
}


==============================================================================
*kt_dev_algo_003*	general list

To support [random-access] as oppose to a simple list that supports only addition at the end:

void InsertList( position p, ListEntry x, List* list);

// the entry in position p of list has been returned as x and deleted from list.
void DeleteList( position p, ListEntry* x, List* list);
void RetrieveList( position p, ListEntry* x, List* list);	// list remain unchanged
void ReplaceList( position p, ListEntry x, List* list);		// list remain unchanged

As with list and others, general list has two kind of implementation: contiguous and linked. For
contiguous, shift later elements to support inserting and deleting in any position. For both, need
to scan from the first every time. 

<do> Add InsertList and deleteList to the simple list using SetPosition which is utility function.

void SetPosition( Position p, List* list, ListNode** current)
{
	 int count;
	 ListNode* q;

	 if( p < 0 || p >= list->count )
		  Error("attempt to set a position not in the list");
	 else 
	 {
		  q = list->head;
		  for( count = 1; count <= p; count++ )
				q = q->next;
		  *current = q;
	 }
}


<code-example-one>

From the ref-001.

void InsertList( Position p, ListEntry x, List* list )
{
   ListNode *newnode, *current;

   // check if pos is in [0...count-1]
   if( p < 0 || p > list->count )
      Error("attempt to set a position not in the list");
   else 
   {
      newnode = MakeListNode(x);
      if( p == 0 )
      {
         newnode->next = list->head;
         list->head = newnode;
      }
      else
      {
         SetPosition( p-1, list, &current );
         newnode->next = current->next;
         current->next = newnode;
      }
      list->count++;
   }
}

 [KT] This has a flaw. If call this when a list empty, that is, pos=0, count=0, then ends up
 accessing NULL. Can be fixed.

 if( p < 0 || p >= list->count )
   Error("attempt to set a position not in the list");

<code-example-two>

The above example has mismatch between count and pos, that is:

count 1 2 3 4 5
pos   0 1 2 3 4

The following uses the same range for both count and pos. Make a note for that always need to handle
the first node separately and [the-previous] node to insert in the list.

#include < iostream>
#include < cstdlib>

typedef int EntryType;
typedef int Position;

typedef struct node
{
	EntryType 	entry;
	node*			pnext;
} Node;

typedef struct {
   int   count;
	Node*	header;
} List;

Node* MakeNode( EntryType entry )
{
	Node* pnode = NULL;

	if( (pnode = (Node*) malloc( sizeof(Node))) == NULL )
		return NULL;

	pnode->entry = entry;
	pnode->pnext = NULL;

	return pnode;
}

void CreatList( List* list )
{ 
   list->count = 0;
   list->header = NULL; 
}	

bool ListEmpty( List* list )
{ return ( list->header == NULL ); }

// add only at the end
bool ListAdd( List* list, EntryType entry )
{
	Node* pnode, *pend;

	if( (pnode = MakeNode(entry)) == NULL )
	{
		std::cout << "add: mem is full" << std::endl;
		return false;
	}

   if( ListEmpty( list ) )
   {
      list->header = pnode;
   }
   else
   {
      // search the end using pnext
      for( pend = list->header; pend->pnext; pend = pend->pnext )
         ;

      pnode->entry = entry;

      pend->pnext = pnode;
   }

   list->count++;

   std::cout << "add: added " << entry << ", count " << list->count << std::endl;

	return true;
}

// support random-access
bool SetPosition( List* list, Position pos, Node** ppNode)
{
   Node* pnode;
   int current;

   // check if pos  is in [1...count]
   if( pos < 1 || pos > list->count )
   {
      std::cout << "error: attempt to insert in a position" << pos << " not in the list" << std::endl;
      return false;
   }

   pnode = list->header;

   #ifdef RETURN_THE_PREVIOUS
   for( current=1; current < pos; current++ )
   #endif
   for( current=1; current <= pos; current++ )
      pnode = pnode->pnext;

   *ppNode = pnode;
}

 [KT] Compared the previois, this has a protection. If call this when a list empty, that is, pos=1,
 count=0, then error happens and return. Cannot use this when a list is empty.

bool InsertList( List* list, EntryType entry, Position pos )
{
   Node* pnewnode, *pnode;

   // check if pos  is in [1...count]
   if( pos < 1 || pos > list->count ) // [KT]
   {
      std::cout << "error: attempt to insert in a position not in the list" << std::endl;
      return false;
   }

   // get a new node
   pnewnode = MakeNode(entry);
   if(pnewnode==NULL)
   {
		std::cout << "error: no more memory" << std::endl;
      return false;
   }

   if( pos == 1 ) // [KT]
   {
      pnewnode->pnext = list->header;
      list->header = pnewnode;
   }
   else
   {
      #ifdef RETURN_THE_PREVIOUS
      // get the prev node of pos node
      SetPosition( list, pos, &pnode );
      #endif

      SetPosition( list, pos-1, &pnode );

      // insert a new node between pos-1 and pos node
      pnewnode->pnext   = pnode->pnext; 
      pnode->pnext      = pnewnode;
   }

   list->count++;
}

bool DeleteList( List* list, EntryType entry, Position pos )
{
}

typedef void(*TRAVERSEFUNC)(EntryType);	

void ListTraverse( List* list, TRAVERSEFUNC func)
{
	Node* pnode;

	if( ListEmpty(list) )
	{
		std::cout << "list is empty" << std::endl;
		return;
	}
	
	pnode = list->header;

	while(pnode)
	{
		func(pnode->entry);
		pnode = pnode->pnext;
	}
}

void EntryPrint(EntryType item)
{
   std::cout << "item is: " << item << std::endl;
}

int main()
{
	int item = 0;

	List list;
	CreatList(&list);

	std::cout << "type in 5 numbers." << std::endl;

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		ListAdd(&list, item );
	}		

   InsertList(&list, 10, 6);
   InsertList(&list, 10, 1);  // expects an error
   InsertList(&list, 20, 6);

	ListTraverse(&list, EntryPrint);
}


{improved-search-list}

For cases refering to the same entry several times as an example, this can be improved by keeping
the current position which is the last-used position, [locality-of-reference] that is, if one entry
is accessed, is it likely that it will next be accessed again:

typedef int Position;

// See {list-linked-implementation} for comparison
//
typedef struct list {
	 int count;
	 ListNode*  head; 
	 Position   currentpos; ~
	 ListNode*  current; ~
} List;

void SetPosition( Position p, List* list )
{
	 if( p < 0 || p >= list->count )
		  Error("attempt to set a position not in the list");
	 else 
	 {
		  if( p < list->currentpos )
		  {
				list->currentpos = 0;
				list->current = list->head;	// since it has one-way direction
		  }

		  for( ; list->currentpos != p; list->currentpos++ )
				list->current = list->current->next;
	 }
}


This improves its efficiency than the previous but the changes needed to the various functions are
minor: For repeated references to the same position, neither if and for will be excuted; that is
when p equals to currentpos. So takes almost no time. For forward move, will be very fast and for
backward move, operates the same way as the previous.


{doubly-linked-list}

Not a simple DL list but supports [random-access] which is more complicated than thought.

typedef struct listnode {
	 ListEntry entry;
	 struct listnode* next;
	 struct listnode* prev;
} ListNode;

typedef struct list {
	 int count; 				// [KT] count [1..n] and pos[0..n-1]. no header
	 ListNode*  current; ~
	 Position   currentpos; ~
} List;

// set current to the position in 0.. count-1. see no return of ppNode and no run when
// pos==currentpos.
void SetPosition( Position p, List* list )
{
	 if( p < 0 || p >= list->count )
		  Error("attempt to set a position not in the list.");
    // move forward
	 else if( list->currentpos < p )
	 {
		  for(; list->currentpos != p; list->currentpos++ )
				list->current = list->current->next;
	 }
    // move backward
	 else if( list->currentpos > p )
	 {
		  for(; list->currentpos != p; list->currentpos-- )
				list->current = list->current->prev;
	 }
}

 [KT] Like the first, has a flaw when the list is empty. But can use this func to add when the list
 is empty.

void InsertList( Position p, ListEntry x, List* list)
{
	 ListNode* newnode, *following;

	 if( p < 0 || p > list->count )
		  Error("attempt to set a position not in the list.");
	 else
	 {
		  newnode = MakeListNode(x);

		  if( p == 0 )		// insert at the beginning as it is not circular
		  {
				newnode->prev = NULL;

				if( list->count == 0 )	// list is empty
					 newnode->next = NULL;
				else
				{
					 Setposition( 0, list );	// [note] set current to pos 0
					 newnode->next = list->current;
					 list-current->prev = newnode; 
				}
		  }
		  else				// insert later in the list
		  {
            // [KT] For DL, need the prev and the current(following) regardless of return pos from
            // SetPostion.
				SetPosition( p-1, list );		

				/* is temp really required?
				 *
				 *             cur(pos-1)  pos(end)
				 * [prev next] [prev next] [prev next]
				 * 
				 *                 new [prev next]
				 *
				 * if do without temp(following) then
				 *
				 * cur->next = new;
				 * cur->next->prev = new;
				 * new->prev = cur;
				 * new->next = cur->next; but cur->next is already changed.
				 *
				 * new->next = cur->next;
				 * new->prev = cur;
				 * cur->next->prev = new;
				 * cur->next = new;
				 *
				 * seems okay. [NO] because cur->next is null when inserting at the end. REALLY?
             *
             *                 pos-1   pos
             *                 cur     following
             *         [0]     [1]     [2] 
             *          next -> next -> next -> null
             * null <- prev <- prev <- prev
             *
				 */
				following = list->current->next;

				// insert between current and following
				newnode->next = following;
				newnode->prev = list->current;
				list->current->next = newnode;

				// this check is required when inserting at the end because cur->next is null
				if(following)		
					 following->prev = newnode;
		  }

		  list->current = newnode;
		  list->currentpos = p;
		  list->count++;
	 }
}

{list-contiguous-and-linked}

In summary, contiguous storage is generally preferable when:

o the records are individually very small
o the size of list is known when the program is written
o few insertion or deletion need to be made except at the end of the list
o random access is important

linked storage proves superior when:

o the records are large
o the size of list is not known when the program is written
o flexibility is needed in inserting, deleting and rearranging the entries.


==============================================================================
*kt_dev_algo_004*	queue

The queue has head(front) and tail(rear).

{queue-contiguous-implementations}

<approach-one> 
Use single index and use always index 0 as a head and the end as a tail. However, use first entry
and then move all the remaining entries one position up. Poor choice.

<approach-two>
Use array and two indices to keep track of both the front and the rear. However, has a defect that
both are increased but never decreased. Space problem. If can relocate queue regularly, two indices
and straight-line storage implementation is very efficient.

// 
// code-example
//
#include < iostream>

#define MAXSIZE 5

typedef int EntryType;

typedef struct {
   EntryType   data[MAXSIZE];
   int         head;
   int         tail;
} Queue;

void CreateQueue(Queue* queue)
{
   queue->head = queue->tail = 0;
}

bool QueueEmpty(Queue* queue)
{
   if( queue->head == queue->tail )
   {
      std::cout << "empty(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

bool QueueFull(Queue* queue)
{
   if( queue->tail >= MAXSIZE )
   {
      std::cout << "full(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

void AddQueue( Queue* queue, EntryType entry )
{
   if( QueueFull(queue) )
      return;

   queue->data[queue->tail++] = entry;
}

void DelQueue( Queue* queue, EntryType* pentry )
{
   if( QueueEmpty(queue) )
      return;

   *pentry = queue->data[queue->head++];
}

void TraverseQueue( Queue* queue, void(*f)(int, EntryType))
{
   int current, end;

   for( current = queue->head, end = queue->tail; current < end; current++ )
      f(current, queue->data[current]);
}

void PrintEntry(int pos, EntryType entry)
{
   std::cout << " " << pos << " : [" << entry << "]" << std::endl;
}

int main()
{
   Queue queue;

   CreateQueue(&queue);

   QueueEmpty(&queue);

   AddQueue(&queue, 10);
   AddQueue(&queue, 11);
   AddQueue(&queue, 12);

   TraverseQueue(&queue, PrintEntry);

   AddQueue(&queue, 13);
   AddQueue(&queue, 14);
   AddQueue(&queue, 15);

   TraverseQueue(&queue, PrintEntry);

   return 0;
}

empty(0,0)
 0 : [10]
 1 : [11]
 2 : [12]
full (0,5) 5%MAXSIZE = 0. there is no way to tell empty or full
 0 : [10]
 1 : [11]
 2 : [12]
 3 : [13]
 4 : [14]


To solve space problem, use [circular-array] and decide boundary condition to indicate if a queue is
full or empty. However, there is no way, by looking at the indicies ALONE, to tell a full queue from
an empty one.

q containing one item
... [] ...
    rear
    front

q which is empty after removing one, that is, increase front
... [] [] [] ...
    rear
       front

q with one empty position
... [] [] [] ...
    rear  front

q which is full after adding one, that is, increase rear
... [] [] [] ...
    rear
       front

addQ is to insert item and inc rear and subQ is to remove item and dec front. See the result of the
code example. To solve that there is no difference between full and empty, there are three
approaches:

<approach-one> {queue-circular-array} {interview}
Use circular array, two indicies and [one position left vacant].

... [] [*] [] ...
    rear
	        front

so empty when rear == front and full when rear == front-2. [KT] That is wrong and was difficult that
thought. Maybe quiz.

From 8.4.3 in DATA STRUCTURES IN C++ (Google eBook) N. S. KUTTI, P. Y. PADHYE, think virtual head
which means front and front which means vacant element. head is always front+1. front and head moves
along as rear do and there is no need to move elements to keep vacant element.

...[f] [h] [r] ...
...[*] [h] [r] ...


 0  1  2  3  4
[f][h][ ][ ][r]

(r,f)             full  empty                   full
(0,4) (0,3) (0,2) (0,1) (0,0) (1,0) (2,0) (3,0) (4,0)
-4    -3    -2    -1    0     1     2     3     4			rear-front
 1     2     3     4    5     6     7     8     9			+QSIZE(5)
 1     2     3     4    0     1     2     3     4			(rear-front+QSIZE)%QSIZE

init: frnot=rear=0;                       // can be any index
empt: return rear==front;
full: return (rear+1)%QSIZE == front;
leng: length = (rear+QSIZE-front)%QSIZE;  // can get any time
haed: head = (front+1)%QSIZE;

This is wrong and see the below code example:

deq:
{
	if not empty
	{
		d = data[front+1];	// [KT] add one to head(front+1)
		front = (front+1) % QSIZE;
		// d = data[head];	
		// front = head;
	}
}

inq:
{
	if not full
	{
		data[rear+1] = d;
		rear = (rear+1) % QSIZE;
	}
}


//
// code-example
//
#include < iostream>

#define MAXSIZE 5

typedef int EntryType;

typedef struct {
   EntryType   data[MAXSIZE];
   int         head;
   int         tail;
} Queue;

void CreateQueue(Queue* queue)
{
   queue->head = queue->tail = 0;
}

bool QueueEmpty(Queue* queue)
{
   if( queue->head == queue->tail )
   {
      std::cout << "empty(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

bool QueueFull(Queue* queue)
{
   if( (queue->tail+1)%MAXSIZE == queue->head ) // ~
   {
      std::cout << "full(" << queue->head << "," << queue->tail << ")" << std::endl;
      return true;
   }

   return false;
}

void AddQueue( Queue* queue, EntryType entry )
{
   if( QueueFull(queue) )
      return;

   queue->tail = (queue->tail+1)%MAXSIZE; // ~
   queue->data[queue->tail] = entry;      // ~

//   std::cout << "add(" << queue->tail << ")" << std::endl;

//   do not work as tail remains the same after add which is different from array queue
//   implementation
//   queue->data[queue->tail+1] = entry;
//   queue->tail = (queue->tail+1)%MAXSIZE;
}

void DelQueue( Queue* queue, EntryType* pentry )
{
   if( QueueEmpty(queue) )
      return;

   queue->head = (queue->head+1)%MAXSIZE;
   *pentry = queue->data[queue->head];

//   std::cout << "del(" << queue->head << ")" << std::endl;

//   do not work
//   *pentry = queue->data[queue->head+1];
//   queue->head = (queue->head+1)%MAXSIZE;
}

// this is differnt from the straight line implementation
void TraverseQueue( Queue* queue, void(*f)(int,int, EntryType))
{
   int count=0, current=0;
   
   // See *kt_dev_algo_005*
   // int length = abs( queue->tail - queue->head)%MAXSIZE; // this do not works.
   int length = ( queue->tail - queue->head + MAXSIZE )%MAXSIZE;

   // std::cout << "trav(" << queue->head+1 << "," << queue->tail+1 << ")" << std::endl;

   for( current = queue->head+1, count=0; count < length; count++, current++ )
   {
      current = current%MAXSIZE;
      f(current, length, queue->data[current]);
   }
}

void PrintEntry(int pos, int length, EntryType entry)
{
   std::cout << " " << pos << ":" << length << " : [" << entry << "]" << std::endl;
}

int main()
{
   Queue queue;
   EntryType entry;

   CreateQueue(&queue);

   QueueEmpty(&queue);

   AddQueue(&queue, 10);
   AddQueue(&queue, 11);
   AddQueue(&queue, 12);

   TraverseQueue(&queue, PrintEntry);

   AddQueue(&queue, 13);
   AddQueue(&queue, 14);
   AddQueue(&queue, 15);

   TraverseQueue(&queue, PrintEntry);

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   AddQueue(&queue, 100);
   AddQueue(&queue, 101);
   AddQueue(&queue, 102);

   TraverseQueue(&queue, PrintEntry);

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   AddQueue(&queue, 300);
   AddQueue(&queue, 301);
   AddQueue(&queue, 302);

   TraverseQueue(&queue, PrintEntry);

   return 0;
}


<approach-two> 
Use circular array, two indicies and new variable: [a bool flag] for full or empty. The flag is
toggle: For a case from a book, if q becomes diff(front-rear) == 1 while flag == full then q becomes
empty. Or int variable to indicate.

<approach-three>
Use circular array, two indicies and new variable: a counter(length) 

typedef T QueueEntry; // application-program dependent

typedef struct queue {
	int count; // 0 .. MAXQUEUE-1
	int front;
	int rear;
	QueueEntry entry[MAXQUEUE];
} Queue;

void CreatQueue(Queue* q)
{
	q->count = q->front = 0;
	q->rear = -1; [emptiness]
}

/* Or Insert. add an entry as its last */
void Append(QueueEntry x, Queue* q)
{
	if( QueueFull(q))
		Error(...);
	else
	{
		q->count++;
      // if use rear=-1 when init
		q->rear = (q->rear+1) % MAXQUEUE;
		q->entry[ q->rear ] = x;
      // if use rear=0 when init
		q->entry[ q->rear ] = x;
		q->rear = (q->rear+1) % MAXQUEUE;
	}
}

/* Or Delete. delete the first entry and note that *x */
void Serve(QueueEntry *x, Queue* q)
{
	if( QueueEmpty(q) )
		Error(...);
	else
	{
		q->count--;
		*x = q->entry[ q->front ];
		q->front = (q->front+1) % MAXQUEUE;
	}
}

Boolean QueueFull(Queue* q)
{
	return q->count >= MAXQUEUE;
}

Boolean QueueEmpty(Queue* q)
{
	return q->count <= 0;
}

int QueueSize(Queue* q)
{	
	return q->count;
}

Also can have ClearQueue, QueueFront, and TraverseQueue.


 [KT] seems do not need emptiness when init. As front and rear always increases, inc first and add
 for append and remove first and dec for serve.

// 
// code-example
// 
#include < iostream>

#define MAXSIZE 5

typedef int EntryType;

typedef struct {
   EntryType   data[MAXSIZE];
   int         count;
   int         head;
   int         tail;
} Queue;

void CreateQueue(Queue* queue)
{
   queue->head = queue->tail = queue->count = 0;
}

bool QueueEmpty(Queue* queue)
{
   if( queue->count == 0 )
   {
      std::cout << "empty(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}

bool QueueFull(Queue* queue)
{
   if( queue->count >= MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}

// the same as the array implementation except mod operation to make it circular
void AddQueue( Queue* queue, EntryType entry )
{
   if( QueueFull(queue) )
      return;

   std::cout << "add(" << queue->tail << ")" << std::endl;
   queue->data[queue->tail++] = entry;
   queue->tail = (queue->tail)%MAXSIZE;

   queue->count++;
}

void DelQueue( Queue* queue, EntryType* pentry )
{
   if( QueueEmpty(queue) )
      return;

   *pentry = queue->data[queue->head++];
   queue->head = (queue->head)%MAXSIZE;

   queue->count--;
}

// changed
void TraverseQueue( Queue* queue, void(*f)(int,int, EntryType))
{
   int count=0, current=0;
   int length = queue->count;

   // std::cout << "trav(" << queue->head+1 << "," << queue->tail+1 << ")" << std::endl;

   for( current = queue->head, count=0; count < length; count++, current++ )
   {
      current = current%MAXSIZE;
      f(current, length, queue->data[current]);
   }
}

void PrintEntry(int pos, int length, EntryType entry)
{
   std::cout << " " << pos << ":" << length << " : [" << entry << "]" << std::endl;
}

int main()
{
   Queue queue;
   EntryType entry;

   CreateQueue(&queue);

   QueueEmpty(&queue);

   AddQueue(&queue, 10);
   AddQueue(&queue, 11);
   AddQueue(&queue, 12);

   TraverseQueue(&queue, PrintEntry);

   AddQueue(&queue, 13);
   AddQueue(&queue, 14);
   AddQueue(&queue, 15);

   TraverseQueue(&queue, PrintEntry);

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   AddQueue(&queue, 100);
   AddQueue(&queue, 101);
   AddQueue(&queue, 102);

   TraverseQueue(&queue, PrintEntry);

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   DelQueue(&queue, &entry);
   std::cout << "del " << entry << std::endl;

   AddQueue(&queue, 300);
   AddQueue(&queue, 301);
   AddQueue(&queue, 302);

   TraverseQueue(&queue, PrintEntry);

   return 0;
}


{queue-linked-implementations}

Unlike contiguous queue, NO space problem and NO emptiness/fullness problem. So no full check and
only care about emptiness:

1) addition when queue is empty must be treated separately since
addition to an empty queue requires setting both the front and the rear to the new node, whereas
addition to nonempty requires changing only the rear. 

2) deletion when queue goes empty must be treated. 

typedef T QueueEntry;

typedef struct queuenode {
	QueueEntry entry;
	struct queuenode *next;
} QueueNode;

typedef struct queue {
	QueueNode* front;
	QueueNode* rear;
} Queue;

void CreateQueue(Queue *q)
{
	// this is a empty condition
	q->front = q->rear = NULL;
}

//
// QueueNode* pentry = (QueueNode*) malloc( sizeof(QueueNode) );
// AppendNode( pentry, q );
//
// [KT] this reveals that it is linked implementation. not well in hiding. the following is better?
//
// QueueItem* pitem = (QueueItem*) malloc( sizeof(QueueItem) );
// AppendQueue( pitem, q );
//
void AppendNode(QueueNode *p, Queue* q)
{
	if(!p)
		Error(...)
	else if( QueueEmpty(q) )
		q->front = q->rear = p;
	else
	{
		q->rear->next = p;
		q->rear = p;
	}
}

// 
// QueueNode* pentry;
// ServeNode( &pentry, q);
// ..
// use entry
// ..
// free(pentry);
//
void ServeNode(QueueNode**p, Queue* q)
{
	if( QueueEmpty(q) )
		Error(...);
	else
	{
		*p = q->front;
		q->front = q->front->next;
		
		/* if q is empty, front is already null so mark rear null as well. */
		if( QueueEmpty(q) )
			q->rear = NULL;
	}
}


==============================================================================
*kt_dev_algo_005*	array: index shift

{example-one}

From *kt_dev_algo_007*	recursion:

4x4
00 01 02 03 : down diff -3. 4th covers 1 pos. -> 0th
10 11 12 13 : down diff -2. 5th covers 2         1th
20 21 22 23 : down diff -1. 6th covers 3         2th
30 31 32 33 : down diff  0. 0th covers 4         3th
            : down diff  1. 1th covers 3         4th
				: down diff  2. 2th covers 2         5th
				: down diff  3. 3th covers 1         6th

#define BOARDSIZE 	4						// 4x4 space
#define DIAGONAL		(2*BOARDSIZE-1)	// up or down diagonal size. 7
#define DOWNOFFSET	(BOARDSIZE-1)		// down diagonal offset. BOARDSIZE-1

bool downfree[ DIAGONAL ];

downfree[ queenrow - col + DOWNOFFSET ] = false;

Since array index cannot be negative, need to shift index into positive. Here -3...3 to 0...6 and
used DOWNOFFSET(3).

-3 -2 -1 0 1 2 3
 0  1  2 3 4 5 6 	// array[7];


{example-two}

From circular-queue, rear-front can have -4...4 and to get the length of queue can shift. Here
there is one vacant element.

 0  1  2  3  4
[f][h][ ][ ][r]

(r,f)                   empty                   full
(0,4) (0,3) (0,2) (0,1) (0,0) (1,0) (2,0) (3,0) (4,0)
-4    -3    -2    -1    0     1     2     3     4			rear-front
 1     2     3     4    5     6     7     8     9			+QSIZE(5)
 1     2     3     4    0     1     2     3     4			(rear-front+QSIZE)%QSIZE

 0     1     2     3    4     5     6     7     8			+QSIZE-1(4)
 
The difference is that there is one vacant element so used QSIZE to shift but not QSIZE-1. 0th is
not used.


==============================================================================
*kt_dev_algo_006*	the game of life

From {ref-001}. In short, the rule as to the neighbour count is:

o if 3 and the dead cell, gets live in the next run.
o if > 4 and the live cell, gets dead in the next run.
o if 2, makes no change.
o if 0, 1, gets dead. makes no change.

{first-version}

Grid map, newmap; // [MAXROW+2][MAXCOL+2]

do 
{
	 for( row = 1; row <= MAXROW; row++ )	// why starts from 1? see {hedge-or-sentinel}
		  for( col = 1; col <= MAXCOL; col++ )
				switch( NeighborCount( map, row, col )) 
				{
					 case 0: case 1:
					 newmap[row][col] = DEAD; break;

					 case 2:
					 newmap[row][col] = map[row][col]; break;

					 case 3:
					 newmap[row][col] = ALIVE; break;

					 case 4: case 5: case 6: case 7: case 8:
					 newmap[row][col] = DEAD; break;
				}

		CopyMap(map, newmap);
		WriteMap(map);

} while( UserSaysYes());

This approach is:

 map (current gen) -> cal and updated newmap(next gen) -> copy newmap to map
 ... repeats
	
MAXROW x MAXCOL = 20 x 60 = 1200. This amounts to about 18,000 statements.


{second-version}

Question is that is it necessary to calculate the number of neighbors of every cell at every
generation? No and improvements are:

o no copy from newmap to map.
o no cal for a whole map but for neighboring cells.

Grid map, numbernbrs;	// [MAXROW+2][MAXCOL+2]
List newlive, newdie;
List maylive, maydie;

while(UserSaysYes())
{
	 // current generation
	 // Vivify it in [map] and add it from [maylive] to [newlive] when it is dead and 3
	 TraverseList( &maylive, Vivify );
	 TraverseList( &maydie, Kill );
	 ClearList( &maylive );
	 ClearList( &maydie );

	 WriteMap( map );		// print to user

	 // next generation
	 // while traversing [newlive], cal neighbor count and update [numbernbrs]. Add it to [maylive]
	 // or [maydie]
	 TraverseList( &newlive, AddNeighbors );
	 TraverseList( &newdie, SubstractNeighbors );
	 ClearList( &newlive );
	 ClearList( &newdie );
}

{postpone-difficulty}

The subtle problem is that maylive/maydie can have multiple same entry and spurious entry and some
should be changed later because [numbernbrs] is not fully updated while traversing lists. This
difficluty is handled later when running vivify call because we have now completed neighbor counts,
that is [numbernbrs]. 

{loop-invariant}

The {loop-invariant} is a statement that is true at the beginning of every iteration of the loop. In
this example, that is:

At the beginning of the main loop, list maylive contains only dead cells, and list maydie contains
only living cells, but the list may contain duplicates or spurious entries whose counts are wrong.
The list newlive and newdie are empty.

The purpose of loop invariant is to capture the essence of the dynamic process. It is not always
easy to find.

{performance}

The amount of computation is no longer proportional to the size of the grid but to the number of
changes being made. Has about 2900 statements which is 6 times faster than the first. Is it
worthwhile although it is more complicated and costly to maintain? Usually there is
{space-and-time-trade-offs}. Depends on.


==============================================================================
*kt_dev_algo_007*	recursion

The recursion is [divide-and-conquer] as it reduce the large problem to one or more problems of a
similar nature but a smaller size. 

Must determine the [stopping-rule], the smallest case because there must be some way that the
recursion stops.


{the-tower-of-hanoi}

The idea is to concentrate not on the first step, but rather on the hardest step: moving the bottom
disk because condition is that only one disk can be moved at a time and the bottom, largest, one can
never be on top of any other.

Move( disk, start, finish, temp );

When there are 64 disks:

Move( 63, 1, 2, 3);                             // 63th disk
printf("move disk 64 from tower 1 to 3.\n");    // 64th disk
Move( 63, 2, 3, 1);                             // 63th disk

The stopping rule is when there is no disk to be moved, there is nothing to do.

#define DISKS	64

void Move(int count, int start, int finish, int temp)
{
	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
		  printf("move a disk from tower %d to %d.\n", start, finish );
		  Move( count-1, temp, finish, start );
	}
}

int main()
{
	 Move( DISKS, 1, 3, 2 );
	 return 0;
}

The number of non-leaves, that is the number of moves for 64 is 2^64-1. This is about 5x10^11 years
where 2x10^10 is 20 billion years

{recursion-tree}

This is a tool to visualize recursive call in which node represents recursion call. The time
requirement is the total number of nodes, vertices, in a recursion tree since traverse all nodes and
the space(stack space) is the depth of tree, not the number of nodes.

                                                          Move(3, 1,3,2) ()

                             Move(2, 1,2,3) ()                                              ...

         Move(1, 1,3,2) ()                      Move(1, 3,2,1) ()          

Move(0, 1,2,3) ()  Move(0, 2,3,1) ()   Move(0, 3,1,2) ()  Move(0, 1,2,3) ()


To get this in programming, can think of:

#include < iostream>

using namespace std;

#define DISKS	3

unsigned int depthRecursion;

void PrintDepth( bool dash, unsigned int depth )
{
	for( unsigned int i=0; i <= depth; ++i)
	{
		if(dash)
			cout << "--";
		else
			cout << "  ";
	}

	if(dash)
		cout << "(" << depth << ") ";
	else
		cout << "      ";
}

void Move(int count, int start, int finish, int temp)
{
	 depthRecursion++;
	 PrintDepth( true, depthRecursion );

	 cout << "Move(" << count << "," << start << "," << finish << "," << temp << ")" << endl;

	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
	 	  PrintDepth( false, depthRecursion );
		  cout << "move a disk " << count << " from tower " << start << " to " << finish << endl;
		  Move( count-1, temp, finish, start );
	 }

	 depthRecursion--;
}

int main()
{
	 Move( DISKS, 1, 3, 2 );
	 return 0;
}

kt@kt-ub-vb:~/c++$ ./a.out 
----(1) Move(3,1,3,2)
------(2) Move(2,1,2,3)
--------(3) Move(1,1,3,2)                        // { (1, s,f,t)
----------(4) Move(0,1,2,3)                      //    { (0, s,f,t)
              move a disk 1 from tower 1 to 3
----------(4) Move(0,2,3,1)                      //    } (0, s,f,t)
            move a disk 2 from tower 1 to 2
--------(3) Move(1,3,2,1)	                      // } (1, s,f,t)

----------(4) Move(0,3,1,2)
              move a disk 1 from tower 3 to 2
----------(4) Move(0,1,2,3)

          move a disk 3 from tower 1 to 3
------(2) Move(2,2,3,1)

--------(3) Move(1,2,1,3)
----------(4) Move(0,2,3,1)
              move a disk 1 from tower 2 to 1
----------(4) Move(0,3,1,2)

            move a disk 2 from tower 2 to 3
--------(3) Move(1,1,3,2)
----------(4) Move(0,1,2,3)
              move a disk 1 from tower 1 to 3
----------(4) Move(0,2,3,1)

Here counts is disks which are 1, 2, 3 and when follows the messages, get a problem solved. Note
that PrintDepth is correct showing the same depth of recursion in column.


{eight-queen-puzzle}

From {ref-001} and C version. The chess rules is that a queen can take another queen that is on the
same row, the same column, or the same diagonal.

<key-step>

This is formulating or outlining that use recursion to mean contiune to the next stage and repeat
the task.

This is naive approach when 8x8 board:

void AddQueen()
{
	 for( every unguarded position p on the board )
	 {
		  place a queen in position p;
		  queen++;

		  if( queen == 8 )
				print the configuration;
		  else
				AddQueen();

		  remove the queen from position p;
		  queen--;
	 }
}
 
4x4 eample

 dead end    dead end    solution    solution
  0 1 2 3     0 1 2 3     0 1 2 3     0 1 2 3 
0 Q ? ? ?   0 Q ? ? ?   0 X Q ? ?   0     Q   
1 X X Q ?   1 X X X Q   1 X X X Q   1 Q       
2 X X X X   2 X Q X X   2 Q X X X   2       Q 
3           3 X X X X   3 X X Q X   3   Q     

<backtrack> <postponing-the-work>

When reach a dead end, must backtrack by going back to the most recent choice we have made and
trying another possibility. Usally called [backtracking-algorithm] which attempt to complete a
search for a solution by constructing [partial-solution] and which proves useful in situation where
many possibilities may first appear such as scheduling problems and a compiler parsing to determine
the meaning of a statement. 

<data-structure>

To choose the data structure to represent data to solve a problem. In this case, array.

<observations>

observation-01: mark guarded and unguarded. 
If scan the board to see if a position is guarded whenever place a queen, would involve considerable
searching. As do on a paper, if can mark guarded posion when place a queen, can look for unguarded
position in the next stage. So reduced searching but a problem arise.

When remove a queen, should not necessrily change a position from false to true(unguarded) because
some other queen still guard that posiotion. So can use int array instead to count and position is
unguarded if and only if it has a count of 0. Better than the first approach but involves
considerable searching and calculation. How to improve? Need more observations.

observation-02: only one queen in each row

int queencol[ rows ] gives the column containing a queen and this covers vertical and horizental
positions.

observation-03: use [difference] for downwards and [sum] for upwards.

4x4
00 01 02 03 : down diff -3. 4th covers 1 pos. -> 0th
10 11 12 13 : down diff -2. 5th covers 2         1th
20 21 22 23 : down diff -1. 6th covers 3         2th
30 31 32 33 : down diff  0. 0th covers 4         3th
            : down diff  1. 1th covers 3         4th
				: down diff  2. 2th covers 2         5th
				: down diff  3. 3th covers 1         6th

The down and up diagonal examples are:

00 11 22 33 : down, 30 21 12 03 : up. where these are xy index in a array. 

The obseravtion here is that the main down diagonal has the same difference: 00 11 22 33 and otheres
are between -3..3. Since there is no minus index in array use offset to map 0..6 (shifted)

up diagonal are ones to upper-right. As down diagonal, cannot use difference because cannot uniquely
identify up diagonals. For example, 00 and 33 have 0 in difference. Therefore, use sum instead.

Try one example

  0 1 2 3
0 Q ? ? ?
1 X X Q ?
2 X X X X
3        

pos 00:Q: queencol[0] = 0. down diff 0 and 0th. up 0th.
pos 12:Q: queencol[1] = 2. down diff -1 and 6th. up sum 3.
    dead: backtrack. unset down 6th and up 3th. there is no duplicates in set/unset up and down diagonal
because pos on the same diagonal will not tried.

Therefore, no need to have int array for marking guarded and unguarded cells for a whole board.
Hence reduced calaulations and searching.

<analysis>

The navie approach which place 8 queens and reject illegal configutation every time when place a
queen. This is C(64, 8) = 64!/8!(64-8)! = 4,426,165,368. This is [combination] notation in math.

The [observation-02] cuts this to 8^8 = 16,777,216
The [observation-03] cuts this to 8! = 40,320

This shows the effectiveness of [backtrack] as reduce a recursion tree to manageable step. The
actual number of cases the program consider will be much less than this.

<code-program>

#include <iostream>

using namespace std;

#define BOARDSIZE 	4						// 4x4 space
#define DIAGONAL		(2*BOARDSIZE-1)	// up or down diagonal size
#define DOWNOFFSET	(BOARDSIZE-1)		// down diagonal offset. BOARDSIZE-1

// to set a column where queen is for a each row. For example,
//
//   0 1 2
// 0 Q
// 1 X X Q
//
// queencol has {0, 2, .. } means that row 0 has 0, row 1 has 2. this is the answer when finish.
//
int queencol[ BOARDSIZE ];					

// row where queen is and also means the number of queens has been put. recursion depth and
// horizental
int queenrow = -1;							

// bitset to mark guarded(occupied) or upguarded position for column, up and down diagonal
// for [backtrack]
bool colfree[ BOARDSIZE ];		// cloumn is guarded? vertical.
bool upfree[ DIAGONAL ];
bool downfree[ DIAGONAL ];

void PrintDepth( bool dash, unsigned int depth )
{
	for( unsigned int i=0; i <= depth; ++i)
	{
		if(dash)
			cout << "-";
		else
			cout << " ";
	}

	if(dash)
		cout << "(" << depth << ") ";
	else
		cout << "    ";
}

void WriteBoard()
{
	cout << "solution {";

	for( int i=0; i < BOARDSIZE; ++i)
		cout << queencol[i] << ",";

	cout << "}" << endl;
}

void AddQueen()
{
	 int col=0;

	 queenrow++;
	 PrintDepth(true, queenrow);
	 cout << "AddQueen(" << queenrow << ", " << col << ")" << endl;

	 for( col = 0; col < BOARDSIZE; col++ )
	 {
		  // check if colfree, upfree and downfree are unguarded
		  //
		  if( colfree[ col ] && upfree[ queenrow + col ] && downfree[ queenrow - col + DOWNOFFSET ] )
		  {
				// put a queen in position( queenrow, col )
				//
				PrintDepth(false, queenrow);
				cout << "added a queen(" << queenrow << ", " << col << ")" << endl;

				queencol[ queenrow ] = col;

				colfree[ col ] = false;
				upfree[ queenrow + col ] = false;
				downfree[ queenrow - col + DOWNOFFSET ] = false;

				if( queenrow == BOARDSIZE-1 ) // termination condition
					 WriteBoard();					// print out and should not terminate program to see all
					                           // solutions
				else 									// proceed recursively
					 AddQueen();

				PrintDepth(false, queenrow);
				cout << "removed a queen(" << queenrow << ", " << col << ")" << endl;

				// backtrack by removing the queen
				colfree[ col ] = true;
				upfree[ queenrow + col ] = true;
				downfree[ queenrow - col + DOWNOFFSET ] = true;
		  }
	 } // for end

	 queenrow--;
}

int main()
{
	 int i;
	 
	 // init bitsets
	 for(i = 0; i < BOARDSIZE; i++)
		  colfree[i] = true;	// unguarded

	 for(i = 0; i < DIAGONAL; i++)
	 {
		  upfree[i] = downfree[i] = true;
	 }

	 AddQueen();
	 return 0;
}

The output when run 4x4:

-(0) AddQueen(0, 0)
     added a queen(0, 0)
--(1) AddQueen(1, 0)
      added a queen(1, 2)
---(2) AddQueen(2, 0)
      removed a queen(1, 2)
      added a queen(1, 3)
---(2) AddQueen(2, 0)
       added a queen(2, 1)
----(3) AddQueen(3, 0)
       removed a queen(2, 1)
      removed a queen(1, 3)
     removed a queen(0, 0)
     added a queen(0, 1)
--(1) AddQueen(1, 0)
      added a queen(1, 3)
---(2) AddQueen(2, 0)
       added a queen(2, 0)
----(3) AddQueen(3, 0)
        added a queen(3, 2)
solution {1,3,0,2,}
        removed a queen(3, 2)
       removed a queen(2, 0)
      removed a queen(1, 3)
     removed a queen(0, 1)
     added a queen(0, 2)
--(1) AddQueen(1, 0)
      added a queen(1, 0)
---(2) AddQueen(2, 0)
       added a queen(2, 3)
----(3) AddQueen(3, 0)
        added a queen(3, 1)
solution {2,0,3,1,}
        removed a queen(3, 1)
       removed a queen(2, 3)
      removed a queen(1, 0)
     removed a queen(0, 2)
     added a queen(0, 3)
--(1) AddQueen(1, 0)
      added a queen(1, 0)
---(2) AddQueen(2, 0)
       added a queen(2, 2)
----(3) AddQueen(3, 0)
       removed a queen(2, 2)
      removed a queen(1, 0)
      added a queen(1, 1)
---(2) AddQueen(2, 0)
      removed a queen(1, 1)
     removed a queen(0, 3)


{designing-recursive}

o find the key step to divide a problem into parts
o find a stopping rule
o outline your algorithm
o check it with a small case
o draw a recursion tree.


{when-not-to-use-recursion} {tail-recursion}

The tail recursion when the last-executed statment is a recursive call waste space as do unnecessary
recusive call. Because when return, restore stack but terminates immediately. For this case, can
change it to iterative one. 

<example-one>

void Move(int count, int start, int finish, int temp)
{
	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
		  printf("move a disk %d from tower %d to %d.\n", count, start, finish );
		  Move( count-1, temp, finish, start );
	}
}


void Move(int count, int start, int finish, int temp)
{
	 int swap;

	 if( count > 0 )
	 {
		  Move( count-1, start, temp, finish );
		  printf("move a disk %d from tower %d to %d.\n", count, start, finish );
		  count--;
		  swap = start;   // swap(start, temp) how does it work???
		  start = temp;
		  temp = swap; 
	}
}


<factorial>

This is a function of non-negative integer and is defined

n! = 1          if n = 0
     n x (n-1)! if n > 0

1 when n=0
1 wnen n=1
2 when n=2
6 when n=3
...

The recursive ones:

int fact(int val)
{
	 if( val > 1 )
		 return fact(val-1)*val; 
	
	return 1;
}

// overflow when val is -1
int fact(int val)
{
	if( val == 0 )
		return 1;
	else
		return fact(val-1)*val;
}

Why is iterative ones better? Use less space and also often time as well. Looking at recursion tree,
it dwaws a chain, not a tree.

n! - (n-1)! - (n-2)! - ... - 2! - 1! - 0!

The iterative ones:
can do by reading the recursion tree [from bottom to top] instead of top to bottom. But not always as
seen at below.

1  when n=0
1  wnen n=1
2  when n=2
6  when n=3. 3x2!
24 when n=4. 4x3!
...

// what's the product value when n < 2 ?
int factorial( int n )
{
	 int count, product;
	 for( product=1, count=2; count <= n; count++)
		  product *= count;

	 return product;
}

Or use 4x3x2x1 from {ref-005}

int fact(int val)
{
	 int ret = 1;

	 while( val > 1 )
		  ret *= val--;
	
	return ret;
}


<fibonacci>

The definition is:

F0 = 0.
F1 = 1.
Fn = Fn-1 + Fn-2 for n >= 2

int fibonacci(int n)
{
	 if( n <= 0 )
		  return 0;
	 else if( n==1 )
		  return 1;
	 else
		  return fibonacci(n-1) + fibonacci(n-2);
}

Far more wasteful example when use recursive because when see recursion tree, after F5, it is done
but lost although it is required later in calculating other nodes. Fn grows exponentially with n. 

The interative version is:

current   one back(fn-1)   two back(fn-2)
2       = 1              + 0
3       = 2              + 1
4       = 3              + 2
5       = 4              + 3
6       = 5              + 4
...

int fibonacci(int n)
{
	 int n;
	 int twoback; // second previous Fi-2
	 int oneback; // previous number Fi-1
	 int current; // current Fi

	 if( n <= 0 )
		  return 0;
	 else if( n==1 )
		  return 1;
	 else
	 {
		  twoback = 0;
		  oneback = 1;

		  for( i=2; i <= n; i++ )
		  {
				current = twoback + oneback;
				twoback = oneback;
				oneback = current;
		  }

		  return current;
	 }
}


<make-a-decision>

The good starting point is to study a recursion tree.

o if it has a simple form like a chain, the iterative may be better. Such as factorial and can do by
reading the recursion tree from bottom to top instead of top to bottom.

o if it has duplicate tasks, use other data structure other than stack. fibonacci iterative version.

So use recursion when the tree appears quite bushy, with little duplication of tasks.


==============================================================================
*kt_dev_algo_008*	search: binary search

{internal-and-external}

The case when to search records in files on disk or tape, external to the computer memory. The
external searching. The records to be searched are stored entirely within the computer memory.
Internal searching.

{target}

The key for which we are searching is called the target of the search. Here concerned only with
internal search and contiguous list.

{search-analysis}

Two premises:

The number of comparisons of keys give us the most useful information when wish to estimate the
computer time to require or to compare it with some other method. This is more useful than the total
running time which is too [dependant] on programming variations and machines. This number of
comparisions of keys is [measure] of analysis.

Use average behavior and means to take each possibility once and average the results. Limit our
attention to where all the possibilities are equally likely.

{binary-search}

The keys in the list are already sorted into order. In only twenty steps, will locate any requested
key in a list containing more than a millions keys. This requires [random-access] so shall limit only
for [contiguous-implementation].

<ordered-list-adt>
An ordered list is a list in which each entry contains a key, such that the keys are in order. That
is, if entry i comes before entry j in the list, then the key of entry i is less than or equal to
the key of entry j. [min...max]

void InsertOrder(List* list, ListEntry x)
{
	int current;
	ListEntry currententry;

	for( current=0; current < ListSize(*list); current++ )
	{
		currententry = RetrieveList(*list, current);
		if( LE(x.key, currententry.key ))
			break;
	}

	InsertList(list, x, current);
}


One study showed that about 90 percent of professional programmers fail to code binary search
correctly, even after working on it for a full hour.


<one-the-forgetful-version>

<do>
Write a binary search to return a postion in [bot...top] array

int RecBinary1( List list, KeyType target, int bottom, int top );

This is one to forget the possibility that the target might be found quickly and continue, whether
target has been found or not, to search [until] when there is only one item, that is, the length or
count is 1. Then see either hit the target or not found. In other words, it makes unnecessary
iterations because fails to recognize that it can found the target before continuing to iterate to
when count is 1.

This will find the first occurance of the target if it appears more than once in the list.

#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

typedef {
	 ...
	 KeyType key;	// can map any key to any entry
	 ...
} ListEntry;

typedef struct list {
	int count;
	ListEntry entry[MAXLIST];
} List;

For convenience,

1 2 3 4 5 6 7 8 9 10 array index
1 2 3 4 5 6 7 8 9 10 keys

// return -1 when not found and pos when found
int RecBinary1( List list, KeyType target, int bottom, int top )
{
	 int middle = -1;

	 if( bottom < top )
	 {
		  middle = (top + bottom)/2;

      // used >; means not include the middle for next interation
		  if( GT( target, list.entry[ middle ].key ))
				middle = RecBinary1( list, target, middle+1, top ); // remove lower half

      // used =<; means include the middle for next iteration so not middle-1 because should have a
      // middle in the search range
		  else
				middle = RecBinary1( list, target, bottom, middle ); // remove upper half
	 }
	 else if( bottom == top )	// the list has only one entry
	 {
		  if( EQ( target, list.entry[ top ].key ))
				middle = top;		// to pass up
	 }

	 return middle;
}

To adjust the params to standard conventions:

int RecBinary1Search(List list, KeyType target)
{ return RecBinary1( list, target, 0, list.count-1 ); }

This is tail-recursion so convert it into a iterative loop. [KT] Here top and bottom are actually
indexes and when top == bottom, means there is one item left. How to check empty list? Used count-1
and check on -1:

int Binary1Search( List list, KeyType target )
{
	 int bottom, middle, top;

	 top = list.count-1;
	 bottom = 0;

	 while( bottom < top )
	 {
		  middle = ( bottom + top )/2;

		  if( GT( target, list.entry[middle].key ))
				bottom = middle+1;
		  else
				top = middle;
	 }

	 // search for an emptry list always fails
	 if( top == -1 )
		  return -1;

	 if( EQ( target, list.entry[top].key ))
		  return top;
	 else
		  return -1;
}


<code-example>

Used the simple array and moved up the check of empty list since this is a check on input but not on
calc during running.

#include < iostream>

using namespace std;

#define EQ(a,b) ((a) == (b))
#define GT(a,b) ((a) > (b))

typedef struct list {
	int count;
	int entry[10];
} List;

int Binary1Search( List list, int target )
{
	 int bottom, middle, top;

	 top = list.count-1;
	 bottom = 0;

	 // search for an emptry list always fails
	 if( top == -1 )
	 {
			cout << "list is empty" << endl;
		  	return -1;
	 }

	 while( bottom < top )
	 {
			middle = ( bottom + top )/2;
			cout << "middle is " << middle << endl;

			if( GT( target, list.entry[middle]))
				bottom = middle+1;
			else
				top = middle;
	 }

	 if( EQ( target, list.entry[top]))
		  return top;
	 else
		  return -1;
}

int main()
{
	int ret;
	List arr;

	for(int i=0; i < 10; ++i)
		arr.entry[i] = i;

	arr.count = 10;
	//arr.count = 0;

	ret = Binary1Search( arr, 4 );

	cout << "ret = " << ret << endl;

	return 0;
}


<two-the-equality-version>

To improve the forgetful version, check at each stage to see if it has found the target. This has
only LT and GT on checks and the equality, that is, found in the middle, is found when LT or GT is
false.

This may return any instance of the target if target appears more than once in the list.

int RecBinary2( List list, KeyType target, int bottom, int top )
{
	 int middle = -1;

	 if( bottom <= top )		// [note] <=. when bottom == top, middle, bottom, and top are the same.
	 {
		  middle = (top+bottom)/2;

		  if( LT( target, list.entry[ middle ].key ))
				middle = RecBinary2( list, target, bottom, middle-1); // [note] middle-1
		  else if ( GT( target, list.entry[ middle ].key ))
				middle = RecBinary2( list, target, middle+1, top);		// [note] middle+1
	 }

	 return middle;
}

int Binary2Search( List list, KeyType target )
{
	 int bottom, middle, top;

	 top = list.count-1;
	 bottom = 0;

	 while( bottom <= top )
	 {
		  middle = (bottom+top)/2;

		  if( EQ( target, list.entry[middle].key ))
				return middle;
		  else if( LT( target, list.entry[middle].key ))
				top = middle-1;
		  else // if ( GT( target, list.entry[middle].key ))
				bottom = middle+1;
	 }

	 return -1;
}


<binary-search-comparison-which-is-better> {comparison-tree}

Which one of these will do fewer comparisons? Binary2 will if found in the beginning of the search
but do 2 comparisons at each iteration.

Can draw a comparison tree to compare.

                   (5) ; root node representing a key
     '<='                       '>'
     (3)                        (8)
'<='       '>'
(2)        (4)
      '<='      '>'
...   (4)       (5)
    '=' '!='  '=' '!='
... [4] [F]   [5] [F]


For n=10, Binary1 does slightly fewer comparisons both for successful and for unsuccessful searches.
However, an optimizing compiler may not do as much work as two full comparisons. In that case,
Binary2 may be slightly better choice.

Sequential search needs O(n) and binary search needs O(logn) comparisons which is excellent since
log n grows very slowly as n increases.

These are only approximate. For large values of n, the difference between log n and log(n+1) is
insignificant and (n+1)/n is very nearly 1. Hence can simply results as:

						Successful 		Unsuccessful search
Binary1Search 		logn + 1			logn + 1
Binary2Search 		2logn-3			2logn

All four cases are proportional to logn and the coefficients of logn are the number of comparisons
inside the loop.

To conclude, for large problems, Binary1(the-forgetful-version) is better and for small problems
Sequential is better. Binary2 may be better when there is optimizing compiler.


<big-o-notation>

To present the operation count or running time for algorithm

O(1) to mean computing time that is bounded by a constant (not dependent on n)
O(n) to mean that the time is directly propotional to n. called liner time.
O(n2) called quadratic time
O(n3) called cubic time
O(2n) called exponential

<other-version>

//
// See how to check empty list when this is array. However, this is not necessary when see the other
// example code below.
//
#include < iostream>

#define GT(x,y) ((x)>(y))
#define EQ(x,y) ((x)==(y))

int bsearch_one( int* list, int start, int end, int target )
{
   int pos = -1;

   // when the list is empty
   if( end == -1 )
   {
      std::cout << "list is empty" << std::endl;
      return pos;
   }

   while( start < end )
   {
      int middle = (start+end)/2;

      if( GT(target, list[middle] ) )
      {
         start = middle+1;
      }
      else
         end = middle;
   }

   // can remove check on start == end
   if( start == end )
   {
      if( EQ( target, list[end] ))
            pos = end;
   }

   return pos;
}

int main()
{
   int ret = -1;

   int brr[] = {};
   int bsize = ( sizeof(brr)/sizeof(brr[0]));
   
   // bsearch_one( , , length-1, );
   ret = bsearch_one( brr, 0, bsize-1, 15 );
   std::cout << "returned pos is " << ret << std::endl; 

   int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

   ret = bsearch_one( arr, 0, size-1, 15 );
   std::cout << "returned pos is " << ret << std::endl; 

   ret = bsearch_one( arr, 0, size-1, 17 );
   std::cout << "returned pos is " << ret << std::endl; 

   ret = bsearch_one( arr, 0, size-1, 2 );
   std::cout << "returned pos is " << ret << std::endl; 

   ret = bsearch_one( arr, 0, size-1, 99 );
   std::cout << "returned pos is " << ret << std::endl; 
}


//
// From p120 in cracking the coding interview. This is the Binary2.
//
int binary_search(int arr[], int length, int sought)
{
	// indexes
	int low = 0;
	int high = length-1;

	// int high = sizeof(arr)/sizeof(int)-1; Note: THIS DOESN'T WORK!
	int mid;

	// Note for condition.
	while( low <= high )
	{
		mid = (low+high)/2;

		if(arr[mid] < sought)
			low = mid+1; // exclues mid by +1
		else if( arr[mid] > sought)
			high = mid-1; // excludes mid by -1. throw upper
		else
			return mid;
	}

	return -1; //error
}


/* example from Primus. what is the type of text?
 */

auto begin = text.begin(), end = text.end();
auto middle = text.begin() + (end-begin)/2;

// while there are still elements to look at and we haven't yet found sought.
while( middle != end && *middle != sought )
{
	if( sought < *middle )
	    end = middle;              # throw upper
	else
		 begin = middle+1;

	middle = begin + ( end - begin )/2;
}

// when no found, begin, end, and middle are the same.


==============================================================================
*kt_dev_algo_009*	sort

Here consider only internal sorting. Analysis concentrate on two actions: comparison and changing
pointers or moving entries. 

The question from {ref-004}: 

Given a very large array of Person objects, sort the people in increasing order of age.

We are given two interesting bits of knowledge here. 1: A large array, so efficiency is very
important. 2: Sorting based on ages, so we know the values are in a small range.

By scanning through the various sorting algorithms, we might notice that bucket(radix) sort would be
a perfect candidate for this problem. In fact, can make the buckets small(just 1 year each) and get
O(n) running time.

The merge, quick, and bucket are the most commonly used in interviews.


{insertion-sort}

From {ordered-list-adt}, the ordered list is ADT which has three more operations: retrieve, insert
and sort. Retrieval is the same as searching and finding the place where to insert is searching. 

For a contiguous ordered list and ordered insertion, then do binary search to find the position
sinces it is ordered and move entries. Finally insert new entry into the list. Since so much time is
needed to move entries no matter how the search is done, it turns out in many cases to be just as
fast to use sequential search as binary search: the search and the movement of entries can be
combined in a single loop, thereby reducing the overhead.

Move one entries from unsorted list to sorted list and use two observations: a list of length 1 is
automatically ordered.

init order     ...

[hen] sorted   [cow]           [cat]
$cow$ unsorted [hen] sorted    [cow]
$cat$          $cat$ unsoerted [hen] sorted
$ram$          $ram$           $ram$ unsorted
$ewe$          $ewe$           $ewe$
$dog$          $dog$           $dog$


<do>

Write the below function using int array:
void InsertionSort(int* arr, int length);

<ref-example>

// contiguous version from the book
void InsertionSort(List* list)
{
   Position    fu;      // the start of unsorted
   Position    place;
   ListEntry   current;

   // fu-2 (place-1)
   // fu-1 (place)   sorted
   // fu   (place+1) unsorted

   for( fu = 1; fu < list->count; fu++ )
   {
      // [KT] This 'if' is important. if the first unsorted entry is less than the last sorted entry,
      // then should be before the last sorted. Otherwise do not need to insert. Save it and find
      // pos to insert

      if( LT( list->entry[fu].key, list->entry[ fu-1 ].key ))
      {
         current = list->entry[fu];

         // search from the end of ordered list. Here do move and search in the same loop.
         for( place = fu-1; place >= 0; place-- )
         {
            // move down
            list->entry[ place+1 ] = list->entry[ place ];

            // since already compared with place(fu-1) so from place-1. Save one comparison
				// [KT] Here assumes that place is signed and so must have place==0 check. If not, place
				// can have -1 when return from break
            if( place == 0 || LT( list->entry[ place-1 ].key, current.key ))
               break;
         }

         list->entry[place] = current;
      }
   }
}


<code-example> 

#include < iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

bool sort_insert( int* array, int length )
{
   int posUnsorted = 0;
   int posSorted = 0;
   int itemUnsorted = 0;

   // when the list is empty
   if( length == 0 )
   {
      std::cout << "input is empty" << std::endl;
      return false;
   }

   // move forward through unsorted part to pick up a unsorted
   for( posUnsorted = 1; posUnsorted < length; posUnsorted++ )
   {
      // only if a unsorted is greater then the last sorted
      if( LT( array[ posUnsorted ], array[ posUnsorted-1]))
      {
         // save unsorted item
         itemUnsorted = array[posUnsorted];
         
         // search back through sorted part to find a place to insert
			// [KT] Here also assumes signed int but it will do the same comparison which is already done in
			// the if. Therefore, have one more comparison than the ref example.

         for( posSorted = posUnsorted-1; posSorted >= 0; posSorted-- )
         {
            if( GT(itemUnsorted, array[posSorted] ))
               break;

            // move down items.
            array[posSorted+1] = array[posSorted];
         }

         array[posSorted+1] = itemUnsorted;
      }
   }

   return true;
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
   int arr[] = { 33, 2, 31, 5, 30, 6, 12, 10, 13, 15, 17, 29, 3 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

   bool ret = sort_insert( arr, size );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
      std::cout << arr[idx] << ", "; 

   std::cout << "}" << std::endl; 
}


<code-eample>

Here used unsigned for position. Careful about array index: if there is no check on sorted==1 then
use a minus index.

#include < iostream>

#define LT(x,y) ((x)<(y))
#define GT(x,y) ((x)>(y))

void isort( int length, int* arr )
{
	for( int idx = 1; idx < length; idx++)
	{
		// need to find a place in the sorted
		if( LT( arr[idx], arr[idx-1] ))
		{
			// save it
			int temp = arr[idx];
			int sorted;

			// scan back in the sorted
			for( sorted = idx; sorted > 0; sorted--)
			{
				// move
				arr[sorted] = arr[sorted-1];

				if( sorted ==1 || GT(temp, arr[sorted-2]))
					break;

			}
			arr[sorted-1] = temp;
      	// std::cout << "arr[" << sorted << "] = " << temp << std::endl;
		}
	}
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
   int arr[] = { 33, 2, 31, 5, 30, 6, 12, 10, 13, 15, 17, 29, 3 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

   isort( size, arr );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
      std::cout << arr[idx] << ", "; 

   std::cout << "}" << std::endl; 
}


<comparison-which-is-better>

The ref-example is better since it will one less for loop by break using checks on place==0 and
comparison of sorted-1. However, the second can exit loop by condition, -1, and hence +1 when
inserting an item. 

Two observations: 
1) a list of length 1 is automatically ordered.
2) search and insert only when the first of unsorted < the last of sorted. If not, it is sorted and
just increase a loop.

For efficiency:
Can save one comparison. move down first and compare with sorted-1.


{selection-sort}

The insertion-sort has major disadvantage: even after most entries have been sorted properly into
the first part of the list, the insertion of a later entry may require that many of them should be
moved because the position of each entry is not a [final-position]. Far more efficient if an entry
being moved could be placed in its final position. 

Scan unsorted list to find the one that comes last in order (largest, alphabetical in this case).
Swap this with the last one of the unsorted list. Repeat this until no more items in the unsorted
list.

$hen$ scan and $hen$ *  $ewe$    ...
$cow$ swap     $cow$    $cow$
$cat$          $cat$    $cat$
$ram$ *        $dog$    $dog$ unsorted
$ewe$          $ewe$ *  [hen] sorted
$dog$ *        [ram]    [ram]

From {ref-004}, can do the opposite. Find the smallest and swap it with the first. Repeat it until
it is sorted.


<do>

Write the below function using int array:

void SelectionSort(int* arr, int length);

// find the position of the largest key in the sublist
Position MaxKey(int begin, int end, int* arr);

// swap two entries in the contiguous list
void Swap(int begin, int end, int* arr);


<ref-example>

void SelectionSort(List* list);

Position MaxKey(Position low, Position high, List* list);

void Swap(Position low, Position high, List* list);

<code-example>

#include < iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

typedef int Position;
typedef int Entry;

// expects start and end in index
Position findPosofMax( Position start, Position end, int* array)
{
	Entry 	entry		= -1;
	Position posMax	= -1;

	for ( Position current = start; current <= end ; current++) {
		if( GT( array[current], entry ))
		{
				posMax 	= current;
				entry 	= array[current];
		}
	}

	return posMax;
}

// expects start and end in index
void swapEntry( Position x, Position y, int* array)
{
	int xval = array[x];

	array[x] = array[y];
	array[y] = xval;
}

// expects the length of array. NO if in for loop.
void sortSelection(int length, int* array)
{
	for( ;length > 1; length--) {
		Position posMax = findPosofMax( 0, length-1, array );
		// std::cout << "posMax:length-1 = (" << posMax << ", " << length-1 << ")" << std::endl;
		swapEntry( posMax, length-1, array );
	}
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
   int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 3 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

   sortSelection(size, arr );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
      std::cout << arr[idx] << ", "; 

   std::cout << "}" << std::endl; 
}


<insertion-vs-selection>

The selection sort is useful for contiguous list with large entries for which movement of entries is
expensive since it uses fewer moves. The selection do more on searching keys.

If the entries are small, or if the list is linked, so that only pointers need be changed to sort
the list, then insertion-sort is usually faster than selection-sort. The insertion do more on
moving.


{devide-and-conquer-sort}

Sort(list)
{
   if the list has length greater than 1 then
   {
      partition the list into lowlist and highlist
      Sort(lowlist);
      Sort(highlist);
      Combine(lowlist, highlist);
   }
}

It is much easier to sort short list than long ones. Two methods which has two basic actions:
partitioning and combining. mergesort does more work in combining and quicksort does more work in
partitioning.


{mergesort}

This is recursion-tree of 7 numbers. Combine() or merge part do most of work and sort. This is an
excellent method for [external-sorting], linked list in random order but spends significant time
finding the center of the list. For contiguous list, not an unqualified success because needs one of
extra space(temp) to merge, computer time, or programming effort in merging two contiguous list. 

The best time is nlogn + O(n)


                     start[down]   finish[up]
           26 33 35 29 19 12 22 () 12 19 22 26 29 33 35
           list        second

      26 33 35 29 () 26 29 33 35             19 12 22 () 12 19 22
      list  second                           list

  26 33 () 26 33   35 29 () 29 35        ...
  list             list

26 [] 33 []        35 [] 29 [] 

where [] is leaf and () is node


<merge-contiguous>

This is a java code from {ref-004}.

void MergeSort(int[] array, int low, int high)
{
	if (low < high)		// 2 at least
	{
		int middle = (low+high)/2;
		MergeSort( array, low, middle );			// sort left
		MergeSort( array, middle+1, high );		// sort right
		Merge( array, low, middle, high );		// merge them
	}
}

small                 big
low        middle     high
[0.........x..........x]
left        right(middle+1)

void Merge( int[] array, int low, int middle, int high )
{
	int[] = helper = new int[array.length];

	for( int i = low; i <= high; i++ )
		helper[i] = array[i];

	int helperLeft = low, helperRight = middle+1;
	int current = low;

	while( helperLeft <= middle && helperRight <= high )
	{
		if( helper[helperLeft] <= helper[helperRight])	// [KT] used <=
		{
			array[current] = helper[helperLeft];
			helperLeft++;
		}
		else
		{
			array[current] = helper[helperRight];
			helperRight++;
		}

		current++;
	}

	// Similar to the linked version, should handle the remaining items. Why Left? Since all items
	// are already copied to the temp array and if done for the left part which has items with small
	// keys then no need to do the right part. So only check on left part.

	int remaining = middle - helperLeft;
	for( int i = 0; i <= remaining; i++ )
		array[current+i] = helper[helperLeft+i];
}


<code-eample>

When tried to do the same myself, got crashes.

#include < iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

typedef int Position;
typedef int Entry;

unsigned int depthRecursion;
void PrintDepth( bool dash, unsigned int depth )
{
	for( unsigned int i=0; i <= depth; ++i)
	{
		if(dash)
			std::cout << "--";
		else
			std::cout << "  ";
	}

	if(dash)
		std::cout << "(" << depth << ") ";
	else
		std::cout << "      ";
}

// see the use of the same array in recursion but within the [start,end] for each iteration.
void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
	Entry out[length];
	int posLeft = start, posRight = middle+1;
	// [KT] got a crash when not init with start
	//int posCurrent;
	int posCurrent = start;

	PrintDepth( false, depthRecursion );
	std::cout << "Mege(" << length << ", " << start << ", " << middle << ", " << end << ")" << std::endl;
	
	// copy entries from array and out
	for(int pos = start; pos <= end; pos++)
		out[pos] = array[pos];

	// sort and copy entries
	while( posLeft <= middle && posRight <= end )
	{
		// [KT] use of LT which is different from the above but not matter. This sort cover the same
		// elements.
		if( LT( out[posLeft], out[posRight] ))
		{
			// [KT] use of posCurrent
			array[posCurrent] = out[posLeft];
			posLeft++;
		}
		else
		{
			array[posCurrent] = out[posRight];
			posRight++;
		}

		posCurrent++;
	}
	
	// [KT] 1st crash error since posCurrent can bigger if middle is big enough
	//for( int pos = middle - posLeft; pos <= middle;)
	//	array[posCurrent++] = out[pos++];

	// [KT] 2nd crash error as the same above.
	//for( int pos = middle - posLeft; pos <= middle; pos++)
	//	array[posCurrent+pos] = out[posLeft+pos];

	// copy remaining entries in the left if they are
	int remaining = middle - posLeft;
	for( int pos = 0; pos <= remaining; pos++)
		array[posCurrent+pos] = out[posLeft+pos];
}

void sortMerge( Entry* array, Position length, Position start, Position end )
{
	if( start < end )
	{
		depthRecursion++;
		PrintDepth( true, depthRecursion );

		int middle = (start + end )/2;
		
	 	// PrintDepth( false, depthRecursion );
		std::cout << "sortMerge(" << length << ", " << start << ", " << middle << ", " << end << ")" << std::endl;

		sortMerge( array, length, start, middle );
		sortMerge( array, length, middle+1, end );
		Merge( array, length, start, middle, end);

		depthRecursion--;
	}
}


int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
	int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 3 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

	sortMerge( arr, size, 0, size-1 );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
      std::cout << arr[idx] << ", "; 

   std::cout << "}" << std::endl; 
}

<excution-tree-or-recursion-tree>

----(1) sortMerge(13, 0, 6, 12)
------(2) sortMerge(13, 0, 3, 6)
--------(3) sortMerge(13, 0, 1, 3)
----------(4) sortMerge(13, 0, 0, 1)
                Mege(13, 0, 0, 1)
----------(4) sortMerge(13, 2, 2, 3)
                Mege(13, 2, 2, 3)
              Mege(13, 0, 1, 3)
--------(3) sortMerge(13, 4, 5, 6)
----------(4) sortMerge(13, 4, 4, 5)
                Mege(13, 4, 4, 5)
              Mege(13, 4, 5, 6)
            Mege(13, 0, 3, 6)
------(2) sortMerge(13, 7, 9, 12)
--------(3) sortMerge(13, 7, 8, 9)
----------(4) sortMerge(13, 7, 7, 8)
                Mege(13, 7, 7, 8)
              Mege(13, 7, 8, 9)
--------(3) sortMerge(13, 10, 11, 12)
----------(4) sortMerge(13, 10, 10, 11)
                Mege(13, 10, 10, 11)
              Mege(13, 10, 11, 12)
            Mege(13, 7, 9, 12)
          Mege(13, 0, 6, 12)
{ 2, 5, 6, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33, }


<merge-linked> not contiguous list

// sort linked list and the keys in all the entries are sorted into increasing order.
void MergeSort(List* list);

// divide the list into two parts. If list has an odd number of entries, then its first half will be
// one entry larger than its second
void Divide(List* list, List* secondhalf);

// merge two list producing a thrid list. first and second are ordered linked list. out is an
// ordered list containing all entries that were in first and second. The first and second have been
// destroyed.
void Merge(List* list, List* second, List* out);


<ref-example>

From the reference book. Here list and secondhalf are list structure having a head so not a problem
when run recursive tree.

void MergeSort(List* list)
{
	List secondhalf;

	if( ListSize(list) > 1 )					// is there a need to sort? 2 at least
	{
		Divide( list, &secondhalf );
		MergeSort(list);							// when list size is 2, be called with 1 and has no effect
		MergeSort(&secondhalf);
		Merge( list, &secondhalf, list );	// see list used as out
	}
}

This is interesting since it shows how to find the middle of the simple list. When midpoint moves
one, current moves two.

mid cur diff len
0   1   1    2
1   3   2    4
2   4        5   ( if odd, the first is one entry larger ) 
2   5   3    6
3   7   4    8
4   8   5    9
5   10  6    11

void Divide(List* list, List* secondhalf)
{
   ListNode* current, *midpoint;

   if((midpoint = list->head) == NULL )
      secondhalf->head = NULL;
   else
   {
      for( current = midpoint->next; current; )
      {
         current = current->next;
         // cannot move two in a single shot since do not know when one is the end.
         if(current)
         {
            midpoint = midpoint->next;
            current = current->next;
         }
      }

      secondhalf->head = midpoint->next;
      midpoint->next = NULL;
   }
}


See that first and out can be the same list since first used one step before out list

void Merge(List* first, List* second, List* out)
{
   ListNode *p1, *p2;      // pointers to traverse first and second list
   ListNode *lastsorted;   // always points to last node of sorted list

   if( !first->head )
      *out = *second;
   else if( !second->head )
      *out = *first;
   else
   {
      p1 = first->head; p2 = second->head;

		// first set the head of the merged list, out and has one item which is sorted. [KT] used LE
      if( LE(p1->entry.key, p2->entry.key))
      {
         *out = *first;
         p1 = p1->next;
      }
      else
      {
         *out = *second;
         p2 = p2->next;
      }

      lastsorted = out->head;

		// sort and build the merged list
      while(p1&&p2)
      {
         if( LE(p1->entry.key, p2->entry.key))
         {
            lastsorted->next = p1;	// make a link
            lastsorted = p1;			// move a pointer
            p1 = p1->next;				// move to next candidate
         }
         else
         {
            lastsorted->next = p2;
            lastsorted = p2;
            p2 = p2->next;
         }
      }

		// whichever lists is used up, if all items are added to the sorted list and reached to the
		// end then simply add remaining list to that end because the remaining list is bigger than
		// the lastsorted. For example, think [26,29,33,35] and [12,19,22] in the above example tree.
      if(p1)
         lastsorted->next = p1;
      else
         lastsorted->next = p2;
   }
}


{quicksort}

This is great [for-contiguous-list] and the contiguous list is the most important application for
quicksort because prove to be fast and has the advantage over contiguous mergesort of not requiring
extra space, complicated and difficult programming effort. 

It uses swapping entries and keep sublists(subsets) in the same list so no extra space. It is sorted
during partition and choose different pivot for each sublist. The sublists are not sorted and entry
is not in the final position during running. The final step of combining sorted list is not
necessary.


<partioning>

There are several methods but the algorithm we develop is much simpler and easier to uderdtand, and
not slow; in fact it does the smallest possible number of key comparisons of any partitioning
algorithm.

To allow for the possibility that more than one entry has key equal to p, the left of pivotpos have
keys strictly less than p and the right have greater than or equal to p.

|  < p   | p |    >= p      |
low                      high

Suppose that pivot starts in the first position and leave it there temporarily then the list has
following property in the middle of loop: loop invariant

| p |  < p   |   >= p   |  ?   |
low         lastsmall     i

When inspect i, there are two cases: if the entry is >= p then simply increase i and maintain the
property. if the entry < p then restore the property by increasing pivotpos(lastsmall) and swapping
it with entry i.

| p |  < p   |*| >= p   |*| ?  |
low           lastsmall  i

When loop ends, will have:

| p |           < p     |      >= p  | 
low                    lastsmall     

Then swap(low, pivotpos) and get 

|      < p     | p |      >= p       | 

[KT] The important property is to have sublists which are < and >= and each sublist is not sorted.
Hence swapping is possible.


<choice-of-pivot> <worst-case>

Not bound to use the first entry; can choose any entry and swap it with the first entry before
beginning the loop. The first is often a poor choice for pivot when the list is already sorted and
one of the sublists will be empty. Hence the careful choice of pivot to make this worst case
unlikey: use near the center of list as a pivot in the hope that it will partition the keys so that
about half come on each side of the pivot. 

[KT] Why is it better to have about half on each side? Otherwise, will end up with long and narrow
comparison tree, meaning a chain which is a bad case for recursion. The worst case is when the keys
are in their natural order or in their reverse order if choose the pivot as the first or the last
key. The average when applied to lists in random order turns out to be the best of any sorting
algorithms.


<quicksort-example>

Choose the first number on a list as the pivot:

[26] 33 35 29 19 12 22 [pivot]

less than 26    more than 26
[19] 12 22      [33] 35 29

...

<execution-trace>

Sort( 26, 33, 35, 29, 19, 12, 22 )
	Partition into ( 19, 12, 22 ) and ( 33, 35, 29 ); pivot = 26
	Sort( 19, 12, 22 )
		Partition into ( 12 ) and ( 22 ); pivot = 19
		Sort(12)
		Sort(22)
		Combine into (12,19,22)

	Sort( 33, 35, 29 )
		Partition into ( 29 ) and ( 35 ); pivot = 33
		Sort(29)
		Sort(35)
		Combine into (29,33,35)

	Combine into (12,19,22,26,29,33,35)


<recustion-tree>

The two calls to Sort as each level are shown as the children of the vertex and the sublist which
need no sorting, are drawn as the leaves.

           () 26

     () 19      () 33

 []12 []22   []29 []35


<ref-example>

void RecQuickSort( List* list, Position low, Position high )
{
	Position pivotpos;

	if( low < high )
	{
		pivotpos = Partition( list, low, high );
		RecQuickSort( list, low, pivotpos-1 );
		RecQuickSort( list, pivotpos+1, high );
	}
}

Position Partition(List* list, Position low, Position high)
{
	ListEntry pivot;
	Position i, lastsmall, pivotpos;

	Swap( low, (low+high)/2, list );
	pivot = list->entry[low];
	pivotpos = low;
	for( i=low+1; i <= high; i++ )
		if( LT( list->entry[i].key, pivot.key ))
			Swap( ++pivotpos, i, list );

	Swap(low, pivotpos, list);
	return pivotpos;
}


<code-example>

#include < iostream>

#define GT(x,y) ((x)>(y))
#define LT(x,y) ((x)<(y))
#define EQ(x,y) ((x)==(y))

typedef int Position;
typedef int Entry;

unsigned int depthRecursion;
void PrintDepth( bool dash, unsigned int depth )
{
	for( unsigned int i=0; i <= depth; ++i)
	{
		if(dash)
			std::cout << "--";
		else
			std::cout << "  ";
	}

	if(dash)
		std::cout << "(" << depth << ") ";
	else
		std::cout << "      ";
}

// expects start and end in index
void swapEntry( Position x, Position y, int* array)
{
	int xval = array[x];

	array[x] = array[y];
	array[y] = xval;
}

Position buildPartion( Entry* array, Position start, Position end )
{
	Position idx, posPivot;
	Entry entryPivot;

	// use the center as a pivot
	swapEntry( start, (start+end)/2, array );

	// [KT] from start+1 since start is a pivot
	for( idx = start+1, posPivot = start, entryPivot = array[start]; idx <= end; idx++ )
	{
		if( LT( array[idx], entryPivot ))
			swapEntry( ++posPivot, idx, array );
	}

	// swap back
	swapEntry( start, posPivot, array );

	PrintDepth( false, depthRecursion );
	std::cout << "buildPartion(" << start << ", " << end << ") returned posPivot = " << posPivot << std::endl;

	// [KT] this posPivoe varies depending on input
	return posPivot;
}

// expects the length of array
void sortQuick( Entry* array, Position start, Position end )
{
	Position posPivot;

	if( start < end )
	{
		depthRecursion++;
		PrintDepth( true, depthRecursion );

		std::cout << "sortQuick(" << start << ", " << end << ")" << std::endl;

		posPivot = buildPartion( array, start, end );
		sortQuick( array, start, posPivot-1 );
		sortQuick( array, posPivot+1, end );

		depthRecursion--;
	}
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
	int arr[] = { 30, 2, 31, 5, 33, 6, 12, 10, 13, 15, 17, 29, 6 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

   sortQuick( arr, 0, size-1 );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
      std::cout << arr[idx] << ", "; 

   std::cout << "}" << std::endl; 
}


<recustion-tree>

----(1) sortQuick(0, 12)
          buildPartion(0, 12) returned posPivot = 5
------(2) sortQuick(0, 4)
            buildPartion(0, 4) returned posPivot = 1
--------(3) sortQuick(2, 4)
              buildPartion(2, 4) returned posPivot = 2
----------(4) sortQuick(3, 4)
                buildPartion(3, 4) returned posPivot = 3
------(2) sortQuick(6, 12)
            buildPartion(6, 12) returned posPivot = 7
--------(3) sortQuick(8, 12)
              buildPartion(8, 12) returned posPivot = 8
----------(4) sortQuick(9, 12)
                buildPartion(9, 12) returned posPivot = 12
------------(5) sortQuick(9, 11)
                  buildPartion(9, 11) returned posPivot = 10

{ 2, 5, 6, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33, }

Compared with the mergesort, see that it has rather simple tree. Hence better.


{heapsort}

Some kind of input can make quicksort misbehave badly and heapsort overcomes this problem. Like the
pecking order in a corporate hierarchy and each employee supervises exactly two others.

When putting 2-tree into a list, found that:

The left and right children of the node with position k are in positions 2k+1 and 2k+2 of the list.
If these positions are beyond the end of the list, then these children do not exist. means leaf.
(this is about position)

The heap is a list in which each entry contains a key, and, for all positions k in the list, the key
a position k is at least [as-large-as-the-key] in positions 2k+1 and 2k+2, provided these positions
exist in the list. (this is about key)

The sample heap as a 2-tree and a list

                () y
        () r          () p
  () d     () f    () b   () k
() a () c


[y r p d f b k a c]

The first entry must be the largest key in the heap. Heapsort has two phases: arrange a list to make
a heap and remove the top of the heap and promote another entry to take its place.

For second phase, move the first entry to the last position: save the last to current, move the
first to the last, and place the current to the right position while building the heap. Decrease a
counter lu(last unsorted). 

This means that heap sort needs random-access and only for contiguous list.

void HeapSort(List* list)
{
	Position lu;
	ListEntry current;

	BuildHeap(list);

	for( lu = list->count-1; lu >=1; lu-- )
	{
		current = list->entry[lu];
		list->entry[lu] = list->entry[0];
		InsertHeap( current, 0, lu-1, list );
	}
}

[y r p d f b k a c]
[  r p d f b k a | y] c = c
[r f p d c b k a | y] 
[p f k d c b a | r y] 
...
[a | b c d f k p r y]

// see the left and right child of low and promote the bigger into low. also loop throuth the list.

void InsertHeap( ListEntry current, Position low, Position high, List* list )
{
	Position large;
	large = 2*low+1;	// index of left child

	while( large <= high )
	{
		// LT(left, right) and choose bigger one
		if( large < high && LT(list->entry[large].key, list->entry[large+1].key ))
			large++;

		// if current is bigger then
		if( GE( current.key, list->entry[large].key ))
			break;
		else
		{
			list->entry[low] = list->entry[large];
			low = large;
			large = 2*low+1;
		}
	}

	// when current is bigger or is out of index meaning there is no child
	list->entry[low] = current;
}

// p326. 2-tree with one node automatically satisfies heap and therefore not worry about leaves of
// the tree. Idea is if begin at the midpoint of the list and work our way back toward the start,
// can use InsertHeap to insert each entry into the partial heap consisting all later entries.

void BuildHeap(List* list)
{
	Position low;

	for(low = list->count/2-1; low >= 0; low-- )
		InsertHeap( list->entry[low], low, list->count, list );
}

 0 1 2 3 4 5 6 7 8
[y r p d f b k a c] low=3, list->count=9 IH( [3], 3, 9 ) : 3, 6, 7 
                    low=2, list->coutt=9 IH( [2], 2, 9 ) : 2, 4, 5
                    low=1, list->coutt=9 IH( [1], 1, 9 ) : 1, 2, 3, 4, 5, 6, 7
                    low=0, list->coutt=9 IH( [0], 0, 9 ) : 0, 1, 2, 3, 4, 5, 6, 7


<heapsort-application> {priority-queue}

The priority queue. each contains a key called priority and queue has two operations: insert and
remove the entry having largest (or smallest) key.

If represent a priority queue as a [sorted] contiguous list, in which case removal is immediate but
insertion take time proportional to n. Or represent it as an [unsorted], in which case insertion is
rapid but removal is slow.

The representation of a priority queue as a heap proves advantageous [for large n] since it is
represented efficiently in contiguous storage and is guaranteeded to need only logarithmic time for
both insertion and deletion.


{sort-summary}

o in choosing a method, take into account the ways in which the keys will usually be arranged before
sorting, the size of application, the amount of time available for programming, the need to save
computer time and space. Futhermore, see statistical analysis such as standard deviation and
empirical testing.

o merge, quick and heapsort are powerful and efficient but more difficult to program when applied to
large lists.

o heapsort is like an insurance: usually slower than quicksort but guarantees that sorting will be
completed in O(nlogn) comparison of keys, something that quicksort cannot always do.


==============================================================================
*kt_dev_algo_010*	table and hash

{logn-barrier}

As seen in binary search, by use of key comparisons alone, impossible to complete a search of n
items in fewer than logn on average: <binary-search-comparison-which-is-better>

The table lookup and searching share the same purpose: information retrieval. Searching uses key
comparison, whereas table lookup do not. Here assumes that each entry has only [one-key]. The table
look-up is O(1) and can be more efficient than any searching method. Provides functions from set of
keys to location of the entry.

Here study ways to implement and access tables in contiguous storage.

{index-function} {access-table}

Think a representation of rectangular array in a computer since computer storage is in a contiguous
sequence. m x n where the columns from 0 to n-1:

Entry(i,j) goes to position ni+j

A formular of this kind is called index function. In this case it is for rectangular array. If there
is a table having [pre-calculated-index] then used for all later references. This is called
an [access-table] to eliminate the calculations.

rectangular array and access table

[cost]    ->   [0]     [costareatear] 
[area]         [4]      0   4   8 
[tear]         [8]

This index function describes mapping meaning that can represent various shape of array. For example,
triangular matrix(table).


{multiple-access-table}

Consider the problem faced by the telephone company in accessing the records of its customers. To
publish the telephone book, the records must be sorted alphabetically by the name but to process
long-distance charges, the accounts must be sorted by telephone number. The company could keep
three(or more) set of its records, one sorted by name, one by number, and one by address. Doing this
would, however, not only be very wasteful of storage but it would introduce endless headaches if one
set of records were updated but another was not.

There is no reason why the records themselves need to be sorted according to one key rather than
another and also no difference whether the records are in array or in dynamic storage with the
access tables holding pointers to records.

index 	name 		address 		phone
1			Hill 		High...		2829478
2			Baker		17 King 		2884285
...
7			Moody		High King 	2822214

access tables

name 		address 		phone
2			3           5 
6        7           7
1        1           1
5        4           4
4        2           2
7        5           3
3        6           6


{table-adt}

This table is ADT which has domain(index set) and the codomain(bast type or value type). A table
with index set I and base type T is a function from I into T; which maps elements of domain to one
of codomain.

Index function and access tables are implementation methods for more general tables. Compared with
list which is sequence, table is the set and the function.


{radixsort}

Very efficient sorting method for linked list that uses a table and queue.

The idea is to consider the key one character at a time and to divide entries into as many sublists
as there are possibilities for the given character from the key. For example, if keys are words or
other alpabetic strings, divide the list into 26 sublists at each stage.

The idea eliminates multiplicity of sublists: partition the items into the table of sublists first
by the least significant position and to the most. When the list has been partitioned by the most
significant plae and recombined, will be sorted. {Q} why?

init 			by 3th 		by 2nd 		by 1st
rat 			mop { 		map { 		car 
mop			map 			rap 			cat
cat 			top 			car 			cot
map 			rap }			tar 			map
car 			car {			rat 			mop
top 			tar } 		cat }			rap
cot 			rat { 		mop { 		rat
tar 			cat 			top 			tar
rap 			cot } 		cot }			top 

The order of the words in each sublist remains the same as it was before the partition.

<ref-example>

Set up an array of 28 linked queues: position 0 corresponds to a blank character, position 1 through
26 to the letters and position 27 to any other character that appears in the key.

Traverse the linked list and add each item to the end of the appropriate queue. After partitioned,
recombine the queues into one list.

typedef char QueueEntry[KEYSIZE];

int QueuePosition(char c)
{
	if( c == '' ) return 0;
	else if( isalpha(c) )
		return tolower(c) - 'a' +1;
	else
		return 27;
}

void Rethread(List* list, Queue queues[] )
{
	int i;
	Node* x;

	for( i=0; i < MAXQARRAY; i++ )
		while( !QueueEmpty( &queues[i] ))
		{
			ServeNode( &x, &queues[i] );
			InsertList( ListSize(list), x, list );
		}
}

void RadixSort(List *list)
{
	int i, j;
	Node *x;
	Queue queues[MAXQARRAY];

	for( i=0; i < MAXQARRAY; i++ )
		CreateQueue(&queue[i]);

	// when keysize is 3, need to loop 2 times but j should start from 2 in order to start from the
	// most significant?
	for( j=KEYSIZE-2; j >= 0; j-- )
	{
		// get out an entry from list and put it to corresponding queue.
		while( !ListEmpty(list) )
		{
			// DeleteList( pos, ListEntry*, List*) and see general list. 
			DeleteList( 0, &x, list );
			AppendNode( x, &queue[ QueuePosition( x->entry[j]) ]);
		}

		// connect 28 queues together as a single list
		Rethread( list, queue );
	}
}

<analysis>

The radix sort is proportional to nk, where n is the number of items and k is the number of
characters in a key. To compare the relative performance with the best time of mergesort: if the
keys are long but there are few of them, then k is large and n is relatively small, then other
methods such as mergesort will outperform radixsort. If k is small and there are a large number of
keys, then radixsort will be faster than any other methods.


{hash-table}

For cases where the key is no longer an index that can be used directly as in array indexing. Hash
table is to allow many of the different possible keys that might occur to be mapped to the same
location under the action of index function. This index function is hash function which map several
different keys to the same index. This is collision. So two questions: find good hash function and
how to resolve collisions.
 
{hash-function}

Need even distribution of the keys but do not know in advance what keys will occur. There is nothing
random about a hash function. Three methods that can be put together in various way to build a hash
function. All about even distribution to avoid collisions.

<truncation>
Use part of key directly as the index. For example, for key 62538194, use 394 which is 1, 2 and 5
digits as the index. This is very fast but often fail to get even distribution.

<folding>
Partition the key into several parts and combine in convenient way. For example, 62538194 maps to
625+381+94 = 1100 which is truncated to 100. Since all information in the key is used, often have
better spread than truncation.

<modular>
Divide by the size of the index range and take remainder as the result. The spread depends very much
on the modulus( in this case, the size of the hash array). If the modulus is a power of a small
integer like 2 or 10, then many keys tend to map to the same index, while other indices remain
unused. The best is to use prime numbers: not 1000 or 1024 but use 997 or 1009.

This is the best since can get good spread and ensures that the result is in the proper range at the
same time. 

int Hash( Key s )
{
	unsigned h = 0;

	while(*s)
		h += *s++;

	return h % HASHSIZE;
}


{collision-resolution}

There are many ways to do. rehasing uses a second hash to obtain the second position to consider.

{summary}

Four different methods of information retrieval: sequential and binary search for list. table lookup
and hashing for table. 

For speed and convenience, Ordinary lookup in contiguous table is superior but there are many
applications to which it is inapplicable: when keys is sparse, when insertion or deletion are
frequent.


==============================================================================
*kt_dev_algo_011*	binary tree

The linked list have great advantages over contiguous implementation but have one weak feature:
{list-contiguous-and-linked} they are sequential list; that is, have to move through them only one
position at a time. not random access.

Tree overcome this and is valuable for problems of information retrieval.

{adt-definition}

A binary tree is either empty, or consist of a node called the root together with two binary tree
called the left subtree and the right subtree of the root.

The left and right are important for binary tree and has recursive nature that allows empty binary
tree and the empty tree is base case for recursive and determine when to stop.

2-tree is different from binary tree since 2-tree has always 0 or 2 children but never 1.

Excercise: get all fourteen binary trees with four nodes.

{traversal-orders}

There are many different traversal orders for trees and reduced to [three] by permitting only the ways
in which the left subtree is traversed before the right.

(V)isiting a node, traversing the left subtree L, and the right subtree R. [KT] notice visit,
traverse and subtree in wording.

VLR(preorder) LVR(inorder) LRV(postorder)
^              ^             ^

Do this order for every node and it has recursive nature. For example, traverse the following tree

	()1
		()2
	()3
()4   ()5

pre 12345, in 14352 and post 45321

{linked-implementation}

A binary tree has a natural implementation in linked strorage. The root variable enable us to find
the tree and it will point to the root of the tree.

{Q} is this typedef okay? Yes, it is.

typedef struct treenode TreeNode;
typedef struct treenode {
	TreeEntry entry; // application dependant
	TreeNode  *left;
	TreeNode  *right;
} TreeNode;

void CreateTree( TreeNode** root )
{ *root = NULL; }

Bool TreeEmpty( TreeNode* root )
{ return root == NULL; }

void Preorder( TreeNode* root, void (*Visit)(TreeEntry x))
{
	if(root)
	{
		Visit(root->entry);
		Preorder( root->left, Visit);
		Preorder( root->right, Visit);
	}
}

void Inorder( TreeNode* root, void (*Visit)(TreeEntry x))
{
	if(root)
	{
		Inorder( root->left, Visit);
		Visit(root->entry);
		Inorder( root->right, Visit);
	}
}


{binary-search-tree}

In {ref-004}, when given a binary tree question, many candidates assumes that it means binary search
tree. Be sure to ask whether or not the tree is a binary search tree(BST). A BST imposes the
condition that, for all nodes, the left children are less than or equal to the current node, which
is less than all the right nodes. BST is a special kind of a binary tree.

The searching through the linked list always reduce to a sequential search and contiguous list is
much slower when frequently need to make changes in the list. The binary search tree is excellent
solution to this problem:

Can we find an implementation for ordered list in which we can search quickly (as with binary search
on a contiguous list) and in which we can make insertions and deletions quickly (as with a linked
list)?

By making the entries of an [ordered-list] into the nodes of a binary tree, O(logn) for search and
O(logn) for insertion and deletion as with binary search. The main design is to store the nodes as a
binary tree with the structure of comparison tree itself, with links used to describe the relations
of the tree. 

This is especially appropriate when random access, traversal in predetermined order, and flexibility
are all required.

<adt-definition>

The binary search tree is a binary tree that is either empty or in which every node contains a key
and satisfies the conditions:

1. The key in the [left] child of a node (if it exists) is [less] than the key in its parent node.
2. The key in the [right] child of a node (if it exists) is [greater] than the key in its parent node.
3. The left and right subtrees of the root are again binary search tree.

This ensures that no two entries in a binary search tree can have [equal-keys] since keys are strictly
less or greater. Possible to change the definition to allow entries with equal keys, but doing so
make the algorithm complicated.


<comparison-trees>

This is a BST and here 0 means NULL for left or right subtree.

              Jim
     Dot              Ron
  Amy     Guy     Kay     Tim
0   Ann Eva Jan Jon Kim Roy Tom
    0 0 0 0 0 0 0 0 0 0 0 0 0 0
 
Preorder: Jim Dot Amy Ann Guy Eva Jan Ron Kay Jon Kim Tim Toy Tom
Inoder  : Amy Ann Dot Eva Guy Jan Jim Jon Kay Kim Ron Roy Tim Tom


<tree-search>

The search in a linked binary search tree and termination condition is if we find the key and if
not, then continue searching until hit an empty subtree. This is based closely on binary search so
do the same comparisons as binary search do. O(logn)

// returns node pointer if an entry in the binary search tree has key equal to target; that is when
// root is not null and LT and GT are false. otherwise, returns NULL which is a leaf. See returning
// root up the chain and 'else if (GT)' but not 'else if'. Strictly less or greater. 

TreeNode* TreeSearch( TreeNode* root, KeyType target )
{
	if(root)
	{
		if( LT( target, root->entry.key) )
			root = TreeSearch( root->left, target );
		else if( GT(target, root->entry.key) )
			root = TreeSearch( root->right, target );
	}

	return root;
}

//
// recursion removal version as it is tail recursion. returns node if found; otherwise, ?

TreeNode* TreeSearch( TreeNode* root, KeyType target)
{
	TreeNode* position = root;

	// already checked equal case in while so no need to the same in if and else clause
	while( position && NE( target, position->entry.key ))
	{
		if( LT(target, position->entry.key ))
			position = position->left;
		else
			position = position->right;
	}

	return position;
}


<random-binary-search-tree>

The same keys which are letters in this case can have quite different shapes of trees depending how
a tree is made. In other words, how it is inserted into a tree from the best which is bushiest
meaning fewerer tree height, comparison, or recursion depth to the wortst which is a single chain
and is equal to sequential search. 

Remember that binary search requires ordered list. The search performance of BST depends on how a
tree constructed. The TreeInsert can handle the random input and when the input is ordered, BST
degenerates to the worst case, single chain. Think a tree shape when use TreeInsert with ordered
input. The worst case is extremely unlikely in practice so TreeSearch performs nearly as well as
binary search. For random order, it is 39% slower than the optimum of log n comparisons. Still
better than sequential search. {Q} is it average? Yes, it is.

This tree handles random input order and hence called random BST.


<tree-insert> which supports the random input
>
 The worst of a random binary search tree is when the keys are inserted into an initially empty tree
 in their natural order, sorted. This will produce a chain, a tree with a single line. The same
 holds if the keys are in reverse order or if they are nearly but not quite sorted into order.
 TreeInsert should never be used with keys that are already sorted into order.

If the keys are equal, we shall adopt the convention of inserting the duplicate key into the right
subtree. It inserts a new key that duplicates a previous key on the right side of the old entry.
TreeSearch, the searching function will always find the first entry of duplicated keys.

// See how return value is used; used to set left or right of the previous node.
//
TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
	if(!root)
	{
		root = newnode;
		root->left = root->right = NULL;
	}
	else if( LT(newnode->key.entry, root->key.entry ) )
		root->left = TreeInsert( root->left, newnode);
	else
		root->right = TreeInsert( root->right, newnode);
	
	return root;
}

In regard to performance, TreeInsert will be very much the same as that of TreeSearch to find a
place to insert: O(logn)


{treesort}

The inorder(LVR) traversal of binary search tree always give the sorted order for the keys. So
simply takes the entries to be sorted, use TreeInsert to build them into a binary search tree, and
use inorder traversal to put them out in order.

Notice the similarity with quicksort. The quicksort is usually an excellent method and treesort
makes the same comparisons as does quicksort. In the average, on a randomly ordered list of n,
treesort performs:

1.39 nlogn + O(n)

Treesort has one advantage over quicksort: Quicksort needs to have access to all the items to be
sorted but with treesort, the nodes need not all be available at the start of the process, but are
built into the tree one by one as they become available since as each node comes in it goes into its
final position in the linked list. 

This is major advantage that 1) search tree remains avaiable for later [insertions-and-deletions], and
that 2) can be searched in logarithmic time, whereas all previous sorting either requires contiguous
list or produce linked list for sequential search. 2) comes from BST.

As quicksort, the major drawback is the worst case when input is already sorted, or are nearly so.


<code-example>

#include < iostream>
#include < string>
#include < cstdlib>

#define LT(a,b) ((a) < (b))

typedef struct {
	int key;
} TreeEntry;

typedef struct treenode {
	TreeEntry entry; // application dependant
	treenode  *left;
	treenode  *right;
} TreeNode;

TreeNode* MakeTreeNode(int key)
{
	TreeNode* pnode = NULL;

	if( (pnode = (TreeNode*) malloc(sizeof(TreeNode))) == NULL )
	{
		std::cout << "MakeTreeNode: out of memory" << std::endl;
		return pnode;
	}

	pnode->entry.key = key;
	pnode->left = pnode->right = NULL;

	return pnode;
}

void CreateTree( TreeNode** root )
{ *root = NULL; }

TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
	if(!root)
	{
		root = newnode;
		root->left = root->right = NULL;
		std::cout << "inserted: " << root->entry.key << std::endl;
	}
	else if( LT(newnode->entry.key, root->entry.key) )
		root->left = TreeInsert( root->left, newnode);
	else
		root->right = TreeInsert( root->right, newnode);
	
	return root;
}

void TreeInorder( TreeNode* root, void (*Visit)(TreeEntry x))
{
	if(root)
	{
		TreeInorder( root->left, Visit);
		Visit(root->entry);
		TreeInorder( root->right, Visit);
	}
}

void PrintTreeNode( TreeEntry entry )
{
	std::cout << ":" << entry.key << std::endl;
}

int main()
{
   // int arr[] = { 2, 3, 5, 6, 10, 12, 13, 15, 17, 29, 30, 31, 33 };
   int arr[] = { 33, 2, 31, 5, 30, 6, 12, 10, 13, 15, 17, 29, 3 };
   int size = ( sizeof(arr)/sizeof(arr[0]));

	TreeNode *proot, *pnode;
	CreateTree( &proot );

   std::cout << "{ "; 
   
   for(int idx = 0; idx < size; idx++)
	{
      std::cout << "insert " << arr[idx] << " into a tree" << std::endl; 
		pnode = MakeTreeNode( arr[idx] );
		// TreeInsert( proot, pnode ); 	// [KT] this is an error and see *kt_dev_cpp_014*
		proot = TreeInsert( proot, pnode );
	}

	TreeInorder( proot, PrintTreeNode );

   std::cout << "}" << std::endl; 
}


{Q} can change these to use reference?


<tree-delete>

Why care about deleting a node in a tree? because it is one of advantages treesort provides and
which is that search remains avaialbe after insertion and deletion. It is more complicated when the
node to be deleted has both left and right subtrees nonempty. One possible solution to following
questions:

1. To which of the subtree, should the parent of the deleted node now point? Right or left subtree?
Here in this book, attach the right subtree in place of the deleted node.

2. To which node of the right subtree, should the former left subtree be attached? Since every key
in the left subtree precedes every key of the right subtree, must be as far to the left as possible.
(remember The left subtree is also a tree.) This point can be found by taking left branches until an
empty left subtree is found.

TreeNode* x;					// pointer to a parent node of a node to delete;
DeleteNodeTree(&x->left); 	// equals to DeleteNodeTree(&(x->left));

// The parameter p is the address of actual node(not a copy) in a tree since the object is to update
// the BST, the actual parameter is the address of one of the links of the tree.

void DeleteNodeTree( TreeNode** p )
{
	// r points node to delete
	TreeNode* r = *p, *q;

	if( r == NULL )
		Error("attempt to delete a nonexistent node from binary search tree");
	// when a node has only either left or right subtree, attach subtree to a parent
	else if( r->right == NULL )
	{
		*p = r->left;	// reattach left subtree
		free(r);
	}
	else if( r->left == NULL )
	{
		*p = r->right;	// reattach right subtree. *p now points to r->right.
		free(r);			// release the node. *r points the previois node so okay to free.
	}
	// when a node has both subtrees [KT] this is interesting parts.
	else
	{
		// get to the leftmost node of the right subtree. starts from the right of r node. see how it
		// moves a tree. loop stops at a node with an empty left subtree, but not to end at the empty
		// subtree itself.
		for( q = r->right; q->left; q = q->left )
			;

		q->left = r->left;	// reattach left subtree
		*p = r->right;			// reattach right subtree
		free(r);
	}
}

For many cases, not given a pointer to a node to delete but instead given a key for which the
corresponding node must be deleted. So combine search and delete function.

void DeleteKeyTree( TreeNode** root, TreeNode** keyposition, KeyType target )
{
	if(*root == NULL)
		Error("attempt to delete a nonexistent node from binary search tree");
	else if ( EQ( target, (*root)->entry.key ) )
	{
		*keyposition = *root;
		DeleteNodeTree(root);
	} else if( LT( target, (*root)->entry.key ))
		DeleteKeyTree( root, keyposition, target);
	else
		DeleteKeyTree( root, keyposition, target);
}	


<tree-balance>

This delete function is far from optimal as it can greatly increase the height of the tree. Two
examples:

     (r)                       (x)    
   (b) (x)    delete r       (b) (y)  
 (a)     (y)               (a)      (z) 
           (z)                       

       (r)    delete r          (z)
    (c)  (z)                  (y)
  (b)  (y)                  (x)
(a)  (x)                  (c)
                        (b)
							(a)

The second example increases its height. Thus the time required for a later search can substantially
increase, even though the total size of the tree has decreased. Hence to optimise the use of binary
search tree, need methods to make the left and right subtree more nearly balanced. To reduce height,
need to make it balanced.

Is it worthwhile, on average, to keep a binary search tree balanced or rebalance it? The average
cost of not balancing a binary search tree is approximately 39% more comparisons because not
balanced tree becomes random binary search tree. See 9.3.6 in {ref-001}


{build-bst-with-ordered-input}

<ref-example>
		 
The complete binary tree of 1...31 in the order in which they are received:
													(16)															2^4
						(8)													(24)								2^3
			(4)					(12)						(20)							(28)				2^2
	(2)		(6)		(10)		(14)			(18)			(22)			(26)			(30)		2^1
(1) (3)	(5) (7)	(9) (11)	(13) (15)	(17) (19)	(21) (23)	(25) (27) 	(29) (31) 	2^0


// lastnode
When node number 1 arrives, is a leaf and therefore its left and right pointers should both be NULL.
When node number 2 arrives, goes above node 1 and should remember where node 1 is. 
When node number 3 arrives, is a leaf but is in the right of node 2 and remember node 2. 

												(4)*				(4)* 				level 3
 			(2)*		(2)*			(2)	   		(2)						level 2	
(1)*	(1)		(1)	(3)	(1)	(3)   	(1)	(3) 		(5)* 		level 1 
n=1	n=2		n=3			n=4				n=5

where * is a node that must be remembered as the tree grows

Must keep a list of all nodes previously processed? No and need only to remember one node on each
level, the last node processed on that level. pointers in lastnode array that will quite small. For
example, 20 levels can have 2^20-1 > 1,000,000 nodes.

For some nodes, the right link should not permanently NULL since the node to insert may be the right
child of some previois node. For some, it may be left child, in which case its parent node has not
yet arrived. Can tell which case occurs by looking at lastnode. If level is the level of new node
then parent level is level+1. Look at lastnode[level+1] and if the right is still null, its right
must be the new node and if not, the right is aleady arrived and the new node must be the left of
some future node.  

// true when x is odd number
#define ODD(x)	((x)/2*2 != (x))

// find the highest power of 2 that devides count. requires x != 0. 
// returns level = 0,1,2,3,4,5...
// count: 	4 			12 		20
// level, x 0 4		0 12		0 20
//        	1 2		1 6		1 10
//        	2 1		2 3		2 5

int Power2(int x)
{
	int level;

	// run when x is even
	for(level=0; !ODD(x); level++)
		x/=2;

	return level;
}

<tree-insert> which assumes the ordered input

void Insert( TreeNode *newnode, int count, TreeNode *lastnode[] )
{
	int level = Power2(count)+1;
	newnode->right = NULL;
	newnode->left 	= lastnode[level-1];							// previous level
	lastnode[level] = newnode;										// level
	
	// for example, when n=6
	if(lastnode[level+1] && !lastnode[level+1]->right )	// parent level
		lastnode[level+1]->right = newnode;
}

// If there is information available, GetNode creates a TreeNode, copies the information into the
// node, and returns a pointer to this TreeNode. Otherwise, returns NULL. This is to obtain each new
// node.
TreeNode *GetNode();

// the root is the highest node in the tree; hence its pointer is the highest entry not equal to
// NULL in the lastnode array.
TreeNode *FindRoot(TreeNode *lastnode[])
{
	int level;

	for( level = MAXHEIGHT-1; level > 0 && !lastnode[level]; level--)
		;

	if( level <= 0 )
		return NULL;
	else
		return lastnode[level];
}

// The nearly completed BST has been initialized. must tie in any subtrees that may not yet be
// connected properly after all the nodes have been received. The difficulty is that some nodes in
// the upper part of tree may still have their right links set to null, even though further nodes
// have come in that belong in their right subtrees. Any node for which the right child is still
// null will be one of the nodes in lastnode. Its right child should be set to the highest node in
// lastnode that is not already in its left subtree.
void ConnectSubtree( TreeNode *lastnode[] )
{
	TreeNode *p;
	int level, templevel;

	// find the root
	for( level = MAXHEIGHT-1; level > 2 && !lastnode[level]; level--)
		;

	while( level > 2 )	// level 1 and 2 are already okay
	{
		if( lastnode[level]->right )
			level--;		// search for highest dangling node
		else 				// right subtree is undefined
		{
			p = lastnode[level]->left;
			templevel = level-1;
			do {			// find highest entry not in left subtree
				p = p->right;
			} while( p && p == lastnode[--templevel]);

			lastnode[level]->right = lastnode[templevel];
			level = templevel;
		}
	}
}

TreeNode *BuildTree(void)
{
	TreeNode *newnode;
	int count = 0;
	int level;

	TreeNode* lastnode[ MAXHEIGHT ];

	for( level = 0; level < MAXHEIGHT; level++ )
		lastnode[level] = NULL;

	while((newnode = GetNode()) != NULL )
		Insert( newnode, ++count, lastnode );

	// after all the nodes have been inserted into the new tree, find the root of the tree and then
	// connect any right subtrees that may be dangling. For example, n=5 and 21 node.
	newnode = FindRoot(lastnode);
	ConnectSubtree( lastnode );

	return newnode;
}

This algorithm produces a binary tree that is not always completed balanced. For n=32, it will
become the root of the tree and all 31 node will be in its left. 5 steps from the root to leaf.
Hence one comparison more than necessary will usually be done and it is not really a high price.

This algorithm is never more than one level away from optimality. There are sophisticated methods
for building a binary tree that is as balanced as possible but recommend a simpler method, one that
does not need to know in advance how many nodes are in the tree. For many practical purposes, this
should prove sufficient.


==============================================================================
*kt_dev_algo_012*	avl tree

{avl-tree}

In many application, insertions and deletions occur continually with no predictable order. AVL tree
is a method to keep the tree very nearly balanced at all times for all search, insertion and
deletions to optimise search times even in the worst case. In almost all cases, AVL tree closely
approximates that of ideal, completely balanced binary search tree. O(logn).


{splay-tree}

Like hospital example, want to keep records that are newly inserted or frequently accessed very
close to the root, while records that are inactive may be placed far off, near or in the leaves.

Also cannot shut down the hospital for an hour to rebuild the tree into the desired shape, so do
self-adjusting data that automatically changes its shape to meet the above.


# ============================================================================
#{

==============================================================================
*kt_dev_algo_100*	discussion: C++ map insertion and lookup performance and storage overhead

http://stackoverflow.com/questions/1822114/c-map-insertion-and-lookup-performance-and-storage-overhead

The question is:

I would like to store a mapping of an integer key to a float value in-memory.  I have roughly 130
million keys (and, accordingly, 130 million values). My focus is on lookup performance -- I have to
do many, many millions of lookups.  The C++ STL library has a map class for associative arrays of
	this sort. I have several questions about map.  What is the storage overhead of map for a dataset
		of the size mentioned above? How does storage overhead scale, in general, with map? It looks
		like the underlying data structure for map is a red-black, balanced binary tree. It sounds
		like the real-world performance for this is O(log n) for insertion and retrieval. It mentions
		O(1) for a hinted insertion. My input is pre-sorted, so I believe I should be able to provide
		a hint for insertion events. How would I provide this hint, using the methods listed here? Is
		there an STL container that provides better lookup performance?  Are there other
		publicly-available, open-source frameworks with an associate array class that uses an
		underlying data structure that would perform better than STL map? If writing my own container
		class would provide better lookup performance, what data structures might I research? I am
		using GCC 4 for this task, running under either Linux or Mac OS X. I apologize in advance if
		these are dumb questions. Thank you for your advice.


Given what you've said, I'd think very hard about using an std::vector<pair<int, float> >, and using
std::lower_bound, std::upper_bound, and/or std::equal_range to look up values.

While the exact overhead of std::map can (and does) vary, there's little or no room for question
that it will normally consume extra memory and look up values more slowly than a binary search in a
vector. As you've noted, it's normally (and almost unavoidably) implemented as some sort of balanced
tree, which imposes overhead for the pointers and the balancing information, and typically means
each node is allocated separately as well. Since your nodes are pretty small (typically 8 bytes)
that extra data is likely to be at least as much as what you're actually storing (i.e. at least 100%
		overhead). Separate allocations often mean poor locality of reference, which leads to poor
cache usage.

Edit: Looking just at implementations of std::map, it's probably worth noting that most use a
red-black tree. If you were going to use an std::map, an implementation that uses an AVL tree would
probably suit your purposes better -- an AVL tree has slightly tighter constraints on balancing.
This gives slightly faster lookup at the expense of slightly slower insertion and deletion (since it
		has to re-balance more often to maintain its stricter interpretation of "balanced"). As long
as your data remains constant during use, however, an std::vector is still almost certainly better.

One other possibility worth noting: if your keys are at least fairly even distributed, you might
want to try looking up using interpolation instead of bisection. i.e. instead of always starting at
the middle of the vector, you do a linear interpolation to guess at the most likely starting point
for the lookup. Of course, if your keys follow some known non-linear distribution, you can use a
	matching interpolation instead.

Edit 2: Assuming the keys are reasonably even distributed, the interpolation search has a complexity
of O(log log N). For 130 million keys, that works out to around 4 probes to find an item. To do
significantly better than that with (normal/non-perfect) hashing, you need a good algorithm, and you
need to keep the load factor in the table around 75% or so -- i.e. you need to allow for something
like 32 million extra (empty) spots in your table to improve the expected complexity from four
probes to three. I may just be old fashioned, but that strikes me as a lot of extra storage to use
for such a small speed improvement.

OTOH, it's true that this is nearly the ideal situation for perfect hashing -- the set is known
	ahead of time, and the key is quite small (important, since hashing is normally linear on the key
			size). Even so, unless the keys are distributed pretty unevenly, I wouldn't expect any huge
	improvement -- a perfect hash function is often (usually?) fairly complex.  share|improve this
	answer
	
definitely just use a binary search in the vector. Least memory, fastest too. –  Will Nov 30 '09 at
20:33
	
What about insertions? To use binary search, you'll have to keep the array sorted. Random
insertions in a vector are not particularly efficient. –  Raphaël Saint-Pierre Nov 30 '09 at 20:36
	
@RaphealSP: yes, if the data were dynamic (i.e. you need to support insertions/deletions during
		use), a sorted vector isn't a good choice. He notes, however, that the data starts out sorted,
	which I took as indicating that he's just reading in data, but not modifying it afterwards. –
		Jerry Coffin Nov 30 '09 at 20:41
	 
I am only inserting once. I do not need to modify my input set afterwards. –  Alex Reynolds Nov 30
'09 at 20:45 


# ============================================================================
#{

==============================================================================
*kt_dev_ref*	references

{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

{ref-003} design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

{ref-005} C++ primer, 5th Ed.

==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
