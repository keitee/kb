*kt_dev_uv*                                                             tw=101

|kt_dev_uv_set_000| tvos-chat

|kt_dev_uv_set_001| setup printer
|kt_dev_uv_set_002| setup email
|kt_dev_uv_set_003| setup: humax build the stack
|kt_dev_uv_set_004| huawei: to revert back the previous version
|kt_dev_uv_set_005| setup: screen connection
|kt_dev_uv_set_006| filegateway
|kt_dev_uv_set_010| setup: git for dev and oem
|kt_dev_uv_set_011| setup: ci builds

*kt_dev_uv_stack_000* zinc-build: zb-make
*kt_dev_uv_stack_000* zinc-build: zb-build-with-progress
*kt_dev_uv_stack_000* zinc-build: makefile
*kt_dev_uv_stack_001* zinc-build: build commands and build vars
*kt_dev_uv_stack_003* zinc-build: debug or release
*kt_dev_uv_stack_003* zinc-build: autotool structures
*kt_dev_uv_stack_003* zinc-build: exclude files
*kt_dev_uv_stack_003* zinc-build: zb-shell, setvar-common
*kt_dev_uv_stack_003* zinc-build: setvars

*kt_dev_uv_stack_002* tool-jirafy:
*kt_dev_uv_stack_002* tool-git-hook:
|kt_dev_uv_stack_002| tool-zb-deploy
*kt_dev_uv_stack_002* tool-patch-a-tron
|kt_dev_uv_stack_003| stack: build: debug or release
*kt_dev_uv_stack_003* stack: build: exclude
|kt_dev_uv_stack_003| stack: startup and bootup
|kt_dev_uv_stack_004| stack: oem version and configs
|kt_dev_uv_stack_005| stack: brcm debug level
|kt_dev_uv_stack_006| stack: netflix ps line
|kt_dev_uv_stack_007| stack: virtual rcu
|kt_dev_uv_stack_008| stack: startup mw
*kt_dev_uv_stack_009* zinc-lsr: keys
|kt_dev_uv_stack_010| stack: commit
|kt_dev_uv_stack_011| zinc-log
|kt_dev_uv_stack_012| stack: gdb
|kt_dev_uv_stack_013| stack: platform data
*kt_dev_uv_stack_014* zinc-test
*kt_dev_uv_stack_014* zinc-test-support

|kt_dev_uv_stack_100| stack: element names
*kt_dev_uv_stack_101* zinc-plugin: plugin and client system
|kt_dev_uv_stack_102| zinc-plugin: plugin and dbus client
|kt_dev_uv_stack_103| zinc-plugin
*kt_dev_uv_stack_103* zinc-plugin: finder
|kt_dev_uv_stack_104| stack: binding and makefile 
|kt_dev_uv_stack_105| stack: dbus

|kt_dev_uv_stack_200| stack: uranium: stagecraft and air
|kt_dev_uv_stack_201| stack: uranium: creation chain to other components via dbus and factory
|kt_dev_uv_stack_202| stack: uranium: metadata: event structures and dbus xml
|kt_dev_uv_stack_203| stack: uranium: metadata: system api call via dbus rpc
|kt_dev_uv_stack_204| stack: uranium: metadata: events and client events
|kt_dev_uv_stack_205| stack: uranium: metadata: how events get updated
|kt_dev_uv_stack_206| stack: uranium: metadata: events data flow
|kt_dev_uv_stack_207| stack: uranium: metadata: summary data flow
|kt_dev_uv_stack_208| stack: uranium: metadata: wrapper and convert flow
|kt_dev_uv_stack_209| stack: uranium: metadata and dbus inspection
|kt_dev_uv_stack_210| stack: uranium: metadata test
|kt_dev_uv_stack_211| stack: uranium: systemmediarecordcachetest tests

*kt_dev_uv_stack_250* zinc-mr-web: runbrowser
*kt_dev_uv_stack_251* zinc-mr-web: binding
*kt_dev_uv_stack_014* zinc-mr-web: debug webkit
*kt_dev_uv_stack_014* zinc-mr-web: build webkit plugin
*kt_dev_uv_stack_253* zinc-mr-web: MediaRouter.WebKit.Plugin
*kt_dev_uv_stack_254* zinc-mr: listener
*kt_dev_uv_stack_255* zinc-mr-error: error handle
*kt_dev_uv_stack_255* zinc-mr-web: ended event
*kt_dev_uv_stack_256* zinc-mr: underflow error handle
*kt_dev_uv_stack_256* zinc-mr: connection retry
*kt_dev_uv_stack_256* zinc-mr-error: when pull network out
*kt_dev_uv_stack_256* mr-dash-error: when http 404
*kt_dev_uv_stack_256* mr-dash-error: corrupted stream
*kt_dev_uv_stack_257* zinc-mr-web: qunit test
*kt_dev_uv_stack_258* zinc-mr: yv webkit plugin
*kt_dev_uv_stack_258* zinc-mr: run cdi app on yv mr
*kt_dev_uv_stack_259* zinc-mr: local web server and client
*kt_dev_uv_stack_400* zinc-mr: links
|kt_dev_uv_stack_402| zinc-mr-gst
*kt_dev_uv_stack_402* zinc-mr-gst: libs and packages
*kt_dev_uv_stack_423* zinc-mr-gst: nexussink
*kt_dev_uv_stack_426* zinc-mr-gst: tsnexusbin
|kt_dev_uv_stack_404| zinc-mr-linear: linearsourced
*kt_dev_uv_stack_405* zinc-mr-linear: zmp 
*kt_dev_uv_stack_407* zinc-mr: media router spec
*kt_dev_uv_stack_408* zinc-mr: plugin creations on mime types
*kt_dev_uv_stack_409* mr-dash: gst-mr: create
*kt_dev_uv_stack_409* mr-dash: gst-mr: use signal
*kt_dev_uv_stack_409* mr-dash: gst-mr: revised to support bin injection
*kt_dev_uv_stack_409* mr-dash: gst-mr: disable dash on master
*kt_dev_uv_stack_410* mr-dash: build dash pipeline using gst mr
*kt_dev_uv_stack_411* zinc-mr: qt and media router interface
*kt_dev_uv_stack_412* zinc-mr: get natual size
*kt_dev_uv_stack_413* zinc-mr: gstmediaroutertest
*kt_dev_uv_stack_413* zinc-mr-auth: device auth
*kt_dev_uv_stack_412* zinc-mr: dash play using the proxy
*kt_dev_uv_stack_413* zinc-mr: hls play
*kt_dev_uv_stack_413* zinc-mr: gstmr-play.sh
*kt_dev_uv_stack_413* mr-dash-debug: 
*kt_dev_uv_stack_413* mr-dash-debug: nickel in sandbox
*kt_dev_uv_stack_413* zinc-drm:
*kt_dev_uv_stack_413* zinc-drm: wrong db creation due to library depandancy
*kt_dev_uv_stack_413* zinc-drm: error
|kt_dev_uv_stack_415| zinc-mr: boot failure when use wrong plugin name
*kt_dev_uv_stack_440* zinc-mr: bronze
*kt_dev_uv_stack_441* zinc-mr: dash todo list

|kt_dev_uv_stack_300| stack: copper: lsr (local storage repository)
|kt_dev_uv_stack_301| stack: copper: client factory

|kt_dev_uv_stack_350| stack: titanium
|kt_dev_uv_stack_351| zinc-sandbox: titanium: sandbox
*kt_dev_uv_stack_351* zinc-sandbox: source 

|kt_dev_uv_stack_450| stack: cobalt

|kt_dev_uv_stack_500| stack: iron
*kt_dev_uv_stack_500* zinc-test-web
*kt_dev_uv_stack_500* zinc-js: 

|kt_dev_uv_stack_114| stack: build pc target
|kt_dev_uv_stack_115| stack: text epg
|kt_dev_uv_stack_116| stack: future
|kt_dev_uv_stack_117| stack: future use

|kt_dev_uv_stack_130| stack: links with 3rd parties. cppunit, gmock and so on

|kt_dev_uv_stack_150| stack: network

|kt_dev_uv_stack_200| commands TODO:

|kt_dev_uv_wiki_001| dbus-monitor-spy
|kt_dev_uv_wiki_100| mpeg-dash

*kt_dev_uv_oem_001* oem-box-hwei:
*kt_dev_uv_oem_001* oem-box-hmax: burning
*kt_dev_uv_oem_001* oem-box: staging and toolchanis
*kt_dev_uv_oem_001* zinc-jira: deploy the prebuilt binary

|kt_dev_uv_oem_001| nexusmgr
*kt_dev_uv_oem_002* nexusmgr build issue and proposal
|kt_dev_uv_oem_002| zinc-nexus: nexussink callback
*kt_dev_uv_oem_003* brcm playpump
|kt_dev_uv_oem_003| brcm reference sw
|kt_dev_uv_oem_004| brcm stc
|kt_dev_uv_oem_005| brcm audio
|kt_dev_uv_oem_006| brcm video

|kt_dev_uv_task_002| task:02: DEVARCH-8869: about IP connection.
|kt_dev_uv_task_003| task:02: DEVARCH-7508: runBrowser-test.sh
|kt_dev_uv_task_004| task:03: DEVARCH-9135: uranium metadata
|kt_dev_uv_task_005| task:01: nexus tools to have 'deprecated" build for hmax
|kt_dev_uv_task_006| task:05: sort out test failures
|kt_dev_uv_task_007| task:06: playback audio only IP channel
|kt_dev_uv_task_008| task:07: DEVARCH-9557: netflix launch issue
|kt_dev_uv_task_009| task:08: fr15: hls: DEVARCH-9722
*kt_dev_uv_task_010* task:09: fr15: yv meadia router switch
*kt_dev_uv_task_011* task:09: fr15: video resize support
*kt_dev_uv_task_011* task:09: fr15: dash error handling
*kt_dev_uv_task_011* task:09: fr15: underflow error handling
*kt_dev_uv_task_011* task:09: fr15: fix gstmediaroutertest failure
*kt_dev_uv_task_011* task:09: fr15: wrong drm db creation on HWEI PVR2

# ============================================================================
#{
={============================================================================
*kt_dev_uv_set_000* tvos-chat

Fri Sep 25 11:22:31 BST 2015

Kris KonopkoÂ·9:55 AM
all if you pull from master and want to use YouView MR, you need to edit the
following file on the device:

/opt/zinc-trunk/share/nickel-system-gstreamer/titaniumdeviceauthority-system-factory.plugin-config

or get your device's DUID listed in the authorisation service under
"yv-mediarouter" feature if you choose the first method, put this as the first
line in the plugin-config file:

libTitaniumDeviceAuthoritySystemOff.so createOffSystemFactory

(no need to delete the original line which becomes the second one) unfortunately
this needs to be done manually now each time you deploy your device... you could
use `-D` option for patch-a-tron script but that would disable all authorisation
and you'd end up enabling NextGen UI which may or may not launch any ideas for
this to make it all easier are welcome also `gstmr-play.sh` now accepts `-n`
option which will use the already running (sandboxed) nickelmediad (or activate
    it) instead of launching a new one locally on the command line


# ============================================================================
#{
={============================================================================
*kt_dev_uv_set_001* setup: printer

1. install cups
sudo apt-get install cups

2. add printers via cups admin page 
See this page, add user to the printer group, and browse to localhost, and
follow the instructions to add printers. 

www.howtoforge.com/how-to-install-a-canon-printer-on-debian-and-debian-like-systems

3. use printer names from this page.
https://wiki.youview.co.uk/display/canvas/How+To+-+Set+up+printers


={============================================================================
*kt_dev_uv_set_002* setup: email

1. The evolution under debian do not work. Forced to use icedove, OWA and
phone instead.

2. Clone the git repo.
Follow this page.
https://wiki.youview.co.uk/display/canvas/How+To+-+Get+access+to+git-dev+repositories


={============================================================================
*kt_dev_uv_set_003* setup: humax build the stack

{install-package}
1. Can see package files from the repo
http://devarch-deb:8080/job/DEBs/ws/DEBS/

-rw-r--r--  1 kpark kpark 205942756 Jan  8 10:30 adobe-flex4-sdk_4.1.0.16076withairsdk2.5-3_i386.deb
-rw-r--r--  1 kpark kpark   5310170 Jan  8 10:30 adobe-stagecraft_2.5.2.3.20120518-3_i386.deb
-rw-r--r--  1 kpark kpark  80815260 Jan  8 10:35 generic-stbgcc-4.4.5-2.0_20120927-2_i386.deb
-rw-r--r--  1 kpark kpark  24399388 Jan  8 10:37 humax-dtr-t1000-staging_20140718H20.2.0-3_i386.deb
-rw-r--r--  1 kpark kpark 328730796 Jan  8 10:48 humax-stbgcc-4.5.3-2.4_20130321-2_i386.deb

2. Or can use apt-get install on the command line.
sudo apt-get install map-dir-and-exec


{1} build-stack
$ cd ~/sources/
zb-virtual-slave zb-shell
ZB_CFG=humax.1000 zb-make

note: shall have pysical data dir under /. when use sym link to the home, failed to build.

<check-package>
dpkg-query -l | grep humax


{2} update-cds; core driver software
https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Humax+DTR-T1000+T1000+H21.5.0

note: follow instruction, CTK. 


{3} update the zinc whcich was built
1. follow "boot from HDD" instruction from:
https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Humax+DTR-T1000+T1000+H21.5.0


{layout}
/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409$ tree -L 3
.
|-- opt
|   `-- zinc-trunk
|       |-- bin
|       |-- devel
|       |-- include
|       |-- lib
|       |-- libexec
|       |-- oss
|       |-- platform
|       |-- share
|       |-- tests
|       `-- var
`-- usr -> /opt/oem-staging/huawei-bcm7409/usr


={============================================================================
*kt_dev_uv_set_004* huawei: to revert back the previous version

touch /opt/cds/download/smdebug

setItem oem.software.version 11.11.11

setItem oem.activatedsoftware.coredevicesoftware.version 11.01.01

setItem oem.activatedsoftware.manufacturerconfiguration.version 1

setItem oem.activatedsoftware.coredevicesoftware.platformapiversion 1.2.0

setItem oem.activatedsoftware.platformsoftware.version 1.3.4

setItem oem.activatedsoftware.platformconfiguration.version 1

Goes to settings -> Dev. Mgt. -> Software Update. Then will update a box from usb stick.

note: Only for ATK.


={============================================================================
*kt_dev_uv_set_005* setup: screen connection

sudo screen /dev/ttyS0 115200

to close screen use Ctrl-A, k, y. Do not use Ctrl-C as it can kill processes running on the box.


={============================================================================
*kt_dev_uv_set_006* filegateway

$ scp -r kit.park@filegateway.youview.co.uk:/export/repos/huawei/from_huawei/PVR1_DN370T/Huawei_DN370T_B37SP33_Eng_Release_20150331_for_YVHUAWEI-6751 ./

$ ssh kit.park@filegateway.youview.co.uk ls -alR /export/repos/huawei/from_huawei/PVR1_DN370T/Huawei_DN370T_B37SP46_Release_20150424/


={============================================================================
*kt_dev_uv_set_010* setup: git for dev and oem

<git-oems>
url = gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git
url = gitolite@git-humax.dev.youview.co.uk:/nexusMgr.git

<git-local>
https://git-dev.dev.youview.co.uk/?p=nexusMgr.git;a=summary

https://git-dev.dev.youview.co.uk/

git clone -b huawei/dn370t gitolite@git-dev:/nexusMgr.git XX

/home/kpark/git-dev/nexusMgr        " cloned
/home/kpark/git-dev/nexusMgr-WIP    " work space for hwei 370

{oem}
/home/kpark/git-oem/*

<hmax>
note: need to figure out branch name
git clone gitolite@git-humax.dev.youview.co.uk:/nexusMgr.git nexusHmax

<hwei>
git clone -b huawei/dn370t gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git nexusHwei


={============================================================================
*kt_dev_uv_set_011* setup: ci builds

https://wiki.youview.co.uk/display/canvas/How+access+Jenkins+build+slaves

o to kick off a test build

Hi All,

Ashley has created a TRY builder to which if you give your branch name or Git
Sha and your email id, it will trigger builds for all devices and send you an
email with the results once complete.

http://spongebob.dev.youview.co.uk:8080/job/Build_Zinc_Release_Try/build?delay=0sec

If any build fails, the email will have link to error logs and if build passes
it will link to the binaries available on devnfs2.

You can use this to kick off builds for your dev branches.

Hope you find it useful.

Thanks,

Tarun


o to see build status
http://spongebob:8080/view/developer/job/Test_Build_Concurrent/


={============================================================================
*kt_dev_uv_stack_000* zinc-build: zb-make

<ET>
Many of these tools rely on the environment variable "ET" to find your checkout
of the DEVARCH repo. The zb-make and zb-build-with-progress tools build the
stack out of your source tree, so you can carry on developing while a build is
running. You control this behaviour with the "ZB_BUILD_DIR" environment
variable, so make sure it exists and is writeable by yourself. Similarly, you'll
probably want the tools available in your PATH, so add these to your ~/.profile:

export PATH=~/sources/zinc-git-tools:$PATH
export ET=~/sources/DEVARCH/

<after-zb-shell>
$ env | grep ^Z
ZINC_USER_BUILD_TYPE=release ~
ZINC_HOST_PREFIX=/opt/zinc-trunk
ZINC_REMOTE_LOGGING_HOST=localhost
ZINC_SRC_ROOT=/data/builds/master/huawei.370/DEVARCH
ZINC_HOST_3PS=/data/builds/master/huawei.370/DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack
ZINC_BUILD_ROOT=/data/builds/master/huawei.370/zinc-build-root 
ZINC_DESTDIR=/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409 ~
ZINC_BUILD_DIR=/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409 ~
ZINC_NATIVE_BUILD_ROOT=/data/builds/master/huawei.370/zinc-build-root
ZB_HOST_CONFIG=huawei-bcm7409
ZINC_BUILD_CFG=debian-7-x86_64
ZINC_INSTALL_ROOT=/data/builds/master/huawei.370/zinc-install-root
ZB_CFG=huawei.370 ~
ZB_BUILD_DIR=/data/builds   note: from .git/config
ZB_BRANCH=master ~
ZINC_USER_HOST_PREFIX=/opt/zinc-trunk
ZINC_HOST_CFG=huawei-bcm7409
ZINC_3PS_HOST_PREFIX=/opt/zinc-trunk/oss
ZINC_REMOTE_LOGGING_PORT=4560
ZINC_BUILD_TYPE=release


<build-root>

note: the build system picks up any dirs in the tree and try to build those.

note: source is copied to /data/builds/.../DEVARCH
1. ~/source/DEVARCH

2. The build root has only output files such as o and a:
can run make here:

/data/builds/<ZB_BRANCH> /huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/
   Polonium.NexusInspect/Makefile
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/
   Polonium.NexusInspect/Makefile

3. But the makefile uses sources from the copied sources as

/data/builds/<ZB_BRANCH> /huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c
/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c

-c -o nexus_inspect-nexus-inspect.o `test -f 'src/nexus-inspect.c' || echo
'/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/'`src/nexus-inspect.c


<install-root>
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/
`-- zinc-trunk
    |-- bin
    |-- devel
    |-- include
    |-- lib
    |-- libexec
    |-- oss
    |-- platform
    |-- share
    |-- tests
    `-- var

/bin/
airlauncher.sh*
audiofeedbackd*
avahi-launcher*
babysitterd*
cadmiumcontentacquisitiond*
cobaltmetadatabrokerd*
copperannouncementd*
CopperDownloader*
copperlocalstoragerepod*
crbd*
dbusredirect*
dbussenddaemon*
...
yv-remote-booking-agent-activate*
yv-remote-booking-agent-watcher*
yv-start-services.sh*


<zb-virtual-slave>
zb-virtual-slave zb-make
{
  /source/zinc-git-tools/zb/zb-load-config.sh
  {
      pre: ET, ZB_CFG 

      configure_git_for_zb() {

      conf zb.huawei.360.host-config huawei-dn360t
      conf zb.huawei.370.host-config huawei-bcm7409
      conf zb.huawei.372.host-config huawei-bcm7231
      conf zb.humax.1000.host-config humax-dtr_t1000
      }

      // [zb] ZB_BUILD_DIR
      // build-dir = /data/builds
      // git config zb.build-dir /home/kpark/builds

      do : set ZB_BUILD_DIR, slave_dir=/data/builds/master/pc

      export ZB_HOST_CONFIG=$(get_conf host-config "host")
  }

   real_path="${ZB_BUILD_DIR}/$branch"
   virtual_path="${ZB_BUILD_DIR}/_virtual_"

  + real_path=/data/builds/<BRANCH>
  + virtual_path=/data/builds/_virtual_

  note: "bash -c string" execute string on the given shell.

  note: when change ET using exports, this will not be passed subshell below.

   echo "===================> \"ET=$ET ${program_to_run}\"" 
   exec map-dir-and-exec \
      "${real_path}:${virtual_path}" "ET=$ET ${program_to_run}" "$@"

  + exec map-dir-and-exec /data/builds/master:/data/builds/_virtual_ /bin/bash -c '"zb-make"  		
  2> >( sed -u "s|/data/builds/_virtual_|/data/builds/master|" >&2 ) \
  | sed -u "s|/data/builds/_virtual_|/data/builds/master|"'
}


<zb-make-sh>
{

  + source /home/kpark/source/zinc-git-tools/zb/zb-load-config.sh
  {
    note: pick up brach name or force it

    # Branch of git repository for which build is to be performed
    if [ -n "${ZB_FORCE_BRANCH}" ]; then
        echo "Overriding branch to build to: ${ZB_FORCE_BRANCH}"
        branch=$ZB_FORCE_BRANCH
        # TODO: Validate that the branch exists.
    else
        if [ -f "$ET/.git/rebase-merge/head-name" ]; then
            # We are in the middle of rebasing
            branch="$(cut -b 12- < "$ET/.git/rebase-merge/head-name")"
        else
            branch=$(GIT_DIR=$ET/.git git symbolic-ref HEAD | cut -b 12- )
        fi
    fi

    note: this is why ZB_FORCE_BRANCH is used

    # Warn the user if they're in a shell already but the branch has
    # changed. This avoids accidentally rebuilding potentially all of
    # the stack when changing branches.
    if [[ -n "${ZB_BRANCH}" && "${ZB_BRANCH}" != "$branch" ]]; then
        warn "You have appeared to change branches in this shell from '$ZB_BRANCH' to '$branch'."
        warn "Continuing may overwrite the build slave for branch '$branch' (oh noes!)."
        prompt "Do you want to continue" || exit
    fi


    ++++ GIT_DIR=/home/kpark/source/DEVARCH//.git
    ++++ git config zb.huawei.install-prefix
    +++ var=/opt/zinc-trunk
    ++ ZINC_USER_HOST_PREFIX=/opt/zinc-trunk

    export ZB_BRANCH=$branch
    ++ ZB_BRANCH=DEVARCH-8092

    note: slave_dir is set

    # Allow slave_dir to evaluate dynamically, so it used latest values
    # of variables (some of them can be set by later scripts)
    slave_dir () {
      if [ -n "${ZB_SLAVE_DIR}" ]; then
          # eg. running under zb-virtual-slave
          echo $ZB_SLAVE_DIR/$ZB_CFG
      else
          echo $ZB_BUILD_DIR/$branch/$ZB_CFG
      fi
    }

    ++ slave_dir=/data/builds/DEVARCH-8092/huawei.370
  }

  cd $ET
  + cd /home/kpark/source/DEVARCH

  ++ git rev-parse HEAD
  + commit_sha=fabf2f275c01fcf68bd8ce212c4e507c46eff45b
  + build_cmd=make


  if [ -n "${ZB_FORCE_BRANCH}" ]; then
      echo "Using overridden branch."
  else
  {

   note: use git and add all tracked but not untracted.

  ++ mktemp /home/kpark/source/DEVARCH/.git/zb-make.XXXXXX
  + TMP_INDEX=/home/kpark/source/DEVARCH/.git/zb-make.yHIM2k

  w_tree=$( (
      cp -p ${GIT_INDEX_FILE-"$GIT_DIR/index"} "$TMP_INDEX" &&
      GIT_INDEX_FILE="$TMP_INDEX" &&
      cd $ET &&
      export GIT_INDEX_FILE &&
      git add -u &&
      git write-tree &&
      rm -f "$TMP_INDEX"
  ) )

  ++ cp -p /home/kpark/source/DEVARCH/.git/index /home/kpark/source/DEVARCH/.git/zb-make.yHIM2k
  ++ GIT_INDEX_FILE=/home/kpark/source/DEVARCH/.git/zb-make.yHIM2k
  ++ cd /home/kpark/source/DEVARCH
  ++ export GIT_INDEX_FILE
  ++ git add -u
  ++ git write-tree
  ++ rm -f /home/kpark/source/DEVARCH/.git/zb-make.yHIM2k
  + w_tree=927a2553cfcc5f738f462d82df5e726363aa142d

  if [[ $(git merge-base $commit_sha "refs/heads/zb/$branch" ) == "$commit_sha" ]]

  + [[ a65d2644c9d647d360b1c04261bcfe90ff8ba1ff == \f\a\b\f\2\f\2\7\5\c\0\1\f\c\f\6\8\b\d\8\c\e\2\1\2\c\4\e\5\0\7\c\4\6\e\f\f\4\5\b ]]
  + b_commit=fabf2f275c01fcf68bd8ce212c4e507c46eff45b


  w_commit=$(printf 'BUILD: ZB_CFG="%s" %s\n' "$ZB_CFG" "$build_cmd $@" |
      git commit-tree $w_tree -p $b_commit) ||
      die "Cannot record working tree state"

  ++ printf 'BUILD: ZB_CFG="%s" %s\n' humax.2100 'make Zinc/Zinc.Common'
  ++ git commit-tree 927a2553cfcc5f738f462d82df5e726363aa142d -p fabf2f275c01fcf68bd8ce212c4e507c46eff45b
  + w_commit=51a0268d701c77dd925a6aea2b2c6ad8a23b8545

  // note:
  // Seems that it make a tree and puts that into a commit
  //
  // commit 51a0268d701c77dd925a6aea2b2c6ad8a23b8545
  // Author: Kit Park <kit.park@youview.com>
  // Date:   Mon Nov 16 14:28:39 2015 +0000
  // 
  //     BUILD: ZB_CFG="humax.2100" make Zinc/Zinc.Common

  git update-ref -m "zb-make" "refs/heads/zb/$branch" "$w_commit" ||
      die "Cannot save the current status"

  + git update-ref -m zb-make refs/heads/zb/master 51a0268d701c77dd925a6aea2b2c6ad8a23b8545
   
  } // end of force branch if


  note: want to new build slave? set "zb/branch" on slave_dir

  # Create repo
  if [ ! -e "$(slave_dir)/DEVARCH/Zinc/Zinc.Build/Makefile" ]; then
      echo "Creating new build slave - 
        $branch because $(slave_dir)/DEVARCH/Zinc/Zinc.Build/Makefile doesn't exist"
      rm -Rf "$(slave_dir)/DEVARCH/"
      mkdir -p "$(slave_dir)/DEVARCH"
      cd "$(slave_dir)"
      git clone -s --branch "zb/$branch" "$ET" "$(slave_dir)/DEVARCH"
  fi


  note: update 'repo'. So make a sink between working and slave repo.

  // <1> when make a change to $(slave_dir), zb-make fails to start:
  //
  // error: refs/remotes/origin/HEAD does not point to a valid object!
  // error: refs/remotes/origin/master does not point to a valid object!
  // error: refs/remotes/origin/HEAD does not point to a valid object!
  // error: refs/remotes/origin/master does not point to a valid object!
  // From /home/kpark/source/DEVARCH
  //  * branch            zb/master  -> FETCH_HEAD
  // error: refs/remotes/origin/HEAD does not point to a valid object!
  // error: refs/remotes/origin/master does not point to a valid object!
  //  + 767650f...51a0268 zb/master  -> origin/zb/master  (forced update)
  // + git update-index --refresh
  // Zinc/Zinc.Common/src/Makefile.am: needs update   note: message from update

  + cd /home/kpark/builds/_virtual_/humax.2100/DEVARCH
  + git fetch origin zb/master

  note: see use of $branch

  cd "$(slave_dir)/DEVARCH"
  git fetch origin "zb/$branch"

  # Sometimes the build system (or something) will touch autogen.sh in various
  # directories not making any changes to the contents but changing the mtime.
  # When we did git reset git would see this and overwrite autogen.sh changing
  # the mtime once again which would in turn confuse the build system.  Calling
  # git update-index --refresh fixes these issues
  git update-index --refresh
  git reset --hard $w_commit

  + git update-index --refresh
  + git reset --hard a56085c23d123f5e5293f23f664a792a29c175bb

  # Build
  cd "$(slave_dir)/DEVARCH/Zinc/Zinc.Build"
   note: one time and can clone again by deleting a makefile?

   build_cmd=${ZB_BUILD_CMD-"make"}
   + build_cmd=make


  <starts-build>
  note: build build tool for host or not.
  + cd /home/kpark/builds/_virtual_/humax.2100/DEVARCH/Zinc/Zinc.Build
  + '[' humax-dtr_t2100 '!=' host ']'
  + '[' '' '!=' 1 ']'
  + echo '========================================= BUILDING BUILD TOOLS!!!!'
  + unset ZINC_USER_HOST_PREFIX

  + source ./setvars-host.sh

  'OR'

  source ../../*/*/setvars-$ZB_HOST_CONFIG.sh

  <build>
  note: back to zb-make
  + build_date='2015-01-09 08:58:17+00:00'
  (
    # Create an environment more like the build servers
    unset DBUS_SESSION_BUS_ADDRESS

    set -o pipefail
    $build_cmd "$@" 2> >( sed -u "s | $ZINC_SRC_ROOT | $ET|" >&2 ) \
    | sed -u "s| $ZINC_SRC_ROOT| $ET|"
  ) && exit_code=0 || exit_code=1 # Don't want to exit on failure

  + unset DBUS_SESSION_BUS_ADDRESS
  + set -o pipefai

  + make buildtools
  + make
  + sed -u 's|/data/builds/master/pc/DEVARCH|/home/kpark/source/DEVARCH|'
   sed -u "s|$ZINC_SRC_ROOT|$ET|" >&2 
  ++ sed -u 's|/data/builds/master/pc/DEVARCH|/home/kpark/source/DEVARCH|'
}


={============================================================================
*kt_dev_uv_stack_000* zinc-build: zb-build-with-progress

ZB_BUILD_CMD=./build-with-progress.sh zb-make "$@"

./Zinc/Zinc.Build/build-with-progress.sh

  -i                            enable incremental building. 


={============================================================================
*kt_dev_uv_stack_001* zinc-build: makefile

Zinc/Zinc.Build/project-deps-rules.mk

# Use the list-buildable-projects.sh to work out which project folders under the
# source root should be considered for building. 
# 
# "autozinc" packages are normal projects in the Zinc source tree that are built
# using autotools.  This doesn't include the "special" Zinc.3rdPartyStack
# project, which is actually a GNU make project itself that builds many other
# projects.

AUTOZINC_PACKAGES:=$(shell $(DEVELOPER_MAKEFILE_DIR)/list-buildable-projects.sh -e
$(DEVELOPER_MAKEFILE_DIR)/excluded-elements.txt -p $(DEVELOPER_MAKEFILE_DIR)/excluded-projects.txt
${ZINC_SRC_ROOT}) $(foreach proj,$(AUTOZINC_PACKAGES),$(eval project-makefile-$(proj) =
      $(DEVELOPER_MAKEFILE_DIR)project-makefile-autozinc.mk))


// from "build-with-progress.sh"
# Force the make to do a dry-run so we can work out how many projects need to be built.
let projects_to_build=$(ZINC_DRY_RUN=1 BASH=${BASH} make -n -f ${makefile} ${target_name} | grep
        "+++ Building " | wc -l)

$ zb-make listprojects

$ zb-make list-targets | ag Polo

Polonium.PCMPlayback-distcheck
Polonium.GSTNexus-check
Polonium.NexusInspect.deprecated-check
Polonium.NexusInspect.deprecated
Polonium.GSTTSPacer-distcheck
Polonium.GSTNexus-distcheck
Polonium.PCMPlayback-clean
Polonium.NexusInspect.deprecated-distcheck
Polonium.GSTTSPacer
Polonium.PCMPlayback-install
Polonium.GSTTSPacer-install
Polonium.PCMPlayback-check
Polonium.GSTNexus
Polonium.GSTNexus-install
Polonium.NexusInspect.deprecated-install
Polonium.GSTTSPacer-clean
Polonium.GSTNexus-clean
Polonium.NexusInspect.deprecated-clean
Polonium.PCMPlayback
Polonium.GSTTSPacer-check


<main-makefile>
make[1]: Entering directory `/home/kpark/source/DEVARCH/Zinc/Zinc.Build'
make[1]: Leaving directory `/home/kpark/source/DEVARCH/Zinc/Zinc.Build'

+++ Source: /home/kpark/source/DEVARCH/ +++
+++ Host build dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409 +++
+++ Build log dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/logs +++
+++ Install location: /data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk +++
+++ release build +++
+++ Building Zinc/Zinc.3rdPartyStack +++

[gmock] libtool: link: (cd "lib/.libs" && rm -f "libgtest_main.so.0" && ln -s "libgtest_main.so.0.0.0" "libgtest_main.so.0")

note: for vanadium

+++ Building Vanadium/Vanadium.Common +++
run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-BigData.xml
doc/htmlfragments/interface-BigData.html
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/doc-interface.html.template

run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-AnotherInterface.xml
doc/htmlfragments/interface-AnotherInterface.html
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/doc-interface.html.template

make[1]: Entering directory `/home/kpark/source/DEVARCH//Zinc/Zinc.Build'

Generating configure files... may take a while.

Found new dependencies; recursively calling docmakedepend.
$*='/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-Farm.xml';
         $dependents_list='/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/enum-Animal.xml'

mv -f .deps/Profiler.Tpo .deps/Profiler.Plo

Found new dependencies; recursively calling docmakedepend.
$*='/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-ChannelService.xml';
         $dependents_list='/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/struct-BroadcastData.xml
             /data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/struct-ChannelData.xml'


+++ Building Vanadium/Vanadium.Client.API +++

make[1]: Entering directory `/home/kpark/source/DEVARCH//Zinc/Zinc.Build'
make[2]: Leaving directory `/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Lead/Lead.System.API'
Generating configure files... may take a while.
make[2]: Entering directory `/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Lead/Lead.System.API'
/bin/mkdir -p include src
/bin/mkdir -p include/mock
/bin/mkdir -p mock-python

run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-AnotherInterface.xml
src/AnotherInterface.cpp
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/base.cpp.template 

mv -f .deps/acl-utils-test.Tpo .deps/acl-utils-test.Po
rm -rf /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Vanadium/Vanadium.Client.API


note: to search, use "Building\|NexusInspect" since logs are intermixed.


+++ Building Polonium/Polonium.NexusInspect +++

mkdir -p
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect

cd /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect
&& /home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect/configure
--prefix=/opt/zinc-trunk --build=x86_64-pc-linux-gnu --host=mipsel-linux
--enable-shared --disable-static

make -C
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect

cd /home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect && /bin/bash
/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/missing
--run automake-1.11 --foreign

make[2]: Entering directory
`/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect'

mipsel-linux-gcc -DPACKAGE_NAME=\"nexus-inspect\"
-DPACKAGE_TARNAME=\"nexus-inspect\" -DPACKAGE_VERSION=\"0.1\"
-DPACKAGE_STRING=\"nexus-inspect\ 0.1\"
-DPACKAGE_BUGREPORT=\"darren.garvey@youview.com\"
-DPACKAGE_URL=\"http://www.youview.com\" -DPACKAGE=\"nexus-inspect\"
-DVERSION=\"0.1\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1
-DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1
-DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1
-DLT_OBJDIR=\".libs/\" -I.
-I/home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect
-I/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/include
-isystem
/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/include
-I/opt/oem-staging/huawei-bcm7409/usr/include
-I/opt/oem-staging/huawei-bcm7409/usr/local/include  -D_GNU_SOURCE=1  -fPIC
-fvisibility=hidden -DVERSION=\"0.1\" -DPACKAGE=\"nexus-inspect\"
-DPKG_BIN_DIR=\"/opt/zinc-trunk/bin\" -O3 -g -Wall -Wextra -std=c99
-Werror=implicit-function-declaration -D_REENTRANT -pthread -DNEXUS_MODE_proxy
-DPLATFORM=97409 -DNEXUS_PLATFORM=97409 -DLINUX -D_GNU_SOURCE=1 -DHAVE_RSRVD=1
-DKBUILD_MODNAME=nexus -DPLATFORM=97409 -DNEXUS_PLATFORM=97409
-DBCHP_CHIP=7420 -DBCHP_VER=BCHP_VER_C1 -DBSTD_CPU_ENDIAN=BSTD_ENDIAN_LITTLE
-DBINT_REENTRANT_CONFIG=BINT_REENTRANT -DBMEM_REENTRANT_CONFIG=BMEM_REENTRANT
-DNEXUS_BASE_OS_linuxkernel=1 -DNEXUS_PROFILE_OS_linuxkernel
-DNEXUS_MODE_driver -DNEXUS_PLATFORM_7410_UMA_32b=1 -DNEXUS_IPLICENSING=1
-DNEXUS_OTPMSP=1 -DNEXUS_USERCMD=1 -DNEXUS_HAS_KEYLADDER_SUPPORT=1
-DNEXUS_KEYLADDER=1 -DNEXUS_SECUREACCESS=1 -DNEXUS_SECURERSA=1
-DNEXUS_SECURITY_EXT_KEY_IV -DNEXUS_SECURITY_SC_VALUE -DNEXUS_FRONTEND_NIM
-DNEXUS_AC3 -DNEXUS_CONFIG_IMAGE -DNEXUS_DDP -DNEXUS_HAS_PLATFORM
-DNEXUS_HAS_CORE -DNEXUS_HAS_BASE -DNEXUS_HAS_I2C -DNEXUS_HAS_GPIO
-DNEXUS_HAS_PWM -DNEXUS_HAS_LED -DNEXUS_HAS_IR_INPUT -DNEXUS_HAS_IR_BLASTER
-DNEXUS_HAS_KEYPAD -DNEXUS_HAS_INPUT_CAPTURE -DNEXUS_HAS_UHF_INPUT
-DNEXUS_HAS_RFM -DNEXUS_HAS_FRONTEND -DNEXUS_HAS_SPI -DNEXUS_HAS_SECURITY
-DNEXUS_HAS_DMA -DNEXUS_HAS_TRANSPORT -DNEXUS_HAS_VIDEO_DECODER
-DNEXUS_HAS_AUDIO -DNEXUS_HAS_SURFACE -DNEXUS_HAS_GRAPHICS2D
-DNEXUS_HAS_PLAYBACK -DNEXUS_HAS_DISPLAY -DNEXUS_HAS_ASTM
-DNEXUS_HAS_SYNC_CHANNEL -DNEXUS_HAS_HDMI_OUTPUT -DNEXUS_HAS_SMARTCARD
-DNEXUS_HAS_SIMPLE_DECODER -DNEXUS_HAS_EEPROM -DNEXUS_HAS_SCART
-DBADS_312X_VER=BCHP_VER_A0 -DBHAB_312X_VER=BCHP_VER_A0 -DBHDM_CEC_SUPPORT
-DBHSM_AEGIS_SUPPORT -DBHSM_SC_VALUE -DBHSM_SECURE_PI_SUPPORT=1
-DBHSM_SECURE_PI_SUPPORT_KEYLADDER=1 -DBHSM_SECURE_PI_SUPPORT_MISC=0
-DBHSM_SECURE_PI_SUPPORT_OTPMSP=1 -DBSP_GENERIC -DBXVD_USE_CUSTOM_IMAGE
-DB_HAS_AVI=1 -DB_HAS_RMFF=1 -DGRCPACKET_SUPPORT=1
-DRAP_AACSBR_PASSTHRU_SUPPORT -DRAP_AACSBR_SUPPORT -DRAP_AC3ENC_SUPPORT
-DRAP_AC3_PASSTHRU_SUPPORT -DRAP_AC3_SUPPORT -DRAP_DDP_PASSTHRU_SUPPORT
-DRAP_DDP_SUPPORT -DRAP_DDP_TO_AC3_SUPPORT -DRAP_DRA_PASSTHRU_SUPPORT
-DRAP_DSOLA_SUPPORT -DRAP_DTSBROADCAST_PASSTHRU_SUPPORT
-DRAP_DTSHD_PASSTHRU_SUPPORT -DRAP_LPCMDVD_SUPPORT -DRAP_MPEG_PASSTHRU_SUPPORT
-DRAP_MPEG_SUPPORT -DRAP_PCMWAV_SUPPORT -DRAP_PCM_SUPPORT
-DRAP_REALAUDIOLBR_PASSTHRU_SUPPORT -DRAP_SRC_SUPPORT -DUNIFIED_ITB_SUPPORT
-DDUAL_OUTPUT
-DNDEBUG -O2 -pipe  -MT nexus_inspect-nexus-inspect.o -MD -MP -MF
.deps/nexus_inspect-nexus-inspect.Tpo -c -o nexus_inspect-nexus-inspect.o
`test -f 'src/nexus-inspect.c' || echo
'/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/'`src/nexus-inspect.c


<build-root-install-root>
When install root updated?

:+++ ZINC_INSTALL_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root
:+++ export ZINC_SRC_ROOT ZINC_BUILD_ROOT ZINC_INSTALL_ROOT

Used in build and link:

-DINSTALLDIR="/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib" 

note: installed into by libtool

+ INSTALL='/usr/bin/install -C'

libtool: install: /usr/bin/install -C nexus-inspect
/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/devel/bin/nexus-inspect


<install-root-not-updated>
$ find /data/builds/_virtual_/huawei.370/zinc-build-root/ -name nexus-inspect | xargs ls -al
-rwxrwxr-x 1 kpark kpark 12213 Apr  7 15:00
/data/builds/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect/nexus-inspect

$ find /data/builds/_virtual_/huawei.370/zinc-install-root/ -name nexus-inspect | xargs ls -al
-rwxr-xr-x 1 kpark kpark  7846 Apr  7 14:13
/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin/nexus-inspect

-rwxr-xr-x 1 kpark kpark 12213 Apr  7 14:16
/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/devel/bin/nexus-inspect

note: the build will not refresh opt/zinc-trunk/ and simply overwrite over time. Here
/bin/nexus-inspect was there and the build updates /devel/bin/nexus-inspect only. This caused
confusion and ended up running /bin/ version.


={============================================================================
*kt_dev_uv_stack_001* zinc-build: build commands and build vars

<ex>
cd =~/sources/DEVARCH/
ZB_CFG="huawei.370" zb-make Polonium/Polonium.NexusInspect
ZB_CFG="huawei.370" zb-make
ZB_CFG=humax.1000 zb-make

<to-pass-make-option>
# -n dry run
zb-make Polonium.NexusInspect -n

<zb-force-branch>
Do not use current branch but use the specified one instead.

ZB_FORCE_BRANCH="xxx" ZB_CFG="huawei.370" zb-make Polonium/Polonium.NexusInspect


<to-check-env> check if env is configured properly or do compile manually
cd ~/source/DEVARCH/
ZB_CFG=huawei.370 zb-shell

mipsel-linux-gcc 
mipsel-linux-g++ 

For huwawei as of 04.02

mipsel-linux-g++ (Broadcom stbgcc-4.4.5-2.0) 4.4.5
Copyright (C) 2010 Free Software Foundation, Inc.


<three>
$ cd ~/sources/
ZB_CFG=huawei.370 zb-shell
zb-make Polonium/Polonium.NexusInspect       note: shall not be "../Polonium.NexusInspect/"

OR

ZB_CFG=huawei.370 zb-virtual-slave zb-shell
zb-make

zb-virtual-slave zb-build-with-progress


<to-set-build-target>
note: can specify make build target

ZINC_SILENT_RULES=1 zb-virtual-slave zb-build-with-progress Zinc.AIR.CTV.Tests-install


<zinc-slient-rules>
ZINC_SILENT_RULES=1 zb-virtual-slave zb-build-with-progress Zinc.AIR.CTV.Tests

DEVARCH/Zinc/Zinc.Build/setvars-common.sh

392-# Automake "silent-rules" can be turned on to reduce the amount of repetitive
393-# information printed when building. Warnings and errors are all still printed
394-# so using silent-rules by default is safe.
395:if [[ "${ZINC_SILENT_RULES}" == 1 ]]; then
396-    export MAKEFLAGS="$MAKEFLAGS V=0"
397-fi


<zinc-incremental>
ZINC_INCREMENTAL

DEVARCH/Zinc/Zinc.Build/Makefile

130-$(patsubst %,$(ZINC_BUILD_DIR)/%buildtools.built,$(PACKAGES) $(zinc3ps) $(zinc_bash_test)) : $(ZINC_BUILD_DIR)/%buildtools.built :
131- $(info +++ Building $* +++)
132-ifeq (${ZINC_DRY_RUN},)  
133:ifeq (${ZINC_INCREMENTAL},)
134- -rm -rf $(HOST_BUILD_DIR)/$*
135:endif # ! ZINC_INCREMENTAL


<zinc-skip-tests>
ZINC_SKIP_TESTS

DEVARCH/Zinc/Zinc.Build/Makefile
37-envtest:=$(and ${ZINC_HOST_CFG},${ZINC_HOST_3PS},${ZINC_HOST_PREFIX},${ZINC_SRC_ROOT},${ZINC_BUILD_ROOT},${PKG_CONFIG},${PKG_CONFIG_PATH},${LDFLAGS},${CPPFLAGS},${ZINC_BUILD_DIR},${BUILD_TRIPLE})
38-
39-DO_CHECK_FLAGS=
40-
41:# Set ZINC_SKIP_TESTS to skip running of the "make check"
42:ifeq (${ZINC_SKIP_TESTS},)


<use-autoconf> to run makefile on built-root or build nexusMgr
git clone -b huawei/dn370t gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git nexusTest

cd nexusMgr

note: use BRANCH
export ET=/data/builds/master/huawei.370/DEVARCH/
export ET=/data/builds/<BRANCH>/huawei.370/DEVARCH/

ZINC_USER_BUILD_TYPE=release source $ET/OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

./autogen.sh

export HOST_TRIPLE=mipsel-linux

./configure --host=$HOST_TRIPLE --with-pic --enable-shared --prefix=$PWD/install

make && make install

make clean; make;
can see output and o file under this.

/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusRelease

But uses sources from: note: DEVARCH

`test -f 'src/exec-then-cleanup-app.c' || echo
'/data/builds/master/huawei.370/DEVARCH/Polonium/Polonium.NexusRelease/'`src/exec-then-cleanup-app.c


<build-log>
'only' when use build-with-progress

/data/builds/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/logs/Polonium/Polonium.NexusInspect.log

ag 'error:'
/data/builds/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/logs/Polonium/Polonium.NexusInspect.log


={============================================================================
*kt_dev_uv_stack_003* zinc-build: debug or release

note: ZINC_BUILD_TYPE this comes from git.config


// from setvars-common.sh

# CXXFLAGS
#
# Check to see if we are building in debug mode
# ( -pipe causes gcc to use pipes instead of temp files to communicate between stages
# e.g. between compile and assemble. This is for speed).
#
if [[ "${ZINC_BUILD_TYPE}" == "debug" ]]
then
	export CXXFLAGS="-g -O0 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
	export CFLAGS="-g -O0 -pipe ${EXTRA_CFLAGS:-}"
else
	export CXXFLAGS="-DNDEBUG -O3 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
	export CFLAGS="-DNDEBUG -O2 -pipe ${EXTRA_CFLAGS:-}"
fi


The thing was that it uses -g option even if it's release build but other's do
not. This makes me confused.

Polonium/Polonium.GSTNexus/Makefile.am

AM_CFLAGS = \
	-fPIC \
	-DGST_USE_UNSTABLE_API \
	-DVERSION=\"@PACKAGE_VERSION@\" \
	-DPACKAGE=\"@PACKAGE_NAME@\" \
	-DDUAL_OUTPUT \
	-O3 -g -Wall -Wextra -std=c99 -Werror=implicit-function-declaration \
	-D_REENTRANT \
	-pthread \
	@NEXUS_CFLAGS@ \
	@DIRECTFB_CFLAGS@ \
	@GSTREAMER_CFLAGS@


={============================================================================
*kt_dev_uv_stack_003* zinc-build: autotool structures

<ex> Zinc.Common example

// source

~/src-dev/DEVARCH/Zinc/Zinc.Common$

kpark   295 Apr 28  2015 autogen.sh*
kpark  3720 Sep 23 13:45 configure.ac
kpark  1168 Apr 28  2015 Makefile.am*

~/src-dev/DEVARCH/Zinc/Zinc.Common/src$

-rwxr-xr-x  1 kpark kpark  1168 Apr 28  2015 Makefile.am*


// source in builds

~/builds-src-dev/master/huawei.370/DEVARCH/Zinc/Zinc.Common$

kpark 352646 Nov 11 17:39 aclocal.m4
kpark    295 Nov 11 16:05 autogen.sh*
kpark  44941 Nov 11 17:39 config.guess*
kpark   1692 Nov 11 17:39 config.h.in
kpark  34423 Nov 11 17:39 config.sub*
kpark 606802 Nov 11 17:39 configure*    note:
kpark   3720 Nov 11 16:05 configure.ac
kpark  13663 Nov 11 17:39 install-sh*
kpark 283766 Nov 11 17:39 ltmain.sh     note: is for libtool
kpark   1168 Nov 11 16:05 Makefile.am*
kpark  30466 Nov 11 17:40 Makefile.in   note:
kpark  11419 Nov 11 17:39 missing*

~/builds-src-dev/master/huawei.370/DEVARCH/Zinc/Zinc.Common/src$

kpark   1168 Nov 11 16:05 Makefile.am*
kpark  30466 Nov 11 17:40 Makefile.in   note:


// build root in build

~/builds-src-dev/master/huawei.370/zinc-build-root/release-huawei-bcm7409/Zinc/Zinc.Common$

kpark   1909 Nov 12 10:10 config.h
kpark  64980 Nov 12 10:10 config.log
kpark  86090 Nov 12 10:10 config.status*
kpark  37256 Nov 12 10:10 Makefile

~/builds-src-dev/master/huawei.370/DEVARCH/Zinc/Zinc.Common/src$

kpark  37256 Nov 12 10:10 Makefile

note: Can see libtool variables in config.log, config.status, and Makefiles


// config.log

~/builds-src-dev/master/huawei.370/zinc-build-root/release-huawei-bcm7409/
  Zinc/Zinc.Common$ ag FLAGS config.log | ag LD 

642:ac_cv_env_LDFLAGS_set=set
643:ac_cv_env_LDFLAGS_value='-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -Wl,--as-needed -Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/lib  -L/opt/oem-staging/huawei-bcm7409/usr/local/lib  -L/opt/oem-staging/huawei-bcm7409/usr/local/lib -Wl,-rpath-link,/opt/oem-staging/huawei-bcm7409/usr/local/lib'

834:LDFLAGS='-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -Wl,--as-needed -Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/lib  -L/opt/oem-staging/huawei-bcm7409/usr/local/lib  -L/opt/oem-staging/huawei-bcm7409/usr/local/lib -Wl,-rpath-link,/opt/oem-staging/huawei-bcm7409/usr/local/lib'


// Makefile
~/builds-src-dev/master/huawei.370/DEVARCH/Zinc/Zinc.Common/src$

note: still use variables

LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
	$(AM_LDFLAGS) $(LDFLAGS) -o $@


// From build log

cd /home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/Zinc/Zinc.Common && 
/home/kpark/src-dev/DEVARCH/Zinc/Zinc.Common/configure --prefix=/opt/zinc-trunk --build=x86_64-pc-linux-gnu --host=mipsel-linux --enable-shared --disable-static


// To run config from zb-shell. note: see run under temp directory "x"

~/builds-src-dev/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/Zinc/Zinc.Common/x
$ /home/kpark/builds-src-dev/_virtual_/huawei.370/DEVARCH/Zinc/Zinc.Common/configure -v --prefix=/opt/zinc-trunk --build=x86_64-pc-linux-gnu --host=mipsel-linux --enable-shared --disable-static

// where LDFLAGS comes from

~/builds-src-dev/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/Zinc/Zinc.Common/x
$ env | ag LDF
LDFLAGS=-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -Wl,--as-needed -Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/lib  -L/opt/oem-staging/huawei-bcm7409/usr/local/lib  -L/opt/oem-staging/huawei-bcm7409/usr/local/lib -Wl,-rpath-link,/opt/oem-staging/huawei-bcm7409/usr/local/lib


// note: this is how LDFLAGS differs from libtool log in build log
// from libtool script

# Commands used to build a shared archive. note: at the end of file
archive_cmds="echo KT \$CC : 
\$pic_flag -shared -nostdlib : 
\$predep_objects : 
\$libobjs : 
\$deplibs :  note:
\$postdep_objects : 
\$compiler_flags : 
\${wl}-soname : 
\$wl\$soname -o \$lib"

KT mipsel-linux-g++ : 
-fPIC -DPIC -shared -nostdlib : 

/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../mipsel-linux-uclibc/sys-root/usr/lib/crti.o /opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5/crtbeginS.o : 

.libs/BindingRegistry.o .libs/AbstractPluginConfig.o .libs/FilePluginConfig.o .libs/FixedPluginConfig.o .libs/PluginReference.o .libs/PluginFactory.o .libs/Plugin.o .libs/DispatchingEventProducer.o .libs/Utilities.o .libs/CancellableFunctor.o .libs/DateTimeUtilities.o .libs/ScopedEnvironmentVariable.o .libs/ProcessCleanup.o .libs/ActionProcessor.o .libs/Enum.o .libs/EventListener.o .libs/Logger.o .libs/LaunchManager.o .libs/SignalCollector.o .libs/MemoryUsage.o .libs/OpaqueData.o .libs/PathList.o .libs/Polymorphic.o .libs/Resettable.o .libs/WorkerFunction.o .libs/SingleThreadDispatcher.o .libs/PolledDispatcher.o .libs/InlineDispatcher.o .libs/FutureContext.o .libs/FutureContextBase.o .libs/ChunkedFutureContextBase.o .libs/Exceptions.o .libs/async-helpers.o .libs/Daemon.o .libs/Error.o .libs/ExceptionConverter.o .libs/ExtendedTypeidRegistrar.o .libs/ResourceFinder.o .libs/getMutableDataPath.o .libs/SingletonDataFinderLocator.o .libs/SingletonLibFinderLocator.o .libs/SingletonBinFinderLocator.o .libs/SingletonPythonFinderLocator.o .libs/ResourceSearchPathGetters.o .libs/Pager.o .libs/Page.o .libs/Profiler.o .libs/ProfileTimer.o .libs/ProfilerManager.o .libs/FileProfileBuffer.o .libs/NamedTimer.o .libs/ScopedTimer.o .libs/MappedFile.o .libs/Unzipper.o .libs/UnzipperFactory.o .libs/Any.o .libs/Variant.o .libs/Bitmap.o : 

-Wl,-rpath -Wl,/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5/../../../../mipsel-linux-uclibc/lib -Wl,-rpath -Wl,/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5/../../../../mipsel-linux-uclibc/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib 

-Wl,--as-needed 

-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/lib -L/opt/oem-staging/huawei-bcm7409/usr/local/lib -lboost_filesystem -lboost_system -lboost_chrono -lboost_thread -llog4cplus -lz_minizip -lz 

-lsqlite3 

-lc-modern -ldl -lrt -L/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5 -L/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc -L/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5/../../../../mipsel-linux-uclibc/lib -L/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../mipsel-linux-uclibc/sys-root/lib -L/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../mipsel-linux-uclibc/sys-root/usr/lib /opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5/../../../../mipsel-linux-uclibc/lib/libstdc++.so -lm -lpthread -lc -lgcc_s : 

/opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../lib/gcc/mipsel-linux-uclibc/4.4.5/crtendS.o /opt/toolchains/generic-stbgcc-4.4.5-2.0/bin/../mipsel-linux-uclibc/sys-root/usr/lib/crtn.o : 

-O3 -pthread -Wl,-rpath-link -Wl,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -Wl,-rpath-link -Wl,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib -Wl,-rpath-link -Wl,/opt/oem-staging/huawei-bcm7409/usr/local/lib -pthread : 

-Wl,-soname : 

-Wl,libZincCommon.so.0 -o .libs/libZincCommon.so.0.0.0


={============================================================================
*kt_dev_uv_stack_003* zinc-build: 3party stack

Zinc/Zinc.3rdPartyStack/Makefile


={============================================================================
*kt_dev_uv_stack_003* zinc-build: exclude files

Zinc/Zinc.Build/excluded-files-production.txt


={============================================================================
*kt_dev_uv_stack_003* zinc-build: zb-shell, setvar-common

{
   <load-config>
   source $(scriptDir)/zb/zb-load-config.sh
   + source /home/kpark/source/zinc-git-tools/zb/zb-load-config.sh

   <setvars-sh>
   source ${slave_dir}/DEVARCH/*/*/setvars-${ZB_HOST_CONFIG}.sh
   + source /DEVARCH/OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh
   {
    ++ export ZINC_HOST_CFG=huawei-bcm7409
    ++ ZINC_HOST_CFG=huawei-bcm7409
    ++ ZINC_HOST_3PS=/DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack
    ++ ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect.deprecated
    ++ ARCH=mipsel
    ++ HOST_TRIPLE=mipsel-linux
    ++ TOOLSROOT=/opt/toolchains/huawei-bcm7409
    ++ OEM_STAGING_ROOT=/opt/oem-staging/huawei-bcm7409
    ++ CROSS_COMPILE=mipsel-linux-
    ++ INC_LIB_ROOT=/opt/toolchains/huawei-bcm7409
    ++ PKG_CONFIG_PATH=
    /opt/oem-staging/huawei-bcm7409/usr/local/lib/pkgconfig:
    /opt/oem-staging/huawei-bcm7409/usr/lib/pkgconfig

     <setvars-common> <LDFLAGS>
     . "$(dirname "${BASH_SOURCE}")/../../Zinc/Zinc.Build/setvars-common.sh"
     ++ . /DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack/../../Zinc/Zinc.Build/setvars-common.sh
     +++ where_am_i=/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Zinc/Zinc.Build
     {
        {
        if [[ "${ZINC_HOST_CFG}" != "${ZINC_BUILD_CFG}" ]]
        then
           # Cross compilation

           echo "Cross compiling. Host cfg: '${ZINC_HOST_CFG}' Build cfg: '${ZINC_BUILD_CFG}'"
        }

       # ZINC_BUILD_TYPE note: this comes from git.config
       #
       # This allows selection between 'debug' and 'release' builds.
       # The default is 'debug'. If you want release, 
       # set ZINC_USER_BUILD_TYPE variable prior to sourcing the setvars script.
       
       [[ -n "${ZINC_USER_BUILD_TYPE:-}" ]] \
           && ZINC_BUILD_TYPE="${ZINC_USER_BUILD_TYPE}" || ZINC_BUILD_TYPE="debug"

       ZINC_BUILD_TYPE=release

       note: 'roots'

       ZINC_SRC_ROOT=/_virtual_/huawei.370/DEVARCH
       ZINC_3PS_DIR=Zinc/Zinc.3rdPartyStack
       ZINC_BUILD_ROOT=/_virtual_/huawei.370/zinc-build-root
       ZINC_INSTALL_ROOT=/_virtual_/huawei.370/zinc-install-root
       ZINC_BUILD_DIR=/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409
       ZINC_DESTDIR=/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409
       ZINC_HOST_PREFIX=/opt/zinc-trunk
       ZINC_3PS_HOST_PREFIX=/opt/zinc-trunk/oss

       # CXXFLAGS
       if [[ "${ZINC_BUILD_TYPE}" == "debug" ]]
       then
          export CXXFLAGS="-g -O0 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
          export CFLAGS="-g -O0 -pipe ${EXTRA_CFLAGS:-}"
       else
          export CXXFLAGS="-DNDEBUG -O3 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
          export CFLAGS="-DNDEBUG -O2 -pipe ${EXTRA_CFLAGS:-}"
       fi

       [[ debug == \d\e\b\u\g ]]
       export 'CXXFLAGS=-g -O0 -pipe -pthread '
       CXXFLAGS='-g -O0 -pipe -pthread '
       export 'CFLAGS=-g -O0 -pipe '
       CFLAGS='-g -O0 -pipe '

       +++ PKG_CONFIG=/data/builds/master/pc/zinc-install-root/debug/debian-7-x86_64/oss/bin/pkg-config

       # N.B. We are setting -rpath-link here, but DO NOT use this to set -rpath.
       # We should leave libtool to deal with -rpath. Setting it here leads to test executables
       # linking against the old (already installed) libraries.
       
       LDFLAGS="-L${ZINC_DESTDIR}${ZINC_HOST_PREFIX}/lib
       -L${ZINC_DESTDIR}${ZINC_3PS_HOST_PREFIX}/lib -Wl,--as-needed
       -Wl,-rpath-link,${ZINC_DESTDIR}${ZINC_HOST_PREFIX}/lib
       -Wl,-rpath-link,${ZINC_DESTDIR}${ZINC_3PS_HOST_PREFIX}/lib"

       LDFLAGS='-L/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
       -L/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
       -Wl,--as-needed
       -Wl,-rpath-link,/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
       -Wl,-rpath-link,/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib'

       LDFLAGS+=' -L/huawei.370/zinc-install-root/release/huawei-bcm7409/lib '
       CPPFLAGS='-I/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/include
       '

       CPPFLAGS+='
       -isystem/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/
       opt/zinc-trunk/oss/include '

       CPPFLAGS+=' -I/opt/oem-staging/huawei-bcm7409/usr/local/include'
       LDFLAGS+=' -L/opt/oem-staging/huawei-bcm7409/usr/local/lib '
       [[ -z '' ]]
        cat /proc/cpuinfo
        grep processor
        wc -l
       let num_cpus=8
       export MAKEFLAGS=-j8
       MAKEFLAGS=-j8

       CC=mipsel-linux-gcc
       CXX=mipsel-linux-g++
       CPP=mipsel-linux-cpp

       note: this message marks the end of setvar-common
       echo "Using Qt version ${ZINC_QT_VERSION}"
     } <setvars-common-end>

     note: NOTE NOTE NOTE
     note: back to host setvar

     For HWEI, modify LDFLAGS from setvars-common which has as-needed by
     default.

     For HMAX, set LDFLAGS which means dismiss value from setvars-common and set
     a new value. DO NOT HAVE as-needed.

     this means that uses local LDFLAG than global for humax.
     
     ++ unset ZINC_EXCLUDE_PROJECTS

     # N.B: This is a temporary for a QIP release and to be removed.
     export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"
     ++ export ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect
     ++ ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect

   } <setvars-end>
}


={============================================================================
*kt_dev_uv_stack_003* zinc-build: setvars

Use ZB_HOST_CONFIG and get the specific host one. Get sourced in zb-shell,
zb-make. note: Uses ones in 'build' root.

source ${slave_dir}/DEVARCH/*/*/setvars-${ZB_HOST_CONFIG}.sh
+ source
  /_virtual_/humax.1000/DEVARCH/
    OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh


<per-host>
:~/source$ ls -al ./DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack/
kpark 1671 Jan  7 15:55 setvars-huawei-bcm7231.sh <PVR2-372>
kpark 1598 Jan  7 15:55 setvars-huawei-bcm7409.sh <PVR1-370>
kpark 1670 Jan  7 15:55 setvars-huawei-dn360t.sh

:~/source$ ls -al ./DEVARCH/OEM.Humax/OEM.Humax.3rdPartyStack/
kpark 1822 Jan  7 15:55 setvars-humax-db_t2200.sh
kpark 1653 Jan  7 15:55 setvars-humax-dtr_t1000.sh
kpark 1930 Jan  7 15:55 setvars-humax-dtr_t2100.sh
kpark 2177 Jan  7 15:55 setvars-humax-dtr_t4000.sh


<defines-what>
extra_flags=" -D_GNU_SOURCE=1 "
CPPFLAGS+=${extra_flags}
export CPPFLAGS

# remove -Wl,--as-needed from LDFLAGS
# TODO: This was here from the very beginning.  Is this still needed?
LDFLAGS="${LDFLAGS/[[:space:]]-Wl,--as-needed}"

# ensure OEM staging libraries can be found
LDFLAGS+=" -L${OEM_STAGING_ROOT}/usr/local/lib -Wl,-rpath-link,${OEM_STAGING_ROOT}/usr/local/lib"
export LDFLAGS


={============================================================================
*kt_dev_uv_stack_002* tool-jirafy:

// raise ticket with no restriction.
$ zg-jirafy 

// only can resolve on origin/master since search ID on that branch and means
// it's pused to master.
$ zg-jira-resolve DEVARCH-10596


={============================================================================
*kt_dev_uv_stack_002* tool-git-hook:

~/source/DEVARCH$ cat Zinc/Zinc.Build/git/hooks/pre-push

zinc-git-tools/zb-make:

ZB_DONT_UPDATE_HOOKS


={============================================================================
*kt_dev_uv_stack_002* tool-zb-deploy

<zb-deploy> 

zb-deploy -o humax.1000 -- -r

note: 

$ zb-deploy -o huawei.370 -f nexus-inspect

++ find
/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release
/huawei-bcm7409/opt/zinc-trunk
-type f -name nexus-inspect

+ for found_file in '$(find "$PREFIX" -type f -name "$file")'
+ destination=/opt/zinc-trunk/devel/bin/nexus-inspect


-f <file(s)>  Copy one or more files to the device without doing anything
drastic, such as killing daemons or wiping out application sandboxes.

zb-deploy -o humax.1000 -f textEPG


note: careful when use -o option. not to use humax1000 and spend some hours why
not working. see there must be dot(.) so "humax.1000" but not "humax1000"

note: NOT run in sub-shell such as zb-shell. Otherwise, see error:

+ tput sgr0
tput: unknown terminal "xterm"
+ rm -rf /tmp/setup-humax.sh.29807
+ tput sgr0
tput: unknown terminal "xterm"

note: this resync between install-root and box:/opt

-o type of device for which deployment is done where permitted values are

 device-spec   : Description
 -----------------------------------------
 humax.1000 : for Humax T1000 boxes
 humax.2100 : for Humax T2100 boxes
 huawei.360 : for Huawei DN360T boxes
 huawei.370 : for Huawei DN370T boxes
 huawei.372 : for Huawei DN372T boxes


08:43:17 {topic} ~/source/DEVARCH$ zb-deploy -o humax.2100 | tee h2100.deploy.log

zb-deploy -o huawei.370 -- -r
{
  + getopts :o:m:f:h:v opt
  + case "${opt}" in
  + export ZB_CFG=humax.2100
  + ZB_CFG=humax.2100
  + getopts :o:m:f:h:v opt
  + shift 2
  +++ readlink -f /home/kpark/source/zinc-git-tools/zb-deploy
  ++ dirname /home/kpark/source/zinc-git-tools/zb-deploy
  + where_am_i=/home/kpark/source/zinc-git-tools
  + source /home/kpark/source/zinc-git-tools/zb/zb-load-config.sh

  <zb-load-config-begin>
  +++ get_conf host-config host
  ++ ZB_HOST_CONFIG=humax-dtr_t2100
  +++ get_conf build-type debug
  ++ ZINC_USER_BUILD_TYPE=release
  +++ get_conf install-prefix ''
  ++ ZINC_USER_HOST_PREFIX=/opt/zinc-trunk

  # check for default git config for ZINC_USE_ICECREAM
  if [[ -z "$ZINC_USE_ICECREAM" && $(conf --bool zb.zinc-use-icecream) == "true" ]]; then
      export ZINC_USE_ICECREAM=1;
  fi

  # check for default git config for ZINC_FORCE_32_BIT
  if [[ -z "$ZINC_FORCE_32_BIT" && $(conf --bool zb.zinc-force-32-bit) == "true" ]]; then
      export ZINC_FORCE_32_BIT=1;
  fi

  # check for a ccache default git config
  if [[ -z "$ZINC_USE_CCACHE" && $(conf --bool zb.use-ccache) == "true" ]]; then
      export ZINC_USE_CCACHE=1;
  fi

  ...

  ++ mkdir -p /home/kpark/builds/.ccache/humax.2100/.ccache
  ++ [[ -z unix:abstract=/tmp/dbus-TGXXuaMUu7,guid=e6ce3d0ace3014e3c91e242b5629ed34 ]]
  <zb-load-config-end>

  echo $ZB_SLAVE_DIR/$ZB_CFG

  ++ '[' -n /home/kpark/builds/_virtual_ ']'
  ++ echo /home/kpark/builds/_virtual_/humax.2100

  + cd /home/kpark/builds/_virtual_/humax.2100/DEVARCH/

  <setvar>
  source */*/setvars-$ZB_HOST_CONFIG.sh &>/dev/null
  + source OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh

  # If the host to deploy for is not the PC then source the appropriate setup
  # script and execute the host specific patch script (used to merge built and
  # 3rd party file system deployment trees).

  + '[' humax-dtr_t2100 '!=' host ']'
  ++ get_conf setup-script-path
  + setup_script_path=/home/kpark/source/setup-humax
  ++ get_conf deploy-script
  + setup_script=setup-humax.sh

  + host=humax-04535

  + deploy_build
  + '[' -z /home/kpark/source/setup-humax ']'
  + '[' -z /home/kpark/source/setup-humax/setup-humax.sh ']'
  ++ which /home/kpark/source/setup-humax/setup-humax.sh
  + '[' '!' -x /home/kpark/source/setup-humax/setup-humax.sh ']'
  + vendor=humax

  + patch_a_tron_script=
  /home/kpark/builds/_virtual_/humax.2100/DEVARCH/OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh

  $setup_script_path/$setup_script -z "$PREFIX" -P "file://${patch_a_tron_script}" "$@" "$host"

  + /home/kpark/source/setup-humax/setup-humax.sh -z 
  /home/kpark/builds/_virtual_/humax.2100/zinc-install-root/
    release/humax-dtr_t2100/opt/zinc-trunk -P \
  file:///home/kpark/builds/_virtual_/humax.2100/DEVARCH/
    OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh 
  humax-04535
}


<setup-humax-sh>

note: no zinc-trunk handling. okay to run it as a standalone.

note: this requires RW rfs.

#/   -r            Reboot the box when this script has completed.

#/   -f            Force first time setup. Does additional installation of
#/                 eg. password-less login, rsync, scp.

#
# firstTimeSetup() {
# 
# + debug 'Setting up passwordless login...'
# + debug 'Installing rsync on Humax device...'
# + debug 'Installing custom login script 
# (./setup-humax/custom-login.sh) to /usr/local/bin/ ...'

$ ./setup-humax/setup-humax.sh -f humax-0873
$ ./setup-huawei/setup-huawei.sh -f 172.20.33.192

note: use git config    

git config zb.huawei.370.deploy-host "hostname of your box here"


#/   -z <zincdir>  Local build to deploy
#/                 (e.g. $ZINC_INSTALL_ROOT/debug/huawei-dtr_t1000/opt).
#    
#/   -P <patchatron url>  Use the specified patch-a-tron.

    + /home/kpark/source/setup-humax/setup-humax.sh 
    -z /home/kpark/builds-src-dev/_virtual_/humax.2100/zinc-install-root/
          release/humax-dtr_t2100/opt/zinc-trunk 
    -P file:///home/kpark/builds-src-dev/_virtual_/humax.2100/
          DEVARCH/OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh 
          humax-04535

setup-humax:main
{

  ! [[ "$0" =~ /setup-humax.sh$ ]] ||  # Don't run if being sourced by unit tests
  main "$@"

  + main -z /home/kpark/builds/_virtual_/humax.2100/zinc-install-root/
            release/humax-dtr_t2100/opt/zinc-trunk 
         -P file:///home/kpark/builds/_virtual_/humax.2100/DEVARCH/OEM.Humax/
            OEM.Humax.Scripts/patch-host-for-yv-zinc.sh humax-04535
  + forcefirsttime=0

  + zincdir=/home/kpark/builds/_virtual_/humax.2100/zinc-install-root/release/humax-dtr_t2100/opt/zinc-trunk

  # We still need to start up the rsync daemon every time the box boots.
  # This command can fail, let's assume that means the daemon is up.
  $ssh "rsync --daemon --ipv4"
  export RSYNC_PASSWORD=zinc

  + ssh -oBatchMode=yes -i /home/kpark/.ssh/id_rsa root@humax-04535 ls
  + ssh -i /home/kpark/.ssh/id_rsa root@humax-04535 'rsync --daemon --ipv4'
  + export RSYNC_PASSWORD=zinc
  + RSYNC_PASSWORD=zinc

  + case "$irdriver" in
  + true
  + '[' -n /home/kpark/builds/_virtual_/humax.2100/zinc-install-root/release/
      humax-dtr_t2100/opt/zinc-trunk ']'

  + installPatchATron
  + local patchatronfile
  + '[' 0 = 1 ']'
  + '[' -z file:///home/kpark/builds/_virtual_/humax.2100/DEVARCH/
      OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh ']'
  + '[' -z '' ']'

  debug "Downloading patch-a-tron to localhost..."
  patchatronfile="$scratchdir/patch-host-for-yv-zinc.sh"
  # download source target
  download "$patchatron" "$patchatronfile"

  + download 

  + patchatronfile=/tmp/setup-humax.sh.31726/patch-host-for-yv-zinc.sh
  + download file:///home/kpark/builds/_virtual_/humax.2100/DEVARCH/OEM.Humax/
    OEM.Humax.Scripts/patch-host-for-yv-zinc.sh /tmp/setup-humax.sh.31726/patch-host-for-yv-zinc.sh
  + local source=file:///home/kpark/builds/_virtual_/humax.2100/DEVARCH/OEM.Humax/
    OEM.Humax.Scripts/patch-host-for-yv-zinc.sh target=/tmp/setup-humax.sh.31726/patch-host-for-yv-zinc.sh
  + case "$source" in

  note: actually get a local file and save it to /tmp/xx

  + curl --silent --show-error -o /tmp/setup-humax.sh.31726/patch-host-for-yv-zinc.sh 
    file:///home/kpark/builds/_virtual_/humax.2100/DEVARCH/OEM.Humax/OEM.Humax.Scripts/
    patch-host-for-yv-zinc.sh


  + debug 'Installing patch-a-tron from /tmp/setup-humax.sh.27595/patch-host-for-yv-zinc.sh ...'

  Installing patch-a-tron from /tmp/setup-humax.sh.27595/patch-host-for-yv-zinc.sh ...
  + chmod a+x /tmp/setup-humax.sh.31726/patch-host-for-yv-zinc.sh

  note: copy to a box

  + rsync -av /tmp/setup-humax.sh.31726/patch-host-for-yv-zinc.sh zinc@humax-04535::Root/usr/local/bin/

  if [ -n "$zincdir" ]; then
      # We want to always install the latest patch-a-tron
      installPatchATron
      # better off with no process holding any resources
      [[ $dontkillzincdaemons = 1 ]] || killZincDaemons
      installZinc
  fi

  + installZinc


  note:
  Here builds filter rules.


  + local thisDir=/home/kpark/source/setup-humax
  + '[' -z /home/kpark/source/DEVARCH ']'
  + local excludedFiles=/home/kpark/source/DEVARCH/Zinc/Zinc.Build/
    excluded-files-production.txt

  debug "Updating Rsync filter rules from $excludedFiles"
  debug "Keeping in devel and tests folders"

  # Preserve the applications directory. This is kept in normal upgrades
  # of the box. In fact only factory reset will delete this directory.
  # We want to keep it around so that application's persistent data is kept
  # like it is in the real world.
  echo "P var/applications/" \
      > "$thisDir/rsync.filter"
      >
  # We keep in the devel and tests folders because they are generally
  # useful to have when developing or testing on the box. You can just
  # modify the grep expression if you want to rsync more.
  cat $excludedFiles | egrep -v "devel|tests|terminfo" | sed 's|opt/\*/||' \
      >> "$thisDir/rsync.filter"
  
  + echo 'P var/applications/'
  + cat /home/kpark/source/DEVARCH/Zinc/Zinc.Build/excluded-files-production.txt

    - opt/*/include/
    - opt/*/oss/include/
    - opt/*/oss/lib/glib-2.0/include/
    - opt/*/oss/lib/dbus-1.0/include/

    - **.a

    - opt/*/oss/man/
    - opt/*/oss/share/gtk-doc/
    - opt/*/oss/share/doc/
    - opt/*/oss/share/man/
    - opt/*/oss/share/info/

  + egrep -v 'devel|tests|terminfo'
  + sed 's|opt/\*/||'

    P var/applications/
    - include/
    - **.a

    # files
    - oss/bin/msggrep
    - oss/bin/envsubst
    - oss/lib/gstreamer-1.0/*.la


  debug "Rsyncing $zincdir to Humax device..."
  rsync -av $rsyncdelete --filter "merge $thisDir/rsync.filter" \
      $zincdir zinc@$humaxip::Root/opt/

  + rsync -av --delete --delete-excluded --filter 
    'merge /home/kpark/source/setup-humax/rsync.filter' 
    /home/kpark/builds/_virtual_/humax.2100/zinc-install-root/release/
      humax-dtr_t2100/opt/zinc-trunk zinc@humax-04535::Root/opt/

  sending incremental file list
  zinc-trunk/lib/sandbox/
  zinc-trunk/lib/sandbox/application-oem.conf
  zinc-trunk/lib/sandbox/application-yv.conf
  zinc-trunk/lib/sandbox/daemon-oem.conf
  zinc-trunk/lib/sandbox/daemon-yv.conf
  ...
  

  # Copy the bash completion script as it may not be part of production
  # tarballs.
  if [ -f "$zincdir/oss/etc/bash_completion.d/dbus-bash-completion.sh" ]; then
      debug "Installing dbus-send tab-completion script..."
      rsync -av "$zincdir/oss/etc/bash_completion.d/dbus-bash-completion.sh" \
          zinc@$humaxip::Root/usr/local/share/dbus-send-completion
  fi
  
  Installing dbus-send tab-completion script...
  + tput sgr0
  + rsync -av /home/kpark/builds-src-dev/_virtual_/humax.2100/zinc-install-root/
    release/humax-dtr_t2100/opt/zinc-trunk/oss/etc/bash_completion.d/dbus-bash-completion.sh 
    zinc@humax-04535::Root/usr/local/share/dbus-send-completion
  

  debug "Running patch-a-tron with /opt/zinc-trunk"
  $ssh "/usr/local/bin/patch-host-for-yv-zinc.sh /opt/zinc-trunk"

  note: run "patch-a-tron"

  Running patch-a-tron with /opt/zinc-trunk
  + ssh -i /home/kpark/.ssh/id_rsa root@humax-04535 
  '/usr/local/bin/patch-host-for-yv-zinc.sh /opt/zinc-trunk'
  
  Finished successfully.
  + tput sgr0
  + rm -rf /tmp/setup-humax.sh.27595
  + tput sgr0
}


={============================================================================
*kt_dev_uv_stack_002* tool-patch-a-tron

<patch-host-for-yv-zinc-sh>
#!/bin/bash

###
# patch-host-for-yv-zinc.sh
#
# Author: john.sadler@youview.com
#
# Copyright (c) 2011, Youview TV Ltd.
#
# This script is used to patch an OEM-provided rootfs such that we can use a 
# YV build of the zinc stack alongside the OEM services. The YV stack build 
# must use a different prefix to /opt/zinc, as this script will modify the 
# original /opt/zinc in-place, redirecting some programs to the YV-built versions.
#
###

set -u

script_name=$(basename "${0}")
prefix="/opt/zinc"
forwarder="/tmp/${script_name}/forwarder"
devel_forwarder="/tmp/${script_name}/devel-forwarder"
oss_forwarder="/tmp/${script_name}/oss-forwarder"
oem_forwarder="/tmp/${script_name}/oem-forwarder"
radiumairlauncher_forwarder="/tmp/${script_name}/radiumairlauncher-forwarder"

# make sure everyone can read and execute newly created files
umask 0022

# These are the programs which we do not wish to replace.
# We will keep using the OEM build of these.

# Humax use abbreviated form of Event Locator, which Client.System can't grok.
# re-add this to the whitelist below, when this issue is sorted.
# ironmetadatad \

use_oem_programs="\
	ironmetadatad \
	cadmiumcontentacquisitiond \
	osmiumd \
"

function die {

	echo "$@">&2
	exit 1
}

function makeForwarders {

	[[ -d "/tmp/${script_name}" ]] || mkdir "/tmp/${script_name}"

	echo "#!/bin/sh
ulimit -c unlimited
program_name=\$(basename \$0)
target=\"${yv_prefix}/bin/\${program_name}\"
LD_LIBRARY_PATH=\"${yv_prefix}/lib:${yv_prefix}/devel/lib:${yv_prefix}/oss/lib:\${LD_LIBRARY_PATH}\" exec \"\${target}\" \"\${@}\"
">"${forwarder}"

	echo "#!/bin/sh
ulimit -c unlimited
program_name=\$(basename \$0)
target=\"${yv_prefix}/devel/bin/\${program_name}\"
LD_LIBRARY_PATH=\"${yv_prefix}/lib:${yv_prefix}/devel/lib:${yv_prefix}/oss/lib:\${LD_LIBRARY_PATH}\" exec \"\${target}\" \"\${@}\"
">"${devel_forwarder}"

	echo "#!/bin/sh
ulimit -c unlimited
program_name=\$(basename \$0)
target=\"${yv_prefix}/oss/bin/\${program_name}\"
LD_LIBRARY_PATH=\"${yv_prefix}/lib:${yv_prefix}/devel/lib:${yv_prefix}/oss/lib:\${LD_LIBRARY_PATH}\" exec \"\${target}\" \"\${@}\"
">"${oss_forwarder}"

	echo "#!/bin/sh
ulimit -c unlimited
program_name=\$(basename \$0)
target=\"${prefix}/bin/\${program_name}.oem\"
LD_LIBRARY_PATH=\"${prefix}/lib:${prefix}/devel/lib:${prefix}/oss/lib:\${LD_LIBRARY_PATH}\" exec \"\${target}\" \"\${@}\"
">"${oem_forwarder}"

	echo "#!/bin/sh
ulimit -c unlimited
program_name=\$(basename \$0)
target=\"${yv_prefix}/bin/\${program_name}\"

for arg in \"\$@\"; do
	target+=\" '\$arg'\"
done

exec ${yv_prefix}/oss/bin/sudo -E -u radiumd -g app_launcher \\
	/bin/sh -c \"LD_LIBRARY_PATH=${yv_prefix}/lib:${yv_prefix}/devel/lib:${yv_prefix}/oss/lib:\${LD_LIBRARY_PATH} exec \${target}\"
">"${radiumairlauncher_forwarder}"

chmod a+rx "${forwarder}"
chmod a+rx "${devel_forwarder}"
chmod a+rx "${oss_forwarder}"
chmod a+rx "${oem_forwarder}"
chmod a+rx "${radiumairlauncher_forwarder}"

}

function patchOptZinc {

  echo "patchOptZinc()"

# Improvised hash-table-in-filesystem for whitelisted oem programs
    local oem_program_hash="/tmp/${script_name}/oem_programs"

    if [[ -e "${oem_program_hash}" ]]; then
      rm -rf "${oem_program_hash}"
        fi

        mkdir -p "${oem_program_hash}"

        for p in ${use_oem_programs}; do
          mkdir -p "${oem_program_hash}/${p}"
            done

            for replacement_suffix in "" "/oss" "/devel" ; do

              if [[ "${replacement_suffix}" == "/oss" ]]; then
                use_forwarder="${oss_forwarder}"
                  elif [[ "${replacement_suffix}" == "/devel" ]]; then
                  use_forwarder="${devel_forwarder}"
              else
                use_forwarder="${forwarder}"
                  fi

                  replacement_prefix="${yv_prefix}${replacement_suffix}"
                  orig_prefix="${prefix}${replacement_suffix}"

                  if [[ -d "${replacement_prefix}" ]]; then

                    for p in `ls ${replacement_prefix}/bin`; do

                      local yv_program="${replacement_prefix}/bin/${p}"

# - only process executable programs.
# - keep original (oem) version of whitelisted programs.
# - ignore new programs already picked-up in a previous run of this script.

                        if [[ -f "${yv_program}" && -x "${yv_program}" && ! -e "${oem_program_hash}/${p}" && ! -f "${prefix}/bin/${p}.yv_new" ]]; then

                          local orig="${orig_prefix}/bin/${p}"
                            local backup="${orig_prefix}/bin/${p}.oem"

                            if [[ -f "${orig}" ]]; then

                              echo "Patching ${orig} ..."

                                if [[ ! -f "${backup}" ]]; then
                                  cp -p "${orig}" "${backup}"
                                    fi

                                    cp -p "${use_forwarder}" "${orig}"

                                else

# There was no existing program found with this name.
# So, we'll assume that this is a new program that has been added.
# Create a forwarder for the program within the old prefix, so
# that we can invoke it easily, without having to manually fudge PATH
# or LD_LIBRARY_PATH.

                                  echo "New Program ${replacement_prefix}/bin/${p} ..."

                                    local new="${orig_prefix}/bin/${p}"
                                    [[ -d "${orig_prefix}/bin" ]] || mkdir -p "${orig_prefix}/bin"
                                    cp -p "${use_forwarder}" "${new}"
# Create this marker file, so the restore operation has an easy
# way of undoing this.
                                    touch "${new}.yv_new"
                                    fi 
                                    fi
                                    done
                                    fi
                                    done
}

function fixUpBabySitter {

	${yv_prefix}/oss/bin/busybox id babysitterd &>/dev/null || \
		${yv_prefix}/oss/bin/busybox addgroup app_launcher &>/dev/null && \
		${yv_prefix}/oss/bin/busybox adduser \
			-h /opt/zinc \
			-s /sbin/nologin \
			-G app_launcher \
			-g '' \
			-D -H \
			babysitterd &>/dev/null

	local config="${yv_prefix}/share/titanium-system-launcher/exec-paths.config"

	# always go through forwarders
	sed -i "s|${yv_prefix}|${prefix}|" "${config}"
}

function fixUpDaemonSandboxing {

	# Back up services-yv to services-yv.orig.
	[ -d ${yv_prefix}/oss/share/dbus-1/services-yv.orig ] || \
		cp -rp ${yv_prefix}/oss/share/dbus-1/services-yv{,.orig}

	# We want to launch YouView services through the forwarders in ${prefix}.
	# One notable thing forwarders do for us is including ${yv_prefix}/devel/lib
	# into LD_LIBRARY_PATH.
	for yv_service_file in $(ls ${yv_prefix}/oss/share/dbus-1/services-yv/); do
		sed "s|Exec=${yv_prefix}|Exec=${prefix}|" \
			${yv_prefix}/oss/share/dbus-1/services-yv.orig/${yv_service_file} > \
			${yv_prefix}/oss/share/dbus-1/services-yv/${yv_service_file}
	done

	# Bring in OEM DBus services into ${yv_prefix}
	cp -p ${prefix}/oss/share/dbus-1/services-oem/* ${yv_prefix}/oss/share/dbus-1/services-oem/

	# Bring in OEM DBus policies.
	cp -p ${prefix}/oss/etc/dbus-1/policies-oem.d/* ${yv_prefix}/oss/etc/dbus-1/policies-oem.d/

	# Bring in OEM sandbox configuration.
	oem_sandbox_conf_dir="${prefix}/lib/sandbox/application-oem.d"
	if [ -n "$(ls -A $oem_sandbox_conf_dir 2>/dev/null)" ]; then
		cp -p ${oem_sandbox_conf_dir}/* ${yv_prefix}/lib/sandbox/application-oem.d/
	fi

	cp -p ${prefix}/lib/sandbox/service-oem.d/* ${yv_prefix}/lib/sandbox/service-oem.d/

	for config in daemon application; do
		cp -p ${prefix}/lib/sandbox/${config}-oem.conf ${yv_prefix}/lib/sandbox/
	done

	# daemon-oem.conf is not expected to import anything from ${prefix}, as
	# that's the job of daemon-yv.conf. When deploying the Zinc stack to
	# ${yv_prefix}, daemon-yv.conf will be importing stuff from ${yv_prefix}
	# rather than from ${prefix}. That means if some of the OEM daemons are under
	# ${prefix} or have dependencies there, we won't be able to launch them.
	# To fix this issue, we modify daemon-yv.conf to import stuff both
	# from ${prefix} and from ${yv_prefix}.
	daemon_yv_conf="${yv_prefix}/lib/sandbox/daemon-yv.conf"

	# process the file in-place (internally a temp file is used)
	# print original lines, save edited lines in the hold buffer
	# on the last line, swap hold & pattern buffers,
	# prepend a comment to the edited lines and print
	sed -i \
		-ne "p;s|${yv_prefix}/|${prefix}/|;H" \
		-ne '${x;s/^/\n# == Added by patch-a-tron ==\n/p}' \
		"${daemon_yv_conf}"

	# ensure applications and UIME have log output available
	local components_with_logging_enabled="
	${yv_prefix}/lib/sandbox/application-yv.conf
	${yv_prefix}/lib/sandbox/service-yv.d/uimanagerd.conf
	${yv_prefix}/lib/sandbox/service-yv.d/babysitterd.conf
	"
	for config_item in ${components_with_logging_enabled}
	do

		grep -q "StdOut" "${config_item}" || \
		echo "
[options]
StdOut=/dev/console
StdErr=/dev/console
" >> "${config_item}"
	done

	# to make the log output available, need to have the output device available in the sandbox
	if [ ! -e /run/dev_sandbox/console ]; then
		local dev_sandbox_config="/etc/sandbox_dev_table.txt"
		if [ -e "${dev_sandbox_config}" ]; then

			grep -q "\bconsole\b" "${dev_sandbox_config}" || \
			echo "console c 666 0 0 5 1 0 0 -" >> "${dev_sandbox_config}"
		else

			echo "WARNING: ${dev_sandbox_config} is not available. Cannot enable stdout/stderr"
		fi
	fi

	# If someone decides to turn the daemon sandboxing off we end up with yv_prefix D-BUS daemon
	# spawning service daemons which is a disaster in case of launching a daemon from ${prefix}.
	# To address that we create forwarders for non-patched daemons so they have ${prefix} env. set properly.

	# TODO: This is not perfect as it won't pick up OEMs services with fancy Exec= entries
	for service_exec_entry in `grep -h "Exec=${prefix}/" ${yv_prefix}/oss/share/dbus-1/services-oem/* \
        | cut -f1 -d' '`; do

		service_exec_with_params="${service_exec_entry#Exec=*}"
		service_exec="${service_exec_with_params%% *}"
		if [ ! -e "${service_exec}.oem" -a ! -e "${service_exec}.yv_new" ]; then

			mv "${service_exec}"{,.oem}
			cp -p "${oem_forwarder}" "${service_exec}"
		fi
	done
}

##
# This fix is required as radiumairlauncher is executed by the baysitterd while the application update
# requires it running as 'radiumd' user. Hence the binary needs setuid bit to get the EUID switch from 'babysitterd' to
# 'radiumd'. Due to setuid bit set the binary will not have libraries loaded properly as the LD_LIBRARY_PATH is ignored
# and /etc/ld.so.cache contains entries only for /opt/zinc.
#
function fixUpForRadiumairlauncher {

	local radiumairlauncher_exec="${prefix}/bin/radiumairlauncher"

	# fix sudo config
	local sudoers_file="${yv_prefix}/oss/etc/sudoers"

	# allow BabySitter to run radiumairlauncher as radiumd on the HUMAX host
	grep -q "babysitterd HUMAX=" "${sudoers_file}" || \
		echo "babysitterd HUMAX=(radiumd:app_launcher) NOPASSWD: SETENV: /bin/sh" >> "${sudoers_file}"
	# this is also required
	sed -i -e 's/root\tALL=(ALL)/root\tALL=(ALL:ALL)/g' "${sudoers_file}"

	# make the sudo happy about the sudoers file permissions
	chown root.root "${sudoers_file}"
	chmod 0440 "${sudoers_file}"

	# fix the sudo binary permissions
	local sudo_exec="${yv_prefix}/oss/bin/sudo"
	chown root.root "${sudo_exec}"
	chmod 04111 "${sudo_exec}"

	cp -p "${prefix}/bin/radiumairlauncher"{,.oem}
	cp -p "${radiumairlauncher_forwarder}" "${prefix}/bin/radiumairlauncher"

}

function fixUpForSandboxing {

	if [ -e "/mnt/hd6" ] ; then
		if [ ! -d "/mnt/hd6/rct" ]; then
			echo "WARNING '/mnt/hd6/rct' is missing. Creating...">&2
			mkdir -p "/mnt/hd6/rct"
		fi
	fi

	fixUpDaemonSandboxing
	fixUpBabySitter

	# all binaries in ${yv_prefix}/bin are checked here for backwards compatibility
	# as they should exist in ${yv_prefix}/libexec

	for f in ${yv_prefix}/bin/yv-kill ${yv_prefix}/bin/yv-sandbox; do

		if [ -e "${f}" ]; then
			chown root.uime "${f}"
			chmod 4110 "${f}"
		fi
	done

	for f in ${yv_prefix}/libexec/yv-sandbox; do

		if [ -e "${f}" ]; then
			chown root.app_launcher "${f}"
			chmod 4110 "${f}"
		fi
	done

	for f in ${yv_prefix}/{bin,libexec}/yv-applicationdatacleaner; do

		if [ -e "${f}" ]; then
			chown root.app_library "${f}"
			chmod 4110 "${f}"
		fi
	done

	for f in ${yv_prefix}/{bin,libexec}/yv-daemon-sandbox; do

		if [ -e "${f}" ]; then
			chown root.dbus "${f}"
			chmod 4110 "${f}"
		fi
	done

	for suffix in yv oem; do
		for item in application service; do
		    local dir="${yv_prefix}/lib/sandbox/${item}-${suffix}.d"
		    if [ -e  "${dir}" ]; then
			chown -R root.root "${dir}"
			chmod 0500 "${dir}"
			[ -n "$(ls -A ${dir})" ] && chmod 0400 ${dir}/*.conf
		    fi
		done
	done
	
	ln -sf ${prefix}/oss/etc/dbus-1/system.d/* ${yv_prefix}/oss/etc/dbus-1/system.d/

	if [ -e "${yv_prefix}/lib/sandbox" ]; then

		chown root.root ${yv_prefix}/lib/sandbox/*.conf
		chmod 0400 ${yv_prefix}/lib/sandbox/*.conf
	fi

}

function disableDeviceAuthoriser() {
  echo "Disabling feature authorisation.  Use -D to preserve it."

  grep -lsr '^libTitaniumDeviceAuthoritySystemDbusClient.so' ${yv_prefix}/share/ | \
  xargs -r sed -i \
  -e '1i libTitaniumDeviceAuthoritySystemOff.so createOffSystemFactory' \
  -e 's/^/# DA disabled by patch-a-tron: /'
}

function processKiller {
    kill $(ps ax | grep '[z]inc' | \
	   egrep -v 'dbus-daemon|bronze|dhclient|NetworkManager|'"${script_name}" | \
	   awk '{print $1}'
	 ) &> /dev/null ||
	 echo "Killing processes: No relevent processeses were found to be killed"
    sleep 5
}

function updateUI {

    function backupUI {
        processKiller
        [[ -d "/opt/ui.oem" ]] || mv "/opt/ui" "/opt/ui.oem"
        rm -rf "/opt/ui"
        mkdir "/opt/ui"
    }

    echo "updateUI()"
    echo "Updating UI to version: ${ui_version}..."

    local current_gallium_url="http://clientappsbuild/job/Gallium.Main/${ui_version}/artifact"

    # if ui_version is less than or equal to 10206 use the old server.
    if [ "$ui_version" = "lastSuccessfulBuild" ]; then
        local gallium_url=$current_gallium_url
    else
        if [ "$ui_version" -le 10206 ]; then
            local gallium_url="http://192.168.18.210:8080/job/Gallium.Main/${ui_version}/artifact/Gallium/target"
        else
            local gallium_url=$current_gallium_url
        fi
    fi

    rm -f /tmp/csui-distro.*    

    wget -q -P /tmp "${gallium_url}/csui-distro.tar" &> /dev/null

    if [ -e "/tmp/csui-distro.tar" ]; then
        backupUI
        tar -C "/opt/ui/" -xf "/tmp/csui-distro.tar"
    else # Try and download a zip archive
        wget -q -P /tmp "${gallium_url}/csui-distro.zip" &> /dev/null
        if [ -e "/tmp/csui-distro.zip" ]; then
            backupUI
            unzip -q "/tmp/csui-distro.zip" -d "/opt/ui/"
        else
            die "No csui-distro archives could be downloaded"
        fi
    fi

    rm -f /tmp/csui-distro.*

	cd /opt/ui/pmui
	rm -f splashscreen
	ln -s /opt/zinc-trunk/share/platform_data/mercury-system-uimanager splashscreen
    
    local new_ui_version=`cat /opt/ui/ui.txt | awk '{print $NF}' | awk -F'-' '{print $2}'`
    echo "Updated UI to version: ${new_ui_version}."
}

function restoreUI {

	echo "restoreUI()"

	if [ -d "/opt/ui.oem" ]; then
        processKiller
		[[ ! -d "/opt/ui" ]] || rm -rf "/opt/ui"
		mv "/opt/ui.oem" "/opt/ui"
	fi
}

function restoreOptZinc {

	echo "restoreOptZinc()"

	for orig_prefix in "${prefix}" "${prefix}/oss" "${prefix}/devel" ; do

		if [[ -d "${orig_prefix}" ]]; then

			# Restore the replaced OEM-built programs
			for backup in `ls ${orig_prefix}/bin/*.oem 2>/dev/null`; do 
				local orig="${backup%%.oem}"
				echo "Restoring ${orig} ..."
				mv "${backup}" "${orig}"
			done
			
			for new_marker in `ls ${orig_prefix}/bin/*.yv_new 2>/dev/null`; do 
				local new="${new_marker%%.yv_new}"
				echo "Removing ${new} ..."
				rm -f "${new}" "${new_marker}"
			done
		fi
	done
}

function usage {
  echo "
  Usage: ${script_name} [ -h ] -r | [ -D ] [ -u ] [ -U <ui version> ] <youview
  prefix>

  Where:

  note: disable auth
  -D                        Disable device authorisation for various features

  -u                        Additionally update/restore the main ui 

  -U                        Specify the ui version, where <ui version> is the UI
  build number.  Will default to last successful build if this option is not
  given.  This option implies -u

  -h                        Print this message

  -r                        Restore oem programs (undo operation)

  <youview prefix>          Path to the youview-built stack (e.g.
  /opt/zinc-trunk). This is not required for restore (-r)

  Examples:

  1) Redirect binaries in /opt/zinc to /opt/zinc-trunk:

  ${script_name} /opt/zinc-trunk

  2) Redirect binaries, AND update to latest UI:

  ${script_name} -u /opt/zinc-trunk

  3) Redirect binaries, AND update to specific UI version:

  ${script_name} -U 4299 /opt/zinc-trunk

  4) Restore original binaries, but leave UI untouched:

  ${script_name} -r 

  5) Restore binaries AND UI

  ${script_name} -ur

  " >&2

  exit 1
}

let disable_device_auth=0
let do_restore=0
yv_prefix=""
ui_version=""

while getopts "DuU:rh" option_name; do
   case $option_name in
   D) disable_device_auth=1;;
   u) [[ -n "${ui_version}" ]] || ui_version="lastSuccessfulBuild";;
   U) ui_version="${OPTARG}";;
   r) let do_restore=1;;
   h) usage;;
   *) usage "Invalid flag";;
   esac
done

if (( ! do_restore )); then
	
	shift $(($OPTIND - 1))

	yv_prefix="${1:-}"

	[[ -n "${yv_prefix}" ]] || usage "Please provide youview prefix."

	# normalize yv_prefix so it doesn't have a slash at the end
	yv_prefix="${yv_prefix%*/}"

	[[ -d "${yv_prefix}" ]] || usage "${yv_prefix} doesn't exist!"
	
fi

if (( do_restore )); then
   restoreOptZinc
   if [[ -n "${ui_version}" ]]; then
      restoreUI
   fi
else
   makeForwarders
   patchOptZinc
   fixUpForSandboxing
   fixUpForRadiumairlauncher
        (( disable_device_auth )) && disableDeviceAuthoriser
   [[ -z "${ui_version}" ]] || updateUI
fi


={============================================================================
*kt_dev_uv_stack_003* stack: startup

cds: core driver software

/opt/cds/etc/rc.user

root# pwd
/opt

root# ls -al
drwxr-xr-x    8 root     root           149 Dec 25 04:33 .
drwxr-xr-x   17 root     root           259 Dec 25 04:33 ..
drwxr-xr-x    3 root     root            33 Dec 25 02:36 adobe
drwxr-xr-x   12 root     root           247 Dec 25 04:33 cds
drwxr-xr-x    4 root     root            84 Dec 18 14:20 netflix
drwxr-xr-x    4 root     root            39 Dec 25 04:33 stagecraft-2.0
lrwxrwxrwx    1 root     root            15 Dec 25 04:33 ui -> /mnt/psi/ui_psi
dr-xr-xr-x    4 root     root            57 Dec 25 02:36 youview
drwxr-xr-x    9 root     root           186 Dec 25 04:33 zinc


<zinc>
root# pwd
/opt/zinc/bin

root# ls
CopperDownloader                     onscreenidd-launch
MediaRouterDbusSpy                   osmiumd
airlauncher.sh                       pcmplaybackd
audiofeedbackd                       persistedpairingrepository_utils.py
avahi-launcher                       provisioninginformationparser
babysitterd                          purge-polipo-diskcache.sh
cadmiumcontentacquisitiond           python_launcher.sh
cobaltmetadatabrokerd                queryNetworkManager
copperannouncementd                  radiumairlauncher
copperlocalstoragerepod              radiumd
crbd                                 remindersd
dbusredirect                         run-stagecraft2-functions.sh
dbussenddaemon                       run-stagecraft2-with-cache.sh
dbuswaitbusname                      runBrowser.sh
deleteTree                           runNetflix.sh
device-manager-launcher              runStagecraft2.sh
dial-server                          sandbox-drop-privileges
dial-server-launcher.sh              setItem
exec-with-cache                      setpgid-and-exec
generate-http-user-agent             sodiumd
getChildItems                        splashScreen
getItem                              start-and-wait-for-busname.sh
http-dbus-bridge                     start-service-over-dbus.sh
http-dbus-bridge-launcher.sh         storagemanagementd
https-cache-proxy                    tunerd
ironmetadatad                        uimanagerd
linearsource-launch                  w3cEngine
linearsource-launch-and-sandbox      watcher
linearsourced                        yv-mainui
lsr-config                           yv-remote-booking-agent-activate
nickelmediad                         yv-remote-booking-agent-watcher
on-demand-launcher                   yv-start-services.sh note:
onscreenidd


<lib-third-party>
/usr/local/lib

directfb-1.4-15            libfusion-1.4.so.15.0.0    libpng14.so.14.3.0
libdirect-1.4.so.15        libfusion.so               libsawman-1.5.so.0
libdirect-1.4.so.15.0.0    libinit.so                 libsawman-1.5.so.0.0.4
libdirect.so               libjpeg.so                 libsawman.so
libdirectfb-1.4.so.15      libjpeg.so.7               libshim_nexus.so
libdirectfb-1.4.so.15.0.0  libjpeg.so.7.0.0           libz.so
libdirectfb.so             libnexus.so                libz.so.1
libfreetype.so             libnexusMgr.so             libz.so.1.2.6
libfreetype.so.6           libpng.so                  modules
libfreetype.so.6.4.0       libpng14.so                pkgconfig
libfusion-1.4.so.15        libpng14.so.14

<humax-from-hdd-boot-case>
/mnt/hd1/bin

[root@HUMAX bin]# cat startYVServices.sh 
#!/bin/sh

/opt/zinc/bin/start-service-over-dbus.sh Zinc.ContentAcquisition
/opt/zinc/bin/start-service-over-dbus.sh Zinc.DeviceSoftware
/opt/zinc/bin/start-service-over-dbus.sh Zinc.DeviceManager
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Broker
/opt/zinc/bin/start-service-over-dbus.sh Zinc.UsageCollection
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Application
/opt/zinc/bin/start-service-over-dbus.sh Zinc.LinearSource
/opt/zinc/bin/start-service-over-dbus.sh Zinc.RemoteDiagnostics
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Metadata --requires Zinc.Broker
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Reminders
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Boot


<on-dbus>
/opt/zinc-trunk/oss/share/dbus-1/services-yv/Zinc.Boot.service 
[D-BUS Service]
Name=Zinc.Boot
Exec=/opt/zinc/bin/yv-start-services.sh
User=zincbootd


{zinc-boot}
https://jira.youview.co.uk/browse/DEVARCH-8276
Zinc.Boot service itself will be started from an OEM script.

The new service introduces the "$prefix/bin/yv-start-services.sh" script,
which it runs from a sandboxed environment. The script is meant to start
other services using the DBus activation mechanism. In this initial
version, it starts Zinc.DIAL only. When asking OEMs to start Zinc.Boot,
we are going to simultaneously ask them to stop starting Zinc.DIAL.

This implementation comes with an unfortunate side effect of producing
the following message to the serial console:

Error org.freedesktop.DBus.Error.NoReply: Did not receive a reply.
Possible causes include: the remote application did not send a reply,
the message bus security policy blocked the reply, the reply timeout
expired, or the network connection was broken.

This comes as a result of Zinc.Boot service not claiming the "Zinc.Boot"
bus name, but is otherwise completely harmless. At this point we decided
not to tackle this issue, as the cost/benefit ratio seems quite high in
this case.

~/src-dev/DEVARCH/Zinc/Zinc.Boot/data$ cat yv-start-services.sh.in 
#!/bin/sh

prefix="@prefix@"

start() {
    echo "Starting $1"
    "${prefix}/bin/start-service-over-dbus.sh" "$@"
}

start Zinc.DIAL
start Zinc.Crb
start Zinc.DBusBridge

exit 0

This is going to be changed to use "staged" boot using wait-on-cpu-load:

https://stash.dev.youview.co.uk/projects/DEVARCH/repos/devarch-mirror/commits/c57e81a58fc10dafe466b6e37b938fb5a5575880

note: here bucket is stage or ring level

This commit works best if OEM boot scripts only start Zinc.Boot
(and their daemons) and let Zinc.Boot start the YouView services
in an efficient manner.

The commit makes Zinc.Boot start all necessary services in three
buckets with delays between each. The idea is that some
non-essential services can be started later so they don't steal
precious CPU cycles or I/O / memory bandwidth.

The delays between each bucket depend on the system load, and the
idea is that the boot script waits until the load drops below a
certain value. This can be configured with new LSR keys:

platform.boot.delay-window-size
platform.boot.step-1-delay-load-threshold
platform.boot.step-2-delay-load-threshold

There is no delay in "step 0" - where key services are started.

The buckets look like:

Step 0:
- Start UI, metadata and media services

Step 1:
- Start second screen / remote control services

Step 2:
- Start CRB, Reminders, Usage Collection services


~/src-dev/DEVARCH/Zinc/Zinc.Boot/data$ cat yv-start-services.sh.in 

# Step 0: Start the minimal set of services to get into live
#         TV / interactive UI fast.
start Zinc.Metadata
start Zinc.Broker
start Zinc.Application
start Zinc.LinearSource

wait_for_idle $threshold1 30

# params:
#	cpu-threshold (percents)
#	timeout (seconds)
#	Note, that for the window size: 25 and sampling period 500ms
#	it will wait for at least 12.5s (the avg window gets filled)
wait_for_idle() {
	$prefix/bin/yv-wait-for-idle -s 500 -w $window_size -e $1 -t $2
}

# from yv-wait-for-idle

("exit_threshold,e", boost::program_options::value(&exit_threshold),
   "If specified specified (in %) - program will exit if "
   "CPU utilisation will fall below this value (default=1)")

("timeout,t", boost::program_options::value(&timeout_seconds),
   "Timeout in seconds (default=infinite)")


{on-dbus}
[root@HUMAX dbus-1]# pwd
/opt/zinc-trunk/oss/share/dbus-1

[root@HUMAX dbus-1]# 
drwxr-xr-x    8 1024     1025        4.0K May  1 12:01 ./
drwxr-xr-x   14 1024     1025        4.0K Apr 30 12:01 ../
drwxrwxr-x    2 1024     1025        4.0K Apr 30 11:59 interfaces/
drwxrwxr-x    2 1024     1025       16.0K Apr 30 12:35 introspection-xml/
drwxrwxr-x    2 1024     1025        4.0K May  1 12:01 services-oem/
drwxrwxr-x    2 1024     1025        4.0K Apr 30 12:47 services-yv/
drwxrwxr-x    2 1024     1025        4.0K Apr 30 12:47 services-yv.orig/
drwxr-xr-x    2 1024     1025        4.0K Apr 30 11:54 system-services/


[root@HUMAX dbus-1]# cat services-oem/Zinc.Media.service 
[D-BUS Service]
Name=Zinc.Media
Exec=/opt/zinc/bin/bronzemediad
User=root

note: redirection do not work to get console from bronze

Exec=/opt/zinc/bin/bronzemediad > x.log 2>&1


={============================================================================
*kt_dev_uv_stack_003* stack: launch chain and appid

https://wiki.youview.co.uk/display/YVDM/Application+Sandboxing?src=search

Launching applications and identities database (informative)

This section is informative only. There's nothing that Device Manufacturers need
to do about it.

The way it works is as follows:

launch chain
Main UI -> [D-BUS] -> UIME -> ((since C13) [D-BUS] -> BabySitter ->) [fork/exec]
-> radiumairlauncher -> Titanium Verifier -> {input: application
    capabilities/credentials} Titanium Container (sandbox)

preparing a sandbox
The Titanium Container prepares a sandbox for the application.


As Titanium Container has to assume that the application might be launched for
the first time it also has to be prepared to allocate and store some information
(see Appendix B: Notes on installing vs. updating/launching an application on
 this page).

At the moment the application "database" is organised in a way that every
application has its own <UID> sub-directory:

/opt/zinc/oss/var/applications/identities
                               `-- <UID>
                                   |-- groups
                                   |-- x-youview-appid
                                   `-- User-Agent

groups
A file containing group identifiers (GID) of all groups that that the
application belongs to. The first GID is the application primary group, all
other are supplementary groups.

x-youview-appid
A file containing the application identifier prefixed with either "youview:" or
"dev:". It is used both to generate x-youview-appid HTTP header (see Section
        'Networking' of 2105-S Flash Presentation Engine Integration
        specification), to look up the identities by the application identifier
and to read the application identifier in the client API (mainly for the client
        API access controls).

User-Agent
A file containing a value for the User-Agent HTTP header (see 1122-S User-Agent
        specification. It is stored individually for each application as it has
        to remain the same since the application particular version of the
        application was launched for the first time.


={============================================================================
*kt_dev_uv_stack_004* stack: oem configs

root# getChildItems oem

root# getChildItems oem | grep softwre
oem.activatedsoftware.coredevicesoftware.platformapiversion=2.9.1
oem.activatedsoftware.coredevicesoftware.version=70.37.05
oem.activatedsoftware.coredevitesoftware.version=1.0.0
oem.activatedsoftware.ispconfiguration.version=10002
oem.activatedsoftware.manufacturerconfiguration.version=4
oem.activatedsoftware.platformconfig=
oem.activatedsoftware.platformconfiguration.version=1304
oem.activatedsoftware.platformsoftware.version=2.9.6
oem.software.version=70.37.05
oem.softwaremanagement.coredevicesoftware.manifest.baseurl=http://su.tv.talktalk.net
oem.softwaremanagement.coredevicesoftware.updatepolicy=standard
oem.softwaremanagement.manufacturerconfiguration.baseurl=http://su.tv.talktalk.net
oem.softwaremanagement.manufacturerconfiguration.updatepolicy=standard


root# which getChildItems
/opt/zinc/bin/getChildItems


{oem-pkg-config}
local -> /opt/oem-staging/humax-dtr_t1000/usr/local//
local/lib/pkgconfig/axis2c.pc
local/lib/pkgconfig/nexus-mgr.pc
local/lib/pkgconfig/directfb.pc
local/lib/pkgconfig/direct.pc
local/lib/pkgconfig/nexusMgr.pc
local/lib/pkgconfig/uuid.pc
local/lib/pkgconfig/fusion.pc
local/lib/pkgconfig/directfb-internal.pc
local/lib/pkgconfig/sawman.pc
local/lib/pkgconfig/nexus.pc


local -> /opt/oem-staging/huawei-dn370t/usr/local/
local/directfb/lib/pkgconfig/libpng.pc
local/directfb/lib/pkgconfig/nexus-mgr.pc
local/directfb/lib/pkgconfig/freetype2.pc
local/directfb/lib/pkgconfig/libpng14.pc
local/directfb/lib/pkgconfig/directfb.pc
local/directfb/lib/pkgconfig/direct.pc
local/directfb/lib/pkgconfig/nexusMgr.pc
local/directfb/lib/pkgconfig/uuid.pc
local/directfb/lib/pkgconfig/fusion.pc
local/directfb/lib/pkgconfig/directfb-internal.pc
local/directfb/lib/pkgconfig/sawman.pc
local/directfb/lib/pkgconfig/nexus.pc
local/lib/pkgconfig/libpng.pc
local/lib/pkgconfig/nexus-mgr.pc
local/lib/pkgconfig/freetype2.pc
local/lib/pkgconfig/libpng14.pc
local/lib/pkgconfig/directfb.pc
local/lib/pkgconfig/direct.pc
local/lib/pkgconfig/nexusMgr.pc
local/lib/pkgconfig/uuid.pc
local/lib/pkgconfig/fusion.pc
local/lib/pkgconfig/directfb-internal.pc
local/lib/pkgconfig/sawman.pc
local/lib/pkgconfig/nexus.pc


={============================================================================
*kt_dev_uv_stack_005* stack: brcm debug level

Invalid level. Should be: err, wrn, msg or none.
echo "nexusMgr msg" >> /proc/brcm/debug


={============================================================================
*kt_dev_uv_stack_006* stack: netflix ps line

16386     1518 66.4 30.2 229456 97392 ?        Sl   14:45   1:03 /opt/netflix/netflix
--write-data-path /app-data/var --cache-path /app-data/cache --disk-cache-path
/app-data/var/nrd/gibbon --user-agent YouViewPlayer4/1.0 (Huawei Technologies Co., Ltd;
    DN370T.02.02.T; 001; CDS/70.37.05; API/2.9.1; PS/2.9.6) (+DVR+FLASH+HTML+MHEG+IPCMC)
--dpi-friendlyname YouView-0067 --device-model YouView_DN370T --esn
YVWTTGD370-9cac040a-6397-4bbd-a0dd-61743837e958 --mdx-manufacturer Huawei Technologies Co., Ltd
--mdx-model-name YouView_DN370T --software-version 70.37.05 --no-mdx
--ui-query-string=source_type=2&trackId=13783779&trackUrl=https%3A%2F%2Fapi.netflix.com%2FBaSePaTh%3Fpage%3DMetaSearch%3F


={============================================================================
*kt_dev_uv_stack_007* stack: virtual rcu

https://wiki.youview.co.uk/display/canvas/2012/04/23/Automating+input+to+the+UI?src=search

<hwei-case>
scp libyouviewrcu.so root@172.20.33.192:/opt/zinc/lib
scp libyouviewrcushim.so root@172.20.33.192:/usr/local/lib/directfb-1.4-15/inputdrivers/
scp libyouviewrcushim.so root@172.20.33.192:/opt/zinc/oss/lib/directfb-1.4-15-pure/inputdrivers/
scp zinc-send-key-hwei root@172.20.33.192:/usr/local/bin

note: no need to build drivers for hwei. Simply use humax binary which are pre-built.

note: the difference is whether use host nc or busybox nc

# to run it on the box
$ scp zinc-send-input-key root@172.20.33.192:/usr/local/bin

printf "D\t${key}\n\0U\t${key}\n\0" | /opt/zinc/oss/bin/busybox nc $box_ip $box_port


# to run it on the host
./zinc-send-input.sh page_up 172.20.33.192 2033

note: cannot use it on host since nc failed. seems that there is firewall settings on a target. so
run it on a target.


<keys>
See this for other keys:
https://svn.youview.co.uk/Canvas/Documents/Presentation.Technology/trunk/2105-S%20Flash%20Presentation%20Engine%20Integration%20Specification%20v1.1E%20tracked.pdf

menu                             YouView
page_up                          Channel Up
page_down                        Channel Down
escape                           Close
cursor_up/down/left/right        
ok                               Enter
back                             Back


<to-check>
1007 ?        Sl     0:06 /usr/local/bin/directfb/1.4/dfbmaster

root# cat /proc/1007/maps | grep youview
-3731c000 r-xp 00000000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3732c000 r--p 00000000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3732d000 rw-p 00001000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3754c000 r-xp 00000000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so
-37568000 r--p 00097000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so
-3756a000 rw-p 000a4000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so

root# printf "D\tMENU\n\0U\tMENU\n\0" | /opt/zinc/oss/bin/busybox nc localhost 2033

note: The latest eng release from huawei do not load these so. So do not work.


={============================================================================
*kt_dev_uv_stack_008* stack: startup mw

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin/yv-start-services.sh

#!/bin/sh

prefix="/opt/zinc-trunk"

start() {
    echo "Starting $1"
    "${prefix}/bin/start-service-over-dbus.sh" "$@"
}

start Zinc.DIAL
start Zinc.Crb

exit 0


/opt/zinc-trunk/bin$ cat start-service-over-dbus.sh 
#!/bin/bash

#
# Launch a dbus service using dbus activation
#
# Author: morgan.henry@youview.com
#

#
# Usage: ./start-service-over-dbus.sh Zinc.Metadata [ --requires Zinc.System ]
#

busname=$1

if [[ $2 == "--requires" ]]; then
	# If we know the service we are about to start requires some other service
	# that has an initialisation period that is potentially greater that the dbus method_call timeout
	# then we can explicitly wait for the required service to start
	# This should be avoided where possible, since it is sub-optimial
	requires=$3
	dbuswaitbusname --timeout 30 $requires
fi

# Send a ping to a known dbus service daemon to cause dbus activation trigger daemon launch
dbus-send --session --type=method_call --print-reply --dest=$busname / org.freedesktop.DBus.Peer.Ping &


{nickelmediad} {onscreenidd}
/source/DEVARCH/Nickel/NickelOnScreenId.System.DBusServer/Makefile.am
bin_PROGRAMS = \
	onscreenidd

/source/DEVARCH/Nickel/Nickel.System.DBusServer/Makefile.am
bin_PROGRAMS = nickelmediad

/source/DEVARCH/Nickel/Nickel.System.DBusServer/src/MediaDaemon.cpp

int main(int argc, char *argv[]) {
  NICKEL_INFO("Launching Fake Media Router Service Daemon...");
  int result = EXIT_SUCCESS;

  try {
    MainLoop mainloop(BusName::MEDIA);
    MediaDaemon daemon(mainloop);
    mainloop.post(boost::bind(&MediaDaemon::start, &daemon, argc, argv));
    result = mainloop.run();
  } catch (std::exception& e) {
    std::cerr << e.what() << endl;
    result = EXIT_FAILURE;
  }

  NICKEL_INFO("Fake Media Router Service Daemon shutting down...");
  return result;
}


={============================================================================
*kt_dev_uv_stack_009* zinc-lsr: keys

[root@HUMAX /]# getItem oem.device.model.variantââââ
oem.device.model.variant=80B07002

[From wiki]
CTK = 80B07001
ATK = 80B07002

[root@HUMAX /]# getItem oem.device.duid
oem.device.duid=DCD321-DTRT1000-0102bb

Element
LSR Key
Make              oem.name
Model             oem.device.model.name
ModelVariant      oem.device.model.variant

CDS/<version> Current version of the Core Device Software.
oem.activatedsoftware.coredevicesoftware.version

API/<version> Current supported version of the YouView API.
oem.activatedsoftware.coredevicesoftware.platformapiversion

PS/<version> Current version of the Platform Software.
oem.activatedsoftware.platformsoftware.version

+DVR Device supports DVR functionality (as defined by D-Book) 
oem.device.capabilities.dvr.available

+DL Device supports file download
oem.device.capabilities.download.available

+FLASH Device is able to execute Flash applications
oem.device.capabilities.flash.available

+HTML Device is able to execute HTML5 applications 
oem.device.capabilities.html.available

+MHEG Device is able to execute MHEG applications
oem.device.capabilities.mheg.available


[root@HUMAX /]# getChildItems.oem | grep oem.    

oem.activatedsoftware.coredevicesoftware.platformapiversion=2.11.2
oem.activatedsoftware.coredevicesoftware.version=23.5.0
oem.activatedsoftware.ispconfiguration.version=10004
oem.activatedsoftware.manufacturerconfiguration.version=1
oem.activatedsoftware.platformconfiguration.version=1507
oem.activatedsoftware.platformsoftware.version=2.11.13
oem.apps.netflix.esn.prefix=YVWBT-DT20
oem.device.broadcast.imagedirectory=/mnt/hd6/rct
oem.device.capabilities.audiofeedback.available=1
oem.device.capabilities.download.available=0
oem.device.capabilities.dvr.available=1
oem.device.capabilities.flash.available=1
oem.device.capabilities.html.available=1
oem.device.capabilities.ipchannels.available=1
oem.device.capabilities.ipchannelsmulticast.available=1
oem.device.capabilities.ipchannelsunicast.available=0
oem.device.capabilities.mheg.available=1
oem.device.capabilities.rfloopthrough.available=1
oem.device.capabilities.uhd.available=0
oem.device.dtt-tuner-count=2
oem.device.duid=0000DB-DTRT2100-06021c
oem.device.ip-tuner-count=3
oem.device.model.basename=DTRT2100
oem.device.model.name=DTRT2100
oem.device.model.variant=84B08502
oem.device.provideridentifier=com.humaxdigital
oem.device.serialnumber=+077329+1434000028
oem.device.state.currenttimesource=BROADCAST
oem.linearacquisition.maindecodertype=0
oem.linearacquisition.max-concurrent-acquisitions=2
oem.linearacquisition.max-concurrent-scheduled-recordings=2
oem.model=DTRT2100-atk
oem.name=Humax
oem.oui=0000DB
oem.rc.assigned.service=YouView
oem.rc.description=YouView Set Top Box
oem.rc.device.status=Disabled
oem.rc.model.nationality=GB
oem.rc.model.operator=BT
oem.rc.nemo.id=urn:marlin:organization:seacert:BT-plc:clientnemo:06021a
oem.rc.swupdate=1
oem.software.autocheck.starttime=%DATESat Oct 24 01:33:05 2015
oem.software.coredevicesoftware.manifest.baseurl=http://test.humaxtvportal.com/SWUpdate
oem.software.coresoftware.upgrade.prefix=DTR-T2100_CDS
oem.software.downloader-connection-timeout-seconds=10
oem.software.downloader-low-speed-limit-bytespersecond=1
oem.software.downloader-low-speed-time-seconds=10
oem.software.downloader-overall-timeout-seconds=1200
oem.software.ispconfig.version=0
oem.software.manufacturerconfig.version=0
oem.software.platformapi.version=0.11.0
oem.software.platformconfig.version=1
oem.uimanagement.suspendmheginpig=true
oem.usergroups=http://refdata.youview.com/mpeg7cs/YouViewApplicationPlayerCS/2011-10-26#html5 http://refdata.youview.com/mpeg7cs/YouViewApplicationPlayerCS/2014-02-26#custom http://refdata.youview.com/mpeg7cs/YouViewApplicationPlayerCS/2015-06-05#html5+dash+pdl
oem.vendorid=HMX
platform.softwaremanagement.oemconfiguration.updatepolicy=normal
platform.softwaremanagement.oemsoftware.updatepolicy=normal


={============================================================================
*kt_dev_uv_stack_010* stack: commit

DEVARCH-XXX: Single line brief description of what this does or fixes.

High level description of what this commit fixes. Give the "why" without
going into too much implementation detail. Could be readable by DME,
OEMs and others who don't have intimate knowledge of the code.

Some more detail about what you've done. Useful for future reference
and for those with more technical knowledge.

- Possibly some bullet points if the commit touched a few different
  things.

Keep all but the first line to <80 chars. If the first line has to be very long to say what the
commit does, then you're probably trying to put too much into one commit. Commits should be "unixy"
- do only one thing and do it well. Here's the wiki page I mentioned previously:

https://wiki.youview.co.uk/display/testautomation/Zinc+Coding+guidelines?src=search#ZincCodingguidelines-Gitcommits

<commit-log>
DEVARCH-8092: the proposed nexus tools and interface to nexusMgr

There is no nexus-inspect for Huawei which is used to release all nexus resources when an
application exits abnormally.

The both OEMs have different nexusMgr implementations and the current nexus-inspect is tightly
coupled with nexusMgr implementation which is private and OEM dependant as described in
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

Therefore, these commits introduce a separation between inspection and releasing and OEMs and
Youview, propose new APIs, and shows a working implementation in order to make them to deliver the
updated nexusMgr as soon.
  
To use this commit, may use the revised nexusMgr from OEMs which is subject to future delivery from
OEMs according to this proposal.

<log>
DEVARCH-7508: Vanadium.W3CEngine.test: Fix runbrowser-test.sh

The cause of the problem is that the cache size is introduced in the
runBrowser.sh[1] but not in the runBrowser-test.sh. Hence mismatch which causes
this failure.

As with runBrower.sh, this commit fixes the problem by looking up the cache size
or silently continuing if it hasn't been set from LSR key
`platform.settings.html-app-cache-size` and so the behaviour shouldn't be
surprising.

[1] See DEVARCH-7362, commit cddb793

$ zg-jira-request-review DEVARCH-7508_1 b6157860ac9fbc1d54bb48820b2f2ed7d662c094^1..b6157860ac9fbc1d54bb48820b2f2ed7d662c094

<log>
YVHUAWEI-6095: Add the latest nexusMgr from Huawei

This is the latest which fixes kernel Oops when an application exits abnormally and is delivered via
this Jira ticket. 


<commit-log> for the nexusMgr proposal
DEVARCH-8092: the proposed nexusMgr for Huawei dn370t

The both OEMs have different nexusMgr implementations and the current nexus-inspect is tightly
coupled with nexusMgr implementation which is private and OEM dependant as described in
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

Therefore, this commit proposes a working implementation to introduce a separation between
inspection and releasing and OEMs and YouView, and propose PID check and new APIs to support these.


<commit-log>
<1>
DEVARCH-8092: Add the nexus inspect to the build for Huawei dn370t

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus utility project to the build for Huawei dn370t. 

<2>
DEVARCH-8092: Add the nexus release tool and revise the exec wrapper

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus release which is revised to use the proposed APIs to release nexus
resources and the updated exec wrapper to use the same.

<3>
DEVARCH-8092: Add the nexus inspect tool

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus inspect which uses the proposed APIs to show information of nexus
resources.

<4>
DEVARCH-8092: Change makefile to build nexus utility

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit has the necessary changes of makefile to build nexus utility and to fix the link order
problem when links with nexusMgr shared library.


<stash>
~/source/DEVARCH$ git push origin DEVARCH-9135:review/DEVARCH-9135/0


={============================================================================
*kt_dev_uv_stack_011* zinc-log

{from-proc}
As an example, can work out log file from fd info:

root       793  0.7  1.0  25528  4176 ?        Sl   16:04   0:00 
  /opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO

# ll /proc/793/fd
fd/     fdinfo/ 

# ll /proc/793/fd/
dr-x------    2 root     root           0 Feb 16 16:06 ./
dr-xr-xr-x    6 root     root           0 Jan  1  2000 ../
lr-x------    1 root     root          64 Feb 16 16:06 0 -> /dev/null
l-wx------    1 root     root          64 Feb 16 16:06 1 -> /var/tmp/NetworkManager.log
lrwx------    1 root     root          64 Feb 16 16:06 10 -> /dev/nexus_astm
lrwx------    1 root     root          64 Feb 16 16:06 11 -> /dev/nexus_display
lrwx------    1 root     root          64 Feb 16 16:06 12 -> /dev/nexus_graphics2d
lrwx------    1 root     root          64 Feb 16 16:06 13 -> /dev/nexus_surface
lrwx------    1 root     root          64 Feb 16 16:06 14 -> /dev/nexus_audio
lrwx------    1 root     root          64 Feb 16 16:06 15 -> /dev/nexus_video_decoder
lrwx------    1 root     root          64 Feb 16 16:06 16 -> /dev/nexus_transport
lrwx------    1 root     root          64 Feb 16 16:06 17 -> /dev/nexus_dma
lrwx------    1 root     root          64 Feb 16 16:06 18 -> /dev/nexus_security
lrwx------    1 root     root          64 Feb 16 16:06 19 -> /dev/nexus_spi
l-wx------    1 root     root          64 Feb 16 16:06 2 -> /var/tmp/NetworkManager.log
lrwx------    1 root     root          64 Feb 16 16:06 20 -> /dev/nexus_frontend
lrwx------    1 root     root          64 Feb 16 16:06 21 -> /dev/nexus_keypad
lrwx------    1 root     root          64 Feb 16 16:06 22 -> /dev/nexus_rfm
lrwx------    1 root     root          64 Feb 16 16:06 23 -> /dev/nexus_uhf_input
lrwx------    1 root     root          64 Feb 16 16:06 24 -> /dev/nexus_input_capture
lrwx------    1 root     root          64 Feb 16 16:06 25 -> /dev/nexus_ir_blaster
lrwx------    1 root     root          64 Feb 16 16:06 26 -> /dev/nexus_ir_input
lrwx------    1 root     root          64 Feb 16 16:06 27 -> /dev/nexus_led
lrwx------    1 root     root          64 Feb 16 16:06 28 -> /dev/nexus_gpio
lrwx------    1 root     root          64 Feb 16 16:06 29 -> /dev/nexus_i2c
lr-x------    1 root     root          64 Feb 16 16:06 3 -> pipe:[548]|
lrwx------    1 root     root          64 Feb 16 16:06 30 -> /dev/nexus_pwm
...

cat /var/tmp/NetworkManager.log


{refs}
https://wiki.youview.co.uk/display/canvas/Zinc+Logging+Framework

<config-and-use>
/opt/zinc-trunk/share

# find . -name *.props

./arsenic-common/arsenic.props
./californium-common/californium.props
./osmium-common/osmium.props
./cadmium-common/cadmium.props
./zinc-common/zinc.common.props
./zinc-common/zinc.common-remote.props
./iron-common/iron.props
./lead-common/lead.props
./zinc-http-dbusbridge/log4cplus.props
./copperannouncement-common/copperannouncement.props
./cobalt-common/cobalt.props
./neon-common/neon.props
./vanadium-common/vanadium.props
./mercury-common/mercury.props
./copperdownloader-common/copperdownloader.props
./titanium-common/titanium.props
./sodium-common/sodium.props
./copper-common/copper.props
./nickel-common/nickel.props
./helium-common/helium.props
./radium-common/radium.props
./rubidium-common/rubidium.props
./uranium-common/uranium.props


[root@HUMAX share]# cat ./nickel-common/nickel.props
log4cplus.logger.nickel=INFO, STDERR, nickelfile

log4cplus.appender.nickelfile=log4cplus::RollingFileAppender
log4cplus.appender.nickelfile.File=/opt/zinc-trunk/var/log/nickel.log
log4cplus.appender.nickelfile.layout=log4cplus::PatternLayout
log4cplus.appender.nickelfile.layout.ConversionPattern=%D{%Y-%m-%d %H:%M:%S,%q} %-5p %x %t %c %l %m%n


/zinc-install-root/debug/debian-7-x86_64/share/uranium-common/uranium.props

log4cplus.logger.uranium=TRACE, uraniumfile

log4cplus.appender.uraniumfile=log4cplus::RollingFileAppender
log4cplus.appender.uraniumfile.File=/home/kpark/builds/_virtual_/pc/zinc-install-root/debug/debian-7-x86_64/var/log/uranium.log
log4cplus.appender.uraniumfile.layout=log4cplus::PatternLayout
log4cplus.appender.uraniumfile.layout.ConversionPattern=%D{%Y-%m-%d %H:%M:%S,%q} %-5p %x %t %c %l %m%n


note: can override settings

export URANIUM_LOGGING_RULE="DEBUG, uraniumfile"      // not work
export URANIUM_LOGGING_RULE="DEBUG,uraniumfile"       // not work
export URANIUM_LOGGING_RULE="TRACE,STDOUT"            // work
./systemmediarecordcachetest 


Canvas Core C++ components use the log4cplus.sourceforge.net project. 

#define ZINC_DECLARE_LOGGER(name) \
    namespace name { \
        namespace detail { \
            ZINC_EXPORT extern log4cplus::Logger* logger; \
            ZINC_EXPORT log4cplus::Logger& getLoggerFallback(); \
        } \
    }


{use-in-code}

Nickel/Nickel.Common/include/NickelLogger.h

#ifndef NICKEL_COMMON_NICKELLOGGER_H_
#define NICKEL_COMMON_NICKELLOGGER_H_

#include "macros.h"

#include <zinc-common/Logger.h>

ZINC_DECLARE_LOGGER(nickel);

#define NICKEL_FUNC_TRACE ZINC_FUNC_TRACE(ZINC_GET_LOGGER(nickel))
#define NICKEL_FUNC_DEBUG ZINC_FUNC_DEBUG(ZINC_GET_LOGGER(nickel))

#define NICKEL_SCOPE_TRACE(a) ZINC_SCOPE_TRACE(ZINC_GET_LOGGER(nickel), a)
#define NICKEL_SCOPE_DEBUG(a) ZINC_SCOPE_DEBUG(ZINC_GET_LOGGER(nickel), a)

#define NICKEL_TRACE(a) ZINC_TRACE(ZINC_GET_LOGGER(nickel), a)
#define NICKEL_DEBUG(a) ZINC_DEBUG(ZINC_GET_LOGGER(nickel), a)
#define NICKEL_INFO(a) ZINC_INFO(ZINC_GET_LOGGER(nickel), a)
#define NICKEL_WARN(a) ZINC_WARN(ZINC_GET_LOGGER(nickel), a)
#define NICKEL_ERROR(a) ZINC_ERROR(ZINC_GET_LOGGER(nickel), a)
#define NICKEL_FATAL(a) ZINC_FATAL(ZINC_GET_LOGGER(nickel), a)

#endif


std::vector<boost::filesystem::path> findMediaRouterPluginConfigFiles(const std::string& configDir) {
   NICKEL_FUNC_TRACE;
   ...
}

2015-06-09 15:01:21,298 TRACE  715849728 nickel
/home/kpark/builds/_virtual_/humax.1000/DEVARCH/Nickel/Nickel.System.Proxy/src/ProxySystemFactory.cpp:50
ENTER: std::vector<boost::filesystem::basic_path<std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >, boost::filesystem::path_traits>,
    std::allocator<boost::filesystem::basic_path<std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >, boost::filesystem::path_traits> > >
nickel::system::findMediaRouterPluginConfigFiles(const std::string&)

2015-06-09 15:01:21,300 TRACE  715849728 nickel
/home/kpark/builds/_virtual_/humax.1000/DEVARCH/Nickel/Nickel.System.Proxy/src/ProxySystemFactory.cpp:50
EXIT:  std::vector<boost::filesystem::basic_path<std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >, boost::filesystem::path_traits>,
    std::allocator<boost::filesystem::basic_path<std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >, boost::filesystem::path_traits> > >
nickel::system::findMediaRouterPluginConfigFiles(const std::string&)


{application-log}
https://wiki.youview.co.uk/display/canvas/Debugging+Issues+on+a+Device+Emporium

Applications like the main UI or OnDemand players live in a different place:
# Main UI logs on an integrated build:
/opt/zinc/var/applications/data/air/mainui/log/
 
# BBC apps logs on an integrated build:
/opt/zinc/var/applications/data/air/31c5e1725fb42bc769224449ebe0e6464cb6304acba079d0e5c4b59768cb9331/log/
 
# Main UI logs on a patch-o-tron build:
/opt/zinc-trunk/var/applications/data/air/mainui/log/


{pc-build-log}
/home/kpark/builds/topic/pc/zinc-install-root/release/debian-7-x86_64/
share/vanadium-common/vanadium.props

/home/kpark/builds/topic/pc/zinc-install-root/release/debian-7-x86_64/var/log


={============================================================================
*kt_dev_uv_stack_012* stack: gdb

#debug "Installing gdb..."
#installTool mipsgdb.tar
#installTool mipsgdb-libthread.tar
# Set up a useful symlink so "gdb" and "gdbserver" are on the usual PATH.
#$ssh 'ln -sf /opt/zinc/oss/debugtools/bin/gdb* /usr/local/bin/'

wget http://devnfs2.dev.youview.co.uk/DEVARCH/tools-huawei/huawei-bcm7409/mipsgdb.tar
wget http://devnfs2.dev.youview.co.uk/DEVARCH/tools-huawei/huawei-bcm7409/mipsgdb-libthread.tar

#/   -T <tools>    Install the given tool (or tools) on the box. Multiple tools
#/                 can be passed by passing a comma-separated list:
#/                     eg. '-T tool1,tool2'
#/                 Tar files are also accepted (but not zipped tars).
#/                 A full list of available tools can be seen at:
#/                     http://devnfs/DEVARCH/tools-huawei/.


{huawei}
$ ./setup-huawei.sh -T mipsgdb.tar 172.20.33.192
failed to create pid file /run/rsyncd.pid: File exists

Untaring and installing tool: mipsgdb.tar...
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 40.4M  100 40.4M    0     0   103M      0 --:--:-- --:--:-- --:--:--  104M
sending incremental file list
./
rsync: failed to set times on "/." (in Root): Read-only file system (30)
opt/
opt/zinc/
opt/zinc/oss/
opt/zinc/oss/debugtools/
opt/zinc/oss/debugtools/bin/
opt/zinc/oss/debugtools/bin/gdb
opt/zinc/oss/debugtools/bin/gdbserver
opt/zinc/oss/debugtools/bin/run
opt/zinc/oss/debugtools/include/
opt/zinc/oss/debugtools/include/ansidecl.h
opt/zinc/oss/debugtools/include/bfd.h
opt/zinc/oss/debugtools/include/bfdlink.h
opt/zinc/oss/debugtools/include/dis-asm.h
opt/zinc/oss/debugtools/include/symcat.h
...
sent 42365871 bytes  received 1528 bytes  6518061.38 bytes/sec
total size is 42355143  speedup is 1.00

{humax}
http://devnfs/DEVARCH/tools-humax/

mipsgdb-7.9.tar

setup-humax.sh -T mipsgdb-7.9.tar 172.20.32.34 

{}
cmd="gdb --args /opt/zinc-trunk/oss/bin/gst-launch-1.0 $gst_opts $pipeline"

echo
echo "Executing:"
echo $cmd

[ -n "$env_vars" ] && echo "Additional environment variables: ${env_vars[@]}"

ulimit -c unlimited
env ${env_vars[@]} $cmd


={============================================================================
*kt_dev_uv_stack_013* stack: platform data

Nickel/Nickel.System.Proxy/data/Makefile.am
1:platformdatadir=$(datadir)/platform_data/mediarouter-plugin-config

[root@HUMAX share]# pwd
/opt/zinc-trunk/share

[root@HUMAX share]# ll platform_data/
drwxrwxr-x   12 1024     1025        4.0K Jun  2 12:10 ./
drwxrwxr-x  125 1024     1025        4.0K Jun  2 12:10 ../
drwxrwxr-x    2 1024     1025        4.0K Jun  2 11:39 copperannouncement-system-production/
drwxrwxr-x    3 1024     1025        4.0K Jun  2 11:56 helium-system-production/
drwxrwxr-x    2 1024     1025        4.0K Jun  2 11:52 mediarouter-plugin-config/
drwxrwxr-x    2 1024     1025        4.0K Jun  2 12:10 mercury-system-uimanager/
drwxrwxr-x    2 1024     1025        4.0K Jun  2 11:56 nickel-linear-source/
drwxrwxr-x    7 1024     1025        4.0K Jun  2 12:03 python/
drwxrwxr-x    3 1024     1025        4.0K Jun  2 12:03 sodium-air-client-api/
drwxrwxr-x    5 1024     1025        4.0K Jun  2 12:00 stagecraft2-extensions/
drwxrwxr-x    2 1024     1025        4.0K Jun  2 11:50 zinc-http/
drwxrwxr-x    2 1024     1025        4.0K Jun  2 11:51 zinc-http-cache/


={============================================================================
*kt_dev_uv_stack_014* zinc-test

  --cases arg            Specify which test cases to run.  This is a whitespace
                         seperated list of test cases
  --list-cases           List the cases that would be run rather than 
                         runningthem

{test-run-single}
/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/
    Uranium/Uranium.Client.System/test/metadata


./systemclienteventrepositorytest 
  --cases SystemClientEventRepositoryTest::testGetSynopsis


NICKEL_LOGGING_RULE="TRACE,STDOUT" ./test/gstmediaroutertest 
  --cases nickel::system::GstMediaRouterTest::test_WrongType


CPPUNIT_TEST_SUITE(GstMediaRouterTest);
This leads to the test binary name

CPPUNIT_TEST(test_thatCallingSetSinkTwiceThrowsIllegalConfigurationException);
This leads to the each test case name


note: must be in zb-shell and be in the 'right' target such as pc.

09:29:10 ~/builds/_virtual_/pc/zinc-build-root/release-debian-7-x86_64/Nickel/Nickel.System.GStreamer/test$ ./gstmediaroutertest --list-cases
All Tests
	nickel::system::GstMediaRouterTest
		nickel::system::GstMediaRouterTest::test_thatCallingSetSinkTwiceThrowsIllegalConfigurationException
      ...
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeWrongType
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeDecode
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeEncode
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeDemux
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeMux
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeFormat
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeDecrypt
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeDecryptNoKey
		nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeAnyOther
		nickel::system::GstMediaRouterTest::test_thatUnderflowNexussinkWarningGeneratesMediaRouterStatusEvents
		nickel::system::GstMediaRouterTest::test_thatSeekDoesntGenerateMediaRouterStatusEventUnderflow
		nickel::system::GstMediaRouterTest::test_thatMp4PlaybackGeneratesHealthySignals
		nickel::system::GstMediaRouterTest::test_thatSetVideoWindowAndGetVideoWindowMatchUp_afterMediaRouterHasStarted
		nickel::system::GstMediaRouterTest::test_thatSetVideoWindowAndGetVideoWindowMatchUp_whenMediaRouterIsStarted
		nickel::system::GstMediaRouterTest::test_thatSetVideoWindowAndGetVideoWindowMatchUp_beforeMediaRouterHasStarted


={============================================================================
*kt_dev_uv_stack_014* zinc-test-support

VERIFY_AND_CLEAR_MOCK   66 Zinc/Zinc.Common/include/testsupport/VerifyAndClearMock.h #define VERIFY_AND_CLEAR_MOCK(mock) NS_ZINC::verifyAndClearMock( mock, #mock, __LINE__ )

verifyAndClearMock   28 Zinc/Zinc.Common/include/testsupport/VerifyAndClearMock.h void verifyAndClearMock( T* mock, const std::string& mockVarName, int linenum )
verifyAndClearMock   42 Zinc/Zinc.Common/include/testsupport/VerifyAndClearMock.h void verifyAndClearMock( boost::shared_ptr< T > mock,


={============================================================================
*kt_dev_uv_stack_100* stack: elememt names

element or component names
https://wiki.youview.co.uk/display/canvas/YouView+Element+Names?src=search

Cobalt   Enhanced metadata (IP sourced) Zinc.Broker 
Iron     Linear metadata (Broadcast sourced) Zinc.Metadata 


={============================================================================
*kt_dev_uv_stack_101* zinc-plugin: plugin and client system

   UI runtimes (EPG, stagecraft(air), etc)
   --------------------------------------- 
      XXX.YYY.Client.API (Uranium.AIR.Client.API)
   ---------------------------------------
         XXX.Client.API     (Uranium.Client.API), API interface
         XXX.Client.System  (Uranium.Client.System), ClientFactory
                            ( Dbus client factories..)

This is directory structure:

Uranium.AIR.Client.API/
Uranium.Client.API/
Uranium.Client.System/
Uranium.Common/


{plugin-mechanism}

1. UI get a SystemClientFactory of a component

All component provides the same "createSystemClientFactory" global function
which is out of a namespace and UI can get this via *plugin-mechanism* see
plugin for more. 

This means that UI makes PluginConfig which set config filename and calls
<get-instance> to get T* derived from Plugin. 

Uranium.AIR.Client.API/data/client-factory.plugin-config:
  libUraniumClientSystem.so createSystemClientFactory

  // This call is global since it is out of a namespace.
  // Uranium.Client.System/src/SystemClientFactory.cpp

  Plugin* createSystemClientFactory() {
    URANIUM_PROFILE_FUNC;
    return 'new' NS_URANIUM_CLIENT::SystemClientFactory();
  }


note:
Each ClientFactory for each component derives from "Plugin", plugin mechanism
calls create function, maiantain derived T*.

// Uranium/Uranium.Client.API/include/ClientFactory.h

struct ZINC_EXPORT ClientFactory : virtual public NS_ZINC::Plugin {

    /**
     * IP Metadata factory methods.
     */
    virtual boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> 
      createMetadataLocator() = 0;

    virtual boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataBroker> 
      createMetadataBroker() = 0;

    virtual boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::EventRepository> 
      createEventRepository() = 0;

    virtual boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> 
      createServiceRepository() = 0;

    virtual boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ParamFactory> 
      createParamFactory() = 0;

    /**
     * Linear Metadata factory methods.
     */

    virtual boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::Locator> 
      createLinearMetadataLocator() = 0;

    ...
};

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable {
    ...
};



UI gets shared pointers of each necessary component using factory create functions.

// Uranium.AIR.Client.API/src/UraniumAirPlugin.cpp

note: Binding. 
Not sure how
NS_URANIUM_LINEAR_AIR_CLIENT::LocatorBinding::setSingletonInstance() is
implemented since there is no source and appears that it is generated by binding
tool. Assumes that this saves a shared pointer of each component locator and
uses it to call apis.

class ZINC_LOCAL UraniumAirPlugin : public GenericAirPlugin<UraniumAirPlugin, ClientFactory> 
{
  void initSingletons(ClientFactory& clientFactory) 
  {
    // create <MD>, save it in its locator and return it back to UI
    shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> nativeLocator(
        clientFactory.createMetadataLocator()
        );

    NS_URANIUM_METADATA_AIR_CLIENT::LocatorBinding::setSingletonInstance(nativeLocator);

    // create <LMD>
    NS_URANIUM_LINEAR_AIR_CLIENT::LocatorBinding::setSingletonInstance(
        clientFactory.createLinearMetadataLocator());

    // get LMLL(locator) and pass up to client application. see factory below
    NS_URANIUM_LML_AIR_CLIENT::LocatorBinding::setSingletonInstance(
        clientFactory.createLocalMediaLibraryLocator());
  }
};

<3> Locators 

note: singleton and factory
Each create function is a factory function: create a singletone locator instance
of each component and this locator has member functions to get a shared pointer
of each interface. So the locator is a container to pack shared pointers to
interfaces and return a shared pointer of this locator to UI.

note:
Each interface(component) defines 'own' locator class chain and how it is
possible? Use namespace.

/Uranium.Client.API/include/local-media-library/Locator.h
/Uranium.Client.API/include/linear-acquisition/Locator.h
/Uranium.Client.API/include/linear-metadata/Locator.h
/Uranium.Client.API/include/metadata/Locator.h
/Uranium.Client.API/include/tuner/Locator.h

/Uranium.Client.System/src/local-media-library/SystemClientLocator.h
/Uranium.Client.System/src/linear-acquisition/SystemClientLocator.h
/Uranium.Client.System/src/linear-metadata/SystemClientLocator.h
/Uranium.Client.System/src/metadata/SystemClientLocator.h
/Uranium.Client.System/src/tuner/SystemClientLocator.h

This is metadata case.

NS_URANIUM_METADATA_CLIENT_OPEN

/**
 * This is the top-level entrypoint to the Zinc Client API.
 * A singleton instance will likely be exposed in the global
 * context within the Javascript environment. An Actionscript
 * binding will be newed in the Flash case.
 */
class ZINC_EXPORT Locator : public NS_ZINC::Polymorphic {

public:
    virtual ~Locator();
    virtual boost::shared_ptr<MetadataBroker> getMetadataBroker() const = 0;
    virtual boost::shared_ptr<EventRepository> getEventRepository() const = 0;
    virtual boost::shared_ptr<ServiceRepository> getServiceRepository() const = 0;
};

class SystemClientLocator : virtual public Locator {

  public:
    SystemClientLocator(boost::shared_ptr<MetadataBroker> metadataBroker, 
        boost::shared_ptr<EventRepository> er, boost::shared_ptr<ServiceRepository> sr);

    boost::shared_ptr<MetadataBroker> getMetadataBroker() const;
    virtual boost::shared_ptr<EventRepository> getEventRepository() const;
    virtual boost::shared_ptr<ServiceRepository> getServiceRepository() const;

  private:
    boost::shared_ptr<MetadataBroker> metadataBroker;
    boost::shared_ptr<EventRepository> eventRepository;
    boost::shared_ptr<ServiceRepository> serviceRepository;
};


={============================================================================
*kt_dev_uv_stack_102* zinc-plugin: plugin and dbus client

{dbus-system-factory}
This is uranium case and see that client system uses plugin mechanism to use
DBUS.

/Uranium/Uranium.Client.System/data$

cadmium-system-factory.plugin-config:
  libCadmiumSystemDbusClient.so createDbusSystemFactory

cobalt-system-factory.plugin-config:
  libCobaltSystemDbusClient.so createDbusSystemFactory

copper-system-factory.plugin-config:
  libCopperSystemDbusClient.so createDbusSystemFactory

ironreminders-system-factory.plugin-config:
  libIronRemindersSystemDbusClient.so createDbusSystemFactory

iron-system-factory.plugin-config:
  libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)

note: why is this "MetadataProxy" but not "Metadata"?

neon-client-factory.plugin-config:
  libNeonClientSystem.so createSystemClientFactory

nickel-system-factory.plugin-config:
  libNickelSystemDbusClient.so createDbusSystemFactory


note:
The system factory can be replaced with a fake by simply changing plugin config
which is flexible.

Uranium.Client.System/data/cobalt-system-factory.plugin-config:
  libCobaltSystemDbusClient.so createDbusSystemFactory
  #libCobaltSystemFake.so createFakeSystemFactory


note: dbus-client
This is a client interface for a component that can be used by others.

No code in source tree and these are 'generated'.

:~/builds/master/humax.1000/zinc-build-root/release-humax-dtr_t1000$ find . -name unity.cpp
./Helium/Helium.System.DBusClient/src/unity.cpp
./Helium/Helium.System.API/src/unity.cpp
./Lead/Lead.System.API/src/unity.cpp
./Lead/Lead.System.DBusClient/src/unity.cpp
./Copper/CopperAnnouncement.System.API/src/unity.cpp
./Copper/CopperAnnouncement.System.DBusClient/src/unity.cpp
./Copper/Copper.System.API/src/unity.cpp
./Copper/Copper.System.DBusClient/src/unity.cpp
./Sodium/Sodium.System.API/src/unity.cpp
./Sodium/Sodium.System.DBusClient/src/unity.cpp
./Radium/Radium.System.API/src/unity.cpp
./Radium/Radium.System.DBusClient/src/unity.cpp

./Iron/IronReminders.System.DBusClient/src/unity.cpp
./Iron/IronReminders.System.API/src/unity.cpp
./Iron/Iron.System.API/src/unity.cpp
./Iron/Iron.System.DBusClient/src/unity.cpp

./Cadmium/Cadmium.System.API/src/unity.cpp
./Cadmium/Cadmium.System.DBusClient/src/unity.cpp
./Rubidium/Rubidium.System.DBusClient/src/unity.cpp
./Rubidium/Rubidium.System.API/src/unity.cpp
./Osmium/Osmium.System.API/src/unity.cpp
./Osmium/Osmium.System.DBusClient/src/unity.cpp
./Neon/Neon.System.DBusClient/src/unity.cpp
./Neon/Neon.System.API/src/unity.cpp
./Nickel/Nickel.System.DBusClient/src/unity.cpp
./Nickel/NickelOnScreenId.System.DBusClient/src/unity.cpp
./Nickel/Nickel.System.API/src/unity.cpp
./Nickel/NickelOnScreenId.System.API/src/unity.cpp
./Nickel/NickelTuner.System.API/src/unity.cpp
./Nickel/NickelTuner.System.DBusClient/src/unity.cpp
./Arsenic/Arsenic.System.API/src/unity.cpp
./Arsenic/Arsenic.System.DBusClient/src/unity.cpp
./Mercury/Mercury.System.API/src/unity.cpp
./Mercury/Mercury.System.DBusClient/src/unity.cpp

./Cobalt/Cobalt.System.DBusClient/src/unity.cpp
./Cobalt/Cobalt.System.API/src/unity.cpp


<system-factory> SF is DBUS SF

note:
Two types. Cobalt DBus client is auto-generated but Nickel DBus client has
sources.


All are generated in build root.

// Cobalt/Cobalt.System.API/include/SystemFactory.h

namespace Zinc { namespace Broker {

  struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> 
      createMetadataBroker() = 0;

    virtual boost::shared_ptr<Zinc::Broker::HiddenServicesStore> 
      createHiddenServicesStore() = 0;

    ...
    
  };

} //namespace
} //namespace

// Cobalt/Cobalt.System.DBusClient/src/unity.cpp

namespace Zinc { namespace Broker { 

class ZINC_EXPORT DbusSystemFactory : public SystemFactory
  {
    public: // from SystemFactory
      DbusSystemFactory(const char* args = NULL);

      virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> 
        createMetadataBroker();
      ...

    private:
      NS_ZINC_DBUS_BINDING::DBusSystemFactoryImpl impl;

      // references to our proxy objects
      boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> 
        theMetadataBroker;
      ...
  };

extern "C" {
  NS_ZINC::Plugin* createDbusSystemFactory(const char* args = NULL) ZINC_EXPORT;
}

NS_ZINC::Plugin *createDbusSystemFactory(const char* args) {
  return new Zinc::Broker::DbusSystemFactory(args);
}

DbusSystemFactory::DbusSystemFactory(const char* args)
 : impl(DBus::BusType::SESSION, getBusName(args))
{
}

note: can see the bus name for this this dbus object, application.

static std::string getBusName(const char* overrideBusName)
{
  const char* busName = NULL;
  if (overrideBusName != NULL && overrideBusName[0] != '\0') {
    busName = overrideBusName;
  }
  if (busName == NULL) {
    busName = ::getenv(BUSNAME_ENV);
  }
  std::string theBusName;

  if(busName && strlen(busName) > 0) {
    theBusName = busName;
  } else {
    theBusName = "Zinc.Broker";          // note: default name
  }
  return theBusName;
}

note: can see all 'interfaces' from this dbus object, application.

boost::shared_ptr<Zinc::Broker::MetadataBroker> DbusSystemFactory::createMetadataBroker()
{
    return NS_ZINC_DBUS_BINDING::applyInterface<Zinc::Broker::MetadataBroker>(
            impl.getOrCreateObject(theMetadataBroker, "/Zinc/Broker/MetadataBroker"));
}


// MetadataProxy      15 ../Cobalt/Cobalt.System.DBusServer/src/BusName.cpp char const * const
// BusName::LINEAR_METADATA = "Zinc.MetadataProxy";


{map-from-client=factory-to-system-factory}
// Uranium.Client.System/data/iron-system-factory.plugin-config
//  libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)

NS_IRON_SYSTEM::SystemFactory& SystemClientFactory::getIronSystemFactory() 
{
  const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find( 
        "iron-system-factory.plugin-config"));

  return PluginFactory::getInstance<NS_IRON_SYSTEM::SystemFactory>(pluginConfig);
}


={============================================================================
*kt_dev_uv_stack_103* zinc-plugin

////////////////////////////////////////
/**
 * PluginConfig.h
 */
#ifndef ZINC_PLUGIN_CONFIG_H_
#define ZINC_PLUGIN_CONFIG_H_

#include "macros.h"
#include <string>

NS_ZINC_OPEN

struct ZINC_EXPORT PluginConfig {

  virtual const std::string& getLibraryName() const = 0;
  virtual const std::string& getCreateFunctionName() const = 0;
  virtual const std::string& getCreateParameters() const = 0;
  virtual ~PluginConfig();
};

NS_ZINC_CLOSE

#endif /* ZINC_PLUGIN_CONFIG_H_ */


////////////////////////////////////////
/**
 * AbstractPluginConfig.h
 */
#ifndef ZINC_ABSTRACT_PLUGIN_CONFIG_H_
#define ZINC_ABSTRACT_PLUGIN_CONFIG_H_

#include "PluginConfig.h"

NS_ZINC_OPEN

class ZINC_EXPORT AbstractPluginConfig : public PluginConfig {

  public:
    virtual const std::string& getLibraryName() const;
    virtual const std::string& getCreateFunctionName() const;
    virtual const std::string& getCreateParameters() const;
    virtual ~AbstractPluginConfig();

  protected:
    AbstractPluginConfig();

    AbstractPluginConfig(const std::string& libraryName, 
        const std::string& createFunctionName, 
        const std::string& createParameters);

    std::string libraryName;
    std::string createFunctionName;
    std::string createParameters;
};

NS_ZINC_CLOSE

#endif /* ZINC_ABSTRACT_PLUGIN_CONFIG_H_ */


////////////////////////////////////////
/**
 * AbstractPluginConfig.cpp
 */
#include "../include/AbstractPluginConfig.h"

NS_ZINC_OPEN

// to anchor RTTI info.
PluginConfig::~PluginConfig() {};

note: why defines base's dtor here?

const std::string& AbstractPluginConfig::getLibraryName() const {
	return libraryName ;
}

const std::string& AbstractPluginConfig::getCreateFunctionName() const {
	return createFunctionName ;
}

const std::string& AbstractPluginConfig::getCreateParameters() const {
	return createParameters ;
}

AbstractPluginConfig::~AbstractPluginConfig() {

}

AbstractPluginConfig::AbstractPluginConfig() : PluginConfig() {

}

AbstractPluginConfig::AbstractPluginConfig(const std::string& libraryName, 
    const std::string& createFunctionName, 
    const std::string& createParameters) :
  PluginConfig(),
  libraryName(libraryName), 
  createFunctionName(createFunctionName), 
  createParameters(createParameters) 
{
}

NS_ZINC_CLOSE


////////////////////////////////////////
/**
 * FixedPluginConfig.h
 */
#ifndef ZINC_FIXED_PLUGIN_CONFIG_H_
#define ZINC_FIXED_PLUGIN_CONFIG_H_

#include "AbstractPluginConfig.h"

NS_ZINC_OPEN

class ZINC_EXPORT FixedPluginConfig : public AbstractPluginConfig {

  public:
    FixedPluginConfig(const std::string& configSpec);
    FixedPluginConfig(const std::string& libraryName, 
        const std::string& createFunctionName);
    FixedPluginConfig(const std::string& libraryName, 
        const std::string& createFunctionName, 
        const std::string& createParameters);
};

NS_ZINC_CLOSE

#endif /* ZINC_FIXED_PLUGIN_CONFIG_H_ */


////////////////////////////////////////
note: reads config string line and set plugin
/**
 * FixedPluginConfig.cpp
 */
#include "../include/FixedPluginConfig.h"
#include <boost/tokenizer.hpp>
#include <iostream>
#include <string>

NS_ZINC_OPEN

FixedPluginConfig::FixedPluginConfig(const std::string& libraryName, 
    const std::string& createFunctionName) :
	AbstractPluginConfig(libraryName, createFunctionName, "") 
{
}

FixedPluginConfig::FixedPluginConfig(const std::string& libraryName, 
    const std::string& createFunctionName, 
    const std::string& createParameters) :
	AbstractPluginConfig(libraryName, createFunctionName, createParameters) 
{
}

/**
 * Construct a FixedPluginConfig by parsing the config file specifier string
 *
 * FixedPluginConfig string spec is of the form:
 *
 *   library_name function_name
 *   library_name function_name parameter [parameter]*
 *   library_name function_name(parameter parameter ...)
 */
FixedPluginConfig::FixedPluginConfig(const std::string &configSpec)
{
  boost::char_separator<char> sep(", ()");
  boost::tokenizer<boost::char_separator<char> > tok(configSpec, sep);
  boost::tokenizer<boost::char_separator<char> >::iterator i = tok.begin();

  libraryName = *i++;
  createFunctionName = *i++;
  createParameters.clear();
  while (i != tok.end())
  {
    createParameters = createParameters.append(*i++);
    if (i != tok.end())
      createParameters = createParameters.append(" ");
  }
}

NS_ZINC_CLOSE


////////////////////////////////////////
note: reads from a file and set plugin
/**
 * FilePluginConfig.h
 */
#ifndef ZINC_FILE_PLUGIN_CONFIG_H_
#define ZINC_FILE_PLUGIN_CONFIG_H_

#include "AbstractPluginConfig.h"

NS_ZINC_OPEN

class ZINC_EXPORT FilePluginConfig : public AbstractPluginConfig {

  public:
    FilePluginConfig(const std::string& configFilePath);
    virtual ~FilePluginConfig();

  protected:
    std::string configFilePath ;
};

NS_ZINC_CLOSE

#endif /* ZINC_FILE_PLUGIN_CONFIG_H_ */


/**
 * FilePluginConfig.cpp
 */
#include <fstream>
#include "../include/FilePluginConfig.h"
#include "../include/FixedPluginConfig.h"
#include "../include/PluginException.h"

using namespace std;
using namespace NS_ZINC;

NS_ZINC_OPEN

FilePluginConfig::FilePluginConfig(const string& configFilePath) :
   configFilePath(configFilePath) 
{
  ifstream configFile ;
  configFile.open(configFilePath.c_str(), ios::in) ;
  if (!configFile) {
    throw PluginException
      ("Failed to open plugin config file: "+configFilePath);
  }

  string line;
  getline (configFile,line);
  FixedPluginConfig config(line);
  configFile.close();

  libraryName = config.getLibraryName();
  createFunctionName = config.getCreateFunctionName();
  createParameters = config.getCreateParameters();

  if ((libraryName == "") || (createFunctionName == "")) {
    throw PluginException
      ("Plugin config file: "+configFilePath+" has invalid format.") ;
  }
}

FilePluginConfig::~FilePluginConfig() {
}

NS_ZINC_CLOSE


////////////////////////////////////////
/**
 * 
 */
#ifndef ZINC_PLUGIN_REFERENCE_H_
#define ZINC_PLUGIN_REFERENCE_H_

#include "../include/macros.h"

NS_ZINC_OPEN

class Plugin ;

class PluginReference {

public:

	explicit PluginReference();
	PluginReference(Plugin* plugin, void* libHandle);
	virtual ~PluginReference();

	void setPlugin(Plugin* newPlugin);

	void setLibHandle(void* newLibHandle);

	Plugin* getPlugin();

	void* getLibHandle();

private:

	Plugin* plugin;
	void* libHandle;
};

NS_ZINC_CLOSE

#endif /* ZINC_PLUGIN_REFERENCE_H_ */


/**
 * 
 */
#include <dlfcn.h>
#include "PluginReference.h"
#include "../include/Plugin.h"

using namespace std;

NS_ZINC_OPEN

PluginReference::PluginReference() :
	plugin(0), libHandle(0) {

}

PluginReference::PluginReference(Plugin* plugin, void* libHandle) :
		plugin(plugin), libHandle(libHandle) {}

PluginReference::~PluginReference() {

	setPlugin(0) ;
	setLibHandle(0) ;
}

<set-plugin>
void PluginReference::setPlugin(Plugin* newPlugin) {

  if (plugin != newPlugin) {

    if (plugin) {
      delete plugin ;
    }
    plugin = newPlugin ;
  }
}

void PluginReference::setLibHandle(void* newLibHandle) {

  if (libHandle != newLibHandle) {
    // Don't do dlclose() here. Let the process unwinding do it.
    // Otherwise, we will likely see static cleanup issues.
    libHandle = newLibHandle ;
  }
}

<get-plugin>
Plugin* PluginReference::getPlugin() {
  return plugin ;
}

void* PluginReference::getLibHandle() {
	return libHandle ;
}

NS_ZINC_CLOSE


/**
 * PluginFactory.h
 */
#ifndef ZINC_PLUGIN_FACTORY_H_
#define ZINC_PLUGIN_FACTORY_H_

#include <boost/shared_ptr.hpp>
#include <map>
#include <string>
#include <typeinfo>
#include <dlfcn.h>

#include "Plugin.h"
#include "PluginConfig.h"
#include "PluginException.h"

NS_ZINC_OPEN

class PluginReference;

class ZINC_EXPORT PluginFactory {

  typedef std::map<const std::string, boost::shared_ptr<PluginReference> > 
    instances_t;

  typedef instances_t::iterator instances_iter_t;

  public:

  template<class T>
    static T& getInstance(const PluginConfig& config);

  static void clearInstance(const PluginConfig& config);

  static void clearAll();

  private:

  static Plugin* loadInstance(const PluginConfig& config);

  static std::string hashKey(const PluginConfig& config);

  PluginFactory();

  ~PluginFactory();

  static instances_t &getInstances(void);
};

extern "C" typedef Plugin* createFunction_t(const char *);

<get-instance>
template<class T>
T& PluginFactory::getInstance(const PluginConfig& config) 
{
  // note: when fails throw PluginNotFoundException(e.what());
  Plugin* plugin = loadInstance(config);

  if (!plugin) throw PluginException
    (std::string("Plugin instance is NULL! Config: "+hashKey(config)));

  T* derived = dynamic_cast<T*>(plugin);

  if (!derived) {
    throw PluginException
      (std::string("Plugin instance is not of expected type. Expected: ")+
        typeid(T).name()+", got: "+typeid(plugin).name());
  }

  return *derived;
}

NS_ZINC_CLOSE

#endif /* ZINC_PLUGIN_FACTORY_H_ */


/**
 * PluginFactory.cpp
 */
#include "../include/PluginFactory.h"
#include "../include/Logger.h"
#include "../include/resource-finder/SingletonLibFinderLocator.h"

#include "PluginReference.h"
#include <string>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

# ifndef NDEBUG
#include <link.h>    // for dl_iterate_phdr
# endif

using namespace std ;

NS_ZINC_OPEN

void PluginFactory::clearInstance(const PluginConfig& config) {

	instances_t &instances=getInstances();
	const string key = hashKey(config) ;
	instances_iter_t iter(instances.find(key));
	if (iter != instances.end()) {
		// Keep the entry in the map, so that we *know* we've previously loaded this lib
		// if we're asked for it again (suppresses warning message).
		// Just null the PluginReference ptr.
		iter->second.reset();
	}
}

void PluginFactory::clearAll() {

	instances_t &instances=getInstances();

	for (instances_iter_t iter=instances.begin(); iter != instances.end(); ++iter) {
		iter->second.reset();
	}
}

PluginFactory::PluginFactory() {
	ZINC_COMMON_FUNC_TRACE;
}

PluginFactory::~PluginFactory() {
	ZINC_COMMON_FUNC_TRACE;
}

# ifndef NDEBUG

namespace {

struct ZINC_LOCAL CheckLibParams {

	size_t& sameCount;
	size_t& diffCount;

	const char* searchForLibName;
	const char* libPluginFactoryWouldLoad;
	dev_t dev;
	ino_t inode;
};

}

static int checkNextLib(struct dl_phdr_info *info, size_t /*size*/, void *data) {

	CheckLibParams* params = static_cast<CheckLibParams*>(data);

	const char* baseName=strrchr(info->dlpi_name, '/');
	baseName = (baseName?baseName+1:info->dlpi_name);

	if (strstr(baseName, params->searchForLibName) == baseName) {

		struct stat sb;
		stat(info->dlpi_name, &sb);

		// check whether loaded library is the exact same .so file that we would load
		if (sb.st_ino == params->inode && sb.st_dev == params->dev) {
			// Same - just log warning
			ZINC_COMMON_WARN(
					endl << "**********************" << endl <<
					"Library: '" << info->dlpi_name << "' already loaded by dynamic linker. " << endl <<
					"It's possible that you're getting this warning because the program is linked against '" << params->searchForLibName <<
					"' but also tries to load it with the PluginFactory. Check the program Makefile." << endl <<
					"Another possibility is that the library is being dlopen'd by some other means than the PluginFactory, or LD_PRELOAD'd." <<
					endl << "**********************" << endl
			);

			++params->sameCount;

		} else {
			// Would load a different version of this .so. This is much more serious and indicates a possible
			// linking error. We should bomb-out with a helpful message.
			ZINC_COMMON_ERROR(
					endl << "**********************" << endl <<
					"Library: '" << info->dlpi_name << "' already loaded by dynamic linker. " << endl <<
					"PluginFactory would load DIFFERENT LIBRARY: '" <<params->libPluginFactoryWouldLoad << "'." << endl <<
					"It's possible that you're getting this error because the program is linked against '" << params->searchForLibName <<
					"' but also tries to load it with the PluginFactory. Check the program Makefile." << endl <<
					"Another possibility is that the library is being dlopen'd by some other means than the PluginFactory, or LD_PRELOAD'd." << endl <<
					"ABORTING" <<
					endl << "**********************" << endl
			);

			++params->diffCount;
		}
	}

	return 0;
}

static bool checkLibraryNotAlreadyLoaded(const std::string& libPath) {

	// reusing this as input and output to callback fn.
	std::string libName(libPath);

	// drop the path elements
	size_t start = libName.rfind('/');
	if (start == string::npos) {
		start = 0;
	} else {
		start += 1;
	}

	// drop any version bit after the .so
	size_t end = libName.rfind(".so");
	if (end != string::npos) {
		end += 3;
	}

	libName = libName.substr(start, end);

	// stat the file to get the device & inode for comparison.
	// this allow us to reliably determine whether an already-loaded
	// .so is the very same file without doing messy readlink() or
	// string munging.

	struct stat sb;
	stat(libPath.c_str(), &sb);

	size_t sameCount(0);
	size_t diffCount(0);

	CheckLibParams params = { sameCount, diffCount, libName.c_str(), libPath.c_str(), sb.st_dev, sb.st_ino };

	dl_iterate_phdr(checkNextLib, &params);

	if (diffCount) {
		abort();
	}

	return sameCount;
}

# endif


<load-instance>
Plugin* PluginFactory::loadInstance(const PluginConfig& config) 
{
  // note:
  // key is a simple combination of library name, create function name and
  // parameters.

  string key = hashKey(config);

  ZINC_COMMON_TRACE("loadInstance: config=" << key);

  boost::shared_ptr<PluginReference> instance ;

  // note:
  // getInstances() is a static singleton which creates a map. 
  //
  // std::map<const std::string, boost::shared_ptr<PluginReference> >
  //
  // if not found in the map which means it is not loaded yet. 

  instances_t &instances=getInstances(); 
  instances_iter_t iter = instances.find(key);

  if (iter == instances.end() || ! iter->second) {

    // note: create a instance
    instance = boost::shared_ptr<PluginReference>(new PluginReference()) ;

    void* libHandle = 0;

    // Support "loading" statically-linked plugins.
    // Use special "library name" of "." to mean statically linked, otherwise
    // assume it is a library to be dlopen'd

    if (config.getLibraryName() != ".") {

      try {

        // note: try to find "library" file
        const std::string libraryPath = 
          SingletonLibFinderLocator::get().find(config.getLibraryName().c_str());

# ifndef NDEBUG
        if (iter == instances.end()) {
          // Don't do this check if we've loaded this plugin before.
          checkLibraryNotAlreadyLoaded(libraryPath);
        }
# endif

        ZINC_COMMON_TRACE("Loading plugin library: " << libraryPath);

        libHandle = dlopen(libraryPath.c_str(), RTLD_GLOBAL|RTLD_LAZY);

        instance->setLibHandle(libHandle) ;

        if (!instance->getLibHandle()) {

          const char* loadError = dlerror() ;

          throw PluginNotFoundException(
              string("Failed to load plugin shared object '")+libraryPath+
              "'. Error: "+loadError) ;
        }

      } catch (ResourceNotFoundException& e) {
        throw PluginNotFoundException(e.what());
      }
    }

    dlerror(); // clear any existing error

    // note: got a create function
    createFunction_t *createFunction = 
      (createFunction_t*)dlsym(
          instance->getLibHandle(), config.getCreateFunctionName().c_str()) ;

    if (!createFunction) {
      std::string errorMessage(
          config.getLibraryName() + " - " + config.getCreateFunctionName() 
          + " - " + dlerror());
      throw PluginException(errorMessage) ;
    }

    // note:
    // 1. each SCF derives from Plugin
    // 2. calls a create function which returns SCF and set it to instance

    instance->setPlugin(createFunction(config.getCreateParameters().c_str())) ;

    if (!instance->getPlugin()) {
      throw new PluginException(string(
        "Plugin creation function returned NULL instance! Plugin config: ")
          +key) ;
    }

    instances[key] = instance ;

  } else {
    instance = (*iter).second ;
  }

  // note: return SCF instance
  return instance->getPlugin() ;
}


std::string PluginFactory::hashKey(const PluginConfig& config) {
    std::string hashKey = config.getLibraryName() + "::" + config.getCreateFunctionName()+ 
        "(" +  config.getCreateParameters() + ")" ;
    return hashKey ;
}

// note: singleton
PluginFactory::instances_t& PluginFactory::getInstances(void) {
    static instances_t instances;
    return(instances);
}

NS_ZINC_CLOSE


={============================================================================
*kt_dev_uv_stack_103* zinc-plugin: finder

////////////////////////////////////////

/**
 * 
 */
#ifndef ZINC_SINGLETON_LIB_FINDER_LOCATOR_H_
#define ZINC_SINGLETON_LIB_FINDER_LOCATOR_H_

#include "ResourceFinder.h"

NS_ZINC_OPEN

/**
 * Use this to get a singleton ResourceFinder that can be shared amongst all the components
 * your application uses.
 *
 * Having a singleton enables the resource search paths to be configured for the whole
 * application, in one place.
 *
 * In lieu of any DI container, we are using a nasty-old static singleton.
 */
class ZINC_EXPORT SingletonLibFinderLocator : boost::noncopyable {

    public:
        static ResourceFinder& get();

    private:
        SingletonLibFinderLocator(); // prevent instantiation
};

NS_ZINC_CLOSE


#endif /* ZINC_SINGLETON_LIB_FINDER_LOCATOR_H_ */


NS_ZINC_OPEN

ResourceFinder& SingletonLibFinderLocator::get() {
    static ResourceFinder theInstance(getProductionLibFinderSearchPath());
    return theInstance;
}

NS_ZINC_CLOSE


// ============== resource finder

#ifndef ZINC_RESOURCEFINDER_H_
#define ZINC_RESOURCEFINDER_H_

#include "ResourceNotFoundException.h"
#include "../PathList.h"
#include <boost/noncopyable.hpp>
#include <string>
#include <vector>
#include <list>
#include <unistd.h>
#include <stdlib.h>

NS_ZINC_OPEN

class ZINC_EXPORT ResourceFinder : boost::noncopyable {

    public:
        explicit ResourceFinder(const PathList& searchPath);

        void setSearchPath(const PathList& searchPath);

        const PathList& getSearchPath() const;

        std::string find(const char* const relativePath, const char* const packageName=0) const;

        std::string find(const std::string& relativePath, const std::string& packageName) const;

    private:
        PathList searchPath;
};


inline std::string ResourceFinder::find(const std::string& relativePath, const std::string& packageName) const {
    return find(relativePath.c_str(), packageName.c_str());
}

NS_ZINC_CLOSE

#endif /* ZINC_RESOURCEFINDER_H_ */


using namespace std;

NS_ZINC_OPEN

ResourceFinder::ResourceFinder(const PathList& pathList) {
   setSearchPath(pathList);
}


void ResourceFinder::setSearchPath(const PathList& pathList) {

    PathList newSearchPath;

    // I don't do a straight assignment here, because I want to filter-out empty paths.
    BOOST_FOREACH(std::string path, pathList) {
        if (!path.empty()) {
            newSearchPath += path;
        }
    }

    // Always include the empty path as the last resort.
    // When we do a find(), the provided sub-path could actually be absolute.
    // Also, for libs, we could just default back to letting the runtime linker
    // search for the plain library name.

    newSearchPath += "";

    searchPath.swap(newSearchPath);
}

const PathList& ResourceFinder::getSearchPath() const {
   return searchPath;
}

std::string ResourceFinder::find(const char* const relativePath, const char* const packageName) const {

    ZINC_RF_DBG(cout << 
            "find() Looking for: " << relativePath << ", package: " 
            << (packageName?packageName:"none") << endl);

    static const std::string EMPTY_PATH;

    if (relativePath) {

        std::string absPath;

        const std::string relPathAsString(relativePath);

        // The package name is optional. If it is supplied, then we prefix the
        // relative path with it, and search for the resulting path, before
        // searching for the plain relativePath.
        //
        // We need to do both to cater for the fact that the package name
        // appears under some root paths, but not others. For example:
        // $prefix/share/zinc-common/somepath vs:
        // <path-to-source>/Zinc.Common/data/somepath

        const std::string relPackageRelPathAsString(packageName?
                Utilities::concatenatePaths(std::string(packageName), relPathAsString):
                EMPTY_PATH
                );

        struct stat statbuf;

        BOOST_FOREACH(std::string path, searchPath) {

            // Search package-qualified first. This is the "right" structure.
            if (packageName) {

                absPath = Utilities::concatenatePaths(path, relPackageRelPathAsString);

                ZINC_RF_DBG(cout << "Trying: " << absPath << endl);

                if (!stat(absPath.c_str(), &statbuf)) {
                    ZINC_RF_DBG(cout << "found." << endl);
                    // Found the file. Don't search any further.
                    return absPath;
                }
            }

            // Search non-package-qualified.
            absPath = Utilities::concatenatePaths(path, relPathAsString);

            ZINC_RF_DBG(cout << "Trying: " << absPath << endl);

            if (!stat(absPath.c_str(), &statbuf)) {
                ZINC_RF_DBG(cout << "found." << endl);
                // Found the file. Don't search any further.
                return absPath;
            }
        }
    }

    std::stringstream errmsg;
    errmsg << "Failed to find resource: '" << (relativePath?relativePath:NULL) << "' "
        "in '" << searchPath.toString() << "'";
    throw ResourceNotFoundException(errmsg.str());
}

NS_ZINC_CLOSE


// ============== package finder

#ifndef ZINC_PACKAGE_DATA_FINDER_H_
#define ZINC_PACKAGE_DATA_FINDER_H_

#include "ResourceFinder.h"
#include "SingletonDataFinderLocator.h"

NS_ZINC_OPEN


#ifndef MACRO__PACKAGE
#error Use of PackageDataFinder requires that MACRO__PACKAGE be defined as the value of the automake constant: PACKAGE
#endif

namespace {

/**
 * Use this to locate package (project)-specific resources such as config files.
 *
 * We expect such resources to be located somewhere under a folder which is named
 * after the autotools package name for the dependent project. So for example, if
 * Zinc.Common depends on "myconfig.cfg", then this should live somewhere under a
 * "zinc-common" folder.
 *
 * Note that we could possibly have multiple "zinc-common" folders. The most obvious
 * would be: $prefix/share/zinc-common, but in a test scenario we might set-up a
 * for e.g. /sometestsandbox/zinc-common as well.
 *
 * Which root locations are present and the order in which these different
 * locations are searched depends on how the core ResourceFinder is configured.
 *
 * NOTE: This class is deliberately defined in an anonymous namespace, and inline.
 * We want internal-linkage for this class, as we wish to ensure that we bake-in
 * the package-name for the calling project, not "zinc-common"!
 */
class ZINC_LOCAL PackageDataFinder {

public:

	/**
	 * This is the constructor you will use most of the time, when you just want to use
	 * the enclosing package.
	 */
	explicit PackageDataFinder(ResourceFinder& dataFinder=SingletonDataFinderLocator::get()) :
		packageName(MACRO__PACKAGE), dataFinder(dataFinder) {}

	/**
	 * This constructor can be used when we actually want to look for resources belonging to
	 * some package other than the enclosing one. Here the package name is provided explicitly.
	 */
	explicit PackageDataFinder(const char* const packageName_,  ResourceFinder& dataFinder=SingletonDataFinderLocator::get()) :
		packageName(packageName_), dataFinder(dataFinder) {}


	/**
	 * Use the ResourceFinder to locate a resource, given a relative-path to the
	 * resource.
	 *
	 * All this method really does is to prepend the package name to the supplied
	 * path, and pass that to the ResourceFinder, so it can then search it's
	 * configured paths.
	 *
	 * @param relativePath the relative path to the resource. This may be just a
	 * filename, or some nested path.
	 *
	 * @return the absolute path to the resource, as returned by the ResourceFinder.
	 */
	std::string find(const char* const relativePath) const {

		return dataFinder.find(relativePath, getPackageName());
	}

	/**
	 * This is added as a convenience, and just delegates to the cstr overload, above.
	 */
	std::string find(const std::string& relativePath) const {

		return dataFinder.find(relativePath.c_str(), getPackageName());
	}

private:

	const char* getPackageName() const {
		return packageName;
	}

	const char* const packageName;

	ResourceFinder& dataFinder;
};

}


NS_ZINC_CLOSE


#endif /* ZINC_PACKAGERESOURCEFINDER_H_ */


// ---------
// use

default-system-factory.plugin-config:1:libNickelSystemDbusClient.so createDbusSystemFactory

// get "libraryName" and "createFunctionName"
FilePluginConfig defaultPluginConfig(PackageDataFinder().find("default-system-factory.plugin-config"));

// get SCF
defaultImplementation = boost::addressof(PluginFactory::getInstance<SystemFactory>(defaultPluginConfig));


={============================================================================
*kt_dev_uv_stack_104* stack: binding and makefile 

How do translation?

./Zinc/Zinc.BindingRuntime/data/air/CommonMakefile.am

## Work out where the Client API headers are
client_api_include_dir = ${PKG_CONFIG_SYSROOT_DIR}$(shell pkg-config --variable=includedir $(client_api_package))/$(client_api_package)

all_client_api_headers:=$(shell find $(client_api_include_dir) -name \*.h)


={============================================================================
*kt_dev_uv_stack_105* zinc-dbus: monitor

To get the list of active bus names. This is script in box:
opt/zinc/devel/bin/lsdbus

$lsdbus

# dbus-send Emporium

https://wiki.youview.co.uk/display/canvas/dbus-send+Emporium?src=contextnavpagetreemode

{monitor}

# to capture
dbus-monitor > /mnt/hd1/mylogs.log &
dbus-monitor | tee /mnt/hd1/mylogs.log &


# To launch Dbus-Monitor on your STB, and inspect MediaRouter activity, run the
# following command:

dbus-monitor "interface=Zinc.Media.MediaRouter"

However, the above do not print return values from this call. 

The below will display only method calls, returns and errors. No signals at all
will be displayed but it does have the benefit of you not getting the
PositionChange signals cluttering your display.

dbus-monitor "type=method_call" "type=method_return" "type=error"

dbus-monitor "interface=Zinc.Media.MediaRouter" "type=method_return"


<use-different-media-router>

note: see different 'path'

path=/Zinc/Media/DefaultMediaRouter;
path=/Zinc/Media/MediaRouters/0;

method call sender=:1.81 -> dest=Zinc.Media serial=969
path=/Zinc/Media/DefaultMediaRouter; interface=Zinc.Media.MediaRouter;
member=setVideoWindow

signal sender=:1.114 -> dest=(null destination) serial=49
path=/Zinc/Media/MediaRouters/0; interface=Zinc.Media.MediaRouter;
member=PositionChangeEvent


<source-event>
# will only display MediaRouter SourceEvent messages:
dbus-monitor | grep -C 2 "member=SourceEvent"

dbus-monitor "type=method_call" "type=method_return" "type=error"

dbus-monitor --profile "interface=Zinc.Application.ApplicationManager,member=launchApplication" \ 
   "interface=Zinc.Application.ApplicationManager,member=ApplicationLifecycleEvent"


<error-event>
dbus-monitor "interface=Zinc.Media.MediaRouter,member=ErrorEvent"

signal sender=org.freedesktop.DBus -> dest=:1.149 serial=2
path=/org/freedesktop/DBus; interface=org.freedesktop.DBus; member=NameAcquired
string ":1.149"

signal sender=:1.147 -> dest=(null destination) serial=3959
path=/Zinc/Media/MediaRouters/23; interface=Zinc.Media.MediaRouter;
member=ErrorEvent

   int32 6
   int32 1
   string "Not Found
GStreamer error domain: gst-resource-error-quark
Additional debug:
gstsouphttpsrc.c(1623): gst_soup_http_src_parse_status ():
  /GstPipeline:pipeline/GstBin:VirtualBinTypefind/GstURIDecodeBin:uri-decoder/GstSoupHTTPSrc:source:
   Not Found (404), URL:
   http://live-dash-clear.dev.youview.co.uk/channel13/channel13.isml/channel13.mpd,
   Redirect to: (NULL)"


{dbus-call}
Take Iron call which is getScheduleEvents() as an example.

:~/source/DEVARCH/Iron/Iron.System.Minimal/scripts$ cat linearmetadata-getevents
#!/bin/sh
#
# Get events out of linear metadata
#

if [ "$1" == "" ] ; then
	echo "usage: $0 <service-locator> [date-time]"
	exit 1
fi

t=$2
if [ "$t" == "" ] ; then
	echo "Showing events from NOW"
	t=$(date "+%Y-%m-%d %H:%M:%S")
fi
t_sec=$(date +%s "$t")

dbus-send --session --type=method_call --print-reply --dest=Zinc.Metadata /Zinc/Metadata/EventRepository Zinc.Metadata.EventRepository.getScheduleEvents array:string:"$1" uint32:"$t_sec" uint32:4294967295


<to-get-detail-about-call>
:~/source/DEVARCH/Iron/Iron.System.API/data/introspection-xml$ ll
-rw-r--r-- 1 kpark kpark   794 Jan  7 15:55 enum-AspectRatio.xml
-rw-r--r-- 1 kpark kpark  1038 Jan  7 15:55 enum-AudioMixType.xml
-rw-r--r-- 1 kpark kpark   349 Jan  7 15:55 enum-SearchField.xml
-rw-r--r-- 1 kpark kpark  3699 Jan  7 15:55 enum-ServiceType.xml
-rw-r--r-- 1 kpark kpark   835 Jan  7 15:55 enum-SubtitlesFormat.xml
-rw-r--r-- 1 kpark kpark  1022 Jan  7 15:55 enum-VideoFormat.xml
-rw-r--r-- 1 kpark kpark   608 Jan  7 15:55 error-EventNotFound.xml
-rw-r--r-- 1 kpark kpark   525 Jan  7 15:55 error-EventRepositoryUnavailable.xml
-rw-r--r-- 1 kpark kpark   496 Jan  7 15:55 error-InvalidRegion.xml
-rw-r--r-- 1 kpark kpark   595 Jan  7 15:55 error-RelatedContentRepositoryUnavailable.xml
-rw-r--r-- 1 kpark kpark   622 Jan  7 15:55 error-ServiceNotFound.xml
-rw-r--r-- 1 kpark kpark   389 Jan  7 15:55 error-ServiceRepositoryUnavailable.xml
-rw-r--r-- 1 kpark kpark 11503 Jan  7 15:55 interface-EventRepository.xml
-rw-r--r-- 1 kpark kpark  3540 Jan  7 15:55 interface-RelatedContentRepository.xml
-rw-r--r-- 1 kpark kpark 10528 Jan  7 15:55 interface-ServiceRepository.xml
-rw-r--r-- 1 kpark kpark   639 Jan  7 15:55 service.xml
-rw-r--r-- 1 kpark kpark 32574 Jan  7 15:55 struct-Event.xml
-rw-r--r-- 1 kpark kpark  2150 Jan  7 15:55 struct-NetworkChangeNotification.xml
-rw-r--r-- 1 kpark kpark  3398 Jan  7 15:55 struct-RelatedContentLink.xml
-rw-r--r-- 1 kpark kpark  7640 Jan  7 15:55 struct-Service.xml
-rw-r--r-- 1 kpark kpark  3026 Jan  7 15:55 struct-TargetRegion.xml

See a file for interface "EventRepository":

-rw-r--r-- 1 kpark kpark 11503 Jan  7 15:55 interface-EventRepository.xml

<method name="getScheduleEvents">
  <yv:docstring>
  <p>Allows retrieval of all events in a given time window on a specified Service. 
  The data is sourced from EIT Schedule only (not EIT Present/Following).</p>
  <p>Any invalid Service Locators are ignored: no Events are returned for
  these Services but no error shall be generated. If one or more Services have
  no schedule data, no Events for these Service(s) shall be included in the
  <tt>events</tt> array.</p>
  </yv:docstring>

  <arg type="as" name="serviceLocators" direction="in">
    <yv:docstring>
    <p>The DVB Locator of the Service in question, as per ETSI TS&#160;102&#160;812 Clause&#160;14.1.</p>
    <p>The <tt>transport_stream_id</tt> field is optional so may be excluded,
    e.g. dvb://233a.1004.1084 or dvb://233a..1084 are both acceptable forms.
    If supplied, the implementation should return a result only if the
    <tt>transport_stream_id</tt> field matches. Otherwise, the appropriate
    error is generated.</p> 
    </yv:docstring>
  </arg>

  <arg type="u" name="startTime" direction="in">
    <yv:docstring><p>The start of the window of time for which events are requested. Expressed in
    seconds since midnight UTC on 1st January 1970.</p>
    </yv:docstring>
  </arg>

  <arg type="u" name="endTime" direction="in">
    <yv:docstring><p>The end of the window of time for which events are requested. Expressed in
    seconds since midnight UTC on 1st January 1970.</p>
    </yv:docstring>
  </arg>

  <arg type="a(ssuua{ss}a{ss}a{ss}asssasasasiia{sai}ba{sai}bsa{ss}asbba{sb})" yv:type="a[Event]" 
      name="events" direction="out">
    <yv:docstring><p>An array of <tt>Event</tt> structures, in which all Events for a particular Service form a contiguous block within the list, in which they are ordered by ascending <tt>start</tt>. The order in which these Service blocks appear is undefined.</p></yv:docstring>
  </arg>

  <yv:possible-errors>
    <yv:error name="Zinc.Metadata.Error.EventRepositoryUnavailable">
     <yv:docstring><p>Generated if this method is invoked during a Service scan.</p></yv:docstring>
    </yv:error>
  </yv:possible-errors>

</method>

Again, see three arguments are used which matches up with xml.

dbus-send --session --type=method_call --print-reply --dest=Zinc.Metadata /Zinc/Metadata/EventRepository Zinc.Metadata.EventRepository.getScheduleEvents array:string:"$1" uint32:"$t_sec" uint32:4294967295


<interfaces>
// this is from build root but not show complete interfaces
//
// Iron.System.DBusClient/src/EventRepositoryDBusToSyncAndAsync.cpp
// 
// 35-
// 36-#include "EventRepositoryDBusToSyncAndAsync.h"
// 37-
// 38-NS_ZINC_DBUS_BINDING_OPEN
// 39:const char* const interface_name<Zinc::Metadata::EventRepositoryAsync>::value =
// "Zinc.Metadata.EventRepository";
// 
// 40:const char* const interface_name<Zinc::Metadata::EventRepositorySync>::value =
//        "Zinc.Metadata.EventRepository";
// 
// 41:const char* const interface_name<Zinc::Metadata::EventRepositoryDBusToSyncAndAsync>::value =
//        "Zinc.Metadata.EventRepository";
//


// Iron.System.DBusClient/src/unity.cpp

namespace Zinc { namespace Metadata {


boost::shared_ptr<Zinc::Metadata::EventRepository> DbusSystemFactory::createEventRepository()
{
	return NS_ZINC_DBUS_BINDING::applyInterface<Zinc::Metadata::EventRepository>(
		impl.getOrCreateObject(theEventRepository, "/Zinc/Metadata/EventRepository"));~
}

boost::shared_ptr<Zinc::Metadata::RelatedContentRepository> DbusSystemFactory::createRelatedContentRepository()
{
	return NS_ZINC_DBUS_BINDING::applyInterface<Zinc::Metadata::RelatedContentRepository>(
		impl.getOrCreateObject(theRelatedContentRepository, "/Zinc/Metadata/RelatedContentRepository"));~
}

boost::shared_ptr<Zinc::Metadata::ServiceRepository> DbusSystemFactory::createServiceRepository()
{
	return NS_ZINC_DBUS_BINDING::applyInterface<Zinc::Metadata::ServiceRepository>(
		impl.getOrCreateObject(theServiceRepository, "/Zinc/Metadata/ServiceRepository")); ~
}

} //namespace
} //namespace


<source>
This is only place to implement this since Iron server is OEM object.

Iron.System.DBusClient/src/getScheduledEvents.cpp
113:    cout<<"Calling getScheduleEvents for service "<<serviceLocator<<" start "<<start<<" end "<<end<<endl;
116:    vector<NS_IRON_SYSTEM::Event> events = eventRepository->getScheduleEvents(servs,start,end).get();


={============================================================================
*kt_dev_uv_stack_105* zinc-dbus: commands

note: stop default MR

<dbus-stop-default-mr>
dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' \
/Zinc/Media/DefaultMediaRouter Zinc.Media.MediaRouter.stop

<dbus-seekpos>
method call sender=:1.106 -> dest=:1.72 serial=40107 path=/Zinc/Media/MediaRouters/0; interface=Zinc.Media.MediaRouter; member=seekPosition
   int32 0
   int32 1092939
   int32 0

dbus-send --session --print-reply --type=method_call --dest='Zinc.MediaProxy2' /Zinc/Media/MediaRouters/0 Zinc.Media.MediaRouter.seekPosition int32:0 int32:92939 int32:0
method return sender=:1.154 -> dest=:1.227 reply_serial=2

<dbus-getpos>
dbus-send --session --print-reply --type=method_call --dest='Zinc.MediaProxy2' /Zinc/Media/MediaRouters/0 Zinc.Media.MediaRouter.getPosition

<dbus-getsource>
dbus-send --session --type=method_call --dest=Zinc.MediaProxy2 /Zinc/Media/MediaRouters/0 Zinc.Media.MediaRouter.getSourceInformation


={============================================================================
*kt_dev_uv_stack_200* stack: uranium: stagecraft and air

<air>
Adobe AIR for TV. AIR is flash runtime engine.
https://wiki.youview.co.uk/display/YVDP/Air+for+TV?src=search

<stagecraft>
Adobe had taken great steps in making the Flash Lite player available to be licensed by mobile
device and CE manufacturers.  As I understand it Stagecraft goes one step farther by wrapping the
Flash Lite player in a layer that mitigates the risks associated with porting just the Flash Lite
player itself. It insures that SWFs created for one Stagecraft based device will work on all
Stagecraft based devices.


={============================================================================
*kt_dev_uv_stack_201* stack: uranium: creation chain to other components via dbus and factory

{use-generic-to-load-library}

Zinc/Zinc.Common/include/PluginFactory.h
Zinc/Zinc.Common/src/PluginFactory.cpp


{use-factory-for-component}
As UI uses a system client factory to get a shared pointer, Uranium uses the same to get a shared
pointer to other components. Here are codes in Uranium to other components such as Iron and Cobalt.

<1> to Iron. getIronSystemEventRepository() <get-iron-system-event-repository>

// note: dbus client library
// MetadataProxy      15 ../Cobalt/Cobalt.System.DBusServer/src/BusName.cpp char const * const
// BusName::LINEAR_METADATA = "Zinc.MetadataProxy";

// Uranium.Client.System/data/iron-system-factory.plugin-config
libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)


NS_IRON_SYSTEM::SystemFactory& SystemClientFactory::getIronSystemFactory() 
{
    URANIUM_PROFILE_FUNC;
    const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find( 
                "iron-system-factory.plugin-config"));

    return PluginFactory::getInstance<NS_IRON_SYSTEM::SystemFactory>(pluginConfig);
}

boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> SystemClientFactory::getIronSystemEventRepository()
{
    if(ironSystemEr == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::getIronSystemEventRepository()");

        // note: this is a call to DBUS client
        ironSystemEr = getIronSystemFactory().createEventRepository();
    }
    return ironSystemEr;
}


// note: this getIronSystemEventRepository() is used in various places and one of them is:

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
createConcreteEventRepository() 
{
  if(eventRepository == 0)
  {
    boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemER(
            getIronSystemEventRepository());

    // ...
  }
}


<2> To Cobalt. getSystemMetadataBroker() <get-system-metadata-broker>

// Uranium.Client.System/data/cobalt-system-factory.plugin-config 
libCobaltSystemDbusClient.so createDbusSystemFactory


NS_COBALT_SYSTEM::SystemFactory& SystemClientFactory::getCobaltSystemFactory() 
{
    const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find(
                "cobalt-system-factory.plugin-config"));
    
    return PluginFactory::getInstance<NS_COBALT_SYSTEM::SystemFactory>(pluginConfig);
}


boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> SystemClientFactory::getSystemMetadataBroker()
{
    if(systemMetadataBroker == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::getSystemMetadataBroker()");
        systemMetadataBroker = getCobaltSystemFactory().createMetadataBroker();
    }
    return systemMetadataBroker;
}


{creation-chain} for linear and metadata and creation chian. 

<MDL> MDCL   -> { MB, ER, SR }
<CMB>        SCMB(MB) -> { SMB(COBALT), C, MO }
                                        C -> { MDR, PC }
Binding:
<MDL> MDCL   -> { MB, ER, SR }

// UI calls:

shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> nativeLocator( clientFactory.createMetadataLocator());

// Uranium/Uranium.Client.System/src/SystemClientFactory.cpp

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
  // [LinearMetadata]
  //     -> { ER, RCR, RR }:
  //          |
  //          -> { ER(IRON), RR }
  
  boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::Locator> createLinearMetadataLocator() 
  {
    using namespace NS_URANIUM_LINEAR_CLIENT;

    URANIUM_FUNC_DEBUG;

    boost::shared_ptr<Locator> loc(linearMetadataLocator.lock());

    if(loc == NULL)
    {
      linearMetadataLocator = loc =
        boost::make_shared<SystemClientLocator>(
            createLinearEventRepository(),
            createRelatedContentRepository(),
            createReminderRepository()
            );
    }
    return loc;
  }

  boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::EventRepository> createLinearEventRepository() 
  {
    using namespace NS_URANIUM_LINEAR_CLIENT;

    boost::shared_ptr<SystemClientEventRepository> eventRepository(linearEventRepository.lock());

    if(!eventRepository) {

      // note: After all, ER is system repository and is from Iron via dbus
      // create Event Repository <get-iron-system-event-repository>

      boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemEventRepository(
          getIronSystemEventRepository());

      eventRepository = boost::make_shared<SystemClientEventRepository>(
          systemEventRepository,
          createReminderRepository()
          );

      systemEventRepository->addListener(eventRepository);
      eventRepository->setDispatcher(getDefaultDispatcher());
      eventRepository->setFutureDispatcher(futureDispatcher);
      linearEventRepository = eventRepository;
    }
    return eventRepository;
  }

  // [Metadata]
  //  -> { MB, ER, SR }
  //
  // <CMB>        SCMB(MB) -> { SMB(COBALT), C, MO }
  //
  //                                         C -> { MDR, PC }
  
  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> createMetadataLocator() 
  {
    if(!metadataLocator)
    {
      metadataLocator = boost::make_shared<NS_URANIUM_METADATA_CLIENT::SystemClientLocator>(
          createMetadataBroker(),   <CMB> 
          createEventRepository(),  <CER>
          createServiceRepository());
    }
    return metadataLocator;
  }
};


<CMB> SCMB(MB) -> { SMB(COBALT), C, MO }
                                 C -> { MDR, PC }

// `Converter` is a helper class that is used to convert MetadataBroker
// `Result` and `ResultSet` to the required Client API types, depending on the
// specific Broker function that was called.

struct ZINC_LOCAL Converter
{
  explicit Converter(boost::shared_ptr<SystemClientMetadataConfig> config_,
      boost::weak_ptr<MetadataRepositories> repos_,
      boost::shared_ptr<ProvisioningCache> provisioningCache_)
    : config(config_),
    repos(repos_),
    provisioningCache(provisioningCache_)
  {}
};

// note: returns a copy

NS_URANIUM_METADATA_CLIENT::Converter SystemClientFactory::createConverter()
{
  URANIUM_PROFILE_FUNC;
  return NS_URANIUM_METADATA_CLIENT::Converter(
      createMetadataConfig(),
      createMetadataRepositories(),
      createProvisioningCache());
}

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataBroker> SystemClientFactory::createMetadataBroker() 
{
  URANIUM_FUNC_DEBUG;

  if(metadataBroker == 0)
  {
    // cobalt <get-system-metadata-broker>
    boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> systemMetadataBroker(getSystemMetadataBroker());

    using NS_URANIUM_METADATA_CLIENT::SystemClientMetadataBroker;

    <SCMB>
    boost::shared_ptr<SystemClientMetadataBroker> mb = 
      boost::make_shared<SystemClientMetadataBroker>( systemMetadataBroker,
          createConverter(),
          createMetadataObserver() );

    mb->setDispatcher(getDefaultDispatcher());
    mb->setFutureDispatcher(futureDispatcher);
    metadataBroker = mb;
  }

  return metadataBroker;
}


<CMB> <SCMB>

// note: SCMB        -> { RS(COBALT), , MR, }. repos is MR 

Uranium.Client.System/src/metadata/SystemClientMetadataBroker.cpp

class ZINC_EXPORT SystemClientMetadataBroker
    : virtual public MetadataBroker,
      virtual public NS_ZINC::DispatchingFutureProducer,
      public boost::enable_shared_from_this<SystemClientMetadataBroker>
{

  SystemClientMetadataBroker(
      boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker_,
      Converter convert_,
      boost::shared_ptr<MetadataObserver> metadataObserver_) :
    metadataBroker(metadataBroker_),
    convert(convert_),
    metadataObserver(metadataObserver_)
  {}

  // note: search
  // note: WHO'S CALLING THIS?  
  NS_ZINC::Future<boost::shared_ptr<SummaryResultSet>> search(const std::string& searchTerms,
      boost::shared_ptr<SearchOptions> searchOptions,
      size_t start,
      size_t size) const
  {
    shared_ptr<SystemClientSearchOptions> scSearchOptions
      = boost::dynamic_pointer_cast<SystemClientSearchOptions>(searchOptions);

    // note: <dbus-call-to-cobalt>
    return metadataBroker->search(searchTerms,
        getSysQopts(scSearchOptions),
        getSysGopts(scSearchOptions),
        scSearchOptions->getFilters(),
        start,
        size)
      .then(*getDispatcher(),
          bind(&SystemClientMetadataBroker::searchCallback,
            shared_from_this(),
            start,
            _1));
  }

  boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker;
  boost::shared_ptr<SystemClientMetadataConfig> config;
  Converter convert;
  boost::shared_ptr<MetadataObserver> metadataObserver;

  boost::weak_ptr<MetadataRepositories> repos;
};


<CER> SCER(ER) -> { MDO, SR, SER, SMB, CRR, CLA, EEIF, PEC, BSM }

note: ER is metadata ER

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::EventRepository> createEventRepository() 
  {
    return createConcreteEventRepository();
  }

  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
    createConcreteEventRepository() 
    {
      if(eventRepository == 0)
      {
        // cobalt <get-system-metadata-broker>
        boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> systemMB = getSystemMetadataBroker();

        // <get-iron-system-event-repository>
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemER(getIronSystemEventRepository());

        boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> clientRR(createReminderRepository());
        boost::shared_ptr<NS_URANIUM_DVR_CLIENT::LinearAcquisition> clientLA(createLinearAcquisition());
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientMetadataConfig> 
          metadataconfig(createMetadataConfig());

        // note: <SCER>
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> concreteER(
            'new' NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository(
              metadataconfig,
              createMetadataObserver(), note: create MDO.
              serviceRepository,
              systemER,
              systemMB,
              clientRR,
              clientLA,
              createExtraEventInfoFacade(),
              createPresentEventsCache(),
              createBrokerStatusMonitor()
              )
            );

        concreteER->setDefaultDispatcher(getDefaultDispatcher());
        concreteER->setFutureDispatcher(futureDispatcher);
        eventRepository = concreteER;

        createMetadataObserver()->addListener(concreteER);
        serviceRepository->setEventRepository(concreteER);
      }

      return eventRepository;
    }
}

SystemClientEventRepository::SystemClientEventRepository(
        boost::shared_ptr<SystemClientMetadataConfig> config_,
        boost::shared_ptr<MetadataObserver> metadataObserver_,
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> serviceRepo_,
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemEventRepo_,
        boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker_,
        boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> reminderRepo_,
        boost::shared_ptr<NS_URANIUM_DVR_CLIENT::LinearAcquisition> linearAcquisition_,
        boost::shared_ptr<ExtraEventInfoFacade> extraInfo_,
        boost::shared_ptr<PresentEventsCache> peCache_,
        boost::shared_ptr<BrokerStatusMonitor> brokerMonitor_) :
           config(config_),
           metadataObserver(metadataObserver_),
           serviceRepo(serviceRepo_),
           systemEventRepo(systemEventRepo_),
           metadataBroker(metadataBroker_),
           reminderRepo(reminderRepo_),
           linearAcquisition(linearAcquisition_),
           extraInfo(extraInfo_),
           peCache(peCache_),
           brokerMonitor(brokerMonitor_)
    {
    }


<MO>
boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataObserver> <createMetadataObserver>()
{
  using namespace NS_URANIUM_METADATA_CLIENT;

  if(metadataObserver == 0)
  {
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataObserver> mo(
        MetadataObserver::create(
          createServiceCache(),
          createReminderRepository(),
          // <get-iron-system-event-repository>
          getIronSystemEventRepository(),
          createPresentEventsCache(),
          createProvisioningCache(),
          createMediaRecordCache(),
          createMetadataConfig(),
          createActionProcessor()
          )
        );

    // WARNING:
    // It is necessary to have an InlineDispatcher: see MetadataObserver::ServiceListChange.
    mo->setDispatcher(boost::make_shared<InlineDispatcher>());

    // <get-iron-system-event-repository>
    getIronSystemEventRepository()->addListener(mo);
    getSystemUnifiedServiceRepository()->addListener(mo);
    createReminderRepository()->addListener(mo);
    createLinearAcquisition()->addListener(mo);

    // note: set listener
    createLocalMediaLibrary()->addListener(mo);

    createMetadataConfig()->addListener(mo);
    getProvisioningService()->addListener(mo);

    // note: 'neon' so 
    ipnetwork = getNeonClientFactory().createIPNetwork();
    ipnetwork->addListener(mo);
    getHiddenServicesStore()->addListener(mo);

    //FIXME: 
    //the order here is not accidental - unfortunately there is a cyclic indirect dependency between 
    //service repo and metadata observer, and this is a way to stop infinite loops in the factory
    mo->addListener(createConcreteServiceRepository(false));
    createConcreteServiceRepository(false)->setMetadataObserver(mo);
    metadataObserver = mo;
  }

  return metadataObserver;
}

Uranium.Client.System/src/metadata/MetadataObserver.h

class ZINC_LOCAL MetadataObserver:
{
  std::vector<boost::weak_ptr<SystemClientEventRepository> > clientEventRepos;

  void MetadataObserver::addListener(boost::shared_ptr<SystemClientEventRepository> er_)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;
    boost::mutex::scoped_lock lock(listenerMutex);
    clientEventRepos.push_back(er_);
  }

  void MetadataObserver::notifyServicesChanged(const vector<string>& changedServiceLocators)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;

    //Service and event repository need to be notified in this order,
    //and before EventWindows. EventDispatchers give us no guarantee
    //about the order of notifications, so we need to ensure it ourselves here.
    boost::shared_ptr<ServiceCache> serviceCacheStrong = serviceCache.lock();

    if(serviceCacheStrong)
    {
      serviceCacheStrong->ServicesChanged(changedServiceLocators);
    }

    //notify and cleanup Service/Event repos.
    boost::mutex::scoped_lock lock(listenerMutex);

    notify<SystemClientServiceRepository>(clientServiceRepos, 
        boost::bind(&SystemClientServiceRepository::ServicesChanged, _1, changedServiceLocators)) ;

    notify<SystemClientEventRepository>(clientEventRepos, 
        boost::bind(&SystemClientEventRepository::ServicesChanged, _1, changedServiceLocators));
    lock.unlock();

    produceEvent(boost::bind(&MetadataChangeListener::ServicesChanged, _1, changedServiceLocators));
  }

  void MetadataObserver::ServiceChange(const std::string& serviceLocator)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;
    notifyServicesChanged(vector<std::string>(1, serviceLocator));

    //we don't need to reload present events cache, because spec 0011-S says that if RCNs change,
    //then the box should emit ServiceListChange anyway.
  } 
};


={============================================================================
*kt_dev_uv_stack_202* stack: uranium: metadata: event structures and dbus xml

{iron-event-struct} dtt event

// zinc-build-root/debug-debian-7-x86_64/Iron/Iron.System.API/include/Event.h

namespace Zinc { namespace Metadata {

struct Event
{
    Event();
    explicit Event( /* deleted */ );

    void swap(Event&);

    // Members:
    std::string serviceLocator;
    std::string eventLocator;
    uint32_t start;
    uint32_t publishedDuration;

    // note: all use 'lang', e.g. eng as a key in map<lang, string>
    //
    // extractValueFromMap(dttEvent.shortTitle, lang)
    // extractValueFromMap(dttEvent.mediumSynopsis, lang)
    //
    // sysEvent.mediumSynopsis["eng"] = "The latest national and international"
    //   "news stories from the BBC News team, followed by weather.";
    
    std::map< std::string, std::string > shortTitle;
    std::map< std::string, std::string > mediumSynopsis;
    std::map< std::string, std::string > longSynopsis;

    std::vector< std::string > classifier;
    std::string programmeCrid;
    std::string splitInstanceIdentifier;
    std::vector< std::string > seriesCrid;
    std::vector< std::string > recommendationCrid;
    std::vector< std::string > collectionCrid;
    VideoFormat::Enum videoFormat;
    AspectRatio::Enum aspectRatio;
    std::map< std::string, std::vector< AudioMixType::Enum > > audio;
    bool audioDescription;
    std::map< std::string, std::vector< SubtitlesFormat::Enum > > subtitles;
    bool signing;
    std::string guidanceCode;
    std::map< std::string, std::string > guidanceText;
    std::vector< std::string > iconURL;
    bool conditionalAccess;
    bool bookable;
    std::map< std::string, bool > alternativeEventLocator;
};

// Iron/Iron.System.API/data/introspection-xml/struct-Event.xml

<yv:struct name="Zinc.Metadata.Event">

   <p>The Event structure members are as follows:</p>

   ...

   <yv:member type="a{ss}" name="shortTitle">
       <yv:docstring>
           <p>A title for the event taken from the <tt>short_event_descriptor()</tt> 
           <tt>event_name_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 âalpha-3â language code (the key) 
           to a title in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

   <yv:member type="a{ss}" name="mediumSynopsis">
       <yv:docstring>
           <p>A description for the event taken from the <tt>short_event_descriptor()</tt> 
           <tt>text_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 âalpha-3â language code (the key) 
           to a synopsis in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

   <yv:member type="a{ss}" name="longSynopsis">
       <yv:docstring>
           <p>A description for the event taken from the <tt>extended_event_descriptor()</tt> 
           <tt>text_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 âalpha-3â language code (the key) 
           to a synopsis in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

note: "a{ss}" is array of dictionary(string, string) and maps to
   std::map< std::string, std::string > shortTitle;


{cobalt-result-struct}
// zinc-build-root/debug-debian-7-x86_64/Cobalt/Cobalt.System.API/include

/*
 * include/Result.h
 *
 * This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 * Template struct.h.template
 * Using /data/builds/_virtual_/pc/DEVARCH/Cobalt/Cobalt.System.API/data/introspection-xml/struct-Result.xml
 */
namespace Zinc { namespace Broker {

struct Result
{
    Result();
    explicit Result( /* omitted */ );
    void swap(Result&);

    // Members:
    std::string recordIdentifier;
    int64_t lastModified;
    int64_t validUntil;
    DataSource::Enum dataSource;
    std::vector< std::string > classifiers;
    std::map< std::string, std::vector< std::string > > identifiers;
    std::map< std::string, std::vector< std::string > > internalReferences;

    // note: 
    // sysResult->description["mediumSynopsis"] = vector<string>(1, "The latest national and international"
    //   "news stories from the BBC News team, followed by weather.");

    std::map< std::string, std::vector< std::string > > description;

    std::map< std::string, std::vector< XmlNode > > nodes;
};

inline Result::Result() 
    : recordIdentifier(), lastModified(), validUntil(),
    dataSource(), classifiers(), identifiers(), internalReferences(),
    description(), nodes() { }

inline Result::Result(const std::string& recordIdentifier_, const int64_t
        lastModified_, const int64_t validUntil_, const DataSource::Enum
        dataSource_, const std::vector< std::string >& classifiers_, const
        std::map< std::string, std::vector< std::string > >& identifiers_,
        const std::map< std::string, std::vector< std::string > >&
        internalReferences_, const std::map< std::string, 
        std::vector<std::string > >& description_, 
        const std::map< std::string, std::vector< XmlNode > >& nodes_) 

    : recordIdentifier(recordIdentifier_), lastModified(lastModified_),
    validUntil(validUntil_), dataSource(dataSource_),
    classifiers(classifiers_), identifiers(identifiers_),
    internalReferences(internalReferences_), description(description_),
    nodes(nodes_) { }


// Cobalt/Cobalt.System.API/data/introspection-xml/struct-Result.xml

<?xml version="1.0" encoding="UTF-8"?>
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0">
    <yv:struct name ="Zinc.Broker.Result">
        <yv:member type="s" name="recordIdentifier" />
        <yv:member type="x" name="lastModified" />
        <yv:member type="x" name="validUntil" />
        <yv:member type="i" yv:type="[DataSource]" name="dataSource" />
        <yv:member type="as" name="classifiers" />
        <yv:member type="a{sas}" name="identifiers" />
        <yv:member type="a{sas}" name="internalReferences" />
        <yv:member type="a{sas}" name="description" />
        <yv:member type="a{sa(a{ss}s)}" yv:type="a{sa[XmlNode]}" name="nodes" />
    </yv:struct>
</node>

note: "a{sas}" maps to
   std::map< std::string, std::vector< std::string > > description;


{translation}
Cobalt/Cobalt.System.Production/data/b2c_map.yaml

node_transformations: [
    # tag                action                 args....
    ['serviceId',       'AppendToDescription', 'owningServiceId'],

    ['summary',         'AppendToDescription', 'shortSynopsis'],
    ['description',     'AppendToDescription', 'mediumSynopsis'],
    ['longDescription', 'AppendToDescription', 'longSynopsis'],


Cobalt.System.Production/src/XMLProcessor.cpp
261-
262:struct AppendToDescription {
263-    typedef void result_type;
264:    AppendToDescription(const string& keyName_)
265-     : keyName(keyName_)
266-    {

https://jira.youview.co.uk/browse/DEVARCH-8960
XMLProcessor is responsible for parsing B2C XML responses into `Result` objects. It is used for
    parsing all results, but in particular it is used to parse schedule query results, which can be
    very large. For instance schedule "Tiles" retrieved for the purposes of P/F generation (for
            IP-channels) are >1MB. Since these are being periodically retrieved, and several such
    tiles will be required to cover all the IP-channels, parsing performance is critical.



{cobalt-resultset}
introspection-xml/struct-ResultSet.xml

	<yv:struct name ="Zinc.Broker.ResultSet">
	    <yv:member type="u" name="totalSize" />
        <yv:member type="a(sxxiasa{sas}a{ss}a{sas}a{sa(a{ss}s)})"
            yv:type="a[Result]"
            name="results"/>
	</yv:struct>


namespace Zinc { namespace Broker {

struct ResultSet
{
    ResultSet();
    explicit ResultSet(const uint32_t totalSize_, const std::vector< Result >& results_);
    void swap(ResultSet&);

    // Members:
    uint32_t totalSize;
    std::vector< Result > results;

};


{use-in-code}
vector<NS_IRON_SYSTEM::Event> getBBC1Events()
{
    NS_IRON_SYSTEM::Event e1;
    NS_IRON_SYSTEM::Event e2;

    e1.serviceLocator = "dvb://233a..1044";
    e1.eventLocator = "dvb://233a..1044;1";
    e1.shortTitle["eng"] = "Title of e1";          // see map<string, string>
    e1.start = 0;
    e1.publishedDuration = 100;

    e2.serviceLocator = "dvb://233a..1044";
    e2.eventLocator = "dvb://233a..1044;2";
    e2.shortTitle["eng"] = "Title of e2";
    e2.start = 200;
    e2.publishedDuration = 100;

    vector<NS_IRON_SYSTEM::Event> result;
    result.reserve(2);
    result.push_back(e1);
    result.push_back(e2);

    return result;
}


// note: this test shows how to use 'cobalt::result' structure.

// Uranium.Client.System/test/metadata/SummaryTest.cpp

SystemClientSummary make_sample_summary(const GuidanceInfo& gi = GuidanceInfo())
{
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult = boost::make_shared<NS_COBALT_SYSTEM::Result>();

    sysResult->description["entityType"] = vector<string>(1, "scheduleevent");
    sysResult->description["eventTitle"] = vector<string>(1, "Eastenders");
    sysResult->description["mediumSynopsis"] = vector<string>(1, "mediumSynopsis");
    sysResult->description["serviceLocator"] = vector<string>(1, "dvb://233a..1044");
    sysResult->description["owningServiceId"] = vector<string>(1, "1");

    if(gi.hasGuidanceCode)
    {
        sysResult->description["guidanceCodes"] = vector<string>(1, "15");
    }

    if(gi.hasGuidanceScheme)
    {
        sysResult->description["guidanceScheme"] = vector<string>(1, "BBCFC");
    }

    if(gi.hasGuidanceText)
    {
        sysResult->description["guidanceText"] = vector<string>(1, "Naughty programme.");
    }

    if(gi.hasGuidanceLongText)
    {
        sysResult->description["longGuidanceText"] = vector<string>(1, "Naughty programme. Watch alone.");
    }

    sysResult->identifiers[
        "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"]
        = vector<string>(1, "dvb://233a..1044;1");

    sysResult->identifiers[
        "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.programmeCRID"]
        = vector<string>(1, "crid://bbc.co.uk/someid");

    SystemClientSummary summary( sysResult,
            clientFactory->createMetadataConfig(),
            clientFactory->createMetadataRepositories(),
            // These tests do not rely on ProvisioningCache
            boost::shared_ptr<ProvisioningCache>(),
            3 );

    return summary;
}


note: WRT getSynopsis, it only uses in void testGetEventFromSummary() but don't see why is doing this.


={============================================================================
*kt_dev_uv_stack_203* stack: uranium: metadata: system api call via dbus rpc

UI has shared pointer to MB via MD Locator and makes a call via this shared pointer.

// note: <dbus-call-to-cobalt>
return metadataBroker->search(searchTerms,
    getSysQopts(scSearchOptions),
    getSysGopts(scSearchOptions),
    scSearchOptions->getFilters(),
    start,
    size)
  .then(*getDispatcher(),
      bind(&SystemClientMetadataBroker::searchCallback,
        shared_from_this(),
        start,
        _1));

introspection-xml/interface-MetadataBroker.xml

<method name="search">
    <yv:docstring>
        This method searches the on-demand catalogue using the B2C
        interface's Search Service, to return Programme Summaries,
        Series, Brands, Applications and/or Services. This method
        is also used for un-rolling Series and Brands within search
        user experiences.
    </yv:docstring>
    <arg type="s" name="queryString" direction="in">
        <yv:docstring>
            The query string for the search.
        </yv:docstring>
    </arg>
    <arg type="(ii)" yv:type="[QueryOptions]" name="queryOptions" direction="in">
        <yv:docstring>
            Options for the query including sorting of the results. 
            See the QueryOptions structure definition for further 
            details.
        </yv:docstring>
    </arg>
    <arg type="(iu)" yv:type="[GroupingOptions]" name="groupingOptions" direction="in">
        <yv:docstring>
            Options controlling the grouping of results. See the 
            GroupingOptions structure for more details.
        </yv:docstring>
    </arg>
    <arg type="a{sas}" name="filters" direction="in">
        <yv:docstring>
            A set of filters to be applied to the query with the key
            beging the filter name and the value being an array of 
            values for the filter which will be applied using the OR
            operator. The different filters are ANDed together in the
            request URL.
        </yv:docstring>
    </arg>
    <arg type="i" name="startIndex" direction="in">
        <yv:docstring>
            The start index of the result set requested, where 0 is 
            the index of the first item in the result set.
        </yv:docstring>
    </arg>
    <arg type="u" name="size" direction="in">
        <yv:docstring>
            The maximum size of the result set requested.
        </yv:docstring>
    </arg>
    <arg type="(ua(sxxiasa{sas}a{sas}a{sas}a{sa(a{ss}s)}))"
        yv:type="[ResultSet]" 
        name="searchResults" direction="out">                   // note: return
        <yv:docstring>
            A SummaryResultSet structure which indicates the size of 
            the total result set and contains an array of the 
            summaries.
        </yv:docstring>
    </arg>
    <yv:possible-errors>
        <yv:error name="Zinc.Broker.Error.Misconfiguration">
            <yv:docstring>
                The box is not configured with endpoint addresses etc.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.InvalidRequest">
            <yv:docstring>
                If the querystring is empty.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.NetworkProblem">
            <yv:docstring>
                Network error.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.InvalidResponse">
            <yv:docstring>
                Invalid response from Metadata Aggregation System.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.InternalProblem">
            <yv:docstring>
                Internal problem in MetadataBroker or MAS.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.TransientServerProblem">
            <yv:docstring>
                Transient problem in MAS.
            </yv:docstring>
        </yv:error>
    </yv:possible-errors>
    <yv:const />
</method>

// note: <dbus-call-to-cobalt>
Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
  metadataBroker->getEventSummariesByServices(recids, start, end);

<method name="getEventSummariesByServices">
    <yv:docstring>
        Returns the schedule for a Service(s) based upon MAS Record 
        Identifiers for the Service(s) and the start and end times of 
        a given time window.
    </yv:docstring>
    <arg type="as" name="serviceRecordIds" direction="in">
        <yv:docstring>
            MAS Record Identifier(s) of the Service(s) for which
           the schedule is requested.  
        </yv:docstring>
    </arg>
    <arg type="x" name="startTime" direction="in">
        <yv:docstring>
            The start of the time window for which a schedule is
            requested.
        </yv:docstring>
    </arg>
    <arg type="x" name="endTime" direction="in">
        <yv:docstring>
            The end of the time window for which a schedule is 
            reequested.
        </yv:docstring>
    </arg>
    <arg type="a(sxxiasa{sas}a{sas}a{sas}a{sa(a{ss}s)})"
        yv:type="a[Result]"
        name="eventSummaries" direction="out">
        <yv:docstring>
            Schedule Event Summaries of the Events in the requested 
            schedule window. 
        </yv:docstring>
    </arg>
    <yv:possible-errors>
        <yv:error name="Zinc.Broker.Error.Misconfiguration">
            <yv:docstring>
                The box is not configured with endpoint addresses etc.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.InvalidRequest">
            <yv:docstring>
                No serviceRecordId sepcified, one (or more) of the 
                specified serviceRecordId values is malformed, 
                or the specified time window is out of bounds.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.NetworkProblem">
            <yv:docstring>
                Network error.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.InvalidResponse">
            <yv:docstring>
                Invalid response from Metadata Aggregation System.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.InternalProblem">
            <yv:docstring>
                Internal problem in MetadataBroker or MAS.
            </yv:docstring>
        </yv:error>
        <yv:error name="Zinc.Broker.Error.TransientServerProblem">
            <yv:docstring>
                Transient problem in MAS.
            </yv:docstring>
        </yv:error>
    </yv:possible-errors>
    <yv:const />
</method>


={============================================================================
*kt_dev_uv_stack_204* stack: uranium: metadata: events and client events

{event-in-ui}
// this comes from "build root"
// Uranium.AIR.Client.API/asInterfaces/ctv/enhancedmetadata/Event.as

/**
 *  A class that represents the Event in the EPG.
 */ 
public interface Event {

    /**
     *  Returns the title of the Event in the currently selected language.
     */
    function getTitle():String;
    ...
};


The old API has:

getLongSynopsis():Object
getMediumSynopsis():Object

The new API has:

getSynopsis():String
Returns the synopsis of the Event if current data source provides it.


{events-and-system-events}
./Uranium.Client.API/include/linear-metadata/Event.h
./Uranium.Client.API/include/metadata/Event.h

./Uranium.Client.System/src/linear-metadata/SystemClientEvent.h
./Uranium.Client.System/src/metadata/SystemClientEvent.h

The both are defined in "Event".

   linear::Event                 metadata::Event

   SCE                           SCE

   SCER                          SCER

                                 SCER->getEventWindow() : EPG has SCER via SCF

<linear>
// Uranium.Client.API/include/linear-metadata/Event.h 

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic 
{
  public:
    virtual boost::shared_ptr<synopsis> getMediumSynopsis() const = 0;
    virtual boost::shared_ptr<synopsis> getLongSynopsis() const = 0;
};

// Uranium.Client.System/src/linear-metadata/SystemClientEvent.h

NS_URANIUM_LINEAR_CLIENT_OPEN

/**
 * "Proxy" class for DVB event data from Iron::System::Event, exposes its properties via the
 * Iron::Client::Event interface.
 */
class ZINC_LOCAL SystemClientEvent : virtual public Event {

    virtual boost::shared_ptr<synopsis> getMediumSynopsis() const;
    virtual boost::shared_ptr<synopsis> getLongSynopsis() const;
};

<metadata>
// Uranium/Uranium.Client.API/include/metadata/Event.h

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic 
{
  public:
    virtual std::string getSynopsis() const = 0;
};

// Uranium.Client.System/src/metadata/SystemClientEvent.h

class ZINC_LOCAL SystemClientEvent : virtual public Event
{
    std::string SystemClientEvent::getSynopsis() const
    {
        URANIUM_PROFILE_FUNC;
        return synopsis;
    }
};


This means "Event" is ABC that defines interfaces and SCE is proxy and concrete class to have
implementation that knows how to get these data from various components such as via dbus. 

How to select an appropriate class to use in client side? Uses 'namespace'

NS_URANIUM_LINEAR_CLIENT_OPEN
NS_URANIUM_METADATA_CLIENT_OPEN

note: Events differs in 'interfaces' and not like a simple structure. So how Events differs is not
to compare two in diff since it's up to SCE how to present via interface.


{SCE}
<linear>
typedef std::map<std::string,std::string> synopsis;

boost::shared_ptr<NS_IRON_SYSTEM::Event> systemEvent;

SystemClientEvent::SystemClientEvent(NS_IRON_SYSTEM::Event event_,
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> eventRepository_,
        boost::shared_ptr<NS_CADMIUM_SYSTEM::LinearAcquisition> linearAcquisition_,
        boost::weak_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> reminderRepository_)
    : eventRepository(eventRepository_),
      reminderRepository(reminderRepository_),

      systemEvent(boost::make_shared<NS_IRON_SYSTEM::Event>(event_)),

      linearAcquisition(convertToSync(linearAcquisition_))
{

}

1. events->push_back(
        make_shared<SystemClientEvent>(
            sysEvents.at(i), eventRepository, linearAcquisition, reminderRepository));

2. return make_shared<SystemClientEvent>(
        systemEvent.get(), sysEventRepository, sysLinearAcquisition, reminderRepository);


<metadata>
Metadat SCE has overloads

// <1> dtt event. from 'iron' <CSCE>
//
// used in DTT::getClientEvents(). run on a target: 'nothing' logged in the log
//
// note: fix: synopsis(extractValueFromMap(dttEvent.mediumSynopsis, lang)),

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
   const std::string& lang,
   const NS_IRON_SYSTEM::Event& dttEvent) :
   ...
   synopsis(extractValueFromMap(dttEvent.longSynopsis, lang))
{}



// <2> Constructs SystemClientEvent from Iron System Event and MAS event. 
//
// used in mergeEvent(). use <4> for mas and use <1> for dttEvent. uses dtt for some members and
// uses mas for some members. WRT Synopsis, uses DTT longSynopsis. So nothing logged in the log.
//
// note: if fix 1 and will be fixed as well.

SystemClientEvent::SystemClientEvent(shared_ptr<SystemClientEvent>& dttEvent,
        shared_ptr<SystemClientEvent>& masEvent):
   ...
   synopsis(dttEvent->getSynopsis()),
{
    // fill some from masEvent but not for synopsis.
}

// <3> Creates MAS event with a new broadcast time
//
// used in mergeEvent(). 
//
// note: if fix 4 and will be fixed as well.

SystemClientEvent::SystemClientEvent(shared_ptr<SystemClientEvent>& masEvent,
   const uint32_t start_,
   const uint32_t end_):
   ...
   synopsis(),
{}


// Creates MAS Event
// <4> used in IP::getClientEvents(). 'cobalt' and 'wrapper'
//
// run on a target: wrapper used but only 'medium' logged in the log. means that only medium from
// cobalt::result.
//
// note: fix: synopsis(masEvent.getSynopsis()),

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const SystemEventWrapper& masEvent) :
   ...
   synopsis(),
{
}

// Creates null event.
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos, 
    boost::shared_ptr<Service> service_, uint32_t start_, uint32_t end_):
    synopsis(),
{}


// <5> Creates a SystemClientEvent from FullEvent. This is used for linear search.
// used in Summary
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
            flags(0),
            isCachedFlag(false),
            id(locator),
            type(IP)
{
    const SystemClientFullEvent fullEvent = SystemClientFullEvent(sysResult);
    synopsis = fullEvent.getMediumSynopsis();
}

// note: do the same as 'wrapper' 
class SystemClientFullEvent : public FullEvent {
public:
    explicit SystemClientFullEvent(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
        scResult(sysResult),
        idBag(scResult)
    {}

    virtual std::string getMediumSynopsis() const
    {
       return scResult.getStringFromDescription("mediumSynopsis");
    }
};


{where-create-scs}
Calls to create SCE. 

<linear>
src/linear-metadata/SystemClientEventRepository.cpp

boost::shared_ptr<Event> makeEvent() 
{
  return make_shared<SystemClientEvent>(
      systemEvent.get(), sysEventRepository, sysLinearAcquisition, reminderRepository);
}

boost::shared_ptr<std::vector<boost::shared_ptr<Event> > > getPresentFollowing()
{
   eventsPtr->push_back(make_shared<SystemClientEvent>(
         *event, eventRepository, linearAcquisition, reminderRepository));
}


<merged>
270 Uranium.Client.System/src/metadata/EventCollectionOperations.cpp     

/**
 * Creates a null event a.k.a "no information available" event.
 * They basically are events which fill any gaps in schedule EventWindow may contain.
 */
boost::shared_ptr<SystemClientEvent> createNullEvent(boost::weak_ptr<MetadataRepositories> repos,
                                                     uint32_t service, uint32_t start, uint32_t end)
{
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> serviceRepo 
        = strongRepos->serviceRepo;

    //clog<<"Creating null event on service "<<service<<" time: ("<<start<<","<<end<<")"<<endl;
    
    return boost::make_shared<SystemClientEvent>(repos,
            serviceRepo->getServiceBySLI(service % serviceRepo->getServiceCount()), start, end);
}


={============================================================================
*kt_dev_uv_stack_205* stack: uranium: metadata: how events get updated

<0> EPG 
EPG uses this:
Package ctv.enhancedmetadata, Interface public interface EventRepository::getEventWindow

// from textEPG
//
// boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
//    boost::make_shared<TextEPGEventWindowEventListener>();
// 
// boost::shared_ptr<EventWindow>  EPG::createEventWindow( boost::shared_ptr<EventRepository> eventRepo)
// {
//     Future<boost::shared_ptr<EventWindow> > f = 
//         eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());
// 
//     boost::shared_ptr<EventWindow> newWindow = f.get();
// 
//     newWindow->addListener(listener);
//     return newWindow;
// }

<1>
This scenario is to make a command to FD(future dispatcher) and to get response, events, back.

// @brief A private struct capturing all the necessary data about the request to create a new
// EventWindow

struct EventWindowCreateCommand : public MetadataChangeListener {

    EventWindowCreateCommand(
            NS_ZINC::Promise<boost::shared_ptr<EventWindow> > promise_,
            Bounds location_,
            Bounds requestedDataBounds_,
            event_collection_ptr oldEvents_,
            boost::posix_time::ptime dataRetrievalStartTime_,
            boost::weak_ptr<ServiceRepository> serviceRepo_):
                promise(promise_),
                location(location_),
                requestedDataBounds(requestedDataBounds_),
                oldEvents(oldEvents_),
                newMASEvents(boost::make_shared<event_collection>()),
                newDTTEvents(boost::make_shared<event_collection>()),
                newEvents(boost::make_shared<event_collection>()),
                newWindow(),
                serviceRepo(serviceRepo_),
                promiseCompleted(false),
                dataRetrievalStartTime(dataRetrievalStartTime_),
                masDataRequested(false),
                dttDataRequested(false),
                noDttDataFound(false),
                metadataChanged(false),
                isListeningToMetadataChanges(false)
    {
    }

    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > promise;

    //Events from old event window that intersect with the new one
    event_collection_ptr oldEvents;
    //Events for this event window that came from MAS
    event_collection_ptr newMASEvents;
    //Events for this event window that came from Iron
    event_collection_ptr newDTTEvents;

    //The window created as a result of this request
    boost::weak_ptr<SystemClientEventWindow> newWindow;
};



void SystemClientEventRepository::getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
{
  URANIUM_FUNC_TRACE;
  URANIUM_PROFILE_FUNC;
  Bounds& dataRetrievalBounds = cmd.requestedDataBounds;

  int64_t start = to_time_t(dataRetrievalBounds.startTime);
  int64_t end = to_time_t(dataRetrievalBounds.startTime) + dataRetrievalBounds.seconds;

  // note: create FB with FD

  NS_ZINC::FutureBarrier bar(*getFutureDispatcher());

  // eventsReceived is overloaded, we need to get the pointer to it first, and the pass to bind.
  
  // 'cobalt'
  void (SystemClientEventRepository::*masCallback)
    (boost::shared_ptr<EventWindowCreateCommand>,
     const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result > > &) =
    &SystemClientEventRepository::eventsReceived;

  // 'iron'
  void (SystemClientEventRepository::*dttCallback)
    (boost::shared_ptr<EventWindowCreateCommand>,
     const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > &) =
    &SystemClientEventRepository::eventsReceived;

  // 'cmd'. create 'window'
  //the two callbacks share the ownership of the command
  boost::shared_ptr<EventWindowCreateCommand> sharedCmd = boost::make_shared<EventWindowCreateCommand>(cmd);

  //make sure that if something changes about the metadata while we're retrieving it from system API,
  //we know about it and can react appropriately (e.g. marking the EventWindow about to be created as stale)
  metadataObserver->addListener(sharedCmd);

  // calls 'merge' events
  // 'eventWindowDataRetrievalComplete'
 
  bar.setCallback(
          boost::bind
            (&SystemClientEventRepository::eventWindowDataRetrievalComplete, shared_from_this(), sharedCmd)
          );

  // 'request' data from System API:

  if(recids.empty() == false)
  {
    URANIUM_INFO("Requesting schedule metadata from MAS.");

    // note: <dbus-call-to-cobalt>
    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
      metadataBroker->getEventSummariesByServices(recids, start, end);
    
    // note: maps 'future' to masCallback 

    bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));
  }

  if(locators.empty() == false)
  {
    URANIUM_INFO("Requesting schedule metadata from DTT.");

    int64_t dttStart = adjustDTTWindowStart(config, start);

    // <dbus-call> getScheduleEvents
    Future <vector<NS_IRON_SYSTEM::Event>> fDTTEvents 
      = systemEventRepo->getScheduleEvents(locators, dttStart, end);

    // note: maps 'future' to masCallback 

    bar.addWithCallback(fDTTEvents, boost::bind(dttCallback, this, sharedCmd, _1));
  }
}


::FutureBar    <- from dbus and wait on future for calls?


<callback-one>
typedef std::vector<boost::shared_ptr<SystemClientEvent> > event_collection;
typedef boost::shared_ptr<event_collection> event_collection_ptr;

note: getClientEvents are overloads for IP or DTT

// old
//
// # IP version note:  getClientEvents from 'cobalt'
// 
// void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
//         const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
// {
//     const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();
// 
//     event_collection_ptr  clientEvents = getClientEvents(systemEvents);
// 
//     copy(clientEvents->begin(), clientEvents->end(), back_inserter(*command->newMASEvents));
// 
//     //
//     // <Q> HOW THIS newMASEvents get delivered to EPG?
//     //
// }
// 
// event_collection_ptr getClientEvents(const std::vector<NS_COBALT_SYSTEM::Result>& systemResults)
// {
//     BOOST_FOREACH(const NS_COBALT_SYSTEM::Result& sysResult, systemResults)
//     {
//         // 'wrapper'  note: wrapper is no longer used in the john's change.
//         // need to check!
//         
//         SystemEventWrapper ewrap(boost::make_shared<NS_COBALT_SYSTEM::Result>(sysResult));
// 
//         boost::shared_ptr<SystemClientEvent> mevent =
//             boost::make_shared<SystemClientEvent>(getRepos(), ewrap);
//         events->push_back(mevent);
//     }
// 
//     return events;
// }


// new: do not use wrapper

void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
        const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
{
    try
    {
        const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();

        // note: build vector<sp<sce>> from vector<result>

        event_collection_ptr  clientEvents = getClientEvents(systemEvents);

        // note: copy vector<sp> to vector<sp> in cmd object
        //
        // newMASEvents(boost::make_shared<event_collection>()),
        //
        // WHY? copy a vector to newMASEvents. CAN BE REMOVED?
        
        copy(clientEvents->begin(), clientEvents->end(), back_inserter(*command->newMASEvents));

        URANIUM_DEBUG("Got "<<clientEvents->size() <<" events from MAS.");

        //if there was no dtt request, continue with creation of the window
        if(command->promiseCompleted == false)
        {
            if((command->dttDataRequested == false) || (command->noDttDataFound == true))
            {
            	URANIUM_DEBUG("Creating window from IP data.");
                clog<<"Creating window from IP data."<<endl;

                event_collection_ptr events = prepareEventsForNewEventWindow(*command, command->newMASEvents);

                // note: signals "done"
                
                command->promise.complete(createEventWindow(*command, events));
                command->promiseCompleted = true;
            }
        }
    }
}


event_collection_ptr SystemClientEventRepository::prepareEventsForNewEventWindow(
        EventWindowCreateCommand& command,
        event_collection_ptr newEvents)
{
    // note: copy ctor sp vector again.

    event_collection_ptr events = boost::make_shared<event_collection>();
    //add in the newly fetched events.
    events->insert(events->end(), newEvents->begin(), newEvents->end());

    //add to events whatever we have in cache.
    event_collection_ptr cachedEvents = getEventCache()->get(command.location, true).events;
    setCached(cachedEvents);
    events = uniqueJoin(events, cachedEvents);

    //Add any events we might have from the old window.
    if(command.oldEvents != 0)
    {
        setCached(command.oldEvents);
        events = uniqueJoin(events, command.oldEvents);
    }

    //We might have requested more data than necessary. These events should go into cache, but not into
    //any window we might be creating now. Filter these events out for now.
    //Sanitisation to make sure errors in schedule don't cause us pain.

    events = sanitizeEvents(events, command.location, getRepos());
    //insert null events to cover any gaps in the event window
    insertNullEvents(command.location, events, getRepos(), config);

    return events;
}

event_collection_ptr SystemClientEventRepository::getClientEvents(
            const std::vector<NS_COBALT_SYSTEM::Result>& systemResults)
{
    URANIUM_PROFILE_FUNC;
    event_collection_ptr events = boost::make_shared<event_collection>();

    events->reserve(systemResults.size());

    BOOST_FOREACH(const NS_COBALT_SYSTEM::Result& sysResult, systemResults)
    {
        boost::shared_ptr<SystemClientEvent> mevent =
            boost::make_shared<SystemClientEvent>(getRepos(), sysResult);

        events->push_back(mevent);
    }
    return events;
}


# DTT version note:  getClientEvents from 'iron'
#
void eventsReceived(
   boost::shared_ptr<EventWindowCreateCommand> command,
   const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > & eventsFV)
{
   event_collection_ptr clientEvents = getClientEvents(systemEvents);
}  

event_collection_ptr getClientEvents(
            const std::vector<NS_IRON_SYSTEM::Event> & events) 
{
    BOOST_FOREACH(const NS_IRON_SYSTEM::Event& event, events)

    boost::shared_ptr<SystemClientEvent> scEvent = make_client_event(event);
}


// src/metadata/SystemClientEventRepository.cpp

boost::shared_ptr<SystemClientEvent> make_client_event(const NS_IRON_SYSTEM::Event& e)
{
  if(!e.eventLocator.empty())
  {
    // note: uses <1> and see above. <CSCE>
    return boost::shared_ptr<SystemClientEvent>( 
        new SystemClientEvent(getRepos(), config->getLanguage(), e));
  }

  return boost::shared_ptr<SystemClientEvent>();
}


<callback-two> 'merge' events

// called from getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
//
void SystemClientEventRepository::eventWindowDataRetrievalComplete(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    event_collection_ptr events =  mergeEvents(command->newDTTEvents, command->newMASEvents);

    notifyExistingWindowAboutNewData(command);
}


/**
 * Merges two sets of events coming from different data sources
 */
event_collection_ptr mergeEvents(event_collection_ptr dttEvents, event_collection_ptr masEvents)
{

    BOOST_FOREACH(boost::shared_ptr<SystemClientEvent>& edtt, *dttEvents)

    event_collection::iterator eip = // SCE in masEvents

    // 102 <2>
    //there is one, merge the properties
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(edtt, *eip));

    // note: eip is SCE here !!!

    BOOST_FOREACH(boost::share d_ptr<SystemClientEvent>& eip, *masEvents)

    boost::shared_ptr<SystemClientEvent> firstDTTEvent = *firstDTTEventIter;
    boost::shared_ptr<SystemClientEvent> lastDTTEvent = *lastDTTEventIter;

    // 189 <3>
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(eip, eip->getStartAsTimeT(), firstDTTEvent->getStartAsTimeT()));

    // 202
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(eip, lastDTTEvent->getEndAsTimeT(), eip->getEndAsTimeT()));
}


<notify-to-epg>

class ZINC_EXPORT EventListener : virtual public Polymorphic 

class ZINC_EXPORT `EventWindowEventListener` : public NS_ZINC::EventListener
{
    /**
     * Indicates the Event Window has changed substantially. To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged() = 0;

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void EventsChanged(const std::vector<boost::shared_ptr<Event> > events) = 0;
};

// note: from textEPG

class TextEPGEventWindowEventListener : public EventWindowEventListener
{
public:

    /**
     * Indicates the Event Window has changed substantially. To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged()
    {
    	printDebug("EventWindowChanged.");
        actionProcessor->post(boost::bind(&doRefreshWindowAndPrintStats));
    }

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void EventsChanged(
            const std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> >  events)
    {
        string s = "EventsChanged: ";
        BOOST_FOREACH(boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e, events)
        {
            s += e->getTitle() + string("(") +
                    boost::lexical_cast<string>(e->getContainingServiceListIndex()) + string("), ");
        }
        printDebug(s);
        sleep(3);
        actionProcessor->post(doRefreshWindowAndPrintStats);
    }
};


boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
   boost::make_shared<TextEPGEventWindowEventListener>();


boost::shared_ptr<EventWindow>  EPG::createEventWindow(
        boost::shared_ptr<EventRepository> eventRepo)
{
    Future<boost::shared_ptr<EventWindow> > f = 
        eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());

    boost::shared_ptr<EventWindow> newWindow = f.get();

    // note: mean that got window from future?
    
    newWindow->addListener(listener);

    return newWindow;
}


template<class ListenerT>
class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer<ListenerT> 
{
    virtual void addListener(boost::shared_ptr<ListenerT> listener) {
        // Hoisting note: we cast to void* here, and cast back down in
        // DowncastingCaller so everything is lovely and symmetrical
        impl.addListener(listener);
    }
};

typedef void hoisted_event_listener;

// from class definition

void addListener(boost::shared_ptr<hoisted_event_listener> listener, 
        boost::shared_ptr<EventDispatcher> clientDispatcher=boost::shared_ptr<EventDispatcher>());

// /Zinc/Zinc.Common/src/DispatchingEventProducer.cpp

void DispatchingEventProducerHoisted::addListener(
   boost::shared_ptr<hoisted_event_listener> listener, boost::shared_ptr<EventDispatcher> clientDispatcher) 
{

    if (!listener) {
        throw std::invalid_argument("NULL listener provided in call to addListener()!");
    }

    ZINC_COMMON_DEBUG(std::string(__func__)+" Dispatcher: "
            +boost::lexical_cast<std::string>(static_cast<const EventDispatcher*>(clientDispatcher.get()))+
            ", Producer: "+boost::lexical_cast<std::string>(this)+
            ", Listener: "+boost::lexical_cast<std::string>(listener.get())
            );

    bool duplicate = false;

    boost::mutex::scoped_lock lock(mutex);

    if (!clientDispatcher) {
        if (!dispatcher) {
            throw std::logic_error("addListener() called, but event producer has no dispatcher set.");
        }
        clientDispatcher = dispatcher;
    }

    // Call entry->second->onWorkAdded()
    Dispatcher::work work(*clientDispatcher);

    // note: make one which is a pair
    
    listener_entry newEntry(listener, clientDispatcher);

    BOOST_FOREACH(const listener_entry& entry, listeners) {

        if (entry.first == newEntry.first) {
            duplicate = true;
            break;
        }
    }

    if (!duplicate) {
        work.release();

        // note: push one
        
        listeners.push_front(newEntry);
    }
}


void SystemClientEventRepository::notifyExistingWindowAboutNewData(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    boost::shared_ptr<SystemClientEventWindow> w = command->newWindow.lock();

    if (w && (cacheGetResult.isStale() == false || w->isCreatedFromStaleData() == false))
    {
        URANIUM_DEBUG("Sending update to the existing window.");
        w->ConfigChanged();
    }
}

void SystemClientEventWindow::ConfigChanged()
{
    isStale = true;
    std::clog<<"EventWindow: Config changed"<<std::endl;
    notifyWindowChanged();
}


// void SystemClientEventWindow::notifyWindowChanged()
// {
// 
//     // ?? 
//     // void SystemClientEventWindow::EventsChanged
//     // (const std::vector<std::string> &eventIdentifiers)
//     
//     produceEvent(bind(&EventWindowEventListener::EventWindowChanged, _1));
// }

void SystemClientEventWindow::notifyEventsChanged(
        std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> > events)
{
    produceEvent(bind(&EventWindowEventListener::EventsChanged, _1, events));
}


<DEPH> Zinc/Zinc.Common/src/DispatchingEventProducer.cpp

typedef std::pair<boost::weak_ptr<hoisted_event_listener>, boost::shared_ptr<EventDispatcher> > 
   listener_entry;

class ZINC_EXPORT DispatchingEventProducerHoisted : boost::noncopyable 
{
    DispatchingEventProducerHoisted(boost::shared_ptr<EventDispatcher> dispatcher_) :
        dispatcher(dispatcher_) { }

    // note: event is 'functor'
    
    void produceEvent(boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event) 
    {
        boost::mutex::scoped_lock lock(mutex);

        size_t len = listeners.size();

        // note: copy listeners to localListeners

        // We copy listeners to this stack allocated array before dispatch so we
        // don't have to hold the lock while calling user code.
        listener_entry localListeners[len];
        listener_entry* next = localListeners;

        std::list<listener_entry>::iterator i = listeners.begin();

        std::list<listener_entry> forRemoval;
        while (i != listeners.end()) {

            if (!i->first.expired()) {
                *next++ = *i;
                ++i;
            } else {
                // Listener or dispatcher instance may have been destroyed since it was registered.
                // Detect this, and remove from collection.
                // Avoid calling dispatcher destructors while the mutex is locked.
                forRemoval.splice(forRemoval.end(), listeners, i++);
                len--;
            }
        }

        // Don't hold locks while running user code:
        lock.unlock();

        BOOST_FOREACH(listener_entry& l, forRemoval) {

            // note: DISPATCH. <Q> How this maps to 'dispatcher' which is DD.
            
            // Call entry->second->onWorkRemoved()
            Dispatcher::work(*l.second, boost::adopt_lock_t());
        }
        forRemoval.clear();

        for (size_t i = 0; i < len; ++i) {

            localListeners[i].second->post(
                    makeWeakFunctor(event, localListeners[i].first));
        }
    }

    private:
    /**
     * This is the default dispatcher. Clients can provide their own in addListener().
     */
    boost::shared_ptr<EventDispatcher> dispatcher;

    // note: 'mutable' ?
    mutable boost::mutex mutex;
};


/**
 * Make a WeakFunctor given a functor and a weak_ptr.
 */
template <typename Functor, typename T>
inline WeakFunctor<Functor, T>
makeWeakFunctor(Functor f, boost::weak_ptr<T> object)
{
    return WeakFunctor<Functor, T>(f, object);
}


//
// produceEvent(f)
//    -> dispatch thread calls 
//       f( <boost::weak_ptr<hoisted_event_listener> ); // event(pair.second);
//    
//       this expands to due to bind()
//
//       -> EventWindowEventListener::EventsChanged( <boost::weak_ptr<hoisted_event_listener> );
//


void SystemClientEventWindow::EventsChanged(const std::vector<std::string> &eventIdentifiers)
{
    URANIUM_FUNC_TRACE;
    if(!isZombie)
    {
        std::vector<boost::shared_ptr<Event> > eventsInThisWindow;
        eventsInThisWindow.reserve(events.size());

        BOOST_FOREACH(const std::string& identifier, eventIdentifiers)
        {
            vector<boost::shared_ptr<Event> > events = this->findEventsByIdentifier(identifier);
            eventsInThisWindow.insert(eventsInThisWindow.end(), events.begin(), events.end());
        }

        URANIUM_DEBUG("Number of events changed in this window: "<<eventsInThisWindow.size());

        if(!eventsInThisWindow.empty())
        {
            notifyEventsChanged(eventsInThisWindow);
        }
    }
    else
    {
        URANIUM_INFO("Ignoring events change signal - this window requires refresh anyway.");
    }
}


={============================================================================
*kt_dev_uv_stack_206* stack: uranium: metadata: event data flow

// Uranium/Uranium.Client.System/src/metadata/SystemEventWrapper.h

NS_URANIUM_METADATA_CLIENT_OPEN

class SystemEventWrapper  {
public:

    // note: "::cobalt::system"
    
    explicit SystemEventWrapper(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
        scResult(sysResult),
        idBag(scResult)
    {}

    std::string getOwningServiceId() const
    {
        return scResult.getStringFromDescription("owningServiceId");    // note: key
    }

    ...

    SystemClientResult scResult;
    IdentifierBag idBag;
};


class SystemClientResult
{
    // note: this is SP
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;

    explicit SystemClientResult(
            boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
        :sysResult(sysResult)
    {}

    std::string getFirstValueFromDescription(const std::string& key, bool toLower = true) const;

    public:

    string SystemClientResult::getStringFromDescription(const std::string& key) const
    {
        return getFirstValueFromDescription(key, false);
    }

    // note: key
    string SystemClientResult::getFirstValueFromDescription(const std::string& key,
            bool toLower) const
    {
        map<string, vector<string> >::const_iterator iter;

        if((iter = sysResult->description.find(key)) == sysResult->description.end())
        {
            return string();
        }
        vector<string> values = iter->second;
        if(values.size() == 0)
        {
            return string();
        }
        string s = values[0];
        if(toLower)
        {
            s = boost::to_lower_copy(s);
        }
        return s;
    }

    private:
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;
};


{from-cobalt}

// this is old

1. get a 'reference' to "Result" array from "Future". NO COPY. 

std::vector<NS_COBALT_SYSTEM::Result>

2. copy ctor "Result" from future Result. note: COPY COST

3. populate SEWs with SP to ctored 'each' "Result" and construct vector< SP< SCE >> 

SystemEventWrapper ewrap(boost::make_shared<NS_COBALT_SYSTEM::Result>(sysResult));

boost::shared_ptr<SystemClientEvent> mevent =
   boost::make_shared<SystemClientEvent>(getRepos(), ewrap);


// this is new   

1. get a 'reference' to array<cobalt::Result> from "Future". NO COPY. 

std::vector<NS_COBALT_SYSTEM::Result>

2. construct SCE for each result in the arrary. SCE uses &Result. NO copy.

3. push SP<SCE> into vector< SP< SCE >> 

 Future                    NO COPY via ref      SCER                    CMD
 -----------------------------------------------------------------------------------------
 vector<cobalt::result>       -->               vector<SP<SCE>>         <vector<SP<SCE>> 
 [0]
 [1]
 ...

 Q. Why copy a vector to a vector in window cmd?


{from-iron}

1. get a 'reference' to "Event" array from "Future". NO COPY. 

std::vector<NS_IRON_SYSTEM::Event>

2. populate SCE with SP to ctored "Result" and construct vector< SP< SCE >> 

boost::shared_ptr<SystemClientEvent>( 
        new SystemClientEvent(getRepos(), config->getLanguage(), e));


={============================================================================
*kt_dev_uv_stack_207* stack: uranium: metadata: summary data flow

1. From EPG?

  NS_ZINC::Future<boost::shared_ptr<SummaryResultSet>> search(const std::string& searchTerms,
      boost::shared_ptr<SearchOptions> searchOptions,
      size_t start,
      size_t size) const
  {
    shared_ptr<SystemClientSearchOptions> scSearchOptions
      = boost::dynamic_pointer_cast<SystemClientSearchOptions>(searchOptions);

    // note: <dbus-call-to-cobalt>
    return metadataBroker->search(searchTerms,
        getSysQopts(scSearchOptions),
        getSysGopts(scSearchOptions),
        scSearchOptions->getFilters(),
        start,
        size)
      .then(*getDispatcher(),
          bind(&SystemClientMetadataBroker::searchCallback,
            shared_from_this(),
            start,
            _1));
  }


2-7.

result set     client type                   system type on dbus
---------      ------------------------      -------------------------------
[SRS].SP    -> vector< SP<SCS> >             
                  [ SCS ].SP  -> class Result object      <- copied from struct Result[i]
                  [ SCS ].SP  -> class Result object
                  ...


2. Callback from cobalt. Get "ResultSet"

boost::shared_ptr<SummaryResultSet>
SystemClientMetadataBroker::searchCallback(uint32_t requestedStartIndex,
    const NS_ZINC::FutureValue<NS_COBALT_SYSTEM::ResultSet>& fvSystem) const
{
    translateAndThrowCobaltSystemExceptions(fvSystem.getError());

    // note: COPY CTOR. copies all from future and once copied, destoried in this function.
    // sysval.results :  std::vector< Result > results;
    //
    // <Q> is there also a copy in 'future'?
    
    NS_COBALT_SYSTEM::ResultSet sysval = fvSystem.get();

    boost::shared_ptr<SystemClientSummaryResultSet> srs =
        convert(sysval, boost::shared_ptr<SystemClientSummaryResultSet>(), requestedStartIndex);

    metadataObserver->addListener(srs);
    srs->setDispatcher(getDispatcher());

    return boost::static_pointer_cast<SummaryResultSet>(srs);
}


3. call Convert. ResultSet -> SummaryResultSet

boost::shared_ptr<SystemClientSummaryResultSet>
Converter::operator()(const NS_COBALT_SYSTEM::ResultSet& rs,
        boost::shared_ptr<SystemClientSummaryResultSet>, uint32_t requestedStartIndex) const
{
    return boost::make_shared<SystemClientSummaryResultSet>(
            boost::make_shared<NS_COBALT_SYSTEM::ResultSet>(rs), config, repos, 
            provisioningCache, requestedStartIndex);
}


4. SystemClientSummaryResultSet

Uranium.Client.System/src/metadata/SystemClientSummaryResultSet.cpp

this is 'only' place to use SCS and the the set is a vector of SCS. See <CMB>

typedef boost::shared_ptr<Summary> SummaryPtr;

class SystemClientSummaryResultSet : public SummaryResultSet, public MetadataChangeListener
{
    boost::shared_ptr<std::vector<SummaryPtr> > summaries;

    SystemClientSummaryResultSet( 
            boost::shared_ptr<NS_COBALT_SYSTEM::ResultSet> sysResultSet,
            boost::shared_ptr<SystemClientMetadataConfig> config,
            boost::weak_ptr<MetadataRepositories> repos,
            boost::shared_ptr<ProvisioningCache> provisioningCache_,
            uint32_t startIndex )

        : provisioningCache(provisioningCache_),
        summaries(

                getClientSummaries(sysResultSet->results, config, repos, startIndex)),

        totalMASResultSetSize(sysResultSet->totalSize)
        {
        }
};


5. SummaryClientSummary

class ZINC_EXPORT Summary : virtual public NS_ZINC::Polymorphic

class SystemClientSummary : public Summary
{
  public:
    SystemClientSummary(
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult,
        boost::shared_ptr<SystemClientMetadataConfig> config,
        boost::weak_ptr<MetadataRepositories> repos_,
        boost::shared_ptr<ProvisioningCache> provisioningCache_,
        uint32_t absoluteIndex_);

    :sysResult(sysResult), config(config), repos(repos_)
    {}

    virtual boost::shared_ptr<Event> getEvent()
    {
      if(entityType != ENTITY_SCHEDULE_EVENT)
      {
        throw EntityNotPresentException("Incorrect entity type. Expected " +
            boost::lexical_cast<string>(ENTITY_SCHEDULE_EVENT) + ", got " +
            boost::lexical_cast<string>(entityType));
      }

      // note: uses <3> to create SCS and see above. metedata-overload
      
      return boost::make_shared<SystemClientEvent>(repos, sysResult);
    }

  private:
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;
    boost::weak_ptr<MetadataRepositories> repos;
};


6. vector< SP<SCS> > 

typedef std::vector<boost::shared_ptr<Summary> > summary_ptr_vector;

boost::shared_ptr<SystemClientSummaryResultSet::summary_ptr_vector>
    SystemClientSummaryResultSet::getClientSummaries( const std::vector< Result >& systemResults,
                                                      boost::shared_ptr<SystemClientMetadataConfig> config,
                                                      boost::weak_ptr<MetadataRepositories> repos,
                                                      uint32_t startIndex)
{
  shared_ptr<summary_ptr_vector> clientSummaries = make_shared<summary_ptr_vector>();

  clientSummaries->reserve(systemResults.size());

  for( size_t i = 0; i < systemResults.size(); ++i)
  {
    clientSummaries->push_back(
        make_shared_summary( systemResults[i], config, repos, provisioningCache, i + startIndex) );
  }
  return clientSummaries;
}


7. Result -> SCS

shared_ptr<SystemClientSummary> make_shared_summary( const Result& sysResult,
    boost::shared_ptr<SystemClientMetadataConfig> config,
    boost::weak_ptr<MetadataRepositories> repos,
    boost::shared_ptr<ProvisioningCache> provisioningCache,
    uint32_t index )
{
    // note: COPY SCS from vector<Result> results[i] since class Result don't define copy ctor.
    //
    // create SP{SCS} -> Result
    
    shared_ptr<Result> sysResultPtr = make_shared<Result>(sysResult);
    return make_shared<SystemClientSummary>(sysResultPtr, config, repos, provisioningCache, index);
}


<populate-to-others>
SCS has interfaces to make other class from "result" that SP points to. All class has
"SystemClientResult" member which has a SP to "result" and this SP is set to SP from SCS.


[ SCS ].SP        -> class Result object

[ Wrappers ].SP   -> the same "Result" object

class SystemClientBrand : public Brand 
{
    explicit SystemClientBrand(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
        :scResult(sysResult)
    {}

    private:
    SystemClientResult scResult;    note: has SP which is set to the arg SP.
};

   -> return boost::make_shared<SystemClientApplication>(sysResult);
   -> return boost::make_shared<SystemClientEvent>(repos, sysResult);
   -> return boost::make_shared<SystemClientProgrammeSummary>(sysResult);
   -> return boost::make_shared<SystemClientSeries>(sysResult);
   -> return boost::make_shared<SystemClientBrand>(sysResult);


<test>
Uranium.Client.System/test/metadata/SummaryTest.cpp

class ZINC_LOCAL SummaryTest :  NS_ZINC::IntegrationTestSandbox, public DefaultMetadataMocksEnvironment
{
  void testGetEventFromSummary()
  {
    SystemClientSummary summary( sysResult,
        clientFactory->createMetadataConfig(),
        clientFactory->createMetadataRepositories(),     note: this is repo(event)
        // These tests do not rely on ProvisioningCache
        boost::shared_ptr<ProvisioningCache>(),
        3 );

    CPPUNIT_ASSERT(summary.getEvent());
    CPPUNIT_ASSERT_EQUAL(string("Eastenders"), summary.getEvent()->getTitle());

   note: MEDIUM SYNOPSIS

   CPPUNIT_ASSERT_EQUAL(string("mediumSynopsis"), summary.getEvent()->getSynopsis());
   CPPUNIT_ASSERT(summary.getEvent()->getService());
  }
}


={============================================================================
*kt_dev_uv_stack_208* stack: uranium: metadata: wrapper and convert flow

1. From EPG?

NS_ZINC::Future<ProgrammePtr>
SystemClientMetadataBroker::getProgramme(
        const string& recId) const
{
    return metadataBroker->getProgramme(recId)
        .then(*getDispatcher(),
              bind(
                  &commonCallback< ProgrammePtr, NS_COBALT_SYSTEM::Result>, 
                  shared_from_this(), convert, _1));
}

template<typename ClientType, typename SysType>
ClientType commonCallback(
        const boost::shared_ptr<const SystemClientMetadataBroker>& broker,
        const Converter& convert,
        const NS_ZINC::FutureValue<SysType>& fvSystem)
{
    translateAndThrowCobaltSystemExceptions(fvSystem.getError());
    return convert(fvSystem.get(), ClientType());
}


2. COPY CTOR from "fvSystem.get()" to "SP<Result>". Client API wrapper

ProgrammePtr
Converter::operator()(const NS_COBALT_SYSTEM::Result& result,
        ProgrammePtr) const
{
    return boost::make_shared<SystemClientProgramme>(
            boost::make_shared<NS_COBALT_SYSTEM::Result>(result)
            );
}


={============================================================================
*kt_dev_uv_stack_209* stack: uranium: metadata and dbus inspection

# from lsdbus

1287  :1.57                    /opt/zinc/bin/ironmetadatad.oem                 
1287  Zinc.Metadata            /opt/zinc/bin/ironmetadatad.oem                 

# 'iron'
# /Iron/Iron.System.API/data/introspection-xml/service.xml
# note: see bus name
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0" name="/" yv:busname="Zinc.Metadata">
    <node name="Zinc/Metadata/EventRepository">
        <interface name="Zinc.Metadata.EventRepository"/>
    </node>
    <node name="Zinc/Metadata/RelatedContentRepository">
        <interface name="Zinc.Metadata.RelatedContentRepository"/>
    </node>
    <node name="Zinc/Metadata/ServiceRepository">
        <interface name="Zinc.Metadata.ServiceRepository"/>
    </node>
</node>


# 'cobalt'
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0" name="/" yv:busname="Zinc.Broker">
    <node name="Zinc/Broker/MetadataBroker">
        <interface name="Zinc.Broker.MetadataBroker"/>
    </node>
    <node name="Zinc/Broker/HiddenServicesStore">
        <interface name="Zinc.Broker.HiddenServicesStore"/>
    </node>
    <node name="Zinc/Broker/UnifiedServiceRepository">
        <interface name="Zinc.Broker.UnifiedServiceRepository"/>
    </node>
    <node name="Zinc/Broker/ProvisioningService">
        <interface name="Zinc.Broker.ProvisioningService"/>
    </node>
    <node name="Zinc/Broker/UnifiedEventRepository">
        <interface name="Zinc.Broker.UnifiedEventRepository"/>
    </node>
    <node name="Zinc/Broker/LinearAcquisitionServiceResolver">
        <interface name="Zinc.Broker.LinearAcquisitionServiceResolver"/>
    </node>
    <node name="Zinc/Broker/DeviceConfig">
        <interface name="Zinc.Broker.DeviceConfig"/>
    </node>
</node>


# note: auto generated to
# zinc-build-root/release-humax-dtr_t1000/Iron/Iron.System.API/include/SystemFactory.h

namespace Zinc { namespace Metadata {

struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Metadata::EventRepository> createEventRepository() = 0;
    virtual boost::shared_ptr<Zinc::Metadata::RelatedContentRepository> createRelatedContentRepository() = 0;
    virtual boost::shared_ptr<Zinc::Metadata::ServiceRepository> createServiceRepository() = 0;
};
} //namespace
} //namespace


namespace Zinc { namespace Broker {

struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> createMetadataBroker() = 0;
    virtual boost::shared_ptr<Zinc::Broker::HiddenServicesStore> createHiddenServicesStore() = 0;
    virtual boost::shared_ptr<Zinc::Broker::UnifiedServiceRepository> createUnifiedServiceRepository() = 0;
    virtual boost::shared_ptr<Zinc::Broker::ProvisioningService> createProvisioningService() = 0;
    virtual boost::shared_ptr<Zinc::Broker::UnifiedEventRepository> createUnifiedEventRepository() = 0;
    virtual boost::shared_ptr<Zinc::Broker::LinearAcquisitionServiceResolver> 
        createLinearAcquisitionServiceResolver() = 0;
    virtual boost::shared_ptr<Zinc::Broker::DeviceConfig> createDeviceConfig() = 0;

};
} //namespace
} //namespace


# from lsdbus

1055  :1.20                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  :1.45                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  Zinc.Broker              /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  Zinc.MetadataProxy       /opt/zinc-trunk/bin/cobaltmetadatabrokerd        

1237  :1.69                    /opt/stagecraft-2.0/bin/stagecraft --astrace --bgalpha 0 --outputrect
0,0,1280,720 --extensionsdir /opt/zinc-trunk/lib/stagecraft2-extensions --profile extendedTV
--modulemap IGraphicsDriver:/opt/stagecraft-2.0/bin/libIGraphicsDriver2.so /app        

# from dbus full log <getScheduleEvents>

method call sender=:1.20 -> dest=Zinc.Metadata serial=7034 path=/Zinc/Metadata/EventRepository; interface=Zinc.Metadata.EventRepository; member=getScheduleEvents

method return sender=:1.20 -> dest=:1.69 reply_serial=4682

   array [
      struct {
         string "12651407"
         int64 1426653570
         int64 1427284880
         int32 0
         array [
         ]
         array [
            dict entry(
               string "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"
               array [
                  string "dvb://233a..5a90;3cf"
               ]
            )
         ]
         array [
         ]
         array [
            dict entry(
               string "entityType"
               array [
                  string "scheduleevent"
               ]
            )
            dict entry(
               string "eventId"
               array [
                  string "12651407"
               ]
            )
            dict entry(
               string "eventTitle"
               array [
                  string "TruTV is on ch. 68..."
               ]
            )
            dict entry(
               string "isAdult"
               array [
                  string "0"
               ]
            )
            dict entry(
               string "mediumSynopsis"
               array [
                  string "...truTV +1 returns at 5am"
               ]
            )
            dict entry(
               string "owningServiceId"
               array [
                  string "10193572"
               ]
            )
            dict entry(
               string "start"
               array [
                  string "2015-03-25T09:00:00Z"
               ]
            )
         ]
         array [
            dict entry(
               string "classifiers"
               array [
                  struct {
                     array [
                        dict entry(
                           string "categoryScheme"
                           string "urn:dtg:metadata:cs:DTGGenreCS:2010-11"
                        )
                     ]
                     string "0"
                  }
               ]
            )
            dict entry(
               string "mediaContent"
               array [
                  struct {
                     array [
                        dict entry(
                           string "aspectRatio"
                           string "4:3"
                        )
                        dict entry(
                           string "audioLanguage"
                           string "eng"
                        )
                        dict entry(
                           string "audioMixType"
                           string "1"
                        )
                        dict entry(
                           string "contentDuration"
                           string "28800"
                        )
                        dict entry(
                           string "contentIsHighDefinition"
                           string "0"
                        )
                        dict entry(
                           string "format"
                           string "sd"
                        )
                        dict entry(
                           string "mediaType"
                           string "video"
                        )
                     ]
                     string ""
                  }
               ]
            )
         ]
      }
      struct {
         string "12655907"
         int64 1426654853
         int64 1427284880
         int32 0
         array [
         ]
         array [
            dict entry(
               string "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"
               array [
                  string "dvb://233a..a0b0;cca3"
               ]
            )
         ]
         array [
         ]
         array [
            dict entry(
               string "entityType"
               array [
                  string "scheduleevent"
               ]
            )
            dict entry(
               string "eventId"
               array [
                  string "12655907"
               ]
            )
            dict entry(
               string "eventTitle"
               array [
                  string "FIM X-Trial World Championship"
               ]
            )
            dict entry(
               string "isAdult"
               array [
                  string "0"
               ]
            )
            dict entry(
               string "mediumSynopsis"
               array [
                  string "Coverage from the X-Trial World Championship where the world's 
                  top riders attempt to clear a series of near-impossible obstacles in the 
                  fastest time. Action from Wiener Neustadt (Austria)."
               ]
            )
            dict entry(
               string "owningServiceId"
               array [
                  string "10672980"
               ]
            )
            dict entry(
               string "start"
               array [
                  string "2015-03-25T09:00:00Z"
               ]
            )
         ]
         array [
            dict entry(
               string "classifiers"
               array [
                  struct {
                     array [
                        dict entry(
                           string "categoryScheme"
                           string "urn:dtg:metadata:cs:DTGGenreCS:2010-11"
                        )
                     ]
                     string "0"
                  }
               ]
            )
            dict entry(
               string "mediaContent"
               array [
                  struct {
                     array [
                        dict entry(
                           string "aspectRatio"
                           string "16:9"
                        )
                        dict entry(
                           string "audioLanguage"
                           string "eng"
                        )
                        dict entry(
                           string "audioMixType"
                           string "2"
                        )
                        dict entry(
                           string "contentDuration"
                           string "3900"
                        )
                        dict entry(
                           string "contentIsHighDefinition"
                           string "0"
                        )
                        dict entry(
                           string "format"
                           string "sd"
                        )
                        dict entry(
                           string "mediaType"
                           string "video"
                        )
                     ]
                     string ""
                  }
               ]
            )
         ]
      }
      ...
   ]


={============================================================================
*kt_dev_uv_stack_210* stack: uranium: metata test

/data/builds/DEVARCH-8092/huawei.370/ \
   zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/tests/uranium-client-system/test/metadata

test/metadata/Makefile.am

summarytest_SOURCES = SummaryTest.cpp $(metadata_helpers)
summarytest_LDADD = $(ldadd_static)

note: see that executables are all lowercases.

{xx}       
Uranium.Client.System/test/metadata/SystemClientEventRepositoryTest.cpp

<MOCK-EDIS>
typedef InlineDispatcher MultipleListenerEventDispatcher;


{system-component-mocks}

note:
These mocks are generated in the build root for each system component.

./Iron/Iron.System.API/include/mock/MockEventRepositoryEventListener.h
./Iron/Iron.System.API/include/mock/MockEventRepositorySync.h
./Iron/Iron.System.API/include/mock/MockEventRepositoryAsync.h

<1> system API
/*
 * include/EventRepositoryAsync.h
 *
 * This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 * Template base-async.template
 * Using
 * /DEVARCH/Iron/Iron.System.API/data/introspection-xml/interface-EventRepository.xml
 */

namespace Zinc { namespace Metadata {

class EventRepositoryEventListener;

class ZINC_EXPORT EventRepositoryAsync : 
    public virtual NS_ZINC::DispatchingEventProducer<EventRepositoryEventListener>
{

/* =============================== Methods ================================= */
public:

    virtual NS_ZINC::Future< std::vector< Event > > 
        getPresentFollowing(const std::string& serviceLocator_in) = 0;

    virtual NS_ZINC::Future< Event > getEvent(const std::string& eventLocator_in) = 0;

    <getScheduleEvents>
    virtual NS_ZINC::Future< std::vector< Event > > getScheduleEvents(
               const std::vector< std::string >& serviceLocators_in, 
               const uint32_t startTime_in, const uint32_t endTime_in) = 0;

    virtual NS_ZINC::Future< std::vector< Event > > findByProgrammeCrid(
               const std::string& programmeCrid_in) = 0;

    virtual NS_ZINC::Future< std::vector< Event > > 
        findBySeriesCrid(const std::string& seriesCrid_in) = 0;

protected:
   virtual ~EventRepositoryAsync();
};


<2>  system API mock
/*
 * This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */
namespace Zinc { namespace Metadata {

class ZINC_LOCAL MockEventRepositoryAsync: public EventRepositoryAsync
{
public:
/* ============================== Methods ================================== */

   typedef std::vector< Event > Mock_getPresentFollowingRet;
   MOCK_METHOD1(getPresentFollowing, NS_ZINC::Future< Mock_getPresentFollowingRet > (const std::string&));

   typedef Event Mock_getEventRet;
   MOCK_METHOD1(getEvent, NS_ZINC::Future< Mock_getEventRet > (const std::string&));

   <getScheduleEvents>
   typedef std::vector< Event > Mock_getScheduleEventsRet;
   MOCK_METHOD3(getScheduleEvents, 
           NS_ZINC::Future< Mock_getScheduleEventsRet > 
           (const std::vector< std::string >&, const uint32_t, const uint32_t));

   typedef std::vector< Event > Mock_findByProgrammeCridRet;
   MOCK_METHOD1(findByProgrammeCrid, NS_ZINC::Future< Mock_findByProgrammeCridRet > (const std::string&));

   typedef std::vector< Event > Mock_findBySeriesCridRet;
   MOCK_METHOD1(findBySeriesCrid, NS_ZINC::Future< Mock_findBySeriesCridRet > (const std::string&));

/* ============================== Signals ================================== */
   void emitPresentFollowingChange(const std::string& serviceLocator, 
           const std::vector< Event >& events)
   {
       produceEvent(
               boost::bind(&EventRepositoryEventListener::PresentFollowingChange,
                   _1,
                   serviceLocator,
                   events));
   }

   void emitScheduleChange(const std::string& serviceLocator, 
           const uint32_t start, const uint32_t end, const std::vector< Event >& events)
   {
       produceEvent(
               boost::bind(&EventRepositoryEventListener::ScheduleChange,
                   _1,
                   serviceLocator,
                   start,
                   end,
                   events));
   }

   virtual ~MockEventRepositoryAsync() { };
};

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT MockEventRepositoryAsyncWithCallbacks : 
    public virtual NS_IRON_SYSTEM::MockEventRepositoryAsync 
{
public:
    void publicProduceEvent(boost::shared_ptr<NS_ZINC::Event> event) const
    {
        URANIUM_FUNC_TRACE;
        produceEvent(event);
    }
};


{use-mock-in-test}

note: this has overloads

void setUp()
{
    // this is inline dispatcher
    systemEventDispatcher = boost::make_shared<MultipleListenerEventDispatcher>();

    // create mock ER
    mockEventRepo = boost::make_shared<NS_IRON_SYSTEM::MockEventRepositoryAsync>();
    mockEventRepo->setDispatcher(systemEventDispatcher);

    // create mock SR
    mockServiceRepo = boost::make_shared<NS_COBALT_SYSTEM::MockUnifiedServiceRepositoryAsync>();
    mockServiceRepo->setDispatcher(systemEventDispatcher);
}


void setUpClientFactory()
{
    clientFactory = TestSupport::createCobaltClientFactory();
}

    /**
     * Creates uranium::metadata::client::Factory and configures it for use in tests. 
     * Note: this no longer uses the plugin mechanism to get the client factory.
     * This is because the tests are linked with the static cobalt client system library.
     */
    SystemClientFactory* createCobaltClientFactory()
    {
        boost::shared_ptr<synchronisable_dispatcher> 
            clientDispatcher = boost::make_shared<synchronisable_dispatcher>();

        clientDispatcher->start();
        
        SystemClientFactory* clientFactory = new SystemClientFactory();
        clientFactory->setDefaultDispatcher(clientDispatcher);
        clientFactory->setFutureDispatcher(clientDispatcher);
        return clientFactory;
    }


void setUp(MetadataSource source, bool useDTTHistory = true, bool skipPFCallsSetup = false, 
        bool enableEventCache = false, bool useBrokerMock = false)
{

    setUpClientFactory();

    if(!skipPFCallsSetup)
    {
        EXPECT_CALL(*mockEventRepo, getPresentFollowing(_))
            .WillRepeatedly(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>()));
    }
    clientFactory->setIronSystemEventRepository(mockEventRepo);

    EXPECT_CALL(*mockServiceRepo, getAllServices(true))
        .WillRepeatedly(returnNewCompletedFuture(getDefaultUnifiedServices(source)));
    clientFactory->setSystemUnifiedServiceRepository(mockServiceRepo);

    if(useBrokerMock)
    {
        mockMB = boost::make_shared<NS_COBALT_SYSTEM::MockMetadataBrokerAsync>();
        clientFactory->setSystemMetadataBroker(mockMB);
    }

    config = clientFactory->createMetadataConfig();
    config->overrideSource(source);
    if(source == IP_AND_DTT)
    {
        config->overrideStagedDataRetrieval(true);
    }

    config->overrideCache(enableEventCache);
    config->overrideUseHistoricDTTData(useDTTHistory);

    //Effectively disable PECache sanitization so that it doesn't interfere with this test.
    config->overrideInitialPECacheSanitisationDelay(3600);

    eventRepo = boost::dynamic_pointer_cast<SystemClientEventRepository>(
            clientFactory->createEventRepository());
    serviceRepo = clientFactory->createServiceRepository();
}


vector<NS_IRON_SYSTEM::Event> getBBC1Events()
{
    NS_IRON_SYSTEM::Event e1;
    NS_IRON_SYSTEM::Event e2;

    e1.serviceLocator = "dvb://233a..1044";
    e1.eventLocator = "dvb://233a..1044;1";
    e1.shortTitle["eng"] = "Title of e1";
    e1.start = 0;
    e1.publishedDuration = 100;

    e2.serviceLocator = "dvb://233a..1044";
    e2.eventLocator = "dvb://233a..1044;2";
    e2.shortTitle["eng"] = "Title of e2";
    e2.start = 200;
    e2.publishedDuration = 100;

    vector<NS_IRON_SYSTEM::Event> result;
    result.reserve(2);
    result.push_back(e1);
    result.push_back(e2);

    return result;
}


void testGetPresentEvent()
{
    // setup the mocks so that there is a present event on all services
    // works as if it get an event from ER via dbus since getPresentFollowing is a system API. 
    // however, getPresentEvent is not a system API.
    //
    EXPECT_CALL(*mockEventRepo, getPresentFollowing(getDefaultUnifiedServices()[0].serviceLocator)).
            WillOnce(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>(1, getBBC1Events()[0])));

    EXPECT_CALL(*mockEventRepo, getPresentFollowing(getDefaultUnifiedServices()[1].serviceLocator)).
            WillOnce(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>(1, getCafeTVEvents()[0])));

    // note: set to 'unified'
    setUp(DTT_ONLY, true, true);

    // note: 'metadate'
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e = eventRepo->getPresentEvent(0);
    
    CPPUNIT_ASSERT_MESSAGE("There should be an event returned", e);
    
    // note: all are EAPIs
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].eventLocator, e->getIdentifier("locator"));
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].shortTitle["eng"], e->getTitle());
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].start, (uint32_t)to_time_t(e->getStart()));
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].publishedDuration, (uint32_t)e->getDuration());
}


={============================================================================
*kt_dev_uv_stack_211* stack: uranium: systemmediarecordcachetest tests

export URANIUM_LOGGING_RULE="INFO,STDOUT"
Uranium/Uranium.Client.System/test/local-media-library/systemmediarecordcachetest 

DEVARCH/Uranium/Uranium.Client.System/test/local-media-library/SystemMediaRecordCacheTest.cpp

class ZINC_LOCAL SystemMediaRecordCacheTest {

    // test class defines its members as well
private:

    boost::shared_ptr< NS_NICKEL_SYSTEM::MockLocalMediaLibraryAsync >  systemLML;
    boost::shared_ptr< Dispatcher >                                    dispatcher;
    boost::shared_ptr<NS_COBALT_SYSTEM::MockProvisioningServiceAsync>  provisioningService;
    boost::shared_ptr< MediaRecordCache >                              cache;
    vector< NS_NICKEL_SYSTEM::MediaRecord >                            systemMediaRecords;

    void setUp()
    {
        systemLML = boost::make_shared< NS_NICKEL_SYSTEM::MockLocalMediaLibraryAsync >();
        dispatcher = boost::make_shared< SingleThreadDispatcher >();
        provisioningService = boost::make_shared<NS_COBALT_SYSTEM::MockProvisioningServiceAsync>();

        <cache>
        cache = MediaRecordCache::create( systemLML, provisioningService, dispatcher );
    }

    /**
     * Set up expectations that are used by most tests. This won't return until
     * the cache is populated.
     *
     * You can populate `systemMediaRecords` with a list of MediaRecords before
     * calling this and that will be used to populate the cache.
     */
    void defaultSetUp()
    {
        EXPECT_CALL( *systemLML, getMediaRecords(_,_,_,_,_,_) )
            .WillOnce( NS_ZINC::returnNewCompletedFuture( systemMediaRecords ) );

        cache->populate().get(); // Wait for the cache to load.

        // Avoid doing these sanity checks in every test.
        if ( systemMediaRecords.size() )
        {
            CPPUNIT_ASSERT( !cache->empty() );
        }
        CPPUNIT_ASSERT_EQUAL( systemMediaRecords.size(), cache->size() );
    }

    /**
     * Check if LibraryContentChange signals during getMediaRecords call are safe
     */
    void test_Update_during_Populate()
    {
        // makes an entry to SMR

        typedef vector< NS_NICKEL_SYSTEM::MediaRecord > MediaRecordsContainer;
        MediaRecordsContainer
        initialMediaRecords = list_of( makeMR( "1" ) ),
        updatedMediaRecords = list_of( makeMR( "2", "contentId" ) )     // 0
                                     ( makeMR( "3", "contentId" ) )     // 1
                                     ( makeMR( "4", "anotherId" ) );    // 2

        // Delay return of getMediaRecords
        Promise< MediaRecordsContainer > delayedMediaRecords;

        EXPECT_CALL( *systemLML, getMediaRecords(_,_,_,_,_,_) )
            .WillOnce( Return( delayedMediaRecords.getFuture() ) );

        // note: question is when and who calls getMediaRecord()?
        
        EXPECT_CALL( *systemLML, getMediaRecord(_) )
            // event #1
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(0) ) ) "2"
            // event #2
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(1) ) ) "3"
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(2) ) ) "4"
            // event #3
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(2) ) ); "4"

        // /*enummarshallingtest*
        //  * Kick off a request to fetch all MediaRecords from the system. This call
        //  * must be called by users of the MediaRecord cache.
        //  *
        //  * @return Future< void > A future that is completed as soon as the cache
        //  *                        has been initially populated.
        //  */
        // NS_ZINC::Future< void > populate();
        //
        // Get all the linear MediaRecords.
        //
        // Future< vector< NS_NICKEL_SYSTEM::MediaRecord > > future = lml->getMediaRecords();
        //
        // cacheReadyFuture.setCallback( *dispatcher,
        //                          boost::bind( &MediaRecordCache::replayInitialUpdates,
        //                            shared_from_this(), _1 ));
        //
        // void MediaRecordCache::replayInitialUpdates( const FutureValue< void >& fv )
        //     applyUpdatesSync( initialUpdates );
        //        updateCache( lml->getMediaRecord( change.first ).get() );
        //

        // Will call getMediaRecords()
        Future<void> cacheReady = cache->populate();

        // 
        // void MediaRecordCache::replayInitialUpdates( const FutureValue< void >& fv )
        //     applyUpdatesSync( initialUpdates );
        //
        // MediaRecordCache::applyUpdatesSync(
        //  map< string, NS_NICKEL_SYSTEM::LibraryContentChangeType::Enum > const& changes )
        //
        // updateCache( lml->getMediaRecord( change.first ).get() );
        //

        // Trigger MediaRecordCache::applyUpdatesSync()
        // while getMediaRecords() hasn't returned yet
        map<string, NS_NICKEL_SYSTEM::LibraryContentChangeType::Enum> changes;

        <1>
        // Update event #1
        changes["1"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::updated;
        changes["2"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::added;

        // /**
        //  * Asynchronously process the updates, possibly calling the system over
        //  * dbus in order to fetch newly added / updated MediaRecords.
        //  *
        //  * This function won't block the calling thread but can block the dispatcher
        //  * that is given to this cache.
        //  *
        //  * @return The future will be completed only when all of the updates have
        //  *         been fully processed. The resulting map will contain a cleansed
        //  *         list of changes that were actually applied.
        //  */
        //
        // ::applyUpdates
        // {
        //     return asyncInvoke( *dispatcher,
        //                         boost::bind( &MediaRecordCache::queueOrApplyUpdates, shared_from_this(), changes ) );
        // }
        // 
        // ::queueOrApplyUpdates(
        // {
        //     return applyUpdatesSync( changes );
        //     -> updateCache( lml->getMediaRecord( change.first ).get() );
        // }
        //

        Future< boost::shared_ptr< map< string, LibraryContentChangeType::Enum > > >  
            updatedFuture = cache->applyUpdates( changes );

        // should return almost immediately
        CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );

        // shouldn't return any events
        
        // note: this is changes.size()
        CPPUNIT_ASSERT_EQUAL( updatedFuture.get()->size(), 0);

        <2>
        // Update event #2
        changes.clear();
        changes["1"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::deleted;
        changes["3"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::updated;
        changes["4"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::added;

        updatedFuture = cache->applyUpdates( changes );

        // should return almost immediately
        CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );
        // shouldn't return any events
        CPPUNIT_ASSERT_EQUAL( updatedFuture.get()->size(), 0);

        // note: here "1" completed?
        // Let getMediaRecords() return which makes chacheReady promise complete
        delayedMediaRecords.complete( initialMediaRecords);

        // cacheReady future should not block infinitely
        CPPUNIT_ASSERT( cacheReady.wait_for(boost::posix_time::seconds(3)) );

        <3>
        // Update event #3 - to make sure #1 and #2 have been already applied
        changes.clear();
        changes["4"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::updated;

        updatedFuture = cache->applyUpdates( changes );

        // should return in a reasonably time
        CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );
        // should return a valid event
        CPPUNIT_ASSERT_EQUAL( updatedFuture.get()->size(), 1);

        // The cache should contain the updated records
        CPPUNIT_ASSERT_EQUAL( updatedMediaRecords.size(), cache->size() );
    }


$ Uranium/Uranium.Client.System/test/local-media-library/systemmediarecordcachetest 
.++ Logger: uranium - override provided in URANIUM_LOGGING_RULE, using that ++
.....
3,660 INFO   140259472475904 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 1 )
lml::client::SystemMediaRecordCacheTest::test_Update_during_Populate()
3,661 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:264 Queueing LibraryContentChange events
3,661 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:264 Queueing LibraryContentChange events
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:298 KT: from cacheReady: Replaying LibraryContentChange events
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 2 )
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 3 )
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 4 )
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 4 )
} 

OK (7)


={============================================================================
*kt_dev_uv_stack_250* zinc-mr-web: runbrowser

Vanadium provides:

Support for Remote Debugging Webkit provides a protocol that allows remote
access to the browser.  See
https://www.webkit.org/blog/1620/webkit-remote-debugging/ It adds a "-debug"
option to the command line for w3cEngine that will enable the remote debug on
port 9222. Once enabled, you can access the remote debug information by
connecting to port 9222 on the STB using Chrome.

Support for client-side disk cache, i.e. support for storing data on the
client in a directory that is specified by the "-cache" command line.
Specifically, it adds support for:

Client-side caching of resources requested by the w3cEngine Usage of the
LocalStorage HTML5 API Usage of the application cache HTML5 feature

Support for persistent storage of cookies It adds a CookieJar class that uses
the QSettings API to persist cookies. The file used to store cookies is
specified by the "-jar" command line option.


# from terminal
Running '/opt/zinc-trunk/bin/runBrowser.sh --app /app --data /app-data --app-launch-parameters
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2011-10-22#groupId.application
crid://bbc.co.uk/iplayer/flash_player/1
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2012-11-08#applicationPublisherIdentifier
uk.co.bbc
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2014-09-25#groupId.application.ondemandPlayer
crid://bbc.co.uk/iplayer/flash_player/1 launch_context.ui.youview.com portal tvp.bbc.co.uk iplayer'
in sandbox...  /app/META-INF/HTML/application.xml validates


app-dir    : /app
data-dir   : /app-data
url        : http://www.bbc.co.uk/iplayer/
sources    : http://www.test.bbc.co.uk http://www.bbc.co.uk http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk
cache-size : 50000000
channel    : 
exec-helper: /opt/zinc-trunk/bin/exec-then-cleanup-app


./Vanadium/Vanadium.W3CEngine/scripts/runBrowser.sh

exec_wrapper="$prefix/bin/exec-then-cleanup-app"
[ -x "$exec_wrapper" ] || exec_wrapper=""

cmd="${RUN_BROWSER_CMD:-$prefix/bin/w3cEngine}"

exec $exec_wrapper "$cmd" \
$enable_webkit_remote_debugging_as_needed \
-cache "$app_data_dir/client-cache" \
-cache-size "$cacheSize" \
-jar "$app_data_dir/cookies.sqlite" \
-url "$url" \
-src "$sources"


** KT: ===================== **
** KT: exec-then-cleanup-app ** pid((null)) 
** KT: exec-then-cleanup-app: pid(null) 
** KT: exec-then-cleanup-app: parent: argv[1](/opt/zinc-trunk/bin/w3cEngine) 
** KT: exec-then-cleanup-app: child: argv[0](/opt/zinc-trunk/bin/exec-then-cleanup-app) parent_pid(1479) 
** KT: ===================== **
** KT: exec-then-cleanup-app ** pid(1479) 
** KT: exec-then-cleanup-app: pid(not null), cleanup_exe(/opt/zinc-trunk/bin/nexus-inspect) 
Going to watch pid: 1479

# when do abnormal termination
** HMAX KT: Releasing Nexus resources: expected 1479 == shm 1479 

# when do normal termination
** HMAX KT: The nexus resources are currently free. shm is 0


0:37 /opt/zinc/bin/w3cEngine -cache
/app-data/client-cache -cache-size 50000000 -jar /app-data/cookies.sqlite -url
http://www.bbc.co.uk/iplayer/ -src http://www.test.bbc.co.uk http://www.bbc.co.uk
http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk

note: do not work on the box
LD_DEBUG=libs 
/opt/zinc/bin/w3cEngine -cache 
/app-data/client-cache -cache-size 50000000 -jar /app-data/cookies.sqlite -url 
http://www.bbc.co.uk/iplayer/ -src http://www.test.bbc.co.uk http://www.bbc.co.uk 
http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk


={============================================================================
*kt_dev_uv_stack_251* zinc-mr-web: binding

JSBindingNP.h

/**
 * This is a single entry point for binding JavaScript with C++ via NPAPI.
 *
 * `JSBindingNP` is a base class which API specific classes should inherit For
 * example if `Example` API needs to be provided to JavaScript, a binding class
 * for it should be created:
 *
 *     class ExampleBindingNP : public JSBindingNP { ... };
 *
 * The reason for this relationship is that the `JSBindingNP` base class is used
 * to resolve the actual calls with what's been registered by the concrete
 * binding class.
 *
 * The concrete binding class should provide an API that mirrors the actual
 * "back-end" implementation API and register it in the `JSBindingNP` class with
 * macros provided.  When the call is resolved it's responsible for
 * unmarshalling and validating the arguments, making a call to the
 * implementation and marshalling the result.
 *
 *    ExampleBindingNP::ExampleBindingNP(const boost::shared_ptr<Example>& impl)
 *        : impl(impl), ...
 *    {
 *        JS_BINDING_NP_BEGIN(ExampleBindingNP);
 *        ADD_METHOD(foo);
 *        ADD_PROPERTY(bar);
 *        JS_BINDING_NP_END();
 *    }
 *
 *    NPVariant ExampleBindingNP::foo(const NPVariant* const args,
 *                                    const uint32_t argCount)
 *    {
 *        // ...
 *    }
 *
 *    NPVariant ExampleBindingNP::bar()
 *    {
 *        // getter
 *    }
 *
 *    void ExampleBindingNP::bar(const NPVariant* value)
 *    {
 *        // setter
 *    }
 *
 * Adding and removing events is pretty much handled by the `JSBindingNP` class.
 * A concrete binding class only needs to register the event and set a callback
 * on a relevant implementation callback handler.  The callback should then do
 * all arguments marshalling and call `JSBindingNP::notifyListeners()` method.
 *
 *    JS_BINDING_NP_BEGIN(ExampleBindingNP);
 *    // ...
 *    ADD_EVENT(onbaz);
 *    impl->onbaz(
 *        boost::bind(&ExampleBindingNP::onbaz, this));
 *    // ...
 *
 *    void ExampleBindingNP::onbaz()
 *    {
 *        notifyListeners("onbaz", std::vector<NPVariant>());
 *    }
 */

<0> To be used from JavaScript like this to register app 'listener' to NPAPI.

broadcastObj = document.getElementById('someId');
broadcastObj.addEventListener("NetworkConnectivityStateChange",
function(state, error) { /* console.log("state = "+state); */ });

The state argument is an integer enumeration with 0 standing for "disconnected" and 1 standing for "connected".


<1> so "binding" dir has bindings for each 'interface' such as Channelxxx and VideoBroadcastxxx.

// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/bindings/VideoBroadcastBindingNP.h, cpp
// 
// class VideoBroadcast is ABC and then concrete impl classes:
//
// /broadcast/production/
// class ProductionVideoBroadcast : public VideoBroadcast,
//
// /broadcast/fake/
// class ZINC_LOCAL FakeBroadcast : virtual public Broadcast   note: why virtual?
//

class VideoBroadcastBindingNP : public JSBindingNP
{
    boost::shared_ptr<VideoBroadcast> vb;
}

<2-1>
Register its handler with vb "impl" class. This is to set up path to get event
from lower parts. 'down' path

VideoBroadcastBindingNP::VideoBroadcastBindingNP(
    const boost::shared_ptr<VideoBroadcast>& vb,
    NPP npp)
    : JSBindingNP(npp),
      vb(vb)
{
    ...

    ADD_EVENT(onNetworkConnectivityStateChange);

    vb->onNetworkConnectivityStateChange(
        boost::bind(&VideoBroadcastBindingNP::onNetworkConnectivityStateChange,
                    this, _1));
    ...
}

<2-2>
Forward 'event' up to app.

void VideoBroadcastBindingNP::onNetworkConnectivityStateChange(
    NetworkConnectivityState::Enum state)
{
  std::vector<NPVariant> args(1);
  args[0] = wrap(state, plugin());

  notifyListeners("onNetworkConnectivityStateChange", args);
}


<3> save a handler of "binding" class in the concrete class.

// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/production/ProductionVideoBroadcast.cpp 

void ProductionVideoBroadcast::onNetworkConnectivityStateChange(
    boost::function<void(NetworkConnectivityState::Enum)> handler)
{
  // this is function<> object
  onNetworkConnectivityStateChangeHandler = handler;
}

<4>
void ProductionVideoBroadcast::emitNetworkConnectivityStateChange(
    NetworkConnectivityState::Enum state)
{
  if (onNetworkConnectivityStateChangeHandler)
  {
    try
    {
      onNetworkConnectivityStateChangeHandler(state);
    }
    catch (...)
    {
      VANADIUM_WARN("Executing network connectivity state change handler failed");
    }
  }
}

// from NM?
// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/production/ProductionVideoBroadcast.cpp 
// 
void ProductionVideoBroadcast::StateChanged(
    const NS_NEON_SYSTEM::NM_STATE::Enum state)
{
  NetworkConnectivityState::Enum const targetState =
    state == NS_NEON_SYSTEM::NM_STATE::connected
    ? NetworkConnectivityState::connected
    : NetworkConnectivityState::disconnected;

  emitNetworkConnectivityStateChange(targetState);
}

<map-to-concrete-class>
BroadcastPluginNP::BroadcastPluginNP(BroadcastFactory& f, NPP npp) :
    f(f),
    jsCallInProgress(false),
    releasing(false),
    npp(npp),
    jsDispatcher(boost::make_shared<JSEventDispatcherNP>(npp)),
    jsAsyncDispatcher(boost::make_shared<JSEventDispatcherNP>(npp, true))
{
  ...

  // boost::shared_ptr<VideoBroadcast> videoBroadcast;
  
  videoBroadcast = f.createVideoBroadcast(jsDispatcher, jsAsyncDispatcher);

  // Create a binding for videoBroadcast.
  const boost::shared_ptr<VideoBroadcastBindingNP> videoBroadcastBinding =
    boost::make_shared<VideoBroadcastBindingNP>(videoBroadcast, npp);
}

<>
kpark@wll1p04345:~/source/DEVARCH/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast$ tree .
.
|-- api
|   |-- BroadcastFactory.cpp
|   |-- ChannelConfig.cpp
|   |-- Channel.cpp
|   |-- ChannelList.cpp
|   |-- VideoBroadcast.cpp

|-- bindings
|   |-- ChannelBindingNP.cpp
|   |-- ChannelConfigBindingNP.cpp
|   |-- ChannelListBindingNP.cpp
|   |-- CollectionBindingNP.h
|   |-- VideoBroadcastBindingNP.cpp

|-- broadcast-plugin.cpp
|-- broadcast-plugin.h
|-- BroadcastPluginNP.cpp
|-- BroadcastPluginNP.h

|-- fake
|   |-- FakeBroadcastFactory.cpp
|   |-- FakeBroadcastFactory.h
|   |-- FakeVideoBroadcast.cpp
|   `-- FakeVideoBroadcast.h

|-- JSBindingNP.cpp
|-- JSBindingNP.h
|-- JSEventDispatcherNP.cpp
|-- JSEventDispatcherNP.h
|-- JSObjectNP.h
|-- JSTypeUnwrappingNP.cpp
|-- JSTypeUnwrappingNP.h
|-- JSTypeWrappingNP.cpp
|-- JSTypeWrappingNP.h
|-- NPObjectIntrusivePtr.h
|-- plugin-logger.h
`-- production
    |-- ProductionBroadcastFactory.cpp
    |-- ProductionBroadcastFactory.h
    |-- ProductionVideoBroadcast.cpp
    `-- ProductionVideoBroadcast.h


# broadcast-plugin.cpp

    // not sure who calls this but from a code, a browser call this and this
    // function registers functions
//
NPError NP_Initialize(NPNetscapeFuncs* nFuncs, NPPluginFuncs* pFuncs)
{
    try
    {
      // 1. register its function table with the caller(browser?)
      // *pFuncs = npp;
      //
      // 2. create T and add T to a map<mine, T*> for MINE, video/broadcast.
      //
      // boost::ptr_map<std::string, BroadcastFactory> factories;
      //
      // addFactory<ProductionBroadcastFactory>(MIME_TYPE);
      //
      // note: 'Production' created.
      return internal::NP_Initialize(nFuncs, pFuncs);
    }
    CATCH_BAD_ALLOC
    CATCH_ALL

    return NPERR_GENERIC_ERROR;
}


={============================================================================
*kt_dev_uv_stack_014* zinc-webkit: debug webkit

https://wiki.youview.co.uk/display/YVHTMLCRB/Debugging+video+playback+in+the+HTML+engine
https://wiki.youview.co.uk/display/canvas/Debugging+Issues+on+a+Device+Emporium

Debugging webkit

The script "configure-webkit" can be used to get more logging or core dumps out
of webkit. More options may be added in future so check the help:

[root@HUMAX tmp]# configure-webkit -h
Usage: /usr/local/bin/configure-webkit [-u <URL>|-U] [-d|-D] [-g|-G] [-c]
        -u: Hard-code a fixed URL in runBrowser script
        -U: Revert to default URL
        -d: Enable WebKit Remote Debugging [1]
        -D: Disable WebKit Remote Debugging [1]
        -g: Enable GStreamer debugging [1]
        -G: Disable GStreamer debugging [1]
        -c: Enable core dumps for HTML5 applications

note:
This script is in /setup-humax/scripts/ and in /usr/local/bin on a box

note:
The following do not work. Add GST_DEBUG in runBrowser.sh manually.

-g: Enable GStreamer debugging [1]

{remote-debugging}

https://wiki.youview.co.uk/display/YVDP/Debugging?src=search

[root@HUMAX /]# configure-webkit -d
Remote debugging enabled - launch http://172.20.32.153:9222 from your PC when WebKit is started.


={============================================================================
*kt_dev_uv_stack_014* zinc-webkit: build webkit plugin

zinc-build-root/release-humax-dtr_t2100/Zinc/Zinc.3rdPartyStack/
qt-everywhere-opensource-src-5.1.0/qtwebkit/Source/WebCore/platform/
graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp


// note: can use this script but it will builds whole qt and more importantly
// applies patches.

./run-3ps-make-standalone.sh qt-everywhere-opensource-sr


// go to this directory under zb-shell and see the Makefile in the same
// directory for other targets.

cd $ZINC_NATIVE_BUILD_ROOT/release-humax-dtr_t2100/Zinc/Zinc.3rdPartyStack/
qt-everywhere-opensource-src-5.1.0

make module-qtwebkit-clean (optional)
make module-qtwebkit

// note: do not use this since it copies from installed directory.
zb-copy libQt5WebKit.so.5.1.0

scp ./qtwebkit/lib/libQt5WebKit.so.5.1.0 root@humax-04535:/opt/zinc-trunk/oss/lib


={============================================================================
*kt_dev_uv_stack_253* zinc-mr-web: MediaRouter.WebKit.Plugin

{previous-impl}

<0>

WebCore/html/HTMLMediaElement.cpp

void HTMLMediaElement::mediaPlayerNetworkStateChanged(MediaPlayer*)
{
    beginProcessingMediaPlayerCallback();
    setNetworkState(m_player->networkState());
    endProcessingMediaPlayerCallback();
}

void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
{
  // calles subroutines to translate 
  // MediaPlayer::xxx such as FormatError to MEDIA_ERR_xxx
}


/qt-everywhere-opensource-src-5.1.0/qtwebkit/Source/WebCore/platform/graphics/
MediaPlayer.h, cpp


<media-player-error>
class MediaPlayer {

enum NetworkState { Empty, Idle, Loading, Loaded, FormatError, NetworkError, DecodeError };
enum ReadyState  { HaveNothing, HaveMetadata, HaveCurrentData, HaveFutureData, HaveEnoughData };

// Client callbacks.
void MediaPlayer::networkStateChanged()
{
  // If more than one media engine is installed and this one failed before finding metadata,
  // let the next engine try.
  if (m_private->networkState() >= FormatError
      && m_private->readyState() < HaveMetadata
      && installedMediaEngines().size() > 1) 
  {
    if (m_contentMIMEType.isEmpty() || 
        bestMediaEngineForTypeAndCodecs(m_contentMIMEType, 
          m_contentTypeCodecs, m_keySystem, m_url, m_currentMediaEngine)) 
    {
      m_reloadTimer.startOneShot(0);
      return;
    }
  }
  if (m_mediaPlayerClient)
    m_mediaPlayerClient->mediaPlayerNetworkStateChanged(this);
}


Use two channels and use networkstate for network and decode errors

m_player->networkStateChanged();
m_player->readyStateChanged();


void MediaPlayerPrivateGStreamer::loadingFailed(MediaPlayer::NetworkState error)
{
  m_errorOccured = true;
  if (m_networkState != error) {
    m_networkState = error;
    m_player->networkStateChanged();
  }
}


#if USE(GSTREAMER)
#include "MediaPlayerPrivateGStreamer.h"
#define PlatformMediaEngineClassName MediaPlayerPrivateGStreamer
#endif

static Vector<MediaPlayerFactory*>& installedMediaEngines() 
{
#if defined(PlatformMediaEngineClassName)
        PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
#endif
    return installedEngines;
}


{current-impl} the proposed which use the proxy

graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
graphics/mediarouter/MediaPlayerPrivateMediaRouter.cpp

note: ERROR_MEDIA_MESSAGE() maps to GST_ERROR


<0>
Source/WebCore/platform/graphics/MediaPlayer.cpp

static Vector<MediaPlayerFactory*>& installedMediaEngines() 
{
    DEFINE_STATIC_LOCAL(Vector<MediaPlayerFactory*>, installedEngines, ());
    static bool enginesQueried = false;

    if (!enginesQueried) {
        enginesQueried = true;

        MediaPlayerPrivateGStreamer::registerMediaEngine(addMediaEngine);
        MediaPlayerPrivateMediaRouter::registerMediaEngine(addMediaEngine);

    }

    return installedEngines;
}


<gst>
/Zinc/Zinc.3rdPartyStack/qt-everywhere-opensource-src-5.1.0/
qtwebkit/Source/WebCore/platform/graphics/gstreamer/

-rw-r--r--  1 kpark kpark 143317 Jun 25 13:22 MediaPlayerPrivateGStreamer.cpp
-rw-r--r--  1 kpark kpark 141339 Jun 25 13:22 MediaPlayerPrivateGStreamer.cpp.orig
-rw-r--r--  1 kpark kpark  11157 Jun 25 13:22 MediaPlayerPrivateGStreamer.h


gstreamer/MediaPlayerPrivateGStreamer.cpp


class MediaPlayerPrivateGStreamer : public MediaPlayerPrivateInterface 

'static' void MediaPlayerPrivateGStreamer::registerMediaEngine(MediaEngineRegistrar registrar)
{
    if (isAvailable())
        registrar(create, getSupportedTypes, supportsType, 0, 0, 0);
}

PassOwnPtr<MediaPlayerPrivateInterface> MediaPlayerPrivateGStreamer::create(MediaPlayer* player)
{
    return adoptPtr(new MediaPlayerPrivateGStreamer(player));
}

MediaPlayerPrivateGStreamer::MediaPlayerPrivateGStreamer(MediaPlayer* player)
    : m_player(player)
{
}

MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::supportsType(const String& type, 
        const String& codecs, const KURL&)
{
    if (type.isNull() || type.isEmpty())
        return MediaPlayer::IsNotSupported;

    if (mimeTypeCache().contains(type))
    {
        return MediaPlayer::IsSupported;
    }
    else
    {
        return MediaPlayer::IsNotSupported;
    }
}

void MediaPlayerPrivateGStreamer::getSupportedTypes(HashSet<String>& types)
{
    types = mimeTypeCache();
}

static HashSet<String> mimeTypeCache()
{
    initializeGStreamerAndRegisterWebKitElements();

    DEFINE_STATIC_LOCAL(HashSet<String>, cache, ());
    static bool typeListInitialized = false;

    if (typeListInitialized)
        return cache;
    const char* mimeTypes[] = { "application/vnd.apple.mpegurl" };

    for (unsigned i = 0; i < (sizeof(mimeTypes) / sizeof(*mimeTypes)); ++i)
        cache.add(String(mimeTypes[i]));

    typeListInitialized = true;
    return cache;
}

void MediaPlayerPrivateGStreamer::load(const String& url)
{
    if(!m_playBin){
        createGSTPlayBin(kurl);
    }

    g_object_set(G_OBJECT (httpSrc.get()), "uri", cleanUrl.utf8().data(), NULL);

    commitLoad();
}

void MediaPlayerPrivateGStreamer::createGSTPlayBin(const KURL& url)
{
    if(path.endsWith(".m3u8", false)){
        createGSTHLSPipeline(srcElement);

    } else if(path.endsWith(".ts", false)) {
        createGSTTSPipeline(srcElement);

    } else if(path.endsWith(".mpd", false)) {
        createDashPipeline(srcElement);
    }        
}

void MediaPlayerPrivateGStreamer::createDashPipeline(const char *srcElementName) 
{
    GstElement *source, *dashdemux, *qtdemux, *h264parse, *nexussink;
    
    LOG_MEDIA_MESSAGE("\n\nMediaPlayerPrivateGStreamer::createDashPipeline()\n");    

    m_playBin = gst_pipeline_new ("dash-player");

    source = gst_element_factory_make (srcElementName,     "http-source");
    dashdemux = gst_element_factory_make ("dashdemux",    "dash-demux");
    qtdemux = gst_element_factory_make ("qtdemux",        "qt-demux");
    h264parse = gst_element_factory_make ("h264parse",    "h264-parse");
    nexussink = gst_element_factory_make ("nexussink",    NULL);
}


<private-media-router>

1. libVanadiumMediaRouterWebKitPlugin.so.0.0.0 to get VanadiumMediaPlayer which is
webkit plugin.

2. VanadiumMediaPlayer links to the proxy.

/opt/zinc-trunk/share/vanadium-webkit-mediarouter-plugin/system-factory.plugin-config
libNickelSystemDbusClient.so createDbusSystemFactory(Zinc.MediaProxy)


/graphics/gstreamer/MediaPlayerPrivateMediaRouter.cpp

void MediaPlayerPrivateMediaRouter::registerMediaEngine(MediaEngineRegistrar registrar)
{
  // note: create
  
  registrar(create, getSupportedTypes, supportsType, 0, 0, 0);
}


note: here make a link to Vanadium

PassOwnPtr<MediaPlayerPrivateInterface> MediaPlayerPrivateMediaRouter::create(MediaPlayer* player)
{
  // old: ZINC_QMEDIA_PLAYER_LIB
  //    =${final_prefix}/lib/libVanadiumMediaRouterWebKitPlugin.so.0.0.0
  //
  // ZINC_QMEDIA_PLAYER_LIB="$prefix/lib/libVanadiumWebKitVideoElement.so" 

  const char* libraryName = getenv("ZINC_QMEDIA_PLAYER_LIB");
  if(!libraryName)
  {
    ERROR_MEDIA_MESSAGE("ZINC_QMEDIA_PLAYER_LIB env var not defined");
    return PassOwnPtr<MediaPlayerPrivateInterface>();
  }

  void* handle = dlopen(libraryName, RTLD_NOW);
  if(!handle)
  {
    ERROR_MEDIA_MESSAGE("Failed to load library [%s]", libraryName);
    return PassOwnPtr<MediaPlayerPrivateInterface>();
  }

  // this links to the proxy
  void* symbol = dlsym(handle, "createMediaPlayerImplementation");

  typedef QMediaPlayerInterface* (*CreateFunction)(QMediaPlayerCallbackInterface*);
  CreateFunction createFunction = reinterpret_cast<CreateFunction>(symbol);

  // note:
  // MediaPlayerPrivateMediaRouterCallbacks simply forwards callbacks to
  // MediaPlayer.
  //
  std::auto_ptr<QMediaPlayerCallbackInterface> callbacks(
      new MediaPlayerPrivateMediaRouterCallbacks(player));

  std::auto_ptr<QMediaPlayerInterface> mediaRouterImpl(createFunction(callbacks.get()));

  return adoptPtr(new MediaPlayerPrivateMediaRouter(mediaRouterImpl,
        callbacks));
}

void MediaPlayerPrivateMediaRouter::getSupportedTypes(HashSet<String>& types)
{
    types = mimeTypeCache();
}

#define DEFINE_STATIC_LOCAL(type, name, arguments) \
    static type* name##Ptr = new type arguments; \
    type& name = *name##Ptr

    DEFINE_STATIC_LOCAL(HashSet<String>, cache, ());

    static HashSet<Strings> cache = new HashSet<Strings>

static HashSet<String> mimeTypeCache()
{
    DEFINE_STATIC_LOCAL(HashSet<String>, cache, ());
    static bool typeListInitialized = false;

    if (typeListInitialized)
        return cache;
    const char* mimeTypes[] = {
                               "application/vnd.apple.mpegurl",
                               "application/vnd.apple.mpegurl",
                               "application/vnd.rn-realmedia",
                               "application/x-3gp",
                               "application/x-pn-realaudio",
                               "application/x-mpegURL",
                               "application/dash+xml",
                               "audio/aac",
                               "audio/mp3",
                               "audio/mp4",
                               "audio/mpeg",
                               "audio/x-m4a",
                               "audio/x-mp3",
                               "audio/x-mpeg",
                               "video/mp4",
                               "video/mpeg",
                               "video/mpegts",
                               "video/mp2t",
                               };

    for (unsigned i = 0; i < (sizeof(mimeTypes) / sizeof(*mimeTypes)); ++i)
        cache.add(String(mimeTypes[i]));

    typeListInitialized = true;
    return cache;
}

MediaPlayer::SupportsType MediaPlayerPrivateMediaRouter::supportsType(const String& type, 
        const String& codecs, const KURL&)
{
    if (type.isNull() || type.isEmpty())
        return MediaPlayer::IsNotSupported;

    // spec says we should not return "probably" if the codecs string is empty
    if (mimeTypeCache().contains(type))
        return codecs.isEmpty() ? MediaPlayer::MayBeSupported : MediaPlayer::IsSupported;
    return MediaPlayer::IsNotSupported;
}


note: mediaRouterImpl is set to m_mediaPlayerImpl so calls to be forwarded to VanadiumMediaPlayer

      MediaPlayerPrivateMediaRouter -> VanadiumMediaPlayer


void MediaPlayerPrivateMediaRouter::play()
{
   INFO_MEDIA_MESSAGE("MediaPlayerPrivateMediaRouter::play()");
   m_mediaPlayerImpl->play();
}


<0>

note: QMediaPlayerInterface is similar to MediaPlayerPrivateInterface and is
by YV.

class ZINC_EXPORT VanadiumMediaPlayer : public WebCore::QMediaPlayerInterface

// Vanadium/Vanadium.MediaRouter.WebKit.Plugin/src/VanadiumMediaPlayer.h
// Vanadium/Vanadium.MediaRouter.WebKit.Plugin/src/VanadiumMediaPlayer.cpp

extern "C"
{
WebCore::QMediaPlayerInterface* createMediaPlayerImplementation(
        WebCore::QMediaPlayerCallbackInterface* callbacks)
{
    VANADIUM_FUNC_TRACE;
    if(!callbacks)
    {
        // Return null immediately rather than crashing later
        return NULL;
    }

    return new NS_VANADIUM::VanadiumMediaPlayer(*callbacks, playerManager);
}
}


class VanadiumMediaPlayer 
{
    boost::shared_ptr<MediaPlayerListener> listener;
};

void VanadiumMediaPlayer::load(const std::string& url)
{
  VANADIUM_FUNC_TRACE;

  // this makes a dbus event link to the media proxy via addListener
  // *system-api*
  mediaRouter->addListener(dispatcher, listener);

  // *set-source* 
  mediaRouter->setSource(url, SetSourceReason::mhegstandard).get();
  mediaRouter->setSink("decoder://0").get();
  currentSource = url;

  // WebKit expects the media player to start in the paused state
  pause();

  if(preloadPolicy != WebCore::QMediaPlayerInterface::NONE)
  {
    mediaRouter->startBuffering();
    currentNetworkState = QMediaPlayerInterface::NETWORK_LOADING;
  }
}

void VanadiumMediaPlayer::play()
{
    VANADIUM_FUNC_TRACE;

    if(playbackPaused)
    {
        mediaRouter->setPlaySpeed(1.0);
        playbackPaused = false;
    }
    if(!mediaRouterPresenting)
    {
        playerManager.playbackStarting(this);
        mediaRouter->start();
        mediaRouterPresenting = true;
    }
    currentNetworkState = QMediaPlayerInterface::NETWORK_LOADING;
}

VanadiumMediaPlayer::VanadiumMediaPlayer(
        QMediaPlayerCallbackInterface& callbacks_,
        MediaPlayerManager& playerManager_)
    : dispatcher(boost::make_shared<GlibEventDispatcher>()),
    callbacks(callbacks_),
    preloadPolicy(QMediaPlayerInterface::AUTO),
    // Should really be NO_SOURCE but this is not exposed on the MediaPlayer API
    currentNetworkState(QMediaPlayerInterface::NETWORK_EMPTY),
    currentReadyState(QMediaPlayerInterface::HAVE_NOTHING),
    seekCount(0),

    listener(boost::make_shared<MediaPlayerListener>(this)),

    playbackPaused(false),
    mediaRouterPresenting(false),
    mediaRouterVolume(0.0),
    playerManager(playerManager_)
{
  // note:
  // 1. this makes a dbus link to the media proxy

  // Vanadium/Vanadium.WebKit.VideoElement/data$ cat system-factory.plugin-config 
  //  libNickelSystemDbusClient.so createDbusSystemFactory(Zinc.MediaProxy)

  FilePluginConfig pluginConfig(PackageDataFinder().find("system-factory.plugin-config"));
  NS_NICKEL_SYSTEM::SystemFactory& nickelSystemFactory =
    PluginFactory::getInstance<NS_NICKEL_SYSTEM::SystemFactory>(pluginConfig);

  boost::shared_ptr<NS_NICKEL_SYSTEM::MediaRouterFactory> mediaRouterFactory
    = nickelSystemFactory.createMediaRouterFactory();

  // note: this returns a future and future.get() returns a SP<MediaRouter>
  // NS_ZINC::Future<boost::shared_ptr<MediaRouter> > ProxyMediaRouterFactory::createMediaRouter();

  mediaRouter = mediaRouterFactory->createMediaRouter().get();
}

boost::shared_ptr<NS_NICKEL_SYSTEM::MediaRouter> mediaRouter;


={============================================================================
*kt_dev_uv_stack_254* zinc-mr: listener

// Nickel/Nickel.Client.API/include/MediaRouterEventListener.h
/**
 * The defined interface for a MediaRouter event-listener.
 *
 * <p>To receive events the object must be set up to listen to the MediaRouter using
 * <code>MediaRouter.addListener()</code>. </p>
 *
 * @see nickel::client::MediaRouter#addListener()
 */
struct ZINC_EXPORT MediaRouterEventListener : public NS_ZINC::EventListener {

}

// this is auto-generated and get built.

Nickel.System.DBusServer/src/MediaRouterAsyncToDBus.h class MediaRouterAsyncToDBus : private boost::noncopyable , public MediaRouterEventListener

Nickel.System.DBusServer/src/MediaRouterAsyncToDBus.cpp


class ZINC_EXPORT VanadiumMediaPlayer : public WebCore::QMediaPlayerInterface
{
  private:
    class MediaPlayerListener : boost::noncopyable,
    public NS_NICKEL_SYSTEM::MediaRouterEventListener
  {
    public:
      MediaPlayerListener(VanadiumMediaPlayer* player)
        : player(player)
      {}

      /**
       * Sever the link between this listener and its VanadiumMediaPlayer instance.
       *
       * This will cause the listener to stop forwarding events.
       */
      void unlinkListener();

      //@{
      /**
       * MediaRouter callbacks.
       */
      void BufferStatusEvent(const NS_NICKEL_SYSTEM::BufferStatusEventValue::Enum event);

      void DrmEvent(const NS_NICKEL_SYSTEM::DrmEventValue::Enum resultRef,
          const std::string& drmMediaIdentifier,
          const std::string& rightsIssuerUrl);

      void PositionChangeEvent(const NS_NICKEL_SYSTEM::Position& position);

      void SourceEvent(const NS_NICKEL_SYSTEM::SourceEventValue::Enum event,
          const NS_NICKEL_SYSTEM::SetSourceReason::Enum reason);

      void SpeedChangeEvent();

      void StatusEvent(const NS_NICKEL_SYSTEM::StatusEventValue::Enum event);

      void ErrorEvent(const NS_NICKEL_SYSTEM::ErrorEventValue::Enum error,
          const NS_NICKEL_SYSTEM::ErrorEventContext::Enum context,
          const std::string& info);
      //@}
    private:
      VanadiumMediaPlayer* player;
  };
};

VanadiumMediaPlayer::VanadiumMediaPlayer(
        QMediaPlayerCallbackInterface& callbacks)
    : dispatcher(makeGlibEventDispatcher()),
    listener(boost::make_shared<MediaPlayerListener>(this)),
  {
    ...
    mediaRouterFactory = nickelSystemFactory.createMediaRouterFactory();
    mediaRouter = mediaRouterFactory->createMediaRouter().get();
    mediaRouter->addListener(dispatcher, listener);
  }


GstMediaRouter::

produceEvent(
    boost::bind(&MediaRouterEventListener::SourceEvent,
            _1,
            event,
            reason));

produceEvent(
      boost::bind(&MediaRouterEventListener::ErrorEvent, _1,
        errVal, errContext, text_msg));


void VanadiumMediaPlayer::SourceEvent(const SourceEventValue::Enum event,
            const SetSourceReason::Enum)
{
}

void VanadiumMediaPlayer::ErrorEvent(const ErrorEventValue::Enum error,
            const ErrorEventContext::Enum,
            const std::string&)
{
  // pass up to WebKit

  currentReadyState = QMediaPlayerInterface::HAVE_NOTHING;
  currentNetworkState = QMediaPlayerInterface::NETWORK_ERROR;
  callbacks.networkStateChanged();
  callbacks.readyStateChanged();
}


={============================================================================
*kt_dev_uv_stack_255* mr-dash: error handle

https://html.spec.whatwg.org/multipage/embedded-content.html#media-data

4.8.13.16 Event summary

This section is non-normative.

The following events fire on media elements as part of the processing model
described above: 

Event name  Interface   Fired when...
error       Event       An error occurs while fetching the media data.

Preconditions 
error is an object with the code MEDIA_ERR_NETWORK or higher. networkState
equals either NETWORK_EMPTY or NETWORK_IDLE, depending on when the download
was aborted. 


4.8.13.1 Error codes

media.error

Returns a MediaError object representing the current error state of the element.

Returns null if there is no error.

All 'media' elements have an associated error status, which records the 'last'
error the element encountered since its resource selection algorithm was last
invoked. The error attribute, on getting, must return the MediaError object
created for this last error, or null if there has not been an error.

interface MediaError {
  const unsigned short MEDIA_ERR_ABORTED = 1;
  const unsigned short MEDIA_ERR_NETWORK = 2;
  const unsigned short MEDIA_ERR_DECODE = 3;
  const unsigned short MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  readonly attribute unsigned short code;
};


media.erro.code

Returns the current error's error code, from the list below.

The code attribute of a MediaError object must return the code for the error,
    which must be one of the following:

MEDIA_ERR_ABORTED (numeric value 1)
    The fetching process for the media resource was aborted by the user agent
    at the user's request.

MEDIA_ERR_NETWORK (numeric value 2)
    A network error of some description caused the user agent to stop fetching
    the media resource, after the resource was established to be usable.

MEDIA_ERR_DECODE (numeric value 3)
    An error of some description occurred while decoding the media resource,
    after the resource was established to be usable.

MEDIA_ERR_SRC_NOT_SUPPORTED (numeric value 4)
    The media resource indicated by the src attribute or assigned media
    provider object was not suitable.


source:
"GstSoupHTTPSrc" "GstTypeFindElement" "uri-decoder"

sink:
"videodecoder", "audiodecoder"


enum GstStreamError

GST_STREAM_ERROR_WRONG_TYPE
used when the element doesn't handle this type of stream.

GST_STREAM_ERROR_CODEC_NOT_FOUND
used when there's no codec to handle the stream's type.

GST_STREAM_ERROR_DECODE
used when decoding fails.

GST_STREAM_ERROR_DEMUX
used when demuxing fails.

GST_STREAM_ERROR_MUX
used when muxing fails.

GST_STREAM_ERROR_FORMAT
used when the stream is of the wrong format (for example, wrong caps).

GST_STREAM_ERROR_DECRYPT
used when the stream is encrypted and can't be decrypted because this is not
supported by the element.

GST_STREAM_ERROR_DECRYPT_NOKEY
used when the stream is encrypted and can't be decrypted because no suitable key
is available.


class MediaPlayer {
enum NetworkState { Empty, Idle, Loading, Loaded, FormatError, NetworkError, DecodeError };
enum ReadyState  { HaveNothing, HaveMetadata, HaveCurrentData, HaveFutureData, HaveEnoughData };
};

class QMediaPlayerInterface
{
public:

    enum NetworkState
    {
        NETWORK_EMPTY,
        NETWORK_IDLE,
        NETWORK_LOADING, (2)
        NETWORK_ERROR,
        NETWORK_LOADED,
        DECODE_ERROR,
        FORMAT_ERROR
    };

    enum ReadyState
    {
        HAVE_NOTHING,
        HAVE_METADATA,
        HAVE_CURRENT_DATA,
        HAVE_FUTURE_DATA, (3)
        HAVE_ENOUGH_DATA
    };
}


{old-way}

/qtwebkit/Source/WebCore/html/MediaError.h
namespace WebCore {

class MediaError : public RefCounted<MediaError> {
public:
    enum Code {
        MEDIA_ERR_ABORTED = 1,
        MEDIA_ERR_NETWORK,
        MEDIA_ERR_DECODE,
        MEDIA_ERR_SRC_NOT_SUPPORTED
#if ENABLE(ENCRYPTED_MEDIA)
        , MEDIA_ERR_ENCRYPTED
#endif
    };
};

WebCore/html/HTMLMediaElement.cpp

note: Get state explicitly. See below

void HTMLMediaElement::mediaPlayerNetworkStateChanged(MediaPlayer*)
{
    beginProcessingMediaPlayerCallback();
    setNetworkState(m_player->networkState());
    endProcessingMediaPlayerCallback();
}

void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
{
  <4> not in any of the above domain
  if (state == MediaPlayer::Empty) {
    // Just update the cached state and leave, we can't do anything.
    m_networkState = NETWORK_EMPTY;
    return;
  }

  mediaLoadingFailed(state)
  {
    <1>
    // note: HTML manage this value, m_loadState, therefore its upto WEBKIT
    
      else if (
          (error == MediaPlayer::FormatError || error == MediaPlayer::NetworkError) 
          && m_loadState == LoadingFromSrcAttr)
      {
        // This is only place to use SRC_NOT_SUPPORTED
        noneSupported();
        {
          m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
        }
      }

    <2>
      else if (error == MediaPlayer::DecodeError)
        mediaEngineError(MediaError::create(MediaError::MEDIA_ERR_DECODE));

    <3>
      if (error == MediaPlayer::NetworkError && m_readyState >= HAVE_METADATA)
        mediaEngineError(MediaError::create(MediaError::MEDIA_ERR_NETWORK));
  }
}


<mapping>

<1> check error code only

MediaPlayerPrivateGStreamer.cpp:
{
  if (err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND
      || err->code == GST_STREAM_ERROR_WRONG_TYPE
      || err->code == GST_STREAM_ERROR_FAILED
      || err->code == GST_CORE_ERROR_MISSING_PLUGIN
      || err->code == GST_RESOURCE_ERROR_NOT_FOUND
      || err->code == GST_RESOURCE_ERROR_BUSY
      || err->code == GST_RESOURCE_ERROR_SETTINGS) {

    // note: this is default. so there is no match to readyState then format
    // error.
    error = MediaPlayer::FormatError;

    if (m_readyState == MediaPlayer::HaveMetadata) 
      error = MediaPlayer::FormatError;
    else if (m_readyState > MediaPlayer::HaveMetadata)
      error = MediaPlayer::DecodeError;

    // void MediaPlayer::networkStateChanged()
    m_player->networkStateChanged();
    m_mediaPlayerClient->mediaPlayerNetworkStateChanged(this);
  }
}

HTMLMediaElement.cpp:

    MediaPlayer::FormatError || MediaPlayer::NetworkError
      m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);

<2>
else if (err->domain == GST_STREAM_ERROR) {

  if (err->code == GST_STREAM_ERROR_TYPE_NOT_FOUND) {
    ERROR_MEDIA_MESSAGE("Decode error, let the Media element emit a stalled event.\n");
    g_free(err);
    g_free(debug);
    break;
  }

  // this handles all other stream errors
  error = MediaPlayer::DecodeError;

<3> all other resource errors
else if (err->domain == GST_RESOURCE_ERROR)
  error = MediaPlayer::NetworkError;

<4> all any other erros:
  error = MediaPlayer::Empty; -> NETWORK_EMPTY


<new-mapping>

struct ErrorEventValue : NS_ZINC::Enum
{
  enum Enum
  {
    other_error_event = 0,
    locator = 1,
    tag = 2,
    language = 3,
    linear_selection = 4,
    network = 5,
    server = 6,
    data = 7,
  };
};


case: ErrorEventValue::data;
    // to raise MEDIA_ERR_DECODE in https://jira.youview.co.uk/browse/SOLDES-584
    //
    // GST_CORE_ERROR_MISSING_PLUGIN:
    // GST_RESOURCE_ERROR_NOT_FOUND:
    // GST_RESOURCE_ERROR_BUSY:
    // GST_RESOURCE_ERROR_SETTINGS:
    // GST_STREAM_ERROR_CODEC_NOT_FOUND:
    // GST_STREAM_ERROR_WRONG_TYPE
    // GST_STREAM_ERROR_FAILED:
    // GST_STREAM_all_others:

    
      if(currentReadyState > QMediaPlayerInterface::HAVE_METADATA)

      1. currentNetworkState = QMediaPlayerInterface::DECODE_ERROR;
          -> MediaError::MEDIA_ERR_DECODE;

      note: How this error? since in VanadiumMediaPlayer::SourceEvent, it
              changes state to readyState

      if(event == SourceEventValue::source_config_complete)
      {
        currentReadyState = HAVE_FUTURE_DATA;
        callbacks.readyStateChanged();
        currentNetworkState = QMediaPlayerInterface::NETWORK_LOADING;
        callbacks.networkStateChanged();
      }

      2. currentNetworkState = QMediaPlayerInterface::FORMAT_ERROR;
          -> MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED;

      note: how to test this error? By doing this, readyState is < METADATA.

      From:

        EXPECT_CALL(*mock,
                setSource(source,
                    SetSourceReason::mhegstandard)).WillOnce(
                    DoAll(Invoke(boost::bind(&sendSourceEvent, mock,
                                SourceEventValue::change_complete,
                                SetSourceReason::mhegstandard)),
                        Invoke(boost::bind(&sendSourceEvent, mock,
                                SourceEventValue::source_config_complete,
                                SetSourceReason::mhegstandard)),
                    Return(makeCompletedFuture())));
      To:

        EXPECT_CALL(*mock,
                setSource(source,
                    SetSourceReason::mhegstandard)).WillOnce(
                    DoAll(Invoke(boost::bind(&sendSourceEvent, mock,
                                SourceEventValue::change_complete,
                                SetSourceReason::mhegstandard)),
                        Invoke(boost::bind(&sendErrorEvent, mock, error,
                                ErrorEventContext::other, std::string())),
                    Return(makeCompletedFuture())));


case ErrorEventValue::server:
case ErrorEventValue::network:
    // used in GST MR and defined to raise MEDIA_ERR_NETWORK in
    // https://jira.youview.co.uk/browse/SOLDES-584. 
    // All other GST_RESOURCE_xxx including HTTP errors

    currentNetworkState = QMediaPlayerInterface::NETWORK_ERROR;


case ErrorEventValue::other;
    // All any other GST errors. 
    //
    // if(readyState==HAVE_NOTHING) error=MEDIA_ERR_SRC_NOT_SUPPORTED 
    // else error=MEDIA_ERR_DECODE 
    // in https://jira.youview.co.uk/browse/SOLDES-584. 

    if(QMediaPlayerInterface::HAVE_NOTHING == currentReadyState)
    {
        currentNetworkState = QMediaPlayerInterface::FORMAT_ERROR;
    }
    else
    {
        currentNetworkState = QMediaPlayerInterface::DECODE_ERROR;
    }

case ErrorEventValue::locator:
    // not used in GST MR but defined to raise MEDIA_ERR_SRC_NOT_SUPPORTED in
    // https://jira.youview.co.uk/browse/SOLDES-584
    currentNetworkState = QMediaPlayerInterface::FORMAT_ERROR;

case ErrorEventValue::tag:
case ErrorEventValue::language:
case ErrorEventValue::linear_selection:
    // https://jira.youview.co.uk/browse/SOLDES-584 said N/A


<Q>
When add this to MOCK MR and run Qunit, it loops forever in MR showing the
below debug line and why?

DEBUG  Vanadium.WebKit.VideoElement/src/VanadiumMediaPlayer.cpp:219 Position: 0

void registerMockForErrorHandlingOther()
{
    boost::shared_ptr<MockMediaRouter> mock = makeMock(
            "http://bbc.co.uk/ErrorHandlingSink.mpd",
            "ONDEMAND.ABR");

    EXPECT_CALL(*mock, getPosition()).WillRepeatedly(
            Return(completedFuture(Position(0, 0, 1000000))));

    EXPECT_CALL(*mock, getMediaDuration()).WillRepeatedly(
            Return(makeCompletedFuture(1000000)));

    EXPECT_CALL(*mock, setPlaySpeed(_)).WillRepeatedly(
                Return(makeCompletedFuture()));

    EXPECT_CALL(*mock, start()).WillOnce(
        DoAll(Invoke(boost::bind(&sendErrorEvent, mock, ErrorEventValue::other,
                        ErrorEventContext::other, std::string())),
            Return(makeCompletedFuture())));

    registerMock("ErrorHandlingOther", mock);
}


<mock-timeout>
There is a timeout in mock repo:
boost::posix_time::seconds(VERIFICATION_TIMEOUT),


<may-be-a-bug>

1. The interface to get state from client to media player uses a translation
to map enums:

MediaPlayer::ReadyState translateReadyState(QMediaPlayerInterface::ReadyState state)
{
    switch(state)
    {
    case QMediaPlayerInterface::HAVE_NOTHING:
        return MediaPlayer::HaveNothing;
    case QMediaPlayerInterface::HAVE_METADATA:
        return MediaPlayer::HaveMetadata;
    case QMediaPlayerInterface::HAVE_CURRENT_DATA:
        return MediaPlayer::HaveCurrentData;
    case QMediaPlayerInterface::HAVE_FUTURE_DATA:
        return MediaPlayer::HaveFutureData;
    case QMediaPlayerInterface::HAVE_ENOUGH_DATA:
        return MediaPlayer::HaveEnoughData;
    };
    return static_cast<MediaPlayer::ReadyState>(-1);
}

MediaPlayer::NetworkState MediaPlayerPrivateMediaRouter::networkState() const
{
    return translateNetworkState(m_mediaPlayerImpl->networkState());
}


2. However, callbacks to media player simply forwards values. May cause a
problem in the client that is HTMLMediaElement.cpp ???

NO since client explicitly make a call to get state when callback is fired.

class MediaPlayerPrivateMediaRouterCallbacks : public QMediaPlayerCallbackInterface
{
    void networkStateChanged()
    {
        m_mediaPlayer->networkStateChanged();
    }

    void readyStateChanged()
    {
        m_mediaPlayer->readyStateChanged();
    }
}

void VanadiumMediaPlayer::ErrorEvent(const ErrorEventValue::Enum error,
            const ErrorEventContext::Enum,
            const std::string&)
{
    switch(error)
    {
        case ErrorEventValue::other:
            currentNetworkState = QMediaPlayerInterface::NETWORK_EMPTY;
            callbacks.networkStateChanged();
            break;
    }
};


<tickets>
https://jira.youview.co.uk/browse/SOLDES-547
https://jira.youview.co.uk/browse/SOLDES-584
https://jira.youview.co.uk/browse/CANPDE-4113


https://jira.youview.co.uk/browse/CANDEL-3601
https://jira.youview.co.uk/browse/CANPDE-4190
PF735.11 - Errors launching HTML Players with encrypted VoD assets (PDL-MS3) -
from Players page or deep-linking 

https://wiki.youview.co.uk/display/CANPDE/Legacy+Error+Messages?src=search


={============================================================================
*kt_dev_uv_stack_255* zinc-mr-web: ended event

https://html.spec.whatwg.org/multipage/embedded-content.html#event-media-ended

A media element is said to have ended playback when:

    The element's readyState attribute is HAVE_METADATA or greater, and

    Either:
        The current playback position is the end of the media resource, and

        The direction of playback is forwards, and

        Either the media element does not have a loop attribute specified, or
        the media element has a current media controller. 

    Or:
        The current playback position is the earliest possible position, and

        The direction of playback is backwards. 

The ended attribute must return true if, the last time the event loop reached
step 1, the media element had ended playback and the direction of playback was
forwards, and false otherwise.


WebCore/html/HTMLMediaElement.cpp

bool HTMLMediaElement::endedPlayback() const
{
  float dur = duration();
  if (!m_player || isnan(dur))
    return false;

  // 4.8.10.8 Playing the media resource

  // A media element is said to have ended playback when the element's 
  // readyState attribute is HAVE_METADATA or greater, 
  if (m_readyState < HAVE_METADATA)
    return false;

  // and the current playback position is the end of the media resource and the
  // direction of playback is forwards, Either the media element does not have a
  // loop attribute specified, or the media element has a current media
  // controller.
  float now = currentTime();
  if (m_playbackRate > 0)
    return dur > 0 && now >= dur && (!loop() || m_mediaController);

  // or the current playback position is the earliest possible position and the
  // direction of playback is backwards
  if (m_playbackRate < 0)
    return now <= 0;

  return false;
}

bool HTMLMediaElement::ended() const
{
  // 4.8.10.8 Playing the media resource
  // The ended attribute must return true if the media element has ended 
  // playback and the direction of playback is forwards, and false otherwise.
  return endedPlayback() && m_playbackRate > 0;
}


={============================================================================
*kt_dev_uv_stack_256* zinc-mr: vanadium: underflow error handle

commit 0c4b989fe8d287edb89d202e0e4104ab506fd16c
Author: Alex Ashley <alex.ashley@youview.com>
Date:   Fri Mar 28 11:15:11 2014 +0000

    DEVARCH-7251: send meaningful warnings and errors from gst_nexus_sink_on_error
    
    Rather than sending an error number from nexussink using a private
    message structure, this commit replaces this with meaningful error
    or warning messages using the gstreamer defined message structures.

static void gst_nexus_sink_on_error( void* context, int reason )
{
  case EFifoEmpty:
    if ( g_atomic_int_get(&sink->eos_received) ) {
      GST_TRACE_OBJECT(sink, "FIFO empty, sending EOS");
      GST_BASE_SINK_CLASS( gst_nexus_sink_parent_class )
        ->event( &sink->parent, gst_event_new_eos() );
    }
    else {
      GST_TRACE_OBJECT(sink, "FIFO empty");
      msg = gst_nexus_sink_create_warning(sink, &err,
          GST_STREAM_ERROR, GST_STREAM_ERROR_FAILED,
          "FIFO empty");
    }
    break;
}


// commit 4cff7c7f0a46b543e94e3315a8aa33d472771541
// Author: Mariusz Buras <mariusz.buras@youview.com>
// Date:   Fri Sep 18 18:23:36 2015 +0100
// 
//     DEVARCH-9489: Nickel.System.GStreamer: Make sure StatusEvent::underflow
//     is not sent while seeking
//
//    So the fix is to stop YV MR from sending StatusEventValue::underrun
//    events when seek is in progress.
//
// note:
// However, this do not work 'perfectly'
// 
// GstMediaRouter.cpp:1264 KT: seekPosition: seekInFlight = true
// GstMediaRouter.cpp:466  KT: warning domain: gst-stream-error-quark, code: 1
// GstMediaRouter.cpp:472  KT: warning domain: seekInFlight: 1, underflow:0
// GstMediaRouter.cpp:1264 KT: seekPosition: seekInFlight = true
// GstMediaRouter.cpp:1264 KT: seekPosition: seekInFlight = true
//
// eats up the first underflow event
//
// GstMediaRouter.cpp:1192 KT: seekPositionFinish_locked: 
//    send started and seekInFlight = false
//
// GstMediaRouter.cpp:466  KT: warning domain: gst-stream-error-quark, code: 1
// GstMediaRouter.cpp:472  KT: warning domain: seekInFlight: 0, underflow:0
// GstMediaRouter.cpp:476  KT: warning domain: fire underflow
// GstMediaRouter.cpp:466  KT: warning domain: gst-stream-error-quark, code: 9
//
// However, will not eat up the second and will fire event up to the chain.

bool GstMediaRouter::handleBusCallback(GstBus* /*bus*/, GstMessage* msg)
{
  case GST_MESSAGE_WARNING:
    {

      gchar  *debug = NULL;
      GError *error = NULL;

      gst_message_parse_warning (msg, &error, &debug);

      const NS_ZINC::ScopedObj<GError> error_owner(error, g_error_free);
      const NS_ZINC::ScopedObj<gchar> debug_owner(debug, g_free);

      if (!seekInFlight && !underflow && error->code == GST_STREAM_ERROR_FAILED) {
        underflow = true;
        underflowTime = sinkBin->getPresentationTime(GST_FORMAT_TIME);
        produceStatusEvent(StatusEventValue::underflow);
      }

      break;
    }
}

void VanadiumMediaPlayer::StatusEvent(const StatusEventValue::Enum statusEvent)
{
    VANADIUM_FUNC_TRACE;

    VANADIUM_DEBUG("statusEvent: " << statusEvent);

    // STARTED: A StatusEvent of this value shall be emitted when the first
    // frame of a MediaRouter's media is output from the decoder following a
    // call to start, following a seek to a different position within the media,
    // or when a MediaRouter resumes playback after recovering from an
    // underflow.

    if(statusEvent == StatusEventValue::started)
    {
        if(isSeeking)
        {
            // We were seeking and normal playback has just resumed
            isSeeking = false;

            if(pauseState != PAUSED)
            {
                mediaRouter->setPlaySpeed(1.0);
            }
            callbacks.timeChanged();
        }
        else
        {
            currentReadyState = HAVE_ENOUGH_DATA;
            callbacks.readyStateChanged();
        }
    }
}


<old-private-gst>

if (err && err->code == GST_STREAM_ERROR_FAILED && 
    g_strrstr(debug, "FIFO empty") && !m_stallTimerHandler)
{
    m_stallTimerHandler = 
      g_timeout_add_seconds(1, reinterpret_cast<GSourceFunc>(
            MediaPlayerPrivateGStreamer::stallTimeoutCallback), this);
}

gboolean MediaPlayerPrivateGStreamer::stallTimeoutCallback(MediaPlayerPrivateGStreamer* player)
{
  // This is the callback for a timeout following a FIFO empty message from Nexus
  ASSERT(isMainThread());
  if(players.find(player)!=players.end()) {

    if(!player->m_paused && !player->m_seeking && !player->m_isEndReached 
        && !player->m_resetPipeline) {

      LOG_MEDIA_MESSAGE ("Media pipeline has stalled");
      player->m_readyState = MediaPlayer::HaveCurrentData;
      player->m_player->readyStateChanged();
    }
  }
  return FALSE;
}

// qtwebkit/Source/WebCore/platform/graphics/qt/MediaPlayerPrivateQt.cpp

    } else if (currentStatus == QMediaPlayer::StalledMedia) {
        m_networkState = MediaPlayer::Loading;
        m_readyState = MediaPlayer::HaveCurrentData;
    } else if (currentStatus == QMediaPlayer::BufferedMedia


note: this is HTML standard said:

stalled 	Event 	

The user agent is trying to fetch media data, but data is unexpectedly not
forthcoming. 	

networkState is NETWORK_LOADING. 

<implemented>

void VanadiumMediaPlayer::StatusEvent(const StatusEventValue::Enum statusEvent)
{
    VANADIUM_FUNC_TRACE;

    VANADIUM_DEBUG("statusEvent: " << statusEvent);

    ...

    if(QMediaPlayerInterface::NETWORK_LOADING == currentNetworkState &&
        StatusEventValue::underflow == statusEvent)
    {
        VANADIUM_DEBUG("statusEvent: UNDERFLOW: currentNetworkState " 
            << currentNetworkState );
        currentReadyState = HAVE_CURRENT_DATA;
        callbacks.readyStateChanged();
    }
}


<wait-three-seconds>
The stall timeout is a user-agent defined length of time, which should be about
three seconds. When a media element that is actively attempting to obtain media
data has failed to receive any data for a duration equal to the stall timeout,
     the user agent must queue a task to fire a simple event named stalled at
     the element.


<log-when-seeking-on-implemented>
VanadiumMediaPlayer.cpp:537 KT: statusEvent: 0
VanadiumMediaPlayer.cpp:542 KT: statusEvent: started: isSeeking: 0 currentReadyState: 3

do seeking

VanadiumMediaPlayer.cpp:537 KT: statusEvent: 5
VanadiumMediaPlayer.cpp:537 KT: statusEvent: 5

started

VanadiumMediaPlayer.cpp:537 KT: statusEvent: 0
anadiumMediaPlayer.cpp:542 KT: statusEvent: started: isSeeking: 1 currentReadyState: 4

underflow (regardless of if from seeking or net down)

anadiumMediaPlayer.cpp:537 KT: statusEvent: 4
anadiumMediaPlayer.cpp:573 KT: start stall timer: 

started (why two started events?)

anadiumMediaPlayer.cpp:537 KT: statusEvent: 0
anadiumMediaPlayer.cpp:542 KT: statusEvent: started: isSeeking: 0 currentReadyState: 4
anadiumMediaPlayer.cpp:558 KT: not seeking and remove stall timer: 


={============================================================================
*kt_dev_uv_stack_256* zinc-mr: connection retry

/Polonium.GSTHLSDemux/src/gsthlsdemux.c:279:  demux->num_retries = DEFAULT_CONNECTION_RETRIES;
/Polonium.GSTHLSDemux/src/gsthlsdemux.c:319:      demux->num_retries = g_value_get_uint (value);
/Polonium.GSTHLSDemux/src/gsthlsdemux.c:354:      g_value_set_uint (value, demux->num_retries);
/Polonium.GSTHLSDemux/src/gsthlsdemux.c:1205:  ssize_t tries_left = demux->num_retries + 1;
/Polonium.GSTHLSDemux/src/gsthlsdemux.c:1229:        demux->num_retries - tries_left + 1,demux->num_retries, http_status);
/Polonium.GSTHLSDemux/src/gsthlsdemux.c:1231:      if ( tries_left != demux->num_retries ) {
/Polonium.GSTHLSDemux/src/gsthlsdemux.c:1268:  ssize_t tries_left = demux->num_retries;
/Polonium.GSTHLSDemux/src/gsthlsdemux.h:84:  guint num_retries;            /* number of retries to be attempted */

$ gl DEFAULT_CONNECTION_RETRIES
DEFAULT_CONNECTION_RETRIES   92 Polonium/Polonium.GSTHLSDemux/src/gsthlsdemux.c #define DEFAULT_CONNECTION_RETRIES    5

<in-run-browser>
GST_HLSDEMUX_RETRIES=$(get_lsr_int_with_default
    "platform.gstreamer.hlsdemux-num-retries" 10) \
GST_HLSDEMUX_RETRIES_MIN_TIME=$(get_lsr_int_with_default
    "platform.gstreamer.hlsdemux-min-backoff-time-seconds" 1) \
GST_HLSDEMUX_RETRIES_MAX_TIME=$(get_lsr_int_with_default
    "platform.gstreamer.hlsdemux-max-backoff-time-seconds" 8) \


={============================================================================
*kt_dev_uv_stack_256* zinc-mr-error: when pull network out

<log-from-iplayer> means the previous implementation before YV MR.

syslog[775]: <info> (eth0): carrier now OFF (device state 8)
syslog[775]: <info> (eth0): device state change: 8 -> 2 (reason 40)
syslog[775]: <info> (eth0): deactivating device (reason: 40).
syslog[775]: <info> (eth0): canceled DHCP transaction, DHCP client pid 811 

Got network status change 0
eth0 cable unplugged, powering down 

:gst_soup_http_src_parse_status:<souphttpsrc0> error: Could not resolve server
  name.                                                                    

:gst_soup_http_src_parse_status:<souphttpsrc0> error: Error resolving
'vod-hls-uk-live.edgesuite.net': Name or service not known (2), URL:
http://vod-h)

:gst_uri_downloader_bus_handler:<uridownloader0> Received error: Could not
resolve server name. from souphttpsrc0, the download will be cancelled      

:gst_soup_http_src_parse_status:<souphttpsrc0> error: Could not resolve server
name.                                                                    

:gst_soup_http_src_parse_status:<souphttpsrc0> error: Error resolving 'vod-hls-uk-live.edgesuite.net': Name or service not known (2), URL: http://vod-h)

_base_src_loop:<souphttpsrc0> error: Internal data flow error.
_base_src_loop:<souphttpsrc0> error: streaming task paused, reason error (-5)


hlsdemux gsthlsdemux.c:1229:gst_hls_demux_download_safely:<hlsdemux0> Retrying
(attempt 0 of 10) download because of uridownloader error "7"                                          

...

hlsdemux gsthlsdemux.c:1229:gst_hls_demux_download_safely:<hlsdemux0> Retrying
(attempt 5 of 10) download because of uridownloader error "0"                                          


note: sink generates underflow

0:01:20.973202322 nexussink
gstnexussink.c:1569:gst_nexus_sink_create_warning:<nexussink> FIFO empty                                                                                                     

ERROR      webkitmediaplayer
MediaPlayerPrivateGStreamer.cpp:1541:handleMessage: KT: warning: 1: FIFO 

0:01:20.974039841 ERROR      webkitmediaplayer :handleMessage: KT: Got FIFO
empty and fire stall 

0:01:22.600858284 ERROR      webkitmediaplayer :stallTimeoutCallback: KT: stall
timer expired and report state 

ERROR      webkitmediaplayer
platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp:264:stallTimeoutCallback:
KT: Media pipeline has stalled

...

note: retries up to 10

0:02:00.666791966  1526   0xc4b830 WARN                hlsdemux
gsthlsdemux.c:1229:gst_hls_demux_download_safely:<hlsdemux0> Retrying (attempt
    10 of 10) download because of uridownloader error "2"                                         

...


WARN                hlsdemux
gsthlsdemux.c:1223:gst_hls_demux_download_safely:<hlsdemux0> error: http error  

WARN                hlsdemux
gsthlsdemux.c:1036:gst_hls_demux_updates_loop:<hlsdemux0> error: Could not fetch
the next fragment, giving  


note: GST_RESOURCE_ERROR_FAILED(1) -> NetworkError. HaveCurrentData(2) 
          -> NETWORK_ERROR

ERROR      webkitmediaplayer :handleMessage: KT: Error 1: Download error:
gst-resource-error-quark (url=http://vod-hls-uk-live.edgesuite.)

ERROR      webkitmediaplayer :handleMessage: KT: final error 6

ERROR      webkitmediaplayer :loadingFailed: KT: NET CHANGED 6
ERROR      webkitmediaplayer :loadingFailed: KT: STAT CHANGED 6

note: GST_RESOURCE_ERROR_NOT_FOUND(3) -> FormatError(4) -> DECODE_ERROR

ERROR      webkitmediaplayer :handleMessage: KT: Error 3: Could not fetch the
next fragment, giving up: gst-resource-error-quark (url=htt)

ERROR      webkitmediaplayer :handleMessage: KT: final error 4
ERROR      webkitmediaplayer :loadingFailed: KT: NET CHANGED 4

note: 
When put network back, GST do not recover and UI will show "Something went wrong
playing this programme" even if there is network on message on console.


<log-from-yv-mr-case>

GstMediaRouter.cpp:1378 
  presentationStreamTime: 1446208068625000000 bufPos 1446207515717614000 1446208110

GstMediaRouter.cpp:464 KT: what mesg : 32768                                                             
GstMediaRouter.cpp:464 KT: what mesg : 64                                                                
GstMediaRouter.cpp:464 KT: what mesg : 8192                                                              
GstMediaRouter.cpp:464 KT: what mesg : 64                                                                
GstMediaRouter.cpp:464 KT: what mesg : 8192                                                              
GstMediaRouter.cpp:464 KT: what mesg : 64                                                                
GstMediaRouter.cpp:464 KT: what mesg : 64                                                                
GstMediaRouter.cpp:464 KT: what mesg : 8192                                                              

GST_MESSAGE_DURATION_CHANGED  = (1 << 18),
GstMediaRouter.cpp:464 KT: what mesg : 262144                                                            

bcmgenet bcmgenet.0: eth0: link down

syslog[796]: <info> (eth0): carrier now OFF (device state 8)
syslog[796]: <info> (eth0): device state change: 8 -> 2 (reason 40)
syslog[796]: <info> (eth0): deactivating device (reason: 40).

nickel /home/kpark/buieth0 cable unplugged, powering down

GstMediaRouter.cpp:1378 
  presentationStreamTime: 1446208080292000000 bufPos 1446207527743281000 1446208120

// GST_MESSAGE_WARNING           = (1 << 2),
// GST_STREAM_ERROR_FAILED = 1,
GstMediaRouter.cpp:464 KT: what mesg : 4                                                                 
GstMediaRouter.cpp:486 KT: warning domain: gst-stream-error-quark, code: 1                               
GstMediaRouter.cpp:492 KT: warning domain: seekInFlight: 0, underflow:0                                  
GstMediaRouter.cpp:496 KT: warning domain: fire underflow                                                

GstMediaRouter.cpp:1378 
  presentationStreamTime: 1446208080292000000 bufPos 1446207532354376000 1446208130

GST_MESSAGE_STATE_CHANGED     = (1 << 6),
GstMediaRouter.cpp:464 KT: what mesg : 64

GST_MESSAGE_STREAM_STATUS     = (1 << 13),
GstMediaRouter.cpp:464 KT: what mesg : 8192

GstMediaRouter.cpp:464 KT: what mesg : 64

GstMediaRouter.cpp:1378 
  presentationStreamTime: 1446208080292000000 bufPos 1446207565228025000 1446208160

eth0 cable plugged in, powering up

GstMediaRouter.cpp:1378 
  presentationStreamTime: 1446208080292000000 bufPos 1446207565473281000 1446208160

bcmgenet bcmgenet.0: eth0: link up, 100 Mbps, full duplex                                                                                                                                                                                    

syslog[796]: <info> (eth0): carrier now ON (device state 2)
syslog[796]: <info> (eth0): device state change: 2 -> 3 (reason 40)
..
syslog[796]: <info> (eth0): device state change: 5 -> 7 (reason 0)
syslog[796]: <info> Activation (eth0) Beginning DHCPv4 transaction (timeout in 1073741823 seconds)
syslog[796]: <info> dhclient started with pid 2062
syslog[796]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) complete.
syslog[796]: <info> (eth0): DHCPv4 state changed nbi -> preinit

GstMediaRouter.cpp:1378 
  presentationStreamTime: 1446208080292000000 bufPos 1446207569934523000 1446208160


<adaptivedemux-source>

0:01:01.359822149  WARN           adaptivedemux gstadaptivedemux.c:623:
gst_adaptive_demux_handle_message:<dashdemux0:video_00> Source posted error: 1482:5 Could not establish connection to server. (gstsouphttpsrc.c(1565): gst_soup_http_src_parse_status (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc1:

Could not connect: Network is unreachable (4), URL: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/V5/10193008.m4s, Redirect to: (NULL))

// video-try-01

// 0:01:01.360046815  DEBUG          adaptivedemux gstadaptivedemux.c:1680:
// gst_adaptive_demux_stream_fragment_download_finish:<dashdemux0:video_00> Download finish: -100 custom-error - err: 0x576e10

0:01:01.360276408  DEBUG          adaptivedemux gstadaptivedemux.c:1963:
gst_adaptive_demux_stream_download_uri:<dashdemux0:video_00> Fragment download finished: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/V5/10193008.m4s -100 custom-error

0:01:01.361295741  WARN           adaptivedemux gstadaptivedemux.c:623:
gst_adaptive_demux_handle_message:<dashdemux0:video_00> Source posted error: 1482:5 Could not establish connection to server. (gstsouphttpsrc.c(1565): gst_soup_http_src_parse_status (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc1:

Could not connect: Network is unreachable (4), URL: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/V5/10193008.m4s, Redirect to: (NULL))


// 0:01:01.361614112  DEBUG          adaptivedemux gstadaptivedemux.c:1680:
// gst_adaptive_demux_stream_fragment_download_finish:<dashdemux0:video_00> Download finish: -100 custom-error - err: 0x579a20

0:01:01.363234963  WARN           adaptivedemux gstadaptivedemux.c:623:
gst_adaptive_demux_handle_message:<dashdemux0:audio_00> Source posted error: 1482:5 Could not establish connection to server. (gstsouphttpsrc.c(1565): gst_soup_http_src_parse_status (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc2:

Could not connect: Network is unreachable (4), URL: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/A1/10193008.m4s, Redirect to: (NULL))

0:01:01.363590741  WARN           adaptivedemux gstadaptivedemux.c:623:
gst_adaptive_demux_handle_message:<dashdemux0:video_00> Source posted error: 1475:1 Internal data flow error. (gstbasesrc.c(2943): gst_base_src_loop (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc1:

streaming task paused, reason error (-5))

0:01:01.363825334  DEBUG          adaptivedemux gstadaptivedemux.c:1680:
gst_adaptive_demux_stream_fragment_download_finish:<dashdemux0:audio_00> Download finish: -100 custom-error - err: 0x577450

// video-try-03

0:01:01.364296852  DEBUG          adaptivedemux gstadaptivedemux.c:1680:
gst_adaptive_demux_stream_fragment_download_finish:<dashdemux0:video_00> Download finish: -100 custom-error - err: 0x56fdd0

// audio
0:01:01.364958371  DEBUG          adaptivedemux gstadaptivedemux.c:1963:gst_adaptive_demux_stream_download_uri:<dashdemux0:audio_00> Fragment download finished: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/A1/10193008.m4s -100 custom-error

<video>
0:01:01.365697852  DEBUG          adaptivedemux gstadaptivedemux.c:2054:
gst_adaptive_demux_stream_download_fragment:<dashdemux0:video_00> Fragment download result: -100 custom-error

0:01:01.365850778  DEBUG          adaptivedemux gstadaptivedemux.c:2062:gst_adaptive_demux_stream_download_fragment:<dashdemux0:video_00> Converting error of live stream to EOS

0:01:01.365980556  DEBUG          adaptivedemux gstadaptivedemux.c:2259:gst_adaptive_demux_stream_download_loop:<dashdemux0:video_00> EOS, checking to stop download loop

0:01:01.366078852  DEBUG          adaptivedemux gstadaptivedemux.c:1749:gst_adaptive_demux_stream_wait_manifest_update:<dashdemux0> No fragment left but live playlist, wait a bit


0:01:01.366081593  WARN           adaptivedemux gstadaptivedemux.c:623:gst_adaptive_demux_handle_message:<dashdemux0:audio_00> Source posted error: 1482:5 Could not establish connection to server. (gstsouphttpsrc.c(1565): gst_soup_http_src_parse_status (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc2:

Could not connect: Network is unreachable (4), URL: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/A1/10193008.m4s, Redirect to: (NULL))

0:01:01.366276852  DEBUG          adaptivedemux gstadaptivedemux.c:1680:gst_adaptive_demux_stream_fragment_download_finish:<dashdemux0:audio_00> Download finish: -100 custom-error - err: 0x579840

0:01:01.367141296  1820   0x5f1660 WARN           adaptivedemux gstadaptivedemux.c:623:gst_adaptive_demux_handle_message:<dashdemux0:audio_00> Source posted error: 1475:1 Internal data flow error. (gstbasesrc.c(2943): gst_base_src_loop (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc2:
streaming task paused, reason error (-5))
0:01:01.367519741  1820   0x5f1660 DEBUG          adaptivedemux gstadaptivedemux.c:1680:gst_adaptive_demux_stream_fragment_download_finish:<dashdemux0:audio_00> Download finish: -100 custom-error - err: 0x577e30
0:01:01.368263111  1820   0x57fcc0 DEBUG          adaptivedemux gstadaptivedemux.c:2054:gst_adaptive_demux_stream_download_fragment:<dashdemux0:audio_00> Fragment download result: -100 custom-error
0:01:01.368465890  1820   0x57fcc0 DEBUG          adaptivedemux gstadaptivedemux.c:2062:gst_adaptive_demux_stream_download_fragment:<dashdemux0:audio_00> Converting error of live stream to EOS

0:01:01.368547075  1820   0x57fcc0 DEBUG          adaptivedemux gstadaptivedemux.c:2259:gst_adaptive_demux_stream_download_loop:<dashdemux0:audio_00> EOS, checking to stop download loop

0:01:01.368604741  1820   0x57fcc0 DEBUG          adaptivedemux gstadaptivedemux.c:1749:gst_adaptive_demux_stream_wait_manifest_update:<dashdemux0> No fragment left but live playlist, wait a bit


/release-humax-dtr_t2100/Zinc/Zinc.3rdPartyStack/gst-plugins-bad-1.6.0/
gst-libs/gst/adaptivedemux/gstadaptivedemux.c


gst_adaptive_demux_stream_download_loop (GstAdaptiveDemuxStream * stream)
{
  ret = gst_adaptive_demux_stream_download_fragment (stream);

  case GST_FLOW_EOS:
      GST_DEBUG_OBJECT (stream->pad, "EOS, checking to stop download loop");

  default:
  if (++stream->download_error_count > MAX_DOWNLOAD_ERROR_COUNT) {
    goto download_error;
  }
}

note:
after all, _download_fragmame should not return GST_FLOW_EOS:

#define MAX_DOWNLOAD_ERROR_COUNT 3

static GstFlowReturn
gst_adaptive_demux_stream_download_fragment (GstAdaptiveDemuxStream * stream)
{
    ret =
        gst_adaptive_demux_stream_download_uri (demux, stream, url,
        stream->fragment.range_start, stream->fragment.range_end);

    GST_DEBUG_OBJECT (stream->pad, "Fragment download result: %d %s",
        stream->last_ret, gst_flow_get_name (stream->last_ret));

    if (ret != GST_FLOW_OK) {
      /* TODO check if we are truly stoping */
      if (ret == GST_FLOW_CUSTOM_ERROR && gst_adaptive_demux_is_live (demux)) {
        if (++stream->download_error_count <= MAX_DOWNLOAD_ERROR_COUNT) {
          /* looks like there is no way of knowing when a live stream has ended
           * Have to assume we are falling behind and cause a manifest reload */
          GST_DEBUG_OBJECT (stream->pad,
              "Converting error of live stream to EOS");
          return GST_FLOW_EOS;
        }
      }
}


gst_adaptive_demux_stream_download_uri ()
{
  GST_DEBUG_OBJECT (stream->pad, "Fragment download finished: %s %d %s",
      uri, stream->last_ret, gst_flow_get_name (stream->last_ret));
}


={============================================================================
*kt_dev_uv_stack_256* mr-dash--error: http 404

GST_DEBUG_NO_COLOR=1 GST_DEBUG_FILE=/not-found.txt GST_DEBUG=4 gstmr-play.sh http://wll1p04345.dev.youview.co.uk/TalkTalk_YouView_TV_Ad-1_vid_dash.mpd


{when-404-from-the-start}
note: in this case there is no vanadium.log
GST_DEBUG_NO_COLOR=1 GST_DEBUG_FILE=/not-found.txt GST_DEBUG=4 gstmr-play.sh http://live-dash-clear.dev.youview.co.uk/channel13/channel13.isml/channel13.mpd

ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" runBrowserStandalone.sh --url http://filegateway.youview.co.uk/applications/applications/html/app-source/cdi-player-FR15

note: no different when tries out from a web page and play one which are not
exist or use direct url.

// GST_MESSAGE_ERROR             = (1 << 1),
GstMediaRouter.cpp:464 KT: what mesg : 2

// GST_RESOURCE_ERROR_NOT_FOUND,
GstMediaRouter.cpp:515 KT: error domain: gst-resource-error-quark, code: 3
msg->src: GstSoupHTTPSrc src: source

// uses g_object_get(src, "last-http-error-code", &code, NULL);
GstMediaRouter.cpp:348 KT: resource error: server: code: 404

// server = 6,
GstMediaRouter.cpp:562 KT: produceEvent: 6

// note: this is previous status
// NetworkState { Empty, Idle, Loading(2)
// ReadyState  { HaveNothing(0)
VanadiumMediaPlayer.cpp:717 KT: currentNetworkState: 2 currentReadyState: 0 error: 6


path=/Zinc/Media/MediaRouters/3; interface=Zinc.Media.MediaRouter; member=setSource
   string "http://live-dash-clear.dev.youview.co.uk/channel13/channel13.isml/channel13.mpd"
   int32 1

note:
This is 'error->message' string from gst_message_parse_error (msg, &error, &debug);
KT: error mesg: Not Found

path=/Zinc/Media/MediaRouters/3; interface=Zinc.Media.MediaRouter; member=ErrorEvent
   int32 6    note: this is error value
   int32 1
   string "Not Found
GStreamer error domain: gst-resource-error-quark
Additional debug:

note:
This is 'debug' string from gst_message_parse_error (msg, &error, &debug);

gstsouphttpsrc.c(1623): gst_soup_http_src_parse_status (): \
/GstPipeline:pipeline/GstBin:VirtualBinTypefind/GstURIDecodeBin:uri-decoder/GstSoupHTTPSrc:source: \
Not Found (404), URL: http://live-dash-clear.dev.youview.co.uk/channel13/channel13.isml/channel13.mpd, Redirect to: (NULL)"


{when-404-in-the-middle}
ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" runBrowserStandalone.sh --url http://wll1p00830.dev.youview.co.uk:9080/video/live_404_2

// GST_RESOURCE_ERROR_NOT_FOUND
GstMediaRouter.cpp:543 KT: error domain: gst-resource-error-quark, code: 3 
msg->src: GstDashDemux src: dashdemux0

GstMediaRouter.cpp:564 KT: error domain: _other
GstMediaRouter.cpp:571 KT: produceEvent: 0

enum NetworkState { Empty, Idle, Loading(2), Loaded, FormatError, NetworkError, DecodeError };
enum ReadyState  { HaveNothing, HaveMetadata, HaveCurrentData, HaveFutureData, HaveEnoughData(4) };

VanadiumMediaPlayer.cpp:717 KT: currentNetworkState: 2 currentReadyState: 4 error: 0

KT: error mesg: Not Found: gstsouphttpsrc.c(1623): gst_soup_http_src_parse_status (): /GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc1:

path=/Zinc/Media/MediaRouters/1; interface=Zinc.Media.MediaRouter; member=ErrorEvent
   int32 0    note: this is error value
   int32 0
   string "Not Found: gstsouphttpsrc.c(1623): gst_soup_http_src_parse_status (): \
/GstPipeline:pipeline/GstBin:VirtualBinSrc/GstDecodeBin:decodebin1/GstDashDemux:dashdemux0/GstSoupHTTPSrc:souphttpsrc2:
Not Found (404), URL: http://wll1p00830.dev.youview.co.uk:9080/dash/live/V3/3300.m4v?404=3300,3302,3305,3307,3310,3312,3315,3317,3320,3322,3325,3327, Redirect to: (NULL)

GStreamer error domain: gst-resource-error-quark
Additional debug:
Error on stream dashdemux0:video_00"


<zira>
DEVARCH-10579: YV MediaRouter: Support HTTP 404 error for DASH play

The YV MediaRouter[1] specifies HTTP errors as server errors. However, HTTP
error support is different or not handled from the previous implementation
before YV MediaRouter and requires additional support from YV MediaRouter. 

During integration test phase[2], scenarios were identified which were not
reporting specified HTMLMediaElement error events such as the 404 error of
missing DASH segment.

This commit supports these cases and comes with corresponding test in YV
MediaRouter test harness.

[1] https://jira.youview.co.uk/browse/SOLDES-584
[2] DEVARCH-9697


={============================================================================
*kt_dev_uv_stack_256* mr-dash-error: corrupted stream

ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" runBrowserStandalone.sh --url http://wll1p00830.dev.youview.co.uk:9080/video/vod_corrupt_2

gstnexussink.c:1659:gst_nexus_sink_create_warning:<videosink> Video decode error
gstnexussink.c:1765:gst_nexus_sink_on_error:<videosink> Error: 0x0202

GstMediaRouter.cpp:496 warning domain: Video decode error                                                
GstMediaRouter.cpp:504 warning domain: errVal: 7                                                         

signal sender=:1.318 -> dest=(null destination) serial=400 path=/Zinc/Media/MediaRouters/0; interface=Zinc.Media.MediaRouter; member=ErrorEvent
   int32 7
   int32 0
   string "Video decode error
GStreamer warning domain: gst-stream-error-quark
Additional debug:
Video decode error"


<zira>
DEVARCH-10527: DASH: Fix wrong mapping of stream errors between sink and GST MR

The YV MediaRouter[1] specifies stream decode errors such as a case where there
is a corrupted segment in the stream to play and YV MediaRouter shall surface it
up to HTMLMediaElement. To that end, YV MediaRouter maps GStreamer errors or
warnings to HTMLMediaElement error depending on current network and metadata
state. However, it has found that GStreamer stream decode errors were mapped to
error domain while these were defined in warning domain in lower Nexus sink
element. So these are not surfaced to HTMLMediaElement.

This commit corrects this mapping in order to support and surface stream decode
errors, some log messages, and relevant test cases in YV MediaRouter test
harness.

[1] https://jira.youview.co.uk/browse/SOLDES-584


={============================================================================
*kt_dev_uv_stack_257* zinc-mr-web: qunit test

For each test, it creates video elements:
https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement

    video = document.createElement('video');

This means that it creates Vanadium each time.


/builds/topic/pc/zinc-build-root/release-debian-7-x86_64/Nickel/
  Nickel.System.API/include/mock/MockMediaRouterAsync.h

namespace Zinc {
namespace Media {

class ZINC_LOCAL MockMediaRouterAsync: public MediaRouterAsync
{
  public:

    /* ============================== Methods ================================== */

    typedef void Mock_setSourceRet;
    MOCK_METHOD2(setSource, NS_ZINC::Future< Mock_setSourceRet > 
        (const std::string&, const SetSourceReason::Enum));

    typedef std::string Mock_getSourceRet;
    MOCK_CONST_METHOD0(getSource, NS_ZINC::Future< Mock_getSourceRet > ());

    ...
};


/Vanadium.WebKit.VideoElement/test/MockMediaRouterRepository.cpp

class ZINC_LOCAL MockMediaRouterRepository
{
  ...
  registerMockForErrorHandlingSink();
};


void registerMockForErrorHandlingSink()
{
  boost::shared_ptr<MockMediaRouter> mock = makeMock(
      "http://bbc.co.uk/ErrorHandlingSink.mpd",
      "ONDEMAND.ABR");

  EXPECT_CALL(*mock, getPosition()).WillRepeatedly(
      Return(completedFuture(Position(0, 0, 1000000))));

  EXPECT_CALL(*mock, getMediaDuration()).WillRepeatedly(
      Return(makeCompletedFuture(1000000)));

  EXPECT_CALL(*mock, setPlaySpeed(_)).WillRepeatedly(
      Return(makeCompletedFuture()));

  EXPECT_CALL(*mock, start()).WillOnce(
      DoAll(Invoke(boost::bind(&sendErrorEvent, mock, ErrorEventValue::data,
            ErrorEventContext::other, std::string())),
        Return(makeCompletedFuture())));

  registerMock("ErrorHandlingSink", mock);
}


/Vanadium/Vanadium.WebKit.VideoElement/js/testplay.js

asyncTestCase("ErrorHandlingSink", function() {
    expect(1);
    video = document.createElement('video');

    video.addEventListener("error", function() {
        console.log("error event");
        equal(video.error.code, MediaError.MEDIA_ERR_DECODE, "Expected MEDIA_ERR_DECODE");
        start();
    });

    video.setAttribute('src', 'http://bbc.co.uk/ErrorHandlingSink.mpd');
    video.load();
    video.play();
});


How those two get 'linked' together? Use "ErrorHandlingSink" sting?


<careful>

1. Great care about "name"

void registerMockForErrorHandlingDataToNotSupported()
{
  ...
  registerMock("ErrorHandlingDataNotSupported", mock);  // note:
}

// from js
var onlyRunTheseTests = ["ErrorHandlingDataToNotSupported"];

Here missed "To" and got:

Could not find mock [ErrorHandlingDataToNotSupported]
Activating ErrorHandlingDataToNotSupported
terminate called after throwing an instance of 'std::runtime_error'
  what():  Mock function called more times than expected - returning default value.
    Function call: setSource(@0x7fff88b295c0 "http://bbc.co.uk/ErrorHandlingSink.mpd", 1)
    The mock function has no default action set, and its return type has no default value set.
Aborted


={============================================================================
*kt_dev_uv_stack_258* zinc-mr: yv webkit plugin

GST_DEBUG=5 ZINC_QMEDIA_PLAYER_LIB=/opt/zinc-trunk/lib/libVanadiumMediaRouterWebKitPlugin.so.0.0.0 \
./runBrowserStandalone.sh --url http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd

TRACE  vanadium /Vanadium/Vanadium.W3CEngine/src/YVWebPage.cpp:66 Network
request for
[http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd]: accepted


TRACE  vanadium
/Vanadium/Vanadium.MediaRouter.WebKit.Plugin/src/VanadiumMediaPlayer.cpp:316
ENTER: virtual bool vanadium::VanadiumMediaPlayer::didLoadingProgress() const


{to-changes}

1. change source 

// note: this log line only works when use MediaPlayerPrivateGStreamer.cpp
// since it inits gst and without GST_DEBUG set
ERROR_MEDIA_MESSAGE ("** KT: MP-GStreamer::supportsType: type(%s) supported!
    \n", type.utf8().data());


2. build qt and copy so to a box

$ scp $BLD/qtwebkit/lib/libQt5WebKit.so root@humax-01351:/opt/zinc-trunk/oss/lib/

3. check 
   getenv("ZINC_QMEDIA_PLAYER_LIB");

4. check 
   ./share/vanadium-webkit-mediarouter-plugin/system-factory.plugin-config
   libNickelSystemDbusClient.so createDbusSystemFactory(Zinc.MediaProxy)


={============================================================================
*kt_dev_uv_stack_258* zinc-mr: run cdi app on yv mr

# Tell WebKit to use the media router for video playback. The default is to use
# the built-in GStreamer pipeline
webkit_use_media_router="false"
[ "false" = "$(lsr-config --bool platform.settings.webkit-use-media-router || echo false)" ] || {
    webkit_use_media_router="true"
}

<to-use-old-mr>
note:
Use MediaPlayerPrivateGst and there are no MR dbus log.

lsr-config platform.settings.webkit-use-media-router false
lsr-config --bool platform.settings.webkit-use-media-router

ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" \
runBrowserStandalone.sh --url http://filegateway.youview.co.uk/applications/dev/mpask/Player-reference-App-FR15

<to-use-yv-mr>
note:
Run in nickelmedia daemon which is created when play. There are MR dbus log.

lsr-config platform.settings.webkit-use-media-router true
lsr-config --bool platform.settings.webkit-use-media-router

ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" \
runBrowserStandalone.sh --url http://filegateway.youview.co.uk/applications/dev/mpask/Player-reference-App-FR15

ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" \
runBrowserStandalone.sh --url http://filegateway.youview.co.uk/applications/applications/html/app-source/cdi-player-FR15

method call sender=:1.145 -> dest=:1.147 serial=3328
path=/Zinc/Media/MediaRouters/13; interface=Zinc.Media.MediaRouter;
member=getPosition


http://filegateway.youview.co.uk/applications/applications/html/app-source/cdi-player-FR15


={============================================================================
*kt_dev_uv_stack_259* zinc-mr: local web server and client

<server-side>
kpark@wll1p04345:~$ ll /usr/share/nginx/www

-rwxrwxrwx 1 root root  164 Jul  2 12:11 index.html*
-rwxrwxrwx 1 root root  644 Jul  2 12:25 test.html*
-rwxrwxrwx 1 root root 1408 Jul  2 14:41 test.js*
-rwxrwxrwx 1 root root 1285 Jul  2 12:20 testplay.js*


kpark@wll1p04345:~$ cat /usr/share/nginx/www/test.html 
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

  <!--
      A generic (default) HTML file for JS tests.

      If you need a test specific HTML file, name it after the
      JS test file
  -->

  <head>
    <title>Welcome to nginx on Kit</title>
    <script type="text/javascript" src="qunit-1.14.0.js"></script>
    <script type="text/javascript" src="qunit-headless.js"></script>

    <!-- This always has to be test.js due to the way the testing
         framework works -->
    <script type="text/javascript" src="test.js"></script>

  </head>

  <body>
  <center><h1>Welcome to nginx on Kit!</h1></center>
  </body>

</html>


kpark@wll1p04345:~$ cat /usr/share/nginx/www/test.js   
function beginTest(testID) {
    var req = new XMLHttpRequest();
    req.enctype = 'text\/plain';
    // We use a GET request to tell the MockMediaRouterRepository that a new
    // test case is starting, which is not very REST-ful but is nice and simple
    req.open('GET', 'http://localhost:5555/' + testID, false);
    req.setRequestHeader('Content-Type', 'text\/plain');
    req.send();
}

function testCase(testName, testFunction) {
    if(testName !== null)
    {
        beginTest(testName);
    }
}

// Create a video element as the first thing we do. This causes the
// libVanadiumVideoTagTest.so plugin to be loaded, which starts the embedded
// web server. The media router factory returns a default mock media router
// for this purpose
function startTesting() {
    video = document.createElement('video');
    // video.setAttribute('src', 'http://blahblahblah.com/media.mpd');
    video.setAttribute('src', 'http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd');
    video.setAttribute('autoplay', '');
    video.setAttribute('controls', 'controls');
    video.load();
    video.play();
}

startTesting();

/*test("CanPlayVideoElement", function() {*/
    //beginTest("CanPlayVideoElement");
    //video = document.createElement('video');
    //video.setAttribute('src', 'http://blahblahblah.com/media.mpd');
    //video.load();
    //ok(true, "video element created");
/*});*/


<client-side>

ZINC_QMEDIA_PLAYER_LIB="/opt/zinc-trunk/lib/libVanadiumWebKitVideoElement.so" \
runBrowserStandalone.sh --url http://wll1p04345.dev.youview.co.uk/test.html
http://filegateway.youview.co.uk/applications/applications/html/app-source/cdi-player-FR15

<use-local-to-play-dash>
GST_DEBUG_NO_COLOR=1 GST_DEBUG_FILE=/not-found GST_DEBUG=5 
GST_DEBUG=adaptivedemux:5 gstmr-play.sh http://wll1p04345.dev.youview.co.uk/TalkTalk_YouView_TV_Ad-1_vid_dash.mpd


<ee>

// 
2015-07-03 12:25:33,605 ERROR  1152333088 zinc /home/kpark/builds/_virtual_/humax.1000/DEVARCH/Zinc/Zinc.DBus.BindingRuntime/src/dbus/DBusClientCallback.cpp:41 Received remote error "org.freedesktop.DBus.Error.NoReply: Did not receive a reply. Possible causes include: the remote application did not send a reply, the message bus security policy blocked the reply, the reply timeout expired, or the network connection was broken." in response to call to 

/Zinc/Media/MediaRouterFactory

terminate called after throwing an instance of 'DBus::ErrorNoReply'
  what():  Did not receive a reply. Possible causes include: the remote application did not send a reply, the message bus security policy blocked the reply, the reply timeout expired, or the network connection was broken.
Aborted


[root@HUMAX /]# dbus-monitor "interface=Zinc.Media.MediaRouterFactory"
method call sender=:1.207 -> dest=Zinc.MediaProxy serial=14 path=/Zinc/Media/MediaRouterFactory; interface=Zinc.Media.MediaRouterFactory; member=createMediaRouter

no response

dbus-send 2>/dev/null --session --print-reply --type=method_call --dest='Zinc.DBusSendDaemon' /Zinc/Media/MediaRouterFactory Zinc.Media.MediaRouterFactory.createMediaRouter \
string:Zinc.MediaProxy 


={============================================================================
*kt_dev_uv_stack_400* zinc-mr: links

https://wiki.youview.co.uk/display/canvas/GStreamer+Emporium

// enable-debug-log
https://wiki.youview.co.uk/display/YVHTMLCRB/Debugging+video+playback+in+the+HTML+engine?src=search


={============================================================================
*kt_dev_uv_stack_402* zinc-mr: gst elements

Some element names that you might need to use:

webkitmediaplayer   Debug messages from MediaPlayerPrivateGstreamer.cpp

hlsdemux            The element that implements the HLS protocol

webkitwebsrc        
Only used if YV_WEBKIT_USE_WEBSRC is defined. If YV_WEBKIT_USE_WEBSRC is
defined, WebKit's networking stack is used to feed data to gstreamer

uridecodebin 
When playing MP4 or MPD files, uridecodebin is used to auto-plug modules that
can produce something that nexussink can accept

decodebin Base class of uridecodebin
basesink Base class of nexussink

uridownloader 
Used by hlsdemux and dashdemux to download fragments. For hlsdemux it is also
used to load media playlists

dashdemux     The element that implements the DASH protocol
fragmented    The element that implements m3u8 file parsing

 
{gst-inspect-on-box}
[root@HUMAX /]# gst-inspect-1.0
videotestsrc:  videotestsrc: Video test source
dashdemux:  dashdemux: DASH Demuxer
dashdemux: application/dash+xml: no extensions
mpegts:  tspacer: Pacer for MPEG-TS streams
fragmented:  hlsdemux: HLS Demuxer
fragmented:  hlssink: HTTP Live Streaming sink
mpegtsdemux:  tsparse: MPEG transport stream parser
mpegtsdemux:  tsdemux: MPEG transport stream demuxer
videoparsersbad:  h263parse: H.263 parser
videoparsersbad:  h264parse: H.264 parser
videoparsersbad:  diracparse: Dirac parser
videoparsersbad:  mpegvideoparse: MPEG video elementary stream parser
videoparsersbad:  mpeg4videoparse: MPEG 4 video elementary stream parser
videoparsersbad:  pngparse: PNG parser
videoparsersbad:  vc1parse: VC1 parser
isomp4:  qtdemux: QuickTime demuxer
isomp4:  rtpxqtdepay: RTP packet depayloader
isomp4:  qtmux: QuickTime Muxer
isomp4:  mp4mux: MP4 Muxer
isomp4:  ismlmux: ISML Muxer
isomp4:  3gppmux: 3GPP Muxer
isomp4:  mj2mux: MJ2 Muxer
isomp4:  qtmoovrecover: QT Moov Recover
vqe:  vqesrc: RTP Receiver
vqe:  vqesdpdemux: VQE SDP Demux
nexus:  nexussink: Nexus sink
tstimeshift:  tsshifter: Time Shift for MPEG TS streams
tstimeshift:  tsshifterbin: Time Shift + TS parser for MPEG TS streams
tstimeshift:  tsseeker: Time-shift seeker
tstimeshift:  tsindexer: Indexer for MPEG-TS streams
tstimeshift:  tsstamper: Stamper for MPEG-TS streams
coreelements:  capsfilter: CapsFilter
coreelements:  fakesrc: Fake Source
coreelements:  fakesink: Fake Sink
coreelements:  fdsrc: Filedescriptor Source
coreelements:  fdsink: Filedescriptor Sink      // note:
coreelements:  filesrc: File Source
coreelements:  funnel: Funnel pipe fitting
coreelements:  identity: Identity
coreelements:  input-selector: Input selector
coreelements:  output-selector: Output selector
coreelements:  queue: Queue
coreelements:  queue2: Queue 2
coreelements:  filesink: File Sink
coreelements:  tee: Tee pipe fitting
coreelements:  typefind: TypeFind
coreelements:  multiqueue: MultiQueue
coreelements:  valve: Valve element
audiotestsrc:  audiotestsrc: Audio test source
soup:  souphttpsrc: HTTP client source
soup:  souphttpclientsink: HTTP client sink
zmpsink:  zmpsink: Generic bin      // note:
playback:  playbin: Player Bin 2
playback:  playsink: Player Sink
playback:  subtitleoverlay: Subtitle Overlay
playback:  streamsynchronizer: Stream Synchronizer
playback:  decodebin: Decoder Bin
playback:  uridecodebin: URI Decoder
staticelements:  bin: Generic bin
staticelements:  pipeline: Pipeline object


{in-zinc}
kpark@wll1p04345:~/source/DEVARCH$ ag gst_element_register
Zinc/Zinc.3rdPartyStack/patches/gst_fluendo_timeshift-1.0.3/
   0007-Implement-an-element-that-will-aid-in-PCR-wraping-te.patch
531:+  if (!gst_element_register (plugin, "tsstamper", GST_RANK_NONE,

Zinc/Zinc.3rdPartyStack/patches/qt-everywhere-opensource-src-5.1.0/
   0008-WebKit-Support-GSTNexus-Video-Playback.patch
905:+    	gst_element_register(0, "webkitwebsrc", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_WEB_SRC);

Zinc/Zinc.3rdPartyStack/patches/qt-everywhere-opensource-src-5.1.0/
   0020-Use-WebkitWebSrc-instead-of-souphttpsrc.patch

3138: gst_element_register(0, "webkitwebsrc", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_WEB_SRC);
3171: gst_element_register(0, webkitwebsrcName, GST_RANK_PRIMARY + 100, WEBKIT_TYPE_WEB_SRC);

Zinc/Zinc.3rdPartyStack/patches/qt-everywhere-opensource-src-5.1.0/
   0019-stop-all-other-video-elements-when-another-video-ele.patch

1708:    gst_element_register(0, "webkitwebsrc", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_WEB_SRC);

Nickel/Nickel.LinearSource/zmp/gstzmpsink.c
728:  return gst_element_register (plugin, "zmpsink", GST_RANK_NONE,

Polonium/Polonium.GSTHLSDemux/src/gsthlssink.c
517:  return gst_element_register (plugin, "hlssink", GST_RANK_NONE,

Polonium/Polonium.GSTHLSDemux/src/gstfragmentedplugin.c
18:  if (!gst_element_register (plugin, "hlsdemux", GST_RANK_PRIMARY,

Polonium/Polonium.GSTTSPacer/src/gsttspacerelement.c
35:  if (!gst_element_register (plugin, "tspacer", GST_RANK_NONE,


={============================================================================
*kt_dev_uv_stack_402* zinc-mr: gst elements: libs and packages

ls -al /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so.0.0.0
374351 Sep 23 16:42 /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so.0.0.0*

ls -al /opt/zinc-trunk/lib/gstreamer-1.0/libgstcenccrypto.so.0.0.0
29423 Sep 24 08:27 /opt/zinc-trunk/lib/gstreamer-1.0/libgstcenccrypto.so.0.0.0*


:~/src-dev/DEVARCH/Zinc/Zinc.3rdPartyStack/packages$ ll gst*
-rw-r--r-- 1 kpark kpark   315131 Apr 28 11:23 gst_fluendo_timeshift-1.0.3.tar.bz2
-rw-r--r-- 1 kpark kpark 65738334 May 29 15:57 gst_libav-1.5.0.tar.bz2
-rw-r--r-- 1 kpark kpark  6471312 May 29 15:57 gst_plugins_bad-1.5.0.tar.bz2
-rw-r--r-- 1 kpark kpark  4318191 May 29 15:57 gst_plugins_base-1.5.0.tar.bz2
-rw-r--r-- 1 kpark kpark  4869327 May 29 15:57 gst_plugins_good-1.5.0.tar.bz2
-rw-r--r-- 1 kpark kpark  9487493 May 29 15:57 gst_plugins_ugly-1.5.0.tar.bz2
-rw-r--r-- 1 kpark kpark 44459079 May 29 15:57 gstreamer-1.5.0.tar.bz2
-rw-r--r-- 1 kpark kpark    23721 Apr 28 11:23 gst_vqe-1.1.0.tar.gz


={============================================================================
*kt_dev_uv_stack_423* zinc-mr: gst elements: nexussink

nexussink YouView's Polonium sink element that connects to NexusMgr

Polonium/Polonium.GSTNexus/src/gstnexuselements.c
36:  if (!gst_element_register (plugin, "nexussink", 
      GST_RANK_NONE, GST_TYPE_NEXUS_SINK))  {


[root@HUMAX /]# gst-inspect-1.0 nexussink
Factory Details:
  Rank                     none (0)
  Long-name                Nexus sink
  Klass                    Sink/Video
  Description              Demux, decode and display via Broadcom Nexus
  Author                   Will Manley <william.manley@youview.com>, 
   Chris Bass <chris.bass@rd.bbc.co.uk>, 
   Atish Nazir <atish.nazir@youview.com>, Alex Ashley <alex.ashley@youview.com>

Plugin Details:
  Name                     nexus
  Description              GStreamer elements that encapsulate Broadcom Nexus functionality
  Filename                 /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so
  Version                  0.1
  License                  Proprietary
  Source module            gstnexus
  Binary package           gst-nexus
  Origin URL               http://youview.com/

GObject
 +----GInitiallyUnowned
       +----GstObject
             +----GstElement
                   +----GstBaseSink
                         +----GstNexusSink

Pad Templates:
  SINK template: 'sink'
    Availability: Always
    Capabilities:
      video/mpegts
           systemstream: true
      video/x-h264
          stream-format: byte-stream
              alignment: { au, nal }
      video/mpeg
            mpegversion: { 2, 4 }
           systemstream: false
      audio/mpeg
            mpegversion: 1
                  layer: { 1, 3 }
      audio/mpeg
            mpegversion: 4
          stream-format: { adts, loas }


Pads:
  SINK: 'sink'
    Pad Template: 'sink'

Element Properties:
  name                : The name of the object
                        flags: readable, writable
                        String. Default: "nexussink0"
  parent              : The parent of the object
                        flags: readable, writable
                        Object of type "GstObject"
  sync                : Sync on the clock
                        flags: readable, writable
                        Boolean. Default: false
  max-lateness        : Maximum number of nanoseconds that a buffer can be late before it is dropped (-1 unlimited)
                        flags: readable, writable
                        Integer64. Range: -1 - 9223372036854775807 Default: -1 
  qos                 : Generate Quality-of-Service events upstream
                        flags: readable, writable
                        Boolean. Default: false
  async               : Go asynchronously to PAUSED
                        flags: readable, writable
                        Boolean. Default: true
  ts-offset           : Timestamp offset in nanoseconds
                        flags: readable, writable
                        Integer64. Range: -9223372036854775808 - 9223372036854775807 Default: 0 
  enable-last-sample  : Enable the last-sample property
                        flags: readable, writable
                        Boolean. Default: false
  last-sample         : The last sample received in the sink
                        flags: readable
                        Boxed pointer of type "GstSample"
  blocksize           : Size in bytes to pull per buffer (0 = default)
                        flags: readable, writable
                        Unsigned Integer. Range: 0 - 4294967295 Default: 4096 
  render-delay        : Additional render delay of the sink in nanoseconds
                        flags: readable, writable
                        Unsigned Integer64. Range: 0 - 18446744073709551615 Default: 160000000 
  throttle-time       : The time to keep between rendered buffers (0 = disabled)
                        flags: readable, writable
                        Unsigned Integer64. Range: 0 - 18446744073709551615 Default: 0 
  max-bitrate         : The maximum bits per second to render (0 = disabled)
                        flags: readable, writable
                        Unsigned Integer64. Range: 0 - 18446744073709551615 Default: 0 
  pcrpid              : The PCR PID that will be  used for sync.
                        flags: readable, writable
                        Integer. Range: 16 - 8190 Default: 8191 
  videopid            : The video PID that will be  decoded.
                        flags: readable, writable
                        Integer. Range: 16 - 8191 Default: 8191 
  audiopid            : The audio PID that will be decoded.
                        flags: readable, writable
                        Integer. Range: 16 - 8191 Default: 8191 
  videocodec          : The video codec (NONE=0, MPEG2=1, H264=2, MPEG4=3, HEVC=4)
                        flags: readable, writable
                        Integer. Range: 0 - 4 Default: 2 
  audiocodec          : The audio codec (NONE=0, MP2=1, AAC_LOAS=2, AAC_ADTS=3, AAC=4, MP3=5)
                        flags: readable, writable
                        Integer. Range: 0 - 4 Default: 2 
  videowindow         : Uses relative scheme of floats from 0.0 to 1.0, x1,y1,x2,y2 .  e.g. fullscreen 0.0,0.0,1.0,1.0, bottom right quarter 0.5,0.5,1.0,1.0
                        flags: writable
                        String. Default: "0.0,0.0,1.0,1.0" Write only
  release             : Release the nexus resources when  in the paused state.
                        flags: readable, writable
                        Boolean. Default: false


{changes-from-fix-to-solve-audio-drop}
1. change qlist in writer

from:
 QList{ elem1     , elem2 }
         -> queue    -> queue

each source(2 sinks) points to each list elem

to:
 QList{ elem1     , elem2 }
         -> source    -> source
            -> queue
            
each source points to queue since writer need to access both source to
implement pumping based on fifo level checks.


{poll-decoder-status}
1. when play hls via the MR proxy, only one sink is created and 

16578:0:00:05.907415774 14290   0x5c1600 DEBUG              nexussink /gstnexussink.c:382:
gst_nexus_sink_render_locked:<nexussink> KT: call poll_decoder_status: to test Joseph version

27026:0:00:11.900851660 14290   0x5c1600 DEBUG              nexussink /gstnexussink.c:382:
gst_nexus_sink_render_locked:<nexussink> KT: call poll_decoder_status: to test Joseph version


No poll-decoder-status from gst_nexus_sink_get_times_locked and means that time
is right.


2. when play dash via command line,

No poll-decoder-status from render_locked() but there are many from
gst_nexus_sink_get_times_locked.

The poll-decoder-status is called when timestamp or duration is wrong and this
happens only audio for dash play. Does it suggest that audio duration is wrong?

nexussink /gstnexussink.c:1934:gst_nexus_sink_get_times_locked:<nexussink0> 
get_times 9530:26:52.800000000 9530:26:52.8100

nexussink /gstnexussink.c:1934:gst_nexus_sink_get_times_locked:<nexussink0> 
get_times 9530:26:52.800000000 9530:26:52.8100

nexussink /gstnexussink.c:1917:gst_nexus_sink_get_times_locked:<nexussink1> 
KT: call poll_decoder_status: to test Joseph v

nexussink /gstnexussink.c:1934:gst_nexus_sink_get_times_locked:<nexussink1> 
get_times 9530:26:52.800000000 99:99:99.999999


={============================================================================
*kt_dev_uv_stack_426* zinc-mr: gst elements: tsnexusbin

tsnexusbin YouView's Polonium sink bin that uses tsparser to auto-detect the PIDs for nexussink
tsnexusbin: TS parser + Nexus sink for MPEG TS streams


Polonium/Polonium.GSTNexus/src/gstnexuselements.c
40:  if (!gst_element_register (plugin, "tsnexusbin", /*GST_RANK_PRIMARY+1*/ GST_RANK_NONE,


[root@HUMAX /]# gst-inspect-1.0 tsnexusbin
Factory Details:
  Rank                     none (0)
  Long-name                TS parser + Nexus sink for MPEG TS streams
  Klass                    Generic/Bin
  Description              Provide decode of MPEG TS streams
  Author                   Alex Ashley <alex.ashley@youview.com>

Plugin Details:
  Name                     nexus
  Description              GStreamer elements that encapsulate Broadcom Nexus functionality
  Filename                 /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so
  Version                  0.1
  License                  Proprietary
  Source module            gstnexus
  Binary package           gst-nexus
  Origin URL               http://youview.com/

GObject
 +----GInitiallyUnowned
       +----GstObject
             +----GstElement
                   +----GstBin
                         +----GstTSNexusBin

Implemented Interfaces:
  GstChildProxy

Pad Templates:
  SINK template: 'sink'
    Availability: Always
    Capabilities:
      video/mpegts                     // note: TS input
           systemstream: true


Pads:
  SINK: 'sink'

Element Properties:
  name                : The name of the object
                        flags: readable, writable
                        String. Default: "tsnexusbin0"
  parent              : The parent of the object
                        flags: readable, writable
                        Object of type "GstObject"
  async-handling      : The bin will handle Asynchronous state changes
                        flags: readable, writable
                        Boolean. Default: false
  message-forward     : Forwards all children messages
                        flags: readable, writable
                        Boolean. Default: false
  videowindow         : Uses relative scheme of floats from 0.0 to 1.0, x1,y1,x2,y2 .  e.g. fullscreen 0.0,0.0,1.0,1.0, bottom right quarter 0.5,0.5,1.0,1.0
                        flags: writable
                        String. Default: "0.0,0.0,1.0,1.0" Write only

Children:                              // note: embedded?
  nexussink
  parser



={============================================================================
*kt_dev_uv_stack_404* zinc-mr: linearsourced

1. IP Channel MediaRouter Device Manufacturer Integration
https://wiki.youview.co.uk/display/IPCHAN/IP+Channel+MediaRouter+Device+Manufacturer+Integration?src=search

o LinearSource component (linearsourced) via a DBus interface 

o streaming sockets interface (zmp).


{roles}
1. YouView Responsibilities

o Providing MPEG-TS stream to Device Manufacturer through zmp


2. Device Manufacturer Responsibilities

o Reading live MPEG-TS stream from zmp


{run-linearsourced}

1.

:~/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000
   /opt/zinc-trunk/oss/share/dbus-1/services-yv$ cat Zinc.LinearSource.service 
[D-BUS Service]
Name=Zinc.LinearSource
Exec=/opt/zinc-trunk/bin/linearsource-launch-and-sandbox
User=linearsourced


2. /opt/zinc-trunk/bin/linearsource-launch-and-sandbox

exec /opt/zinc-trunk/bin/sandbox-drop-privileges /opt/zinc-trunk/bin/linearsource-launch


3. 

/opt/zinc/bin/linearsource-launch

get_vqe_buffer_size() 
{ 
   vqe_buffer_size="$(lsr-config --int platform.linearsource.vqebuffersize)"

   if [ -z "$vqe_buffer_size" ]; then
   # Assume sensible default           
      vqe_buffer_size=48384 
   fi

}

# Allow overriding which program to launch for tests
cmd=${LINEARSOURCE_LAUNCH_CMD:-/opt/zinc-trunk/bin/linearsourced}

mkdir -p /opt/zinc-trunk/var/linearsourced/http_cache
exec /opt/zinc-trunk/bin/exec-with-cache \
  $polipo_cfg_arg \
  -d /opt/zinc-trunk/var/linearsourced/http_cache \
  "$cmd" --user-agent="$(generate-http-user-agent)" --vqe-buffer-size=$vqe_buffer_size


leads to:

+ exec /opt/zinc-trunk/bin/exec-with-cache -c /tmp/lsd-polipo.cfg.bYZxqv 
-d /opt/zinc-trunk/var/linearsourced/http_cache 

/opt/zinc-trunk/bin/linearsourced 

'--user-agent=YouView (Humax; DTRT1
000; 80B07001; CDS/21.30.30; API/2.9.4; PS/2.9.32) (+DVR+FLASH+HTML+MHEG+IPCMC)' --vqe-buffer-size=65536


{gst-pipeline}
This is original pipeline.

uridecodebin caps=video/mpegts name=src ! queue ! zmpsink name=sink tsshifterbin name=buffer


<run-ip-channel-without-oem>
To playback ip channel using tsnexusbin instead of using zmp sink and oem mr:

gst-inspect-1.0 uridecodebin ui=http://54.225.86.153/INT01_LCN_66.sdp caps=video/mpegts name=src ! queue ! tsnexusbin

note: this DO NOT WORK!

// from-lance
#! /bin/sh

dbus-send --print-reply --session --dest=Zinc.Tuner /Zinc/Tuner/TunerControl Zinc.Tuner.TunerControl.deactivate int32:0

export GST_PLUGIN_PATH=/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/oss/lib/gstreamer-1.0
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/zinc-trunk/oss/lib/gstreamer-1.0

LD_PRELOAD=/usr/local/lib/libdirectfb.so:/usr/local/lib/libdirect.so:/usr/local/lib/libinit.so \
           gst-launch-1.0 souphttpsrc location=http://54.225.86.153/INT01_LCN_66.sdp ! vqesdpdemux caps=video/mpegts ! queue ! tsshifterbin ! tsnexusbin


<remove-timeshifter>
[root@HUMAX nickel-linear-source]# pwd
/opt/zinc-trunk/share/platform_data/nickel-linear-source

[root@HUMAX nickel-linear-source]# ll
drwxrwxr-x    2 1024     1025        4.0K Apr 30 12:44 ./
drwxrwxr-x   10 1024     1025        4.0K Apr 30 12:58 ../
-rw-r--r--    1 1024     1025          80 Apr 30 12:44 gst-pipeline-non-pausing
-rw-r--r--    1 1024     1025          94 May  5 15:52 gst-pipeline-pausing

from:

[root@HUMAX nickel-linear-source]# less gst-pipeline-pausing 
uridecodebin caps=video/mpegts name=src ! queue ! tsshifterbin name=buffer ! zmpsink name=sink 

to:

[root@HUMAX nickel-linear-source]# less gst-pipeline-pausing 
uridecodebin caps=video/mpegts name=src ! queue ! zmpsink name=sink tsshifterbin name=buffer 

uridecodebin caps=video/mpegts name=src ! queue ! zmpsink name=sink tsshifterbin name=buffer 


{related-jiras}
TASK: ADD: add key to control LSD/VQE buffer size
https://jira.youview.co.uk/browse/SPECWIP-3794

   IPC Linearsourced performance - taking up much CPU - affects IP Live & Recordings.
   https://jira.youview.co.uk/browse/DEVARCH-6269


{gst-code}
Nickel/Nickel.LinearSource/src

LinearSourceControlImpl.cpp

GstElement* create_pipeline(const std::string& description)
{
    GError *error = NULL;
    GstElement *const p = gst_parse_launch(description.c_str(), &error);
    const SCOPED_OBJ(error, g_error_free);
}


={============================================================================
*kt_dev_uv_stack_405* zinc-mr-linear: zmp 

{zmpsink}
libgstzmp.so.0.0.0

[root@HUMAX gstreamer-1.0]# pwd
/opt/zinc-trunk/oss/lib/gstreamer-1.0

lrwxrwxrwx    1 1024     1025            18 May  1 12:00 libgstzmp.so -> libgstzmp.so.0.0.0*
lrwxrwxrwx    1 1024     1025            18 May  1 12:00 libgstzmp.so.0 -> libgstzmp.so.0.0.0*
-rwxr-xr-x    1 1024     1025         27968 Apr 30 12:44 libgstzmp.so.0.0.0*

alias hcpp='scp 
   ~/builds/DEVARCH-8828/humax.1000/zinc-build-root/release-humax-dtr_t1000/Nickel/Nickel.LinearSource/.libs/libgstzmp.so.0.0.0 
   root@172.20.35.27:/opt/zinc-trunk/oss/lib/gstreamer-1.0'


gst_zmp_pad_chain(GstPad *pad, GstObject *parent, GstBuffer *buffer)
{
   bytes_written = send_with_fd(zmp->serialized_event_fd.fd, msg, iovlen, fds[0]);
}


{zmp}

[root@HUMAX lib]# pwd
/opt/zinc-trunk/lib

lrwxrwxrwx    1 1024     1025          19 May  1 11:59 libzmp-1.0.so -> libzmp-1.0.so.0.0.0*
lrwxrwxrwx    1 1024     1025          19 May  1 11:59 libzmp-1.0.so.0 -> libzmp-1.0.so.0.0.0*
-rwxr-xr-x    1 1024     1025       17.3K Apr 30 12:44 libzmp-1.0.so.0.0.0*

alias hczm='scp 
   ~/builds/DEVARCH-8828/humax.1000/zinc-build-root/release-humax-dtr_t1000/Nickel/Nickel.LinearSource/.libs/libzmp-1.0.so.0.0.0 
   root@172.20.35.27:/opt/zinc-trunk/lib'

note: bronzemediad uses libzmp and found that it's in /opt/zinc/lib even when use zinc-trunk


# client.cpp
https://wiki.youview.co.uk/display/IPCHAN/example+client.cpp?src=search

# zmp.h
https://wiki.youview.co.uk/display/IPCHAN/zmp.h?src=contextnavchildmode

zmp (Zinc Media Protocol) - a sockets and pipes protocol for streaming data
based upon Gstreamer pipeline concepts.

Modelled on the Gstreamer concept of a media pipeline where data flows
downstream and control and information events can be sent upstream or
downstream or downstream serialized with the data.

Implemented in terms of UNIX sockets, pipes and file descriptor passing

Used for providing the data stream, information about it and some control such
as seeking.

libzmp is provided to make it easy to integrate with Device Manufacturer code.
It is written in C to make it easier to preserve binary compatibility. It is
designed so it will work without requiring any additional threads in Device
Manufacturer implementations.


gst_bin_get_by_name  125 Nickel/Nickel.LinearSource/src/LinearSourceControlImpl.cpp     if (GstElement *const e = gst_bin_get_by_name(GST_BIN(pipeline), name))
gst_bin_get_by_name  538 Nickel/Nickel.LinearSource/src/LinearSourceControlImpl.cpp             if (GstElement *const elem = gst_bin_get_by_name(GST_BIN(pipelineElem), "vqesrc"))


LinearSourceControlImpl.cpp |307|     GstElement *const timeshifter = get_element_by_name(pipelineElem, "timeshifter");                                  
LinearSourceControlImpl.cpp |234|     GstElement *const bufferElem = get_element_by_name(pipelineElem, "buffer");                                            
LinearSourceControlImpl.cpp |231|     GstElement *const srcElem = get_element_by_name(pipelineElem, "src");                                                  
LinearSourceControlImpl.cpp |228|     GstElement *const sinkElem = get_element_by_name(pipelineElem, "sink");                                                


{interfaces}

/humax.1000/zinc-build-root/release-humax-dtr_t1000/Zinc/Zinc.3rdPartyStack/src/humax-dtr_t1000
/gstreamer/plugins/elements/gstfdsink.c

fdsink:

gst_fd_sink_render (GstBaseSink * sink, GstBuffer * buffer)
{

  gst_buffer_map (buffer, &info, GST_MAP_READ);

  left = info.size;

  // note: info.size
  
  GST_DEBUG_OBJECT (fdsink, "writing %" G_GSIZE_FORMAT " bytes to"
      " file descriptor %d", info.size, fdsink->fd);

  written = write (fdsink->fd, ptr, left);

  /* short write, select and try to write the remainder */
  if (G_UNLIKELY (left > 0))
    goto again;
}


      zmp:                                               client:

                                                      <- pass down two fds to zmp 

      /** * 
       * Create a ZMPStream object. 
       * The two file descriptors should be UNIX domain sockets created with SOCK_SEQPACKET. The
       * other ends of the file descriptors should be connected to the write end. */

      ZMPStream* zmp_stream_new(int serialized_events_fd, int immediate_events_fd)
      int zmp_stream_init(ZMPStream *s, int serialized_events_fd, int immediate_events_fd)

         s->multiplex_fd = epoll_create1(EPOLL_CLOEXEC);
         s->fd[FD_IMMEDIATE_EVENTS].fd = immediate_events_fd;
         s->fd[FD_SERIALIZED_EVENTS].fd = serialized_events_fd;

   <- int zmp_stream_get_listen_fd(ZMPStream* stream) <- zmp client calls to get fd to listen
         return stream->multiplex_fd;
                                                         poll(fd);

                                                      <- zmp_stream_notify
      int zmp_stream_notify(ZMPStream *stream)
         poll( stream->multiplex_fd );

         switch (events[i].data.u32) {
            case FD_IMMEDIATE_EVENTS:
i              zmp_handle_immediate_event(stream);

            case FD_READ_READY:
               while (stream->state == STATE_OK && zmp_handle_serial(stream)) 

      // get pipe fd from socket
      int zmp_handle_serial(ZMPStream* stream)

          // pass up pipe fd to client
          while ((bytes_read = stream->on_data(stream->user_data, stream,
                          stream->fd[FD_DATA].fd)) > 0) {


{on-read}
 * on_data: 
 *      Called when data should be transferred. Data should be read from input_fd. This callback is
 *      intended to behave like the standard UNIX function read() when called on a non-blocking
 *      file-descriptor.
 *

When data is available libzmp will call this callback repeatedly until it either returns 0 (to
        indicate EOF on input_fd) or -1 (to indicate an an error). 

This function should behave like read in that: 

o If any data was successfully consumed it should return the number of bytes that had been consumed. 

o If reading data from the pipe would cause the function to block, it should return -1 and set errno
to EAGAIN.

o If consuming the data would otherwise require on_data to block, it should return -1 and set errno
to EAGAIN. This might happen if the decoder buffer that on_data is feeding were full.
zmp_stream_notify_read_ready should be called once you are again ready to consume data.
zmp_stream_notify_read_ready can be called from any thread.      
            
o If no data could be consumed because of an error, it should return -1 and errno set appropriately.
This will put libzmp into an error state and no further data will be available.


/*
 * onData
 * ======
 *
 * Called when data is available for consumption.
 */
ssize_t onData( ZMPStream *, int infd)
{
    /* In a real client you will want to fill your decoder buffers here by
     * reading from infd.  If your decoder buffer fills return -1 and set
     * errno to EAGAIN.  You will then later be required to call
     * zmp_notify_read_ready when your decoder buffer once again has space
     */
    char buf[4096];
    int err;
    ssize_t bytes_read = read(infd, buf, sizeof(buf));
    err = errno;
    if ( bytes_read > 0 ) {
        out->write(buf, bytes_read);
    }
    total_bytes_consumed += bytes_read;
    errno = err;
    return bytes_read;
}


1491: KT-ZMP: Received data: ** 0B ** 
1491: KT-ZMP: reading blocked on data fd 0

1492: KT-ZMP: reading blocked on data fd 0

1493: KT-ZMP: reading blocked on data fd 0

1494: KT-ZMP: Received data: ** 0B ** 
1494: KT-ZMP: reading blocked on data fd 0

1495: KT-ZMP: reading blocked on data fd 0
1496: KT-ZMP: reading blocked on data fd 0
1497: KT-ZMP: Received data: ** 0B ** 
1497: KT-ZMP: reading blocked on data fd 0
1498: KT-ZMP: reading blocked on data fd 0
1499: KT-ZMP: reading blocked on data fd 0


={============================================================================
*kt_dev_uv_stack_407* zinc-mr: media router spec

https://jira.youview.co.uk/browse/SPECWIP-3703


={============================================================================
*kt_dev_uv_stack_408* zinc-mr: plugin creations on mime types

<before>
    w3c:
      QtWeb : direct gst play
            : plugin to SCF
              -to bronze via dbus client and others

    <------------------------------------------- dbus -------->

<after>
    w3c:
      QtWeb : plugin gst play
            : plugin to MediaPlayerPrivateMediaRouter 
                        -> VanadiumMediaPlayer -> the proxy see:Vanadium

    <------------------------------------------- dbus -------->

                        -> nickelmediad(server)
                           - SCF (media router proxy) that was a fake before
                             - to bronze for forwaring (.so)
                             - to gst for hls, dash type (.so)
                                  gst.so, virtualbin.so


{app} same as before. gets SCF and then MR factory via SCF.

Nickel.AIR.Client.API/data/client-factory.plugin-config
  libNickelClientSystem.so createSystemClientFactory


{get-system-media-router-factory}

MediaRouterFactory* createMediaRouterFactory();
  SF(dbus)->createMediaRouterFactory();

SystemMediaRouterFactory::createMediaRouter();
  SF(dbus)->createMediaRouter();


<system-client-factory>
SCF is the same as before and comes from:

Nickel.Client.System/libNickelClientSystem.so.0.0.0

*create-system-client-factory*

Plugin* createSystemClientFactory() {
    return new NS_NICKEL_CLIENT::SystemClientFactory();
}

// Nickel/Nickel.Client.API/include/ClientFactory.h

struct ZINC_EXPORT ClientFactory : virtual public NS_ZINC::Plugin {

  boost::shared_ptr<NS_ZINC::EventDispatcher> defaultDispatcher;
  boost::shared_ptr<NS_ZINC::FutureDispatcher> futureDispatcher;

  virtual boost::shared_ptr<NS_ZINC::EventDispatcher> 
    getDefaultDispatcher() const = 0;

  virtual void setDefaultDispatcher(
    boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher) = 0;

  virtual boost::shared_ptr<Locator> createLocator() = 0;

  virtual boost::shared_ptr<MediaRouterFactory> createMediaRouterFactory() = 0;
  ...
};


// Nickel/Nickel.Client.System/src/SystemClientFactory.cpp

class SystemClientFactory : virtual public ClientFactory {

  note: new dispatcher

  SystemClientFactory::SystemClientFactory() 
    : defaultDispatcher(new MultipleListenerEventDispatcher()) {
    }

  boost::shared_ptr<Locator> createLocator() {
    static boost::shared_ptr<Locator> locator;
    if(!locator)
    {
      locator.reset(
          new SystemClientLocator(
            createMediaRouterFactory(),
            createMediaSettings(),
            createOutputManager(),
            createServiceListBuilder(),
            createAudioFeedback()
            )
          );
    }
    return locator;
  }

  boost::shared_ptr<NS_NICKEL_CLIENT::MediaRouterFactory> mediaRouterFactory;

  // note: create SMRF via client system factory interface which uses DBUS
  // system factory to create MRF and this comes from bronze daemon on dbus.
  // That is SCF and SMRF are wrappers which wraps bronze SF and MRF for client.

  boost::shared_ptr<NS_NICKEL_CLIENT::MediaRouterFactory> 
    createMediaRouterFactory() 
  {
    boost::mutex::scoped_lock lock(mutex);

    if(mediaRouterFactory == NULL) {

      *get-system-factory*

      boost::shared_ptr<NS_NICKEL_SYSTEM::MediaRouterFactorySync> 
        sysMRFactory
          (convertToSync( getSystemFactory().createMediaRouterFactory()));

      // pass bronze MRF, defaultDispatcher(inlineDP) and get SMRF

      boost::shared_ptr<NS_NICKEL_CLIENT::SystemMediaRouterFactory> 
        cliMRFactory(
          new NS_NICKEL_CLIENT::SystemMediaRouterFactory
            (sysMRFactory, defaultDispatcher, *this));

      mediaRouterFactory = cliMRFactory;
    }

    return(mediaRouterFactory);
  }
};


<get-system-factory> <dbus-client>

SF is used to get MRF from bronze via DBUS

nickel-system-factory.plugin-config:
  libNickelSystemDbusClient.so createDbusSystemFactory
 

Zinc::Media::SystemFactory& SystemClientFactory::getSystemFactory() {

  static const NS_ZINC::FilePluginConfig 
    SYSTEM_FACTORY_PLUGIN_CONFIG(PackageDataFinder().find(
          "nickel-system-factory.plugin-config"
          ));

  return PluginFactory::getInstance<Zinc::Media::SystemFactory>
    (SYSTEM_FACTORY_PLUGIN_CONFIG);
}

// Nickel/Nickel.System.DBusClient/src/DbusSystemFactory.cpp
// Nickel/Nickel.System.DBusClient/src/DbusSystemFactory.h

    : theBusName("Zinc.Media") note: this is bronze

Plugin *createDbusSystemFactory(const char* busName) {
    return new DbusSystemFactory(busName);
}


<system-factory-interface>

namespace Zinc { namespace Media {

  struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Media::LocalMediaLibrary> 
      createLocalMediaLibrary() = 0;

    virtual boost::shared_ptr<Zinc::Media::MediaRouterFactory> 
      createMediaRouterFactory() = 0;

    virtual boost::shared_ptr<Zinc::Media::MediaSettings> 
      createMediaSettings() = 0;

    virtual boost::shared_ptr<Zinc::Media::OutputManager> 
      createOutputManager() = 0;

    virtual boost::shared_ptr<Zinc::Media::ServiceListBuilder> 
      createServiceListBuilder() = 0;

    virtual boost::shared_ptr<Zinc::Media::MediaRouter> 
      createDefaultMediaRouter() = 0;

  };
} //namespace
} //namespace


class ZINC_EXPORT DbusSystemFactory : 
    public NS_ZINC_DBUS_BINDING::AbstractDbusSystemFactory<SystemFactory> 
{
  shared_ptr<MediaRouterFactory> DbusSystemFactory::createMediaRouterFactory() 
  {
    recursive_mutex::scoped_lock lock(mutex);
    boost::shared_ptr<MediaRouterFactory> strong(theMediaRouterFactory.lock());
    if (!strong) {
      DBus::Connection conn = getDBusSessionConnection();
      if (!mediaRouterCollection) {
        mediaRouterCollection = 
          boost::make_shared
          <NS_ZINC_DBUS_BINDING::ProxyFactory<MediaRouterDBusToSyncAndAsync>>
          (NS_ZINC_DBUS_BINDING::ObjectWithEventsProxyFactory
            <MediaRouterDBusToSyncAndAsync>
              (getEventDispatcher(), getFutureDispatcher()));
      }

      // const char* const MEDIA_ROUTER_FACTORY 
      //    = "/Zinc/Media/MediaRouterFactory";

      strong = MediaRouterFactoryDBusToSyncAndAsync::create(conn,
          theBusName,
          NS_NICKEL_SYSTEM::ObjectPath::MEDIA_ROUTER_FACTORY,
          getFutureDispatcher(),
          mediaRouterCollection);
      theMediaRouterFactory = strong;
    }
    return strong;
  }
}


<system-media-router-factory>

// Nickel/Nickel.Client.API/include/MediaRouterFactory.h

struct ZINC_EXPORT MediaRouterFactory : virtual public NS_ZINC::Polymorphic 
{
  /**
   * Creates an unconfigured MediaRouter instance.
   *
   * @return an unconfigured MediaRouter instance.
   *
   * @throws nickel::client::InsufficientResources There is not sufficient
   * memory to allocate a new MediaRouter instance.
   *
   * @acl cp
   */
  virtual boost::shared_ptr<MediaRouter> createMediaRouter() = 0; 
};

// Nickel/Nickel.Client.System/src/SystemMediaRouterFactory.h

class SystemMediaRouterFactory : 
  public virtual NS_NICKEL_CLIENT::MediaRouterFactory,
  public boost::enable_shared_from_this<SystemMediaRouterFactory>
{
   virtual boost::shared_ptr<MediaRouter> createMediaRouter();
    
   note: ctor
   SystemMediaRouterFactory::SystemMediaRouterFactory():
        sysFactory(sysFactory_), clientFactory(&clientFactory_), 
        dispatcher(dispatcher) {}
};

boost::shared_ptr<NS_NICKEL_CLIENT::MediaRouter> 
    SystemMediaRouterFactory::createMediaRouter(void) 
{
  try 
  {
    // note: after all, calls OEM one.
    boost::shared_ptr<NS_NICKEL_CLIENT::MediaRouter> p =
      wrapSystemRouter(sysFactory->createMediaRouter(), dispatcher);
    return p;

  } catch (const NS_NICKEL_SYSTEM::InsufficientResources&) 
  {
    throw InsufficientResources();
  }
}

// Nickel/Nickel.Client.System/src/SystemMediaRouter.cpp
// note: here "SystemMediaRouter" created

boost::shared_ptr<MediaRouter> wrapSystemRouter(
    boost::shared_ptr<NS_NICKEL_SYSTEM::MediaRouter> sysRouter,
    boost::shared_ptr<EventDispatcher> dispatcher)
{
  boost::shared_ptr<SystemMediaRouter> cliSysRouter =
    boost::make_shared<SystemMediaRouter>(sysRouter);

  cliSysRouter->setDispatcher(dispatcher);
  sysRouter->addListener(cliSysRouter);
  NICKEL_DEBUG("cli "<<cliSysRouter<<" sys "<<sysRouter);
  return cliSysRouter;
}


{how-events-get-delivered-on-dbus}

Nickel.System.API/include/MediaRouterEventListener.h

/**
 * Inherit from MediaRouterEventListener and register with
 * MediaRouter::addListener() to receive signals sent by
 * MediaRouter.
 */
struct ZINC_EXPORT MediaRouterEventListener : public NS_ZINC::EventListener
{
  virtual ~MediaRouterEventListener();
  virtual void BufferStatusEvent(const BufferStatusEventValue::Enum event) = 0;
  virtual void DrmEvent(const DrmEventValue::Enum event, 
      const std::string& drmMediaIdentifier, 
      const std::string& rightsIssuerUrl) = 0;
  virtual void PositionChangeEvent(const Position& position) = 0;
  virtual void SourceEvent(const SourceEventValue::Enum event, 
      const SetSourceReason::Enum reason) = 0;
  virtual void SpeedChangeEvent() = 0;
  virtual void StatusEvent(const StatusEventValue::Enum event) = 0;
  virtual void ErrorEvent(const ErrorEventValue::Enum error, 
      const ErrorEventContext::Enum context, const std::string& info) = 0;

};

Nickel.System.API/include/MediaRouterAsync.h

class MediaRouterEventListener;

class ZINC_EXPORT MediaRouterAsync : 
  public virtual NS_ZINC::DispatchingEventProducer<MediaRouterEventListener>
{
}


{yv-mr} nickelmediad which is a dbus-server

1. these are files generated

// Nickel.System.DBusServer/
   libNickelSystemDbus.so.0.0.0
   nickelmediad

2. starts as a deamon

// Nickel/Nickel.System.Proxy/data/Zinc.MediaProxy.service 
[D-BUS Service]
Name=Zinc.MediaProxy
Exec=/opt/zinc-trunk/bin/nickelmediad -b Zinc.MediaProxy
User=nickelmediad

// from source
("busname,b", po::value<std::string>(&busName)->default_value(defaultBusName), 
  "DBus connection name")


3. load a SCF(media router proxy) via "media-daemon.plugin-config"


<media-daemon-plugin>
Nickel.System.DBusServer/data/media-daemon.plugin-config:
  libNickelSystemProxy.so createSystemFactory

// this is 'before':
// media-daemon.plugin-config:
// libNickelSystemFake.so createFakeSystemFactory


4. MediaDaemon.cpp

void MediaDaemon::start(int argc, char *argv[])
{
  // note: the default is media-daemon.plugin-config
  NS_ZINC::FilePluginConfig filePluginConfig(configFilePath);

  // combine file plugin with command-line-arguments
  NS_ZINC::FixedPluginConfig pluginConfig( filePluginConfig.getLibraryName(),
      filePluginConfig.getCreateFunctionName(),
      filePluginConfig.getCreateParameters() + std::string(" ") + args );

  SystemFactory& factory = NS_ZINC::PluginFactory::getInstance<SystemFactory>(pluginConfig);

  if (mediaRoutersEnabled)
  {
    dbus.expose(ObjectPath::MEDIA_ROUTER_FACTORY, factoryMediaRouter.createMediaRouterFactory(),
        boost::make_shared<NonInheritingAdaptorFactory<MediaRouter> >
        (
         NS_ZINC_DBUS_BINDING::RefCountedAdaptorFactory<MediaRouter>(*bnm), conn, 
         "/Zinc/Media/MediaRouters/")
        );
    dbus.expose(ObjectPath::DEFAULT_MEDIA_ROUTER, 
        factoryMediaRouterDefault.createDefaultMediaRouter());
  }
}


<system-factory> media-router-proxy

note: 
SF is not necessarily DBUS SF and can be others as this case shows

Nickel.System.Proxy/libNickelSystemProxy.so.0.0.0
  libNickelSystemProxy.so createSystemFactory

// Nickel/Nickel.System.Proxy/src/ProxySystemFactory.cpp
//
// class ZINC_LOCAL ProxySystemFactory : public SystemFactory
    
extern "C" {
  NS_NICKEL_SYSTEM::SystemFactory* createSystemFactory() {
    return new NS_NICKEL_SYSTEM::ProxySystemFactory();
  }
}


typedef std::pair<std::string, std::vector<MIMEMediaRouterFactory> > 
  MIMEMediaRouterFactoryMap;

typedef std::vector<MIMEMediaRouterFactoryMap> 
  ProtocolMediaRouterFactoryMap;

note:
ProxySystemFactory::ProxySystemFactory() {
    loadImplementations();
}

// Nickel/Nickel.System.Proxy/data/Makefile.am
// 1:platformdatadir=$(datadir)/platform_data/mediarouter-plugin-config


note:
Builds a map<protocal, factory-function> which has HLS and DASH and all uses GST
MR.

// ll share/platform_data/mediarouter-plugin-config/
//
// 51 Oct 21 19:03 http-application%2Fdash%2Bxml.plugin-config
// 51 Oct 21 19:03 http-application%2Fvnd.apple.mpegurl.plugin-config
// 51 Oct 21 19:03 https-application%2Fdash%2Bxml.plugin-config
// 51 Oct 21 19:03 https-application%2Fvnd.apple.mpegurl.plugin-config

typedef std::pair<std::string, boost::shared_ptr<MediaRouterFactory> > MIMEMediaRouterFactory;
typedef std::pair<std::string, std::vector<MIMEMediaRouterFactory> > MIMEMediaRouterFactoryMap;
typedef std::vector<MIMEMediaRouterFactoryMap> ProtocolMediaRouterFactoryMap;

void ProxySystemFactory::loadImplementations()
{
  // note: bronze
  // default-system-factory.plugin-config
  //  libNickelSystemDbusClient.so createDbusSystemFactory

  FilePluginConfig defaultPluginConfig(
      PackageDataFinder().find("default-system-factory.plugin-config"));

  defaultImplementation = boost::addressof(
      PluginFactory::getInstance<SystemFactory>(defaultPluginConfig));

  // /opt/zinc-trunk/share/platform_data/mediarouter-plugin-config
  //
  // http-application%2Fdash%2Bxml.plugin-config:
  //  libNickelSystemGstreamer.so createGstSystemFactory
  // https-application%2Fdash%2Bxml.plugin-config:
  //  libNickelSystemGstreamer.so createGstSystemFactory
  //
  // protocol "http"
  // mimeType "application%2Fdash%2Bxml"
  // after decodedMimeType
  // mimeType "application/dash+xml"
  //
  // for_each add {protocol, {mime, factory-function}} in vector
  //   {"http", { "application/dash+xml", factory-function}} in vector
  //   {"https", { "application/dash+xml", factory-function}} in vector

  SystemFactory& factory(
      PluginFactory::getInstance<SystemFactory>(pluginConfig));

  protMapIter->second.push_back(
      std::make_pair(mimeType, factory.createMediaRouterFactory()));

  // save factories
  defaultMediaRouterFactory = defaultImplementation->createMediaRouterFactory();

  // save to ProxySystemFactory::proxyMediaRouterFactory
  proxyMediaRouterFactory = boost::make_shared<ProxyMediaRouterFactory>(getDispatcher(),
      defaultMediaRouterFactory, protocolMediaRouterFactoryMap);
}


<proxy-media-router-factory>
ProxySystemFactory -> ProxyMediaRouterFactory -> ProxyMediaRouter -> GST MR

ProxyMediaRouterFactory::ProxyMediaRouterFactory(
        boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher_,
        boost::shared_ptr<MediaRouterFactory> defaultMediaRouterFactory_,
        ProtocolMediaRouterFactoryMap protocolMediaRouterFactoryMap_) :

    dispatcher(dispatcher_),
    defaultMediaRouterFactory(defaultMediaRouterFactory_),

    // copy a map
    protocolMediaRouterFactoryMap(protocolMediaRouterFactoryMap_),

    mimeTypes(boost::make_shared<mime::MIMETypes>())
{
}

// return PMRF
boost::shared_ptr<MediaRouterFactory> 
ProxySystemFactory::createMediaRouterFactory() {
    return proxyMediaRouterFactory;
}


// forwarding to bronze
boost::shared_ptr<LocalMediaLibrary> 
ProxySystemFactory::createLocalMediaLibrary() {
    return defaultImplementation->createLocalMediaLibrary();
}


// Nickel/Nickel.System.Proxy/src/ProxyMediaRouterFactory.cpp

NS_ZINC::Future<boost::shared_ptr<MediaRouter> > 
  ProxyMediaRouterFactory::createMediaRouter() 
{
  // note: here pass a map to "createMediaRouter()"
  return NS_ZINC::completedFuture(
      *dispatcher, boost::shared_ptr<MediaRouter>(new ProxyMediaRouter(
          dispatcher, defaultMediaRouterFactory, protocolMediaRouterFactoryMap,
          mimeTypes)));
}


// Nickel/Nickel.System.Proxy/src/ProxyMediaRouter.cpp

note: implements "MediaRouter" interface

class ZINC_LOCAL ProxyMediaRouter : public MediaRouter,
    public boost::enable_shared_from_this<ProxyMediaRouter>,
    public MediaRouterEventListener {
    };

ProxyMediaRouter::ProxyMediaRouter(
        boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher_,
        boost::shared_ptr<MediaRouterFactory> defaultMediaRouterFactory_,
        ProtocolMediaRouterFactoryMap protocolMediaRouterFactoryMap_,
        boost::shared_ptr<mime::MIMETypes> mimeTypes_) :

    dispatcher(dispatcher_),
    defaultMediaRouterFactory(defaultMediaRouterFactory_),

    // copy a map
    protocolMediaRouterFactoryMap(protocolMediaRouterFactoryMap_),
    sourcing(false),
    mimeTypes(mimeTypes_)
{
}


$ dbus-send --session --print-reply --type=method_call --dest='Zinc.MediaProxy' $MR \
> Zinc.Media.MediaRouter.setSource 
> string:http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd int32:0


note: does it mean that create real media router when start() is called?

class ZINC_LOCAL SetSourceContinuation : 
  public NS_ZINC::Continuation<void, SetSourceContinuation> 
{
  void start(boost::shared_ptr<ProxyMediaRouter> proxy_, 
      const std::string& source_, 
      const SetSourceReason::Enum reason_) 
  {
    // note: find 'factory' function pointer depending on "source"
    boost::shared_ptr<MediaRouterFactory> 
      ProxyMediaRouter::findFactoryGivenSource(source);

    continueOnSuccess(
        factory->createMediaRouter(), &SetSourceContinuation::onMediaRouterCreated);
  }
};


// source http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd
//
boost::shared_ptr<MediaRouterFactory> ProxyMediaRouter::findFactoryGivenSource
   (const std::string& source) const 
{
    std::string mediaExtension = "default";

    if(source.empty())
    {
        throw InvalidLocatorException("Empty media locator");
    }

    boost::shared_ptr<SoupURI> sourceURI(soup_uri_new(source.c_str()), &SoupURIQuietFree);

    if(!sourceURI.get() || !soup_uri_get_scheme(sourceURI.get()))
    {
        throw InvalidLocatorException("Invalid media locator");
    }

    sourceURI = decodeCompoundURI(sourceURI);

    // protocol "http"
    const std::string protocol(soup_uri_get_scheme(sourceURI.get()));

    std::string mimeType(ProxySystemFactory::DEFAULT_MIME_TYPE);

    ProtocolMediaRouterFactoryMap::const_iterator protIter = findInVectorOfPairs(
            protocolMediaRouterFactoryMap, MIMEMediaRouterFactoryMap(protocol,
                std::vector<MIMEMediaRouterFactory>()));

    // We found an entry for this protocol, search by MIME type
    if(protIter != protocolMediaRouterFactoryMap.end())
    {
        // If the URL has a query portion, take the file extension from that.
        // Otherwise a URL of the form http://host/cms.jsp?media=film.ts would
        // be parsed as having a .jsp extension rather than a .ts extension. Of
        // course this approach only really works if there is just a single
        // query parameter.
        const char* mediaName = soup_uri_get_query(sourceURI.get());

        // mediaName "/e/pseudolive/bbb/client_manifest.mpd"

        if(!mediaName)
        {
            mediaName = soup_uri_get_path(sourceURI.get());
        }

        const std::string extension = getMediaExtension(mediaName ? mediaName : "");

        // extension "mpd"

        if(!extension.empty())
        {
            const std::string retrievedMIMEType = mimeTypes->getMIMEType(extension);
            if(!retrievedMIMEType.empty())
            {
                // see <mime-type> since get mime from extension using this file 
                // retrievedMIMEType "application/dash+xml"}}

                mimeType = retrievedMIMEType;
            }
        }

        std::vector<MIMEMediaRouterFactory>::const_iterator mimeIter = findInVectorOfPairs(
                protIter->second, MIMEMediaRouterFactory(mimeType,
                    boost::shared_ptr<MediaRouterFactory>()));

        if(mimeIter != protIter->second.end())
        {
            // Found an exact match (protcol & MIME type)
            return mimeIter->second;
        }
        else if(mimeType != ProxySystemFactory::DEFAULT_MIME_TYPE)
        {
            // Try searching for a protocol default
            mimeIter = findInVectorOfPairs(
                    protIter->second, MIMEMediaRouterFactory(
                        ProxySystemFactory::DEFAULT_MIME_TYPE,
                        boost::shared_ptr<MediaRouterFactory>()));

            if(mimeIter != protIter->second.end())
            {
                return mimeIter->second;
            }
        }
    }

    // Return the default media router factory
    return defaultMediaRouterFactory;
}


<mime-type>
:~/src-dev/DEVARCH$ cat ./Zinc/Zinc.HTTP/share/mime/mime.types
/opt/zinc-trunk/share/platform_data/zinc-http/mime.types

################################################################################
#
#  MIME-TYPES and the extensions that represent them
#
#  The format of this file is a MIME type on the left and zero or more
#  filename extensions on the right.
#
#  This mapping is used by the ProxyMediaRouter to determine the MIME type of
#  its source media. It then chooses the appropriate media router
#  implementation based on the MIME type.
#
#  The format of this file is based on /etc/mime.types.
#
#  The class mime::MIMETypes provides a way to query the contents of this file.
#
################################################################################
application/dash+xml               mpd
application/vnd.apple.mpegurl      m3u8


<gst-factory>
libNickelSystemGStreamer.so.0.0.0
libNickelSystemVirtualBin.so.0.0.0

Nickel.System.Proxy/data/http-application%2Fdash%2Bxml.plugin-config
1:libNickelSystemGstreamer.so createGstSystemFactory

// Nickel/Nickel.System.GStreamer/src/GstSystemFactory.cpp

class GstSystemFactory : virtual public SystemFactory
{
    boost::shared_ptr<MediaRouterFactory> createMediaRouterFactory()
    {
        mrf = createGstMediaRouterFactory(dispatcher);
    }

    boost::shared_ptr<MediaRouter> createDefaultMediaRouter();

    boost::shared_ptr<LocalMediaLibrary> createLocalMediaLibrary();

    boost::shared_ptr<MediaSettings> createMediaSettings();

    boost::shared_ptr<OutputManager> createOutputManager();

    boost::shared_ptr<ServiceListBuilder> createServiceListBuilder();
};

NS_ZINC::Plugin* createGstSystemFactory()
{
    try
    {
        return new GstSystemFactory(
                boost::make_shared<NS_ZINC::SingleThreadDispatcher>());
    }
}


note:
from void nickel::system::SetSourceContinuation::start()


// Nickel/Nickel.System.GStreamer/src/GstMediaRouterFactory.cpp

boost::shared_ptr<MediaRouterFactoryAsync> createGstMediaRouterFactory(
    boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher)
{
    return boost::make_shared<GstMediaRouterFactory>(dispatcher);
}


GstMediaRouterFactory::GstMediaRouterFactory(
    boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher) : dispatcher(dispatcher)
{
    NICKEL_FUNC_TRACE;

    gst.glib.context = g_main_context_new();
    gst.glib.loop = g_main_loop_new(gst.glib.context, FALSE);
    gst.thread = g_thread_new("gst_loop_thread", gstThreadFunc, &gst.glib);

    start();
}


NS_ZINC::Future<boost::shared_ptr<MediaRouterAsync> >
GstMediaRouterFactory::createMediaRouter()
{
    NICKEL_FUNC_TRACE;
    return NS_ZINC::completedFuture(*dispatcher,
                                    createGstMediaRouter(dispatcher));
}

// Nickel/Nickel.System.GStreamer/src/GstMediaRouter.cpp

boost::shared_ptr<MediaRouterAsync> createGstMediaRouter(
    boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher)
{
    return boost::make_shared<GstMediaRouter>(dispatcher);
}


={============================================================================
*kt_dev_uv_stack_409* mr-dash: create gst mr

{creation}

./Nickel/Nickel.System.API/include/MediaRouterAsync.h

/*
 *	include/MediaRouterAsync.h
 *
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 *	Template base-async.template
 *	Using
 *	/home/kpark/builds/_virtual_/
 *	humax.2100/DEVARCH/Nickel/Nickel.System.API/data/introspection-xml
 *	/interface-MediaRouter.xml
 */

#ifndef DBUSXXX_nickel_system_api_INCLUDE_MEDIAROUTERASYNC_H
#define DBUSXXX_nickel_system_api_INCLUDE_MEDIAROUTERASYNC_H

#include <zinc-common/DispatchingEventProducer.h>

namespace Zinc {
namespace Media {

class MediaRouterEventListener;

class ZINC_EXPORT MediaRouterAsync : 
    public virtual NS_ZINC::DispatchingEventProducer<MediaRouterEventListener>
{
   virtual NS_ZINC::Future< void > 
       setSource(const std::string& mediaLocator_in,
           const SetSourceReason::Enum reason_in) = 0;
   ...
};



NS_ZINC::Future<boost::shared_ptr<MediaRouterAsync> >
GstMediaRouterFactory::createMediaRouter()
{
  return enabled ?
    NS_ZINC::completedFuture(
        *dispatcher,
        createGstMediaRouter(dispatcher,
          boost::bind(gst_pipeline_new, "pipeline"),
          userAgent)) :
    NS_ZINC::exceptionalFuture<boost::shared_ptr<MediaRouterAsync> >(
        *dispatcher,
        NotSupportedException("YouView MediaRouter is disabled"));
}

// Nickel/Nickel.System.GStreamer/src/GstMediaRouter.cpp

class GstMediaRouter : public MediaRouterAsync
{
  GstMediaRouter(
      boost::shared_ptr<NS_ZINC::Dispatcher> d,
      boost::function<GstElement*(void)> pipelineFactory) :
      NS_ZINC::DispatchingEventProducer<MediaRouterEventListener>(d),
      pipelineFactory(pipelineFactory),
    ...
  {
    typefindPadFactory_sinkpads = boost::make_shared<VirtualPadFactoryInProcess>();
    srcPadFactory_srcpads = boost::make_shared<VirtualPadFactoryInProcess>();
    srcPadFactory_sinkpads = boost::make_shared<VirtualPadFactoryInProcess>();
    sinkPadFactory_sinkpads = boost::make_shared<VirtualPadFactoryInProcess>();
    init();
  }
};


// this creates 'three' bins, add them into a pipeline, add a bus to a pipeline
// and creates whole pipeline via each constructor.
//
// GstMediaRouter
//
// pipeline
// ----------------------------------------------------------------------
//  TF bin             VSRC bin          VSINK bin
//  (uridecodebin)     (decodebin)       (qtdemux, h264parse, nexussink)
//  sinkPF   srcPF     sinkPF   scrPF     siniPF   srcPF
//  default  tyepePF   _srcpad  _sinkpad  _sinkpad default

void GstMediaRouter::init()
{
  // VirtualBinTypefind(boost::shared_ptr<VirtualPadFactory> sinkPadFactory,
  //    boost::shared_ptr<VirtualPadFactory> srcPadFactory,
  //    VirtualBin::CallbackType);
  //
  // typedef boost::function<
  //    bool(VirtualBinCallbackAction::Enum,
  //    boost::shared_ptr<VirtualBin>,
  //    boost::shared_ptr<VirtualPad>)> CallbackType;

  RefObj<GstPad> mirrorPad(const RefObj<GstPad>& pad,
      const RefObj<GstElement>& bin,
      const char* padName = NULL);

  typefindBin =
    boost::make_shared<VirtualBinTypefind>(
        boost::shared_ptr<VirtualPadFactoryInProcess>(),
        typefindPadFactory_sinkpads,

        // note: pass down the callback
        boost::bind(&GstMediaRouter::plugVirtualPad, this, _1, _2, _3));

  srcBin =
    boost::make_shared<VirtualBinSrc>(
        srcPadFactory_srcpads,
        srcPadFactory_sinkpads,
        boost::bind(&GstMediaRouter::plugVirtualPad, this, _1, _2, _3));

  sinkBin =
    boost::make_shared<VirtualBinSink>(
        sinkPadFactory_sinkpads,
        boost::shared_ptr<VirtualPadFactoryInProcess>(),
        boost::bind(&GstMediaRouter::plugVirtualPad, this, _1, _2, _3));

  RefObj<GstElement> elem = pipelineFactory();

  gst_bin_add_many(GST_BIN(elem.get()),
      typefindBin->getParent().retain(),
      srcBin->getParent().retain(),
      sinkBin->getParent().retain(), NULL);

  const RefObj<GstBus> bus =
    gst_pipeline_get_bus(GST_PIPELINE(elem.get()));

  watchId = gst_bus_add_watch(bus.get(), busCallback, this);
}


<create-typefind>

class VirtualBin
    : boost::noncopyable,
      public boost::enable_shared_from_this<VirtualBin>
{
  typedef boost::function<
    bool(VirtualBinCallbackAction::Enum,
        boost::shared_ptr<VirtualBin>,
        boost::shared_ptr<VirtualPad>)> CallbackType;

  typedef std::map<std::string,
          boost::function<RefObj<GstElement>()> > FactoryContainer;

  protected:
  FactoryContainer elementFactory;

  private:
  CallbackType callback;
  const RefObj<GstElement> container;
};

VirtualBin::VirtualBin(boost::shared_ptr<VirtualPadFactory> sinkPadFactory,
                       boost::shared_ptr<VirtualPadFactory> srcPadFactory,
                       const char* const binName, CallbackType callback) :
    callback(callback),
    sinkPadFactory(sinkPadFactory),
    srcPadFactory(srcPadFactory),
    container(gst_bin_new(binName))   // note
{}

RefObj<GstElement> VirtualBin::getParent() const
{
  return container;
}


// This create 'uridecodebin', add it to the 'bin', set property to support hls
// and dash, and connect signal.

class VirtualBinTypefind : public VirtualBin
{
  VirtualBinTypefind::VirtualBinTypefind(
      boost::shared_ptr<VirtualPadFactory> sinkPadFactory,
      boost::shared_ptr<VirtualPadFactory> srcPadFactory,
      VirtualBin::CallbackType callback)
    : VirtualBin(sinkPadFactory, srcPadFactory, "VirtualBinTypefind", callback)
  {
    uridecodebin = gst_element_factory_make("uridecodebin", "uri-decoder");

    if (!uridecodebin) {
      throw std::runtime_error("Couldn't create element!");
    }

    if (gst_bin_add(GST_BIN(getParent().get()), uridecodebin.get())) {
      uridecodebin.retain();

      GstCaps *const caps = gst_caps_from_string(
          "application/dash+xml; "
          "application/x-hls; "
          "video/quicktime");

      g_object_set(uridecodebin.get(), "caps", caps, NULL);

      // *pad-added* : newPadCb
      if (0 == g_signal_connect(uridecodebin.get(), "pad-added",
            G_CALLBACK(newPadCb),
            static_cast<gpointer>(this))) {
      }
    }
  }
};


note: this "newPadCb" leads to call <callback-chain> from typefinder


<create-binsrc>

typedef std::map<std::string,
  boost::function<RefObj<GstElement>()>> FactoryContainer;

// protected member from VirtualBin
FactoryContainer elementFactory;

elementFactory["application/dash+xml"] =
  boost::bind(&VirtualBinSrc::makeAndSetupDecodebin, this,
    "video/quicktime; audio/x-m4a; text/x-raw");

RefObj<GstElement> VirtualBinSrc::makeAndSetupDecodebin(
        const char* const outputCaps)
{
}

FactoryContainer::iterator it = elementFactory.find(mediaType);

upstream = it->second();

gst_bin_add(GST_BIN(container.get()), upstream.get());


// This create 'decodebin', set property to support hls and dash, and connect
// signal. However, not add it to the bin 'yet'

class VirtualBinSrc : public VirtualBin
{
  RefObj<GstElement> VirtualBinSrc::makeAndSetupDecodebin(
      const char* const outputCaps)
  {
    // 'decodebin'
    const RefObj<GstElement> decodebin =
      gst_element_factory_make("decodebin", NULL);

    g_object_set(decodebin.get(),
        "caps", gst_caps_from_string(outputCaps),
        NULL);

    // *pad-added* : newDecodebinPadCb

    g_signal_connect(decodebin.get(), "pad-added",
        G_CALLBACK(newDecodebinPadCb),
        static_cast<gpointer>(this));

    return sink = decodebin;
  }

  VirtualBinSrc::VirtualBinSrc(
      boost::shared_ptr<VirtualPadFactory> sinkPadFactory,
      boost::shared_ptr<VirtualPadFactory> srcPadFactory,
      VirtualBin::CallbackType callback)
    : VirtualBin(sinkPadFactory, srcPadFactory, "VirtualBinSrc", callback),
    sink()
  {
    // note: function< RefObj<GstElement>(void)>, no use of placeholder, and
    // fixed parameter.

    elementFactory["application/dash+xml"] =
        boost::bind(&VirtualBinSrc::makeAndSetupDecodebin, this,
            "video/x-h264; audio/mpeg; text/x-raw; application/x-cenc");

    elementFactory["application/x-hls"] =
        boost::bind(&VirtualBinSrc::makeAndSetupDecodebin, this,
            "video/mpegts");
  }
};


<create-binsink>

class VirtualBinSink : public VirtualBin
{
  VirtualBinSink::VirtualBinSink(
      boost::shared_ptr<VirtualPadFactory> sinkPadFactory,
      boost::shared_ptr<VirtualPadFactory> srcPadFactory,
      VirtualBin::CallbackType callback)
    : VirtualBin(sinkPadFactory, srcPadFactory, "VirtualBinSink", callback)
  {
    elementFactory["video/quicktime"] =
      boost::bind(makeMp4Element,
        PlugFunc(boost::bind(&VirtualBin::plug, 
          static_cast<VirtualBin*>(this), _1)) );

    elementFactory["audio/x-m4a"] =  boost::bind(makeElementSimple, "fakesink");

    if (const RefObj<GstElementFactory> nexusFactory =
        gst_element_factory_find ("nexussink")) {
      elementFactory["video/x-h264"] =
        boost::bind(makeH264Element,
            "h264parse ! nexussink");
    } else {
      elementFactory["video/x-h264"] =
        boost::bind(makeH264Element,
            "h264parse ! avdec_h264 ! autovideosink");
    }
  }

  RefObj<GstElement> makeMp4Element(PlugFunc plug)
  {
    struct NewPadCallback{
      static void callback(GstElement* elem, GstPad* pad, gpointer data)
      {
        NICKEL_FUNC_TRACE;
        const PlugFunc* plugFunc = static_cast<PlugFunc*>(data);
        const RefObj<GstPad> sink = (*plugFunc)(RefObj<GstPad>(pad, true));

        // note: which element is

        gst_pad_link(pad, sink.get());
        g_signal_handlers_disconnect_by_data(elem, data);
        delete plugFunc;
      }
    };

    const RefObj<GstElement> qtdemux =
      gst_element_factory_make("qtdemux", NULL);

    if (!qtdemux) {
      NICKEL_ERROR("Couldn't create qtdemux!");
    }

    if (0 == g_signal_connect(qtdemux.get(), "pad-added",
          G_CALLBACK(&NewPadCallback::callback),
          static_cast<gpointer>(new PlugFunc(plug)))) {
    }

    return qtdemux;
  }

  RefObj<GstElement> makeH264Element(const std::string& desc)
  {
    GError *error = NULL;
    const RefObj<GstElement> elem =
      gst_parse_bin_from_description(desc.c_str(),
          TRUE, /* create ghost pads */
          &error);

    if (error) {
      const NS_ZINC::ScopedObj<GError> errorScoped(error, g_error_free);
      NICKEL_ERROR("Failed to create element from description '"
          << desc << "': " << GST_STR_NULL(error->message));
    }

    return elem;
  }

  RefObj<GstElement> makeElementSimple(const char* const elementName)
  {
    return gst_element_factory_make(elementName, NULL);
  }
};


={============================================================================
*kt_dev_uv_stack_409* mr-dash: gst mr: use signal

boost::signals2::signal<void(GstState, GstState, GstState)> onStateChange;

void GstMediaRouter::produceStatusEvent(
    const StatusEventValue::Enum what)
{
  produceEvent(
      boost::bind(&MediaRouterEventListener::StatusEvent,
        _1,
        what));
}

void GstMediaRouter::startReportingPositionChange()
{
  ...
}

NS_ZINC::Future<void> GstMediaRouter::start()
{
  onStateChange.connect_extended(
      OneShotFunctionCall(
        boost::bind(&GstMediaRouter::produceStatusEvent,
          this,
          StatusEventValue::started),
        GST_STATE_PLAYING));

  onStateChange.connect_extended(
      OneShotFunctionCall(
        boost::bind(
          &GstMediaRouter::startReportingPositionChange,
          this), GST_STATE_PLAYING));
}

struct OneShotFunctionCall
{
  typedef void result_type;

  OneShotFunctionCall(boost::function<void(void)> func, GstState desiredState)
    : func(func), desiredState(desiredState) {}
  OneShotFunctionCall(boost::function<void(void)> func)
    : func(func), desiredState(GST_STATE_VOID_PENDING) {}

  void operator()(const boost::signals2::connection& connection,
      GstState /* oldstate */,
      GstState newstate,
      GstState /* pending */)
  {
    if (newstate == desiredState) {
      func();
      connection.disconnect();
    }
  }

  void operator()(const boost::signals2::connection& connection)
  {
    func();
    connection.disconnect();
  }

  boost::function<void(void)> func;
  const GstState desiredState;
};

case GST_MESSAGE_STATE_CHANGED:
  onStateChange(oldstate, newstate, pending);


={============================================================================
*kt_dev_uv_stack_409* mr-dash: gst-mr: revised to support bin injection

1. GstMediaRouter creates "bins" directly without using bin factory.
  -> should use "bin factory", createXXXBinFactory instead.

2. VirtualPadFactoryInProcess is not used.

3. Use setPlugCallback(CallbackType callback) to set callback.


={============================================================================
*kt_dev_uv_stack_409* mr-dash: gst-mr: disable dash on master

1. Use different auth string and check on a box:

dbus-send --session --print-reply --dest=Zinc.DeviceAuthority /Zinc/DeviceAuthority/Authoriser Zinc.DeviceAuthority.Authoriser.isFeatureEnabled string:"yv-mediarouter-dash"
method return sender=:1.125 -> dest=:1.134 reply_serial=2
   boolean false

2. Get these error:
VirtualBin.cpp:283 Couldn't handle media type: application/dash+xml
GstMediaRouter.cpp:693 Pad linking failed!


={============================================================================
*kt_dev_uv_stack_410* mr-dash: build dash pipeline using media router

*uridecodebin* -> *decodebin(video)* -> *qtdemux* -> *h264parse-nexussink*
                *decodebin(audio)* -> *fakesink*

dbus-send --print-reply --type=method_call --dest='Zinc.MediaProxy' $MR
Zinc.Media.MediaRouter.setSource 
string:http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd int32:0


// Nickel/Nickel.System.Proxy/src/ProxyMediaRouter.cpp
// See spec A.1.1

NS_ZINC::Future< void > 
ProxyMediaRouter::setSource(const std::string& mediaLocator_in, 
  const SetSourceReason::Enum reason_in) 
{
  scoped_lock lock(mutex);

  if (sourcing) {
    return deferCall(
        boost::bind(&MediaRouter::setSource, _1, mediaLocator_in, reason_in));
  }

  sourcing = true;

  // note: <0>
  return SetSourceContinuation::create(
      *dispatcher, shared_from_this(), mediaLocator_in, reason_in);
}


class ZINC_LOCAL SetSourceContinuation 
  : public NS_ZINC::Continuation<void, SetSourceContinuation> 
{
  friend class NS_ZINC::Continuation<void, SetSourceContinuation>;

  public:

  private:

  // note:
  // Why start()? This is from "Contiunation" since create() creates an object
  // then calls start().

  void start(boost::shared_ptr<ProxyMediaRouter> proxy_, 
      const std::string& source_, const SetSourceReason::Enum reason_) 
  {
    // I take copies of the proxy state, in case it is modified before the continuation
    // completes.
    //
    // This start() method will be called by the same thread that calls 
    // ProxyMediaRouter::setSource(), so I assume it is OK to access proxy state from 
    // here (as lock will already be held).

    // note: property comes from ProxyMediaRouter

    properties = proxy->properties;

    // note: see uses of ProxyMediaRouter directly

    else 
    {
      // note: this is where map used and get the corresponding factory.
      //
      factory = proxy->findFactoryGivenSource(source);

      // This covers the cases where we have no implementation MediaRouter, or
      // a recycled one that is not compatible with the source media.
      // In both cases, we create a new one of the appropriate type.

      // note: <1> async call
      if (factory != proxy->lastFactory) {
        continueOnSuccess(
            factory->createMediaRouter(), 
            &SetSourceContinuation::onMediaRouterCreated);
        return;
      }
    }

    // We only reach here if we have a recycled MediaRouter implementation already,
    // or we have an existing dvb MediaRouter and we are setting another dvb source.
    //
    // In these cases, we do not have to create a new MediaRouter implementation, so
    // we move straight on to setting the properties.
    //
    setProperties();
  }

  void onMediaRouterCreated(boost::shared_ptr<MediaRouter> impl_) {

    NICKEL_FUNC_TRACE;

    // note: save up gst media router
    impl = impl_;
    impl->addListener(proxy);
    setProperties();
  }

  void setProperties()
  {
    // note: <2> async call
    continueOnSuccess(SetPropertiesContinuation::create(getDispatcher(),
          proxy, impl, shared_from_this(), properties),
        &SetSourceContinuation::onPropertiesSet);
  }

  void onPropertiesSet()
  {
    // note: <6> async call.
    //
    // Future<void> 
    // GstMediaRouter::setSource
    // (const std::string&, Zinc::Media::SetSourceReason::Enum);

    continueOnSuccess
      (impl->setSource(source, reason), &SetSourceContinuation::complete);
  }

  void complete() {

    promise.complete();

    // note: set-source-complete
    proxy->setSourceComplete(source, impl, factory);
  }

  boost::shared_ptr<ProxyMediaRouter> proxy;
  ProxyMediaRouter::UnsourcedProperties properties;
  boost::shared_ptr<MediaRouter> impl;
  std::string source;
  SetSourceReason::Enum reason;

  boost::shared_ptr<MediaRouterFactory> factory;

  boost::optional<std::string> setPropertiesFailureMessage;
};


class ZINC_LOCAL SetPropertiesContinuation
    : public NS_ZINC::Continuation<void, SetPropertiesContinuation> 
{
    friend class NS_ZINC::Continuation<void, SetPropertiesContinuation>;

private:

    // note: <3>. calls bunch of async calls and end a chain
    //
    void start(boost::shared_ptr<ProxyMediaRouter> proxy_,
            boost::shared_ptr<MediaRouter> impl_,
            boost::shared_ptr<SetSourceContinuation> parentContinuation_,
            const ProxyMediaRouter::UnsourcedProperties& mrProperties_)
    {
        proxy = proxy_;
        parentContinuation = parentContinuation_;
        properties = mrProperties_;
        impl = impl_;

        NS_ZINC::FutureBarrier barrier(getDispatcher());
        if (properties.mediaDuration) {
            barrier.add(impl->setMediaDuration(*properties.mediaDuration));
        }
        if (properties.sink) {
            barrier.add(impl->setSink(*properties.sink));
        }
        if (properties.captureMode) {
            barrier.add(impl->setCaptureMode(*properties.captureMode));
        }
        if (properties.videoWindow) {
            barrier.add(impl->setVideoWindow(*properties.videoWindow));
        }
        if (properties.playSpeed) {
            barrier.add(impl->setPlaySpeed(*properties.playSpeed));
        }
        if (properties.endTime) {
            barrier.add(impl->setEndTime(*properties.endTime));
        }
        if (properties.bufferingMode) {
            barrier.add(impl->setBufferingMode(*properties.bufferingMode));
        }
        if (properties.videoTerminationMode) {
            barrier.add(impl->setVideoTerminationMode(
                        *properties.videoTerminationMode));
        }
        if (properties.volume) {
            barrier.add(impl->setVolume(*properties.volume));
        }

        // note: <4>
        continueOnSuccess(barrier, &SetPropertiesContinuation::onPropertiesSet);
    }

    void SetPropertiesContinuation::onPropertiesSet()
    {
        // note: <5> this ends "continuation chain"
        promise.complete();
    }

    boost::shared_ptr<ProxyMediaRouter> proxy;
    ProxyMediaRouter::UnsourcedProperties properties;
    boost::shared_ptr<MediaRouter> impl;
    boost::shared_ptr<SetSourceContinuation> parentContinuation;
};


// note: <7>
NS_ZINC::Future<void> GstMediaRouter::setSource( const std::string& mediaLocator,
    const SetSourceReason::Enum reason)
{
    const boost::lock_guard<boost::mutex> l(lock);

    if (!src.empty()) {
        return
            NS_ZINC::exceptionalFuture<void>(*getDispatcher(),
                                             IllegalReconfigurationException());
    }

    if (boost::starts_with(mediaLocator, "dvb://")) {
        return NS_ZINC::exceptionalFuture<void>(*getDispatcher(),
                                                InvalidLocatorException());
    } else if (boost::starts_with(mediaLocator, "linear:")) {
        return NS_ZINC::exceptionalFuture<void>(*getDispatcher(),
                                                InvalidLocatorException());
    } else {
        src = mediaLocator;
    }

    // note: <8>
    // TODO: work out whether the source is live
    typefindBin->setSource(src);

    // send CHANGE_COMPLETE signal
    // TODO: in the future move to a place when we know that source if configured
    produceEvent(
        boost::bind(
            &MediaRouterEventListener::SourceEvent, _1,
            SourceEventValue::change_complete, reason));

    return NS_ZINC::completedFuture(*getDispatcher());
}


// <8>
// note: uri set to "uridecodebin"
void VirtualBinTypefind::setSource(const std::string& sourceUri)
{
    g_object_set(G_OBJECT(uridecodebin.get()),
                 "uri", sourceUri.c_str(),
                 NULL);
}


<mr-start>

NS_ZINC::Future<void> GstMediaRouter::start()
{
    gst_element_set_state(pipeline.get(), GST_STATE_PLAYING));
}

// {{{
// note: -> call "pad-added" callback from uridecodebin since it added into
// the pipleline from TF(TypeFinder) ctor.

void VirtualBinTypefind::newPadCb
  (GstElement* element, GstPad* pad, gpointer data)
{
  VirtualBinTypefind* const vbin = static_cast<VirtualBinTypefind*>(data);
  vbin->newPad(element, pad);
}

void VirtualBinTypefind::newPad(GstElement*, GstPad* pad)
{
  const boost::shared_ptr<VirtualPad> wrappedPad = wrapSrcPad(pad);

  // this comes from VirtualBin and each bin has callback memeber when gets
  // created.
  parentCallback(
      VirtualBinCallbackAction::RequestPadConnection,
      shared_from_this(),
      wrappedPad);
}

// note:
// getSrcPadFactory() returns VirtualFactoryInProcess() created from GstMR ctor
// and now retuns VirtualPadInProcess which it creates. Hence factory.
//
// boost::shared_ptr<VirtualPad> VirtualBin::wrapSrcPad(GstPad* pad)
// {
//     return getSrcPadFactory()->wrap(
//         mirrorPad(RefObj<GstPad>(pad, true), container).retain());
// }
//
// boost::shared_ptr<VirtualPad> VirtualPadFactoryInProcess::wrap(GstPad* pad)
// {
//     return boost::make_shared<VirtualPadInProcess>(pad, shared_from_this());
// }
//
// note:
// create a ghost pad.
//
// from VirtualBin.h
//
// RefObj<GstPad> mirrorPad(const RefObj<GstPad>& pad,
//                          const RefObj<GstElement>& bin,
//                         const char* padName = NULL);
//
// from VirtualBin.cpp
//
// RefObj<GstPad> mirrorPad(const RefObj<GstPad>& pad,
//                          const RefObj<GstElement>& bin,
//                          const char* const padName)
// {
//     RefObj<GstPad> ghostPad;
// 
//     if (padName) {
//         ghostPad = gst_ghost_pad_new(padName, pad.get());
//     } else {
//         const NS_ZINC::ScopedObj<gchar> staticPadName(
//             gst_pad_get_name(pad.get()), gcharFree);
// 
//         if (!staticPadName) {
//             return ghostPad;
//         }
// 
//         const NS_ZINC::ScopedObj<gchar> uniquePadName(
//             g_strdup_printf("%s_%p", staticPadName.get(), pad.get()),
//             gcharFree);
//         if (!uniquePadName) {
//             NICKEL_ERROR("Failed to create unique pad name");
//             return ghostPad;
//         }
// 
//         ghostPad = gst_ghost_pad_new(uniquePadName.get(), pad.get());
//     }
// 
//     if (!ghostPad) {
//         NICKEL_ERROR("Failed to create ghost pad!");
//     }
// 
//     if (!gst_pad_set_active(ghostPad.get(), TRUE)) {
//         NICKEL_ERROR("gst_pad_set_active failed!");
//     }
// 
//     if (gst_element_add_pad(GST_ELEMENT(bin.get()),
//                             ghostPad.get())) {
//         ghostPad.retain();
//     } else {
//         NICKEL_ERROR("gst_element_add_pad failed!");
//     }
// 
//     return ghostPad;
// }

boost::bind(&GstMediaRouter::plugVirtualPad, this, _1, _2, _3));


// note:
// This is "sort-of" autoplug implemenatation programmatically which links
// elements.
//
// bool GstMediaRouter::plugVirtualPad(VirtualBinCallbackAction::Enum action,
//     boost::shared_ptr<VirtualBin> bin,
//     boost::shared_ptr<VirtualPad> vpad)
// {
//     boost::lock_guard<boost::mutex> l(lock);
// 
//     // note: sinkBin and srcBin are sp created in init()
//     // so when bin is srcBin and calls sink->autoplug
// 
//     if (action == VirtualBinCallbackAction::RequestPadConnection) {
//         if (bin == typefindBin && srcBin->autoplug(vpad)) {
//             NICKEL_TRACE("connected typefindbin to srcbin!");
// 
//         } else if (bin == srcBin && sinkBin->autoplug(vpad)) {
//             NICKEL_TRACE("srcbin requested connection");
// 
//         } else if (bin == sinkBin) {
//             NICKEL_TRACE("sinkbin shouldn't request pad connection!");
//         } else {
//             NICKEL_ERROR("Pad linking failed!");
//             return false;
//         }
//     }
//     return true;
// }


(BinTypefind, pad from uridecode)

bool GstMediaRouter::plugVirtualPad(VirtualBinCallbackAction::Enum action,
    boost::shared_ptr<VirtualBin> bin,
    boost::shared_ptr<VirtualPad> vpad)
{
   // note: calls <bin-scr> srcBin->autoplug(srcPad from Typefind)
   
   VirtualBinCallbackAction::RequestPadConnection

   if (bin == typefindBin && srcBin->autoplug(vpad));
}

// note:
// why "derived->autoplug()" although all uses base implementation?
// 
// VirtualBin::elementFactory
// VirtualBin::autoplug
//
// because this map, elementfactory, is protected member in the base and each
// derived has its own copy and add items in ctor. However, autoplug has
// common code but actually run on derived copy of map.

bool VirtualBin::autoplug(boost::shared_ptr<VirtualPad> srcPad)
{
    // plug_unlocked() returns *decodebin* based on cap of srcPad since:
    //
    // Element has current caps, get mime fro caps, get element for: application/dash+xml
    //
    // BinTypefind has an entry in the map
    //   ["application/dash+xml"] = VirtualBinSrc::makeAndSetupDecodebin
    //
    // plug_unlocked:: upstream = it->second();
    //
    // calls VirtualBinSrc::makeAndSetupDecodebin
    //   creates decodebin, and set pad-add handler('this')
    //
    // caps set: video/quicktime; audio/x-m4a; text/x-raw
    //
    sinkpad = RefObj<GstPad> VirtualBin::plug_unlocked(const RefObj<GstPad>& scrPad);

    // *uridecodebin* -> *decodebin*
    gst_pad_link_full(unwrappedSrcPad.get(), sinkpad);
}

NICKEL_TRACE("connected typefindbin to srcbin!");


// {{{
// note: -> call "pad-added" callback from decodebin for video
// pad(video/quicktime)

void VirtualBinSrc::newDecodebinPadCb(GstElement* element, GstPad* pad,
    gpointer data)
{
   VirtualBinSrc* const vbin = static_cast<VirtualBinSrc*>(data);    // BinSrc
   vbin->newDecodebinPad(element, pad);
}

note: (BinSrc, pad from uridecode)

bool GstMediaRouter::plugVirtualPad(VirtualBinCallbackAction::Enum action,
    boost::shared_ptr<VirtualBin> bin,
    boost::shared_ptr<VirtualPad> vpad)
{
   // SINK AUTOPLUG
   // note: sinkBin->autoplug(srcPad from BinSrc)

   else if (bin == srcBin && sinkBin->autoplug(vpad)) {
}

bool VirtualBin::autoplug(boost::shared_ptr<VirtualPad> srcPad)
{
    // plug_unlocked() returns *decodebin* based on cap of srcPad since:
    //
    // Element has current caps, making element for: video/quicktime
    //
    // BinSrc = "video/quicktime; audio/x-m4a; text/x-raw");
    // BinSrc has an entry in the map
    //   elementFactory["video/quicktime"] = VirtualBinSink::makeMp4Element.
    //
    // calls VirtualBinSink::makeMp4Element
    //   creates qtdemux, and set pad-add handler
    //   no cap set
    //
    sinkpad = RefObj<GstPad> VirtualBin::plug_unlocked(const RefObj<GstPad>& pad);

    // *decodebin(video)* -> *qtdemux*
    gst_pad_link_full(unwrappedSrcPad.get(), sinkpad);
}

NICKEL_TRACE("srcbin requested connection");


// {{{
// note: -> call "pad-added" callback from decodebin. for audio pad(audio/x-m4a)

void VirtualBinSrc::newDecodebinPadCb(GstElement* element, GstPad* pad,
    gpointer data)
{
   VirtualBinSrc* const vbin = static_cast<VirtualBinSrc*>(data);
   vbin->newDecodebinPad(element, pad);
}

note: (BinSrc, pad from uridecode)

bool GstMediaRouter::plugVirtualPad(VirtualBinCallbackAction::Enum action,
    boost::shared_ptr<VirtualBin> bin,
    boost::shared_ptr<VirtualPad> vpad)
{
   // SINK AUTOPLUG
   // note: sinkBin->autoplug(srcPad from BinSrc)

   else if (bin == srcBin && sinkBin->autoplug(vpad)) {
}

bool VirtualBin::autoplug(boost::shared_ptr<VirtualPad> srcPad)
{
    // plug_unlocked() returns *decodebin* based on cap of srcPad since:
    //
    // Element has current caps, making element for: audio/x-m4a
    //
    // BinSrc = "video/quicktime; audio/x-m4a; text/x-raw");
    // BinSrc has an entry in the map
    //   elementFactory["audio/x-m4a"] = VirtualBinSink::makeElementSimple;
    //
    // VirtualBinSink::makeElementSimple
    //   creates fakesink
    //
    sinkpad = RefObj<GstPad> VirtualBin::plug_unlocked(const RefObj<GstPad>& pad);

    // *decodebin(audio)* -> *fakesink*
    gst_pad_link_full(unwrappedSrcPad.get(), sinkpad);
}

NICKEL_TRACE("srcbin requested connection");

// {{{ 
// note: -> call "pad-added" callback from qtdemux. for video/x-h264
// note: THIS IS NOT A CAP REQUESTED

NewPadCallback::callback(GstElement*, GstPad*, void*)
{
    // return sink
    RefObj<GstPad> VirtualBin::plug(const RefObj<GstPad>& pad)
    {
        const boost::lock_guard<boost::mutex> l(lock);
        return plug_unlocked(pad);
    }

    // plug_unlocked() returns *h264parse-nexussink* based on cap of srcPad since:
    //
    // Element has current caps, making element for: video/x-h264
    //
    // BinSrc has an entry in the map
    //   elementFactory["video/x-h264"] = VirtualBinSink::makeH264Element;
    //
    // calls VirtualBinSink::makeH264Element
    //   creates element(h264 ! nexussink)
    //

    // *qtdemux* -> *h264parse-nexussink*
    gst_pad_link_full(pad.get(), sinkpad);
}


GstMediaRouter.cpp:300 State transition READY -> PAUSED wanted PLAYING
GstMediaRouter.cpp:300 State transition PAUSED -> PLAYING wanted VOID_PENDING


<stop>
ProxyMediaRouter.cpp:862 ENTER: 
  virtual zinc::Future<void> nickel::system::ProxyMediaRouter::stop()


={============================================================================
*kt_dev_uv_stack_411* zinc-mr: qt and media router interface

//qtwebkit/Source/WebCore/platform/graphics/MediaPlayerPrivate.h

class MediaPlayerPrivateInterface {
public:
    MediaPlayerPrivateInterface() { }
    virtual ~MediaPlayerPrivateInterface() { }

    virtual void load(const String& url) = 0;
    virtual void cancelLoad() = 0;
    
    virtual void prepareToPlay() { }
    virtual PlatformMedia platformMedia() const { return NoPlatformMedia; }

#if USE(ACCELERATED_COMPOSITING)
    virtual PlatformLayer* platformLayer() const { return 0; }
#endif

    virtual void play() = 0;
    virtual void pause() = 0;    

    virtual bool supportsFullscreen() const { return false; }
    virtual bool supportsSave() const { return false; }
    virtual bool supportsScanning() const { return false; }

    virtual IntSize naturalSize() const = 0;

    virtual bool hasVideo() const = 0;
    virtual bool hasAudio() const = 0;

    virtual void setVisible(bool) = 0;

    virtual float duration() const = 0;

    virtual float currentTime() const = 0;
    virtual void seek(float time) = 0;
    virtual bool seeking() const = 0;

    virtual float startTime() const { return 0; }

    virtual double initialTime() const { return 0; }

    virtual void setRate(float) = 0;
    virtual void setPreservesPitch(bool) { }

    virtual bool paused() const = 0;

    virtual void setVolume(float) = 0;

    virtual bool supportsMuting() const { return false; }
    virtual void setMuted(bool) { }

    virtual bool hasClosedCaptions() const { return false; }    
    virtual void setClosedCaptionsVisible(bool) { }

    virtual MediaPlayer::NetworkState networkState() const = 0;
    virtual MediaPlayer::ReadyState readyState() const = 0;

    virtual PassRefPtr<TimeRanges> seekable() const 
    { return maxTimeSeekable() ? TimeRanges::create(0, maxTimeSeekable()) : TimeRanges::create(); }

    virtual float maxTimeSeekable() const = 0;
    virtual PassRefPtr<TimeRanges> buffered() const = 0;

    virtual bool didLoadingProgress() const = 0;

    virtual void setSize(const IntSize&) = 0;

    virtual void paint(GraphicsContext*, const IntRect&) = 0;

    virtual void paintCurrentFrameInContext(GraphicsContext* c, const IntRect& r) { paint(c, r); }

    virtual void setPreload(MediaPlayer::Preload) { }

    virtual bool hasAvailableVideoFrame() const { return readyState() >= MediaPlayer::HaveCurrentData; }

    virtual bool canLoadPoster() const { return false; }
    virtual void setPoster(const String&) { }

#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
    virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
    virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
    virtual void setControls(bool) { }
#endif

#if ENABLE(PLUGIN_PROXY_FOR_VIDEO) || USE(NATIVE_FULLSCREEN_VIDEO)
    virtual void enterFullscreen() { }
    virtual void exitFullscreen() { }
#endif

#if USE(NATIVE_FULLSCREEN_VIDEO)
    virtual bool canEnterFullscreen() const { return false; }
#endif

#if USE(ACCELERATED_COMPOSITING)
    // whether accelerated rendering is supported by the media engine for the current media.
    virtual bool supportsAcceleratedRendering() const { return false; }
    // called when the rendering system flips the into or out of accelerated rendering mode.
    virtual void acceleratedRenderingStateChanged() { }
#endif

    virtual bool hasSingleSecurityOrigin() const { return false; }

    virtual bool didPassCORSAccessCheck() const { return false; }

    virtual MediaPlayer::MovieLoadType movieLoadType() const { return MediaPlayer::Unknown; }

    virtual void prepareForRendering() { }

    // Time value in the movie's time scale. It is only necessary to override this if the media
    // engine uses rational numbers to represent media time.
    virtual float mediaTimeForTimeValue(float timeValue) const { return timeValue; }

    // Overide this if it is safe for HTMLMediaElement to cache movie time and report
    // 'currentTime' as [cached time + elapsed wall time]. Returns the maximum wall time
    // it is OK to calculate movie time before refreshing the cached time.
    virtual double maximumDurationToCacheMediaTime() const { return 0; }

    virtual unsigned decodedFrameCount() const { return 0; }
    virtual unsigned droppedFrameCount() const { return 0; }
    virtual unsigned audioDecodedByteCount() const { return 0; }
    virtual unsigned videoDecodedByteCount() const { return 0; }

    void getSitesInMediaCache(Vector<String>&) { }
    void clearMediaCache() { }
    void clearMediaCacheForSite(const String&) { }

    virtual void setPrivateBrowsingMode(bool) { }

    virtual String engineDescription() const { return emptyString(); }

#if ENABLE(WEB_AUDIO)
    virtual AudioSourceProvider* audioSourceProvider() { return 0; }
#endif

#if ENABLE(MEDIA_SOURCE)
    virtual MediaPlayer::AddIdStatus sourceAddId
        (const String& id, const String& type, const Vector<String>& codecs) 
        { return MediaPlayer::NotSupported; }

    virtual PassRefPtr<TimeRanges> sourceBuffered(const String& id) { return TimeRanges::create(); }
    virtual bool sourceRemoveId(const String& id) { return false; }
    virtual bool sourceAppend(const String& id, const unsigned char* data, unsigned length) { return false; }
    virtual bool sourceAbort(const String& id) { return false; }
    virtual void sourceSetDuration(double) { }
    virtual void sourceEndOfStream(MediaPlayer::EndOfStreamStatus) { }
    virtual bool sourceSetTimestampOffset(const String& id, double offset) { return false; }
#endif

#if ENABLE(ENCRYPTED_MEDIA)
    virtual MediaPlayer::MediaKeyException addKey
        (const String&, const unsigned char*, unsigned, const unsigned char*, 
         unsigned, const String&) { return MediaPlayer::KeySystemNotSupported; }

    virtual MediaPlayer::MediaKeyException generateKeyRequest
        (const String&, const unsigned char*, unsigned) { return MediaPlayer::KeySystemNotSupported; }

    virtual MediaPlayer::MediaKeyException cancelKeyRequest
        (const String&, const String&) { return MediaPlayer::KeySystemNotSupported; }
#endif

#if ENABLE(VIDEO_TRACK)
    virtual void getTextTracks(Vector<RefPtr<InbandTextTrackPrivate> >&) { }
    virtual void setTextTrackClient(TextTrackClient*) { }
#endif
};

class MediaPlayerPrivateGStreamer : public MediaPlayerPrivateInterface 


={============================================================================
*kt_dev_uv_stack_412* zinc-mr: get natual size

{
    NEXUS_Error rc = NEXUS_VideoDecoder_GetStatus( sharedMem->videoDecoder, &vidStatus );

    printf( "KT: _source_changed: "
            "source{ %d, %d }, code{ %d, %d}, disp{ %d, %d },"
            "ar: %d, frate: %d, format:%d \n", 
            vidStatus.source.width, vidStatus.source.height, 
            vidStatus.coded.width, vidStatus.coded.height, 
            vidStatus.display.width, vidStatus.display.height,
            vidStatus.aspectRatio, vidStatus.frameRate, vidStatus.format);

    NEXUS_VideoDecoderStreamInformation vsi;
    rc = NEXUS_VideoDecoder_GetStreamInformation( sharedMem->videoDecoder, &vsi );
    printf("KT: _stream_changed: "
            "source{ h: %d, v: %d }, code{ h: %d, v: %d}, disp{ h: %d, v: %d },"
            "ar: %d, { %d, %d }, frate: %d \n", 
            vsi.sourceHorizontalSize, vsi.sourceVerticalSize, 
            vsi.codedSourceHorizontalSize, vsi.codedSourceVerticalSize, 
            vsi.displayHorizontalSize, vsi.displayVerticalSize,
            vsi.aspectRatio, vsi.sampleAspectRatioX, vsi.sampleAspectRatioY, vsi.frameRate);
}

o get AR from streaminto

typedef struct NEXUS_VideoDecoderStreamInformation
{
  NEXUS_AspectRatio_eSar     (6)

  /* Sample aspect ratio - aspect ratio of the source calculated as the ratio of
   * two numbers reported by the decoder. See
   * NEXUS_VideoDecoderStreamInformation.sampleAspectRatioX and
   * sampleAspectRatioY for an example.  This aspect ratio is applied to the
   * picture's source size (i.e. coded size), not the picture's display size. */

  NEXUS_AspectRatio aspectRatio;

  uint16_t sampleAspectRatioX; 

  /* Only valid if aspectRatio is NEXUS_AspectRatio_eSar.
   * NEXUS_AspectRatio_eSar is only used for some codecs. If used, the
   * source's aspect ratio is calculated as the ratio of
   * sampleAspectRatioX/sampleAspectRatioY. sampleAspectRatioX and
   * sampleAspectRatioY should not be used except as a ratio. */

  uint16_t sampleAspectRatioY; /* See comments for sampleAspectRatioX */
}

o set AR values in the sink

switch(streamInformation.aspectRatio){
  case NEXUS_AspectRatio_e16x9:
    new_aspect_ratio_d = 9;
    new_aspect_ratio_n = 16;
    break;
  case NEXUS_AspectRatio_e4x3:
    new_aspect_ratio_d = 3;
    new_aspect_ratio_n = 4;
    break;
  case NEXUS_AspectRatio_eSar:
    new_aspect_ratio_d = streamInformation.sampleAspectRatioY;
    new_aspect_ratio_n = streamInformation.sampleAspectRatioX;
    break;
    // Default to 1:1
  case NEXUS_AspectRatio_eSquarePixel:


KT: _stream_changed: 
   source{ h: 1280, v: 720 }, code{ h: 1280, v: 720}, disp{ h: 1280, v: 720 },ar: 6, { 1, 1 }, frate: 3 

note: 
Here, "eSar" and square AR

ar: 6, { 1, 1 }

dbus-send --session --type=method_call --dest=Zinc.MediaProxy2 /Zinc/Media/MediaRouters/0 Zinc.Media.MediaRouter.getSourceInformation


={============================================================================
*kt_dev_uv_stack_413* zinc-mr: gstmediaroutertest

Nickel/Nickel.System.GStreamer/test/GstMediaRouterTest.cpp

{for-mr-test}

1. create GST MR 

    return createGstMediaRouter(dispatcher,
        boost::bind(Helper::returnPipeline,pipeline.retain()));

2. add event listener.

3. use test web server for programmed responses.


{for-error-test}

NICKEL_LOGGING_RULE="TRACE,STDOUT" ./gstmediaroutertest --cases nickel::system::GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeWrongType

// default EventVal value is 'data'

void uriDecoderErrorHarness(const GstStreamError error,
    const ErrorEventValue::Enum mrEventVal = ErrorEventValue::data);

// GstStreamError is enum from gst and set 'error' in the message.

void GstMediaRouterTest::uriDecoderErrorHarness(const GstStreamError error,
    const ErrorEventValue::Enum mrEventVal)
{
  RefObj<GstElement>  element = gst_element_factory_make("queue","uri-decoder");

  GstMessage *msg =
    gst_message_new_error(GST_OBJECT_CAST (element.get()),
        g_error_new_literal(GST_STREAM_ERROR, error, ""),
        "(no debug)");

  errorEventHarness(msg, mrEventVal, ErrorEventContext::source);
}


void GstMediaRouterTest::test_thatUriDecoderErrorIsProcessedForStreamErrorCodeWrongType()
{
  // 5
  uriDecoderErrorHarness(GST_STREAM_ERROR_WRONG_TYPE);
}

value = ErrorEventValue::data(7)

void GstMediaRouterTest::errorEventHarness(GstMessage *msg, const ErrorEventValue::Enum errorVal,
    const ErrorEventContext::Enum context)
{
  NS_ZINC::AtomicBool done;

  // so if not 'data' it's failure.

  EXPECT_CALL(
      *listener, ErrorEvent(errorVal, context, _))
    .WillOnce(InvokeWithoutArgs(boost::function<void(void)>(
            boost::bind(&NS_ZINC::AtomicBool::set,
              boost::ref(done), true))));

  CPPUNIT_ASSERT(gst_element_post_message(pipeline.get(), msg));

  ZINC_ASSERT_WITHIN_TIMEOUT(done.get(), DEFAULT_TIMEOUT);
}


note:
void GstMediaRouterTest::test_thatInvalidMediaUrlRaisesError()
This case raises GST_CORE_ERROR_MISSING_PLUGIN

<404-error-result>

$ NICKEL_LOGGING_RULE="TRACE,STDOUT" ./test/gstmediaroutertest --cases nickel::system::GstMediaRouterTest::test_that404OnManifestFetchRaisesError

/GstMediaRouter.cpp:532 KT: error mesg: Not found
/GstMediaRouter.cpp:552 KT: error domain: gst-resource-error-quark, code: 3 
    msg->src: GstSoupHTTPSrcsrc: source
/GstMediaRouter.cpp:562 KT: error domain: _src
/GstMediaRouter.cpp:348 KT: resource error: server: code: 404
/GstMediaRouter.cpp:581 KT: produceEvent: 6


<res>
note: Here, src name is 'videodecoder' and it goes to sink part handling.

$ NICKEL_LOGGING_RULE="TRACE,STDOUT" ./test/gstmediaroutertest --cases nickel::system::GstMediaRouterTest::test_thatVideoDecoderErrorIsProcessedForResourceError

GstMediaRouter.cpp:532 KT: error mesg: 
GstMediaRouter.cpp:552 KT: error domain: gst-resource-error-quark, code: 0 
  msg->src: GstQueue src: videodecoder

GstMediaRouter.cpp:569 KT: error domain: _sink
GstMediaRouter.cpp:581 KT: produceEvent: 5


={============================================================================
*kt_dev_uv_stack_413* zinc-mr-auth: device auth

DEVARCH-10265: YouView MR: Enable only on selected production devices

[root@HUMAX share]# find . -name titaniumdeviceauthority-system-*-config
./nickel-system-gstreamer/titaniumdeviceauthority-system-factory.plugin-config

note: org

/opt/zinc-trunk/share/

nickel-system-gstreamer/titaniumdeviceauthority-system-factory.plugin-config
libTitaniumDeviceAuthoritySystemDbusClient.so createDbusSystemFactory 

titanium-applicationcontainer-production/titaniumdeviceauthority.plugin-config:
libTitaniumDeviceAuthoritySystemDbusClient.so createDbusSystemFactory

mercury-system-uimanager/titaniumdeviceauthority.plugin-config:
libTitaniumDeviceAuthoritySystemDbusClient.so createDbusSystemFactory

note:
For 2100, without this change, cannot play even a clear stream.


NS_ZINC::Future<boost::shared_ptr<MediaRouterAsync> >
GstMediaRouterFactory::createMediaRouter()
{
    NICKEL_FUNC_TRACE;

    return enabled ?
        NS_ZINC::completedFuture(
            *dispatcher,
            createGstMediaRouter(dispatcher,
                                 boost::bind(gst_pipeline_new, "pipeline"))) :
        NS_ZINC::exceptionalFuture<boost::shared_ptr<MediaRouterAsync> >(
            *dispatcher,
            NotSupportedException("YouView MediaRouter is disabled"));
}

Zinc.Media ERROR: YouView MediaRouter is disabled
YouView MediaRouter is disabled


<check-on-dbus>
dbus-send --session --print-reply --dest=Zinc.DeviceAuthority /Zinc/DeviceAuthority/Authoriser Zinc.DeviceAuthority.Authoriser.isFeatureEnabled string:"yv-mediarouter"


note: change config as below by running command

/opt/zinc-trunk/share/

nickel-system-gstreamer/titaniumdeviceauthority-system-factory.plugin-config:
libTitaniumDeviceAuthoritySystemOff.so createOffSystemFactory
# DA disabled by patch-a-tron: libTitaniumDeviceAuthoritySystemDbusClient.so createDbusSystemFactory


source/DEVARCH/Titanium/TitaniumDeviceAuthority.System.Off


grep -lsr '^libTitaniumDeviceAuthoritySystemDbusClient.so' /opt/zinc-trunk/share/ | \
xargs -r sed -i \
-e '1i libTitaniumDeviceAuthoritySystemOff.so createOffSystemFactory' \
-e 's/^/# DA disabled by patch-a-tron: /'

grep -lsr '^libTitaniumDeviceAuthoritySystemDbusClient.so' /opt/zinc/share/ | \
xargs -r sed -i \
-e '1i libTitaniumDeviceAuthoritySystemOff.so createOffSystemFactory' \
-e 's/^/# DA disabled by patch-a-tron: /'

<for-pc-build>
04:04:03 ~/builds/topic/pc/zinc-install-root/release/debian-7-x86_64/share$ grep -lsr '^libTitaniumDeviceAuthoritySystemDbusClient.so' ./
./titanium-applicationcontainer-production/titaniumdeviceauthority.plugin-config
./mercury-system-uimanager/titaniumdeviceauthority.plugin-config
04:04:07 ~/builds/topic/pc/zinc-install-root/release/debian-7-x86_64/share$ 

grep -lsr '^libTitaniumDeviceAuthoritySystemDbusClient.so' ./
xargs -r sed -i \
-e '1i libTitaniumDeviceAuthoritySystemOff.so createOffSystemFactory' \
-e 's/^/# DA disabled by patch-a-tron: /'


={============================================================================
*kt_dev_uv_stack_412* zinc-mr: dash play using the proxy

Live: http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd

Test Card: http://rdmedia.bbc.co.uk/dash/ondemand/testcard/1/client_manifest-events.mpd

You cannot create MediaRouters and expect to hold on to them via dbus-send
alone, as they are reference counted and will be recycled and their object path
deleted when the dbus-send process terminates. Luckily, Will Manley wrote
dbussenddaemon which holds into the references for you until you're done.
Awesome.


# stop oem bronze

dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' \
/Zinc/Media/DefaultMediaRouter Zinc.Media.MediaRouter.stop

dbussenddaemon &

sleep 1

MR=`dbus-send 2>/dev/null --session --print-reply --type=method_call \
--dest='Zinc.DBusSendDaemon' \
/Zinc/Media/MediaRouterFactory \
Zinc.Media.MediaRouterFactory.createMediaRouter \
string:Zinc.MediaProxy 2>/dev/null |grep "/Zinc/Media/MediaRouters/" |cut -d'"' -f2`

// method return sender=:1.155 -> dest=:1.230 reply_serial=2 object path
// "/Zinc/Media/MediaRouters/1"

echo $MR

note: if not okay, MR is empty

// echo $MR
// /Zinc/Media/MediaRouters/1

dbus-send --session --print-reply --type=method_call \ 
--dest='Zinc.MediaProxy' $MR Zinc.Media.MediaRouter.setSource \
string:http://dash.bidi.int.bbc.co.uk/e/pseudolive/bbb/client_manifest.mpd int32:0

dbus-send --session --print-reply --type=method_call \
--dest='Zinc.MediaProxy' $MR Zinc.Media.MediaRouter.setSink \
string:decoder://0

dbus-send --session --print-reply --type=method_call \
--dest='Zinc.MediaProxy' $MR Zinc.Media.MediaRouter.start

sleep 10

dbus-send --session --print-reply --type=method_call \
--dest='Zinc.MediaProxy' $MR Zinc.Media.MediaRouter.stop

killall dbussenddaemon

ls -al /opt/zinc/bin/nickelmediad*
16:13 /opt/zinc/bin/nickelmediad*
02:15 /opt/zinc/bin/nickelmediad.oem*

note: 
need to use local library. LD_LIBRARY_PATH is local

export
LD_LIBRARY_PATH=/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/lib
:/opt/zinc-trunk/devel/lib:/usr/local/lib
:/opt/stagecraft-2.0/bin:/opt/zinc/tests/lib:

LD_PRELOAD=/usr/local/lib/libdirectfb.so
:/usr/local/lib/libdirect.so
:/usr/local/lib/libinit.so:/lib/libpthread.so.0

/opt/zinc-trunk/bin/nickelmediad -b Zinc.MediaProxy


note: this zinc log

2015-06-03 16:52:55,756 TRACE  772130080 nickel
Nickel.System.GStreamer/src/GstMediaRouter.cpp:300 State transition PAUSED ->
PAUSED wanted PLAYING


(!) DirectFBSetOption: DirectFBInit has to be called before DirectFBSetOption!
commandline read: nickelmediad
commandline read: -b
commandline read: Zinc.MediaProxy

   ~~~~~~~~~~~~~~~~~~~~~~~~~~| DirectFB 1.4.15 Phase 1.5.2 |~~~~~~~~~~~~~~~~~~~~~~~~~~
        (c) 2001-2010  The world wide DirectFB Open Source Community
        (c) 2000-2004  Convergence (integrated media) GmbH
      ----------------------------------------------------------------

0:02:03.109739443  2247   0x568380 ERROR              nexussink
Polonium.GSTNexus/src/gstnexussink.c:1687
  :gst_nexus_sink_poll_decoder_status_locked:<nexussink0> Frame rate 25/1


note:
When kill nickelmediad loaded when boots up and manually launch it again, it
will use /opt/zinc in LD_LIBRARY_PATH since it's local to a process as shown:

LD_LIBRARY_PATH="/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/oss/lib:${LD_LIBRARY_PATH}"

exec "${target}" "${@}"

So need to run this and export it as shown above. If not, will use fake library
and see OEM build path in log lines. So should see your build path in the log.

note:
Unlike humax 2000, directfb related libraries were not loaded on 1000 box and
hence no AV although YV media router is up and running. Hence to run LD_PRELOAD
line as shown above before launching a new nickel daemon.

If all is okay, shall see directfb log in the log, nexus fds in /proc/XXX/fd.

note:
export
LD_PRELOAD=/usr/local/lib/libdirectfb.so:/usr/local/lib/libdirect.so:/usr/local/lib/libinit.so

export LD_LIBRARY_PATH=/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib:${LD_LIBRARY_PATH}

export GST_PLUGIN_PATH=/opt/zinc-trunk/oss/lib/gstreamer-1.0

dbus-send --session --print-reply --type=method_call --dest='Zinc.Media'
/Zinc/Media/DefaultMediaRouter Zinc.Media.MediaRouter.stop


<gst-launcgh>
gst-launch-1.0 --gst-debug=souphttpsrc:5  -v souphttpsrc
location="http://wll1p02380.dev.youview.co.uk/videos/dash/bigBunny2/yv_TestTRec.mpd"
! dashdemux name=dash dash.  ! qtdemux ! h264parse ! queue  ! nexussink

gst-launch-1.0 --gst-debug=nexussink:4  -v souphttpsrc
location="http://wll1p02380.dev.youview.co.uk/videos/dash/bigBunny2/yv_TestTRec.mpd"
! dashdemux name=dash dash.  ! qtdemux ! h264parse ! queue  ! nexussink

gst-launch-1.0 souphttpsrc
location="http://wll1p02380.dev.youview.co.uk/videos/dash/bigBunny2/yv_TestTRec.mpd"
! dashdemux name=dash dash.  ! qtdemux ! h264parse ! queue  ! nexussink


={============================================================================
*kt_dev_uv_stack_413* zinc-mr: hls play

note:
The webkit plugin has direct implementation to have hls.

qtwebkit/Source/WebCore/platform/graphics/gstreamer/
MediaPlayerPrivateGStreamer.cpp

MediaPlayerPrivateGStreamer::createGSTHLSPipeline(const char *srcElementName)

m_playBin = gst_pipeline_new ("hls-player");

// gst_element_factory_make() returns a floating reference so we should not adopt.
GRefPtr<GstElement> httpSrc = gst_element_factory_make (srcElementName, "http-source");
GRefPtr<GstElement> hlsdemux = gst_element_facto
    y_make ("hlsdemux", NULL);
GRefPtr<GstElement> nexusSink = gst_element_factory_make ("tsnexusbin", NULL);

gst_bin_add_many (GST_BIN (m_playBin.get()),
                  GST_ELEMENT(gst_object_ref(httpSrc.get())),
                  GST_ELEMENT(gst_object_ref(hlsdemux.get())),
                  GST_ELEMENT(gst_object_ref(nexusSink.get())),
                  NULL);

g_signal_connect (hlsdemux.get(), "pad-added", G_CALLBACK (cb_new_hlsdemux_pad), this);

if(!gst_element_link (httpSrc.get(), hlsdemux.get())){


cb_new_hlsdemux_pad (GstElement *hlsdemuxElement,)
   MediaPlayerPrivateGStreamer::hlsdemux_pad_added (GstElement *hlsdemux, GstPad *pad)
      link_gst_element(hlsdemux, pad,"tsnexusbin");


https://wiki.youview.co.uk/display/canvas/2014/05/30/playback+of+a+HLS+stream+from+the+command+line?src=search

# on the box
gst-launch-1.0
  souphttpsrc location="http://184.72.239.149/vod/smil:bigbuckbunnyiphone.smil/playlist.m3u8" 
  ! hlsdemux ! tsnexusbin


GST_DEBUG_NO_COLOR=1 GST_DEBUG_FILE=/gst-hls-log.txt GST_DEBUG=5 
  ./gstmr-play.sh -p 3


={============================================================================
*kt_dev_uv_stack_413* zinc-mr: gstmr-play.sh

What's the "-p" option?

        (-p | --proxy)
            BUS_NAME="Zinc.MediaProxy2"
            USE_PROXY="true"
            shift;;
The original script set temp cfg which force to use GST MR directly without
  going through YV MR:

echo "libNickelSystemGStreamer.so createGstSystemFactory" > $cfg

echo "Starting GStreamer MR daemon ..."
env ${vars[@]} nickelmediad \
    --no-mediasettings --no-localmedialibrary \
    --no-outputmanager --no-servicelistbuilder \
    -b $BUS_NAME -f $cfg &


Now need to make YV MR usable on command line to test hls/dash play through YV
MR. Therefore, introduced this option to do this:

# when not use YV MR

if [ -z "${USE_PROXY:-}" ]; then
    declare -r cfg=$(mktemp)
    echo "libNickelSystemGStreamer.so createGstSystemFactory" > $cfg

    echo "Starting GStreamer MR daemon ..."
    env ${vars[@]} nickelmediad \
        --no-mediasettings --no-localmedialibrary \
        --no-outputmanager --no-servicelistbuilder \
        -b $BUS_NAME -f $cfg &

# when use YV MR
else
    echo "Starting YV MR daemon ..."
    env ${vars[@]} nickelmediad -b $BUS_NAME &
fi


Now when run "gstmr-play.sh 3", will launch a new daemon and use GST MR
directly. So "-p" is to say if want to use the proxy or not in a new daemon.


={============================================================================
*kt_dev_uv_stack_413* mr-dash-debug: 

{for-glib}
G_MESSAGES_DEBUG=drmwasabi


{for-gst}
GST_DEBUG_NO_COLOR=1 GST_DEBUG_FILE=/gst-hls-log.txt GST_DEBUG=5 
GST_DEBUG=cencdec:5 

nexussink:3
decodebin:4
uridecodebin:4
dashdemux:4
adaptivedemux:4
h264parse:4


{for-out-of-sandbox}
Means out of sandbox

killall linearsourced
export GST_DEBUG=5
linearsource-launch &


{level}
The number after the element name indicates the debug level:

0	GST_LEVEL_NONE
1	GST_LEVEL_ERROR
2	GST_LEVEL_WARNING
3	GST_LEVEL_FIXME
4	GST_LEVEL_INFO
5	GST_LEVEL_DEBUG
6	GST_LEVEL_LOG
   Log messages are messages that are very common but might be useful to know.
   As a rule of thumb a pipeline that is iterating as expected should never
   output anything else but LOG messages. Use this log level to log recurring
   information in chain functions and loop functions, for example.


7	GST_LEVEL_TRACE
   Tracing-related messages. Examples for this are referencing/dereferencing of
   objects.

9	GST_LEVEL_MEMDUMP
   memory dump messages are used to log (small) chunks of data as memory dumps
   in the log. They will be displayed as hexdump with ASCII characters.


/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk/oss/include/
  gstreamer-1.0/gst

gstinfo.h

typedef enum {
  GST_LEVEL_NONE = 0,
  GST_LEVEL_ERROR = 1,
  GST_LEVEL_WARNING = 2,
  GST_LEVEL_FIXME = 3,
  GST_LEVEL_INFO = 4,
  GST_LEVEL_DEBUG = 5,
  GST_LEVEL_LOG = 6,
  GST_LEVEL_TRACE = 7,
  /* add more */
  GST_LEVEL_MEMDUMP = 9,
  /* add more */
  GST_LEVEL_COUNT
} GstDebugLevel;


{element-register}
Nickel/Nickel.LinearSource/zmp/gstzmpsink.c

static gboolean
gst_zmp_sink_plugin_init (GstPlugin * plugin)
{
  GST_DEBUG_CATEGORY_INIT (gst_zmp_sink_debug, "zmpsink", 0,
      "ZMP Sink");

  return gst_element_register (plugin, "zmpsink", GST_RANK_NONE,
      GST_TYPE_ZMP_SINK);
}


={============================================================================
*kt_dev_uv_stack_413* mr-dash-debug: nickel in sandbox

{on-log-in-sandbox}

/opt/zinc/bin/nickelmediad-launch

#!/bin/sh
ulimit -c unlimited
program_name=$(basename $0)
target="/opt/zinc-trunk/bin/${program_name}"
GST_DEBUG_NO_COLOR=1 GST_DEBUG_FILE=/dash.txt GST_DEBUG=adaptivedemux:5 \
G_MESSAGES_DEBUG=drmwasabi \
LD_LIBRARY_PATH="/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib \
:/opt/zinc-trunk/oss/lib:${LD_LIBRARY_PATH}" exec "${target}" "${@}"


G_MESSAGES_DEBUG=drmwasabi get you:

(nickelmediad:2907): drmwasabi-DEBUG: 
  Failed at /.../DEVARCH/Polonium/Polonium.Drm/src/gdrmwasabi.c:986

note: not able to log file in sandbox but able to get GST_DEBUG on console.


={============================================================================
*kt_dev_uv_stack_413* zinc-drm:

{oem-wasabi}

DEVARCH/Zinc/Zinc.Build/setvars-host.sh

#
# Wasabi (optional)
#
wasabi_pkg_config_dir="/opt/wasabi/lib/pkgconfig"
if [[ -d "${wasabi_pkg_config_dir}" ]]; then
  export PKG_CONFIG_PATH="${wasabi_pkg_config_dir}:${PKG_CONFIG_PATH}"
else
  echo "Info: Wasabi not found"
fi

$ pkg-config --libs wasabi
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/usr/local/lib -Wl,-rpath,/usr/local/lib -lWasabi -lSkb 


{enc-play-fail}

ERROR  /Nickel/Nickel.System.GStreamer/src/VirtualBinSink.cpp:294 
Failed to resolve compound URL: https://ms3.youview.co.uk/s/Big+Buck+Bunny+DASH+2d

const std::string VirtualBinSink::setDrmUrl(const std::string& sourceUri)
{
  std::string contentUrl = sourceUri;

  if (0 == sourceUri.find("https://") &&
      std::string::npos != sourceUri.find("#")) {
    // We've got a compound url
    const RefObj<GObject> drm = G_OBJECT(g_drm_create_default());
    gst_cenc_decrypt_drm_use(getParent().get(), G_DRM_CAST(drm.get()));

    const GDrmResult* const resolved =
      g_drm_resolve_url(G_DRM_CAST(drm.get()), sourceUri.c_str());

    ...

    NICKEL_ERROR("Failed to resolve compound URL: " << sourceUri);

  }
}

This leads to:

// Polonium/Polonium.Drm/src/gdrmwasabi.c
g_drm_wasabi_cenc_resolve_url (GDrmWasabi * self,


<libs>
zb-copy libgdrm.so.0.0.0


<case-out-of-sandbox>

(nickelmediad:1643): drmwasabi-DEBUG: No MS3 constraints found

nickel Nickel.System.GStreamer/src/VirtualBinSink.cpp:285 
Resolved compound URL:
https://ms3.youview.co.uk/s/Big+Buck+Bunny+DASH+2#http://test-media.youview.co.uk/ondemand/bbb/avc3/1/2drm_manifest.mpd
C-URL: http://test-media.youview.co.uk/ondemand/bbb/avc3/1/2drm_manifest.mpd


<case-in-sandbox>

(nickelmediad:2907): drmwasabi-CRITICAL **: Wasabi error occured: (unknown) (no
  details available)

(nickelmediad:2907): drmwasabi-DEBUG: Failed at
                     /Polonium/Polonium.Drm/src/gdrmwasabi.c:986

(nickelmediad:2907): drmwasabi-CRITICAL **: KT: g_drm_wasabi_init fail

(nickelmediad:2907): drmwasabi-CRITICAL **: Wasabi error occured: (unknown) (no
  details available)

(nickelmediad:2907): drmwasabi-DEBUG: Failed at
                     /Polonium.Drm/src/gdrmwasabi.c:674

(nickelmediad:2907): drmwasabi-CRITICAL **: KT: g_drm_wasabi_failure
                     (g_drm_wasabi_get_sas_error)

ERROR  /Nickel/Nickel.System.GStreamer/src/VirtualBinSink.cpp:294 
Failed to resolve compound URL: https://ms3.youview.co.uk/s/Big+Buck+Bunny+DASH+2d


<personalize>

note: wrong and found that this is what gets created when run out of sandbox.

[root@HUMAX /]# ls -alR /var/lib/
/var/lib/:
drwxr-xr-x    3 root     root          4096 Oct 28 08:41 ./
drwxr-xr-x   13 root     root          4096 Jan  1  2000 ../
drwxrwxrwx    2 root     root          4096 Oct 29 10:16 marlin/
-rw-------    1 root     root           512 Jan  1  2000 random-seed

/var/lib/marlin:
drwxrwxrwx    2 root     root          4096 Oct 29 10:16 ./
drwxr-xr-x    3 root     root          4096 Oct 28 08:41 ../
-rw-------    1 root     root         63514 Oct 29 10:16 db0.storage


note: MUST rm dir but not db0.storage. Otherwise, not properly make files due to
check in /opt/zinc/libexec/yv-personalise.sh

[root@HUMAX /]# rm -rf /var/lib/marlin/

[root@HUMAX /]# /bin/marlin-personalise.sh 
time source = BROADCAST
(!) DirectFBSetOption: DirectFBInit has to be called before DirectFBSetOption!
commandline read: yv-personalise-marlin

   ~~~~~~~~~~~~~~~~~~~~~~~~~~| DirectFB 1.4.17 v1.5 |~~~~~~~~~~~~~~~~~~~~~~~~~~
        (c) 2001-2012  The world wide DirectFB Open Source Community
        (c) 2000-2004  Convergence (integrated media) GmbH
      ----------------------------------------------------------------

(*) DirectFB/Core: Multi Application Core. (2015-10-15 16:25) 
(*) Fusion/SHM: Using MADV_REMOVE (forced)

** Message: Personalising device ...
...

HKP_Cleanup(798) ------------------------------------------------+++++++++
HKP_Cleanup(806) ------------------------------------------------+++++++++
...


[root@HUMAX /]# ls -alR /var/lib/
/var/lib/:
drwxr-xr-x    3 root     root          4096 Oct 29 10:19 ./
drwxr-xr-x   13 root     root          4096 Jan  1  2000 ../
drwxrws--T    2 root     keys          4096 Oct 29 10:19 marlin/
-rw-------    1 root     root           512 Jan  1  2000 random-seed

/var/lib/marlin:
drwxrws--T    2 root     keys          4096 Oct 29 10:19 ./
drwxr-xr-x    3 root     root          4096 Oct 29 10:19 ../
-rw-rw-r-T    1 root     keys         63514 Oct 29 10:19 db0.storage

note: see owner and permission changes. MUST *restart* nickelmediad


[root@HUMAX /]# cat /bin/marlin-personalise.sh
#!/bin/bash
RETRIES=0
while [ $RETRIES -lt 12 ]
do
	TIMESOURCE=`lsr-config oem.device.state.currenttimesource`	
	if [ $TIMESOURCE != 'NONE' ] && [ $TIMESOURCE != 'FREERUNNING' ]
	then
		echo "time source = $TIMESOURCE"
		/opt/zinc/libexec/yv-personalise.sh --drm=marlin --group=keys
		break
	fi
	let RETRIES=RETRIES+1
	sleep 5
done


note: will create 'only' when there is no directory before.

[root@HUMAX /]# cat /opt/zinc/libexec/yv-personalise.sh
...
if [ ! -d "$drm_dir" ]; then
    umask 0022

    mkdir -p -m 2770 "$drm_dir"
    chown root.$drm_group "$drm_dir"

    $drm_exec

	# group can read and write, only the owner (root) can remove files
    chmod -R g+w,+t "$drm_dir"

    umask $umask_orig
fi


[root@HUMAX /]# cat /bin/setup_dbus.sh
...
isUIManagerRunning=`ps ax | grep uimanagerd | grep -v grep | wc -l`
if [ $isUIManagerRunning == 0 ]; then
	appstart -L; umount /opt/ui; umount /opt/ui2
	YVStartupFile="/mnt/hd1/YVStart.sh"
	if [[ -a $YVStartupFile ]]; then
		./$YVStartupFile
	else
		marlin-personalise.sh
		startYVServices.sh
	fi
fi

https://jira.youview.co.uk/browse/CANHUM-3487


={============================================================================
*kt_dev_uv_stack_413* zinc-drm: wrong db creation due to library depandancy

<HWEI-PVR1>

1. Shows wasabi.so statically linked with sqlite.

/opt/oem-staging/huawei-dn370t/usr/local/lib
$ nm libWasabi.so | ag sql | ag Create
0028823c T SHI_SQLiteDb_Create
00287760 T SHI_SQLiteDb_Query_Create
00287ab8 T SHI_SQLiteDb_Statement_Create
0013f750 T sqlite3BitvecCreate

2. Shows there is sqlite in Zinc build

~/builds-src-dev/master/huawei.370/zinc-build-root/release-huawei-bcm7409/
  Zinc/Zinc.3rdPartyStack/build/huawei-bcm7409/sqlite/.libs
$ nm libsqlite3.so.0.8.6 | ag sql | ag Create
00013fbc t sqlite3BitvecCreate
00045944 t sqlite3BtreeCreateTable

3. pkg-config

~/src-dev/DEVARCH$ pkg-config --libs wasabi
-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/
  huawei-bcm7409/usr/local/lib -Wl,-rpath,/usr/local/lib -lWasabi -lSkb 

4. zinc common lib

~/builds-src-dev/master/huawei.370/zinc-build-root/release-huawei-bcm7409/Zinc/
  Zinc.Common/src/.libs
$ readelf -d libZincCommon.so.0.0.0 | ag NEEDED
 0x00000001 (NEEDED)    Shared library: [libboost_filesystem.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [libboost_system.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [libboost_chrono.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [libboost_thread.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [liblog4cplus-1.0.so.4]
 0x00000001 (NEEDED)    Shared library: [libz.so.1]
 0x00000001 (NEEDED)    Shared library: [libdl.so.0]
 0x00000001 (NEEDED)    Shared library: [librt.so.0]
 0x00000001 (NEEDED)    Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)    Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)    Shared library: [libc.so.0]
 0x00000001 (NEEDED)    Shared library: [libgcc_s.so.1]


5. link commands from log
...
-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed ~
-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib -lboost_filesystem
-lboost_system -lboost_chrono -lboost_thread -llog4cplus -lz_minizip -lz
-lsqlite3 ~
-lc-modern -ldl -lrt
...
-Wl,-soname -Wl,libZincCommon.so.0 -o .libs/libZincCommon.so.0.0.0


6. from env

LDFLAGS=-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib 

-Wl,--as-needed 

-Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-L/home/kpark/builds-src-dev/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib
-Wl,-rpath-link,/opt/oem-staging/huawei-bcm7409/usr/local/lib


<HWEI-PVR2>

1. Shows the same as PVR1

/opt/oem-staging/huawei-dn372t/usr/local/lib
$ nm libWasabi.so | ag sql | ag Create
00259274 T SHI_SQLiteDb_Create
...

2. Shows the same as PVR1

~/builds-src-dev/master/huawei.372/zinc-build-root/release-huawei-bcm7231/
  Zinc/Zinc.3rdPartyStack/build/huawei-bcm7231/sqlite/.libs
$ nm libsqlite3.so.0.8.6 | ag sql | ag Create
00012488 t sqlite3BitvecCreate

3. pkg-config

~/src-dev/DEVARCH$ pkg-config --libs wasabi
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/
  huawei-bcm7231/usr/local/lib -Wl,-rpath,/usr/local/lib -lWasabi -lSkb 

4. zinc common lib

~/builds-src-dev/master/huawei.372/zinc-build-root/release-huawei-bcm7231/Zinc/
  Zinc.Common/src/.libs
$ readelf -d libZincCommon.so.0.0.0 | ag NEEDED
 0x00000001 (NEEDED)    Shared library: [libboost_filesystem.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [libboost_system.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [libboost_chrono.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [libboost_thread.so.1.57.0]
 0x00000001 (NEEDED)    Shared library: [liblog4cplus-1.0.so.4]
 0x00000001 (NEEDED)    Shared library: [libz.so.1]
 0x00000001 (NEEDED)    Shared library: [libsqlite3.so.0]   note: SEE! 
 0x00000001 (NEEDED)    Shared library: [libdl.so.0]
 0x00000001 (NEEDED)    Shared library: [librt.so.0]
 0x00000001 (NEEDED)    Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)    Shared library: [libm.so.0]
 0x00000001 (NEEDED)    Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)    Shared library: [libc.so.0]
 0x00000001 (NEEDED)    Shared library: [libgcc_s.so.1]


5. link commands from log

...
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/lib
-L/opt/oem-staging/huawei-bcm7231/usr/local/lib -lboost_filesystem
-lboost_system -lboost_chrono -lboost_thread -llog4cplus -lz_minizip -lz
-lsqlite3 ~
-lc-modern -ldl -lrt
...
-Wl,-soname -Wl,libZincCommon.so.0 -o .libs/libZincCommon.so.0.0.0


6. from env. note: NO as-needed

LDFLAGS=-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib
-Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib
-Wl,-rpath-link,/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib
-L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/lib
-L/opt/oem-staging/huawei-bcm7231/usr/local/lib
-L/opt/oem-staging/huawei-bcm7231/usr/local/lib
-Wl,-rpath-link,/opt/oem-staging/huawei-bcm7231/usr/local/lib


<372-PVR2-sqlite-build-issue-when-use-as-needed>

note: with as-needed

~/builds-src-dev/_virtual_/huawei.372/zinc-build-root/release-huawei-bcm7231/Zinc/Zinc.3rdPartyStack/build/huawei-bcm7231/sqlite

$ mipsel-linux-gcc -D_REENTRANT=1 -DSQLITE_THREADSAFE=1 -DSQLITE_ENABLE_FTS3 -DSQLITE_ENABLE_RTREE -DNDEBUG -O2 -pipe -Wl,--as-needed -Wl,-rpath-link -Wl,/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib -Wl,-rpath-link -Wl,/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib -Wl,-rpath-link -Wl,/opt/oem-staging/huawei-bcm7231/usr/local/lib -o .libs/sqlite3 shell.o  -L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/lib -L/opt/oem-staging/huawei-bcm7231/usr/local/lib ./.libs/libsqlite3.so -lpthread  -Wl,--rpath -Wl,/opt/zinc-trunk/oss/lib

./.libs/libsqlite3.so:(.got+0x0): multiple definition of `_GLOBAL_OFFSET_TABLE_'
collect2: ld returned 1 exit status

note: with NO as-needed, builds OKAY

~/builds-src-dev/_virtual_/huawei.372/zinc-build-root/release-huawei-bcm7231/Zinc/Zinc.3rdPartyStack/build/huawei-bcm7231/sqlite

$ mipsel-linux-gcc -D_REENTRANT=1 -DSQLITE_THREADSAFE=1 -DSQLITE_ENABLE_FTS3 -DSQLITE_ENABLE_RTREE -DNDEBUG -O2 -pipe -Wl,-rpath-link -Wl,/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib -Wl,-rpath-link -Wl,/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib -Wl,-rpath-link -Wl,/opt/oem-staging/huawei-bcm7231/usr/local/lib -o .libs/sqlite3 shell.o  -L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/opt/zinc-trunk/oss/lib -L/home/kpark/builds-src-dev/_virtual_/huawei.372/zinc-install-root/release/huawei-bcm7231/lib -L/opt/oem-staging/huawei-bcm7231/usr/local/lib ./.libs/libsqlite3.so -lpthread  -Wl,--rpath -Wl,/opt/zinc-trunk/oss/lib


={============================================================================
*kt_dev_uv_stack_413* zinc-drm: error

https://jira.youview.co.uk/browse/SOLDES-555


={============================================================================
*kt_dev_uv_stack_415* zinc-mr: boot failure when use wrong plugin name

/opt/zinc/bin/nickelmediad 

INFO   715850528 nickel /Nickel.System.DBusServer/src/MediaDaemon.cpp:207 Launching Fake Media Router Service Daemon...
INFO   715850528 nickel /Nickel.System.DBusServer/src/MediaDaemon.cpp:200 Using configuration file: /opt/zinc-trunk/share/nickel-system-dbusserver/media-daemon.plugin-config

DEBUG  715850528 nickel /Nickel.System.Proxy/src/ProxySystemFactory.cpp:156 KT: add {http, application/dash+xml}
DEBUG  715850528 nickel /Nickel.System.Proxy/src/ProxySystemFactory.cpp:156 KT: add {https, application/dash+xml}

Zinc.Media ERROR: Failed to find resource: 'libNickelSystemGstreamer.so' in '/opt/zinc-trunk/lib:/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/oss/lib:/opt/zinc/oss/lib:/opt/zinc/lib:/opt/zinc/devel/lib:/usr/local/lib:/opt/stagecraft-2.0/bin:/opt/zinc/tests/lib:'

Failed to find resource: 'libNickelSystemGstreamer.so' in '/opt/zinc-trunk/lib:/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/oss/lib:/opt/zinc/oss/lib:/opt/zinc/lib:/opt/zinc/devel/lib:/usr/local/lib:/opt/stagecraft-2.0/bin:/opt/zinc/tests/lib:'

INFO   715850528 nickel /Nickel/Nickel.System.DBusServer/src/MediaDaemon.cpp:220 Fake Media Router Service Daemon shutting down...


KT: configDir: /opt/zinc-trunk/share/platform_data/mediarouter-plugin-config

KT: fullPath.string:
/opt/zinc-trunk/share/platform_data/mediarouter-plugin-config/http-application%2Fdash%2Bxml.plugin-config
KT: add {http, application/dash+xml}

KT: fullPath.string:
/opt/zinc-trunk/share/platform_data/mediarouter-plugin-config/https-application%2Fdash%2Bxml.plugin-config
KT: add {https, application/dash+xml}

KT: fullPath.string:
/opt/zinc-trunk/share/platform_data/mediarouter-plugin-config/http-application%2Fx-hls.plugin-config

Zinc.Media ERROR: Failed to find resource: 'libNickelSystemGstreamer.so' in '/opt/zinc-trunk/lib:/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/oss/lib:/opt/zinc/oss/lib:/opt/zinc/lib:/opt/zinc/devel/lib:/usr/local/lib:/opt/stagecraft-2.0/bin:/opt/zinc/tests/lib:'

Failed to find resource: 'libNickelSystemGstreamer.so' in '/opt/zinc-trunk/lib:/opt/zinc-trunk/oss/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/lib:/opt/zinc-trunk/devel/lib:/opt/zinc-trunk/oss/lib:/opt/zinc/oss/lib:/opt/zinc/lib:/opt/zinc/devel/lib:/usr/local/lib:/opt/stagecraft-2.0/bin:/opt/zinc/tests/lib:'

http-application%2Fdash%2Bxml.plugin-config:libNickelSystemGStreamer.so createGstSystemFactory
http-application%2Fx-hls.plugin-config:libNickelSystemGstreamer.so createGstSystemFactory
https-application%2Fdash%2Bxml.plugin-config:libNickelSystemGStreamer.so createGstSystemFactory

http-application%2Fx-hls.plugin-config:libNickelSystemGstreamer.so createGstSystemFactory
                                                       *^*
                                                       o
                                                       

// from tunerd                                                       
2015-07-08 16:32:40,386 ERROR  715850528 zinc src/unity.cpp:5662 Received exception "Launch helper exited with unknown return code 1" making call to Zinc.Media.MediaRouterFactory.createMedia
Router


={============================================================================
*kt_dev_uv_stack_440* zinc-mr: bronze

855   :1.6                     /opt/zinc/bin/bronzemediad.oem                  
855   Zinc.Media               /opt/zinc/bin/bronzemediad.oem                  
855   Zinc.OEMSystem           /opt/zinc/bin/bronzemediad.oem                  


={============================================================================
*kt_dev_uv_stack_441* zinc-mr: dash

MPEG DASH to-do list
https://wiki.youview.co.uk/display/canvas/MPEG+DASH+to-do+list?src=search


={============================================================================
*kt_dev_uv_stack_300* stack: copper: lsr (local storage repository)

{process}
To add lst to the master config.
https://jira.youview.co.uk/browse/YVSIPA-1579?jql=project%20%3D%20YVSIPA


{access-interface}
Copper/Copper.System.API/include/LSRHelpers.h


={============================================================================
*kt_dev_uv_stack_301* stack: copper: client factory

struct zinc_export clientfactory : virtual public ns_zinc::plugin {

    virtual ~clientfactory();

	virtual boost::shared_ptr<ns_zinc::eventdispatcher> getdefaultdispatcher() = 0;

	virtual void setdefaultdispatcher(boost::shared_ptr<ns_zinc::eventdispatcher> dispatcher) = 0;

	virtual boost::shared_ptr<localstoragelocator> createlocalstoragelocator() = 0;

	virtual boost::shared_ptr<localstoragerepository> createlocalstoragerepository() = 0;

};


Uranium/Uranium.Client.System/src/SystemClientFactory.cpp

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientMetadataConfig> 
SystemClientFactory::createMetadataConfig() 
{
    URANIUM_FUNC_DEBUG;

    if(config == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::createMetadataConfig()");
        boost::shared_ptr<NS_COPPER_SYSTEM::LocalStorageRepositorySync> 
            lsr = convertToSync(getCopperSystemFactory().createLocalStorageRepository());

        config = NS_URANIUM_METADATA_CLIENT::SystemClientMetadataConfig::create(lsr);

        config->setDispatcher(getDefaultDispatcher());
    }
    return config;
}


={============================================================================
*kt_dev_uv_stack_302* stack: copper: lsr-config

https://wiki.youview.co.uk/pages/viewpage.action?pageId=67737064&src=search

The traditional way to interact with the LSR on the command line has been using
either `getItem `, `setItem`, `getChildItems` or `deleteTree`. Now there is a
much superior alternative to getItem and setItem. That is: `lsr-config`.

The help for lsr-config is:

/opt/zinc-trunk/bin/lsr-config - Get and set LSR options
Usage:
    /opt/zinc-trunk/bin/lsr-config [--int|--bool] keyname
    /opt/zinc-trunk/bin/lsr-config keyname newvalue

If the --bool or --int options are passed /opt/zinc-trunk/bin/lsr-config will validate and
normalise the values of the keys exiting with exit code 10 if the
value doesn't conform.  The --bool option understands true, false,
1, 0, yes, no, on, off and will consider a blank string to be false.
Unset keys are treated the same as blank ones.
Exit codes:
     0 - Success
     1 - Invalid usage
    10 - Validation failed (with --bool or --int)
    20 - Communication with LSR daemon failed

note: "lsr-config --bool" returns "true/false" string and if not set, return
"false" string so not a null string when test in a script. When not use --bool
returns 0/1.


./Copper/Copper.System.DBusClient/src/lsr-config.c

vqe_buffer_size="$(lsr-config --int platform.linearsource.vqebuffersize)"


platform.settings.audiofeedback.enabled=0
platform.settings.audiofeedback.volume=0
platform.settings.disable-html5-boundary-check=0
platform.settings.enable-avahi-daemon=1
platform.settings.enable-dial=1
platform.settings.enable-http-dbus-bridge-daemon=1
platform.settings.enable-ipcrb=1
platform.settings.enable-netflix=1
platform.settings.enable-webkit-remote-debugging=0
platform.settings.enabledevelopermode=0
platform.settings.html-app-cache-size=50000000
platform.settings.language.metadata=eng
platform.settings.language.ui=eng
platform.settings.shareprivatedata=1

DEVARCH-9861-Selection switch between OEM and YV


git format-patch zinc-pristine

={============================================================================
*kt_dev_uv_stack_350* stack: titanium

Security, Application Verification

// on box
lrwxrwxrwx    1 1024     1025            33 Apr 27 15:06 ./zinc-trunk/lib/
  libTitaniumCryptoLocking.so -> libTitaniumCryptoLocking.so.0.0.0
lrwxrwxrwx    1 root     root            33 Jan  1  1970 ./zinc/lib/
  libTitaniumCryptoLocking.so -> libTitaniumCryptoLocking.so.0.0.0


={============================================================================
*kt_dev_uv_stack_351* zinc-sandbox: titanium

{sandbox}
Generally this is about what to import from a real file system in to "sandbox"
that is applications view. sandbox is container.


{sandbox-files}
/opt/zinc-trunk/lib/sandbox

-r--------    1 root     root         403 Jul  3 03:19 application-oem.conf
dr-x------    2 root     root        4.0K Jun 25 14:17 application-oem.d/
-r--------    1 root     root        1.1K Jul  9 13:43 application-yv.conf
dr-x------    2 root     root        4.0K Jun 25 14:17 application-yv.d/

-r--------    1 root     root         427 Jul  3 03:19 daemon-oem.conf
-r--------    1 root     root        2.1K Jul  9 13:43 daemon-yv.conf
dr-x------    2 root     root        4.0K Jul  9 13:43 service-oem.d/
dr-x------    2 root     root        4.0K Jun 25 14:17 service-yv.d/


{sandbox-application}
/opt/zinc-trunk/lib/sandbox/application-yv.conf

##
# This is a common configuration file for application sandbox.  It specifies all
# directories that are imported "as is" from the real file system into the
# sandbox.
#
# This file is managed by YouView and is not to be modified by OEMs.
#
# Note that following directories are already in the sandbox and they are
# "special":
#
# /opt/zinc-trunk/var/log
# /opt/zinc-trunk/var/http-cache
# /app
# /app-data
# /opt/adobe/stagecraft/data
# /proc
# /dev
# /tmp
####

[directories]
# system
/lib
/usr/lib
/usr/local/lib
/usr/local/etc

# TODO: Remove
/bin
# TODO: Remove
/usr/bin

# users, groups, networking...
/etc

# YV stack
/opt/zinc-trunk/lib
/opt/zinc-trunk/share
/opt/zinc-trunk/share/platform_data
/opt/zinc-trunk/devel/lib
/opt/zinc-trunk/devel/share
/opt/zinc-trunk/oss/var/applications/identities
/opt/zinc-trunk/oss/lib

# TODO: Remove
/opt/zinc-trunk/bin
/opt/zinc-trunk/devel/bin
# TODO: Remove
/opt/zinc-trunk/oss/bin

# certificates
/opt/youview/pki

# DirectFB
/run/dfb

# Application type specific configuration is specified in application-yv.d
# directory

[options]
StdOut=/dev/console
StdErr=/dev/console


<applications>
/opt/zinc-trunk/lib/sandbox/application-yv.d
dr-x------    2 root     root        4.0K Jul 14 14:38 ./
drwxrwxr-x    6 1024     1025        4.0K Jul 14 15:22 ../
-r--------    1 root     root         419 Jul 14 14:38 air.conf
-r--------    1 root     root         376 Jul 14 16:26 html5.conf
-r--------    1 root     root         272 Jul 14 14:38 netflix.conf
-r--------    1 root     root         418 Jul 14 14:38 ui.conf


[root@HUMAX application-yv.d]# cat air.conf 
##
# This is AIR specific configuration file for application sandbox.  It specifies
# directories that are imported "as is" from the real filesystem into the
# sandbox.  This file is managed by YouView and is not to be modified by OEMs.
#
# Note that following directories are already in the sandbox and they are
# "special": 
# /opt/adobe/stagecraft/data
####

[directories]
/opt/stagecraft-2.0
/opt/adobe/stagecraft/fonts
[root@HUMAX application-yv.d]# 


{sandbox-daemon}
https://wiki.youview.co.uk/display/YVDM/Daemon+Sandboxing?src=contextnavpagetreemode

If a daemon requires specific directories in the sandbox and/or specific
capabilities (C11) 'all' daemons share a common configuration file which lists
directories that YouView considers as required to import into the sandbox:


-r--------    1 root     root         427 Jul  3 03:19 daemon-oem.conf
-r--------    1 root     root        2.1K Jul  9 13:43 daemon-yv.conf


# cat /opt/zinc/lib/sandbox/daemon-yv.conf 
##
# This is a common configuration file for daemons sandbox.  It specifies all
# directories that are imported "as is" from the real filesystem into the
# sandbox.  This file is managed by YouView and is not to be modified by OEMs.
#
# Note that following directories are already in the sandbox and they are
# "special":
# /opt/zinc/var (this is completely private - daemons do NOT share var)
# /proc
# /dev
# /tmp
####

[directories]
# system
/lib
/usr/lib
/usr/local/lib
/usr/local/etc

# TODO: Remove
/bin
# TODO: Remove
/usr/bin

# users, groups, networking...
/etc

# YV stack
/opt/zinc/lib
/opt/zinc/share
/opt/zinc/share/platform_data
/opt/zinc/oss/etc
/opt/zinc/oss/lib
/opt/zinc/platform

/opt/zinc/devel/lib
/opt/zinc/devel/share

# TODO: Remove
/opt/zinc/bin
/opt/zinc/devel/bin
# TODO: Remove
/opt/zinc/oss/bin

# If a daemon needs additional directories, they can be specified in a daemon
# specific configuration file: /opt/zinc/lib/sandbox/service-yv.d/<daemon>.conf
# where <daemon> is daemon link name


<specific-daemon>

dr-x------    2 root     root        4.0K Jul  9 13:43 service-oem.d/
dr-x------    2 root     root        4.0K Jun 25 14:17 service-yv.d/

This file should NOT be modified. In order to add daemon specific
directories/capabilities create a configuration file:

Make sure that only root can read it (otherwise sandboxing the daemon may fail).


[root@HUMAX /]# ll /opt/zinc-trunk/lib/sandbox/service-yv.d/            
-r--------    1 root     root          47 Jun 25 14:17 audiofeedbackd.conf
-r--------    1 root     root         126 Jun 25 14:17 avahid.conf
-r--------    1 root     root         119 Jul  8 15:06 babysitterd.conf
-r--------    1 root     root         101 Jun 25 14:17 cobaltmetadatabrokerd.conf
-r--------    1 root     root         192 Jun 25 14:17 dbusbridged.conf
-r--------    1 root     root          35 Jun 25 14:17 devicemanagerd.conf
-r--------    1 root     root         126 Jun 25 14:17 dialserverd.conf
-r--------    1 root     root         251 Jun 25 14:17 linearsourced.conf
-r--------    1 root     root         123 Jun 25 14:17 onscreenidd.conf
-r--------    1 root     root         685 Jun 25 14:17 radiumd.conf
-r--------    1 root     root         132 Jun 25 14:17 sodiumd.conf
-r--------    1 root     root          89 Jul  8 16:20 tunerd.conf
-r--------    1 root     root         322 Jul  8 15:06 uimanagerd.conf


<to-see-outputs-from-daemon-on-console>
add this line to a daemon conf file.

[options]                       
StdOut=/dev/console
StdErr=/dev/console


<to-run-deamon-in-sandbox>
Running yv-daemon-sandbox Daemon in Sandbox

Ideally no daemon should run as root and all of them should be launched using
D-BUS activation. Even if the daemon requires to run as root it should also be
started via D-BUS (see the service files section below).  Service Files

YouView configured the D-BUS in release C11-m4 to launch all services by using
yv-daemon-sandbox setuid helper executable. This requires that every service
file in /opt/zinc/oss/share/dbus-1/services has the User entry even if it's
root, e. g.

# ls -C /opt/zinc/oss/share/dbus-1/services-*

/opt/zinc/oss/share/dbus-1/services-oem:

Zinc.ContentAcquisition.service*
Zinc.DeviceSoftware.service*
Zinc.Media.service*
Zinc.Metadata.service*
Zinc.OEMSystem.service*
Zinc.OEMSystemManager.service*
Zinc.OEMSystemTime.service*
Zinc.RemoteDiagnostics.service*
Zinc.StorageManagement.service*
Zinc.System.service*

/opt/zinc/oss/share/dbus-1/services-yv:

Zinc.Announcement.service*
Zinc.Application.service*
Zinc.ApplicationPackages.service*
Zinc.Audio.service*
Zinc.BabySitter.service*
Zinc.Boot.service*
Zinc.Broker.service*
Zinc.ContentAcquisition.service*
Zinc.Crb.service*
Zinc.Crypto.service*
Zinc.DBusBridge.service*
Zinc.DIAL.service*
Zinc.DeviceAuthority.service*
Zinc.DeviceManager.service*
Zinc.DeviceSoftware.service*
Zinc.LinearSource.service*
Zinc.Media.service*
Zinc.MediaProxy.service*
Zinc.Metadata.service*
Zinc.MetadataProxy.service*
Zinc.OEMSystem.service*
Zinc.OEMSystemManager.service*
Zinc.OEMSystemTime.service*
Zinc.OnScreenId.service*
Zinc.Reminders.service*
Zinc.RemoteDiagnostics.service*
Zinc.System.service*
Zinc.Tuner.service*
Zinc.UsageCollection.service*
lead.Echo.service*
lead.MediaRouter.service*
lead.Metadata.service*
lead.Tuning.service*


[D-BUS Service]
Name=Zinc.Announcement
Exec=/opt/zinc-trunk/bin/copperannouncementd
User=copperannouncementd

If your daemon is completely not ready for running in the sandbox then you may
specify the User entry as User=root. This will 'disable' sandboxing for that
daemon. If you can run your daemon in the sandbox but need to kep root
privileges to set the capabilities and drop privileges in the daemon code then
specify the User entry as your daemon's non-root user name and add KeepRootUser
option to your daemon sandbox configuration files (see the sections above).


{daemon-files}
By default all file system writeable area is not shared between daemons. Hence
/opt/zinc/var and as a consequence /opt/zinc/var/log are 'private' to every
daemon. You can find the private area in /opt/zinc/var/daemons/<daemon name>.

Note that /tmp is not only private but also volatile and removed automatically
when the daemon ceases to exist

note: 
depending on how run daemon, log will be made in different place. If run it as
root like running it on command line, then see /opt/zinc/var/log/nickel.log. If
run is over dbus then see /opt/zinc/var/daemons/<daemon name>/nickel.log

<when-in-sandbox>

/proc/1042/fd

l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:14 10 -> /run/youview/jail/daemons/
   osmiumd-N7HXTA/opt/zinc/var/log/litanium.log
lrwx------    1 osmiumd  osmiumd       64 Feb 16 16:14 11 -> anon_inode:[eventpoll]
lrwx------    1 osmiumd  osmiumd       64 Feb 16 16:14 12 -> anon_inode:[eventfd]
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:04 2 -> /dev/null
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:04 3 -> /run/youview/jail/daemons/
   osmiumd-N7HXTA/opt/zinc/var/log/osmium.log

note: for zinc-trunk
cat /opt/zinc-trunk/var/log/osmium.log

cat /opt/zinc/var/daemons/osmiumd/log/osmium.log


<to-disable-daemon-sandbox>
There is a helper script to additionally disable any sandboxing (both daemons
        and applications):

/opt/zinc-trunk/devel/share/titanium-applicationcontainer-production/switch-sbx.sh.

Invoke it without any arguments to get the usage message. Note that it requires
CDS to be installed on a read-write partition.


{in-zinc}
./Titanium.ApplicationContainer.Production/src/sandbox-drop-privileges.c


<ex>

/proc/1606/root

root# ll
-r--------    1 16385    yv_signe         0 Apr  2 16:49 auxv
--w-------    1 16385    yv_signe         0 Apr  2 16:49 clear_refs
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 cmdline
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 coredump_filter
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:49 cwd -> 
  /run/youview/jail/applications/1
-r--------    1 16385    yv_signe         0 Apr  2 16:49 environ
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:52 exe -> 
  /run/youview/jail/applications/1/opt/zinc-trunk/bin/w3cEngine
dr-x------    2 16385    yv_signe         0 Apr  2 16:52 fd
dr-x------    2 16385    yv_signe         0 Apr  2 16:49 fdinfo
-r--------    1 16385    yv_signe         0 Apr  2 16:49 limits
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 maps
-rw-------    1 16385    yv_signe         0 Apr  2 16:49 mem
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 mountinfo
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 mounts
-r--------    1 16385    yv_signe         0 Apr  2 16:49 mountstats
dr-xr-xr-x    4 16385    yv_signe         0 Apr  2 16:49 net
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 oom_adj
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 oom_score
-r--------    1 16385    yv_signe         0 Apr  2 16:49 pagemap
-r--------    1 16385    yv_signe         0 Apr  2 16:49 personality
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:49 root -> 
  /run/youview/jail/applications/1
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 sched
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 smaps
-r--------    1 16385    yv_signe         0 Apr  2 16:49 stack
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 stat
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 statm
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 status
dr-xr-xr-x   19 16385    yv_signe         0 Apr  2 16:49 task
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 wchan


note: nothing shown.

root# ll /run/youview/jail/applications/1
root# 


However, do cd from /proc/PID/root then shows:

root# cd root
root# ll
drwxr-xr-x    3 radiumd  app_libr      4096 Apr  2 15:56 app
drwx------    3 16385    yv_signe      4096 Apr  2 16:23 app-data
drwxr-xr-x    2 root     root          4096 Mar 31 01:07 bin
drwxr-xr-x    3 root     root          1420 Jan  1  1970 dev
drwxr-xr-x    6 root     root          4096 Apr  1 13:30 etc
drwxr-xr-x    4 root     root          4096 Mar 31 01:07 lib
drwxr-xr-x    6 root     root           120 Apr  2 16:48 mnt
drwxr-xr-x    7 root     root           140 Apr  2 16:48 opt
dr-xr-xr-x  128 root     root             0 Jan  1  1970 proc
drwxr-xr-x    4 root     root            80 Apr  2 16:48 run
drwx------    2 16385    yv_signe      4096 Apr  2 16:49 tmp
drwxr-xr-x    4 root     root            80 Apr  2 16:48 usr
drwxr-xr-x    3 root     root            60 Apr  2 16:48 var


={============================================================================
*kt_dev_uv_stack_351* zinc-sandbox: source 

Titanium.ApplicationContainer.Production/src/yv-daemon-sandbox-util.cpp
163:    cfg.parse(YV_PATH_SBX_DAEMON_CONFIG_FILE_YV);

Titanium.ApplicationContainer.Common/include/path-constants.h
36:char const* const YV_PATH_SBX_DAEMON_CONFIG_FILE_YV  = 
  MACRO__prefix "/lib/sandbox/daemon-yv.conf";


={============================================================================
*kt_dev_uv_stack_450* stack: cobalt

Enhanced metadata (IP sourced) Zinc.Broker 

1050  :1.23                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1050  :1.50                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1050  Zinc.Broker              /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1050  Zinc.MetadataProxy       /opt/zinc-trunk/bin/cobaltmetadatabrokerd


={============================================================================
*kt_dev_uv_stack_500* stack: iron

Linear metadata (Broadcast sourced) Zinc.Metadata 

1288  :1.68                    /opt/zinc/bin/ironmetadatad.oem                 
1288  Zinc.Metadata            /opt/zinc/bin/ironmetadatad.oem                 

{dbus-scripts}
kpark@wll1p04345:~/source/DEVARCH/Iron/Iron.System.Minimal/scripts$ ll
total 24
drwxr-xr-x 2 kpark kpark 4096 Jan  7 15:55 ./
drwxr-xr-x 7 kpark kpark 4096 Jan  7 15:55 ../
-rwxr-xr-x 1 kpark kpark  240 Jan  7 15:55 linearmetadata-findbyprogrammecrid*
-rwxr-xr-x 1 kpark kpark  463 Jan  7 15:55 linearmetadata-getevents*
-rwxr-xr-x 1 kpark kpark  173 Jan  7 15:55 linearmetadata-getservice*
-rwxr-xr-x 1 kpark kpark  165 Jan  7 15:55 linearmetadata-getservicelist*


={============================================================================
*kt_dev_uv_stack_500* zinc-test-web

https://wiki.youview.co.uk/display/canvas/2010/12/01/HTTP+Test+Server?src=search

HTTP Test Server


Added by Milton Mukhopadhyay, last edited by Dave Evans on Jan 18, 2011

I am documenting the original use cases and requirements for the test server
here, but as an 'embeddable' HTTP server might be useful for testing other
components as well, please add additional requirements that we may need to cater
to other use cases.  

Pre-Implementation Stuff: 

Use Cases

  MetadataBroker has Python asynchronous HTTP client implemented with
  pycurl+libcurl. We need to have unit testcases for the component.

  We need to be able to test MetadataBroker against exceptional conditions where
  HTTP server would reply back with different status codes and other errors.  
  
  We need to be able to test the MetadataBroker performance with or without the
  HTTP cache by selectively injecting delays in HTTP server responses.


High Level Requirements

  To have an embeddable HTTP Server.
  It should be possible to programmatically control the HTTP server behaviour.


Low Level Requirements

  To be able to run the server and clients on different threads in the same
  process.

  To be able to serve a request with programmatically specified header fields.
  To be able to serve a request with HTTP response body taken from a string.
  To be able to serve a request with HTTP response body taken from a file.
  To be able to serve a request with programmatically specified HTTP status
  code.

  To be able to inject delay in serving requests for specific URLs.

  It should be possible to use it as HTTP 1.1 file server.

  To be able to serve a body as a series of chunks to verify pause/resume
  download functionality.

  To be able to verify that two HTTP requests are interleaved, possibly by
  chunking. E.g. Deterministically download job1-chunk1, job2-chunk1,
  job1-chunk2, job2-chunk2.


Implementation Decisions

We've decided to use mongoose as the core webserver. Mongoose is a single file,
light weight web server, that can be run directly as a file server or it may
  serve requests through callbacks.

  When serving requests through callbacks it works as a simple listener with a
  thread pool to invoke callbacks.
  
  As a standalone server it works as a HTTP 1.1 compliant file server. 

We need a wrapper for creating HTTP responses from inside test cases. The
wrapper would be responsible for the following :

  Configuring the HTTP server.

  Creating per URL handlers (pity that mongoose does not support per URI
      callbacks anymore, on the other hand the API is quite succinct now.)

  Creating HTTP responses with different kinds of headers, bodies, status codes
  etc.


Implementation Details :

Mongoose :

Mongoose is a single file webserver library with a command line standalone
directory server. I had to pick up the development version of the source as
certain APIs are not yet there in the stable version. So though we are using
Mongoose 3.0, it is yet to be released (I picked the version number from its
    header file). To have it under Zinc.3rdPartyStack , I patched it to make it
an autotool project with proper package config etc.

Wrappers :

We have some wrappers on mongoose to make it possible to use the Http server
programmatically in Zinc.TestWebServer. At the moment this is really like a
framework that supports the usescases mentioned above. I believe we can easily
add more features to it. We can also replace mongoose with any other Http Server
if required as 'mongoose' is completely contained within MongooseWrapper.cpp and
  any other class supporting the contract could be used.  
    

How to use : 

In short, create a configuration object, one or more responder objects and run
the server with the configuration and any number of responders. Whenever the
server gets 'requests' from a Http client the appropriate 'responder' will
respond to it.


A longer desc:

  Create ManualServerConfig object specifying the port on which you want your
  server to run.

  Create a 'responder' where you have the code to 'handle' actual Http requests.
  At the moment we have a convenience responder called SimpleResponder, which
  has methods to add header fields, body etc. so that whenever it gets requests
  from a client it replies back with those fields and content.

  A HttpServer is created with the configuration object and one or more
  responders. You can register a responder against a particular URL or the
  responder could be a 'wildcard' responder with empty string for the URL. A
  wildcard responder is going to be invoked whenever there is no specific
  responder registered for a URL.

  Run the HttpServer. There is a convenient ServerRunner class that uses RAII to
  call the start() and stop() methods on the HttpServer. 

Using TestWebServer in MetadataBroker :

TestWebServer is used in MetadataBroker to simulate MAS behaviour; a new set of
representative testcases are there in MetadataBrokerHttpTests.

Cobalt/Cobalt.System.Production/test/HttpGeneralTests.cpp

In addition to being able to test HTTP client, it has also simplified the
testcase writing process, as :

  For the first time we could proplerly verify MetadataBroker generated URIs and
  query strings ( we dont just have to depend on the directory structure for
      that).

  When using the TestWebServer we dont have to replicate the URL hierarchy. (So
      we dont need to have deeply nested directories with funny file names in
      mas-data anymore.)

TODOs:

  Have a programmatically controllable directory serving responder.
  Have a convenience responder to selectively inject delays before it replies.
  Think of all the other error injection possibilities.
  I need to add more test cases ... at the moment I am banking on the fact that
  since I am writing testcases in MetadataBroker using the testwebserver that
  would in turn test the webserver as well.


https://wiki.youview.co.uk/display/canvas/2011/02/11/HTTP+Test+Server+-+Updated?src=search


={============================================================================
*kt_dev_uv_stack_500* zinc-js: 

First pass at some JS bindings documentation here: https://wiki.youview.co.uk/display/canvas/HOWTO+Create+a+JavaScript+Binding+Project+for+an+Element

https://wiki.youview.co.uk/display/canvas/JavaScript+emporium


={============================================================================
*kt_dev_uv_stack_600* stack: ui

{fail-to-boot}

/opt/zinc-trunk/var/applications/data/air/mainui/log/uranium.log

// log before changes

uranium
/Uranium/Uranium.Client.System/src/tuner/SystemClientLinearPlaybackControl.cpp:275
convertSetVideoWindowExceptions() - Unexpected exception: Launch helper exited
with unknown return code 1


// changed to print calling function using bind()

void convertSetVideoWindowExceptions(const std::string& calling_function,
                                     NS_ZINC::FutureValue< void > fv)
{
    try
    {
        fv.get();
    }
    catch (const NS_NICKEL_SYSTEM::OutOfBounds &)
    {
        URANIUM_ERROR("convertSetVideoWindowExceptions(" << calling_function
                      << ") - Out of bounds");
        throw NS_NICKEL_CLIENT::OutOfBounds();
    }
    catch (const std::exception &e)
    {
        URANIUM_ERROR("convertSetVideoWindowExceptions(" << calling_function
                      << ") - Unexpected exception: " << e.what());
        throw;
    }
}

virtual NS_ZINC::Future< void > minimise()
{
    URANIUM_DEBUG("minimise()");
    return systemLinearPlaybackControl->minimise().then(
        boost::bind(&convertSetVideoWindowExceptions, __FUNCTION__, _1));
}

virtual NS_ZINC::Future< void > maximise()
{
    URANIUM_DEBUG("maximise()");
    return systemLinearPlaybackControl->maximise().then(
        boost::bind(&convertSetVideoWindowExceptions, __FUNCTION__, _1));
}


={============================================================================
*kt_dev_uv_stack_114* stack: build pc target

Unlike cross platform builds, build runs tests and pc target build fails if any test fails.

1. Fail to buile due to failure on tests/cobalt-system-api/test/dateparsingtest

Test name: N6cobalt6system15DateParsingTestE::test_calling_isDaylightSavingTime_with_DST_times

To solve this, need to do:

export TZ="Europe/London"


2. Various failure on some python tests such as Rubidium/Rubidium.System.Production

The reason is that python script has "#!/bin/env python" which expect /bin/env but there is not. So

$ sudo ln -s /usr/bin/env /bin/env

Make a build success.


={============================================================================
*kt_dev_uv_stack_115* stack: text epg

./Uranium.Client.System/src/metadata/tools/textEPG.cpp

https://wiki.youview.co.uk/display/YVFDT/2014/04/09/TextEPG+howto?src=search

TextEPG is a a little text based app that lets you view the schedule data that the UI consumes via
the ctv.enhancedmetadata.EventWindow interface. It can be very useful for debugging. Just type
textEPG on in an ssh/telnet session on the box textEPG

you should then see something like this: text based epg using ncurses

Present events are marked with an asterisk.

You can navigate the window using the WASD keys.  

You can view just DTT, just IP, or merged DTT/IP data (this last is what the UI uses, assuming you
        have accepted T&Cs and have a network connection)

[root@HUMAX /]# textEPG --help
Invalid data source
Usage: textEPG [ip | dtt |stagedip] [<number of services> <number of seconds>]
The numbers specify the dimensions of the epg window.

Other options :

+ / - keys cycle through a subset of the available 'fields' in each event, e.g. title, event
locator, service record identifier.  It a field is missing, then it will need adding in the textEPG
source, see Devarch, or find a book on ncurses.

Running on a read only box

If you get terminal related  error running the textEPG on a read only box, try this first
export TERMINFO=/opt/zinc/oss/share/terminfo

The textEPG was created several years ago (by Jarek in Devarch), as a diagnostic tools to help in
testing/development of the EventWindow API in the CAL, and has not had much love since then. It was
designed to show the schedule data from the CAL, back when that was the main cache of event data
used by the UI. Since the implementation of IP channels, a lot of the event information that was
previously cached in the CAL has moved down to the Unified Event Repository. The textEPG still seems
to work, as it just fetches an EventWindow and renders it in text, but YMMV.

/data/builds/DEVARCH-9135/pc/zinc-install-root/debug/debian-7-x86_64/devel/bin/textEPG

box: /opt/zinc-trunk/devel/bin/textEPG
box: /opt/zinc/devel/bin/textEPG


={============================================================================
*kt_dev_uv_stack_116* stack: future

{futurecontext}

<FCB>
/**
 * This class provides context to a dispatcher about async function calls
 *
 * Intrusively reference counted by Futures, Promises, and FutureDispatchers
 * The intrusive_ptr implementation keeps the size of client facing objects
 * Future<T>, Promise<T>, FutureValue<T>, Chunk<T> small
 *
 */
class ZINC_EXPORT FutureContextBase : boost::noncopyable
{
public:

	virtual ~FutureContextBase();
	virtual bool dispatchNextResult() = 0;

	virtual void dispatchCancellation() = 0;

	/**
	 * Wait for this async op to complete
	 */
	void wait();

	/**
	 * Wait for this async op to complete, with a time out
	 * specified with a time duration
	 *
	 * @see Future<T>::wait_for()
	 */
	template<typename duration_type>
	bool wait_for(const duration_type &rel_time)
	{
		monotonic_clock::time_point abs_time = monotonic_clock::now() + rel_time;
		return wait_until(abs_time);
	}

	/**
	 * Wait for this async op to complete, with a time out
	 * specified with a time point
	 *
	 * @see Future<T>::wait_until()
	 */
	template<typename time_point_type>
	bool wait_until(const time_point_type &abs_time)
	{
		boost::mutex::scoped_lock lock(mutex);
		while (!completed)
		{
			const bool signalled = cond.wait_until(lock, abs_time);
			if (!signalled && !completed)
				return false; // we timed out, without a completion and without a cancellation
		}
		return true;
	}

	/**
	 * Does the moral equivalent to
	 *     dispatcher.post(bind(FutureContextBase::dispatchNextResult, this));
	 *
	 * WARNING: dispatchNextResult may be called synchronously and
	 *          re-entrantly by this function.
	 */
	void scheduleCallback();

	void scheduleCancellationCallback();

protected:

	explicit FutureContextBase(NS_ZINC::FutureDispatcher* dispatcher_);

	/**
	 * Mark this future as having a completion handler
	 *
	 * Must be called with the future locked
	 */
	void markCallback();

public:
	boost::detail::atomic_count refCount;
	boost::detail::atomic_count promiseCount;
public:
	bool completed;
	FutureDispatcher* dispatcher;
	FutureDispatcher* clientDispatcher;
	static boost::condition_variable cond;
	static boost::mutex mutex;
private:
	FutureContextBase(); // forbid default construction
};

FutureContextBase::FutureContextBase(NS_ZINC::FutureDispatcher* dispatcher_) :
	refCount(0),
	promiseCount(0),
	completed(false),
	dispatcher(dispatcher_),
	clientDispatcher(dispatcher_)
{}

<FCCI>
class ZINC_EXPORT FutureContextCommonImpl : public NS_ZINC::FutureContextBase
{
	explicit FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_);

	// The state of the promise and the future can evolve semi-independently
	promise_state::Enum promiseState;
	bool callCancellationCallback;
	boost::function<void ()> cancellationCallback;
};

FutureContextCommonImpl::FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_)
 : FutureContextBase(dispatcher_),
   forDispatch(false),
   futurevalueState(futurevalue_state::value_or_error),
   shouldCallCompletionHandler(true),
   promiseState(promise_state::incomplete),
   callCancellationCallback(true)
{
}

<FC>
/**
 * A context object for Futures
 * FutureContext holds a single value passed from a providing Promise and the client Future
 * and (if set) a completionHandler that is called by the dispatcher when the value is available
 */
template <typename T>
class FutureContext : public FutureContextCommonImpl
{
public:

	explicit FutureContext(NS_ZINC::FutureDispatcher* dispatcher_)
		: FutureContextCommonImpl(dispatcher_)
	{}

	/**
	 * Type specific completion code called from Promise::complete()
	 *
	 * Take a copy of the result from the Promise and stash it in FutureContext,
	 * complete() marks this FutureContext as completed, and post() hands
	 * it over to the dispatcher
	 *
	 * @see FutureContextBase::complete()
	 * @see FutureContextBase::post()
	 */
	void set(const T & result)
	{
		boost::mutex::scoped_lock lock;
		if (runPreSetChecksAndLock(lock)) {
			value = result;
		}
		doPostSetActionsAndUnlock(lock);

      // note: this will post functor to dispatcher thread
      //
      // void FutureContextBase::scheduleCallback()
      // {
      // 	assert(clientDispatcher);
      // 	boost::intrusive_ptr<FutureContextBase> ip(this);
      // 	clientDispatcher->post(boost::bind(&FutureContextBase::dispatchNextResult, ip));
      // 	cond.notify_all();
      // }
	}
	
	template <typename Handler>
	void setCallback(const Handler& fn, FutureDispatcher* clientDispatcher_) {
		setCallbackHoisted(boost::function<void (FutureContextBase*)>(
			makeCallbackHoistingWrapper<T>(boost::bind<void>(fn, _1))),
			clientDispatcher_
		);
	}

	T value;
};


void FutureContextCommonImpl::setCallbackHoisted(boost::function<void (FutureContextBase*)> fn, 
        FutureDispatcher* clientDispatcher_)
{
    // It is safe to read this->clientDispatcher without holding the lock because
    // it is word sized and will only be assigned to at initialisation time and
    // below (where it's guaranteed to be assigned to only once).
    FutureDispatcher* d = clientDispatcher_ ? clientDispatcher_ : this->clientDispatcher;
    if (!d) {
        throw CallbackSetWithoutDispatcherException();
    }
    Dispatcher::work tryWork(*d);

    boost::mutex::scoped_lock lock(this->mutex);

    if (!shouldCallCompletionHandler)
    {
        throw NS_ZINC::CancelledFuture();
    }
    if (forDispatch)
    {
        throw DuplicateFutureCallback();
    }
    // Client can choose an alternate dispatcher when they call setCallback()
    clientDispatcher = d;
    this->work.swap(tryWork);
    completionHandler = fn;
    forDispatch = true; // we are responsible for dispatching the completion handler
    bool oldCompleted = completed;
    lock.unlock();
    if (oldCompleted)
    {
        scheduleCallback();
    }
}


<futurevalue>

class FutureValueBase
{
	friend class internal::PolymorphicFutureValue;

public:

	/**
	 * Retrieve exception as an ErrorCode.
	 *
	 * In the success case, there will be no exception so this method will return
	 * a default-constructed ErrorCode, where the not operator (!) will return true.
	 * So, you can test whether an error occurred by doing:
	 *
	 *     if (!futureValue.getError()) {
	 *         // no error
	 *     }
	 *
	 * @return an ErrorCode wrapper around the exception that occurred in the
	 * asynchronous operation.
	 */
	const ErrorCode& getError() const;

protected:

	explicit FutureValueBase(const boost::intrusive_ptr<detail::FutureContextCommonImpl> & context) ZINC_EXPORT;

	~FutureValueBase() ZINC_EXPORT;

	boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
	detail::futurevalue_state::Enum state;
};


template<>
class FutureValue<void> : public FutureValueBase
{
	friend FutureValue<void> makeFutureValue();
};

// FutureValue_Impl.h

inline FutureValue<void> makeFutureValue()
{
    detail::FutureContext<void>* fc = new detail::FutureContext<void>(NULL);
    FutureValue<void> f(fc);
    fc->set();
    return f;
}


<future>

#ifndef ZINC_FUTURE_H_

template <typename T> class Promise;

namespace detail {
template <typename T> class FutureContext;
}

namespace internal {
class PolymorphicFuture;
}

class Dispatcher;

class FutureBase 
{
    friend class internal::PolymorphicFuture;

    public:

    /**
     * Cancel the Future.
     *
     * This merely prevents the Future ever being fulfilled. If a callback
     * has been set, and not called already, it will not be called.
     *
     * Cancellation may, or may not, cause the underlying asynchronous operation to be
     * canceled. The client should not assume this to be the case.
     *
     * Cancellation may be modified with the flags argument.
     *  * future.cancel(clear_callback) just prevents the
     *    callback set with setCallback from being invoked.
     *  * future.cancel(deep) calls the onCancel handler that may have been
     *    provided promise-side
     *  * future.cancel(immediately) has behaviour equivalent to the Promise
     *    being immediately completed with a CancelledFuture exception.  If the
     *    promise has already been completed calling get() will still cause a
     *    CancelledFuture exception to be thrown.
     *  * future.cancel(0) does nothing.
     */
    void cancel(unsigned flags = cancel_flag::clear_callback |
            cancel_flag::deep |
            cancel_flag::immediately);


    /**
     * Synchronously wait for the value to become available.
     *
     * This will block the calling thread until either the value is available,
     * or an exception occurs.
     *
     * When the caller returns from this call, a subsequent call to get() will not
     * block.
     */
    void wait();

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as a relative time duration
     *
     * eg
     *		Future<int> f = fn_returning_a_future();
     *		f.wait_for(boost::posix_time::milliseconds(500));
     *
     * @param rel_time specifies the time duration to wait for completion
     * @return false if the given time period elapses without completion or cancellation
     * @see wait()
     */
    template<typename duration_type>
        bool wait_for(const duration_type &rel_time);

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as an absolute time point
     *
     * Use wait_for() in preference
     *
     * @param abs_time specifies the time point to stop waiting
     * @return false if we reach the given time point without completion or cancellation
     *
     * @see wait()
     * @see wait_for()
     */
    template<typename time_point_type>
        bool wait_until(const time_point_type &abs_time);


    /**
     * Ask if the Future has been completed with a value provided by its Promise
     *
     * A positive response does not guarantee that the callback has yet been executed
     *
     * @return true if this Future has been completed
     */
    bool isComplete();

    /**
     * Has this Future been default constructed?  If so, then it is not useful
     *
     * @see Future<T>::swap
     * @see Promise<T>::getFuture
     *
     * @return false if this Future is valid
     */
    bool isEmpty();


    protected:

    explicit FutureBase(boost::intrusive_ptr<detail::FutureContextCommonImpl> context) ZINC_EXPORT;

    FutureBase(const FutureBase& other) ZINC_EXPORT;

    FutureBase() {}

    ~FutureBase() ZINC_EXPORT;

    void baseSwap(FutureBase& other);

    boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
};


/**
 * A Future is a token for some value that will be delivered asynchronously.
 *
 * The holder of the Future token may either wait for the value synchronously,
 * (blocking the executing thread), or set a callback method that will be invoked
 * either when the value becomes available, or will not become available due to
 * some exception.
 *
 * The Future holder also has the option to cancel the Future, which will prevent
 * the value from being delivered, assuming this hasn't happened already.
 */
template <typename T>
class Future : public FutureBase
{
    public:
        typedef T value_type;

        Future(const Future & other);

        Future & operator=(const Future & other);

        ~Future();

        /**
         * Provide a default constructor so we can put Futures in
         * STL containers
         *
         * A Future without a Promise is not much use to you,
         * so use Promise.getFuture() instead, or use swap(Future<T> & other)
         * to swap in a valid future
         *
         * @see Promise<T>::getFuture()
         * @see Future<T>::swap(Future<T> & other)
         */
        Future() {}

        /**
         * Set a callback method to be invoked when either the value becomes
         * available, or an exception occurs.
         *
         * The callback will be executed on the dispatcher that was provided to
         * the Promise constructor.
         *
         * @param fn A function that must accept a FutureValue<T> as it's single
         *           argument.
         *
         * @throws DuplicateFutureCallback if a callback has already been set on
         * this Future.
         * @throws CallbackSetWithoutDispatcherException if the corresponding
         *         wasn't initialized with a dispatcher.  Use the two argument
         *         setCallback instead
         */
        template <typename Handler>
            void setCallback(const Handler& fn) {
                // fn(x) must be valid where x is a FutureValue<T>
                ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
                static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, 0);
            }

        /**
         * Set a callback method to be invoked when either the value becomes
         * available, or an exception occurs.
         *
         * The callback will be executed on the provided dispatcher, rather than the
         * dispatcher used by the Promise.
         *
         * Explicitly providing the dispatcher gives the caller more control over
         * which thread will execute their callback.
         *
         * @param dispatcher_ The dispatcher on which the callback should be executed.
         *
         * @param fn A function that must accept a FutureValue<T> as it's single
         *           argument.
         *
         * @throws DuplicateFutureCallback if a callback has already been set on
         * this Future.
         */
        template <typename Handler>
            void setCallback(Dispatcher& dispatcher_, const Handler& fn) {
                // fn(x) must be valid where x is a FutureValue<T>
                ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
                static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, &dispatcher_);
            }

        /**
         * then() allows specifying a Functor to be called once the Future is
         * completed.  It is much like Future.setCallback() but for a Future<T> if
         * the functor has the form:
         *
         *     R Functor(FutureValue<T>)
         *
         * then then() will return a new Future of type Future<R> which will be
         * completed when the original Future completes and the functor has
         * operated on the original value.  The value/exception contained in the
         * new future will be that returned/thrown from the functor.  This makes
         * then() very convenient for transforming the value (and potentially the
         * type) contained within a `Future`.
         *
         * If a dispatcher is provided the functor will be executed on that
         * dispatcher.  Otherwise it will be run inline at the point and in the
         * context in which the `Promise` is completed or the setCallback is set
         * (whichever comes later).  As the environment in which the functor will
         * be run is unknown and even non-deterministic it is only safe to do the
         * simplest pure-functional transformations in these functors, e.g.
         * translating between exceptions/enum types, etc.  Anything dependent on
         * some state may require locking a mutex of similar and to make it
         * deterministic, safe and to avoid unexpected failures as changes are
         * made to other parts of the code the callbacks should be run on a user
         * specified `Dispatcher`.
         *
         *`Future.then()` is a proposed addition to the C++14 standard[1].
         *
         * [1]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3558.pdf
         *
         * Usage Example:
         *
         * @code
         * string boolToYesNo(FutureValue<bool> b) {
         *     try {
         *         return (b.get()?"yes":"no");
         *     } catch (const std::exception& e) {
         *         // translating exception thrown from original future.
         *         throw MyNewException(e.what());
         *     }
         * }
         *
         * Future<bool> answer = isCool();
         *
         * Future<string> answerAsString = answer.then(&boolToYesNo);
         *
         * cout << "Cool? " << answerAsString.get() << endl;
         * @endcode
         */
        template<typename Functor>
            Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
                    Dispatcher& dispatcher, Functor transformRtoT);
        template<typename Functor>
            Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
                    Functor transformRtoT);

        /**
         * Synchronously wait for and retrieve the value.
         *
         * This method may throw an exception of any type, in the event that the
         * value could not be retrieved due to an exception in the asynchronous
         * operation producing the value.
         *
         * Equivalent to f.getFutureValue().get();
         *
         * @return the value.
         */
        typename const_return<T>::type get();

        /**
         * Synchronously wait for and retrieve the value.
         *
         * Unlike get() this method does not throw if the promise has been completed
         * with an exception.  This can be used to deal with errors without a try
         * catch block.
         *
         * @return the value.
         */
        FutureValue<T> getFutureValue();

        /**
         * Swap this Future with the one provided
         */
        void swap(Future<T> & other);

    private:
        friend class Promise<T>; // only Promises can create a Future
        explicit Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ );

};

#endif


<future-impl>
#ifndef ZINC_FUTURE_INL

NS_ZINC_OPEN

inline void FutureBase::wait()
{
	context->wait();
}

template<typename duration_type>
inline bool FutureBase::wait_for(const duration_type &rel_time)
{
	return context->wait_for(rel_time);
}

template<typename time_point_type>
inline bool FutureBase::wait_until(const time_point_type &abs_time)
{
	return context->wait_until(abs_time);
}

inline bool FutureBase::isComplete()
{
	return context->completed;
}

inline bool FutureBase::isEmpty()
{
	return (context.get() == NULL);
}

inline void FutureBase::cancel(unsigned flags)
{
	context->cancel(flags);
}

inline void FutureBase::baseSwap(FutureBase& other)
{
	using std::swap;
	swap(context, other.context);
}


/**
 * Generic Future definitions
 */

template<typename T>
inline Future<T>::Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ ) : FutureBase(boost::static_pointer_cast<detail::FutureContextCommonImpl>(context_)) {}

template<typename T>
inline Future<T>::Future(const Future<T>& other) : FutureBase(other) {}

template<typename T>
inline Future<T>::~Future() {}

template<typename T>
inline Future<T>& Future<T>::operator=(const Future<T>& other)
{
	Future<T>(other).swap(*this);
	return *this;
}

template<typename T>
inline FutureValue<T> Future<T>::getFutureValue()
{
    wait();
    return FutureValue<T>(boost::static_pointer_cast<detail::FutureContext<T> >(context));
}

template<typename T>
inline typename const_return<T>::type Future<T>::get()
{
	return getFutureValue().get();
}

template<typename T>
inline void Future<T>::swap(Future<T> & other)
{
	 baseSwap(other);
}

/**
 * Future<void> definitions
 */
template<>
inline void Future<void>::get()
{
	wait();
	// get() may throw
	FutureValue<void>(boost::static_pointer_cast<detail::FutureContext<void> >(context)).get();
}

namespace detail {

template<typename T, typename R, typename Functor>
struct DoTransformAndComplete {
    static inline void apply(Promise<R>& promise, Functor& transform, const FutureValue<T>& fv) {
        promise.complete(transform(fv));
    }
};

template<typename T, typename Functor>
struct DoTransformAndComplete<T, void, Functor> {
    static inline void apply(Promise<void>& promise, Functor& transform, const FutureValue<T>& fv) {
        transform(fv);
        promise.complete();
    }
};

template<typename T, typename Functor>
struct TransformAndComplete {

    typedef typename boost::result_of<Functor(FutureValue<T>)>::type R;

    TransformAndComplete(const Functor& f)
     : transform(f) {}

    void operator()(const FutureValue<T>& fv) {
        try {
            DoTransformAndComplete<T, R, Functor>::apply(promise, transform, fv);
        } catch (const std::exception& e) {
            promise.exception(e);
        } catch (...) {
            promise.exception(std::runtime_error("Unknown exception."));
        }
    }

    Promise<R> promise;
    Functor transform;
};

template<typename FutureLike, typename Functor>
Future<typename boost::result_of<Functor(FutureValue<typename FutureLike::value_type>)>::type> futureThen(
        FutureLike& future, Dispatcher& dispatcher, Functor transformTtoR) {

    detail::TransformAndComplete<typename FutureLike::value_type, Functor>
        transformAndComplete(transformTtoR);
    future.setCallback(dispatcher, transformAndComplete);
    return transformAndComplete.promise.getFuture();
}
} // namespace detail

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Dispatcher& dispatcher, Functor transformTtoR) {

    return detail::futureThen(*this, dispatcher, transformTtoR);
}

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Functor transformTtoR) {

    return then(InlineDispatcher::sharedInstance(), trantsformTtoR);
}                                                       i
                                                        {
#endif                                                   
                                                        }


={============================================================================
*kt_dev_uv_stack_117* stack: future use

<0> promise and future creation

EPG uses this:
Package ctv.enhancedmetadata, Interface public interface EventRepository::getEventWindow

Future<boost::shared_ptr<EventWindow> > SystemClientEventRepository::getEventWindow(
        uint32_t startingServiceRow, uint32_t serviceCount,
        boost::posix_time::ptime startTime, int32_t seconds,
        event_collection_ptr intersectingEvents, Bounds missing,
        bool isMovingForward)
{
    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > p(*getFutureDispatcher());

    // explicit Promise(Dispatcher& dispatcher_);
    //
    // template<typename T>
    // inline Promise<T>::Promise(FutureDispatcher& dispatcher_) :
    //
    //   // note: 'new' FC
    //   PromiseBase( new detail::FutureContext<T>(&dispatcher_) )
    //   {}
    //
    // boost::intrusive_ptr<detail::FutureContextCommonImpl> context;
    //
    // PromiseBase::PromiseBase(detail::FutureContextCommonImpl* p)
    //  : context(p)
    // {
    //   // note: get is member of intrusive_ptr
    // 	if (context.get())
    // 	{
    // 		++context->promiseCount;
    // 	}
    // }

    getEventsFromSystemAPI(cmd);

    return p.getFuture();

    // note: ?? since there seems no Future<T>(FC&). HOW?
    //
	 // Future(const Future & other);
    //
    // template<typename T>
    // inline Future<T> Promise<T>::getFuture()
    // {
    // 	return Future<T>(&getContext());
    // }
    //
    // note: return a reference
    //
    // template<typename T>
    // inline detail::FutureContext<T>& Promise<T>::getContext()
    // {
    // 	return  *static_cast< detail::FutureContext<T>* >(context.get());
    // }
}


<1> call dbus call, set callback with dbus call future, and add future and callback pair to future
barrier. does it mean that FB copies future since fMasEvents is local?

void SystemClientEventRepository::getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
{
    NS_ZINC::FutureBarrier bar(*getFutureDispatcher());

    // 'cobalt' callback
    void (SystemClientEventRepository::*masCallback)
        (boost::shared_ptr<EventWindowCreateCommand>,
         const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result > > &) =
        &SystemClientEventRepository::eventsReceived;

    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
        metadataBroker->getEventSummariesByServices(recids, start, end);

    bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));
}


<2> when future is signaled from dbus

::FutureBar    <- from components on dbus?


<3> calls registered callback from FB.

void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
        const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
{
    // get reference of vector from a future   
    const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();
}


={============================================================================
*kt_dev_uv_stack_130* stack: links with 3rd parties. cppunit, gmock and so on

-DMACRO__pkgdatadir=\"/opt/zinc/share/uranium-client-system\" -m32 -I/opt/zinc/include  -isystem
/opt/zinc/oss/include  -D_FORTIFY_SOURCE=2  -fstack-protector-all   -m32 -DNDEBUG -O3 -pipe -pthread
-march=i686 -Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
-Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format -Werror=missing-braces
-Werror=nonnull -Werror=parentheses -Werror=pointer-sign -Werror=return-type -Werror=sequence-point
-Werror=strict-overflow=1 -Werror=trigraphs -Werror=unknown-pragmas -Werror=unused-function
-Werror=unused-label -Werror=unused-value -Werror=volatile-register-var -fdiagnostics-show-option
-Werror=uninitialized  -MT SummaryTest.o -MD -MP -MF $depbase.Tpo -c -o SummaryTest.o
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Uranium/Uranium.Client.System/test/metadata/SummaryTest.cpp
&&\


/bin/sh ../../libtool  --tag=CXX   --mode=link i686-pc-linux-gnu-g++  -m32 -DNDEBUG -O3 -pipe
-pthread  -march=i686 -Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
-Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format -Werror=missing-braces
-Werror=nonnull -Werror=parentheses -Werror=pointer-sign -Werror=return-type -Werror=sequence-point
-Werror=strict-overflow=1 -Werror=trigraphs -Werror=unknown-pragmas -Werror=unused-function
-Werror=unused-label -Werror=unused-value -Werror=volatile-register-var -fdiagnostics-show-option
-Werror=uninitialized  -rdynamic -L/opt/zinc/lib -L/opt/zinc/oss/lib -Wl,--as-needed
-Wl,-rpath-link,/opt/zinc/lib -Wl,-rpath-link,/opt/zinc/oss/lib -o summarytest SummaryTest.o
helpers/SynchronisableDispatcher.o helpers/TestSupport.o ../../src/libUraniumClientSystemStatic.la
-L/opt/zinc/lib -L/opt/zinc/oss/lib 

-lboost_date_time 
-lboost_filesystem 
-lboost_system 
-lboost_program_options 
-lboost_thread 
-lboost_iostreams 

-llog4cplus 

-ldl 
-lboost_thread 
-llog4cplus
-ldbus-c++-1 
-ldbus-1 
-ldbus-c++-testsupport-1 

-lCadmiumSystemAPI 

-lUraniumClientAPI -lUraniumCommon

-lCobaltCommon 

-lCopperSystemDbus -lCopperSystemAPI 

-lIronSystemAPI -lIronRemindersSystemAPI -lIronRemindersSystemDbus -lIronRemindersSystemAPI

-lNeonClientSystem -lNeonClientApi -lNeonSystemAPI 

-lNickelSystemAPI 

-lZincCommonTestRunner
-lcppunit 
-lZincCommonTestSupport 
-lZincCommon 
-lZincDbusBindingTestSupport -lZincDbusBindingRuntime -lZincCommon -ldl
-lcppunit 
-lgmock -lgtest


={============================================================================
*kt_dev_uv_stack_150* stack: network

The dbus log when plug out and then plug in a cable

# dbus-monitor "interface=org.freedesktop.NetworkManager.Device.Wired 

Tue 2015-02-17 14:32:27 GMT
[17-02-2015 14:32:27.880473] signal sender=org.freedesktop.DBus -> dest=:1.80 serial=2 path=/org/freedesktop/DBus; interface=org.freedesktop.DBus; member=NameAcquired
   string ":1.80"
Feb 17 14:32:44 syslog[785]: <info> (eth0): carrier now OFF (device state 8)
Feb 17 14:32:44 syslog[785]: <info> (eth0): device state change: 8 -> 2 (reason 40)
Feb 17 14:32:44 syslog[785]: <info> (eth0): deactivating device (reason: 40).
eth0 Link DOWN.
Feb 17 14:32:44 syslog[785]: <info> (eth0): canceled DHCP transaction, DHCP client pid 815
[17-02-2015 14:32:44.579382] signal sender=:1.0 -> dest=(null destination) serial=204 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Carrier"
         variant             boolean false                  note: OFF
      )
      dict entry(
         string "State"
         variant             uint32 2
      )
      dict entry(
         string "Dhcp4Config"
         variant             object path "/"
      )
      dict entry(
         string "Ip6Config"
         variant             object path "/"
      )
      dict entry(
         string "Ip4Config"
         variant             object path "/"
      )
   ]
eth0 cable unplugged, powering down
eth0 cable plugged in, powering up
eth0 Link UP.
Auto config phy
eth0: Link is up, 100 Mbps Full Duplex
Feb 17 14:33:05 syslog[785]: <info> (eth0): carrier now ON (device state 2)
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 2 -> 3 (reason 40)
[17-02-2015 14:33:05.661158] signal sender=:1.0 -> dest=(null destination) serial=209 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Carrier"
         variant             boolean true          note: ON
      )
      dict entry(
         string "State"
         variant             uint32 3
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) starting connection 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6'
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 3 -> 4 (reason 0)
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) started...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) starting...
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 4 -> 5 (reason 0)
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) successful.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) scheduled.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) started...
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 5 -> 7 (reason 0)
[17-02-2015 14:33:05.685977] signal sender=:1.0 -> dest=(null destination) serial=214 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Beginning DHCPv4 transaction (timeout in 1073741823 seconds)
   array [
      dict entry(
         string "State"
         variant             uint32 4
      )
   ]
[17-02-2015 14:33:05.701563] signal sender=:1.0 -> dest=(null destination) serial=218 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 5
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> dhclient started with pid 1546
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) complete.
[17-02-2015 14:33:05.708832] signal sender=:1.0 -> dest=(null destination) serial=220 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 7
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> (eth0): DHCPv4 state changed nbi -> preinit
Feb 17 14:33:05 syslog[785]: <info> (eth0): DHCPv4 state changed preinit -> reboot
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) started...
Feb 17 14:33:05 syslog[785]: <info>   address 172.20.35.27
Feb 17 14:33:05 syslog[785]: <info>   prefix 20 (255.255.240.0)
Feb 17 14:33:05 syslog[785]: <info>   gateway 172.20.32.1
Feb 17 14:33:05 syslog[785]: <info>   nameserver '127.0.0.1'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.34.223'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.34.224'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.35.66'
Feb 17 14:33:05 syslog[785]: <info> Scheduling stage 5
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Done scheduling stage 5
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) started...
[17-02-2015 14:33:05.932824] signal sender=:1.0 -> dest=(null destination) serial=222 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Dhcp4Config"
         variant             object path "/org/freedesktop/NetworkManager/DHCP4Config/1"
      )
   ]
Feb 17 14:33:06 syslog[785]: <info> (eth0): device state change: 7 -> 8 (reason 0)
Feb 17 14:33:06 syslog[785]: <info> Policy set 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6' (eth0) as default for IPv4 routing and DNS.
Feb 17 14:33:06 syslog[785]: <info> Activation (eth0) successful, device activated.
Feb 17 14:33:06 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) complete.
[17-02-2015 14:33:07.009626] signal sender=:1.0 -> dest=(null destination) serial=230 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 8
      )
      dict entry(
         string "Ip4Config"
         variant             object path "/org/freedesktop/NetworkManager/IP4Config/1"
      )
   ]
Feb 17 14:33:56 syslog[785]: <info> Trying to start the supplicant...


={============================================================================
*kt_dev_uv_stack_200* commands

# what?
root# setItem platform.settings.enable-ipcrb 1

# log?
tail -f /opt/zinc/var/daemons/crbd/log/helium.log


How to Introspect DBus from the Command Line
https://wiki.youview.co.uk/display/canvas/How+to+Introspect+DBus+from+the+Command+Line?src=search
# to see messages on dbus
root# dbus-monitor "interface=Zinc.Application.ApplicationManager"

# what is it? LSR?
root# getChildItems oem

LD_PRELOAD=/usr/local/lib/libdirectfb.so:/usr/local/lib/libdirect.so:/usr/local/lib/libinit.so gst-launch-1.0 souphttpsrc location=http://54.225.86.153/INT01_LCN_551.sdp ! vqesdpdemux caps=video/mpegts ! queue ! tsnexusbin 

#
root# cat /opt/ui/ui.txt 
ui revision-846ef89 version-F26.8.0-RC1root# 

root# ls /opt/zinc-trunk/share/Zinc.Binaries.*


={============================================================================
*kt_dev_uv_wiki_001* dbus-monitor-spy

{dbus-spy}
https://wiki.youview.co.uk/display/YVDP/How+to+inspect+MediaRouter+activity
This is a python script and run on the box.

MediaRouter Dbus Spy is a tool that prints all the MediaRouter dbus communications in a more
readable format than the raw output. It also reports when a new application is launched or killed
and any MediaRouter crash.

https://wiki.youview.co.uk/pages/viewpage.action?pageId=75305458


dbus-monitor.oem


={============================================================================
*kt_dev_uv_wiki_002* wiki: netflix account

https://wiki.youview.co.uk/display/testautomation/Netflix+accounts?src=search


={============================================================================
*kt_dev_uv_oem_001* oem-box-hwei:

From the release, follow the step 3:

https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Huawei+DN370T+PVR1+B37SP11

3. Boot from HDD

From SSH or the serial console run the following command:

mkdir -p /mnt/nand/userdata/data && echo "rw" > /mnt/nand/userdata/data/rw_cmd

The next boot will take slightly longer than normal as the files are copied from
nand to the harddisk.


{hwei}
TestHw123 (Huawei)

huawei-04877 huawei-04877.dev.youview.co.uk  172.20.33.192  20:F3:A3:70:D1:94

<1>
if delete this, then will boot from flash
/mnt/nand/userdata/data/rw_cmd


<370-PVR1>
sudo apt-get install huawei-dn370t-toolchain
sudo apt-get install huawei-dn370t-staging
sudo apt-get install huawei-stbgcc-4.5.3-2.4

note: this will picks up the correct file from the link below.
http://devarch-deb.dev.youview.co.uk:8080/job/DEBs/ws/DEBS/

huawei-dn370t-toolchain_20120927-2_i386.deb
huawei-dn370t-nexus_20131104-2_i386.deb
huawei-dn370t-staging_20140804-2_i386.deb

https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Huawei+DN370T+PVR1+B37SP11

ZB_CFG=huawei.370 zb-make


<372-PVR2>

sudo apt-cache search dn372

huawei-dn372t-toolchain - Toolchain for HUAWEI DN372T set-top box
huawei-dn372t-staging - Staging environment for Huawei DN372T set-top box

ZB_CFG=huawei.372 zb-make


={============================================================================
*kt_dev_uv_oem_001* oem-box-hmax: burning

{hmax} 
onlydebug (Humax)

||Hostname||FQDN||IP Address||MAC Address||
humax-0873   humax-0873.dev.youview.co.uk    172.20.35.27   00:03:78:4B:7A:2B

/.ssh -> /var/tmp/authorized_keys


{hmax-flash}

note: when flash binary, wipes out hdd rfs as well and need to download hdd rfs
again.

1. Back to boot from flash and see if it works fine.

unsetenv KERNEL_OPT
unsetenv BOOT
unsetenv IFCONFIG


2. Install the rootfs onto HDD, type the following commands via SSH or serial
from the root@HUMAX command prompt:

cd /mnt/hd1 &&
wget http://devnfs2.dev.youview.co.uk/HUMAX/H23.1.0/T2100/scripts/humax-hdd-install.sh -O humax-hdd-install.sh &&
chmod +x humax-hdd-install.sh
./humax-hdd-install.sh -s -r H23.1.0 &&
reboot -f

// from script
===> Downloading dtrt2100_atk_nfsroot-root_release_12123.tar.gz to /tmp
+ wget -q -P /tmp http://devnfs2.dev.youview.co.uk/HUMAX/H23.1.0/T2100/rootfs/
    dtrt2100_atk_nfsroot-root_release_12123.tar.gz


<to-check-nfs>
http://devnfs2.dev.youview.co.uk/HUMAX/

This script writes the rootfs to the HDD and copies the UI from NAND 

Set booting from HDD (read-write rootfs)

Boot to the CFE prompt by holding down the 'down' arrow on your keyboard over
serial. At the CFE> prompt type the following commands:

setenv -p KERNEL_OPT "root=/dev/sda1 rw"
reboot


as of Wed Oct 14 15:39:00 BST 2015
   _______________________________________________________ 
  | Box Details                                           |
  |                                                       |
  |                 OEM NAME : Humax
  |                    Model : DTRT2100
  |              System Type : BCM7429B0
  |                 Hostname : humax-04535
  |               IP Address : 172.20.32.153
  | This box is running from : unkown
  |_______________________________________________________|
  | Current versions (based on current boot method: unkown)
  |                                                        
  |    Current Humax Release : H23.5.0
  |               Current UI : F27.7.0-RC1 Rev: 7b027ea
  |     Platform Config (ui) : 1507
  |  Current CCO Environment : int01
  |_______________________________________________________|
  | Versions on next boot (based on HardDisk data)
  |                                                        
  |     Humax Release on HDD : H23.5.0
  |                   New UI : F27.7.0-RC1 Rev:7b027ea
  |     Platform Config (ui) : 1507
  |          CCO Environment : int01
  |               LSR Status : LSR successfully removed.
  |_______________________________________________________|


={============================================================================
*kt_dev_uv_oem_001* oem-box: staging and toolchanis

https://wiki.youview.co.uk/display/canvas/OEM+Staging+and+Toolchains?src=search

.
|-- adobe
|   `-- stagecraft
|-- Adobe
|   |-- Flex4SDK -> flex_sdk_4.1.0.16076_with_air_sdk_2.5_linux
|   `-- flex_sdk_4.1.0.16076_with_air_sdk_2.5_linux
|-- HipChat
|   |-- bin
|   |-- lib
|   `-- share
|-- oem-staging            // note: it does have headers or possibly sources
|   |-- huawei-bcm7409
|   |-- huawei-dn370t -> huawei-bcm7409
|   |-- humax-dtr_t1000
|   `-- oem-staging.md5
|-- pac
|   |-- lib
|   |-- LICENSE
|   |-- pac
|   |-- README
|   |-- res
|   `-- utils
|-- stagecraft-2.0 -> stagecraft-2.5.2.3.20120105-sl6-directfb1.4-windowed
        -C12M2-maine_coon-release-20120518
|-- stagecraft-2.5.2.3.20120105-sl6-directfb1.4-windowed
      -C12M2-maine_coon-release-20120518
|   |-- bin
|   `-- share
`-- toolchains
    |-- generic-stbgcc-4.4.5-2.0
    |-- huawei-bcm7409 -> generic-stbgcc-4.4.5-2.0
    |-- huawei-stbgcc-4.5.3-2.4
    |-- humax-dtr_t1000 -> generic-stbgcc-4.4.5-2.0
    `-- humax-stbgcc-4.5.3-2.4

/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409
drwxr-xr-x 4 kpark kpark 4096 Feb  3 08:06 opt/
lrwxrwxrwx 1 kpark kpark   35 Jan 30 08:28 usr -> /opt/oem-staging/huawei-bcm7409/usr/

<refsw>
The refsw headers from staging:
/opt/oem-staging/huawei-bcm7409/usr/local/refsw/nexus

This is copied to build root to be used in building and these are the same:
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/refsw/nexus

<oem-code>
The OEM header files: note: this means that if changes OEM code and want to
build any in the full stack build env, then need to update staging as well
before building.

/opt/oem-staging/huawei-bcm7409/
./usr/local/include/nexusMgr/nexusMgr.h
./usr/local/include/nexusMgr/nexusMgr.c
./usr/local/lib/nexusMgr.h
./usr/local/lib/pkgconfig/nexusMgr.pc

For example, inspect tool and this is link option: path when build inspect tool
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib


https://wiki.youview.co.uk/display/canvas/OEM+Staging+and+Toolchains?src=search

$ sudo apt-get install huawei-dn372t-staging
$ sudo apt-get install huawei-dn372t-toolchain

$ sudo apt-cache search t2100         
humax-dtr-t2100-nexus - Nexus headers and .inc files for HUMAX DTR-T2100 set-top box
humax-dtr-t2100-staging - Staging environment for HUMAX DTR-T2100 set-top box
humax-dtr-t2100-toolchain - Toolchain for HUMAX DTR-T2100 set-top box

humax-dtr-t1000-toolchain - Toolchain for HUMAX DTR-T1000 set-top box
humax-dtr-t1000-staging - Staging environment for HUMAX DTR-T1000 set-top box

http://devarch-deb.dev.youview.co.uk:8080/job/DEBs/ws/pool/main/h

$ wget http://devarch-deb.dev.youview.co.uk:8080/job/DEBs/ws/pool/main/h/huawei-dn372t-staging/huawei-dn372t-staging_20150427-5_i386.deb
$ sudo dpkg -i huawei-dn372t-staging_20150427-5_i386.deb


<pkg-config>
drwxr-xr-x 3 root root     4096 Apr 29 15:06 huawei-bcm7231/
drwxr-xr-x 3 root root     4096 Apr 24 12:28 huawei-bcm7409/
drwxr-xr-x 3 root root     4096 May 18 12:47 huawei-bcm7409-20150427-3/
drwxr-xr-x 3 root root     4096 May 18 12:23 huawei-bcm7409-for-nexus-release-eng-rel/
lrwxrwxrwx 1 root root       14 May 18 13:07 huawei-dn370t -> huawei-bcm7409/

$PKG_CONFIG_PATH uses "huawei-bcm7409" rather than a sym link


/opt/oem-staging/humax-dtr_t2100/usr$ find . -name *.pc

./local/lib/pkgconfig/axis2c.pc
./local/lib/pkgconfig/nexus-mgr.pc
./local/lib/pkgconfig/wasabi.pc
./local/lib/pkgconfig/directfb.pc
./local/lib/pkgconfig/direct.pc
./local/lib/pkgconfig/nexusMgr.pc
./local/lib/pkgconfig/uuid.pc
./local/lib/pkgconfig/fusion.pc
./local/lib/pkgconfig/directfb-internal.pc
./local/lib/pkgconfig/sawman.pc
./local/lib/pkgconfig/nexus.pc

note:
Should be in zb-shell

$ pkg-config --libs nexusmgr


={============================================================================
*kt_dev_uv_oem_001* zinc-jira: deploy the prebuilt binary

<when-use-built-release>
http://spongebob.dev.youview.co.uk:8080/job/Deploy_Candidate_Releases_on_STB/

// from logs
11:22:47 + rm -rf zinc-trunk

11:23:25 + rm -f zinc-production-stack-humax-dtr_t2100-master-2eefdc0-20150628-2332-release.tar.gz
11:23:25 + mkdir C27.1.0-RC1-production-temp
11:23:25 + wget http://devnfs2.dev.youview.co.uk/DEVARCH/C27.1.0/RC1/HUMAX/humax-dtr_t2100/release/zinc-trunk//zinc-production-stack-humax-dtr_t2100-master-2eefdc0-20150628-2332-release.tar.gz
11:23:25 Connecting to devnfs2.dev.youview.co.uk (172.20.34.3:80)

11:23:26 zinc-production-stac  74% |***********************        | 43852k  0:00:01 ETA
zinc-production-stac  93% |*****************************  | 55240k  0:00:00 ETA
zinc-production-stac 100% |*******************************| 58773k  0:00:00 ETA
11:23:31 + tar xzf zinc-production-stack-humax-dtr_t2100-master-2eefdc0-20150628-2332-release.tar.gz -C C27.1.0-RC1-production-temp

11:24:02 + mv C27.1.0-RC1-production-temp/opt/zinc-trunk C27.1.0-RC1-production
11:24:02 + ln -s C27.1.0-RC1-production zinc-trunk
11:24:02 + rm -r C27.1.0-RC1-production-temp
11:24:02 
11:24:02 [0;32mRunning patch-a-tron on box

11:24:02 (B[mpatchOptZinc()
11:24:03 Patching /opt/zinc/bin/CopperDownloader ...
11:24:03 Patching /opt/zinc/bin/airlauncher.sh ...
11:24:03 Patching /opt/zinc/bin/audiofeedbackd ...
11:24:03 Patching /opt/zinc/bin/avahi-launcher ...
11:24:03 Patching /opt/zinc/bin/babysitterd ...
11:24:03 Patching /opt/zinc/bin/cobaltmetadatabrokerd ...
11:24:03 Patching /opt/zinc/bin/copperannouncementd ...
11:24:03 Patching /opt/zinc/bin/copperlocalstoragerepod ...
11:24:03 Patching /opt/zinc/bin/crbd ...


note:
Going back from RC or prebuilt deploy to own zb-deploy do not seem to work well.
Did the root fs again.


={============================================================================
*kt_dev_uv_oem_001* nexusmgr

{inspect}
used in wrapper:

/bin/nexus-inspect -r -p "${parent_pid}"


{mgr-interface}
nexusMgr interfaces:

BcmNexus_Audio_Mixer_Register(NEXUS_AudioMixerHandle hMixer)
BcmNexus_Audio_Mixer_Unregister(void)
BcmNexus_Graphics_Resources_Acquire(BcmNexus_Graphics_Resources_Config *)
BcmNexus_Graphics_Resources_Release(const BcmNexus_Graphics_Resources *)
BcmNexus_ImageDecoder_Resources_Acquire(const BcmNexus_ImageDecoder_Resources_Config *)
BcmNexus_ImageDecoder_Resources_Release(const BcmNexus_ImageDecoder_Resources *)
BcmNexus_Input_Resources_Acquire(const BcmNexus_Input_Resources_Config *)
BcmNexus_Input_Resources_Release(const BcmNexus_Input_Resources *)
BcmNexus_Key_Last_Key_Timestamp(void)
BcmNexus_Platform_Init(void)
BcmNexus_Platform_Uninit(void)
BcmNexus_Screen_Capture(void)
BcmNexus_SetMixerPath(NEXUS_AudioMixerHandle hmixer, const BcmNexus_StreamPlayer_Resources *resources)
BcmNexus_Set_Last_Key_Timestamp(void)
BcmNexus_SoundOutput_Resources_Acquire(const BcmNexus_SoundOutput_Resources_Config *)
BcmNexus_SoundOutput_Resources_Release(const BcmNexus_SoundOutput_Resources *)
BcmNexus_SoundOutput_SetVolume(BcmNexus_SoundOutput_Volume, unsigned)
BcmNexus_StreamPlayer_Resources_Acquire(const BcmNexus_StreamPlayer_Resources_Config *)
BcmNexus_StreamPlayer_Resources_Avaiable(void)
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *)
BcmNexus_UnSetMixerPath(NEXUS_AudioMixerHandle hmixer, const BcmNexus_StreamPlayer_Resources *resources)


{shm}
<from-inspect>
// return true if no shared mem opens or destroied it successfully. so no process owns it
static bool do_platform_init(size_t shMemSz);

<release>
// this is done when option "-r" is on
static void releaseNexusResources( BcmNexus_Shared_Memory *shmem )
{
  shmem->resource_pid = getpid();
  printf( "Reset resource_pid\n" );
  /* set callback to NULL */

  // <out> commented out since no support from HWEI
  // resetDimmingSetting(shmem);
  // {
  //  NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindow, &picture_settings );
  // }

  NEXUS_VideoDecoder_Stop( shmem->videoDecoder );
  NEXUS_AudioDecoder_Stop( shmem->audioDecoder[0] );

  // <out> commented out since no support from HWEI
  // for (uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  // {
  //   // stopPlayPump( shmem->playpump[i] );
  //   {
  //     NEXUS_PlaypumpSettings playpump_settings;
  //     NEXUS_Playpump_Stop( playPump );
  //     NEXUS_Playpump_GetSettings( playPump, &playpump_settings );
  //     NEXUS_Playpump_SetSettings( playPump, &playpump_settings );
  //   }
  // }

  NEXUS_VideoDecoder_Flush( shmem->videoDecoder );

  // <mod> HWEI has two audio decoders
  NEXUS_AudioDecoder_Flush( shmem->audioDecoder[0] );

  // <out> commented out since no support from HWEI
  // for (uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  // {
  //   NEXUS_Playpump_Flush( shmem->playpump[i] );
  // }

  shmem->resource_pid=0;
}

<missed-from-huawei>
These are fields that huawei mgr DO NOT HAVE from what inspect tool uses.

BcmNexus_State.sharedMem->videoWindow;
BcmNexus_State.sharedMem->playPump[i];


<from-inspect>
typedef struct
{
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[1];           // used
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_VideoDecoderHandle    videoDecoder;              // used
  NEXUS_VideoWindowHandle     videoWindow;               // used
  NEXUS_PlaypumpHandle        playpump[MAX_PUMP_NUM];    // used
  NEXUS_DmaHandle             dmaHandle;
  pid_t                       resource_pid;
} BcmNexus_Shared_Memory;


<from-mgr-humax>
typedef struct {
  //
  // 'same' as inspect
  //
  NEXUS_AudioPlaybackStartSettings    audioStartSettings;
  bool                                pcmStarted[NEXUS_NUM_AUDIO_PLAYBACKS];
} BcmNexus_Shared_Memory;

<from-mgr-huawei>
typedef struct {
    NEXUS_AudioMixerHandle              mixer;
    NEXUS_AudioPlaybackHandle           pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
    NEXUS_AudioDecoderHandle            audioDecoder[2];
    NEXUS_VideoDecoderHandle            videoDecoder;
} BcmNexus_Shared_Memory;



{pid-check}
<from-inspect>
When the option -r is given and the given pid is the same as shm pid, then do
release:

if ( 0 == expected_owning_pid || expected_owning_pid == sharedMem->resource_pid )

<from-mgr-humax>
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
  // check in both oem. this prevents the same process getting the same.
  if (BcmNexus_State.streamResource) {
    BDBG_MSG_TRACE(("BcmNexus_StreamPlayer_Resources_Acquire: Already acquired!!"));
    return NULL;
  }

  // check and if already owns by the other process then returns. only when no
  // one owns it, go forward
  if( (BcmNexus_State.sharedMem->resource_pid != 0) && (BcmNexus_State.sharedMem->resource_pid != getpid()) )

  // set to say i owns it
  BcmNexus_State.sharedMem->resource_pid = getpid();
}

BcmNexus_StreamPlayer_Resources_Release()
{
  // set pid = 0
}

note: Q: the below is ONLY for humax and not used in inspect tool. Who's using it?

BcmNexus_StreamPlayer_Resources_Avaiable(void)
{
  if( (BcmNexus_State.sharedMem->resource_pid == 0) || (BcmNexus_State.sharedMem->resource_pid == getpid()) )
}


{hwei-mgr-modification}
<playpump>
note: The below is only for Humax and also has a pair for Init and Uninit for each audio and video.
BcmNexus_Platform_Init_Video(void);

For HWEI, the below do the work that Init_Audio and Init_Video do in HMAX case. Hence added playpump
open code in:
BcmNexus_Platform_Init_Audio(void);

However, no pair but instead uninit done in: 
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *resources_)

Added playpump in SHM structure and handles it in Init and Release.

<videoWindow>
note: do not use videoWindowSD in inspect tool so not shared in shm.

BcmNexus_State.sharedMem->videoWindow;

As with playpump, init and uninit done in Acquire and Release:

BcmNexus_StreamPlayer_Resources_Acquire
BcmNexus_StreamPlayer_Resources_Release

note: Unline HMAX, NO input connection on videoWindow in Acquire and so no handle in Release.

Added videoWindow in SHM structure and handles it in Acquire and Release.

This cause opps:
Code: 00000000  8fa20010  3c04e1bd <8c420000> 24848dbc  afa20010  8fa30010 8fa20014  0062001a ###
00:00:22.574 nexus_driver_callbacks: two apps can't register for the same callback for the same
handle *** 00:00:22.574 nexus_driver_callbacks: nexus_driver_callback_to_driver:
(HDMI_OUTPUT:0xcf3a6c80) not enough resources to map callback 0xc04:0xe1d60064 *** 00:00:22.574
BHDM_EDID: Overriding 1366x768p/1360x768p to BFMT_VideoFmt_e720p !!! Assert 'Bad object of expected
type #NEXUS_VideoWindow:0xdeadda7a (0x0:0xe19f39b4)' Failed at
/home/gejing/dn370tb37sp05/bcm7409/refsw6.5/nexus/modules/display/7420/src/nexus_video_window.c:1285
BKNI_Fail: forcing oops CPU 0 Unable to handle kernel paging request at virtual address 00000000,
    epc == e178ec90, ra == e178ec88


{open-and-start}
<from-mgr-humax>

Q: nexusMgr already has Init and Uninit interface. Is it okay to use these rather than implementing
the proposed function? 

BcmNexus_Platform_Uninit(void);

A: NO. Since Init and Uninit pair do 'open' and close but inspect tool uses 'stop'. Interestingly, the
nexusMgr do not use 'start' interface. Does it mean that do start automatically when it is opened?


BcmNexus_State.sharedMem->ac3Encoder = NEXUS_Ac3Encode_Open(NULL);


{design} the suggested call
1. check manager's init state and the given pid.

if( !BcmNexus_State.initialized && pid != resource_pid )
   return;

2. set shm resource pid = 0 at the end of the call.


{tickets}
https://jira.youview.co.uk/browse/DEVARCH-8092
Provide a method in Huawei's nexusMgr to release resources acquired by a pid

<proposed-api>
The proposed interface in OEM nexusMgr code.
BcmNexus_Release_All_Resources_Acquired_By_Process(pid_t pid);

https://jira.youview.co.uk/browse/YVHUAWEI-6095
Kernel oops when killing w3cEngine or Netflix

Chris Dudding added a comment - Last Wednesday 15:34
B37SP05 is an engineering release, so the "kernel oops" fixes are not applied in the latest Huawei
FR13 release (B37SP11). We've asked them to apply the fix into their main FR13 branch. We will mark
this ticket as resolved when the fix is available in the next FR13 release.

Zegen Pei added a comment - Last Friday 02:25
fixed in 70.37.13

note: update. 2015.01.15. tried the eng. release and seen no kernel oops any more.


https://jira.youview.co.uk/browse/DEVARCH-8081
<TODO> 1
If we are to proceed with `nexus-inspect` as a solution, we separately need OEMs to move the struct
definition into the header file, but for now, we should identify which devices the current
implementation is compatible with. 

Device Works (Y/N)   Comments
Humax T1000          Y 
Humax T2100/T2000    Y 
Humax T2200          Y 
Huawei DN370T        N 
Huawei DN372T 
Huawei DN360T

note: before that need to verify #6095 first since it cause opps when kill apps.

1. this is function sets resource_pid in humax case
BcmNexus_StreamPlayer_Resources_Acquire(const BcmNexus_StreamPlayer_Resources_Config *)

2. We could perhaps make an initial implementation of this for each OEM and
provide as a patch to OEMs, or if that proves too problematic in the Huawei
case, leave it as an empty "no-op", and let them fill-in the implementation.

3. At the moment Humax saves the pid of the last process and Ideally we should
know what process acquired each resource so we can more safely release them.
Some testing will tell us how necessary it is for now.

https://jira.youview.co.uk/browse/DEVARCH-8080
<disable>
This can be disabled by removing either of the executables:
    /opt/zinc/bin/exec-then-cleanup-app.sh
    /opt/zinc/bin/nexus-inspect


{logs}
2015.01.16: 

1. able to build nexus mgr which has debug print mesg to see if it is loaded and used.  found the
problem which prevents me copying the built lib to a box since box has read-only fs. need to make it
rw fs.

2. managed to make a fs writable.

3. however, tried to use the lib built on my own, the box doesn't boot up but when use the original
lib works okay. why?

4. __FUNCTION__ macro seems to cause one problem. need to check.

5. there is the latest nexusMgr code from HWEI and tried that as well. But no success. The code from
https://jira.youview.co.uk/browse/YVHUAWEI-5895

6. three versions of nexus mgr: from uv git, from the gira, from the staging folder.

7. the log line
Error org.freedesktop.DBus.Error.NoMemory: Launcher could not run (out of memory)


2015.01.19, Mon:

1. Tried three variants of sources. None of them works. Asked Bomen(HWEI guy) to have a trace log
for a working case to compare.

2015.01.20, Tue:

1. Created a new ticket for an issue that cannot build a working nexusMgr. 
https://jira.youview.co.uk/browse/YVHUAWEI-6598

2. Ongoing discussion about features to implement.
https://jira.youview.co.uk/browse/YVHUAWEI-6095


2015.01.21, Wed:

1. Hack sources

HUAWEI_SHARED_RESOURCE        : defed in src

NEXUS_HAS_PICTURE_DECODER     : NO
_SC_DIRECT_NEXUS_             : NO
NEXUS_NUM_XXX                 : NO
DFB_PLATFORM_VERSION_MAJOR    : NO
DUAL_OUTPUT                         : defed in pkg config for hwei and hmax
NEXUS_HAS_DMA && NEXUS_HAS_SECURITY : defed in pkg config
BCMEXUS_STREAM_XXX                  : NO
USE_SIMPLE_DECODER                  : NO


01.29:   <shm-size-issue>
======
Investigating shmget error.

" from nexusMgr log line
log-usb-Mon-Jan-26-12:01:40:1253:*** KT: 0121: NEW BcmNexus_Platform_Init_Audio: shm size(24) ***

" from proc device
305450176

cat /proc/sysvipc/shm
key         shmid    perms    size  cpid  lpid nattch uid   gid  cuid  cgid      atime      dtime      ctime
305450176   163844   666      24    1063  1395 4      504   504   504   504 1422517874 1422517866         33
 
504       1063 12.6  9.7 502416 31352 ?        Sl   07:50   8:03 /opt/cds/bin/huaweidaemon

However, inspect asks 28 bytes which is the cause of the error.


02.09:
======

{shm-diff}

The handles are all pointers like:

typedef struct NEXUS_AudioMixer *NEXUS_AudioMixerHandle;


<proposed>
#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[2];
  NEXUS_AudioDecoderHandle    audioDecoder[2];
  NEXUS_VideoDecoderHandle    videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_DmaHandle             dmaHandle;
  NEXUS_VideoWindowHandle     videoWindow;
  NEXUS_PlaypumpHandle        playpump[1];
  pid_t                       resource_pid;
} NexusInspectCapsV0;


<humax> (from inspect.c)
#define NEXUS_NUM_AUDIO_PLAYBACKS 2
#define NEXUS_NUM_HDMI_OUTPUTS 1
#define MAX_PUMP_NUM	1

typedef struct {
  NEXUS_AudioMixerHandle              mixer;
  NEXUS_AudioPlaybackHandle           pcmPlayback[2];
  NEXUS_AudioDecoderHandle            audioDecoder[1];
  NEXUS_VideoDecoderHandle            videoDecoder;
  NEXUS_StcChannelHandle              stcChannel;
  NEXUS_Ac3EncodeHandle               ac3Encoder;
  NEXUS_DmaHandle                     dmaHandle;
  NEXUS_VideoWindowHandle             videoWindow;
  NEXUS_PlaypumpHandle                playpump[1];
  pid_t                               resource_pid;
} BcmNexus_Shared_Memory;

<huawei>

#define NEXUS_NUM_AUDIO_PLAYBACKS (1)

typedef struct {
    NEXUS_AudioMixerHandle              mixer;
    NEXUS_AudioPlaybackHandle           pcmPlayback[1];
    NEXUS_AudioDecoderHandle            audioDecoder[2];
    NEXUS_VideoDecoderHandle            videoDecoder;
    NEXUS_StcChannelHandle              stcChannel;
    pid_t                               resource_pid;
} BcmNexus_Shared_Memory;


   humax                                                                         hwei
--------------------------------------------------------------------          --------------------------------------------------------------------
typedef struct                                                                typedef struct 
{                                                                             {                                                                 
  NEXUS_AudioMixerHandle      mixer;                                            NEXUS_AudioMixerHandle              mixer;
  // 2 in mgr source                                                            // 1 in oem stage
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];           NEXUS_AudioPlaybackHandle           pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[1];           // used to stop        NEXUS_AudioDecoderHandle            audioDecoder[2];
  NEXUS_Ac3EncodeHandle       ac3Encoder;                // used in info        NEXUS_VideoDecoderHandle            videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;                // used in info        NEXUS_StcChannelHandle              stcChannel;
  NEXUS_VideoDecoderHandle    videoDecoder;              // used in info        pid_t                               resource_pid;
  NEXUS_VideoWindowHandle     videoWindow;               // used in info      } BcmNexus_Shared_Memory;                                                        
  // 1 in mgr source
  NEXUS_PlaypumpHandle        playpump[MAX_PUMP_NUM];    // used to stop
  NEXUS_DmaHandle             dmaHandle;                 // used in info
  pid_t                       resource_pid;
} BcmNexus_Shared_Memory;


04.20
======

#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_INSPECT_NUM_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[NEXUS_INSPECT_NUM_ADECS];
  NEXUS_VideoDecoderHandle    videoDecoder;                                   // covered. both
  NEXUS_StcChannelHandle      stcChannel;                                     // covered. both
  NEXUS_Ac3EncodeHandle       ac3Encoder;                                     // covered. hmax
  NEXUS_DmaHandle             dmaHandle;                                      // covered. hmax
  NEXUS_VideoWindowHandle     videoWindow;                                    // covered. hmax
  NEXUS_PlaypumpHandle        playpump[NEXUS_INSPECT_NUM_PLAYPUMPS];          // covered. both
  pid_t                       resource_pid;              
} NexusInspectCapsV0;

1. if( caps_v0.videoDecoder ) : covered for both.

static void printNexusManagerInfo( BcmNexus_Shared_Memory* sharedMem )
{
  // covered for both.
  //
  // NEXUS_PictureCtrlCommonSettings picture_settings;
  // printf( "\tAc3EncodeHandle: 0x%x\n", (unsigned int)sharedMem->ac3Encoder );
  // printf( "\tStcChannelHandle: 0x%x\n", (unsigned int)sharedMem->stcChannel );
  // printf( "\tVideoDecoderHandle: 0x%x\n",(unsigned int)sharedMem->videoDecoder );
  // printf( "\tVideoWindowHandle: 0x%x\n", (unsigned int)sharedMem->videoWindow );

  // NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindow, &picture_settings );
  // printf( "\t\tVideoDecoder contrast: %d\n", picture_settings.contrast );
  // printf( "\t\tVideoDecoder brightness: %d\n", picture_settings.brightness );
  // printf( "\t\tVideoDecoder saturation: %d\n", picture_settings.saturation );

#ifdef NEXUS_DUAL_OUTPUT
  printf( "\tSD DisplayHandle: 0x%x\n", (unsigned int)sharedMem->displaySD ) ;
  printf( "\tSD VideoWindowHandle: 0x%x\n", (unsigned int)sharedMem->videoWindowSD );
  NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindowSD, &picture_settings );
  printf( "\t\tSD VideoDecoder contrast: %d\n", picture_settings.contrast );
  printf( "\t\tSD VideoDecoder brightness: %d\n", picture_settings.brightness );
  printf( "\t\tSD VideoDecoder saturation: %d\n", picture_settings.saturation );
#endif // NEXUS_DUAL_OUTPUT
  for(uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  {
    printf( "\tPlaypumpHandle[%d]: 0x%x\n", i, (unsigned int)sharedMem->playpump[i] );
  }
  printf( "\tDmaHandle: 0x%x\n", (unsigned int)sharedMem->dmaHandle );
}

02.24: (logs changes to rewrite git commits and commit history)
======
1. OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

For hwei, do comment out as below to inlcude this in the build.

# export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"

2. Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c

change name nexus-inspect to nexus-release

3. Add nexus-release.c

4. Add nexus-inspect.[ch] 

5. Change Makefile.am to build both files.


02.25: as-needed option problem when builds nexus tools
======

<fail>
-O2 -pipe -rdynamic -Wl,-rpath-link/opt/cds/bin/huaweidaemon

-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-o nexus-release nexus_release-nexus-release.o -Wl,-rpath -Wl,/usr/local/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib ~
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread -pthread ~

/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBSetOption' 
/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBCreate' 
/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBInit' collect2: ld returned 1 exit status

<okay>
-O2 -pipe -Wl,-rpath -Wl,/usr/local/lib -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-o nexus-inspect nexus_inspect-nexus-inspect.o

-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib -pthread


<runtime> no direct reference to nexusMgr
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin$ readelf
-d w3cEngine | grep NEED

(standard input):4: 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
(standard input):5: 0x00000001 (NEEDED)                     Shared library: [libsoup-2.4.so.1]
(standard input):6: 0x00000001 (NEEDED)                     Shared library: [libgobject-2.0.so.0]
(standard input):7: 0x00000001 (NEEDED)                     Shared library: [libglib-2.0.so.0]
(standard input):8: 0x00000001 (NEEDED)                     Shared library: [libNickelTunerSystemAPI.so.0]
(standard input):9: 0x00000001 (NEEDED)                     Shared library: [libQt5WebKitWidgets.so.5]
(standard input):10: 0x00000001 (NEEDED)                     Shared library: [libQt5Widgets.so.5]
(standard input):11: 0x00000001 (NEEDED)                     Shared library: [libZincJsCoreBindingRuntime.so.0]
(standard input):12: 0x00000001 (NEEDED)                     Shared library: [libZincCommon.so.0]
(standard input):13: 0x00000001 (NEEDED)                     Shared library: [libboost_thread.so.1.42.0]
(standard input):14: 0x00000001 (NEEDED)                     Shared library: [liblog4cplus-1.0.so.4]
(standard input):15: 0x00000001 (NEEDED)                     Shared library: [libboost_system.so.1.42.0]
(standard input):16: 0x00000001 (NEEDED)                     Shared library: [libQt5WebKit.so.5]
(standard input):17: 0x00000001 (NEEDED)                     Shared library: [libQt5Gui.so.5]
(standard input):18: 0x00000001 (NEEDED)                     Shared library: [libQt5Network.so.5]
(standard input):19: 0x00000001 (NEEDED)                     Shared library: [libQt5Core.so.5]
(standard input):20: 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
(standard input):21: 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
(standard input):22: 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
(standard input):49: 0x6ffffffe (VERNEED)                    0x40bd3c
(standard input):50: 0x6fffffff (VERNEEDNUM)                 2


04.01:
======
1. Got eng release and check on shm first.

before:
cat /proc/sysvipc/shm

key         shmid    perms    size  cpid  lpid nattch uid   gid  cuid  cgid      atime      dtime      ctime

305450176   163844   666      24    1063  1395 4      504   504   504   504
1422517874 1422517866         33

now:
305450176     196613   666         28  1074  1422      4   504   504   504
504 1427879275 1427879314         43

from ps:
1074 ?        Sl     3:09 /opt/cds/bin/huaweidaemon


2. Need to make a box writable since requires to copy exec and nexus-release
binary.

exec-then-cleanup-app

3. Seen a problem of making fs writable.

4. Cannot run iplayer and nexus-release as well
/opt/zinc-trunk/bin/nexus-release: can't load library 'libnexusMgr.so.0'

In that case, shows this error:

(w3cEngine:2429): GStreamer-WARNING **: Failed to load plugin
                  '/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so': File
                  not found


5. However, there are files on a box.

root# ll /opt/{zinc,zinc-trunk}/oss/lib/gstreamer-1.0/libgstnexus.so
lrwxrwxrwx    1 1024     1025            20 Apr  1 13:30
/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so -> libgstnexus.so.0.0.0

lrwxrwxrwx    1 root     root            20 Jan  1  1970
/opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so -> libgstnexus.so.0.0.0


6. on a huwawei box

objdump -p /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so

/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so:     file format elf32-tradlittlemips

Dynamic Section:
  NEEDED               libnexusMgr.so.0 ~
  NEEDED               libnexus.so
  NEEDED               libgstbase-1.0.so.0
  NEEDED               libgstmpegts-1.0.so.0
  NEEDED               libgstreamer-1.0.so.0
  NEEDED               libgobject-2.0.so.0
  NEEDED               libglib-2.0.so.0
  NEEDED               libgcc_s.so.1
  NEEDED               libpthread.so.0
  NEEDED               libc.so.0
  SONAME               libgstnexus.so.0
  RPATH                /usr/local/lib
  RUNPATH              /usr/local/lib


root# objdump -p /opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so      

/opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so:     file format elf32-tradlittlemips

Dynamic Section:
  NEEDED               libnexusMgr.so ~
  NEEDED               libnexus.so
  NEEDED               libgstbase-1.0.so.0
  NEEDED               libgstmpegts-1.0.so.0
  NEEDED               libgstreamer-1.0.so.0
  NEEDED               libgobject-2.0.so.0
  NEEDED               libglib-2.0.so.0
  NEEDED               libgcc_s.so.1
  NEEDED               libpthread.so.0
  NEEDED               libc.so.0
  SONAME               libgstnexus.so.0
  RPATH                /usr/local/lib
  RUNPATH              /usr/local/lib


open("/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so", O_RDONLY) = 60

open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/oss/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/oss/lib/gstreamer-1.0/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/devel/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/tests/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)

write(2, "\n(w3cEngine:1641): GStreamer-WARN"..., 134
(w3cEngine:1641): GStreamer-WARNING **: Failed to load plugin '/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so': File not found
) = 134


05.15
======
To enable the nexus tools in the build for all Huawei platforms

DEVARCH-9538: NexusInspect: Enable the nexus tools to build for all Huawei
platforms; 370, 360, and 372.
    
As an interim solution, DEVARCH-8092 has a configuration that pick up the
previous for platforms that are not moved to the new approach yet and to pick
up the new for platforms that already moved. This commit enables it for all
Huawei platforms since they moved the new approach and made a official
release.


={============================================================================
*kt_dev_uv_oem_002* nexusmgr build issue and proposal

While working on nexus inspect tool, found that it failed to find the
libnexusMgr.so at runtime. Investigated and found that the inspect tool expect
libnexusMgr.so.0 and own-built mgr has the same as SONAME but there is ONLY
libnexusMgr.so in /usr/local/lib. 

libnexusMgr.so.0 -> libnexusMgr.so

This easy solution worked okay. 

Do we need to make a change to a system to make a link? Why was it okay to run
other application that uses that library?

note: <QQQQ> this is hwei case. how about humax? see /usr/local/lib

Investigated the system and found that applications uses the realname.

So the easiest is to change makefile of libnexusMgr to use realname than soname.


04.02: summary
======
1. nexusMgr comes from OEM staging

/opt/oem-staging/huawei-bcm7409:

./usr/local/include/nexusMgr/nexusMgr.h
./usr/local/include/nexusMgr/nexusMgr.c
./usr/local/lib/nexusMgr.h

./usr/local/lib/pkgconfig/nexusMgr.pc

./usr/local/directfb/lib/libnexusMgr.so
./usr/local/lib/libnexusMgr.so


2. pkg-config when is in shell configured for a target

$ pkg-config --libs nexusmgr
Package nexusmgr was not found in the pkg-config search path.
Perhaps you should add the directory containing `nexusmgr.pc'
to the PKG_CONFIG_PATH environment variable
No package 'nexusmgr' found

$ pkg-config --libs nexusMgr
-L/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -Wl,-rpath,/usr/local/lib -lfusion -ldirect -linit -lnexus -lz -lpthread


3. inspect tool builds line

-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib ~
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread -pthread ~
nexus_inspect-nexus-inspect.o: In function `main':
/home/kpark/source/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c:343:

note: see that picks from staging and the use of linkername.


4. the previous next inspect do not have a reference to nexusMgr.so as below:

$ readelf -d ./Polonium/Polonium.NexusRelease/nexus-inspect | grep NEED
(standard input):4: 0x00000001 (NEEDED)                     Shared library: [libnexus.so]

That's why it was not a problem before.


5. compare nexusMgrs

kpark@wll1p04345:/opt/oem-staging/huawei-bcm7409/usr/local/lib$ readelf -d libnexusMgr.so.org 

Dynamic section at offset 0x14c contains 29 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libnexus.so]
 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)                     Shared library: [libm.so.0]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x0000000f (RPATH)                      Library rpath: [/opt/stagecraft-2.0/bin:/opt/zinc/oss/lib]
 0x0000001d (RUNPATH)                    Library runpath: [/opt/stagecraft-2.0/bin:/opt/zinc/oss/lib]

kpark@wll1p04345:/opt/oem-staging/huawei-bcm7409/usr/local/lib$ readelf -d libnexusMgr.so     

Dynamic section at offset 0x14c contains 27 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libinit.so]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x0000000e (SONAME)                     Library soname: [libnexusMgr.so.0]

note: the own nexusMgr buils has soname but the original don't


box:/usr/local/lib/libnexusMgr.so has no soname as the original.



5.1 Given that the original mgr so do not have soname. However, build mgr own and then it has soname
as below. 

10:libtool: link: mipsel-linux-gcc -shared  -fPIC -DPIC  .libs/nexusMgr.o   -lpthread -linit
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib  -O3 -pthread -O2 -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/oss/lib
-pthread -Wl,-soname -Wl,libnexusMgr.so.0 -o .libs/libnexusMgr.so.0.0.0

Therefore, when link nexus tools, these will picks up soname. So it's all down to how mgr is built. 


<how-other-uses-nexus-mgr>

6.1. when run w3c, not load nexusMgr but when 'runs' video, can see nexusMgr in mem mapping. So
there seems other so to load nexusMgr when needed. note that w3c do have a reference to nexus mgr
so.


6.2. The libgstnexus.so for both oems uses the real name. The one on a box shows the same.

Dynamic Section:
  NEEDED               libnexusMgr.so
  ...
  SONAME               libgstnexus.so.0


<the-proposal>
https://jira.youview.co.uk/browse/DEVARCH-9145

h3. New nexusMgr library proposal and guideline

h4. 0. Introduction
There has been a need to have tools to release forcefully nexus resources which are locked up when
an application exits abnormally and to have more information about nexus resources.

The tools are developed for one of OEMs and it uses the private nexusMgr implementation details.
However, the both OEMs have different implementations and prevents YouView from having common
nexus tools that works on both OEMs.

Therefore, this proposal propose a separation between inspection and releasing and OEMs and
YouView, propose new APIs, and shows a working implementation as a base for them to have a quick start. 


h4. 1. Capability interface and the inspect header
The proposal introduces capability interface to query the exposed capability of OEM nexusMgr and
uses it to inspect resources.

The header defines the version and the structure to be used for both OEMs and is subject to future
extension if necessary. YouView maintain and release it to OEMs based on the common agreement and it
will be the part of OEM staging delivery.

{noformat}
/**
 * nexus-inspect.h
 *
 * Created: 11 February, 2015
 *
 * This header defines a capability structure and API to get nexus resources
 * from OEM nexus managers in order to inspect various status or information
 * about nexus resources.
 *
 * OEMs may implement the API with this header provided by YouView and use the
 * version specified and agreed between YouView and OEMs.
 *
 * Copyright (C) 2015 YouView TV Ltd
 */     

#ifndef _NEXUS_INSPECT_H_
#define _NEXUS_INSPECT_H_

/**
 * Defines nexus inspect capability versions for future extensions.
 */
#define NEXUS_INSPECT_CAP_V0     (0x00000001)
#define NEXUS_INSPECT_CAP_V1     (0x00000002)

/**
 * Defines nexus inspect capability structure for each version. OEM may set the
 * unsupported resources to NULL from a return.
 *
 * More version structures for future extensions if necessary.
 */
#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_INSPECT_NUM_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[NEXUS_INSPECT_NUM_ADECS];
  NEXUS_VideoDecoderHandle    videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_DmaHandle             dmaHandle;
  NEXUS_VideoWindowHandle     videoWindow;
  NEXUS_PlaypumpHandle        playpump[NEXUS_INSPECT_NUM_PLAYPUMPS];
  pid_t                       resource_pid;
} NexusInspectCapsV0;


#endif /* _NEXUS_INSPECT_H_ */
{noformat}

h4. 2. New APIs
The proposal introduces two new APIs which are implemented in nexusMgr.

{noformat}
/**
 * Defines a API to get nexus inspect capability.
 *
 * @ param {version} specify the capability version to request
 * @ param {cap} specify the capability structure to get values from nexus
 * manger according to the version.
 *
 * @ return {bool} true when nexus manager supports the provided version and
 * fills up the structure.  Otherwise, false.
 */     
bool BcmNexus_Acquire_Capability( unsigned int version, void *cap, size_t size );

/**
 * Defines a API to release nexus resources.
 *
 * @ param {application_pid} specify the PID which holds nexus resources.
 *
 * @ return none
 */     
void BcmNexus_Release_All_Resources_Acquired_By_Process( pid_t application_pid );
{noformat}

h4. 3. The suggested nexusMgr implementation
The suggested implementation shows implementation to support the proposal. Although this is working
on a target, it is OEM's onus to make a official delivery to YouView that may supports both the
proposal and the OEM specific needs. The suggested in nexusMgr.c only shows the added code.

{noformat}
typedef struct {
  // {PROPOSED}
  pid_t                               resource_pid;
} BcmNexus_Shared_Memory;

const BcmNexus_StreamPlayer_Resources *
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
  // {PROPOSED}
  if( (BcmNexus_State.sharedMem->resource_pid != 0) && (BcmNexus_State.sharedMem->resource_pid != getpid()) )
  {
    BDBG_MSG_TRACE(("BcmNexus_StreamPlayer_Resources_Acquire: already acquired"));
    goto err_playpump;
  }

  // {PROPOSED}
  BcmNexus_State.sharedMem->resource_pid = getpid();
}

void 
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *resources_)
{
  // {PROPOSED}
  BcmNexus_State.sharedMem->resource_pid = 0;
}

// {PROPOSED}
void 
BcmNexus_Release_All_Resources_Acquired_By_Process( pid_t application_pid )
{
  // Getting nexus shm
  //
  BcmNexus_State.masterProcess = do_platform_init(sizeof(BcmNexus_Shared_Memory));
  BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: masterProcess = %c",BcmNexus_State.masterProcess?'y':'n'));

  NEXUS_Platform_Join();

  BcmNexus_State.sharedMem = (BcmNexus_Shared_Memory*)setupSharedMemory(sizeof(BcmNexus_Shared_Memory), (BcmNexus_State.masterProcess ? true : false));
  BDBG_ASSERT(BcmNexus_State.sharedMem);

  if (BcmNexus_State.masterProcess) {
    return;
  }

  if( BcmNexus_State.sharedMem->resource_pid == application_pid ) 
  {
    // Cleaning up nexus resources
    //
    BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Stopping video decoder"));
    NEXUS_VideoDecoder_Stop( BcmNexus_State.sharedMem->videoDecoder );

    for (uint8_t i = 0; i < NEXUS_INSPECT_NUM_ADECS; ++i)
    {
      BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Stopping audio decoder"));
      NEXUS_AudioDecoder_Stop( BcmNexus_State.sharedMem->audioDecoder[i] );
    }

    BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Flushing video decoder"));
    NEXUS_VideoDecoder_Flush( BcmNexus_State.sharedMem->videoDecoder );

    for (uint8_t i = 0; i < NEXUS_INSPECT_NUM_ADECS; ++i)
    {
      BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Flushing audio decoder"));
      NEXUS_AudioDecoder_Flush( BcmNexus_State.sharedMem->audioDecoder[i] );
    }

    BcmNexus_State.sharedMem->resource_pid = 0;
  }

  return;
}

bool 
BcmNexus_Acquire_Capability( unsigned int version, void *cap, size_t capSize )
{
  // Getting nexus shm
  //
  BcmNexus_State.masterProcess = do_platform_init(sizeof(BcmNexus_Shared_Memory));
  BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: masterProcess = %c",BcmNexus_State.masterProcess?'y':'n'));

  NEXUS_Platform_Join();

  BcmNexus_State.sharedMem = (BcmNexus_Shared_Memory*)setupSharedMemory(sizeof(BcmNexus_Shared_Memory), (BcmNexus_State.masterProcess ? true : false));
  BDBG_ASSERT(BcmNexus_State.sharedMem);

  if (BcmNexus_State.masterProcess) {
    return false;
  }

  ((NexusInspectCapsV0*)cap)->videoDecoder = BcmNexus_State.sharedMem->videoDecoder;

  return true;
}
{noformat}

h4. 4. The JIRAs, the branch and git
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

o The proposed nexus tools. review/DEVARCH-8092/3 on Stash
https://stash.dev.youview.co.uk/projects/DEVARCH/repos/devarch-mirror/compare/commits?sourceBranch=refs%2Fheads%2Freview%2FDEVARCH-8092%2F3&targetBranch=refs%2Fheads%2Fmaster

DEVARCH-9131: NexusInspect: Fix up makefile to build nexus utilities. There is no common solution
for nexus utility features since both OEMs have different nexusMgr implementations and the current
implementation of nexus utility is tightly coupled with nexusMgr implementation which is private and
OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080. This
commit has the necessary changes of makefile to build nexus utility and to fix the link order
problem ...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9130: NexusInspect: Add nexus inspect tool. There is no common solution for nexus utility
features since both OEMs have different nexusMgr implementations and the current implementation of
nexus utility is tightly coupled with nexusMgr implementation which is private and OEM dependant as
described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080. This commit add the nexus
inspect which uses the proposed APIs to show information of nexus resources. Since the tool is no
l...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9129: NexusInspect: Add nexus release tool and revise the exec wrapper There is no common
solution for nexus utility features since both OEMs have different nexusMgr implementations and the
current implementation of nexus utility is tightly coupled with nexusMgr implementation which is
private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and
DEVARCH-8080. This commit add the nexus release which is revised to use the proposed APIs to release
nexus resou...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9128: NexusInspect: Add the nexus inspect to the build for Huawei dn370t There is no common
solution for nexus utility features since both OEMs have different nexusMgr implementations and the
current implementation of nexus utility is tightly coupled with nexusMgr implementation which is
private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and
DEVARCH-8080. This commit add the nexus utility project to the build for Huawei dn370t.		5 days ago
5 JIRA Issues	

o The updated and proposed nexusMgr.
https://git-dev.dev.youview.co.uk/?p=nexusMgr.git;a=shortlog;h=refs/heads/propose/huawei


={============================================================================
*kt_dev_uv_oem_002* zinc-nexus: and nexussink callback

Hmax only provides 1 playpump.

note: seems that stream types comes from gst when opens a sink and that means
that below enums should match ones in gst?

// gstnexusmgr.h

enum NexusSinkContentType
{
    CTTransportStream=0,
    CTVideoElementaryStream=1,
    CTAudioElementaryStream=2,
    CTNone=0xFF
};


<sink-settings>

NEXUS_Callback void ( void *context, int param );

struct {
  /**
   * Fires when space becomes available, but only when writing transport stream.
   * For elementary streams, use gst_nexus_mgr_get_pes_writer() and
   * ConcurrentPesWriter API.
   */
  NEXUS_Callback data;

  /**
   * Fires when Nexus resources are acquired.
   *
   * @note If there are multiple clients using the same instance of GstNexusMgr,
   *       only one of them (an arbitrary one) will receive this callback.
   */
  NEXUS_Callback resourcesAcquired;

  /**
   * Fires when Nexus resources are released. When we release Nexus resources
   * to immediately re-acquire them (we do that for re-configuration purposes),
   * we don't emit resourcesReleased followed by resourcesAcquired callbacks.
   * If re-acquiring fails though, we do emit a single resourcesReleased callback.
   *
   * @note If there are multiple clients using the same instance of GstNexusMgr,
   *       only one of them (an arbitrary one) will receive this callback.
   */
  NEXUS_Callback resourcesReleased;

  NEXUS_Callback firstPts;  /* Fires when the decoder receives the first PTS after start. */
  NEXUS_Callback streamChange; /* Fires when stream format has changed or the first time
                                  the decoder has parsed the codec format after start. */
  NEXUS_Callback error; /* Fires when an error occurs */
  void* context; /* passed as the first parameter to the callback functions */
} GstNexusCallbacks ;

struct {
  NexusSinkContentType contentType;
  NexusSinkVideoCodec video_codec;
  NexusSinkAudioCodec audio_codec;

  // *callbacks*
  GstNexusCallbacks callbacks;

  int video_pid;
  int audio_pid;
} GstNexusStreamSetting;

struct {
  ...
  GstNexusStreamSetting settings;
} GstNexusSink;


static void gst_nexus_sink_init( GstNexusSink * sink )
{
  sink->settings.callbacks.data = gst_nexus_sink_space_available;
  sink->settings.callbacks.resourcesAcquired = gst_nexus_sink_resources_acquired;
  sink->settings.callbacks.resourcesReleased = gst_nexus_sink_resources_released;

  // *sink-on-error* handles custom Exxx error and this emits EOS
  sink->settings.callbacks.error = gst_nexus_sink_on_error;

  sink->settings.callbacks.firstPts = gst_nexus_sink_first_pts;

  sink->settings.callbacks.streamChange = gst_nexus_sink_stream_change;

  // note:
  // each sink set itself and this used to set callback_contexts. when callback
  // fires, it passes this and each sink callback use this to identify which
  // sink to use.
  sink->settings.callbacks.context = sink;
}

enum NexusSinkErrorReason
{
    EFifoEmpty = 0x0101,
    EPtsError = 0x0206, /* PTS discontinuity error */
}

src/gstnexusmgr.c:1777:gst_nexus_mgr_error_1st_level_cb: => KT: AudioError: 0x0206
src/gstnexusmgr.c:1777:gst_nexus_mgr_error_1st_level_cb: => KT: VideoError: 0x0101


<nexusmgr-callback>

typedef struct
{
  /**
   * First level callbacks may only access callback_cond, pending_callbacks
   * and pending_callbacks_mutex through this pointer. Second level callbacks
   * may access any member, as those are called with resource_lock held.
   *
   * @note mgr->resources may well be NULL in a 2nd level callback handler.
   */
  GstNexusMgr* mgr;

  GstNexusCallbackId callback_id;

  /**
   * We initialise NEXUS_CallbackDesc::param with one of NexusSinkErrorReason
   * enumeration values. Nexus passes that value as a second argument to
   * callbacks. gst_nexus_mgr_generic_1st_level_cb() takes that argument and
   * saves it to this member before posting the callback to mgr->callback_thread.
   */
  int reason;

  /* The members below are specific to callback_id. */

  int playpump_num;
  NEXUS_Callback delegate_callback;
  void* delegate_context;
} GstNexusMgrCallbackInfo;

typedef struct
{
  GstNexusMgrCallbackInfo audio_buffer_available;
  GstNexusMgrCallbackInfo video_buffer_available;

  GstNexusMgrCallbackInfo audio_first_pts;
  GstNexusMgrCallbackInfo video_first_pts;

  GstNexusMgrCallbackInfo audio_error;
  GstNexusMgrCallbackInfo video_error;
} GstNexusMgrCallbackContexts;


struct _GstNexusMgr
{
  ...
  GstNexusMgrCallbackContexts callback_contexts;

  GstNexusStreamSetting settings;
  {
    GstNexusCallbacks callbacks;
  }

  GstNexusCallbacks audioCallbacks;
}


gst_nexus_mgr_acquire_playpumps(GstNexusMgr * mgr, 
  const GstNexusStreamSetting * settings)
{
  // *resource-lock*
  g_mutex_lock(&mgr->resource_lock);

  // sink call this with its setting so mgr has its sink setting.
  // set mgr callbacks from sink
  mgr->settings.callbacks = settings->callbacks;

  // only for audio type
  mgr->audioCallbacks = settings->callbacks;

  // set callback_contexts with cb id
  gst_nexus_mgr_callback_contexts_init(&mgr->callback_contexts, mgr);

  // { set *mgr_callback_contexts_delegate* to forward them to *sink-on-error*
  // note: make a callback link from mgr to sink without 2nd level callback
  
  // set context to pass a/v errors to video sink
  mgr->callback_contexts.video_error.delegate_callback = mgr->settings.callbacks.error;

  // note: context is the address of sink
  mgr->callback_contexts.video_error.delegate_context = mgr->settings.callbacks.context;

  // set context to pass a/v errors to audio sink
  if(mgr->audioCallbacks.error){
    mgr->callback_contexts.audio_error.delegate_callback = mgr->audioCallbacks.error;
    mgr->callback_contexts.audio_error.delegate_context = mgr->audioCallbacks.context;
  }

  mgr->callback_contexts.audio_error.delegate_callback = mgr->settings.callbacks.error;
  mgr->callback_contexts.audio_error.delegate_context = mgr->settings.callbacks.context;
  //}}


  // note: don't see why use audioCallbacks

  //{{ set *callbacks* for *playpump*
  //
  // set buffer avail callbacks via nexusmgr
  //
  // use direct callback

  BcmNexus_StreamPlayer_Resources_Config config;
  config.numPlaypumps = 1;

  // use two level callback when TS type. use direct callback when ES type.
  config.audioDataCallback.callback = &gst_nexus_mgr_pes_buffer_availability;
  config.audioDataCallback.context = mgr->pes_writer;

  config.videoDataCallback.callback = &gst_nexus_mgr_pes_buffer_availability;
  config.videoDataCallback.context = mgr->pes_writer;

  mgr->resources = 
    (BcmNexus_StreamPlayer_Resources*) BcmNexus_StreamPlayer_Resources_Acquire( &config );

  // set error callbacks via nexus playpump
  //
  NEXUS_CallbackDesc playpumpErrorCallbackConfiguration = {
    gst_nexus_mgr_error_1st_level_cb, &mgr->callback_contexts.audio_error, EStreamError
  };

  NEXUS_Playpump_GetSettings( mgr->resources->playpump[mgr->audio.playpump_num], &playpump_settings );

  playpump_settings.errorCallback = playpumpErrorCallbackConfiguration;

  NEXUS_Playpump_SetSettings( mgr->resources->playpump[mgr->video.playpump_num], &playpump_settings );
  //}}


  //{{ set *callbacks* for *video-decoder*
  
  <two-level-call>
  // used and maps to
  // gst_nexus_mgr_video_first_pts_2nd_level_cb,  /* CB_VIDEO_FIRST_PTS */
  // and 'leads' to sink callback gst_nexus_sink_first_pts:<nexussink1>
  //
  // note "firstPtsPassed"
  //
  // -> gst_nexus_mgr_generic_1st_level_cb
  //      (&mgr->callback_contexts.video_first_pts, 0);

  video_decoder_settings.firstPtsPassed.callback = &gst_nexus_mgr_generic_1st_level_cb;
  video_decoder_settings.firstPtsPassed.context = &mgr->callback_contexts.video_first_pts;


  <direct-call>  
  //
  // typedef struct NEXUS_CallbackDesc {
  //     NEXUS_Callback callback; /* Function pointer */
  //     void *context;           /* First parameter to callback function. */
  //     int param;               /* Second parameter to callback function. */
  // } NEXUS_CallbackDesc;
  //
  // note: callback_context is an array and has default settings by
  // gst_nexus_mgr_callback_contexts_init() so "cb->" is always okay. 
  //
  // static void gst_nexus_mgr_error_1st_level_cb(void* context, int reason)
  // {
  //   GstNexusMgrCallbackInfo* cb = context;
  //   if (cb->delegate_callback) {
  //     cb->delegate_callback(cb->delegate_context, reason);
  //   }
  //   else
  //     print("messges");
  // }
  //
  // -> gst_nexus_mgr_error_1st_level_cb
  //      (&mgr->callback_contexts.video_error, EFifoEmpty);
  //
  // note:
  // this will be forwarded to *sink-on-error* since delegate is set above
  //

  video_decoder_settings.fifoEmpty.callback = &gst_nexus_mgr_error_1st_level_cb;
  video_decoder_settings.fifoEmpty.context = &mgr->callback_contexts.video_error;
  video_decoder_settings.fifoEmpty.param = EFifoEmpty;

  video_decoder_settings.decodeError.callback = &gst_nexus_mgr_error_1st_level_cb;
  video_decoder_settings.decodeError.context = &mgr->callback_contexts.video_error;
  video_decoder_settings.decodeError.param = EVideoDecode;

  // *streamChanged* for video from sink so will goes to sink directly
  if(mgr->settings.callbacks.streamChange){
    NEXUS_CALLBACKDESC_INIT( &video_decoder_settings.streamChanged );
    video_decoder_settings.streamChanged.callback = mgr->settings.callbacks.streamChange;
    video_decoder_settings.streamChanged.context = mgr->settings.callbacks.context;
  }

  NEXUS_VideoDecoder_SetSettings( mgr->resources->videoDecoder, 
      &video_decoder_settings );
  //
  //}}


  //{{ set *callbacks* for *audio-decoder*
  //
  NEXUS_AudioDecoderSettings audio_decoder_settings;

  // used and maps to
  // gst_nexus_mgr_audio_first_pts_2nd_level_cb,  /* CB_AUDIO_FIRST_PTS */
  //
  // and leads to sink callback
  //
  audio_decoder_settings.firstPts.callback = &gst_nexus_mgr_generic_1st_level_cb;
  audio_decoder_settings.firstPts.context = &mgr->callback_contexts.audio_first_pts;

  // forwards them to *sink-on-error*
  audio_decoder_settings.ptsError.callback = &gst_nexus_mgr_error_1st_level_cb;
  audio_decoder_settings.ptsError.context = &mgr->callback_contexts.audio_error;

  // *streamChanged* for audio from sink so will goes to sink directly
  // note: use streamStatusAvailable
  if(mgr->audioCallbacks.streamChange){
    NEXUS_CALLBACKDESC_INIT( &audio_decoder_settings.streamStatusAvailable );
    audio_decoder_settings.streamStatusAvailable.callback = mgr->audioCallbacks.streamChange;
    audio_decoder_settings.streamStatusAvailable.context = mgr->audioCallbacks.context;
  }

  NEXUS_AudioDecoder_SetSettings( mgr->resources->audioDecoder[0], 
      &audio_decoder_settings );
  //
  //}}
}


{issue-when-eos-is-broken}
The problem is that as shown, eos is received at sink and need to populate it to
the pipeline which is to be done in sink_on_error callback. However, this
callback link do not work.

nexussink /gstnexussink.c:999:gst_nexus_sink_event_locked:<nexussink0> End of stream
nexussink /gstnexussink.c:999:gst_nexus_sink_event_locked:<nexussink1> End of stream
nexussink /gstnexusmgr.c:1795:gst_nexus_mgr_error_1st_level_cb: VideoError: 0x0101

After all, registered callback to NEXUS will use context from sink settings even
when there is no resource locked since callback happens regardless of resource
acquired/released. So mgr settings *must* remain vaild when releasing resource
is done. This is the fix which excluding setting init when releasing resource.

// new one which fixes the broken callback link causing eos issue
//
static void
gst_nexus_mgr_release_playpumps_locked(GstNexusMgr *mgr, gboolean mute)
{
    if(mgr->resources){
        ...
        memset(&mgr->callback_contexts, 0, sizeof(mgr->callback_contexts));
    }
}


// old one which has resets callback settings so broke callback link.
//
static void
gst_nexus_mgr_release_playpumps_locked(GstNexusMgr *mgr, gboolean mute)
{
    if(mgr->resources){

        ...

        /* This has to go after dispatching pending callbacks, as those callbacks
         * will be receiving pointers to members of mgr->callback_contexts as
         * their "context" argument.
         */
        memset(&mgr->callback_contexts, 0, sizeof(mgr->callback_contexts));

        /* These have to go after dispatching pending callbacks, as callbacks
         * are accessing these structures.
         */
        memset(&mgr->settings.callbacks, 0, sizeof(mgr->settings.callbacks));
        memset(&mgr->audioCallbacks, 0, sizeof(mgr->audioCallbacks));
    }
}


<callback-handlers>

// GstNexusMgrCallbackInfo

static const GstNexusMgr2ndLevelCallback gst_nexus_mgr_2nd_level_cb_table[] = {
  &gst_nexus_mgr_buffer_available_2nd_level_cb, /* CB_BUFFER_AVAILABLE */
  &gst_nexus_mgr_audio_first_pts_2nd_level_cb,  /* CB_AUDIO_FIRST_PTS */
  &gst_nexus_mgr_video_first_pts_2nd_level_cb,  /* CB_VIDEO_FIRST_PTS */
  &gst_nexus_mgr_noop_2nd_level_cb,             /* CB_AUDIO_ERROR */
  &gst_nexus_mgr_noop_2nd_level_cb              /* CB_VIDEO_ERROR */
};

void gst_nexus_mgr_generic_1st_level_cb(void* context, int reason)
{
  uses two level callback which means to use callback thread to decouple
  callbacks from NEXUS

  used for buffer avail in TS case and first pts for in ES

  use CB ID(index) in GstNexusMgr2ndLevelCallback 

  gst_nexus_mgr_2nd_level_cb_table[cb->callback_id](cb);
}

void gst_nexus_mgr_stream_change_2nd_level_cb(GstNexusMgrCallbackInfo* cb)
{
  mgr->settings.callbacks.streamChange(mgr->settings.callbacks.context, cb->reason);
}

void gst_nexus_mgr_error_1st_level_cb(void* context, int reason)
{
   calls client sink directly if it's set and if not stops here

   if (cb->delegate_callback) {
     cb->delegate_callback(cb->delegate_context, reason);
   }
}


{resouce-lock}

// where it used and only from sink

gst_nexus_sink_render_locked( GstNexusSink * sink, GstBuffer * buf );
gst_nexus_sink_play_locked ( GstNexusSink * sink);
gst_nexus_sink_get_times_locked (GstNexusSink * sink, ...);


// note: must be used as a pair. get resource and release it when finishes.

BcmNexus_StreamPlayer_Resources*
gst_nexus_mgr_get_resources(GstNexusMgr * mgr, 
							const GstNexusStreamSetting * settings)
{
  if (gst_nexus_mgr_acquire_playpumps(mgr, settings)) {
	return mgr->resources;
  }
  return NULL;
}

gst_nexus_mgr_acquire_playpumps(GstNexusMgr * mgr, 
								const GstNexusStreamSetting * settings)
{
  g_mutex_lock(&mgr->resource_lock);
  ...
}

// res is used to check args
void gst_nexus_mgr_release_resources(GstNexusMgr * mgr, 
        BcmNexus_StreamPlayer_Resources* res)
{
  if(!mgr->video.decoder_active && !mgr->video.playpump_active &&
     !mgr->audio.decoder_active && !mgr->audio.playpump_active){
    GST_TRACE ("no decoders or playpumps active, releasing Nexus resources");

    // true is for mute
    gst_nexus_mgr_release_playpumps_locked(mgr, true);

    gst_nexus_mgr_signal_resources_released_locked(mgr);
  }

  g_mutex_unlock( &mgr->resource_lock );
}

note: locking between two sink elements, callback thread and pes writer

All uses mgr->resource_lock. The point is that it is to protect mgr structure
which has handles and states. However not to guard to NEXUS calls. So can make a
NEXUS calls without locking.

GMutex resource_lock;


{stream-changed}
When plays DASH and see many stream changes for video, sink0. This shows that
there are many representation? True the number of changes matches to the num of
representation in mpd file.

$ ag "call sink|stream change|first PTS" 01-dash.log 

nexussink /gstnexusmgr.c:1937:gst_nexus_mgr_audio_first_pts_2nd_level_cb: KT: call sink audio first pts
nexussink /gstnexussink.c:1918:gst_nexus_sink_first_pts:<nexussink1> KT: first PTS
nexussink /gstnexusmgr.c:1937:gst_nexus_mgr_audio_first_pts_2nd_level_cb: KT: call sink audio first pts
nexussink /gstnexussink.c:1918:gst_nexus_sink_first_pts:<nexussink1> KT: first PTS

nexussink /gstnexussink.c:1722:gst_nexus_sink_stream_change:<nexussink0> KT: stream change
nexussink /gstnexussink.c:1722:gst_nexus_sink_stream_change:<nexussink1> KT: stream change
nexussink /gstnexussink.c:1722:gst_nexus_sink_stream_change:<nexussink0> KT: stream change

nexussink /gstnexusmgr.c:1914:gst_nexus_mgr_video_first_pts_2nd_level_cb: KT: call sink video first pts
nexussink /gstnexussink.c:1918:gst_nexus_sink_first_pts:<nexussink0> KT: first PTS

nexussink /gstnexussink.c:1722:gst_nexus_sink_stream_change:<nexussink0> KT: stream change
nexussink /gstnexussink.c:1722:gst_nexus_sink_stream_change:<nexussink0> KT: stream change


from mpd file:

<Representation id="V1" codecs="avc3.4d4015" height="288" width="512" bandwidth="356296" />
<Representation id="V2" codecs="avc3.4d401e" height="396" width="704" bandwidth="619088" />
<Representation id="V3" codecs="avc3.64001f" height="504" width="896" bandwidth="1330608" />
<Representation id="V4" codecs="avc3.640020" height="720" width="1280" bandwidth="2501216" />
<Representation id="V5" codecs="avc3.640028" height="1080" width="1920" bandwidth="4487408" />


note: see that less changed callback and ratio change than mpd file

nexussink /gstnexussink.c:1744:gst_nexus_sink_stream_change:<nexussink0> KT: stream change
nexussink /gstnexussink.c:1881:gst_nexus_sink_poll_decoder_status_locked:<nexussink0> 
KT: Video size or aspect ratio changed to size=0x0 PAR=0/0

nexussink /gstnexussink.c:1744:gst_nexus_sink_stream_change:<nexussink0> KT: stream change

nexussink /gstnexussink.c:1744:gst_nexus_sink_stream_change:<nexussink0> KT: stream change
nexussink /gstnexussink.c:1881:gst_nexus_sink_poll_decoder_status_locked:<nexussink0> 
KT: Video size or aspect ratio changed to size=512x288 PAR=1/1

nexussink /gstnexussink.c:1744:gst_nexus_sink_stream_change:<nexussink0> KT: stream change
nexussink /gstnexussink.c:1881:gst_nexus_sink_poll_decoder_status_locked:<nexussink0> 
KT: Video size or aspect ratio changed to size=1280x720 PAR=1/1


={============================================================================
*kt_dev_uv_oem_003* brcm playpump

<nesuxmgr>
typedef struct BcmNexus_StreamPlayer_Resources_Config {
    NEXUS_VideoCodec                        videoCodec;
    NEXUS_AudioCodec                        audioCodec;
    uint16_t                                audioPid;
    uint16_t                                videoPid;
    uint16_t                                numPlaypumps;
    NEXUS_TransportType                     transportType;
    NEXUS_CallbackDesc                      videoDataCallback;
    NEXUS_CallbackDesc                      audioDataCallback;
    NEXUS_KeySlotHandle                     decryptContext;
    NEXUS_CallbackDesc                      videoSourceCallback;
    NEXUS_CallbackDesc                      fifoEmptyCallback;
} BcmNexus_StreamPlayer_Resources_Config;

const BcmNexus_StreamPlayer_Resources *
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
    NEXUS_PlaypumpSettings playpumpSettings;

    // *callback* only use this 
    playpumpSettings.dataCallback = config->videoDataCallback;

    if (!config->transportType) {
      playpumpSettings.transportType = NEXUS_TransportType_eMpeg2Pes;
#if BCMEXUS_STREAM_VIDEO_ES || BCMEXUS_STREAM_AUDIO_ES
      playpumpSettings.transportType = NEXUS_TransportType_eEs;
#endif
    } else {
      playpumpSettings.transportType = config->transportType;
    }

    rc = NEXUS_Playpump_SetSettings(resources->playpump[i], &playpumpSettings);
}


<playpump> nexus ref sw

/**
Summary:
Function prototype used by NEXUS_CallbackDesc.
**/
typedef void (*NEXUS_Callback)(void *context, int param);

/*
Summary:
Standard definition of a callback in Nexus.
*/
typedef struct NEXUS_CallbackDesc {
    NEXUS_Callback callback; /* Function pointer */
    void *context;           /* First parameter to callback function. */
    int param;               /* Second parameter to callback function. */
} NEXUS_CallbackDesc;


/**
Summary:
Settings for playpump
**/
typedef struct NEXUS_PlaypumpSettings
{
    NEXUS_TransportType transportType;          
    /* Type of data stream going into playpump. Note that if the data must be
     * packetized, you can get the resulting NEXUS_TransportType from
     * NEXUS_PidChannelStatus. */

    NEXUS_TransportType originalTransportType;  
    /* If the user packetizes intput to playpump, this describes the input. If
     * there is no packetization, this is member should be set to
     * NEXUS_TransportType_eUnknown. */ 

    bool continuityCountEnabled;                
    /* If true, transport will check for correct continuity counters and
     * discard bad packets.  This must be set to false for trick modes.
     * Default is false. */ 

    /* Type of original transport stream */

    // /**
    // Summary:
    // Determines method of feeding data into playpump.
    // **/
    // typedef enum NEXUS_PlaypumpMode
    // {
    //     NEXUS_PlaypumpMode_eFifo,         
    //     /* Playpump allocates a block of memory which serves as the
    //     playback fifo.  The user must copy data into this buffer with the
    //     CPU or DMA. */
    //
    // } NEXUS_PlaypumpMode;
    
    NEXUS_PlaypumpMode mode;                    
    /* Method of pushing data into playpump. This setting determines the
     * format of data the app will feed to playpump. */

    // *callbacks*
    NEXUS_CallbackDesc dataCallback;            
    /* Callback when space becomes available. User should call
     * NEXUS_Playpump_GetBuffer. You will not receive another callback until
     * NEXUS_Playpump_GetBuffer is called. */

    NEXUS_CallbackDesc errorCallback;           
    /* Callback called when error was detected in ptocessing of the stream data
     */

    NEXUS_CallbackDesc ccError;                 
    /* Continuity Count Error - raised when continuity counter of next packet
    does not have the next counter value.  continuityCountEnabled must be set to
    true. See NEXUS_PidChannelStatus.continuityCountErrors to get a count of
    errors per pid. */

    NEXUS_CallbackDesc teiError;                
    /* Transport Error Indicator - error status from a demodulator */


    int playRate;                               
    /* Rate in units of NEXUS_NORMAL_PLAY_SPEED. It's used for certain type of
     * streams to control the direction of presentation time. */
    // /**
    // Summary:
    // Base rate for normal play used in NEXUS_PlaypumpSettings.playRate.
    // **/
    // #define NEXUS_NORMAL_PLAY_SPEED 1000

    NEXUS_DmaHandle securityDma;                /* Instance of DMA that is used for security processing, NULL if security processing is not required */
    NEXUS_DmaDataFormat securityDmaDataFormat;
    NEXUS_KeySlotHandle securityContext;

    unsigned maxDataRate;                       /* Maximum data rate for the playback parser band in units of bits per second. Default is typically 108000000 (i.e. 108 Mbps).
                                                   If you increase this, you need to analyze total transport bandwidth and overall system bandwidth. */
    bool blindSync;                             /* Force transport to not look for sync bytes. */

    /* all pass settings */
    bool allPass;                               
    /* If true, NEXUS_Playpump_OpenPidChannel's pid param is ignored and the
     * resulting pid channel can be used for all-pass record.  Also set
     * acceptNullPackets to true if you want to capture the entire stream.
     * When opening the allPass pid channel, set
     * NEXUS_PlaypumpOpenPidChannelSettings.pidSettings.pidChannelIndex = 16 +
     * playpump index number. */ bool acceptNullPackets;
    /* If true and allPass is true, NULL packets are not discarded.  */


note: TS but shows no difference when TS and ES type play

    struct {
        NEXUS_TransportTimestampType type;      
        /* The type of timestamping in this stream. */
        
        uint16_t pcrPacingPid;                  
        /* Some chips can pace playback using a PCR pid. Set
         * timestamp.pcrPacingPid to a non-zero value and set timestamp.pacing
         * = true. */

        bool pacing;                            
        /* If true, pace this stream using embedded timestamp information or
         * using pcr-based pacing.  For timestamp-based pacing, set
         * timestampType as well.  For pcr-based pacing, set pcrPacingPid as
         * well. */

        unsigned pacingMaxError;                
        /* Set the maximum allowable timestamp error (TS_RANGE_ERROR) used
         * during playback pacing. */

        NEXUS_Timebase timebase;                
        /* Timebase used for timestamp. Use NEXUS_Timebase_eInvalid for
         * freerun. */

        bool parityCheckDisable;                
        /* Set true to disable timestamp parity check. */

        bool pacingOffsetAdjustDisable;         
        /* Set true to adjust the pacing timestamps with the reference offset
         * */

        bool resetPacing;                       
        /* Set true if you want the pacing start bit reset when a
         * TS_RANGE_ERROR interrupt occurs */

        bool forceRestamping;                   
        /* Set true if you want to restamp the incoming timestamps or if you
         * are recording and want to add timestamps */

    } timestamp;

} NEXUS_PlaypumpSettings;


local/include/refsw/nexus/modules/core/7420/include/nexus_types.h

/**
Summary:
The transport format, or stream type, of digital data.

Description:
This includes a variety of container classes and standard stream muxes.

See Also:
NEXUS_PidChannelSettings
NEXUS_StcChannelSettings
**/
typedef enum NEXUS_TransportType {
    NEXUS_TransportType_eUnknown,   /* Unknown stream format */
    NEXUS_TransportType_eEs,        /* Elementary stream. No container or muxing. */

    NEXUS_TransportType_eTs,        /* MPEG2 transport stream */

    NEXUS_TransportType_eMpeg2Pes,  
    /* MPEG2 packetized elementary stream, this includes MPEG2 Program Stream
     * streams */

    NEXUS_TransportType_eVob,       /* DVD VOB, this is subset of MPEG2 Program Stream, special processing is applied for VOB streams */
    NEXUS_TransportType_eMpeg1Ps,   /* MPEG1 program stream */
    NEXUS_TransportType_eDssEs,     /* DSS with ES payload (used for SD) */
    NEXUS_TransportType_eDssPes,    /* DSS with PES payload (used for HD) */
    NEXUS_TransportType_eAsf,       /* Advanced Systems Format */
    NEXUS_TransportType_eAvi,       /* Audio Video Interleave */
    NEXUS_TransportType_eMp4,       /* MP4 (MPEG-4 Part12) container */
    NEXUS_TransportType_eFlv,       /* Flash video container */
    NEXUS_TransportType_eMkv,       /* Matroska container */
    NEXUS_TransportType_eWav,       /* WAVE audio container */
    NEXUS_TransportType_eMp4Fragment,  /* separate 'moof' boxes from the MP4 (MPEG-4 Part12) container */
    NEXUS_TransportType_eRmff,       /* RMFF container */
    NEXUS_TransportType_eMax
} NEXUS_TransportType;


/**
Summary:
Status returned by NEXUS_Playpump_GetStatus
**/
typedef struct NEXUS_PlaypumpStatus
{
    bool started;               /* Has NEXUS_Playpump_Start been called? */
    size_t fifoDepth;           /* Depth in bytes of the playback buffer */
    size_t fifoSize;            /* Size in bytes of the playback buffer */
    size_t descFifoDepth;       /* Number of active (i.e. busy) descriptors */
    size_t descFifoSize;        /* Number of allocated descriptors */
    void *bufferBase;           /* attr{memory=cached} Pointer to the base of the playback buffer.
                                   This can be used for calculating your exact position
                                   in the buffer for alignment considerations. */
    uint64_t bytesPlayed;       /* Total number of bytes played since starting */
    unsigned index;             /* Index of this playpump */

    unsigned pacingTsRangeError; /* Number of TS_RANGE_ERROR's if pacing is activated. */
    unsigned syncErrors;         /* count of sync errors found in the stream */
    unsigned resyncEvents;       /* count of resync handled in the stream */
    unsigned streamErrors;       /* count of other errors found in the stream */
    NEXUS_PtsType mediaPtsType;    /* Type of the current PTS */
    uint32_t mediaPts;    /* if playpump does inline media streeam conversion (i.e. AVI to PES), then this is the last known PTS (in units of 45KHz) for the first converted pid (track) */
} NEXUS_PlaypumpStatus;


/*
Summary:
Get a pointer and size for the next location in the buffer which can accept
playpump data.

Description:
NEXUS_Playpump_GetBuffer is non-destructive. You can safely call it multiple
times.

The buffer and size returned by NEXUS_Playpump_GetBuffer are valid until you
call NEXUS_Playpump_Flush or NEXUS_Playpump_WriteComplete.

The size returned by NEXUS_Playpump_GetBuffer can be limited by two things:
space in the ring buffer or free descriptors

used to send data to the transport block. If you are performing trick modes with
lots of small reads, you may find that NEXUS_Playpump_GetBuffer says there is no
space available even though NEXUS_PlaypumpStatus reports free space. The
solution is to increase the number of descriptors in NEXUS_PlaypumpOpenSettings.
*/

NEXUS_Error NEXUS_Playpump_GetBuffer(

    NEXUS_PlaypumpHandle playpump,

    void **pBuffer, 
    /* [out] attr{memory=cached} pointer to memory mapped region that is ready
     * for playback data */

    size_t *pSize 
    /* [out] total number of writeable, contiguous bytes which buffer is
     * pointing to */
    );

/**
Summary:
Notify Playpump of how much data was added into the buffer.

Description:
You can only call NEXUS_Playpump_WriteComplete once after a
NEXUS_Playpump_GetBuffer call.  After calling it, you must call
NEXUS_Playpump_GetBuffer before adding more data.

The skip parameter allows an application to copy data into the playpump buffer
with whatever alignment it desired. This is needed for "direct I/O" from disk
drives which requires all memory access to be page aligned (e.g. 4K).  
**/

NEXUS_Error NEXUS_Playpump_WriteComplete(

    NEXUS_PlaypumpHandle playpump,

    size_t skip,            
    /* skip is the number of bytes at the beginning of the current buffer
     * pointer which Playpump should skip over. */

    size_t amountUsed       
    /* amountUsed is the number of bytes, following any skip bytes, which
     * Playpump should feed into transport. */

    );


src/refsw/nexus/modules/audio/include/nexus_audio_decoder_types.h

NEXUS_CallbackDesc ptsError;            

/* Fires on any PTS discontinuity. This callback is used for application
 * notification. No response is required for TSM. 
 */


={============================================================================
*kt_dev_uv_oem_003* brcm reference sw

to get source:
https://wiki.youview.co.uk/display/canvas/2015/03/05/OEM_STAGING_TOOLS-REL_2.0?src=search

to see source in stash:
https://stash.dev.youview.co.uk/projects/STB

to see examples:
./refsw/nexus/examples/dvr/multiplexed_playpump.c


={============================================================================
*kt_dev_uv_oem_004* brcm stc

/*
Summary:
TSM modes used in NEXUS_StcChannelSettings
*/
typedef enum NEXUS_StcChannelMode
{
    NEXUS_StcChannelMode_ePcr,  /* Live TSM.
                                    STC values are derived from the stream's PCR using the DPCR block.
                                    The PCR_OFFSET block pipelines the offsets in the ITB to handle PCR discontinuities.
                                    CDB/ITB buffer levels are determined by relative PCR/PTS muxing. */
    NEXUS_StcChannelMode_eAuto, /* Playback TSM.
                                    Decoders report PTS values and the StcChannel sets the STC.
                                    The PCR_OFFSET block is not used and offsets are not pipelined.
                                    CDB/ITB buffer levels are determined by the first decoder to fill its buffer
                                    and by relative audio/video muxing. */
    NEXUS_StcChannelMode_eHost, /* Playback TSM where the application is responsible for setting the STC.
                                    This has all the same characteristics as eAuto, except the PTS interrupts
                                    from the decoder do not set the STC. */
    NEXUS_StcChannelMode_eMax
} NEXUS_StcChannelMode;

/*
Summary:
This describes the behavior for STC seeding during PVR when StcChannelMode is set to eAuto
*/
typedef enum NEXUS_StcChannelAutoModeBehavior
{
    NEXUS_StcChannelAutoModeBehavior_eFirstAvailable, /* The STC will be driven by either the video or audio PTS, depending on stream muxing and error conditions. */
    NEXUS_StcChannelAutoModeBehavior_eVideoMaster,    /* The video PTS will always drive the STC.  Audio errors will be ignored. */
    NEXUS_StcChannelAutoModeBehavior_eAudioMaster,    /* The audio PTS will always drive the STC.  Video errors will be ignored. */
    NEXUS_StcChannelAutoModeBehavior_eMax
} NEXUS_StcChannelAutoModeBehavior;


	stcChannelSettings.mode = NEXUS_StcChannelMode_eAuto;
	if( CTVideoElementaryStream==mgr->settings.contentType ||
	  (CTTransportStream==mgr->settings.contentType && PADDING_PID!=mgr->settings.video_pid)){

      GST_DEBUG ("=> KT: STC video master");

	  /* Change the STC settings to use the video stream as the STC master */
	  stcChannelSettings.modeSettings.Auto.behavior = NEXUS_StcChannelAutoModeBehavior_eVideoMaster;


/*
Summary:
Change the rate of the STC. Rate is calculated as: rate = (increment) / (prescale + 1).

Description:
The following are some examples of how the increment and prescale parameters
map to some typical rates:

    1, 0 = 1x (normal speed)
    0, X = 0.0x (paused)
    1, 1 = 0.5x (slow motion)
    2, 0 = 2x (fast forward)
    8, 9 = 0.8x (slow motion, audio trick mode may be possible)
    12, 9 = 1.2x (fast forward, audio trick mode may be possible)

Be aware that the audio and video decoders may not be able to decoder at faster than 1.0x speeds.
They are limited by overall memory bandwidth and RTS (real time scheduler) programming.
Also, speeds that may work for low bitrate (SD) streams or low-complexity streams may not work for
high bitrate (HD) streams or high-complexity streams.

If a decoder cannot keep up with the STC rate, it will drop data. This will result in
video drops or audio pops. Video drops may be acceptable because it will be similar to a host trick mode.
Audio pops are usually not acceptable.

Some versions of the audio decoder support 0.8x and 1.2x audio trick modes.
For any other STC trick mode, the audio decoder should be muted (for fast resumption to normal play) or stopped.
If you are using the Nexus Playback module, this will be done automatically if NEXUS_PlaybackSettings.stcTrick is true.

There is no reverse stc rate.
*/
NEXUS_Error NEXUS_StcChannel_SetRate(
    NEXUS_StcChannelHandle stcChannel,
    unsigned increment,
    unsigned prescale
    );


={============================================================================
*kt_dev_uv_oem_005* brcm audio

// 1. use audio decoder handle that got from nexus-manager.
// 2. stop decoder before changes settings.
// 3. use to change callback registration to nexus since _AudioDecoderSettings
//    do not have "rate" field.

NEXUS_AudioDecoder_Stop( mgr->resources->audioDecoder[0] );

NEXUS_AudioDecoder_SetSettings( mgr->resources->audioDecoder[0], &audio_decoder_settings );


// 1. use audio decoder handle that got from nexus-manager.

note: no rates

typedef struct NEXUS_AudioDecoderStartSettings
{
    NEXUS_PidChannelHandle pidChannel;  /* Input from transport */

    // note: codec
    NEXUS_AudioCodec codec;             /* Format of data coming from the pid channel */
    NEXUS_StcChannelHandle stcChannel;  /* Connection to clock for TSM and lipsync with VideoDecoder. If NULL, decode in vsync mode. */

    bool targetSyncEnabled;             /* If true, normal frame sync operation will be used (default).  This flag can be set to false
                                           for certification applications that require the last frame of the input buffer to be consumed
                                           without the audio decoder finding the start of the successive frame.  */
    ...

} NEXUS_AudioDecoderStartSettings;


gst_nexus_mgr_start_audio_locked(GstNexusMgr * mgr, gboolean start_decoder)
{
    NEXUS_AudioDecoderStartSettings audioProgram;
    NEXUS_AudioDecoder_GetDefaultStartSettings( &audioProgram );

    // note: codec
    audioProgram.codec = gst_nexus_mgr_convert_audio_codec(&mgr->settings);

    audioProgram.pidChannel = mgr->resources->audioPidChannel;
    audioProgram.stcChannel = mgr->resources->stcChannel;

    NEXUS_AudioDecoder_Start( mgr->resources->audioDecoder[0], &audioProgram );
}

<Representation audioSamplingRate="24000" bandwidth="32000" codecs="mp4a.40.5" id="audio_eng=32000">

static NEXUS_AudioCodec
gst_nexus_mgr_convert_audio_codec(const GstNexusStreamSetting * settings)
{
  switch( settings->audio_codec ) {
  case ACODEC_AAC_LOAS:
	return NEXUS_AudioCodec_eAacPlusLoas;
	break;
  case ACODEC_AAC_ADTS:
	return NEXUS_AudioCodec_eAacAdts;
	break;
  case ACODEC_AAC:
	return NEXUS_AudioCodec_eAac;
	break;
  case ACODEC_MP2:
	return NEXUS_AudioCodec_eMpeg;
	break;	  
  case ACODEC_MP3:
	return NEXUS_AudioCodec_eMp3; 
	break;	  
  default:
	break;
  }
  return NEXUS_AudioCodec_eUnknown;
}


BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
   BcmNexus_Audio_Set_Default_Path();
		NEXUS_AudioPlayback_Start(BcmNexus_State.sharedMem->pcmPlayback[0], &BcmNexus_State.sharedMem->audioStartSettings);


$ pkg-config --cflags-only-other nexusMgr | ag AUDIO_DSP

-DCONFIG_BCM_FIX_AUDIO_DSP_MIXER

#if !defined(CONFIG_BCM_FIX_AUDIO_DSP_MIXER)
   /* After re-connected to mixer, all modules have to be started. */
   NEXUS_AudioPlayback_Start(BcmNexus_State.sharedMem->pcmPlayback[0], &BcmNexus_State.sharedMem->audioStartSettings);
#endif

note: So not used.


typedef struct NEXUS_AudioDecoderStatus
{
    bool    started; /* true if decoder was started */

    bool tsm;        /* AudioDecoder is in TSM (time stamp managed) mode. TSM may be not applicable (e.g. ES streams), may be disabled directly
                        by the user (setting stcChannel = NULL) or indirectly by other API's (e.g. trick modes, ASTM, etc.) */

    bool locked;     /* True if the decoder has found a valid frame sync */

    NEXUS_AudioCodec codec;     /* Audio stream format */
    unsigned sampleRate;        /* In Hz */
    unsigned timebase;          /* STC index. This is derived from NEXUS_AudioDecoderStartSettings.stcChannel. The name is unfortunate because this is not a timebase. */

    unsigned framesDecoded;     /* Total number of frames decoded since start was called. */
    unsigned frameErrors;       /* Total number of frame errors since start was called. */
    unsigned dummyFrames;       /* Total number of dummy (zero/null) frames filled by the decoder since start was called. */
    unsigned numFifoOverflows;  /* Total number of FIFO overflows since start was called. */
    unsigned numFifoUnderflows; /* Total number of FIFO underflows since start was called. */
    uint64_t numBytesDecoded;   /* total number of ES bytes decoded since last start or flush.  Applicable to transport (NEXUS_PidChannel) input only. */

    union
    {
        struct
        {
            unsigned bitStreamId;
            NEXUS_AudioAc3Acmod acmod;
            unsigned frameSizeCode;
            unsigned bitrate;           /* bitrate in Kbps */
            bool lfe;
            bool copyright;  /* true if the copyright bit is asserted */
        } ac3;  /* Applies to both AC3 and AC3+ */
        struct
        {
            NEXUS_AudioMpegChannelMode channelMode;
            NEXUS_AudioMpegLayer layer;
            NEXUS_AudioMpegEmphasis emphasis;
            unsigned bitrate;           /* bitrate in Kbps */
            unsigned numSamples;    /* Number of decoded samples */
            bool original;
            bool copyright;  /* true if the copyright bit is asserted */
        } mpeg; /* Valid for MPEG and MP3 */
        struct
        {
            NEXUS_AudioAacAcmod acmod;
            NEXUS_AudioAacProfile profile;
            unsigned bitrate;           /* bitrate in Kbps */
            unsigned numSamples;        /* Number of decoded samples */
            bool lfe;
            bool pseudoSurround;
            bool drc;
            bool stereoMatrix;          /* True if a stereo downmix matrix is present */
            unsigned matrixIndex;       /* A two-bit value indicating the coefficient to be used in a stereo downmix */
            unsigned numLfeChannels;
            unsigned numBackChannels;
            unsigned numSideChannels;
            unsigned numFrontChannels;
        } aac;  /* Applies to AAC, AAC-HE (SBR), and Dolby Pulse */
        struct
        {
            NEXUS_AudioDtsAmode amode;              /* DTS audio channel arrangement */
            unsigned pcmResolution;                 /* Quantization resolution of source PCM samples (in bits) */
            NEXUS_AudioDtsCopyHistory copyHistory;  /* Copy history of the stream */
            unsigned lfeInterpolation;              /* LFE interpolation factor */
            NEXUS_AudioDtsExtension extensionDescriptor; /* Extension descriptor code from the stream header. Valid if extensionPresent is true */
            unsigned bitRate;                       /* Bitrate in kbps.  0 for Open, Variable, or Lossless coded streams (bitRateCode=29..31) */
            unsigned version;                       /* Version Number */
            uint8_t bitRateCode;                    /* Raw bitrate value coded in the stream header */
            bool esFormat;                          /* If true, the left and right surround channels are mastered in ES format */
            bool lfe;                               /* True if LFE is present */
            bool extensionPresent;                  /* True if extended audio coding data is present in the stream */
            bool crc;                               /* True if a CRC is present */
            bool hdcdFormat;                        /* True if the source content is mastered in HDCD format */
            bool drc;                               /* True if DRC (dynamic range compression) is present */
            bool downmixCoefficients;               /* True if downmix coefficients are present in the stream */
            bool neo;                               /* True if DTS NEO is enabled */
            unsigned frameSize;                     /* Total bytes in the current frame including primary and extension data */
            unsigned numChannels;                   /* Total number of channels (primary+LFE) supported by the decoder depending on user configuration */
            unsigned pcmFrameSize;                  /* Total size of the current PCM frame in bytes (valid if frameSize ranges between 95..16383) */
            unsigned numPcmBlocks;                  /* Number of coded PCM blocks */
        } dts;  /* Applies to DTS, DTS-HD */
        struct
        {
            unsigned bitRate;           /* In kbps */
            bool original;
            bool copyright;
            bool crc;
            bool stereo;                /* True if stereo data is present, false if mono data is present */
            unsigned version;           /* Version - 1 or 2 */
        } wma;
        struct
        {
            unsigned bitRate;           /* In kbps */
            bool original;
            bool copyright;
            bool crc;
            bool lfe;
            unsigned version;           /* Version - 1 or 2 is WMA Standard, 3 is WMA Pro */
            NEXUS_AudioWmaProStereoMode stereoMode;
            NEXUS_AudioWmaProAcmod acmod;
        } wmaPro;
        struct
        {
            unsigned numChannels;
        } pcmWav;
        struct
        {
            NEXUS_AudioAmrBitrate bitRate;
        } amr;
        struct
        {
            unsigned frameSize;             /* In bytes */
            unsigned numBlocks;             /* Number of short window mdct blocks in the frame.  There are 128 samples per block. */
            NEXUS_AudioDraAcmod acmod;      /* Channel coding mode */
            bool lfe;
            NEXUS_AudioDraStereoMode stereoMode;
        } dra;
        struct
        {
            bool stereo;        /* True if stereo, false if mono */
            unsigned frameSize; /* Frame size in bytes */
        } cook;
    } codecStatus;

    unsigned fifoDepth; /* depth in bytes of the compressed buffer */
    unsigned fifoSize; /* size in bytes of the compressed buffer */

    uint32_t pts;              /* current PTS of the audio decoder */
    NEXUS_PtsType ptsType;     /* current PTS type of the codec */
    int32_t ptsStcDifference;  /* current PTS-STC difference including lipsync adjustments */
    unsigned ptsErrorCount;    /* counter for number of PTS errors since start of decode */
    unsigned queuedFrames;     /* Number of compressed frames in the queue */

    uint8_t wordLength;    /* For SPDIF/HDMI inputs, this is the bits per sample of PCM data */
    uint8_t maxWordLength; /* For SPDIF/HDMI inputs, this is the max bits per sample of PCM data */

    uint8_t algorithmProfileId;     /* Profile ID of the current decode algorithm */
    uint8_t algorithmVersionId[4];  /* Version ID of the current decode algorithm */
    uint8_t firmwareVersionId;      /* Firmware Version ID of the current decode algorithm */
} NEXUS_AudioDecoderStatus;


={============================================================================
*kt_dev_uv_oem_006* brcm video

/opt/oem-staging/humax-dtr_t1000/usr/local/include/refsw/nexus/modules/
video_decoder/7420/include/nexus_video_decoder.h

/**
Summary:
Picture information for the currently displayed picture or the first decoded
picture for a new decode.

Description:
NEXUS_VideoDecoderStreamInformation picture information differs from
NEXUS_VideoDecoderStatus information in that NEXUS_VideoDecoderStatus returns
information on the 'currently' displayed picture. When starting a new decode,
this could be the last picture from the previous decode.

NEXUS_VideoDecoderStreamInformation always gives picture information from this
decode.  When starting decode, after the first picture is decoded, it will be
held until its PTS matures.  NEXUS_VideoDecoderStreamInformation will have
information about that first picture, before it is displayed.  After the first
picture is displayed, NEXUS_VideoDecoderStreamInformation will return the same
picture information as NEXUS_VideoDecoderStatus.

Because this information is available 'before' display, it is similar to the old
MPEG sequence header interrupt. However, after that first picture is displayed,
it does not provided any advance warning like a sequence header interrupt.

note:
Any changes in this information will generate a
NEXUS_VideoDecoderSettings.streamChanged callback.

Used in NEXUS_VideoDecoder_GetStreamInformation
**/

typedef struct NEXUS_VideoDecoderStreamInformation
{
    uint32_t sourceHorizontalSize; 
    /* width of active area. possibly clipped from coded size. */

    uint32_t sourceVerticalSize; 
    /* height of active area. possibly clipped from coded size. */

    uint32_t codedSourceHorizontalSize; /* coded width */
    uint32_t codedSourceVerticalSize; /* coded height */

    uint32_t displayHorizontalSize; 
    /* intended display width of active area needed to preserve correct aspect
     * ratio. this is not the actual display width used. */
    

    uint32_t displayVerticalSize; 
    /* intended display height of active area needed to preserve correct aspect
     * ratio. this is not the actual display height used. */

    NEXUS_AspectRatio aspectRatio;

    uint16_t sampleAspectRatioX; 
    uint16_t sampleAspectRatioY; /* See comments for sampleAspectRatioX */

    /* Only valid if aspectRatio is NEXUS_AspectRatio_eSar.
     * NEXUS_AspectRatio_eSar is only used for some codecs. If used, the
     * source's aspect ratio is calculated as the ratio of
     * sampleAspectRatioX/sampleAspectRatioY. sampleAspectRatioX and
     * sampleAspectRatioY should not be used except as a ratio. */

    NEXUS_VideoFrameRate frameRate;
    NEXUS_ColorPrimaries colorPrimaries;
    NEXUS_TransferCharacteristics transferCharacteristics;
    NEXUS_MatrixCoefficients matrixCoefficients;
    bool frameProgressive;
    bool streamProgressive;
    int32_t horizontalPanScan;
    int32_t verticalPanScan;

    uint32_t lowDelayFlag;       /* delay flag from the sequence extension */
    uint32_t fixedFrameRateFlag; /* fixed_frame_rate_flag from AVC VUI (video usability info) */
} NEXUS_VideoDecoderStreamInformation;


/opt/oem-staging/humax-dtr_t1000/usr/local/include/refsw/nexus/modules/
video_decoder/7420/include/nexus_video_decoder_types.h

/**
Summary:
Current status of the video decoder.

Description:
The picture format information comes from the picture currently being fed to the
Display.

note:
See NEXUS_VideoDecoderSettings.sourceChanged for notification when the picture
format changes.
When set a callback to get this, got a core saying on T2100 on 2015.09:
Program terminated with signal 4, Illegal instruction.
**/

typedef struct NEXUS_VideoDecoderStatus
{
    bool started;           /* true if decoder was started */

    struct
    {
        unsigned width, height; /* dimensions in pixels */
    } source, coded, display; 

    /* source is the active area size. coded is the coded area. it could be
     * greater than the active area because of clipping. display is the display
     * size needed to preserve aspect ratio. the actual display size is
     * determined by the NEXUS_VideoWindowSettings. 
     */


    NEXUS_AspectRatio aspectRatio;  
    /* aspect ratio of the source */

    NEXUS_VideoFrameRate frameRate; 
    /* frame rate of the source */

    bool interlaced;          
    /* true if the source is interlaced, regardless of scanout requirements.
                                 Note that VideoInputStatus.videoFormat will
                                 report interlaced or progressive based on
                                 scanout, which is not necessarily the source
                                 coding. Some progressive streams must be
                                 scanned out as fields. */

    NEXUS_VideoFormat format; 
    /* The video format is derived from source.height, frameRate and interlaced
     * fields. 
     */


    NEXUS_VideoProtocolLevel protocolLevel;
    NEXUS_VideoProtocolProfile protocolProfile;

    bool muted;               /* VideoDecoder is feeding muted pictures to Display */
    NEXUS_VideoDecoderTimeCode timeCode; /* last encoded timecode found in the stream */
    unsigned long pictureTag; /* last picture tag found in the stream */
    
    /* TSM status */                                 
    bool tsm;                 /* VideoDecoder is in TSM (time stamp managed) mode. TSM may be not applicable (e.g. ES streams), may be disabled directly
                                 by the user (setting stcChannel = NULL) or indirectly by other API's (e.g. trick modes, ASTM, etc.) */
    uint32_t pts;             /* Current PTS of the video decoder
                                 Note: the stc is available from NEXUS_StcChannel_GetStc */
    int32_t  ptsStcDifference; /* Current PTS-STC difference including lipsync adjustments */
    NEXUS_PtsType ptsType;    /* Type of the current PTS */
    bool firstPtsPassed;      /* The first PTS for this stream has passed. This means that the information in this status structure is for pictures currently being displayed.
                                 See NEXUS_VideoDecoderSettings.firstPtsPassed for a callback related to this status. */

    /* buffer status */                                 
    unsigned fifoDepth;       /* depth in bytes of the compressed buffer */
    unsigned fifoSize;        /* size in bytes of the compressed buffer */
    unsigned queueDepth;      /* the number of decoded pictures currently ready to be displayed */
    unsigned cabacBinDepth;   /* depth in bytes of the cabac bin buffer */
    unsigned enhancementFifoDepth; /* depth in bytes of the enhancement compressed buffer */
    unsigned enhancementFifoSize; /* size in bytes of the enhancement compressed buffer */

    /* cumulative status */
    unsigned numDecoded;      /* total number of decoded pictures since Start */
    unsigned numDisplayed;    /* total number of display pictures since Start */
    unsigned numDecodeErrors; /* total number of decoder errors since Start */
    unsigned numDecodeOverflows; /* total number of overflows of the input to the decoder since Start */
    unsigned numDisplayErrors;/* total number of display manager errors since Start. This includes parity mismatches which may result in glitching on the display. */
    unsigned numDecodeDrops;  /* total number of pictures dropped by the decoder since Start */
    unsigned numPicturesReceived; /* total number of pictures which the decoder has received since Start. This includes pictures which are skipped due to TSM, NEXUS_VideoDecoderDecodeMode,
                                     or other factors. */
    unsigned numDisplayDrops; /* total number of pictures dropped by the display manager due to TSM failures since Start */
    unsigned numDisplayUnderflows;  /* total number of times the display manager was unable to deliver a new picture since Start */
    unsigned ptsErrorCount;   /* counter for number of PTS error interrupts since Start */
    unsigned avdStatusBlock;  /* snap shot of the AVD channel status. See NEXUS_CHANNELSTATUS_AVD_XXX macros for possible values. */
    unsigned numWatchdogs;    /* total number of watchdog events for the device since NEXUS_VideoDecoderModule_Init. the count is per AVD device, not per VideoDecoder channel. */
    uint64_t numBytesDecoded; /* total number of ES bytes decoded since last start or flush */
} NEXUS_VideoDecoderStatus;


/opt/oem-staging/humax-dtr_t1000/usr/local/include/refsw/nexus/modules/
video_decoder/7420/include/nexus_video_decoder.h

/*
Summary:
Video decoder settings.

Description:
These settings can be changed before or after NEXUS_VideoDecoder_Start.

Used in NEXUS_VideoDecoder_GetSettings and NEXUS_VideoDecoder_SetSettings.
*/

typedef struct NEXUS_VideoDecoderSettings
{
    bool freeze;            /* hold current picture. decoder can discard incoming data. */
    bool mute;              /* black out video, but keep decoding */
    bool userDataEnabled;   /* Enable raw userdata capture with NEXUS_VideoDecoder_GetUserDataBuffer */

    bool panScanEnabled;    /* Allow decoder to process panscan vectors if present. */

    NEXUS_VideoDecoder_ChannelChangeMode channelChangeMode;

    unsigned fifoThreshold; /* If set, this can limit the maximum FIFO depth to a value <= the value specified
                               in NEXUS_VideoDecoderOpenSettings.fifoSize.  If 0, the entire FIFO can fill.  */

    int ptsOffset;  /* Add an offset used in the decoder's TSM equation. Measured in PTS units (45KHz for MPEG2TS, 27MHz for DSS).
                       This is added to any PTS offset also set by SyncChannel. */

    unsigned discardThreshold; /* in PTS units. defaults to 0, which allows Nexus to set the default discard threshold based on codec and trick mode state.
                                  if PTS-STC is greater than the discard threshold, the picture is dropped. */

    // note:
    NEXUS_CallbackDesc sourceChanged; 
    /* Fires when the format (e.g. size, framerate) of pictures being fed to
     * Display changes. Call NEXUS_VideoDecoder_GetStatus to get the current
     * format information. 
     */

    NEXUS_CallbackDesc streamChanged; 
    /* Fires when the format (e.g. size, framerate) of pictures being decoded
     * changes. This is similar to an MPEG sequence header interrupt, but with
     * some important differences. See NEXUS_VideoDecoderStreamInformation for a
     * complete description. Call NEXUS_VideoDecoder_GetStreamInformation to
     * get the new video format information.
     */

    NEXUS_CallbackDesc appUserDataReady; 
    /* Fires when application userdata is available. userDataEnabled must be
     * true. */

    NEXUS_CallbackDesc ptsError;         
    /* Fires on any PTS discontinuity. This callback is used for application
     * notification. No response is required for TSM. */


    NEXUS_CallbackDesc firstPts;         
    /* Fires when the decoder receives the first PTS after Start.  This event is
     * also called "request STC" because the decoder needs StcChannel to set the
     * STC in Auto mode. This callback is used for application notification. No
     * response is required for TSM. */


    NEXUS_CallbackDesc firstPtsPassed;   
    /* Fires when the decoder allows the first picture to pass to the display
     * after TSM pass.  This callback is used for application notification. No
     * response is required for TSM. */


    NEXUS_CallbackDesc fifoEmpty;        /* Fires when the source FIFO becomes empty during normal decode, usually because of the loss of the source. */

    NEXUS_CallbackDesc afdChanged;       /* Fires when the NEXUS_VideoDecoderUserDataStatus.afdValue (active format description) changes. */

    NEXUS_CallbackDesc decodeError;      /* Fires when the decoder reports an error. Call NEXUS_VideoDecoder_GetStatus and check numDecodeErrors. */

    bool preferredUserDataFormat;        /* Whatever format is set by NEXUS_VideoDecoder_SetUserDataFormatFilter is treated as the preferred format, but
                                            until that format is detected, VideoDecoder will operate in NEXUS_UserDataFormat_eAny mode.
                                            When the preferred format is detected, VideoDecoder will switch to the preferred mode until decode is stopped. */
    bool dropFieldMode;                  /* By default, if VideoDecoder needs to drop pictures because of TSM, it will drop field pairs. This prevents
                                            any jitter from the deinterlacer. However, for 60->50Hz conversion dropping field pairs may result in motion judder.
                                            By setting dropFieldMode to true, VideoDecoder will drop only single fields and 60->50Hz conversion will only have slight jitter instead. */
    bool manualPowerState;               /* If true, internal hardware state will be left up, even when VideoDecoder is disconnected.
                                            See NEXUS_VideoDecoder_SetPowerState for manual control if manualPowerState = true.
                                            If false (default), internal HW state will be automatically brought up on NEXUS_VideoWindow_AddInput and down on NEXUS_VideoWindow_RemoveInput.
                                            Bringing down internal HW state results in reduced power consumption. */
    NEXUS_StillContentInterpolationMode stillContentInterpolationMode;
    NEXUS_MovingContentInterpolationMode movingContentInterpolationMode;
    NEXUS_VideoDecoderScanMode scanMode; /* Must be set before calling NEXUS_VideoWindow_AddInput. */
    bool customSourceOrientation; /* allows application to override sources orientation derived by the decoder */
    NEXUS_VideoDecoderSourceOrientation sourceOrientation; /* video orientation for 3D sources, ignored if customSourceOrientation is false */
    NEXUS_VideoDecoderHorizontalOverscanMode horizontalOverscanMode;

    NEXUS_VideoCodec supportedCodecs[NEXUS_VideoCodec_eMax]; /* List of codecs that can be decoded. Use eNone for unfilled slots.
        This is defaulted by NEXUS_VideoDecoderModuleSettings.supportedCodecs[].
        You must set this before your first NEXUS_VideoDecoder_Start or after a NEXUS_VideoInput_Shutdown to take effect. */
} NEXUS_VideoDecoderSettings;

={============================================================================
*kt_dev_uv_oem_005* gstnexussink


={============================================================================
*kt_dev_uv_task_002* task:02: DEVARCH-8869: about IP connection.

02.16:
======
CANTST-15347: BBC iPlayer: app not fully functional following IP reconnect after IP disconnect error message shown
-> DEVARCH-8869: Investigate/Fix CANTST-15347 BBC iPlayer: app not fully functional following IP reconnect after IP disconnect error message shown

<net-manager>
this is oem comp which is based on open source and has some oem modification.
source will be provided by tar file in this folder.

/home/kpark/source/DEVARCH/OEM.Humax/NetworkManager/src/NetworkManager-0.8.5.92


<serial-log-when-plug-in-out>
eth0 Link DOWN.
Feb 16 16:51:52 syslog[793]: <info> (eth0): carrier now OFF (device state 8)
Feb 16 16:51:52 syslog[793]: <info> (eth0): device state change: 8 -> 2 (reason 40)
Feb 16 16:51:52 syslog[793]: <info> (eth0): deactivating device (reason: 40).
Feb 16 16:51:53 syslog[793]: <info> (eth0): canceled DHCP transaction, DHCP client pid 2516
eth0 cable unplugged, powering down



eth0 cable plugged in, powering up
eth0 Link UP.
Auto config phy
eth0: Link is up, 100 Mbps Full Duplex
Feb 16 16:52:09 syslog[793]: <info> (eth0): carrier now ON (device state 2)
Feb 16 16:52:09 syslog[793]: <info> (eth0): device state change: 2 -> 3 (reason 40)
Feb 16 16:52:09 syslog[793]: <info> Activation (eth0) starting connection 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6'
Feb 16 16:52:09 syslog[793]: <info> (eth0): device state change: 3 -> 4 (reason 0)

This matches to:

./src/nm-device-ethernet.c:243: nm_log_info (LOGD_HW | LOGD_ETHER, "(%s): carrier now %s (device state %d%s)",
./src/nm-device-ethernet.c:245:              carrier ? "ON" : "OFF",

<dbus>
793   :1.0                     /opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        
793   org.freedesktop.NetworkManager/opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        
793   org.freedesktop.NetworkManagerSystemSettings/opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        

dbus-send  --session --type=method_call --print-reply --dest='Zinc.ContentAcquisition' \
 /Zinc org.freedesktop.DBus.Introspectable.Introspect


02.18
======
1. https://jira.youview.co.uk/browse/DEVARCH-7941

Shows the requirement. The points to note:

1. about handling errors that happen during playback and not during tuning. If does when tuning,
kill CRB application.

From OIPF-DAE:

LAN connectivity problem (results in a YVM102 message being shown by the YouView UI) 	Presenting
Connecting 	PlayStateChange (playstate 1, errorState 9 - insufficient bandwidth)

LAN connectivity problem

This one is quite easy and should just consist in making ProductionVideoBroadcast listen to
Neon.Client.API / NetworkStatusChange.  The UI might need to be modified to show only a notification
instead of showing a dialogue in case the CRB app is running (TBC), and usage reporting need to be
preserved if there is any.

note: Given there is "LAN connectivity problem restored:", the above includes no connection and
timed-out one?

On demand UI req:
https://wiki.youview.co.uk/display/UXDWIP/FR+12+-+On+Demand+Playback

From CANTST-15347:
Test description:
1. Launch a piece of content from BBC application (tested with iPlayer,and iPlayer from CRB)

Actual result:
note: 4. When the app freezes and must be closed and restarted.

NB in all the above cases the YV box reports the loss of internet connection (YVM-102) when the
cable is pulled from the back of the box.

The scenarios in all cases are the same whether it is the ethernet or the WAN being disconnected.

<test-result>
The version used:
Humax DTR-T1000 T1000 H21.7.30

The version reported:
Box: Humax T1000 PRK
CDS: H20.9.0
Environment: Live

The observation:

1. run iplayer 
2. run one of contents
3. plug out a cable
4. YVM-102 is shown on tv.
5. video still runs for some time and shows waiting icon 
6. error 02100 from iplayer app saying "something are not working playing this program. ..."
7. plug it back
8. shows "youview is connected again" message on tv.
9. able to navigate iplayer app which is 'different' from the reported.

Tried 5 times and no problem. Tried once after a reboot, no problem.


02.19
======
Assigned back to the reporter to re-test.
Started on the new one, #7508, which is about runBrowser-test.sh


={============================================================================
*kt_dev_uv_task_003* task:02: DEVARCH-7508: runBrowser-test.sh log:

02.20
======
kpark@wll1p04345:/data/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk$ find . -name runBrowser.sh
./bin/runBrowser.sh
kpark@wll1p04345:/data/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk$ find . -name runBrowser-test.sh
./tests/vanadium-w3c-engine/test/runBrowser-test.sh

[root@HUMAX zinc-trunk]# find . -name runBrowser* ./bin/runBrowser.sh
./devel/bin/runBrowserStandalone.sh
./tests/vanadium-w3c-engine/test/runBrowser-test.sh
[root@HUMAX zinc-trunk]# 


From runBrowser-test.sh log:

+ paramsContainStringAtPosition 0 3 -cache /tmp/client-cache -cache-size 50000000 -jar /tmp/cookies.sqlite -url 'http://youview.tv/test-player?launch_context.ui.youview.com=portal&some.test.param=some.test.param.value&test.param.spaces=param%20value%20with%20spaces' -src '
      http://youview.tv http://broadcast.example.com
      http://www.bbc.co.uk http://cdn.example.net:8080
    '
+ local stringToSearchFor=0
+ local positionToExpectStringAt=3
+ local 'stringToSearch=-cache /tmp/client-cache -cache-size 50000000 -jar /tmp/cookies.sqlite -url http://youview.tv/test-player?launch_context.ui.youview.com=portal&some.test.param=some.test.param.value&test.param.spaces=param%20value%20with%20spaces -src 
      http://youview.tv http://broadcast.example.com
      http://www.bbc.co.uk http://cdn.example.net:8080
    '
So expect to see 0 but 50000000. Why?

From runBrowser.sh

# Decide whether to turn on Qt's network cache + local storage.
cacheSize="$(lsr-config --int platform.settings.html-app-cache-size || echo 0)"

This cache size comes from external but the test script uses the 'fixed' value. mismatch.

that_generates_url_handler() {

    paramsContainStringAtPosition "0" 3 "$@"
    cacheSizeValueCorrectAtExpectedPosition=$?
}


related https://jira.youview.co.uk/browse/DEVARCH-7362 since about cache size.

The solution:

kpark@wll1p04345:~/jira/feb-7508$ diff runBrowser-test-old.sh runBrowser-test.sh 
--- runBrowser-test-old.sh	2015-02-20 14:23:37.978416274 +0000
+++ runBrowser-test.sh	2015-02-20 14:21:59.318417412 +0000
@@ -173,7 +173,8 @@ test.param.spaces=param%20value%20with%2
     paramsContainStringAtPosition "-cache-size" 2 "$@"
     cacheSizeOptionCorrectAtExpectedPosition=$?
 
-    paramsContainStringAtPosition "0" 3 "$@"
+    # paramsContainStringAtPosition "0" 3 "$@"
+    paramsContainStringAtPosition "$(lsr-config --int platform.settings.html-app-cache-size || echo 0)" 3 "$@"
     cacheSizeValueCorrectAtExpectedPosition=$?
 
     paramsContainStringAtPosition "-jar" 4 "$@"


02.23
======
DEVARCH-7508/0: runBrowser-test.sh fails on DTR-T1000

The cause of the problem is that the cache size is introduced in the runBrowser.sh but not in the
runBrowser-test.sh. Hence mismatch which cause this failure. 

This commit has the fix to have the same approach rumBrower.sh has to use the value from LSR. 

<review>
Please review the commits for [DEVARCH-7508] which on the branch [review/DEVARCH-7508/0].

1. [DEVARCH-7508: runBrowser-test.sh fails on DTR-T1000 [e4ac0e1]

[1]: https://jira.youview.co.uk/browse/DEVARCH-7508
[2]: https://git-dev.dev.youview.co.uk/?p=DEVARCH.git;a=shortlog;h=refs/heads/review/DEVARCH-7508/0
[e4ac0e1]: https://git-dev.dev.youview.co.uk/?p=DEVARCH.git;a=commit;h=e4ac0e157a900d55fa30b7c9c88a9f080b3767b1


={============================================================================
*kt_dev_uv_task_004* task:03: DEVARCH-9135: uranium metadata

03.04
======
Assigned.
https://jira.youview.co.uk/browse/DEVARCH-9135

UI is provided two metadata APIs for events:

From the API docs: http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/index.html

<Q> CTV?

ctv.enhancemetadata.Event
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/ctv/enhancedmetadata/Event.html

ctv.linearmetadata.Event
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/ctv/linearmetadata/Event.html

The latter Event type is an old API that we don't consider efficient and would ideally remove it. In
order to do this, the ctv.enhancedmetadata.Event type needs to contain all of the information that
the UI needs.

It has been noticed (by Stephen Spencer) that ctv.enhancedmetadata.Event.getSynopsis() doesn't
always return a value for some types of events. This should be investigated and fixed.

The implementation of ctv.enhancedmetadata.Event is in the file:

Uranium/Uranium.Client.System/src/metadata/SystemClientEvent.cpp


03.25
======
The fix made:
Uranium/Uranium.Client.System/test/metadata/SystemClientEventTest.cpp

    void testEventAccessors_When_ConstructedFromAnIronEvent():

+        sysEvent.mediumSynopsis["eng"] = "The latest national and international"
+            "news stories from the BBC News team, followed by weather.";
 
+        CPPUNIT_ASSERT_EQUAL(string("The latest national and international"
+                    "news stories from the BBC News team, followed by weather."), event.getSynopsis());
     }

    void testEventAccessors_When_ConstructedFromAPopulatedSystemEventWrapper()

         sysResult->description["owningServiceId"] = vector<string>(1, "1");
+        sysResult->description["mediumSynopsis"] = vector<string>(1, "The latest national and international"
+                "news stories from the BBC News team, followed by weather.");

+        CPPUNIT_ASSERT_EQUAL(string("The latest national and international"
+                "news stories from the BBC News team, followed by weather."), event.getSynopsis());
     }

Uranium/Uranium.Client.System/src/metadata/SystemClientEvent.cpp

1.

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const std::string& lang,
        const NS_IRON_SYSTEM::Event& dttEvent) :

@@ -117,7 +117,9 @@ SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos
         actualAvailability(false),
         flags(0),
         isCachedFlag(false),
-        synopsis(extractValueFromMap(dttEvent.longSynopsis, lang)),
+        // { FIX
+        synopsis(extractValueFromMap(dttEvent.mediumSynopsis, lang)),
+        // } FIX


2.

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const SystemEventWrapper& masEvent) :

@@ -358,7 +349,9 @@ SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos
             actualAvailability(masEvent.isAvailable()),
             flags(0),
             isCachedFlag(false),
-            synopsis(),
+            // { FIX
+            synopsis(masEvent.getSynopsis()),
+            // } FIX


Uranium/Uranium.Client.System/src/metadata/SystemEventWrapper.h

class SystemEventWrapper  {

@@ -32,6 +32,13 @@ public:
         idBag(scResult)
     {}
 
+    // { FIX
+    std::string getSynopsis() const
+    {
+        return scResult.getStringFromDescription("mediumSynopsis");
+    }
+    // } FIX
+


04.01: have had a look at john's commits since these makes conflict with changes I made.
======

* 62ef094 (HEAD, origin/john.sadler/uranium-opt-1, john.sadler/uranium-opt-1) DEVARCH-9276: Uranium.Client.API: Simplify `TargetRegion`.
* 646adc9 DEVARCH-9288: Uranium.Client.System: Remove ReminderRepository pointer member from SystemClientEvent.
* 8cfaa44 DEVARCH-9287: Uranium.Client.System: Remove ServiceRepository pointer member from SystemClientEvent.
* eac309d DEVARCH-9286: Uranium.Client.System: Remove LinearAcquisition pointer member from SystemClientEvent.
* 467bc42 DEVARCH-9285: Uranium.Client.System: Remove EventRepository pointer member from SystemClientEvent.
* 500ce26 DEVARCH-9275: Uranium.Client.System: Remove `IdentifierBag`.
* 499950f DEVARCH-9274: Uranium.Client.System: Remove `SystemEventWrapper` and avoid additional copy of `Result` when constructing `SystemClientEvent`.
* b7c5176 DEVARCH-9272: Cobalt.System.Fake: Use correct ISO 8601 format when constructing event times.
* d3d85d5 DEVARCH-9271: Cobalt.System.API: Add `ResultHelpers` functions to get OD Availability & ProgrammeId fields from `Result`.
* 29c9fab  DEVARCH-9271: Uranium.Client.System: Avoid pointless copy of entire Broker ResultSet when constructing CAL ResultSet wrappers.


* 7d2a5f3 
=========

John Sadler committed e9a6201940707 Mar 2015
DEVARCH-9269: Uranium.Client.System: Make `SystemClientSummary` create CAL `Result` wrapper
immediately in it's constructor.

Due to the wonderfully-generic MAS B2C interface, the MetadataBroker
`search()` and `getSummaries()` methods each return a vector of `Summary`
objects where each `Summary` could be one of a number of entity types:
`Brand`, `Series`, `Programme Summary`, `Service`, `Application`, and
`Schedule Event`.

So essentially, `Summary` is a discriminated variant type.

The current implementation of `Summary` in the CAL: `SystemClientSummary`
defers creation of the specific CAL entity until a caller asks for it by
calling a method such as: `getBrand()` via the `Summary` interface. It
doesn't bother caching the object once it has created it either, which means
that repeated calls will return different instances, (so a shallow
"identity comparison" would fail).

This commit modifies `SystemClientSummary` such that it immediately creates
the appropriate CAL entity, depending on the `entity-type` conveyed in the
System API `Result` object it is constructed from. It holds the entity in a
type-erased form (`shared_ptr<void>`), but since it also knows the type of
the entity, it can safely static_cast back to the appropriate type when a
client calls a getter method (such as `getBrand()`).

By doing this, we remove the need for `SystemClientSummary` to hold a copy
of the original System API `Result` struct, and also enable it to give the
guarantee that repeated calls to getter methods return the same object.
That also means that clients which call the getter multiple times don't
repeatedly incur the overhead of constructing the CAL entity and copying
the `Result` struct.

It should be pointed-out that this change introduces a slight change in
behaviour which required one of the existing testcases to be modified.
What the testcase was doing was retrieving an Event from Summary that
was on a hidden Service, and then un-hiding the Service via the
ServiceRepository. Following this, it was then re-fetching the Event from
the Summary, and then the Service from the Event, and asserting that the
Service was now "unhidden". This no-longer works because the Event is
now being created only once (and the Service is looked-up in the constructor),
and changes to Services are unfortunately not reflected on Service objects
(it is necessary to re-fetch the Service from the ServiceRepository).
Happily, the UI does not make use of the previous behaviour (which is in
any case undocumented).

note: two points

1. By doing this, we remove the need for `SystemClientSummary` to hold a copy
of the original System API `Result` struct, 


-> The point is to remove a copy in SCS since SystemClientSummary in JS has Result member. This save
    a memory in SCS and copy to SCS. However, my master has SP to Result instead and this change has
    no effect. Which one is the latest?


and also enable it to give the guarantee that repeated calls to getter methods return the same
object.  That also means that clients which call the getter multiple times don't repeatedly incur
the overhead of constructing the CAL entity and copying the `Result` struct.

-> This is valid since creates different wrapper instances from the same result. So one result and
one wrapper instance. Good point.


* d0e695e 
=========
commit d0e695e6e148f911dfbc6aee3a36238a3e90a9f6
Author: John Sadler <john.sadler@youview.com>
Date:   Sat Mar 7 12:23:07 2015 +0000

DEVARCH-9266: Uranium.Client.System: Don't heap-allocate a copy of System API `Result` when creating
Client API wrappers.

The MetadataBroker System API `Result` struct is very generic and is used
to transport a variety of different entities, such as Schedule Events,
Applications, Programmes, & Publications.

In the Client API (which is implemented in-terms-of the System API), we
expose different, strongly-typed, interfaces for each of the different
entity types. Each instance of these ultimately either wraps a `Result`
object, or is constructed from one.

As a System API, MetadataBroker returns it's results by-value. Non of the
generated System APIs return structs, or collections by `boost::shared_ptr`.
However, all of the Client API wrappers expect to receive the `Result`
object via `boost::shared_ptr`. This leads to the conversion functions
heap-allocating a copy of the returned `Result`, just so it can be passed
via shared_ptr.

If we consider that:

a) each Client API wrapper object will end-up uniquely owning a copy of the
System API `Result` and

b) the Client API objects themselves are referenced by shared_ptr (because
they are bound-up to AS3 & JavaScript, and we want by-reference semantics).

Then it doesn't make much sense to use shared_ptr. An in-line copy of the
System API `Result` will give better locality (rather than dereferencing
another pointer), and we can also avoid the shared_ptr overhead.

This change also paves the way for eliding copies of the `Result` objects
by stealing/moving them directly into the CAL wrappers.


note: 
1. do not "copy ctor" in converter and make SCR have a copy of "Result" instead. No changes in
wrapper classes but SCR now do "copy ctor" to copy "Result".

ProgrammePtr
Converter::operator()(const NS_COBALT_SYSTEM::Result& result, ProgrammePtr) const
{
    return boost::make_shared<SystemClientProgramme>(result);
}

class SystemClientProgramme : public Programme 
{
    public:
         -explicit SystemClientProgramme(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
         +explicit SystemClientProgramme(const NS_COBALT_SYSTEM::Result& sysResult)
            :scResult(sysResult)
            {}
};

class SystemClientResult
{
    public:
        explicit SystemClientResult(const NS_COBALT_SYSTEM::Result& sysResult)
            : sysResult(sysResult)
        {}

        int64_t getValidUntil() const
        {
            return sysResult.validUntil;
        }

        std::string getRecordIdentifier() const
        {
            return sysResult.recordIdentifier;
        }

        const NS_COBALT_SYSTEM::Result& getResult() const
        {
            return sysResult;
        }
        ...

    private:
        NS_COBALT_SYSTEM::Result sysResult;  // note:
};


* 5c9a202 DEVARCH-9266: Uranium.Client.System: Get rid of defunct `wrapSysResult()` and `wrapSysResults()` in Converter.
-> LGTM. 

* 3e896f3 DEVARCH-9265: Uranium.Client.System: Reserve vector capacity when converting System Broker results.
-> LGTM. 


04.13
======
Megre john's commits and on top of it, make fixes to this problem. Build is fine against the latest
master.


<commit-log>
DEVARCH-8092: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

The UI is provided two metadata APIs for events; ctv.linearmetadata.Event which is an old API and
ctv.enhancedmetadata.Event which is an new API. It has been reported that
ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value.

It appears that getSynopsis() is never been implemented since the current implementation of
`SystemClientEvent` is broken in either it uses wrong field of Event or do not handle getSynopsis()
at all to return a synopsis to UI.

This commit fixes `SystemClientEvent` to use the right field for synopsis and to implement missing
mappings between the Event Repository and SystemClientEvent for DTT and IP source. It also revises
the related test cases to test getSynopsis() of various `SystemClientEvent` instances for both
sources.

note: 2015.04.27. fix the jira number since it was 8092

DEVARCH-9135: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

The UI is provided two metadata APIs for events; ctv.linearmetadata.Event which is an old API and
ctv.enhancedmetadata.Event which is an new API. It has been reported that
ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value.

It appears that getSynopsis() is never been implemented since the current implementation of
`SystemClientEvent` is broken in either it uses wrong field of Event or do not handle getSynopsis()
at all to return a synopsis to UI.

This commit fixes `SystemClientEvent` to use the right field for synopsis and to implement missing
mappings between the Event Repository and SystemClientEvent for DTT and IP source. 


DEVARCH-9135: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

The UI is provided two metadata APIs for events; ctv.linearmetadata.Event which is an old API and
ctv.enhancedmetadata.Event which is an new API. It has been reported that
ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value.

It appears that getSynopsis() is never been implemented since the current implementation of
`SystemClientEvent` is broken in either it uses wrong field of Event or do not handle getSynopsis()
at all to return a synopsis to UI.

This commit fixes `SystemClientEvent` to use the right field for synopsis and to implement missing
mappings between the Event Repository and SystemClientEvent for DTT and IP source. 

This commit revises the related test cases to test getSynopsis() of various `SystemClientEvent`
instances for both sources.


={============================================================================
*kt_dev_uv_task_005* task:01: nexus tools to have 'deprecated" build for hmax

04.13
======
While waiting for the official release from Huawei for nexusMgr, told that do
some work; that is to have a temp solution for a release. The old nexus tools
for Humax and the new nexus tools for Huawe since Humax still has not been moved
    to the new approach. How?

1. Have a different directory for each oems

/source/DEVARCH/Polonium/Polonium.NexusInspect.deprecated/   // for hmax
/source/DEVARCH/Polonium/Polonium.NexusInspect/              // for hwei

2. Use exclude feature

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh
   -> exclude 'deprecated' version

# N.B: This is a temporary for a QIP release and to be removed.
export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect.deprecated"

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh
   -> exclude the normal version

# N.B: This is a temporary for a QIP release and to be removed.
export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"

3. No other changes and it means that the output( exec_wrapper and inspect ) will have the same name
and will be placed under the same in install root.


04.14
======

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-db_t2200.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh

Cobalt/Cobalt.Common Cobalt/Cobalt.System.Production Cobalt/Cobalt.System.API
Polonium/Polonium.NexusInspect.deprecated Polonium/Polonium.GSTNexus Polonium/Polonium.GSTTSPacer
Polonium/Polonium.PCMPlayback

SUCCESS: building branch zb/DEVARCH-8092-TEMP: 6906d73df6ea4cbccab97d984434f623e0779902 with
ZB_CFG="humax.2100" zb-make listprojects

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t4000.sh

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7231.sh*
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh*
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-dn360t.sh*


04.15
======

For all humax, have a insepct.deprecated only.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-db_t2200.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t4000.sh

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7231.sh, (372) do not have both
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh  (370) inspect only
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-dn360t.sh*        do not have both


Did a full build for hmax1000 and hwei370. For the rest, did run "listtarget".


<commit-log>
DEVARCH-8092: NexusInspect: Add join and uninit pair in the nexus-inspect.

In order to support new API, Huawei introduce a new pair of calls in a user side to call these APIs
and to use Nexus resources returned from these API. 

This commit add the pair in nexus-inspect to have valid Nexus resource handles.


DEVARCH-8092: NexusInspect: Add the previous nexus-inspect as a deprecated project in the build.

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

This commit add the previous nexus-inspect to the build as deprecated project.


<hwei-372>
DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 372. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hwei-370>
DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 370. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hwei-360>
DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 360. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-1000>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 1000. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-2100>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2100. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-2200>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2200. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-4000>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 4000. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 


04.17
======

kpark@wll1p04345:~/source/DEVARCH$ git show --name-only 9614591..8e5e127
commit 8e5e127afa70e2a44c4c3619e5e670632d7181ea
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:55:31 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 4000.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t4000.sh

commit f67ccfa1d2cf87ce1cefad35b9248b799d47c88d
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:54:47 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2200.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-db_t2200.sh

commit d0fffbfd698e49fcf59e1179891279e65542eee4
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:53:59 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2100.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh

commit 62dd1be6052b2b0bae64916e638ebd74ec173c7d
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:52:48 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 1000.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh

<c>
commit 9801a6417b9103304552a89790e8bd0aeb0f816c
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:51:21 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 360.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-dn360t.sh

<c>
commit a372b5a0e145208244bd731776bae804488e1d12
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:37:28 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 370.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

<c>
commit 64f3b343c5f8185584ff0a8b978cd5c6d400a224
Author: Kit Park <kit.park@youview.com>
Date:   Thu Apr 16 12:17:43 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 372.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7231.sh

<c>
commit 1ddd353a2c42128a16170473e5cb8787e932cfaa
Author: Kit Park <kit.park@youview.com>
Date:   Thu Apr 16 12:31:02 2015 +0100

    DEVARCH-8092: NexusInspect: Add the previous nexus-inspect as a deprecated project in the build.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.
    
    This commit adds the previous nexus-inspect to the build as deprecated project.

Polonium/Polonium.NexusInspect.deprecated/Makefile.am
Polonium/Polonium.NexusInspect.deprecated/autogen.sh
Polonium/Polonium.NexusInspect.deprecated/configure.ac
Polonium/Polonium.NexusInspect.deprecated/nexus-inspect.pc.in
Polonium/Polonium.NexusInspect.deprecated/scripts/exec-then-cleanup-app.sh.in
Polonium/Polonium.NexusInspect.deprecated/src/exec-then-cleanup-app.c
Polonium/Polonium.NexusInspect.deprecated/src/nexus-inspect.c

<c>
commit 55a17f211662c36dd7f5f1a615bf09f4691a8240
Author: Kit Park <kit.park@youview.com>
Date:   Fri Apr 10 16:47:36 2015 +0100

    DEVARCH-8092: NexusInspect: Add join and uninit pair in the nexus-inspect.
    
    In order to support new APIs, Huawei introduces a new pair of calls in a user side to call these APIs
    and to use Nexus resources returned from these API.
    
    This commit add this pair in nexus-inspect to have valid Nexus resource handles.

Polonium/Polonium.NexusInspect/src/nexus-inspect.c


<c>
commit 9d26684984cecc7bed044ddbd5c6eee1b1be13da
Author: Kit Park <kit.park@youview.com>
Date:   Tue Feb 24 13:10:29 2015 +0000

    DEVARCH-9131: NexusInspect: Fix up makefile to build nexus utilities.
    
    There is no common solution for nexus utility features since both OEMs have different nexusMgr
    implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
    implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
    DEVARCH-8101, and DEVARCH-8080.
    
    This commit has the necessary changes of makefile to build nexus utility and to fix the link order
    problem when linking with nexusMgr shared library.

Polonium/Polonium.NexusInspect/Makefile.am


<c>
commit cc9940795c80a6df88ab7cdf69eac4037d56f732
Author: Kit Park <kit.park@youview.com>
Date:   Tue Feb 24 13:07:04 2015 +0000

    DEVARCH-9130: NexusInspect: Add nexus-inspect tool.
    
    There is no common solution for nexus utility features since both OEMs have different nexusMgr
    implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
    implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
    DEVARCH-8101, and DEVARCH-8080.
    
    This commit add the nexus-inspect which uses the proposed APIs to show information of nexus
    resources. Since the tool is no longer needed in production, this commit moves it into
    $prefix/devel/bin.

Polonium/Polonium.NexusInspect/Makefile.am
Polonium/Polonium.NexusInspect/src/nexus-inspect.c
Polonium/Polonium.NexusInspect/src/nexus-inspect.h


<c>
commit 2519985aab9d51d439ee45dcf0f78f7fe6524b34
Author: Kit Park <kit.park@youview.com>
Date:   Tue Feb 24 13:03:18 2015 +0000

DEVARCH-9129: NexusInspect: Add nexus-release tool and revise the exec-wrapper

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus-release which is revised to use the proposed APIs to release nexus
resources and the updated exec-wrapper to use the same.

Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c
Polonium/Polonium.NexusInspect/src/nexus-release.c

<c>
commit 44026356e1a233cb9b9853f3abe8b0525f655622
Author: Kit Park <kit.park@youview.com>
Date:   Tue Mar 3 10:13:29 2015 +0000

    DEVARCH-9128: NexusInspect: Add the nexus-inspect to the build for Huawei dn370t
    
    There is no common solution for nexus utility features since both OEMs have different nexusMgr
    implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
    implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
    DEVARCH-8101, and DEVARCH-8080.
    
    This commit add the nexus utility project to the build for Huawei dn370t. OEM dependency unification
    effort should now make it possible to build this project for Huawei as well.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

04.21
======
<host>
DEVARCH-8092: NexusInspect: Add the exclude project for PC host. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 


DEVARCH-8092: NexusInspect: Add more and the latest reports to the nexus-inspect. 

Add all inspection reports from the previous implementation and also the
latest from the architect group such as reports of audio decoder and STC.

Here is the reports on Huawei 370 engineering release that implements the
proposal.

==================================================
  Nexus inspect v0.1

BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
  StcChannelHandle         : 0xe12831e4
  VideoDecoderHandle       : 0xe12850f8
  Ac3EncodeHandle          : 0x0
  VideoWindowHandle        : 0x0
  DmaHandle                : 0x0
  Pid                      : 0
  PlaypumpHandle[0]        : 0x0
  Started                  : 1
  Coded                    : 1920 x 1088,  Display: 1920 x 1080
  Current PTS              : 27953744
  Num decoded frames       : 107242
  Num displayed frames     : 214482
  Started                  : 4201120
  TSM                      : 4201156
  Locked                   : 4201192
  Sample rate              : 4201228
  Num decoded frames       : 1
  Current fifo depth       : 0.389481% (2042 of 524288)
  PlaypumpHandle[0]        : 0x0             // see
  Started                  : 4201120
  TSM                      : 4201156
  Locked                   : 4201192
  Sample rate              : 4201228
  Num decoded frames       : 0
  PlaypumpHandle[1]        : 0x0             // see
  STC timebase source      : NEXUS_TimebaseSourceType_ePcr
  STC pid channel          : 0xcee16880
  STC max PCR error        : 255
  STC PCR track range      : NEXUS_TimebaseTrackRange_e61ppm
  PID channel              : enabled
  PID                      : 101
  Transport type           : NEXUS_TransportType_eTs
  Original transport type  : NEXUS_TransportType_eTs
  Playback                 : false
  CC errors                : 0
BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
==================================================


04.22
======
Found that there is a redundant output and a problem not printing out as
expected. Sorted.

DEVARCH-8092: NexusInspect: Fix redundant and missing output in the
nexus-inspect. 

Fix redundant and missing output when run the nexus-inspect. No functional
changes and updated the report on Huawei 370 engineering release that
implements the proposal.

==================================================
  Nexus inspect v0.1

BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
  StcChannelHandle         : 0xe12831e4
  VideoDecoderHandle       : 0xe12850f8
  Ac3EncodeHandle          : 0x0
  VideoWindowHandle        : 0x0
  DmaHandle                : 0x0
  Pid                      : 0
  PlaypumpHandle[0]        : 0x0
  Started                  : 1
  Coded                    : 1920 x 1088,  Display: 1920 x 1080
  Current PTS              : 2932777648
  Num decoded frames       : 19278
  Num displayed frames     : 38555
  Started                  : 1
  TSM                      : 1
  Locked                   : 1
  Sample rate              : 48000
  Num decoded frames       : 36212
  Num error frames         : 0
  Num fifo overflows       : 0
  Num fifo underflows      : 2932781277
  Current PTS              : 1
  Current fifo depth       : 0.318718% (1671 of 524288)
  Started                  : 0
  TSM                      : 0
  Locked                   : 0
  Sample rate              : 0
  Num decoded frames       : 0
  Num error frames         : 0
  Num fifo overflows       : 0
  Num fifo underflows      : 0
  Current PTS              : 1
  STC timebase source      : NEXUS_TimebaseSourceType_ePcr
  STC pid channel          : 0xc6a79c00
  STC max PCR error        : 255
  STC PCR track range      : NEXUS_TimebaseTrackRange_e61ppm
  Pid channel              : enabled
  Pid                      : 101
  Transport type           : NEXUS_TransportType_eTs
  Original transport type  : NEXUS_TransportType_eTs
  Playback                 : false
  CC errors                : 0
BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
==================================================


={============================================================================
*kt_dev_uv_task_006* task:05: sort out test failures

Use this as a mother ticket

https://jira.youview.co.uk/browse/DEVARCH-4122


<systemmediarecordcachetest>

2015-04-20_03-28-00:

DEVARCH/Uranium/Uranium.Client.System/test/local-media-library/SystemMediaRecordCacheTest.cpp

15 Uranium/Uranium.Client.System (systemmediarecordcachetest)

works okay on host:

:~/builds/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/Uranium/Uranium.Client.System/test/local-media-library$ ./systemmediarecordcachetest 
.......

OK (7)


fails on:

http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/872/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/878/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/880/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/882/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/883/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/884/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/889/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/894/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/897/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/898/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/900/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/901/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/475/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/488/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1235/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                         
 

from log: #901, 872,

PASS: systemmediarecordtest
.......F

FAIL: systemmediarecordcachetest


from: #475

PASS: systemmediarecordtest
.......F../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:282: Failure
Actual function call count doesn't match EXPECT_CALL(*systemLML, getMediaRecord(_))...
         Expected: to be called 4 times
           Actual: called once - unsatisfied and active
F


../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:279: ERROR: mock object '*systemLML' should be deleted but never is. Its address is @0x989d644.
../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:282: ERROR: mock object '*systemLML' should be deleted but never is. Its address is @0x989d644.
ERROR: 1 leaked mock object found at program exit.
FAIL: systemmediarecordcachetest


from: #488

PASS: systemmediarecordtest
.......F../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:282: Failure
Actual function call count doesn't match EXPECT_CALL(*systemLML, getMediaRecord(_))...
         Expected: to be called 4 times
           Actual: called once - unsatisfied and active
F

FAIL: systemmediarecordcachetest


from: #1235

PASS: systemmediarecordtest
.......F

FAIL: systemmediarecordcachetest


2015-04-27_03-28-01:

10 Uranium/Uranium.Client.System (systemmediarecordcachetest)

http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/905/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/912/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/917/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/921/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/922/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/515/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/519/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/522/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/524/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/526/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
 

04.28
======

1. For a debug log:

--- a/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp
+++ b/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp
@@ -295,7 +295,7 @@ void MediaRecordCache::replayInitialUpdates( const FutureValue< void >& fv )
     }
     else
     {
-        URANIUM_INFO( "Replaying LibraryContentChange events" );
+        URANIUM_INFO( "KT: from cacheReady: Replaying LibraryContentChange events" );
         applyUpdatesSync( initialUpdates );
     }
     initialUpdates.clear();
@@ -330,6 +330,7 @@ MediaRecordCache::applyUpdatesSync(
             {
                 try
                 {
+                    URANIUM_INFO( "KT: call lml->getMediaRecord( " <<  change.first << " )" );
                     updateCache( cache,
                                  propagatedClientChanges,
                                  change.second,



2. Suggested the generic approach to have timeout value rather than the fixed
in tests.

CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );


/** Defines time in milliseconds for which probes will be waiting for an event to occur. */

Copper/CopperAnnouncement.Client.System/test/SystemClientAnnouncementServiceTest.cpp:   const int32_t TEST_TIMEOUT = 5000;


ZINC_ASSERT_WITHIN_TIMEOUT(f.isComplete(), TEST_TIMEOUT);


/**
 * Unit test assertion macro to check that an expression becomes true in the
 * given time.
 *
 * It polls every 100ms
 */
#define ZINC_ASSERT_WITHIN_TIMEOUT(expression, timeoutms) \
    do { \
        bool success = false; \
        for (int _assert_within_timeout_i = 0; \
             _assert_within_timeout_i < (timeoutms+99)/100; \        //
             ++_assert_within_timeout_i) { \
            if (expression) { \
                success = true; \
                break; \
            } \
            usleep(1000 * 100); \                                    // 100ms
        } \
        CPPUNIT_ASSERT_MESSAGE( #expression " did not happen within " #timeoutms "ms", success); \
    } \
    while (0);


<eventrepositorytest>
note: this is different from 

linear-metadata/EventRepositoryTest.cpp
282:    CPPUNIT_TEST_SUITE(EventRepositoryTest);
311:CPPUNIT_TEST_SUITE_REGISTRATION(EventRepositoryTest);

602:    CPPUNIT_TEST_SUITE(SystemClientEventRepositoryTest);
636:CPPUNIT_TEST_SUITE_REGISTRATION(SystemClientEventRepositoryTest);


2015-04-20_03-28-00:

 5 Uranium/Uranium.Client.System (eventrepositorytest)

works okay on host:

:~/builds/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/Uranium/Uranium.Client.System/test/linear-metadata$ ./eventrepositorytest


from log:

/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Zinc/Zinc.Build/jenkins/cppunit2junit.sh: line 74: 23726 Segmentation fault      ZINC_CPPUNIT_XML=1 $test_exe 9> ${results}
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Document is empty

^
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Start tag expected, '<' not found

^
unable to parse /var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml
FAIL: eventrepositorytest


only seen on COS:

52: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1236/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
51: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1237/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
49: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1239/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
46: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1242/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
33: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1255/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest


2015-04-27_03-28-01:

  3 Uranium/Uranium.Client.System (eventrepositorytest)

http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1287/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1285/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1265/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest

/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Zinc/Zinc.Build/jenkins/cppunit2junit.sh: line 74: 16627 Segmentation fault      ZINC_CPPUNIT_XML=1 $test_exe 9> ${results}
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Document is empty

^
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Start tag expected, '<' not found

^
unable to parse /var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml
FAIL: eventrepositorytest


04.29
======
Made a fix, ran an test under stressed env, worked okay, built okay, created
JIRA for this. Ready to code review?


DEVARCH-9473: Fix test failing - systemmediarecordcachetest

The latest build reports have shown failures on this test and this seems to
have failed on various host and target distributions.

2015-04-27_03-28-01
10 Uranium/Uranium.Client.System (systemmediarecordcachetest)

2015-04-20_03-28-00:
15 Uranium/Uranium.Client.System (systemmediarecordcachetest)

The problem is that it uses a short fixed time value in which the result
depends on a system load when running a test and this is why the result is
flaky. This commit has increased value, more general and robust approach in
line with other test.


={============================================================================
*kt_dev_uv_task_007* task:06: playback audio only IP channel

04.29
======
https://jira.youview.co.uk/browse/DEVARCH-8828

We have audio-only IP channel 567 to test this. Currently, it works fine on Huawei but not on Humax. Seems to be an OEM issue.

04.30
======
On hwei 372, channel 567, OK

root# cat audio 
    397327:49:35.879 nexus_audio_module: Audio:
    397327:49:35.883 nexus_audio_module:  handles: ape:bcb93000 dsp:b6278004
    397327:49:35.890 nexus_audio_module:  img ctxt:bb291800
    397327:49:35.896 nexus_audio_module:  settings: wd:1 id:1
    397327:49:35.901 nexus_audio_module:  channel0: (bcac0000) locked ~
    397327:49:35.908 nexus_audio_module:   started=y, codec=1
    397327:49:35.913 nexus_audio_module:   fifo: 32286/262144 (12%), queued: 56
    397327:49:35.920 nexus_audio_module:   TSM: enabled pts=0x4e4b6638 pts_stc_diff=-7 errors=0
    397327:49:35.929 nexus_audio_module:   watchdogs: 0
    397327:49:35.934 nexus_audio_module:  channel1: (bcba0000) 
    397327:49:35.940 nexus_audio_module:   started=n, codec=0
    397327:49:35.945 nexus_audio_module:   fifo: 0/0 (0%), queued: 0
    397327:49:35.952 nexus_audio_module:   TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
    397327:49:35.960 nexus_audio_module:   watchdogs: 0
    397327:49:35.965 nexus_audio_module:  channel2: (bc450000) 
    397327:49:35.970 nexus_audio_module:   started=n, codec=0
    397327:49:35.976 nexus_audio_module:   fifo: 0/0 (0%), queued: 0
    397327:49:35.982 nexus_audio_module:   TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
    397327:49:35.990 nexus_audio_module:   watchdogs: 0
Audio:
 handles: ape:bcb93000 dsp:b6278004
 img ctxt:bb291800
 settings: wd:1 id:1
 channel0: (bcac0000) locked ~
  started=y, codec=1
  fifo: 32286/262144 (12%), queued: 56
  TSM: enabled pts=0x4e4b6638 pts_stc_diff=-7 errors=0
  watchdogs: 0
 channel1: (bcba0000) 
  started=n, codec=0
  fifo: 0/0 (0%), queued: 0
  TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
  watchdogs: 0
 channel2: (bc450000) 
  started=n, codec=0
  fifo: 0/0 (0%), queued: 0
  TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
  watchdogs: 0

note: when tune to 112(QVC) which is not on air, can see no audio is running
and no channel is locked.

Q: what's the codec?

MPEG_AUDIO         76 local/refsw/BSEAV/lib/media/bmpeg_audio_util.h #define B_MPEG_AUDIO_LAYER_III      0x01


On hmax 1000, channel 567, NOT OK but mostly no audio but can hear blop sound
in a sec. Also do not have proc device.

On hwei 370, channel 567, OK. But NO proc device to see.



From local/refsw/nexus/modules/core/7420/include/nexus_audio_types.h

/***************************************************************************
Summary:
Audio codecs
***************************************************************************/
typedef enum NEXUS_AudioCodec 
{
    NEXUS_AudioCodec_eUnknown = 0,    /* unknown/not supported audio format */
    NEXUS_AudioCodec_eMpeg,           /* MPEG1/2, layer 1/2. This does not support layer 3 (mp3). */
    NEXUS_AudioCodec_eMp3,            /* MPEG1/2, layer 3. */
    NEXUS_AudioCodec_eAac,            /* Advanced audio coding. Part of MPEG-4 */
    NEXUS_AudioCodec_eAacAdts=NEXUS_AudioCodec_eAac,
    NEXUS_AudioCodec_eAacLoas,        /* Advanced audio coding. Part of MPEG-4 */
    NEXUS_AudioCodec_eAacPlus,        /* AAC plus SBR. aka MPEG-4 High Efficiency (AAC-HE) with ADTS (Audio Data Transport Format) */
    NEXUS_AudioCodec_eAacPlusLoas =NEXUS_AudioCodec_eAacPlus,    /* AAC plus SBR. aka MPEG-4 High Efficiency (AAC-HE), with LOAS (Low Overhead Audio Stream) sync and LATM mux */
    NEXUS_AudioCodec_eAacPlusAdts,    /* AAC plus SBR. aka MPEG-4 High Efficiency (AAC-HE), with ADTS (Audio Data Transport Format) sync and LATM mux */
    NEXUS_AudioCodec_eAc3,            /* Dolby Digital AC3 audio */
    NEXUS_AudioCodec_eAc3Plus,        /* Dolby Digital Plus (AC3+ or DDP) audio */
    NEXUS_AudioCodec_eDts,            /* Digital Digital Surround sound, uses non-legacy frame-sync */
    NEXUS_AudioCodec_eLpcmDvd,        /* LPCM, DVD mode */
    NEXUS_AudioCodec_eLpcmHdDvd,      /* LPCM, HD-DVD mode */
    NEXUS_AudioCodec_eLpcmBluRay,     /* LPCM, Blu-Ray mode */
    NEXUS_AudioCodec_eDtsHd,          /* Digital Digital Surround sound, HD, uses non-legacy frame-sync, decodes only DTS part of DTS-HD stream */
    NEXUS_AudioCodec_eWmaStd,         /* WMA Standard */
    NEXUS_AudioCodec_eWmaPro,         /* WMA Professional */
    NEXUS_AudioCodec_eAvs,            /* AVS */ 
    NEXUS_AudioCodec_ePcm,            /* PCM audio - Generally used only with inputs such as SPDIF or HDMI. */ 
    NEXUS_AudioCodec_ePcmWav,         /* PCM audio with Wave header - Used with streams containing PCM audio */
    NEXUS_AudioCodec_eAmr,            /* Adaptive Multi-Rate compression (typically used w/3GPP) */
    NEXUS_AudioCodec_eDra,            /* Dynamic Resolution Adaptation.  Used in Blu-Ray and China Broadcasts. */
    NEXUS_AudioCodec_eCook,           /* Real Audio 8 LBR */
    NEXUS_AudioCodec_eAdpcm,          /* MS ADPCM audio format */
    NEXUS_AudioCodec_eSbc,            /* Sub Band Codec used in Bluetooth A2DP audio */
    NEXUS_AudioCodec_eDtsLegacy,      /* Digital Digital Surround sound, legacy mode (14 bit), uses legacy frame-sync */
    NEXUS_AudioCodec_eMax
} NEXUS_AudioCodec;


<2>
run custom inspect tool on humax when on a radio channe. started but fifo
depth is nearly zero.

        Audio status: started TSM 
                Codec 1
                Sample rate 0
                Num decoded frames 0
                Num error frames 0
                Num fifo overflows 0
                Num fifo underflows 141
                Current PTS 0
                Current fifo depth 0.000000% (0 of 262144)

On the same box, but on the normal av channel.

        Audio status: started TSM locked 
                Codec 1
                Sample rate 48000
                Num decoded frames 2822
                Num error frames 0
                Num fifo overflows 0
                Num fifo underflows 17
                Current PTS 3639679926
                Current fifo depth 1.586914% (4160 of 262144)

On the PVR2, shows constant updates:

  Started                  : 1
  TSM                      : 1
  Locked                   : 1
  Sample rate              : 48000
  Num decoded frames       : 16193
  Num error frames         : 0
  Num fifo overflows       : 0
  Num fifo underflows      : 3671371537
  Current PTS              : 2146556080
  Current fifo depth       : 1.327515% (3480 of 262144)


<3>
[root@HUMAX hd1]# *** 134364:45:47.303 
nexus_playpump: NEXUS_Playpump_OpenPidChannel: 0xc72ada00 detected duplicated pid 1002 (0x8df17e80:1) with non-compatible settings


05.19
======

<humax>

if (NEXUS_Playpump_GetBuffer(s_astFeederInst->playPumpHandle, &buffer,&buffer_size))
{
    PrintError("ERROR ::NEXUS_Playpump_GetBuffer\n\r",__FUNCTION__,__LINE__);
    goto errout;
}

if (buffer_size == 0)
{
    PrintZMPDebug("[ %s (%d)] buffer_size == 0\n\r",__FUNCTION__,__LINE__);
    errval = EAGAIN;
    goto errout;
}

rc = read(infd, buffer, buffer_size);

if (rc > 0)
{
    bytes_read = rc;

    PrintZMPDebug("buffer_size(%d) rc(%d) \n\r",buffer_size, bytes_read);

    err = NEXUS_Playpump_ReadComplete(s_astFeederInst->playPumpHandle, 0, bytes_read);

    if (err)
    {
        rc = -1;
        PrintError("NEXUS_Playpump_ReadComplete failed\n");
    }
}
               

local/include/refsw/nexus/modules/transport/7420/include/nexus_playpump.h 


/**
Summary: Settings used in NEXUS_Playpump_Open 
**/
typedef struct NEXUS_PlaypumpOpenSettings
{
    size_t fifoSize;            /* size of playpump's fifo in bytes */
    unsigned alignment;         /* You may want to specify the alignment of the fifo allocation to prevent any wasted buffer because of memory alignment requirements.
                                   See NEXUS_Playppump_ReadComplete and its skip parameter for more information about alignment requirements. */
    unsigned numDescriptors;    /* More descriptors are needed to perform certain trick modes. See NEXUS_Playpump_GetBuffer for details. */
    bool streamMuxCompatible;     /* If set to true,  this playpump could be used with the StreamMux module */

    NEXUS_HeapHandle heap;      /* optional heap for fifo allocation */
    NEXUS_HeapHandle boundsHeap; /* optional heap to bounds check all scatter-gather descriptors */
} NEXUS_PlaypumpOpenSettings;


/*
Summary:
Get a pointer and size for the next location in the buffer which can accept playpump data.

Description:
NEXUS_Playpump_GetBuffer is non-destructive. You can safely call it multiple times.

The buffer and size returned by NEXUS_Playpump_GetBuffer are valid until you call
NEXUS_Playpump_Flush or NEXUS_Playpump_WriteComplete.

The size returned by NEXUS_Playpump_GetBuffer can be limited by two things: space in the ring buffer
or free descriptors used to send data to the transport block. If you are performing trick modes with
lots of small reads, you may find that NEXUS_Playpump_GetBuffer says there is no space available
even though NEXUS_PlaypumpStatus reports free space. 

The solution is to increase the number of descriptors in NEXUS_PlaypumpOpenSettings.

*/

NEXUS_Error NEXUS_Playpump_GetBuffer(
    NEXUS_PlaypumpHandle playpump,
    void **pBuffer,  /* [out] attr{memory=cached} pointer to memory mapped region that is ready for playback data */
    size_t *pSize    /* [out] total number of writeable, contiguous bytes which buffer is pointing to */
    );

/**
Summary:
Notify Playpump of how much data was added into the buffer.

Description:
You can only call NEXUS_Playpump_WriteComplete once after a NEXUS_Playpump_GetBuffer call.
After calling it, you must call NEXUS_Playpump_GetBuffer before adding more data.

The skip parameter allows an application to copy data into the playpump buffer with whatever
alignment it desired. This is needed for "direct I/O" from disk drives which requires all memory
access to be page aligned (e.g. 4K). 
*/

NEXUS_Error NEXUS_Playpump_WriteComplete(
    NEXUS_PlaypumpHandle playpump,
    size_t skip,            /* skip is the number of bytes at the beginning of the current buffer pointer
                               which Playpump should skip over. */
    size_t amountUsed       /* amountUsed is the number of bytes, following any skip bytes,
                               which Playpump should feed into transport. */
    );

/* backward compatibility */
#define NEXUS_Playpump_ReadComplete NEXUS_Playpump_WriteComplete


={============================================================================
*kt_dev_uv_task_008* task:07: DEVARCH-9557: netflix launch issue

scp root@172.20.33.192:/opt/zinc-trunk/bin/exec-then-cleanup-app .
scp root@172.20.33.192:/opt/zinc-trunk/lib/libTitaniumCryptoLocking.so.0.0.0 .
scp root@172.20.33.192:/opt/netflix/netflix .

H1000
      :  exec                    
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]

      :  libTitaniumCryptoLocking
 0x00000001 (NEEDED)                     Shared library: [libTitaniumUtils.so.0]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]

      :  netflix
 0x00000001 (NEEDED)                     Shared library: [libm.so.0]
 0x00000001 (NEEDED)                     Shared library: [libJavaScriptCore.so]
 0x00000001 (NEEDED)                     Shared library: [libWTF.so]
 0x00000001 (NEEDED)                     Shared library: [libdirectfb-1.4.so.15]
 0x00000001 (NEEDED)                     Shared library: [libz.so.1]
 0x00000001 (NEEDED)                     Shared library: [libfusion-1.4.so.15]
 0x00000001 (NEEDED)                     Shared library: [libdirect-1.4.so.15]
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libdl.so.0]
 0x00000001 (NEEDED)                     Shared library: [libnexusMgr.so]
 0x00000001 (NEEDED)                     Shared library: [libinit.so]
 0x00000001 (NEEDED)                     Shared library: [libnexus.so]
 0x00000001 (NEEDED)                     Shared library: [libssl.so.1.0.0]
 0x00000001 (NEEDED)                     Shared library: [libcrypto.so.1.0.0]
 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]


HWEI 370, PVR1. the same as H1000

scp root@172.20.35.27:/opt/zinc-trunk/bin/exec-then-cleanup-app .
scp root@172.20.35.27:/opt/zinc-trunk/lib/libTitaniumCryptoLocking.so.0.0.0 .
scp root@172.20.35.27:/opt/netflix/netflix .

/home/kpark/builds/master/huawei.372/zinc-build-root/release-huawei-bcm7231/Polonium/Polonium.NexusInspect/exec-then-cleanup-app
/home/kpark/builds/master/huawei.372/zinc-build-root/release-huawei-bcm7231/Titanium/Titanium.Utils/src/.libs/libTitaniumCryptoLocking.so.0.0.0

find /home/kpark/builds/master/huawei.372/zinc-build-root/release-huawei-bcm7231 -f {exec-then-cleanup-app|libTitaniumCryptoLocking.so.0.0.0}
.
scp root@172.20.35.27:/opt/netflix/netflix .


={============================================================================
*kt_dev_uv_task_009* task:08: fr15: hls: DEVARCH-9722, 9740

https://jira.youview.co.uk/browse/DEVARCH-9722
DEMO - HLS playback through YV MediaRouter - via command line
   https://jira.youview.co.uk/browse/DEVARCH-9739
   note: this is ticket to implement 9722.


DEVARCH-9739:Nickel.System.GStreamer: Support HLS playback 

The current YV MediaRouter don't support HSL playback and as a feature
development required by DEVARCH-9718, this commit adds necessary changes to
build a GST pipeline and to play HSL stream under current YV MediaRouter
implementation.

It should be pointed-out that the MIME type of HLS in this commit is
"application/x-hls" which is different from "application/vnd.apple.mpegurl" in
http:://www.iana.org since underlying hlsdemux uses the former. 



https://jira.youview.co.uk/browse/DEVARCH-9723
DEMO - HLS playback via MediaRouterProxy - via command line
   https://jira.youview.co.uk/browse/DEVARCH-9740

DEVARCH-9740:Nickel.System.Proxy: Support HLS playback in MediaRouterProxy

The current YV MediaRouterProxy don't support HSL playback and as DEVARCH-9722
delivers HLS play in MediaRouter, this commit adds necessary changes to
MediaRouterProxy in order to make a link to HLS playback in the proxy which
enables us to play HLS via DBus command line.


={============================================================================
*kt_dev_uv_task_010* task:09: fr15: yv meadia router switch

DEVARCH-9861: Implement a selection switch between OEM and YV MR

Since there are two media router implementations, this commit introduces a way
to select one of them to use using the LSR key which is default to OEM media
router. The LSR key introduced is :

platform.settings.enable-yv-media

To use YV media router, run:

lsr-config platform.settings.webkit-use-media-router 1

// runBrowser.sh

# Tell WebKit to use the media router for video playback. The default is to use
# the built-in GStreamer pipeline
webkit_use_media_router="false"
[ "false" = "$(lsr-config --bool platform.settings.webkit-use-media-router || echo false)" ] || {
    webkit_use_media_router="true"
}


={============================================================================
*kt_dev_uv_task_011* task:09: fr15: video resize support

https://jira.youview.co.uk/browse/DEVARCH-10262

HTML 5 defines the read-only properties videoHeight and videoWidth, which
contain "the intrinsic height of the resource in CSS pixels, taking into
account the dimensions, aspect ratio, clean aperture, resolution, and so
forth, as defined for the format used by the resource".

These correspond to the naturalSize API on VanadiumMediaPlayer

daren's commit:
gitk cd68d5775af9aae433ff9bf044a62971640642b3 &

DEVARCH-8992: nexussink: Notify video resolution changes using "video-changed" message.

This is part of a commit series that fixes video resizing in the browser.
These commits fix the `videoHeight` and `videoWidth` properties on an
HTML <video> element, which allows WebKit to correctly size video while
maintaining aspect ratio.

When the video resolution changes, send a "video-changed" message
with details of the video resolution and display aspect ratio.

This is required by WebKit in order to be able to populate the
videoWidth and videoHeight properties of the HTML5 video element.

When playing MP4 files, WebKit can find out the video size by
inspecting the caps set on nexussink, but when playing transport
streams, it needs nexussink to provide this information.

This commit is largely taken from one on the alex.ashley/DEVARCH-8992
branch, with the main modification of posting the "video-changed"
message on the main thread when it is idle.

<log>
DEVARCH-10262: Fix video resolution changes delivery in nexussink and
implement plumbing to the YV media router.

This is a commit to provide new video size from Nexus when stream changes
using video size and aspect ratio in order to support video resizing in the
browser since HTML 5 defines the read-only properties `videoHeight` and
`videoWidth` on an video element and which allows WebKit to correctly size
video while maintaining aspect ratio.

This commit examined various commits started from DEVARCH-8992 and different
approach as to Nexus callback to use to obtain stream details reliably. To
that end, do the delivery of video resolution changes via two-level callback
approach and uses simplified math to calculate video size. 

Also this commit implements plumbing up to the YV media router to pass
calculated video size.


={============================================================================
*kt_dev_uv_task_011* task:09: fr15: dash error handling

DASH error handling: Hooking up errors through YV MR
https://jira.youview.co.uk/browse/DEVARCH-9698

DEMO - VOD error handling (source, output controls, etc)
https://jira.youview.co.uk/browse/DEVARCH-10097

DEVARCH-10097: YV MediaRouter: DASH error support

The YV MediaRouter allows the client application to receive errors for
DASH unicast play in case there are errors reported during play and
defines ErrorEventValue and ErrorEventContext to support reporting
errors to the client.

This commit enables video tag in HTML application to receive playback
errors which are non-DRM related errors through WebKit and implements
translation and mapping of play errors between GStreamer and YV
MediaRouter according to the YV MediaRouter[1] and the design
requirement[2].

This commit comes with corresponding test in Vanadium test harness.

[1] 1125-S Media Router Specification v1.3
[2] https://jira.youview.co.uk/browse/SOLDES-584


={============================================================================
*kt_dev_uv_task_011* task:09: fr15: underflow error handling

DEVARCH-10424: YV MediaRouter: Underflow error support

The YV MediaRouter allows the client application to receive HTMLMediaElement
events for underflow event reported during play via StatusEvent.

This commit enables video element in HTML to receive underflow event through
WebKit and implements unit tests according to the YV MediaRouter[1] and the
design requirement[2].

This commit comes with corresponding test in Vanadium test harness.

[1] 1125-S Media Router Specification v1.3
[2] https://jira.youview.co.uk/browse/SOLDES-584

={============================================================================
*kt_dev_uv_task_011* task:09: fr15: fix gstmediaroutertest failure

DEVARCH-10468: YV MediaRouter: Fix gstmediaroutertest failures

There are some unit test failures in gstmediaroutertest and this are due to
changes made to YV MR to support error handling [1][2].

This commit resolves those failures by updating unit tests to conform to changes
and adds some log messages.

[1] DEVARCH-10097
[2] 1125-S Media Router Specification v1.3


={============================================================================
*kt_dev_uv_task_011* task:09: fr15: wrong drm db creation on HWEI PVR2

YVHUAWEI-7403 found that DRM DB file gets created unencrypted and eventually
fails to load on PVR2 because huawei deamon loads Zinc.Common so which loads
sqlite3 as well. However, wasabi so expects its own sqlite statically linked
with it. Since sqlite is loaded first, wasabi version won't get resovled.

Tried to use --as-needed globally in link option but found that there is a
toolchain issue in the toolchain for this platform and the solution is to change
Zinc.Common dependancy directly.

https://jira.youview.co.uk/browse/DEVARCH-10610

DASH: Zinc.Common: Remove dependency on sqlite

As the analysis on YVHUAWEI-7403 showed, the dependency of libZincCommon.so on
libsqlite3.so has caused the problem of using the DRM personalisation DB.

The --as-needed link flag would be a general solution to this but it is disabled
for Huawei PVR2 without history or explanation. The further investigation showed
that when the build has that link flag on, build fails on various 3party packages 
and that there is a toolchain issue, GNU LD, https://sourceware.org/ml/binutils/2013-02/msg00159.html, 
which seems not fixed yet for mips target when looked at git upstream.

The toolchain in question is huawei-stbgcc-4.5.3-2.4 and GNU ld 2.22 and
therefore, some Humax target which uses the same toolchain base has the same
issue and hence no --as-needed flag used.

Since there is no prospect that BRCM would fix this in their future toolchain
delivery, this commit changes Zinc.Common dependencies directly to remove
sqlite3 from the Zinc.Common shared library and would have no impact on the
other part of stack since that sqlite3 feaure was separated out to
libZincCommonSQLite.so.


==============================================================================
vim:tw=100:ts=3:ft=help:norl:
