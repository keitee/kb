*kt_dev_uv*                                                             tw=100

|kt_dev_uv_set_001| setup printer
|kt_dev_uv_set_002| setup email
|kt_dev_uv_set_003| setup: humax build the stack
|kt_dev_uv_set_004| huawei: to revert back the previous version
|kt_dev_uv_set_005| setup: screen connection
|kt_dev_uv_set_006| filegateway
|kt_dev_uv_set_007| setup: huawei build the stack
|kt_dev_uv_set_008| setup: oem staging and toolchains
|kt_dev_uv_set_009| setup: boxes
|kt_dev_uv_set_010| setup: git for dev and oem
|kt_dev_uv_set_011| setup: ci builds

|kt_dev_uv_stack_000| stack: builds
|kt_dev_uv_stack_001| stack: build examples
|kt_dev_uv_stack_002| stack: build: deploy
|kt_dev_uv_stack_003| stack: startup and bootup
|kt_dev_uv_stack_004| stack: oem configs
|kt_dev_uv_stack_005| stack: brcm debug level
|kt_dev_uv_stack_006| stack: netflix ps line
|kt_dev_uv_stack_007| stack: virtual rcu
|kt_dev_uv_stack_008| stack: startup mw
|kt_dev_uv_stack_009| stack: nexusmgr
|kt_dev_uv_stack_010| stack: commit
|kt_dev_uv_stack_011| stack: log
|kt_dev_uv_stack_012| stack: gdb

|kt_dev_uv_stack_100| stack: element names
|kt_dev_uv_stack_101| stack: vanadium: runBrowser
|kt_dev_uv_stack_102| stack: vanadium: binding
|kt_dev_uv_stack_103| stack: vanadium: remote debug
|kt_dev_uv_stack_104| stack: LSR (local storage repository)
|kt_dev_uv_stack_105| stack: uranium
|kt_dev_uv_stack_106| stack: cal: loading
|kt_dev_uv_stack_107| stack: cal: component link creation
|kt_dev_uv_stack_108| stack: cal: metadata: event structures and dbus mapping.
|kt_dev_uv_stack_109| stack: cal: metadata: api and dbus mapping.
|kt_dev_uv_stack_110| stack: cal: metadata: event connection to application
|kt_dev_uv_stack_111| stack: cal: metadata: how events get updated
|kt_dev_uv_stack_112| stack: cal: metadata: events data flow
|kt_dev_uv_stack_113| stack: cal: metadata: summary data flow
|kt_dev_uv_stack_114| stack: cal: metadata: wrapper and convert flow

|kt_dev_uv_stack_200| stack: nickel: 
|kt_dev_uv_stack_201| stack: nickel: tests

|kt_dev_uv_stack_250| stack: binding and makefile 

|kt_dev_uv_stack_300| stack: IP: wikis

|kt_dev_uv_stack_350| stack: pump: gst

|kt_dev_uv_stack_120| stack: cal: dispatcher
|kt_dev_uv_stack_121| stack: cal: unit test
|kt_dev_uv_stack_114| stack: build pc target
|kt_dev_uv_stack_115| stack: text epg
|kt_dev_uv_stack_116| stack: future
|kt_dev_uv_stack_117| stack: future use
|kt_dev_uv_stack_118| stack: metadata and dbus
|kt_dev_uv_stack_119| stack: sandbox

|kt_dev_uv_stack_130| stack: links with 3rd parties. cppunit, gmock and so on

|kt_dev_uv_stack_150| stack: network
|kt_dev_uv_stack_200| stack: dbus

|kt_dev_uv_stack_200| commands TODO:

|kt_dev_uv_wiki_001| dbus-monitor

|kt_dev_uv_hwei_001| stack: convert ro filesystem to rw

|kt_dev_uv_task_001| task:01: nexusMgr
|kt_dev_uv_task_002| task:02: DEVARCH-8869: about IP connection.
|kt_dev_uv_task_003| task:02: DEVARCH-7508: runBrowser-test.sh
|kt_dev_uv_task_004| task:03: DEVARCH-9135: uranium metadata
|kt_dev_uv_task_005| task:01: nexus tools for both hmax and hwei
|kt_dev_uv_task_006| task:05: sort out test failures
|kt_dev_uv_task_007| task:06: playback audio only IP channel


# ============================================================================
#{
={============================================================================
*kt_dev_uv_set_001* setup: printer

1. install cups
sudo apt-get install cups

2. add printers via cups admin page 
See this page, add user to the printer group, and browse to localhost, and
follow the instructions to add printers. 

www.howtoforge.com/how-to-install-a-canon-printer-on-debian-and-debian-like-systems

3. use printer names from this page.
https://wiki.youview.co.uk/display/canvas/How+To+-+Set+up+printers


={============================================================================
*kt_dev_uv_set_002* setup: email

1. The evolution under debian do not work. Forced to use icedove, OWA and
phone instead.

2. Clone the git repo.
Follow this page.
https://wiki.youview.co.uk/display/canvas/How+To+-+Get+access+to+git-dev+repositories


={============================================================================
*kt_dev_uv_set_003* setup: humax build the stack

{install-package}
1. Can see package files from the repo
http://devarch-deb:8080/job/DEBs/ws/DEBS/

-rw-r--r--  1 kpark kpark 205942756 Jan  8 10:30 adobe-flex4-sdk_4.1.0.16076withairsdk2.5-3_i386.deb
-rw-r--r--  1 kpark kpark   5310170 Jan  8 10:30 adobe-stagecraft_2.5.2.3.20120518-3_i386.deb
-rw-r--r--  1 kpark kpark  80815260 Jan  8 10:35 generic-stbgcc-4.4.5-2.0_20120927-2_i386.deb
-rw-r--r--  1 kpark kpark  24399388 Jan  8 10:37 humax-dtr-t1000-staging_20140718H20.2.0-3_i386.deb
-rw-r--r--  1 kpark kpark 328730796 Jan  8 10:48 humax-stbgcc-4.5.3-2.4_20130321-2_i386.deb

2. Or can use apt-get install on the command line.
sudo apt-get install map-dir-and-exec


{1} build-stack
$ cd ~/sources/
zb-virtual-slave zb-shell
ZB_CFG=humax.1000 zb-make

note: shall have pysical data dir under /. when use sym link to the home, failed to build.

<check-package>
dpkg-query -l | grep humax


{2} update-cds; core driver software
https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Humax+DTR-T1000+T1000+H21.5.0

note: follow instruction, CTK. 


{3} update the zinc whcich was built
1. follow "boot from HDD" instruction from:
https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Humax+DTR-T1000+T1000+H21.5.0


{layout}
/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409$ tree -L 3
.
|-- opt
|   `-- zinc-trunk
|       |-- bin
|       |-- devel
|       |-- include
|       |-- lib
|       |-- libexec
|       |-- oss
|       |-- platform
|       |-- share
|       |-- tests
|       `-- var
`-- usr -> /opt/oem-staging/huawei-bcm7409/usr


={============================================================================
*kt_dev_uv_set_004* huawei: to revert back the previous version

touch /opt/cds/download/smdebug

setItem oem.software.version 11.11.11

setItem oem.activatedsoftware.coredevicesoftware.version 11.01.01

setItem oem.activatedsoftware.manufacturerconfiguration.version 1

setItem oem.activatedsoftware.coredevicesoftware.platformapiversion 1.2.0

setItem oem.activatedsoftware.platformsoftware.version 1.3.4

setItem oem.activatedsoftware.platformconfiguration.version 1

Goes to settings -> Dev. Mgt. -> Software Update. Then will update a box from usb stick.

note: Only for ATK.


={============================================================================
*kt_dev_uv_set_005* setup: screen connection

sudo screen /dev/ttyS0 115200

to close screen use Ctrl-A, k, y. Do not use Ctrl-C as it can kill processes running on the box.


={============================================================================
*kt_dev_uv_set_006* filegateway

$ scp -r kit.park@filegateway.youview.co.uk:/export/repos/huawei/from_huawei/PVR1_DN370T/Huawei_DN370T_B37SP33_Eng_Release_20150331_for_YVHUAWEI-6751 ./

$ ssh kit.park@filegateway.youview.co.uk ls -alR /export/repos/huawei/from_huawei/PVR1_DN370T/Huawei_DN370T_B37SP46_Release_20150424/


={============================================================================
*kt_dev_uv_set_007* setup: huawei build the stack

sudo apt-get install huawei-dn370t-toolchain
sudo apt-get install huawei-dn370t-staging
sudo apt-get install huawei-stbgcc-4.5.3-2.4

note: this will picks up the correct file from the link below.
http://devarch-deb.dev.youview.co.uk:8080/job/DEBs/ws/DEBS/

huawei-dn370t-toolchain_20120927-2_i386.deb
huawei-dn370t-nexus_20131104-2_i386.deb
huawei-dn370t-staging_20140804-2_i386.deb

https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Huawei+DN370T+PVR1+B37SP11

ZB_CFG=huawei.370 zb-make


={============================================================================
*kt_dev_uv_set_008* setup: oem staging and toolchanis

https://wiki.youview.co.uk/display/canvas/OEM+Staging+and+Toolchains?src=search

.
|-- adobe
|   `-- stagecraft
|-- Adobe
|   |-- Flex4SDK -> flex_sdk_4.1.0.16076_with_air_sdk_2.5_linux
|   `-- flex_sdk_4.1.0.16076_with_air_sdk_2.5_linux
|-- HipChat
|   |-- bin
|   |-- lib
|   `-- share
|-- oem-staging            // note: it does have headers or possibly sources
|   |-- huawei-bcm7409
|   |-- huawei-dn370t -> huawei-bcm7409
|   |-- humax-dtr_t1000
|   `-- oem-staging.md5
|-- pac
|   |-- lib
|   |-- LICENSE
|   |-- pac
|   |-- README
|   |-- res
|   `-- utils
|-- stagecraft-2.0 -> stagecraft-2.5.2.3.20120105-sl6-directfb1.4-windowed-C12M2-maine_coon-release-20120518
|-- stagecraft-2.5.2.3.20120105-sl6-directfb1.4-windowed-C12M2-maine_coon-release-20120518
|   |-- bin
|   `-- share
`-- toolchains
    |-- generic-stbgcc-4.4.5-2.0
    |-- huawei-bcm7409 -> generic-stbgcc-4.4.5-2.0
    |-- huawei-stbgcc-4.5.3-2.4
    |-- humax-dtr_t1000 -> generic-stbgcc-4.4.5-2.0
    `-- humax-stbgcc-4.5.3-2.4

/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409
drwxr-xr-x 4 kpark kpark 4096 Feb  3 08:06 opt/
lrwxrwxrwx 1 kpark kpark   35 Jan 30 08:28 usr -> /opt/oem-staging/huawei-bcm7409/usr/

<refsw>
The refsw headers from staging:
/opt/oem-staging/huawei-bcm7409/usr/local/refsw/nexus

This is copied to build root to be used in building and these are the same:
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/refsw/nexus

<oem-code>
The OEM header files: note: this means that if changes OEM code and want to build any in the full
stack build env, then need to update staging as well before building.

/opt/oem-staging/huawei-bcm7409/
./usr/local/include/nexusMgr/nexusMgr.h
./usr/local/include/nexusMgr/nexusMgr.c
./usr/local/lib/nexusMgr.h
./usr/local/lib/pkgconfig/nexusMgr.pc

For example, inspect tool and this is link option: path when build inspect tool
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib


https://wiki.youview.co.uk/display/canvas/OEM+Staging+and+Toolchains?src=search

$ sudo apt-get install huawei-dn372t-staging
$ sudo apt-get install huawei-dn372t-toolchain

$ wget http://devarch-deb.dev.youview.co.uk:8080/job/DEBs/ws/pool/main/h/huawei-dn372t-staging/huawei-dn372t-staging_20150427-5_i386.deb
$ sudo dpkg -i huawei-dn372t-staging_20150427-5_i386.deb


={============================================================================
*kt_dev_uv_set_009* setup: boxes

{hmax} 
onlydebug (Humax)

||Hostname||FQDN||IP Address||MAC Address||
humax-0873   humax-0873.dev.youview.co.uk    172.20.35.27   00:03:78:4B:7A:2B

/.ssh -> /var/tmp/authorized_keys


{hwei}
TestHw123 (Huawei)

huawei-04877 huawei-04877.dev.youview.co.uk  172.20.33.192  20:F3:A3:70:D1:94

<1>
if delete this, then will boot from flash
/mnt/nand/userdata/data/rw_cmd


={============================================================================
*kt_dev_uv_set_010* setup: git for dev and oem

<git-oems>
url = gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git
url = gitolite@git-humax.dev.youview.co.uk:/nexusMgr.git

<git-local>
https://git-dev.dev.youview.co.uk/?p=nexusMgr.git;a=summary

https://git-dev.dev.youview.co.uk/

git clone -b huawei/dn370t gitolite@git-dev:/nexusMgr.git XX

/home/kpark/git-dev/nexusMgr        " cloned
/home/kpark/git-dev/nexusMgr-WIP    " work space for hwei 370

{oem}
/home/kpark/git-oem/*

<hmax>
note: need to figure out branch name
git clone gitolite@git-humax.dev.youview.co.uk:/nexusMgr.git nexusHmax

<hwei>
git clone -b huawei/dn370t gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git nexusHwei


={============================================================================
*kt_dev_uv_set_011* setup: ci builds

https://wiki.youview.co.uk/display/canvas/How+access+Jenkins+build+slaves

o to kick off a test build

Hi All,

Ashley has created a TRY builder to which if you give your branch name or Git
Sha and your email id, it will trigger builds for all devices and send you an
email with the results once complete.

http://spongebob.dev.youview.co.uk:8080/job/Build_Zinc_Release_Try/build?delay=0sec

If any build fails, the email will have link to error logs and if build passes
it will link to the binaries available on devnfs2.

You can use this to kick off builds for your dev branches.

Hope you find it useful.

Thanks,

Tarun


o to see build status
http://spongebob:8080/view/developer/job/Test_Build_Concurrent/


={============================================================================
*kt_dev_uv_stack_000* stack: builds

<ET>
Many of these tools rely on the environment variable "ET" to find your checkout of the DEVARCH repo.
The zb-make and zb-build-with-progress tools build the stack out of your source tree, so you can
carry on developing while a build is running. You control this behaviour with the "ZB_BUILD_DIR"
environment variable, so make sure it exists and is writeable by yourself. Similarly, you'll
probably want the tools available in your PATH, so add these to your ~/.profile:

export PATH=~/sources/zinc-git-tools:$PATH
export ET=~/sources/DEVARCH/

<after-zb-shell>
$ env | grep ^Z
ZINC_USER_BUILD_TYPE=release ~
ZINC_HOST_PREFIX=/opt/zinc-trunk
ZINC_REMOTE_LOGGING_HOST=localhost
ZINC_SRC_ROOT=/data/builds/master/huawei.370/DEVARCH
ZINC_HOST_3PS=/data/builds/master/huawei.370/DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack
ZINC_BUILD_ROOT=/data/builds/master/huawei.370/zinc-build-root 
ZINC_DESTDIR=/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409 ~
ZINC_BUILD_DIR=/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409 ~
ZINC_NATIVE_BUILD_ROOT=/data/builds/master/huawei.370/zinc-build-root
ZB_HOST_CONFIG=huawei-bcm7409
ZINC_BUILD_CFG=debian-7-x86_64
ZINC_INSTALL_ROOT=/data/builds/master/huawei.370/zinc-install-root
ZB_CFG=huawei.370 ~
ZB_BUILD_DIR=/data/builds ~
ZB_BRANCH=master ~
ZINC_USER_HOST_PREFIX=/opt/zinc-trunk
ZINC_HOST_CFG=huawei-bcm7409
ZINC_3PS_HOST_PREFIX=/opt/zinc-trunk/oss
ZINC_REMOTE_LOGGING_PORT=4560
ZINC_BUILD_TYPE=release


<build-and-install-dir>

note: the build system picks up any dirs in the tree and try to build those.

note: source is copied to /data/builds/.../DEVARCH
1. ~/source/DEVARCH

2. The build root has only output files such as o and a:
can run make here:

/data/builds/<ZB_BRANCH> /huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/
   Polonium.NexusInspect/Makefile
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/
   Polonium.NexusInspect/Makefile

3. But the makefile uses sources from the copied sources as

/data/builds/<ZB_BRANCH> /huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c
/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c

-c -o nexus_inspect-nexus-inspect.o `test -f 'src/nexus-inspect.c' || echo
'/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/'`src/nexus-inspect.c


/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/
`-- zinc-trunk
    |-- bin
    |-- devel
    |-- include
    |-- lib
    |-- libexec
    |-- oss
    |-- platform
    |-- share
    |-- tests
    `-- var

/bin/
airlauncher.sh*
audiofeedbackd*
avahi-launcher*
babysitterd*
cadmiumcontentacquisitiond*
cobaltmetadatabrokerd*
copperannouncementd*
CopperDownloader*
copperlocalstoragerepod*
crbd*
dbusredirect*
dbussenddaemon*
dbuswaitbusname*
deleteTree*
device-manager-launcher*
dial-server*
dial-server-launcher.sh*
exec-then-cleanup-app*
exec-then-cleanup-app.sh*
exec-with-cache*
generate-http-user-agent*
getChildItems*
getItem*
http-dbus-bridge*
http-dbus-bridge-launcher.sh*
https-cache-proxy*
ironmetadatad*
linearsourced*
linearsource-launch*
linearsource-launch-and-sandbox*
lsr-config*
nexus-inspect*
nickelmediad*
on-demand-launcher*
onscreenidd*
onscreenidd-launch*
osmiumd*
pcmplaybackd*
provisioninginformationparser*
purge-polipo-diskcache.sh*
python_launcher.sh*
queryNetworkManager*
radiumairlauncher*
radiumd*
remindersd*
runBrowser.sh*
runNetflix.sh*
run-stagecraft2-functions.sh*
runStagecraft2.sh*
run-stagecraft2-with-cache.sh*
sandbox-drop-privileges*
setItem*
setpgid-and-exec*
sodiumd*
splashScreen*
start-service-over-dbus.sh*
storagemanagementd*
tunerd*
uimanagerd*
w3cEngine*
watcher*
yv-mainui*
yv-remote-booking-agent-activate*
yv-remote-booking-agent-watcher*
yv-start-services.sh*


<zb-virtual-slave>
zb-virtual-slave zb-make
{
  /source/zinc-git-tools/zb/zb-load-config.sh
  {
      pre: ET, ZB_CFG 

      configure_git_for_zb() {

      conf zb.huawei.360.host-config huawei-dn360t
      conf zb.huawei.370.host-config huawei-bcm7409
      conf zb.huawei.372.host-config huawei-bcm7231
      conf zb.humax.1000.host-config humax-dtr_t1000
      }

      // [zb] ZB_BUILD_DIR
      // build-dir = /data/builds
      // git config zb.build-dir /home/kpark/builds

      do : set ZB_BUILD_DIR, slave_dir=/data/builds/master/pc

      export ZB_HOST_CONFIG=$(get_conf host-config "host")
  }

   real_path="${ZB_BUILD_DIR}/$branch"
   virtual_path="${ZB_BUILD_DIR}/_virtual_"

  + real_path=/data/builds/<BRANCH>
  + virtual_path=/data/builds/_virtual_

  note: "bash -c string" execute string on the given shell.

  note: when change ET using exports, this will not be passed subshell below.

   echo "===================> \"ET=$ET ${program_to_run}\"" 
   exec map-dir-and-exec \
      "${real_path}:${virtual_path}" "ET=$ET ${program_to_run}" "$@"

  + exec map-dir-and-exec /data/builds/master:/data/builds/_virtual_ /bin/bash -c '"zb-make"  		
  2> >( sed -u "s|/data/builds/_virtual_|/data/builds/master|" >&2 ) \
  | sed -u "s|/data/builds/_virtual_|/data/builds/master|"'
}


<zb-shell>
{
   <load-config>
   source $(scriptDir)/zb/zb-load-config.sh
   + source /home/kpark/source/zinc-git-tools/zb/zb-load-config.sh

   <setvars-host>
   source ${slave_dir}/DEVARCH/*/*/setvars-${ZB_HOST_CONFIG}.sh
   + source
   /home/kpark/builds/_virtual_/humax.1000/DEVARCH/OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh
   {
      # N.B: This is a temporary for a QIP release and to be removed.
      export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"
      ++ export ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect
      ++ ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect
   }

   + /home/kpark/source/zinc-git-tools/zb/zb-exec-shell
      source $(scriptDir)/zb-load-config.sh
      source ${slave_dir}/DEVARCH/*/*/setvars-${ZB_HOST_CONFIG}.sh
}


<zb-make>
{
  if [ -n "${ZB_FORCE_BRANCH}" ]; then
      echo "Using overridden branch."
  else
   <load-config>
   source $where_am_i/zb/zb-load-config.sh
   {
      note: pick up brach name or force it

      # Branch of git repository for which build is to be performed
      if [ -n "${ZB_FORCE_BRANCH}" ]; then
          echo "Overriding branch to build to: ${ZB_FORCE_BRANCH}"
          branch=$ZB_FORCE_BRANCH
          # TODO: Validate that the branch exists.
      else
          if [ -f "$ET/.git/rebase-merge/head-name" ]; then
              # We are in the middle of rebasing
              branch="$(cut -b 12- < "$ET/.git/rebase-merge/head-name")"
          else
              branch=$(GIT_DIR=$ET/.git git symbolic-ref HEAD | cut -b 12- )
          fi
      fi

      ++++ GIT_DIR=/home/kpark/source/DEVARCH//.git
      ++++ git config zb.huawei.install-prefix
      +++ var=/opt/zinc-trunk
      ++ ZINC_USER_HOST_PREFIX=/opt/zinc-trunk

      export ZB_BRANCH=$branch
      ++ ZB_BRANCH=DEVARCH-8092

      if
          slave_dir=$ZB_SLAVE_DIR/$ZB_CFG
      else
          slave_dir=$ZB_BUILD_DIR/$branch/$ZB_CFG
      fi

      note: ZB_BUILD_DIR is set

      ++ slave_dir=/data/builds/DEVARCH-8092/huawei.370
   }

   ZB_HOST_CONFIG=host 
   cd $ET
   + cd /home/kpark/source/DEVARCH

   note: use git and add all tracked but not untracted.

   + GIT_DIR=/home/kpark/source/DEVARCH/.git
   + TMP_INDEX=/home/kpark/source/DEVARCH/.git/zb-make.BQARxy
   ++ cp -p /home/kpark/source/DEVARCH/.git/index /home/kpark/source/DEVARCH/.git/zb-make.BQARxy
   ++ GIT_INDEX_FILE=/home/kpark/source/DEVARCH/.git/zb-make.BQARxy
   ++ cd /home/kpark/source/DEVARCH
   ++ export GIT_INDEX_FILE
   
   ++ git add -u
   
   ++ git write-tree
   ++ rm -f /home/kpark/source/DEVARCH/.git/zb-make.BQARxy
   + w_tree=0a1007627919340947ff5559fbcf402c3e45be31
   + [[ 14dbb0bffed797c3de26af9ed3887aa099deaa4a == \1\4\d\b\b\0\b\f\f\e\d\7\9\7\c\3\d\e\2\6\a\f\9\e\d\3\8\8\7\a\a\0\9\9\d\e\a\a\4\a ]]
   + b_commit=0b59954972927a2ee94845191444ed8c010a0399
   
   ++ git commit-tree 0a1007627919340947ff5559fbcf402c3e45be31 -p 0b59954972927a2ee94845191444ed8c010a0399
   
   + w_commit=9bb7699e8dba4d5c478ec12753c0873682a3095a
   
   + git update-ref -m zb-make refs/heads/zb/DEVARCH-8092-TEMP 9bb7699e8dba4d5c478ec12753c0873682a3095a
   + branch=zb/DEVARCH-8092-TEMP
   
   + '[' '!' -e /home/kpark/builds/_virtual_/humax.1000/DEVARCH/Zinc/Zinc.Build/Makefile ']'
   + unset GIT_DIR
   + unset GIT_INDEX_FILE
   + echo /home/kpark/builds/_virtual_/humax.1000/DEVARCH
   + cd /home/kpark/builds/_virtual_/humax.1000/DEVARCH
   + git fetch origin zb/DEVARCH-8092-TEMP
   From /home/kpark/source/DEVARCH
    * branch            zb/DEVARCH-8092-TEMP -> FETCH_HEAD
      0b59954..9bb7699  zb/DEVARCH-8092-TEMP -> origin/zb/DEVARCH-8092-TEMP
   + git update-index --refresh
   + git reset --hard 9bb7699e8dba4d5c478ec12753c0873682a3095a
   HEAD is now at 9bb7699 BUILD: ZB_CFG="humax.1000" make 

   note: one time and can clone again by deleting a makefile?

   # Create repo
   if [ ! -e "$slave_dir/DEVARCH/Zinc/Zinc.Build/Makefile" ]; then
       echo "Creating new build slave - \
         $branch because $slave_dir/DEVARCH/Zinc/Zinc.Build/Makefile doesn't exist"
       rm -Rf "$slave_dir/DEVARCH/"
       mkdir -p "$slave_dir/DEVARCH"
       cd "$slave_dir"
       git clone -s --depth=1 --branch "$branch" "$ET" "$slave_dir/DEVARCH"
   fi

   build_cmd=${ZB_BUILD_CMD-"make"}
   + build_cmd=make

   <setvars>
   {
      note: when not "host", run setvars-host.sh

      if [ "$ZB_HOST_CONFIG" != "host" ];
      + '[' humax-dtr_t1000 '!=' host ']'

      + echo '========================================= BUILDING BUILD TOOLS!!!!'

      + source ../../Zinc/Zinc.Build/setvars-host.sh

      export HOST_TRIPLE="${ARCH}-pc-linux-gnu"
      ++ export HOST_TRIPLE=x86_64-pc-linux-gnu
      export BUILD_TRIPLE=${HOST_TRIPLE}

      ZINC_NATIVE_BUILD=1 source "$(dirname ${BASH_SOURCE})/setvars-common.sh"

      :~/source$ ls -al ./DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack/
      -rwxr-xr-x 1 kpark kpark 1671 Jan  7 15:55 setvars-huawei-bcm7231.sh
      -rwxr-xr-x 1 kpark kpark 1598 Jan  7 15:55 setvars-huawei-bcm7409.sh
      -rwxr-xr-x 1 kpark kpark 1670 Jan  7 15:55 setvars-huawei-dn360t.sh

      :~/source$ ls -al ./DEVARCH/OEM.Humax/OEM.Humax.3rdPartyStack/
      -rw-r--r-- 1 kpark kpark 1822 Jan  7 15:55 setvars-humax-db_t2200.sh
      -rw-r--r-- 1 kpark kpark 1653 Jan  7 15:55 setvars-humax-dtr_t1000.sh
      -rw-r--r-- 1 kpark kpark 1930 Jan  7 15:55 setvars-humax-dtr_t2100.sh
      -rw-r--r-- 1 kpark kpark 2177 Jan  7 15:55 setvars-humax-dtr_t4000.sh
      {
         note: this is for host tools and cwd.

         <setvars-common>
         ++ source ../../Zinc/Zinc.Build/setvars-common.sh
         +++ where_am_i=/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Zinc/Zinc.Build
         {
            {
            if [[ "${ZINC_HOST_CFG}" != "${ZINC_BUILD_CFG}" ]]
            then
               # Cross compilation

               echo "Cross compiling. Host cfg: '${ZINC_HOST_CFG}' Build cfg: '${ZINC_BUILD_CFG}'"
            }

           note: 'roots'

           +++ ZINC_SRC_ROOT=/data/builds/DEVARCH-8092/huawei.370/DEVARCH
           +++ ZINC_BUILD_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-build-root
           +++ ZINC_INSTALL_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root


           +++ ZINC_BUILD_DIR=/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-debian-7-x86_64

           # CXXFLAGS
           if [[ "${ZINC_BUILD_TYPE}" == "debug" ]]
           then
              export CXXFLAGS="-g -O0 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
              export CFLAGS="-g -O0 -pipe ${EXTRA_CFLAGS:-}"
           else
              export CXXFLAGS="-DNDEBUG -O3 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
              export CFLAGS="-DNDEBUG -O2 -pipe ${EXTRA_CFLAGS:-}"
           fi
           +++ [[ debug == \d\e\b\u\g ]]
           +++ export 'CXXFLAGS=-g -O0 -pipe -pthread '
           +++ CXXFLAGS='-g -O0 -pipe -pthread '
           +++ export 'CFLAGS=-g -O0 -pipe '
           +++ CFLAGS='-g -O0 -pipe '

           +++ PKG_CONFIG=/data/builds/master/pc/zinc-install-root/debug/debian-7-x86_64/oss/bin/pkg-config

           # N.B. We are setting -rpath-link here, but DO NOT use this to set -rpath.
           # We should leave libtool to deal with -rpath. Setting it here leads to test executables
           # linking against the old (already installed) libraries.
           #
           
           LDFLAGS="-L${ZINC_DESTDIR}${ZINC_HOST_PREFIX}/lib
           -L${ZINC_DESTDIR}${ZINC_3PS_HOST_PREFIX}/lib -Wl,--as-needed
           -Wl,-rpath-link,${ZINC_DESTDIR}${ZINC_HOST_PREFIX}/lib
           -Wl,-rpath-link,${ZINC_DESTDIR}${ZINC_3PS_HOST_PREFIX}/lib"
           
           +++
           LDFLAGS='-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/lib
           -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib
           -Wl,--as-needed
           -Wl,-rpath-link,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/lib
        -Wl,-rpath-link,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib'

         }
      }

      # We can't build these for PC
      export ZINC_EXCLUDE_PROJECTS="Polonium.GSTNexus Polonium.NexusInspect Polonium.PCMPlayback"

      ++ export 'ZINC_EXCLUDE_PROJECTS=Polonium.GSTNexus Polonium.NexusInspect Polonium.PCMPlayback'
      ++ ZINC_EXCLUDE_PROJECTS='Polonium.GSTNexus Polonium.NexusInspect Polonium.PCMPlayback'

      ++ CPPFLAGS+=' -fstack-protector-all '
   }

   // after done buildtools builds

   Must remake target `buildtools'.
   Successfully remade target file `buildtools'.
   + source ../../OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh

   {
      <setvars-host>
      source ../../*/*/setvars-$ZB_HOST_CONFIG.sh
      + source ../../OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

      // note: unset and set

      ++ unset ZINC_EXCLUDE_PROJECTS

      # N.B: This is a temporary for a QIP release and to be removed.
      export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"
      ++ export ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect
      ++ ZINC_EXCLUDE_PROJECTS=Polonium.NexusInspect

      ++ warnings_flags='-Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat

      -Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format
      -Werror=missing-braces -Werror=nonnull -Werror=parentheses -Werror=pointer-sign
      -Werror=return-type -Werror=sequence-point -Werror=strict-overflow=1 -Werror=trigraphs
      -Werror=unknown-pragmas -Werror=unused-function -Werror=unused-label -Werror=unused-value
      -Werror=volatile-register-var -fdiagnostics-show-option'

      # Enable "Safe" STL wrappers in debug builds.
      # 
      if [[ "${ZINC_BUILD_TYPE}" == "debug" ]]; then
          export CPPFLAGS+=" -D_GLIBCXX_DEBUG "
      fi
      ++ [[ debug == \d\e\b\u\g ]]
      ++ export 'CPPFLAGS+= -D_GLIBCXX_DEBUG '
      ++ CPPFLAGS+=' -D_GLIBCXX_DEBUG '

      # -fstack-protector-all enables the insertion of "canaries" to detect stack-smashing at
      # runtime. The cost of such checks are supposedly small.
      export CPPFLAGS+=" -fstack-protector-all "
      ++ export 'CPPFLAGS+= -fstack-protector-all '
      ++ CPPFLAGS+=' -fstack-protector-all '
   }

   note: back to zb-make

   + build_date='2015-01-09 08:58:17+00:00'
   (
      # Create an environment more like the build servers
      unset DBUS_SESSION_BUS_ADDRESS

      set -o pipefail
      $build_cmd "$@" 2> >( sed -u "s | $ZINC_SRC_ROOT | $ET|" >&2 ) \
      | sed -u "s| $ZINC_SRC_ROOT| $ET|"
   ) && exit_code=0 || exit_code=1 # Don't want to exit on failure

   + unset DBUS_SESSION_BUS_ADDRESS
   + set -o pipefai
l

+ make buildtools
+ make
+ sed -u 's|/data/builds/master/pc/DEVARCH|/home/kpark/source/DEVARCH|'
 sed -u "s|$ZINC_SRC_ROOT|$ET|" >&2 
++ sed -u 's|/data/builds/master/pc/DEVARCH|/home/kpark/source/DEVARCH|'

<makefile>

Zinc/Zinc.Build/project-deps-rules.mk

# Use the list-buildable-projects.sh to work out which project folders under the source root should be considered
# for building. 
# 
# "autozinc" packages are normal projects in the Zinc source tree that are built using autotools.
# This doesn't include the "special" Zinc.3rdPartyStack project, which is actually a GNU make project
# itself that builds many other projects.

AUTOZINC_PACKAGES:=$(shell $(DEVELOPER_MAKEFILE_DIR)/list-buildable-projects.sh -e
$(DEVELOPER_MAKEFILE_DIR)/excluded-elements.txt -p $(DEVELOPER_MAKEFILE_DIR)/excluded-projects.txt
${ZINC_SRC_ROOT}) $(foreach proj,$(AUTOZINC_PACKAGES),$(eval project-makefile-$(proj) =
      $(DEVELOPER_MAKEFILE_DIR)project-makefile-autozinc.mk))


// from "build-with-progress.sh"
# Force the make to do a dry-run so we can work out how many projects need to be built.
let projects_to_build=$(ZINC_DRY_RUN=1 BASH=${BASH} make -n -f ${makefile} ${target_name} | grep
        "+++ Building " | wc -l)

$ zb-make listprojects

$ zb-make list-targets | ag Polo

Polonium.PCMPlayback-distcheck
Polonium.GSTNexus-check
Polonium.NexusInspect.deprecated-check
Polonium.NexusInspect.deprecated
Polonium.GSTTSPacer-distcheck
Polonium.GSTNexus-distcheck
Polonium.PCMPlayback-clean
Polonium.NexusInspect.deprecated-distcheck
Polonium.GSTTSPacer
Polonium.PCMPlayback-install
Polonium.GSTTSPacer-install
Polonium.PCMPlayback-check
Polonium.GSTNexus
Polonium.GSTNexus-install
Polonium.NexusInspect.deprecated-install
Polonium.GSTTSPacer-clean
Polonium.GSTNexus-clean
Polonium.NexusInspect.deprecated-clean
Polonium.PCMPlayback
Polonium.GSTTSPacer-check


<main-makefile>
make[1]: Entering directory `/home/kpark/source/DEVARCH/Zinc/Zinc.Build'
make[1]: Leaving directory `/home/kpark/source/DEVARCH/Zinc/Zinc.Build'

+++ Source: /home/kpark/source/DEVARCH/ +++
+++ Host build dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409 +++
+++ Build log dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/logs +++
+++ Install location: /data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk +++
+++ release build +++
+++ Building Zinc/Zinc.3rdPartyStack +++

[gmock] libtool: link: (cd "lib/.libs" && rm -f "libgtest_main.so.0" && ln -s "libgtest_main.so.0.0.0" "libgtest_main.so.0")

note: for vanadium

+++ Building Vanadium/Vanadium.Common +++
run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-BigData.xml
doc/htmlfragments/interface-BigData.html
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/doc-interface.html.template

run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-AnotherInterface.xml
doc/htmlfragments/interface-AnotherInterface.html
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/doc-interface.html.template

make[1]: Entering directory `/home/kpark/source/DEVARCH//Zinc/Zinc.Build'

Generating configure files... may take a while.

Found new dependencies; recursively calling docmakedepend.
$*='/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-Farm.xml';
         $dependents_list='/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/enum-Animal.xml'

mv -f .deps/Profiler.Tpo .deps/Profiler.Plo

Found new dependencies; recursively calling docmakedepend.
$*='/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-ChannelService.xml';
         $dependents_list='/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/struct-BroadcastData.xml
             /data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/struct-ChannelData.xml'


+++ Building Vanadium/Vanadium.Client.API +++

make[1]: Entering directory `/home/kpark/source/DEVARCH//Zinc/Zinc.Build'
make[2]: Leaving directory `/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Lead/Lead.System.API'
Generating configure files... may take a while.
make[2]: Entering directory `/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Lead/Lead.System.API'
/bin/mkdir -p include src
/bin/mkdir -p include/mock
/bin/mkdir -p mock-python

run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-AnotherInterface.xml
src/AnotherInterface.cpp
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/base.cpp.template 

mv -f .deps/acl-utils-test.Tpo .deps/acl-utils-test.Po
rm -rf /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Vanadium/Vanadium.Client.API


note: to search, use "Building\|NexusInspect" since logs are intermixed.


+++ Building Polonium/Polonium.NexusInspect +++

mkdir -p
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect

cd /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect
&& /home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect/configure
--prefix=/opt/zinc-trunk --build=x86_64-pc-linux-gnu --host=mipsel-linux
--enable-shared --disable-static

make -C
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect

cd /home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect && /bin/bash
/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/missing
--run automake-1.11 --foreign

make[2]: Entering directory
`/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect'

mipsel-linux-gcc -DPACKAGE_NAME=\"nexus-inspect\"
-DPACKAGE_TARNAME=\"nexus-inspect\" -DPACKAGE_VERSION=\"0.1\"
-DPACKAGE_STRING=\"nexus-inspect\ 0.1\"
-DPACKAGE_BUGREPORT=\"darren.garvey@youview.com\"
-DPACKAGE_URL=\"http://www.youview.com\" -DPACKAGE=\"nexus-inspect\"
-DVERSION=\"0.1\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1
-DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1
-DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1
-DLT_OBJDIR=\".libs/\" -I.
-I/home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect
-I/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/include
-isystem
/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/include
-I/opt/oem-staging/huawei-bcm7409/usr/include
-I/opt/oem-staging/huawei-bcm7409/usr/local/include  -D_GNU_SOURCE=1  -fPIC
-fvisibility=hidden -DVERSION=\"0.1\" -DPACKAGE=\"nexus-inspect\"
-DPKG_BIN_DIR=\"/opt/zinc-trunk/bin\" -O3 -g -Wall -Wextra -std=c99
-Werror=implicit-function-declaration -D_REENTRANT -pthread -DNEXUS_MODE_proxy
-DPLATFORM=97409 -DNEXUS_PLATFORM=97409 -DLINUX -D_GNU_SOURCE=1 -DHAVE_RSRVD=1
-DKBUILD_MODNAME=nexus -DPLATFORM=97409 -DNEXUS_PLATFORM=97409
-DBCHP_CHIP=7420 -DBCHP_VER=BCHP_VER_C1 -DBSTD_CPU_ENDIAN=BSTD_ENDIAN_LITTLE
-DBINT_REENTRANT_CONFIG=BINT_REENTRANT -DBMEM_REENTRANT_CONFIG=BMEM_REENTRANT
-DNEXUS_BASE_OS_linuxkernel=1 -DNEXUS_PROFILE_OS_linuxkernel
-DNEXUS_MODE_driver -DNEXUS_PLATFORM_7410_UMA_32b=1 -DNEXUS_IPLICENSING=1
-DNEXUS_OTPMSP=1 -DNEXUS_USERCMD=1 -DNEXUS_HAS_KEYLADDER_SUPPORT=1
-DNEXUS_KEYLADDER=1 -DNEXUS_SECUREACCESS=1 -DNEXUS_SECURERSA=1
-DNEXUS_SECURITY_EXT_KEY_IV -DNEXUS_SECURITY_SC_VALUE -DNEXUS_FRONTEND_NIM
-DNEXUS_AC3 -DNEXUS_CONFIG_IMAGE -DNEXUS_DDP -DNEXUS_HAS_PLATFORM
-DNEXUS_HAS_CORE -DNEXUS_HAS_BASE -DNEXUS_HAS_I2C -DNEXUS_HAS_GPIO
-DNEXUS_HAS_PWM -DNEXUS_HAS_LED -DNEXUS_HAS_IR_INPUT -DNEXUS_HAS_IR_BLASTER
-DNEXUS_HAS_KEYPAD -DNEXUS_HAS_INPUT_CAPTURE -DNEXUS_HAS_UHF_INPUT
-DNEXUS_HAS_RFM -DNEXUS_HAS_FRONTEND -DNEXUS_HAS_SPI -DNEXUS_HAS_SECURITY
-DNEXUS_HAS_DMA -DNEXUS_HAS_TRANSPORT -DNEXUS_HAS_VIDEO_DECODER
-DNEXUS_HAS_AUDIO -DNEXUS_HAS_SURFACE -DNEXUS_HAS_GRAPHICS2D
-DNEXUS_HAS_PLAYBACK -DNEXUS_HAS_DISPLAY -DNEXUS_HAS_ASTM
-DNEXUS_HAS_SYNC_CHANNEL -DNEXUS_HAS_HDMI_OUTPUT -DNEXUS_HAS_SMARTCARD
-DNEXUS_HAS_SIMPLE_DECODER -DNEXUS_HAS_EEPROM -DNEXUS_HAS_SCART
-DBADS_312X_VER=BCHP_VER_A0 -DBHAB_312X_VER=BCHP_VER_A0 -DBHDM_CEC_SUPPORT
-DBHSM_AEGIS_SUPPORT -DBHSM_SC_VALUE -DBHSM_SECURE_PI_SUPPORT=1
-DBHSM_SECURE_PI_SUPPORT_KEYLADDER=1 -DBHSM_SECURE_PI_SUPPORT_MISC=0
-DBHSM_SECURE_PI_SUPPORT_OTPMSP=1 -DBSP_GENERIC -DBXVD_USE_CUSTOM_IMAGE
-DB_HAS_AVI=1 -DB_HAS_RMFF=1 -DGRCPACKET_SUPPORT=1
-DRAP_AACSBR_PASSTHRU_SUPPORT -DRAP_AACSBR_SUPPORT -DRAP_AC3ENC_SUPPORT
-DRAP_AC3_PASSTHRU_SUPPORT -DRAP_AC3_SUPPORT -DRAP_DDP_PASSTHRU_SUPPORT
-DRAP_DDP_SUPPORT -DRAP_DDP_TO_AC3_SUPPORT -DRAP_DRA_PASSTHRU_SUPPORT
-DRAP_DSOLA_SUPPORT -DRAP_DTSBROADCAST_PASSTHRU_SUPPORT
-DRAP_DTSHD_PASSTHRU_SUPPORT -DRAP_LPCMDVD_SUPPORT -DRAP_MPEG_PASSTHRU_SUPPORT
-DRAP_MPEG_SUPPORT -DRAP_PCMWAV_SUPPORT -DRAP_PCM_SUPPORT
-DRAP_REALAUDIOLBR_PASSTHRU_SUPPORT -DRAP_SRC_SUPPORT -DUNIFIED_ITB_SUPPORT
-DDUAL_OUTPUT
-DNDEBUG -O2 -pipe  -MT nexus_inspect-nexus-inspect.o -MD -MP -MF
.deps/nexus_inspect-nexus-inspect.Tpo -c -o nexus_inspect-nexus-inspect.o
`test -f 'src/nexus-inspect.c' || echo
'/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/'`src/nexus-inspect.c


<build-root-install-root>
When install root updated?

:+++ ZINC_INSTALL_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root
:+++ export ZINC_SRC_ROOT ZINC_BUILD_ROOT ZINC_INSTALL_ROOT

Used in build and link:

-DINSTALLDIR="/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib" 

note: installed into by libtool

+ INSTALL='/usr/bin/install -C'

libtool: install: /usr/bin/install -C nexus-inspect
/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/devel/bin/nexus-inspect


<install-root-not-updated>
$ find /data/builds/_virtual_/huawei.370/zinc-build-root/ -name nexus-inspect | xargs ls -al
-rwxrwxr-x 1 kpark kpark 12213 Apr  7 15:00
/data/builds/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect/nexus-inspect

$ find /data/builds/_virtual_/huawei.370/zinc-install-root/ -name nexus-inspect | xargs ls -al
-rwxr-xr-x 1 kpark kpark  7846 Apr  7 14:13
/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin/nexus-inspect

-rwxr-xr-x 1 kpark kpark 12213 Apr  7 14:16
/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/devel/bin/nexus-inspect

note: the build will not refresh opt/zinc-trunk/ and simply overwrite over time. Here
/bin/nexus-inspect was there and the build updates /devel/bin/nexus-inspect only. This caused
confusion and ended up running /bin/ version.


={============================================================================
*kt_dev_uv_stack_001* stack: build examples

<one>
cd =~/sources/DEVARCH/
ZB_CFG="huawei.370" zb-make Polonium/Polonium.NexusInspect
ZB_CFG="huawei.370" zb-make
ZB_CFG=humax.1000 zb-make

ZB_FORCE_BRANCH="xxx" ZB_CFG="huawei.370" zb-make Polonium/Polonium.NexusInspect

# -n dry run
ZB_FORCE_BRANCH="xxx" ZB_OVERWRITE_REMOTE_BRANCH=1 ZB_CFG="huawei.370" zb-make Polonium.NexusInspect -n

ZB_FORCE_BRANCH="xxx" ZB_OVERWRITE_REMOTE_BRANCH=1 ZB_CFG="huawei.370" zb-make Polonium.NexusInspect


<two> check if env is configured properly or do compile manually
cd ~/source/DEVARCH/
ZB_CFG=huawei.370 zb-shell

mipsel-linux-gcc 
mipsel-linux-g++ 

For huwawei as of 04.02

mipsel-linux-g++ (Broadcom stbgcc-4.4.5-2.0) 4.4.5
Copyright (C) 2010 Free Software Foundation, Inc.


<three>
$ cd ~/sources/
ZB_CFG=huawei.370 zb-shell
zb-make Polonium/Polonium.NexusInspect       note: shall not be "../Polonium.NexusInspect/"

OR

ZB_CFG=huawei.370 zb-virtual-slave zb-shell
zb-make

zb-virtual-slave zb-build-with-progress

<tips>

note: can specify make build target
ZINC_SILENT_RULES=1 zb-virtual-slave zb-build-with-progress Zinc.AIR.CTV.Tests-install

ZINC_SILENT_RULES=1 zb-virtual-slave zb-build-with-progress Zinc.AIR.CTV.Tests

DEVARCH/Zinc/Zinc.Build/setvars-common.sh
391-
392-# Automake "silent-rules" can be turned on to reduce the amount of repetitive
393-# information printed when building. Warnings and errors are all still printed
394-# so using silent-rules by default is safe.
395:if [[ "${ZINC_SILENT_RULES}" == 1 ]]; then
396-    export MAKEFLAGS="$MAKEFLAGS V=0"
397-fi


ZINC_INCREMENTAL

DEVARCH/Zinc/Zinc.Build/Makefile
129-#
130-$(patsubst %,$(ZINC_BUILD_DIR)/%buildtools.built,$(PACKAGES) $(zinc3ps) $(zinc_bash_test)) : $(ZINC_BUILD_DIR)/%buildtools.built :
131- $(info +++ Building $* +++)
132-ifeq (${ZINC_DRY_RUN},)  
133:ifeq (${ZINC_INCREMENTAL},)
134- -rm -rf $(HOST_BUILD_DIR)/$*
135:endif # ! ZINC_INCREMENTAL


ZINC_SKIP_TESTS

DEVARCH/Zinc/Zinc.Build/Makefile
37-envtest:=$(and ${ZINC_HOST_CFG},${ZINC_HOST_3PS},${ZINC_HOST_PREFIX},${ZINC_SRC_ROOT},${ZINC_BUILD_ROOT},${PKG_CONFIG},${PKG_CONFIG_PATH},${LDFLAGS},${CPPFLAGS},${ZINC_BUILD_DIR},${BUILD_TRIPLE})
38-
39-DO_CHECK_FLAGS=
40-
41:# Set ZINC_SKIP_TESTS to skip running of the "make check"
42:ifeq (${ZINC_SKIP_TESTS},)


<use-autoconf> to run makefile on built-root or build nexusMgr
git clone -b huawei/dn370t gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git nexusTest

cd nexusMgr

note: use BRANCH
export ET=/data/builds/master/huawei.370/DEVARCH/
export ET=/data/builds/<BRANCH>/huawei.370/DEVARCH/

ZINC_USER_BUILD_TYPE=release source $ET/OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

./autogen.sh

export HOST_TRIPLE=mipsel-linux

./configure --host=$HOST_TRIPLE --with-pic --enable-shared --prefix=$PWD/install

make && make install

make clean; make;
can see output and o file under this.

/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusRelease

But uses sources from: note: DEVARCH

`test -f 'src/exec-then-cleanup-app.c' || echo
'/data/builds/master/huawei.370/DEVARCH/Polonium/Polonium.NexusRelease/'`src/exec-then-cleanup-app.c


<build-log>
'only' when use build-with-progress

/data/builds/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/logs/Polonium/Polonium.NexusInspect.log

ag 'error:'
/data/builds/_virtual_/huawei.370/zinc-build-root/release-huawei-bcm7409/logs/Polonium/Polonium.NexusInspect.log


={============================================================================
*kt_dev_uv_stack_002* stack: build: deploy

<setup-xx-sh>

./setup-humax/setup-humax.sh -h humax-0873
./setup-humax/setup-humax.sh -f humax-0873

note: no zinc-trunk handling. okay to run it as a standalone.

note: this requires RW rfs.

#/   -r            Reboot the box when this script has completed.

#/   -f            Force first time setup. Does additional installation of
#/                 eg. password-less login, rsync, scp.

#
# firstTimeSetup() {
# 
# + debug 'Setting up passwordless login...'
# + debug 'Installing rsync on Humax device...'
# + debug 'Installing custom login script (./setup-humax/custom-login.sh) to /usr/local/bin/ ...'

$ ./setup-huawei/setup-huawei.sh -f 172.20.33.192

note: use git config    

git config zb.huawei.370.deploy-host "hostname of your box here"


<zb-deploy> 

zb-deploy -o humax.1000 -- -r

note: 

$ zb-deploy -o huawei.370 -f nexus-inspect

++ find /data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk
-type f -name nexus-inspect

+ for found_file in '$(find "$PREFIX" -type f -name "$file")'
+ destination=/opt/zinc-trunk/devel/bin/nexus-inspect


-f <file(s)>  Copy one or more files to the device without doing anything drastic, such as killing
daemons or wiping out application sandboxes.

zb-deploy -o humax.1000 -f textEPG


note: careful when use -o option. not to use humax1000 and spend some hours why not working. see
there must be dot(.) so "humax.1000" but not "humax1000"

note: NOT run in sub-shell such as zb-shell. Otherwise, see error:

+ tput sgr0
tput: unknown terminal "xterm"
+ rm -rf /tmp/setup-humax.sh.29807
+ tput sgr0
tput: unknown terminal "xterm"

note: this resync between install-root and box:/opt

-o type of device for which deployment is done where permitted values are

 device-spec   : Description
 -----------------------------------------
 humax.1000 : for Humax T1000 boxes
 humax.2100 : for Humax T2100 boxes
 huawei.360 : for Huawei DN360T boxes
 huawei.370 : for Huawei DN370T boxes
 huawei.372 : for Huawei DN372T boxes


zb-deploy -o huawei.370 -- -r
{
    source $where_am_i/zb/zb-load-config.sh

    // zb.default-config=pc
    //
    if [ -z "${ZB_CFG}" ]; then
       export ZB_CFG=$(get_conf default-config "env")
    fi

    source */*/setvars-$ZB_HOST_CONFIG.sh &>/dev/null
    + source OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh

    deploy_build():
    + deploy_build
    + '[' -z /home/kpark/source/setup-humax ']'
    + '[' -z /home/kpark/source/setup-humax/setup-humax.sh ']'
    which $setup_script_path/$setup_script 2>/dev/null)"
    which $setup_script_path/$setup_script 2>/dev/null)
    which $setup_script_path/$setup_script 2>/dev/null
    ++ which /home/kpark/source/setup-humax/setup-humax.sh
    + '[' '!' -x /home/kpark/source/setup-humax/setup-humax.sh ']'
    + vendor=humax
    +
    patch_a_tron_script=
      /data/builds/_virtual_/humax.1000/DEVARCH/OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh
    
    
    note: call setup-xx-sh <setup-xx-sh>
    + /home/kpark/source/setup-humax/setup-humax.sh -z
        /data/builds/_virtual_/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk
        -P
        file:///data/builds/_virtual_/humax.1000/DEVARCH/OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh
        humax-0873
}


#/   -z <zincdir>  Local build to deploy
#/                 (e.g. $ZINC_INSTALL_ROOT/debug/huawei-dtr_t1000/opt).

#/   -P <patchatron url>  Use the specified patch-a-tron.


={============================================================================
*kt_dev_uv_stack_003* stack: startup

cds: core driver software

/opt/cds/etc/rc.user

root# pwd
/opt

root# ls -al
drwxr-xr-x    8 root     root           149 Dec 25 04:33 .
drwxr-xr-x   17 root     root           259 Dec 25 04:33 ..
drwxr-xr-x    3 root     root            33 Dec 25 02:36 adobe
drwxr-xr-x   12 root     root           247 Dec 25 04:33 cds
drwxr-xr-x    4 root     root            84 Dec 18 14:20 netflix
drwxr-xr-x    4 root     root            39 Dec 25 04:33 stagecraft-2.0
lrwxrwxrwx    1 root     root            15 Dec 25 04:33 ui -> /mnt/psi/ui_psi
dr-xr-xr-x    4 root     root            57 Dec 25 02:36 youview
drwxr-xr-x    9 root     root           186 Dec 25 04:33 zinc


<zinc>
root# pwd
/opt/zinc/bin

root# ls
CopperDownloader                     onscreenidd-launch
MediaRouterDbusSpy                   osmiumd
airlauncher.sh                       pcmplaybackd
audiofeedbackd                       persistedpairingrepository_utils.py
avahi-launcher                       provisioninginformationparser
babysitterd                          purge-polipo-diskcache.sh
cadmiumcontentacquisitiond           python_launcher.sh
cobaltmetadatabrokerd                queryNetworkManager
copperannouncementd                  radiumairlauncher
copperlocalstoragerepod              radiumd
crbd                                 remindersd
dbusredirect                         run-stagecraft2-functions.sh
dbussenddaemon                       run-stagecraft2-with-cache.sh
dbuswaitbusname                      runBrowser.sh
deleteTree                           runNetflix.sh
device-manager-launcher              runStagecraft2.sh
dial-server                          sandbox-drop-privileges
dial-server-launcher.sh              setItem
exec-with-cache                      setpgid-and-exec
generate-http-user-agent             sodiumd
getChildItems                        splashScreen
getItem                              start-and-wait-for-busname.sh
http-dbus-bridge                     start-service-over-dbus.sh
http-dbus-bridge-launcher.sh         storagemanagementd
https-cache-proxy                    tunerd
ironmetadatad                        uimanagerd
linearsource-launch                  w3cEngine
linearsource-launch-and-sandbox      watcher
linearsourced                        yv-mainui
lsr-config                           yv-remote-booking-agent-activate
nickelmediad                         yv-remote-booking-agent-watcher
on-demand-launcher                   yv-start-services.sh note:
onscreenidd


<lib-third-party>
/usr/local/lib

directfb-1.4-15            libfusion-1.4.so.15.0.0    libpng14.so.14.3.0
libdirect-1.4.so.15        libfusion.so               libsawman-1.5.so.0
libdirect-1.4.so.15.0.0    libinit.so                 libsawman-1.5.so.0.0.4
libdirect.so               libjpeg.so                 libsawman.so
libdirectfb-1.4.so.15      libjpeg.so.7               libshim_nexus.so
libdirectfb-1.4.so.15.0.0  libjpeg.so.7.0.0           libz.so
libdirectfb.so             libnexus.so                libz.so.1
libfreetype.so             libnexusMgr.so             libz.so.1.2.6
libfreetype.so.6           libpng.so                  modules
libfreetype.so.6.4.0       libpng14.so                pkgconfig
libfusion-1.4.so.15        libpng14.so.14

<humax-from-hdd-boot-case>
/mnt/hd1/bin

[root@HUMAX bin]# cat startYVServices.sh 
#!/bin/sh

/opt/zinc/bin/start-service-over-dbus.sh Zinc.ContentAcquisition
/opt/zinc/bin/start-service-over-dbus.sh Zinc.DeviceSoftware
/opt/zinc/bin/start-service-over-dbus.sh Zinc.DeviceManager
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Broker
/opt/zinc/bin/start-service-over-dbus.sh Zinc.UsageCollection
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Application
/opt/zinc/bin/start-service-over-dbus.sh Zinc.LinearSource
/opt/zinc/bin/start-service-over-dbus.sh Zinc.RemoteDiagnostics
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Metadata --requires Zinc.Broker
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Reminders
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Boot


{zinc-boot}
https://jira.youview.co.uk/browse/DEVARCH-8276
Zinc.Boot service itself will be started from an OEM script.

The new service introduces the "$prefix/bin/yv-start-services.sh" script,
which it runs from a sandboxed environment. The script is meant to start
other services using the DBus activation mechanism. In this initial
version, it starts Zinc.DIAL only. When asking OEMs to start Zinc.Boot,
we are going to simultaneously ask them to stop starting Zinc.DIAL.

This implementation comes with an unfortunate side effect of producing
the following message to the serial console:

Error org.freedesktop.DBus.Error.NoReply: Did not receive a reply.
Possible causes include: the remote application did not send a reply,
the message bus security policy blocked the reply, the reply timeout
expired, or the network connection was broken.

This comes as a result of Zinc.Boot service not claiming the "Zinc.Boot"
bus name, but is otherwise completely harmless. At this point we decided
not to tackle this issue, as the cost/benefit ratio seems quite high in
this case.

~/src-dev/DEVARCH/Zinc/Zinc.Boot/data$ cat yv-start-services.sh.in 
#!/bin/sh

prefix="@prefix@"

start() {
    echo "Starting $1"
    "${prefix}/bin/start-service-over-dbus.sh" "$@"
}

start Zinc.DIAL
start Zinc.Crb
start Zinc.DBusBridge

exit 0

This is going to be changed to use "staged" boot using wait-on-cpu-load:

https://stash.dev.youview.co.uk/projects/DEVARCH/repos/devarch-mirror/commits/c57e81a58fc10dafe466b6e37b938fb5a5575880

note: here bucket is stage or ring level

This commit works best if OEM boot scripts only start Zinc.Boot
(and their daemons) and let Zinc.Boot start the YouView services
in an efficient manner.

The commit makes Zinc.Boot start all necessary services in three
buckets with delays between each. The idea is that some
non-essential services can be started later so they don't steal
precious CPU cycles or I/O / memory bandwidth.

The delays between each bucket depend on the system load, and the
idea is that the boot script waits until the load drops below a
certain value. This can be configured with new LSR keys:

platform.boot.delay-window-size
platform.boot.step-1-delay-load-threshold
platform.boot.step-2-delay-load-threshold

There is no delay in "step 0" - where key services are started.

The buckets look like:

Step 0:
- Start UI, metadata and media services

Step 1:
- Start second screen / remote control services

Step 2:
- Start CRB, Reminders, Usage Collection services


~/src-dev/DEVARCH/Zinc/Zinc.Boot/data$ cat yv-start-services.sh.in 

# Step 0: Start the minimal set of services to get into live
#         TV / interactive UI fast.
start Zinc.Metadata
start Zinc.Broker
start Zinc.Application
start Zinc.LinearSource

wait_for_idle $threshold1 30

# params:
#	cpu-threshold (percents)
#	timeout (seconds)
#	Note, that for the window size: 25 and sampling period 500ms
#	it will wait for at least 12.5s (the avg window gets filled)
wait_for_idle() {
	$prefix/bin/yv-wait-for-idle -s 500 -w $window_size -e $1 -t $2
}

# from yv-wait-for-idle

("exit_threshold,e", boost::program_options::value(&exit_threshold),
   "If specified specified (in %) - program will exit if "
   "CPU utilisation will fall below this value (default=1)")

("timeout,t", boost::program_options::value(&timeout_seconds),
   "Timeout in seconds (default=infinite)")


{on-dbus}
[root@HUMAX dbus-1]# pwd
/opt/zinc-trunk/oss/share/dbus-1

[root@HUMAX dbus-1]# 
drwxr-xr-x    8 1024     1025        4.0K May  1 12:01 ./
drwxr-xr-x   14 1024     1025        4.0K Apr 30 12:01 ../
drwxrwxr-x    2 1024     1025        4.0K Apr 30 11:59 interfaces/
drwxrwxr-x    2 1024     1025       16.0K Apr 30 12:35 introspection-xml/
drwxrwxr-x    2 1024     1025        4.0K May  1 12:01 services-oem/
drwxrwxr-x    2 1024     1025        4.0K Apr 30 12:47 services-yv/
drwxrwxr-x    2 1024     1025        4.0K Apr 30 12:47 services-yv.orig/
drwxr-xr-x    2 1024     1025        4.0K Apr 30 11:54 system-services/


[root@HUMAX dbus-1]# cat services-oem/Zinc.Media.service 
[D-BUS Service]
Name=Zinc.Media
Exec=/opt/zinc/bin/bronzemediad
User=root


={============================================================================
*kt_dev_uv_stack_004* stack: oem configs

root# getChildItems oem

root# getChildItems oem | grep softwre
oem.activatedsoftware.coredevicesoftware.platformapiversion=2.9.1
oem.activatedsoftware.coredevicesoftware.version=70.37.05
oem.activatedsoftware.coredevitesoftware.version=1.0.0
oem.activatedsoftware.ispconfiguration.version=10002
oem.activatedsoftware.manufacturerconfiguration.version=4
oem.activatedsoftware.platformconfig=
oem.activatedsoftware.platformconfiguration.version=1304
oem.activatedsoftware.platformsoftware.version=2.9.6
oem.software.version=70.37.05
oem.softwaremanagement.coredevicesoftware.manifest.baseurl=http://su.tv.talktalk.net
oem.softwaremanagement.coredevicesoftware.updatepolicy=standard
oem.softwaremanagement.manufacturerconfiguration.baseurl=http://su.tv.talktalk.net
oem.softwaremanagement.manufacturerconfiguration.updatepolicy=standard


root# which getChildItems
/opt/zinc/bin/getChildItems


{oem-pkg-config}
local -> /opt/oem-staging/humax-dtr_t1000/usr/local//
local/lib/pkgconfig/axis2c.pc
local/lib/pkgconfig/nexus-mgr.pc
local/lib/pkgconfig/directfb.pc
local/lib/pkgconfig/direct.pc
local/lib/pkgconfig/nexusMgr.pc
local/lib/pkgconfig/uuid.pc
local/lib/pkgconfig/fusion.pc
local/lib/pkgconfig/directfb-internal.pc
local/lib/pkgconfig/sawman.pc
local/lib/pkgconfig/nexus.pc


local -> /opt/oem-staging/huawei-dn370t/usr/local/
local/directfb/lib/pkgconfig/libpng.pc
local/directfb/lib/pkgconfig/nexus-mgr.pc
local/directfb/lib/pkgconfig/freetype2.pc
local/directfb/lib/pkgconfig/libpng14.pc
local/directfb/lib/pkgconfig/directfb.pc
local/directfb/lib/pkgconfig/direct.pc
local/directfb/lib/pkgconfig/nexusMgr.pc
local/directfb/lib/pkgconfig/uuid.pc
local/directfb/lib/pkgconfig/fusion.pc
local/directfb/lib/pkgconfig/directfb-internal.pc
local/directfb/lib/pkgconfig/sawman.pc
local/directfb/lib/pkgconfig/nexus.pc
local/lib/pkgconfig/libpng.pc
local/lib/pkgconfig/nexus-mgr.pc
local/lib/pkgconfig/freetype2.pc
local/lib/pkgconfig/libpng14.pc
local/lib/pkgconfig/directfb.pc
local/lib/pkgconfig/direct.pc
local/lib/pkgconfig/nexusMgr.pc
local/lib/pkgconfig/uuid.pc
local/lib/pkgconfig/fusion.pc
local/lib/pkgconfig/directfb-internal.pc
local/lib/pkgconfig/sawman.pc
local/lib/pkgconfig/nexus.pc


={============================================================================
*kt_dev_uv_stack_005* stack: brcm debug level

Invalid level. Should be: err, wrn, msg or none.
echo "nexusMgr msg" >> /proc/brcm/debug


={============================================================================
*kt_dev_uv_stack_006* stack: netflix ps line

16386     1518 66.4 30.2 229456 97392 ?        Sl   14:45   1:03 /opt/netflix/netflix
--write-data-path /app-data/var --cache-path /app-data/cache --disk-cache-path
/app-data/var/nrd/gibbon --user-agent YouViewPlayer4/1.0 (Huawei Technologies Co., Ltd;
    DN370T.02.02.T; 001; CDS/70.37.05; API/2.9.1; PS/2.9.6) (+DVR+FLASH+HTML+MHEG+IPCMC)
--dpi-friendlyname YouView-0067 --device-model YouView_DN370T --esn
YVWTTGD370-9cac040a-6397-4bbd-a0dd-61743837e958 --mdx-manufacturer Huawei Technologies Co., Ltd
--mdx-model-name YouView_DN370T --software-version 70.37.05 --no-mdx
--ui-query-string=source_type=2&trackId=13783779&trackUrl=https%3A%2F%2Fapi.netflix.com%2FBaSePaTh%3Fpage%3DMetaSearch%3F


={============================================================================
*kt_dev_uv_stack_007* stack: virtual rcu

https://wiki.youview.co.uk/display/canvas/2012/04/23/Automating+input+to+the+UI?src=search

<hwei-case>
scp libyouviewrcu.so root@172.20.33.192:/opt/zinc/lib
scp libyouviewrcushim.so root@172.20.33.192:/usr/local/lib/directfb-1.4-15/inputdrivers/
scp libyouviewrcushim.so root@172.20.33.192:/opt/zinc/oss/lib/directfb-1.4-15-pure/inputdrivers/
scp zinc-send-key-hwei root@172.20.33.192:/usr/local/bin

note: no need to build drivers for hwei. Simply use humax binary which are pre-built.

note: the difference is whether use host nc or busybox nc

# to run it on the box
$ scp zinc-send-input-key root@172.20.33.192:/usr/local/bin

printf "D\t${key}\n\0U\t${key}\n\0" | /opt/zinc/oss/bin/busybox nc $box_ip $box_port


# to run it on the host
./zinc-send-input.sh page_up 172.20.33.192 2033

note: cannot use it on host since nc failed. seems that there is firewall settings on a target. so
run it on a target.


<keys>
See this for other keys:
https://svn.youview.co.uk/Canvas/Documents/Presentation.Technology/trunk/2105-S%20Flash%20Presentation%20Engine%20Integration%20Specification%20v1.1E%20tracked.pdf

menu                             YouView
page_up                          Channel Up
page_down                        Channel Down
escape                           Close
cursor_up/down/left/right        
ok                               Enter
back                             Back


<to-check>
1007 ?        Sl     0:06 /usr/local/bin/directfb/1.4/dfbmaster

root# cat /proc/1007/maps | grep youview
-3731c000 r-xp 00000000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3732c000 r--p 00000000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3732d000 rw-p 00001000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3754c000 r-xp 00000000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so
-37568000 r--p 00097000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so
-3756a000 rw-p 000a4000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so

root# printf "D\tMENU\n\0U\tMENU\n\0" | /opt/zinc/oss/bin/busybox nc localhost 2033

note: The latest eng release from huawei do not load these so. So do not work.


={============================================================================
*kt_dev_uv_stack_008* stack: startup mw

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin/yv-start-services.sh

#!/bin/sh

prefix="/opt/zinc-trunk"

start() {
    echo "Starting $1"
    "${prefix}/bin/start-service-over-dbus.sh" "$@"
}

start Zinc.DIAL
start Zinc.Crb

exit 0


/opt/zinc-trunk/bin$ cat start-service-over-dbus.sh 
#!/bin/bash

#
# Launch a dbus service using dbus activation
#
# Author: morgan.henry@youview.com
#

#
# Usage: ./start-service-over-dbus.sh Zinc.Metadata [ --requires Zinc.System ]
#

busname=$1

if [[ $2 == "--requires" ]]; then
	# If we know the service we are about to start requires some other service
	# that has an initialisation period that is potentially greater that the dbus method_call timeout
	# then we can explicitly wait for the required service to start
	# This should be avoided where possible, since it is sub-optimial
	requires=$3
	dbuswaitbusname --timeout 30 $requires
fi

# Send a ping to a known dbus service daemon to cause dbus activation trigger daemon launch
dbus-send --session --type=method_call --print-reply --dest=$busname / org.freedesktop.DBus.Peer.Ping &


{nickelmediad} {onscreenidd}
/source/DEVARCH/Nickel/NickelOnScreenId.System.DBusServer/Makefile.am
bin_PROGRAMS = \
	onscreenidd

/source/DEVARCH/Nickel/Nickel.System.DBusServer/Makefile.am
bin_PROGRAMS = nickelmediad

/source/DEVARCH/Nickel/Nickel.System.DBusServer/src/MediaDaemon.cpp

int main(int argc, char *argv[]) {
  NICKEL_INFO("Launching Fake Media Router Service Daemon...");
  int result = EXIT_SUCCESS;

  try {
    MainLoop mainloop(BusName::MEDIA);
    MediaDaemon daemon(mainloop);
    mainloop.post(boost::bind(&MediaDaemon::start, &daemon, argc, argv));
    result = mainloop.run();
  } catch (std::exception& e) {
    std::cerr << e.what() << endl;
    result = EXIT_FAILURE;
  }

  NICKEL_INFO("Fake Media Router Service Daemon shutting down...");
  return result;
}


={============================================================================
*kt_dev_uv_stack_009* stack: nexusmgr

While working on nexus inspect tool, found that it failed to find the libnexusMgr.so at runtime.
Investigated and found that the inspect tool expect libnexusMgr.so.0 and own-built mgr has the same
as SONAME but there is ONLY libnexusMgr.so in /usr/local/lib. 

libnexusMgr.so.0 -> libnexusMgr.so

This easy solution worked okay. 

Do we need to make a change to a system to make a link? Why was it okay to run other
application that uses that library?

note: <QQQQ> this is hwei case. how about humax? see /usr/local/lib

Investigated the system and found that applications uses the realname.

So the easiest is to change makefile of libnexusMgr to use realname than soname.


04.02: summary
======
1. nexusMgr comes from OEM staging

/opt/oem-staging/huawei-bcm7409:

./usr/local/include/nexusMgr/nexusMgr.h
./usr/local/include/nexusMgr/nexusMgr.c
./usr/local/lib/nexusMgr.h

./usr/local/lib/pkgconfig/nexusMgr.pc

./usr/local/directfb/lib/libnexusMgr.so
./usr/local/lib/libnexusMgr.so


2. pkg-config when is in shell configured for a target

$ pkg-config --libs nexusmgr
Package nexusmgr was not found in the pkg-config search path.
Perhaps you should add the directory containing `nexusmgr.pc'
to the PKG_CONFIG_PATH environment variable
No package 'nexusmgr' found

$ pkg-config --libs nexusMgr
-L/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -Wl,-rpath,/usr/local/lib -lfusion -ldirect -linit -lnexus -lz -lpthread


3. inspect tool builds line

-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib ~
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread -pthread ~
nexus_inspect-nexus-inspect.o: In function `main':
/home/kpark/source/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c:343:

note: see that picks from staging and the use of linkername.


4. the previous next inspect do not have a reference to nexusMgr.so as below:

$ readelf -d ./Polonium/Polonium.NexusRelease/nexus-inspect | grep NEED
(standard input):4: 0x00000001 (NEEDED)                     Shared library: [libnexus.so]

That's why it was not a problem before.


5. compare nexusMgrs

kpark@wll1p04345:/opt/oem-staging/huawei-bcm7409/usr/local/lib$ readelf -d libnexusMgr.so.org 

Dynamic section at offset 0x14c contains 29 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libnexus.so]
 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)                     Shared library: [libm.so.0]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x0000000f (RPATH)                      Library rpath: [/opt/stagecraft-2.0/bin:/opt/zinc/oss/lib]
 0x0000001d (RUNPATH)                    Library runpath: [/opt/stagecraft-2.0/bin:/opt/zinc/oss/lib]

kpark@wll1p04345:/opt/oem-staging/huawei-bcm7409/usr/local/lib$ readelf -d libnexusMgr.so     

Dynamic section at offset 0x14c contains 27 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libinit.so]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x0000000e (SONAME)                     Library soname: [libnexusMgr.so.0]

note: the own nexusMgr buils has soname but the original don't


box:/usr/local/lib/libnexusMgr.so has no soname as the original.



5.1 Given that the original mgr so do not have soname. However, build mgr own and then it has soname
as below. 

10:libtool: link: mipsel-linux-gcc -shared  -fPIC -DPIC  .libs/nexusMgr.o   -lpthread -linit
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib  -O3 -pthread -O2 -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/oss/lib
-pthread -Wl,-soname -Wl,libnexusMgr.so.0 -o .libs/libnexusMgr.so.0.0.0

Therefore, when link nexus tools, these will picks up soname. So it's all down to how mgr is built. 


<how-other-uses-nexus-mgr>

6.1. when run w3c, not load nexusMgr but when 'runs' video, can see nexusMgr in mem mapping. So
there seems other so to load nexusMgr when needed. note that w3c do have a reference to nexus mgr
so.


6.2. The libgstnexus.so for both oems uses the real name. The one on a box shows the same.

Dynamic Section:
  NEEDED               libnexusMgr.so
  ...
  SONAME               libgstnexus.so.0


<the-proposal>
https://jira.youview.co.uk/browse/DEVARCH-9145

h3. New nexusMgr library proposal and guideline

h4. 0. Introduction
There has been a need to have tools to release forcefully nexus resources which are locked up when
an application exits abnormally and to have more information about nexus resources.

The tools are developed for one of OEMs and it uses the private nexusMgr implementation details.
However, the both OEMs have different implementations and prevents YouView from having common
nexus tools that works on both OEMs.

Therefore, this proposal propose a separation between inspection and releasing and OEMs and
YouView, propose new APIs, and shows a working implementation as a base for them to have a quick start. 


h4. 1. Capability interface and the inspect header
The proposal introduces capability interface to query the exposed capability of OEM nexusMgr and
uses it to inspect resources.

The header defines the version and the structure to be used for both OEMs and is subject to future
extension if necessary. YouView maintain and release it to OEMs based on the common agreement and it
will be the part of OEM staging delivery.

{noformat}
/**
 * nexus-inspect.h
 *
 * Created: 11 February, 2015
 *
 * This header defines a capability structure and API to get nexus resources
 * from OEM nexus managers in order to inspect various status or information
 * about nexus resources.
 *
 * OEMs may implement the API with this header provided by YouView and use the
 * version specified and agreed between YouView and OEMs.
 *
 * Copyright (C) 2015 YouView TV Ltd
 */     

#ifndef _NEXUS_INSPECT_H_
#define _NEXUS_INSPECT_H_

/**
 * Defines nexus inspect capability versions for future extensions.
 */
#define NEXUS_INSPECT_CAP_V0     (0x00000001)
#define NEXUS_INSPECT_CAP_V1     (0x00000002)

/**
 * Defines nexus inspect capability structure for each version. OEM may set the
 * unsupported resources to NULL from a return.
 *
 * More version structures for future extensions if necessary.
 */
#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_INSPECT_NUM_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[NEXUS_INSPECT_NUM_ADECS];
  NEXUS_VideoDecoderHandle    videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_DmaHandle             dmaHandle;
  NEXUS_VideoWindowHandle     videoWindow;
  NEXUS_PlaypumpHandle        playpump[NEXUS_INSPECT_NUM_PLAYPUMPS];
  pid_t                       resource_pid;
} NexusInspectCapsV0;


#endif /* _NEXUS_INSPECT_H_ */
{noformat}

h4. 2. New APIs
The proposal introduces two new APIs which are implemented in nexusMgr.

{noformat}
/**
 * Defines a API to get nexus inspect capability.
 *
 * @ param {version} specify the capability version to request
 * @ param {cap} specify the capability structure to get values from nexus
 * manger according to the version.
 *
 * @ return {bool} true when nexus manager supports the provided version and
 * fills up the structure.  Otherwise, false.
 */     
bool BcmNexus_Acquire_Capability( unsigned int version, void *cap, size_t size );

/**
 * Defines a API to release nexus resources.
 *
 * @ param {application_pid} specify the PID which holds nexus resources.
 *
 * @ return none
 */     
void BcmNexus_Release_All_Resources_Acquired_By_Process( pid_t application_pid );
{noformat}

h4. 3. The suggested nexusMgr implementation
The suggested implementation shows implementation to support the proposal. Although this is working
on a target, it is OEM's onus to make a official delivery to YouView that may supports both the
proposal and the OEM specific needs. The suggested in nexusMgr.c only shows the added code.

{noformat}
typedef struct {
  // {PROPOSED}
  pid_t                               resource_pid;
} BcmNexus_Shared_Memory;

const BcmNexus_StreamPlayer_Resources *
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
  // {PROPOSED}
  if( (BcmNexus_State.sharedMem->resource_pid != 0) && (BcmNexus_State.sharedMem->resource_pid != getpid()) )
  {
    BDBG_MSG_TRACE(("BcmNexus_StreamPlayer_Resources_Acquire: already acquired"));
    goto err_playpump;
  }

  // {PROPOSED}
  BcmNexus_State.sharedMem->resource_pid = getpid();
}

void 
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *resources_)
{
  // {PROPOSED}
  BcmNexus_State.sharedMem->resource_pid = 0;
}

// {PROPOSED}
void 
BcmNexus_Release_All_Resources_Acquired_By_Process( pid_t application_pid )
{
  // Getting nexus shm
  //
  BcmNexus_State.masterProcess = do_platform_init(sizeof(BcmNexus_Shared_Memory));
  BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: masterProcess = %c",BcmNexus_State.masterProcess?'y':'n'));

  NEXUS_Platform_Join();

  BcmNexus_State.sharedMem = (BcmNexus_Shared_Memory*)setupSharedMemory(sizeof(BcmNexus_Shared_Memory), (BcmNexus_State.masterProcess ? true : false));
  BDBG_ASSERT(BcmNexus_State.sharedMem);

  if (BcmNexus_State.masterProcess) {
    return;
  }

  if( BcmNexus_State.sharedMem->resource_pid == application_pid ) 
  {
    // Cleaning up nexus resources
    //
    BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Stopping video decoder"));
    NEXUS_VideoDecoder_Stop( BcmNexus_State.sharedMem->videoDecoder );

    for (uint8_t i = 0; i < NEXUS_INSPECT_NUM_ADECS; ++i)
    {
      BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Stopping audio decoder"));
      NEXUS_AudioDecoder_Stop( BcmNexus_State.sharedMem->audioDecoder[i] );
    }

    BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Flushing video decoder"));
    NEXUS_VideoDecoder_Flush( BcmNexus_State.sharedMem->videoDecoder );

    for (uint8_t i = 0; i < NEXUS_INSPECT_NUM_ADECS; ++i)
    {
      BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Flushing audio decoder"));
      NEXUS_AudioDecoder_Flush( BcmNexus_State.sharedMem->audioDecoder[i] );
    }

    BcmNexus_State.sharedMem->resource_pid = 0;
  }

  return;
}

bool 
BcmNexus_Acquire_Capability( unsigned int version, void *cap, size_t capSize )
{
  // Getting nexus shm
  //
  BcmNexus_State.masterProcess = do_platform_init(sizeof(BcmNexus_Shared_Memory));
  BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: masterProcess = %c",BcmNexus_State.masterProcess?'y':'n'));

  NEXUS_Platform_Join();

  BcmNexus_State.sharedMem = (BcmNexus_Shared_Memory*)setupSharedMemory(sizeof(BcmNexus_Shared_Memory), (BcmNexus_State.masterProcess ? true : false));
  BDBG_ASSERT(BcmNexus_State.sharedMem);

  if (BcmNexus_State.masterProcess) {
    return false;
  }

  ((NexusInspectCapsV0*)cap)->videoDecoder = BcmNexus_State.sharedMem->videoDecoder;

  return true;
}
{noformat}

h4. 4. The JIRAs, the branch and git
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

o The proposed nexus tools. review/DEVARCH-8092/3 on Stash
https://stash.dev.youview.co.uk/projects/DEVARCH/repos/devarch-mirror/compare/commits?sourceBranch=refs%2Fheads%2Freview%2FDEVARCH-8092%2F3&targetBranch=refs%2Fheads%2Fmaster

DEVARCH-9131: NexusInspect: Fix up makefile to build nexus utilities. There is no common solution
for nexus utility features since both OEMs have different nexusMgr implementations and the current
implementation of nexus utility is tightly coupled with nexusMgr implementation which is private and
OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080. This
commit has the necessary changes of makefile to build nexus utility and to fix the link order
problem ...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9130: NexusInspect: Add nexus inspect tool. There is no common solution for nexus utility
features since both OEMs have different nexusMgr implementations and the current implementation of
nexus utility is tightly coupled with nexusMgr implementation which is private and OEM dependant as
described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080. This commit add the nexus
inspect which uses the proposed APIs to show information of nexus resources. Since the tool is no
l...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9129: NexusInspect: Add nexus release tool and revise the exec wrapper There is no common
solution for nexus utility features since both OEMs have different nexusMgr implementations and the
current implementation of nexus utility is tightly coupled with nexusMgr implementation which is
private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and
DEVARCH-8080. This commit add the nexus release which is revised to use the proposed APIs to release
nexus resou...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9128: NexusInspect: Add the nexus inspect to the build for Huawei dn370t There is no common
solution for nexus utility features since both OEMs have different nexusMgr implementations and the
current implementation of nexus utility is tightly coupled with nexusMgr implementation which is
private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and
DEVARCH-8080. This commit add the nexus utility project to the build for Huawei dn370t.		5 days ago
5 JIRA Issues	

o The updated and proposed nexusMgr.
https://git-dev.dev.youview.co.uk/?p=nexusMgr.git;a=shortlog;h=refs/heads/propose/huawei


={============================================================================
*kt_dev_uv_stack_010* stack: commit

DEVARCH-XXX: Single line brief description of what this does or fixes.

High level description of what this commit fixes. Give the "why" without
going into too much implementation detail. Could be readable by DME,
OEMs and others who don't have intimate knowledge of the code.

Some more detail about what you've done. Useful for future reference
and for those with more technical knowledge.

- Possibly some bullet points if the commit touched a few different
  things.

Keep all but the first line to <80 chars. If the first line has to be very long to say what the
commit does, then you're probably trying to put too much into one commit. Commits should be "unixy"
- do only one thing and do it well. Here's the wiki page I mentioned previously:

https://wiki.youview.co.uk/display/testautomation/Zinc+Coding+guidelines?src=search#ZincCodingguidelines-Gitcommits

<commit-log>
DEVARCH-8092: the proposed nexus tools and interface to nexusMgr

There is no nexus-inspect for Huawei which is used to release all nexus resources when an
application exits abnormally.

The both OEMs have different nexusMgr implementations and the current nexus-inspect is tightly
coupled with nexusMgr implementation which is private and OEM dependant as described in
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

Therefore, these commits introduce a separation between inspection and releasing and OEMs and
Youview, propose new APIs, and shows a working implementation in order to make them to deliver the
updated nexusMgr as soon.
  
To use this commit, may use the revised nexusMgr from OEMs which is subject to future delivery from
OEMs according to this proposal.

<log>
DEVARCH-7508: Vanadium.W3CEngine.test: Fix runbrowser-test.sh

The cause of the problem is that the cache size is introduced in the runBrowser.sh[1] but not in the
runBrowser-test.sh. Hence mismatch which causes this failure.

As with runBrower.sh, this commit fixes the problem by looking up the cache size or silently continuing
if it hasn't been set from LSR key `platform.settings.html-app-cache-size` and so the behaviour
shouldn't be surprising.

[1] See DEVARCH-7362, commit cddb793

$ zg-jira-request-review DEVARCH-7508_1 b6157860ac9fbc1d54bb48820b2f2ed7d662c094^1..b6157860ac9fbc1d54bb48820b2f2ed7d662c094

<log>
YVHUAWEI-6095: Add the latest nexusMgr from Huawei

This is the latest which fixes kernel Oops when an application exits abnormally and is delivered via
this Jira ticket. 


<commit-log> for the nexusMgr proposal
DEVARCH-8092: the proposed nexusMgr for Huawei dn370t

The both OEMs have different nexusMgr implementations and the current nexus-inspect is tightly
coupled with nexusMgr implementation which is private and OEM dependant as described in
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

Therefore, this commit proposes a working implementation to introduce a separation between
inspection and releasing and OEMs and YouView, and propose PID check and new APIs to support these.


<commit-log>
<1>
DEVARCH-8092: Add the nexus inspect to the build for Huawei dn370t

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus utility project to the build for Huawei dn370t. 

<2>
DEVARCH-8092: Add the nexus release tool and revise the exec wrapper

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus release which is revised to use the proposed APIs to release nexus
resources and the updated exec wrapper to use the same.

<3>
DEVARCH-8092: Add the nexus inspect tool

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus inspect which uses the proposed APIs to show information of nexus
resources.

<4>
DEVARCH-8092: Change makefile to build nexus utility

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit has the necessary changes of makefile to build nexus utility and to fix the link order
problem when links with nexusMgr shared library.


<stash>
kpark@wll1p04345:~/source/DEVARCH$ git push origin DEVARCH-9135:review/DEVARCH-9135/0


={============================================================================
*kt_dev_uv_stack_011* stack: log

{from-proc}
As an example, can work out log file from fd info:

root       793  0.7  1.0  25528  4176 ?        Sl   16:04   0:00 /opt/zinc/oss/sbin/NetworkManager 
   --no-daemon --log-level=INFO

# ll /proc/793/fd
fd/     fdinfo/ 

# ll /proc/793/fd/
dr-x------    2 root     root           0 Feb 16 16:06 ./
dr-xr-xr-x    6 root     root           0 Jan  1  2000 ../
lr-x------    1 root     root          64 Feb 16 16:06 0 -> /dev/null
l-wx------    1 root     root          64 Feb 16 16:06 1 -> /var/tmp/NetworkManager.log
lrwx------    1 root     root          64 Feb 16 16:06 10 -> /dev/nexus_astm
lrwx------    1 root     root          64 Feb 16 16:06 11 -> /dev/nexus_display
lrwx------    1 root     root          64 Feb 16 16:06 12 -> /dev/nexus_graphics2d
lrwx------    1 root     root          64 Feb 16 16:06 13 -> /dev/nexus_surface
lrwx------    1 root     root          64 Feb 16 16:06 14 -> /dev/nexus_audio
lrwx------    1 root     root          64 Feb 16 16:06 15 -> /dev/nexus_video_decoder
lrwx------    1 root     root          64 Feb 16 16:06 16 -> /dev/nexus_transport
lrwx------    1 root     root          64 Feb 16 16:06 17 -> /dev/nexus_dma
lrwx------    1 root     root          64 Feb 16 16:06 18 -> /dev/nexus_security
lrwx------    1 root     root          64 Feb 16 16:06 19 -> /dev/nexus_spi
l-wx------    1 root     root          64 Feb 16 16:06 2 -> /var/tmp/NetworkManager.log
lrwx------    1 root     root          64 Feb 16 16:06 20 -> /dev/nexus_frontend
lrwx------    1 root     root          64 Feb 16 16:06 21 -> /dev/nexus_keypad
lrwx------    1 root     root          64 Feb 16 16:06 22 -> /dev/nexus_rfm
lrwx------    1 root     root          64 Feb 16 16:06 23 -> /dev/nexus_uhf_input
lrwx------    1 root     root          64 Feb 16 16:06 24 -> /dev/nexus_input_capture
lrwx------    1 root     root          64 Feb 16 16:06 25 -> /dev/nexus_ir_blaster
lrwx------    1 root     root          64 Feb 16 16:06 26 -> /dev/nexus_ir_input
lrwx------    1 root     root          64 Feb 16 16:06 27 -> /dev/nexus_led
lrwx------    1 root     root          64 Feb 16 16:06 28 -> /dev/nexus_gpio
lrwx------    1 root     root          64 Feb 16 16:06 29 -> /dev/nexus_i2c
lr-x------    1 root     root          64 Feb 16 16:06 3 -> pipe:[548]|
lrwx------    1 root     root          64 Feb 16 16:06 30 -> /dev/nexus_pwm
...

cat /var/tmp/NetworkManager.log

<when-in-sandbox>
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:14 10 -> /run/youview/jail/daemons/
   osmiumd-N7HXTA/opt/zinc/var/log/litanium.log
lrwx------    1 osmiumd  osmiumd       64 Feb 16 16:14 11 -> anon_inode:[eventpoll]
lrwx------    1 osmiumd  osmiumd       64 Feb 16 16:14 12 -> anon_inode:[eventfd]
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:04 2 -> /dev/null
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:04 3 -> /run/youview/jail/daemons/
   osmiumd-N7HXTA/opt/zinc/var/log/osmium.log

cat /opt/zinc/var/daemons/osmiumd/log/osmium.log


{refs}
https://wiki.youview.co.uk/display/canvas/Zinc+Logging+Framework

<config-and-use>

/home/kpark/builds/master/pc/zinc-install-root/debug/debian-7-x86_64/share/uranium-common/uranium.props

log4cplus.logger.uranium=TRACE, uraniumfile

log4cplus.appender.uraniumfile=log4cplus::RollingFileAppender
log4cplus.appender.uraniumfile.File=/home/kpark/builds/_virtual_/pc/zinc-install-root/debug/debian-7-x86_64/var/log/uranium.log
log4cplus.appender.uraniumfile.layout=log4cplus::PatternLayout
log4cplus.appender.uraniumfile.layout.ConversionPattern=%D{%Y-%m-%d %H:%M:%S,%q} %-5p %x %t %c %l %m%n


export URANIUM_LOGGING_RULE="DEBUG, uraniumfile"      // not work
export URANIUM_LOGGING_RULE="DEBUG,uraniumfile"       // not work
export URANIUM_LOGGING_RULE="TRACE,STDOUT"            // work
./systemmediarecordcachetest 


Canvas Core C++ components use the log4cplus.sourceforge.net project. 

#include <zinc-common/Logger.h>

ZINC_DECLARE_LOGGER(uranium);

#define URANIUM_FUNC_TRACE ZINC_FUNC_TRACE(ZINC_GET_LOGGER(uranium))
#define URANIUM_FUNC_DEBUG ZINC_FUNC_DEBUG(ZINC_GET_LOGGER(uranium))

#define URANIUM_SCOPE_TRACE(a) ZINC_SCOPE_TRACE(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_SCOPE_DEBUG(a) ZINC_SCOPE_DEBUG(ZINC_GET_LOGGER(uranium), a)

#define URANIUM_TRACE(a) ZINC_TRACE(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_DEBUG(a) ZINC_DEBUG(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_INFO(a) ZINC_INFO(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_WARN(a) ZINC_WARN(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_ERROR(a) ZINC_ERROR(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_FATAL(a) ZINC_FATAL(ZINC_GET_LOGGER(uranium), a)


#define ZINC_DECLARE_LOGGER(name) \
	namespace name { \
		namespace detail { \
			ZINC_EXPORT extern log4cplus::Logger* logger; \
			ZINC_EXPORT log4cplus::Logger& getLoggerFallback(); \
		} \
	}


https://wiki.youview.co.uk/display/canvas/Debugging+Issues+on+a+Device?src=search

Applications like the main UI or OnDemand players live in a different place:

# Main UI logs on a patch-o-tron build:
/opt/zinc-trunk/var/applications/data/air/mainui/log/

# Main UI logs on an integrated build:
/opt/zinc/var/applications/data/air/mainui/log/

To collect all application logs into a single tarball, you can run this command:
tar -cjf application-logs.tar.bz2 $(find /opt/zinc*/var/applications/ -name "*.log")

ie. create a bzipped tarball called "application-logs.tar.bz2" by finding all files in application
directories ending in ".log"


={============================================================================
*kt_dev_uv_stack_012* stack: gdb

#debug "Installing gdb..."
#installTool mipsgdb.tar
#installTool mipsgdb-libthread.tar
# Set up a useful symlink so "gdb" and "gdbserver" are on the usual PATH.
#$ssh 'ln -sf /opt/zinc/oss/debugtools/bin/gdb* /usr/local/bin/'

kpark@wll1p04345:~/source/setup-huawei$ ./setup-huawei.sh -T mipsgdb.tar 172.20.33.192
failed to create pid file /run/rsyncd.pid: File exists

Untaring and installing tool: mipsgdb.tar...
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 40.4M  100 40.4M    0     0   103M      0 --:--:-- --:--:-- --:--:--  104M
sending incremental file list
./
rsync: failed to set times on "/." (in Root): Read-only file system (30)
opt/
opt/zinc/
opt/zinc/oss/
opt/zinc/oss/debugtools/
opt/zinc/oss/debugtools/bin/
opt/zinc/oss/debugtools/bin/gdb
opt/zinc/oss/debugtools/bin/gdbserver
opt/zinc/oss/debugtools/bin/run
opt/zinc/oss/debugtools/include/
opt/zinc/oss/debugtools/include/ansidecl.h
opt/zinc/oss/debugtools/include/bfd.h
opt/zinc/oss/debugtools/include/bfdlink.h
opt/zinc/oss/debugtools/include/dis-asm.h
opt/zinc/oss/debugtools/include/symcat.h
...
sent 42365871 bytes  received 1528 bytes  6518061.38 bytes/sec
total size is 42355143  speedup is 1.00
rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1070) [sender=3.0.9]


={============================================================================
*kt_dev_uv_stack_100* stack: elememt names

element or component names
https://wiki.youview.co.uk/display/canvas/YouView+Element+Names?src=search

Cobalt   Enhanced metadata (IP sourced) Zinc.Broker 
Iron     Linear metadata (Broadcast sourced) Zinc.Metadata 


={============================================================================
*kt_dev_uv_stack_101* stack: vanadium: runbrowser

Vanadium provides:

Support for Remote Debugging Webkit provides a protocol that allows remote access to the browser.
See https://www.webkit.org/blog/1620/webkit-remote-debugging/ It adds a "-debug" option to the
command line for w3cEngine that will enable the remote debug on port 9222. Once enabled, you can
access the remote debug information by connecting to port 9222 on the STB using Chrome.

Support for client-side disk cache, i.e. support for storing data on the client in a directory that
is specified by the "-cache" command line. Specifically, it adds support for:

Client-side caching of resources requested by the w3cEngine
Usage of the LocalStorage HTML5 API
Usage of the application cache HTML5 feature

Support for persistent storage of cookies It adds a CookieJar class that uses the QSettings API to
persist cookies. The file used to store cookies is specified by the "-jar" command line option.


# from terminal
Running '/opt/zinc-trunk/bin/runBrowser.sh --app /app --data /app-data --app-launch-parameters
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2011-10-22#groupId.application
crid://bbc.co.uk/iplayer/flash_player/1
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2012-11-08#applicationPublisherIdentifier
uk.co.bbc
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2014-09-25#groupId.application.ondemandPlayer
crid://bbc.co.uk/iplayer/flash_player/1 launch_context.ui.youview.com portal tvp.bbc.co.uk iplayer'
in sandbox...  /app/META-INF/HTML/application.xml validates


app-dir    : /app
data-dir   : /app-data
url        : http://www.bbc.co.uk/iplayer/
sources    : http://www.test.bbc.co.uk http://www.bbc.co.uk http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk
cache-size : 50000000
channel    : 
exec-helper: /opt/zinc-trunk/bin/exec-then-cleanup-app


./Vanadium/Vanadium.W3CEngine/scripts/runBrowser.sh

exec_wrapper="$prefix/bin/exec-then-cleanup-app"
[ -x "$exec_wrapper" ] || exec_wrapper=""

cmd="${RUN_BROWSER_CMD:-$prefix/bin/w3cEngine}"

exec $exec_wrapper "$cmd" \
$enable_webkit_remote_debugging_as_needed \
-cache "$app_data_dir/client-cache" \
-cache-size "$cacheSize" \
-jar "$app_data_dir/cookies.sqlite" \
-url "$url" \
-src "$sources"


** KT: ===================== **
** KT: exec-then-cleanup-app ** pid((null)) 
** KT: exec-then-cleanup-app: pid(null) 
** KT: exec-then-cleanup-app: parent: argv[1](/opt/zinc-trunk/bin/w3cEngine) 
** KT: exec-then-cleanup-app: child: argv[0](/opt/zinc-trunk/bin/exec-then-cleanup-app) parent_pid(1479) 
** KT: ===================== **
** KT: exec-then-cleanup-app ** pid(1479) 
** KT: exec-then-cleanup-app: pid(not null), cleanup_exe(/opt/zinc-trunk/bin/nexus-inspect) 
Going to watch pid: 1479

# when do abnormal termination
** HMAX KT: Releasing Nexus resources: expected 1479 == shm 1479 

# when do normal termination
** HMAX KT: The nexus resources are currently free. shm is 0


16385     2025 15.1 19.9 341300 75940 ?        Sl   15:22   0:37 /opt/zinc/bin/w3cEngine -cache
/app-data/client-cache -cache-size 50000000 -jar /app-data/cookies.sqlite -url
http://www.bbc.co.uk/iplayer/ -src http://www.test.bbc.co.uk http://www.bbc.co.uk
http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk

note: do not work on the box
LD_DEBUG=libs 
/opt/zinc/bin/w3cEngine -cache 
/app-data/client-cache -cache-size 50000000 -jar /app-data/cookies.sqlite -url 
http://www.bbc.co.uk/iplayer/ -src http://www.test.bbc.co.uk http://www.bbc.co.uk 
http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk


={============================================================================
*kt_dev_uv_stack_102* stack: vanadium: binding

JSBindingNP.h

/**
 * This is a single entry point for binding JavaScript with C++ via NPAPI.
 *
 * `JSBindingNP` is a base class which API specific classes should inherit For
 * example if `Example` API needs to be provided to JavaScript, a binding class
 * for it should be created:
 *
 *     class ExampleBindingNP : public JSBindingNP { ... };
 *
 * The reason for this relationship is that the `JSBindingNP` base class is used
 * to resolve the actual calls with what's been registered by the concrete
 * binding class.
 *
 * The concrete binding class should provide an API that mirrors the actual
 * "back-end" implementation API and register it in the `JSBindingNP` class with
 * macros provided.  When the call is resolved it's responsible for
 * unmarshalling and validating the arguments, making a call to the
 * implementation and marshalling the result.
 *
 *    ExampleBindingNP::ExampleBindingNP(const boost::shared_ptr<Example>& impl)
 *        : impl(impl), ...
 *    {
 *        JS_BINDING_NP_BEGIN(ExampleBindingNP);
 *        ADD_METHOD(foo);
 *        ADD_PROPERTY(bar);
 *        JS_BINDING_NP_END();
 *    }
 *
 *    NPVariant ExampleBindingNP::foo(const NPVariant* const args,
 *                                    const uint32_t argCount)
 *    {
 *        // ...
 *    }
 *
 *    NPVariant ExampleBindingNP::bar()
 *    {
 *        // getter
 *    }
 *
 *    void ExampleBindingNP::bar(const NPVariant* value)
 *    {
 *        // setter
 *    }
 *
 * Adding and removing events is pretty much handled by the `JSBindingNP` class.
 * A concrete binding class only needs to register the event and set a callback
 * on a relevant implementation callback handler.  The callback should then do
 * all arguments marshalling and call `JSBindingNP::notifyListeners()` method.
 *
 *    JS_BINDING_NP_BEGIN(ExampleBindingNP);
 *    // ...
 *    ADD_EVENT(onbaz);
 *    impl->onbaz(
 *        boost::bind(&ExampleBindingNP::onbaz, this));
 *    // ...
 *
 *    void ExampleBindingNP::onbaz()
 *    {
 *        notifyListeners("onbaz", std::vector<NPVariant>());
 *    }
 */

<0> To be used from JavaScript like this to register app 'listener' to NPAPI.

broadcastObj = document.getElementById('someId');
broadcastObj.addEventListener("NetworkConnectivityStateChange",
function(state, error) { /* console.log("state = "+state); */ });

The state argument is an integer enumeration with 0 standing for "disconnected" and 1 standing for "connected".


<1> so "binding" dir has bindings for each 'interface' such as Channelxxx and VideoBroadcastxxx.

// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/bindings/VideoBroadcastBindingNP.h, cpp
// 
// class VideoBroadcast is ABC and then concrete impl classes:
//
// /broadcast/production/
// class ProductionVideoBroadcast : public VideoBroadcast,
//
// /broadcast/fake/
// class ZINC_LOCAL FakeBroadcast : virtual public Broadcast   note: why virtual?
//

class VideoBroadcastBindingNP : public JSBindingNP
{
    boost::shared_ptr<VideoBroadcast> vb;
}

<2-1>
Register its handler with vb "impl" class. This is to set up path to get event
from lower parts. 'down' path

VideoBroadcastBindingNP::VideoBroadcastBindingNP(
    const boost::shared_ptr<VideoBroadcast>& vb,
    NPP npp)
    : JSBindingNP(npp),
      vb(vb)
{
    ...

    ADD_EVENT(onNetworkConnectivityStateChange);

    vb->onNetworkConnectivityStateChange(
        boost::bind(&VideoBroadcastBindingNP::onNetworkConnectivityStateChange,
                    this, _1));
    ...
}

<2-2>
Forward 'event' up to app.

void VideoBroadcastBindingNP::onNetworkConnectivityStateChange(
    NetworkConnectivityState::Enum state)
{
  std::vector<NPVariant> args(1);
  args[0] = wrap(state, plugin());

  notifyListeners("onNetworkConnectivityStateChange", args);
}


<3> save a handler of "binding" class in the concrete class.

// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/production/ProductionVideoBroadcast.cpp 

void ProductionVideoBroadcast::onNetworkConnectivityStateChange(
    boost::function<void(NetworkConnectivityState::Enum)> handler)
{
  // this is function<> object
  onNetworkConnectivityStateChangeHandler = handler;
}

<4>
void ProductionVideoBroadcast::emitNetworkConnectivityStateChange(
    NetworkConnectivityState::Enum state)
{
  if (onNetworkConnectivityStateChangeHandler)
  {
    try
    {
      onNetworkConnectivityStateChangeHandler(state);
    }
    catch (...)
    {
      VANADIUM_WARN("Executing network connectivity state change handler failed");
    }
  }
}

// from NM?
// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/production/ProductionVideoBroadcast.cpp 
// 
void ProductionVideoBroadcast::StateChanged(
    const NS_NEON_SYSTEM::NM_STATE::Enum state)
{
  NetworkConnectivityState::Enum const targetState =
    state == NS_NEON_SYSTEM::NM_STATE::connected
    ? NetworkConnectivityState::connected
    : NetworkConnectivityState::disconnected;

  emitNetworkConnectivityStateChange(targetState);
}

<map-to-concrete-class>
BroadcastPluginNP::BroadcastPluginNP(BroadcastFactory& f, NPP npp) :
    f(f),
    jsCallInProgress(false),
    releasing(false),
    npp(npp),
    jsDispatcher(boost::make_shared<JSEventDispatcherNP>(npp)),
    jsAsyncDispatcher(boost::make_shared<JSEventDispatcherNP>(npp, true))
{
  ...

  // boost::shared_ptr<VideoBroadcast> videoBroadcast;
  
  videoBroadcast = f.createVideoBroadcast(jsDispatcher, jsAsyncDispatcher);

  // Create a binding for videoBroadcast.
  const boost::shared_ptr<VideoBroadcastBindingNP> videoBroadcastBinding =
    boost::make_shared<VideoBroadcastBindingNP>(videoBroadcast, npp);
}

<>
kpark@wll1p04345:~/source/DEVARCH/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast$ tree .
.
|-- api
|   |-- BroadcastFactory.cpp
|   |-- ChannelConfig.cpp
|   |-- Channel.cpp
|   |-- ChannelList.cpp
|   |-- VideoBroadcast.cpp

|-- bindings
|   |-- ChannelBindingNP.cpp
|   |-- ChannelConfigBindingNP.cpp
|   |-- ChannelListBindingNP.cpp
|   |-- CollectionBindingNP.h
|   |-- VideoBroadcastBindingNP.cpp

|-- broadcast-plugin.cpp
|-- broadcast-plugin.h
|-- BroadcastPluginNP.cpp
|-- BroadcastPluginNP.h

|-- fake
|   |-- FakeBroadcastFactory.cpp
|   |-- FakeBroadcastFactory.h
|   |-- FakeVideoBroadcast.cpp
|   `-- FakeVideoBroadcast.h

|-- JSBindingNP.cpp
|-- JSBindingNP.h
|-- JSEventDispatcherNP.cpp
|-- JSEventDispatcherNP.h
|-- JSObjectNP.h
|-- JSTypeUnwrappingNP.cpp
|-- JSTypeUnwrappingNP.h
|-- JSTypeWrappingNP.cpp
|-- JSTypeWrappingNP.h
|-- NPObjectIntrusivePtr.h
|-- plugin-logger.h
`-- production
    |-- ProductionBroadcastFactory.cpp
    |-- ProductionBroadcastFactory.h
    |-- ProductionVideoBroadcast.cpp
    `-- ProductionVideoBroadcast.h


# broadcast-plugin.cpp

    // not sure who calls this but from a code, a browser call this and this
    // function registers functions
//
NPError NP_Initialize(NPNetscapeFuncs* nFuncs, NPPluginFuncs* pFuncs)
{
    try
    {
      // 1. register its function table with the caller(browser?)
      // *pFuncs = npp;
      //
      // 2. create T and add T to a map<mine, T*> for MINE, video/broadcast.
      //
      // boost::ptr_map<std::string, BroadcastFactory> factories;
      //
      // addFactory<ProductionBroadcastFactory>(MIME_TYPE);
      //
      // note: 'Production' created.
      return internal::NP_Initialize(nFuncs, pFuncs);
    }
    CATCH_BAD_ALLOC
    CATCH_ALL

    return NPERR_GENERIC_ERROR;
}


={============================================================================
*kt_dev_uv_stack_103* stack: vanadium: remote debug

https://wiki.youview.co.uk/display/YVDP/Debugging?src=search


={============================================================================
*kt_dev_uv_stack_104* stack: LSR (local storage repository)

./Copper/Copper.System.DBusClient/src/lsr-config.c


={============================================================================
*kt_dev_uv_stack_105* stack: uranium. air.

<air>
Adobe AIR for TV. AIR is flash runtime engine.
https://wiki.youview.co.uk/display/YVDP/Air+for+TV?src=search

<stagecraft>
Adobe had taken great steps in making the Flash Lite player available to be licensed by mobile
device and CE manufacturers.  As I understand it Stagecraft goes one step farther by wrapping the
Flash Lite player in a layer that mitigates the risks associated with porting just the Flash Lite
player itself. It insures that SWFs created for one Stagecraft based device will work on all
Stagecraft based devices.


={============================================================================
*kt_dev_uv_stack_106* stack: cal

{so-loading}
So can use either config file or the direct name. 

note: uses the same "createSystemClientFactory" for all libraries.


<0> EPG gets a CF via this
Create a client factory. The below is how test cast do to get CF. 

static const PluginConfig &getClientFactoryPluginConfig(void)
{
    static const FixedPluginConfig pluginConfig("libUraniumClientSystem.so", "createSystemClientFactory");
    return(pluginConfig);
}

Uranium.AIR.Client.API/data/client-factory.plugin-config
1:libUraniumClientSystem.so createSystemClientFactory

Uranium.Client.System/src/SystemClientFactory.cpp

Plugin* createSystemClientFactory() {
  URANIUM_PROFILE_FUNC;
  return 'new' NS_URANIUM_CLIENT::SystemClientFactory();
}


<1> Binding. Using CF, calls createXXX.

Uranium.AIR.Client.API/src/UraniumAirPlugin.cpp

Create a singletone instance of each interface locator and this locator has a singletone of real
interface so this is singletone chain. Pass a SP to it back to a client. Client can use a real
instance since locator has interface to get SP of real instance.


class ZINC_LOCAL UraniumAirPlugin : public GenericAirPlugin<UraniumAirPlugin, ClientFactory> 
{
  void initSingletons(ClientFactory& clientFactory) 
  {
    note: create <MD>
    shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> nativeLocator(
        clientFactory.createMetadataLocator()
        );

    NS_URANIUM_METADATA_AIR_CLIENT::LocatorBinding::setSingletonInstance(nativeLocator);

    note: create <LMD>
    NS_URANIUM_LINEAR_AIR_CLIENT::LocatorBinding::setSingletonInstance(
        clientFactory.createLinearMetadataLocator());

    note: get LMLL(locator) and pass up to client application. see factory below
    NS_URANIUM_LML_AIR_CLIENT::LocatorBinding::setSingletonInstance(
        clientFactory.createLocalMediaLibraryLocator());
  }
};


<2> How to get connected to 'iron'

$ cat ./Uranium.Client.System/data/iron-system-factory.plugin-config
libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)


NS_IRON_SYSTEM::SystemFactory& SystemClientFactory::getIronSystemFactory() 
{
    URANIUM_PROFILE_FUNC;
    const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find(
                "iron-system-factory.plugin-config"));
    return PluginFactory::getInstance<NS_IRON_SYSTEM::SystemFactory>(pluginConfig);
}

boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> SystemClientFactory::getIronSystemEventRepository()
{
    if(ironSystemEr == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::getIronSystemEventRepository()");

        // note: this is a call to DBUS client

        ironSystemEr = getIronSystemFactory().createEventRepository();
    }
    return ironSystemEr;
}


note: this getIronSystemEventRepository() is used in various places and one of them is:

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
createConcreteEventRepository() 
{
  if(eventRepository == 0)
  {
    // note: create ER via 'iron' factory. shared lib. is it proxy?
    boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemER(
            getIronSystemEventRepository());

    // ...
  }
}


<3> How to get connected to 'cobalt'

/Uranium.Client.System/data$ cat cobalt-system-factory.plugin-config 
libCobaltSystemDbusClient.so createDbusSystemFactory


NS_COBALT_SYSTEM::SystemFactory& SystemClientFactory::getCobaltSystemFactory() 
{
    const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find(
                "cobalt-system-factory.plugin-config"));
    
    return PluginFactory::getInstance<NS_COBALT_SYSTEM::SystemFactory>(pluginConfig);
}


boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> SystemClientFactory::getSystemMetadataBroker()
{
    if(systemMetadataBroker == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::getSystemMetadataBroker()");
        systemMetadataBroker = getCobaltSystemFactory().createMetadataBroker();
    }
    return systemMetadataBroker;
}


<4> SF is DBUS SF

unity.cpp. auto generated.

class ZINC_EXPORT DbusSystemFactory : public SystemFactory
{
    public: // from SystemFactory
        DbusSystemFactory(const char* args = NULL);

        virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> createMetadataBroker();
        virtual boost::shared_ptr<Zinc::Broker::HiddenServicesStore> createHiddenServicesStore();
        virtual boost::shared_ptr<Zinc::Broker::UnifiedServiceRepository> createUnifiedServiceRepository();
        virtual boost::shared_ptr<Zinc::Broker::ProvisioningService> createProvisioningService();
        virtual boost::shared_ptr<Zinc::Broker::UnifiedEventRepository> createUnifiedEventRepository();
        virtual boost::shared_ptr<Zinc::Broker::LinearAcquisitionServiceResolver> 
            createLinearAcquisitionServiceResolver();
        virtual boost::shared_ptr<Zinc::Broker::DeviceConfig> createDeviceConfig();

    private:
        NS_ZINC_DBUS_BINDING::DBusSystemFactoryImpl impl;

        // references to our proxy objects
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theMetadataBroker;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theHiddenServicesStore;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theUnifiedServiceRepository;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theProvisioningService;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theUnifiedEventRepository;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theLinearAcquisitionServiceResolver;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theDeviceConfig;
};

DbusSystemFactory::DbusSystemFactory(const char* args)
 : impl(DBus::BusType::SESSION, getBusName(args))
{
}

boost::shared_ptr<Zinc::Broker::MetadataBroker> DbusSystemFactory::createMetadataBroker()
{
    // 'interface'
    
    return NS_ZINC_DBUS_BINDING::applyInterface<Zinc::Broker::MetadataBroker>(
            impl.getOrCreateObject(theMetadataBroker, "/Zinc/Broker/MetadataBroker"));
}

static std::string getBusName(const char* overrideBusName)
{
    const char* busName = NULL;
    if (overrideBusName != NULL && overrideBusName[0] != '\0') {
        busName = overrideBusName;
    }
    if (busName == NULL) {
        busName = ::getenv(BUSNAME_ENV);
    }
    std::string theBusName;

    if(busName && strlen(busName) > 0) {
        theBusName = busName;
    } else {
        theBusName = "Zinc.Broker";          // note: see
    }
    return theBusName;
}

NS_ZINC::Plugin *createDbusSystemFactory(const char* args) {
    return new Zinc::Broker::DbusSystemFactory(args);
}



<apis>
Uranium.Client.API/include/metadata/Event.h
Uranium.Client.API/include/metadata/Summary.h
Uranium.Client.API/include/local-media-library/MediaRecord.h
Uranium.Client.API/include/linear-acquisition/Booking.h

struct ZINC_EXPORT MediaRecord : virtual public NS_ZINC::Polymorphic {
   virtual std::string getSynopsis() const = 0;
}

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic;

class ZINC_EXPORT Summary : virtual public NS_ZINC::Polymorphic;


{client-system}

Uranium.Client.System/src/SystemClientFactory.cpp

NS_URANIUM_CLIENT_OPEN

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
  private:
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> eventRepository;
    boost::weak_ptr<NS_URANIUM_LINEAR_CLIENT::SystemClientEventRepository> linearEventRepository;

  public:
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> createMetadataLocator();

    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
      createConcreteEventRepository();
    boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::Locator> createLinearMetadataLocator();


    // <factory-lml>
    boost::shared_ptr<NS_URANIUM_LML_CLIENT::Locator> createLocalMediaLibraryLocator();
    {
      using namespace NS_URANIUM_LML_CLIENT;

      if(!localMediaLibraryLocator)
      {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::createLocalMediaLibraryLocator()");
        localMediaLibraryLocator = boost::make_shared<SystemClientLocator>(createLocalMediaLibrary());
      }

      return localMediaLibraryLocator;
    }

    boost::shared_ptr<NS_URANIUM_LML_CLIENT::LocalMediaLibrary> createLocalMediaLibrary();
    {
        boost::mutex::scoped_lock lock(boost::mutex);

        if(localMediaLibrary == NULL) {
            URANIUM_PROFILE_SCOPE("SystemClientFactory::createLocalMediaLibrary()");

            // note: get cache
            boost::shared_ptr<NS_URANIUM_LML_CLIENT::MediaRecordCache> cache
                = getMediaRecordCache();

            // note: create SLML
            boost::shared_ptr<NS_URANIUM_LML_CLIENT::SystemLocalMediaLibrary> lml
                = boost::make_shared<NS_URANIUM_LML_CLIENT::SystemLocalMediaLibrary>(
                        getSystemLocalMediaLibrary(), getProvisioningService(), cache);

            boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
                createConcreteEventRepository() 
                {
                    concreteER->setDefaultDispatcher(getDefaultDispatcher())
                    {
                        dispatcher = dispatcher_;
                    }

                    concreteER->setFutureDispatcher(futureDispatcher);
                }


            lml->setDispatcher(getDefaultDispatcher());
            localMediaLibrary = lml;
            getSystemLocalMediaLibrary()->addListener(lml);
        }

        return(localMediaLibrary);
    }
};


struct ZINC_EXPORT Locator : public NS_ZINC::Polymorphic 

class SystemClientLocator : public Locator 
{
    SystemClientLocator(const boost::shared_ptr<LocalMediaLibrary> lml_);
};


{locators}
Each interface defines 'own' locator class chain and how it is possible? Use namespace.

NS_URANIUM_METADATA_CLIENT_OPEN

/**
 * This is the top-level entrypoint to the Zinc Client API.
 * A singleton instance will likely be exposed in the global
 * context within the Javascript environment. An Actionscript
 * binding will be newed in the Flash case.
 */
class ZINC_EXPORT Locator : public NS_ZINC::Polymorphic {

public:
    virtual ~Locator();
    virtual boost::shared_ptr<MetadataBroker> getMetadataBroker() const = 0;
    virtual boost::shared_ptr<EventRepository> getEventRepository() const = 0;
    virtual boost::shared_ptr<ServiceRepository> getServiceRepository() const = 0;
};

class SystemClientLocator : virtual public Locator {

  public:
    SystemClientLocator(boost::shared_ptr<MetadataBroker> metadataBroker, 
        boost::shared_ptr<EventRepository> er, boost::shared_ptr<ServiceRepository> sr);

    boost::shared_ptr<MetadataBroker> getMetadataBroker() const;
    virtual boost::shared_ptr<EventRepository> getEventRepository() const;
    virtual boost::shared_ptr<ServiceRepository> getServiceRepository() const;

  private:
    boost::shared_ptr<MetadataBroker> metadataBroker;
    boost::shared_ptr<EventRepository> eventRepository;
    boost::shared_ptr<ServiceRepository> serviceRepository;
};


={============================================================================
*kt_dev_uv_stack_107* stack: cal: component link creation

{creation-chain} for linear and metadata and creation chian. 

<MDL> MDCL   -> { MB, ER, SR }
<CMB>        SCMB(MB) -> { SMB(COBALT), C, MO }
                                        C -> { MDR, PC }
Binding:
<MDL> MDCL   -> { MB, ER, SR }

shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> nativeLocator(
    clientFactory.createMetadataLocator());

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{

  // 'linear'
  // LCL    -> { ER, RCR, RR }:
  //              |
  //              -> { ER(IRON), RR }
  //
  boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::Locator> createLinearMetadataLocator() 
  {
    using namespace NS_URANIUM_LINEAR_CLIENT;

    URANIUM_FUNC_DEBUG;

    boost::shared_ptr<Locator> loc(linearMetadataLocator.lock());

    if(loc == NULL)
    {
      linearMetadataLocator = loc =
        boost::make_shared<SystemClientLocator>(
            createLinearEventRepository(),
            createRelatedContentRepository(),
            createReminderRepository()
            );
    }
    return loc;
  }

  boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::EventRepository> createLinearEventRepository() 
  {
    using namespace NS_URANIUM_LINEAR_CLIENT;

    boost::shared_ptr<SystemClientEventRepository> eventRepository(linearEventRepository.lock());

    if(!eventRepository) {

      //create Event Repository
      boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemEventRepository(
          getIronSystemEventRepository());

      // note: from 'iron-system-factory.plugin-config
      //
      // libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)
      //
      // MetadataProxy      15 ../Cobalt/Cobalt.System.DBusServer/src/BusName.cpp char const * const
      // BusName::LINEAR_METADATA = "Zinc.MetadataProxy";
      //

      eventRepository = boost::make_shared<SystemClientEventRepository>(
          systemEventRepository,
          createReminderRepository()
          );

      systemEventRepository->addListener(eventRepository);
      eventRepository->setDispatcher(getDefaultDispatcher());
      eventRepository->setFutureDispatcher(futureDispatcher);
      linearEventRepository = eventRepository;
    }
    return eventRepository;
  }

  // note: 'metadata' see use of namespace to specify
  //
  // <MDL> MCL    -> { MB, ER, SR }
  //
  // <CMB>        SCMB(MB) -> { SMB(COBALT), C, MO }
  //
  //                                         C -> { MDR, PC }
  //
  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> createMetadataLocator() 
  {
    if(!metadataLocator)
    {
      metadataLocator = boost::make_shared<NS_URANIUM_METADATA_CLIENT::SystemClientLocator>(
          createMetadataBroker(),   <CMB> 
          createEventRepository(),  <CER>
          createServiceRepository());
    }
    return metadataLocator;
  }
};

Uranium/Uranium.Client.System/src/SystemClientFactory.cpp

<CMB> SCMB(MB) -> { SMB(COBALT), C, MO }
                                 C -> { MDR, PC }

// `Converter` is a helper class that is used to convert MetadataBroker
// `Result` and `ResultSet` to the required Client API types, depending on the
// specific Broker function that was called.

struct ZINC_LOCAL Converter
{
  explicit Converter(boost::shared_ptr<SystemClientMetadataConfig> config_,
      boost::weak_ptr<MetadataRepositories> repos_,
      boost::shared_ptr<ProvisioningCache> provisioningCache_)
    : config(config_),
    repos(repos_),
    provisioningCache(provisioningCache_)
  {}
};

// note: returns a copy

NS_URANIUM_METADATA_CLIENT::Converter SystemClientFactory::createConverter()
{
  URANIUM_PROFILE_FUNC;
  return NS_URANIUM_METADATA_CLIENT::Converter(
      createMetadataConfig(),
      createMetadataRepositories(),
      createProvisioningCache());
}

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataBroker> SystemClientFactory::createMetadataBroker() 
{
  URANIUM_FUNC_DEBUG;

  if(metadataBroker == 0)
  {
    // note: cobalt
    
    boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> systemMetadataBroker(getSystemMetadataBroker());

    using NS_URANIUM_METADATA_CLIENT::SystemClientMetadataBroker;

    <SCMB>
    boost::shared_ptr<SystemClientMetadataBroker> mb = 
      boost::make_shared<SystemClientMetadataBroker>( systemMetadataBroker,
          createConverter(),
          createMetadataObserver() );

    mb->setDispatcher(getDefaultDispatcher());
    mb->setFutureDispatcher(futureDispatcher);
    metadataBroker = mb;
  }

  return metadataBroker;
}


<CMB> <SCMB>

// note: SCMB        -> { RS(COBALT), , MR, }. repos is MR 

Uranium.Client.System/src/metadata/SystemClientMetadataBroker.cpp

class ZINC_EXPORT SystemClientMetadataBroker
    : virtual public MetadataBroker,
      virtual public NS_ZINC::DispatchingFutureProducer,
      public boost::enable_shared_from_this<SystemClientMetadataBroker>
{

  SystemClientMetadataBroker(
      boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker_,
      Converter convert_,
      boost::shared_ptr<MetadataObserver> metadataObserver_) :
    metadataBroker(metadataBroker_),
    convert(convert_),
    metadataObserver(metadataObserver_)
  {}

  // note: search
  // note: WHO'S CALLING THIS?  
  NS_ZINC::Future<boost::shared_ptr<SummaryResultSet>> search(const std::string& searchTerms,
      boost::shared_ptr<SearchOptions> searchOptions,
      size_t start,
      size_t size) const
  {
    shared_ptr<SystemClientSearchOptions> scSearchOptions
      = boost::dynamic_pointer_cast<SystemClientSearchOptions>(searchOptions);

    // note: <dbus-call-to-cobalt>
    return metadataBroker->search(searchTerms,
        getSysQopts(scSearchOptions),
        getSysGopts(scSearchOptions),
        scSearchOptions->getFilters(),
        start,
        size)
      .then(*getDispatcher(),
          bind(&SystemClientMetadataBroker::searchCallback,
            shared_from_this(),
            start,
            _1));
  }

  boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker;
  boost::shared_ptr<SystemClientMetadataConfig> config;
  Converter convert;
  boost::shared_ptr<MetadataObserver> metadataObserver;

  boost::weak_ptr<MetadataRepositories> repos;
};


<CER> SCER(ER) -> { MDO, SR, SER, SMB, CRR, CLA, EEIF, PEC, BSM }

note: ER is metadata ER

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::EventRepository> createEventRepository() 
  {
    return createConcreteEventRepository();
  }

  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
    createConcreteEventRepository() 
    {
      if(eventRepository == 0)
      {
        boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> systemMB = getSystemMetadataBroker();

        // note: create ER via 'iron' factory. shared lib. is it proxy?
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemER(getIronSystemEventRepository());

        boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> clientRR(createReminderRepository());
        boost::shared_ptr<NS_URANIUM_DVR_CLIENT::LinearAcquisition> clientLA(createLinearAcquisition());
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientMetadataConfig> 
          metadataconfig(createMetadataConfig());

        // note: <SCER>
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> concreteER(
            'new' NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository(
              metadataconfig,
              createMetadataObserver(), note: create MDO.
              serviceRepository,
              systemER,
              systemMB,
              clientRR,
              clientLA,
              createExtraEventInfoFacade(),
              createPresentEventsCache(),
              createBrokerStatusMonitor()
              )
            );

        concreteER->setDefaultDispatcher(getDefaultDispatcher());
        concreteER->setFutureDispatcher(futureDispatcher);
        eventRepository = concreteER;

        createMetadataObserver()->addListener(concreteER);
        serviceRepository->setEventRepository(concreteER);
      }

      return eventRepository;
    }
}

SystemClientEventRepository::SystemClientEventRepository(
        boost::shared_ptr<SystemClientMetadataConfig> config_,
        boost::shared_ptr<MetadataObserver> metadataObserver_,
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> serviceRepo_,
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemEventRepo_,
        boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker_,
        boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> reminderRepo_,
        boost::shared_ptr<NS_URANIUM_DVR_CLIENT::LinearAcquisition> linearAcquisition_,
        boost::shared_ptr<ExtraEventInfoFacade> extraInfo_,
        boost::shared_ptr<PresentEventsCache> peCache_,
        boost::shared_ptr<BrokerStatusMonitor> brokerMonitor_) :
           config(config_),
           metadataObserver(metadataObserver_),
           serviceRepo(serviceRepo_),
           systemEventRepo(systemEventRepo_),
           metadataBroker(metadataBroker_),
           reminderRepo(reminderRepo_),
           linearAcquisition(linearAcquisition_),
           extraInfo(extraInfo_),
           peCache(peCache_),
           brokerMonitor(brokerMonitor_)
    {
    }


<MO>
boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataObserver> <createMetadataObserver>()
{
  using namespace NS_URANIUM_METADATA_CLIENT;

  if(metadataObserver == 0)
  {
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataObserver> mo(
        MetadataObserver::create(
          createServiceCache(),
          createReminderRepository(),
          getIronSystemEventRepository(),
          createPresentEventsCache(),
          createProvisioningCache(),
          createMediaRecordCache(),
          createMetadataConfig(),
          createActionProcessor()
          )
        );

    // WARNING:
    // It is necessary to have an InlineDispatcher: see MetadataObserver::ServiceListChange.
    mo->setDispatcher(boost::make_shared<InlineDispatcher>());

    getIronSystemEventRepository()->addListener(mo);
    getSystemUnifiedServiceRepository()->addListener(mo);
    createReminderRepository()->addListener(mo);
    createLinearAcquisition()->addListener(mo);

    // note: set listener
    createLocalMediaLibrary()->addListener(mo);

    createMetadataConfig()->addListener(mo);
    getProvisioningService()->addListener(mo);

    // note: 'neon' so 
    ipnetwork = getNeonClientFactory().createIPNetwork();
    ipnetwork->addListener(mo);
    getHiddenServicesStore()->addListener(mo);

    //FIXME: 
    //the order here is not accidental - unfortunately there is a cyclic indirect dependency between 
    //service repo and metadata observer, and this is a way to stop infinite loops in the factory
    mo->addListener(createConcreteServiceRepository(false));
    createConcreteServiceRepository(false)->setMetadataObserver(mo);
    metadataObserver = mo;
  }

  return metadataObserver;
}

Uranium.Client.System/src/metadata/MetadataObserver.h

class ZINC_LOCAL MetadataObserver:
{
  std::vector<boost::weak_ptr<SystemClientEventRepository> > clientEventRepos;

  void MetadataObserver::addListener(boost::shared_ptr<SystemClientEventRepository> er_)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;
    boost::mutex::scoped_lock lock(listenerMutex);
    clientEventRepos.push_back(er_);
  }

  void MetadataObserver::notifyServicesChanged(const vector<string>& changedServiceLocators)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;

    //Service and event repository need to be notified in this order,
    //and before EventWindows. EventDispatchers give us no guarantee
    //about the order of notifications, so we need to ensure it ourselves here.
    boost::shared_ptr<ServiceCache> serviceCacheStrong = serviceCache.lock();

    if(serviceCacheStrong)
    {
      serviceCacheStrong->ServicesChanged(changedServiceLocators);
    }

    //notify and cleanup Service/Event repos.
    boost::mutex::scoped_lock lock(listenerMutex);

    notify<SystemClientServiceRepository>(clientServiceRepos, 
        boost::bind(&SystemClientServiceRepository::ServicesChanged, _1, changedServiceLocators)) ;

    notify<SystemClientEventRepository>(clientEventRepos, 
        boost::bind(&SystemClientEventRepository::ServicesChanged, _1, changedServiceLocators));
    lock.unlock();

    produceEvent(boost::bind(&MetadataChangeListener::ServicesChanged, _1, changedServiceLocators));
  }

  void MetadataObserver::ServiceChange(const std::string& serviceLocator)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;
    notifyServicesChanged(vector<std::string>(1, serviceLocator));

    //we don't need to reload present events cache, because spec 0011-S says that if RCNs change,
    //then the box should emit ServiceListChange anyway.
  } 
};


={============================================================================
*kt_dev_uv_stack_108* stack: cal: metadata: event structures and mapping

{iron-event-struct}
/zinc-build-root/debug-debian-7-x86_64/Iron/Iron.System.API/include/Event.h

namespace Zinc {
namespace Metadata {

struct Event
{
    Event();
    explicit Event( /* deleted */ );

    void swap(Event&);

    // Members:
    std::string serviceLocator;
    std::string eventLocator;
    uint32_t start;
    uint32_t publishedDuration;

    // note: all use 'lang' eg eng as a key in map<lang, string>
    //
    // extractValueFromMap(dttEvent.shortTitle, lang)
    // extractValueFromMap(dttEvent.mediumSynopsis, lang)
    //
    // sysEvent.mediumSynopsis["eng"] = "The latest national and international"
    //   "news stories from the BBC News team, followed by weather.";
    
    std::map< std::string, std::string > shortTitle;
    std::map< std::string, std::string > mediumSynopsis;
    std::map< std::string, std::string > longSynopsis;

    std::vector< std::string > classifier;
    std::string programmeCrid;
    std::string splitInstanceIdentifier;
    std::vector< std::string > seriesCrid;
    std::vector< std::string > recommendationCrid;
    std::vector< std::string > collectionCrid;
    VideoFormat::Enum videoFormat;
    AspectRatio::Enum aspectRatio;
    std::map< std::string, std::vector< AudioMixType::Enum > > audio;
    bool audioDescription;
    std::map< std::string, std::vector< SubtitlesFormat::Enum > > subtitles;
    bool signing;
    std::string guidanceCode;
    std::map< std::string, std::string > guidanceText;
    std::vector< std::string > iconURL;
    bool conditionalAccess;
    bool bookable;
    std::map< std::string, bool > alternativeEventLocator;
};

Iron/Iron.System.API/data/introspection-xml/struct-Event.xml

<yv:struct name="Zinc.Metadata.Event">

   <p>The Event structure members are as follows:</p>

   ...

   <yv:member type="a{ss}" name="shortTitle">
       <yv:docstring>
           <p>A title for the event taken from the <tt>short_event_descriptor()</tt> 
           <tt>event_name_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 “alpha-3” language code (the key) 
           to a title in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

   <yv:member type="a{ss}" name="mediumSynopsis">
       <yv:docstring>
           <p>A description for the event taken from the <tt>short_event_descriptor()</tt> 
           <tt>text_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 “alpha-3” language code (the key) 
           to a synopsis in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

   <yv:member type="a{ss}" name="longSynopsis">
       <yv:docstring>
           <p>A description for the event taken from the <tt>extended_event_descriptor()</tt> 
           <tt>text_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 “alpha-3” language code (the key) 
           to a synopsis in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

note: "a{ss}" is array of dictionary(string, string) and maps to
   std::map< std::string, std::string > shortTitle;


{cobalt-result}
/zinc-build-root/debug-debian-7-x86_64/Cobalt/Cobalt.System.API/include

/*
 * include/Result.h
 *
 * This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 * Template struct.h.template
 * Using /data/builds/_virtual_/pc/DEVARCH/Cobalt/Cobalt.System.API/data/introspection-xml/struct-Result.xml
 */
namespace Zinc {
namespace Broker {

struct Result
{
    Result();
    explicit Result( /* omitted */ );
    void swap(Result&);

    // Members:
    std::string recordIdentifier;
    int64_t lastModified;
    int64_t validUntil;
    DataSource::Enum dataSource;
    std::vector< std::string > classifiers;
    std::map< std::string, std::vector< std::string > > identifiers;
    std::map< std::string, std::vector< std::string > > internalReferences;

    // note: 
    // sysResult->description["mediumSynopsis"] = vector<string>(1, "The latest national and international"
    //   "news stories from the BBC News team, followed by weather.");

    std::map< std::string, std::vector< std::string > > description;

    std::map< std::string, std::vector< XmlNode > > nodes;
};

inline Result::Result() 
    : recordIdentifier(), lastModified(), validUntil(),
    dataSource(), classifiers(), identifiers(), internalReferences(),
    description(), nodes() { }

inline Result::Result(const std::string& recordIdentifier_, const int64_t
        lastModified_, const int64_t validUntil_, const DataSource::Enum
        dataSource_, const std::vector< std::string >& classifiers_, const
        std::map< std::string, std::vector< std::string > >& identifiers_,
        const std::map< std::string, std::vector< std::string > >&
        internalReferences_, const std::map< std::string, 
        std::vector<std::string > >& description_, 
        const std::map< std::string, std::vector< XmlNode > >& nodes_) 

    : recordIdentifier(recordIdentifier_), lastModified(lastModified_),
    validUntil(validUntil_), dataSource(dataSource_),
    classifiers(classifiers_), identifiers(identifiers_),
    internalReferences(internalReferences_), description(description_),
    nodes(nodes_) { }


Cobalt/Cobalt.System.API/data/introspection-xml/struct-Result.xml

<?xml version="1.0" encoding="UTF-8"?>
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0">
    <yv:struct name ="Zinc.Broker.Result">
        <yv:member type="s" name="recordIdentifier" />
        <yv:member type="x" name="lastModified" />
        <yv:member type="x" name="validUntil" />
        <yv:member type="i" yv:type="[DataSource]" name="dataSource" />
        <yv:member type="as" name="classifiers" />
        <yv:member type="a{sas}" name="identifiers" />
        <yv:member type="a{sas}" name="internalReferences" />
        <yv:member type="a{sas}" name="description" />
        <yv:member type="a{sa(a{ss}s)}" yv:type="a{sa[XmlNode]}" name="nodes" />
    </yv:struct>
</node>

note: "a{sas}" maps to
   std::map< std::string, std::vector< std::string > > description;


{translation}
Cobalt/Cobalt.System.Production/data/b2c_map.yaml

node_transformations: [
    # tag                action                 args....
    ['serviceId',       'AppendToDescription', 'owningServiceId'],

    ['summary',         'AppendToDescription', 'shortSynopsis'],
    ['description',     'AppendToDescription', 'mediumSynopsis'],
    ['longDescription', 'AppendToDescription', 'longSynopsis'],


Cobalt.System.Production/src/XMLProcessor.cpp
261-
262:struct AppendToDescription {
263-    typedef void result_type;
264:    AppendToDescription(const string& keyName_)
265-     : keyName(keyName_)
266-    {

https://jira.youview.co.uk/browse/DEVARCH-8960
XMLProcessor is responsible for parsing B2C XML responses into `Result` objects. It is used for
    parsing all results, but in particular it is used to parse schedule query results, which can be
    very large. For instance schedule "Tiles" retrieved for the purposes of P/F generation (for
            IP-channels) are >1MB. Since these are being periodically retrieved, and several such
    tiles will be required to cover all the IP-channels, parsing performance is critical.



{cobalt-resultset}
introspection-xml/struct-ResultSet.xml

	<yv:struct name ="Zinc.Broker.ResultSet">
	    <yv:member type="u" name="totalSize" />
        <yv:member type="a(sxxiasa{sas}a{ss}a{sas}a{sa(a{ss}s)})"
            yv:type="a[Result]"
            name="results"/>
	</yv:struct>


namespace Zinc { namespace Broker {

struct ResultSet
{
    ResultSet();
    explicit ResultSet(const uint32_t totalSize_, const std::vector< Result >& results_);
    void swap(ResultSet&);

    // Members:
    uint32_t totalSize;
    std::vector< Result > results;

};


{use}
vector<NS_IRON_SYSTEM::Event> getBBC1Events()
{
    NS_IRON_SYSTEM::Event e1;
    NS_IRON_SYSTEM::Event e2;

    e1.serviceLocator = "dvb://233a..1044";
    e1.eventLocator = "dvb://233a..1044;1";
    e1.shortTitle["eng"] = "Title of e1";          // see map<string, string>
    e1.start = 0;
    e1.publishedDuration = 100;

    e2.serviceLocator = "dvb://233a..1044";
    e2.eventLocator = "dvb://233a..1044;2";
    e2.shortTitle["eng"] = "Title of e2";
    e2.start = 200;
    e2.publishedDuration = 100;

    vector<NS_IRON_SYSTEM::Event> result;
    result.reserve(2);
    result.push_back(e1);
    result.push_back(e2);

    return result;
}


note: this test shows how to use 'cobalt::result' structure.

Uranium.Client.System/test/metadata/SummaryTest.cpp

SystemClientSummary make_sample_summary(const GuidanceInfo& gi = GuidanceInfo())
{
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult = boost::make_shared<NS_COBALT_SYSTEM::Result>();

    sysResult->description["entityType"] = vector<string>(1, "scheduleevent");
    sysResult->description["eventTitle"] = vector<string>(1, "Eastenders");
    sysResult->description["mediumSynopsis"] = vector<string>(1, "mediumSynopsis");
    sysResult->description["serviceLocator"] = vector<string>(1, "dvb://233a..1044");
    sysResult->description["owningServiceId"] = vector<string>(1, "1");

    if(gi.hasGuidanceCode)
    {
        sysResult->description["guidanceCodes"] = vector<string>(1, "15");
    }

    if(gi.hasGuidanceScheme)
    {
        sysResult->description["guidanceScheme"] = vector<string>(1, "BBCFC");
    }

    if(gi.hasGuidanceText)
    {
        sysResult->description["guidanceText"] = vector<string>(1, "Naughty programme.");
    }

    if(gi.hasGuidanceLongText)
    {
        sysResult->description["longGuidanceText"] = vector<string>(1, "Naughty programme. Watch alone.");
    }

    sysResult->identifiers[
        "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"]
        = vector<string>(1, "dvb://233a..1044;1");

    sysResult->identifiers[
        "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.programmeCRID"]
        = vector<string>(1, "crid://bbc.co.uk/someid");

    SystemClientSummary summary( sysResult,
            clientFactory->createMetadataConfig(),
            clientFactory->createMetadataRepositories(),
            // These tests do not rely on ProvisioningCache
            boost::shared_ptr<ProvisioningCache>(),
            3 );

    return summary;
}


note: WRT getSynopsis, it only uses in void testGetEventFromSummary() but don't see why is doing this.



={============================================================================
*kt_dev_uv_stack_109* stack: cal: metadata: api and dbus mapping.

    // note: <dbus-call-to-cobalt>
    return metadataBroker->search(searchTerms,
        getSysQopts(scSearchOptions),
        getSysGopts(scSearchOptions),
        scSearchOptions->getFilters(),
        start,
        size)
      .then(*getDispatcher(),
          bind(&SystemClientMetadataBroker::searchCallback,
            shared_from_this(),
            start,
            _1));

introspection-xml/interface-MetadataBroker.xml

        <method name="search">
            <yv:docstring>
                This method searches the on-demand catalogue using the B2C
                interface's Search Service, to return Programme Summaries,
                Series, Brands, Applications and/or Services. This method
                is also used for un-rolling Series and Brands within search
                user experiences.
            </yv:docstring>
            <arg type="s" name="queryString" direction="in">
                <yv:docstring>
                    The query string for the search.
                </yv:docstring>
            </arg>
            <arg type="(ii)" yv:type="[QueryOptions]" name="queryOptions" direction="in">
                <yv:docstring>
                    Options for the query including sorting of the results. 
                    See the QueryOptions structure definition for further 
                    details.
                </yv:docstring>
            </arg>
            <arg type="(iu)" yv:type="[GroupingOptions]" name="groupingOptions" direction="in">
                <yv:docstring>
                    Options controlling the grouping of results. See the 
                    GroupingOptions structure for more details.
                </yv:docstring>
            </arg>
            <arg type="a{sas}" name="filters" direction="in">
                <yv:docstring>
                    A set of filters to be applied to the query with the key
                    beging the filter name and the value being an array of 
                    values for the filter which will be applied using the OR
                    operator. The different filters are ANDed together in the
                    request URL.
                </yv:docstring>
            </arg>
            <arg type="i" name="startIndex" direction="in">
                <yv:docstring>
                    The start index of the result set requested, where 0 is 
                    the index of the first item in the result set.
                </yv:docstring>
            </arg>
            <arg type="u" name="size" direction="in">
                <yv:docstring>
                    The maximum size of the result set requested.
                </yv:docstring>
            </arg>
            <arg type="(ua(sxxiasa{sas}a{sas}a{sas}a{sa(a{ss}s)}))"
                yv:type="[ResultSet]" 
                name="searchResults" direction="out">                   // note: return
                <yv:docstring>
                    A SummaryResultSet structure which indicates the size of 
                    the total result set and contains an array of the 
                    summaries.
                </yv:docstring>
            </arg>
            <yv:possible-errors>
                <yv:error name="Zinc.Broker.Error.Misconfiguration">
                    <yv:docstring>
                        The box is not configured with endpoint addresses etc.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.InvalidRequest">
                    <yv:docstring>
                        If the querystring is empty.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.NetworkProblem">
                    <yv:docstring>
                        Network error.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.InvalidResponse">
                    <yv:docstring>
                        Invalid response from Metadata Aggregation System.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.InternalProblem">
                    <yv:docstring>
                        Internal problem in MetadataBroker or MAS.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.TransientServerProblem">
                    <yv:docstring>
                        Transient problem in MAS.
                    </yv:docstring>
                </yv:error>
            </yv:possible-errors>
            <yv:const />
        </method>

    // note: <dbus-call-to-cobalt>
    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
      metadataBroker->getEventSummariesByServices(recids, start, end);

        <method name="getEventSummariesByServices">
            <yv:docstring>
                Returns the schedule for a Service(s) based upon MAS Record 
                Identifiers for the Service(s) and the start and end times of 
                a given time window.
            </yv:docstring>
            <arg type="as" name="serviceRecordIds" direction="in">
                <yv:docstring>
                    MAS Record Identifier(s) of the Service(s) for which
                   the schedule is requested.  
                </yv:docstring>
            </arg>
            <arg type="x" name="startTime" direction="in">
                <yv:docstring>
                    The start of the time window for which a schedule is
                    requested.
                </yv:docstring>
            </arg>
            <arg type="x" name="endTime" direction="in">
                <yv:docstring>
                    The end of the time window for which a schedule is 
                    reequested.
                </yv:docstring>
            </arg>
            <arg type="a(sxxiasa{sas}a{sas}a{sas}a{sa(a{ss}s)})"
                yv:type="a[Result]"
                name="eventSummaries" direction="out">
                <yv:docstring>
                    Schedule Event Summaries of the Events in the requested 
                    schedule window. 
                </yv:docstring>
            </arg>
            <yv:possible-errors>
                <yv:error name="Zinc.Broker.Error.Misconfiguration">
                    <yv:docstring>
                        The box is not configured with endpoint addresses etc.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.InvalidRequest">
                    <yv:docstring>
                        No serviceRecordId sepcified, one (or more) of the 
                        specified serviceRecordId values is malformed, 
                        or the specified time window is out of bounds.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.NetworkProblem">
                    <yv:docstring>
                        Network error.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.InvalidResponse">
                    <yv:docstring>
                        Invalid response from Metadata Aggregation System.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.InternalProblem">
                    <yv:docstring>
                        Internal problem in MetadataBroker or MAS.
                    </yv:docstring>
                </yv:error>
                <yv:error name="Zinc.Broker.Error.TransientServerProblem">
                    <yv:docstring>
                        Transient problem in MAS.
                    </yv:docstring>
                </yv:error>
            </yv:possible-errors>
            <yv:const />
        </method>


={============================================================================
*kt_dev_uv_stack_110* stack: cal: metadata: event connection to application

{event-apis}

note: this comes from "build root"

Uranium.AIR.Client.API/asInterfaces/ctv/enhancedmetadata/Event.as

/**
 *  A class that represents the Event in the EPG.
 */ 
public interface Event {

    /**
     *  Returns the title of the Event in the currently selected language.
     */
    function getTitle():String;
    ...
};


The old API has:

getLongSynopsis():Object
getMediumSynopsis():Object

The new API has:

getSynopsis():String
Returns the synopsis of the Event if current data source provides it.

The both are defined in "Event".

   linear::Event                 metadata::Event

   SCE                           SCE

   SCER                          SCER

                                 SCER->getEventWindow() : EPG has SCER via SCF


{which-events}
<linear>
DEVARCH/Uranium/Uranium.Client.API/include/linear-metadata/Event.h 

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic 
{
  public:
    virtual boost::shared_ptr<synopsis> getMediumSynopsis() const = 0;
    virtual boost::shared_ptr<synopsis> getLongSynopsis() const = 0;
};


<metadata>
DEVARCH/Uranium/Uranium.Client.API/include/metadata/Event.h

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic 
{
  public:
    virtual std::string getSynopsis() const = 0;
};

class ZINC_LOCAL SystemClientEvent : virtual public Event
{
    std::string SystemClientEvent::getSynopsis() const
    {
        URANIUM_PROFILE_FUNC;
        return synopsis;
    }
};


Uranium.Client.System/src/metadata/SystemClientEvent.h
Uranium.Client.System/src/metadata/SystemClientEvent.cpp

Uranium.Client.System/src/linear-metadata/SystemClientEvent.h
Uranium.Client.System/src/linear-metadata/SystemClientEvent.cpp

This means Event is ABC and SCE is concrete class to have implementation. How to select an
appropriate class to use in client side? Uses 'namespace'

NS_URANIUM_LINEAR_CLIENT_OPEN
NS_URANIUM_METADATA_CLIENT_OPEN

note: Events differs in 'interfaces' and not like a simple structure. So how Events differs is not
to compare two in diff since it's up to SCE how to present via interface.


{linear-sce}

typedef std::map<std::string,std::string> synopsis;

boost::shared_ptr<NS_IRON_SYSTEM::Event> systemEvent;

SystemClientEvent::SystemClientEvent(NS_IRON_SYSTEM::Event event_,
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> eventRepository_,
        boost::shared_ptr<NS_CADMIUM_SYSTEM::LinearAcquisition> linearAcquisition_,
        boost::weak_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> reminderRepository_)
    : eventRepository(eventRepository_),
      reminderRepository(reminderRepository_),

      systemEvent(boost::make_shared<NS_IRON_SYSTEM::Event>(event_)),

      linearAcquisition(convertToSync(linearAcquisition_))
{

}

1. events->push_back(
        make_shared<SystemClientEvent>(
            sysEvents.at(i), eventRepository, linearAcquisition, reminderRepository));

2. return make_shared<SystemClientEvent>(
        systemEvent.get(), sysEventRepository, sysLinearAcquisition, reminderRepository);



{metadata-sce-overloads}

// <1> dtt event. from 'iron' <CSCE>
//
// used in DTT::getClientEvents().  run on a target: 'nothing' logged in the log
//
// note: fix: synopsis(extractValueFromMap(dttEvent.mediumSynopsis, lang)),

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
   const std::string& lang,
   const NS_IRON_SYSTEM::Event& dttEvent) :

   synopsis(extractValueFromMap(dttEvent.longSynopsis, lang))
{}



// <2> Constructs SystemClientEvent from Iron System Event and MAS event. 
//
// used in mergeEvent(). use <4> for mas and use <1> for dttEvent. uses dtt for some members and
// uses mas for some members. WRT Synopsis, uses DTT longSynopsis. So nothing logged in the log.
//
// note: if fix 1 and will be fixed as well.

SystemClientEvent::SystemClientEvent(shared_ptr<SystemClientEvent>& dttEvent,
        shared_ptr<SystemClientEvent>& masEvent):

   synopsis(dttEvent->getSynopsis()),
{
    // fill some from masEvent but not for synopsis.
}

// <3> Creates MAS event with a new broadcast time
//
// used in mergeEvent(). 
//
// note: if fix 4 and will be fixed as well.

SystemClientEvent::SystemClientEvent(shared_ptr<SystemClientEvent>& masEvent,
   const uint32_t start_,
   const uint32_t end_):

   synopsis(),
{}


// Creates MAS Event
// <4> used in IP::getClientEvents(). 'cobalt' and 'wrapper'
//
// run on a target: wrapper used but only 'medium' logged in the log. means that only medium from
// cobalt::result.
//
// note: fix: synopsis(masEvent.getSynopsis()),

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const SystemEventWrapper& masEvent) :

   synopsis(),
{
}

// Creates null event.
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos, 
    boost::shared_ptr<Service> service_, uint32_t start_, uint32_t end_):
    synopsis(),
{}


// <5> Creates a SystemClientEvent from FullEvent. This is used for linear search.
// used in Summary
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
            flags(0),
            isCachedFlag(false),
            id(locator),
            type(IP)
{
    const SystemClientFullEvent fullEvent = SystemClientFullEvent(sysResult);
    synopsis = fullEvent.getMediumSynopsis();
}

// note: do the same as 'wrapper' 
class SystemClientFullEvent : public FullEvent {
public:
    explicit SystemClientFullEvent(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
        scResult(sysResult),
        idBag(scResult)
    {}

    virtual std::string getMediumSynopsis() const
    {
       return scResult.getStringFromDescription("mediumSynopsis");
    }
};



{where-create-scs}
Calls to create SCE. 

<linear>
src/linear-metadata/SystemClientEventRepository.cpp

boost::shared_ptr<Event> makeEvent() 
{
  return make_shared<SystemClientEvent>(
      systemEvent.get(), sysEventRepository, sysLinearAcquisition, reminderRepository);
}

boost::shared_ptr<std::vector<boost::shared_ptr<Event> > > getPresentFollowing()
{
   eventsPtr->push_back(make_shared<SystemClientEvent>(
         *event, eventRepository, linearAcquisition, reminderRepository));
}


<merged>
270 Uranium.Client.System/src/metadata/EventCollectionOperations.cpp     

/**
 * Creates a null event a.k.a "no information available" event.
 * They basically are events which fill any gaps in schedule EventWindow may contain.
 */
boost::shared_ptr<SystemClientEvent> createNullEvent(boost::weak_ptr<MetadataRepositories> repos,
                                                     uint32_t service, uint32_t start, uint32_t end)
{
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> serviceRepo 
        = strongRepos->serviceRepo;

    //clog<<"Creating null event on service "<<service<<" time: ("<<start<<","<<end<<")"<<endl;
    
    return boost::make_shared<SystemClientEvent>(repos,
            serviceRepo->getServiceBySLI(service % serviceRepo->getServiceCount()), start, end);
}


={============================================================================
*kt_dev_uv_stack_111* stack: cal: metadata: how events get updated

<0> EPG 
EPG uses this:
Package ctv.enhancedmetadata, Interface public interface EventRepository::getEventWindow

// from textEPG
//
// boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
//    boost::make_shared<TextEPGEventWindowEventListener>();
// 
// boost::shared_ptr<EventWindow>  EPG::createEventWindow( boost::shared_ptr<EventRepository> eventRepo)
// {
//     Future<boost::shared_ptr<EventWindow> > f = 
//         eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());
// 
//     boost::shared_ptr<EventWindow> newWindow = f.get();
// 
//     newWindow->addListener(listener);
//     return newWindow;
// }

<1>
This scenario is to make a command to FD(future dispatcher) and to get response, events, back.

// @brief A private struct capturing all the necessary data about the request to create a new
// EventWindow

struct EventWindowCreateCommand : public MetadataChangeListener {

    EventWindowCreateCommand(
            NS_ZINC::Promise<boost::shared_ptr<EventWindow> > promise_,
            Bounds location_,
            Bounds requestedDataBounds_,
            event_collection_ptr oldEvents_,
            boost::posix_time::ptime dataRetrievalStartTime_,
            boost::weak_ptr<ServiceRepository> serviceRepo_):
                promise(promise_),
                location(location_),
                requestedDataBounds(requestedDataBounds_),
                oldEvents(oldEvents_),
                newMASEvents(boost::make_shared<event_collection>()),
                newDTTEvents(boost::make_shared<event_collection>()),
                newEvents(boost::make_shared<event_collection>()),
                newWindow(),
                serviceRepo(serviceRepo_),
                promiseCompleted(false),
                dataRetrievalStartTime(dataRetrievalStartTime_),
                masDataRequested(false),
                dttDataRequested(false),
                noDttDataFound(false),
                metadataChanged(false),
                isListeningToMetadataChanges(false)
    {
    }

    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > promise;

    //Events from old event window that intersect with the new one
    event_collection_ptr oldEvents;
    //Events for this event window that came from MAS
    event_collection_ptr newMASEvents;
    //Events for this event window that came from Iron
    event_collection_ptr newDTTEvents;

    //The window created as a result of this request
    boost::weak_ptr<SystemClientEventWindow> newWindow;
};

Future<boost::shared_ptr<EventWindow> > SystemClientEventRepository::getEventWindow(
        uint32_t startingServiceRow, uint32_t serviceCount,
        boost::posix_time::ptime startTime, int32_t seconds,
        event_collection_ptr intersectingEvents, Bounds missing,
        bool isMovingForward)
{
    // note: create Promise(FD)
    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > p(*getFutureDispatcher());

    // note: create a cmd and Promise is copied to cmd that has *SCEW, and promise
    EventWindowCreateCommand cmd( p, newWindowLocation, newWindowLocation,
            intersectingEvents, microsec_clock::universal_time(),
            serviceRepo);

    // create SCEW
    boost::shared_ptr<SystemClientEventWindow> ew = createEventWindow(cmd, newWindowEvents,
            hasStaleData);

    // note: this is to say that EW creation is done. so "promise" for EW creation.
    cmd.promise.complete(ew);
    cmd.promiseCompleted = true;

    getEventsFromSystemAPI(cmd);

    // return future to EPG
    return p.getFuture();
}


void SystemClientEventRepository::getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
{
  URANIUM_FUNC_TRACE;
  URANIUM_PROFILE_FUNC;
  Bounds& dataRetrievalBounds = cmd.requestedDataBounds;

  int64_t start = to_time_t(dataRetrievalBounds.startTime);
  int64_t end = to_time_t(dataRetrievalBounds.startTime) + dataRetrievalBounds.seconds;

  // note: create FB with FD

  NS_ZINC::FutureBarrier bar(*getFutureDispatcher());

  // eventsReceived is overloaded, we need to get the pointer to it first, and the pass to bind.
  
  // 'cobalt'
  void (SystemClientEventRepository::*masCallback)
    (boost::shared_ptr<EventWindowCreateCommand>,
     const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result > > &) =
    &SystemClientEventRepository::eventsReceived;

  // 'iron'
  void (SystemClientEventRepository::*dttCallback)
    (boost::shared_ptr<EventWindowCreateCommand>,
     const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > &) =
    &SystemClientEventRepository::eventsReceived;

  // 'cmd'. create 'window'
  //the two callbacks share the ownership of the command
  boost::shared_ptr<EventWindowCreateCommand> sharedCmd = boost::make_shared<EventWindowCreateCommand>(cmd);

  //make sure that if something changes about the metadata while we're retrieving it from system API,
  //we know about it and can react appropriately (e.g. marking the EventWindow about to be created as stale)
  metadataObserver->addListener(sharedCmd);

  // calls 'merge' events
  // 'eventWindowDataRetrievalComplete'
 
  bar.setCallback(boost::bind(
              &SystemClientEventRepository::eventWindowDataRetrievalComplete, shared_from_this(), sharedCmd));

  // 'request' data from System API:

  if(recids.empty() == false)
  {
    URANIUM_INFO("Requesting schedule metadata from MAS.");

    // note: <dbus-call-to-cobalt>
    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
      metadataBroker->getEventSummariesByServices(recids, start, end);
    
    // note: maps 'future' to masCallback 

    bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));
  }

  if(locators.empty() == false)
  {
    URANIUM_INFO("Requesting schedule metadata from DTT.");

    int64_t dttStart = adjustDTTWindowStart(config, start);

    Future <vector<NS_IRON_SYSTEM::Event>> fDTTEvents 
      = systemEventRepo->getScheduleEvents(locators, dttStart, end);

    // note: maps 'future' to masCallback 

    bar.addWithCallback(fDTTEvents, boost::bind(dttCallback, this, sharedCmd, _1));
  }
}


::FutureBar    <- from dbus and wait on future for calls?


<callback-one>
typedef std::vector<boost::shared_ptr<SystemClientEvent> > event_collection;
typedef boost::shared_ptr<event_collection> event_collection_ptr;

note: getClientEvents are overloads for IP or DTT

// old
//
// # IP version note:  getClientEvents from 'cobalt'
// 
// void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
//         const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
// {
//     const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();
// 
//     event_collection_ptr  clientEvents = getClientEvents(systemEvents);
// 
//     copy(clientEvents->begin(), clientEvents->end(), back_inserter(*command->newMASEvents));
// 
//     //
//     // <Q> HOW THIS newMASEvents get delivered to EPG?
//     //
// }
// 
// event_collection_ptr getClientEvents(const std::vector<NS_COBALT_SYSTEM::Result>& systemResults)
// {
//     BOOST_FOREACH(const NS_COBALT_SYSTEM::Result& sysResult, systemResults)
//     {
//         // 'wrapper'  note: wrapper is no longer used in the john's change.
//         // need to check!
//         
//         SystemEventWrapper ewrap(boost::make_shared<NS_COBALT_SYSTEM::Result>(sysResult));
// 
//         boost::shared_ptr<SystemClientEvent> mevent =
//             boost::make_shared<SystemClientEvent>(getRepos(), ewrap);
//         events->push_back(mevent);
//     }
// 
//     return events;
// }


// new: do not use wrapper

void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
        const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
{
    try
    {
        const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();

        // note: build vector<sp<sce>> from vector<result>

        event_collection_ptr  clientEvents = getClientEvents(systemEvents);

        // note: copy vector<sp> to vector<sp> in cmd object
        //
        // newMASEvents(boost::make_shared<event_collection>()),
        //
        // WHY? copy a vector to newMASEvents. CAN BE REMOVED?
        
        copy(clientEvents->begin(), clientEvents->end(), back_inserter(*command->newMASEvents));

        URANIUM_DEBUG("Got "<<clientEvents->size() <<" events from MAS.");

        //if there was no dtt request, continue with creation of the window
        if(command->promiseCompleted == false)
        {
            if((command->dttDataRequested == false) || (command->noDttDataFound == true))
            {
            	URANIUM_DEBUG("Creating window from IP data.");
                clog<<"Creating window from IP data."<<endl;

                event_collection_ptr events = prepareEventsForNewEventWindow(*command, command->newMASEvents);

                // note: signals "done"
                
                command->promise.complete(createEventWindow(*command, events));
                command->promiseCompleted = true;
            }
        }
    }
}


event_collection_ptr SystemClientEventRepository::prepareEventsForNewEventWindow(
        EventWindowCreateCommand& command,
        event_collection_ptr newEvents)
{
    // note: copy ctor sp vector again.

    event_collection_ptr events = boost::make_shared<event_collection>();
    //add in the newly fetched events.
    events->insert(events->end(), newEvents->begin(), newEvents->end());

    //add to events whatever we have in cache.
    event_collection_ptr cachedEvents = getEventCache()->get(command.location, true).events;
    setCached(cachedEvents);
    events = uniqueJoin(events, cachedEvents);

    //Add any events we might have from the old window.
    if(command.oldEvents != 0)
    {
        setCached(command.oldEvents);
        events = uniqueJoin(events, command.oldEvents);
    }

    //We might have requested more data than necessary. These events should go into cache, but not into
    //any window we might be creating now. Filter these events out for now.
    //Sanitisation to make sure errors in schedule don't cause us pain.

    events = sanitizeEvents(events, command.location, getRepos());
    //insert null events to cover any gaps in the event window
    insertNullEvents(command.location, events, getRepos(), config);

    return events;
}

event_collection_ptr SystemClientEventRepository::getClientEvents(
            const std::vector<NS_COBALT_SYSTEM::Result>& systemResults)
{
    URANIUM_PROFILE_FUNC;
    event_collection_ptr events = boost::make_shared<event_collection>();

    events->reserve(systemResults.size());

    BOOST_FOREACH(const NS_COBALT_SYSTEM::Result& sysResult, systemResults)
    {
        boost::shared_ptr<SystemClientEvent> mevent =
            boost::make_shared<SystemClientEvent>(getRepos(), sysResult);

        events->push_back(mevent);
    }
    return events;
}


# DTT version note:  getClientEvents from 'iron'
#
void eventsReceived(
   boost::shared_ptr<EventWindowCreateCommand> command,
   const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > & eventsFV)
{
   event_collection_ptr clientEvents = getClientEvents(systemEvents);
}  

event_collection_ptr getClientEvents(
            const std::vector<NS_IRON_SYSTEM::Event> & events) 
{
    BOOST_FOREACH(const NS_IRON_SYSTEM::Event& event, events)

    boost::shared_ptr<SystemClientEvent> scEvent = make_client_event(event);
}


// src/metadata/SystemClientEventRepository.cpp

boost::shared_ptr<SystemClientEvent> make_client_event(const NS_IRON_SYSTEM::Event& e)
{
  if(!e.eventLocator.empty())
  {
    // note: uses <1> and see above. <CSCE>
    return boost::shared_ptr<SystemClientEvent>( 
        new SystemClientEvent(getRepos(), config->getLanguage(), e));
  }

  return boost::shared_ptr<SystemClientEvent>();
}


<callback-two> 'merge' events

// called from getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
//
void SystemClientEventRepository::eventWindowDataRetrievalComplete(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    event_collection_ptr events =  mergeEvents(command->newDTTEvents, command->newMASEvents);

    notifyExistingWindowAboutNewData(command);
}


/**
 * Merges two sets of events coming from different data sources
 */
event_collection_ptr mergeEvents(event_collection_ptr dttEvents, event_collection_ptr masEvents)
{

    BOOST_FOREACH(boost::shared_ptr<SystemClientEvent>& edtt, *dttEvents)

    event_collection::iterator eip = // SCE in masEvents

    // 102 <2>
    //there is one, merge the properties
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(edtt, *eip));

    // note: eip is SCE here !!!

    BOOST_FOREACH(boost::share d_ptr<SystemClientEvent>& eip, *masEvents)

    boost::shared_ptr<SystemClientEvent> firstDTTEvent = *firstDTTEventIter;
    boost::shared_ptr<SystemClientEvent> lastDTTEvent = *lastDTTEventIter;

    // 189 <3>
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(eip, eip->getStartAsTimeT(), firstDTTEvent->getStartAsTimeT()));

    // 202
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(eip, lastDTTEvent->getEndAsTimeT(), eip->getEndAsTimeT()));
}


<notify-to-epg>

class ZINC_EXPORT EventListener : virtual public Polymorphic 

class ZINC_EXPORT `EventWindowEventListener` : public NS_ZINC::EventListener
{
    /**
     * Indicates the Event Window has changed substantially. To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged() = 0;

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void EventsChanged(const std::vector<boost::shared_ptr<Event> > events) = 0;
};

// note: from textEPG

class TextEPGEventWindowEventListener : public EventWindowEventListener
{
public:

    /**
     * Indicates the Event Window has changed substantially. To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged()
    {
    	printDebug("EventWindowChanged.");
        actionProcessor->post(boost::bind(&doRefreshWindowAndPrintStats));
    }

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void EventsChanged(
            const std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> >  events)
    {
        string s = "EventsChanged: ";
        BOOST_FOREACH(boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e, events)
        {
            s += e->getTitle() + string("(") +
                    boost::lexical_cast<string>(e->getContainingServiceListIndex()) + string("), ");
        }
        printDebug(s);
        sleep(3);
        actionProcessor->post(doRefreshWindowAndPrintStats);
    }
};


boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
   boost::make_shared<TextEPGEventWindowEventListener>();


boost::shared_ptr<EventWindow>  EPG::createEventWindow(
        boost::shared_ptr<EventRepository> eventRepo)
{
    Future<boost::shared_ptr<EventWindow> > f = 
        eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());

    boost::shared_ptr<EventWindow> newWindow = f.get();

    // note: mean that got window from future?
    
    newWindow->addListener(listener);

    return newWindow;
}


template<class ListenerT>
class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer<ListenerT> 
{
    virtual void addListener(boost::shared_ptr<ListenerT> listener) {
        // Hoisting note: we cast to void* here, and cast back down in
        // DowncastingCaller so everything is lovely and symmetrical
        impl.addListener(listener);
    }
};

typedef void hoisted_event_listener;

// from class definition

void addListener(boost::shared_ptr<hoisted_event_listener> listener, 
        boost::shared_ptr<EventDispatcher> clientDispatcher=boost::shared_ptr<EventDispatcher>());

// /Zinc/Zinc.Common/src/DispatchingEventProducer.cpp

void DispatchingEventProducerHoisted::addListener(
   boost::shared_ptr<hoisted_event_listener> listener, boost::shared_ptr<EventDispatcher> clientDispatcher) 
{

    if (!listener) {
        throw std::invalid_argument("NULL listener provided in call to addListener()!");
    }

    ZINC_COMMON_DEBUG(std::string(__func__)+" Dispatcher: "
            +boost::lexical_cast<std::string>(static_cast<const EventDispatcher*>(clientDispatcher.get()))+
            ", Producer: "+boost::lexical_cast<std::string>(this)+
            ", Listener: "+boost::lexical_cast<std::string>(listener.get())
            );

    bool duplicate = false;

    boost::mutex::scoped_lock lock(mutex);

    if (!clientDispatcher) {
        if (!dispatcher) {
            throw std::logic_error("addListener() called, but event producer has no dispatcher set.");
        }
        clientDispatcher = dispatcher;
    }

    // Call entry->second->onWorkAdded()
    Dispatcher::work work(*clientDispatcher);

    // note: make one which is a pair
    
    listener_entry newEntry(listener, clientDispatcher);

    BOOST_FOREACH(const listener_entry& entry, listeners) {

        if (entry.first == newEntry.first) {
            duplicate = true;
            break;
        }
    }

    if (!duplicate) {
        work.release();

        // note: push one
        
        listeners.push_front(newEntry);
    }
}


void SystemClientEventRepository::notifyExistingWindowAboutNewData(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    boost::shared_ptr<SystemClientEventWindow> w = command->newWindow.lock();

    if (w && (cacheGetResult.isStale() == false || w->isCreatedFromStaleData() == false))
    {
        URANIUM_DEBUG("Sending update to the existing window.");
        w->ConfigChanged();
    }
}

void SystemClientEventWindow::ConfigChanged()
{
    isStale = true;
    std::clog<<"EventWindow: Config changed"<<std::endl;
    notifyWindowChanged();
}


// void SystemClientEventWindow::notifyWindowChanged()
// {
// 
//     // ?? 
//     // void SystemClientEventWindow::EventsChanged
//     // (const std::vector<std::string> &eventIdentifiers)
//     
//     produceEvent(bind(&EventWindowEventListener::EventWindowChanged, _1));
// }

void SystemClientEventWindow::notifyEventsChanged(
        std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> > events)
{
    produceEvent(bind(&EventWindowEventListener::EventsChanged, _1, events));
}


<DEPH> Zinc/Zinc.Common/src/DispatchingEventProducer.cpp

typedef std::pair<boost::weak_ptr<hoisted_event_listener>, boost::shared_ptr<EventDispatcher> > 
   listener_entry;

class ZINC_EXPORT DispatchingEventProducerHoisted : boost::noncopyable 
{
    DispatchingEventProducerHoisted(boost::shared_ptr<EventDispatcher> dispatcher_) :
        dispatcher(dispatcher_) { }

    // note: event is 'functor'
    
    void produceEvent(boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event) 
    {
        boost::mutex::scoped_lock lock(mutex);

        size_t len = listeners.size();

        // note: copy listeners to localListeners

        // We copy listeners to this stack allocated array before dispatch so we
        // don't have to hold the lock while calling user code.
        listener_entry localListeners[len];
        listener_entry* next = localListeners;

        std::list<listener_entry>::iterator i = listeners.begin();

        std::list<listener_entry> forRemoval;
        while (i != listeners.end()) {

            if (!i->first.expired()) {
                *next++ = *i;
                ++i;
            } else {
                // Listener or dispatcher instance may have been destroyed since it was registered.
                // Detect this, and remove from collection.
                // Avoid calling dispatcher destructors while the mutex is locked.
                forRemoval.splice(forRemoval.end(), listeners, i++);
                len--;
            }
        }

        // Don't hold locks while running user code:
        lock.unlock();

        BOOST_FOREACH(listener_entry& l, forRemoval) {

            // note: DISPATCH. <Q> How this maps to 'dispatcher' which is DD.
            
            // Call entry->second->onWorkRemoved()
            Dispatcher::work(*l.second, boost::adopt_lock_t());
        }
        forRemoval.clear();

        for (size_t i = 0; i < len; ++i) {

            localListeners[i].second->post(
                    makeWeakFunctor(event, localListeners[i].first));
        }
    }

    private:
    /**
     * This is the default dispatcher. Clients can provide their own in addListener().
     */
    boost::shared_ptr<EventDispatcher> dispatcher;

    // note: 'mutable' ?
    mutable boost::mutex mutex;
};


/**
 * Make a WeakFunctor given a functor and a weak_ptr.
 */
template <typename Functor, typename T>
inline WeakFunctor<Functor, T>
makeWeakFunctor(Functor f, boost::weak_ptr<T> object)
{
    return WeakFunctor<Functor, T>(f, object);
}


//
// produceEvent(f)		
//    -> dispatch thread calls 
//       f( <boost::weak_ptr<hoisted_event_listener> ); // event(pair.second);
//    
//       this expands to due to bind()
//
//       -> EventWindowEventListener::EventsChanged( <boost::weak_ptr<hoisted_event_listener> );
//


void SystemClientEventWindow::EventsChanged(const std::vector<std::string> &eventIdentifiers)
{
    URANIUM_FUNC_TRACE;
    if(!isZombie)
    {
        std::vector<boost::shared_ptr<Event> > eventsInThisWindow;
        eventsInThisWindow.reserve(events.size());

        BOOST_FOREACH(const std::string& identifier, eventIdentifiers)
        {
            vector<boost::shared_ptr<Event> > events = this->findEventsByIdentifier(identifier);
            eventsInThisWindow.insert(eventsInThisWindow.end(), events.begin(), events.end());
        }

        URANIUM_DEBUG("Number of events changed in this window: "<<eventsInThisWindow.size());

        if(!eventsInThisWindow.empty())
        {
            notifyEventsChanged(eventsInThisWindow);
        }
    }
    else
    {
        URANIUM_INFO("Ignoring events change signal - this window requires refresh anyway.");
    }
}


={============================================================================
*kt_dev_uv_stack_112* stack: cal: metadata: event data flow

/Uranium/Uranium.Client.System/src/metadata/SystemEventWrapper.h

NS_URANIUM_METADATA_CLIENT_OPEN

class SystemEventWrapper  {
public:

    // note: "::cobalt::system"
    
    explicit SystemEventWrapper(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
        scResult(sysResult),
        idBag(scResult)
    {}

    std::string getOwningServiceId() const
    {
        return scResult.getStringFromDescription("owningServiceId");    // note: key
    }

    ...

    SystemClientResult scResult;
    IdentifierBag idBag;
};


class SystemClientResult
{
    // note: this is SP
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;

    explicit SystemClientResult(
            boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
        :sysResult(sysResult)
    {}

    std::string getFirstValueFromDescription(const std::string& key, bool toLower = true) const;

    public:

    string SystemClientResult::getStringFromDescription(const std::string& key) const
    {
        return getFirstValueFromDescription(key, false);
    }

    // note: key
    string SystemClientResult::getFirstValueFromDescription(const std::string& key,
            bool toLower) const
    {
        map<string, vector<string> >::const_iterator iter;

        if((iter = sysResult->description.find(key)) == sysResult->description.end())
        {
            return string();
        }
        vector<string> values = iter->second;
        if(values.size() == 0)
        {
            return string();
        }
        string s = values[0];
        if(toLower)
        {
            s = boost::to_lower_copy(s);
        }
        return s;
    }

    private:
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;
};


{from-cobalt}

// this is old

1. get a 'reference' to "Result" array from "Future". NO COPY. 

std::vector<NS_COBALT_SYSTEM::Result>

2. copy ctor "Result" from future Result. note: COPY COST

3. populate SEWs with SP to ctored 'each' "Result" and construct vector< SP< SCE >> 

SystemEventWrapper ewrap(boost::make_shared<NS_COBALT_SYSTEM::Result>(sysResult));

boost::shared_ptr<SystemClientEvent> mevent =
   boost::make_shared<SystemClientEvent>(getRepos(), ewrap);


// this is new   

1. get a 'reference' to array<cobalt::Result> from "Future". NO COPY. 

std::vector<NS_COBALT_SYSTEM::Result>

2. construct SCE for each result in the arrary. SCE uses &Result. NO copy.

3. push SP<SCE> into vector< SP< SCE >> 

 Future                    NO COPY via ref      SCER                    CMD
 -----------------------------------------------------------------------------------------
 vector<cobalt::result>       -->               vector<SP<SCE>>         <vector<SP<SCE>> 
 [0]
 [1]
 ...

 Q. Why copy a vector to a vector in window cmd?


{from-iron}

1. get a 'reference' to "Event" array from "Future". NO COPY. 

std::vector<NS_IRON_SYSTEM::Event>

2. populate SCE with SP to ctored "Result" and construct vector< SP< SCE >> 

boost::shared_ptr<SystemClientEvent>( 
        new SystemClientEvent(getRepos(), config->getLanguage(), e));


={============================================================================
*kt_dev_uv_stack_113* stack: cal: metadata: summary data flow

1. From EPG?

  NS_ZINC::Future<boost::shared_ptr<SummaryResultSet>> search(const std::string& searchTerms,
      boost::shared_ptr<SearchOptions> searchOptions,
      size_t start,
      size_t size) const
  {
    shared_ptr<SystemClientSearchOptions> scSearchOptions
      = boost::dynamic_pointer_cast<SystemClientSearchOptions>(searchOptions);

    // note: <dbus-call-to-cobalt>
    return metadataBroker->search(searchTerms,
        getSysQopts(scSearchOptions),
        getSysGopts(scSearchOptions),
        scSearchOptions->getFilters(),
        start,
        size)
      .then(*getDispatcher(),
          bind(&SystemClientMetadataBroker::searchCallback,
            shared_from_this(),
            start,
            _1));
  }


2-7.

result set     client type                   system type on dbus
---------      ------------------------      -------------------------------
[SRS].SP    -> vector< SP<SCS> >             
                  [ SCS ].SP  -> class Result object      <- copied from struct Result[i]
                  [ SCS ].SP  -> class Result object
                  ...


2. Callback from cobalt. Get "ResultSet"

boost::shared_ptr<SummaryResultSet>
SystemClientMetadataBroker::searchCallback(uint32_t requestedStartIndex,
    const NS_ZINC::FutureValue<NS_COBALT_SYSTEM::ResultSet>& fvSystem) const
{
    translateAndThrowCobaltSystemExceptions(fvSystem.getError());

    // note: COPY CTOR. copies all from future and once copied, destoried in this function.
    // sysval.results :  std::vector< Result > results;
    //
    // <Q> is there also a copy in 'future'?
    
    NS_COBALT_SYSTEM::ResultSet sysval = fvSystem.get();

    boost::shared_ptr<SystemClientSummaryResultSet> srs =
        convert(sysval, boost::shared_ptr<SystemClientSummaryResultSet>(), requestedStartIndex);

    metadataObserver->addListener(srs);
    srs->setDispatcher(getDispatcher());

    return boost::static_pointer_cast<SummaryResultSet>(srs);
}


3. call Convert. ResultSet -> SummaryResultSet

boost::shared_ptr<SystemClientSummaryResultSet>
Converter::operator()(const NS_COBALT_SYSTEM::ResultSet& rs,
        boost::shared_ptr<SystemClientSummaryResultSet>, uint32_t requestedStartIndex) const
{
    return boost::make_shared<SystemClientSummaryResultSet>(
            boost::make_shared<NS_COBALT_SYSTEM::ResultSet>(rs), config, repos, 
            provisioningCache, requestedStartIndex);
}


4. SystemClientSummaryResultSet

Uranium.Client.System/src/metadata/SystemClientSummaryResultSet.cpp

this is 'only' place to use SCS and the the set is a vector of SCS. See <CMB>

typedef boost::shared_ptr<Summary> SummaryPtr;

class SystemClientSummaryResultSet : public SummaryResultSet, public MetadataChangeListener
{
    boost::shared_ptr<std::vector<SummaryPtr> > summaries;

    SystemClientSummaryResultSet( 
            boost::shared_ptr<NS_COBALT_SYSTEM::ResultSet> sysResultSet,
            boost::shared_ptr<SystemClientMetadataConfig> config,
            boost::weak_ptr<MetadataRepositories> repos,
            boost::shared_ptr<ProvisioningCache> provisioningCache_,
            uint32_t startIndex )

        : provisioningCache(provisioningCache_),
        summaries(

                getClientSummaries(sysResultSet->results, config, repos, startIndex)),

        totalMASResultSetSize(sysResultSet->totalSize)
        {
        }
};


5. SummaryClientSummary

class ZINC_EXPORT Summary : virtual public NS_ZINC::Polymorphic

class SystemClientSummary : public Summary
{
  public:
    SystemClientSummary(
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult,
        boost::shared_ptr<SystemClientMetadataConfig> config,
        boost::weak_ptr<MetadataRepositories> repos_,
        boost::shared_ptr<ProvisioningCache> provisioningCache_,
        uint32_t absoluteIndex_);

    :sysResult(sysResult), config(config), repos(repos_)
    {}

    virtual boost::shared_ptr<Event> getEvent()
    {
      if(entityType != ENTITY_SCHEDULE_EVENT)
      {
        throw EntityNotPresentException("Incorrect entity type. Expected " +
            boost::lexical_cast<string>(ENTITY_SCHEDULE_EVENT) + ", got " +
            boost::lexical_cast<string>(entityType));
      }

      // note: uses <3> to create SCS and see above. metedata-overload
      
      return boost::make_shared<SystemClientEvent>(repos, sysResult);
    }

  private:
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;
    boost::weak_ptr<MetadataRepositories> repos;
};


6. vector< SP<SCS> > 

typedef std::vector<boost::shared_ptr<Summary> > summary_ptr_vector;

boost::shared_ptr<SystemClientSummaryResultSet::summary_ptr_vector>
    SystemClientSummaryResultSet::getClientSummaries( const std::vector< Result >& systemResults,
                                                      boost::shared_ptr<SystemClientMetadataConfig> config,
                                                      boost::weak_ptr<MetadataRepositories> repos,
                                                      uint32_t startIndex)
{
  shared_ptr<summary_ptr_vector> clientSummaries = make_shared<summary_ptr_vector>();

  clientSummaries->reserve(systemResults.size());

  for( size_t i = 0; i < systemResults.size(); ++i)
  {
    clientSummaries->push_back(
        make_shared_summary( systemResults[i], config, repos, provisioningCache, i + startIndex) );
  }
  return clientSummaries;
}


7. Result -> SCS

shared_ptr<SystemClientSummary> make_shared_summary( const Result& sysResult,
    boost::shared_ptr<SystemClientMetadataConfig> config,
    boost::weak_ptr<MetadataRepositories> repos,
    boost::shared_ptr<ProvisioningCache> provisioningCache,
    uint32_t index )
{
    // note: COPY SCS from vector<Result> results[i] since class Result don't define copy ctor.
    //
    // create SP{SCS} -> Result
    
    shared_ptr<Result> sysResultPtr = make_shared<Result>(sysResult);
    return make_shared<SystemClientSummary>(sysResultPtr, config, repos, provisioningCache, index);
}


<populate-to-others>
SCS has interfaces to make other class from "result" that SP points to. All class has
"SystemClientResult" member which has a SP to "result" and this SP is set to SP from SCS.


[ SCS ].SP        -> class Result object

[ Wrappers ].SP   -> the same "Result" object

class SystemClientBrand : public Brand 
{
    explicit SystemClientBrand(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
        :scResult(sysResult)
    {}

    private:
    SystemClientResult scResult;    note: has SP which is set to the arg SP.
};

   -> return boost::make_shared<SystemClientApplication>(sysResult);
   -> return boost::make_shared<SystemClientEvent>(repos, sysResult);
   -> return boost::make_shared<SystemClientProgrammeSummary>(sysResult);
   -> return boost::make_shared<SystemClientSeries>(sysResult);
   -> return boost::make_shared<SystemClientBrand>(sysResult);


<test>
Uranium.Client.System/test/metadata/SummaryTest.cpp

class ZINC_LOCAL SummaryTest :  NS_ZINC::IntegrationTestSandbox, public DefaultMetadataMocksEnvironment
{
  void testGetEventFromSummary()
  {
    SystemClientSummary summary( sysResult,
        clientFactory->createMetadataConfig(),
        clientFactory->createMetadataRepositories(),     note: this is repo(event)
        // These tests do not rely on ProvisioningCache
        boost::shared_ptr<ProvisioningCache>(),
        3 );

    CPPUNIT_ASSERT(summary.getEvent());
    CPPUNIT_ASSERT_EQUAL(string("Eastenders"), summary.getEvent()->getTitle());

   note: MEDIUM SYNOPSIS

   CPPUNIT_ASSERT_EQUAL(string("mediumSynopsis"), summary.getEvent()->getSynopsis());
   CPPUNIT_ASSERT(summary.getEvent()->getService());
  }
}


={============================================================================
*kt_dev_uv_stack_114* stack: cal: metadata: wrapper and convert flow

1. From EPG?

NS_ZINC::Future<ProgrammePtr>
SystemClientMetadataBroker::getProgramme(
        const string& recId) const
{
    return metadataBroker->getProgramme(recId)
        .then(*getDispatcher(),
              bind(
                  &commonCallback< ProgrammePtr, NS_COBALT_SYSTEM::Result>, 
                  shared_from_this(), convert, _1));
}

template<typename ClientType, typename SysType>
ClientType commonCallback(
        const boost::shared_ptr<const SystemClientMetadataBroker>& broker,
        const Converter& convert,
        const NS_ZINC::FutureValue<SysType>& fvSystem)
{
    translateAndThrowCobaltSystemExceptions(fvSystem.getError());
    return convert(fvSystem.get(), ClientType());
}


2. COPY CTOR from "fvSystem.get()" to "SP<Result>". Client API wrapper

ProgrammePtr
Converter::operator()(const NS_COBALT_SYSTEM::Result& result,
        ProgrammePtr) const
{
    return boost::make_shared<SystemClientProgramme>(
            boost::make_shared<NS_COBALT_SYSTEM::Result>(result)
            );
}


={============================================================================
*kt_dev_uv_stack_200* stack: nickel: 

Media Playback    Zinc.Media 


={============================================================================
*kt_dev_uv_stack_200* stack: nickel: dbus command

dbus-send --session --print-reply --type=method_call --dest='Zinc.Media' /Zinc/Media/DefaultMediaRouter Zinc.Media.MediaRouter.stop


={============================================================================
*kt_dev_uv_stack_201* stack: nickel: IP

1. IP Channel MediaRouter Device Manufacturer Integration
https://wiki.youview.co.uk/display/IPCHAN/IP+Channel+MediaRouter+Device+Manufacturer+Integration?src=search

o LinearSource component (linearsourced) via a DBus interface 

o streaming sockets interface (zmp).


{roles}

1. YouView Responsibilities

o Providing MPEG-TS stream to Device Manufacturer through zmp


2. Device Manufacturer Responsibilities

o Reading live MPEG-TS stream from zmp


{zmpsink}

gst_zmp_pad_chain(GstPad *pad, GstObject *parent, GstBuffer *buffer)
{
   bytes_written = send_with_fd(zmp->serialized_event_fd.fd, msg, iovlen, fds[0]);
}

{zmp}

# client.cpp
https://wiki.youview.co.uk/display/IPCHAN/example+client.cpp?src=search

# zmp.h
https://wiki.youview.co.uk/display/IPCHAN/zmp.h?src=contextnavchildmode

zmp (Zinc Media Protocol) - a sockets and pipes protocol for streaming data
based upon Gstreamer pipeline concepts.

Modelled on the Gstreamer concept of a media pipeline where data flows
downstream and control and information events can be sent upstream or
downstream or downstream serialized with the data.

Implemented in terms of UNIX sockets, pipes and file descriptor passing

Used for providing the data stream, information about it and some control such
as seeking.

libzmp is provided to make it easy to integrate with Device Manufacturer code.
It is written in C to make it easier to preserve binary compatibility. It is
designed so it will work without requiring any additional threads in Device
Manufacturer implementations.


gst_bin_get_by_name  125 Nickel/Nickel.LinearSource/src/LinearSourceControlImpl.cpp     if (GstElement *const e = gst_bin_get_by_name(GST_BIN(pipeline), name))
gst_bin_get_by_name  538 Nickel/Nickel.LinearSource/src/LinearSourceControlImpl.cpp             if (GstElement *const elem = gst_bin_get_by_name(GST_BIN(pipelineElem), "vqesrc"))


LinearSourceControlImpl.cpp |307|     GstElement *const timeshifter = get_element_by_name(pipelineElem, "timeshifter");                                  
LinearSourceControlImpl.cpp |234|     GstElement *const bufferElem = get_element_by_name(pipelineElem, "buffer");                                            
LinearSourceControlImpl.cpp |231|     GstElement *const srcElem = get_element_by_name(pipelineElem, "src");                                                  
LinearSourceControlImpl.cpp |228|     GstElement *const sinkElem = get_element_by_name(pipelineElem, "sink");                                                


={============================================================================
*kt_dev_uv_stack_220* stack: nickel: tests

export URANIUM_LOGGING_RULE="INFO,STDOUT"
Uranium/Uranium.Client.System/test/local-media-library/systemmediarecordcachetest 

DEVARCH/Uranium/Uranium.Client.System/test/local-media-library/SystemMediaRecordCacheTest.cpp

class ZINC_LOCAL SystemMediaRecordCacheTest {

    // test class defines its members as well
private:

    boost::shared_ptr< NS_NICKEL_SYSTEM::MockLocalMediaLibraryAsync >  systemLML;
    boost::shared_ptr< Dispatcher >                                    dispatcher;
    boost::shared_ptr<NS_COBALT_SYSTEM::MockProvisioningServiceAsync>  provisioningService;
    boost::shared_ptr< MediaRecordCache >                              cache;
    vector< NS_NICKEL_SYSTEM::MediaRecord >                            systemMediaRecords;

    void setUp()
    {
        systemLML = boost::make_shared< NS_NICKEL_SYSTEM::MockLocalMediaLibraryAsync >();
        dispatcher = boost::make_shared< SingleThreadDispatcher >();
        provisioningService = boost::make_shared<NS_COBALT_SYSTEM::MockProvisioningServiceAsync>();

        <cache>
        cache = MediaRecordCache::create( systemLML, provisioningService, dispatcher );
    }

    /**
     * Set up expectations that are used by most tests. This won't return until
     * the cache is populated.
     *
     * You can populate `systemMediaRecords` with a list of MediaRecords before
     * calling this and that will be used to populate the cache.
     */
    void defaultSetUp()
    {
        EXPECT_CALL( *systemLML, getMediaRecords(_,_,_,_,_,_) )
            .WillOnce( NS_ZINC::returnNewCompletedFuture( systemMediaRecords ) );

        cache->populate().get(); // Wait for the cache to load.

        // Avoid doing these sanity checks in every test.
        if ( systemMediaRecords.size() )
        {
            CPPUNIT_ASSERT( !cache->empty() );
        }
        CPPUNIT_ASSERT_EQUAL( systemMediaRecords.size(), cache->size() );
    }

    /**
     * Check if LibraryContentChange signals during getMediaRecords call are safe
     */
    void test_Update_during_Populate()
    {
        // makes an entry to SMR

        typedef vector< NS_NICKEL_SYSTEM::MediaRecord > MediaRecordsContainer;
        MediaRecordsContainer
        initialMediaRecords = list_of( makeMR( "1" ) ),
        updatedMediaRecords = list_of( makeMR( "2", "contentId" ) )     // 0
                                     ( makeMR( "3", "contentId" ) )     // 1
                                     ( makeMR( "4", "anotherId" ) );    // 2

        // Delay return of getMediaRecords
        Promise< MediaRecordsContainer > delayedMediaRecords;

        EXPECT_CALL( *systemLML, getMediaRecords(_,_,_,_,_,_) )
            .WillOnce( Return( delayedMediaRecords.getFuture() ) );

        // note: question is when and who calls getMediaRecord()?
        
        EXPECT_CALL( *systemLML, getMediaRecord(_) )
            // event #1
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(0) ) ) "2"
            // event #2
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(1) ) ) "3"
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(2) ) ) "4"
            // event #3
            .WillOnce( returnNewCompletedFuture( updatedMediaRecords.at(2) ) ); "4"

        // /**
        //  * Kick off a request to fetch all MediaRecords from the system. This call
        //  * must be called by users of the MediaRecord cache.
        //  *
        //  * @return Future< void > A future that is completed as soon as the cache
        //  *                        has been initially populated.
        //  */
        // NS_ZINC::Future< void > populate();
        //
        // Get all the linear MediaRecords.
        //
        // Future< vector< NS_NICKEL_SYSTEM::MediaRecord > > future = lml->getMediaRecords();
        //
        // cacheReadyFuture.setCallback( *dispatcher,
        //                          boost::bind( &MediaRecordCache::replayInitialUpdates,
        //                            shared_from_this(), _1 ));
        //
        // void MediaRecordCache::replayInitialUpdates( const FutureValue< void >& fv )
        //     applyUpdatesSync( initialUpdates );
        //        updateCache( lml->getMediaRecord( change.first ).get() );
        //

        // Will call getMediaRecords()
        Future<void> cacheReady = cache->populate();

        // 
        // void MediaRecordCache::replayInitialUpdates( const FutureValue< void >& fv )
        //     applyUpdatesSync( initialUpdates );
        //
        // MediaRecordCache::applyUpdatesSync(
        //  map< string, NS_NICKEL_SYSTEM::LibraryContentChangeType::Enum > const& changes )
        //
        // updateCache( lml->getMediaRecord( change.first ).get() );
        //

        // Trigger MediaRecordCache::applyUpdatesSync()
        // while getMediaRecords() hasn't returned yet
        map<string, NS_NICKEL_SYSTEM::LibraryContentChangeType::Enum> changes;

        <1>
        // Update event #1
        changes["1"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::updated;
        changes["2"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::added;

        // /**
        //  * Asynchronously process the updates, possibly calling the system over
        //  * dbus in order to fetch newly added / updated MediaRecords.
        //  *
        //  * This function won't block the calling thread but can block the dispatcher
        //  * that is given to this cache.
        //  *
        //  * @return The future will be completed only when all of the updates have
        //  *         been fully processed. The resulting map will contain a cleansed
        //  *         list of changes that were actually applied.
        //  */
        //
        // ::applyUpdates
        // {
        //     return asyncInvoke( *dispatcher,
        //                         boost::bind( &MediaRecordCache::queueOrApplyUpdates, shared_from_this(), changes ) );
        // }
        // 
        // ::queueOrApplyUpdates(
        // {
        //     return applyUpdatesSync( changes );
        //     -> updateCache( lml->getMediaRecord( change.first ).get() );
        // }
        //

        Future< boost::shared_ptr< map< string, LibraryContentChangeType::Enum > > >  
            updatedFuture = cache->applyUpdates( changes );

        // should return almost immediately
        CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );

        // shouldn't return any events
        
        // note: this is changes.size()
        CPPUNIT_ASSERT_EQUAL( updatedFuture.get()->size(), 0);

        <2>
        // Update event #2
        changes.clear();
        changes["1"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::deleted;
        changes["3"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::updated;
        changes["4"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::added;

        updatedFuture = cache->applyUpdates( changes );

        // should return almost immediately
        CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );
        // shouldn't return any events
        CPPUNIT_ASSERT_EQUAL( updatedFuture.get()->size(), 0);

        // note: here "1" completed?
        // Let getMediaRecords() return which makes chacheReady promise complete
        delayedMediaRecords.complete( initialMediaRecords);

        // cacheReady future should not block infinitely
        CPPUNIT_ASSERT( cacheReady.wait_for(boost::posix_time::seconds(3)) );

        <3>
        // Update event #3 - to make sure #1 and #2 have been already applied
        changes.clear();
        changes["4"] = NS_NICKEL_SYSTEM::LibraryContentChangeType::updated;

        updatedFuture = cache->applyUpdates( changes );

        // should return in a reasonably time
        CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );
        // should return a valid event
        CPPUNIT_ASSERT_EQUAL( updatedFuture.get()->size(), 1);

        // The cache should contain the updated records
        CPPUNIT_ASSERT_EQUAL( updatedMediaRecords.size(), cache->size() );
    }


$ Uranium/Uranium.Client.System/test/local-media-library/systemmediarecordcachetest 
.++ Logger: uranium - override provided in URANIUM_LOGGING_RULE, using that ++
.....
3,660 INFO   140259472475904 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 1 )
lml::client::SystemMediaRecordCacheTest::test_Update_during_Populate()
3,661 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:264 Queueing LibraryContentChange events
3,661 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:264 Queueing LibraryContentChange events
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:298 KT: from cacheReady: Replaying LibraryContentChange events
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 2 )
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 3 )
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 4 )
3,662 INFO   140259455690496 uranium /home/kpark/builds/_virtual_/pc/DEVARCH/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp:333 KT: call lml->getMediaRecord( 4 )
} 

OK (7)


={============================================================================
*kt_dev_uv_stack_250* stack: binding and makefile 

How do translation?

./Zinc/Zinc.BindingRuntime/data/air/CommonMakefile.am

## Work out where the Client API headers are
client_api_include_dir = ${PKG_CONFIG_SYSROOT_DIR}$(shell pkg-config --variable=includedir $(client_api_package))/$(client_api_package)

all_client_api_headers:=$(shell find $(client_api_include_dir) -name \*.h)


={============================================================================
*kt_dev_uv_stack_300* stack: IP: wikis

1. IP Channel MediaRouter Device Manufacturer Integration
https://wiki.youview.co.uk/display/IPCHAN/IP+Channel+MediaRouter+Device+Manufacturer+Integration?src=search

o LinearSource component (linearsourced) via a DBus interface 

o streaming sockets interface (zmp).


={============================================================================
*kt_dev_uv_stack_350* stack: pump: gst

https://wiki.youview.co.uk/display/canvas/GStreamer+Emporium


{enable-debug-log}
https://wiki.youview.co.uk/display/YVHTMLCRB/Debugging+video+playback+in+the+HTML+engine?src=search

Gstreamer debug

The next thing to try is to add gstreamer debugging. Add

export GST_DEBUG=2,nexussink:4,webkitmediaplayer:5,basesink:3,hlsdemux:3

That should produce quite a lot of debug information on the serial port console when the w3cEngine
tries to start playing video.

The GST_DEBUG setting allows different debug levels to be set of each gstreamer element. Some
element names that you might need to use:

name           module
nexussink	         YouView's Polonium sink element that connects to NexusMgr
webkitmediaplayer	   Debug messages from MediaPlayerPrivateGstreamer.cpp
tsnexusbin	         YouView's Polonium sink bin that uses tsparser to auto-detect the PIDs for nexussink
hlsdemux	            The element that implements the HLS protocol
webkitwebsrc	      Only used if YV_WEBKIT_USE_WEBSRC is defined. If YV_WEBKIT_USE_WEBSRC is defined, WebKit's networking stack is used to feed data to gstreamer
uridecodebin	      When playing MP4 or MPD files, uridecodebin is used to auto-plug modules that can produce something that nexussink can accept
decodebin	         Base class of uridecodebin
basesink	            Base class of nexussink
uridownloader	      Used by hlsdemux and dashdemux to download fragments. For hlsdemux it is also used to load media playlists
dashdemux	         The element that implements the DASH protocol
fragmented	         The element that implements m3u8 file parsing

 
The number after the element name indicates the debug level:
Number
	
Gstreamer debug level Description
0	GST_LEVEL_NONE
	No debugging level specified or desired. Used to deactivate debugging output.

1	GST_LEVEL_ERROR
   Error messages are to be used only when an error occured that stops the application from keeping
   working correctly. An examples is gst_element_error, which outputs a message with this priority.
   It does not mean that the application is terminating as with g_errror.  
   
2	GST_LEVEL_WARNING
   Warning messages are to inform about abnormal behaviour that could lead to problems or weird
   behaviour later on. An example of this would be clocking issues ("your computer is pretty slow")
   or broken input data ("Can't synchronize to stream.") 
   
3	GST_LEVEL_FIXME
   Fixme messages are messages that indicate that something in the executed code path is not fully
   implemented or handled yet. Note that this does not replace proper error handling in any way, the
   purpose of this message is to make it easier to spot incomplete/unfinished pieces of code when
   reading the debug log.

4	GST_LEVEL_INFO
   Informational messages should be used to keep the developer updated about what is happening.
   Examples where this should be used are when a typefind function has successfully determined the
   type of the stream or when an mp3 plugin detects the format to be used. ("This file has mono
           sound.")

5	GST_LEVEL_DEBUG
   Debugging messages should be used when something common happens that is not the expected default
   behavior, or something that's useful to know but doesn't happen all the time (ie. per loop
           iteration or buffer processed or event handled). An example would be notifications about
   state changes or receiving/sending of events.

6	GST_LEVEL_LOG
   Log messages are messages that are very common but might be useful to know. As a rule of thumb a
   pipeline that is iterating as expected should never output anything else but LOG messages. Use
   this log level to log recurring information in chain functions and loop functions, for example.

7	GST_LEVEL_TRACE
	Tracing-related messages. Examples for this are referencing/dereferencing of objects.

9	GST_LEVEL_MEMDUMP
   memory dump messages are used to log (small) chunks of data as memory dumps in the log. They will
   be displayed as hexdump with ASCII characters.


You can send the gstreamer debug output to a file, rather than to the console by adding the
following two lines to the runBrowser.sh script:

    GST_DEBUG_NO_COLOR=1 \

    GST_DEBUG_FILE=/app-data/gst-log.txt \

The log file should appear in:

/opt/zinc-trunk/var/applications/data/air/31c5e1725fb42bc769224449ebe0e6464cb6304acba079d0e5c4b59768cb9331/app-data/

/builds/flaky-tests/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk/oss/include/gstreamer-1.0/gst

gstinfo.h

typedef enum {
  GST_LEVEL_NONE = 0,
  GST_LEVEL_ERROR = 1,
  GST_LEVEL_WARNING = 2,
  GST_LEVEL_FIXME = 3,
  GST_LEVEL_INFO = 4,
  GST_LEVEL_DEBUG = 5,
  GST_LEVEL_LOG = 6,
  GST_LEVEL_TRACE = 7,
  /* add more */
  GST_LEVEL_MEMDUMP = 9,
  /* add more */
  GST_LEVEL_COUNT
} GstDebugLevel;


{element-register}
Nickel/Nickel.LinearSource/zmp/gstzmpsink.c

static gboolean
gst_zmp_sink_plugin_init (GstPlugin * plugin)
{
  GST_DEBUG_CATEGORY_INIT (gst_zmp_sink_debug, "zmpsink", 0,
      "ZMP Sink");

  return gst_element_register (plugin, "zmpsink", GST_RANK_NONE,
      GST_TYPE_ZMP_SINK);
}


{set-debug}
killall linearsourced
export GST_DEBUG=5
linearsource-launch &

1. /opt/zinc/bin/linearsource-launch
this calls

2. /opt/zinc-trunk/bin/linearsource-launch

3. leads to:
+ exec /opt/zinc-trunk/bin/exec-with-cache -c /tmp/lsd-polipo.cfg.bYZxqv 
-d /opt/zinc-trunk/var/linearsourced/http_cache 

/opt/zinc-trunk/bin/linearsourced 

'--user-agent=YouView (Humax; DTRT1
000; 80B07001; CDS/21.30.30; API/2.9.4; PS/2.9.32) (+DVR+FLASH+HTML+MHEG+IPCMC)' --vqe-buffer-size=65536


{gst-inspect}
[root@HUMAX /]# gst-inspect-1.0
typefindfunctions: video/x-ms-asf: asf, wm, wma, wmv
typefindfunctions: audio/x-musepack: mpc, mpp, mp+
typefindfunctions: audio/x-au: au, snd
typefindfunctions: video/x-msvideo: avi
typefindfunctions: audio/qcelp: qcp
typefindfunctions: video/x-cdxa: dat
typefindfunctions: video/x-vcd: dat
typefindfunctions: audio/x-imelody: imy, ime, imelody
typefindfunctions: audio/midi: mid, midi
typefindfunctions: audio/riff-midi: mid, midi
typefindfunctions: audio/mobile-xmf: mxmf
typefindfunctions: video/x-fli: flc, fli
typefindfunctions: application/x-id3v2: mp3, mp2, mp1, mpga, ogg, flac, tta
typefindfunctions: application/x-id3v1: mp3, mp2, mp1, mpga, ogg, flac, tta
typefindfunctions: application/x-apetag: mp3, ape, mpc, wv
typefindfunctions: audio/x-ttafile: tta
typefindfunctions: audio/x-mod: 669, amf, ams, dbm, digi, dmf, dsm, gdm, far, imf, it, j2b, mdl, med, mod, mt2, mtm, okt, psm, ptm, sam, s3m, stm, stx, ult, xm
typefindfunctions: audio/mpeg: mp3, mp2, mp1, mpga
typefindfunctions: audio/x-ac3: ac3, eac3
typefindfunctions: audio/x-dts: dts
typefindfunctions: audio/x-gsm: gsm
typefindfunctions: video/mpeg-sys: mpe, mpeg, mpg
typefindfunctions: video/mpegts: ts, mts
typefindfunctions: application/ogg: ogg, oga, ogv, ogm, ogx, spx, anx, axa, axv
typefindfunctions: video/mpeg-elementary: mpv, mpeg, mpg
typefindfunctions: video/mpeg4: m4v
typefindfunctions: video/x-h263: h263, 263
typefindfunctions: video/x-h264: h264, x264, 264
typefindfunctions: video/x-nuv: nuv
typefindfunctions: audio/x-m4a: m4a
typefindfunctions: application/x-3gp: 3gp
typefindfunctions: video/quicktime: mov
typefindfunctions: image/x-quicktime: qif, qtif, qti
typefindfunctions: image/jp2: jp2
typefindfunctions: video/mj2: mj2
typefindfunctions: text/html: htm, html
typefindfunctions: application/vnd.rn-realmedia: ra, ram, rm, rmvb
typefindfunctions: application/x-pn-realaudio: ra, ram, rm, rmvb
typefindfunctions: application/x-shockwave-flash: swf, swfl
typefindfunctions: application/vnd.ms-sstr+xml: no extensions
typefindfunctions: video/x-flv: flv
typefindfunctions: text/plain: txt
typefindfunctions: text/utf-16: txt
typefindfunctions: text/utf-32: txt
typefindfunctions: text/uri-list: ram
typefindfunctions: application/x-hls: m3u8
typefindfunctions: application/sdp: sdp
typefindfunctions: application/smil: smil
typefindfunctions: application/xml: xml
typefindfunctions: audio/x-wav: wav
typefindfunctions: audio/x-aiff: aiff, aif, aifc
typefindfunctions: audio/x-svx: iff, svx
typefindfunctions: audio/x-paris: paf
typefindfunctions: audio/x-nist: nist
typefindfunctions: audio/x-voc: voc
typefindfunctions: audio/x-sds: sds
typefindfunctions: audio/x-ircam: sf
typefindfunctions: audio/x-w64: w64
typefindfunctions: audio/x-shorten: shn
typefindfunctions: application/x-ape: ape
typefindfunctions: image/jpeg: jpg, jpe, jpeg
typefindfunctions: image/gif: gif
typefindfunctions: image/png: png
typefindfunctions: image/bmp: bmp
typefindfunctions: image/tiff: tif, tiff
typefindfunctions: image/webp: webp
typefindfunctions: image/x-portable-pixmap: pnm, ppm, pgm, pbm
typefindfunctions: video/x-matroska: mkv, mka, mk3d, webm
typefindfunctions: application/mxf: mxf
typefindfunctions: video/x-mve: mve
typefindfunctions: video/x-dv: dv, dif
typefindfunctions: audio/x-amr-nb-sh: amr
typefindfunctions: audio/x-amr-wb-sh: amr
typefindfunctions: audio/iLBC-sh: ilbc
typefindfunctions: audio/x-sbc: sbc
typefindfunctions: audio/x-sid: sid
typefindfunctions: image/x-xcf: xcf
typefindfunctions: video/x-mng: mng
typefindfunctions: image/x-jng: jng
typefindfunctions: image/x-xpixmap: xpm
typefindfunctions: image/x-sun-raster: ras
typefindfunctions: application/x-bzip: bz2
typefindfunctions: application/x-gzip: gz
typefindfunctions: application/zip: zip
typefindfunctions: application/x-compress: Z
typefindfunctions: subtitle/x-kate: no extensions
typefindfunctions: audio/x-flac: flac
typefindfunctions: audio/x-vorbis: no extensions
typefindfunctions: video/x-theora: no extensions
typefindfunctions: application/x-ogm-video: no extensions
typefindfunctions: application/x-ogm-audio: no extensions
typefindfunctions: application/x-ogm-text: no extensions
typefindfunctions: audio/x-speex: no extensions
typefindfunctions: audio/x-celt: no extensions
typefindfunctions: application/x-ogg-skeleton: no extensions
typefindfunctions: text/x-cmml: no extensions
typefindfunctions: application/x-executable: no extensions
typefindfunctions: audio/aac: aac, adts, adif, loas
typefindfunctions: audio/x-spc: spc
typefindfunctions: audio/x-wavpack: wv, wvp
typefindfunctions: audio/x-wavpack-correction: wvc
typefindfunctions: application/postscript: ps
typefindfunctions: image/svg+xml: svg
typefindfunctions: application/x-rar: rar
typefindfunctions: application/x-tar: tar
typefindfunctions: application/x-ar: a
typefindfunctions: application/x-ms-dos-executable: dll, exe, ocx, sys, scr, msstyles, cpl
typefindfunctions: video/x-dirac: no extensions
typefindfunctions: multipart/x-mixed-replace: no extensions
typefindfunctions: application/x-mmsh: no extensions
typefindfunctions: video/vivo: viv
typefindfunctions: audio/x-nsf: nsf
typefindfunctions: audio/x-gym: gym
typefindfunctions: audio/x-ay: ay
typefindfunctions: audio/x-gbs: gbs
typefindfunctions: audio/x-vgm: vgm
typefindfunctions: audio/x-sap: sap
typefindfunctions: video/x-ivf: ivf
typefindfunctions: audio/x-kss: kss
typefindfunctions: application/pdf: pdf
typefindfunctions: application/msword: doc
typefindfunctions: image/vnd.adobe.photoshop: psd
typefindfunctions: image/vnd.wap.wbmp: no extensions
typefindfunctions: application/x-yuv4mpeg: no extensions
typefindfunctions: image/x-icon: no extensions
typefindfunctions: image/x-degas: no extensions
typefindfunctions: application/octet-stream: no extensions
typefindfunctions: application/x-ssa: ssa, ass
typefindfunctions: video/x-pva: pva
videotestsrc:  videotestsrc: Video test source
dashdemux:  dashdemux: DASH Demuxer
dashdemux: application/dash+xml: no extensions
mpegts:  tspacer: Pacer for MPEG-TS streams
fragmented:  hlsdemux: HLS Demuxer
fragmented:  hlssink: HTTP Live Streaming sink
mpegtsdemux:  tsparse: MPEG transport stream parser
mpegtsdemux:  tsdemux: MPEG transport stream demuxer
videoparsersbad:  h263parse: H.263 parser
videoparsersbad:  h264parse: H.264 parser
videoparsersbad:  diracparse: Dirac parser
videoparsersbad:  mpegvideoparse: MPEG video elementary stream parser
videoparsersbad:  mpeg4videoparse: MPEG 4 video elementary stream parser
videoparsersbad:  pngparse: PNG parser
videoparsersbad:  vc1parse: VC1 parser
isomp4:  qtdemux: QuickTime demuxer
isomp4:  rtpxqtdepay: RTP packet depayloader
isomp4:  qtmux: QuickTime Muxer
isomp4:  mp4mux: MP4 Muxer
isomp4:  ismlmux: ISML Muxer
isomp4:  3gppmux: 3GPP Muxer
isomp4:  mj2mux: MJ2 Muxer
isomp4:  qtmoovrecover: QT Moov Recover
vqe:  vqesrc: RTP Receiver
vqe:  vqesdpdemux: VQE SDP Demux
nexus:  nexussink: Nexus sink
nexus:  tsnexusbin: TS parser + Nexus sink for MPEG TS streams
tstimeshift:  tsshifter: Time Shift for MPEG TS streams
tstimeshift:  tsshifterbin: Time Shift + TS parser for MPEG TS streams
tstimeshift:  tsseeker: Time-shift seeker
tstimeshift:  tsindexer: Indexer for MPEG-TS streams
tstimeshift:  tsstamper: Stamper for MPEG-TS streams
coreelements:  capsfilter: CapsFilter
coreelements:  fakesrc: Fake Source
coreelements:  fakesink: Fake Sink
coreelements:  fdsrc: Filedescriptor Source
coreelements:  fdsink: Filedescriptor Sink      // note:
coreelements:  filesrc: File Source
coreelements:  funnel: Funnel pipe fitting
coreelements:  identity: Identity
coreelements:  input-selector: Input selector
coreelements:  output-selector: Output selector
coreelements:  queue: Queue
coreelements:  queue2: Queue 2
coreelements:  filesink: File Sink
coreelements:  tee: Tee pipe fitting
coreelements:  typefind: TypeFind
coreelements:  multiqueue: MultiQueue
coreelements:  valve: Valve element
audiotestsrc:  audiotestsrc: Audio test source
soup:  souphttpsrc: HTTP client source
soup:  souphttpclientsink: HTTP client sink
zmpsink:  zmpsink: Generic bin      // note:
playback:  playbin: Player Bin 2
playback:  playsink: Player Sink
playback:  subtitleoverlay: Subtitle Overlay
playback:  streamsynchronizer: Stream Synchronizer
playback:  decodebin: Decoder Bin
playback:  uridecodebin: URI Decoder
staticelements:  bin: Generic bin
staticelements:  pipeline: Pipeline object



={============================================================================
*kt_dev_uv_stack_351* stack: gst: log

{zmpsink}
libgstzmp.so.0.0.0


[root@HUMAX gstreamer-1.0]# pwd
/opt/zinc-trunk/oss/lib/gstreamer-1.0

lrwxrwxrwx    1 1024     1025            18 May  1 12:00 libgstzmp.so -> libgstzmp.so.0.0.0*
lrwxrwxrwx    1 1024     1025            18 May  1 12:00 libgstzmp.so.0 -> libgstzmp.so.0.0.0*
-rwxr-xr-x    1 1024     1025         27968 Apr 30 12:44 libgstzmp.so.0.0.0*

alias hcpp='scp 
   ~/builds/DEVARCH-8828/humax.1000/zinc-build-root/release-humax-dtr_t1000/Nickel/Nickel.LinearSource/.libs/libgstzmp.so.0.0.0 
   root@172.20.35.27:/opt/zinc-trunk/oss/lib/gstreamer-1.0'


{zmp}

[root@HUMAX lib]# pwd
/opt/zinc-trunk/lib

lrwxrwxrwx    1 1024     1025          19 May  1 11:59 libzmp-1.0.so -> libzmp-1.0.so.0.0.0*
lrwxrwxrwx    1 1024     1025          19 May  1 11:59 libzmp-1.0.so.0 -> libzmp-1.0.so.0.0.0*
-rwxr-xr-x    1 1024     1025       17.3K Apr 30 12:44 libzmp-1.0.so.0.0.0*

alias hczm='scp 
   ~/builds/DEVARCH-8828/humax.1000/zinc-build-root/release-humax-dtr_t1000/Nickel/Nickel.LinearSource/.libs/libzmp-1.0.so.0.0.0 
   root@172.20.35.27:/opt/zinc-trunk/lib'

note: bronzemediad uses libzmp and found that it's in /opt/zinc/lib even when use zinc-trunk


{remove-timeshifter}

[root@HUMAX nickel-linear-source]# pwd
/opt/zinc-trunk/share/platform_data/nickel-linear-source

[root@HUMAX nickel-linear-source]# ll
drwxrwxr-x    2 1024     1025        4.0K Apr 30 12:44 ./
drwxrwxr-x   10 1024     1025        4.0K Apr 30 12:58 ../
-rw-r--r--    1 1024     1025          80 Apr 30 12:44 gst-pipeline-non-pausing
-rw-r--r--    1 1024     1025          94 May  5 15:52 gst-pipeline-pausing

from:

[root@HUMAX nickel-linear-source]# less gst-pipeline-pausing 
uridecodebin caps=video/mpegts name=src ! queue ! tsshifterbin name=buffer ! zmpsink name=sink 

to:

[root@HUMAX nickel-linear-source]# less gst-pipeline-pausing 
uridecodebin caps=video/mpegts name=src ! queue ! zmpsink name=sink tsshifterbin name=buffer 

uridecodebin caps=video/mpegts name=src ! queue ! zmpsink name=sink tsshifterbin name=buffer 

{buffer-size}
get_vqe_buffer_size() {                                                                                           
        vqe_buffer_size="$(lsr-config --int platform.linearsource.vqebuffersize)"                                 
        if [ -z "$vqe_buffer_size" ]; then                                                                        
                # Assume sensible default                                                                         
                vqe_buffer_size=48384                                                                             
        fi                                                                                                        
}                                                                                                                 


{related-jiras}
TASK: ADD: add key to control LSD/VQE buffer size
https://jira.youview.co.uk/browse/SPECWIP-3794

   IPC Linearsourced performance - taking up much CPU - affects IP Live & Recordings.
   https://jira.youview.co.uk/browse/DEVARCH-6269


{on-read}
 * on_data: 
 *      Called when data should be transferred. Data should be read from input_fd. This callback is
 *      intended to behave like the standard UNIX function read() when called on a non-blocking
 *      file-descriptor.
 *

When data is available libzmp will call this callback repeatedly until it either returns 0 (to
        indicate EOF on input_fd) or -1 (to indicate an an error). 

This function should behave like read in that: 

o If any data was successfully consumed it should return the number of bytes that had been consumed. 

o If reading data from the pipe would cause the function to block, it should return -1 and set errno
to EAGAIN.

o If consuming the data would otherwise require on_data to block, it should return -1 and set errno
to EAGAIN. This might happen if the decoder buffer that on_data is feeding were full.
zmp_stream_notify_read_ready should be called once you are again ready to consume data.
zmp_stream_notify_read_ready can be called from any thread.      
            
o If no data could be consumed because of an error, it should return -1 and errno set appropriately.
This will put libzmp into an error state and no further data will be available.


/*
 * onData
 * ======
 *
 * Called when data is available for consumption.
 */
ssize_t onData( ZMPStream *, int infd)
{
    /* In a real client you will want to fill your decoder buffers here by
     * reading from infd.  If your decoder buffer fills return -1 and set
     * errno to EAGAIN.  You will then later be required to call
     * zmp_notify_read_ready when your decoder buffer once again has space
     */
    char buf[4096];
    int err;
    ssize_t bytes_read = read(infd, buf, sizeof(buf));
    err = errno;
    if ( bytes_read > 0 ) {
        out->write(buf, bytes_read);
    }
    total_bytes_consumed += bytes_read;
    errno = err;
    return bytes_read;
}


1491: KT-ZMP: Received data: ** 0B ** 
1491: KT-ZMP: reading blocked on data fd 0

1492: KT-ZMP: reading blocked on data fd 0

1493: KT-ZMP: reading blocked on data fd 0

1494: KT-ZMP: Received data: ** 0B ** 
1494: KT-ZMP: reading blocked on data fd 0

1495: KT-ZMP: reading blocked on data fd 0
1496: KT-ZMP: reading blocked on data fd 0
1497: KT-ZMP: Received data: ** 0B ** 
1497: KT-ZMP: reading blocked on data fd 0
1498: KT-ZMP: reading blocked on data fd 0
1499: KT-ZMP: reading blocked on data fd 0


={============================================================================
*kt_dev_uv_stack_120* stack: cal: dispatcher

{future-dispatcher}

class ZINC_EXPORT InlineDispatcher : public Dispatcher
{
    public:
        InlineDispatcher();
        ~InlineDispatcher();

        /**
         * Since InlineDispatcher is stateless, it is convenient to reuse
         * a single instance of it.
         *
         * This does not mean that we must always use it as a singleton.
         *
         * @return an instance that may be shared.
         */
        static InlineDispatcher& sharedInstance();

    public: // from Dispatcher
        virtual void post(boost::function<void ()> handler);
        virtual int getPendingCount();
};

/DEVARCH/Zinc/Zinc.Common/include/async/Dispatcher.h

/*
 * Interface for general functor dispatcher.
 *
 * Dispatchers are used to 'invoke' callback functors (for events and futures for example).
 *
 */
struct ZINC_EXPORT Dispatcher : boost::noncopyable
{
	/**
	 * Dispatcher::work is a RAII class.  An object of this type should exist
	 * for as long as there is the possibility of you calling post.  This is
	 * similar to an boost::io_service::work and will prevent the dispatcher
	 * from running down.
	 *
	 * Example: A Future will hold a work object after setCallback is called
	 *          as it knows it will be posting a functor at some point in the
	 *          future (but doesn't know when).  After the callback is called
	 *          the work object is destroyed so the dispatcher can run down.
	 */
	typedef boost::unique_lock<Dispatcher> work;

	virtual ~Dispatcher();

	/**
	 * Post the supplied completion handler to the dispatcher for execution.
	 *
	 * The Dispatcher will hold a reference to the suppled functor until the
	 * it has been executed.
	 *
	 * @param handler the completion handler
	 */
	virtual void post(boost::function<void ()> handler) = 0;

private:
	/**
	 * These methods are called when a Dispatcher::work object is
	 * created/destroyed. Typically a dispatcher that is interested will treat
	 * these functions like a ref count inc/dec.
	 *
	 * It is not necessary to implement these functions.  The default
	 * implementations do nothing.
	 */
	virtual void onWorkAdded() {};
	virtual void onWorkRemoved() {};

private: // Lockable concept
	// Implement the "lockable" concept so we can use unique_lock as our RAII
	// "work" class
	friend class boost::unique_lock<Dispatcher>;
	void lock() ZINC_LOCAL { onWorkAdded(); };
	void unlock() ZINC_LOCAL { onWorkRemoved(); };
};


<worker-function>
/*
 * WorkerFunction.h
 *
 *  Created on: Oct 22, 2009
 *      Author: john.sadler@bbc.co.uk
 *
 * Copyright (C) 2009 British Broadcasting Corporation
 */

#ifndef ZINC_WORKERFUNCTION_H_
#define ZINC_WORKERFUNCTION_H_

#include "macros.h"

NS_ZINC_OPEN

namespace detail {

void maskSignals() ZINC_EXPORT;

/**
 * This functor is used to wrap any functor (or plain function) that will
 * be executed by a worker thread. It's purpose is to ensure that the first
 * thing the thread does is to ignore all signals delivered to the process.
 *
 * This is important, since posix does not define *which* thread a will
 * receive a signal delivered to the process. It only says that the signal
 * may be delivered to any thread that does not mask it. So, if we wish to have
 * a sane signal handling strategy, then we should nominate a *single* specific
 * thread to deal with all signals (and perhaps propagate them to other threads, as
 * application events).
 *
 * Use this class like:
 *
 * boost::thread thread(WorkerFunction(myThreadFunctionOrFunctor));
 *
 */
template <class NullaryFunctor>
    class WorkerFunction {

        public:
            WorkerFunction(NullaryFunctor functor)
                : workerFunction(functor)
            {
            }

            void operator()() {
                maskSignals();
                workerFunction();
            }

        private:
            NullaryFunctor workerFunction;
    };

}

template <typename NullaryFunctor>
detail::WorkerFunction<NullaryFunctor> makeWorkerFunction(NullaryFunctor fn)
{
    return detail::WorkerFunction<NullaryFunctor>(fn);
}

NS_ZINC_CLOSE


#endif /* WORKERFUNCTION_H_ */


<single-thread-dispatcher>
/*
 * A Dispatcher implementation that 'owns' a single 'thread' on which it executes the
 * functors posted to it. Functors are executed strictly in the order that they are
 * posted to the dispatcher.
 */
class ZINC_EXPORT SingleThreadDispatcher : public Dispatcher
{
    public:
        SingleThreadDispatcher();
        ~SingleThreadDispatcher();

    public: // from Dispatcher
        virtual void post(boost::function<void ()> handler);
        virtual int getPendingCount();

    private:
        boost::asio::io_service io;
        boost::thread thread;
};

SingleThreadDispatcher:: SingleThreadDispatcher()
 : thread(makeWorkerFunction(boost::bind(&run, &io)))
{
}

SingleThreadDispatcher::~SingleThreadDispatcher()
{
    io.stop();
    thread.join();
}

static void run(boost::asio::io_service* io) 
{
    boost::asio::io_service::work work(*io);
    while (1) {
        try {
            // because of the io_service::work above the only reason this
            // will return is if io.stop() is called from ~SingleThreadDispatcher()
            // destructor
            io->run();
            break;
        }
        catch (...) {
            // Exceptions thrown in functors posted to the io_service are
            // propogated up to the caller of run().  We wish to ignore them
        }
    }
}


/**
 * Post a functor to the dispatcher, and put it on the pending dispatch queue.
 */
void SingleThreadDispatcher::post(boost::function<void ()> handler)
{
    io.post(handler);
}


typedef SingleThreadDispatcher SequentialFutureDispatcher;


class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
    boost::shared_ptr<NS_ZINC::EventDispatcher> defaultDispatcher;

    boost::shared_ptr<NS_ZINC::FutureDispatcher> futureDispatcher;

    // create ED, FD

    SystemClientFactory() :
        defaultDispatcher(boost::make_shared<InlineDispatcher>()),

        // note:
        futureDispatcher(boost::make_shared<SequentialFutureDispatcher>()),

        provisioningCacheThread(boost::make_shared<SingleThreadDispatcher>())
    {
    }

    // pass FD to SCER

    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
        createConcreteEventRepository() 
        {
            concreteER->setDefaultDispatcher(getDefaultDispatcher());

            // set dispatchers
            
            concreteER->setFutureDispatcher(futureDispatcher);
        }

    boost::shared_ptr<EventDispatcher> getDefaultDispatcher() 
    {
        if (!defaultDispatcher.get())
            throw runtime_error("No default dispatcher set");
        return defaultDispatcher;
    }
};



{future-producer}

/*
 * DispatchingFutureProducer
 *
 * Provide an interface for injecting a future dispatcher
 */
class DispatchingFutureProducer : virtual public Polymorphic
{
public:
	virtual void setFutureDispatcher(boost::shared_ptr<FutureDispatcher> dispatcher)
	{
		boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
		this->dispatcher = dispatcher;
	}
	virtual void removeFutureDispatcher()
	{
		boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
		dispatcher.reset();
	}
	virtual boost::shared_ptr<FutureDispatcher> getFutureDispatcher() const
	{
		boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
		return dispatcher;
	}
private:
	boost::shared_ptr<FutureDispatcher> dispatcher;
	mutable boost::recursive_mutex dispatcherMutex;
};


class ZINC_EXPORT SystemClientEventRepository : 
    public EventRepository,
    public NS_ZINC::DispatchingFutureProducer,
    public boost::enable_shared_from_this<SystemClientEventRepository>,
    public MetadataChangeListener
{
    boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher;

    void setDefaultDispatcher(boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher_)
    {
        dispatcher = dispatcher_;
    }

    // note: called in @getEventWindow(), @eventReceived() for IP and DTT
    
    /**
     * Creates event window from events passed in.
     * @note The method sanitizes the events, removes duplicates and joins adjacent null events
     * @note This method assumes that if there are duplicates inside events passed in, they'll be identical.
     */
    boost::shared_ptr<SystemClientEventWindow> SystemClientEventRepository::createEventWindow(
            EventWindowCreateCommand& cmd,
            event_collection_ptr events, bool hasStaleData)
    {
        //clog<<"Creating window in "<<cmd.location;
        boost::shared_ptr<SystemClientEventWindow> ew = 
            boost::make_shared<SystemClientEventWindow>(cmd.location,
                    sanitizedEvents, serviceRepo, shared_from_this(),
                    (microsec_clock::universal_time() - cmd.dataRetrievalStartTime).total_milliseconds(),
                    cmd.hasDataFromAllSources(), hasStaleData);

        // note: set FD!

        ew->setDispatcher(dispatcher);

        metadataObserver->addListener(ew);
    }
};



{event-producer} window

// * An abstract producer of events matching a particular specification.

template<class ListenerT>
class ZINC_EXPORT EventProducer : virtual public Polymorphic 
{
   virtual void addListener(boost::shared_ptr<ListenerT> listener) = 0;
};


// note: it do not have a thread

typedef Dispatcher EventDispatcher;

// /Zinc/Zinc.Common/include/DispatchingEventProducer.h

template<class ListenerT>
class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer<ListenerT> 
{
    // <DEPH>
    mutable detail::DispatchingEventProducerHoisted impl;

    // * @param dispatcher_ this dispatcher will be used to 'dispatch' event listener callback
    // * methods, unless clients explicitly provide an alternative dispatcher in the
    // * call to addListener()
    //
    explicit DispatchingEventProducer(boost::shared_ptr<EventDispatcher> dispatcher_) 
        : impl(dispatcher_) {}

    virtual void addListener(boost::shared_ptr<ListenerT> listener) {
        // Hoisting note: we cast to void* here, and cast back down in
        // DowncastingCaller so everything is lovely and symmetrical
        impl.addListener(listener);
    }

    // pass 'dispatcher' to 'impl' which is the hoisted
    
    virtual void setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher) {
        impl.setDispatcher(dispatcher);
    }

	 // * Derived implementations should call this method to dispatch an event.
    
    template <typename Functor>
        void produceEvent(Functor f) const {

            ZINC_CHECK_CONCEPT(f(static_cast<ListenerT*>(NULL)));
            impl.produceEvent(DowncastingCaller<Functor>(f));
        }
};


//  * A class that represents the Event Window, basically the EPG view.
class ZINC_EXPORT EventWindow : virtual public NS_ZINC::DispatchingEventProducer<EventWindowEventListener> 
{
   // EventWindow is ABC
};


// created from createEventWindow() and passed up to EPG

class ZINC_EXPORT SystemClientEventWindow 
                                 : virtual public EventWindow,
                                   public boost::enable_shared_from_this<SystemClientEventWindow>,
                                   virtual public MetadataChangeListener 
{
    // note: add f = bind() to listeners. so when called from listners, will lead to 
    // EventWindowEventListener::EventsChanged(_1, events);
    
    notifyEventsChanged(std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> > events)
    {
        produceEvent(bind(&EventWindowEventListener::EventsChanged, _1, events));
    }

    notifyWindowChanged()
    {
        produceEvent(bind(&EventWindowEventListener::EventWindowChanged, _1));
    }
};


={============================================================================
*kt_dev_uv_stack_121* stack: cal: test

/data/builds/DEVARCH-8092/huawei.370/ \
   zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/tests/uranium-client-system/test/metadata

-rwxr-xr-x 1 kpark kpark  391852 Feb 25 14:44 brokerintegrationtest*
-rwxr-xr-x 1 kpark kpark 5250731 Feb 25 14:44 eventcachettltest*
-rwxr-xr-x 1 kpark kpark 5260059 Feb 25 14:44 eventwindowresizetest*
-rwxr-xr-x 1 kpark kpark 3986922 Feb 25 14:44 fulleventtest*
-rwxr-xr-x 1 kpark kpark 2024474 Feb 25 14:44 identifierbagtest*
-rwxr-xr-x 1 kpark kpark 2022120 Feb 25 14:44 identifierprocessingtest*
-rwxr-xr-x 1 kpark kpark 4468512 Feb 25 14:44 mediarecordcachetest*
-rwxr-xr-x 1 kpark kpark 5292645 Feb 25 14:44 metadatabrokerfunctest*
-rwxr-xr-x 1 kpark kpark 1502519 Feb 25 14:44 metadataobservertest*
-rwxr-xr-x 1 kpark kpark 1624748 Feb 25 14:44 metadatasourcefallbacktest*
-rwxr-xr-x 1 kpark kpark  217077 Feb 25 14:44 metadata-systemclientfactorytest*
-rwxr-xr-x 1 kpark kpark 4423512 Feb 25 14:44 presenteventscachesanitisationtest*
-rwxr-xr-x 1 kpark kpark 4426963 Feb 25 14:44 presenteventscachetest*
-rwxr-xr-x 1 kpark kpark 3977156 Feb 25 14:44 programmetest*
-rwxr-xr-x 1 kpark kpark 2265663 Feb 25 14:44 provisioningcachetest*
-rwxr-xr-x 1 kpark kpark 3986679 Feb 25 14:44 publicationtest*
-rwxr-xr-x 1 kpark kpark 5249049 Feb 25 14:44 servicefilteringtest*
-rwxr-xr-x 1 kpark kpark 1482503 Feb 25 14:44 servicehidingtest*
-rwxr-xr-x 1 kpark kpark 5371826 Feb 25 14:44 stagedeventmetadataretrievaltest*
-rwxr-xr-x 1 kpark kpark 5230334 Feb 25 14:44 summaryresultsettest*
-rwxr-xr-x 1 kpark kpark 5159299 Feb 25 14:44 summarytest*
-rwxr-xr-x 1 kpark kpark 4978003 Feb 25 14:44 systemclienteventrepositorytest*
-rwxr-xr-x 1 kpark kpark 5197127 Feb 25 14:44 systemclienteventtest*
-rwxr-xr-x 1 kpark kpark 4167294 Feb 25 14:44 systemclienteventwindowdtttest*
-rwxr-xr-x 1 kpark kpark 4143268 Feb 25 14:44 systemclienteventwindowiptest*
-rwxr-xr-x 1 kpark kpark  278360 Feb 25 14:44 systemclientmetadataconfigtest*
-rwxr-xr-x 1 kpark kpark 1609246 Feb 25 14:44 systemclientservicerepositorytest*

test/metadata/Makefile.am

summarytest_SOURCES = SummaryTest.cpp $(metadata_helpers)
summarytest_LDADD = $(ldadd_static)

note: see that executables are all lowercases.


<log-from-jenkins>
Uranium.Client.System.log

PASS: systemclientservicerepositorytest


<build-from-pc-target>
zb-make Uranium/Uranium.Client.System


{run-test}
note: to run a single test and should match how it was built since it shall be run under virtual?

/data/builds/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/Uranium/Uranium.Client.System/test/metadata

./systemclienteventrepositorytest --cases SystemClientEventRepositoryTest::testGetSynopsis

itoryTest::testGetPresentEvent
Metadata source is DTT_ONLY
Overriding metadata source to DTT_ONLY

.2015-03-16 14:18:31,062 INFO   140235723970336 iron
/data/builds/_virtual_/pc/DEVARCH/Iron/IronReminders.System.Production/src/ProductionSystemFactory.cpp:43
Using configuration file:
/data/builds/_virtual_/pc/zinc-install-root/debug/debian-7-x86_64/tests/uranium-client-system/share/copper-system-factory.plugin-config

2015-03-16 14:18:31,063 INFO   140235723970336 iron
/data/builds/_virtual_/pc/DEVARCH/Iron/IronReminders.System.Production/src/ProductionSystemFactory.cpp:58
Using configuration file:
/data/builds/_virtual_/pc/zinc-install-root/debug/debian-7-x86_64/tests/uranium-client-system/share/metadata/iron-system-factory.plugin-config

2015-03-16 14:18:31,092 INFO   140235723970336 cadmium
/data/builds/_virtual_/pc/DEVARCH/Cadmium/Cadmium.System.Fake/src/FakeLinearAcquisition.cpp:40 Using
Cadmium DB file "/tmp/testmutabledatadir.6aPGJO/cadmium-system-fake/dvrdata.db"

2015-03-16 14:18:31,092 INFO   140235723970336 cadmium
/data/builds/_virtual_/pc/DEVARCH/Cadmium/Cadmium.System.Fake/src/FakeLinearAcquisition.cpp:44 Using
Nickel DB file "/tmp/testmutabledatadir.6aPGJO/nickel-system-fake/lmldata.db"

Caching media records...Caching services...done.
Caching PF...done.
done.

OK (1)


{xx}       
Uranium.Client.System/test/metadata/SystemClientEventRepositoryTest.cpp

<MOCK-EDIS>
struct ZINC_EXPORT Dispatcher : boost::noncopyable

class ZINC_EXPORT InlineDispatcher : public Dispatcher

typedef InlineDispatcher MultipleListenerEventDispatcher;


{system-component-mocks}

<1> system API
/*
 *	include/EventRepositoryAsync.h
 *
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 *	Template base-async.template
 *	Using
 *	/DEVARCH/Iron/Iron.System.API/data/introspection-xml/interface-EventRepository.xml
 */
namespace Zinc {
namespace Metadata {

class EventRepositoryEventListener;

class ZINC_EXPORT EventRepositoryAsync : 
    public virtual NS_ZINC::DispatchingEventProducer<EventRepositoryEventListener>
{

/* =============================== Methods ================================= */
public:

	virtual NS_ZINC::Future< std::vector< Event > > getPresentFollowing(const std::string& serviceLocator_in) = 0;

	virtual NS_ZINC::Future< Event > getEvent(const std::string& eventLocator_in) = 0;

   <getScheduleEvents>
	virtual NS_ZINC::Future< std::vector< Event > > getScheduleEvents(
           const std::vector< std::string >& serviceLocators_in, 
           const uint32_t startTime_in, const uint32_t endTime_in) = 0;

	virtual NS_ZINC::Future< std::vector< Event > > findByProgrammeCrid(
           const std::string& programmeCrid_in) = 0;

	virtual NS_ZINC::Future< std::vector< Event > > findBySeriesCrid(const std::string& seriesCrid_in) = 0;

protected:
	virtual ~EventRepositoryAsync();
};


<2>  system API mock

note: MockEventRepositoryAsync.h is from install root and see inheritance

/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */
namespace Zinc {
namespace Metadata {

class ZINC_LOCAL MockEventRepositoryAsync: public EventRepositoryAsync
{
public:
/* ============================== Methods ================================== */

	typedef std::vector< Event > Mock_getPresentFollowingRet;
	MOCK_METHOD1(getPresentFollowing, NS_ZINC::Future< Mock_getPresentFollowingRet > (const std::string&));

	typedef Event Mock_getEventRet;
	MOCK_METHOD1(getEvent, NS_ZINC::Future< Mock_getEventRet > (const std::string&));

   <getScheduleEvents>
	typedef std::vector< Event > Mock_getScheduleEventsRet;
	MOCK_METHOD3(getScheduleEvents, 
           NS_ZINC::Future< Mock_getScheduleEventsRet > 
           (const std::vector< std::string >&, const uint32_t, const uint32_t));

	typedef std::vector< Event > Mock_findByProgrammeCridRet;
	MOCK_METHOD1(findByProgrammeCrid, NS_ZINC::Future< Mock_findByProgrammeCridRet > (const std::string&));

	typedef std::vector< Event > Mock_findBySeriesCridRet;
	MOCK_METHOD1(findBySeriesCrid, NS_ZINC::Future< Mock_findBySeriesCridRet > (const std::string&));

/* ============================== Signals ================================== */
	void emitPresentFollowingChange(const std::string& serviceLocator, 
           const std::vector< Event >& events)
	{
		produceEvent(
			boost::bind(&EventRepositoryEventListener::PresentFollowingChange,
			     _1,
			     serviceLocator,
			     events));
	}

	void emitScheduleChange(const std::string& serviceLocator, 
           const uint32_t start, const uint32_t end, const std::vector< Event >& events)
	{
		produceEvent(
			boost::bind(&EventRepositoryEventListener::ScheduleChange,
			     _1,
			     serviceLocator,
			     start,
			     end,
			     events));
	}

	virtual ~MockEventRepositoryAsync() { };
};

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT MockEventRepositoryAsyncWithCallbacks : 
    public virtual NS_IRON_SYSTEM::MockEventRepositoryAsync // note: cannot find a def or file
{
public:
    void publicProduceEvent(boost::shared_ptr<NS_ZINC::Event> event) const
    {
        URANIUM_FUNC_TRACE;
        produceEvent(event);
    }
};


{use-mock-in-test}

note: this has overloads

void setUp()
{
    systemEventDispatcher = boost::make_shared<MultipleListenerEventDispatcher>();

    // create mock ER
    mockEventRepo = boost::make_shared<NS_IRON_SYSTEM::MockEventRepositoryAsync>();

    // this is not a mock function?
    mockEventRepo->setDispatcher(systemEventDispatcher);

    // create mock SR
    mockServiceRepo = boost::make_shared<NS_COBALT_SYSTEM::MockUnifiedServiceRepositoryAsync>();
    mockServiceRepo->setDispatcher(systemEventDispatcher);
}



void setUpClientFactory()
{
    clientFactory = TestSupport::createCobaltClientFactory();
}

    /**
     * Creates uranium::metadata::client::Factory and configures it for use in tests. 
     * Note: this no longer uses the plugin mechanism to get the client factory.
     * This is because the tests are linked with the static cobalt client system library.
     */
    SystemClientFactory* createCobaltClientFactory()
    {
        boost::shared_ptr<synchronisable_dispatcher> clientDispatcher = boost::make_shared<synchronisable_dispatcher>();
        clientDispatcher->start();
        
        SystemClientFactory* clientFactory = new SystemClientFactory();
        clientFactory->setDefaultDispatcher(clientDispatcher);
        clientFactory->setFutureDispatcher(clientDispatcher);
        return clientFactory;
    }


void setUp(MetadataSource source, bool useDTTHistory = true, bool skipPFCallsSetup = false, 
        bool enableEventCache = false, bool useBrokerMock = false)
{

    setUpClientFactory();

    if(!skipPFCallsSetup)
    {
        EXPECT_CALL(*mockEventRepo, getPresentFollowing(_))
            .WillRepeatedly(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>()));
    }
    clientFactory->setIronSystemEventRepository(mockEventRepo);

    EXPECT_CALL(*mockServiceRepo, getAllServices(true))
        .WillRepeatedly(returnNewCompletedFuture(getDefaultUnifiedServices(source)));
    clientFactory->setSystemUnifiedServiceRepository(mockServiceRepo);

    if(useBrokerMock)
    {
        mockMB = boost::make_shared<NS_COBALT_SYSTEM::MockMetadataBrokerAsync>();
        clientFactory->setSystemMetadataBroker(mockMB);
    }

    config = clientFactory->createMetadataConfig();
    config->overrideSource(source);
    if(source == IP_AND_DTT)
    {
        config->overrideStagedDataRetrieval(true);
    }

    config->overrideCache(enableEventCache);
    config->overrideUseHistoricDTTData(useDTTHistory);

    //Effectively disable PECache sanitization so that it doesn't interfere with this test.
    config->overrideInitialPECacheSanitisationDelay(3600);

    eventRepo = boost::dynamic_pointer_cast<SystemClientEventRepository>(
            clientFactory->createEventRepository());
    serviceRepo = clientFactory->createServiceRepository();
}


vector<NS_IRON_SYSTEM::Event> getBBC1Events()
{
    NS_IRON_SYSTEM::Event e1;
    NS_IRON_SYSTEM::Event e2;

    e1.serviceLocator = "dvb://233a..1044";
    e1.eventLocator = "dvb://233a..1044;1";
    e1.shortTitle["eng"] = "Title of e1";
    e1.start = 0;
    e1.publishedDuration = 100;

    e2.serviceLocator = "dvb://233a..1044";
    e2.eventLocator = "dvb://233a..1044;2";
    e2.shortTitle["eng"] = "Title of e2";
    e2.start = 200;
    e2.publishedDuration = 100;

    vector<NS_IRON_SYSTEM::Event> result;
    result.reserve(2);
    result.push_back(e1);
    result.push_back(e2);

    return result;
}


void testGetPresentEvent()
{
    //setup the mocks so that there is a present event on all services
    EXPECT_CALL(*mockEventRepo, getPresentFollowing(getDefaultUnifiedServices()[0].serviceLocator)).
            WillOnce(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>(1, getBBC1Events()[0])));

    EXPECT_CALL(*mockEventRepo, getPresentFollowing(getDefaultUnifiedServices()[1].serviceLocator)).
            WillOnce(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>(1, getCafeTVEvents()[0])));

    // note: set to 'unified'
    setUp(DTT_ONLY, true, true);

    // note: 'metadate'
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e = eventRepo->getPresentEvent(0);
    
    CPPUNIT_ASSERT_MESSAGE("There should be an event returned", e);
    
    // note: all are EAPIs
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].eventLocator, e->getIdentifier("locator"));
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].shortTitle["eng"], e->getTitle());
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].start, (uint32_t)to_time_t(e->getStart()));
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].publishedDuration, (uint32_t)e->getDuration());
}


{future-helpers-for-test}

/**
 * File:   FutureMockActions.h
 *
 * Created on 11 April 2013
 *
 * Copyright (c) 2013, YouView TV Ltd.
 */
#ifndef ZINC_COMMON_FUTUREMOCKACTIONS_H
#define	ZINC_COMMON_FUTUREMOCKACTIONS_H

#include "../async/Promise.h"
#include "../async/async-helpers.h"

#include <gmock/gmock.h>

NS_ZINC_OPEN

/**
 * These helper actions are for use with Google Mock objects.
 *
 * When returning a future from a mock object expectation, care is needed to
 * make sure a new future is created each time the expectation is matched.
 * This shows up as a problem when setCallback is called on the returned future.
 *
 * The problem is that when using something like:
 *
 * EXPECT_CALL( ... ).WillRepeatedly(Return(FunctionThatReturnsAFuture()));
 *
 * Google Mock will copy the future returned from `FunctionThatReturnsAFuture()`
 * and always return the same future. This doesn't work for instance if you ever
 * call setCallback() on that future, which will throw a
 * DuplicateFutureCallback error on subsequent calls.
 *
 * Even this doesn't work, surprisingly:
 *
 * EXPECT_CALL( ... ).WillOnce(Return(FunctionThatReturnsAFuture()))
 *                   .WillOnce(Return(FunctionThatReturnsAFuture()));
 *
 * Again, the same promise is returned. I'm not quite sure how that happens
 * though.
 *
 * This can be used like this:
 *
 * EXPECT_CALL( ... ).WillOnce(returnNewCompletedFuture(someValue))
 *
 */

ACTION(returnNewCompletedFuture) {
    return completedFuture();
}

ACTION_P(returnNewCompletedFuture, value) {
    return completedFuture<typename return_type::value_type>(value);
}

ACTION_P(returnNewExceptionalFuture, exception) {
    return exceptionalFuture<typename return_type::value_type>(exception);
}

NS_ZINC_CLOSE

#endif // ZINC_COMMON_FUTUREMOCKACTIONS_H


<future-helpers>
This simply complete a promise as if it's "really" completed.

template<typename T>
Future<T> completedFuture(const T& val);

Future<void> completedFuture();

/DEVARCH/Zinc/Zinc.Common/include/async/detail/async-helpers_Impl.h

template<typename T>
Future<T> completedFuture(const T& val) {
    Promise<T> p;
    p.complete(val);
    return p.getFuture();
}

/DEVARCH/Zinc/Zinc.Common/src/async/async-helpers.cpp

#include "../../include/async/async-helpers.h"

NS_ZINC_OPEN

Future<void> completedFuture(Dispatcher& dispatcher) {

    Promise<void> p(dispatcher);
    p.complete();
    return p.getFuture();
}

Future<void> completedFuture() {

    Promise<void> p;
    p.complete();
    return p.getFuture();
}

NS_ZINC_CLOSE


={============================================================================
*kt_dev_uv_stack_114* stack: build pc target

Unlike cross platform builds, build runs tests and pc target build fails if any test fails.

1. Fail to buile due to failure on tests/cobalt-system-api/test/dateparsingtest

Test name: N6cobalt6system15DateParsingTestE::test_calling_isDaylightSavingTime_with_DST_times

To solve this, need to do:

export TZ="Europe/London"


2. Various failure on some python tests such as Rubidium/Rubidium.System.Production

The reason is that python script has "#!/bin/env python" which expect /bin/env but there is not. So

$ sudo ln -s /usr/bin/env /bin/env

Make a build success.


={============================================================================
*kt_dev_uv_stack_115* stack: text epg

./Uranium.Client.System/src/metadata/tools/textEPG.cpp

https://wiki.youview.co.uk/display/YVFDT/2014/04/09/TextEPG+howto?src=search

TextEPG is a a little text based app that lets you view the schedule data that the UI consumes via
the ctv.enhancedmetadata.EventWindow interface. It can be very useful for debugging. Just type
textEPG on in an ssh/telnet session on the box textEPG

you should then see something like this: text based epg using ncurses

Present events are marked with an asterisk.

You can navigate the window using the WASD keys.  

You can view just DTT, just IP, or merged DTT/IP data (this last is what the UI uses, assuming you
        have accepted T&Cs and have a network connection)

[root@HUMAX /]# textEPG --help
Invalid data source
Usage: textEPG [ip | dtt |stagedip] [<number of services> <number of seconds>]
The numbers specify the dimensions of the epg window.

Other options :

+ / - keys cycle through a subset of the available 'fields' in each event, e.g. title, event
locator, service record identifier.  It a field is missing, then it will need adding in the textEPG
source, see Devarch, or find a book on ncurses.

Running on a read only box

If you get terminal related  error running the textEPG on a read only box, try this first
export TERMINFO=/opt/zinc/oss/share/terminfo

The textEPG was created several years ago (by Jarek in Devarch), as a diagnostic tools to help in
testing/development of the EventWindow API in the CAL, and has not had much love since then. It was
designed to show the schedule data from the CAL, back when that was the main cache of event data
used by the UI. Since the implementation of IP channels, a lot of the event information that was
previously cached in the CAL has moved down to the Unified Event Repository. The textEPG still seems
to work, as it just fetches an EventWindow and renders it in text, but YMMV.

/data/builds/DEVARCH-9135/pc/zinc-install-root/debug/debian-7-x86_64/devel/bin/textEPG

box: /opt/zinc-trunk/devel/bin/textEPG
box: /opt/zinc/devel/bin/textEPG


={============================================================================
*kt_dev_uv_stack_116* stack: future

{futurecontext}

<FCB>
/**
 * This class provides context to a dispatcher about async function calls
 *
 * Intrusively reference counted by Futures, Promises, and FutureDispatchers
 * The intrusive_ptr implementation keeps the size of client facing objects
 * Future<T>, Promise<T>, FutureValue<T>, Chunk<T> small
 *
 */
class ZINC_EXPORT FutureContextBase : boost::noncopyable
{
public:

	virtual ~FutureContextBase();
	virtual bool dispatchNextResult() = 0;

	virtual void dispatchCancellation() = 0;

	/**
	 * Wait for this async op to complete
	 */
	void wait();

	/**
	 * Wait for this async op to complete, with a time out
	 * specified with a time duration
	 *
	 * @see Future<T>::wait_for()
	 */
	template<typename duration_type>
	bool wait_for(const duration_type &rel_time)
	{
		monotonic_clock::time_point abs_time = monotonic_clock::now() + rel_time;
		return wait_until(abs_time);
	}

	/**
	 * Wait for this async op to complete, with a time out
	 * specified with a time point
	 *
	 * @see Future<T>::wait_until()
	 */
	template<typename time_point_type>
	bool wait_until(const time_point_type &abs_time)
	{
		boost::mutex::scoped_lock lock(mutex);
		while (!completed)
		{
			const bool signalled = cond.wait_until(lock, abs_time);
			if (!signalled && !completed)
				return false; // we timed out, without a completion and without a cancellation
		}
		return true;
	}

	/**
	 * Does the moral equivalent to
	 *     dispatcher.post(bind(FutureContextBase::dispatchNextResult, this));
	 *
	 * WARNING: dispatchNextResult may be called synchronously and
	 *          re-entrantly by this function.
	 */
	void scheduleCallback();

	void scheduleCancellationCallback();

protected:

	explicit FutureContextBase(NS_ZINC::FutureDispatcher* dispatcher_);

	/**
	 * Mark this future as having a completion handler
	 *
	 * Must be called with the future locked
	 */
	void markCallback();

public:
	boost::detail::atomic_count refCount;
	boost::detail::atomic_count promiseCount;
public:
	bool completed;
	FutureDispatcher* dispatcher;
	FutureDispatcher* clientDispatcher;
	static boost::condition_variable cond;
	static boost::mutex mutex;
private:
	FutureContextBase(); // forbid default construction
};

FutureContextBase::FutureContextBase(NS_ZINC::FutureDispatcher* dispatcher_) :
	refCount(0),
	promiseCount(0),
	completed(false),
	dispatcher(dispatcher_),
	clientDispatcher(dispatcher_)
{}

<FCCI>
class ZINC_EXPORT FutureContextCommonImpl : public NS_ZINC::FutureContextBase
{
	explicit FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_);

	// The state of the promise and the future can evolve semi-independently
	promise_state::Enum promiseState;
	bool callCancellationCallback;
	boost::function<void ()> cancellationCallback;
};

FutureContextCommonImpl::FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_)
 : FutureContextBase(dispatcher_),
   forDispatch(false),
   futurevalueState(futurevalue_state::value_or_error),
   shouldCallCompletionHandler(true),
   promiseState(promise_state::incomplete),
   callCancellationCallback(true)
{
}

<FC>
/**
 * A context object for Futures
 * FutureContext holds a single value passed from a providing Promise and the client Future
 * and (if set) a completionHandler that is called by the dispatcher when the value is available
 */
template <typename T>
class FutureContext : public FutureContextCommonImpl
{
public:

	explicit FutureContext(NS_ZINC::FutureDispatcher* dispatcher_)
		: FutureContextCommonImpl(dispatcher_)
	{}

	/**
	 * Type specific completion code called from Promise::complete()
	 *
	 * Take a copy of the result from the Promise and stash it in FutureContext,
	 * complete() marks this FutureContext as completed, and post() hands
	 * it over to the dispatcher
	 *
	 * @see FutureContextBase::complete()
	 * @see FutureContextBase::post()
	 */
	void set(const T & result)
	{
		boost::mutex::scoped_lock lock;
		if (runPreSetChecksAndLock(lock)) {
			value = result;
		}
		doPostSetActionsAndUnlock(lock);

      // note: this will post functor to dispatcher thread
      //
      // void FutureContextBase::scheduleCallback()
      // {
      // 	assert(clientDispatcher);
      // 	boost::intrusive_ptr<FutureContextBase> ip(this);
      // 	clientDispatcher->post(boost::bind(&FutureContextBase::dispatchNextResult, ip));
      // 	cond.notify_all();
      // }
	}
	
	template <typename Handler>
	void setCallback(const Handler& fn, FutureDispatcher* clientDispatcher_) {
		setCallbackHoisted(boost::function<void (FutureContextBase*)>(
			makeCallbackHoistingWrapper<T>(boost::bind<void>(fn, _1))),
			clientDispatcher_
		);
	}

	T value;
};


void FutureContextCommonImpl::setCallbackHoisted(boost::function<void (FutureContextBase*)> fn, 
        FutureDispatcher* clientDispatcher_)
{
    // It is safe to read this->clientDispatcher without holding the lock because
    // it is word sized and will only be assigned to at initialisation time and
    // below (where it's guaranteed to be assigned to only once).
    FutureDispatcher* d = clientDispatcher_ ? clientDispatcher_ : this->clientDispatcher;
    if (!d) {
        throw CallbackSetWithoutDispatcherException();
    }
    Dispatcher::work tryWork(*d);

    boost::mutex::scoped_lock lock(this->mutex);

    if (!shouldCallCompletionHandler)
    {
        throw NS_ZINC::CancelledFuture();
    }
    if (forDispatch)
    {
        throw DuplicateFutureCallback();
    }
    // Client can choose an alternate dispatcher when they call setCallback()
    clientDispatcher = d;
    this->work.swap(tryWork);
    completionHandler = fn;
    forDispatch = true; // we are responsible for dispatching the completion handler
    bool oldCompleted = completed;
    lock.unlock();
    if (oldCompleted)
    {
        scheduleCallback();
    }
}


<futurevalue>

class FutureValueBase
{
	friend class internal::PolymorphicFutureValue;

public:

	/**
	 * Retrieve exception as an ErrorCode.
	 *
	 * In the success case, there will be no exception so this method will return
	 * a default-constructed ErrorCode, where the not operator (!) will return true.
	 * So, you can test whether an error occurred by doing:
	 *
	 *     if (!futureValue.getError()) {
	 *         // no error
	 *     }
	 *
	 * @return an ErrorCode wrapper around the exception that occurred in the
	 * asynchronous operation.
	 */
	const ErrorCode& getError() const;

protected:

	explicit FutureValueBase(const boost::intrusive_ptr<detail::FutureContextCommonImpl> & context) ZINC_EXPORT;

	~FutureValueBase() ZINC_EXPORT;

	boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
	detail::futurevalue_state::Enum state;
};


template<>
class FutureValue<void> : public FutureValueBase
{
	friend FutureValue<void> makeFutureValue();
};

// FutureValue_Impl.h

inline FutureValue<void> makeFutureValue()
{
    detail::FutureContext<void>* fc = new detail::FutureContext<void>(NULL);
    FutureValue<void> f(fc);
    fc->set();
    return f;
}


<future>

#ifndef ZINC_FUTURE_H_

template <typename T> class Promise;

namespace detail {
template <typename T> class FutureContext;
}

namespace internal {
class PolymorphicFuture;
}

class Dispatcher;

class FutureBase 
{
    friend class internal::PolymorphicFuture;

    public:

    /**
     * Cancel the Future.
     *
     * This merely prevents the Future ever being fulfilled. If a callback
     * has been set, and not called already, it will not be called.
     *
     * Cancellation may, or may not, cause the underlying asynchronous operation to be
     * canceled. The client should not assume this to be the case.
     *
     * Cancellation may be modified with the flags argument.
     *  * future.cancel(clear_callback) just prevents the
     *    callback set with setCallback from being invoked.
     *  * future.cancel(deep) calls the onCancel handler that may have been
     *    provided promise-side
     *  * future.cancel(immediately) has behaviour equivalent to the Promise
     *    being immediately completed with a CancelledFuture exception.  If the
     *    promise has already been completed calling get() will still cause a
     *    CancelledFuture exception to be thrown.
     *  * future.cancel(0) does nothing.
     */
    void cancel(unsigned flags = cancel_flag::clear_callback |
            cancel_flag::deep |
            cancel_flag::immediately);


    /**
     * Synchronously wait for the value to become available.
     *
     * This will block the calling thread until either the value is available,
     * or an exception occurs.
     *
     * When the caller returns from this call, a subsequent call to get() will not
     * block.
     */
    void wait();

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as a relative time duration
     *
     * eg
     *		Future<int> f = fn_returning_a_future();
     *		f.wait_for(boost::posix_time::milliseconds(500));
     *
     * @param rel_time specifies the time duration to wait for completion
     * @return false if the given time period elapses without completion or cancellation
     * @see wait()
     */
    template<typename duration_type>
        bool wait_for(const duration_type &rel_time);

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as an absolute time point
     *
     * Use wait_for() in preference
     *
     * @param abs_time specifies the time point to stop waiting
     * @return false if we reach the given time point without completion or cancellation
     *
     * @see wait()
     * @see wait_for()
     */
    template<typename time_point_type>
        bool wait_until(const time_point_type &abs_time);


    /**
     * Ask if the Future has been completed with a value provided by its Promise
     *
     * A positive response does not guarantee that the callback has yet been executed
     *
     * @return true if this Future has been completed
     */
    bool isComplete();

    /**
     * Has this Future been default constructed?  If so, then it is not useful
     *
     * @see Future<T>::swap
     * @see Promise<T>::getFuture
     *
     * @return false if this Future is valid
     */
    bool isEmpty();


    protected:

    explicit FutureBase(boost::intrusive_ptr<detail::FutureContextCommonImpl> context) ZINC_EXPORT;

    FutureBase(const FutureBase& other) ZINC_EXPORT;

    FutureBase() {}

    ~FutureBase() ZINC_EXPORT;

    void baseSwap(FutureBase& other);

    boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
};


/**
 * A Future is a token for some value that will be delivered asynchronously.
 *
 * The holder of the Future token may either wait for the value synchronously,
 * (blocking the executing thread), or set a callback method that will be invoked
 * either when the value becomes available, or will not become available due to
 * some exception.
 *
 * The Future holder also has the option to cancel the Future, which will prevent
 * the value from being delivered, assuming this hasn't happened already.
 */
template <typename T>
class Future : public FutureBase
{
    public:
        typedef T value_type;

        Future(const Future & other);

        Future & operator=(const Future & other);

        ~Future();

        /**
         * Provide a default constructor so we can put Futures in
         * STL containers
         *
         * A Future without a Promise is not much use to you,
         * so use Promise.getFuture() instead, or use swap(Future<T> & other)
         * to swap in a valid future
         *
         * @see Promise<T>::getFuture()
         * @see Future<T>::swap(Future<T> & other)
         */
        Future() {}

        /**
         * Set a callback method to be invoked when either the value becomes
         * available, or an exception occurs.
         *
         * The callback will be executed on the dispatcher that was provided to
         * the Promise constructor.
         *
         * @param fn A function that must accept a FutureValue<T> as it's single
         *           argument.
         *
         * @throws DuplicateFutureCallback if a callback has already been set on
         * this Future.
         * @throws CallbackSetWithoutDispatcherException if the corresponding
         *         wasn't initialized with a dispatcher.  Use the two argument
         *         setCallback instead
         */
        template <typename Handler>
            void setCallback(const Handler& fn) {
                // fn(x) must be valid where x is a FutureValue<T>
                ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
                static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, 0);
            }

        /**
         * Set a callback method to be invoked when either the value becomes
         * available, or an exception occurs.
         *
         * The callback will be executed on the provided dispatcher, rather than the
         * dispatcher used by the Promise.
         *
         * Explicitly providing the dispatcher gives the caller more control over
         * which thread will execute their callback.
         *
         * @param dispatcher_ The dispatcher on which the callback should be executed.
         *
         * @param fn A function that must accept a FutureValue<T> as it's single
         *           argument.
         *
         * @throws DuplicateFutureCallback if a callback has already been set on
         * this Future.
         */
        template <typename Handler>
            void setCallback(Dispatcher& dispatcher_, const Handler& fn) {
                // fn(x) must be valid where x is a FutureValue<T>
                ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
                static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, &dispatcher_);
            }

        /**
         * then() allows specifying a Functor to be called once the Future is
         * completed.  It is much like Future.setCallback() but for a Future<T> if
         * the functor has the form:
         *
         *     R Functor(FutureValue<T>)
         *
         * then then() will return a new Future of type Future<R> which will be
         * completed when the original Future completes and the functor has
         * operated on the original value.  The value/exception contained in the
         * new future will be that returned/thrown from the functor.  This makes
         * then() very convenient for transforming the value (and potentially the
         * type) contained within a `Future`.
         *
         * If a dispatcher is provided the functor will be executed on that
         * dispatcher.  Otherwise it will be run inline at the point and in the
         * context in which the `Promise` is completed or the setCallback is set
         * (whichever comes later).  As the environment in which the functor will
         * be run is unknown and even non-deterministic it is only safe to do the
         * simplest pure-functional transformations in these functors, e.g.
         * translating between exceptions/enum types, etc.  Anything dependent on
         * some state may require locking a mutex of similar and to make it
         * deterministic, safe and to avoid unexpected failures as changes are
         * made to other parts of the code the callbacks should be run on a user
         * specified `Dispatcher`.
         *
         *`Future.then()` is a proposed addition to the C++14 standard[1].
         *
         * [1]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3558.pdf
         *
         * Usage Example:
         *
         * @code
         * string boolToYesNo(FutureValue<bool> b) {
         *     try {
         *         return (b.get()?"yes":"no");
         *     } catch (const std::exception& e) {
         *         // translating exception thrown from original future.
         *         throw MyNewException(e.what());
         *     }
         * }
         *
         * Future<bool> answer = isCool();
         *
         * Future<string> answerAsString = answer.then(&boolToYesNo);
         *
         * cout << "Cool? " << answerAsString.get() << endl;
         * @endcode
         */
        template<typename Functor>
            Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
                    Dispatcher& dispatcher, Functor transformRtoT);
        template<typename Functor>
            Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
                    Functor transformRtoT);

        /**
         * Synchronously wait for and retrieve the value.
         *
         * This method may throw an exception of any type, in the event that the
         * value could not be retrieved due to an exception in the asynchronous
         * operation producing the value.
         *
         * Equivalent to f.getFutureValue().get();
         *
         * @return the value.
         */
        typename const_return<T>::type get();

        /**
         * Synchronously wait for and retrieve the value.
         *
         * Unlike get() this method does not throw if the promise has been completed
         * with an exception.  This can be used to deal with errors without a try
         * catch block.
         *
         * @return the value.
         */
        FutureValue<T> getFutureValue();

        /**
         * Swap this Future with the one provided
         */
        void swap(Future<T> & other);

    private:
        friend class Promise<T>; // only Promises can create a Future
        explicit Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ );

};

#endif


<future-impl>
#ifndef ZINC_FUTURE_INL

NS_ZINC_OPEN

inline void FutureBase::wait()
{
	context->wait();
}

template<typename duration_type>
inline bool FutureBase::wait_for(const duration_type &rel_time)
{
	return context->wait_for(rel_time);
}

template<typename time_point_type>
inline bool FutureBase::wait_until(const time_point_type &abs_time)
{
	return context->wait_until(abs_time);
}

inline bool FutureBase::isComplete()
{
	return context->completed;
}

inline bool FutureBase::isEmpty()
{
	return (context.get() == NULL);
}

inline void FutureBase::cancel(unsigned flags)
{
	context->cancel(flags);
}

inline void FutureBase::baseSwap(FutureBase& other)
{
	using std::swap;
	swap(context, other.context);
}


/**
 * Generic Future definitions
 */

template<typename T>
inline Future<T>::Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ ) : FutureBase(boost::static_pointer_cast<detail::FutureContextCommonImpl>(context_)) {}

template<typename T>
inline Future<T>::Future(const Future<T>& other) : FutureBase(other) {}

template<typename T>
inline Future<T>::~Future() {}

template<typename T>
inline Future<T>& Future<T>::operator=(const Future<T>& other)
{
	Future<T>(other).swap(*this);
	return *this;
}

template<typename T>
inline FutureValue<T> Future<T>::getFutureValue()
{
    wait();
    return FutureValue<T>(boost::static_pointer_cast<detail::FutureContext<T> >(context));
}

template<typename T>
inline typename const_return<T>::type Future<T>::get()
{
	return getFutureValue().get();
}

template<typename T>
inline void Future<T>::swap(Future<T> & other)
{
	 baseSwap(other);
}

/**
 * Future<void> definitions
 */
template<>
inline void Future<void>::get()
{
	wait();
	// get() may throw
	FutureValue<void>(boost::static_pointer_cast<detail::FutureContext<void> >(context)).get();
}

namespace detail {

template<typename T, typename R, typename Functor>
struct DoTransformAndComplete {
    static inline void apply(Promise<R>& promise, Functor& transform, const FutureValue<T>& fv) {
        promise.complete(transform(fv));
    }
};

template<typename T, typename Functor>
struct DoTransformAndComplete<T, void, Functor> {
    static inline void apply(Promise<void>& promise, Functor& transform, const FutureValue<T>& fv) {
        transform(fv);
        promise.complete();
    }
};

template<typename T, typename Functor>
struct TransformAndComplete {

    typedef typename boost::result_of<Functor(FutureValue<T>)>::type R;

    TransformAndComplete(const Functor& f)
     : transform(f) {}

    void operator()(const FutureValue<T>& fv) {
        try {
            DoTransformAndComplete<T, R, Functor>::apply(promise, transform, fv);
        } catch (const std::exception& e) {
            promise.exception(e);
        } catch (...) {
            promise.exception(std::runtime_error("Unknown exception."));
        }
    }

    Promise<R> promise;
    Functor transform;
};

template<typename FutureLike, typename Functor>
Future<typename boost::result_of<Functor(FutureValue<typename FutureLike::value_type>)>::type> futureThen(
        FutureLike& future, Dispatcher& dispatcher, Functor transformTtoR) {

    detail::TransformAndComplete<typename FutureLike::value_type, Functor>
        transformAndComplete(transformTtoR);
    future.setCallback(dispatcher, transformAndComplete);
    return transformAndComplete.promise.getFuture();
}
} // namespace detail

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Dispatcher& dispatcher, Functor transformTtoR) {

    return detail::futureThen(*this, dispatcher, transformTtoR);
}

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Functor transformTtoR) {

    return then(InlineDispatcher::sharedInstance(), trantsformTtoR);
}                                                       i
                                                        {
#endif                                                   
                                                        }


<future-barrier>

class Dispatcher;
typedef Dispatcher FutureDispatcher;

namespace detail {
    template <typename Functor> class BarrierWrapper;
    class FutureBarrierImpl;
}

/**
 * FutureBarrier is designed to aid synchronisation when making multiple
 * asynchronous calls simultaneously.  FutureBarrier will call a given
 * callback asynchronously once all the futures added to it have
 * completed AND the FutureBarrier itself has gone out of scope.
 *
 * (NOTE: This means you must not keep a FutureBarrier alive after the method
 * creating it returns; for example you must not pass around a shared_ptr to a
 * FutureBarrier, and you must not make a FutureBarrier be a member of your
 * class.)
 *
 * FutureBarrier is "FutureLike" in that it defines the functions setCallback
 * and cancel() and thus can be used as an argument to
 * Continuation::setCallback();
 */
class FutureBarrier : boost::noncopyable {
public:
    typedef void value_type;

    /**
     * Constructor
     */
    explicit FutureBarrier(FutureDispatcher& dispatcher);
    ~FutureBarrier();

    /**
     * Add a Future to the barrier to delay the FutureBarrier from completing
     * until the Future has completed.
     *
     * @param f The future to add. This can be any "FutureLike" object, such
     *          as a Future, a Continuation, or even another FutureBarrier.
     *
     * @param c Callback to be called when the future "f" completes
     *          *successfully*. It must have the signature:
     *              void SuccessCallback(T);
     *          where T is the value_type of the future "f".
     *          Note that the parameter is T, not FutureValue<T>.
     *          If the future "f" completes with an error, this callback will
     *          not be called; and the "final" callback (set with setCallback)
     *          will (eventually, once all other futures have completed) be
     *          called with an error.
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     *
     * Note: The FutureDispatcher you use should provide the guarantee that all
     * callbacks will be dispatched on the same thread (which may be a
     * different thread than the thread where you create the FutureBarrier and
     * call addWithSuccessCallback). This way, the various callbacks you set
     * with addWithSuccessCallback don't need to worry about synchronisation
     * issues.
     */
    template <class FutureLike, typename SuccessCallback>
    void addWithSuccessCallback(FutureLike f, SuccessCallback /* void (T) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * This is distinct from addWithSuccessCallback in that this is called with a
     * FutureValue<T> rather than just T, thus allowing finer grained control
     * of error conditions.
     *
     * @param f The future to add.
     *
     * @param c The function to call once the future "f" is complete.
     *          It must have the signature:
     *              void Callback(FutureValue<T>);
     *          where T is the value_type of the future "f".
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     */
    template <class FutureLike, typename Callback>
    void addWithCallback(FutureLike f, Callback /* void (FutureValue<T>) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * The value returned by the completed future is ignored, as long as it is
     * not an error. An error will cause this FutureBarrier to complete with
     * the error, just like addWithSuccessCallback.
     *
     * @param f The future to add.
     */
    template <class FutureLike>
    void add(FutureLike f);

    /**
     * Cancel the FutureBarrier.  The behaviour of this function depends on the
     * template parameter CancellationPolicy.
     */
    void cancel(unsigned flags);

    /**
     * Set the "final" callback method to be invoked after all of the barrier's
     * Futures have completed, successfully or otherwise.
     *
     * @param c The function to call once all the futures have completed.
     *          This function should have the signature:
     *              void (FutureValue<void>);
     *          In this way FutureBarrier is interface compatible with
     *          Future<void>.
     */
    template <typename Callback>
    void setCallback(Callback c) const;

    template <typename Callback>
    void setCallback(FutureDispatcher& dispatcher, Callback c);
private:
    template <typename Functor, typename ValueType> friend class detail::BarrierWrapper;
    detail::FutureBarrierImpl* impl;
};


// Callback is a functor with the signature:
//     void (FutureValue<T>);
template <class FutureLike, typename Callback>
inline void FutureBarrier::addWithCallback(FutureLike f, Callback c) {
    typedef typename FutureLike::value_type T;
    // Concept check for nicer error messages:
    ZINC_CHECK_CONCEPT(( c(LValue<FutureValue<T> >()) ));

    impl->continueOn(f, boost::bind(c, _2));
}


// Callback is a functor with the signature:
//     void (FutureBarrierImpl&, FutureValue<T>);
template <class FutureLike, typename Callback>
void FutureBarrierImpl::continueOn(FutureLike f, Callback c) {
    typedef typename FutureLike::value_type T;
    // Concept check for nicer error messages:
    ZINC_CHECK_CONCEPT(( c(*this, LValue<FutureValue<T> >()) ));

    inc();
    // FIXME: if Callback copy constructor fails we leak
    f.setCallback(dispatcher, detail::barrierWrap(this, c));
}


<promise>
#ifndef ZINC_PROMISE_H_

namespace internal{
class PolymorphicPromise;
}

/**
 * Base class for Promises which contain different types.  This can be useful
 * when hoisting to reduce object code size.
 */
class PromiseBase : boost::noncopyable 
{
    friend class internal::PolymorphicPromise;

    public:

    /**
     * Complete this Promise with a zinc::ErrorCode
     *
     * @param error the error code value
     *
     * @throws PromiseAlreadyCompleted if this Promise has already been completed
     */
    void error(const NS_ZINC::ErrorCode& error);

    /**
     * Complete this Promise with an exception
     *
     * @param e the exception
     *
     * @throws PromiseAlreadyCompleted if this Promise has already been completed
     */
    void exception(const std::exception& e);

    /**
     * Ask if this async operation has been completed with a value
     *
     * @return true if the async operation associated with this Promise has been completed
     */
    bool isComplete() const;

    protected:

    // Destructor and Constructor are protected to prevent deletion through the
    // base class.  If you want to store a Promise polymorphically use
    // PolymorphicPromise.
    ~PromiseBase() ZINC_EXPORT;

    explicit PromiseBase(detail::FutureContextCommonImpl*) ZINC_EXPORT;

    PromiseBase(const PromiseBase& other) ZINC_EXPORT;

    boost::intrusive_ptr<detail::FutureContextCommonImpl> context;

    void baseSwap(PromiseBase& other);
};


/**
 * A Promise provides the API to set the result of an asynchronous operation,
 * signal the caller, and trigger dispatch of any associated completion handlers
 */
template<typename T>
class Promise : public PromiseBase
{
    public:
        /**
         * Construct a Promise for an asynchronous operation.
         *
         * If a dispatcher is passed the deprecated single-argument
         * Future::setCallback which does not take a Dispatcher may be used on the
         * Future returned from getFuture().  In this case the callback will be
         * executed on the Dispatcher passed here.  This is a deprecated mode of
         * use.
         *
         * Using the default Promise constructor and the two argument Future
         * setCallback is strongly recommended in new code.  The single argument
         * Promise constructor is likely to be deprecated in the future.
         *
         * If a cancellation callback is provided it will be executed on the
         * dispatcher provided here.
         */
        Promise();
        explicit Promise(Dispatcher& dispatcher_);
        explicit Promise(Dispatcher& dispatcher_,
                boost::function<void ()> cancelationCallback);

        Promise(const Promise<T> & other);

        Promise & operator=(const Promise<T> & other);

        /**
         * Swap this promise with the one provided
         */
        void swap(Promise<T> & other);

        /**
         * Create a Future for this Promise.
         *
         * The created Future can be used to access the result of this Promise.
         *
         * @return A Future used to access the result of this Promise
         */
        Future<T> getFuture();

        /**
         * Complete this Promise with a value and deliver the result to
         * all associated Futures
         *
         * @param value the result to be delivered
         *
         * @throws PromiseAlreadyCompleted if this Promise has already been completed
         */
        void complete(typename const_param<T>::type);
    private:
        detail::FutureContext<T>& getContext();
        // WARNING: DO NOT ADD MEMBERS HERE:
        //     PolymorphicPromise depends on Promise<T> having no additional members
        //     vs. PromiseBase
};


#include "detail/Promise_Impl.h"

#endif

// Zinc/Zinc.Common/src/async/FutureContext.cpp

PromiseBase::PromiseBase(detail::FutureContextCommonImpl* p)
 : context(p)
{
	if (context.get())
	{
		++context->promiseCount;
	}
}

<promise-impl>
#ifndef ZINC_PROMISE_IMPL_H_

#include "../Future.h"
#include "../async-exceptions.h"


inline void PromiseBase::baseSwap(PromiseBase& other)
{
	using std::swap;
	swap(context, other.context);
}

inline void PromiseBase::error(const NS_ZINC::ErrorCode& error)
{
	context->completeError(error);
}

inline void PromiseBase::exception(const std::exception& e)
{
	error(zinc::copyException(e));
}

inline bool PromiseBase::isComplete() const
{
	return context->completed;
}

template<typename T>
inline Promise<T>::Promise() :
	PromiseBase( new detail::FutureContext<T>(NULL) )
{
}

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_) :
	PromiseBase( new detail::FutureContext<T>(&dispatcher_) )
{
}

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_, boost::function<void ()> cancellationCallback_) :
	PromiseBase( new detail::FutureContext<T>(&dispatcher_, cancellationCallback_ ) )
{
}

template<typename T>
Promise<T>::Promise(const Promise<T> &other)
 : PromiseBase(other.context.get())
{
}

template<typename T>
Promise<T>& Promise<T>::operator=(const Promise<T> & other)
{
	Promise<T>(other).swap(*this);
	return *this;
}

template<typename T>
inline Future<T> Promise<T>::getFuture()
{
	return Future<T>(&getContext());
}

template<typename T>
inline void Promise<T>::complete(typename const_param<T>::type value)
{
	getContext().set(value);
}

template<typename T>
inline void Promise<T>::swap(Promise<T> & other)
{
    baseSwap(other);
}

template<typename T>
inline detail::FutureContext<T>& Promise<T>::getContext()
{
	return *static_cast<detail::FutureContext<T>* >(context.get());
}

// ** void specialization **

// This is the only method that actually needs to be different.
inline void Promise<void>::complete()
{
	getContext().set();
}

// But we have to repeat all these, because whole class is specialized.

inline Promise<void>::Promise() :
	PromiseBase( new detail::FutureContext<void>(NULL) )
{
}

inline Promise<void>::Promise(FutureDispatcher& dispatcher_) :
	PromiseBase( new detail::FutureContext<void>(&dispatcher_) )
{
}

inline Promise<void>::Promise(FutureDispatcher & dispatcher_, boost::function<void ()> cancellationCallback_) :
	PromiseBase( new detail::FutureContext<void>(&dispatcher_, cancellationCallback_) )
{
}

inline Promise<void> & Promise<void>::operator=(const Promise<void> & other)
{
	Promise<void>(other).swap(*this);
	return *this;
}

inline Promise<void>::Promise(const Promise<void> & other)
 : PromiseBase(other.context.get())
{
}

inline Future<void> Promise<void>::getFuture()
{
	return Future<void>(&getContext());
}

inline void Promise<void>::swap(Promise<void> & other)
{
    baseSwap(other);
}

inline detail::FutureContext<void>& Promise<void>::getContext()
{
	return *static_cast<detail::FutureContext<void>* >(context.get());
}

#endif 


<future-barrier>

class Dispatcher;
typedef Dispatcher FutureDispatcher;

namespace detail {
    template <typename Functor> class BarrierWrapper;
    class FutureBarrierImpl;
}

/**
 * FutureBarrier is designed to aid synchronisation when making multiple
 * asynchronous calls simultaneously.  FutureBarrier will call a given
 * callback asynchronously once all the futures added to it have
 * completed AND the FutureBarrier itself has gone out of scope.
 *
 * (NOTE: This means you must not keep a FutureBarrier alive after the method
 * creating it returns; for example you must not pass around a shared_ptr to a
 * FutureBarrier, and you must not make a FutureBarrier be a member of your
 * class.)
 *
 * FutureBarrier is "FutureLike" in that it defines the functions setCallback
 * and cancel() and thus can be used as an argument to
 * Continuation::setCallback();
 */
class FutureBarrier : boost::noncopyable {
public:
    typedef void value_type;

    /**
     * Constructor
     */
    explicit FutureBarrier(FutureDispatcher& dispatcher);
    ~FutureBarrier();

    /**
     * Add a Future to the barrier to delay the FutureBarrier from completing
     * until the Future has completed.
     *
     * @param f The future to add. This can be any "FutureLike" object, such
     *          as a Future, a Continuation, or even another FutureBarrier.
     *
     * @param c Callback to be called when the future "f" completes
     *          *successfully*. It must have the signature:
     *              void SuccessCallback(T);
     *          where T is the value_type of the future "f".
     *          Note that the parameter is T, not FutureValue<T>.
     *          If the future "f" completes with an error, this callback will
     *          not be called; and the "final" callback (set with setCallback)
     *          will (eventually, once all other futures have completed) be
     *          called with an error.
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     *
     * Note: The FutureDispatcher you use should provide the guarantee that all
     * callbacks will be dispatched on the same thread (which may be a
     * different thread than the thread where you create the FutureBarrier and
     * call addWithSuccessCallback). This way, the various callbacks you set
     * with addWithSuccessCallback don't need to worry about synchronisation
     * issues.
     */
    template <class FutureLike, typename SuccessCallback>
    void addWithSuccessCallback(FutureLike f, SuccessCallback /* void (T) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * This is distinct from addWithSuccessCallback in that this is called with a
     * FutureValue<T> rather than just T, thus allowing finer grained control
     * of error conditions.
     *
     * @param f The future to add.
     *
     * @param c The function to call once the future "f" is complete.
     *          It must have the signature:
     *              void Callback(FutureValue<T>);
     *          where T is the value_type of the future "f".
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     */
    template <class FutureLike, typename Callback>
    void addWithCallback(FutureLike f, Callback /* void (FutureValue<T>) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * The value returned by the completed future is ignored, as long as it is
     * not an error. An error will cause this FutureBarrier to complete with
     * the error, just like addWithSuccessCallback.
     *
     * @param f The future to add.
     */
    template <class FutureLike>
    void add(FutureLike f);

    /**
     * Cancel the FutureBarrier.  The behaviour of this function depends on the
     * template parameter CancellationPolicy.
     */
    void cancel(unsigned flags);

    /**
     * Set the "final" callback method to be invoked after all of the barrier's
     * Futures have completed, successfully or otherwise.
     *
     * @param c The function to call once all the futures have completed.
     *          This function should have the signature:
     *              void (FutureValue<void>);
     *          In this way FutureBarrier is interface compatible with
     *          Future<void>.
     */
    template <typename Callback>
    void setCallback(Callback c) const;

    template <typename Callback>
    void setCallback(FutureDispatcher& dispatcher, Callback c);
private:
    template <typename Functor, typename ValueType> friend class detail::BarrierWrapper;
    detail::FutureBarrierImpl* impl;
};



={============================================================================
*kt_dev_uv_stack_117* stack: future use

<0> promise and future creation

EPG uses this:
Package ctv.enhancedmetadata, Interface public interface EventRepository::getEventWindow

Future<boost::shared_ptr<EventWindow> > SystemClientEventRepository::getEventWindow(
        uint32_t startingServiceRow, uint32_t serviceCount,
        boost::posix_time::ptime startTime, int32_t seconds,
        event_collection_ptr intersectingEvents, Bounds missing,
        bool isMovingForward)
{
    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > p(*getFutureDispatcher());

    // explicit Promise(Dispatcher& dispatcher_);
    //
    // template<typename T>
    // inline Promise<T>::Promise(FutureDispatcher& dispatcher_) :
    //
    //   // note: 'new' FC
    //   PromiseBase( new detail::FutureContext<T>(&dispatcher_) )
    //   {}
    //
    // boost::intrusive_ptr<detail::FutureContextCommonImpl> context;
    //
    // PromiseBase::PromiseBase(detail::FutureContextCommonImpl* p)
    //  : context(p)
    // {
    //   // note: get is member of intrusive_ptr
    // 	if (context.get())
    // 	{
    // 		++context->promiseCount;
    // 	}
    // }

    getEventsFromSystemAPI(cmd);

    return p.getFuture();

    // note: ?? since there seems no Future<T>(FC&). HOW?
    //
	 // Future(const Future & other);
    //
    // template<typename T>
    // inline Future<T> Promise<T>::getFuture()
    // {
    // 	return Future<T>(&getContext());
    // }
    //
    // note: return a reference
    //
    // template<typename T>
    // inline detail::FutureContext<T>& Promise<T>::getContext()
    // {
    // 	return  *static_cast< detail::FutureContext<T>* >(context.get());
    // }
}


<1> call dbus call, set callback with dbus call future, and add future and callback pair to future
barrier. does it mean that FB copies future since fMasEvents is local?

void SystemClientEventRepository::getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
{
    NS_ZINC::FutureBarrier bar(*getFutureDispatcher());

    // 'cobalt' callback
    void (SystemClientEventRepository::*masCallback)
        (boost::shared_ptr<EventWindowCreateCommand>,
         const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result > > &) =
        &SystemClientEventRepository::eventsReceived;

    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
        metadataBroker->getEventSummariesByServices(recids, start, end);

    bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));
}


<2> when future is signaled from dbus

::FutureBar    <- from components on dbus?


<3> calls registered callback from FB.

void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
        const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
{
    // get reference of vector from a future   
    const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();
}


={============================================================================
*kt_dev_uv_stack_118* stack: metadata and dbus

# from lsdbus

1287  :1.57                    /opt/zinc/bin/ironmetadatad.oem                 
1287  Zinc.Metadata            /opt/zinc/bin/ironmetadatad.oem                 

# 'iron'
# /Iron/Iron.System.API/data/introspection-xml/service.xml
# note: see bus name
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0" name="/" yv:busname="Zinc.Metadata">
    <node name="Zinc/Metadata/EventRepository">
        <interface name="Zinc.Metadata.EventRepository"/>
    </node>
    <node name="Zinc/Metadata/RelatedContentRepository">
        <interface name="Zinc.Metadata.RelatedContentRepository"/>
    </node>
    <node name="Zinc/Metadata/ServiceRepository">
        <interface name="Zinc.Metadata.ServiceRepository"/>
    </node>
</node>


# 'cobalt'
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0" name="/" yv:busname="Zinc.Broker">
    <node name="Zinc/Broker/MetadataBroker">
        <interface name="Zinc.Broker.MetadataBroker"/>
    </node>
    <node name="Zinc/Broker/HiddenServicesStore">
        <interface name="Zinc.Broker.HiddenServicesStore"/>
    </node>
    <node name="Zinc/Broker/UnifiedServiceRepository">
        <interface name="Zinc.Broker.UnifiedServiceRepository"/>
    </node>
    <node name="Zinc/Broker/ProvisioningService">
        <interface name="Zinc.Broker.ProvisioningService"/>
    </node>
    <node name="Zinc/Broker/UnifiedEventRepository">
        <interface name="Zinc.Broker.UnifiedEventRepository"/>
    </node>
    <node name="Zinc/Broker/LinearAcquisitionServiceResolver">
        <interface name="Zinc.Broker.LinearAcquisitionServiceResolver"/>
    </node>
    <node name="Zinc/Broker/DeviceConfig">
        <interface name="Zinc.Broker.DeviceConfig"/>
    </node>
</node>


# note: auto generated to
# zinc-build-root/release-humax-dtr_t1000/Iron/Iron.System.API/include/SystemFactory.h

namespace Zinc {
namespace Metadata {

struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Metadata::EventRepository> createEventRepository() = 0;
    virtual boost::shared_ptr<Zinc::Metadata::RelatedContentRepository> createRelatedContentRepository() = 0;
    virtual boost::shared_ptr<Zinc::Metadata::ServiceRepository> createServiceRepository() = 0;
};
} //namespace
} //namespace


namespace Zinc {
namespace Broker {

struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> createMetadataBroker() = 0;
    virtual boost::shared_ptr<Zinc::Broker::HiddenServicesStore> createHiddenServicesStore() = 0;
    virtual boost::shared_ptr<Zinc::Broker::UnifiedServiceRepository> createUnifiedServiceRepository() = 0;
    virtual boost::shared_ptr<Zinc::Broker::ProvisioningService> createProvisioningService() = 0;
    virtual boost::shared_ptr<Zinc::Broker::UnifiedEventRepository> createUnifiedEventRepository() = 0;
    virtual boost::shared_ptr<Zinc::Broker::LinearAcquisitionServiceResolver> 
        createLinearAcquisitionServiceResolver() = 0;
    virtual boost::shared_ptr<Zinc::Broker::DeviceConfig> createDeviceConfig() = 0;

};
} //namespace
} //namespace


# from lsdbus

1055  :1.20                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  :1.45                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  Zinc.Broker              /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  Zinc.MetadataProxy       /opt/zinc-trunk/bin/cobaltmetadatabrokerd        

1237  :1.69                    /opt/stagecraft-2.0/bin/stagecraft --astrace --bgalpha 0 --outputrect
0,0,1280,720 --extensionsdir /opt/zinc-trunk/lib/stagecraft2-extensions --profile extendedTV
--modulemap IGraphicsDriver:/opt/stagecraft-2.0/bin/libIGraphicsDriver2.so /app        

# from dbus full log

method call sender=:1.20 -> dest=Zinc.Metadata serial=7034 path=/Zinc/Metadata/EventRepository; interface=Zinc.Metadata.EventRepository; member=getScheduleEvents

method return sender=:1.20 -> dest=:1.69 reply_serial=4682

   array [
      struct {
         string "12651407"
         int64 1426653570
         int64 1427284880
         int32 0
         array [
         ]
         array [
            dict entry(
               string "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"
               array [
                  string "dvb://233a..5a90;3cf"
               ]
            )
         ]
         array [
         ]
         array [
            dict entry(
               string "entityType"
               array [
                  string "scheduleevent"
               ]
            )
            dict entry(
               string "eventId"
               array [
                  string "12651407"
               ]
            )
            dict entry(
               string "eventTitle"
               array [
                  string "TruTV is on ch. 68..."
               ]
            )
            dict entry(
               string "isAdult"
               array [
                  string "0"
               ]
            )
            dict entry(
               string "mediumSynopsis"
               array [
                  string "...truTV +1 returns at 5am"
               ]
            )
            dict entry(
               string "owningServiceId"
               array [
                  string "10193572"
               ]
            )
            dict entry(
               string "start"
               array [
                  string "2015-03-25T09:00:00Z"
               ]
            )
         ]
         array [
            dict entry(
               string "classifiers"
               array [
                  struct {
                     array [
                        dict entry(
                           string "categoryScheme"
                           string "urn:dtg:metadata:cs:DTGGenreCS:2010-11"
                        )
                     ]
                     string "0"
                  }
               ]
            )
            dict entry(
               string "mediaContent"
               array [
                  struct {
                     array [
                        dict entry(
                           string "aspectRatio"
                           string "4:3"
                        )
                        dict entry(
                           string "audioLanguage"
                           string "eng"
                        )
                        dict entry(
                           string "audioMixType"
                           string "1"
                        )
                        dict entry(
                           string "contentDuration"
                           string "28800"
                        )
                        dict entry(
                           string "contentIsHighDefinition"
                           string "0"
                        )
                        dict entry(
                           string "format"
                           string "sd"
                        )
                        dict entry(
                           string "mediaType"
                           string "video"
                        )
                     ]
                     string ""
                  }
               ]
            )
         ]
      }
      struct {
         string "12655907"
         int64 1426654853
         int64 1427284880
         int32 0
         array [
         ]
         array [
            dict entry(
               string "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"
               array [
                  string "dvb://233a..a0b0;cca3"
               ]
            )
         ]
         array [
         ]
         array [
            dict entry(
               string "entityType"
               array [
                  string "scheduleevent"
               ]
            )
            dict entry(
               string "eventId"
               array [
                  string "12655907"
               ]
            )
            dict entry(
               string "eventTitle"
               array [
                  string "FIM X-Trial World Championship"
               ]
            )
            dict entry(
               string "isAdult"
               array [
                  string "0"
               ]
            )
            dict entry(
               string "mediumSynopsis"
               array [
                  string "Coverage from the X-Trial World Championship where the world's 
                  top riders attempt to clear a series of near-impossible obstacles in the 
                  fastest time. Action from Wiener Neustadt (Austria)."
               ]
            )
            dict entry(
               string "owningServiceId"
               array [
                  string "10672980"
               ]
            )
            dict entry(
               string "start"
               array [
                  string "2015-03-25T09:00:00Z"
               ]
            )
         ]
         array [
            dict entry(
               string "classifiers"
               array [
                  struct {
                     array [
                        dict entry(
                           string "categoryScheme"
                           string "urn:dtg:metadata:cs:DTGGenreCS:2010-11"
                        )
                     ]
                     string "0"
                  }
               ]
            )
            dict entry(
               string "mediaContent"
               array [
                  struct {
                     array [
                        dict entry(
                           string "aspectRatio"
                           string "16:9"
                        )
                        dict entry(
                           string "audioLanguage"
                           string "eng"
                        )
                        dict entry(
                           string "audioMixType"
                           string "2"
                        )
                        dict entry(
                           string "contentDuration"
                           string "3900"
                        )
                        dict entry(
                           string "contentIsHighDefinition"
                           string "0"
                        )
                        dict entry(
                           string "format"
                           string "sd"
                        )
                        dict entry(
                           string "mediaType"
                           string "video"
                        )
                     ]
                     string ""
                  }
               ]
            )
         ]
      }
      ...
   ]


={============================================================================
*kt_dev_uv_stack_119* stack: sandbox


/opt/zinc-trunk/lib/sandbox/application-yv.conf

##
# This is a common configuration file for application sandbox.
# It specifies all directories that are imported "as is" from the real
# file system into the sandbox.
#
# This file is managed by YouView and is not to be modified by OEMs.
#
# Note that following directories are already in the sandbox and they are
# "special":
#
# /opt/zinc-trunk/var/log
# /opt/zinc-trunk/var/http-cache
# /app
# /app-data
# /opt/adobe/stagecraft/data
# /proc
# /dev
# /tmp
####

[directories]
# system
/lib
/usr/lib
/usr/local/lib
/usr/local/etc

# TODO: Remove
/bin
# TODO: Remove
/usr/bin

# users, groups, networking...
/etc

# YV stack
/opt/zinc-trunk/lib
/opt/zinc-trunk/share
/opt/zinc-trunk/share/platform_data
/opt/zinc-trunk/devel/lib
/opt/zinc-trunk/devel/share
/opt/zinc-trunk/oss/var/applications/identities
/opt/zinc-trunk/oss/lib

# TODO: Remove
/opt/zinc-trunk/bin
/opt/zinc-trunk/devel/bin
# TODO: Remove
/opt/zinc-trunk/oss/bin

# certificates
/opt/youview/pki

# DirectFB
/run/dfb

# Application type specific configuration is specified in application-yv.d
# directory

[options]
StdOut=/dev/console
StdErr=/dev/console


<ex>

/proc/1606/root

root# ll
-r--------    1 16385    yv_signe         0 Apr  2 16:49 auxv
--w-------    1 16385    yv_signe         0 Apr  2 16:49 clear_refs
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 cmdline
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 coredump_filter
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:49 cwd -> /run/youview/jail/applications/1
-r--------    1 16385    yv_signe         0 Apr  2 16:49 environ
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:52 exe -> /run/youview/jail/applications/1/opt/zinc-trunk/bin/w3cEngine
dr-x------    2 16385    yv_signe         0 Apr  2 16:52 fd
dr-x------    2 16385    yv_signe         0 Apr  2 16:49 fdinfo
-r--------    1 16385    yv_signe         0 Apr  2 16:49 limits
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 maps
-rw-------    1 16385    yv_signe         0 Apr  2 16:49 mem
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 mountinfo
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 mounts
-r--------    1 16385    yv_signe         0 Apr  2 16:49 mountstats
dr-xr-xr-x    4 16385    yv_signe         0 Apr  2 16:49 net
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 oom_adj
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 oom_score
-r--------    1 16385    yv_signe         0 Apr  2 16:49 pagemap
-r--------    1 16385    yv_signe         0 Apr  2 16:49 personality
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:49 root -> /run/youview/jail/applications/1
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 sched
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 smaps
-r--------    1 16385    yv_signe         0 Apr  2 16:49 stack
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 stat
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 statm
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 status
dr-xr-xr-x   19 16385    yv_signe         0 Apr  2 16:49 task
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 wchan

root# ll /run/youview/jail/applications/1
root# 


However, do cd into root then shows:

root# cd root
root# ll
drwxr-xr-x    3 radiumd  app_libr      4096 Apr  2 15:56 app
drwx------    3 16385    yv_signe      4096 Apr  2 16:23 app-data
drwxr-xr-x    2 root     root          4096 Mar 31 01:07 bin
drwxr-xr-x    3 root     root          1420 Jan  1  1970 dev
drwxr-xr-x    6 root     root          4096 Apr  1 13:30 etc
drwxr-xr-x    4 root     root          4096 Mar 31 01:07 lib
drwxr-xr-x    6 root     root           120 Apr  2 16:48 mnt
drwxr-xr-x    7 root     root           140 Apr  2 16:48 opt
dr-xr-xr-x  128 root     root             0 Jan  1  1970 proc
drwxr-xr-x    4 root     root            80 Apr  2 16:48 run
drwx------    2 16385    yv_signe      4096 Apr  2 16:49 tmp
drwxr-xr-x    4 root     root            80 Apr  2 16:48 usr
drwxr-xr-x    3 root     root            60 Apr  2 16:48 var
root# 


={============================================================================
*kt_dev_uv_stack_130* stack: links with 3rd parties. cppunit, gmock and so on

-DMACRO__pkgdatadir=\"/opt/zinc/share/uranium-client-system\" -m32 -I/opt/zinc/include  -isystem
/opt/zinc/oss/include  -D_FORTIFY_SOURCE=2  -fstack-protector-all   -m32 -DNDEBUG -O3 -pipe -pthread
-march=i686 -Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
-Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format -Werror=missing-braces
-Werror=nonnull -Werror=parentheses -Werror=pointer-sign -Werror=return-type -Werror=sequence-point
-Werror=strict-overflow=1 -Werror=trigraphs -Werror=unknown-pragmas -Werror=unused-function
-Werror=unused-label -Werror=unused-value -Werror=volatile-register-var -fdiagnostics-show-option
-Werror=uninitialized  -MT SummaryTest.o -MD -MP -MF $depbase.Tpo -c -o SummaryTest.o
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Uranium/Uranium.Client.System/test/metadata/SummaryTest.cpp
&&\


/bin/sh ../../libtool  --tag=CXX   --mode=link i686-pc-linux-gnu-g++  -m32 -DNDEBUG -O3 -pipe
-pthread  -march=i686 -Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
-Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format -Werror=missing-braces
-Werror=nonnull -Werror=parentheses -Werror=pointer-sign -Werror=return-type -Werror=sequence-point
-Werror=strict-overflow=1 -Werror=trigraphs -Werror=unknown-pragmas -Werror=unused-function
-Werror=unused-label -Werror=unused-value -Werror=volatile-register-var -fdiagnostics-show-option
-Werror=uninitialized  -rdynamic -L/opt/zinc/lib -L/opt/zinc/oss/lib -Wl,--as-needed
-Wl,-rpath-link,/opt/zinc/lib -Wl,-rpath-link,/opt/zinc/oss/lib -o summarytest SummaryTest.o
helpers/SynchronisableDispatcher.o helpers/TestSupport.o ../../src/libUraniumClientSystemStatic.la
-L/opt/zinc/lib -L/opt/zinc/oss/lib 

-lboost_date_time 
-lboost_filesystem 
-lboost_system 
-lboost_program_options 
-lboost_thread 
-lboost_iostreams 

-llog4cplus 

-ldl 
-lboost_thread 
-llog4cplus
-ldbus-c++-1 
-ldbus-1 
-ldbus-c++-testsupport-1 

-lCadmiumSystemAPI 

-lUraniumClientAPI -lUraniumCommon

-lCobaltCommon 

-lCopperSystemDbus -lCopperSystemAPI 

-lIronSystemAPI -lIronRemindersSystemAPI -lIronRemindersSystemDbus -lIronRemindersSystemAPI

-lNeonClientSystem -lNeonClientApi -lNeonSystemAPI 

-lNickelSystemAPI 

-lZincCommonTestRunner
-lcppunit 
-lZincCommonTestSupport 
-lZincCommon 
-lZincDbusBindingTestSupport -lZincDbusBindingRuntime -lZincCommon -ldl
-lcppunit 
-lgmock -lgtest



={============================================================================
*kt_dev_uv_stack_150* stack: network

The dbus log when plug out and then plug in a cable

# dbus-monitor "interface=org.freedesktop.NetworkManager.Device.Wired 

Tue 2015-02-17 14:32:27 GMT
[17-02-2015 14:32:27.880473] signal sender=org.freedesktop.DBus -> dest=:1.80 serial=2 path=/org/freedesktop/DBus; interface=org.freedesktop.DBus; member=NameAcquired
   string ":1.80"
Feb 17 14:32:44 syslog[785]: <info> (eth0): carrier now OFF (device state 8)
Feb 17 14:32:44 syslog[785]: <info> (eth0): device state change: 8 -> 2 (reason 40)
Feb 17 14:32:44 syslog[785]: <info> (eth0): deactivating device (reason: 40).
eth0 Link DOWN.
Feb 17 14:32:44 syslog[785]: <info> (eth0): canceled DHCP transaction, DHCP client pid 815
[17-02-2015 14:32:44.579382] signal sender=:1.0 -> dest=(null destination) serial=204 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Carrier"
         variant             boolean false                  note: OFF
      )
      dict entry(
         string "State"
         variant             uint32 2
      )
      dict entry(
         string "Dhcp4Config"
         variant             object path "/"
      )
      dict entry(
         string "Ip6Config"
         variant             object path "/"
      )
      dict entry(
         string "Ip4Config"
         variant             object path "/"
      )
   ]
eth0 cable unplugged, powering down
eth0 cable plugged in, powering up
eth0 Link UP.
Auto config phy
eth0: Link is up, 100 Mbps Full Duplex
Feb 17 14:33:05 syslog[785]: <info> (eth0): carrier now ON (device state 2)
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 2 -> 3 (reason 40)
[17-02-2015 14:33:05.661158] signal sender=:1.0 -> dest=(null destination) serial=209 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Carrier"
         variant             boolean true          note: ON
      )
      dict entry(
         string "State"
         variant             uint32 3
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) starting connection 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6'
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 3 -> 4 (reason 0)
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) started...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) starting...
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 4 -> 5 (reason 0)
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) successful.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) scheduled.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) started...
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 5 -> 7 (reason 0)
[17-02-2015 14:33:05.685977] signal sender=:1.0 -> dest=(null destination) serial=214 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Beginning DHCPv4 transaction (timeout in 1073741823 seconds)
   array [
      dict entry(
         string "State"
         variant             uint32 4
      )
   ]
[17-02-2015 14:33:05.701563] signal sender=:1.0 -> dest=(null destination) serial=218 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 5
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> dhclient started with pid 1546
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) complete.
[17-02-2015 14:33:05.708832] signal sender=:1.0 -> dest=(null destination) serial=220 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 7
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> (eth0): DHCPv4 state changed nbi -> preinit
Feb 17 14:33:05 syslog[785]: <info> (eth0): DHCPv4 state changed preinit -> reboot
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) started...
Feb 17 14:33:05 syslog[785]: <info>   address 172.20.35.27
Feb 17 14:33:05 syslog[785]: <info>   prefix 20 (255.255.240.0)
Feb 17 14:33:05 syslog[785]: <info>   gateway 172.20.32.1
Feb 17 14:33:05 syslog[785]: <info>   nameserver '127.0.0.1'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.34.223'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.34.224'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.35.66'
Feb 17 14:33:05 syslog[785]: <info> Scheduling stage 5
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Done scheduling stage 5
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) started...
[17-02-2015 14:33:05.932824] signal sender=:1.0 -> dest=(null destination) serial=222 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Dhcp4Config"
         variant             object path "/org/freedesktop/NetworkManager/DHCP4Config/1"
      )
   ]
Feb 17 14:33:06 syslog[785]: <info> (eth0): device state change: 7 -> 8 (reason 0)
Feb 17 14:33:06 syslog[785]: <info> Policy set 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6' (eth0) as default for IPv4 routing and DNS.
Feb 17 14:33:06 syslog[785]: <info> Activation (eth0) successful, device activated.
Feb 17 14:33:06 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) complete.
[17-02-2015 14:33:07.009626] signal sender=:1.0 -> dest=(null destination) serial=230 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 8
      )
      dict entry(
         string "Ip4Config"
         variant             object path "/org/freedesktop/NetworkManager/IP4Config/1"
      )
   ]
Feb 17 14:33:56 syslog[785]: <info> Trying to start the supplicant...


={============================================================================
*kt_dev_uv_stack_200* stack: dbus

To get the list of active bus names. This is script in box: opt/zinc/devel/bin/lsdbus

$lsdbus

# dbus-send Emporium

https://wiki.youview.co.uk/display/canvas/dbus-send+Emporium?src=contextnavpagetreemode

<monitor>
# to capture
dbus-monitor > /mnt/hd1/mylogs.log &
dbus-monitor | tee /mnt/hd1/mylogs.log &

# To launch Dbus-Monitor on your STB, and inspect MediaRouter activity, run the following command:
dbus-monitor "interface=Zinc.Media.MediaRouter"

# will only display MediaRouter SourceEvent messages:
dbus-monitor | grep -C 2 "member=SourceEvent"

dbus-monitor "type=method_call" "type=method_return" "type=error"

dbus-monitor --profile "interface=Zinc.Application.ApplicationManager,member=launchApplication" \ 
   "interface=Zinc.Application.ApplicationManager,member=ApplicationLifecycleEvent"

<introspect>

Q: which is the start to build interface/method to build a hierarchy?

kpark@wll1p04345:~/source/DEVARCH/Neon$ find . -name *.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerActiveConnection.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerSettings.xml
./Neon.System.API/data/introspection-xml/enum-PingStatus.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-settings.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-device-ethernet.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-active-connection.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-manager.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-device.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-exported-connection.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-ip4-config.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_CAP.xml
./Neon.System.API/data/introspection-xml/struct-PingResponse.xml
./Neon.System.API/data/introspection-xml/enum-NM_ACTIVE_CONNECTION_STATE.xml
./Neon.System.API/data/introspection-xml/enum-NM_STATE.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerIP4Config.xml
./Neon.System.API/data/introspection-xml/service.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerDeviceWired.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_TYPE.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_STATE.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerDevice.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManager.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerSettingsConnection.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_STATE_REASON.xml
./Neon.System.API/data/introspection-xml/interface-IPNetwork.xml


<interface-name>
Cobalt.System.DBusClient/src/MetadataBrokerDBusToSyncAndAsync.cpp

36-
37-#include "MetadataBrokerDBusToSyncAndAsync.h"
38-
39-NS_ZINC_DBUS_BINDING_OPEN
40:const char* const interface_name<Zinc::Broker::MetadataBrokerAsync>::value = "Zinc.Broker.MetadataBroker";
41:const char* const interface_name<Zinc::Broker::MetadataBrokerSync>::value = "Zinc.Broker.MetadataBroker";
42:const char* const interface_name<Zinc::Broker::MetadataBrokerDBusToSyncAndAsync>::value =
       "Zinc.Broker.MetadataBroker";

Iron.System.DBusClient/src/EventRepositoryDBusToSyncAndAsync.cpp

35-
36-#include "EventRepositoryDBusToSyncAndAsync.h"
37-
38-NS_ZINC_DBUS_BINDING_OPEN
39:const char* const interface_name<Zinc::Metadata::EventRepositoryAsync>::value =
"Zinc.Metadata.EventRepository";

40:const char* const interface_name<Zinc::Metadata::EventRepositorySync>::value =
       "Zinc.Metadata.EventRepository";

41:const char* const interface_name<Zinc::Metadata::EventRepositoryDBusToSyncAndAsync>::value =
       "Zinc.Metadata.EventRepository";


={============================================================================
*kt_dev_uv_stack_200* commands

# what?
root# setItem platform.settings.enable-ipcrb 1

# log?
tail -f /opt/zinc/var/daemons/crbd/log/helium.log


How to Introspect DBus from the Command Line
https://wiki.youview.co.uk/display/canvas/How+to+Introspect+DBus+from+the+Command+Line?src=search
# to see messages on dbus
root# dbus-monitor "interface=Zinc.Application.ApplicationManager"

# what is it? LSR?
root# getChildItems oem

# what?
export GST_PLUGIN_PATH=/opt/zinc/oss/lib:/opt/zinc/oss/lib/gstreamer-1.0
export LD_LIBRARY_PATH=/lib:/usr/local/lib:/opt/zinc/oss/lib/gstreamer-1.0:/opt/zinc/oss/lib:/opt/zinc/oss/lib/python2.6

LD_PRELOAD=/usr/local/lib/libdirectfb.so:/usr/local/lib/libdirect.so:/usr/local/lib/libinit.so gst-launch-1.0 souphttpsrc location=http://54.225.86.153/INT01_LCN_551.sdp ! vqesdpdemux caps=video/mpegts ! queue ! tsnexusbin 


={============================================================================
*kt_dev_uv_wiki_001* dbus-monitor

dbus-send  --session --type=method_call --print-reply --dest='org.freedesktop.DBus' / org.freedesktop.DBus.ListNames
dbus-monitor --profile "interface=Zinc.Application.ApplicationManager,member=launchApplication" "interface=Zinc.Application.ApplicationManager,member=ApplicationLifecycleEvent"

{dbus-spy}
https://wiki.youview.co.uk/display/YVDP/How+to+inspect+MediaRouter+activity
This is a python script and run on the box.

MediaRouter Dbus Spy is a tool that prints all the MediaRouter dbus communications in a more
readable format than the raw output. It also reports when a new application is launched or killed
and any MediaRouter crash.


={============================================================================
*kt_dev_uv_hwei_001* stack: convert ro filesystem to rw

From the release, follow the step 3:

https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Huawei+DN370T+PVR1+B37SP11

3. Boot from HDD

From SSH or the serial console run the following command:

mkdir -p /mnt/nand/userdata/data && echo "rw" > /mnt/nand/userdata/data/rw_cmd

The next boot will take slightly longer than normal as the files are copied from nand to the harddisk.


={============================================================================
*kt_dev_uv_task_001* task:01: nexusMgr

{inspect}
used in wrapper:

/bin/nexus-inspect -r -p "${parent_pid}"


{mgr-interface}
nexusMgr interfaces:

BcmNexus_Audio_Mixer_Register(NEXUS_AudioMixerHandle hMixer)
BcmNexus_Audio_Mixer_Unregister(void)
BcmNexus_Graphics_Resources_Acquire(BcmNexus_Graphics_Resources_Config *)
BcmNexus_Graphics_Resources_Release(const BcmNexus_Graphics_Resources *)
BcmNexus_ImageDecoder_Resources_Acquire(const BcmNexus_ImageDecoder_Resources_Config *)
BcmNexus_ImageDecoder_Resources_Release(const BcmNexus_ImageDecoder_Resources *)
BcmNexus_Input_Resources_Acquire(const BcmNexus_Input_Resources_Config *)
BcmNexus_Input_Resources_Release(const BcmNexus_Input_Resources *)
BcmNexus_Key_Last_Key_Timestamp(void)
BcmNexus_Platform_Init(void)
BcmNexus_Platform_Uninit(void)
BcmNexus_Screen_Capture(void)
BcmNexus_SetMixerPath(NEXUS_AudioMixerHandle hmixer, const BcmNexus_StreamPlayer_Resources *resources)
BcmNexus_Set_Last_Key_Timestamp(void)
BcmNexus_SoundOutput_Resources_Acquire(const BcmNexus_SoundOutput_Resources_Config *)
BcmNexus_SoundOutput_Resources_Release(const BcmNexus_SoundOutput_Resources *)
BcmNexus_SoundOutput_SetVolume(BcmNexus_SoundOutput_Volume, unsigned)
BcmNexus_StreamPlayer_Resources_Acquire(const BcmNexus_StreamPlayer_Resources_Config *)
BcmNexus_StreamPlayer_Resources_Avaiable(void)
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *)
BcmNexus_UnSetMixerPath(NEXUS_AudioMixerHandle hmixer, const BcmNexus_StreamPlayer_Resources *resources)


{shm}
<from-inspect>
// return true if no shared mem opens or destroied it successfully. so no process owns it
static bool do_platform_init(size_t shMemSz);

static void releaseNexusResources( BcmNexus_Shared_Memory *shmem )
{
  shmem->resource_pid = getpid();
  printf( "Reset resource_pid\n" );
  /* set callback to NULL */

  // <out> commented out since no support from HWEI
  // resetDimmingSetting(shmem);
  // {
  //  NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindow, &picture_settings );
  // }

  NEXUS_VideoDecoder_Stop( shmem->videoDecoder );
  NEXUS_AudioDecoder_Stop( shmem->audioDecoder[0] );

  // <out> commented out since no support from HWEI
  // for (uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  // {
  //   // stopPlayPump( shmem->playpump[i] );
  //   {
  //     NEXUS_PlaypumpSettings playpump_settings;
  //     NEXUS_Playpump_Stop( playPump );
  //     NEXUS_Playpump_GetSettings( playPump, &playpump_settings );
  //     NEXUS_Playpump_SetSettings( playPump, &playpump_settings );
  //   }
  // }

  NEXUS_VideoDecoder_Flush( shmem->videoDecoder );

  // <mod> HWEI has two audio decoders
  NEXUS_AudioDecoder_Flush( shmem->audioDecoder[0] );

  // <out> commented out since no support from HWEI
  // for (uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  // {
  //   NEXUS_Playpump_Flush( shmem->playpump[i] );
  // }

  shmem->resource_pid=0;
}

<missed-from-huawei>
These are fields that huawei mgr DO NOT HAVE from what inspect tool uses.

BcmNexus_State.sharedMem->videoWindow;
BcmNexus_State.sharedMem->playPump[i];


<from-inspect>
typedef struct
{
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[1];           // used
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_VideoDecoderHandle    videoDecoder;              // used
  NEXUS_VideoWindowHandle     videoWindow;               // used
  NEXUS_PlaypumpHandle        playpump[MAX_PUMP_NUM];    // used
  NEXUS_DmaHandle             dmaHandle;
  pid_t                       resource_pid;
} BcmNexus_Shared_Memory;


<from-mgr-humax>
typedef struct {
  //
  // 'same' as inspect
  //
  NEXUS_AudioPlaybackStartSettings    audioStartSettings;
  bool                                pcmStarted[NEXUS_NUM_AUDIO_PLAYBACKS];
} BcmNexus_Shared_Memory;

<from-mgr-huawei>
typedef struct {
    NEXUS_AudioMixerHandle              mixer;
    NEXUS_AudioPlaybackHandle           pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
    NEXUS_AudioDecoderHandle            audioDecoder[2];
    NEXUS_VideoDecoderHandle            videoDecoder;
} BcmNexus_Shared_Memory;



{pid-check}
<from-inspect>
When the given pid is the same as shm pid, then do release:

if ( 0 == expected_owning_pid || expected_owning_pid == sharedMem->resource_pid )

<from-mgr-humax>
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
  // check in both oem. this prevents the same process getting the same.
  if (BcmNexus_State.streamResource) {
    BDBG_MSG_TRACE(("BcmNexus_StreamPlayer_Resources_Acquire: Already acquired!!"));
    return NULL;
  }

  // check and if already owns by the other process then returns. only when no
  // one owns it, go forward
  if( (BcmNexus_State.sharedMem->resource_pid != 0) && (BcmNexus_State.sharedMem->resource_pid != getpid()) )

  // set to say i owns it
  BcmNexus_State.sharedMem->resource_pid = getpid();
}

BcmNexus_StreamPlayer_Resources_Release()
{
  // set pid = 0
}

note: Q: the below is ONLY for humax and not used in inspect tool. Who's using it?

BcmNexus_StreamPlayer_Resources_Avaiable(void)
{
  if( (BcmNexus_State.sharedMem->resource_pid == 0) || (BcmNexus_State.sharedMem->resource_pid == getpid()) )
}


{hwei-mgr-modification}
<playpump>
note: The below is only for Humax and also has a pair for Init and Uninit for each audio and video.
BcmNexus_Platform_Init_Video(void);

For HWEI, the below do the work that Init_Audio and Init_Video do in HMAX case. Hence added playpump
open code in:
BcmNexus_Platform_Init_Audio(void);

However, no pair but instead uninit done in: 
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *resources_)

Added playpump in SHM structure and handles it in Init and Release.

<videoWindow>
note: do not use videoWindowSD in inspect tool so not shared in shm.

BcmNexus_State.sharedMem->videoWindow;

As with playpump, init and uninit done in Acquire and Release:

BcmNexus_StreamPlayer_Resources_Acquire
BcmNexus_StreamPlayer_Resources_Release

note: Unline HMAX, NO input connection on videoWindow in Acquire and so no handle in Release.

Added videoWindow in SHM structure and handles it in Acquire and Release.

This cause opps:
Code: 00000000  8fa20010  3c04e1bd <8c420000> 24848dbc  afa20010  8fa30010 8fa20014  0062001a ###
00:00:22.574 nexus_driver_callbacks: two apps can't register for the same callback for the same
handle *** 00:00:22.574 nexus_driver_callbacks: nexus_driver_callback_to_driver:
(HDMI_OUTPUT:0xcf3a6c80) not enough resources to map callback 0xc04:0xe1d60064 *** 00:00:22.574
BHDM_EDID: Overriding 1366x768p/1360x768p to BFMT_VideoFmt_e720p !!! Assert 'Bad object of expected
type #NEXUS_VideoWindow:0xdeadda7a (0x0:0xe19f39b4)' Failed at
/home/gejing/dn370tb37sp05/bcm7409/refsw6.5/nexus/modules/display/7420/src/nexus_video_window.c:1285
BKNI_Fail: forcing oops CPU 0 Unable to handle kernel paging request at virtual address 00000000,
    epc == e178ec90, ra == e178ec88


{open-and-start}
<from-mgr-humax>

Q: nexusMgr already has Init and Uninit interface. Is it okay to use these rather than implementing
the proposed function? 

BcmNexus_Platform_Uninit(void);

A: NO. Since Init and Uninit pair do 'open' and close but inspect tool uses 'stop'. Interestingly, the
nexusMgr do not use 'start' interface. Does it mean that do start automatically when it is opened?


BcmNexus_State.sharedMem->ac3Encoder = NEXUS_Ac3Encode_Open(NULL);


{design} the suggested call
1. check manager's init state and the given pid.

if( !BcmNexus_State.initialized && pid != resource_pid )
   return;

2. set shm resource pid = 0 at the end of the call.


{tickets}
https://jira.youview.co.uk/browse/DEVARCH-8092
Provide a method in Huawei's nexusMgr to release resources acquired by a pid

<proposed-api>
The proposed interface in OEM nexusMgr code.
BcmNexus_Release_All_Resources_Acquired_By_Process(pid_t pid);

https://jira.youview.co.uk/browse/YVHUAWEI-6095
Kernel oops when killing w3cEngine or Netflix

Chris Dudding added a comment - Last Wednesday 15:34
B37SP05 is an engineering release, so the "kernel oops" fixes are not applied in the latest Huawei
FR13 release (B37SP11). We've asked them to apply the fix into their main FR13 branch. We will mark
this ticket as resolved when the fix is available in the next FR13 release.

Zegen Pei added a comment - Last Friday 02:25
fixed in 70.37.13

note: update. 2015.01.15. tried the eng. release and seen no kernel oops any more.


https://jira.youview.co.uk/browse/DEVARCH-8081
<TODO> 1
If we are to proceed with `nexus-inspect` as a solution, we separately need OEMs to move the struct
definition into the header file, but for now, we should identify which devices the current
implementation is compatible with. 

Device Works (Y/N)   Comments
Humax T1000          Y 
Humax T2100/T2000    Y 
Humax T2200          Y 
Huawei DN370T        N 
Huawei DN372T 
Huawei DN360T

note: before that need to verify #6095 first since it cause opps when kill apps.

1. this is function sets resource_pid in humax case
BcmNexus_StreamPlayer_Resources_Acquire(const BcmNexus_StreamPlayer_Resources_Config *)

2. We could perhaps make an initial implementation of this for each OEM and provide as a patch to
OEMs, or if that proves too problematic in the Huawei case, leave it as an empty "no-op", and let
them fill-in the implementation.

3. At the moment Humax saves the pid of the last process and Ideally we should know what process
acquired each resource so we can more safely release them. Some testing will tell us how necessary
it is for now.

https://jira.youview.co.uk/browse/DEVARCH-8080
<disable>
This can be disabled by removing either of the executables:
    /opt/zinc/bin/exec-then-cleanup-app.sh
    /opt/zinc/bin/nexus-inspect


{logs}
2015.01.16: 

1. able to build nexus mgr which has debug print mesg to see if it is loaded and used.  found the
problem which prevents me copying the built lib to a box since box has read-only fs. need to make it
rw fs.

2. managed to make a fs writable.

3. however, tried to use the lib built on my own, the box doesn't boot up but when use the original
lib works okay. why?

4. __FUNCTION__ macro seems to cause one problem. need to check.

5. there is the latest nexusMgr code from HWEI and tried that as well. But no success. The code from
https://jira.youview.co.uk/browse/YVHUAWEI-5895

6. three versions of nexus mgr: from uv git, from the gira, from the staging folder.

7. the log line
Error org.freedesktop.DBus.Error.NoMemory: Launcher could not run (out of memory)


2015.01.19, Mon:

1. Tried three variants of sources. None of them works. Asked Bomen(HWEI guy) to have a trace log
for a working case to compare.

2015.01.20, Tue:

1. Created a new ticket for an issue that cannot build a working nexusMgr. 
https://jira.youview.co.uk/browse/YVHUAWEI-6598

2. Ongoing discussion about features to implement.
https://jira.youview.co.uk/browse/YVHUAWEI-6095


2015.01.21, Wed:

1. Hack sources

HUAWEI_SHARED_RESOURCE        : defed in src

NEXUS_HAS_PICTURE_DECODER     : NO
_SC_DIRECT_NEXUS_             : NO
NEXUS_NUM_XXX                 : NO
DFB_PLATFORM_VERSION_MAJOR    : NO
DUAL_OUTPUT                         : defed in pkg config for hwei and hmax
NEXUS_HAS_DMA && NEXUS_HAS_SECURITY : defed in pkg config
BCMEXUS_STREAM_XXX                  : NO
USE_SIMPLE_DECODER                  : NO


01.29:   <shm-size-issue>
======
Investigating shmget error.

" from nexusMgr log line
log-usb-Mon-Jan-26-12:01:40:1253:*** KT: 0121: NEW BcmNexus_Platform_Init_Audio: shm size(24) ***

" from proc device
305450176

cat /proc/sysvipc/shm
key         shmid    perms    size  cpid  lpid nattch uid   gid  cuid  cgid      atime      dtime      ctime
305450176   163844   666      24    1063  1395 4      504   504   504   504 1422517874 1422517866         33
 
504       1063 12.6  9.7 502416 31352 ?        Sl   07:50   8:03 /opt/cds/bin/huaweidaemon

However, inspect asks 28 bytes which is the cause of the error.


02.09:
======

{shm-diff}

The handles are all pointers like:

typedef struct NEXUS_AudioMixer *NEXUS_AudioMixerHandle;


<proposed>
#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[2];
  NEXUS_AudioDecoderHandle    audioDecoder[2];
  NEXUS_VideoDecoderHandle    videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_DmaHandle             dmaHandle;
  NEXUS_VideoWindowHandle     videoWindow;
  NEXUS_PlaypumpHandle        playpump[1];
  pid_t                       resource_pid;
} NexusInspectCapsV0;


<humax> (from inspect.c)
#define NEXUS_NUM_AUDIO_PLAYBACKS 2
#define NEXUS_NUM_HDMI_OUTPUTS 1
#define MAX_PUMP_NUM	1

typedef struct {
  NEXUS_AudioMixerHandle              mixer;
  NEXUS_AudioPlaybackHandle           pcmPlayback[2];
  NEXUS_AudioDecoderHandle            audioDecoder[1];
  NEXUS_VideoDecoderHandle            videoDecoder;
  NEXUS_StcChannelHandle              stcChannel;
  NEXUS_Ac3EncodeHandle               ac3Encoder;
  NEXUS_DmaHandle                     dmaHandle;
  NEXUS_VideoWindowHandle             videoWindow;
  NEXUS_PlaypumpHandle                playpump[1];
  pid_t                               resource_pid;
} BcmNexus_Shared_Memory;

<huawei>

#define NEXUS_NUM_AUDIO_PLAYBACKS (1)

typedef struct {
    NEXUS_AudioMixerHandle              mixer;
    NEXUS_AudioPlaybackHandle           pcmPlayback[1];
    NEXUS_AudioDecoderHandle            audioDecoder[2];
    NEXUS_VideoDecoderHandle            videoDecoder;
    NEXUS_StcChannelHandle              stcChannel;
    pid_t                               resource_pid;
} BcmNexus_Shared_Memory;


   humax                                                                         hwei
--------------------------------------------------------------------          --------------------------------------------------------------------
typedef struct                                                                typedef struct 
{                                                                             {                                                                 
  NEXUS_AudioMixerHandle      mixer;                                            NEXUS_AudioMixerHandle              mixer;
  // 2 in mgr source                                                            // 1 in oem stage
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];           NEXUS_AudioPlaybackHandle           pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[1];           // used to stop        NEXUS_AudioDecoderHandle            audioDecoder[2];
  NEXUS_Ac3EncodeHandle       ac3Encoder;                // used in info        NEXUS_VideoDecoderHandle            videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;                // used in info        NEXUS_StcChannelHandle              stcChannel;
  NEXUS_VideoDecoderHandle    videoDecoder;              // used in info        pid_t                               resource_pid;
  NEXUS_VideoWindowHandle     videoWindow;               // used in info      } BcmNexus_Shared_Memory;                                                        
  // 1 in mgr source
  NEXUS_PlaypumpHandle        playpump[MAX_PUMP_NUM];    // used to stop
  NEXUS_DmaHandle             dmaHandle;                 // used in info
  pid_t                       resource_pid;
} BcmNexus_Shared_Memory;


04.20
======

#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_INSPECT_NUM_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[NEXUS_INSPECT_NUM_ADECS];
  NEXUS_VideoDecoderHandle    videoDecoder;                                   // covered. both
  NEXUS_StcChannelHandle      stcChannel;                                     // covered. both
  NEXUS_Ac3EncodeHandle       ac3Encoder;                                     // covered. hmax
  NEXUS_DmaHandle             dmaHandle;                                      // covered. hmax
  NEXUS_VideoWindowHandle     videoWindow;                                    // covered. hmax
  NEXUS_PlaypumpHandle        playpump[NEXUS_INSPECT_NUM_PLAYPUMPS];          // covered. both
  pid_t                       resource_pid;              
} NexusInspectCapsV0;

1. if( caps_v0.videoDecoder ) : covered for both.

static void printNexusManagerInfo( BcmNexus_Shared_Memory* sharedMem )
{
  // covered for both.
  //
  // NEXUS_PictureCtrlCommonSettings picture_settings;
  // printf( "\tAc3EncodeHandle: 0x%x\n", (unsigned int)sharedMem->ac3Encoder );
  // printf( "\tStcChannelHandle: 0x%x\n", (unsigned int)sharedMem->stcChannel );
  // printf( "\tVideoDecoderHandle: 0x%x\n",(unsigned int)sharedMem->videoDecoder );
  // printf( "\tVideoWindowHandle: 0x%x\n", (unsigned int)sharedMem->videoWindow );

  // NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindow, &picture_settings );
  // printf( "\t\tVideoDecoder contrast: %d\n", picture_settings.contrast );
  // printf( "\t\tVideoDecoder brightness: %d\n", picture_settings.brightness );
  // printf( "\t\tVideoDecoder saturation: %d\n", picture_settings.saturation );

#ifdef NEXUS_DUAL_OUTPUT
  printf( "\tSD DisplayHandle: 0x%x\n", (unsigned int)sharedMem->displaySD ) ;
  printf( "\tSD VideoWindowHandle: 0x%x\n", (unsigned int)sharedMem->videoWindowSD );
  NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindowSD, &picture_settings );
  printf( "\t\tSD VideoDecoder contrast: %d\n", picture_settings.contrast );
  printf( "\t\tSD VideoDecoder brightness: %d\n", picture_settings.brightness );
  printf( "\t\tSD VideoDecoder saturation: %d\n", picture_settings.saturation );
#endif // NEXUS_DUAL_OUTPUT
  for(uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  {
    printf( "\tPlaypumpHandle[%d]: 0x%x\n", i, (unsigned int)sharedMem->playpump[i] );
  }
  printf( "\tDmaHandle: 0x%x\n", (unsigned int)sharedMem->dmaHandle );
}

02.24: (logs changes to rewrite git commits and commit history)
======
1. OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

For hwei, do comment out as below to inlcude this in the build.

# export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"

2. Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c

change name nexus-inspect to nexus-release

3. Add nexus-release.c

4. Add nexus-inspect.[ch] 

5. Change Makefile.am to build both files.


02.25: as-needed option problem when builds nexus tools
======

<fail>
-O2 -pipe -rdynamic -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-o nexus-release nexus_release-nexus-release.o -Wl,-rpath -Wl,/usr/local/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib ~
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread -pthread ~

/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBSetOption' 
/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBCreate' 
/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBInit' collect2: ld returned 1 exit status

<okay>
-O2 -pipe -Wl,-rpath -Wl,/usr/local/lib -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-o nexus-inspect nexus_inspect-nexus-inspect.o

-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib -pthread


<runtime> no direct reference to nexusMgr
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin$ readelf
-d w3cEngine | grep NEED

(standard input):4: 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
(standard input):5: 0x00000001 (NEEDED)                     Shared library: [libsoup-2.4.so.1]
(standard input):6: 0x00000001 (NEEDED)                     Shared library: [libgobject-2.0.so.0]
(standard input):7: 0x00000001 (NEEDED)                     Shared library: [libglib-2.0.so.0]
(standard input):8: 0x00000001 (NEEDED)                     Shared library: [libNickelTunerSystemAPI.so.0]
(standard input):9: 0x00000001 (NEEDED)                     Shared library: [libQt5WebKitWidgets.so.5]
(standard input):10: 0x00000001 (NEEDED)                     Shared library: [libQt5Widgets.so.5]
(standard input):11: 0x00000001 (NEEDED)                     Shared library: [libZincJsCoreBindingRuntime.so.0]
(standard input):12: 0x00000001 (NEEDED)                     Shared library: [libZincCommon.so.0]
(standard input):13: 0x00000001 (NEEDED)                     Shared library: [libboost_thread.so.1.42.0]
(standard input):14: 0x00000001 (NEEDED)                     Shared library: [liblog4cplus-1.0.so.4]
(standard input):15: 0x00000001 (NEEDED)                     Shared library: [libboost_system.so.1.42.0]
(standard input):16: 0x00000001 (NEEDED)                     Shared library: [libQt5WebKit.so.5]
(standard input):17: 0x00000001 (NEEDED)                     Shared library: [libQt5Gui.so.5]
(standard input):18: 0x00000001 (NEEDED)                     Shared library: [libQt5Network.so.5]
(standard input):19: 0x00000001 (NEEDED)                     Shared library: [libQt5Core.so.5]
(standard input):20: 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
(standard input):21: 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
(standard input):22: 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
(standard input):49: 0x6ffffffe (VERNEED)                    0x40bd3c
(standard input):50: 0x6fffffff (VERNEEDNUM)                 2


04.01:
======
1. Got eng release and check on shm first.

before:
cat /proc/sysvipc/shm

key         shmid    perms    size  cpid  lpid nattch uid   gid  cuid  cgid      atime      dtime      ctime

305450176   163844   666      24    1063  1395 4      504   504   504   504
1422517874 1422517866         33

now:
305450176     196613   666         28  1074  1422      4   504   504   504
504 1427879275 1427879314         43

from ps:
1074 ?        Sl     3:09 /opt/cds/bin/huaweidaemon


2. Need to make a box writable since requires to copy exec and nexus-release
binary.

exec-then-cleanup-app

3. Seen a problem of making fs writable.

4. Cannot run iplayer and nexus-release as well
/opt/zinc-trunk/bin/nexus-release: can't load library 'libnexusMgr.so.0'

In that case, shows this error:

(w3cEngine:2429): GStreamer-WARNING **: Failed to load plugin
                  '/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so': File
                  not found


5. However, there are files on a box.

root# ll /opt/{zinc,zinc-trunk}/oss/lib/gstreamer-1.0/libgstnexus.so
lrwxrwxrwx    1 1024     1025            20 Apr  1 13:30
/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so -> libgstnexus.so.0.0.0

lrwxrwxrwx    1 root     root            20 Jan  1  1970
/opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so -> libgstnexus.so.0.0.0


6. on a huwawei box

objdump -p /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so

/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so:     file format elf32-tradlittlemips

Dynamic Section:
  NEEDED               libnexusMgr.so.0 ~
  NEEDED               libnexus.so
  NEEDED               libgstbase-1.0.so.0
  NEEDED               libgstmpegts-1.0.so.0
  NEEDED               libgstreamer-1.0.so.0
  NEEDED               libgobject-2.0.so.0
  NEEDED               libglib-2.0.so.0
  NEEDED               libgcc_s.so.1
  NEEDED               libpthread.so.0
  NEEDED               libc.so.0
  SONAME               libgstnexus.so.0
  RPATH                /usr/local/lib
  RUNPATH              /usr/local/lib


root# objdump -p /opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so      

/opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so:     file format elf32-tradlittlemips

Dynamic Section:
  NEEDED               libnexusMgr.so ~
  NEEDED               libnexus.so
  NEEDED               libgstbase-1.0.so.0
  NEEDED               libgstmpegts-1.0.so.0
  NEEDED               libgstreamer-1.0.so.0
  NEEDED               libgobject-2.0.so.0
  NEEDED               libglib-2.0.so.0
  NEEDED               libgcc_s.so.1
  NEEDED               libpthread.so.0
  NEEDED               libc.so.0
  SONAME               libgstnexus.so.0
  RPATH                /usr/local/lib
  RUNPATH              /usr/local/lib


open("/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so", O_RDONLY) = 60

open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/oss/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/oss/lib/gstreamer-1.0/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/devel/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/tests/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)

write(2, "\n(w3cEngine:1641): GStreamer-WARN"..., 134
(w3cEngine:1641): GStreamer-WARNING **: Failed to load plugin '/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so': File not found
) = 134


={============================================================================
*kt_dev_uv_task_002* task:02: DEVARCH-8869: about IP connection.

02.16:
======
CANTST-15347: BBC iPlayer: app not fully functional following IP reconnect after IP disconnect error message shown
-> DEVARCH-8869: Investigate/Fix CANTST-15347 BBC iPlayer: app not fully functional following IP reconnect after IP disconnect error message shown

<net-manager>
this is oem comp which is based on open source and has some oem modification.
source will be provided by tar file in this folder.

/home/kpark/source/DEVARCH/OEM.Humax/NetworkManager/src/NetworkManager-0.8.5.92


<serial-log-when-plug-in-out>
eth0 Link DOWN.
Feb 16 16:51:52 syslog[793]: <info> (eth0): carrier now OFF (device state 8)
Feb 16 16:51:52 syslog[793]: <info> (eth0): device state change: 8 -> 2 (reason 40)
Feb 16 16:51:52 syslog[793]: <info> (eth0): deactivating device (reason: 40).
Feb 16 16:51:53 syslog[793]: <info> (eth0): canceled DHCP transaction, DHCP client pid 2516
eth0 cable unplugged, powering down



eth0 cable plugged in, powering up
eth0 Link UP.
Auto config phy
eth0: Link is up, 100 Mbps Full Duplex
Feb 16 16:52:09 syslog[793]: <info> (eth0): carrier now ON (device state 2)
Feb 16 16:52:09 syslog[793]: <info> (eth0): device state change: 2 -> 3 (reason 40)
Feb 16 16:52:09 syslog[793]: <info> Activation (eth0) starting connection 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6'
Feb 16 16:52:09 syslog[793]: <info> (eth0): device state change: 3 -> 4 (reason 0)

This matches to:

./src/nm-device-ethernet.c:243: nm_log_info (LOGD_HW | LOGD_ETHER, "(%s): carrier now %s (device state %d%s)",
./src/nm-device-ethernet.c:245:              carrier ? "ON" : "OFF",

<dbus>
793   :1.0                     /opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        
793   org.freedesktop.NetworkManager/opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        
793   org.freedesktop.NetworkManagerSystemSettings/opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        

dbus-send  --session --type=method_call --print-reply --dest='Zinc.ContentAcquisition' \
 /Zinc org.freedesktop.DBus.Introspectable.Introspect


02.18
======
1. https://jira.youview.co.uk/browse/DEVARCH-7941

Shows the requirement. The points to note:

1. about handling errors that happen during playback and not during tuning. If does when tuning,
kill CRB application.

From OIPF-DAE:

LAN connectivity problem (results in a YVM102 message being shown by the YouView UI) 	Presenting
Connecting 	PlayStateChange (playstate 1, errorState 9 - insufficient bandwidth)

LAN connectivity problem

This one is quite easy and should just consist in making ProductionVideoBroadcast listen to
Neon.Client.API / NetworkStatusChange.  The UI might need to be modified to show only a notification
instead of showing a dialogue in case the CRB app is running (TBC), and usage reporting need to be
preserved if there is any.

note: Given there is "LAN connectivity problem restored:", the above includes no connection and
timed-out one?

On demand UI req:
https://wiki.youview.co.uk/display/UXDWIP/FR+12+-+On+Demand+Playback

From CANTST-15347:
Test description:
1. Launch a piece of content from BBC application (tested with iPlayer,and iPlayer from CRB)

Actual result:
note: 4. When the app freezes and must be closed and restarted.

NB in all the above cases the YV box reports the loss of internet connection (YVM-102) when the
cable is pulled from the back of the box.

The scenarios in all cases are the same whether it is the ethernet or the WAN being disconnected.

<test-result>
The version used:
Humax DTR-T1000 T1000 H21.7.30

The version reported:
Box: Humax T1000 PRK
CDS: H20.9.0
Environment: Live

The observation:

1. run iplayer 
2. run one of contents
3. plug out a cable
4. YVM-102 is shown on tv.
5. video still runs for some time and shows waiting icon 
6. error 02100 from iplayer app saying "something are not working playing this program. ..."
7. plug it back
8. shows "youview is connected again" message on tv.
9. able to navigate iplayer app which is 'different' from the reported.

Tried 5 times and no problem. Tried once after a reboot, no problem.


02.19
======
Assigned back to the reporter to re-test.
Started on the new one, #7508, which is about runBrowser-test.sh


={============================================================================
*kt_dev_uv_task_003* task:02: DEVARCH-7508: runBrowser-test.sh log:

02.20
======
kpark@wll1p04345:/data/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk$ find . -name runBrowser.sh
./bin/runBrowser.sh
kpark@wll1p04345:/data/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk$ find . -name runBrowser-test.sh
./tests/vanadium-w3c-engine/test/runBrowser-test.sh

[root@HUMAX zinc-trunk]# find . -name runBrowser* ./bin/runBrowser.sh
./devel/bin/runBrowserStandalone.sh
./tests/vanadium-w3c-engine/test/runBrowser-test.sh
[root@HUMAX zinc-trunk]# 


From runBrowser-test.sh log:

+ paramsContainStringAtPosition 0 3 -cache /tmp/client-cache -cache-size 50000000 -jar /tmp/cookies.sqlite -url 'http://youview.tv/test-player?launch_context.ui.youview.com=portal&some.test.param=some.test.param.value&test.param.spaces=param%20value%20with%20spaces' -src '
      http://youview.tv http://broadcast.example.com
      http://www.bbc.co.uk http://cdn.example.net:8080
    '
+ local stringToSearchFor=0
+ local positionToExpectStringAt=3
+ local 'stringToSearch=-cache /tmp/client-cache -cache-size 50000000 -jar /tmp/cookies.sqlite -url http://youview.tv/test-player?launch_context.ui.youview.com=portal&some.test.param=some.test.param.value&test.param.spaces=param%20value%20with%20spaces -src 
      http://youview.tv http://broadcast.example.com
      http://www.bbc.co.uk http://cdn.example.net:8080
    '
So expect to see 0 but 50000000. Why?

From runBrowser.sh

# Decide whether to turn on Qt's network cache + local storage.
cacheSize="$(lsr-config --int platform.settings.html-app-cache-size || echo 0)"

This cache size comes from external but the test script uses the 'fixed' value. mismatch.

that_generates_url_handler() {

    paramsContainStringAtPosition "0" 3 "$@"
    cacheSizeValueCorrectAtExpectedPosition=$?
}


related https://jira.youview.co.uk/browse/DEVARCH-7362 since about cache size.

The solution:

kpark@wll1p04345:~/jira/feb-7508$ diff runBrowser-test-old.sh runBrowser-test.sh 
--- runBrowser-test-old.sh	2015-02-20 14:23:37.978416274 +0000
+++ runBrowser-test.sh	2015-02-20 14:21:59.318417412 +0000
@@ -173,7 +173,8 @@ test.param.spaces=param%20value%20with%2
     paramsContainStringAtPosition "-cache-size" 2 "$@"
     cacheSizeOptionCorrectAtExpectedPosition=$?
 
-    paramsContainStringAtPosition "0" 3 "$@"
+    # paramsContainStringAtPosition "0" 3 "$@"
+    paramsContainStringAtPosition "$(lsr-config --int platform.settings.html-app-cache-size || echo 0)" 3 "$@"
     cacheSizeValueCorrectAtExpectedPosition=$?
 
     paramsContainStringAtPosition "-jar" 4 "$@"


02.23
======
DEVARCH-7508/0: runBrowser-test.sh fails on DTR-T1000

The cause of the problem is that the cache size is introduced in the runBrowser.sh but not in the
runBrowser-test.sh. Hence mismatch which cause this failure. 

This commit has the fix to have the same approach rumBrower.sh has to use the value from LSR. 

<review>
Please review the commits for [DEVARCH-7508] which on the branch [review/DEVARCH-7508/0].

1. [DEVARCH-7508: runBrowser-test.sh fails on DTR-T1000 [e4ac0e1]

[1]: https://jira.youview.co.uk/browse/DEVARCH-7508
[2]: https://git-dev.dev.youview.co.uk/?p=DEVARCH.git;a=shortlog;h=refs/heads/review/DEVARCH-7508/0
[e4ac0e1]: https://git-dev.dev.youview.co.uk/?p=DEVARCH.git;a=commit;h=e4ac0e157a900d55fa30b7c9c88a9f080b3767b1


={============================================================================
*kt_dev_uv_task_004* task:03: DEVARCH-9135: uranium metadata

03.04
======
Assigned.
https://jira.youview.co.uk/browse/DEVARCH-9135

UI is provided two metadata APIs for events:

From the API docs: http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/index.html

<Q> CTV?

ctv.enhancemetadata.Event
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/ctv/enhancedmetadata/Event.html

ctv.linearmetadata.Event
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/ctv/linearmetadata/Event.html

The latter Event type is an old API that we don't consider efficient and would ideally remove it. In
order to do this, the ctv.enhancedmetadata.Event type needs to contain all of the information that
the UI needs.

It has been noticed (by Stephen Spencer) that ctv.enhancedmetadata.Event.getSynopsis() doesn't
always return a value for some types of events. This should be investigated and fixed.

The implementation of ctv.enhancedmetadata.Event is in the file:

Uranium/Uranium.Client.System/src/metadata/SystemClientEvent.cpp


03.25
======
The fix made:
Uranium/Uranium.Client.System/test/metadata/SystemClientEventTest.cpp

    void testEventAccessors_When_ConstructedFromAnIronEvent():

+        sysEvent.mediumSynopsis["eng"] = "The latest national and international"
+            "news stories from the BBC News team, followed by weather.";
 
+        CPPUNIT_ASSERT_EQUAL(string("The latest national and international"
+                    "news stories from the BBC News team, followed by weather."), event.getSynopsis());
     }

    void testEventAccessors_When_ConstructedFromAPopulatedSystemEventWrapper()

         sysResult->description["owningServiceId"] = vector<string>(1, "1");
+        sysResult->description["mediumSynopsis"] = vector<string>(1, "The latest national and international"
+                "news stories from the BBC News team, followed by weather.");

+        CPPUNIT_ASSERT_EQUAL(string("The latest national and international"
+                "news stories from the BBC News team, followed by weather."), event.getSynopsis());
     }

Uranium/Uranium.Client.System/src/metadata/SystemClientEvent.cpp

1.

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const std::string& lang,
        const NS_IRON_SYSTEM::Event& dttEvent) :

@@ -117,7 +117,9 @@ SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos
         actualAvailability(false),
         flags(0),
         isCachedFlag(false),
-        synopsis(extractValueFromMap(dttEvent.longSynopsis, lang)),
+        // { FIX
+        synopsis(extractValueFromMap(dttEvent.mediumSynopsis, lang)),
+        // } FIX


2.

SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const SystemEventWrapper& masEvent) :

@@ -358,7 +349,9 @@ SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos
             actualAvailability(masEvent.isAvailable()),
             flags(0),
             isCachedFlag(false),
-            synopsis(),
+            // { FIX
+            synopsis(masEvent.getSynopsis()),
+            // } FIX


Uranium/Uranium.Client.System/src/metadata/SystemEventWrapper.h

class SystemEventWrapper  {

@@ -32,6 +32,13 @@ public:
         idBag(scResult)
     {}
 
+    // { FIX
+    std::string getSynopsis() const
+    {
+        return scResult.getStringFromDescription("mediumSynopsis");
+    }
+    // } FIX
+


04.01: have had a look at john's commits since these makes conflict with changes I made.
======

* 62ef094 (HEAD, origin/john.sadler/uranium-opt-1, john.sadler/uranium-opt-1) DEVARCH-9276: Uranium.Client.API: Simplify `TargetRegion`.
* 646adc9 DEVARCH-9288: Uranium.Client.System: Remove ReminderRepository pointer member from SystemClientEvent.
* 8cfaa44 DEVARCH-9287: Uranium.Client.System: Remove ServiceRepository pointer member from SystemClientEvent.
* eac309d DEVARCH-9286: Uranium.Client.System: Remove LinearAcquisition pointer member from SystemClientEvent.
* 467bc42 DEVARCH-9285: Uranium.Client.System: Remove EventRepository pointer member from SystemClientEvent.
* 500ce26 DEVARCH-9275: Uranium.Client.System: Remove `IdentifierBag`.
* 499950f DEVARCH-9274: Uranium.Client.System: Remove `SystemEventWrapper` and avoid additional copy of `Result` when constructing `SystemClientEvent`.
* b7c5176 DEVARCH-9272: Cobalt.System.Fake: Use correct ISO 8601 format when constructing event times.
* d3d85d5 DEVARCH-9271: Cobalt.System.API: Add `ResultHelpers` functions to get OD Availability & ProgrammeId fields from `Result`.
* 29c9fab  DEVARCH-9271: Uranium.Client.System: Avoid pointless copy of entire Broker ResultSet when constructing CAL ResultSet wrappers.


* 7d2a5f3 
=========

John Sadler committed e9a6201940707 Mar 2015
DEVARCH-9269: Uranium.Client.System: Make `SystemClientSummary` create CAL `Result` wrapper
immediately in it's constructor.

Due to the wonderfully-generic MAS B2C interface, the MetadataBroker
`search()` and `getSummaries()` methods each return a vector of `Summary`
objects where each `Summary` could be one of a number of entity types:
`Brand`, `Series`, `Programme Summary`, `Service`, `Application`, and
`Schedule Event`.

So essentially, `Summary` is a discriminated variant type.

The current implementation of `Summary` in the CAL: `SystemClientSummary`
defers creation of the specific CAL entity until a caller asks for it by
calling a method such as: `getBrand()` via the `Summary` interface. It
doesn't bother caching the object once it has created it either, which means
that repeated calls will return different instances, (so a shallow
"identity comparison" would fail).

This commit modifies `SystemClientSummary` such that it immediately creates
the appropriate CAL entity, depending on the `entity-type` conveyed in the
System API `Result` object it is constructed from. It holds the entity in a
type-erased form (`shared_ptr<void>`), but since it also knows the type of
the entity, it can safely static_cast back to the appropriate type when a
client calls a getter method (such as `getBrand()`).

By doing this, we remove the need for `SystemClientSummary` to hold a copy
of the original System API `Result` struct, and also enable it to give the
guarantee that repeated calls to getter methods return the same object.
That also means that clients which call the getter multiple times don't
repeatedly incur the overhead of constructing the CAL entity and copying
the `Result` struct.

It should be pointed-out that this change introduces a slight change in
behaviour which required one of the existing testcases to be modified.
What the testcase was doing was retrieving an Event from Summary that
was on a hidden Service, and then un-hiding the Service via the
ServiceRepository. Following this, it was then re-fetching the Event from
the Summary, and then the Service from the Event, and asserting that the
Service was now "unhidden". This no-longer works because the Event is
now being created only once (and the Service is looked-up in the constructor),
and changes to Services are unfortunately not reflected on Service objects
(it is necessary to re-fetch the Service from the ServiceRepository).
Happily, the UI does not make use of the previous behaviour (which is in
any case undocumented).

note: two points

1. By doing this, we remove the need for `SystemClientSummary` to hold a copy
of the original System API `Result` struct, 


-> The point is to remove a copy in SCS since SystemClientSummary in JS has Result member. This save
    a memory in SCS and copy to SCS. However, my master has SP to Result instead and this change has
    no effect. Which one is the latest?


and also enable it to give the guarantee that repeated calls to getter methods return the same
object.  That also means that clients which call the getter multiple times don't repeatedly incur
the overhead of constructing the CAL entity and copying the `Result` struct.

-> This is valid since creates different wrapper instances from the same result. So one result and
one wrapper instance. Good point.


* d0e695e 
=========
commit d0e695e6e148f911dfbc6aee3a36238a3e90a9f6
Author: John Sadler <john.sadler@youview.com>
Date:   Sat Mar 7 12:23:07 2015 +0000

DEVARCH-9266: Uranium.Client.System: Don't heap-allocate a copy of System API `Result` when creating
Client API wrappers.

The MetadataBroker System API `Result` struct is very generic and is used
to transport a variety of different entities, such as Schedule Events,
Applications, Programmes, & Publications.

In the Client API (which is implemented in-terms-of the System API), we
expose different, strongly-typed, interfaces for each of the different
entity types. Each instance of these ultimately either wraps a `Result`
object, or is constructed from one.

As a System API, MetadataBroker returns it's results by-value. Non of the
generated System APIs return structs, or collections by `boost::shared_ptr`.
However, all of the Client API wrappers expect to receive the `Result`
object via `boost::shared_ptr`. This leads to the conversion functions
heap-allocating a copy of the returned `Result`, just so it can be passed
via shared_ptr.

If we consider that:

a) each Client API wrapper object will end-up uniquely owning a copy of the
System API `Result` and

b) the Client API objects themselves are referenced by shared_ptr (because
they are bound-up to AS3 & JavaScript, and we want by-reference semantics).

Then it doesn't make much sense to use shared_ptr. An in-line copy of the
System API `Result` will give better locality (rather than dereferencing
another pointer), and we can also avoid the shared_ptr overhead.

This change also paves the way for eliding copies of the `Result` objects
by stealing/moving them directly into the CAL wrappers.


note: 
1. do not "copy ctor" in converter and make SCR have a copy of "Result" instead. No changes in
wrapper classes but SCR now do "copy ctor" to copy "Result".

ProgrammePtr
Converter::operator()(const NS_COBALT_SYSTEM::Result& result, ProgrammePtr) const
{
    return boost::make_shared<SystemClientProgramme>(result);
}

class SystemClientProgramme : public Programme 
{
    public:
         -explicit SystemClientProgramme(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
         +explicit SystemClientProgramme(const NS_COBALT_SYSTEM::Result& sysResult)
            :scResult(sysResult)
            {}
};

class SystemClientResult
{
    public:
        explicit SystemClientResult(const NS_COBALT_SYSTEM::Result& sysResult)
            : sysResult(sysResult)
        {}

        int64_t getValidUntil() const
        {
            return sysResult.validUntil;
        }

        std::string getRecordIdentifier() const
        {
            return sysResult.recordIdentifier;
        }

        const NS_COBALT_SYSTEM::Result& getResult() const
        {
            return sysResult;
        }
        ...

    private:
        NS_COBALT_SYSTEM::Result sysResult;  // note:
};


* 5c9a202 DEVARCH-9266: Uranium.Client.System: Get rid of defunct `wrapSysResult()` and `wrapSysResults()` in Converter.
-> LGTM. 

* 3e896f3 DEVARCH-9265: Uranium.Client.System: Reserve vector capacity when converting System Broker results.
-> LGTM. 


04.13
======
Megre john's commits and on top of it, make fixes to this problem. Build is fine against the latest
master.


<commit-log>
DEVARCH-8092: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

The UI is provided two metadata APIs for events; ctv.linearmetadata.Event which is an old API and
ctv.enhancedmetadata.Event which is an new API. It has been reported that
ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value.

It appears that getSynopsis() is never been implemented since the current implementation of
`SystemClientEvent` is broken in either it uses wrong field of Event or do not handle getSynopsis()
at all to return a synopsis to UI.

This commit fixes `SystemClientEvent` to use the right field for synopsis and to implement missing
mappings between the Event Repository and SystemClientEvent for DTT and IP source. It also revises
the related test cases to test getSynopsis() of various `SystemClientEvent` instances for both
sources.

note: 2015.04.27. fix the jira number since it was 8092

DEVARCH-9135: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

The UI is provided two metadata APIs for events; ctv.linearmetadata.Event which is an old API and
ctv.enhancedmetadata.Event which is an new API. It has been reported that
ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value.

It appears that getSynopsis() is never been implemented since the current implementation of
`SystemClientEvent` is broken in either it uses wrong field of Event or do not handle getSynopsis()
at all to return a synopsis to UI.

This commit fixes `SystemClientEvent` to use the right field for synopsis and to implement missing
mappings between the Event Repository and SystemClientEvent for DTT and IP source. 


DEVARCH-9135: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

The UI is provided two metadata APIs for events; ctv.linearmetadata.Event which is an old API and
ctv.enhancedmetadata.Event which is an new API. It has been reported that
ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value.

It appears that getSynopsis() is never been implemented since the current implementation of
`SystemClientEvent` is broken in either it uses wrong field of Event or do not handle getSynopsis()
at all to return a synopsis to UI.

This commit fixes `SystemClientEvent` to use the right field for synopsis and to implement missing
mappings between the Event Repository and SystemClientEvent for DTT and IP source. 

This commit revises the related test cases to test getSynopsis() of various `SystemClientEvent`
instances for both sources.


={============================================================================
*kt_dev_uv_task_005* task:01: nexus tools for both hmax and hwei

04.13
======
While waiting for the official release from Huawei for nexusMgr, told that do some work; that is to
have a temp solution for a release. The old nexus tools for Humax and the new nexus tools for Huawe.
How?

1. Have a different directory for each oems

/source/DEVARCH/Polonium/Polonium.NexusInspect.deprecated/   // for hmax
/source/DEVARCH/Polonium/Polonium.NexusInspect/              // for hwei

2. Use exclude feature

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh
   -> exclude 'deprecated' version

# N.B: This is a temporary for a QIP release and to be removed.
export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect.deprecated"

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh
   -> exclude the normal version

# N.B: This is a temporary for a QIP release and to be removed.
export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"

3. No other changes and it means that the output( exec_wrapper and inspect ) will have the same name
and will be placed under the same in install root.


04.14
======

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-db_t2200.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh

Cobalt/Cobalt.Common Cobalt/Cobalt.System.Production Cobalt/Cobalt.System.API
Polonium/Polonium.NexusInspect.deprecated Polonium/Polonium.GSTNexus Polonium/Polonium.GSTTSPacer
Polonium/Polonium.PCMPlayback

SUCCESS: building branch zb/DEVARCH-8092-TEMP: 6906d73df6ea4cbccab97d984434f623e0779902 with
ZB_CFG="humax.2100" zb-make listprojects

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t4000.sh

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7231.sh*
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh*
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-dn360t.sh*


04.15
======

For all humax, have a insepct.deprecated only.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-db_t2200.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh
OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t4000.sh

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7231.sh, (372) do not have both
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh  (370) inspect only
OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-dn360t.sh*        do not have both


Did a full build for hmax1000 and hwei370. For the rest, did run "listtarget".


<commit-log>
DEVARCH-8092: NexusInspect: Add join and uninit pair in the nexus-inspect.

In order to support new API, Huawei introduce a new pair of calls in a user side to call these APIs
and to use Nexus resources returned from these API. 

This commit add the pair in nexus-inspect to have valid Nexus resource handles.


DEVARCH-8092: NexusInspect: Add the previous nexus-inspect as a deprecated project in the build.

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

This commit add the previous nexus-inspect to the build as deprecated project.


<hwei-372>
DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 372. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hwei-370>
DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 370. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hwei-360>
DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 360. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-1000>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 1000. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-2100>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2100. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-2200>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2200. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 

<hmax-4000>
DEVARCH-8092: NexusInspect: Add the exclude project for Humax 4000. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 


04.17
======

kpark@wll1p04345:~/source/DEVARCH$ git show --name-only 9614591..8e5e127
commit 8e5e127afa70e2a44c4c3619e5e670632d7181ea
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:55:31 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 4000.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t4000.sh

commit f67ccfa1d2cf87ce1cefad35b9248b799d47c88d
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:54:47 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2200.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-db_t2200.sh

commit d0fffbfd698e49fcf59e1179891279e65542eee4
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:53:59 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 2100.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t2100.sh

commit 62dd1be6052b2b0bae64916e638ebd74ec173c7d
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:52:48 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Humax 1000.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh

<c>
commit 9801a6417b9103304552a89790e8bd0aeb0f816c
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:51:21 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 360.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-dn360t.sh

<c>
commit a372b5a0e145208244bd731776bae804488e1d12
Author: Kit Park <kit.park@youview.com>
Date:   Wed Apr 15 15:37:28 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 370.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

<c>
commit 64f3b343c5f8185584ff0a8b978cd5c6d400a224
Author: Kit Park <kit.park@youview.com>
Date:   Thu Apr 16 12:17:43 2015 +0100

    DEVARCH-8092: NexusInspect: Add the exclude project for Huawei 372.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7231.sh

<c>
commit 1ddd353a2c42128a16170473e5cb8787e932cfaa
Author: Kit Park <kit.park@youview.com>
Date:   Thu Apr 16 12:31:02 2015 +0100

    DEVARCH-8092: NexusInspect: Add the previous nexus-inspect as a deprecated project in the build.
    
    In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
    interim solution to pick up the previous for platforms that are not moved to the new approach yet
    and to pick up the new for platforms that already moved.
    
    This commit adds the previous nexus-inspect to the build as deprecated project.

Polonium/Polonium.NexusInspect.deprecated/Makefile.am
Polonium/Polonium.NexusInspect.deprecated/autogen.sh
Polonium/Polonium.NexusInspect.deprecated/configure.ac
Polonium/Polonium.NexusInspect.deprecated/nexus-inspect.pc.in
Polonium/Polonium.NexusInspect.deprecated/scripts/exec-then-cleanup-app.sh.in
Polonium/Polonium.NexusInspect.deprecated/src/exec-then-cleanup-app.c
Polonium/Polonium.NexusInspect.deprecated/src/nexus-inspect.c

<c>
commit 55a17f211662c36dd7f5f1a615bf09f4691a8240
Author: Kit Park <kit.park@youview.com>
Date:   Fri Apr 10 16:47:36 2015 +0100

    DEVARCH-8092: NexusInspect: Add join and uninit pair in the nexus-inspect.
    
    In order to support new APIs, Huawei introduces a new pair of calls in a user side to call these APIs
    and to use Nexus resources returned from these API.
    
    This commit add this pair in nexus-inspect to have valid Nexus resource handles.

Polonium/Polonium.NexusInspect/src/nexus-inspect.c


<c>
commit 9d26684984cecc7bed044ddbd5c6eee1b1be13da
Author: Kit Park <kit.park@youview.com>
Date:   Tue Feb 24 13:10:29 2015 +0000

    DEVARCH-9131: NexusInspect: Fix up makefile to build nexus utilities.
    
    There is no common solution for nexus utility features since both OEMs have different nexusMgr
    implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
    implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
    DEVARCH-8101, and DEVARCH-8080.
    
    This commit has the necessary changes of makefile to build nexus utility and to fix the link order
    problem when linking with nexusMgr shared library.

Polonium/Polonium.NexusInspect/Makefile.am


<c>
commit cc9940795c80a6df88ab7cdf69eac4037d56f732
Author: Kit Park <kit.park@youview.com>
Date:   Tue Feb 24 13:07:04 2015 +0000

    DEVARCH-9130: NexusInspect: Add nexus-inspect tool.
    
    There is no common solution for nexus utility features since both OEMs have different nexusMgr
    implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
    implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
    DEVARCH-8101, and DEVARCH-8080.
    
    This commit add the nexus-inspect which uses the proposed APIs to show information of nexus
    resources. Since the tool is no longer needed in production, this commit moves it into
    $prefix/devel/bin.

Polonium/Polonium.NexusInspect/Makefile.am
Polonium/Polonium.NexusInspect/src/nexus-inspect.c
Polonium/Polonium.NexusInspect/src/nexus-inspect.h


<c>
commit 2519985aab9d51d439ee45dcf0f78f7fe6524b34
Author: Kit Park <kit.park@youview.com>
Date:   Tue Feb 24 13:03:18 2015 +0000

DEVARCH-9129: NexusInspect: Add nexus-release tool and revise the exec-wrapper

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus-release which is revised to use the proposed APIs to release nexus
resources and the updated exec-wrapper to use the same.

Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c
Polonium/Polonium.NexusInspect/src/nexus-release.c

<c>
commit 44026356e1a233cb9b9853f3abe8b0525f655622
Author: Kit Park <kit.park@youview.com>
Date:   Tue Mar 3 10:13:29 2015 +0000

    DEVARCH-9128: NexusInspect: Add the nexus-inspect to the build for Huawei dn370t
    
    There is no common solution for nexus utility features since both OEMs have different nexusMgr
    implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
    implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
    DEVARCH-8101, and DEVARCH-8080.
    
    This commit add the nexus utility project to the build for Huawei dn370t. OEM dependency unification
    effort should now make it possible to build this project for Huawei as well.

OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

04.21
======
<host>
DEVARCH-8092: NexusInspect: Add the exclude project for PC host. 

In order to support release of both OEMs when transition to new nexus tools is incomplete, this is a
interim solution to pick up the previous for platforms that are not moved to the new approach yet
and to pick up the new for platforms that already moved. 


DEVARCH-8092: NexusInspect: Add more and the latest reports to the nexus-inspect. 

Add all inspection reports from the previous implementation and also the
latest from the architect group such as reports of audio decoder and STC.

Here is the reports on Huawei 370 engineering release that implements the
proposal.

==================================================
  Nexus inspect v0.1

BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
  StcChannelHandle         : 0xe12831e4
  VideoDecoderHandle       : 0xe12850f8
  Ac3EncodeHandle          : 0x0
  VideoWindowHandle        : 0x0
  DmaHandle                : 0x0
  Pid                      : 0
  PlaypumpHandle[0]        : 0x0
  Started                  : 1
  Coded                    : 1920 x 1088,  Display: 1920 x 1080
  Current PTS              : 27953744
  Num decoded frames       : 107242
  Num displayed frames     : 214482
  Started                  : 4201120
  TSM                      : 4201156
  Locked                   : 4201192
  Sample rate              : 4201228
  Num decoded frames       : 1
  Current fifo depth       : 0.389481% (2042 of 524288)
  PlaypumpHandle[0]        : 0x0             // see
  Started                  : 4201120
  TSM                      : 4201156
  Locked                   : 4201192
  Sample rate              : 4201228
  Num decoded frames       : 0
  PlaypumpHandle[1]        : 0x0             // see
  STC timebase source      : NEXUS_TimebaseSourceType_ePcr
  STC pid channel          : 0xcee16880
  STC max PCR error        : 255
  STC PCR track range      : NEXUS_TimebaseTrackRange_e61ppm
  PID channel              : enabled
  PID                      : 101
  Transport type           : NEXUS_TransportType_eTs
  Original transport type  : NEXUS_TransportType_eTs
  Playback                 : false
  CC errors                : 0
BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
==================================================


04.22
======
Found that there is a redundant output and a problem not printing out as
expected. Sorted.

DEVARCH-8092: NexusInspect: Fix redundant and missing output in the
nexus-inspect. 

Fix redundant and missing output when run the nexus-inspect. No functional
changes and updated the report on Huawei 370 engineering release that
implements the proposal.

==================================================
  Nexus inspect v0.1

BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
  StcChannelHandle         : 0xe12831e4
  VideoDecoderHandle       : 0xe12850f8
  Ac3EncodeHandle          : 0x0
  VideoWindowHandle        : 0x0
  DmaHandle                : 0x0
  Pid                      : 0
  PlaypumpHandle[0]        : 0x0
  Started                  : 1
  Coded                    : 1920 x 1088,  Display: 1920 x 1080
  Current PTS              : 2932777648
  Num decoded frames       : 19278
  Num displayed frames     : 38555
  Started                  : 1
  TSM                      : 1
  Locked                   : 1
  Sample rate              : 48000
  Num decoded frames       : 36212
  Num error frames         : 0
  Num fifo overflows       : 0
  Num fifo underflows      : 2932781277
  Current PTS              : 1
  Current fifo depth       : 0.318718% (1671 of 524288)
  Started                  : 0
  TSM                      : 0
  Locked                   : 0
  Sample rate              : 0
  Num decoded frames       : 0
  Num error frames         : 0
  Num fifo overflows       : 0
  Num fifo underflows      : 0
  Current PTS              : 1
  STC timebase source      : NEXUS_TimebaseSourceType_ePcr
  STC pid channel          : 0xc6a79c00
  STC max PCR error        : 255
  STC PCR track range      : NEXUS_TimebaseTrackRange_e61ppm
  Pid channel              : enabled
  Pid                      : 101
  Transport type           : NEXUS_TransportType_eTs
  Original transport type  : NEXUS_TransportType_eTs
  Playback                 : false
  CC errors                : 0
BKNI_Malloc(linuxuser): allocated:8788(39) freed:8788(39) peak:8788
==================================================


={============================================================================
*kt_dev_uv_task_006* task:05: sort out test failures

Use this as a mother ticket

https://jira.youview.co.uk/browse/DEVARCH-4122


<systemmediarecordcachetest>

2015-04-20_03-28-00:

DEVARCH/Uranium/Uranium.Client.System/test/local-media-library/SystemMediaRecordCacheTest.cpp

15 Uranium/Uranium.Client.System (systemmediarecordcachetest)

works okay on host:

:~/builds/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/Uranium/Uranium.Client.System/test/local-media-library$ ./systemmediarecordcachetest 
.......

OK (7)


fails on:

http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/872/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/878/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/880/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/882/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/883/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/884/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/889/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/894/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/897/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/898/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/900/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/901/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/475/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/488/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1235/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                         
 

from log: #901, 872,

PASS: systemmediarecordtest
.......F

FAIL: systemmediarecordcachetest


from: #475

PASS: systemmediarecordtest
.......F../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:282: Failure
Actual function call count doesn't match EXPECT_CALL(*systemLML, getMediaRecord(_))...
         Expected: to be called 4 times
           Actual: called once - unsatisfied and active
F


../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:279: ERROR: mock object '*systemLML' should be deleted but never is. Its address is @0x989d644.
../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:282: ERROR: mock object '*systemLML' should be deleted but never is. Its address is @0x989d644.
ERROR: 1 leaked mock object found at program exit.
FAIL: systemmediarecordcachetest


from: #488

PASS: systemmediarecordtest
.......F../../../test/local-media-library/SystemMediaRecordCacheTest.cpp:282: Failure
Actual function call count doesn't match EXPECT_CALL(*systemLML, getMediaRecord(_))...
         Expected: to be called 4 times
           Actual: called once - unsatisfied and active
F

FAIL: systemmediarecordcachetest


from: #1235

PASS: systemmediarecordtest
.......F

FAIL: systemmediarecordcachetest


2015-04-27_03-28-01:

10 Uranium/Uranium.Client.System (systemmediarecordcachetest)

http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/905/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/912/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/917/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/921/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://stimpy:8080/job/_Zinc.Build__master__release__debian-7-x86_64/922/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                                             
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/515/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/519/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/522/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/524/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/526/artifact/error-logs - Uranium/Uranium.Client.System - systemmediarecordcachetest                                                              
 

04.28
======

1. For a debug log:

--- a/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp
+++ b/Uranium/Uranium.Client.System/src/local-media-library/SystemMediaRecordCache.cpp
@@ -295,7 +295,7 @@ void MediaRecordCache::replayInitialUpdates( const FutureValue< void >& fv )
     }
     else
     {
-        URANIUM_INFO( "Replaying LibraryContentChange events" );
+        URANIUM_INFO( "KT: from cacheReady: Replaying LibraryContentChange events" );
         applyUpdatesSync( initialUpdates );
     }
     initialUpdates.clear();
@@ -330,6 +330,7 @@ MediaRecordCache::applyUpdatesSync(
             {
                 try
                 {
+                    URANIUM_INFO( "KT: call lml->getMediaRecord( " <<  change.first << " )" );
                     updateCache( cache,
                                  propagatedClientChanges,
                                  change.second,



2. Suggested the generic approach to have timeout value rather than the fixed
in tests.

CPPUNIT_ASSERT( updatedFuture.wait_for(boost::posix_time::seconds(3)) );


/** Defines time in milliseconds for which probes will be waiting for an event to occur. */

Copper/CopperAnnouncement.Client.System/test/SystemClientAnnouncementServiceTest.cpp:   const int32_t TEST_TIMEOUT = 5000;


ZINC_ASSERT_WITHIN_TIMEOUT(f.isComplete(), TEST_TIMEOUT);


/**
 * Unit test assertion macro to check that an expression becomes true in the
 * given time.
 *
 * It polls every 100ms
 */
#define ZINC_ASSERT_WITHIN_TIMEOUT(expression, timeoutms) \
    do { \
        bool success = false; \
        for (int _assert_within_timeout_i = 0; \
             _assert_within_timeout_i < (timeoutms+99)/100; \        //
             ++_assert_within_timeout_i) { \
            if (expression) { \
                success = true; \
                break; \
            } \
            usleep(1000 * 100); \                                    // 100ms
        } \
        CPPUNIT_ASSERT_MESSAGE( #expression " did not happen within " #timeoutms "ms", success); \
    } \
    while (0);


<eventrepositorytest>
note: this is different from 

linear-metadata/EventRepositoryTest.cpp
282:    CPPUNIT_TEST_SUITE(EventRepositoryTest);
311:CPPUNIT_TEST_SUITE_REGISTRATION(EventRepositoryTest);

602:    CPPUNIT_TEST_SUITE(SystemClientEventRepositoryTest);
636:CPPUNIT_TEST_SUITE_REGISTRATION(SystemClientEventRepositoryTest);


2015-04-20_03-28-00:

 5 Uranium/Uranium.Client.System (eventrepositorytest)

works okay on host:

:~/builds/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/Uranium/Uranium.Client.System/test/linear-metadata$ ./eventrepositorytest


from log:

/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Zinc/Zinc.Build/jenkins/cppunit2junit.sh: line 74: 23726 Segmentation fault      ZINC_CPPUNIT_XML=1 $test_exe 9> ${results}
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Document is empty

^
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Start tag expected, '<' not found

^
unable to parse /var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml
FAIL: eventrepositorytest


only seen on COS:

52: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1236/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
51: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1237/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
49: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1239/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
46: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1242/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
33: http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1255/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest


2015-04-27_03-28-01:

  3 Uranium/Uranium.Client.System (eventrepositorytest)

http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1287/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1285/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest
http://zebedee:8080/job/_Zinc.Build__master__release__CentOS-6.4-x86_64/1265/artifact/error-logs - Uranium/Uranium.Client.System - eventrepositorytest

/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Zinc/Zinc.Build/jenkins/cppunit2junit.sh: line 74: 16627 Segmentation fault      ZINC_CPPUNIT_XML=1 $test_exe 9> ${results}
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Document is empty

^
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml:1: parser error : Start tag expected, '<' not found

^
unable to parse /var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/test-results/uranium-client-system-eventrepositorytest-results.xml
FAIL: eventrepositorytest


04.29
======
Made a fix, ran an test under stressed env, worked okay, built okay, created
JIRA for this. Ready to code review?


DEVARCH-9473: Fix test failing - systemmediarecordcachetest

The latest build reports have shown failures on this test and this seems to
have failed on various host and target distributions.

2015-04-27_03-28-01
10 Uranium/Uranium.Client.System (systemmediarecordcachetest)

2015-04-20_03-28-00:
15 Uranium/Uranium.Client.System (systemmediarecordcachetest)

The problem is that it uses a short fixed time value in which the result
depends on a system load when running a test and this is why the result is
flaky. This commit has increased value, more general and robust approach in
line with other test.


={============================================================================
*kt_dev_uv_task_007* task:06: playback audio only IP channel

04.29
======
https://jira.youview.co.uk/browse/DEVARCH-8828

We have audio-only IP channel 567 to test this. Currently, it works fine on Huawei but not on Humax. Seems to be an OEM issue.

04.30
======
On hwei 372, channel 567, OK

root# cat audio 
    397327:49:35.879 nexus_audio_module: Audio:
    397327:49:35.883 nexus_audio_module:  handles: ape:bcb93000 dsp:b6278004
    397327:49:35.890 nexus_audio_module:  img ctxt:bb291800
    397327:49:35.896 nexus_audio_module:  settings: wd:1 id:1
    397327:49:35.901 nexus_audio_module:  channel0: (bcac0000) locked ~
    397327:49:35.908 nexus_audio_module:   started=y, codec=1
    397327:49:35.913 nexus_audio_module:   fifo: 32286/262144 (12%), queued: 56
    397327:49:35.920 nexus_audio_module:   TSM: enabled pts=0x4e4b6638 pts_stc_diff=-7 errors=0
    397327:49:35.929 nexus_audio_module:   watchdogs: 0
    397327:49:35.934 nexus_audio_module:  channel1: (bcba0000) 
    397327:49:35.940 nexus_audio_module:   started=n, codec=0
    397327:49:35.945 nexus_audio_module:   fifo: 0/0 (0%), queued: 0
    397327:49:35.952 nexus_audio_module:   TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
    397327:49:35.960 nexus_audio_module:   watchdogs: 0
    397327:49:35.965 nexus_audio_module:  channel2: (bc450000) 
    397327:49:35.970 nexus_audio_module:   started=n, codec=0
    397327:49:35.976 nexus_audio_module:   fifo: 0/0 (0%), queued: 0
    397327:49:35.982 nexus_audio_module:   TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
    397327:49:35.990 nexus_audio_module:   watchdogs: 0
Audio:
 handles: ape:bcb93000 dsp:b6278004
 img ctxt:bb291800
 settings: wd:1 id:1
 channel0: (bcac0000) locked ~
  started=y, codec=1
  fifo: 32286/262144 (12%), queued: 56
  TSM: enabled pts=0x4e4b6638 pts_stc_diff=-7 errors=0
  watchdogs: 0
 channel1: (bcba0000) 
  started=n, codec=0
  fifo: 0/0 (0%), queued: 0
  TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
  watchdogs: 0
 channel2: (bc450000) 
  started=n, codec=0
  fifo: 0/0 (0%), queued: 0
  TSM: disabled pts=0x0 pts_stc_diff=0 errors=0
  watchdogs: 0

note: when tune to 112(QVC) which is not on air, can see no audio is running
and no channel is locked.

Q: what's the codec?

MPEG_AUDIO         76 local/refsw/BSEAV/lib/media/bmpeg_audio_util.h #define B_MPEG_AUDIO_LAYER_III      0x01


On hmax 1000, channel 567, NOT OK but mostly no audio but can hear blop sound
in a sec. Also do not have proc device.

On hwei 370, channel 567, OK. But NO proc device to see.



From local/refsw/nexus/modules/core/7420/include/nexus_audio_types.h

/***************************************************************************
Summary:
Audio codecs
***************************************************************************/
typedef enum NEXUS_AudioCodec 
{
    NEXUS_AudioCodec_eUnknown = 0,    /* unknown/not supported audio format */
    NEXUS_AudioCodec_eMpeg,           /* MPEG1/2, layer 1/2. This does not support layer 3 (mp3). */
    NEXUS_AudioCodec_eMp3,            /* MPEG1/2, layer 3. */
    NEXUS_AudioCodec_eAac,            /* Advanced audio coding. Part of MPEG-4 */
    NEXUS_AudioCodec_eAacAdts=NEXUS_AudioCodec_eAac,
    NEXUS_AudioCodec_eAacLoas,        /* Advanced audio coding. Part of MPEG-4 */
    NEXUS_AudioCodec_eAacPlus,        /* AAC plus SBR. aka MPEG-4 High Efficiency (AAC-HE) with ADTS (Audio Data Transport Format) */
    NEXUS_AudioCodec_eAacPlusLoas =NEXUS_AudioCodec_eAacPlus,    /* AAC plus SBR. aka MPEG-4 High Efficiency (AAC-HE), with LOAS (Low Overhead Audio Stream) sync and LATM mux */
    NEXUS_AudioCodec_eAacPlusAdts,    /* AAC plus SBR. aka MPEG-4 High Efficiency (AAC-HE), with ADTS (Audio Data Transport Format) sync and LATM mux */
    NEXUS_AudioCodec_eAc3,            /* Dolby Digital AC3 audio */
    NEXUS_AudioCodec_eAc3Plus,        /* Dolby Digital Plus (AC3+ or DDP) audio */
    NEXUS_AudioCodec_eDts,            /* Digital Digital Surround sound, uses non-legacy frame-sync */
    NEXUS_AudioCodec_eLpcmDvd,        /* LPCM, DVD mode */
    NEXUS_AudioCodec_eLpcmHdDvd,      /* LPCM, HD-DVD mode */
    NEXUS_AudioCodec_eLpcmBluRay,     /* LPCM, Blu-Ray mode */
    NEXUS_AudioCodec_eDtsHd,          /* Digital Digital Surround sound, HD, uses non-legacy frame-sync, decodes only DTS part of DTS-HD stream */
    NEXUS_AudioCodec_eWmaStd,         /* WMA Standard */
    NEXUS_AudioCodec_eWmaPro,         /* WMA Professional */
    NEXUS_AudioCodec_eAvs,            /* AVS */ 
    NEXUS_AudioCodec_ePcm,            /* PCM audio - Generally used only with inputs such as SPDIF or HDMI. */ 
    NEXUS_AudioCodec_ePcmWav,         /* PCM audio with Wave header - Used with streams containing PCM audio */
    NEXUS_AudioCodec_eAmr,            /* Adaptive Multi-Rate compression (typically used w/3GPP) */
    NEXUS_AudioCodec_eDra,            /* Dynamic Resolution Adaptation.  Used in Blu-Ray and China Broadcasts. */
    NEXUS_AudioCodec_eCook,           /* Real Audio 8 LBR */
    NEXUS_AudioCodec_eAdpcm,          /* MS ADPCM audio format */
    NEXUS_AudioCodec_eSbc,            /* Sub Band Codec used in Bluetooth A2DP audio */
    NEXUS_AudioCodec_eDtsLegacy,      /* Digital Digital Surround sound, legacy mode (14 bit), uses legacy frame-sync */
    NEXUS_AudioCodec_eMax
} NEXUS_AudioCodec;


<2>
run custom inspect tool on humax when on a radio channe. started but fifo
depth is nearly zero.

        Audio status: started TSM 
                Codec 1
                Sample rate 0
                Num decoded frames 0
                Num error frames 0
                Num fifo overflows 0
                Num fifo underflows 141
                Current PTS 0
                Current fifo depth 0.000000% (0 of 262144)

On the same box, but on the normal av channel.

        Audio status: started TSM locked 
                Codec 1
                Sample rate 48000
                Num decoded frames 2822
                Num error frames 0
                Num fifo overflows 0
                Num fifo underflows 17
                Current PTS 3639679926
                Current fifo depth 1.586914% (4160 of 262144)

On the PVR2, shows constant updates:

  Started                  : 1
  TSM                      : 1
  Locked                   : 1
  Sample rate              : 48000
  Num decoded frames       : 16193
  Num error frames         : 0
  Num fifo overflows       : 0
  Num fifo underflows      : 3671371537
  Current PTS              : 2146556080
  Current fifo depth       : 1.327515% (3480 of 262144)


<3>
[root@HUMAX hd1]# *** 134364:45:47.303 
nexus_playpump: NEXUS_Playpump_OpenPidChannel: 0xc72ada00 detected duplicated pid 1002 (0x8df17e80:1) with non-compatible settings


==============================================================================
vim:tw=100:ts=3:ft=help:norl:
