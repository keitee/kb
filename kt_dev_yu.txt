*kt_dev_uv*                                                             tw=100

|kt_dev_uv_set_001| setup printer
|kt_dev_uv_set_002| setup email
|kt_dev_uv_set_003| setup: humax build the stack
|kt_dev_uv_set_004| huawei: to revert back the previous version
|kt_dev_uv_set_005| setup: screen connection
|kt_dev_uv_set_006| filegateway
|kt_dev_uv_set_007| setup: huawei build the stack
|kt_dev_uv_set_008| setup: oem staging and toolchains
|kt_dev_uv_set_009| setup: boxes
|kt_dev_uv_set_010| setup: git for dev and oem

|kt_dev_uv_stack_000| stack: builds
|kt_dev_uv_stack_001| stack: build examples
|kt_dev_uv_stack_002| stack: build: deploy
|kt_dev_uv_stack_003| stack: startup and tree
|kt_dev_uv_stack_004| stack: oem configs
|kt_dev_uv_stack_005| stack: brcm debug level
|kt_dev_uv_stack_006| stack: netflix ps line
|kt_dev_uv_stack_007| stack: virtual rcu
|kt_dev_uv_stack_008| stack: startup mw
|kt_dev_uv_stack_009| stack: nexusmgr
|kt_dev_uv_stack_010| stack: commit
|kt_dev_uv_stack_011| stack: log

|kt_dev_uv_stack_100| stack: element names
|kt_dev_uv_stack_101| stack: vanadium: runBrowser
|kt_dev_uv_stack_102| stack: vanadium: binding
|kt_dev_uv_stack_103| stack: vanadium: remote debug
|kt_dev_uv_stack_104| stack: LSR (local storage repository)
|kt_dev_uv_stack_105| stack: uranium
|kt_dev_uv_stack_106| stack: cal
|kt_dev_uv_stack_107| stack: cal: metadata creation
|kt_dev_uv_stack_108| stack: cal: metadata: event structures and mapping
|kt_dev_uv_stack_109| stack: cal: metadata: event connection to application
|kt_dev_uv_stack_110| stack: cal: metadata: how events get updated
|kt_dev_uv_stack_111| stack: cal: future producer and event producer
|kt_dev_uv_stack_112| stack: cal: metadata: summary
|kt_dev_uv_stack_113| stack: cal: test
|kt_dev_uv_stack_114| stack: build pc target
|kt_dev_uv_stack_115| stack: text epg
|kt_dev_uv_stack_116| stack: future
|kt_dev_uv_stack_117| stack: metadata and dbus
|kt_dev_uv_stack_118| stack: sandbox

|kt_dev_uv_stack_120| stack: cppunit

|kt_dev_uv_stack_150| stack: network
|kt_dev_uv_stack_200| stack: dbus

|kt_dev_uv_stack_200| commands TODO:

|kt_dev_uv_wiki_001| dbus-monitor

|kt_dev_uv_hwei_001| stack: convert ro filesystem to rw

|kt_dev_uv_task_001| task:01: nexusMgr
|kt_dev_uv_task_002| task:02: DEVARCH-8869
|kt_dev_uv_task_003| task:02: DEVARCH-7508
|kt_dev_uv_task_004| task:03: DEVARCH-9135


# ============================================================================
#{
={============================================================================
*kt_dev_uv_set_001* setup: printer

1. install cups
sudo apt-get install cups

2. add printers via cups admin page 
See this page, add user to the printer group, and browse to localhost, and
follow the instructions to add printers. 

www.howtoforge.com/how-to-install-a-canon-printer-on-debian-and-debian-like-systems

3. use printer names from this page.
https://wiki.youview.co.uk/display/canvas/How+To+-+Set+up+printers


={============================================================================
*kt_dev_uv_set_002* setup: email

1. The evolution under debian do not work. Forced to use icedove, OWA and
phone instead.

2. Clone the git repo.
Follow this page.
https://wiki.youview.co.uk/display/canvas/How+To+-+Get+access+to+git-dev+repositories


={============================================================================
*kt_dev_uv_set_003* setup: humax build the stack

{install-package}
1. Can see package files from the repo
http://devarch-deb:8080/job/DEBs/ws/DEBS/

-rw-r--r--  1 kpark kpark 205942756 Jan  8 10:30 adobe-flex4-sdk_4.1.0.16076withairsdk2.5-3_i386.deb
-rw-r--r--  1 kpark kpark   5310170 Jan  8 10:30 adobe-stagecraft_2.5.2.3.20120518-3_i386.deb
-rw-r--r--  1 kpark kpark  80815260 Jan  8 10:35 generic-stbgcc-4.4.5-2.0_20120927-2_i386.deb
-rw-r--r--  1 kpark kpark  24399388 Jan  8 10:37 humax-dtr-t1000-staging_20140718H20.2.0-3_i386.deb
-rw-r--r--  1 kpark kpark 328730796 Jan  8 10:48 humax-stbgcc-4.5.3-2.4_20130321-2_i386.deb

2. Or can use apt-get install on the command line.
sudo apt-get install map-dir-and-exec


{1} build-stack
$ cd ~/sources/
zb-virtual-slave zb-shell
ZB_CFG=humax.1000 zb-make

note: shall have pysical data dir under /. when use sym link to the home, failed to build.

<check-package>
dpkg-query -l | grep humax


{2} update-cds; core driver software
https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Humax+DTR-T1000+T1000+H21.5.0

note: follow instruction, CTK. 


{3} update the zinc whcich was built
1. follow "boot from HDD" instruction from:
https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Humax+DTR-T1000+T1000+H21.5.0


{layout}
/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409$ tree -L 3
.
|-- opt
|   `-- zinc-trunk
|       |-- bin
|       |-- devel
|       |-- include
|       |-- lib
|       |-- libexec
|       |-- oss
|       |-- platform
|       |-- share
|       |-- tests
|       `-- var
`-- usr -> /opt/oem-staging/huawei-bcm7409/usr


={============================================================================
*kt_dev_uv_set_004* huawei: to revert back the previous version

touch /opt/cds/download/smdebug

setItem oem.software.version 11.11.11

setItem oem.activatedsoftware.coredevicesoftware.version 11.01.01

setItem oem.activatedsoftware.manufacturerconfiguration.version 1

setItem oem.activatedsoftware.coredevicesoftware.platformapiversion 1.2.0

setItem oem.activatedsoftware.platformsoftware.version 1.3.4

setItem oem.activatedsoftware.platformconfiguration.version 1

Goes to settings -> Dev. Mgt. -> Software Update. Then will update a box from usb stick.

note: Only for ATK.


={============================================================================
*kt_dev_uv_set_005* setup: screen connection

sudo screen /dev/ttyS0 115200

to close screen use Ctrl-A, k, y. Do not use Ctrl-C as it can kill processes running on the box.


={============================================================================
*kt_dev_uv_set_006* filegateway

$ scp -r kit.park@filegateway.youview.co.uk:/export/repos/huawei/from_huawei/PVR1_DN370T/Huawei_DN370T_B37SP33_Eng_Release_20150331_for_YVHUAWEI-6751 ./


={============================================================================
*kt_dev_uv_set_007* setup: huawei build the stack

sudo apt-get install huawei-dn370t-toolchain
sudo apt-get install huawei-dn370t-staging
sudo apt-get install huawei-stbgcc-4.5.3-2.4

note: this will picks up the correct file from the link below.
http://devarch-deb.dev.youview.co.uk:8080/job/DEBs/ws/DEBS/

huawei-dn370t-toolchain_20120927-2_i386.deb
huawei-dn370t-nexus_20131104-2_i386.deb
huawei-dn370t-staging_20140804-2_i386.deb

https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Huawei+DN370T+PVR1+B37SP11

ZB_CFG=huawei.370 zb-make


={============================================================================
*kt_dev_uv_set_008* setup: oem staging and toolchanis

https://wiki.youview.co.uk/display/canvas/OEM+Staging+and+Toolchains?src=search

.
|-- adobe
|   `-- stagecraft
|-- Adobe
|   |-- Flex4SDK -> flex_sdk_4.1.0.16076_with_air_sdk_2.5_linux
|   `-- flex_sdk_4.1.0.16076_with_air_sdk_2.5_linux
|-- HipChat
|   |-- bin
|   |-- lib
|   `-- share
|-- oem-staging            // note: it does have headers or possibly sources
|   |-- huawei-bcm7409
|   |-- huawei-dn370t -> huawei-bcm7409
|   |-- humax-dtr_t1000
|   `-- oem-staging.md5
|-- pac
|   |-- lib
|   |-- LICENSE
|   |-- pac
|   |-- README
|   |-- res
|   `-- utils
|-- stagecraft-2.0 -> stagecraft-2.5.2.3.20120105-sl6-directfb1.4-windowed-C12M2-maine_coon-release-20120518
|-- stagecraft-2.5.2.3.20120105-sl6-directfb1.4-windowed-C12M2-maine_coon-release-20120518
|   |-- bin
|   `-- share
`-- toolchains
    |-- generic-stbgcc-4.4.5-2.0
    |-- huawei-bcm7409 -> generic-stbgcc-4.4.5-2.0
    |-- huawei-stbgcc-4.5.3-2.4
    |-- humax-dtr_t1000 -> generic-stbgcc-4.4.5-2.0
    `-- humax-stbgcc-4.5.3-2.4

/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409
drwxr-xr-x 4 kpark kpark 4096 Feb  3 08:06 opt/
lrwxrwxrwx 1 kpark kpark   35 Jan 30 08:28 usr -> /opt/oem-staging/huawei-bcm7409/usr/

<refsw>
The refsw headers from staging:
/opt/oem-staging/huawei-bcm7409/usr/local/refsw/nexus

This is copied to build root to be used in building and these are the same:
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/refsw/nexus

<oem-code>
The OEM header files: note: this means that if changes OEM code and want to build any in the full
stack build env, then need to update staging as well before building.

/opt/oem-staging/huawei-bcm7409/
./usr/local/include/nexusMgr/nexusMgr.h
./usr/local/include/nexusMgr/nexusMgr.c
./usr/local/lib/nexusMgr.h
./usr/local/lib/pkgconfig/nexusMgr.pc

For example, inspect tool and this is link option: path when build inspect tool
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib


={============================================================================
*kt_dev_uv_set_009* setup: boxes

{hmax} 
onlydebug (Humax)

||Hostname||FQDN||IP Address||MAC Address||
humax-0873   humax-0873.dev.youview.co.uk    172.20.35.27   00:03:78:4B:7A:2B

/.ssh -> /var/tmp/authorized_keys


{hwei}
TestHw123 (Huawei)

huawei-04877 huawei-04877.dev.youview.co.uk  172.20.33.192  20:F3:A3:70:D1:94

<1>
if delete this, then will boot from flash
/mnt/nand/userdata/data/rw_cmd


={============================================================================
*kt_dev_uv_set_010* setup: git for dev and oem

<git-oems>
url = gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git
url = gitolite@git-humax.dev.youview.co.uk:/nexusMgr.git

<git-local>
https://git-dev.dev.youview.co.uk/?p=nexusMgr.git;a=summary

https://git-dev.dev.youview.co.uk/

git clone -b huawei/dn370t gitolite@git-dev:/nexusMgr.git XX

/home/kpark/git-dev/nexusMgr        " cloned
/home/kpark/git-dev/nexusMgr-WIP    " work space for hwei 370

{oem}
/home/kpark/git-oem/*

<hmax>
note: need to figure out branch name
git clone gitolite@git-humax.dev.youview.co.uk:/nexusMgr.git nexusHmax

<hwei>
git clone -b huawei/dn370t gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git nexusHwei


={============================================================================
*kt_dev_uv_stack_000* stack: builds

<log>
+++ Build log dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-debian-7-x86_64/logs +++

However, there are no log files there.


<ET>
Many of these tools rely on the environment variable "ET" to find your checkout of the DEVARCH repo.
The zb-make and zb-build-with-progress tools build the stack out of your source tree, so you can
carry on developing while a build is running. You control this behaviour with the "ZB_BUILD_DIR"
environment variable, so make sure it exists and is writeable by yourself. Similarly, you'll
probably want the tools available in your PATH, so add these to your ~/.profile:

export PATH=~/sources/zinc-git-tools:$PATH
export ET=~/sources/DEVARCH/

<after-zb-shell>
$ env | grep ^Z
ZINC_USER_BUILD_TYPE=release ~
ZINC_HOST_PREFIX=/opt/zinc-trunk
ZINC_REMOTE_LOGGING_HOST=localhost
ZINC_SRC_ROOT=/data/builds/master/huawei.370/DEVARCH
ZINC_HOST_3PS=/data/builds/master/huawei.370/DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack
ZINC_BUILD_ROOT=/data/builds/master/huawei.370/zinc-build-root 
ZINC_DESTDIR=/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409 ~
ZINC_BUILD_DIR=/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409 ~
ZINC_NATIVE_BUILD_ROOT=/data/builds/master/huawei.370/zinc-build-root
ZB_HOST_CONFIG=huawei-bcm7409
ZINC_BUILD_CFG=debian-7-x86_64
ZINC_INSTALL_ROOT=/data/builds/master/huawei.370/zinc-install-root
ZB_CFG=huawei.370 ~
ZB_BUILD_DIR=/data/builds ~
ZB_BRANCH=master ~
ZINC_USER_HOST_PREFIX=/opt/zinc-trunk
ZINC_HOST_CFG=huawei-bcm7409
ZINC_3PS_HOST_PREFIX=/opt/zinc-trunk/oss
ZINC_REMOTE_LOGGING_PORT=4560
ZINC_BUILD_TYPE=release


<build-and-install-dir>

note: the build system picks up any dirs in the tree and try to build those.

note: source is copied to /data/builds/.../DEVARCH
1. ~/source/DEVARCH

2. The build root has only output files such as o and a:
can run make here:

/data/builds/<ZB_BRANCH> /huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/
   Polonium.NexusInspect/Makefile
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/
   Polonium.NexusInspect/Makefile

3. But the makefile uses sources from the copied sources as

/data/builds/<ZB_BRANCH> /huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c
/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c

-c -o nexus_inspect-nexus-inspect.o `test -f 'src/nexus-inspect.c' || echo
'/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/'`src/nexus-inspect.c


/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/
`-- zinc-trunk
    |-- bin
    |-- devel
    |-- include
    |-- lib
    |-- libexec
    |-- oss
    |-- platform
    |-- share
    |-- tests
    `-- var

/bin/
airlauncher.sh*
audiofeedbackd*
avahi-launcher*
babysitterd*
cadmiumcontentacquisitiond*
cobaltmetadatabrokerd*
copperannouncementd*
CopperDownloader*
copperlocalstoragerepod*
crbd*
dbusredirect*
dbussenddaemon*
dbuswaitbusname*
deleteTree*
device-manager-launcher*
dial-server*
dial-server-launcher.sh*
exec-then-cleanup-app*
exec-then-cleanup-app.sh*
exec-with-cache*
generate-http-user-agent*
getChildItems*
getItem*
http-dbus-bridge*
http-dbus-bridge-launcher.sh*
https-cache-proxy*
ironmetadatad*
linearsourced*
linearsource-launch*
linearsource-launch-and-sandbox*
lsr-config*
nexus-inspect*
nickelmediad*
on-demand-launcher*
onscreenidd*
onscreenidd-launch*
osmiumd*
pcmplaybackd*
provisioninginformationparser*
purge-polipo-diskcache.sh*
python_launcher.sh*
queryNetworkManager*
radiumairlauncher*
radiumd*
remindersd*
runBrowser.sh*
runNetflix.sh*
run-stagecraft2-functions.sh*
runStagecraft2.sh*
run-stagecraft2-with-cache.sh*
sandbox-drop-privileges*
setItem*
setpgid-and-exec*
sodiumd*
splashScreen*
start-service-over-dbus.sh*
storagemanagementd*
tunerd*
uimanagerd*
w3cEngine*
watcher*
yv-mainui*
yv-remote-booking-agent-activate*
yv-remote-booking-agent-watcher*
yv-start-services.sh*


<zb-virtual-slave>
zb-virtual-slave zb-make
{
  /source/zinc-git-tools/zb/zb-load-config.sh
  {
      pre: ET, ZB_CFG 

      configure_git_for_zb() {

      conf zb.huawei.360.host-config huawei-dn360t
      conf zb.huawei.370.host-config huawei-bcm7409
      conf zb.huawei.372.host-config huawei-bcm7231
      conf zb.humax.1000.host-config humax-dtr_t1000
      }

      do : set ZB_BUILD_DIR, slave_dir=/data/builds/master/pc
  }

   real_path="${ZB_BUILD_DIR}/$branch"
   virtual_path="${ZB_BUILD_DIR}/_virtual_"

  + real_path=/data/builds/<BRANCH>
  + virtual_path=/data/builds/_virtual_

  note: "bash -c string" execute string on the given shell.

  + exec map-dir-and-exec /data/builds/master:/data/builds/_virtual_ /bin/bash -c '"zb-make"  		
  2> >( sed -u "s|/data/builds/_virtual_|/data/builds/master|" >&2 ) \
  | sed -u "s|/data/builds/_virtual_|/data/builds/master|"'
}


<zb-shell>


<zb-make>
{
  if [ -n "${ZB_FORCE_BRANCH}" ]; then
      echo "Using overridden branch."
  else
   <load-config>
   source $where_am_i/zb/zb-load-config.sh
   {
      note: pick up brach name or force it

      # Branch of git repository for which build is to be performed
      if [ -n "${ZB_FORCE_BRANCH}" ]; then
          echo "Overriding branch to build to: ${ZB_FORCE_BRANCH}"
          branch=$ZB_FORCE_BRANCH
          # TODO: Validate that the branch exists.
      else
          if [ -f "$ET/.git/rebase-merge/head-name" ]; then
              # We are in the middle of rebasing
              branch="$(cut -b 12- < "$ET/.git/rebase-merge/head-name")"
          else
              branch=$(GIT_DIR=$ET/.git git symbolic-ref HEAD | cut -b 12- )
          fi
      fi

      ++++ GIT_DIR=/home/kpark/source/DEVARCH//.git
      ++++ git config zb.huawei.install-prefix
      +++ var=/opt/zinc-trunk
      ++ ZINC_USER_HOST_PREFIX=/opt/zinc-trunk

      export ZB_BRANCH=$branch
      ++ ZB_BRANCH=DEVARCH-8092

      if
          slave_dir=$ZB_SLAVE_DIR/$ZB_CFG
      else
          slave_dir=$ZB_BUILD_DIR/$branch/$ZB_CFG
      fi

      note: ZB_BUILD_DIR is set

      ++ slave_dir=/data/builds/DEVARCH-8092/huawei.370
   }

   ZB_HOST_CONFIG=host 
   cd $ET
   + cd /home/kpark/source/DEVARCH

   ++ git rev-parse HEAD
   + commit_sha=fa4948db164a29775e0804795047ebefdce29e5d

   + git update-ref -m zb-make refs/heads/zb/DEVARCH-8092 7887ca28ed3a1480959ce9f5d1804405b3b5bfdc
   + branch=zb/DEVARCH-8092

   note: one time and can clone again by deleting a makefile?

   # Create repo
   if [ ! -e "$slave_dir/DEVARCH/Zinc/Zinc.Build/Makefile" ]; then
       echo "Creating new build slave - \
         $branch because $slave_dir/DEVARCH/Zinc/Zinc.Build/Makefile doesn't exist"
       rm -Rf "$slave_dir/DEVARCH/"
       mkdir -p "$slave_dir/DEVARCH"
       cd "$slave_dir"
       git clone -s --depth=1 --branch "$branch" "$ET" "$slave_dir/DEVARCH"
   fi

   build_cmd=${ZB_BUILD_CMD-"make"}
   + build_cmd=make

   <setvars>
   {
      source ../../*/*/setvars-$ZB_HOST_CONFIG.sh
      + source ../../Zinc/Zinc.Build/setvars-host.sh

      export HOST_TRIPLE="${ARCH}-pc-linux-gnu"
      ++ export HOST_TRIPLE=x86_64-pc-linux-gnu
      export BUILD_TRIPLE=${HOST_TRIPLE}

      :~/source$ ls -al ./DEVARCH/OEM.Huawei/OEM.Huawei.3rdPartyStack/
      -rwxr-xr-x 1 kpark kpark 1671 Jan  7 15:55 setvars-huawei-bcm7231.sh
      -rwxr-xr-x 1 kpark kpark 1598 Jan  7 15:55 setvars-huawei-bcm7409.sh
      -rwxr-xr-x 1 kpark kpark 1670 Jan  7 15:55 setvars-huawei-dn360t.sh

      :~/source$ ls -al ./DEVARCH/OEM.Humax/OEM.Humax.3rdPartyStack/
      -rw-r--r-- 1 kpark kpark 1822 Jan  7 15:55 setvars-humax-db_t2200.sh
      -rw-r--r-- 1 kpark kpark 1653 Jan  7 15:55 setvars-humax-dtr_t1000.sh
      -rw-r--r-- 1 kpark kpark 1930 Jan  7 15:55 setvars-humax-dtr_t2100.sh
      -rw-r--r-- 1 kpark kpark 2177 Jan  7 15:55 setvars-humax-dtr_t4000.sh
      {
         note: this is for host tools and cwd.

         <setvars-common>
         ++ source ../../Zinc/Zinc.Build/setvars-common.sh
         +++ where_am_i=/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Zinc/Zinc.Build
         {
            {
            if [[ "${ZINC_HOST_CFG}" != "${ZINC_BUILD_CFG}" ]]
            then
               # Cross compilation

               echo "Cross compiling. Host cfg: '${ZINC_HOST_CFG}' Build cfg: '${ZINC_BUILD_CFG}'"
            }

           note: 'roots'

           +++ ZINC_SRC_ROOT=/data/builds/DEVARCH-8092/huawei.370/DEVARCH
           +++ ZINC_BUILD_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-build-root
           +++ ZINC_INSTALL_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root


           +++ ZINC_BUILD_DIR=/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-debian-7-x86_64

           # CXXFLAGS
           if [[ "${ZINC_BUILD_TYPE}" == "debug" ]]
           then
              export CXXFLAGS="-g -O0 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
              export CFLAGS="-g -O0 -pipe ${EXTRA_CFLAGS:-}"
           else
              export CXXFLAGS="-DNDEBUG -O3 -pipe -pthread ${EXTRA_CXXFLAGS:-}"
              export CFLAGS="-DNDEBUG -O2 -pipe ${EXTRA_CFLAGS:-}"
           fi
           +++ [[ debug == \d\e\b\u\g ]]
           +++ export 'CXXFLAGS=-g -O0 -pipe -pthread '
           +++ CXXFLAGS='-g -O0 -pipe -pthread '
           +++ export 'CFLAGS=-g -O0 -pipe '
           +++ CFLAGS='-g -O0 -pipe '

           +++ PKG_CONFIG=/data/builds/master/pc/zinc-install-root/debug/debian-7-x86_64/oss/bin/pkg-config

           # N.B. We are setting -rpath-link here, but DO NOT use this to set -rpath.
           # We should leave libtool to deal with -rpath. Setting it here leads to test executables
           # linking against the old (already installed) libraries.
           #
           
           LDFLAGS="-L${ZINC_DESTDIR}${ZINC_HOST_PREFIX}/lib
           -L${ZINC_DESTDIR}${ZINC_3PS_HOST_PREFIX}/lib -Wl,--as-needed
           -Wl,-rpath-link,${ZINC_DESTDIR}${ZINC_HOST_PREFIX}/lib
           -Wl,-rpath-link,${ZINC_DESTDIR}${ZINC_3PS_HOST_PREFIX}/lib"
           
           +++
           LDFLAGS='-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/lib
           -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib
           -Wl,--as-needed
           -Wl,-rpath-link,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/lib
        -Wl,-rpath-link,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib'

         }
      }

      note: still running setvars-host.sh

      # We can't build these for PC
      export ZINC_EXCLUDE_PROJECTS="Polonium.GSTNexus Polonium.NexusInspect Polonium.PCMPlayback"

      ++ warnings_flags='-Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
      -Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format
      -Werror=missing-braces -Werror=nonnull -Werror=parentheses -Werror=pointer-sign
      -Werror=return-type -Werror=sequence-point -Werror=strict-overflow=1 -Werror=trigraphs
      -Werror=unknown-pragmas -Werror=unused-function -Werror=unused-label -Werror=unused-value
      -Werror=volatile-register-var -fdiagnostics-show-option'

      # Enable "Safe" STL wrappers in debug builds.
      # 
      if [[ "${ZINC_BUILD_TYPE}" == "debug" ]]; then
          export CPPFLAGS+=" -D_GLIBCXX_DEBUG "
      fi
      ++ [[ debug == \d\e\b\u\g ]]
      ++ export 'CPPFLAGS+= -D_GLIBCXX_DEBUG '
      ++ CPPFLAGS+=' -D_GLIBCXX_DEBUG '

      # -fstack-protector-all enables the insertion of "canaries" to detect stack-smashing at
      # runtime. The cost of such checks are supposedly small.
      export CPPFLAGS+=" -fstack-protector-all "
      ++ export 'CPPFLAGS+= -fstack-protector-all '
      ++ CPPFLAGS+=' -fstack-protector-all '
   }

   note: back to zb-make

   + build_date='2015-01-09 08:58:17+00:00'
   (
      # Create an environment more like the build servers
      unset DBUS_SESSION_BUS_ADDRESS

      set -o pipefail
      $build_cmd "$@" 2> >( sed -u "s | $ZINC_SRC_ROOT | $ET|" >&2 ) \
      | sed -u "s| $ZINC_SRC_ROOT| $ET|"
   ) && exit_code=0 || exit_code=1 # Don't want to exit on failure

   + unset DBUS_SESSION_BUS_ADDRESS
   + set -o pipefai
l

+ make buildtools
+ make
+ sed -u 's|/data/builds/master/pc/DEVARCH|/home/kpark/source/DEVARCH|'
 sed -u "s|$ZINC_SRC_ROOT|$ET|" >&2 
++ sed -u 's|/data/builds/master/pc/DEVARCH|/home/kpark/source/DEVARCH|'

<main-makefile>
make[1]: Entering directory `/home/kpark/source/DEVARCH/Zinc/Zinc.Build'
make[1]: Leaving directory `/home/kpark/source/DEVARCH/Zinc/Zinc.Build'

+++ Source: /home/kpark/source/DEVARCH/ +++
+++ Host build dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409 +++
+++ Build log dir: /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/logs +++
+++ Install location: /data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk +++
+++ release build +++
+++ Building Zinc/Zinc.3rdPartyStack +++

[gmock] libtool: link: (cd "lib/.libs" && rm -f "libgtest_main.so.0" && ln -s "libgtest_main.so.0.0.0" "libgtest_main.so.0")

note: for vanadium

+++ Building Vanadium/Vanadium.Common +++
run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-BigData.xml
doc/htmlfragments/interface-BigData.html
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/doc-interface.html.template

run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-AnotherInterface.xml
doc/htmlfragments/interface-AnotherInterface.html
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/doc-interface.html.template

make[1]: Entering directory `/home/kpark/source/DEVARCH//Zinc/Zinc.Build'

Generating configure files... may take a while.

Found new dependencies; recursively calling docmakedepend.
$*='/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-Farm.xml';
         $dependents_list='/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/enum-Animal.xml'

mv -f .deps/Profiler.Tpo .deps/Profiler.Plo

Found new dependencies; recursively calling docmakedepend.
$*='/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-ChannelService.xml';
         $dependents_list='/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/struct-BroadcastData.xml
             /data/builds/DEVARCH-8092/huawei.370/DEVARCH/Lead/Lead.System.API/data/introspection-xml/struct-ChannelData.xml'


+++ Building Vanadium/Vanadium.Client.API +++

make[1]: Entering directory `/home/kpark/source/DEVARCH//Zinc/Zinc.Build'
make[2]: Leaving directory `/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Lead/Lead.System.API'
Generating configure files... may take a while.
make[2]: Entering directory `/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Lead/Lead.System.API'
/bin/mkdir -p include src
/bin/mkdir -p include/mock
/bin/mkdir -p mock-python

run_xml2cpp.sh
/home/kpark/source/DEVARCH//Lead/Lead.System.API/data/introspection-xml/interface-AnotherInterface.xml
src/AnotherInterface.cpp
--template=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/share/zinc-system-api/templates/base.cpp.template 

mv -f .deps/acl-utils-test.Tpo .deps/acl-utils-test.Po
rm -rf /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Vanadium/Vanadium.Client.API


note: to search, use "Building\|NexusInspect" since logs are intermixed.


+++ Building Polonium/Polonium.NexusInspect +++

mkdir -p
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect

cd /data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect
&& /home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect/configure
--prefix=/opt/zinc-trunk --build=x86_64-pc-linux-gnu --host=mipsel-linux
--enable-shared --disable-static

make -C
/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect

cd /home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect && /bin/bash
/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/missing
--run automake-1.11 --foreign

make[2]: Entering directory
`/data/builds/DEVARCH-8092/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusInspect'

mipsel-linux-gcc -DPACKAGE_NAME=\"nexus-inspect\"
-DPACKAGE_TARNAME=\"nexus-inspect\" -DPACKAGE_VERSION=\"0.1\"
-DPACKAGE_STRING=\"nexus-inspect\ 0.1\"
-DPACKAGE_BUGREPORT=\"darren.garvey@youview.com\"
-DPACKAGE_URL=\"http://www.youview.com\" -DPACKAGE=\"nexus-inspect\"
-DVERSION=\"0.1\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1
-DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1
-DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1
-DLT_OBJDIR=\".libs/\" -I.
-I/home/kpark/source/DEVARCH//Polonium/Polonium.NexusInspect
-I/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/include
-isystem
/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/include
-I/opt/oem-staging/huawei-bcm7409/usr/include
-I/opt/oem-staging/huawei-bcm7409/usr/local/include  -D_GNU_SOURCE=1  -fPIC
-fvisibility=hidden -DVERSION=\"0.1\" -DPACKAGE=\"nexus-inspect\"
-DPKG_BIN_DIR=\"/opt/zinc-trunk/bin\" -O3 -g -Wall -Wextra -std=c99
-Werror=implicit-function-declaration -D_REENTRANT -pthread -DNEXUS_MODE_proxy
-DPLATFORM=97409 -DNEXUS_PLATFORM=97409 -DLINUX -D_GNU_SOURCE=1 -DHAVE_RSRVD=1
-DKBUILD_MODNAME=nexus -DPLATFORM=97409 -DNEXUS_PLATFORM=97409
-DBCHP_CHIP=7420 -DBCHP_VER=BCHP_VER_C1 -DBSTD_CPU_ENDIAN=BSTD_ENDIAN_LITTLE
-DBINT_REENTRANT_CONFIG=BINT_REENTRANT -DBMEM_REENTRANT_CONFIG=BMEM_REENTRANT
-DNEXUS_BASE_OS_linuxkernel=1 -DNEXUS_PROFILE_OS_linuxkernel
-DNEXUS_MODE_driver -DNEXUS_PLATFORM_7410_UMA_32b=1 -DNEXUS_IPLICENSING=1
-DNEXUS_OTPMSP=1 -DNEXUS_USERCMD=1 -DNEXUS_HAS_KEYLADDER_SUPPORT=1
-DNEXUS_KEYLADDER=1 -DNEXUS_SECUREACCESS=1 -DNEXUS_SECURERSA=1
-DNEXUS_SECURITY_EXT_KEY_IV -DNEXUS_SECURITY_SC_VALUE -DNEXUS_FRONTEND_NIM
-DNEXUS_AC3 -DNEXUS_CONFIG_IMAGE -DNEXUS_DDP -DNEXUS_HAS_PLATFORM
-DNEXUS_HAS_CORE -DNEXUS_HAS_BASE -DNEXUS_HAS_I2C -DNEXUS_HAS_GPIO
-DNEXUS_HAS_PWM -DNEXUS_HAS_LED -DNEXUS_HAS_IR_INPUT -DNEXUS_HAS_IR_BLASTER
-DNEXUS_HAS_KEYPAD -DNEXUS_HAS_INPUT_CAPTURE -DNEXUS_HAS_UHF_INPUT
-DNEXUS_HAS_RFM -DNEXUS_HAS_FRONTEND -DNEXUS_HAS_SPI -DNEXUS_HAS_SECURITY
-DNEXUS_HAS_DMA -DNEXUS_HAS_TRANSPORT -DNEXUS_HAS_VIDEO_DECODER
-DNEXUS_HAS_AUDIO -DNEXUS_HAS_SURFACE -DNEXUS_HAS_GRAPHICS2D
-DNEXUS_HAS_PLAYBACK -DNEXUS_HAS_DISPLAY -DNEXUS_HAS_ASTM
-DNEXUS_HAS_SYNC_CHANNEL -DNEXUS_HAS_HDMI_OUTPUT -DNEXUS_HAS_SMARTCARD
-DNEXUS_HAS_SIMPLE_DECODER -DNEXUS_HAS_EEPROM -DNEXUS_HAS_SCART
-DBADS_312X_VER=BCHP_VER_A0 -DBHAB_312X_VER=BCHP_VER_A0 -DBHDM_CEC_SUPPORT
-DBHSM_AEGIS_SUPPORT -DBHSM_SC_VALUE -DBHSM_SECURE_PI_SUPPORT=1
-DBHSM_SECURE_PI_SUPPORT_KEYLADDER=1 -DBHSM_SECURE_PI_SUPPORT_MISC=0
-DBHSM_SECURE_PI_SUPPORT_OTPMSP=1 -DBSP_GENERIC -DBXVD_USE_CUSTOM_IMAGE
-DB_HAS_AVI=1 -DB_HAS_RMFF=1 -DGRCPACKET_SUPPORT=1
-DRAP_AACSBR_PASSTHRU_SUPPORT -DRAP_AACSBR_SUPPORT -DRAP_AC3ENC_SUPPORT
-DRAP_AC3_PASSTHRU_SUPPORT -DRAP_AC3_SUPPORT -DRAP_DDP_PASSTHRU_SUPPORT
-DRAP_DDP_SUPPORT -DRAP_DDP_TO_AC3_SUPPORT -DRAP_DRA_PASSTHRU_SUPPORT
-DRAP_DSOLA_SUPPORT -DRAP_DTSBROADCAST_PASSTHRU_SUPPORT
-DRAP_DTSHD_PASSTHRU_SUPPORT -DRAP_LPCMDVD_SUPPORT -DRAP_MPEG_PASSTHRU_SUPPORT
-DRAP_MPEG_SUPPORT -DRAP_PCMWAV_SUPPORT -DRAP_PCM_SUPPORT
-DRAP_REALAUDIOLBR_PASSTHRU_SUPPORT -DRAP_SRC_SUPPORT -DUNIFIED_ITB_SUPPORT
-DDUAL_OUTPUT
-DNDEBUG -O2 -pipe  -MT nexus_inspect-nexus-inspect.o -MD -MP -MF
.deps/nexus_inspect-nexus-inspect.Tpo -c -o nexus_inspect-nexus-inspect.o
`test -f 'src/nexus-inspect.c' || echo
'/data/builds/DEVARCH-8092/huawei.370/DEVARCH/Polonium/Polonium.NexusInspect/'`src/nexus-inspect.c


<install-root>
When install root updated?

:+++ ZINC_INSTALL_ROOT=/data/builds/DEVARCH-8092/huawei.370/zinc-install-root
:+++ export ZINC_SRC_ROOT ZINC_BUILD_ROOT ZINC_INSTALL_ROOT

Used in build and link:

-DINSTALLDIR="/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/debian-7-x86_64/oss/lib" 

<example>
+ INSTALL='/usr/bin/install -C'

/bin/bash ./libtool   --mode=install /usr/bin/install -C exec-then-cleanup-app nexus-inspect nexus-release 
   '/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin'

/usr/bin/install -C scripts/exec-then-cleanup-app.sh 
   '/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin'

/usr/bin/install -C -m 644 nexus-inspect.pc 
   '/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib/pkgconfig'

libtool: install: /usr/bin/install -C exec-then-cleanup-app 
   /data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/
   opt/zinc-trunk/bin/exec-then-cleanup-app


={============================================================================
*kt_dev_uv_stack_001* stack: build examples

<one>
cd =~/sources/DEVARCH/
ZB_CFG="huawei.370" zb-make Polonium/Polonium.NexusInspect
ZB_CFG="huawei.370" zb-make
ZB_CFG=humax.1000 zb-make

ZB_FORCE_BRANCH="xxx" ZB_CFG="huawei.370" zb-make Polonium/Polonium.NexusInspect

# -n dry run
ZB_FORCE_BRANCH="xxx" ZB_OVERWRITE_REMOTE_BRANCH=1 ZB_CFG="huawei.370" zb-make Polonium.NexusInspect -n

ZB_FORCE_BRANCH="xxx" ZB_OVERWRITE_REMOTE_BRANCH=1 ZB_CFG="huawei.370" zb-make Polonium.NexusInspect


<two> check if env is configured properly or do compile manually
cd ~/source/DEVARCH/
ZB_CFG=huawei.370 zb-shell

mipsel-linux-gcc 
mipsel-linux-g++ 

For huwawei as of 04.02

mipsel-linux-g++ (Broadcom stbgcc-4.4.5-2.0) 4.4.5
Copyright (C) 2010 Free Software Foundation, Inc.


<three>
$ cd ~/sources/
ZB_CFG=huawei.370 zb-shell
zb-make

OR

ZB_CFG=huawei.370 zb-virtual-slave zb-shell
zb-make

zb-virtual-slave zb-build-with-progress

<tips>

note: can specify make build target
ZINC_SILENT_RULES=1 zb-virtual-slave zb-build-with-progress Zinc.AIR.CTV.Tests-install

ZINC_SILENT_RULES=1 zb-virtual-slave zb-build-with-progress Zinc.AIR.CTV.Tests

DEVARCH/Zinc/Zinc.Build/setvars-common.sh
391-
392-# Automake "silent-rules" can be turned on to reduce the amount of repetitive
393-# information printed when building. Warnings and errors are all still printed
394-# so using silent-rules by default is safe.
395:if [[ "${ZINC_SILENT_RULES}" == 1 ]]; then
396-    export MAKEFLAGS="$MAKEFLAGS V=0"
397-fi


ZINC_INCREMENTAL

DEVARCH/Zinc/Zinc.Build/Makefile
129-#
130-$(patsubst %,$(ZINC_BUILD_DIR)/%buildtools.built,$(PACKAGES) $(zinc3ps) $(zinc_bash_test)) : $(ZINC_BUILD_DIR)/%buildtools.built :
131- $(info +++ Building $* +++)
132-ifeq (${ZINC_DRY_RUN},)  
133:ifeq (${ZINC_INCREMENTAL},)
134- -rm -rf $(HOST_BUILD_DIR)/$*
135:endif # ! ZINC_INCREMENTAL


ZINC_SKIP_TESTS

DEVARCH/Zinc/Zinc.Build/Makefile
37-envtest:=$(and ${ZINC_HOST_CFG},${ZINC_HOST_3PS},${ZINC_HOST_PREFIX},${ZINC_SRC_ROOT},${ZINC_BUILD_ROOT},${PKG_CONFIG},${PKG_CONFIG_PATH},${LDFLAGS},${CPPFLAGS},${ZINC_BUILD_DIR},${BUILD_TRIPLE})
38-
39-DO_CHECK_FLAGS=
40-
41:# Set ZINC_SKIP_TESTS to skip running of the "make check"
42:ifeq (${ZINC_SKIP_TESTS},)


<use-autoconf> to run makefile on built-root or build nexusMgr
git clone -b huawei/dn370t gitolite@git-huawei.dev.youview.co.uk:/nexusMgr.git nexusTest

cd nexusMgr

note: use BRANCH
export ET=/data/builds/master/huawei.370/DEVARCH/
export ET=/data/builds/<BRANCH>/huawei.370/DEVARCH/

ZINC_USER_BUILD_TYPE=release source $ET/OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

./autogen.sh

export HOST_TRIPLE=mipsel-linux

./configure --host=$HOST_TRIPLE --with-pic --enable-shared --prefix=$PWD/install

make && make install

make clean; make;
can see output and o file under this.

/data/builds/master/huawei.370/zinc-build-root/release-huawei-bcm7409/Polonium/Polonium.NexusRelease

But uses sources from: note: DEVARCH

`test -f 'src/exec-then-cleanup-app.c' || echo
'/data/builds/master/huawei.370/DEVARCH/Polonium/Polonium.NexusRelease/'`src/exec-then-cleanup-app.c


={============================================================================
*kt_dev_uv_stack_002* stack: build: deploy

  973  2015-02-02 12:28:38 vim DEVARCH/.git/config 
  974  2015-02-02 12:29:10 which rsync
  975  2015-02-02 12:29:21 ssh root@humax-0873

cd ~/source
./setup-humax/setup-humax.sh -h humax-0873
./setup-humax/setup-humax.sh -f humax-0873

zb-deploy -o humax.1000 -- -r


-f <file(s)>  Copy one or more files to the device without doing anything drastic, such as killing
daemons or wiping out application sandboxes.

zb-deploy -o humax.1000 -f textEPG


<setup-xx-sh>
note: no zinc-trunk handling. okay to run it as a standalone.

note: this requires RW rfs.

#/   -r            Reboot the box when this script has completed.

#/   -f            Force first time setup. Does additional installation of
#/                 eg. password-less login, rsync, scp.

#
# firstTimeSetup() {
# 
# + debug 'Setting up passwordless login...'
# + debug 'Installing rsync on Humax device...'
# + debug 'Installing custom login script (./setup-humax/custom-login.sh) to /usr/local/bin/ ...'

$ ./setup-huawei/setup-huawei.sh -f 172.20.33.192

git config zb.huawei.370.deploy-host "hostname of your box here"


<zb-deploy> 
note: careful when use -o option. not to use humax1000 and spend some hours why not working. see
there must be dot(.) so "humax.1000" but not "humax1000"

note: NOT run in sub-shell such as zb-shell. Otherwise, see error:

+ tput sgr0
tput: unknown terminal "xterm"
+ rm -rf /tmp/setup-humax.sh.29807
+ tput sgr0
tput: unknown terminal "xterm"

note: this resync between install-root and box:/opt

-o type of device for which deployment is done where permitted values are

 device-spec   : Description
 -----------------------------------------
 humax.1000 : for Humax T1000 boxes
 humax.2100 : for Humax T2100 boxes
 huawei.360 : for Huawei DN360T boxes
 huawei.370 : for Huawei DN370T boxes
 huawei.372 : for Huawei DN372T boxes


zb-deploy -o huawei.370 -- -r
{
    source $where_am_i/zb/zb-load-config.sh

    // zb.default-config=pc
    //
    if [ -z "${ZB_CFG}" ]; then
       export ZB_CFG=$(get_conf default-config "env")
    fi

    source */*/setvars-$ZB_HOST_CONFIG.sh &>/dev/null
    + source OEM.Humax/OEM.Humax.3rdPartyStack/setvars-humax-dtr_t1000.sh

    deploy_build():
    + deploy_build
    + '[' -z /home/kpark/source/setup-humax ']'
    + '[' -z /home/kpark/source/setup-humax/setup-humax.sh ']'
    which $setup_script_path/$setup_script 2>/dev/null)"
    which $setup_script_path/$setup_script 2>/dev/null)
    which $setup_script_path/$setup_script 2>/dev/null
    ++ which /home/kpark/source/setup-humax/setup-humax.sh
    + '[' '!' -x /home/kpark/source/setup-humax/setup-humax.sh ']'
    + vendor=humax
    +
    patch_a_tron_script=
      /data/builds/_virtual_/humax.1000/DEVARCH/OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh
    
    
    note: call setup-xx-sh
    + /home/kpark/source/setup-humax/setup-humax.sh -z
        /data/builds/_virtual_/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk
        -P
        file:///data/builds/_virtual_/humax.1000/DEVARCH/OEM.Humax/OEM.Humax.Scripts/patch-host-for-yv-zinc.sh
        humax-0873
}


={============================================================================
*kt_dev_uv_stack_003* stack: startup

cds: core driver software

/opt/cds/etc/rc.user

root# pwd
/opt

root# ls -al
drwxr-xr-x    8 root     root           149 Dec 25 04:33 .
drwxr-xr-x   17 root     root           259 Dec 25 04:33 ..
drwxr-xr-x    3 root     root            33 Dec 25 02:36 adobe
drwxr-xr-x   12 root     root           247 Dec 25 04:33 cds
drwxr-xr-x    4 root     root            84 Dec 18 14:20 netflix
drwxr-xr-x    4 root     root            39 Dec 25 04:33 stagecraft-2.0
lrwxrwxrwx    1 root     root            15 Dec 25 04:33 ui -> /mnt/psi/ui_psi
dr-xr-xr-x    4 root     root            57 Dec 25 02:36 youview
drwxr-xr-x    9 root     root           186 Dec 25 04:33 zinc


<zinc>
root# pwd
/opt/zinc/bin

root# ls
CopperDownloader                     onscreenidd-launch
MediaRouterDbusSpy                   osmiumd
airlauncher.sh                       pcmplaybackd
audiofeedbackd                       persistedpairingrepository_utils.py
avahi-launcher                       provisioninginformationparser
babysitterd                          purge-polipo-diskcache.sh
cadmiumcontentacquisitiond           python_launcher.sh
cobaltmetadatabrokerd                queryNetworkManager
copperannouncementd                  radiumairlauncher
copperlocalstoragerepod              radiumd
crbd                                 remindersd
dbusredirect                         run-stagecraft2-functions.sh
dbussenddaemon                       run-stagecraft2-with-cache.sh
dbuswaitbusname                      runBrowser.sh
deleteTree                           runNetflix.sh
device-manager-launcher              runStagecraft2.sh
dial-server                          sandbox-drop-privileges
dial-server-launcher.sh              setItem
exec-with-cache                      setpgid-and-exec
generate-http-user-agent             sodiumd
getChildItems                        splashScreen
getItem                              start-and-wait-for-busname.sh
http-dbus-bridge                     start-service-over-dbus.sh
http-dbus-bridge-launcher.sh         storagemanagementd
https-cache-proxy                    tunerd
ironmetadatad                        uimanagerd
linearsource-launch                  w3cEngine
linearsource-launch-and-sandbox      watcher
linearsourced                        yv-mainui
lsr-config                           yv-remote-booking-agent-activate
nickelmediad                         yv-remote-booking-agent-watcher
on-demand-launcher                   yv-start-services.sh
onscreenidd

[root@HUMAX bin]# ls
CopperDownloader*                 litaniumsystemmanagerd*
airlauncher.sh*                   lsr-config*
appfactoryreset*                  nexus-inspect*
appstart*                         nickelmediad*
appversion*                       on-demand-launcher*
audiofeedbackd*                   onscreenidd*
avahi-launcher*                   onscreenidd-launch*
babysitterd*                      osmiumd*
bronzemediad*                     pcmplaybackd*
cadmiumcontentacquisitiond*       provisioninginformationparser*
cobaltmetadatabrokerd*            purge-polipo-diskcache.sh*
copperannouncementd*              python_launcher.sh*
copperlocalstoragerepod*          queryNetworkManager*
crbd*                             radiumairlauncher*
dbusredirect*                     radiumd*
dbussenddaemon*                   remindersd*
dbuswaitbusname*                  run-stagecraft2-functions.sh*
deleteTree*                       run-stagecraft2-with-cache.sh*
device-manager-launcher*          runBrowser.sh*
dial-server*                      runNetflix.sh*
dial-server-launcher.sh*          runStagecraft2.sh*
exec-then-cleanup-app*            sandbox-drop-privileges*
exec-then-cleanup-app.sh*         setItem*
exec-with-cache*                  setpgid-and-exec*
formathdd*                        sodiumd*
generate-http-user-agent*         splashScreen*
getChildItems*                    start-service-over-dbus.sh*
getItem*                          storagemanagementd*
goldsystemtimed*                  tunerd*
http-dbus-bridge*                 uimanagerd*
http-dbus-bridge-launcher.sh*     w3cEngine*
https-cache-proxy*                watcher*
indiumd*                          yv-mainui*
ironmetadatad*                    yv-remote-booking-agent-activate*
linearsource-launch*              yv-remote-booking-agent-watcher*
linearsource-launch-and-sandbox*  yv-start-services.sh*
linearsourced*


<lib-third-party>
/usr/local/lib

directfb-1.4-15            libfusion-1.4.so.15.0.0    libpng14.so.14.3.0
libdirect-1.4.so.15        libfusion.so               libsawman-1.5.so.0
libdirect-1.4.so.15.0.0    libinit.so                 libsawman-1.5.so.0.0.4
libdirect.so               libjpeg.so                 libsawman.so
libdirectfb-1.4.so.15      libjpeg.so.7               libshim_nexus.so
libdirectfb-1.4.so.15.0.0  libjpeg.so.7.0.0           libz.so
libdirectfb.so             libnexus.so                libz.so.1
libfreetype.so             libnexusMgr.so             libz.so.1.2.6
libfreetype.so.6           libpng.so                  modules
libfreetype.so.6.4.0       libpng14.so                pkgconfig
libfusion-1.4.so.15        libpng14.so.14

<humax-from-hdd-boot-case>
/mnt/hd1/bin

[root@HUMAX bin]# cat startYVServices.sh 
#!/bin/sh

/opt/zinc/bin/start-service-over-dbus.sh Zinc.ContentAcquisition
/opt/zinc/bin/start-service-over-dbus.sh Zinc.DeviceSoftware
/opt/zinc/bin/start-service-over-dbus.sh Zinc.DeviceManager
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Broker
/opt/zinc/bin/start-service-over-dbus.sh Zinc.UsageCollection
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Application
/opt/zinc/bin/start-service-over-dbus.sh Zinc.LinearSource
/opt/zinc/bin/start-service-over-dbus.sh Zinc.RemoteDiagnostics
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Metadata --requires Zinc.Broker
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Reminders
/opt/zinc/bin/start-service-over-dbus.sh Zinc.Boot


={============================================================================
*kt_dev_uv_stack_004* stack: oem configs

root# getChildItems oem

root# getChildItems oem | grep softwre
oem.activatedsoftware.coredevicesoftware.platformapiversion=2.9.1
oem.activatedsoftware.coredevicesoftware.version=70.37.05
oem.activatedsoftware.coredevitesoftware.version=1.0.0
oem.activatedsoftware.ispconfiguration.version=10002
oem.activatedsoftware.manufacturerconfiguration.version=4
oem.activatedsoftware.platformconfig=
oem.activatedsoftware.platformconfiguration.version=1304
oem.activatedsoftware.platformsoftware.version=2.9.6
oem.software.version=70.37.05
oem.softwaremanagement.coredevicesoftware.manifest.baseurl=http://su.tv.talktalk.net
oem.softwaremanagement.coredevicesoftware.updatepolicy=standard
oem.softwaremanagement.manufacturerconfiguration.baseurl=http://su.tv.talktalk.net
oem.softwaremanagement.manufacturerconfiguration.updatepolicy=standard


root# which getChildItems
/opt/zinc/bin/getChildItems


{oem-pkg-config}
local -> /opt/oem-staging/humax-dtr_t1000/usr/local//
local/lib/pkgconfig/axis2c.pc
local/lib/pkgconfig/nexus-mgr.pc
local/lib/pkgconfig/directfb.pc
local/lib/pkgconfig/direct.pc
local/lib/pkgconfig/nexusMgr.pc
local/lib/pkgconfig/uuid.pc
local/lib/pkgconfig/fusion.pc
local/lib/pkgconfig/directfb-internal.pc
local/lib/pkgconfig/sawman.pc
local/lib/pkgconfig/nexus.pc


local -> /opt/oem-staging/huawei-dn370t/usr/local/
local/directfb/lib/pkgconfig/libpng.pc
local/directfb/lib/pkgconfig/nexus-mgr.pc
local/directfb/lib/pkgconfig/freetype2.pc
local/directfb/lib/pkgconfig/libpng14.pc
local/directfb/lib/pkgconfig/directfb.pc
local/directfb/lib/pkgconfig/direct.pc
local/directfb/lib/pkgconfig/nexusMgr.pc
local/directfb/lib/pkgconfig/uuid.pc
local/directfb/lib/pkgconfig/fusion.pc
local/directfb/lib/pkgconfig/directfb-internal.pc
local/directfb/lib/pkgconfig/sawman.pc
local/directfb/lib/pkgconfig/nexus.pc
local/lib/pkgconfig/libpng.pc
local/lib/pkgconfig/nexus-mgr.pc
local/lib/pkgconfig/freetype2.pc
local/lib/pkgconfig/libpng14.pc
local/lib/pkgconfig/directfb.pc
local/lib/pkgconfig/direct.pc
local/lib/pkgconfig/nexusMgr.pc
local/lib/pkgconfig/uuid.pc
local/lib/pkgconfig/fusion.pc
local/lib/pkgconfig/directfb-internal.pc
local/lib/pkgconfig/sawman.pc
local/lib/pkgconfig/nexus.pc


={============================================================================
*kt_dev_uv_stack_005* stack: brcm debug level

Invalid level. Should be: err, wrn, msg or none.
echo "nexusMgr msg" >> /proc/brcm/debug


={============================================================================
*kt_dev_uv_stack_006* stack: netflix ps line

16386     1518 66.4 30.2 229456 97392 ?        Sl   14:45   1:03 /opt/netflix/netflix
--write-data-path /app-data/var --cache-path /app-data/cache --disk-cache-path
/app-data/var/nrd/gibbon --user-agent YouViewPlayer4/1.0 (Huawei Technologies Co., Ltd;
    DN370T.02.02.T; 001; CDS/70.37.05; API/2.9.1; PS/2.9.6) (+DVR+FLASH+HTML+MHEG+IPCMC)
--dpi-friendlyname YouView-0067 --device-model YouView_DN370T --esn
YVWTTGD370-9cac040a-6397-4bbd-a0dd-61743837e958 --mdx-manufacturer Huawei Technologies Co., Ltd
--mdx-model-name YouView_DN370T --software-version 70.37.05 --no-mdx
--ui-query-string=source_type=2&trackId=13783779&trackUrl=https%3A%2F%2Fapi.netflix.com%2FBaSePaTh%3Fpage%3DMetaSearch%3F


={============================================================================
*kt_dev_uv_stack_007* stack: virtual rcu

https://wiki.youview.co.uk/display/canvas/2012/04/23/Automating+input+to+the+UI?src=search

<hwei-case>
scp libyouviewrcu.so root@172.20.33.192:/opt/zinc/lib
scp libyouviewrcushim.so root@172.20.33.192:/usr/local/lib/directfb-1.4-15/inputdrivers/
scp libyouviewrcushim.so root@172.20.33.192:/opt/zinc/oss/lib/directfb-1.4-15-pure/inputdrivers/
scp zinc-send-key-hwei root@172.20.33.192:/usr/local/bin

note: no need to build drivers for hwei. Simply use humax binary which are pre-built.

note: the difference is whether use host nc or busybox nc

# to run it on the box
$ scp zinc-send-input-key root@172.20.33.192:/usr/local/bin

printf "D\t${key}\n\0U\t${key}\n\0" | /opt/zinc/oss/bin/busybox nc $box_ip $box_port


# to run it on the host
./zinc-send-input.sh page_up 172.20.33.192 2033

note: cannot use it on host since nc failed. seems that there is firewall settings on a target. so
run it on a target.


<keys>
See this for other keys:
https://svn.youview.co.uk/Canvas/Documents/Presentation.Technology/trunk/2105-S%20Flash%20Presentation%20Engine%20Integration%20Specification%20v1.1E%20tracked.pdf

menu                             YouView
page_up                          Channel Up
page_down                        Channel Down
escape                           Close
cursor_up/down/left/right        
ok                               Enter
back                             Back


<to-check>
1007 ?        Sl     0:06 /usr/local/bin/directfb/1.4/dfbmaster

root# cat /proc/1007/maps | grep youview
-3731c000 r-xp 00000000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3732c000 r--p 00000000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3732d000 rw-p 00001000 08:04 530898     /usr/local/lib/directfb-1.4-15/inputdrivers/libyouviewrcushim.so
-3754c000 r-xp 00000000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so
-37568000 r--p 00097000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so
-3756a000 rw-p 000a4000 08:04 530897     /opt/zinc/lib/libyouviewrcu.so

root# printf "D\tMENU\n\0U\tMENU\n\0" | /opt/zinc/oss/bin/busybox nc localhost 2033

note: The latest eng release from huawei do not load these so. So do not work.


={============================================================================
*kt_dev_uv_stack_008* stack: startup mw

/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin/yv-start-services.sh

#!/bin/sh

prefix="/opt/zinc-trunk"

start() {
    echo "Starting $1"
    "${prefix}/bin/start-service-over-dbus.sh" "$@"
}

start Zinc.DIAL
start Zinc.Crb

exit 0


/opt/zinc-trunk/bin$ cat start-service-over-dbus.sh 
#!/bin/bash

#
# Launch a dbus service using dbus activation
#
# Author: morgan.henry@youview.com
#

#
# Usage: ./start-service-over-dbus.sh Zinc.Metadata [ --requires Zinc.System ]
#

busname=$1

if [[ $2 == "--requires" ]]; then
	# If we know the service we are about to start requires some other service
	# that has an initialisation period that is potentially greater that the dbus method_call timeout
	# then we can explicitly wait for the required service to start
	# This should be avoided where possible, since it is sub-optimial
	requires=$3
	dbuswaitbusname --timeout 30 $requires
fi

# Send a ping to a known dbus service daemon to cause dbus activation trigger daemon launch
dbus-send --session --type=method_call --print-reply --dest=$busname / org.freedesktop.DBus.Peer.Ping &


{nickelmediad} {onscreenidd}
/source/DEVARCH/Nickel/NickelOnScreenId.System.DBusServer/Makefile.am
bin_PROGRAMS = \
	onscreenidd

/source/DEVARCH/Nickel/Nickel.System.DBusServer/Makefile.am
bin_PROGRAMS = nickelmediad

/source/DEVARCH/Nickel/Nickel.System.DBusServer/src/MediaDaemon.cpp

int main(int argc, char *argv[]) {
  NICKEL_INFO("Launching Fake Media Router Service Daemon...");
  int result = EXIT_SUCCESS;

  try {
    MainLoop mainloop(BusName::MEDIA);
    MediaDaemon daemon(mainloop);
    mainloop.post(boost::bind(&MediaDaemon::start, &daemon, argc, argv));
    result = mainloop.run();
  } catch (std::exception& e) {
    std::cerr << e.what() << endl;
    result = EXIT_FAILURE;
  }

  NICKEL_INFO("Fake Media Router Service Daemon shutting down...");
  return result;
}


={============================================================================
*kt_dev_uv_stack_009* stack: nexusmgr

While working on nexus inspect tool, found that it failed to find the libnexusMgr.so at runtime.
Investigated and found that the inspect tool expect libnexusMgr.so.0 and own-built mgr has the same
as SONAME but there is ONLY libnexusMgr.so in /usr/local/lib. 

libnexusMgr.so.0 -> libnexusMgr.so

This easy solution worked okay. 

Do we need to make a change to a system to make a link? Why was it okay to run other
application that uses that library?

note: <QQQQ> this is hwei case. how about humax? see /usr/local/lib

Investigated the system and found that applications uses the realname.

So the easiest is to change makefile of libnexusMgr to use realname than soname.


04.02: summary
======
1. nexusMgr comes from OEM staging

/opt/oem-staging/huawei-bcm7409:

./usr/local/include/nexusMgr/nexusMgr.h
./usr/local/include/nexusMgr/nexusMgr.c
./usr/local/lib/nexusMgr.h

./usr/local/lib/pkgconfig/nexusMgr.pc

./usr/local/directfb/lib/libnexusMgr.so
./usr/local/lib/libnexusMgr.so


2. pkg-config when is in shell configured for a target

$ pkg-config --libs nexusmgr
Package nexusmgr was not found in the pkg-config search path.
Perhaps you should add the directory containing `nexusmgr.pc'
to the PKG_CONFIG_PATH environment variable
No package 'nexusmgr' found

$ pkg-config --libs nexusMgr
-L/data/builds/_virtual_/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -Wl,-rpath,/usr/local/lib -lfusion -ldirect -linit -lnexus -lz -lpthread


3. inspect tool builds line

-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib ~
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread -pthread ~
nexus_inspect-nexus-inspect.o: In function `main':
/home/kpark/source/DEVARCH/Polonium/Polonium.NexusInspect/src/nexus-inspect.c:343:

note: see that picks from staging and the use of linkername.


4. the previous next inspect do not have a reference to nexusMgr.so as below:

$ readelf -d ./Polonium/Polonium.NexusRelease/nexus-inspect | grep NEED
(standard input):4: 0x00000001 (NEEDED)                     Shared library: [libnexus.so]

That's why it was not a problem before.


5. compare nexusMgrs

kpark@wll1p04345:/opt/oem-staging/huawei-bcm7409/usr/local/lib$ readelf -d libnexusMgr.so.org 

Dynamic section at offset 0x14c contains 29 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libnexus.so]
 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
 0x00000001 (NEEDED)                     Shared library: [libm.so.0]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x0000000f (RPATH)                      Library rpath: [/opt/stagecraft-2.0/bin:/opt/zinc/oss/lib]
 0x0000001d (RUNPATH)                    Library runpath: [/opt/stagecraft-2.0/bin:/opt/zinc/oss/lib]

kpark@wll1p04345:/opt/oem-staging/huawei-bcm7409/usr/local/lib$ readelf -d libnexusMgr.so     

Dynamic section at offset 0x14c contains 27 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
 0x00000001 (NEEDED)                     Shared library: [libinit.so]
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
 0x0000000e (SONAME)                     Library soname: [libnexusMgr.so.0]

note: the own nexusMgr buils has soname but the original don't


box:/usr/local/lib/libnexusMgr.so has no soname as the original.



5.1 Given that the original mgr so do not have soname. However, build mgr own and then it has soname
as below. 

10:libtool: link: mipsel-linux-gcc -shared  -fPIC -DPIC  .libs/nexusMgr.o   -lpthread -linit
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib  -O3 -pthread -O2 -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc/oss/lib
-pthread -Wl,-soname -Wl,libnexusMgr.so.0 -o .libs/libnexusMgr.so.0.0.0

Therefore, when link nexus tools, these will picks up soname. So it's all down to how mgr is built. 


<how-other-uses-nexus-mgr>

6.1. when run w3c, not load nexusMgr but when 'runs' video, can see nexusMgr in mem mapping. So
there seems other so to load nexusMgr when needed. note that w3c do have a reference to nexus mgr
so.


6.2. The libgstnexus.so for both oems uses the real name. The one on a box shows the same.

Dynamic Section:
  NEEDED               libnexusMgr.so
  ...
  SONAME               libgstnexus.so.0


<the-proposal>
https://jira.youview.co.uk/browse/DEVARCH-9145

h3. New nexusMgr library proposal and guideline

h4. 0. Introduction
There has been a need to have tools to release forcefully nexus resources which are locked up when
an application exits abnormally and to have more information about nexus resources.

The tools are developed for one of OEMs and it uses the private nexusMgr implementation details.
However, the both OEMs have different implementations and prevents YouView from having common
nexus tools that works on both OEMs.

Therefore, this proposal propose a separation between inspection and releasing and OEMs and
YouView, propose new APIs, and shows a working implementation as a base for them to have a quick start. 


h4. 1. Capability interface and the inspect header
The proposal introduces capability interface to query the exposed capability of OEM nexusMgr and
uses it to inspect resources.

The header defines the version and the structure to be used for both OEMs and is subject to future
extension if necessary. YouView maintain and release it to OEMs based on the common agreement and it
will be the part of OEM staging delivery.

{noformat}
/**
 * nexus-inspect.h
 *
 * Created: 11 February, 2015
 *
 * This header defines a capability structure and API to get nexus resources
 * from OEM nexus managers in order to inspect various status or information
 * about nexus resources.
 *
 * OEMs may implement the API with this header provided by YouView and use the
 * version specified and agreed between YouView and OEMs.
 *
 * Copyright (C) 2015 YouView TV Ltd
 */     

#ifndef _NEXUS_INSPECT_H_
#define _NEXUS_INSPECT_H_

/**
 * Defines nexus inspect capability versions for future extensions.
 */
#define NEXUS_INSPECT_CAP_V0     (0x00000001)
#define NEXUS_INSPECT_CAP_V1     (0x00000002)

/**
 * Defines nexus inspect capability structure for each version. OEM may set the
 * unsupported resources to NULL from a return.
 *
 * More version structures for future extensions if necessary.
 */
#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_INSPECT_NUM_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[NEXUS_INSPECT_NUM_ADECS];
  NEXUS_VideoDecoderHandle    videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_DmaHandle             dmaHandle;
  NEXUS_VideoWindowHandle     videoWindow;
  NEXUS_PlaypumpHandle        playpump[NEXUS_INSPECT_NUM_PLAYPUMPS];
  pid_t                       resource_pid;
} NexusInspectCapsV0;


#endif /* _NEXUS_INSPECT_H_ */
{noformat}

h4. 2. New APIs
The proposal introduces two new APIs which are implemented in nexusMgr.

{noformat}
/**
 * Defines a API to get nexus inspect capability.
 *
 * @ param {version} specify the capability version to request
 * @ param {cap} specify the capability structure to get values from nexus
 * manger according to the version.
 *
 * @ return {bool} true when nexus manager supports the provided version and
 * fills up the structure.  Otherwise, false.
 */     
bool BcmNexus_Acquire_Capability( unsigned int version, void *cap, size_t size );

/**
 * Defines a API to release nexus resources.
 *
 * @ param {application_pid} specify the PID which holds nexus resources.
 *
 * @ return none
 */     
void BcmNexus_Release_All_Resources_Acquired_By_Process( pid_t application_pid );
{noformat}

h4. 3. The suggested nexusMgr implementation
The suggested implementation shows implementation to support the proposal. Although this is working
on a target, it is OEM's onus to make a official delivery to YouView that may supports both the
proposal and the OEM specific needs. The suggested in nexusMgr.c only shows the added code.

{noformat}
typedef struct {
  // {PROPOSED}
  pid_t                               resource_pid;
} BcmNexus_Shared_Memory;

const BcmNexus_StreamPlayer_Resources *
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
  // {PROPOSED}
  if( (BcmNexus_State.sharedMem->resource_pid != 0) && (BcmNexus_State.sharedMem->resource_pid != getpid()) )
  {
    BDBG_MSG_TRACE(("BcmNexus_StreamPlayer_Resources_Acquire: already acquired"));
    goto err_playpump;
  }

  // {PROPOSED}
  BcmNexus_State.sharedMem->resource_pid = getpid();
}

void 
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *resources_)
{
  // {PROPOSED}
  BcmNexus_State.sharedMem->resource_pid = 0;
}

// {PROPOSED}
void 
BcmNexus_Release_All_Resources_Acquired_By_Process( pid_t application_pid )
{
  // Getting nexus shm
  //
  BcmNexus_State.masterProcess = do_platform_init(sizeof(BcmNexus_Shared_Memory));
  BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: masterProcess = %c",BcmNexus_State.masterProcess?'y':'n'));

  NEXUS_Platform_Join();

  BcmNexus_State.sharedMem = (BcmNexus_Shared_Memory*)setupSharedMemory(sizeof(BcmNexus_Shared_Memory), (BcmNexus_State.masterProcess ? true : false));
  BDBG_ASSERT(BcmNexus_State.sharedMem);

  if (BcmNexus_State.masterProcess) {
    return;
  }

  if( BcmNexus_State.sharedMem->resource_pid == application_pid ) 
  {
    // Cleaning up nexus resources
    //
    BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Stopping video decoder"));
    NEXUS_VideoDecoder_Stop( BcmNexus_State.sharedMem->videoDecoder );

    for (uint8_t i = 0; i < NEXUS_INSPECT_NUM_ADECS; ++i)
    {
      BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Stopping audio decoder"));
      NEXUS_AudioDecoder_Stop( BcmNexus_State.sharedMem->audioDecoder[i] );
    }

    BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Flushing video decoder"));
    NEXUS_VideoDecoder_Flush( BcmNexus_State.sharedMem->videoDecoder );

    for (uint8_t i = 0; i < NEXUS_INSPECT_NUM_ADECS; ++i)
    {
      BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: Flushing audio decoder"));
      NEXUS_AudioDecoder_Flush( BcmNexus_State.sharedMem->audioDecoder[i] );
    }

    BcmNexus_State.sharedMem->resource_pid = 0;
  }

  return;
}

bool 
BcmNexus_Acquire_Capability( unsigned int version, void *cap, size_t capSize )
{
  // Getting nexus shm
  //
  BcmNexus_State.masterProcess = do_platform_init(sizeof(BcmNexus_Shared_Memory));
  BDBG_MSG_TRACE(("BcmNexus_Release_All_Resources_Acquired_By_Process: masterProcess = %c",BcmNexus_State.masterProcess?'y':'n'));

  NEXUS_Platform_Join();

  BcmNexus_State.sharedMem = (BcmNexus_Shared_Memory*)setupSharedMemory(sizeof(BcmNexus_Shared_Memory), (BcmNexus_State.masterProcess ? true : false));
  BDBG_ASSERT(BcmNexus_State.sharedMem);

  if (BcmNexus_State.masterProcess) {
    return false;
  }

  ((NexusInspectCapsV0*)cap)->videoDecoder = BcmNexus_State.sharedMem->videoDecoder;

  return true;
}
{noformat}

h4. 4. The JIRAs, the branch and git
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

o The proposed nexus tools. review/DEVARCH-8092/3 on Stash
https://stash.dev.youview.co.uk/projects/DEVARCH/repos/devarch-mirror/compare/commits?sourceBranch=refs%2Fheads%2Freview%2FDEVARCH-8092%2F3&targetBranch=refs%2Fheads%2Fmaster

DEVARCH-9131: NexusInspect: Fix up makefile to build nexus utilities. There is no common solution
for nexus utility features since both OEMs have different nexusMgr implementations and the current
implementation of nexus utility is tightly coupled with nexusMgr implementation which is private and
OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080. This
commit has the necessary changes of makefile to build nexus utility and to fix the link order
problem ...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9130: NexusInspect: Add nexus inspect tool. There is no common solution for nexus utility
features since both OEMs have different nexusMgr implementations and the current implementation of
nexus utility is tightly coupled with nexusMgr implementation which is private and OEM dependant as
described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080. This commit add the nexus
inspect which uses the proposed APIs to show information of nexus resources. Since the tool is no
l...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9129: NexusInspect: Add nexus release tool and revise the exec wrapper There is no common
solution for nexus utility features since both OEMs have different nexusMgr implementations and the
current implementation of nexus utility is tightly coupled with nexusMgr implementation which is
private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and
DEVARCH-8080. This commit add the nexus release which is revised to use the proposed APIs to release
nexus resou...		24 Feb 2015	5 JIRA Issues	

DEVARCH-9128: NexusInspect: Add the nexus inspect to the build for Huawei dn370t There is no common
solution for nexus utility features since both OEMs have different nexusMgr implementations and the
current implementation of nexus utility is tightly coupled with nexusMgr implementation which is
private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and
DEVARCH-8080. This commit add the nexus utility project to the build for Huawei dn370t.		5 days ago
5 JIRA Issues	

o The updated and proposed nexusMgr.
https://git-dev.dev.youview.co.uk/?p=nexusMgr.git;a=shortlog;h=refs/heads/propose/huawei


={============================================================================
*kt_dev_uv_stack_010* stack: commit

DEVARCH-XXX: Single line brief description of what this does or fixes.

High level description of what this commit fixes. Give the "why" without
going into too much implementation detail. Could be readable by DME,
OEMs and others who don't have intimate knowledge of the code.

Some more detail about what you've done. Useful for future reference
and for those with more technical knowledge.

- Possibly some bullet points if the commit touched a few different
  things.

Keep all but the first line to <80 chars. If the first line has to be very long to say what the
commit does, then you're probably trying to put too much into one commit. Commits should be "unixy"
- do only one thing and do it well. Here's the wiki page I mentioned previously:

https://wiki.youview.co.uk/display/testautomation/Zinc+Coding+guidelines?src=search#ZincCodingguidelines-Gitcommits

<commit-log>
DEVARCH-8092: the proposed nexus tools and interface to nexusMgr

There is no nexus-inspect for Huawei which is used to release all nexus resources when an
application exits abnormally.

The both OEMs have different nexusMgr implementations and the current nexus-inspect is tightly
coupled with nexusMgr implementation which is private and OEM dependant as described in
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

Therefore, these commits introduce a separation between inspection and releasing and OEMs and
Youview, propose new APIs, and shows a working implementation in order to make them to deliver the
updated nexusMgr as soon.
  
To use this commit, may use the revised nexusMgr from OEMs which is subject to future delivery from
OEMs according to this proposal.

<log>
DEVARCH-7508: Vanadium.W3CEngine.test: Fix runbrowser-test.sh

The cause of the problem is that the cache size is introduced in the runBrowser.sh[1] but not in the
runBrowser-test.sh. Hence mismatch which causes this failure.

As with runBrower.sh, this commit fixes the problem by looking up the cache size or silently continuing
if it hasn't been set from LSR key `platform.settings.html-app-cache-size` and so the behaviour
shouldn't be surprising.

[1] See DEVARCH-7362, commit cddb793

$ zg-jira-request-review DEVARCH-7508_1 b6157860ac9fbc1d54bb48820b2f2ed7d662c094^1..b6157860ac9fbc1d54bb48820b2f2ed7d662c094

<log>
YVHUAWEI-6095: Add the latest nexusMgr from Huawei

This is the latest which fixes kernel Oops when an application exits abnormally and is delivered via
this Jira ticket. 


<commit-log> for the nexusMgr proposal
DEVARCH-8092: the proposed nexusMgr for Huawei dn370t

The both OEMs have different nexusMgr implementations and the current nexus-inspect is tightly
coupled with nexusMgr implementation which is private and OEM dependant as described in
DEVARCH-8081, DEVARCH-8092, DEVARCH-8101, and DEVARCH-8080.

Therefore, this commit proposes a working implementation to introduce a separation between
inspection and releasing and OEMs and YouView, and propose PID check and new APIs to support these.


<commit-log>
<1>
DEVARCH-8092: Add the nexus inspect to the build for Huawei dn370t

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus utility project to the build for Huawei dn370t. 

<2>
DEVARCH-8092: Add the nexus release tool and revise the exec wrapper

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus release which is revised to use the proposed APIs to release nexus
resources and the updated exec wrapper to use the same.

<3>
DEVARCH-8092: Add the nexus inspect tool

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit add the nexus inspect which uses the proposed APIs to show information of nexus
resources.

<4>
DEVARCH-8092: Change makefile to build nexus utility

There is no common solution for nexus utility features since both OEMs have different nexusMgr
implementations and the current implementation of nexus utility is tightly coupled with nexusMgr
implementation which is private and OEM dependant as described in DEVARCH-8081, DEVARCH-8092,
DEVARCH-8101, and DEVARCH-8080.

This commit has the necessary changes of makefile to build nexus utility and to fix the link order
problem when links with nexusMgr shared library.


<commit-log>
DEVARCH-8092: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

This commit fixes SystemClientEvent to use the right Event field for Synopsis and to implement
missing map between the Event Repository and SystemClientEvent for DTT and IP source. It also
updated the related test case to test getSynopsis() for both sources.


DEVARCH-8092: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

This commit fixes SystemClientEvent to use the right Event field for Synopsis and to implement
missing map between the Event Repository and SystemClientEvent for DTT and IP source. 


DEVARCH-8092: Uranium.Client.System: Fix ctv.enhancedmetadata.Event.getSynopsis()

The ctv.enhancedmetadata.Event.getSynopsis() doesn't return a value for DTT and IP source.

This commit updated the related test case to test getSynopsis() for both sources.


<stash>
kpark@wll1p04345:~/source/DEVARCH$ git push origin DEVARCH-9135:review/DEVARCH-9135/0


={============================================================================
*kt_dev_uv_stack_011* stack: log

{from-proc}
As an example, can work out log file from fd info:

root       793  0.7  1.0  25528  4176 ?        Sl   16:04   0:00 /opt/zinc/oss/sbin/NetworkManager 
   --no-daemon --log-level=INFO

# ll /proc/793/fd
fd/     fdinfo/ 

# ll /proc/793/fd/
dr-x------    2 root     root           0 Feb 16 16:06 ./
dr-xr-xr-x    6 root     root           0 Jan  1  2000 ../
lr-x------    1 root     root          64 Feb 16 16:06 0 -> /dev/null
l-wx------    1 root     root          64 Feb 16 16:06 1 -> /var/tmp/NetworkManager.log
lrwx------    1 root     root          64 Feb 16 16:06 10 -> /dev/nexus_astm
lrwx------    1 root     root          64 Feb 16 16:06 11 -> /dev/nexus_display
lrwx------    1 root     root          64 Feb 16 16:06 12 -> /dev/nexus_graphics2d
lrwx------    1 root     root          64 Feb 16 16:06 13 -> /dev/nexus_surface
lrwx------    1 root     root          64 Feb 16 16:06 14 -> /dev/nexus_audio
lrwx------    1 root     root          64 Feb 16 16:06 15 -> /dev/nexus_video_decoder
lrwx------    1 root     root          64 Feb 16 16:06 16 -> /dev/nexus_transport
lrwx------    1 root     root          64 Feb 16 16:06 17 -> /dev/nexus_dma
lrwx------    1 root     root          64 Feb 16 16:06 18 -> /dev/nexus_security
lrwx------    1 root     root          64 Feb 16 16:06 19 -> /dev/nexus_spi
l-wx------    1 root     root          64 Feb 16 16:06 2 -> /var/tmp/NetworkManager.log
lrwx------    1 root     root          64 Feb 16 16:06 20 -> /dev/nexus_frontend
lrwx------    1 root     root          64 Feb 16 16:06 21 -> /dev/nexus_keypad
lrwx------    1 root     root          64 Feb 16 16:06 22 -> /dev/nexus_rfm
lrwx------    1 root     root          64 Feb 16 16:06 23 -> /dev/nexus_uhf_input
lrwx------    1 root     root          64 Feb 16 16:06 24 -> /dev/nexus_input_capture
lrwx------    1 root     root          64 Feb 16 16:06 25 -> /dev/nexus_ir_blaster
lrwx------    1 root     root          64 Feb 16 16:06 26 -> /dev/nexus_ir_input
lrwx------    1 root     root          64 Feb 16 16:06 27 -> /dev/nexus_led
lrwx------    1 root     root          64 Feb 16 16:06 28 -> /dev/nexus_gpio
lrwx------    1 root     root          64 Feb 16 16:06 29 -> /dev/nexus_i2c
lr-x------    1 root     root          64 Feb 16 16:06 3 -> pipe:[548]|
lrwx------    1 root     root          64 Feb 16 16:06 30 -> /dev/nexus_pwm
...

cat /var/tmp/NetworkManager.log

<when-in-sandbox>
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:14 10 -> /run/youview/jail/daemons/
   osmiumd-N7HXTA/opt/zinc/var/log/litanium.log
lrwx------    1 osmiumd  osmiumd       64 Feb 16 16:14 11 -> anon_inode:[eventpoll]
lrwx------    1 osmiumd  osmiumd       64 Feb 16 16:14 12 -> anon_inode:[eventfd]
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:04 2 -> /dev/null
l-wx------    1 osmiumd  osmiumd       64 Feb 16 16:04 3 -> /run/youview/jail/daemons/
   osmiumd-N7HXTA/opt/zinc/var/log/osmium.log

cat /opt/zinc/var/daemons/osmiumd/log/osmium.log


{refs}
https://wiki.youview.co.uk/display/canvas/Zinc+Logging+Framework

Canvas Core C++ components use the log4cplus.sourceforge.net project. 

#include <zinc-common/Logger.h>

ZINC_DECLARE_LOGGER(uranium);

#define URANIUM_FUNC_TRACE ZINC_FUNC_TRACE(ZINC_GET_LOGGER(uranium))
#define URANIUM_FUNC_DEBUG ZINC_FUNC_DEBUG(ZINC_GET_LOGGER(uranium))

#define URANIUM_SCOPE_TRACE(a) ZINC_SCOPE_TRACE(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_SCOPE_DEBUG(a) ZINC_SCOPE_DEBUG(ZINC_GET_LOGGER(uranium), a)

#define URANIUM_TRACE(a) ZINC_TRACE(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_DEBUG(a) ZINC_DEBUG(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_INFO(a) ZINC_INFO(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_WARN(a) ZINC_WARN(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_ERROR(a) ZINC_ERROR(ZINC_GET_LOGGER(uranium), a)
#define URANIUM_FATAL(a) ZINC_FATAL(ZINC_GET_LOGGER(uranium), a)


#define ZINC_DECLARE_LOGGER(name) \
	namespace name { \
		namespace detail { \
			ZINC_EXPORT extern log4cplus::Logger* logger; \
			ZINC_EXPORT log4cplus::Logger& getLoggerFallback(); \
		} \
	}


https://wiki.youview.co.uk/display/canvas/Debugging+Issues+on+a+Device?src=search

Applications like the main UI or OnDemand players live in a different place:

# Main UI logs on a patch-o-tron build:
/opt/zinc-trunk/var/applications/data/air/mainui/log/

# Main UI logs on an integrated build:
/opt/zinc/var/applications/data/air/mainui/log/

To collect all application logs into a single tarball, you can run this command:
tar -cjf application-logs.tar.bz2 $(find /opt/zinc*/var/applications/ -name "*.log")

ie. create a bzipped tarball called "application-logs.tar.bz2" by finding all files in application
directories ending in ".log"


={============================================================================
*kt_dev_uv_stack_100* stack: elememt names

element or component names
https://wiki.youview.co.uk/display/canvas/YouView+Element+Names?src=search

Cobalt   Enhanced metadata (IP sourced) Zinc.Broker 
Iron     Linear metadata (Broadcast sourced) Zinc.Metadata 


={============================================================================
*kt_dev_uv_stack_101* stack: vanadium: runbrowser

Vanadium provides:

Support for Remote Debugging Webkit provides a protocol that allows remote access to the browser.
See https://www.webkit.org/blog/1620/webkit-remote-debugging/ It adds a "-debug" option to the
command line for w3cEngine that will enable the remote debug on port 9222. Once enabled, you can
access the remote debug information by connecting to port 9222 on the STB using Chrome.

Support for client-side disk cache, i.e. support for storing data on the client in a directory that
is specified by the "-cache" command line. Specifically, it adds support for:

Client-side caching of resources requested by the w3cEngine
Usage of the LocalStorage HTML5 API
Usage of the application cache HTML5 feature

Support for persistent storage of cookies It adds a CookieJar class that uses the QSettings API to
persist cookies. The file used to store cookies is specified by the "-jar" command line option.


# from terminal
Running '/opt/zinc-trunk/bin/runBrowser.sh --app /app --data /app-data --app-launch-parameters
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2011-10-22#groupId.application
crid://bbc.co.uk/iplayer/flash_player/1
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2012-11-08#applicationPublisherIdentifier
uk.co.bbc
http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2014-09-25#groupId.application.ondemandPlayer
crid://bbc.co.uk/iplayer/flash_player/1 launch_context.ui.youview.com portal tvp.bbc.co.uk iplayer'
in sandbox...  /app/META-INF/HTML/application.xml validates


app-dir    : /app
data-dir   : /app-data
url        : http://www.bbc.co.uk/iplayer/
sources    : http://www.test.bbc.co.uk http://www.bbc.co.uk http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk
cache-size : 50000000
channel    : 
exec-helper: /opt/zinc-trunk/bin/exec-then-cleanup-app


./Vanadium/Vanadium.W3CEngine/scripts/runBrowser.sh

exec_wrapper="$prefix/bin/exec-then-cleanup-app"
[ -x "$exec_wrapper" ] || exec_wrapper=""

cmd="${RUN_BROWSER_CMD:-$prefix/bin/w3cEngine}"

exec $exec_wrapper "$cmd" \
$enable_webkit_remote_debugging_as_needed \
-cache "$app_data_dir/client-cache" \
-cache-size "$cacheSize" \
-jar "$app_data_dir/cookies.sqlite" \
-url "$url" \
-src "$sources"


** KT: ===================== **
** KT: exec-then-cleanup-app ** pid((null)) 
** KT: exec-then-cleanup-app: pid(null) 
** KT: exec-then-cleanup-app: parent: argv[1](/opt/zinc-trunk/bin/w3cEngine) 
** KT: exec-then-cleanup-app: child: argv[0](/opt/zinc-trunk/bin/exec-then-cleanup-app) parent_pid(1479) 
** KT: ===================== **
** KT: exec-then-cleanup-app ** pid(1479) 
** KT: exec-then-cleanup-app: pid(not null), cleanup_exe(/opt/zinc-trunk/bin/nexus-inspect) 
Going to watch pid: 1479

# when do abnormal termination
** HMAX KT: Releasing Nexus resources: expected 1479 == shm 1479 

# when do normal termination
** HMAX KT: The nexus resources are currently free. shm is 0


16385     2025 15.1 19.9 341300 75940 ?        Sl   15:22   0:37 /opt/zinc/bin/w3cEngine -cache
/app-data/client-cache -cache-size 50000000 -jar /app-data/cookies.sqlite -url
http://www.bbc.co.uk/iplayer/ -src http://www.test.bbc.co.uk http://www.bbc.co.uk
http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk

note: do not work on the box
LD_DEBUG=libs 
/opt/zinc/bin/w3cEngine -cache 
/app-data/client-cache -cache-size 50000000 -jar /app-data/cookies.sqlite -url 
http://www.bbc.co.uk/iplayer/ -src http://www.test.bbc.co.uk http://www.bbc.co.uk 
http://www.int.bbc.co.uk http://www.stage.bbc.co.uk http://filegateway.youview.co.uk


={============================================================================
*kt_dev_uv_stack_102* stack: vanadium: binding

JSBindingNP.h

/**
 * This is a single entry point for binding JavaScript with C++ via NPAPI.
 *
 * `JSBindingNP` is a base class which API specific classes should inherit For
 * example if `Example` API needs to be provided to JavaScript, a binding class
 * for it should be created:
 *
 *     class ExampleBindingNP : public JSBindingNP { ... };
 *
 * The reason for this relationship is that the `JSBindingNP` base class is used
 * to resolve the actual calls with what's been registered by the concrete
 * binding class.
 *
 * The concrete binding class should provide an API that mirrors the actual
 * "back-end" implementation API and register it in the `JSBindingNP` class with
 * macros provided.  When the call is resolved it's responsible for
 * unmarshalling and validating the arguments, making a call to the
 * implementation and marshalling the result.
 *
 *    ExampleBindingNP::ExampleBindingNP(const boost::shared_ptr<Example>& impl)
 *        : impl(impl), ...
 *    {
 *        JS_BINDING_NP_BEGIN(ExampleBindingNP);
 *        ADD_METHOD(foo);
 *        ADD_PROPERTY(bar);
 *        JS_BINDING_NP_END();
 *    }
 *
 *    NPVariant ExampleBindingNP::foo(const NPVariant* const args,
 *                                    const uint32_t argCount)
 *    {
 *        // ...
 *    }
 *
 *    NPVariant ExampleBindingNP::bar()
 *    {
 *        // getter
 *    }
 *
 *    void ExampleBindingNP::bar(const NPVariant* value)
 *    {
 *        // setter
 *    }
 *
 * Adding and removing events is pretty much handled by the `JSBindingNP` class.
 * A concrete binding class only needs to register the event and set a callback
 * on a relevant implementation callback handler.  The callback should then do
 * all arguments marshalling and call `JSBindingNP::notifyListeners()` method.
 *
 *    JS_BINDING_NP_BEGIN(ExampleBindingNP);
 *    // ...
 *    ADD_EVENT(onbaz);
 *    impl->onbaz(
 *        boost::bind(&ExampleBindingNP::onbaz, this));
 *    // ...
 *
 *    void ExampleBindingNP::onbaz()
 *    {
 *        notifyListeners("onbaz", std::vector<NPVariant>());
 *    }
 */

<0> To be used from JavaScript like this to register app 'listener' to NPAPI.

broadcastObj = document.getElementById('someId');
broadcastObj.addEventListener("NetworkConnectivityStateChange",
function(state, error) { /* console.log("state = "+state); */ });

The state argument is an integer enumeration with 0 standing for "disconnected" and 1 standing for "connected".


<1> so "binding" dir has bindings for each 'interface' such as Channelxxx and VideoBroadcastxxx.

// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/bindings/VideoBroadcastBindingNP.h, cpp
// 
// class VideoBroadcast is ABC and then concrete impl classes:
//
// /broadcast/production/
// class ProductionVideoBroadcast : public VideoBroadcast,
//
// /broadcast/fake/
// class ZINC_LOCAL FakeBroadcast : virtual public Broadcast   note: why virtual?
//

class VideoBroadcastBindingNP : public JSBindingNP
{
    boost::shared_ptr<VideoBroadcast> vb;
}

<2-1>
Register its handler with vb "impl" class. This is to set up path to get event
from lower parts. 'down' path

VideoBroadcastBindingNP::VideoBroadcastBindingNP(
    const boost::shared_ptr<VideoBroadcast>& vb,
    NPP npp)
    : JSBindingNP(npp),
      vb(vb)
{
    ...

    ADD_EVENT(onNetworkConnectivityStateChange);

    vb->onNetworkConnectivityStateChange(
        boost::bind(&VideoBroadcastBindingNP::onNetworkConnectivityStateChange,
                    this, _1));
    ...
}

<2-2>
Forward 'event' up to app.

void VideoBroadcastBindingNP::onNetworkConnectivityStateChange(
    NetworkConnectivityState::Enum state)
{
  std::vector<NPVariant> args(1);
  args[0] = wrap(state, plugin());

  notifyListeners("onNetworkConnectivityStateChange", args);
}


<3> save a handler of "binding" class in the concrete class.

// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/production/ProductionVideoBroadcast.cpp 

void ProductionVideoBroadcast::onNetworkConnectivityStateChange(
    boost::function<void(NetworkConnectivityState::Enum)> handler)
{
  // this is function<> object
  onNetworkConnectivityStateChangeHandler = handler;
}

<4>
void ProductionVideoBroadcast::emitNetworkConnectivityStateChange(
    NetworkConnectivityState::Enum state)
{
  if (onNetworkConnectivityStateChangeHandler)
  {
    try
    {
      onNetworkConnectivityStateChangeHandler(state);
    }
    catch (...)
    {
      VANADIUM_WARN("Executing network connectivity state change handler failed");
    }
  }
}

// from NM?
// a/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast/production/ProductionVideoBroadcast.cpp 
// 
void ProductionVideoBroadcast::StateChanged(
    const NS_NEON_SYSTEM::NM_STATE::Enum state)
{
  NetworkConnectivityState::Enum const targetState =
    state == NS_NEON_SYSTEM::NM_STATE::connected
    ? NetworkConnectivityState::connected
    : NetworkConnectivityState::disconnected;

  emitNetworkConnectivityStateChange(targetState);
}

<map-to-concrete-class>
BroadcastPluginNP::BroadcastPluginNP(BroadcastFactory& f, NPP npp) :
    f(f),
    jsCallInProgress(false),
    releasing(false),
    npp(npp),
    jsDispatcher(boost::make_shared<JSEventDispatcherNP>(npp)),
    jsAsyncDispatcher(boost::make_shared<JSEventDispatcherNP>(npp, true))
{
  ...

  // boost::shared_ptr<VideoBroadcast> videoBroadcast;
  
  videoBroadcast = f.createVideoBroadcast(jsDispatcher, jsAsyncDispatcher);

  // Create a binding for videoBroadcast.
  const boost::shared_ptr<VideoBroadcastBindingNP> videoBroadcastBinding =
    boost::make_shared<VideoBroadcastBindingNP>(videoBroadcast, npp);
}

<>
kpark@wll1p04345:~/source/DEVARCH/Vanadium/Vanadium.W3CEngine/src/plugins/broadcast$ tree .
.
|-- api
|   |-- BroadcastFactory.cpp
|   |-- ChannelConfig.cpp
|   |-- Channel.cpp
|   |-- ChannelList.cpp
|   |-- VideoBroadcast.cpp

|-- bindings
|   |-- ChannelBindingNP.cpp
|   |-- ChannelConfigBindingNP.cpp
|   |-- ChannelListBindingNP.cpp
|   |-- CollectionBindingNP.h
|   |-- VideoBroadcastBindingNP.cpp

|-- broadcast-plugin.cpp
|-- broadcast-plugin.h
|-- BroadcastPluginNP.cpp
|-- BroadcastPluginNP.h

|-- fake
|   |-- FakeBroadcastFactory.cpp
|   |-- FakeBroadcastFactory.h
|   |-- FakeVideoBroadcast.cpp
|   `-- FakeVideoBroadcast.h

|-- JSBindingNP.cpp
|-- JSBindingNP.h
|-- JSEventDispatcherNP.cpp
|-- JSEventDispatcherNP.h
|-- JSObjectNP.h
|-- JSTypeUnwrappingNP.cpp
|-- JSTypeUnwrappingNP.h
|-- JSTypeWrappingNP.cpp
|-- JSTypeWrappingNP.h
|-- NPObjectIntrusivePtr.h
|-- plugin-logger.h
`-- production
    |-- ProductionBroadcastFactory.cpp
    |-- ProductionBroadcastFactory.h
    |-- ProductionVideoBroadcast.cpp
    `-- ProductionVideoBroadcast.h


# broadcast-plugin.cpp

    // not sure who calls this but from a code, a browser call this and this
    // function registers functions
//
NPError NP_Initialize(NPNetscapeFuncs* nFuncs, NPPluginFuncs* pFuncs)
{
    try
    {
      // 1. register its function table with the caller(browser?)
      // *pFuncs = npp;
      //
      // 2. create T and add T to a map<mine, T*> for MINE, video/broadcast.
      //
      // boost::ptr_map<std::string, BroadcastFactory> factories;
      //
      // addFactory<ProductionBroadcastFactory>(MIME_TYPE);
      //
      // note: 'Production' created.
      return internal::NP_Initialize(nFuncs, pFuncs);
    }
    CATCH_BAD_ALLOC
    CATCH_ALL

    return NPERR_GENERIC_ERROR;
}

={============================================================================
*kt_dev_uv_stack_103* stack: vanadium: remote debug

https://wiki.youview.co.uk/display/YVDP/Debugging?src=search


={============================================================================
*kt_dev_uv_stack_104* stack: LSR (local storage repository)

./Copper/Copper.System.DBusClient/src/lsr-config.c


={============================================================================
*kt_dev_uv_stack_105* stack: uranium. air.

<air>
Adobe AIR for TV. AIR is flash runtime engine.
https://wiki.youview.co.uk/display/YVDP/Air+for+TV?src=search

<stagecraft>
Adobe had taken great steps in making the Flash Lite player available to be licensed by mobile
device and CE manufacturers.  As I understand it Stagecraft goes one step farther by wrapping the
Flash Lite player in a layer that mitigates the risks associated with porting just the Flash Lite
player itself. It insures that SWFs created for one Stagecraft based device will work on all
Stagecraft based devices.


={============================================================================
*kt_dev_uv_stack_106* stack: cal

{so-loading}
So can use either config file or the direct name. 

note: uses the same "createSystemClientFactory" for all libraries.


<0> EPG gets a CF via this
Create a client factory. The below is how test cast do to get CF. 

static const PluginConfig &getClientFactoryPluginConfig(void)
{
    static const FixedPluginConfig pluginConfig("libUraniumClientSystem.so", "createSystemClientFactory");
    return(pluginConfig);
}

Uranium.AIR.Client.API/data/client-factory.plugin-config
1:libUraniumClientSystem.so createSystemClientFactory

Uranium.Client.System/src/SystemClientFactory.cpp

Plugin* createSystemClientFactory() {
  URANIUM_PROFILE_FUNC;
  return 'new' NS_URANIUM_CLIENT::SystemClientFactory();
}


<1> Binding. Using CF, calls createXXX.

Uranium.AIR.Client.API/src/UraniumAirPlugin.cpp

Create a singletone instance of each interface locator and this locator has a singletone of real
interface so this is singletone chain. Pass a SP to it back to a client. Client can use a real
instance since locator has interface to get SP of real instance.


class ZINC_LOCAL UraniumAirPlugin : public GenericAirPlugin<UraniumAirPlugin, ClientFactory> 
{
  void initSingletons(ClientFactory& clientFactory) 
  {
    note: create <MD>
    shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> nativeLocator(
        clientFactory.createMetadataLocator()
        );

    NS_URANIUM_METADATA_AIR_CLIENT::LocatorBinding::setSingletonInstance(nativeLocator);

    note: create <LMD>
    NS_URANIUM_LINEAR_AIR_CLIENT::LocatorBinding::setSingletonInstance(
        clientFactory.createLinearMetadataLocator());

    note: get LMLL(locator) and pass up to client application. see factory below
    NS_URANIUM_LML_AIR_CLIENT::LocatorBinding::setSingletonInstance(
        clientFactory.createLocalMediaLibraryLocator());
  }
};


<2> How to get connected to 'iron'

$ cat ./Uranium.Client.System/data/iron-system-factory.plugin-config
libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)


NS_IRON_SYSTEM::SystemFactory& SystemClientFactory::getIronSystemFactory() 
{
    URANIUM_PROFILE_FUNC;
    const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find(
                "iron-system-factory.plugin-config"));
    return PluginFactory::getInstance<NS_IRON_SYSTEM::SystemFactory>(pluginConfig);
}

boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> SystemClientFactory::getIronSystemEventRepository()
{
    if(ironSystemEr == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::getIronSystemEventRepository()");

        // note: this is a call to DBUS client

        ironSystemEr = getIronSystemFactory().createEventRepository();
    }
    return ironSystemEr;
}


note: this getIronSystemEventRepository() is used in various places and one of them is:

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
createConcreteEventRepository() 
{
  if(eventRepository == 0)
  {
    // note: create ER via 'iron' factory. shared lib. is it proxy?
    boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemER(
            getIronSystemEventRepository());

    // ...
  }
}


<3> How to get connected to 'cobalt'

/Uranium.Client.System/data$ cat cobalt-system-factory.plugin-config 
libCobaltSystemDbusClient.so createDbusSystemFactory


NS_COBALT_SYSTEM::SystemFactory& SystemClientFactory::getCobaltSystemFactory() 
{
    const NS_ZINC::FilePluginConfig pluginConfig(PackageDataFinder().find(
                "cobalt-system-factory.plugin-config"));
    
    return PluginFactory::getInstance<NS_COBALT_SYSTEM::SystemFactory>(pluginConfig);
}


boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> SystemClientFactory::getSystemMetadataBroker()
{
    if(systemMetadataBroker == 0)
    {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::getSystemMetadataBroker()");
        systemMetadataBroker = getCobaltSystemFactory().createMetadataBroker();
    }
    return systemMetadataBroker;
}


<4> SF is DBUS SF

unity.cpp. auto generated.

class ZINC_EXPORT DbusSystemFactory : public SystemFactory
{
    public: // from SystemFactory
        DbusSystemFactory(const char* args = NULL);

        virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> createMetadataBroker();
        virtual boost::shared_ptr<Zinc::Broker::HiddenServicesStore> createHiddenServicesStore();
        virtual boost::shared_ptr<Zinc::Broker::UnifiedServiceRepository> createUnifiedServiceRepository();
        virtual boost::shared_ptr<Zinc::Broker::ProvisioningService> createProvisioningService();
        virtual boost::shared_ptr<Zinc::Broker::UnifiedEventRepository> createUnifiedEventRepository();
        virtual boost::shared_ptr<Zinc::Broker::LinearAcquisitionServiceResolver> 
            createLinearAcquisitionServiceResolver();
        virtual boost::shared_ptr<Zinc::Broker::DeviceConfig> createDeviceConfig();

    private:
        NS_ZINC_DBUS_BINDING::DBusSystemFactoryImpl impl;

        // references to our proxy objects
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theMetadataBroker;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theHiddenServicesStore;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theUnifiedServiceRepository;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theProvisioningService;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theUnifiedEventRepository;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theLinearAcquisitionServiceResolver;
        boost::weak_ptr<NS_ZINC_DBUS_BINDING::ObjectProxy> theDeviceConfig;
};

DbusSystemFactory::DbusSystemFactory(const char* args)
 : impl(DBus::BusType::SESSION, getBusName(args))
{
}

boost::shared_ptr<Zinc::Broker::MetadataBroker> DbusSystemFactory::createMetadataBroker()
{
    // 'interface'
    
    return NS_ZINC_DBUS_BINDING::applyInterface<Zinc::Broker::MetadataBroker>(
            impl.getOrCreateObject(theMetadataBroker, "/Zinc/Broker/MetadataBroker"));
}

static std::string getBusName(const char* overrideBusName)
{
    const char* busName = NULL;
    if (overrideBusName != NULL && overrideBusName[0] != '\0') {
        busName = overrideBusName;
    }
    if (busName == NULL) {
        busName = ::getenv(BUSNAME_ENV);
    }
    std::string theBusName;

    if(busName && strlen(busName) > 0) {
        theBusName = busName;
    } else {
        theBusName = "Zinc.Broker";          // note: see
    }
    return theBusName;
}

NS_ZINC::Plugin *createDbusSystemFactory(const char* args) {
    return new Zinc::Broker::DbusSystemFactory(args);
}



<apis>
Uranium.Client.API/include/metadata/Event.h
Uranium.Client.API/include/metadata/Summary.h
Uranium.Client.API/include/local-media-library/MediaRecord.h
Uranium.Client.API/include/linear-acquisition/Booking.h

struct ZINC_EXPORT MediaRecord : virtual public NS_ZINC::Polymorphic {
   virtual std::string getSynopsis() const = 0;
}

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic;

class ZINC_EXPORT Summary : virtual public NS_ZINC::Polymorphic;


{client-system}

Uranium.Client.System/src/SystemClientFactory.cpp

NS_URANIUM_CLIENT_OPEN

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
  private:
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> eventRepository;
    boost::weak_ptr<NS_URANIUM_LINEAR_CLIENT::SystemClientEventRepository> linearEventRepository;

  public:
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> createMetadataLocator();

    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
      createConcreteEventRepository();
    boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::Locator> createLinearMetadataLocator();


    // <factory-lml>
    boost::shared_ptr<NS_URANIUM_LML_CLIENT::Locator> createLocalMediaLibraryLocator();
    {
      using namespace NS_URANIUM_LML_CLIENT;

      if(!localMediaLibraryLocator)
      {
        URANIUM_PROFILE_SCOPE("SystemClientFactory::createLocalMediaLibraryLocator()");
        localMediaLibraryLocator = boost::make_shared<SystemClientLocator>(createLocalMediaLibrary());
      }

      return localMediaLibraryLocator;
    }

    boost::shared_ptr<NS_URANIUM_LML_CLIENT::LocalMediaLibrary> createLocalMediaLibrary();
    {
        boost::mutex::scoped_lock lock(boost::mutex);

        if(localMediaLibrary == NULL) {
            URANIUM_PROFILE_SCOPE("SystemClientFactory::createLocalMediaLibrary()");

            // note: get cache
            boost::shared_ptr<NS_URANIUM_LML_CLIENT::MediaRecordCache> cache
                = getMediaRecordCache();

            // note: create SLML
            boost::shared_ptr<NS_URANIUM_LML_CLIENT::SystemLocalMediaLibrary> lml
                = boost::make_shared<NS_URANIUM_LML_CLIENT::SystemLocalMediaLibrary>(
                        getSystemLocalMediaLibrary(), getProvisioningService(), cache);

            boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
                createConcreteEventRepository() 
                {
                    concreteER->setDefaultDispatcher(getDefaultDispatcher())
                    {
                        dispatcher = dispatcher_;
                    }

                    concreteER->setFutureDispatcher(futureDispatcher);
                }


            lml->setDispatcher(getDefaultDispatcher());
            localMediaLibrary = lml;
            getSystemLocalMediaLibrary()->addListener(lml);
        }

        return(localMediaLibrary);
    }
};


struct ZINC_EXPORT Locator : public NS_ZINC::Polymorphic 

class SystemClientLocator : public Locator 
{
    SystemClientLocator(const boost::shared_ptr<LocalMediaLibrary> lml_);
};


{locators}
Each interface defines 'own' locator class chain and how it is possible? Use namespace.

NS_URANIUM_METADATA_CLIENT_OPEN

/**
 * This is the top-level entrypoint to the Zinc Client API.
 * A singleton instance will likely be exposed in the global
 * context within the Javascript environment. An Actionscript
 * binding will be newed in the Flash case.
 */
class ZINC_EXPORT Locator : public NS_ZINC::Polymorphic {

public:
    virtual ~Locator();
    virtual boost::shared_ptr<MetadataBroker> getMetadataBroker() const = 0;
    virtual boost::shared_ptr<EventRepository> getEventRepository() const = 0;
    virtual boost::shared_ptr<ServiceRepository> getServiceRepository() const = 0;
};

class SystemClientLocator : virtual public Locator {

  public:
    SystemClientLocator(boost::shared_ptr<MetadataBroker> metadataBroker, 
        boost::shared_ptr<EventRepository> er, boost::shared_ptr<ServiceRepository> sr);

    boost::shared_ptr<MetadataBroker> getMetadataBroker() const;
    virtual boost::shared_ptr<EventRepository> getEventRepository() const;
    virtual boost::shared_ptr<ServiceRepository> getServiceRepository() const;

  private:
    boost::shared_ptr<MetadataBroker> metadataBroker;
    boost::shared_ptr<EventRepository> eventRepository;
    boost::shared_ptr<ServiceRepository> serviceRepository;
};


={============================================================================
*kt_dev_uv_stack_107* stack: cal: metadata creation

{creation-chain} for linear and metadata and creation chian. 

<MDL> MDCL   -> { MB, ER, SR }
<CMB>        SCMB(MB) -> { SMB(COBALT), C, MO }
                                        C -> { MDR, PC }
Binding:
<MDL> MDCL   -> { MB, ER, SR }

shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> nativeLocator(
    clientFactory.createMetadataLocator());

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{

  // 'linear'
  // LCL    -> { ER, RCR, RR }:
  //              |
  //              -> { ER(IRON), RR }
  //
  boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::Locator> createLinearMetadataLocator() 
  {
    using namespace NS_URANIUM_LINEAR_CLIENT;

    URANIUM_FUNC_DEBUG;

    boost::shared_ptr<Locator> loc(linearMetadataLocator.lock());

    if(loc == NULL)
    {
      linearMetadataLocator = loc =
        boost::make_shared<SystemClientLocator>(
            createLinearEventRepository(),
            createRelatedContentRepository(),
            createReminderRepository()
            );
    }
    return loc;
  }

  boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::EventRepository> createLinearEventRepository() 
  {
    using namespace NS_URANIUM_LINEAR_CLIENT;

    boost::shared_ptr<SystemClientEventRepository> eventRepository(linearEventRepository.lock());

    if(!eventRepository) {

      //create Event Repository
      boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemEventRepository(
          getIronSystemEventRepository());

      // note: from 'iron-system-factory.plugin-config
      //
      // libIronSystemDbusClient.so createDbusSystemFactory(Zinc.MetadataProxy)
      //
      // MetadataProxy      15 ../Cobalt/Cobalt.System.DBusServer/src/BusName.cpp char const * const
      // BusName::LINEAR_METADATA = "Zinc.MetadataProxy";
      //

      eventRepository = boost::make_shared<SystemClientEventRepository>(
          systemEventRepository,
          createReminderRepository()
          );

      systemEventRepository->addListener(eventRepository);
      eventRepository->setDispatcher(getDefaultDispatcher());
      eventRepository->setFutureDispatcher(futureDispatcher);
      linearEventRepository = eventRepository;
    }
    return eventRepository;
  }

  // note: 'metadata' see use of namespace to specify
  //
  // <MDL> MCL    -> { MB, ER, SR }
  //
  // <CMB>        SCMB(MB) -> { SMB(COBALT), C, MO }
  //
  //                                         C -> { MDR, PC }
  //
  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Locator> createMetadataLocator() 
  {
    if(!metadataLocator)
    {
      metadataLocator = boost::make_shared<NS_URANIUM_METADATA_CLIENT::SystemClientLocator>(
          createMetadataBroker(),   <CMB> 
          createEventRepository(),  <CER>
          createServiceRepository());
    }
    return metadataLocator;
  }
};

Uranium/Uranium.Client.System/src/SystemClientFactory.cpp

<CMB> SCMB(MB) -> { SMB(COBALT), C, MO }
                                 C -> { MDR, PC }

// `Converter` is a helper class that is used to convert MetadataBroker
// `Result` and `ResultSet` to the required Client API types, depending on the
// specific Broker function that was called.

struct ZINC_LOCAL Converter
{
  explicit Converter(boost::shared_ptr<SystemClientMetadataConfig> config_,
      boost::weak_ptr<MetadataRepositories> repos_,
      boost::shared_ptr<ProvisioningCache> provisioningCache_)
    : config(config_),
    repos(repos_),
    provisioningCache(provisioningCache_)
  {}
};

// note: returns a copy

NS_URANIUM_METADATA_CLIENT::Converter SystemClientFactory::createConverter()
{
  URANIUM_PROFILE_FUNC;
  return NS_URANIUM_METADATA_CLIENT::Converter(
      createMetadataConfig(),
      createMetadataRepositories(),
      createProvisioningCache());
}

boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataBroker> SystemClientFactory::createMetadataBroker() 
{
  URANIUM_FUNC_DEBUG;

  if(metadataBroker == 0)
  {
    // note: cobalt
    
    boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> systemMetadataBroker(getSystemMetadataBroker());

    using NS_URANIUM_METADATA_CLIENT::SystemClientMetadataBroker;

    <SCMB>
    boost::shared_ptr<SystemClientMetadataBroker> mb = 
      boost::make_shared<SystemClientMetadataBroker>( systemMetadataBroker,
          createConverter(),
          createMetadataObserver() );

    mb->setDispatcher(getDefaultDispatcher());
    mb->setFutureDispatcher(futureDispatcher);
    metadataBroker = mb;
  }

  return metadataBroker;
}


<CMB> <SCMB>
Uranium.Client.System/src/metadata/SystemClientMetadataBroker.cpp

class ZINC_EXPORT SystemClientMetadataBroker
    : virtual public MetadataBroker,
      virtual public NS_ZINC::DispatchingFutureProducer,
      public boost::enable_shared_from_this<SystemClientMetadataBroker>
{

  SystemClientMetadataBroker(
      boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker_,
      Converter convert_,
      boost::shared_ptr<MetadataObserver> metadataObserver_) :
    metadataBroker(metadataBroker_),
    convert(convert_),
    metadataObserver(metadataObserver_)
  {}

  // note: search
  // note: WHO'S CALLING THIS?  
  NS_ZINC::Future<boost::shared_ptr<SummaryResultSet>> search(const std::string& searchTerms,
      boost::shared_ptr<SearchOptions> searchOptions,
      size_t start,
      size_t size) const
  {
    shared_ptr<SystemClientSearchOptions> scSearchOptions
      = boost::dynamic_pointer_cast<SystemClientSearchOptions>(searchOptions);

    // note: this is SMB(COBALT)

    return metadataBroker->search(searchTerms,
        getSysQopts(scSearchOptions),
        getSysGopts(scSearchOptions),
        scSearchOptions->getFilters(),
        start,
        size)
      .then(*getDispatcher(),
          bind(&SystemClientMetadataBroker::searchCallback,
            shared_from_this(),
            start,
            _1));
  }

  // note: searchCallback

  boost::shared_ptr<SummaryResultSet>
    SystemClientMetadataBroker::searchCallback(uint32_t requestedStartIndex,
        const NS_ZINC::FutureValue<NS_COBALT_SYSTEM::ResultSet>& fvSystem) const
    {
      translateAndThrowCobaltSystemExceptions(fvSystem.getError());
      NS_COBALT_SYSTEM::ResultSet sysval = fvSystem.get();

      // note: SCMB        -> { RS(COBALT), , MR, }
      // note: repos is MR 
      
      // note: create <SCSRS> and see <use-summary>
      
      boost::shared_ptr<SystemClientSummaryResultSet> srs =
        convert(sysval, boost::shared_ptr<SystemClientSummaryResultSet>(), requestedStartIndex);

      // boost::shared_ptr<SystemClientSummaryResultSet>
      //   Converter::operator()(const NS_COBALT_SYSTEM::ResultSet& rs,
      //       boost::shared_ptr<SystemClientSummaryResultSet>, uint32_t requestedStartIndex) const
      //   {
      //     return boost::make_shared<SystemClientSummaryResultSet>(
      //         boost::make_shared<NS_COBALT_SYSTEM::ResultSet>(rs), config, repos, 
      //         provisioningCache, requestedStartIndex);
      //   }

      metadataObserver->addListener(srs);
      srs->setDispatcher(getDispatcher());

      return boost::static_pointer_cast<SummaryResultSet>(srs);
    }

  boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker;
  boost::shared_ptr<SystemClientMetadataConfig> config;
  Converter convert;
  boost::shared_ptr<MetadataObserver> metadataObserver;

  boost::weak_ptr<MetadataRepositories> repos;
};


<CER> SCER(ER) -> { MDO, SR, SER, SMB, CRR, CLA, EEIF, PEC, BSM }

note: ER is metadata ER

class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::EventRepository> createEventRepository() 
  {
    return createConcreteEventRepository();
  }

  boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
    createConcreteEventRepository() 
    {
      if(eventRepository == 0)
      {
        boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> systemMB = getSystemMetadataBroker();

        // note: create ER via 'iron' factory. shared lib. is it proxy?
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemER(getIronSystemEventRepository());

        boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> clientRR(createReminderRepository());
        boost::shared_ptr<NS_URANIUM_DVR_CLIENT::LinearAcquisition> clientLA(createLinearAcquisition());
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientMetadataConfig> 
          metadataconfig(createMetadataConfig());

        // note: <SCER>
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> concreteER(
            'new' NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository(
              metadataconfig,
              createMetadataObserver(), note: create MDO.
              serviceRepository,
              systemER,
              systemMB,
              clientRR,
              clientLA,
              createExtraEventInfoFacade(),
              createPresentEventsCache(),
              createBrokerStatusMonitor()
              )
            );

        concreteER->setDefaultDispatcher(getDefaultDispatcher());
        concreteER->setFutureDispatcher(futureDispatcher);
        eventRepository = concreteER;

        createMetadataObserver()->addListener(concreteER);
        serviceRepository->setEventRepository(concreteER);
      }

      return eventRepository;
    }
}

SystemClientEventRepository::SystemClientEventRepository(
        boost::shared_ptr<SystemClientMetadataConfig> config_,
        boost::shared_ptr<MetadataObserver> metadataObserver_,
        boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> serviceRepo_,
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> systemEventRepo_,
        boost::shared_ptr<NS_COBALT_SYSTEM::MetadataBroker> metadataBroker_,
        boost::shared_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> reminderRepo_,
        boost::shared_ptr<NS_URANIUM_DVR_CLIENT::LinearAcquisition> linearAcquisition_,
        boost::shared_ptr<ExtraEventInfoFacade> extraInfo_,
        boost::shared_ptr<PresentEventsCache> peCache_,
        boost::shared_ptr<BrokerStatusMonitor> brokerMonitor_) :
           config(config_),
           metadataObserver(metadataObserver_),
           serviceRepo(serviceRepo_),
           systemEventRepo(systemEventRepo_),
           metadataBroker(metadataBroker_),
           reminderRepo(reminderRepo_),
           linearAcquisition(linearAcquisition_),
           extraInfo(extraInfo_),
           peCache(peCache_),
           brokerMonitor(brokerMonitor_)
    {
    }


<MO>
boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataObserver> <createMetadataObserver>()
{
  using namespace NS_URANIUM_METADATA_CLIENT;

  if(metadataObserver == 0)
  {
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::MetadataObserver> mo(
        MetadataObserver::create(
          createServiceCache(),
          createReminderRepository(),
          getIronSystemEventRepository(),
          createPresentEventsCache(),
          createProvisioningCache(),
          createMediaRecordCache(),
          createMetadataConfig(),
          createActionProcessor()
          )
        );

    // WARNING:
    // It is necessary to have an InlineDispatcher: see MetadataObserver::ServiceListChange.
    mo->setDispatcher(boost::make_shared<InlineDispatcher>());

    getIronSystemEventRepository()->addListener(mo);
    getSystemUnifiedServiceRepository()->addListener(mo);
    createReminderRepository()->addListener(mo);
    createLinearAcquisition()->addListener(mo);

    // note: set listener
    createLocalMediaLibrary()->addListener(mo);

    createMetadataConfig()->addListener(mo);
    getProvisioningService()->addListener(mo);

    // note: 'neon' so 
    ipnetwork = getNeonClientFactory().createIPNetwork();
    ipnetwork->addListener(mo);
    getHiddenServicesStore()->addListener(mo);

    //FIXME: 
    //the order here is not accidental - unfortunately there is a cyclic indirect dependency between 
    //service repo and metadata observer, and this is a way to stop infinite loops in the factory
    mo->addListener(createConcreteServiceRepository(false));
    createConcreteServiceRepository(false)->setMetadataObserver(mo);
    metadataObserver = mo;
  }

  return metadataObserver;
}

Uranium.Client.System/src/metadata/MetadataObserver.h

class ZINC_LOCAL MetadataObserver:
{
  std::vector<boost::weak_ptr<SystemClientEventRepository> > clientEventRepos;

  void MetadataObserver::addListener(boost::shared_ptr<SystemClientEventRepository> er_)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;
    boost::mutex::scoped_lock lock(listenerMutex);
    clientEventRepos.push_back(er_);
  }

  void MetadataObserver::notifyServicesChanged(const vector<string>& changedServiceLocators)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;

    //Service and event repository need to be notified in this order,
    //and before EventWindows. EventDispatchers give us no guarantee
    //about the order of notifications, so we need to ensure it ourselves here.
    boost::shared_ptr<ServiceCache> serviceCacheStrong = serviceCache.lock();

    if(serviceCacheStrong)
    {
      serviceCacheStrong->ServicesChanged(changedServiceLocators);
    }

    //notify and cleanup Service/Event repos.
    boost::mutex::scoped_lock lock(listenerMutex);

    notify<SystemClientServiceRepository>(clientServiceRepos, 
        boost::bind(&SystemClientServiceRepository::ServicesChanged, _1, changedServiceLocators)) ;

    notify<SystemClientEventRepository>(clientEventRepos, 
        boost::bind(&SystemClientEventRepository::ServicesChanged, _1, changedServiceLocators));
    lock.unlock();

    produceEvent(boost::bind(&MetadataChangeListener::ServicesChanged, _1, changedServiceLocators));
  }

  void MetadataObserver::ServiceChange(const std::string& serviceLocator)
  {
    URANIUM_FUNC_TRACE;
    URANIUM_PROFILE_FUNC;
    notifyServicesChanged(vector<std::string>(1, serviceLocator));

    //we don't need to reload present events cache, because spec 0011-S says that if RCNs change,
    //then the box should emit ServiceListChange anyway.
  } 
};


={============================================================================
*kt_dev_uv_stack_108* stack: cal: metadata: event structures and mapping

{iron-event-struct}
/zinc-build-root/debug-debian-7-x86_64/Iron/Iron.System.API/include/Event.h

namespace Zinc {
namespace Metadata {

struct Event
{
    Event();
    explicit Event( /* deleted */ );

    void swap(Event&);

    // Members:
    std::string serviceLocator;
    std::string eventLocator;
    uint32_t start;
    uint32_t publishedDuration;

    // note: all use 'lang' eg eng as a key in map<lang, string>
    //
    // extractValueFromMap(dttEvent.shortTitle, lang)
    // extractValueFromMap(dttEvent.mediumSynopsis, lang)
    //
    // sysEvent.mediumSynopsis["eng"] = "The latest national and international"
    //   "news stories from the BBC News team, followed by weather.";
    
    std::map< std::string, std::string > shortTitle;
    std::map< std::string, std::string > mediumSynopsis;
    std::map< std::string, std::string > longSynopsis;

    std::vector< std::string > classifier;
    std::string programmeCrid;
    std::string splitInstanceIdentifier;
    std::vector< std::string > seriesCrid;
    std::vector< std::string > recommendationCrid;
    std::vector< std::string > collectionCrid;
    VideoFormat::Enum videoFormat;
    AspectRatio::Enum aspectRatio;
    std::map< std::string, std::vector< AudioMixType::Enum > > audio;
    bool audioDescription;
    std::map< std::string, std::vector< SubtitlesFormat::Enum > > subtitles;
    bool signing;
    std::string guidanceCode;
    std::map< std::string, std::string > guidanceText;
    std::vector< std::string > iconURL;
    bool conditionalAccess;
    bool bookable;
    std::map< std::string, bool > alternativeEventLocator;
};


/zinc-build-root/debug-debian-7-x86_64/Cobalt/Cobalt.System.API/include

/*
 * include/Result.h
 *
 * This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 * Template struct.h.template
 * Using /data/builds/_virtual_/pc/DEVARCH/Cobalt/Cobalt.System.API/data/introspection-xml/struct-Result.xml
 */
namespace Zinc {
namespace Broker {

struct Result
{
    Result();
    explicit Result( /* omitted */ );
    void swap(Result&);

    // Members:
    std::string recordIdentifier;
    int64_t lastModified;
    int64_t validUntil;
    DataSource::Enum dataSource;
    std::vector< std::string > classifiers;
    std::map< std::string, std::vector< std::string > > identifiers;
    std::map< std::string, std::vector< std::string > > internalReferences;

    // note: 
    // sysResult->description["mediumSynopsis"] = vector<string>(1, "The latest national and international"
    //   "news stories from the BBC News team, followed by weather.");

    std::map< std::string, std::vector< std::string > > description;

    std::map< std::string, std::vector< XmlNode > > nodes;
};

inline Result::Result() 
    : recordIdentifier(), lastModified(), validUntil(),
    dataSource(), classifiers(), identifiers(), internalReferences(),
    description(), nodes() { }

inline Result::Result(const std::string& recordIdentifier_, const int64_t
        lastModified_, const int64_t validUntil_, const DataSource::Enum
        dataSource_, const std::vector< std::string >& classifiers_, const
        std::map< std::string, std::vector< std::string > >& identifiers_,
        const std::map< std::string, std::vector< std::string > >&
        internalReferences_, const std::map< std::string, std::vector<
        std::string > >& description_, const std::map< std::string,
        std::vector< XmlNode > >& nodes_) 
    : recordIdentifier(recordIdentifier_), lastModified(lastModified_),
    validUntil(validUntil_), dataSource(dataSource_),
    classifiers(classifiers_), identifiers(identifiers_),
    internalReferences(internalReferences_), description(description_),
    nodes(nodes_) { }


{events-xml}
Iron/Iron.System.API/data/introspection-xml/struct-Event.xml

<yv:struct name="Zinc.Metadata.Event">

   <p>The Event structure members are as follows:</p>

   ...

   <yv:member type="a{ss}" name="shortTitle">
       <yv:docstring>
           <p>A title for the event taken from the <tt>short_event_descriptor()</tt> 
           <tt>event_name_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 “alpha-3” language code (the key) 
           to a title in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

   <yv:member type="a{ss}" name="mediumSynopsis">
       <yv:docstring>
           <p>A description for the event taken from the <tt>short_event_descriptor()</tt> 
           <tt>text_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 “alpha-3” language code (the key) 
           to a synopsis in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>

   <yv:member type="a{ss}" name="longSynopsis">
       <yv:docstring>
           <p>A description for the event taken from the <tt>extended_event_descriptor()</tt> 
           <tt>text_char</tt> field.</p>
           <p>Each dictionary entry matches an ISO&#160;639 “alpha-3” language code (the key) 
           to a synopsis in the indicated language (the value).</p>
       </yv:docstring>
   </yv:member>


Cobalt/Cobalt.System.API/data/introspection-xml/struct-Result.xml

<?xml version="1.0" encoding="UTF-8"?>
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0">
    <yv:struct name ="Zinc.Broker.Result">
        <yv:member type="s" name="recordIdentifier" />
        <yv:member type="x" name="lastModified" />
        <yv:member type="x" name="validUntil" />
        <yv:member type="i" yv:type="[DataSource]" name="dataSource" />
        <yv:member type="as" name="classifiers" />
        <yv:member type="a{sas}" name="identifiers" />
        <yv:member type="a{sas}" name="internalReferences" />
        <yv:member type="a{sas}" name="description" />
        <yv:member type="a{sa(a{ss}s)}" yv:type="a{sa[XmlNode]}" name="nodes" />
    </yv:struct>
</node>


{translation}

Cobalt/Cobalt.System.Production/data/b2c_map.yaml

node_transformations: [
    # tag                action                 args....
    ['serviceId',       'AppendToDescription', 'owningServiceId'],

    ['summary',         'AppendToDescription', 'shortSynopsis'],
    ['description',     'AppendToDescription', 'mediumSynopsis'],
    ['longDescription', 'AppendToDescription', 'longSynopsis'],


Cobalt.System.Production/src/XMLProcessor.cpp
261-
262:struct AppendToDescription {
263-    typedef void result_type;
264:    AppendToDescription(const string& keyName_)
265-     : keyName(keyName_)
266-    {

https://jira.youview.co.uk/browse/DEVARCH-8960
XMLProcessor is responsible for parsing B2C XML responses into `Result` objects. It is used for
    parsing all results, but in particular it is used to parse schedule query results, which can be
    very large. For instance schedule "Tiles" retrieved for the purposes of P/F generation (for
            IP-channels) are >1MB. Since these are being periodically retrieved, and several such
    tiles will be required to cover all the IP-channels, parsing performance is critical.


vector<NS_IRON_SYSTEM::Event> getBBC1Events()
{
    NS_IRON_SYSTEM::Event e1;
    NS_IRON_SYSTEM::Event e2;

    e1.serviceLocator = "dvb://233a..1044";
    e1.eventLocator = "dvb://233a..1044;1";
    e1.shortTitle["eng"] = "Title of e1";          // see map<string, string>
    e1.start = 0;
    e1.publishedDuration = 100;

    e2.serviceLocator = "dvb://233a..1044";
    e2.eventLocator = "dvb://233a..1044;2";
    e2.shortTitle["eng"] = "Title of e2";
    e2.start = 200;
    e2.publishedDuration = 100;

    vector<NS_IRON_SYSTEM::Event> result;
    result.reserve(2);
    result.push_back(e1);
    result.push_back(e2);

    return result;
}


note: this test shows how to use 'result' structure.

Uranium.Client.System/test/metadata/SummaryTest.cpp

SystemClientSummary make_sample_summary(const GuidanceInfo& gi = GuidanceInfo())
{
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult = boost::make_shared<NS_COBALT_SYSTEM::Result>();

    sysResult->description["entityType"] = vector<string>(1, "scheduleevent");
    sysResult->description["eventTitle"] = vector<string>(1, "Eastenders");
    sysResult->description["mediumSynopsis"] = vector<string>(1, "mediumSynopsis");
    sysResult->description["serviceLocator"] = vector<string>(1, "dvb://233a..1044");
    sysResult->description["owningServiceId"] = vector<string>(1, "1");

    if(gi.hasGuidanceCode)
    {
        sysResult->description["guidanceCodes"] = vector<string>(1, "15");
    }

    if(gi.hasGuidanceScheme)
    {
        sysResult->description["guidanceScheme"] = vector<string>(1, "BBCFC");
    }

    if(gi.hasGuidanceText)
    {
        sysResult->description["guidanceText"] = vector<string>(1, "Naughty programme.");
    }

    if(gi.hasGuidanceLongText)
    {
        sysResult->description["longGuidanceText"] = vector<string>(1, "Naughty programme. Watch alone.");
    }

    sysResult->identifiers[
        "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"]
        = vector<string>(1, "dvb://233a..1044;1");

    sysResult->identifiers[
        "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.programmeCRID"]
        = vector<string>(1, "crid://bbc.co.uk/someid");

    SystemClientSummary summary( sysResult,
            clientFactory->createMetadataConfig(),
            clientFactory->createMetadataRepositories(),
            // These tests do not rely on ProvisioningCache
            boost::shared_ptr<ProvisioningCache>(),
            3 );

    return summary;
}


note: WRT getSynopsis, it only uses in void testGetEventFromSummary() but don't see why is doing this.


{wrapper}
/Uranium/Uranium.Client.System/src/metadata/SystemEventWrapper.h

NS_URANIUM_METADATA_CLIENT_OPEN

class SystemEventWrapper  {
public:

    // note: "::cobalt::system"
    
    explicit SystemEventWrapper(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
        scResult(sysResult),
        idBag(scResult)
    {}

    std::string getOwningServiceId() const
    {
        return scResult.getStringFromDescription("owningServiceId");    // note: key
    }

    ...

    SystemClientResult scResult;
    IdentifierBag idBag;
};


class SystemClientResult
{
    // note: this is SP
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;

    explicit SystemClientResult(
            boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
        :sysResult(sysResult)
    {}

    std::string getFirstValueFromDescription(const std::string& key, bool toLower = true) const;

    public:

    string SystemClientResult::getStringFromDescription(const std::string& key) const
    {
        return getFirstValueFromDescription(key, false);
    }

    // note: key
    string SystemClientResult::getFirstValueFromDescription(const std::string& key,
            bool toLower) const
    {
        map<string, vector<string> >::const_iterator iter;

        if((iter = sysResult->description.find(key)) == sysResult->description.end())
        {
            return string();
        }
        vector<string> values = iter->second;
        if(values.size() == 0)
        {
            return string();
        }
        string s = values[0];
        if(toLower)
        {
            s = boost::to_lower_copy(s);
        }
        return s;
    }
};


={============================================================================
*kt_dev_uv_stack_109* stack: cal: metadata: event connection to application

{event-apis}

note: this comes from "build root"

Uranium.AIR.Client.API/asInterfaces/ctv/enhancedmetadata/Event.as

/**
 *  A class that represents the Event in the EPG.
 */ 
public interface Event {

    /**
     *  Returns the title of the Event in the currently selected language.
     */
    function getTitle():String;
    ...
};


The old API has:

getLongSynopsis():Object
getMediumSynopsis():Object

The new API has:

getSynopsis():String
Returns the synopsis of the Event if current data source provides it.

The both are defined in "Event".

   linear::Event                 metadata::Event

   SCE                           SCE

   SCER                          SCER

                                 SCER->getEventWindow() : EPG has SCER via SCF


{which-events}
<linear>
DEVARCH/Uranium/Uranium.Client.API/include/linear-metadata/Event.h 

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic 
{
  public:
    virtual boost::shared_ptr<synopsis> getMediumSynopsis() const = 0;
    virtual boost::shared_ptr<synopsis> getLongSynopsis() const = 0;
};


<metadata>
DEVARCH/Uranium/Uranium.Client.API/include/metadata/Event.h

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic 
{
  public:
    virtual std::string getSynopsis() const = 0;
};

class ZINC_LOCAL SystemClientEvent : virtual public Event
{
    std::string SystemClientEvent::getSynopsis() const
    {
        URANIUM_PROFILE_FUNC;
        return synopsis;
    }
};


Uranium.Client.System/src/metadata/SystemClientEvent.h
Uranium.Client.System/src/metadata/SystemClientEvent.cpp

Uranium.Client.System/src/linear-metadata/SystemClientEvent.h
Uranium.Client.System/src/linear-metadata/SystemClientEvent.cpp

This means Event is ABC and SCE is concrete class to have implementation. How to select an
appropriate class to use in client side? Uses 'namespace'

NS_URANIUM_LINEAR_CLIENT_OPEN
NS_URANIUM_METADATA_CLIENT_OPEN

note: Events differs in 'interfaces' and not like a simple structure. So how Events differs is not
to compare two in diff since it's up to SCE how to present via interface.


{linear-sce}

typedef std::map<std::string,std::string> synopsis;

boost::shared_ptr<NS_IRON_SYSTEM::Event> systemEvent;

SystemClientEvent::SystemClientEvent(NS_IRON_SYSTEM::Event event_,
        boost::shared_ptr<NS_IRON_SYSTEM::EventRepository> eventRepository_,
        boost::shared_ptr<NS_CADMIUM_SYSTEM::LinearAcquisition> linearAcquisition_,
        boost::weak_ptr<NS_URANIUM_LINEAR_CLIENT::ReminderRepository> reminderRepository_)
    : eventRepository(eventRepository_),
      reminderRepository(reminderRepository_),

      systemEvent(boost::make_shared<NS_IRON_SYSTEM::Event>(event_)),

      linearAcquisition(convertToSync(linearAcquisition_))
{

}

1. events->push_back(
        make_shared<SystemClientEvent>(
            sysEvents.at(i), eventRepository, linearAcquisition, reminderRepository));

2. return make_shared<SystemClientEvent>(
        systemEvent.get(), sysEventRepository, sysLinearAcquisition, reminderRepository);



{metadata-sce-overloads}

// <1> dtt event. from 'iron' <CSCE>
//
// used in DTT::getClientEvents(). 
//
// run on a target: 'nothing' logged in the log
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
   const std::string& lang,
   const NS_IRON_SYSTEM::Event& dttEvent) :

   synopsis(extractValueFromMap(dttEvent.longSynopsis, lang))
{}


// <2> Constructs SystemClientEvent from Iron System Event and MAS event. 
// note that used in mergeEvent(). use <4> for mas and use <1> for dttEvent. This means DTT uses
// longSynopsis.
//
// run on a target: 'nothing' logged in the log
//
SystemClientEvent::SystemClientEvent(shared_ptr<SystemClientEvent>& dttEvent,
        shared_ptr<SystemClientEvent>& masEvent):

   synopsis(dttEvent->getSynopsis()),
{
    // fill some from masEvent but not for synopsis.
}

// <3> Creates MAS event with a new broadcast time
// used in mergeEvent(). 
SystemClientEvent::SystemClientEvent(shared_ptr<SystemClientEvent>& masEvent,
   const uint32_t start_,
   const uint32_t end_):

   synopsis(),
{}


// Creates MAS Event
// <4> used in IP::getClientEvents(). 'cobalt' and 'wrapper'
//
// run on a target: wrapper used but only 'medium' logged in the log. means that only medium in
// cobalt::result.
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        const SystemEventWrapper& masEvent) :

   synopsis(),
{
    // note: no updates on synopsis.
}

// Creates null event.
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos, 
    boost::shared_ptr<Service> service_, uint32_t start_, uint32_t end_):
    synopsis(),
{}


// <5> Creates a SystemClientEvent from FullEvent. This is used for linear search.
// used in Summary
//
SystemClientEvent::SystemClientEvent(boost::weak_ptr<MetadataRepositories> repos,
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
            flags(0),
            isCachedFlag(false),
            id(locator),
            type(IP)
{
    const SystemClientFullEvent fullEvent = SystemClientFullEvent(sysResult);
    synopsis = fullEvent.getMediumSynopsis();
}

// note: do the same as 'wrapper' 
class SystemClientFullEvent : public FullEvent {
public:
    explicit SystemClientFullEvent(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult) :
        scResult(sysResult),
        idBag(scResult)
    {}

    virtual std::string getMediumSynopsis() const
    {
       return scResult.getStringFromDescription("mediumSynopsis");
    }
};



{where-create-scs}
Calls to create SCE. 

<linear>
src/linear-metadata/SystemClientEventRepository.cpp

boost::shared_ptr<Event> makeEvent() 
{
  return make_shared<SystemClientEvent>(
      systemEvent.get(), sysEventRepository, sysLinearAcquisition, reminderRepository);
}

boost::shared_ptr<std::vector<boost::shared_ptr<Event> > > getPresentFollowing()
{
   eventsPtr->push_back(make_shared<SystemClientEvent>(
         *event, eventRepository, linearAcquisition, reminderRepository));
}


<merged>
270 Uranium.Client.System/src/metadata/EventCollectionOperations.cpp     

/**
 * Creates a null event a.k.a "no information available" event.
 * They basically are events which fill any gaps in schedule EventWindow may contain.
 */
boost::shared_ptr<SystemClientEvent> createNullEvent(boost::weak_ptr<MetadataRepositories> repos,
                                                     uint32_t service, uint32_t start, uint32_t end)
{
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::ServiceRepository> serviceRepo 
        = strongRepos->serviceRepo;

    //clog<<"Creating null event on service "<<service<<" time: ("<<start<<","<<end<<")"<<endl;
    
    return boost::make_shared<SystemClientEvent>(repos,
            serviceRepo->getServiceBySLI(service % serviceRepo->getServiceCount()), start, end);
}


={============================================================================
*kt_dev_uv_stack_110* stack: cal: metadata: how events get updated

<0> EPG 
EPG uses this:
Package ctv.enhancedmetadata, Interface public interface EventRepository::getEventWindow

// from textEPG
//
boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
   boost::make_shared<TextEPGEventWindowEventListener>();

boost::shared_ptr<EventWindow>  EPG::createEventWindow(
        boost::shared_ptr<EventRepository> eventRepo)
{
    Future<boost::shared_ptr<EventWindow> > f = 
        eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());

    boost::shared_ptr<EventWindow> newWindow = f.get();

    newWindow->addListener(listener);
    return newWindow;
}

<1>
This scenario is to make a command to FD(future dispatcher) and to get response, events, back.

/**
 * @brief A private struct capturing all the necessary data about the request to create a new EventWindow
 */
struct EventWindowCreateCommand : public MetadataChangeListener {

    EventWindowCreateCommand(
            NS_ZINC::Promise<boost::shared_ptr<EventWindow> > promise_,
            Bounds location_,
            Bounds requestedDataBounds_,
            event_collection_ptr oldEvents_,
            boost::posix_time::ptime dataRetrievalStartTime_,
            boost::weak_ptr<ServiceRepository> serviceRepo_):
                promise(promise_),
                location(location_),
                requestedDataBounds(requestedDataBounds_),
                oldEvents(oldEvents_),
                newMASEvents(boost::make_shared<event_collection>()),
                newDTTEvents(boost::make_shared<event_collection>()),
                newEvents(boost::make_shared<event_collection>()),
                newWindow(),
                serviceRepo(serviceRepo_),
                promiseCompleted(false),
                dataRetrievalStartTime(dataRetrievalStartTime_),
                masDataRequested(false),
                dttDataRequested(false),
                noDttDataFound(false),
                metadataChanged(false),
                isListeningToMetadataChanges(false)
    {
    }

    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > promise;

    //Events from old event window that intersect with the new one
    event_collection_ptr oldEvents;
    //Events for this event window that came from MAS
    event_collection_ptr newMASEvents;
    //Events for this event window that came from Iron
    event_collection_ptr newDTTEvents;

    //The window created as a result of this request
    boost::weak_ptr<SystemClientEventWindow> newWindow;
};

Future<boost::shared_ptr<EventWindow> > SystemClientEventRepository::getEventWindow(
        uint32_t startingServiceRow, uint32_t serviceCount,
        boost::posix_time::ptime startTime, int32_t seconds,
        event_collection_ptr intersectingEvents, Bounds missing,
        bool isMovingForward)
{
    // note: set FD?
    //
    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > p(*getFutureDispatcher());

    EventWindowCreateCommand cmd( p, newWindowLocation, newWindowLocation,
            intersectingEvents, microsec_clock::universal_time(),
            serviceRepo);

    // note: save up ew?
    //
    boost::shared_ptr<SystemClientEventWindow> ew = createEventWindow(cmd, newWindowEvents, hasStaleData);
    cmd.promise.complete(ew);
    cmd.promiseCompleted = true;

    // note: this cmd has *SCEW, and promise
    
    getEventsFromSystemAPI(cmd);

    // note: return future
    
    return p.getFuture();
}


void SystemClientEventRepository::getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
{
  URANIUM_FUNC_TRACE;
  URANIUM_PROFILE_FUNC;
  Bounds& dataRetrievalBounds = cmd.requestedDataBounds;

  int64_t start = to_time_t(dataRetrievalBounds.startTime);
  int64_t end = to_time_t(dataRetrievalBounds.startTime) + dataRetrievalBounds.seconds;

  // note: Future?
  NS_ZINC::FutureBarrier bar(*getFutureDispatcher());

  // eventsReceived is overloaded, we need to get the pointer to it first, and the pass to bind.
  // 'cobalt'
  void (SystemClientEventRepository::*masCallback)
    (boost::shared_ptr<EventWindowCreateCommand>,
     const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result > > &) =
    &SystemClientEventRepository::eventsReceived;

  // 'iron'
  void (SystemClientEventRepository::*dttCallback)
    (boost::shared_ptr<EventWindowCreateCommand>,
     const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > &) =
    &SystemClientEventRepository::eventsReceived;

  // 'cmd'. create 'window'
  //the two callbacks share the ownership of the command
  boost::shared_ptr<EventWindowCreateCommand> sharedCmd = boost::make_shared<EventWindowCreateCommand>(cmd);

  //make sure that if something changes about the metadata while we're retrieving it from system API,
  //we know about it and can react appropriately (e.g. marking the EventWindow about to be created as stale)
  metadataObserver->addListener(sharedCmd);

  // calls 'merge' events
  // 'eventWindowDataRetrievalComplete'
 
  bar.setCallback(boost::bind(
              &SystemClientEventRepository::eventWindowDataRetrievalComplete, shared_from_this(), sharedCmd));

  // 'request' data from System API:

  if(recids.empty() == false)
  {
    URANIUM_INFO("Requesting schedule metadata from MAS.");

    // this is call to 'cobalt'
    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
      metadataBroker->getEventSummariesByServices(recids, start, end);
    
    // note: masCallback 
    bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));
  }

  if(locators.empty() == false)
  {
    URANIUM_INFO("Requesting schedule metadata from DTT.");

    int64_t dttStart = adjustDTTWindowStart(config, start);

    Future <vector<NS_IRON_SYSTEM::Event>> fDTTEvents 
      = systemEventRepo->getScheduleEvents(locators, dttStart, end);

    note: dttCallback
    bar.addWithCallback(fDTTEvents, boost::bind(dttCallback, this, sharedCmd, _1));
  }
}



::FutureBar    <- from components on dbus?


<callback-one>

typedef std::vector<boost::shared_ptr<SystemClientEvent> > event_collection;
typedef boost::shared_ptr<event_collection> event_collection_ptr;


# IP version note:  getClientEvents from 'cobalt'

event_collection_ptr getClientEvents(const std::vector<NS_COBALT_SYSTEM::Result>& systemResults)
{
    BOOST_FOREACH(const NS_COBALT_SYSTEM::Result& sysResult, systemResults)
    {
        // 'wrapper'  note: wrapper is no longer used in the john's change.
        // need to check!
        
        SystemEventWrapper ewrap(boost::make_shared<NS_COBALT_SYSTEM::Result>(sysResult));

        boost::shared_ptr<SystemClientEvent> mevent =
            boost::make_shared<SystemClientEvent>(getRepos(), ewrap);
        events->push_back(mevent);
    }

    return events;
}

void SystemClientEventRepository::eventsReceived(boost::shared_ptr<EventWindowCreateCommand> command,
        const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
{
    const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();

    event_collection_ptr  clientEvents = getClientEvents(systemEvents);

    copy(clientEvents->begin(), clientEvents->end(), back_inserter(*command->newMASEvents));

    //
    // <Q> HOW THIS newMASEvents get delivered to EPG?
    //
}


# DTT version note:  getClientEvents from 'iron'

src/metadata/SystemClientEventRepository.cpp

boost::shared_ptr<SystemClientEvent> make_client_event(const NS_IRON_SYSTEM::Event& e)
{
  if(!e.eventLocator.empty())
  {
    // note: uses <1> and see above. <CSCE>
    return boost::shared_ptr<SystemClientEvent>( 
        new SystemClientEvent(getRepos(), config->getLanguage(), e));
  }

  return boost::shared_ptr<SystemClientEvent>();
}

event_collection_ptr getClientEvents(
            const std::vector<NS_IRON_SYSTEM::Event> & events) 
{
    BOOST_FOREACH(const NS_IRON_SYSTEM::Event& event, events)

    boost::shared_ptr<SystemClientEvent> scEvent = make_client_event(event);
}

void eventsReceived(
   boost::shared_ptr<EventWindowCreateCommand> command,
   const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > & eventsFV)
{
   event_collection_ptr clientEvents = getClientEvents(systemEvents);
}  

This leads to getClientEvents overloads for IP or DTT


<callback-two> 'merge' events

// called from getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
//
void SystemClientEventRepository::eventWindowDataRetrievalComplete(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    event_collection_ptr events =  mergeEvents(command->newDTTEvents, command->newMASEvents);

    notifyExistingWindowAboutNewData(command);
}


/**
 * Merges two sets of events coming from different data sources
 */
event_collection_ptr mergeEvents(event_collection_ptr dttEvents, event_collection_ptr masEvents)
{

    BOOST_FOREACH(boost::shared_ptr<SystemClientEvent>& edtt, *dttEvents)

    event_collection::iterator eip = // SCE in masEvents

    // 102 <4>
    //there is one, merge the properties
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(edtt, *eip));

    // note: eip is SCE here !!!

    BOOST_FOREACH(boost::share d_ptr<SystemClientEvent>& eip, *masEvents)

    boost::shared_ptr<SystemClientEvent> firstDTTEvent = *firstDTTEventIter;
    boost::shared_ptr<SystemClientEvent> lastDTTEvent = *lastDTTEventIter;

    // 189 <5>
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(eip, eip->getStartAsTimeT(), firstDTTEvent->getStartAsTimeT()));

    // 202
    boost::shared_ptr<SystemClientEvent> emerged = boost::shared_ptr<SystemClientEvent>(
            new SystemClientEvent(eip, lastDTTEvent->getEndAsTimeT(), eip->getEndAsTimeT()));
}


<notify-to-epg>

class ZINC_EXPORT EventListener : virtual public Polymorphic 

class ZINC_EXPORT `EventWindowEventListener` : public NS_ZINC::EventListener
{
    /**
     * Indicates the Event Window has changed substantially. To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged() = 0;

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void EventsChanged(const std::vector<boost::shared_ptr<Event> > events) = 0;
};

// note: from textEPG

class TextEPGEventWindowEventListener : public EventWindowEventListener
{
public:

    /**
     * Indicates the Event Window has changed substantially. To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged()
    {
    	printDebug("EventWindowChanged.");
        actionProcessor->post(boost::bind(&doRefreshWindowAndPrintStats));
    }

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void EventsChanged(
            const std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> >  events)
    {
        string s = "EventsChanged: ";
        BOOST_FOREACH(boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e, events)
        {
            s += e->getTitle() + string("(") +
                    boost::lexical_cast<string>(e->getContainingServiceListIndex()) + string("), ");
        }
        printDebug(s);
        sleep(3);
        actionProcessor->post(doRefreshWindowAndPrintStats);
    }
};


boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
   boost::make_shared<TextEPGEventWindowEventListener>();


boost::shared_ptr<EventWindow>  EPG::createEventWindow(
        boost::shared_ptr<EventRepository> eventRepo)
{
    Future<boost::shared_ptr<EventWindow> > f = 
        eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());

    boost::shared_ptr<EventWindow> newWindow = f.get();

    // note: mean that got window from future?
    
    newWindow->addListener(listener);

    return newWindow;
}


template<class ListenerT>
class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer<ListenerT> 
{
    virtual void addListener(boost::shared_ptr<ListenerT> listener) {
        // Hoisting note: we cast to void* here, and cast back down in
        // DowncastingCaller so everything is lovely and symmetrical
        impl.addListener(listener);
    }
};

typedef void hoisted_event_listener;

// from class definition

void addListener(boost::shared_ptr<hoisted_event_listener> listener, 
        boost::shared_ptr<EventDispatcher> clientDispatcher=boost::shared_ptr<EventDispatcher>());

// /Zinc/Zinc.Common/src/DispatchingEventProducer.cpp

void DispatchingEventProducerHoisted::addListener(
   boost::shared_ptr<hoisted_event_listener> listener, boost::shared_ptr<EventDispatcher> clientDispatcher) 
{

    if (!listener) {
        throw std::invalid_argument("NULL listener provided in call to addListener()!");
    }

    ZINC_COMMON_DEBUG(std::string(__func__)+" Dispatcher: "
            +boost::lexical_cast<std::string>(static_cast<const EventDispatcher*>(clientDispatcher.get()))+
            ", Producer: "+boost::lexical_cast<std::string>(this)+
            ", Listener: "+boost::lexical_cast<std::string>(listener.get())
            );

    bool duplicate = false;

    boost::mutex::scoped_lock lock(mutex);

    if (!clientDispatcher) {
        if (!dispatcher) {
            throw std::logic_error("addListener() called, but event producer has no dispatcher set.");
        }
        clientDispatcher = dispatcher;
    }

    // Call entry->second->onWorkAdded()
    Dispatcher::work work(*clientDispatcher);

    // note: make one which is a pair
    
    listener_entry newEntry(listener, clientDispatcher);

    BOOST_FOREACH(const listener_entry& entry, listeners) {

        if (entry.first == newEntry.first) {
            duplicate = true;
            break;
        }
    }

    if (!duplicate) {
        work.release();

        // note: push one
        
        listeners.push_front(newEntry);
    }
}


void SystemClientEventRepository::notifyExistingWindowAboutNewData(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    boost::shared_ptr<SystemClientEventWindow> w = command->newWindow.lock();

    if (w && (cacheGetResult.isStale() == false || w->isCreatedFromStaleData() == false))
    {
        URANIUM_DEBUG("Sending update to the existing window.");
        w->ConfigChanged();
    }
}

void SystemClientEventWindow::ConfigChanged()
{
    isStale = true;
    std::clog<<"EventWindow: Config changed"<<std::endl;
    notifyWindowChanged();
}


// void SystemClientEventWindow::notifyWindowChanged()
// {
// 
//     // ?? 
//     // void SystemClientEventWindow::EventsChanged
//     // (const std::vector<std::string> &eventIdentifiers)
//     
//     produceEvent(bind(&EventWindowEventListener::EventWindowChanged, _1));
// }

void SystemClientEventWindow::notifyEventsChanged(
        std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> > events)
{
    produceEvent(bind(&EventWindowEventListener::EventsChanged, _1, events));
}


<DEPH> Zinc/Zinc.Common/src/DispatchingEventProducer.cpp

typedef std::pair<boost::weak_ptr<hoisted_event_listener>, boost::shared_ptr<EventDispatcher> > 
   listener_entry;

class ZINC_EXPORT DispatchingEventProducerHoisted : boost::noncopyable 
{
    DispatchingEventProducerHoisted(boost::shared_ptr<EventDispatcher> dispatcher_) :
        dispatcher(dispatcher_) { }

    // note: event is 'functor'
    
    void produceEvent(boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event) 
    {
        boost::mutex::scoped_lock lock(mutex);

        size_t len = listeners.size();

        // note: copy listeners to localListeners

        // We copy listeners to this stack allocated array before dispatch so we
        // don't have to hold the lock while calling user code.
        listener_entry localListeners[len];
        listener_entry* next = localListeners;

        std::list<listener_entry>::iterator i = listeners.begin();

        std::list<listener_entry> forRemoval;
        while (i != listeners.end()) {

            if (!i->first.expired()) {
                *next++ = *i;
                ++i;
            } else {
                // Listener or dispatcher instance may have been destroyed since it was registered.
                // Detect this, and remove from collection.
                // Avoid calling dispatcher destructors while the mutex is locked.
                forRemoval.splice(forRemoval.end(), listeners, i++);
                len--;
            }
        }

        // Don't hold locks while running user code:
        lock.unlock();

        BOOST_FOREACH(listener_entry& l, forRemoval) {

            // note: DISPATCH. <Q> How this maps to 'dispatcher' which is DD.
            
            // Call entry->second->onWorkRemoved()
            Dispatcher::work(*l.second, boost::adopt_lock_t());
        }
        forRemoval.clear();

        for (size_t i = 0; i < len; ++i) {

            localListeners[i].second->post(
                    makeWeakFunctor(event, localListeners[i].first));
        }
    }

    private:
    /**
     * This is the default dispatcher. Clients can provide their own in addListener().
     */
    boost::shared_ptr<EventDispatcher> dispatcher;

    // note: 'mutable' ?
    mutable boost::mutex mutex;
};


/**
 * Make a WeakFunctor given a functor and a weak_ptr.
 */
template <typename Functor, typename T>
inline WeakFunctor<Functor, T>
makeWeakFunctor(Functor f, boost::weak_ptr<T> object)
{
    return WeakFunctor<Functor, T>(f, object);
}


//
// produceEvent(f)		
//    -> dispatch thread calls 
//       f( <boost::weak_ptr<hoisted_event_listener> ); // event(pair.second);
//    
//       this expands to due to bind()
//
//       -> EventWindowEventListener::EventsChanged( <boost::weak_ptr<hoisted_event_listener> );
//


void SystemClientEventWindow::EventsChanged(const std::vector<std::string> &eventIdentifiers)
{
    URANIUM_FUNC_TRACE;
    if(!isZombie)
    {
        std::vector<boost::shared_ptr<Event> > eventsInThisWindow;
        eventsInThisWindow.reserve(events.size());

        BOOST_FOREACH(const std::string& identifier, eventIdentifiers)
        {
            vector<boost::shared_ptr<Event> > events = this->findEventsByIdentifier(identifier);
            eventsInThisWindow.insert(eventsInThisWindow.end(), events.begin(), events.end());
        }

        URANIUM_DEBUG("Number of events changed in this window: "<<eventsInThisWindow.size());

        if(!eventsInThisWindow.empty())
        {
            notifyEventsChanged(eventsInThisWindow);
        }
    }
    else
    {
        URANIUM_INFO("Ignoring events change signal - this window requires refresh anyway.");
    }
}


={============================================================================
*kt_dev_uv_stack_111* stack: cal: future producer and event producer

{future-dispatcher}

class ZINC_EXPORT InlineDispatcher : public Dispatcher
{
    public:
        InlineDispatcher();
        ~InlineDispatcher();

        /**
         * Since InlineDispatcher is stateless, it is convenient to reuse
         * a single instance of it.
         *
         * This does not mean that we must always use it as a singleton.
         *
         * @return an instance that may be shared.
         */
        static InlineDispatcher& sharedInstance();

    public: // from Dispatcher
        virtual void post(boost::function<void ()> handler);
        virtual int getPendingCount();
};

/DEVARCH/Zinc/Zinc.Common/include/async/Dispatcher.h

/*
 * Interface for general functor dispatcher.
 *
 * Dispatchers are used to 'invoke' callback functors (for events and futures for example).
 *
 */
struct ZINC_EXPORT Dispatcher : boost::noncopyable
{
	/**
	 * Dispatcher::work is a RAII class.  An object of this type should exist
	 * for as long as there is the possibility of you calling post.  This is
	 * similar to an boost::io_service::work and will prevent the dispatcher
	 * from running down.
	 *
	 * Example: A Future will hold a work object after setCallback is called
	 *          as it knows it will be posting a functor at some point in the
	 *          future (but doesn't know when).  After the callback is called
	 *          the work object is destroyed so the dispatcher can run down.
	 */
	typedef boost::unique_lock<Dispatcher> work;

	virtual ~Dispatcher();

	/**
	 * Post the supplied completion handler to the dispatcher for execution.
	 *
	 * The Dispatcher will hold a reference to the suppled functor until the
	 * it has been executed.
	 *
	 * @param handler the completion handler
	 */
	virtual void post(boost::function<void ()> handler) = 0;

private:
	/**
	 * These methods are called when a Dispatcher::work object is
	 * created/destroyed. Typically a dispatcher that is interested will treat
	 * these functions like a ref count inc/dec.
	 *
	 * It is not necessary to implement these functions.  The default
	 * implementations do nothing.
	 */
	virtual void onWorkAdded() {};
	virtual void onWorkRemoved() {};

private: // Lockable concept
	// Implement the "lockable" concept so we can use unique_lock as our RAII
	// "work" class
	friend class boost::unique_lock<Dispatcher>;
	void lock() ZINC_LOCAL { onWorkAdded(); };
	void unlock() ZINC_LOCAL { onWorkRemoved(); };
};


/*
 * A Dispatcher implementation that 'owns' a single 'thread' on which it executes the
 * functors posted to it. Functors are executed strictly in the order that they are
 * posted to the dispatcher.
 */
class ZINC_EXPORT SingleThreadDispatcher : public Dispatcher
{
public:
	SingleThreadDispatcher();
	~SingleThreadDispatcher();

public: // from Dispatcher
	virtual void post(boost::function<void ()> handler);
	virtual int getPendingCount();

private:
	boost::asio::io_service io;
	boost::thread thread;
};

/**
 * Post a functor to the dispatcher, and put it on the pending dispatch queue.
 */
void SingleThreadDispatcher::post(boost::function<void ()> handler)
{
	io.post(handler);
}


typedef SingleThreadDispatcher SequentialFutureDispatcher;


class ZINC_EXPORT SystemClientFactory : public ClientFactory, public NS_ZINC::Resettable 
{
    boost::shared_ptr<NS_ZINC::EventDispatcher> defaultDispatcher;

    boost::shared_ptr<NS_ZINC::FutureDispatcher> futureDispatcher;

    // create ED, FD

    SystemClientFactory() :
        defaultDispatcher(boost::make_shared<InlineDispatcher>()),

        // note:
        futureDispatcher(boost::make_shared<SequentialFutureDispatcher>()),

        provisioningCacheThread(boost::make_shared<SingleThreadDispatcher>())
    {
    }

    // pass FD to SCER

    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::SystemClientEventRepository> 
        createConcreteEventRepository() 
        {
            concreteER->setDefaultDispatcher(getDefaultDispatcher());

            // set dispatchers
            
            concreteER->setFutureDispatcher(futureDispatcher);
        }

    boost::shared_ptr<EventDispatcher> getDefaultDispatcher() 
    {
        if (!defaultDispatcher.get())
            throw runtime_error("No default dispatcher set");
        return defaultDispatcher;
    }
};



{future-producer}

/*
 * DispatchingFutureProducer
 *
 * Provide an interface for injecting a future dispatcher
 */
class DispatchingFutureProducer : virtual public Polymorphic
{
public:
	virtual void setFutureDispatcher(boost::shared_ptr<FutureDispatcher> dispatcher)
	{
		boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
		this->dispatcher = dispatcher;
	}
	virtual void removeFutureDispatcher()
	{
		boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
		dispatcher.reset();
	}
	virtual boost::shared_ptr<FutureDispatcher> getFutureDispatcher() const
	{
		boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
		return dispatcher;
	}
private:
	boost::shared_ptr<FutureDispatcher> dispatcher;
	mutable boost::recursive_mutex dispatcherMutex;
};


class ZINC_EXPORT SystemClientEventRepository : 
    public EventRepository,
    public NS_ZINC::DispatchingFutureProducer,
    public boost::enable_shared_from_this<SystemClientEventRepository>,
    public MetadataChangeListener
{
    boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher;

    void setDefaultDispatcher(boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher_)
    {
        dispatcher = dispatcher_;
    }

    // note: called in @getEventWindow(), @eventReceived() for IP and DTT
    
    /**
     * Creates event window from events passed in.
     * @note The method sanitizes the events, removes duplicates and joins adjacent null events
     * @note This method assumes that if there are duplicates inside events passed in, they'll be identical.
     */
    boost::shared_ptr<SystemClientEventWindow> SystemClientEventRepository::createEventWindow(
            EventWindowCreateCommand& cmd,
            event_collection_ptr events, bool hasStaleData)
    {
        //clog<<"Creating window in "<<cmd.location;
        boost::shared_ptr<SystemClientEventWindow> ew = 
            boost::make_shared<SystemClientEventWindow>(cmd.location,
                    sanitizedEvents, serviceRepo, shared_from_this(),
                    (microsec_clock::universal_time() - cmd.dataRetrievalStartTime).total_milliseconds(),
                    cmd.hasDataFromAllSources(), hasStaleData);

        // note: set FD!

        ew->setDispatcher(dispatcher);

        metadataObserver->addListener(ew);
    }
};



{event-producer} window

// * An abstract producer of events matching a particular specification.

template<class ListenerT>
class ZINC_EXPORT EventProducer : virtual public Polymorphic 
{
   virtual void addListener(boost::shared_ptr<ListenerT> listener) = 0;
};


// note: it do not have a thread

typedef Dispatcher EventDispatcher;

// /Zinc/Zinc.Common/include/DispatchingEventProducer.h

template<class ListenerT>
class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer<ListenerT> 
{
    // <DEPH>
    mutable detail::DispatchingEventProducerHoisted impl;

    // * @param dispatcher_ this dispatcher will be used to 'dispatch' event listener callback
    // * methods, unless clients explicitly provide an alternative dispatcher in the
    // * call to addListener()
    //
    explicit DispatchingEventProducer(boost::shared_ptr<EventDispatcher> dispatcher_) 
        : impl(dispatcher_) {}

    virtual void addListener(boost::shared_ptr<ListenerT> listener) {
        // Hoisting note: we cast to void* here, and cast back down in
        // DowncastingCaller so everything is lovely and symmetrical
        impl.addListener(listener);
    }

    // pass 'dispatcher' to 'impl' which is the hoisted
    
    virtual void setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher) {
        impl.setDispatcher(dispatcher);
    }

	 // * Derived implementations should call this method to dispatch an event.
    
    template <typename Functor>
        void produceEvent(Functor f) const {

            ZINC_CHECK_CONCEPT(f(static_cast<ListenerT*>(NULL)));
            impl.produceEvent(DowncastingCaller<Functor>(f));
        }
};


//  * A class that represents the Event Window, basically the EPG view.
class ZINC_EXPORT EventWindow : virtual public NS_ZINC::DispatchingEventProducer<EventWindowEventListener> 
{
   // EventWindow is ABC
};


// created from createEventWindow() and passed up to EPG

class ZINC_EXPORT SystemClientEventWindow 
                                 : virtual public EventWindow,
                                   public boost::enable_shared_from_this<SystemClientEventWindow>,
                                   virtual public MetadataChangeListener 
{
    // note: add f = bind() to listeners. so when called from listners, will lead to 
    // EventWindowEventListener::EventsChanged(_1, events);
    
    notifyEventsChanged(std::vector<boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> > events)
    {
        produceEvent(bind(&EventWindowEventListener::EventsChanged, _1, events));
    }

    notifyWindowChanged()
    {
        produceEvent(bind(&EventWindowEventListener::EventWindowChanged, _1));
    }
};


={============================================================================
*kt_dev_uv_stack_112* stack: cal: metadata: summary

Uranium.Client.API/include/metadata/Summary.h

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT Event : virtual public NS_ZINC::Polymorphic;

class ZINC_EXPORT Summary : virtual public NS_ZINC::Polymorphic
{
  /**
   * Returns Event object if getSummaryType() returns SCHEDULE_EVENT otherwise throws
   * EntityNotPresentException.
   */
  virtual boost::shared_ptr<Event> getEvent() = 0;
}

Uranium.Client.System/src/metadata/SystemClientSummary.h

class SystemClientSummary : public Summary
{
  public:
    SystemClientSummary(
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult,
        boost::shared_ptr<SystemClientMetadataConfig> config,
        boost::weak_ptr<MetadataRepositories> repos_,
        boost::shared_ptr<ProvisioningCache> provisioningCache_,
        uint32_t absoluteIndex_);

    :sysResult(sysResult), config(config), repos(repos_)
    {}

    virtual boost::shared_ptr<Event> getEvent()
    {
      if(entityType != ENTITY_SCHEDULE_EVENT)
      {
        throw EntityNotPresentException("Incorrect entity type. Expected " +
            boost::lexical_cast<string>(ENTITY_SCHEDULE_EVENT) + ", got " +
            boost::lexical_cast<string>(entityType));
      }

      // note: uses <3> to create SCS and see above. metedata-overload
      
      return boost::make_shared<SystemClientEvent>(repos, sysResult);
    }

  private:
    boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;
    boost::weak_ptr<MetadataRepositories> repos;
};


<use-summary>
Uranium.Client.System/src/metadata/SystemClientSummaryResultSet.cpp

note: this is 'only' place to use SCS and the the set is a vector of SCS. See <CMB>

SystemClientSummaryResultSet::SystemClientSummaryResultSet( 
    boost::shared_ptr<NS_COBALT_SYSTEM::ResultSet> sysResultSet,
    boost::shared_ptr<SystemClientMetadataConfig> config,
    boost::weak_ptr<MetadataRepositories> repos,
    boost::shared_ptr<ProvisioningCache> provisioningCache_,
    : provisioningCache(provisioningCache_),
      summaries(

          // note:
          getClientSummaries(sysResultSet->results, config, repos, startIndex)),

      totalMASResultSetSize(sysResultSet->totalSize)
{
}


boost::shared_ptr<SystemClientSummaryResultSet::summary_ptr_vector>
    SystemClientSummaryResultSet::getClientSummaries( const std::vector< Result >& systemResults,
                                                      boost::shared_ptr<SystemClientMetadataConfig> config,
                                                      boost::weak_ptr<MetadataRepositories> repos,
                                                      uint32_t startIndex)
{
  shared_ptr<summary_ptr_vector> clientSummaries = make_shared<summary_ptr_vector>();
  clientSummaries->reserve(systemResults.size());

  for( size_t i = 0; i < systemResults.size(); ++i)
  {
    clientSummaries->push_back(
        make_shared_summary( systemResults[i], config, repos, provisioningCache, i + startIndex) );
  }
  return clientSummaries;
}

shared_ptr<SystemClientSummary> make_shared_summary( const Result& sysResult,
    boost::shared_ptr<SystemClientMetadataConfig> config,
    boost::weak_ptr<MetadataRepositories> repos,
    boost::shared_ptr<ProvisioningCache> provisioningCache,
    uint32_t index )
{
  shared_ptr<Result> sysResultPtr = make_shared<Result>(sysResult);
  return make_shared<SystemClientSummary>(sysResultPtr, config, repos, provisioningCache, index);
}


<test>
Uranium.Client.System/test/metadata/SummaryTest.cpp

class ZINC_LOCAL SummaryTest :  NS_ZINC::IntegrationTestSandbox, public DefaultMetadataMocksEnvironment
{
  void testGetEventFromSummary()
  {
    SystemClientSummary summary( sysResult,
        clientFactory->createMetadataConfig(),
        clientFactory->createMetadataRepositories(),     note: this is repo(event)
        // These tests do not rely on ProvisioningCache
        boost::shared_ptr<ProvisioningCache>(),
        3 );

    CPPUNIT_ASSERT(summary.getEvent());
    CPPUNIT_ASSERT_EQUAL(string("Eastenders"), summary.getEvent()->getTitle());

   note: MEDIUM SYNOPSIS

   CPPUNIT_ASSERT_EQUAL(string("mediumSynopsis"), summary.getEvent()->getSynopsis());
   CPPUNIT_ASSERT(summary.getEvent()->getService());
  }
}


={============================================================================
*kt_dev_uv_stack_113* stack: cal: test

/data/builds/DEVARCH-8092/huawei.370/ \
   zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/tests/uranium-client-system/test/metadata

-rwxr-xr-x 1 kpark kpark  391852 Feb 25 14:44 brokerintegrationtest*
-rwxr-xr-x 1 kpark kpark 5250731 Feb 25 14:44 eventcachettltest*
-rwxr-xr-x 1 kpark kpark 5260059 Feb 25 14:44 eventwindowresizetest*
-rwxr-xr-x 1 kpark kpark 3986922 Feb 25 14:44 fulleventtest*
-rwxr-xr-x 1 kpark kpark 2024474 Feb 25 14:44 identifierbagtest*
-rwxr-xr-x 1 kpark kpark 2022120 Feb 25 14:44 identifierprocessingtest*
-rwxr-xr-x 1 kpark kpark 4468512 Feb 25 14:44 mediarecordcachetest*
-rwxr-xr-x 1 kpark kpark 5292645 Feb 25 14:44 metadatabrokerfunctest*
-rwxr-xr-x 1 kpark kpark 1502519 Feb 25 14:44 metadataobservertest*
-rwxr-xr-x 1 kpark kpark 1624748 Feb 25 14:44 metadatasourcefallbacktest*
-rwxr-xr-x 1 kpark kpark  217077 Feb 25 14:44 metadata-systemclientfactorytest*
-rwxr-xr-x 1 kpark kpark 4423512 Feb 25 14:44 presenteventscachesanitisationtest*
-rwxr-xr-x 1 kpark kpark 4426963 Feb 25 14:44 presenteventscachetest*
-rwxr-xr-x 1 kpark kpark 3977156 Feb 25 14:44 programmetest*
-rwxr-xr-x 1 kpark kpark 2265663 Feb 25 14:44 provisioningcachetest*
-rwxr-xr-x 1 kpark kpark 3986679 Feb 25 14:44 publicationtest*
-rwxr-xr-x 1 kpark kpark 5249049 Feb 25 14:44 servicefilteringtest*
-rwxr-xr-x 1 kpark kpark 1482503 Feb 25 14:44 servicehidingtest*
-rwxr-xr-x 1 kpark kpark 5371826 Feb 25 14:44 stagedeventmetadataretrievaltest*
-rwxr-xr-x 1 kpark kpark 5230334 Feb 25 14:44 summaryresultsettest*
-rwxr-xr-x 1 kpark kpark 5159299 Feb 25 14:44 summarytest*
-rwxr-xr-x 1 kpark kpark 4978003 Feb 25 14:44 systemclienteventrepositorytest*
-rwxr-xr-x 1 kpark kpark 5197127 Feb 25 14:44 systemclienteventtest*
-rwxr-xr-x 1 kpark kpark 4167294 Feb 25 14:44 systemclienteventwindowdtttest*
-rwxr-xr-x 1 kpark kpark 4143268 Feb 25 14:44 systemclienteventwindowiptest*
-rwxr-xr-x 1 kpark kpark  278360 Feb 25 14:44 systemclientmetadataconfigtest*
-rwxr-xr-x 1 kpark kpark 1609246 Feb 25 14:44 systemclientservicerepositorytest*

test/metadata/Makefile.am

summarytest_SOURCES = SummaryTest.cpp $(metadata_helpers)
summarytest_LDADD = $(ldadd_static)

note: see that executables are all lowercases.


<log-from-jenkins>
Uranium.Client.System.log

PASS: systemclientservicerepositorytest


<build-from-pc-target>
zb-make Uranium/Uranium.Client.System


<test-cases>
For enhanced metadata:

test/metadata/SystemClientEventRepositoryTest.cpp
454-        
455-        CPPUNIT_ASSERT_MESSAGE("There should be an event returned", e);
456-        
457-        CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].eventLocator, e->getIdentifier("locator"));
458:        CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].shortTitle["eng"], e->getTitle());
459-        CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].start, (uint32_t)to_time_t(e->getStart()));
460-        CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].publishedDuration, (uint32_t)e->getDuration());
461-    }
462-    


test/metadata/StagedEventMetadataRetrievalTest.cpp
222-        }
223-        CPPUNIT_ASSERT_EQUAL(from_time_t(availabilityStart), ecli->getAvailabilityStart());
224-        CPPUNIT_ASSERT_EQUAL(from_time_t(availabilityEnd), ecli->getAvailabilityEnd());
225-        CPPUNIT_ASSERT_EQUAL(false, ecli->isAvailable());
226:        CPPUNIT_ASSERT_EQUAL(edtt.shortTitle["eng"], ecli->getTitle());
227-        CPPUNIT_ASSERT_EQUAL( (int32_t)edtt.publishedDuration, ecli->getDuration());
228-        CPPUNIT_ASSERT_EQUAL(from_time_t(edtt.start), ecli->getStart());
229-        CPPUNIT_ASSERT_EQUAL(edtt.programmeCrid, ecli->getIdentifier("progcrid"));


test/metadata/SystemClientEventWindowTestBase.h
45-{
46-
47-    std::string eventTitleExtractor(boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e)
48-    {
49:        return e->getTitle();
50-    }


src/metadata/tools/textEPG.cpp
92-    if(e->isPresent())
93-    {
94-        s = "*";
95-    }
96:    return s + e->getTitle();


{xx}       
Uranium.Client.System/test/metadata/SystemClientEventRepositoryTest.cpp

<MOCK-EDIS>
struct ZINC_EXPORT Dispatcher : boost::noncopyable

class ZINC_EXPORT InlineDispatcher : public Dispatcher

typedef InlineDispatcher MultipleListenerEventDispatcher;

{mock-er}

<1> 
/*
 *	include/EventRepositoryAsync.h
 *
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 *
 *	Template base-async.template
 *	Using
 *	/DEVARCH/Iron/Iron.System.API/data/introspection-xml/interface-EventRepository.xml
 */
namespace Zinc {
namespace Metadata {

class EventRepositoryEventListener;

class ZINC_EXPORT EventRepositoryAsync : 
    public virtual NS_ZINC::DispatchingEventProducer<EventRepositoryEventListener>
{

/* =============================== Methods ================================= */
public:

	virtual NS_ZINC::Future< std::vector< Event > > getPresentFollowing(const std::string& serviceLocator_in) = 0;

	virtual NS_ZINC::Future< Event > getEvent(const std::string& eventLocator_in) = 0;

	virtual NS_ZINC::Future< std::vector< Event > > getScheduleEvents(
           const std::vector< std::string >& serviceLocators_in, 
           const uint32_t startTime_in, const uint32_t endTime_in) = 0;

	virtual NS_ZINC::Future< std::vector< Event > > findByProgrammeCrid(
           const std::string& programmeCrid_in) = 0;

	virtual NS_ZINC::Future< std::vector< Event > > findBySeriesCrid(const std::string& seriesCrid_in) = 0;

protected:
	virtual ~EventRepositoryAsync();
};


<2> 

MockEventRepositoryAsync.h from install root

/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

namespace Zinc {
namespace Metadata {

class ZINC_LOCAL MockEventRepositoryAsync: public EventRepositoryAsync
{
public:
/* ============================== Methods ================================== */

	typedef std::vector< Event > Mock_getPresentFollowingRet;
	MOCK_METHOD1(getPresentFollowing, NS_ZINC::Future< Mock_getPresentFollowingRet > (const std::string&));

	typedef Event Mock_getEventRet;
	MOCK_METHOD1(getEvent, NS_ZINC::Future< Mock_getEventRet > (const std::string&));

	typedef std::vector< Event > Mock_getScheduleEventsRet;
	MOCK_METHOD3(getScheduleEvents, 
           NS_ZINC::Future< Mock_getScheduleEventsRet > 
           (const std::vector< std::string >&, const uint32_t, const uint32_t));

	typedef std::vector< Event > Mock_findByProgrammeCridRet;
	MOCK_METHOD1(findByProgrammeCrid, NS_ZINC::Future< Mock_findByProgrammeCridRet > (const std::string&));

	typedef std::vector< Event > Mock_findBySeriesCridRet;
	MOCK_METHOD1(findBySeriesCrid, NS_ZINC::Future< Mock_findBySeriesCridRet > (const std::string&));

/* ============================== Signals ================================== */
	void emitPresentFollowingChange(const std::string& serviceLocator, 
           const std::vector< Event >& events)
	{
		produceEvent(
			boost::bind(&EventRepositoryEventListener::PresentFollowingChange,
			     _1,
			     serviceLocator,
			     events));
	}

	void emitScheduleChange(const std::string& serviceLocator, 
           const uint32_t start, const uint32_t end, const std::vector< Event >& events)
	{
		produceEvent(
			boost::bind(&EventRepositoryEventListener::ScheduleChange,
			     _1,
			     serviceLocator,
			     start,
			     end,
			     events));
	}

	virtual ~MockEventRepositoryAsync() { };
};

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT MockEventRepositoryAsyncWithCallbacks : 
    public virtual NS_IRON_SYSTEM::MockEventRepositoryAsync // note: cannot find a def or file
{
public:
    void publicProduceEvent(boost::shared_ptr<NS_ZINC::Event> event) const
    {
        URANIUM_FUNC_TRACE;
        produceEvent(event);
    }
};

note: this has overloads

void setUp()
{
    systemEventDispatcher = boost::make_shared<MultipleListenerEventDispatcher>();

    // note this is mock object
    mockEventRepo = boost::make_shared<NS_IRON_SYSTEM::MockEventRepositoryAsync>();

    mockEventRepo->setDispatcher(systemEventDispatcher);

    mockServiceRepo = boost::make_shared<NS_COBALT_SYSTEM::MockUnifiedServiceRepositoryAsync>();
    mockServiceRepo->setDispatcher(systemEventDispatcher);
}


void setUp(MetadataSource source, bool useDTTHistory = true, bool skipPFCallsSetup = false, 
        bool enableEventCache = false, bool useBrokerMock = false)
{

    setUpClientFactory();

    if(!skipPFCallsSetup)
    {
        EXPECT_CALL(*mockEventRepo, getPresentFollowing(_))
            .WillRepeatedly(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>()));
    }
    clientFactory->setIronSystemEventRepository(mockEventRepo);

    EXPECT_CALL(*mockServiceRepo, getAllServices(true))
        .WillRepeatedly(returnNewCompletedFuture(getDefaultUnifiedServices(source)));
    clientFactory->setSystemUnifiedServiceRepository(mockServiceRepo);

    if(useBrokerMock)
    {
        mockMB = boost::make_shared<NS_COBALT_SYSTEM::MockMetadataBrokerAsync>();
        clientFactory->setSystemMetadataBroker(mockMB);
    }

    config = clientFactory->createMetadataConfig();
    config->overrideSource(source);
    if(source == IP_AND_DTT)
    {
        config->overrideStagedDataRetrieval(true);
    }

    config->overrideCache(enableEventCache);
    config->overrideUseHistoricDTTData(useDTTHistory);

    //Effectively disable PECache sanitization so that it doesn't interfere with this test.
    config->overrideInitialPECacheSanitisationDelay(3600);

    eventRepo = boost::dynamic_pointer_cast<SystemClientEventRepository>(
            clientFactory->createEventRepository());
    serviceRepo = clientFactory->createServiceRepository();
}


vector<NS_IRON_SYSTEM::Event> getBBC1Events()
{
    NS_IRON_SYSTEM::Event e1;
    NS_IRON_SYSTEM::Event e2;

    e1.serviceLocator = "dvb://233a..1044";
    e1.eventLocator = "dvb://233a..1044;1";
    e1.shortTitle["eng"] = "Title of e1";
    e1.start = 0;
    e1.publishedDuration = 100;

    e2.serviceLocator = "dvb://233a..1044";
    e2.eventLocator = "dvb://233a..1044;2";
    e2.shortTitle["eng"] = "Title of e2";
    e2.start = 200;
    e2.publishedDuration = 100;

    vector<NS_IRON_SYSTEM::Event> result;
    result.reserve(2);
    result.push_back(e1);
    result.push_back(e2);

    return result;
}


void testGetPresentEvent()
{
    //setup the mocks so that there is a present event on all services
    EXPECT_CALL(*mockEventRepo, getPresentFollowing(getDefaultUnifiedServices()[0].serviceLocator)).
            WillOnce(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>(1, getBBC1Events()[0])));

    EXPECT_CALL(*mockEventRepo, getPresentFollowing(getDefaultUnifiedServices()[1].serviceLocator)).
            WillOnce(returnNewCompletedFuture(vector<NS_IRON_SYSTEM::Event>(1, getCafeTVEvents()[0])));

    // note: set to 'unified'
    setUp(DTT_ONLY, true, true);

    // note: 'metadate'
    boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::Event> e = eventRepo->getPresentEvent(0);
    
    CPPUNIT_ASSERT_MESSAGE("There should be an event returned", e);
    
    // note: all are EAPIs
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].eventLocator, e->getIdentifier("locator"));
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].shortTitle["eng"], e->getTitle());
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].start, (uint32_t)to_time_t(e->getStart()));
    CPPUNIT_ASSERT_EQUAL(getBBC1Events()[0].publishedDuration, (uint32_t)e->getDuration());
}


note: to run a single test and should match how it was built since it shall be run under virtual?

./systemclienteventrepositorytest --cases SystemClientEventRepositoryTest::testGetSynopsis

itoryTest::testGetPresentEvent
Metadata source is DTT_ONLY
Overriding metadata source to DTT_ONLY

.2015-03-16 14:18:31,062 INFO   140235723970336 iron
/data/builds/_virtual_/pc/DEVARCH/Iron/IronReminders.System.Production/src/ProductionSystemFactory.cpp:43
Using configuration file:
/data/builds/_virtual_/pc/zinc-install-root/debug/debian-7-x86_64/tests/uranium-client-system/share/copper-system-factory.plugin-config

2015-03-16 14:18:31,063 INFO   140235723970336 iron
/data/builds/_virtual_/pc/DEVARCH/Iron/IronReminders.System.Production/src/ProductionSystemFactory.cpp:58
Using configuration file:
/data/builds/_virtual_/pc/zinc-install-root/debug/debian-7-x86_64/tests/uranium-client-system/share/metadata/iron-system-factory.plugin-config

2015-03-16 14:18:31,092 INFO   140235723970336 cadmium
/data/builds/_virtual_/pc/DEVARCH/Cadmium/Cadmium.System.Fake/src/FakeLinearAcquisition.cpp:40 Using
Cadmium DB file "/tmp/testmutabledatadir.6aPGJO/cadmium-system-fake/dvrdata.db"

2015-03-16 14:18:31,092 INFO   140235723970336 cadmium
/data/builds/_virtual_/pc/DEVARCH/Cadmium/Cadmium.System.Fake/src/FakeLinearAcquisition.cpp:44 Using
Nickel DB file "/tmp/testmutabledatadir.6aPGJO/nickel-system-fake/lmldata.db"

Caching media records...Caching services...done.
Caching PF...done.
done.


OK (1)
kpark@wll1p04345:/data/builds/_virtual_/pc/zinc-build-root/debug-debian-7-x86_64/Uranium/Uranium.Client.System/test/metadata$ 

/**
 * File:   FutureMockActions.h
 *
 * Created on 11 April 2013
 *
 * Copyright (c) 2013, YouView TV Ltd.
 */
#ifndef ZINC_COMMON_FUTUREMOCKACTIONS_H
#define	ZINC_COMMON_FUTUREMOCKACTIONS_H

#include "../async/Promise.h"
#include "../async/async-helpers.h"

#include <gmock/gmock.h>

NS_ZINC_OPEN

/**
 * These helper actions are for use with Google Mock objects.
 *
 * When returning a future from a mock object expectation, care is needed to
 * make sure a new future is created each time the expectation is matched.
 * This shows up as a problem when setCallback is called on the returned future.
 *
 * The problem is that when using something like:
 *
 * EXPECT_CALL( ... ).WillRepeatedly(Return(FunctionThatReturnsAFuture()));
 *
 * Google Mock will copy the future returned from `FunctionThatReturnsAFuture()`
 * and always return the same future. This doesn't work for instance if you ever
 * call setCallback() on that future, which will throw a
 * DuplicateFutureCallback error on subsequent calls.
 *
 * Even this doesn't work, surprisingly:
 *
 * EXPECT_CALL( ... ).WillOnce(Return(FunctionThatReturnsAFuture()))
 *                   .WillOnce(Return(FunctionThatReturnsAFuture()));
 *
 * Again, the same promise is returned. I'm not quite sure how that happens
 * though.
 *
 * This can be used like this:
 *
 * EXPECT_CALL( ... ).WillOnce(returnNewCompletedFuture(someValue))
 *
 */

ACTION(returnNewCompletedFuture) {
    return completedFuture();
}

ACTION_P(returnNewCompletedFuture, value) {
    return completedFuture<typename return_type::value_type>(value);
}

ACTION_P(returnNewExceptionalFuture, exception) {
    return exceptionalFuture<typename return_type::value_type>(exception);
}

NS_ZINC_CLOSE

#endif // ZINC_COMMON_FUTUREMOCKACTIONS_H


={============================================================================
*kt_dev_uv_stack_114* stack: build pc target

Unlike cross platform builds, build runs tests and pc target build fails if any test fails.

1. Fail to buile due to failure on tests/cobalt-system-api/test/dateparsingtest

Test name: N6cobalt6system15DateParsingTestE::test_calling_isDaylightSavingTime_with_DST_times

To solve this, need to do:

export TZ="Europe/London"


2. Various failure on some python tests such as Rubidium/Rubidium.System.Production

The reason is that python script has "#!/bin/env python" which expect /bin/env but there is not. So

$ sudo ln -s /usr/bin/env /bin/env

Make a build success.


={============================================================================
*kt_dev_uv_stack_115* stack: text epg

./Uranium.Client.System/src/metadata/tools/textEPG.cpp

https://wiki.youview.co.uk/display/YVFDT/2014/04/09/TextEPG+howto?src=search

TextEPG is a a little text based app that lets you view the schedule data that the UI consumes via
the ctv.enhancedmetadata.EventWindow interface. It can be very useful for debugging. Just type
textEPG on in an ssh/telnet session on the box textEPG

you should then see something like this: text based epg using ncurses

Present events are marked with an asterisk.

You can navigate the window using the WASD keys.  

You can view just DTT, just IP, or merged DTT/IP data (this last is what the UI uses, assuming you
        have accepted T&Cs and have a network connection)

[root@HUMAX /]# textEPG --help
Invalid data source
Usage: textEPG [ip | dtt |stagedip] [<number of services> <number of seconds>]
The numbers specify the dimensions of the epg window.

Other options :

+ / - keys cycle through a subset of the available 'fields' in each event, e.g. title, event
locator, service record identifier.  It a field is missing, then it will need adding in the textEPG
source, see Devarch, or find a book on ncurses.

Running on a read only box

If you get terminal related  error running the textEPG on a read only box, try this first
export TERMINFO=/opt/zinc/oss/share/terminfo

The textEPG was created several years ago (by Jarek in Devarch), as a diagnostic tools to help in
testing/development of the EventWindow API in the CAL, and has not had much love since then. It was
designed to show the schedule data from the CAL, back when that was the main cache of event data
used by the UI. Since the implementation of IP channels, a lot of the event information that was
previously cached in the CAL has moved down to the Unified Event Repository. The textEPG still seems
to work, as it just fetches an EventWindow and renders it in text, but YMMV.

/data/builds/DEVARCH-9135/pc/zinc-install-root/debug/debian-7-x86_64/devel/bin/textEPG

box: /opt/zinc-trunk/devel/bin/textEPG
box: /opt/zinc/devel/bin/textEPG


={============================================================================
*kt_dev_uv_stack_116* stack: future

<future>

#ifndef ZINC_FUTURE_H_

template <typename T> class Promise;

namespace detail {
template <typename T> class FutureContext;
}

namespace internal {
class PolymorphicFuture;
}

class Dispatcher;

class FutureBase 
{
    friend class internal::PolymorphicFuture;

    public:

    /**
     * Cancel the Future.
     *
     * This merely prevents the Future ever being fulfilled. If a callback
     * has been set, and not called already, it will not be called.
     *
     * Cancellation may, or may not, cause the underlying asynchronous operation to be
     * canceled. The client should not assume this to be the case.
     *
     * Cancellation may be modified with the flags argument.
     *  * future.cancel(clear_callback) just prevents the
     *    callback set with setCallback from being invoked.
     *  * future.cancel(deep) calls the onCancel handler that may have been
     *    provided promise-side
     *  * future.cancel(immediately) has behaviour equivalent to the Promise
     *    being immediately completed with a CancelledFuture exception.  If the
     *    promise has already been completed calling get() will still cause a
     *    CancelledFuture exception to be thrown.
     *  * future.cancel(0) does nothing.
     */
    void cancel(unsigned flags = cancel_flag::clear_callback |
            cancel_flag::deep |
            cancel_flag::immediately);


    /**
     * Synchronously wait for the value to become available.
     *
     * This will block the calling thread until either the value is available,
     * or an exception occurs.
     *
     * When the caller returns from this call, a subsequent call to get() will not
     * block.
     */
    void wait();

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as a relative time duration
     *
     * eg
     *		Future<int> f = fn_returning_a_future();
     *		f.wait_for(boost::posix_time::milliseconds(500));
     *
     * @param rel_time specifies the time duration to wait for completion
     * @return false if the given time period elapses without completion or cancellation
     * @see wait()
     */
    template<typename duration_type>
        bool wait_for(const duration_type &rel_time);

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as an absolute time point
     *
     * Use wait_for() in preference
     *
     * @param abs_time specifies the time point to stop waiting
     * @return false if we reach the given time point without completion or cancellation
     *
     * @see wait()
     * @see wait_for()
     */
    template<typename time_point_type>
        bool wait_until(const time_point_type &abs_time);


    /**
     * Ask if the Future has been completed with a value provided by its Promise
     *
     * A positive response does not guarantee that the callback has yet been executed
     *
     * @return true if this Future has been completed
     */
    bool isComplete();

    /**
     * Has this Future been default constructed?  If so, then it is not useful
     *
     * @see Future<T>::swap
     * @see Promise<T>::getFuture
     *
     * @return false if this Future is valid
     */
    bool isEmpty();


    protected:

    explicit FutureBase(boost::intrusive_ptr<detail::FutureContextCommonImpl> context) ZINC_EXPORT;

    FutureBase(const FutureBase& other) ZINC_EXPORT;

    FutureBase() {}

    ~FutureBase() ZINC_EXPORT;

    void baseSwap(FutureBase& other);

    boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
};


/**
 * A Future is a token for some value that will be delivered asynchronously.
 *
 * The holder of the Future token may either wait for the value synchronously,
 * (blocking the executing thread), or set a callback method that will be invoked
 * either when the value becomes available, or will not become available due to
 * some exception.
 *
 * The Future holder also has the option to cancel the Future, which will prevent
 * the value from being delivered, assuming this hasn't happened already.
 */
template <typename T>
class Future : public FutureBase
{
    public:
        typedef T value_type;

        Future(const Future & other);

        Future & operator=(const Future & other);

        ~Future();

        /**
         * Provide a default constructor so we can put Futures in
         * STL containers
         *
         * A Future without a Promise is not much use to you,
         * so use Promise.getFuture() instead, or use swap(Future<T> & other)
         * to swap in a valid future
         *
         * @see Promise<T>::getFuture()
         * @see Future<T>::swap(Future<T> & other)
         */
        Future() {}

        /**
         * Set a callback method to be invoked when either the value becomes
         * available, or an exception occurs.
         *
         * The callback will be executed on the dispatcher that was provided to
         * the Promise constructor.
         *
         * @param fn A function that must accept a FutureValue<T> as it's single
         *           argument.
         *
         * @throws DuplicateFutureCallback if a callback has already been set on
         * this Future.
         * @throws CallbackSetWithoutDispatcherException if the corresponding
         *         wasn't initialized with a dispatcher.  Use the two argument
         *         setCallback instead
         */
        template <typename Handler>
            void setCallback(const Handler& fn) {
                // fn(x) must be valid where x is a FutureValue<T>
                ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
                static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, 0);
            }

        /**
         * Set a callback method to be invoked when either the value becomes
         * available, or an exception occurs.
         *
         * The callback will be executed on the provided dispatcher, rather than the
         * dispatcher used by the Promise.
         *
         * Explicitly providing the dispatcher gives the caller more control over
         * which thread will execute their callback.
         *
         * @param dispatcher_ The dispatcher on which the callback should be executed.
         *
         * @param fn A function that must accept a FutureValue<T> as it's single
         *           argument.
         *
         * @throws DuplicateFutureCallback if a callback has already been set on
         * this Future.
         */
        template <typename Handler>
            void setCallback(Dispatcher& dispatcher_, const Handler& fn) {
                // fn(x) must be valid where x is a FutureValue<T>
                ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
                static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, &dispatcher_);
            }

        /**
         * then() allows specifying a Functor to be called once the Future is
         * completed.  It is much like Future.setCallback() but for a Future<T> if
         * the functor has the form:
         *
         *     R Functor(FutureValue<T>)
         *
         * then then() will return a new Future of type Future<R> which will be
         * completed when the original Future completes and the functor has
         * operated on the original value.  The value/exception contained in the
         * new future will be that returned/thrown from the functor.  This makes
         * then() very convenient for transforming the value (and potentially the
         * type) contained within a `Future`.
         *
         * If a dispatcher is provided the functor will be executed on that
         * dispatcher.  Otherwise it will be run inline at the point and in the
         * context in which the `Promise` is completed or the setCallback is set
         * (whichever comes later).  As the environment in which the functor will
         * be run is unknown and even non-deterministic it is only safe to do the
         * simplest pure-functional transformations in these functors, e.g.
         * translating between exceptions/enum types, etc.  Anything dependent on
         * some state may require locking a mutex of similar and to make it
         * deterministic, safe and to avoid unexpected failures as changes are
         * made to other parts of the code the callbacks should be run on a user
         * specified `Dispatcher`.
         *
         *`Future.then()` is a proposed addition to the C++14 standard[1].
         *
         * [1]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3558.pdf
         *
         * Usage Example:
         *
         * @code
         * string boolToYesNo(FutureValue<bool> b) {
         *     try {
         *         return (b.get()?"yes":"no");
         *     } catch (const std::exception& e) {
         *         // translating exception thrown from original future.
         *         throw MyNewException(e.what());
         *     }
         * }
         *
         * Future<bool> answer = isCool();
         *
         * Future<string> answerAsString = answer.then(&boolToYesNo);
         *
         * cout << "Cool? " << answerAsString.get() << endl;
         * @endcode
         */
        template<typename Functor>
            Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
                    Dispatcher& dispatcher, Functor transformRtoT);
        template<typename Functor>
            Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
                    Functor transformRtoT);

        /**
         * Synchronously wait for and retrieve the value.
         *
         * This method may throw an exception of any type, in the event that the
         * value could not be retrieved due to an exception in the asynchronous
         * operation producing the value.
         *
         * Equivalent to f.getFutureValue().get();
         *
         * @return the value.
         */
        typename const_return<T>::type get();

        /**
         * Synchronously wait for and retrieve the value.
         *
         * Unlike get() this method does not throw if the promise has been completed
         * with an exception.  This can be used to deal with errors without a try
         * catch block.
         *
         * @return the value.
         */
        FutureValue<T> getFutureValue();

        /**
         * Swap this Future with the one provided
         */
        void swap(Future<T> & other);

    private:
        friend class Promise<T>; // only Promises can create a Future
        explicit Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ );

};

#endif


<future-impl>
#ifndef ZINC_FUTURE_INL

NS_ZINC_OPEN

inline void FutureBase::wait()
{
	context->wait();
}

template<typename duration_type>
inline bool FutureBase::wait_for(const duration_type &rel_time)
{
	return context->wait_for(rel_time);
}

template<typename time_point_type>
inline bool FutureBase::wait_until(const time_point_type &abs_time)
{
	return context->wait_until(abs_time);
}

inline bool FutureBase::isComplete()
{
	return context->completed;
}

inline bool FutureBase::isEmpty()
{
	return (context.get() == NULL);
}

inline void FutureBase::cancel(unsigned flags)
{
	context->cancel(flags);
}

inline void FutureBase::baseSwap(FutureBase& other)
{
	using std::swap;
	swap(context, other.context);
}


/**
 * Generic Future definitions
 */

template<typename T>
inline Future<T>::Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ ) : FutureBase(boost::static_pointer_cast<detail::FutureContextCommonImpl>(context_)) {}

template<typename T>
inline Future<T>::Future(const Future<T>& other) : FutureBase(other) {}

template<typename T>
inline Future<T>::~Future() {}

template<typename T>
inline Future<T>& Future<T>::operator=(const Future<T>& other)
{
	Future<T>(other).swap(*this);
	return *this;
}

template<typename T>
inline FutureValue<T> Future<T>::getFutureValue()
{
    wait();
    return FutureValue<T>(boost::static_pointer_cast<detail::FutureContext<T> >(context));
}

template<typename T>
inline typename const_return<T>::type Future<T>::get()
{
	return getFutureValue().get();
}

template<typename T>
inline void Future<T>::swap(Future<T> & other)
{
	 baseSwap(other);
}

/**
 * Future<void> definitions
 */
template<>
inline void Future<void>::get()
{
	wait();
	// get() may throw
	FutureValue<void>(boost::static_pointer_cast<detail::FutureContext<void> >(context)).get();
}

namespace detail {

template<typename T, typename R, typename Functor>
struct DoTransformAndComplete {
    static inline void apply(Promise<R>& promise, Functor& transform, const FutureValue<T>& fv) {
        promise.complete(transform(fv));
    }
};

template<typename T, typename Functor>
struct DoTransformAndComplete<T, void, Functor> {
    static inline void apply(Promise<void>& promise, Functor& transform, const FutureValue<T>& fv) {
        transform(fv);
        promise.complete();
    }
};

template<typename T, typename Functor>
struct TransformAndComplete {

    typedef typename boost::result_of<Functor(FutureValue<T>)>::type R;

    TransformAndComplete(const Functor& f)
     : transform(f) {}

    void operator()(const FutureValue<T>& fv) {
        try {
            DoTransformAndComplete<T, R, Functor>::apply(promise, transform, fv);
        } catch (const std::exception& e) {
            promise.exception(e);
        } catch (...) {
            promise.exception(std::runtime_error("Unknown exception."));
        }
    }

    Promise<R> promise;
    Functor transform;
};

template<typename FutureLike, typename Functor>
Future<typename boost::result_of<Functor(FutureValue<typename FutureLike::value_type>)>::type> futureThen(
        FutureLike& future, Dispatcher& dispatcher, Functor transformTtoR) {

    detail::TransformAndComplete<typename FutureLike::value_type, Functor>
        transformAndComplete(transformTtoR);
    future.setCallback(dispatcher, transformAndComplete);
    return transformAndComplete.promise.getFuture();
}
} // namespace detail

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Dispatcher& dispatcher, Functor transformTtoR) {

    return detail::futureThen(*this, dispatcher, transformTtoR);
}

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Functor transformTtoR) {

    return then(InlineDispatcher::sharedInstance(), transformTtoR);
}

#endif


<promise>
#ifndef ZINC_PROMISE_H_

namespace internal{
class PolymorphicPromise;
}

/**
 * Base class for Promises which contain different types.  This can be useful
 * when hoisting to reduce object code size.
 */
class PromiseBase : boost::noncopyable 
{
    friend class internal::PolymorphicPromise;

    public:

    /**
     * Complete this Promise with a zinc::ErrorCode
     *
     * @param error the error code value
     *
     * @throws PromiseAlreadyCompleted if this Promise has already been completed
     */
    void error(const NS_ZINC::ErrorCode& error);

    /**
     * Complete this Promise with an exception
     *
     * @param e the exception
     *
     * @throws PromiseAlreadyCompleted if this Promise has already been completed
     */
    void exception(const std::exception& e);

    /**
     * Ask if this async operation has been completed with a value
     *
     * @return true if the async operation associated with this Promise has been completed
     */
    bool isComplete() const;

    protected:

    // Destructor and Constructor are protected to prevent deletion through the
    // base class.  If you want to store a Promise polymorphically use
    // PolymorphicPromise.
    ~PromiseBase() ZINC_EXPORT;
    explicit PromiseBase(detail::FutureContextCommonImpl*) ZINC_EXPORT;
    PromiseBase(const PromiseBase& other) ZINC_EXPORT;
    boost::intrusive_ptr<detail::FutureContextCommonImpl> context;
    void baseSwap(PromiseBase& other);
};


/**
 * A Promise provides the API to set the result of an asynchronous operation,
 * signal the caller, and trigger dispatch of any associated completion handlers
 */
template<typename T>
class Promise : public PromiseBase
{
    public:
        /**
         * Construct a Promise for an asynchronous operation.
         *
         * If a dispatcher is passed the deprecated single-argument
         * Future::setCallback which does not take a Dispatcher may be used on the
         * Future returned from getFuture().  In this case the callback will be
         * executed on the Dispatcher passed here.  This is a deprecated mode of
         * use.
         *
         * Using the default Promise constructor and the two argument Future
         * setCallback is strongly recommended in new code.  The single argument
         * Promise constructor is likely to be deprecated in the future.
         *
         * If a cancellation callback is provided it will be executed on the
         * dispatcher provided here.
         */
        Promise();
        explicit Promise(Dispatcher& dispatcher_);
        explicit Promise(Dispatcher& dispatcher_,
                boost::function<void ()> cancelationCallback);

        Promise(const Promise<T> & other);

        Promise & operator=(const Promise<T> & other);

        /**
         * Swap this promise with the one provided
         */
        void swap(Promise<T> & other);

        /**
         * Create a Future for this Promise.
         *
         * The created Future can be used to access the result of this Promise.
         *
         * @return A Future used to access the result of this Promise
         */
        Future<T> getFuture();

        /**
         * Complete this Promise with a value and deliver the result to
         * all associated Futures
         *
         * @param value the result to be delivered
         *
         * @throws PromiseAlreadyCompleted if this Promise has already been completed
         */
        void complete(typename const_param<T>::type);
    private:
        detail::FutureContext<T>& getContext();
        // WARNING: DO NOT ADD MEMBERS HERE:
        //     PolymorphicPromise depends on Promise<T> having no additional members
        //     vs. PromiseBase
};


/**
 * A Promise<void> provides the API to signal the caller of an asynchronous operation,
 * and trigger dispatch of any associated completion handlers
 *
 * FIXME: It's a shame that we have to specialize the whole class for void, when complete()
 * is really the only method that is different. But, to use sub-classing to do this
 * would confuse the interface.
 */
template<>
class Promise<void> : public PromiseBase
{
    public:

        /**
         * Construct a Promise for an asynchronous operation.
         *
         * If a dispatcher is passed the deprecated single-argument
         * Future::setCallback which does not take a Dispatcher may be used on the
         * Future returned from getFuture().  In this case the callback will be
         * executed on the Dispatcher passed here.  This is a deprecated mode of
         * use.
         *
         * Using the default Promise constructor and the two argument Future
         * setCallback is strongly recommended in new code.  The single argument
         * Promise constructor is likely to be deprecated in the future.
         *
         * If a cancellation callback is provided it will be executed on the
         * dispatcher provided here.
         */
        Promise();
        explicit Promise(Dispatcher& dispatcher_);
        explicit Promise(Dispatcher& dispatcher_,
                boost::function<void ()> cancelationCallback);

        Promise(const Promise<void> &other);

        Promise & operator=(const Promise<void> & other);

        /**
         * Swap this promise with the one provided
         */
        void swap(Promise<void> & other);

        /**
         * Create a Future for this Promise.
         *
         * The created Future can be used to synchronise on completion of this Promise,
         * and retrieve any error conditions that may occur.
         *
         * @return A Future used to access the result of this Promise
         */
        Future<void> getFuture();

        /**
         * Complete this Promise and notify all associated Futures
         *
         * @throws PromiseAlreadyCompleted if this Promise has already been completed
         */
        void complete();

    private:
        detail::FutureContext<void>& getContext();
        // WARNING: DO NOT ADD MEMBERS HERE:
        //     PolymorphicPromise depends on Promise<T> having no additional members
        //     vs. PromiseBase
};

#include "detail/Promise_Impl.h"

#endif


<promise-impl>
#ifndef ZINC_PROMISE_IMPL_H_

#include "../Future.h"
#include "../async-exceptions.h"


inline void PromiseBase::baseSwap(PromiseBase& other)
{
	using std::swap;
	swap(context, other.context);
}

inline void PromiseBase::error(const NS_ZINC::ErrorCode& error)
{
	context->completeError(error);
}

inline void PromiseBase::exception(const std::exception& e)
{
	error(zinc::copyException(e));
}

inline bool PromiseBase::isComplete() const
{
	return context->completed;
}

template<typename T>
inline Promise<T>::Promise() :
	PromiseBase( new detail::FutureContext<T>(NULL) )
{
}

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_) :
	PromiseBase( new detail::FutureContext<T>(&dispatcher_) )
{
}

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_, boost::function<void ()> cancellationCallback_) :
	PromiseBase( new detail::FutureContext<T>(&dispatcher_, cancellationCallback_ ) )
{
}

template<typename T>
Promise<T>::Promise(const Promise<T> &other)
 : PromiseBase(other.context.get())
{
}

template<typename T>
Promise<T>& Promise<T>::operator=(const Promise<T> & other)
{
	Promise<T>(other).swap(*this);
	return *this;
}

template<typename T>
inline Future<T> Promise<T>::getFuture()
{
	return Future<T>(&getContext());
}

template<typename T>
inline void Promise<T>::complete(typename const_param<T>::type value)
{
	getContext().set(value);
}

template<typename T>
inline void Promise<T>::swap(Promise<T> & other)
{
    baseSwap(other);
}

template<typename T>
inline detail::FutureContext<T>& Promise<T>::getContext()
{
	return *static_cast<detail::FutureContext<T>* >(context.get());
}

// ** void specialization **

// This is the only method that actually needs to be different.
inline void Promise<void>::complete()
{
	getContext().set();
}

// But we have to repeat all these, because whole class is specialized.

inline Promise<void>::Promise() :
	PromiseBase( new detail::FutureContext<void>(NULL) )
{
}

inline Promise<void>::Promise(FutureDispatcher& dispatcher_) :
	PromiseBase( new detail::FutureContext<void>(&dispatcher_) )
{
}

inline Promise<void>::Promise(FutureDispatcher & dispatcher_, boost::function<void ()> cancellationCallback_) :
	PromiseBase( new detail::FutureContext<void>(&dispatcher_, cancellationCallback_) )
{
}

inline Promise<void> & Promise<void>::operator=(const Promise<void> & other)
{
	Promise<void>(other).swap(*this);
	return *this;
}

inline Promise<void>::Promise(const Promise<void> & other)
 : PromiseBase(other.context.get())
{
}

inline Future<void> Promise<void>::getFuture()
{
	return Future<void>(&getContext());
}

inline void Promise<void>::swap(Promise<void> & other)
{
    baseSwap(other);
}

inline detail::FutureContext<void>& Promise<void>::getContext()
{
	return *static_cast<detail::FutureContext<void>* >(context.get());
}

#endif 


<future-barrier>

class Dispatcher;
typedef Dispatcher FutureDispatcher;

namespace detail {
    template <typename Functor> class BarrierWrapper;
    class FutureBarrierImpl;
}

/**
 * FutureBarrier is designed to aid synchronisation when making multiple
 * asynchronous calls simultaneously.  FutureBarrier will call a given
 * callback asynchronously once all the futures added to it have
 * completed AND the FutureBarrier itself has gone out of scope.
 *
 * (NOTE: This means you must not keep a FutureBarrier alive after the method
 * creating it returns; for example you must not pass around a shared_ptr to a
 * FutureBarrier, and you must not make a FutureBarrier be a member of your
 * class.)
 *
 * FutureBarrier is "FutureLike" in that it defines the functions setCallback
 * and cancel() and thus can be used as an argument to
 * Continuation::setCallback();
 */
class FutureBarrier : boost::noncopyable {
public:
    typedef void value_type;

    /**
     * Constructor
     */
    explicit FutureBarrier(FutureDispatcher& dispatcher);
    ~FutureBarrier();

    /**
     * Add a Future to the barrier to delay the FutureBarrier from completing
     * until the Future has completed.
     *
     * @param f The future to add. This can be any "FutureLike" object, such
     *          as a Future, a Continuation, or even another FutureBarrier.
     *
     * @param c Callback to be called when the future "f" completes
     *          *successfully*. It must have the signature:
     *              void SuccessCallback(T);
     *          where T is the value_type of the future "f".
     *          Note that the parameter is T, not FutureValue<T>.
     *          If the future "f" completes with an error, this callback will
     *          not be called; and the "final" callback (set with setCallback)
     *          will (eventually, once all other futures have completed) be
     *          called with an error.
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     *
     * Note: The FutureDispatcher you use should provide the guarantee that all
     * callbacks will be dispatched on the same thread (which may be a
     * different thread than the thread where you create the FutureBarrier and
     * call addWithSuccessCallback). This way, the various callbacks you set
     * with addWithSuccessCallback don't need to worry about synchronisation
     * issues.
     */
    template <class FutureLike, typename SuccessCallback>
    void addWithSuccessCallback(FutureLike f, SuccessCallback /* void (T) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * This is distinct from addWithSuccessCallback in that this is called with a
     * FutureValue<T> rather than just T, thus allowing finer grained control
     * of error conditions.
     *
     * @param f The future to add.
     *
     * @param c The function to call once the future "f" is complete.
     *          It must have the signature:
     *              void Callback(FutureValue<T>);
     *          where T is the value_type of the future "f".
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     */
    template <class FutureLike, typename Callback>
    void addWithCallback(FutureLike f, Callback /* void (FutureValue<T>) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * The value returned by the completed future is ignored, as long as it is
     * not an error. An error will cause this FutureBarrier to complete with
     * the error, just like addWithSuccessCallback.
     *
     * @param f The future to add.
     */
    template <class FutureLike>
    void add(FutureLike f);

    /**
     * Cancel the FutureBarrier.  The behaviour of this function depends on the
     * template parameter CancellationPolicy.
     */
    void cancel(unsigned flags);

    /**
     * Set the "final" callback method to be invoked after all of the barrier's
     * Futures have completed, successfully or otherwise.
     *
     * @param c The function to call once all the futures have completed.
     *          This function should have the signature:
     *              void (FutureValue<void>);
     *          In this way FutureBarrier is interface compatible with
     *          Future<void>.
     */
    template <typename Callback>
    void setCallback(Callback c) const;

    template <typename Callback>
    void setCallback(FutureDispatcher& dispatcher, Callback c);
private:
    template <typename Functor, typename ValueType> friend class detail::BarrierWrapper;
    detail::FutureBarrierImpl* impl;
};



={============================================================================
*kt_dev_uv_stack_117* stack: metadata and dbus

# from lsdbus

1287  :1.57                    /opt/zinc/bin/ironmetadatad.oem                 
1287  Zinc.Metadata            /opt/zinc/bin/ironmetadatad.oem                 

# 'iron'
# /Iron/Iron.System.API/data/introspection-xml/service.xml
# note: see bus name
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0" name="/" yv:busname="Zinc.Metadata">
    <node name="Zinc/Metadata/EventRepository">
        <interface name="Zinc.Metadata.EventRepository"/>
    </node>
    <node name="Zinc/Metadata/RelatedContentRepository">
        <interface name="Zinc.Metadata.RelatedContentRepository"/>
    </node>
    <node name="Zinc/Metadata/ServiceRepository">
        <interface name="Zinc.Metadata.ServiceRepository"/>
    </node>
</node>


# 'cobalt'
<node xmlns:yv="http://refdata.youview.com/schemas/dbus-extensions-v1.0" name="/" yv:busname="Zinc.Broker">
    <node name="Zinc/Broker/MetadataBroker">
        <interface name="Zinc.Broker.MetadataBroker"/>
    </node>
    <node name="Zinc/Broker/HiddenServicesStore">
        <interface name="Zinc.Broker.HiddenServicesStore"/>
    </node>
    <node name="Zinc/Broker/UnifiedServiceRepository">
        <interface name="Zinc.Broker.UnifiedServiceRepository"/>
    </node>
    <node name="Zinc/Broker/ProvisioningService">
        <interface name="Zinc.Broker.ProvisioningService"/>
    </node>
    <node name="Zinc/Broker/UnifiedEventRepository">
        <interface name="Zinc.Broker.UnifiedEventRepository"/>
    </node>
    <node name="Zinc/Broker/LinearAcquisitionServiceResolver">
        <interface name="Zinc.Broker.LinearAcquisitionServiceResolver"/>
    </node>
    <node name="Zinc/Broker/DeviceConfig">
        <interface name="Zinc.Broker.DeviceConfig"/>
    </node>
</node>


# note: auto generated to
# zinc-build-root/release-humax-dtr_t1000/Iron/Iron.System.API/include/SystemFactory.h

namespace Zinc {
namespace Metadata {

struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Metadata::EventRepository> createEventRepository() = 0;
    virtual boost::shared_ptr<Zinc::Metadata::RelatedContentRepository> createRelatedContentRepository() = 0;
    virtual boost::shared_ptr<Zinc::Metadata::ServiceRepository> createServiceRepository() = 0;
};
} //namespace
} //namespace


namespace Zinc {
namespace Broker {

struct ZINC_EXPORT SystemFactory : virtual public NS_ZINC::Plugin {
    virtual ~SystemFactory();

    virtual boost::shared_ptr<Zinc::Broker::MetadataBroker> createMetadataBroker() = 0;
    virtual boost::shared_ptr<Zinc::Broker::HiddenServicesStore> createHiddenServicesStore() = 0;
    virtual boost::shared_ptr<Zinc::Broker::UnifiedServiceRepository> createUnifiedServiceRepository() = 0;
    virtual boost::shared_ptr<Zinc::Broker::ProvisioningService> createProvisioningService() = 0;
    virtual boost::shared_ptr<Zinc::Broker::UnifiedEventRepository> createUnifiedEventRepository() = 0;
    virtual boost::shared_ptr<Zinc::Broker::LinearAcquisitionServiceResolver> 
        createLinearAcquisitionServiceResolver() = 0;
    virtual boost::shared_ptr<Zinc::Broker::DeviceConfig> createDeviceConfig() = 0;

};
} //namespace
} //namespace


# from lsdbus

1055  :1.20                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  :1.45                    /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  Zinc.Broker              /opt/zinc-trunk/bin/cobaltmetadatabrokerd        
1055  Zinc.MetadataProxy       /opt/zinc-trunk/bin/cobaltmetadatabrokerd        

1237  :1.69                    /opt/stagecraft-2.0/bin/stagecraft --astrace --bgalpha 0 --outputrect
0,0,1280,720 --extensionsdir /opt/zinc-trunk/lib/stagecraft2-extensions --profile extendedTV
--modulemap IGraphicsDriver:/opt/stagecraft-2.0/bin/libIGraphicsDriver2.so /app        

# from dbus full log

method call sender=:1.20 -> dest=Zinc.Metadata serial=7034 path=/Zinc/Metadata/EventRepository; interface=Zinc.Metadata.EventRepository; member=getScheduleEvents

method return sender=:1.20 -> dest=:1.69 reply_serial=4682

   array [
      struct {
         string "12651407"
         int64 1426653570
         int64 1427284880
         int32 0
         array [
         ]
         array [
            dict entry(
               string "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"
               array [
                  string "dvb://233a..5a90;3cf"
               ]
            )
         ]
         array [
         ]
         array [
            dict entry(
               string "entityType"
               array [
                  string "scheduleevent"
               ]
            )
            dict entry(
               string "eventId"
               array [
                  string "12651407"
               ]
            )
            dict entry(
               string "eventTitle"
               array [
                  string "TruTV is on ch. 68..."
               ]
            )
            dict entry(
               string "isAdult"
               array [
                  string "0"
               ]
            )
            dict entry(
               string "mediumSynopsis"
               array [
                  string "...truTV +1 returns at 5am"
               ]
            )
            dict entry(
               string "owningServiceId"
               array [
                  string "10193572"
               ]
            )
            dict entry(
               string "start"
               array [
                  string "2015-03-25T09:00:00Z"
               ]
            )
         ]
         array [
            dict entry(
               string "classifiers"
               array [
                  struct {
                     array [
                        dict entry(
                           string "categoryScheme"
                           string "urn:dtg:metadata:cs:DTGGenreCS:2010-11"
                        )
                     ]
                     string "0"
                  }
               ]
            )
            dict entry(
               string "mediaContent"
               array [
                  struct {
                     array [
                        dict entry(
                           string "aspectRatio"
                           string "4:3"
                        )
                        dict entry(
                           string "audioLanguage"
                           string "eng"
                        )
                        dict entry(
                           string "audioMixType"
                           string "1"
                        )
                        dict entry(
                           string "contentDuration"
                           string "28800"
                        )
                        dict entry(
                           string "contentIsHighDefinition"
                           string "0"
                        )
                        dict entry(
                           string "format"
                           string "sd"
                        )
                        dict entry(
                           string "mediaType"
                           string "video"
                        )
                     ]
                     string ""
                  }
               ]
            )
         ]
      }
      struct {
         string "12655907"
         int64 1426654853
         int64 1427284880
         int32 0
         array [
         ]
         array [
            dict entry(
               string "http://refdata.youview.com/mpeg7cs/YouViewIdentifierTypeCS/2010-12-09#linear.eventLocator"
               array [
                  string "dvb://233a..a0b0;cca3"
               ]
            )
         ]
         array [
         ]
         array [
            dict entry(
               string "entityType"
               array [
                  string "scheduleevent"
               ]
            )
            dict entry(
               string "eventId"
               array [
                  string "12655907"
               ]
            )
            dict entry(
               string "eventTitle"
               array [
                  string "FIM X-Trial World Championship"
               ]
            )
            dict entry(
               string "isAdult"
               array [
                  string "0"
               ]
            )
            dict entry(
               string "mediumSynopsis"
               array [
                  string "Coverage from the X-Trial World Championship where the world's 
                  top riders attempt to clear a series of near-impossible obstacles in the 
                  fastest time. Action from Wiener Neustadt (Austria)."
               ]
            )
            dict entry(
               string "owningServiceId"
               array [
                  string "10672980"
               ]
            )
            dict entry(
               string "start"
               array [
                  string "2015-03-25T09:00:00Z"
               ]
            )
         ]
         array [
            dict entry(
               string "classifiers"
               array [
                  struct {
                     array [
                        dict entry(
                           string "categoryScheme"
                           string "urn:dtg:metadata:cs:DTGGenreCS:2010-11"
                        )
                     ]
                     string "0"
                  }
               ]
            )
            dict entry(
               string "mediaContent"
               array [
                  struct {
                     array [
                        dict entry(
                           string "aspectRatio"
                           string "16:9"
                        )
                        dict entry(
                           string "audioLanguage"
                           string "eng"
                        )
                        dict entry(
                           string "audioMixType"
                           string "2"
                        )
                        dict entry(
                           string "contentDuration"
                           string "3900"
                        )
                        dict entry(
                           string "contentIsHighDefinition"
                           string "0"
                        )
                        dict entry(
                           string "format"
                           string "sd"
                        )
                        dict entry(
                           string "mediaType"
                           string "video"
                        )
                     ]
                     string ""
                  }
               ]
            )
         ]
      }
      ...
   ]


={============================================================================
*kt_dev_uv_stack_118* stack: sandbox


/opt/zinc-trunk/lib/sandbox/application-yv.conf

##
# This is a common configuration file for application sandbox.
# It specifies all directories that are imported "as is" from the real
# file system into the sandbox.
#
# This file is managed by YouView and is not to be modified by OEMs.
#
# Note that following directories are already in the sandbox and they are
# "special":
#
# /opt/zinc-trunk/var/log
# /opt/zinc-trunk/var/http-cache
# /app
# /app-data
# /opt/adobe/stagecraft/data
# /proc
# /dev
# /tmp
####

[directories]
# system
/lib
/usr/lib
/usr/local/lib
/usr/local/etc

# TODO: Remove
/bin
# TODO: Remove
/usr/bin

# users, groups, networking...
/etc

# YV stack
/opt/zinc-trunk/lib
/opt/zinc-trunk/share
/opt/zinc-trunk/share/platform_data
/opt/zinc-trunk/devel/lib
/opt/zinc-trunk/devel/share
/opt/zinc-trunk/oss/var/applications/identities
/opt/zinc-trunk/oss/lib

# TODO: Remove
/opt/zinc-trunk/bin
/opt/zinc-trunk/devel/bin
# TODO: Remove
/opt/zinc-trunk/oss/bin

# certificates
/opt/youview/pki

# DirectFB
/run/dfb

# Application type specific configuration is specified in application-yv.d
# directory

[options]
StdOut=/dev/console
StdErr=/dev/console


<ex>

/proc/1606/root

root# ll
-r--------    1 16385    yv_signe         0 Apr  2 16:49 auxv
--w-------    1 16385    yv_signe         0 Apr  2 16:49 clear_refs
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 cmdline
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 coredump_filter
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:49 cwd -> /run/youview/jail/applications/1
-r--------    1 16385    yv_signe         0 Apr  2 16:49 environ
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:52 exe -> /run/youview/jail/applications/1/opt/zinc-trunk/bin/w3cEngine
dr-x------    2 16385    yv_signe         0 Apr  2 16:52 fd
dr-x------    2 16385    yv_signe         0 Apr  2 16:49 fdinfo
-r--------    1 16385    yv_signe         0 Apr  2 16:49 limits
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 maps
-rw-------    1 16385    yv_signe         0 Apr  2 16:49 mem
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 mountinfo
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:52 mounts
-r--------    1 16385    yv_signe         0 Apr  2 16:49 mountstats
dr-xr-xr-x    4 16385    yv_signe         0 Apr  2 16:49 net
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 oom_adj
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 oom_score
-r--------    1 16385    yv_signe         0 Apr  2 16:49 pagemap
-r--------    1 16385    yv_signe         0 Apr  2 16:49 personality
lrwxrwxrwx    1 16385    yv_signe         0 Apr  2 16:49 root -> /run/youview/jail/applications/1
-rw-r--r--    1 16385    yv_signe         0 Apr  2 16:49 sched
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 smaps
-r--------    1 16385    yv_signe         0 Apr  2 16:49 stack
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 stat
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 statm
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 status
dr-xr-xr-x   19 16385    yv_signe         0 Apr  2 16:49 task
-r--r--r--    1 16385    yv_signe         0 Apr  2 16:49 wchan

root# ll /run/youview/jail/applications/1
root# 


However, do cd into root then shows:

root# cd root
root# ll
drwxr-xr-x    3 radiumd  app_libr      4096 Apr  2 15:56 app
drwx------    3 16385    yv_signe      4096 Apr  2 16:23 app-data
drwxr-xr-x    2 root     root          4096 Mar 31 01:07 bin
drwxr-xr-x    3 root     root          1420 Jan  1  1970 dev
drwxr-xr-x    6 root     root          4096 Apr  1 13:30 etc
drwxr-xr-x    4 root     root          4096 Mar 31 01:07 lib
drwxr-xr-x    6 root     root           120 Apr  2 16:48 mnt
drwxr-xr-x    7 root     root           140 Apr  2 16:48 opt
dr-xr-xr-x  128 root     root             0 Jan  1  1970 proc
drwxr-xr-x    4 root     root            80 Apr  2 16:48 run
drwx------    2 16385    yv_signe      4096 Apr  2 16:49 tmp
drwxr-xr-x    4 root     root            80 Apr  2 16:48 usr
drwxr-xr-x    3 root     root            60 Apr  2 16:48 var
root# 


={============================================================================
*kt_dev_uv_stack_120* stack: cppunit

-DMACRO__pkgdatadir=\"/opt/zinc/share/uranium-client-system\" -m32 -I/opt/zinc/include  -isystem
/opt/zinc/oss/include  -D_FORTIFY_SOURCE=2  -fstack-protector-all   -m32 -DNDEBUG -O3 -pipe -pthread
-march=i686 -Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
-Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format -Werror=missing-braces
-Werror=nonnull -Werror=parentheses -Werror=pointer-sign -Werror=return-type -Werror=sequence-point
-Werror=strict-overflow=1 -Werror=trigraphs -Werror=unknown-pragmas -Werror=unused-function
-Werror=unused-label -Werror=unused-value -Werror=volatile-register-var -fdiagnostics-show-option
-Werror=uninitialized  -MT SummaryTest.o -MD -MP -MF $depbase.Tpo -c -o SummaryTest.o
/var/lib/jenkins/jobs/_Zinc.Build__master__release__CentOS-6.4-x86_64/workspace/source/Uranium/Uranium.Client.System/test/metadata/SummaryTest.cpp
&&\


/bin/sh ../../libtool  --tag=CXX   --mode=link i686-pc-linux-gnu-g++  -m32 -DNDEBUG -O3 -pipe
-pthread  -march=i686 -Wall -Wextra -Werror=address -Werror=array-bounds -Werror=c++0x-compat
-Werror=char-subscripts -Werror=comment -Werror=enum-compare -Werror=format -Werror=missing-braces
-Werror=nonnull -Werror=parentheses -Werror=pointer-sign -Werror=return-type -Werror=sequence-point
-Werror=strict-overflow=1 -Werror=trigraphs -Werror=unknown-pragmas -Werror=unused-function
-Werror=unused-label -Werror=unused-value -Werror=volatile-register-var -fdiagnostics-show-option
-Werror=uninitialized  -rdynamic -L/opt/zinc/lib -L/opt/zinc/oss/lib -Wl,--as-needed
-Wl,-rpath-link,/opt/zinc/lib -Wl,-rpath-link,/opt/zinc/oss/lib -o summarytest SummaryTest.o
helpers/SynchronisableDispatcher.o helpers/TestSupport.o ../../src/libUraniumClientSystemStatic.la
-L/opt/zinc/lib -L/opt/zinc/oss/lib 

-lboost_date_time 
-lboost_filesystem 
-lboost_system 
-lboost_program_options 
-lboost_thread 
-lboost_iostreams 

-llog4cplus 

-ldl 
-lboost_thread 
-llog4cplus
-ldbus-c++-1 
-ldbus-1 
-ldbus-c++-testsupport-1 

-lCadmiumSystemAPI 

-lUraniumClientAPI -lUraniumCommon

-lCobaltCommon 

-lCopperSystemDbus -lCopperSystemAPI 

-lIronSystemAPI -lIronRemindersSystemAPI -lIronRemindersSystemDbus -lIronRemindersSystemAPI

-lNeonClientSystem -lNeonClientApi -lNeonSystemAPI 

-lNickelSystemAPI 

-lZincCommonTestRunner
-lcppunit 
-lZincCommonTestSupport 
-lZincCommon 
-lZincDbusBindingTestSupport -lZincDbusBindingRuntime -lZincCommon -ldl
-lcppunit 
-lgmock -lgtest



={============================================================================
*kt_dev_uv_stack_150* stack: network

The dbus log when plug out and then plug in a cable

# dbus-monitor "interface=org.freedesktop.NetworkManager.Device.Wired 

Tue 2015-02-17 14:32:27 GMT
[17-02-2015 14:32:27.880473] signal sender=org.freedesktop.DBus -> dest=:1.80 serial=2 path=/org/freedesktop/DBus; interface=org.freedesktop.DBus; member=NameAcquired
   string ":1.80"
Feb 17 14:32:44 syslog[785]: <info> (eth0): carrier now OFF (device state 8)
Feb 17 14:32:44 syslog[785]: <info> (eth0): device state change: 8 -> 2 (reason 40)
Feb 17 14:32:44 syslog[785]: <info> (eth0): deactivating device (reason: 40).
eth0 Link DOWN.
Feb 17 14:32:44 syslog[785]: <info> (eth0): canceled DHCP transaction, DHCP client pid 815
[17-02-2015 14:32:44.579382] signal sender=:1.0 -> dest=(null destination) serial=204 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Carrier"
         variant             boolean false                  note: OFF
      )
      dict entry(
         string "State"
         variant             uint32 2
      )
      dict entry(
         string "Dhcp4Config"
         variant             object path "/"
      )
      dict entry(
         string "Ip6Config"
         variant             object path "/"
      )
      dict entry(
         string "Ip4Config"
         variant             object path "/"
      )
   ]
eth0 cable unplugged, powering down
eth0 cable plugged in, powering up
eth0 Link UP.
Auto config phy
eth0: Link is up, 100 Mbps Full Duplex
Feb 17 14:33:05 syslog[785]: <info> (eth0): carrier now ON (device state 2)
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 2 -> 3 (reason 40)
[17-02-2015 14:33:05.661158] signal sender=:1.0 -> dest=(null destination) serial=209 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Carrier"
         variant             boolean true          note: ON
      )
      dict entry(
         string "State"
         variant             uint32 3
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) starting connection 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6'
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 3 -> 4 (reason 0)
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) started...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 1 of 5 (Device Prepare) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) starting...
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 4 -> 5 (reason 0)
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) successful.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) scheduled.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 2 of 5 (Device Configure) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) started...
Feb 17 14:33:05 syslog[785]: <info> (eth0): device state change: 5 -> 7 (reason 0)
[17-02-2015 14:33:05.685977] signal sender=:1.0 -> dest=(null destination) serial=214 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Beginning DHCPv4 transaction (timeout in 1073741823 seconds)
   array [
      dict entry(
         string "State"
         variant             uint32 4
      )
   ]
[17-02-2015 14:33:05.701563] signal sender=:1.0 -> dest=(null destination) serial=218 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 5
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> dhclient started with pid 1546
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 3 of 5 (IP Configure Start) complete.
[17-02-2015 14:33:05.708832] signal sender=:1.0 -> dest=(null destination) serial=220 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 7
      )
   ]
Feb 17 14:33:05 syslog[785]: <info> (eth0): DHCPv4 state changed nbi -> preinit
Feb 17 14:33:05 syslog[785]: <info> (eth0): DHCPv4 state changed preinit -> reboot
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) started...
Feb 17 14:33:05 syslog[785]: <info>   address 172.20.35.27
Feb 17 14:33:05 syslog[785]: <info>   prefix 20 (255.255.240.0)
Feb 17 14:33:05 syslog[785]: <info>   gateway 172.20.32.1
Feb 17 14:33:05 syslog[785]: <info>   nameserver '127.0.0.1'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.34.223'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.34.224'
Feb 17 14:33:05 syslog[785]: <info>   nameserver '172.20.35.66'
Feb 17 14:33:05 syslog[785]: <info> Scheduling stage 5
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) scheduled...
Feb 17 14:33:05 syslog[785]: <info> Done scheduling stage 5
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 4 of 5 (IP4 Configure Get) complete.
Feb 17 14:33:05 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) started...
[17-02-2015 14:33:05.932824] signal sender=:1.0 -> dest=(null destination) serial=222 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "Dhcp4Config"
         variant             object path "/org/freedesktop/NetworkManager/DHCP4Config/1"
      )
   ]
Feb 17 14:33:06 syslog[785]: <info> (eth0): device state change: 7 -> 8 (reason 0)
Feb 17 14:33:06 syslog[785]: <info> Policy set 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6' (eth0) as default for IPv4 routing and DNS.
Feb 17 14:33:06 syslog[785]: <info> Activation (eth0) successful, device activated.
Feb 17 14:33:06 syslog[785]: <info> Activation (eth0) Stage 5 of 5 (IP Configure Commit) complete.
[17-02-2015 14:33:07.009626] signal sender=:1.0 -> dest=(null destination) serial=230 path=/org/freedesktop/NetworkManager/Devices/0; interface=org.freedesktop.NetworkManager.Device.Wired; d
   array [
      dict entry(
         string "State"
         variant             uint32 8
      )
      dict entry(
         string "Ip4Config"
         variant             object path "/org/freedesktop/NetworkManager/IP4Config/1"
      )
   ]
Feb 17 14:33:56 syslog[785]: <info> Trying to start the supplicant...


={============================================================================
*kt_dev_uv_stack_200* stack: dbus

To get the list of active bus names. This is script in box: opt/zinc/devel/bin/lsdbus

$lsdbus

# dbus-send Emporium

https://wiki.youview.co.uk/display/canvas/dbus-send+Emporium?src=contextnavpagetreemode

<monitor>
# to capture
dbus-monitor > /mnt/hd1/mylogs.log &
dbus-monitor | tee /mnt/hd1/mylogs.log &

# To launch Dbus-Monitor on your STB, and inspect MediaRouter activity, run the following command:
dbus-monitor "interface=Zinc.Media.MediaRouter"

# will only display MediaRouter SourceEvent messages:
dbus-monitor | grep -C 2 "member=SourceEvent"

dbus-monitor "type=method_call" "type=method_return" "type=error"

dbus-monitor --profile "interface=Zinc.Application.ApplicationManager,member=launchApplication" \ 
   "interface=Zinc.Application.ApplicationManager,member=ApplicationLifecycleEvent"

<introspect>

Q: which is the start to build interface/method to build a hierarchy?

kpark@wll1p04345:~/source/DEVARCH/Neon$ find . -name *.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerActiveConnection.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerSettings.xml
./Neon.System.API/data/introspection-xml/enum-PingStatus.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-settings.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-device-ethernet.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-active-connection.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-manager.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-device.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-exported-connection.xml
./Neon.System.API/data/introspection-xml/vendor/NetworkManager/NM_0_8/nm-ip4-config.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_CAP.xml
./Neon.System.API/data/introspection-xml/struct-PingResponse.xml
./Neon.System.API/data/introspection-xml/enum-NM_ACTIVE_CONNECTION_STATE.xml
./Neon.System.API/data/introspection-xml/enum-NM_STATE.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerIP4Config.xml
./Neon.System.API/data/introspection-xml/service.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerDeviceWired.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_TYPE.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_STATE.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerDevice.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManager.xml
./Neon.System.API/data/introspection-xml/interface-NetworkManagerSettingsConnection.xml
./Neon.System.API/data/introspection-xml/enum-NM_DEVICE_STATE_REASON.xml
./Neon.System.API/data/introspection-xml/interface-IPNetwork.xml


<interface-name>
Cobalt.System.DBusClient/src/MetadataBrokerDBusToSyncAndAsync.cpp

36-
37-#include "MetadataBrokerDBusToSyncAndAsync.h"
38-
39-NS_ZINC_DBUS_BINDING_OPEN
40:const char* const interface_name<Zinc::Broker::MetadataBrokerAsync>::value = "Zinc.Broker.MetadataBroker";
41:const char* const interface_name<Zinc::Broker::MetadataBrokerSync>::value = "Zinc.Broker.MetadataBroker";
42:const char* const interface_name<Zinc::Broker::MetadataBrokerDBusToSyncAndAsync>::value =
       "Zinc.Broker.MetadataBroker";

Iron.System.DBusClient/src/EventRepositoryDBusToSyncAndAsync.cpp

35-
36-#include "EventRepositoryDBusToSyncAndAsync.h"
37-
38-NS_ZINC_DBUS_BINDING_OPEN
39:const char* const interface_name<Zinc::Metadata::EventRepositoryAsync>::value =
"Zinc.Metadata.EventRepository";

40:const char* const interface_name<Zinc::Metadata::EventRepositorySync>::value =
       "Zinc.Metadata.EventRepository";

41:const char* const interface_name<Zinc::Metadata::EventRepositoryDBusToSyncAndAsync>::value =
       "Zinc.Metadata.EventRepository";


={============================================================================
*kt_dev_uv_stack_200* commands

# what?
root# setItem platform.settings.enable-ipcrb 1

# log?
tail -f /opt/zinc/var/daemons/crbd/log/helium.log


How to Introspect DBus from the Command Line
https://wiki.youview.co.uk/display/canvas/How+to+Introspect+DBus+from+the+Command+Line?src=search
# to see messages on dbus
root# dbus-monitor "interface=Zinc.Application.ApplicationManager"

# what is it? LSR?
root# getChildItems oem

# what?
export GST_PLUGIN_PATH=/opt/zinc/oss/lib:/opt/zinc/oss/lib/gstreamer-1.0
export LD_LIBRARY_PATH=/lib:/usr/local/lib:/opt/zinc/oss/lib/gstreamer-1.0:/opt/zinc/oss/lib:/opt/zinc/oss/lib/python2.6

LD_PRELOAD=/usr/local/lib/libdirectfb.so:/usr/local/lib/libdirect.so:/usr/local/lib/libinit.so gst-launch-1.0 souphttpsrc location=http://54.225.86.153/INT01_LCN_551.sdp ! vqesdpdemux caps=video/mpegts ! queue ! tsnexusbin 


={============================================================================
*kt_dev_uv_wiki_001* dbus-monitor

dbus-send  --session --type=method_call --print-reply --dest='org.freedesktop.DBus' / org.freedesktop.DBus.ListNames
dbus-monitor --profile "interface=Zinc.Application.ApplicationManager,member=launchApplication" "interface=Zinc.Application.ApplicationManager,member=ApplicationLifecycleEvent"

{dbus-spy}
https://wiki.youview.co.uk/display/YVDP/How+to+inspect+MediaRouter+activity
This is a python script and run on the box.

MediaRouter Dbus Spy is a tool that prints all the MediaRouter dbus communications in a more
readable format than the raw output. It also reports when a new application is launched or killed
and any MediaRouter crash.


={============================================================================
*kt_dev_uv_hwei_001* stack: convert ro filesystem to rw

From the release, follow the step 3:

https://wiki.youview.co.uk/display/canvas/HOWTO+Install+Huawei+DN370T+PVR1+B37SP11

3. Boot from HDD

From SSH or the serial console run the following command:

mkdir -p /mnt/nand/userdata/data && echo "rw" > /mnt/nand/userdata/data/rw_cmd

The next boot will take slightly longer than normal as the files are copied from nand to the harddisk.


={============================================================================
*kt_dev_uv_task_001* task:01: nexusMgr

{inspect}
used in wrapper:

/bin/nexus-inspect -r -p "${parent_pid}"


{mgr-interface}
nexusMgr interfaces:

BcmNexus_Audio_Mixer_Register(NEXUS_AudioMixerHandle hMixer)
BcmNexus_Audio_Mixer_Unregister(void)
BcmNexus_Graphics_Resources_Acquire(BcmNexus_Graphics_Resources_Config *)
BcmNexus_Graphics_Resources_Release(const BcmNexus_Graphics_Resources *)
BcmNexus_ImageDecoder_Resources_Acquire(const BcmNexus_ImageDecoder_Resources_Config *)
BcmNexus_ImageDecoder_Resources_Release(const BcmNexus_ImageDecoder_Resources *)
BcmNexus_Input_Resources_Acquire(const BcmNexus_Input_Resources_Config *)
BcmNexus_Input_Resources_Release(const BcmNexus_Input_Resources *)
BcmNexus_Key_Last_Key_Timestamp(void)
BcmNexus_Platform_Init(void)
BcmNexus_Platform_Uninit(void)
BcmNexus_Screen_Capture(void)
BcmNexus_SetMixerPath(NEXUS_AudioMixerHandle hmixer, const BcmNexus_StreamPlayer_Resources *resources)
BcmNexus_Set_Last_Key_Timestamp(void)
BcmNexus_SoundOutput_Resources_Acquire(const BcmNexus_SoundOutput_Resources_Config *)
BcmNexus_SoundOutput_Resources_Release(const BcmNexus_SoundOutput_Resources *)
BcmNexus_SoundOutput_SetVolume(BcmNexus_SoundOutput_Volume, unsigned)
BcmNexus_StreamPlayer_Resources_Acquire(const BcmNexus_StreamPlayer_Resources_Config *)
BcmNexus_StreamPlayer_Resources_Avaiable(void)
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *)
BcmNexus_UnSetMixerPath(NEXUS_AudioMixerHandle hmixer, const BcmNexus_StreamPlayer_Resources *resources)


{shm}
<from-inspect>
// return true if no shared mem opens or destroied it successfully. so no process owns it
static bool do_platform_init(size_t shMemSz);

static void releaseNexusResources( BcmNexus_Shared_Memory *shmem )
{
  shmem->resource_pid = getpid();
  printf( "Reset resource_pid\n" );
  /* set callback to NULL */

  // <out> commented out since no support from HWEI
  // resetDimmingSetting(shmem);
  // {
  //  NEXUS_PictureCtrl_GetCommonSettings( sharedMem->videoWindow, &picture_settings );
  // }

  NEXUS_VideoDecoder_Stop( shmem->videoDecoder );
  NEXUS_AudioDecoder_Stop( shmem->audioDecoder[0] );

  // <out> commented out since no support from HWEI
  // for (uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  // {
  //   // stopPlayPump( shmem->playpump[i] );
  //   {
  //     NEXUS_PlaypumpSettings playpump_settings;
  //     NEXUS_Playpump_Stop( playPump );
  //     NEXUS_Playpump_GetSettings( playPump, &playpump_settings );
  //     NEXUS_Playpump_SetSettings( playPump, &playpump_settings );
  //   }
  // }

  NEXUS_VideoDecoder_Flush( shmem->videoDecoder );

  // <mod> HWEI has two audio decoders
  NEXUS_AudioDecoder_Flush( shmem->audioDecoder[0] );

  // <out> commented out since no support from HWEI
  // for (uint8_t i = 0; i < MAX_PUMP_NUM; ++i)
  // {
  //   NEXUS_Playpump_Flush( shmem->playpump[i] );
  // }

  shmem->resource_pid=0;
}

<missed-from-huawei>
These are fields that huawei mgr DO NOT HAVE from what inspect tool uses.

BcmNexus_State.sharedMem->videoWindow;
BcmNexus_State.sharedMem->playPump[i];


<from-inspect>
typedef struct
{
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[1];           // used
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_VideoDecoderHandle    videoDecoder;              // used
  NEXUS_VideoWindowHandle     videoWindow;               // used
  NEXUS_PlaypumpHandle        playpump[MAX_PUMP_NUM];    // used
  NEXUS_DmaHandle             dmaHandle;
  pid_t                       resource_pid;
} BcmNexus_Shared_Memory;


<from-mgr-humax>
typedef struct {
  //
  // 'same' as inspect
  //
  NEXUS_AudioPlaybackStartSettings    audioStartSettings;
  bool                                pcmStarted[NEXUS_NUM_AUDIO_PLAYBACKS];
} BcmNexus_Shared_Memory;

<from-mgr-huawei>
typedef struct {
    NEXUS_AudioMixerHandle              mixer;
    NEXUS_AudioPlaybackHandle           pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
    NEXUS_AudioDecoderHandle            audioDecoder[2];
    NEXUS_VideoDecoderHandle            videoDecoder;
} BcmNexus_Shared_Memory;



{pid-check}
<from-inspect>
When the given pid is the same as shm pid, then do release:

if ( 0 == expected_owning_pid || expected_owning_pid == sharedMem->resource_pid )

<from-mgr-humax>
BcmNexus_StreamPlayer_Resources_Acquire( const BcmNexus_StreamPlayer_Resources_Config *config)
{
  // check in both oem. this prevents the same process getting the same.
  if (BcmNexus_State.streamResource) {
    BDBG_MSG_TRACE(("BcmNexus_StreamPlayer_Resources_Acquire: Already acquired!!"));
    return NULL;
  }

  // check and if already owns by the other process then returns. only when no
  // one owns it, go forward
  if( (BcmNexus_State.sharedMem->resource_pid != 0) && (BcmNexus_State.sharedMem->resource_pid != getpid()) )

  // set to say i owns it
  BcmNexus_State.sharedMem->resource_pid = getpid();
}

BcmNexus_StreamPlayer_Resources_Release()
{
  // set pid = 0
}

note: Q: the below is ONLY for humax and not used in inspect tool. Who's using it?

BcmNexus_StreamPlayer_Resources_Avaiable(void)
{
  if( (BcmNexus_State.sharedMem->resource_pid == 0) || (BcmNexus_State.sharedMem->resource_pid == getpid()) )
}


{hwei-mgr-modification}
<playpump>
note: The below is only for Humax and also has a pair for Init and Uninit for each audio and video.
BcmNexus_Platform_Init_Video(void);

For HWEI, the below do the work that Init_Audio and Init_Video do in HMAX case. Hence added playpump
open code in:
BcmNexus_Platform_Init_Audio(void);

However, no pair but instead uninit done in: 
BcmNexus_StreamPlayer_Resources_Release(const BcmNexus_StreamPlayer_Resources *resources_)

Added playpump in SHM structure and handles it in Init and Release.

<videoWindow>
note: do not use videoWindowSD in inspect tool so not shared in shm.

BcmNexus_State.sharedMem->videoWindow;

As with playpump, init and uninit done in Acquire and Release:

BcmNexus_StreamPlayer_Resources_Acquire
BcmNexus_StreamPlayer_Resources_Release

note: Unline HMAX, NO input connection on videoWindow in Acquire and so no handle in Release.

Added videoWindow in SHM structure and handles it in Acquire and Release.

This cause opps:
Code: 00000000  8fa20010  3c04e1bd <8c420000> 24848dbc  afa20010  8fa30010 8fa20014  0062001a ###
00:00:22.574 nexus_driver_callbacks: two apps can't register for the same callback for the same
handle *** 00:00:22.574 nexus_driver_callbacks: nexus_driver_callback_to_driver:
(HDMI_OUTPUT:0xcf3a6c80) not enough resources to map callback 0xc04:0xe1d60064 *** 00:00:22.574
BHDM_EDID: Overriding 1366x768p/1360x768p to BFMT_VideoFmt_e720p !!! Assert 'Bad object of expected
type #NEXUS_VideoWindow:0xdeadda7a (0x0:0xe19f39b4)' Failed at
/home/gejing/dn370tb37sp05/bcm7409/refsw6.5/nexus/modules/display/7420/src/nexus_video_window.c:1285
BKNI_Fail: forcing oops CPU 0 Unable to handle kernel paging request at virtual address 00000000,
    epc == e178ec90, ra == e178ec88


{open-and-start}
<from-mgr-humax>

Q: nexusMgr already has Init and Uninit interface. Is it okay to use these rather than implementing
the proposed function? 

BcmNexus_Platform_Uninit(void);

A: NO. Since Init and Uninit pair do 'open' and close but inspect tool uses 'stop'. Interestingly, the
nexusMgr do not use 'start' interface. Does it mean that do start automatically when it is opened?


BcmNexus_State.sharedMem->ac3Encoder = NEXUS_Ac3Encode_Open(NULL);


{design} the suggested call
1. check manager's init state and the given pid.

if( !BcmNexus_State.initialized && pid != resource_pid )
   return;

2. set shm resource pid = 0 at the end of the call.


{tickets}
https://jira.youview.co.uk/browse/DEVARCH-8092
Provide a method in Huawei's nexusMgr to release resources acquired by a pid

<proposed-api>
The proposed interface in OEM nexusMgr code.
BcmNexus_Release_All_Resources_Acquired_By_Process(pid_t pid);

https://jira.youview.co.uk/browse/YVHUAWEI-6095
Kernel oops when killing w3cEngine or Netflix

Chris Dudding added a comment - Last Wednesday 15:34
B37SP05 is an engineering release, so the "kernel oops" fixes are not applied in the latest Huawei
FR13 release (B37SP11). We've asked them to apply the fix into their main FR13 branch. We will mark
this ticket as resolved when the fix is available in the next FR13 release.

Zegen Pei added a comment - Last Friday 02:25
fixed in 70.37.13

note: update. 2015.01.15. tried the eng. release and seen no kernel oops any more.


https://jira.youview.co.uk/browse/DEVARCH-8081
<TODO> 1
If we are to proceed with `nexus-inspect` as a solution, we separately need OEMs to move the struct
definition into the header file, but for now, we should identify which devices the current
implementation is compatible with. 

Device Works (Y/N)   Comments
Humax T1000          Y 
Humax T2100/T2000    Y 
Humax T2200          Y 
Huawei DN370T        N 
Huawei DN372T 
Huawei DN360T

note: before that need to verify #6095 first since it cause opps when kill apps.

1. this is function sets resource_pid in humax case
BcmNexus_StreamPlayer_Resources_Acquire(const BcmNexus_StreamPlayer_Resources_Config *)

2. We could perhaps make an initial implementation of this for each OEM and provide as a patch to
OEMs, or if that proves too problematic in the Huawei case, leave it as an empty "no-op", and let
them fill-in the implementation.

3. At the moment Humax saves the pid of the last process and Ideally we should know what process
acquired each resource so we can more safely release them. Some testing will tell us how necessary
it is for now.

https://jira.youview.co.uk/browse/DEVARCH-8080
<disable>
This can be disabled by removing either of the executables:
    /opt/zinc/bin/exec-then-cleanup-app.sh
    /opt/zinc/bin/nexus-inspect


{logs}
2015.01.16: 

1. able to build nexus mgr which has debug print mesg to see if it is loaded and used.  found the
problem which prevents me copying the built lib to a box since box has read-only fs. need to make it
rw fs.

2. managed to make a fs writable.

3. however, tried to use the lib built on my own, the box doesn't boot up but when use the original
lib works okay. why?

4. __FUNCTION__ macro seems to cause one problem. need to check.

5. there is the latest nexusMgr code from HWEI and tried that as well. But no success. The code from
https://jira.youview.co.uk/browse/YVHUAWEI-5895

6. three versions of nexus mgr: from uv git, from the gira, from the staging folder.

7. the log line
Error org.freedesktop.DBus.Error.NoMemory: Launcher could not run (out of memory)


2015.01.19, Mon:

1. Tried three variants of sources. None of them works. Asked Bomen(HWEI guy) to have a trace log
for a working case to compare.

2015.01.20, Tue:

1. Created a new ticket for an issue that cannot build a working nexusMgr. 
https://jira.youview.co.uk/browse/YVHUAWEI-6598

2. Ongoing discussion about features to implement.
https://jira.youview.co.uk/browse/YVHUAWEI-6095


2015.01.21, Wed:

1. Hack sources

HUAWEI_SHARED_RESOURCE        : defed in src

NEXUS_HAS_PICTURE_DECODER     : NO
_SC_DIRECT_NEXUS_             : NO
NEXUS_NUM_XXX                 : NO
DFB_PLATFORM_VERSION_MAJOR    : NO
DUAL_OUTPUT                         : defed in pkg config for hwei and hmax
NEXUS_HAS_DMA && NEXUS_HAS_SECURITY : defed in pkg config
BCMEXUS_STREAM_XXX                  : NO
USE_SIMPLE_DECODER                  : NO


01.29:   <shm-size-issue>
======
Investigating shmget error.

" from nexusMgr log line
log-usb-Mon-Jan-26-12:01:40:1253:*** KT: 0121: NEW BcmNexus_Platform_Init_Audio: shm size(24) ***

" from proc device
305450176

cat /proc/sysvipc/shm
key         shmid    perms    size  cpid  lpid nattch uid   gid  cuid  cgid      atime      dtime      ctime
305450176   163844   666      24    1063  1395 4      504   504   504   504 1422517874 1422517866         33
 
504       1063 12.6  9.7 502416 31352 ?        Sl   07:50   8:03 /opt/cds/bin/huaweidaemon

However, inspect asks 28 bytes which is the cause of the error.


02.09:
======

{shm-diff}

The handles are all pointers like:

typedef struct NEXUS_AudioMixer *NEXUS_AudioMixerHandle;


<proposed>
#define NEXUS_INSPECT_NUM_ADECS       (2)
#define NEXUS_INSPECT_NUM_PLAYBACKS   (2)
#define NEXUS_INSPECT_NUM_PLAYPUMPS   (1)

typedef struct {
  NEXUS_AudioMixerHandle      mixer;
  NEXUS_AudioPlaybackHandle   pcmPlayback[2];
  NEXUS_AudioDecoderHandle    audioDecoder[2];
  NEXUS_VideoDecoderHandle    videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;
  NEXUS_Ac3EncodeHandle       ac3Encoder;
  NEXUS_DmaHandle             dmaHandle;
  NEXUS_VideoWindowHandle     videoWindow;
  NEXUS_PlaypumpHandle        playpump[1];
  pid_t                       resource_pid;
} NexusInspectCapsV0;


<humax> (from inspect.c)
#define NEXUS_NUM_AUDIO_PLAYBACKS 2
#define NEXUS_NUM_HDMI_OUTPUTS 1
#define MAX_PUMP_NUM	1

typedef struct {
  NEXUS_AudioMixerHandle              mixer;
  NEXUS_AudioPlaybackHandle           pcmPlayback[2];
  NEXUS_AudioDecoderHandle            audioDecoder[1];
  NEXUS_VideoDecoderHandle            videoDecoder;
  NEXUS_StcChannelHandle              stcChannel;
  NEXUS_Ac3EncodeHandle               ac3Encoder;
  NEXUS_DmaHandle                     dmaHandle;
  NEXUS_VideoWindowHandle             videoWindow;
  NEXUS_PlaypumpHandle                playpump[1];
  pid_t                               resource_pid;
} BcmNexus_Shared_Memory;

<huawei>

#define NEXUS_NUM_AUDIO_PLAYBACKS (1)

typedef struct {
    NEXUS_AudioMixerHandle              mixer;
    NEXUS_AudioPlaybackHandle           pcmPlayback[1];
    NEXUS_AudioDecoderHandle            audioDecoder[2];
    NEXUS_VideoDecoderHandle            videoDecoder;
    NEXUS_StcChannelHandle              stcChannel;
    pid_t                               resource_pid;
} BcmNexus_Shared_Memory;


   humax                                                                         hwei
--------------------------------------------------------------------          --------------------------------------------------------------------
typedef struct                                                                typedef struct 
{                                                                             {                                                                 
  NEXUS_AudioMixerHandle      mixer;                                            NEXUS_AudioMixerHandle              mixer;
  // 2 in mgr source                                                            // 1 in oem stage
  NEXUS_AudioPlaybackHandle   pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];           NEXUS_AudioPlaybackHandle           pcmPlayback[NEXUS_NUM_AUDIO_PLAYBACKS];
  NEXUS_AudioDecoderHandle    audioDecoder[1];           // used to stop        NEXUS_AudioDecoderHandle            audioDecoder[2];
  NEXUS_Ac3EncodeHandle       ac3Encoder;                // used in info        NEXUS_VideoDecoderHandle            videoDecoder;
  NEXUS_StcChannelHandle      stcChannel;                // used in info        NEXUS_StcChannelHandle              stcChannel;
  NEXUS_VideoDecoderHandle    videoDecoder;              // used in info        pid_t                               resource_pid;
  NEXUS_VideoWindowHandle     videoWindow;               // used in info      } BcmNexus_Shared_Memory;                                                        
  // 1 in mgr source
  NEXUS_PlaypumpHandle        playpump[MAX_PUMP_NUM];    // used to stop
  NEXUS_DmaHandle             dmaHandle;                 // used in info
  pid_t                       resource_pid;
} BcmNexus_Shared_Memory;


02.24: (logs changes to rewrite git commits and commit history)
======
1. OEM.Huawei/OEM.Huawei.3rdPartyStack/setvars-huawei-bcm7409.sh

For hwei, do comment out as below to inlcude this in the build.

# export ZINC_EXCLUDE_PROJECTS="Polonium.NexusInspect"

2. Polonium/Polonium.NexusInspect/src/exec-then-cleanup-app.c

change name nexus-inspect to nexus-release

3. Add nexus-release.c

4. Add nexus-inspect.[ch] 

5. Change Makefile.am to build both files.


02.25: as-needed option problem when builds nexus tools
======

<fail>
-O2 -pipe -rdynamic -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-o nexus-release nexus_release-nexus-release.o -Wl,-rpath -Wl,/usr/local/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib ~
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread -pthread ~

/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBSetOption' 
/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBCreate' 
/opt/oem-staging/huawei-bcm7409/usr/local/lib/libnexusMgr.so: undefined reference to `DirectFBInit' collect2: ld returned 1 exit status

<okay>
-O2 -pipe -Wl,-rpath -Wl,/usr/local/lib -Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-Wl,-rpath-link
-Wl,/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-o nexus-inspect nexus_inspect-nexus-inspect.o

-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/usr/local/lib
-lnexusMgr -ldirectfb -lfusion -ldirect -linit -lnexus -lz -lpthread
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/lib
-L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/oss/lib
-Wl,--as-needed -L/data/builds/DEVARCH-8092/huawei.370/zinc-install-root/release/huawei-bcm7409/lib
-L/opt/oem-staging/huawei-bcm7409/usr/local/lib -pthread


<runtime> no direct reference to nexusMgr
/data/builds/master/huawei.370/zinc-install-root/release/huawei-bcm7409/opt/zinc-trunk/bin$ readelf
-d w3cEngine | grep NEED

(standard input):4: 0x00000001 (NEEDED)                     Shared library: [libstdc++.so.6]
(standard input):5: 0x00000001 (NEEDED)                     Shared library: [libsoup-2.4.so.1]
(standard input):6: 0x00000001 (NEEDED)                     Shared library: [libgobject-2.0.so.0]
(standard input):7: 0x00000001 (NEEDED)                     Shared library: [libglib-2.0.so.0]
(standard input):8: 0x00000001 (NEEDED)                     Shared library: [libNickelTunerSystemAPI.so.0]
(standard input):9: 0x00000001 (NEEDED)                     Shared library: [libQt5WebKitWidgets.so.5]
(standard input):10: 0x00000001 (NEEDED)                     Shared library: [libQt5Widgets.so.5]
(standard input):11: 0x00000001 (NEEDED)                     Shared library: [libZincJsCoreBindingRuntime.so.0]
(standard input):12: 0x00000001 (NEEDED)                     Shared library: [libZincCommon.so.0]
(standard input):13: 0x00000001 (NEEDED)                     Shared library: [libboost_thread.so.1.42.0]
(standard input):14: 0x00000001 (NEEDED)                     Shared library: [liblog4cplus-1.0.so.4]
(standard input):15: 0x00000001 (NEEDED)                     Shared library: [libboost_system.so.1.42.0]
(standard input):16: 0x00000001 (NEEDED)                     Shared library: [libQt5WebKit.so.5]
(standard input):17: 0x00000001 (NEEDED)                     Shared library: [libQt5Gui.so.5]
(standard input):18: 0x00000001 (NEEDED)                     Shared library: [libQt5Network.so.5]
(standard input):19: 0x00000001 (NEEDED)                     Shared library: [libQt5Core.so.5]
(standard input):20: 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
(standard input):21: 0x00000001 (NEEDED)                     Shared library: [libpthread.so.0]
(standard input):22: 0x00000001 (NEEDED)                     Shared library: [libc.so.0]
(standard input):49: 0x6ffffffe (VERNEED)                    0x40bd3c
(standard input):50: 0x6fffffff (VERNEEDNUM)                 2


04.01:
======
1. Got eng release and check on shm first.

before:
cat /proc/sysvipc/shm

key         shmid    perms    size  cpid  lpid nattch uid   gid  cuid  cgid      atime      dtime      ctime

305450176   163844   666      24    1063  1395 4      504   504   504   504
1422517874 1422517866         33

now:
305450176     196613   666         28  1074  1422      4   504   504   504
504 1427879275 1427879314         43

from ps:
1074 ?        Sl     3:09 /opt/cds/bin/huaweidaemon


2. Need to make a box writable since requires to copy exec and nexus-release
binary.

exec-then-cleanup-app

3. Seen a problem of making fs writable.

4. Cannot run iplayer and nexus-release as well
/opt/zinc-trunk/bin/nexus-release: can't load library 'libnexusMgr.so.0'

In that case, shows this error:

(w3cEngine:2429): GStreamer-WARNING **: Failed to load plugin
                  '/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so': File
                  not found


5. However, there are files on a box.

root# ll /opt/{zinc,zinc-trunk}/oss/lib/gstreamer-1.0/libgstnexus.so
lrwxrwxrwx    1 1024     1025            20 Apr  1 13:30
/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so -> libgstnexus.so.0.0.0

lrwxrwxrwx    1 root     root            20 Jan  1  1970
/opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so -> libgstnexus.so.0.0.0


6. on a huwawei box

objdump -p /opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so

/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so:     file format elf32-tradlittlemips

Dynamic Section:
  NEEDED               libnexusMgr.so.0 ~
  NEEDED               libnexus.so
  NEEDED               libgstbase-1.0.so.0
  NEEDED               libgstmpegts-1.0.so.0
  NEEDED               libgstreamer-1.0.so.0
  NEEDED               libgobject-2.0.so.0
  NEEDED               libglib-2.0.so.0
  NEEDED               libgcc_s.so.1
  NEEDED               libpthread.so.0
  NEEDED               libc.so.0
  SONAME               libgstnexus.so.0
  RPATH                /usr/local/lib
  RUNPATH              /usr/local/lib


root# objdump -p /opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so      

/opt/zinc/oss/lib/gstreamer-1.0/libgstnexus.so:     file format elf32-tradlittlemips

Dynamic Section:
  NEEDED               libnexusMgr.so ~
  NEEDED               libnexus.so
  NEEDED               libgstbase-1.0.so.0
  NEEDED               libgstmpegts-1.0.so.0
  NEEDED               libgstreamer-1.0.so.0
  NEEDED               libgobject-2.0.so.0
  NEEDED               libglib-2.0.so.0
  NEEDED               libgcc_s.so.1
  NEEDED               libpthread.so.0
  NEEDED               libc.so.0
  SONAME               libgstnexus.so.0
  RPATH                /usr/local/lib
  RUNPATH              /usr/local/lib


open("/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so", O_RDONLY) = 60

open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/oss/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/oss/lib/gstreamer-1.0/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/devel/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/opt/zinc-trunk/tests/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/local/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/usr/lib/libnexusMgr.so.0", O_RDONLY) = -1 ENOENT (No such file or directory)

write(2, "\n(w3cEngine:1641): GStreamer-WARN"..., 134
(w3cEngine:1641): GStreamer-WARNING **: Failed to load plugin '/opt/zinc-trunk/oss/lib/gstreamer-1.0/libgstnexus.so': File not found
) = 134


={============================================================================
*kt_dev_uv_task_002* task:02: DEVARCH-8869

02.16:
======
CANTST-15347: BBC iPlayer: app not fully functional following IP reconnect after IP disconnect error message shown
-> DEVARCH-8869: Investigate/Fix CANTST-15347 BBC iPlayer: app not fully functional following IP reconnect after IP disconnect error message shown

<net-manager>
this is oem comp which is based on open source and has some oem modification.
source will be provided by tar file in this folder.

/home/kpark/source/DEVARCH/OEM.Humax/NetworkManager/src/NetworkManager-0.8.5.92


<serial-log-when-plug-in-out>
eth0 Link DOWN.
Feb 16 16:51:52 syslog[793]: <info> (eth0): carrier now OFF (device state 8)
Feb 16 16:51:52 syslog[793]: <info> (eth0): device state change: 8 -> 2 (reason 40)
Feb 16 16:51:52 syslog[793]: <info> (eth0): deactivating device (reason: 40).
Feb 16 16:51:53 syslog[793]: <info> (eth0): canceled DHCP transaction, DHCP client pid 2516
eth0 cable unplugged, powering down



eth0 cable plugged in, powering up
eth0 Link UP.
Auto config phy
eth0: Link is up, 100 Mbps Full Duplex
Feb 16 16:52:09 syslog[793]: <info> (eth0): carrier now ON (device state 2)
Feb 16 16:52:09 syslog[793]: <info> (eth0): device state change: 2 -> 3 (reason 40)
Feb 16 16:52:09 syslog[793]: <info> Activation (eth0) starting connection 'bf2bf8f8-d3c5-43c9-806f-129a9f730cb6'
Feb 16 16:52:09 syslog[793]: <info> (eth0): device state change: 3 -> 4 (reason 0)

This matches to:

./src/nm-device-ethernet.c:243: nm_log_info (LOGD_HW | LOGD_ETHER, "(%s): carrier now %s (device state %d%s)",
./src/nm-device-ethernet.c:245:              carrier ? "ON" : "OFF",

<dbus>
793   :1.0                     /opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        
793   org.freedesktop.NetworkManager/opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        
793   org.freedesktop.NetworkManagerSystemSettings/opt/zinc/oss/sbin/NetworkManager --no-daemon --log-level=INFO        

dbus-send  --session --type=method_call --print-reply --dest='Zinc.ContentAcquisition' \
 /Zinc org.freedesktop.DBus.Introspectable.Introspect


02.18
======
1. https://jira.youview.co.uk/browse/DEVARCH-7941

Shows the requirement. The points to note:

1. about handling errors that happen during playback and not during tuning. If does when tuning,
kill CRB application.

From OIPF-DAE:

LAN connectivity problem (results in a YVM102 message being shown by the YouView UI) 	Presenting
Connecting 	PlayStateChange (playstate 1, errorState 9 - insufficient bandwidth)

LAN connectivity problem

This one is quite easy and should just consist in making ProductionVideoBroadcast listen to
Neon.Client.API / NetworkStatusChange.  The UI might need to be modified to show only a notification
instead of showing a dialogue in case the CRB app is running (TBC), and usage reporting need to be
preserved if there is any.

note: Given there is "LAN connectivity problem restored:", the above includes no connection and
timed-out one?

On demand UI req:
https://wiki.youview.co.uk/display/UXDWIP/FR+12+-+On+Demand+Playback

From CANTST-15347:
Test description:
1. Launch a piece of content from BBC application (tested with iPlayer,and iPlayer from CRB)

Actual result:
note: 4. When the app freezes and must be closed and restarted.

NB in all the above cases the YV box reports the loss of internet connection (YVM-102) when the
cable is pulled from the back of the box.

The scenarios in all cases are the same whether it is the ethernet or the WAN being disconnected.

<test-result>
The version used:
Humax DTR-T1000 T1000 H21.7.30

The version reported:
Box: Humax T1000 PRK
CDS: H20.9.0
Environment: Live

The observation:

1. run iplayer 
2. run one of contents
3. plug out a cable
4. YVM-102 is shown on tv.
5. video still runs for some time and shows waiting icon 
6. error 02100 from iplayer app saying "something are not working playing this program. ..."
7. plug it back
8. shows "youview is connected again" message on tv.
9. able to navigate iplayer app which is 'different' from the reported.

Tried 5 times and no problem. Tried once after a reboot, no problem.


02.19
======
Assigned back to the reporter to re-test.
Started on the new one, #7508, which is about runBrowser-test.sh


={============================================================================
*kt_dev_uv_task_003* task:02: DEVARCH-7508

02.20
======
kpark@wll1p04345:/data/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk$ find . -name runBrowser.sh
./bin/runBrowser.sh
kpark@wll1p04345:/data/builds/master/humax.1000/zinc-install-root/release/humax-dtr_t1000/opt/zinc-trunk$ find . -name runBrowser-test.sh
./tests/vanadium-w3c-engine/test/runBrowser-test.sh

[root@HUMAX zinc-trunk]# find . -name runBrowser* ./bin/runBrowser.sh
./devel/bin/runBrowserStandalone.sh
./tests/vanadium-w3c-engine/test/runBrowser-test.sh
[root@HUMAX zinc-trunk]# 


From runBrowser-test.sh log:

+ paramsContainStringAtPosition 0 3 -cache /tmp/client-cache -cache-size 50000000 -jar /tmp/cookies.sqlite -url 'http://youview.tv/test-player?launch_context.ui.youview.com=portal&some.test.param=some.test.param.value&test.param.spaces=param%20value%20with%20spaces' -src '
      http://youview.tv http://broadcast.example.com
      http://www.bbc.co.uk http://cdn.example.net:8080
    '
+ local stringToSearchFor=0
+ local positionToExpectStringAt=3
+ local 'stringToSearch=-cache /tmp/client-cache -cache-size 50000000 -jar /tmp/cookies.sqlite -url http://youview.tv/test-player?launch_context.ui.youview.com=portal&some.test.param=some.test.param.value&test.param.spaces=param%20value%20with%20spaces -src 
      http://youview.tv http://broadcast.example.com
      http://www.bbc.co.uk http://cdn.example.net:8080
    '
So expect to see 0 but 50000000. Why?

From runBrowser.sh

# Decide whether to turn on Qt's network cache + local storage.
cacheSize="$(lsr-config --int platform.settings.html-app-cache-size || echo 0)"

This cache size comes from external but the test script uses the 'fixed' value. mismatch.

that_generates_url_handler() {

    paramsContainStringAtPosition "0" 3 "$@"
    cacheSizeValueCorrectAtExpectedPosition=$?
}


related https://jira.youview.co.uk/browse/DEVARCH-7362 since about cache size.

The solution:

kpark@wll1p04345:~/jira/feb-7508$ diff runBrowser-test-old.sh runBrowser-test.sh 
--- runBrowser-test-old.sh	2015-02-20 14:23:37.978416274 +0000
+++ runBrowser-test.sh	2015-02-20 14:21:59.318417412 +0000
@@ -173,7 +173,8 @@ test.param.spaces=param%20value%20with%2
     paramsContainStringAtPosition "-cache-size" 2 "$@"
     cacheSizeOptionCorrectAtExpectedPosition=$?
 
-    paramsContainStringAtPosition "0" 3 "$@"
+    # paramsContainStringAtPosition "0" 3 "$@"
+    paramsContainStringAtPosition "$(lsr-config --int platform.settings.html-app-cache-size || echo 0)" 3 "$@"
     cacheSizeValueCorrectAtExpectedPosition=$?
 
     paramsContainStringAtPosition "-jar" 4 "$@"


02.23
======
DEVARCH-7508/0: runBrowser-test.sh fails on DTR-T1000

The cause of the problem is that the cache size is introduced in the runBrowser.sh but not in the
runBrowser-test.sh. Hence mismatch which cause this failure. 

This commit has the fix to have the same approach rumBrower.sh has to use the value from LSR. 

<review>
Please review the commits for [DEVARCH-7508] which on the branch [review/DEVARCH-7508/0].

1. [DEVARCH-7508: runBrowser-test.sh fails on DTR-T1000 [e4ac0e1]

[1]: https://jira.youview.co.uk/browse/DEVARCH-7508
[2]: https://git-dev.dev.youview.co.uk/?p=DEVARCH.git;a=shortlog;h=refs/heads/review/DEVARCH-7508/0
[e4ac0e1]: https://git-dev.dev.youview.co.uk/?p=DEVARCH.git;a=commit;h=e4ac0e157a900d55fa30b7c9c88a9f080b3767b1


={============================================================================
*kt_dev_uv_task_004* task:03: DEVARCH-9135

03.04
======
Assigned.
https://jira.youview.co.uk/browse/DEVARCH-9135

UI is provided two metadata APIs for events:

From the API docs: http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/index.html

<Q> CTV?

ctv.enhancemetadata.Event
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/ctv/enhancedmetadata/Event.html

ctv.linearmetadata.Event
http://moomintroll:8080/job/_Zinc.Build__master__release__Scientific-Linux-6.6-i686/lastSuccessfulBuild/artifact/as3-developer-api-docs/ctv/linearmetadata/Event.html

The latter Event type is an old API that we don't consider efficient and would ideally remove it. In
order to do this, the ctv.enhancedmetadata.Event type needs to contain all of the information that
the UI needs.

It has been noticed (by Stephen Spencer) that ctv.enhancedmetadata.Event.getSynopsis() doesn't
always return a value for some types of events. This should be investigated and fixed.

The implementation of ctv.enhancedmetadata.Event is in the file:

Uranium/Uranium.Client.System/src/metadata/SystemClientEvent.cpp


04.01
======

* 62ef094 (HEAD, origin/john.sadler/uranium-opt-1, john.sadler/uranium-opt-1) DEVARCH-9276: Uranium.Client.API: Simplify `TargetRegion`.
* 646adc9 DEVARCH-9288: Uranium.Client.System: Remove ReminderRepository pointer member from SystemClientEvent.
* 8cfaa44 DEVARCH-9287: Uranium.Client.System: Remove ServiceRepository pointer member from SystemClientEvent.
* eac309d DEVARCH-9286: Uranium.Client.System: Remove LinearAcquisition pointer member from SystemClientEvent.
* 467bc42 DEVARCH-9285: Uranium.Client.System: Remove EventRepository pointer member from SystemClientEvent.
* 500ce26 DEVARCH-9275: Uranium.Client.System: Remove `IdentifierBag`.
* 499950f DEVARCH-9274: Uranium.Client.System: Remove `SystemEventWrapper` and avoid additional copy of `Result` when constructing `SystemClientEvent`.
* b7c5176 DEVARCH-9272: Cobalt.System.Fake: Use correct ISO 8601 format when constructing event times.
* d3d85d5 DEVARCH-9271: Cobalt.System.API: Add `ResultHelpers` functions to get OD Availability & ProgrammeId fields from `Result`.
* 29c9fab  DEVARCH-9271: Uranium.Client.System: Avoid pointless copy of entire Broker ResultSet when constructing CAL ResultSet wrappers.
* 7d2a5f3 DEVARCH-9269: Uranium.Client.System: Make `SystemClientSummary` create CAL `Result` wrapper immediately in it's constructor.

* d0e695e DEVARCH-9266: Uranium.Client.System: Don't heap-allocate a copy of System API `Result` when creating Client API wrappers.

ProgrammePtr
Converter::operator()(const NS_COBALT_SYSTEM::Result& result, ProgrammePtr) const
{
    return boost::make_shared<SystemClientProgramme>(
            boost::make_shared<NS_COBALT_SYSTEM::Result>(result)
            );
}

class SystemClientProgramme : public Programme 
{
    public:
        explicit SystemClientProgramme(boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
            :scResult(sysResult)
        {}

        virtual std::string getRecordIdentifier() const
        {
            return scResult.getRecordIdentifier();
        }
        ...

    private:
            SystemClientResult scResult;
};

class SystemClientResult
{
    public:
        explicit SystemClientResult(
                boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult)
            :sysResult(sysResult)
        {}

        int64_t getValidUntil() const
        {
            return sysResult->validUntil;
        }

        std::string getRecordIdentifier() const
        {
            return sysResult->recordIdentifier;
        }

        const NS_COBALT_SYSTEM::Result& getResult() const
        {
            return *sysResult;
        }

    private:
        boost::shared_ptr<NS_COBALT_SYSTEM::Result> sysResult;
};


TO:

ProgrammePtr
Converter::operator()(const NS_COBALT_SYSTEM::Result& result, ProgrammePtr) const
{
    return boost::make_shared<SystemClientProgramme>(result);
}

class SystemClientProgramme : public Programme 
{
    public:
        explicit SystemClientProgramme(const NS_COBALT_SYSTEM::Result& sysResult)
            :scResult(sysResult)
        {}

        virtual std::string getRecordIdentifier() const
        {
            return scResult.getRecordIdentifier();
        }
        ...

    private:
            SystemClientResult scResult;
};

class SystemClientResult
{
    public:
        explicit SystemClientResult(const NS_COBALT_SYSTEM::Result& sysResult)
            : sysResult(sysResult)
        {}

        int64_t getValidUntil() const
        {
            return sysResult.validUntil;
        }

        std::string getRecordIdentifier() const
        {
            return sysResult.recordIdentifier;
        }

        const NS_COBALT_SYSTEM::Result& getResult() const
        {
            return sysResult;
        }
        ...

    private:
        NS_COBALT_SYSTEM::Result sysResult;
};

    -> LGTM. * 5c9a202 DEVARCH-9266: Uranium.Client.System: Get rid of defunct `wrapSysResult()` and `wrapSysResults()` in Converter.

    -> LGTM. * 3e896f3 DEVARCH-9265: Uranium.Client.System: Reserve vector capacity when converting System Broker results.

==============================================================================
vim:tw=100:ts=3:ft=help:norl:
