*kt_dev_01*		tw=100

aMon 13 Jan 2014 15:34:27 GMT

TODO:
- move controls in C++11.

Keywords:
{QQ} for questions to find out more
{DN} for design considerations
{BP} for best practice
{IE} for interesting example

KT KB. DEVELOPMENT.

SE

|kt_dev_seng_001|	first major hurdle in attacking a large problem
|kt_dev_seng_002|	information hiding and oop
|kt_dev_seng_003|	comments in source
|kt_dev_seng_004|	80 and 20

ISSUES and CODES
|kt_dev_prob_001| memcpy considered danger
|kt_dev_prob_002| out of index of array
|kt_dev_prob_003| double free
|kt_dev_prob_004| eval-order
|kt_dev_prob_005| squeeze() and strcat()
|kt_dev_prob_006| print ansi color 
|kt_dev_prob_007| random number {time}
|kt_dev_prob_008| elapsed time {clock}
|kt_dev_prob_009| debug printf {stdarg} {macro} {why-ellipses-dangerous} {ndebug}
|kt_dev_prob_010| macro: get max value of type


GNU CORE UTILS
|kt_dev_guti_000| gnu core util sites

GCC
|kt_dev_gcc_000|  gcc compile script
|kt_dev_gcc_001|  error: two or more data types in declaration specifiers {preprocessor} 
|kt_dev_gcc_002|  error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]
|kt_dev_gcc_003|  error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]
|kt_dev_gcc_004|  error: variable-sized object 'out' may not be initialised
|kt_dev_gcc_005|  error: expected ‘}’ at end of input
|kt_dev_gcc_006|  error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 
|kt_dev_gcc_007|  error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before
|kt_dev_gcc_100|  gcc and c++11 {how-to-use-gcc-optimisation} {gcc-profiling} {gcc-options}
|kt_dev_gcc_101|  gcc typeof
|kt_dev_gcc_102|  gcc binutil
|kt_dev_gcc_103|  gcc link and ld {cyclic-dependencies}
|kt_dev_gcc_104|  gcc comma-operator {C99}
|kt_dev_gcc_105|  gcc likely and unlikely 
|kt_dev_gcc_200|  gcc preprocessor
|kt_dev_gcc_300|  gcc gprof

C and C++

|kt_dev_lang_001|	global, file and local static	{singleton-pattern} {file-scope}
|kt_dev_lang_002|	func pointer
|kt_dev_lang_003|	#error and #warning
|kt_dev_lang_004|	post and pre inc {post-inc} {post-inc-overload} {tip}
|kt_dev_lang_005|	chaining
|kt_dev_lang_006|	compile error types
|kt_dev_lang_007|	bool type {true-and-false}
|kt_dev_lang_008|	char type
|kt_dev_lang_009|	implicit conversion {built-in-conversion} {equal-misspell}
|kt_dev_lang_010|	incomplete type {forward-declaration} {text-query-example}
|kt_dev_lang_011|	literal type
|kt_dev_lang_012|	array {ref-to-array} {size-of-operator-caveat} {sizeof-operator}
|kt_dev_lang_013|	allman style 

|kt_dev_cpp_000|	operator-precedence
|kt_dev_cpp_001|	virtual inheritance (interview) {virtual-base-class}
|kt_dev_cpp_002|	pointer vs. reference (interview)
|kt_dev_cpp_003|	ctor and copy controls {pass-by-reference-to-const} {default-arg} {constructor-initializers}
|kt_dev_cpp_004|	copy-controls when use dyn resource	{the-rule-of-three} {value-like} {preventing-copies} {self-assign}
|kt_dev_cpp_005|	converting ctor 			{class-type-conversion} {explicit-keyword}
|kt_dev_cpp_006|	swap							{copy-and-swap-idiom} {pimpl-idiom}
|kt_dev_cpp_007|	function matching and overload 	{scope-in-inheritance}
|kt_dev_cpp_008|	const and conversion		{const-on-iterators} {equal-misspell} 
|kt_dev_cpp_009|	undefined result and a temp-object {temp-object-in-return} {cost-of-temp-object}
|kt_dev_cpp_010|	def args
|kt_dev_cpp_011|	inline {empty-ctor-represenstaion}
|kt_dev_cpp_012|	const member func	{bitwise-const} {mutable}
|kt_dev_cpp_013|	when use reference {called-by-reference} 
|kt_dev_cpp_014|	decltype, typedef, and using {class-vs-struct} 
|kt_dev_cpp_015|	declaration and definition
|kt_dev_cpp_016|	statement {division-and-modulus} {switch-under-the-hood}
|kt_dev_cpp_017|	static-members and class const	{class-method} {class-const}
|kt_dev_cpp_018|	dtor {non-virtual-destruction-problem} {how-virtual-works}
|kt_dev_cpp_019|	exception {problem-of-exception-in-dtor} {exception-safe}
|kt_dev_cpp_020|	<empty>
|kt_dev_cpp_021|	op overload				{member-or-non-member} {function-object}
|kt_dev_cpp_022|	inheritance {static-type} {subobject-and-derived-to-base-conversion} {base-class-pointer-container} {RTTI}
|kt_dev_cpp_023|	override		{override-keyword} {dynamic-binding} {default-arg-in-virtual}
|kt_dev_cpp_024|	ABC {refactoring}
|kt_dev_cpp_025|	template {debug-delete}
|kt_dev_cpp_026|	enum	{enum-hack}
|kt_dev_cpp_027|	volatile
|kt_dev_cpp_028|	namespace  {unnamed-namespace}
|kt_dev_cpp_029|	nested class
|kt_dev_cpp_030|	case study: framework {tizen-case}
|kt_dev_cpp_031|	wrapper
|kt_dev_cpp_032|	case study: porting layer

STL 

|kt_dev_stl_000|	useful links {stl-design-rationale}
|kt_dev_stl_001|	seq-containers {trade-offs}
|kt_dev_stl_005|	assoc-containers {insert-erase} {key-type-requirement} {use-typedef} 
|kt_dev_stl_002|	vector
|kt_dev_stl_003|	list
|kt_dev_stl_004|	adaptors {stack} {queue}
|kt_dev_stl_006|	iterator	{category} {insert-method} {invalidated-iterators}	{estl-009}
|kt_dev_stl_007|	iterator: inserter {algo-copy} {stream-iterator}
|kt_dev_stl_008|	algorithm
|kt_dev_stl_009|	algorithm: sort, unique
|kt_dev_stl_010|	algorithm: predicate and lambda
|kt_dev_stl_011|	containers: restrictions on element type
|kt_dev_stl_012|	containers: copy init
|kt_dev_stl_013|	algorithm: copy
|kt_dev_stl_014|	<empty>
|kt_dev_stl_015|	string: stringstream {inefficient-concatnation}
|kt_dev_stl_016|	io stream
|kt_dev_stl_017|	emplace_* member
|kt_dev_stl_018|	smart pointer, RAII {factory-func} {auto-lock}
|kt_dev_stl_019|	new and delete {default-and-value-init} {placement-new} {allocator}
|kt_dev_stl_020|	gcc stl impl files
|kt_dev_stl_021|	algorithm: remove-erase idiom
|kt_dev_stl_022|	iterator: external and internal


SYSTEM 

|kt_dev_sys_001|	<empty>
|kt_dev_sys_002|	endianess
|kt_dev_sys_003|	to check endianess at runtime
|kt_dev_sys_004|	to check address alignment
|kt_dev_sys_005|	two's complement
|kt_dev_sys_007|	stack (MIPS)
|kt_dev_sys_008|	stack asm example (MIPS)
|kt_dev_sys_009|	for and while asm (MIPS)
|kt_dev_sys_010|	POR(power on reset) (MIPS)
|kt_dev_sys_011|	instruction and addressing (MIPS)
|kt_dev_sys_012|	dump_stack
|kt_dev_sys_013|	<empty>
|kt_dev_sys_014|	newlines between dos and linux


EFFECTIVE C++ 3RD

|kt_dev_ecpp_001|	01: federation of language
|kt_dev_ecpp_002|	02: no to preprocessor
|kt_dev_ecpp_003|	09: no virtual call in ctor or dtor {pass-log-to-base-class} {static-member-example}
|kt_dev_ecpp_004|	18: hard to use incorrectly 
|kt_dev_ecpp_005|	23: prefer non-member non-friend func {encapsulation}
|kt_dev_ecpp_006|	26: postpone variable definitions
|kt_dev_ecpp_007|	28: avoid returning handles to object internals
|kt_dev_ecpp_008|	31: minimize compilation dependencies	{pimpl-idiom} {interface-class} {factory-pattern}
|kt_dev_ecpp_009|	32: public inheritance. is-a model 
|kt_dev_ecpp_010|	34: interface and implementation inheritance
|kt_dev_ecpp_011|	35: alternatives to virtual func {template-pattern} {strategy-pattern}
|kt_dev_ecpp_012|	38: composition. has-a model {private-inheritance} {is-implemented-in-terms-of}
|kt_dev_ecpp_013|	22: data member must be private
|kt_dev_ecpp_014|	27: minimize casting {named-cast}
|kt_dev_ecpp_015|	30: ins and outs of inlining 


MORE EFFECTIVE C++ 1ST, 1996, 25TH PRINTING

|kt_dev_mecpp_001| 16: 80-20 rule and profiler
|kt_dev_mecpp_002| 17: lazy evaluation
|kt_dev_mecpp_003| 18: over-eager evaluation
|kt_dev_mecpp_004| 24: virtual cost {how-vtable-works}
|kt_dev_mecpp_005| 25: reference-counting
|kt_dev_mecpp_006| 28: log entry
|kt_dev_mecpp_007| 34: combine C and C++
|kt_dev_mecpp_008| 32: program in the future tense

EFFECTIVE STL 3RD

|kt_dev_estl_001|	design: 02: illusion of container-independent code


BLUSHES

|kt_dev_blush_001|	accessing neighbors in array


|kt_dev_uml_001|	   aggragation

|kt_dev_reference|	references


# ============================================================================
#{

==============================================================================
*kt_dev_seng_001*	first major hurdle in attacking a large problem

is deciding exactly what the problem because necessary 

1) to translate vague goals
2) contradictory requests
3) perhaps unstated desires into a precisely formulated project that can be programmed.


==============================================================================
*kt_dev_seng_002*	information hiding and oop 

<information-hiding> whether is done by sepration beteen interface and implementation, or by having
module or #defines, has

1) changes of implementation
2) clarity of program
3) top-down design

{oop}

The key ideas in OOP are data abstraction, inheritance, and dynamic binding.

1> The <data-abstration> can define classes that separate interface from implementation.

2> The <inheritance> can define classes that model the relationships among similar types.

Conceptually, neither the kind of device nor the character size affects the IO operations we want to
perform. For example, we would like to use >> to read data regardless of whether we are reading a
console window, a disk file, or a string. Similarly, we would like to use that operator regardless
of whether the characters we read fit in a char or require a wchar_t.

The library lets us ignore the differences among these different kinds of streams by using
inheritance. As with templates (§ 3.3, p. 96), we can use classes related by inheritance without
understanding the details of how inheritance works

inheritance lets us say that a particular class inherits from another class. Ordinarily, we can use
an object of an inherited class as if it were an object of the same type as the class from which it
inherits.

3> <dynamic-binding> can use objects of these types while ignoring the details of how they differ.


==============================================================================
*kt_dev_seng_003*	comments in source

why?

1) no gurantee that only one person maintain whole source tree. works as a team. no
lifetime employment. no unlimited memory.

2) code speaks themselves? not for big and real system which has history such as filed
fixes. project/field specific requirement and one line worth a week long dev trip. 

Should have comment or reference for more detail or full history.


==============================================================================
*kt_dev_seng_004*	80 and 20

EC++ p139.

Typical program spends 80% of its time excuting only 20% of its code. Your goal as a
software developer is to identify the 20% of your code that can increase your program's
overall performance.

From MEC++16:

The 80e-20 R8ule0-20 rule states that 80 percent of a program's resources are used by about 20
percent of the code: 80 percent of the runtime is spent in approximately 20 percent of the code; 80
percent of the memory is used by some 20 percent of the code; 80 percent of the disk accesses are
performed for about 20 percent of the code; 80 percent of the maintenance effort is devoted to
around 20 percent of the code.  The rule has been repeatedly verified through examinations of
countless machines, operating systems, and applications. The 80-20 rule is more than just a catchy
phrase; it's a guideline about system performance that has both wide applicability and a solid
empirical basis.


# ============================================================================
#{

==============================================================================
*kt_dev_prob_001*	memcpy considered danger

Seen on NDS MW issue

MW_Process crash with core dump in SIM_dbc_query_ReadProgrammeInstanceInfo (during memcpy) 

# void *memcpy(void *dest, const void *src, size_t n);
(void)memcpy((void*)&obj_array[offset].sort_title[0], (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

# source when crashed
0x1d8dfec: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x1d8dffc: 0xc009 0x0 0x0 0x0

# dest
x/40a obj_array[0].sort_title
0x204eb20: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x204eb30: 0x0 0x0 0x0 0x0

# solution
strncpy(&obj_array[offset].sort_title[0], (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

This will ensure only the length of the value.text is copied (destination then padded out
with nulls) or a maximum of 40 is copied if the source string is over 40.

note. so it's more of accessing out of index; that's src is smaller than length.


==============================================================================
*kt_dev_prob_002*	out of index of array

when acces out of index of array, 'undefined' so sometimes work or sometimes not.


# 01
#

int g_arr[3];

int main(int argc, char* argv[])
{
    if( g_arr[5] == 0 )
        printf("idx 5 is false\n");
    else
        printf("idx 5 is true\n");
                                                                                                                                
}

$ ./a.out 
idx 5 is false


# 02
#

/* the issue was that index(dbConId) was -1(0xFFFFFFFF used as a handle) and worked
 * sometimes. But crashed
 */

static MFS_STATUS MFSDBWRAP_GetDbContext(MFS_STORAGE_DB_CONTEXT_ID            dbConId,
										 MFS_DB_CONTEXT						**ppContext)
{
    MFS_STATUS					mfsStatus = MFS_STATUS_OK;

    XDEBUG_DEFINE_FUNC_INFO("MFSDBWRAP_GetDbContext");
	XDEBUG_TRACE2_1("start: dbConId=%d", dbConId);
    	

	/* the dbConId is the index into the db context array,
	   so we can directly access it.
	   First check that the context is really in use. 
	   If not this is a bug.
	*/
	if (db_contexts_array[dbConId].bInUse == XFALSE)
	{
		XDEBUG_ERR2_0("No free slots for contextes.  Returning the first one");
		mfsStatus = MFS_STATUS_ERROR;
	}
	else
	{
		*ppContext = &db_contexts_array[dbConId];
	}
	
    return mfsStatus;
}


==============================================================================
*kt_dev_prob_003*	double free

when do double free under pc linux that uses glibc, make a core as below but run on a
embedded linux that uses uclibc, shows no problem.

$ ./a.out 
pstr = 
this is..
*** glibc detected *** ./a.out: double free or corruption (fasttop): 0x000000001834b010 ***
======= Backtrace: =========
/lib64/libc.so.6[0x393c07230f]
/lib64/libc.so.6(cfree+0x4b)[0x393c07276b]
./a.out[0x40062f]
/lib64/libc.so.6(__libc_start_main+0xf4)[0x393c01d994]
./a.out[0x4004b9]
======= Memory map: ========
00400000-00401000 r-xp 00000000 fd:02 37781700                           /data/home/NDS-UK/parkkt/work/a.out
00600000-00601000 rw-p 00000000 fd:02 37781700                           /data/home/NDS-UK/parkkt/work/a.out
1834b000-1836c000 rw-p 1834b000 00:00 0                                  [heap]
393bc00000-393bc1c000 r-xp 00000000 fd:00 3538948                        /lib64/ld-2.5.so
393be1b000-393be1c000 r--p 0001b000 fd:00 3538948                        /lib64/ld-2.5.so
393be1c000-393be1d000 rw-p 0001c000 fd:00 3538948                        /lib64/ld-2.5.so
393c000000-393c14e000 r-xp 00000000 fd:00 3538955                        /lib64/libc-2.5.so
393c14e000-393c34d000 ---p 0014e000 fd:00 3538955                        /lib64/libc-2.5.so
393c34d000-393c351000 r--p 0014d000 fd:00 3538955                        /lib64/libc-2.5.so
393c351000-393c352000 rw-p 00151000 fd:00 3538955                        /lib64/libc-2.5.so
393c352000-393c357000 rw-p 393c352000 00:00 0 
394b200000-394b20d000 r-xp 00000000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
394b20d000-394b40d000 ---p 0000d000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
394b40d000-394b40e000 rw-p 0000d000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
2ba0f68d2000-2ba0f68d4000 rw-p 2ba0f68d2000 00:00 0 
2ba0f68ec000-2ba0f68ee000 rw-p 2ba0f68ec000 00:00 0 
7fff1e6e4000-7fff1e6f9000 rw-p 7ffffffe9000 00:00 0                      [stack]
ffffffffff600000-ffffffffffe00000 ---p 00000000 00:00 0                  [vdso]
Aborted


==============================================================================
*kt_dev_prob_004*	eval-order

while (fgets(line, 256, file))
{
        sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], &Highs[i], &Lows[i++]);
}

Review comment from Ian Park.
You made big mistake here. Increasing 'i' in the parameter is very dangerous. The evaluation order
of function parameter is undefined in spec and usually they are evaluated in reverse order in most
of compilers. Therefore 'i' will be increased firstly and the data for Stocks,Intervals,Volumes and
Highs will be stored in the next row. The data will be totally mangled. Increase 'i' in the
separated line.


==============================================================================
*kt_dev_prob_005*	squeeze() and strcat()

From C prog language,

All these are example where <post-inc> version is required.

/* squeeze: delete all c from string s */
void squeeze(char s[], int c)
{
	int i, j;

	while( i = j = 0; s[i] != '\0'; i++ )
		  if( s[i] != c )
				s[j++] = s[i];

	s[j] = '\0';
}

/* strcat: concatenate t to end of s; s must be big enough 
 * note lib version returns a pointer of resulting string
 */
void strcat( char s[], char t[] )
{
	int i, j;

	i = j = 0;
	while( s[i] != '\0' )	/* find end of s */
		  i++;
	
	while( (s[i++] = t[j++]) != '\0' )	/* copy t */
		 ;
}


==============================================================================
*kt_dev_prob_006*	print ansi color 


# dark blue
printf("\033[34m CR-1048: NVRAM Retry Byte set to 0x%X \033[0m \n",nvram_retry_bytes);


==============================================================================
*kt_dev_prob_007*	random number

#include <stdlib.h>

The seed

void Randomize()
{
	 srand( (unsigned int) (time(NULL)%10000));
}

time() returns the number of seconds elapsed since 00:00:00 GMT, Jan. 1, 1970. 
time_t time(time_t *timeptr); 

int PoissonRandom( double expectedvalue )
{
	 int n = 0;
	 double limit;
	 double x;

	 limit = exp(-expectedvalue);
	 x = rand()/(double) INT_MAX;
	 while( x > limit )
	 {
		  n++;
		  x *= rand()/(double) INT_MAX;
	 }

	 return n;
}


==============================================================================
*kt_dev_prob_008*	elapsed time 

#include <time.h>

float Time(int flag)
{
	 static clock_t start; // [note] static
	 clock_t end;

	 if( flag == START )
	 {
		  start = clock();
		  return 0.0;
	 }
	 else
	 {
		  end = clock();
		  return (end-start) / CLK_TCK; // or CLOCK_PER_SEC
	 }
}

void Usuage()
{
	 float elapsedtime;

	 Time(START);

	 ...

	 elapsedtime = Time(END);

	 printf("elapsed time to complete %d searches is %f seconds \n", searchcount, elapsedtime );
	 ...
}


==============================================================================
*kt_dev_prob_009*	debug printf 

{ndebug}
The assert macro is defined in cassert header. It depends on a preprocessor varaible named NDEBUG.
If NDEBUG is defined, assert do nothing. By default, it's not defined.


{useful-macros}
#define abs(n) ((n) < 0 ? -(n) : (n))

#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

// a is array
#define NELEMENTS(a) (sizeof(a)/sizeof(*(a)))


{variable-arguments}
The va_arg, va_copy, va_end, and va_start macros provide a portable way to access the arguments to a
function when the function takes a variable number of arguments. There are two versions of the
macros: The macros defined in STDARG.H conform to the ISO C99 standard; the macros defined in
VARARGS.H are deprecated but are retained for backward compatibility with code that was written
before the ANSI C89 standard. 

<from-linux>
STDARG(3) Linux Programmer's Manual

NAME
stdarg, va_start, va_arg, va_end, va_copy - variable argument lists

SYNOPSIS
 #include <stdarg.h>

 void va_start(va_list ap, last);
 type va_arg(va_list ap, type); // [KT] see type
 void va_end(va_list ap);
 void va_copy(va_list dest, va_list src);

DESCRIPTION

A function may be called with a [varying-number] of arguments of [varying-types]. The include file
<stdarg.h> declares a type va_list and defines three [macros] for stepping through a list of arguments
whose number and types are not known to the called function.

The called function must declare an object of type va_list which is used by the macros va_start(),
va_arg(), and va_end().

va_start() 

The va_start() macro initializes [ap] for subsequent use by va_arg() and va_end(), and must be called
first.

The argument last is the name of the last argument before the variable argument list, that is, the
last argument of which the calling function knows the type.

Because the address of this argument may be used in the va_start() macro, it should not be declared
as a register variable, or as a function or an array type.

va_arg()

The va_arg() macro expands to an expression that has the type and value of the next argument in the
call. The  argument ap is the va_list ap initialized by va_start(). Each call to va_arg() modifies
ap so that the next call returns the next argument. The argument type is a type name specified so
that the type of a pointer to an object that has the specified type can be obtained simply by
adding a * to type.

The first use of the va_arg() macro after that of the va_start() macro returns the argument after
last. Successive invocations return the values of the remaining arguments.

If there is no next argument, or if type is not compatible with the type of the actual next argument
(as promoted according to the default argument promotions), random errors will occur. ~

If ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the
return of that function.

va_end()

Each invocation of va_start() must be matched by a corresponding invocation of va_end() in the same
function. After the call va_end(ap) the variable ap is undefined. Multiple traversals of the list,
each bracketed by va_start() and va_end() are possible. va_end() may be a macro or a function.

example

#include <iostream>
#include <cstdarg>

void argprint(int num_args, ...)
{
  va_list ap;

  va_start(ap, num_args);
  for( int i = 0; i < num_args; i++)
  {
    std::cout << "arg:" << i << " is " << va_arg(ap, int) << std::endl;
  }

  va_end(ap);
}

int main()
{
  std::cout << "--{ main " << std::endl;

  argprint( 3, 10, 20, 30 );

  std::cout << "--} main " << std::endl;
}

The function foo takes a string of format characters and prints out the argument associated with
each format character based on the type.

#include <stdio.h>
#include <stdarg.h>

void
foo(char *fmt, ...)
{
  va_list ap;
  int d;
  char c, *s;

  va_start(ap, fmt);
  while (*fmt)					// [KT] null is a termination condition
      switch (*fmt++) {    // [KT] see ++
      case 's':              /* string */
          s = va_arg(ap, char *);
          printf("string %s\n", s);
          break;
      case 'd':              /* int */
          d = va_arg(ap, int);
          printf("int %d\n", d);
          break;
      case 'c':              /* char */
          /* need a cast here since va_arg only
             takes fully promoted types */
          c = (char) va_arg(ap, int);
          printf("char %c\n", c);
          break;
      }
  va_end(ap);
}


{snprintf-and-vsnprintf}
#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

#include <stdarg.h>

int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);

The functions vprintf(), vfprintf(), vsprintf(), vsnprintf() are equivalent to the functions
printf(), fprintf(), sprintf(), snprintf(), respectively, except that they are called with a
<va_list> instead of a variable number of arguments.  These  functions  do not call the va_end
macro. Because they invoke the va_arg macro, the value of ap is undefined after the call.  See
stdarg(3).

The functions snprintf() and vsnprintf() do not write more than size bytes (including the
terminating null byte ('\0')). If the output was truncated due to this limit then the return value
is the number of characters (excluding the terminating null byte) which would have been written to
the final string if enough space had been available. Thus, a return value of size or more means that
the output was truncated.  (See also below under NOTES.) If an output error is encountered, a
negative value is returned.


{swallowing-the-semicolon}
http://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html#Swallowing-the-Semicolon

Often it is desirable to define a macro that expands into a compound statement. Consider, for
example, the following macro, that advances a pointer (the argument p says where to find it) across
whitespace characters:

#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
 while (p < lim) {            \
   if (*p++ != ' ') {         \
     p--; break; }}}

Here backslash-newline is used to split the macro definition, which must be a single logical line,
so that it resembles the way such code would be laid out if not part of a macro definition.

A call to this macro might be SKIP_SPACES (p, lim). Strictly speaking, the call expands to a
compound statement, which is a complete statement with no need for a semicolon to end it. However,
since it looks like a function call, it minimizes confusion if you can use it like a function call,
writing a semicolon afterward, as in SKIP_SPACES (p, lim);

This can cause trouble before else statements, because the semicolon is actually a null statement.
Suppose you write

if (*p != 0)
 SKIP_SPACES (p, lim);
else ...

The presence of two statements-the compound statement and a null statement-in between the if
condition and the else makes [invalid] C code.

The definition of the macro SKIP_SPACES can be altered to solve this problem, using a do ... while
statement. Here is how:

#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
    while (p < lim) {            \
      if (*p++ != ' ') {         \
        p--; break; }}}          \
while (0)

Now SKIP_SPACES (p, lim); expands into

do {...} while (0);

which is one statement. The loop executes exactly once; most compilers generate no extra code for
it. 

 [KT] There should be NO spaces after \;otherwise compile error.


{stringification}
http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification

Sometimes you may want to convert a macro argument into a string constant. Parameters are not
replaced inside string constants, but you can use the '#' preprocessing operator instead. When a
macro parameter is used with a leading '#', the preprocessor replaces it with the literal text of
the actual argument, converted to a string constant. Unlike normal parameter replacement, the
argument is [not-macro-expanded-first]. This is called stringification.

There is no way to combine an argument with surrounding text and stringify it all together. Instead,
you can write a series of adjacent string constants and stringified arguments. The preprocessor will
replace the stringified arguments with string constants. The C compiler will then combine all the
adjacent string constants into one long string.

Here is an example of a macro definition that uses stringification:

     #define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

     WARN_IF (x == 0);
          ==> do { if (x == 0)
                fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);

The argument for EXP is substituted once, as-is, into the if statement, and once, stringified, into
the argument to fprintf. If x were a macro, it would be expanded in the if statement, but not in the
string.

The do and while (0) are a kludge to make it possible to write WARN_IF (arg);, which the resemblance
of WARN_IF to a function would make C programmers want to do; see Swallowing the Semicolon.

Stringification in C involves more than putting double-quote characters around the fragment. The
preprocessor backslash-escapes the quotes surrounding embedded string constants, and all backslashes
within string and character constants, in order to get a valid C string constant with the proper
contents. Thus, stringifying p = "foo\n"; results in "p = \"foo\\n\";". However, backslashes that
are not inside string or character constants are not duplicated: '\n' by itself stringifies to "\n".

All leading and trailing whitespace in text being stringified is ignored. Any sequence of whitespace
in the middle of the text is converted to a single space in the stringified result. Comments are
replaced by whitespace long before stringification happens, so they never appear in stringified
text.

There is no way to convert a macro argument into a character constant.

If you want to stringify [the-result-of-expansion] of a macro argument, you have to use [two-levels]
of macros.

#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
    ==> "foo"  // [KT] is not "4" because not macro-expanded
xstr (foo)
    ==> xstr (4)
    ==> str (4)
    ==> "4"

s is stringified when it is used in str, so it is not macro-expanded first. But s is an ordinary
argument to xstr, so it is completely macro-expanded before xstr itself is expanded (see Argument
Prescan). Therefore, by the time str gets to its argument, it has already been macro-expanded. 

#include <iostream>

#define PRINT_TRUE true

#define PRINT_STRING(exp) \
   do { \
      std::cout << "arg:" << #exp << std::endl; \
      std::cout << "arg:" << exp << std::endl; } \
   while(0)

#define XPRINT_STRING(s) PRINT_STRING(s)

int main()
{
	std::cout << "--{ main " << std::endl;

   PRINT_STRING(true);
   XPRINT_STRING(true);

	std::cout << "--} main " << std::endl;
}

arg:PRINT_TRUE		// stringified but not expanded
arg:1					// expanded
arg:true				// expanded before stringified
arg:1:				// expanded


<example-one>

Although macro expansion does not occur within a quoted string, the text of the macro arguments can
be quoted and treated as a string literal by using the "#" directive (also known as the "Stringizing
Operator"). For example, with the macro

#define QUOTEME(x) #x

the code

printf("%s\n", QUOTEME(1+2));

will expand to

printf("%s\n", "1+2");

This capability can be used with automatic string literal concatenation to
make debugging macros. For example, the macro in

#define dumpme(x, fmt) printf("%s:%u: %s=" fmt, __FILE__, __LINE__, #x, x)
 
int some_function() {
	int foo;
	/* a lot of complicated code goes here */
	dumpme(foo, "%d");
	/* more complicated code goes here */
}

would print the name of an [expression] and its value, along with the file name and the line number.

<example-two>

#define KT_CREATE(value)	JPA_CREATE( #value, value)

void JPA_CREATE(const char* vname, int value)
{
  printf("JPA_CREATE: value=%s value=%d...\n", vname, value );
}

int main(int argc, char *argv[])
{
	 int val = 3;
	 int is_this_my_own = 4;

	 KT_CREATE(val);
	 KT_CREATE(is_this_my_own);

	 return;
}

output:
JPA_CREATE: value=val value=3...
JPA_CREATE: value=is_this_my_own value=4...


{variadic-macros}

http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html

A macro can be declared to accept a variable number of arguments much as a function can. The syntax
for defining the macro is similar to that of a function. Here is an example:

     #define eprintf(...) fprintf (stderr, __VA_ARGS__)

This kind of macro is called [variadic]. When the macro is invoked, all the tokens in its argument
list after the last named argument (this eprintf macro has none), including any commas, become the
variable argument. This sequence of tokens replaces the identifier __VA_ARGS__ in the macro body
wherever it appears. Thus, we have this expansion:

     eprintf ("%s:%d: ", input_file, lineno)
          ==>  fprintf (stderr, "%s:%d: ", input_file, lineno)

The variable argument is completely macro-expanded before it is inserted into the macro expansion,
just like an ordinary argument. You may use the '#' and '##' operators to stringify the variable
argument or to paste its leading or trailing token with another token. (But see below for an
important special case for '##'.)

If your macro is complicated, you may want a more [descriptive-name] for the variable argument than
__VA_ARGS__. CPP permits this, as an extension. You may write an argument name immediately before
the '...'; that name is used for the variable argument. The eprintf macro above could be written

     #define eprintf(args...) fprintf (stderr, args)

using this extension. You cannot use __VA_ARGS__ and this extension in the same macro.
 
<possible-problem>

You can have named arguments as well as variable arguments in a variadic macro. We could define
eprintf like this, instead:

     #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)

This formulation looks more descriptive, but unfortunately it is [less-flexible]: you must now
supply at [least-one-argument] after the format string. In standard C, you cannot omit the comma
separating the named argument from the variable arguments. Furthermore, if you leave the variable
argument empty, you will get a [syntax-error], because there will be an extra comma after the format
string.

     eprintf("success!\n", );
          ==> fprintf(stderr, "success!\n", );

GNU CPP has a pair of extensions which deal with this problem. First, you are allowed to leave the
variable argument out entirely:

     eprintf ("success!\n");
          ==> fprintf(stderr, "success!\n", );

 [KT] not works in 4.6 G++. 

Second, the '##' token paste operator has a special meaning when placed between a comma and a
variable argument. If you write

     #define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

and the variable argument is left out when the eprintf macro is used, then the comma before the '##'
will be deleted. This does not happen if you pass an empty argument, nor does it happen if the token
preceding '##' is anything other than a comma.

     eprintf ("success!\n")
          ==> fprintf(stderr, "success!\n");

 [KT] this works in 4.6 G++.

The above explanation is ambiguous about the case where the only macro parameter is a variable
arguments parameter, as it is meaningless to try to distinguish whether no argument at all is an
empty argument or a missing argument. In this case the C99 standard is clear that the comma must
remain, however the existing GCC extension used to swallow the comma. So CPP retains the comma when
conforming to a specific C standard, and drops it otherwise.

Variadic macros are a new feature in C99. GNU CPP has supported them for a long time, but only with
a named variable argument ('args...', not '...' and __VA_ARGS__). If you are concerned with
portability to previous versions of GCC, you should use only named variable arguments. On the other
hand, if you are concerned with portability to other conforming implementations of C99, you should
use only __VA_ARGS__.

Previous versions of CPP implemented the comma-deletion extension much more generally. We have
restricted it in this release ( [KT] version? ) to minimize the differences from C99. To get the
same effect with both this and previous versions of GCC, the token preceding the special '##' must
be a comma, and there must be white space between that comma and whatever comes immediately before
it:

     #define eprintf(format, args...) fprintf (stderr, format , ##args)


{case-example-one}

Use:

MHEGDebugInfo(eMHVdsm, "_mhvDsmEventCreate %d\n", num);

#if ...

 [KT] see debug output to use both module or single module(mhegdebug).

#define MHEGDebugInfo(comp, ...) {BP_PRINT(MHEGDebugCompToBPComp(comp), CCDebugBP::INFO, __VA_ARGS__);\
                                  MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__); }
...

#define MHEGOnlyDebugInfo(comp, ...) (MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
...

#else

#define MHEGDebugInfo(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugDebug(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelDebug, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugWarning(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelWarning, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugMajor(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelMajor, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugFatal(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelFatal, __FUNCTION__, __VA_ARGS__))

#endif

void MHEGDebugTrace(MHEGComponent comp, MHEGLevel level, const char* functionName, ...)
{
  // Always send to BP print, at least for now.
  if ((s_traceLevels[comp] >= level) && (s_traceLevels[comp] < eMHEGLevelOff))
  {
      va_list ap;
      va_start(ap, functionName);
      char *message = va_arg(ap, char*);
      output(comp, level, functionName, message, ap);
      va_end(ap);
  }
}

#define LINE_LIMIT 1024
static char temp_buffer[LINE_LIMIT + 1]; // Limit all strings to LINE_LIMIT

// [KT] here string is fmt
//
void output(MHEGComponent comp, MHEGLevel level, const char* function, const char* string, va_list arg)
{
   AUTOLOCK();

   // TODO, add support for timestamp.
   // Check for space
   // Construct final string
   long int tick = PCTime::Tick();

   // [KT] #define SNPRINTF snprintf
   int pos = SNPRINTF(temp_buffer, LINE_LIMIT, "[%ld:%ld][%s][%s][%s] ", 
      tick/1000, tick%1000, s_names[comp], s_traceLevelName[level], function);

   // [KT] string is format
   size_t len = vsnprintf(temp_buffer + pos, LINE_LIMIT - pos - 1, string, arg) + pos;
   if (temp_buffer[len - 1] != '\n')
   {
     temp_buffer[len] = '\n';
     len++;
     temp_buffer[len] = '\0';
   }

   BP_PRINTR(CCDebug::DEFAULT, CCDebugBP::INFO, temp_buffer);
}


Tried to use macro only to use frintf but seems not a solution because no way to build "format"
properly. Here get is ["fmt" __LINE__, __FUNC__, "fmt", args... ]

#define MHEGDebugInfo(comp, ...) TLOG("[%d:%s]\n",  __LINE__,  __PRETTY_FUNCTION__, __VA_ARGS__)
#define TLOG(...) fprintf( stderr, __VA_ARGS__)


{case-example-two}

From Tizen:

__pServiceAppImpl is pointer from creating objcets.

/*
 * @param[in]	NID			The Tizen namespace
 * @param[in]	condition		The condition that is expected to be true
 * @param[in]	r			The last result to set
 * @param[in]   ...			The message to display
 */

SysTryReturnResult(NID_APP, __pServiceAppImpl, E_OUT_OF_MEMORY, "[E_OUT_OF_MEMORY] Insufficient memory.");

#ifndef unlikely
#define unlikely(x)  __builtin_expect(!!(x), 0)    // see {likey-and-unlikely}
#endif

#define SysTryReturnVoidResult(NID, condition, r, ...)	\
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			return;	\
		} \
	} while (0);

#define SysLogException(NID, r, ...)               SysLogExceptionInternal(NID, r, __PRETTY_FUNCTION__, 
__LINE__, __VA_ARGS__)


void
SysLogExceptionInternal(unsigned long nid, result r, const char* pFunction, int lineNumber, 
const char* pFormat, ...)
{
	va_list args;

	SetLastResult(r);

	if (!logInfo.platformExceptionEnabled)
	{
		return;
	}

	va_start(args, pFormat);

	__PrintSysLog(static_cast<_LogType>(LOG_EXCEPTION), static_cast<LogID>(nid), pFunction, lineNumber, 
	pFormat, args);

	va_end(args);
}

void __PrintSysLog(_LogType type, LogID id, const char* pFunction, int lineNumber, const char* pFormat, 
va_list args)
{
	if (!iniLoaded)
	{
		__InitializeLogInfo();
	}

	if (!__GetEnableInfo(static_cast<LogID>(id)))
	{
		return;
	}

	char logBody[LOG_LEN_MAX];
	snprintf(logBody, LOG_LEN_MAX, "%s(%d) > %s", pFunction, lineNumber, pFormat);
	logBody[LOG_LEN_MAX -1] = '\0';

	char logTag[LOG_MODULE_NAME_LEN_MAX];

	snprintf(logTag, LOG_MODULE_NAME_LEN_MAX, "%s", __GetModuleName(static_cast<LogID>(id)));
	logTag[LOG_MODULE_NAME_LEN_MAX - 1] = '\0';

	switch (type)
	{
	case static_cast<_LogType>(LOG_INFO):
		LOG_VA(LOG_INFO, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_DEBUG):
		LOG_VA(LOG_DEBUG, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_EXCEPTION):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_USER):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	default:
		LOG_VA(LOG_DEBUG, LOG_TAG_NULL, logBody, args);
		break;
	}
}

#ifndef LOG_VA
#define LOG_VA(priority, tag, fmt, args) \
    vprint_log(D##priority, tag, fmt, args)
#endif

#define vprint_log(prio, tag, fmt...) \
	__dlog_vprint(LOG_ID_MAIN, prio, tag, fmt)


{case-example-try-catch}

result
ServiceApp::Execute(ServiceAppInstanceFactory pServiceAppFactory, const IList* pArguments)
{
	r = pAppImpl->Construct(pArguments);
	SysTryCatch(NID_APP, !IsFailed(r), r = E_SYSTEM, E_SYSTEM, "[E_SYSTEM] %s.", GetErrorMessage(r));
CATCH:
	delete pServiceApp;

	return r;
}

#define SysTryCatch(NID, condition, expr, r, ...) \
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			expr; \
			goto CATCH;	\
		} \
	} while (0);


{case-example-two}

_INFO("main:_terminate:leave\n");

#ifndef _ERR
#define _ERR(fmt, args...) LOGE("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _DBG
#define _DBG(fmt, args...) LOGD("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _INFO
#define _INFO(fmt, args...) LOGI("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)		[KT] multi-level
#endif

#ifndef LOGI
#define LOGI(...) ((void)LOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOGE
#define LOGE(...) ((void)LOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOG
#define LOG(priority, tag, ...) \
	print_log(D##priority, tag, __VA_ARGS__)
#endif

#define print_log(prio, tag, fmt...) \
	__dlog_print(LOG_ID_MAIN, prio, tag, fmt)

int __dlog_vprint(log_id_t log_id, int prio, const char *tag, const char *fmt, va_list ap)
{
    char buf[LOG_BUF_SIZE];

    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);

    return write_to_log(log_id, prio, tag, buf);
}

int __dlog_print(log_id_t log_id, int prio, const char *tag, const char *fmt, ...)
{
    va_list ap;
    char buf[LOG_BUF_SIZE];

    va_start(ap, fmt);
    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
    va_end(ap);

    return write_to_log(log_id, prio, tag, buf);
}

static int __write_to_log_kernel(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
	ssize_t ret;
	int log_fd;
	struct iovec vec[3];

	if( log_id < LOG_ID_MAX )
		log_fd = log_fds[log_id];
	else
		return -1; // for TC

	if (!tag)
		  tag = "";

	vec[0].iov_base	= (unsigned char *) &prio;
	vec[0].iov_len	= 1;
	vec[1].iov_base	= (void *) tag;
	vec[1].iov_len	= strlen(tag) + 1;
	vec[2].iov_base	= (void *) msg;
	vec[2].iov_len	= strlen(msg) + 1;

   // [KT] this is sys call
	ret = writev(log_fd, vec, 3);

	return ret;
}

static int __dlog_init(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
#ifdef HAVE_PTHREADS
		pthread_mutex_lock(&log_init_lock);
#endif
	// get filtering info

	// open device
	if( write_to_log == __dlog_init)
	{
		log_fds[LOG_ID_MAIN] = open("/dev/"LOG_MAIN, O_WRONLY);
		log_fds[LOG_ID_RADIO] = open("/dev/"LOG_RADIO, O_WRONLY);
		log_fds[LOG_ID_SYSTEM] = open("/dev/"LOG_SYSTEM, O_WRONLY);

		if( log_fds[LOG_ID_MAIN] < 0 || log_fds[LOG_ID_RADIO] < 0 )
		{
			fprintf(stderr, "open log dev is failed\n");
			write_to_log = __write_to_log_null;
		}
		else
			write_to_log = __write_to_log_kernel;

		if( log_fds[LOG_ID_SYSTEM] < 0 )
		{
			log_fds[LOG_ID_SYSTEM] = log_fds[LOG_ID_MAIN];
		}
	}
#ifdef HAVE_PTHREADS
    pthread_mutex_unlock(&log_init_lock);
#endif
	return write_to_log(log_id, prio, tag, msg);
}


{why-ellipses-dangerous}
http://www.learncpp.com/cpp-tutorial/714-ellipses-and-why-to-avoid-them/

Two points:

o no type checks on calling parameters
o no checks on the mumber of calling parameters

#include <cstdarg> // needed to use ellipses

// The ellipses must be the last parameter
double FindAverage(int nCount, ...)
{
  long lSum = 0;

  // We access the ellipses through a va_list, so let's declare one
  va_list list;

  // We initialize the va_list using va_start. The first parameter is
  // the list to initialize. The second parameter is the last non-ellipse
  // parameter.
  va_start(list, nCount);

  // Loop nCount times
  for (int nArg=0; nArg < nCount; nArg++)
    // We use va_arg to get parameters out of our ellipses
    // The first parameter is the va_list we're using
    // The second parameter is the type of the parameter
    lSum += va_arg(list, int);

  // Cleanup the va_list when we're done.
  va_end(list);

  return static_cast<double>(lSum) / nCount;
}
 
int main()
{
  cout << FindAverage(5, 1, 2, 3, 4, 5) << endl;
  cout << FindAverage(6, 1, 2, 3, 4, 5, 6) << endl;
}

Why ellipses are dangerous

Ellipses offer the programmer a lot of flexibility to implement functions that can take a variable
number of parameters. However, this flexibility comes with some very dangerous downsides.

With regular function parameters, the compiler uses type checking to ensure the types of the
function arguments match the types of the function parameters (or can be implicitly converted so
they match). This helps ensure you don't pass a function an integer when it was expecting a string,
or vice versa. However, note that ellipses parameters have no type declarations. When using
ellipses, the compiler completely suspends type checking for ellipses parameters. This means it is
possible to send arguments of any type to the ellipses! However, the downside is that the compiler
will no longer be able to warn you if you call the function with ellipses arguments that do not make
sense. When using the ellipses, it is completely up to the caller to ensure the function is called
with ellipses arguments that the function can handle. Obviously that leaves quite a bit of room for
error (especially if the caller wasn't the one who wrote the function).

Lets look at an example of a mistake that is pretty subtle:
	
cout << FindAverage(6, 1.0, 2, 3, 4, 5, 6) << endl;

Although this may look harmless enough at first glance, see that the second argument (the first
ellipse argument) is a double instead of an integer. This compiles fine, and produces a somewhat
surprising result:

1.78782e+008

which is a REALLY big number. How did this happen?

As you have learned in previous lessons, a computer stores all data as a sequence of bits. A
variable's type tells the computer how to translate that sequence of bits into a meaningful value.
However, you just learned that the ellipses throw away the variable's type! Consequently, the only
way to get a meaningful value back from the ellipses is to manually tell va_arg() what the expected
type of the next parameter is. This is what the second parameter of va_arg() does. If the actual
parameter type doesn't match the expected parameter type, bad things will usually happen.

In the above FindAverage program, we told va_arg() that our variables are all expected to have a
type of int. Consequently, each call to va_arg() will return the next sequence of bits translated as
an integer.

In this case, the problem is that the double we passed in as the first ellipse argument is 8 bytes,
whereas va_arg(list, int) will only return 4 bytes of data with each call. Consequently, the first
call to va_arg will only read the first 4 types of the double (producing a garbage result), and the
second call to va_arg will read the second 4 bytes of the double (producing another garbage result).
Thus, our overall result is garbage.

Because type checking is suspended, the compiler won't even complain if we do something completely
ridiculous, like this:
	
int nValue = 7; cout << FindAverage(6, 1.0, 2, "Hello, world!", 'G', &nValue, &FindAverage) << endl;

Believe it or not, this actually compiles just fine, and produces the following result on the
author's machine:

1.79766e+008

This result epitomizes the phrase, "Garbage in, garbage out" which is a popular computer science
phrase used primarily to call attention to the fact that computers, unlike humans, will
unquestioningly process the most nonsensical of input data and produce nonsensical output
(wikipedia).

So, in summary, type checking on the parameters is suspended, and we have to trust the caller to
pass in the right type of parameters. If they don't, the compiler won't complain; our program will
just produce garbage (or maybe crash).

<second-problem>
As if that wasn't dangerous enough, we run into a second potential problem. Not only do the ellipses
throw away the type of the parameters, it also throws away the number of parameters in the ellipses!
This means we have to devise our own solution for keeping track of the number of parameters passed
into the ellipses. Typically, this is done in one of two ways:

o One of the fixed parameters is used as a parameter count (this is the solution we use in the
FindAverage example above)

o The ellipse parameters are processed until a sentinel value is reached. A sentinel is a special
value that is used to terminate a loop when it is encountered. For example, we could pick a sentinel
value of 0, and continually process ellipse parameters until we find a 0 (which should be the last
value). Sentinel values only work well if you can find a sentinel value that is not a legal data
value. 

However, even here we run into trouble. For example, consider the following call:

For example:
	
cout << FindAverage(6, 1, 2, 3, 4, 5) << endl;

On the authors machine at the time of writing, this produced the result:

699773

What happened? We told FindAverage() we were going to give it 6 values, but we only gave it 5.
Consequently, the first five values that va_arg() returns were the ones we passed in. The 6th value
it returns was a garbage value somewhere in the stack. Consequently, we got a garbage answer.

When using a sentinel value, if the caller forgets to include the sentinel, the loop will run
continuously until it runs into garbage that matches the sentinel (or crashes).

Recommendations for safer use of ellipses

First, if possible, do not use ellipses at all! Oftentimes, other reasonable solutions are
available, even if they require slightly more work. For example, in our FindAverage() program, we
could have passed in a dynamically sized array of integers instead. This would have provided both
strong type checking (to make sure the caller doesn't try to do something nonsensical) while
preserving the ability to pass a variable number of integers to be averaged.

Second, if you do use ellipses, do not mix expected argument types within your ellipses if possible.
Doing so vastly increases the possibility of the caller inadvertently passing in data of the wrong
type and va_arg() producing a garbage result.

Third, using a count parameter as part of the argument list is generally safer than using a sentinel
as an ellipses parameter. This forces the user to pick an appropriate value for the count parameter,
which ensures the ellipses loop will terminate after a reasonable number of iterations even if it
produces a garbage value.


==============================================================================
*kt_dev_prob_010*	macro: get max value of type

From glibc

# ifndef ULONG_MAX
#  define ULONG_MAX ((unsigned long int) ~(unsigned long int) 0)
# endif
# ifndef LONG_MAX
#  define LONG_MAX ((long int) (ULONG_MAX >> 1))
# endif


# ============================================================================
#{ GNU CORE UTILS
==============================================================================
*kt_dev_guti_000*   gnu core util sites

http://www.gnu.org/software/coreutils/
git clone git://git.sv.gnu.org/coreutils coreutils


# ============================================================================
#{ GCC
==============================================================================
*kt_dev_gcc_000*	gcc compile script

#!/bin/bash
g++ -g -std=c++0x $1


==============================================================================
*kt_dev_gcc_001*	error: two or more data types in declaration specifiers

This error happened under gcc c build when include a header having:

#ifndef __cplusplus
typedef uint8_t bool;
#endif

Thought that it means duplication defined in somewhere and tried followings in sample build:

{example-one} no error

#include <stdio.h>

typedef unsigned char bool;
typedef unsigned char bool;


{example-one} errors

#include <stdio.h>

typedef unsigned char bool;
typedef int bool;

testerrfunc.c:4:13: error: conflicting types for 'bool'
testerrfunc.c:3:23: note: previous declaration of 'bool' was here


{example-three} 

#include <stdio.h>

#define bool unsigned char
typedef int bool;

testerrfunc.c:4:13: error: two or more data types in declaration specifiers
testerrfunc.c:4:1: warning: useless type name in empty declaration [enabled by default]

Therefore, this means "typedef int unsigned char;" hence error.


{stdbool.h} {preprocessor-options}

Tried to preprocessor output using "-E" option but not that useful. But found following line from
the output and when followed that file, found what went wrong:

From -E output using GCC 453.  
# 1 "/usr/lib/gcc/armv7l-tizen-linux-gnueabi/4.5.3/include/stdbool.h" 1 3 4

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */

#ifndef _STDBOOL_H
#define _STDBOOL_H

#ifndef __cplusplus

#define bool	_Bool
#define true	1
#define false	0

#else /* __cplusplus */

/* Supporting <stdbool.h> in C++ is a GCC extension.  */
#define _Bool	bool
#define bool	bool
#define false	false
#define true	true

#endif /* __cplusplus */

/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined	1
#endif	/* stdbool.h */

note: it is not automatically included when use stdio.h.

From GCC: http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types

ISO C99 adds the following keywords:
     inline _Bool _Complex _Imaginary


==============================================================================
*kt_dev_gcc_002*	error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]

class UseStaic
{
	public:
	UseStatic() { std::cout << "Use staic ctor" << std::endl; }

	private:
	Sclass m_sclass;
};

Happened when made a typo in class name and meant to be class UseStatic. Basically, not able to find
UseStatic type.

From GCC:

-fpermissive

Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using
-fpermissive allows some nonconforming code to compile. 


{when-missed-include}

<example-one>

#include < iostream>
// #include < stack>

using namespace std;

int main()
{
	int n;
	double item;
	stack<double> numbers;
	...
}

usestack.cpp:11:2: error: 'stack' was not declared in this scope
usestack.cpp:11:8: error: expected primary-expression before 'double'
usestack.cpp:11:8: error: expected ';' before 'double'


<example-two>

#include < iostream>
// #include < stack>

int main()
{
	int n;
	double item;
	std::stack<double> numbers;
	...
}

usestack.cpp:8:2: error: 'stack' is not a member of 'std'
usestack.cpp:8:13: error: expected primary-expression before 'double'
usestack.cpp:8:13: error: expected ';' before 'double'

Does it mean that it gives more reason not to use using-directive?


==============================================================================
*kt_dev_gcc_003*	error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]

This is an error when tried convert from base to derived.

class Singleton
{
	protected:
	Singleton() {};

	public:
	virtual Singleton* Instance();

	protected:
	static Singleton* m_pins;
};

Singleton* Singleton::m_pins = 0;

Singleton* Singleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "Singleton::Instance" << std::endl;
		//m_pins = new Singleton;
	}

	return m_pins;
}

class MySingleton : public Singleton
{
	public:
	virtual MySingleton* Instance();
};

MySingleton* MySingleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "MySingleton::Instance" << std::endl;
		//_pins = new MySingleton;
	}

	return m_pins; // error
}

usestatic.cpp: In member function 'virtual MySingleton* MySingleton::Instance()':
usestatic.cpp:106:9: error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]


==============================================================================
*kt_dev_gcc_004*	error: variable-sized object 'out' may not be initialised

void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
	Entry out[length];			// this works fine but not inited.
	Entry out[length] = {0};	// this causes an error
	Entry out[30] = {0};			// this works
}


I am assuming that you are using a C99 compiler (with support for dynamically sized arrays). The
problem in your code is that at the time when the compilers sees your variable declaration it cannot
know how many elements there are in the array (I am also assuming here, from the compiler error that
length is not a compile time constant). 

So should use memset or alloc in a function. [KT] Think from compiler perspective.

==============================================================================
*kt_dev_gcc_005*	error: expected ‘}’ at end of input


#include <iostream>
#include "Fsm.h"

int main()
{
	std::cout << "--{ main " << std::endl;

	std::cout << "--} main " << std::endl;
}

main.cpp:9:1: error: expected ‘}’ at end of input

Have got this error and puzzled since there is not much in this file. Interestingly when remove
fsm.h include, builds. So thought it may not find this header? Spend some time to change makefile to
specify current directory in the gcc command line. This turns out that in fsm.h, there is a missing
closing brace and this cause this error.

#ifdef __cplusplus
extern "C"
{
#endif

  ...

//#ifdef __cplusplus
//}
//#endif


==============================================================================
*kt_dev_gcc_006*  error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

error: 'X' does not name a type 

This happens when there is no typedef or types declared before its use.

error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

This is the same as above but more difficult to find because it happes when include a lot of headers
and there is dependencies between them.

<buffer.h>

#include "semaphore.h" // here one of struct uses some from st.h
#include "st.h"

<buffer.c>

#include "buffer.h"
#include "st.h"

In file included from buffer.h:1, from buffer.c:4: 
semaphore.h:4: error: expected specifier-qualifier-list before 'st_cond_t'

This shows the order is important in header inclusion.

This also happens when use the same header guard for two different headers. This effectvely do not
include necessary header and hence the error.

#ifndef __MH5W_GPI_H__
#define __MH5W_GPI_H__


==============================================================================
*kt_dev_gcc_007*  error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before

<case-01>
Like this case when use CPP features in C, this is very obvious so errors are clear.

kit@kit-vb:~/work$ gcc repmanc.c 
repmanc.c:10:1: error: unknown type name ‘class’
repmanc.c:11:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token

<case-02>
However, when there are many header files and they are cascaded each other, this is not obvious.
This happens because C file uses CPP header which defines classes and cannot handle class keyword.

In file included from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/OSAbstraction.h:10:0,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/app/MApp.h:26,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/main/view_main.c:28:
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/PCString.h:52:7: error: expected '=', ',',
';', 'asm' or '__attribute__' before 'PCMem'


==============================================================================
*kt_dev_gcc_100*	gcc and c++11

{reference}

http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html
http://gcc.gnu.org/wiki/HomePage

{gcc-headers}

For ubuntu:

/usr/lib/gcc/i686-linux-gnu/4.6/include
/usr/include/c++/4.6/


{override-keyword}
Explicit virtual overrides from GCC 4.7


{range-for}
VC 2012 supports but g++ (GCC) 4.4.5 don't. This 'range based for' is supported from 4.6

vector< int > v = { ... };

for(auto& r : v )
	 r *= 2;

is equals to:

for(auto beg = v.begin(), end = v.end(); beg != end; ++beg )
{
	 auto& r = *beg;
	 r *= 2;
}


{alias-declaration}

Primers p68. GCC 4.4.5 don't.

class Foo {

	 using line_no = vector< string >::size_type;

	 typedef vector< string >::size_type line_no;
};


{auto}

GCC 4.4.5 do.


{explicit}

From GCC 45. See *kt_dev_cpp_005* for more.


{class-initializers}

For GCC 463 it emit error:
usecomma.cpp:5:19: sorry, unimplemented: non-static data member initialisers


{c++11}

http://gcc.gnu.org/projects/cxx0x.html

C++0x was the working name of the ISO C++ 2011 standard, which introduced a host of new features
into the standard C++ language and library. This project sought to implement new C++11 features in
GCC, and made it the first compiler to bring feature-complete C++11 to C++ programmers.

C++11 features are available as part of the "mainline" GCC compiler in the trunk of GCC's Subversion
repository and in GCC 4.3 and later. 

>
 To enable C++0x support, add the command-line parameter -std=c++0x to your g++ command line. 
<
Or, to enable GNU extensions in addition to C++0x extensions,
add -std=gnu++0x to your g++ command line. GCC 4.7 and later support -std=c++11 and -std=gnu++11 as
well.

Important: GCC's support for C++11 is still experimental. Some features were implemented based on
early proposals, and no attempt will be made to maintain backward compatibility when they are
updated to match the final C++11 standard.

$ g++ -v --help | egrep "\-std"

  -std=c++0x                  Conform to the ISO 1998 C++ standard, with
                              extensions that are likely to become a part of
                              the upcoming ISO C++ standard, dubbed C++0x. Note
                              that the extensions enabled by this mode are
                              experimental and may be removed in future
                              releases of GCC.

note: when use gcc, got link errors that cannot find STLs. must use g++.
$ g++ -std=c++0x sample.cpp

{the-gnu-c++-library}
http://gcc.gnu.org/onlinedocs/libstdc++/index.html


{how-to-use-gcc-optimisation} {gcc-profiling}

The example program above does have a very predictable, repeatable flow of execution. Let's see what
happens when we use compiler-assisted optimization. Building the programming now involves two steps:
a profiling phase and an optimized compile. In the profiling phase, we build and run an instrumented
version of the executable. We build as follows:

    $ cc -O3 -DDONT_EXPECT -fprofile-generate builtin_expect_test.c -o bn.prof

(The -fprofile-generate option implies -fprofile-arcs, as well as one or two other profiling
options.)

We then run the executable, which generates profiling information that is stored in a file (with the
extension .gcda).

    $ time -f "%E real, %U user, %S sys" ./bn.prof 1000
    0, 1000000000
    0:05.39 real,  5.37 user, 0.00 sys

Note that, because of the instrumentation code, the profiled version runs rather slower that the
normally compiled code.  Running this code created a file containing the profiling results:

    $ ls *.gcda
    builtin_expect_test.gcda

We then employ the -fprofile-use compiler option,which (implicitly) uses the profiling results to
create an optimized executable.

    $ cc -O3 -DDONT_EXPECT -fprofile-use builtin_expect_test.c -o bn.opt

And then we run the optimized program:

    $ time -f "%E real, %U user, %S sys" ./bn.opt 1000
    0, 1000000000
    0:01.95 real,  1.94 user, 0.00 sys

This optimized version runs significantly faster (1.95 versus 2.28 seconds) than our version that
used __builtin_expect(). This is because, in addition to the branching in the if statement, the
branching in the for loops was also optimized.

It's left as an exercise for the reader to show that employing __builtin_expect() (to expect 0) in
conjunction with compiler-assisted optimization doesn't improve things: the compiler already
optimizes the if branching as well as the programmer-directed optimization. One other interesting
exercise  is, of course, to compare the assembler (cc -S) code generated for each of the above
cases. 

{gcc-options}

http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC

-v
Print (on standard error output) the commands executed to run the stages of compilation. Also print
the version number of the compiler driver program and of the preprocessor and the compiler proper.
 [KT] can see spec and include path

-###
Like -v except the commands are not executed and arguments are quoted unless they contain only
alphanumeric characters or ./-_. This is useful for shell scripts to capture the driver-generated
command lines. 

-print-search-dirs [KT] to check path for lib


==============================================================================
*kt_dev_gcc_101*	gcc typeof

To check actual type of some expression. For example:

http://gcc.gnu.org/onlinedocs/gcc/Typeof.html
http://stackoverflow.com/questions/16832863/behaviour-of-sizeof-in-c-gcc


==============================================================================
*kt_dev_gcc_102*	gcc binutil

{gcc-binutil}

http://sourceware.org/binutils/docs-2.20/
http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html

GCC provides a large number of built-in functions other than the ones mentioned above. Some of these
are for internal use in the processing of exceptions or variable-length argument lists and are not
documented here because they may change from time to time; we do not recommend general use of these
functions. 


{nm-find-symbol}

%nm *.a

%/opt/toolchains/bin/mipsel-linux-uclibc-nm
%nm libicammulti.a | grep vendor

00000bc0 t _GLOBAL__I_vendor_init
00000980 T vendor_cleanup
00000000 T vendor_init
000002c8 T vendor_setup
000000bc r _ZZ12vendor_setupE12__FUNCTION__
00000088 r _ZZ12vendor_setupE19__PRETTY_FUNCTION__

where: for more details %man nm
 
Uppercase means global and lowercase means local. 
B is bss
T/t is text and means symbols defined in this object file. 
D data
A is this address is absolute and is not subject to modification by an additional link stage
U is undefined meaning extern

Cannot use nm for a stripped object


==============================================================================
*kt_dev_gcc_103*	gcc link and ld

{gcc-compliation-process}

Four phase: preprocessing, compilation, assembly and linking. [KT] Seen the case that during the
porting work, built all files but when starts some funcs which are part of files which are already
built, seeing more errors of missing header files and undefined symbols. Why?

From online:

Once the object file containing the machine code is produced in the step above, the linking step
makes sure that all the undefined symbols in code are resolved.

Enable warnings using -Wall flag, then you will see warning: Implicit call to function bprint() and
Implicit call to function aprint(). It's is basically compiler recognizes this function during
Linker stage and this does not give any error.

So gcc assumes implicit calls in compilation phase and starts to emit errors when actually use it
which lead to link it. See the below for a correct answer.

{gcc-link-order}

http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/
_______________________________
Library order in static linking

July 9th, 2013 at 5:56 am

I'll start with a slightly sneaky but educational example. Suppose we have this code:

volatile char src[] = {1, 2, 3, 4, 5};
volatile char dst[50] = { 0 };

void* memcpy(void* dst, void* src, int len);

int main(int argc, const char* argv[])
{
    memcpy(dst, src, sizeof(src) / sizeof(src[0]));
    return dst[4];
}

It runs just fine and the return value is 5. Now, suppose this is part of a larger project that
consists of many object files and libraries, and somewhere within the project there is a library
that contains this code:

void memcpy(char* aa, char* bb, char* cc) {
    int i;
    for (i = 0; i < 100; ++i) {
        cc[i] = aa[i] + bb[i];
    }
}

If the previous snippet gets linked with this library, what happens? Would you expect it to still
return 5? Return something else? Crash? The answer is: it depends - the result can be either correct
or a segmentation fault. It depends on the order in which the objects and libraries in the project
were fed to the linker.

If you fully understand why this depends on linking order, as well as how to avoid the problem (and
more serious problems, like circular dependencies) then congratulate yourself and move on - this
article is probably not for you. Otherwise, read on.  

__________
The basics

Let's start by defining the scope of this article: first, my examples are demonstrating the use of
the gcc and binutils toolchain on Linux. Compatible toolchains (like clang instead of gcc) apply
too. Second, the discussion here resolves around [static-linking] that's done at compile/link time.

To understand [why-linking-order-matters], it's first instructional to understand how the linker
works with respect to linking libraries and objects together. Just as a quick reminder - an object
file both provides (exports) external symbols to other objects and libraries, and expects (imports)
symbols from other objects and libraries. For example, in this C code:

int imported(int);

static int internal(int x) {
    return x * 2;
}

int exported(int x) {
    return imported(x) * internal(x);
}

The names of the functions speak for themselves. Let's compile it and look at the symbol table:

$ gcc -c x.c
$ nm x.o
000000000000000e T exported
                 U imported
0000000000000000 t internal

This means: exported is an external symbol - defined in the object file and visible from the
outside. [imported-is-an-undefined-symbol]; in other words, the linker is expected to find it
elsewhere. When we talk about linking later, the term undefined can become confusing - so it helps
to remember that this is where it comes from originally. internal is defined within the object but
invisible from the outside.

Now, a library is simply a collection of object files. Just a bunch of object files glued together.
Creating a library is a very trivial operation that doesn't do anything special besides placing many
object files into the same file. This in itself is important, because a horde of object files is not
convenient to deal with. For example, on my system libc.a (the static version of the C library)
consists of almost 1500 object files. It's way nicer to just carry libc.a around.  

The linking process {gcc-link-algorithm}

This section defines the linking process in a somewhat dry, algorithmic manner. This process is the
key to understanding why linking order matters.

Consider a linker invocation:

$ gcc main.o -L/some/lib/dir -lfoo -lbar -lbaz

<caution>
The following do not work:
gcc -lfoo main.c

The linker is almost always invoked through [the-compiler-driver-gcc] when compiling C or C++ code.
This is because the driver knows how to provide the correct command-line arguments to the linker
itself (ld) with all the support libraries, etc. We'll see more of this later.

Anyhow, as you can see the object files and libraries are provided in a certain order on the
command-line, from left to right. This is [the-linking-order]. Here's what the linker does:

The linker maintains a [symbol-table]. This symbol table does a bunch of things, but among them is
keeping two lists:

1. A list of symbols exported by all the objects and libraries encountered so far.
2. A list of undefined symbols that the encountered objects and libraries requested to import and
were not found yet.

<for-object-file>

When the linker encounters a new object-file, it looks at:

1.The symbols it exports: these are added to the list of exported symbols mentioned above. If any
symbol is in the undefined list, it's removed from there because it has now been found. If any
symbol has already been in the exported list, we get a "multiple definition" error: two different
objects export the same symbol and the linker is confused.

2. The symbols it imports: these are added to the list of undefined symbols, unless they can be
found in the list of exported symbols.

<for-library>

When the linker encounters a new library, things are a bit more interesting. The linker goes over
all the objects in the library. For each one, it [first] looks at the symbols it exports.

1. If any of the symbols it exports are on the undefined list, the object is [added] to the link and
the next step is executed. Otherwise, the next step is skipped. [KT] this means that if not, this
object is not be added to the link. 

2. If the object has been added to the link, it's treated as described above - its undefined and
exported symbols get added to the symbol table. [KT] added to the link.

3. Finally, if any of the objects in the library has been included in the link, the library is
rescanned again - it's possible that symbols imported by the included object can be found in other
objects within the same library.

When the linker finishes, it looks at the symbol table. If any symbols remain in the undefined list,
the linker will throw an "undefined reference" error. For example, when you create an executable and
forget to include the file with the main function, you'll get something like:

/usr/lib/x86_64-linux-gnu/crt1.o: In function '_start':
(.text+0x20): undefined reference to 'main'
collect2: ld returned 1 exit status

Note that after the linker has looked at a library, it won't look at it again. Even if it exports
symbols that may be needed by some later library. The only time where a linker goes back to rescan
objects it has already seen, happens within a single library - as mentioned above, once an object
from some library is taken into the link, all other objects in the same library will be rescanned.
Flags passed to the linker can tweak this process - again, we'll see some examples later.

>
 Also note that when a library is examined, an object file within it can be left out of the link if
 it does not provide symbols that the symbol table needs. This is a very important feature of static
 linking. The C library I mentioned before makes a heavy use of this feature, by mostly splitting
 itself to an-object-per-function. So, for example if the only C standard library function your code
 <uses> is strlen, only strlen.o will be taken into the link from libc.a - and your executable will
 be very small.
<
_______________
Simple examples [KT] these examples works on ubuntu as they are shown.

The previous section can be hard to digest, so here are some simple examples that show the process
in action.

Let's start with the most basic case, of linking two objects together:

$ cat simplefunc.c
int func(int i) {
    return i + 21;
}

$ cat simplemain.c
int func(int);

int main(int argc, const char* argv[])
{
    return func(argc);
}

$ gcc -c simplefunc.c
$ gcc -c simplemain.c
$ gcc simplefunc.o simplemain.o
$ ./a.out ; echo $?
22

>
 Note that since these are object files, the linking order does not matter. Object files are always
 taken into the link. We can pass them to the linker in reversed order and it still works: 
<

$ gcc simplemain.o simplefunc.o
$ ./a.out ; echo $?
22

Now let's do something different. Let's put simplefunc.c into a library:

$ ar r libsimplefunc.a simplefunc.o [KT] or ar rs to skip ranlib command.
$ ranlib libsimplefunc.a
$ gcc  simplemain.o -L. -lsimplefunc
$ ./a.out ; echo $?
22

Works like a charm. But note what happens if the linking order is reversed now:

$ gcc  -L. -lsimplefunc  simplemain.o
simplemain.o: In function 'main':
simplemain.c:(.text+0x15): undefined reference to 'func'
collect2: ld returned 1 exit status

Understanding the linking algorithm outlined above makes this case simple to explain. When the
linker encounters libsimplefunc.a, it still hasn't seen simplemain.o, which means that func is not
yet on the undefined list. When the linker looks into the library it sees simplefunc.o that exports
func. But since it doesn't need func, this object file is [not] included in the link. When the
linker does reach simplemain.o and sees that func is, indeed required, it's added to the undefined
list (because it's not on the exported list). The linker then reaches the end of the link and func
is still undefined.

Note how this doesn't happen in the previous linking order - since simplemain.o comes first, func is
on the undefined list before the linker sees the library, so the object file exporting it does get
included.

This brings us to the most important corollary of the linking process outlined above:

If object or library AA needs a symbol from library BB, then AA should come before library BB in the
command-line invocation of the linker. [KT] slightly not correct.

___________________
Circular dependency {cyclic-dependencies}

The corollary above is an important summary of the linking process - it's certainly much more
practical to keep in mind because it's so short. But it makes one wonder - what happens if AA needs
a symbol from BB, but BB also needs a symbol from AA? While officially this isn't a good programming
practice, in reality it happens quite a lot. But AA can't come both before and after BB on the
command-line, right? That's just silly. Wait, is it, really?

Let's see an example and start simple. Imagine that instead of simplefunc.c, the func symbol is
provided thus:

$ cat func_dep.c
int bar(int);

int func(int i) {
    return bar(i + 1);
}

$ cat bar_dep.c
int func(int);

int bar(int i) {
    if (i > 3)
        return i;
    else
        return func(i);
}

These two files depend on each other and get placed into different libraries. If we link them in one
order, we fail:

$ gcc  simplemain.o -L.  -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

However, the other order does work:

$ gcc  simplemain.o -L. -lfunc_dep -lbar_dep
$ ./a.out ; echo $?
4

Quiz: can you figure out why? Hint: just go over the linking process algorithm with this
command-line. What undefined symbols does the symbol table contain when the linker first sees
-lfunc_dep?

<analysis-on-okay-case>

simplemain:
			U func

symbol table: undefined: func

func_dep.a:
         U bar  (import)
00000000 T func (export)

okay, add func to the link.

bar_dep.a:
00000000 T bar  (export)
         U func (import)

The symbol table has func and bar.

<analysis-on-not-okay-case>

simplemain:
			U func

symbol table: undefined: func

bar_dep.a:
00000000 T bar  (export)
         U func (import)

Here, bar is not added to the link.

func_dep.a:
         U bar
00000000 T func (undefined reference to 'bar')

The symbol table has func but not bar. Hence, error.

But this is a very simple case. Let's look at a trickier one. We'll add a dependency to bar on
another function from libfunc_dep.a, but one that lives in a different object:

$ cat bar_dep.c
int func(int);
int frodo(int);

int bar(int i) {
    if (i > 3)
        return frodo(i);
    else
        return func(i);
}

$ cat frodo_dep.c
int frodo(int i) {
    return 6 * i;
}

We'll recompile all these files into separate objects, and the libfunc_dep.a library will now be:

$ ar r libfunc_dep.a func_dep.o frodo_dep.o
$ ranlib libfunc_dep.a

Here's a drawing of the libraries, with arrows showing the dependencies:

simplemain:
			U func

 libfunc_dep.a        libbar_dep.a
  - func_dep.o  ->  <- - bar_dep.o (need func and frodo)
  - frodo_dep.o     <-

Now linking fails no matter what order we list the libraries in:

U func; func and bar; bar and frodo

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep
./libbar_dep.a(bar_dep.o): In function 'bar':
bar_dep.c:(.text+0x17): undefined reference to 'frodo'
collect2: ld returned 1 exit status

U func; nothing for bar_dep; func and bar

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

To solve this, consider that it's perfectly valid to list a library more than once on the link; so
in fact, we can provide libfunc_dep.a both before and after libbar_dep.a:

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Another quiz: will the same trick work providing -lbar_dep twice? Why not?

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep -lbar_dep

U func; nothing for bar_dep; func and bar(U); bar

./libbar.a(bar_dep.o): In function `bar':
bar_dep.c:(.text+0x13): undefined reference to `frodo'
collect2: ld returned 1 exit status

Becase frodo is in the libaray but was not added to the link because of object-per-function-linking.

_________________________________________
Using linker flags to control the process

As I've mentioned above, the linker has a number of interesting flags that can be used to control
the process in a fine-grained manner. For example, circular dependency problems can be easily
resolved with --start-group and --end-group. Here's an instructive portion from man ld:

-start-group archives -end-group

The specified archives are searched repeatedly until no new undefined references are created.
Normally, an archive is searched only once in the order that it is specified on the command line. If
a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an
archive that appears later on the command line, the linker would not be able to resolve that
reference. By grouping the archives, they all be searched repeatedly until all possible references
are resolved.

Using this option has a significant performance cost. It is best to use it only when there are
unavoidable circular references between two or more archives.

Here's how this helps in our case:

$ gcc simplemain.o -L. -Wl,--start-group -lbar_dep -lfunc_dep -Wl,--end-group
$ ./a.out ; echo $?
24

It's interesting to note the "significant performance cost" warning in the excerpt above. This
explains why the linking process is the way it is. Presumably, linkers could just re-scan the whole
library list until no new symbols got resolved. This would eliminate most circular-dependency and
linking order problems in the world, but it would also be slow. Linking is already a critical part
of the compilation time of large systems, since it looks at the whole program and requires quite a
bit of memory. It's better to make it as fast as possible for well-behaved programs (that got their
linking order right), and provide special options like groups for the difficult circular dependency
cases. [KT] This is only about cost in linking?

There's at least one another linker flag that can help us resolve the circular dependency here. We
can use the --undefined flag to tell the linker - "buddy, here's a symbol I want you to add to the
undefined list". In our case this makes the link error go away even though the libraries are
specified only once:

$ gcc simplemain.o -L. -Wl,--undefined=bar -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Figuring out why this works is left as an exercise to the reader.

____________________________
Back to the original example

Let's go back to the example this article started with. main assumes it gets the correct memcpy from
the C library, but the memcpy it gets linked with does something else. Assuming the memcpy here was
packed into the libstray_memcpy.a library:

$ gcc  -L. main_using_memcpy.o -lstray_memcpy
$ ./a.out
Segmentation fault (core dumped)

This is the expected behavior. Since -lstray_memcpy was provided after main_using_memcpy.o on the
command-line, it gets linked in. But what happens if the order is reversed:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o
$ ./a.out ; echo $?
5

The program links and works correctly. The reason for this is simple: even without us explicitly
asking for it, gcc asks the linker to link the C library as well. The full linker invocation command
of gcc is pretty complex, and can be examined by passing the -### flag to gcc. But in our case this
amounts to:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o -lc

When the linker sees -lstray_memcpy, the symbol table does not yet have an undefined entry for
memcpy, so the object file with the wrong function does not get linked. The linker adds this
undefined entry only after it sees main_using_memcpy.o. Then, when it reaches -lc, the object file
holding memcpy from the C library does get linked in because by now memcpy is on the undefined list.

__________
Conclusion

The algorithm used by the linker to resolve symbols between objects and libraries is pretty simple.
As long as you keep it in mind, linker errors and related problems should be easy to understand. If
you still run into problematic situations you're not sure how to resolve, this article mentioned two
tools that can be very useful in debugging such problems: one is nm, which shows the symbol table of
an object or a whole library. The other is the -### flag that gcc accepts and as a result shows the
full commands it passes to the underlying tools.

 [KT] When use this option, it appears that linker cannot detect duplicated symbols and use one of
 symbols. There are duplicated in the same lib archive but picked up wrong one. 


{gcc-link-search-path}

-Lsearchdir 
--library-path=searchdir 

Add path searchdir to the list of paths that ld will search for archive libraries and ld control
scripts. You may use this option any number of times. The directories are searched in the order in
which they are specified on the command line. Directories specified on the command line are searched
before the default directories. All -L options apply to all -l options, regardless of the order in
which the options appear.  If searchdir begins with =, then the = will be replaced by the sysroot
prefix, a path specified when the linker is configured.  The default set of paths searched (without
being specified with `-L') depends on which emulation mode ld is using, and in some cases also on
how it was configured. See Environment.  The paths can also be specified in a link script with the
SEARCH_DIR command. Directories specified this way are searched at the point in which the linker
script appears in the command line. 

{gcc-link-option}

http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options
https://sourceware.org/binutils/docs/ld/Options.html

-Wl,option

Pass option as an option to the linker. If option contains commas, it is split into multiple options
at the commas. You can use this syntax to pass an argument to the option. For example,
-Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also
get the same effect with -Wl,-Map=output.map. 

-nostdlib

Do not use the standard system startup files or libraries when linking. No startup files and only
the libraries you specify are passed to the linker, and options specifying linkage of the system
libraries, such as -static-libgcc or -shared-libgcc, are ignored.

The compiler may generate calls to memcmp, memset, memcpy and memmove. These entries are usually
resolved by entries in libc. These entry points should be supplied through some other mechanism when
this option is specified.

One of the standard libraries bypassed by -nostdlib and -nodefaultlibs is libgcc.a, a library of
internal subroutines which GCC uses to overcome shortcomings of particular machines, or special
needs for some languages. (See Interfacing to GCC Output, for more discussion of libgcc.a.) In most
cases, you need libgcc.a even when you want to avoid other standard libraries. In other words, when
you specify -nostdlib or -nodefaultlibs you should usually specify -lgcc as well. This ensures that
you have no unresolved references to internal GCC library subroutines. (An example of such an
internal subroutine is '__main', used to ensure C++ constructors are called; see collect2.) 


==============================================================================
*kt_dev_gcc_104*	gcc comma-operator {C99}

Preface

This is a reference manual for the C programming language as implemented by the GNU Compiler
Collection (GCC). Specifically, this manual aims to document:

The 1989 ANSI C standard, commonly known as C89/C90

The 1999 ISO C standard, commonly known as C99, ISO/IEC 9899:1999, to the extent that C99 is
implemented by GCC

The current state of GNU extensions to standard C 

This manual describes C89 as its baseline. C99 features and GNU extensions are explicitly labeled as
such.

By default, GCC will compile code as C89 plus GNU-specific extensions. Much of C99 is supported;
once full support is available, the default compilation dialect will be C99 plus GNU-specific
extensions. (Some of the GNU extensions to C89 ended up, sometimes slightly modified, as standard
language features in C99.)

The C language includes a set of preprocessor directives, which are used for things such as macro
text replacement, conditional compilation, and file inclusion. Although normally described in a C
language manual, the GNU C preprocessor has been thoroughly documented in The C Preprocessor, a
separate manual which covers preprocessing for C, C++, and Objective-C programs, so it is not
included here. 


{C90-C99}
After ANSI produced the official standard for the C programming language in 1989, which became an
international standard in 1990, the C language specification remained relatively static for some
time, while C++ continued to evolve, largely during its own standardization effort. Normative
Amendment 1 created a new standard for C in 1995, but only to correct some details of the 1989
standard and to add more extensive support for international character sets. The standard underwent
further revision in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which
was adopted as an ANSI standard in May 2000. The language defined by that version of the standard is
commonly referred to as "C99". 


{comma-operator}
The following causes error:
usecomma.cpp:70:42: error: invalid conversion from 'Node* {aka node*}' to 'int' [-fpermissive]
usecomma.cpp:72:22: error: base operand of '->' is not a pointer

{
   // search the end using count
70:   for( int current = 1, pend = list->header; current < list->count; current++)
72:      pend = pend->pnext;
}

{
   // search the end using count
   pend = list->header;
   for( int current = 1; current < list->count; current++)
      pend = pend->pnext;

   or

   // search the end using count
   int current;
   for( current = 1, pend = list->header; current < list->count; current++) 
      pend = pend->pnext;
}

Why? Because cannot define different types in the init part of for.

From ISO/IEC 9899-1999

6.8.5 Iteration statements
Syntax

for ( expression opt ; expression opt ; expression opt) statement
for ( declaration expression opt ; expression opt) statement

Constraints
2 The controlling expression of an iteration statement shall have scalar type.
3 The declaration part of a for statement shall only declare identifiers for objects having storage class auto or register
.

Semantics
4 An iteration statement causes a statement called the loop body to be executed repeatedly until the controlling expression compares equal to 0.

> [KT] This is why the var declared in a for has a scope
 5 An iteration statement is a block whose scope is a strict subset of the scope of its enclosing
 block. The loop body is also a block whose scope is a strict subset of the scope of the iteration
 statement. 
<

Now the 'block wrapped around the loop' comes into its own; it explains why the variable i cannot be
accessed outside the loop. You can declare more than one variable, but they must all be of [the-same
-type]:

for (int i = 0, j = sizeof(something); i < j; i++, j--) { ... }

6.8.5.3 The for statement

1 The statement for ( clause-1 ; expression-2 ; expression-3) statement

behaves as follows: The expression expression-2 is the controlling expression that is evaluated
before each execution of the loop body. The expression expression-3 is evaluated as a void
expression after each execution of the loop body. If clause-1 is a declaration, the scope of any
variables it declares is the remainder of the declaration and the entire loop, including the other
two expressions; it is reached in the order of execution before the first evaluation of the
controlling expression. If clause-1 is an expression, it is evaluated as a void expression before
the first evaluation of the controlling expression.

2 Both clause-1 and expression-3 can be omitted. An omitted expression-2 is replaced by a nonzero constant

 [KT] Cannot see where it says it should be the same type though.


Why comma operator?

The comma operator is a sequence point (as they are && and ||) so the order of evaluation of the
operands is {fixed}. It is a binary operator that evaluates its first operand, performs all side
effects and discards the result, and then evaluates the second operand and returns its value.

Any number of expressions separated by commas can form a single expression because the comma
operator is associative. The use of the comma operator guarantees that the subexpressions will be
evaluated in left-to-right order, and the value of the last becomes the value of the entire
expression. type so:

x = (y, z);

will do y and, after performing all side effects, will discard it, then do z and finally will set x
to z.

Because the comma operator discards its first operand, it is useful where the first operand has
<desirable-side-effects>, such as in the initializer or the counting expression of a for loop. Used
to produce side effects.

For example, this for statement:

for(p=0;p+=(a&1)*b,a!=1;a>>=1,b<<=1)
   ...

can be re-written:

p=0;
p+=(a&1)*b;
while (a!=1) {
    ...
    a>>=1;
    b<<=1;
    p+=(a&1)*b;
}


The primary use of the comma operator is to produce side effects in the following situations:

Calling a function
Entering or repeating an iteration loop
Testing a condition
Other situations where a side effect is required but the result of the expression is not immediately needed

for (i=0; i<2; ++i, f() ); 	

A for statement in which i is incremented and f() is called at each iteration.

if ( f(), ++i, i>1 ) { /* ... */ } 	

An if statement in which function f() is called, variable i is incremented, and variable i is tested
against a value. The first two expressions within this comma expression are evaluated before the
expression i>1. Regardless of the results of the first two expressions, the third is evaluated and
its result determines whether the if statement is processed.

func( ( ++a, f(a) ) ); 	

A function call to func() in which a is incremented, the resulting value is passed to a function
f(), and the return value of f() is passed to func(). The function func() is passed only a single
argument, because the comma expression is enclosed in parentheses within the function argument list.


==============================================================================
*kt_dev_gcc_105*	gcc likely and unlikely 

{likey-and-unlikely}
This is built-in function: long __builtin_expect (long exp, long c)

You may use __builtin_expect to provide the compiler with branch prediction information. In general,
you should prefer to use actual profile feedback for this (-fprofile-arcs), as programmers are
notoriously bad at predicting how their programs actually perform. However, there are applications
in which this data is hard to collect.


{reading-two}
http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html
As the gcc documentation says, you can use this compiler built-in function to give the optimizer a
clue about the likely result of an integer (or Boolean) expression. In the context of an if
statement, this enables the optimizer to reorder the code in a way that gives best performance, by
ensuring that the code that is most likely to execute after the conditional immediately follows the
conditional when the instruction stream is fed to the CPU pipeline.

The __builtin_expect() function takes two arguments: a value to be tested, and the expected result.
Both of these are integral values. The interface is a little clumsy for most uses, since the common
case is that we want to test for "true" (non-zero) or "false" (zero). Thus, the Linux kernel defines
two simpler interfaces: likely() and unlikely() (in include/linux/compiler.h):

    #define likely(x)      __builtin_expect(!!(x), 1)
    #define unlikely(x)    __builtin_expect(!!(x), 0)

In other words, likely(x) means "I expect x is true", and and unlikely(x) means "I expect x is
false".

Here's my test program. The comments should be enough to help you understand some of the more
obscure pieces. Below, I'll just skip to looking at the test results.

The program essentially repeatedly scans a one-million-element integer array whose contents are zero
(in the default case). Using the program, we can time the results of the checks that are performed
either with or without using __builtin_expect().

For example, here we scan the array without  __builtin_expect():

    $ cc -DDONT_EXPECT -O3 builtin_expect_test.c -o bn
    $ time -f "%E real, %U user, %S sys" ./bn 1000
    0, 1000000000
    0:02.68 real,  2.67 user, 0.00 sys

In this case, the program looped one thousand times through the array, to perform a total of one
billion checks, and the real time for execution was 2.68 seconds. (The test machine is an Intel Core
Duo 2.53GHz, and the gcc version is 4.6.3.)

Here's what happens if we employ  __builtin_expect(), telling the compiler that the expected result
of the test is 0.

    [KT] expects 0 and best case
    $ cc -DEXPECT_RESULT=0 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    0, 1000000000
    0:02.28 real,  2.28 user, 0.00 sys

The execution time fell to 2.28 seconds. In other words (for this particular CPU, compiler version,
and program), __builtin_expect() improved the execution time of each check by 0.4 nanoseconds (0.4
seconds for one billion checks).

Well and good. What if we tell __builtin_expect() to expect the wrong value?

    [KT] expects 1 when all elements are 0 so worst case
    $ cc -DEXPECT_RESULT=1 -O3 builtin_expect_test.c -o b1
    $ time -f "%E real, %U user, %S sys" ./b1 1000
    0, 1000000000
    0:04.19 real,  4.18 user, 0.00 sys

In this case, unsurprisingly, we made each check run slower, by about 1.5 (i.e., 4.19 - 2.68)
nanoseconds. So, should you use __builtin_expect()?  

You should only use __builtin_expect()-or the Linux kernel's likely() and unlikely()-if it's "very
likely" that your code will follow the predicted branch. How much is "very likely"? If you're
looking for actual numbers, the answer will depend on your compiler version, CPU, and code. But to
illustrate that you should generally [avoid] these optimizations unless your code is very likely to
follow one branch, here's some further tests using the above code.

In this test, the program first injects some nonzero values into the array before doing tests for
zero using __builtin_expect(). Nonzero values are placed at every tenth element in the array:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000000, 900000000
    0:02.79 real,  2.76 user, 0.01 sys

Note what happened. Even though most array elements contained the expected zero value, execution
speed was actually worse (2.79 seconds versus 2.69 seconds) than not using __builtin_expect() at
all! In fact, even when only one in ten thousand values is nonzero, we're still at only roughly the
break-even point:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10000 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000, 999900000
    0:02.66 real,  2.64 user, 0.00 sys

The point where using these optimizations becomes worthwhile will depend on the factors mention
above, but the point is that you should really only use them when your predicted path is very
likely, and if your predicted path is not very likely, then you're better off avoiding them, as
you'll actually slow your code down a little. Compiler-assisted run-time profiling The gcc
documentation contains the following advice regarding the use of __builtin_expect():

    In general, you should prefer to use actual profile feedback for this (-fprofile-arcs), as
    programmers are notoriously bad at predicting how their programs actually perform. However,
    there are applications in which this data is hard to collect. 

That's good concise advice. To put things another way, the only time you should use
__builtin_expect() is when you can't use compiler-assisted runtime optimization (perhaps because
your program has no easily repeatable pattern of execution-the Linux kernel is an obvious example)
and you are certain that your predicted code path is very (very) likely to be the one that will be
taken.


{reading-one}
This is about branch-prediction and optimisation in a compiler. 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "else" block is more probable by saying that x is more likely to be
  // false(0)
  if(__builtin_expect(x, 0)) 
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
 
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
 
abc.o:     file format elf32-i386
 
Disassembly of section .text:
 
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   75 07                   jne    11 < testfun+0x11 >
   The compiler branches the "if" block and keeps "else" sequential
   a:   b8 06 00 00 00          mov    $0x6,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 19 00 00 00          mov    $0x19,%eax
  16:   eb f7                   jmp    f < testfun+0xf > 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "if" block is more probable by saying that x is more likely to be
  // true(1), non-zero.
  if(__builtin_expect(x, 1))
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
                                                                                                   
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
                                                                                                   
abc.o:     file format elf32-i386
                                                                                                   
Disassembly of section .text:
                                                                                                   
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   74 07                   je     11 < testfun+0x11 >
   The compiler branches the "else" block and keeps "if" sequential
   a:   b8 19 00 00 00          mov    $0x19,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 06 00 00 00          mov    $0x6,%eax
  16:   eb f7                   jmp    f < testfun+0xf >
<

 [KT] As shown, the probable cases are placed in sequencial and menas in the pipe line. So most of
 case there is no jump.

{example-from-glibc}

#if __GNUC__ >= 3
# define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
# define __glibc_likely(cond)	__builtin_expect ((cond), 1)
#else
# define __glibc_unlikely(cond)	(cond)
# define __glibc_likely(cond)	(cond)
#endif

  if (__glibc_unlikely (*s == L_('\0')))
    goto noconv;


==============================================================================
*kt_dev_gcc_200*	gcc and c++11

{gcc-preprocessor} 

http://gcc.gnu.org/onlinedocs/cpp/
/usr/bin/cpp

{preprocessor-options}

http://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html

-E

If you use the -E option, nothing is done except preprocessing. Some of these options make sense
only together with -E because they cause the preprocessor output to be unsuitable for actual
compilation. 

g++ -std=c++0x -E useargs.cpp > out.txt

<save-temp-option>
To produce three extra files with .i, .s and .o extension. The temporary files produced by
-save-temps flag in one go can be produced one by one by using the gcc flags -E, -C and -S at each
of the preprocessing, compilation and assembly steps respectively.


-D name=definition

The contents of definition are tokenized and processed as if they appeared during translation phase
three in a '#define' directive. In particular, the definition will be truncated by embedded newline
characters.

If you are invoking the preprocessor from a shell or shell-like program you may need to use the
shell's quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its argument list with
surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells,
so you will need to quote the option. With sh and csh, -D'name(args...)=definition' works.

-D and -U options are processed in the order they are given on the command line. All -imacros file
and -include file options are processed after all -D and -U options. 

-Wall

Turns on all optional warnings which are desirable for normal code. At present this is -Wcomment,
-Wtrigraphs, -Wmultichar and a warning about integer promotion causing a change of sign in #if
expressions. Note that many of the preprocessor's warnings are on by default and have no options to
control them. 

<to-get-header-lists>
-M
Instead of outputting the result of preprocessing, output a rule suitable for make describing the
dependencies of the main source file. The preprocessor outputs one make rule containing the object
file name for that source file, a colon, and the names of all the included files, including those
coming from -include or -imacros command line options. 


{predefined-macros}

http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros

The standard predefined macros are specified by the relevant language standards, so they are
available with all compilers that implement those standards. Older compilers may not provide all of
them. Their names all start with double underscores.

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus to test whether a
header is compiled by a C compiler or a C++ compiler. This macro is similar to __STDC_VERSION__, in
that it expands to a version number. Depending on the language standard selected, the value of the
macro is 199711L, as mandated by the 1998 C++ standard; 201103L, per the 2011 C++ standard; an
unspecified value strictly larger than 201103L for the experimental languages enabled by -std=c++1y
and -std=gnu++1y. 

__FILE__

This macro expands to the name of the current input file, in the form of a C string constant. This
is the path by which the preprocessor opened the file, not the short name specified in '#include' or
as the input file name argument. For example, "/usr/local/include/myheader.h" is a possible
expansion of this macro. [KT] For c files, this is a path from where run gcc to build.

<how-to-get-filename-without-full-path>

char *strrchr(const char *s, int c);
The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

#include <string.h>
#define FILE (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

int main()
{
   printf("file is %s\n", __FILE__);
   printf("file is %s:%d:%s\n", FILE, __LINE__, __PRETTY_FUNCTION__ );
}

__LINE__

This macro expands to the current input line number, in the form of a decimal integer constant.
While we call it a predefined macro, it's a pretty strange macro, since its "definition" changes
with each new line of source code. 

__FILE__ and __LINE__ are useful in generating an error message to report an inconsistency detected
by the program; the message can state the source line at which the inconsistency was detected. For
example,

     fprintf (stderr, "Internal error: "
                      "negative string length "
                      "%d at %s, line %d.",
              length, __FILE__, __LINE__);

An '#include' directive changes the expansions of __FILE__ and __LINE__ to correspond to the
included file. At the end of that file, when processing resumes on the input file that contained the
'#include' directive, the expansions of __FILE__ and __LINE__ revert to the values they had before
the '#include' (but __LINE__ is then incremented by one as processing moves to the line after the
'#include').

A '#line' directive changes __LINE__, and may change __FILE__ as well. See Line Control.

__func__ and __FUNCTION__ 

C99 introduces __func__, and GCC has provided __FUNCTION__ for a long time. Both of these are
strings containing the name of the current function (there are slight semantic differences; see the
GCC manual). Neither of them is a macro; the preprocessor does not know the name of the current
function. They tend to be useful in conjunction with __FILE__ and __LINE__, though. 

__PRETTY_FUNCTION__

http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html

GCC provides three magic variables that hold the name of the current function, as a string. The
first of these is __func__, which is part of the C99 standard:

The identifier __func__ is implicitly declared by the translator as if, immediately following the
opening brace of each function definition, the declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing function. This name is the
unadorned name of the function.

__FUNCTION__ is another name for __func__. Older versions of GCC recognize only this name. However,
it is not standardized. For maximum portability, we recommend you use __func__, but provide a
fallback definition with the preprocessor:

     #if __STDC_VERSION__ < 199901L
     # if __GNUC__ >= 2
     #  define __func__ __FUNCTION__
     # else
     #  define __func__ "<unknown>"
     # endif
     #endif

In C, __PRETTY_FUNCTION__ is yet another name for __func__. 

>
 However, in C++, __PRETTY_FUNCTION__ contains the type signature of the function as well as its bare
 name. For example, this program:
<
     extern "C" {
     extern int printf (char *, ...);
     }
     
     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };
     
     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)  // [KT] seems useful

These identifiers are not preprocessor macros. In GCC 3.3 and earlier, in C only, __FUNCTION__ and
__PRETTY_FUNCTION__ were treated as string literals; they could be used to initialize char arrays,
and they could be concatenated with other string literals. GCC 3.4 and later treat them as
variables, like __func__. In C++, __FUNCTION__ and __PRETTY_FUNCTION__ have always been variables. 


==============================================================================
*kt_dev_gcc_300*	gcc gprof

http://sourceware.org/binutils/docs/gprof/


# ============================================================================
#{

==============================================================================
*kt_dev_lang_001*	global, file and local static

{local-static} {global-static} 

Global vars has a program scope, global static has a file scope <file-static>, and local static has a
func scope <function-static>. file-static is from C and should use <unnamed-namespace> in C++. 

local-static == function-static. global-static == file-static.

void foo () {   
	 static int x = 0;
	 ++x;
	 cout << x << endl;
}

int main (int argc, char const *argv[]) {
	 foo();  // 1
	 foo();  // 2
	 foo();  // 3
	 return 0;
}

The differences are:

The name is only accessible within the function, and has no linkage.(?) It is initialised the first
time execution reaches the definition, not necessarily during the program's initialisation phases.

<file-static-mean>

This applies to a function so if define static function, it has file scope. 

// file one
#include < iostream>

static int gfs_count;
// extern static int gfs_count; 
// this causes an compile error: conflicting specifiers in declaration of 'gfs_count'

void print_gfs()
{
   std::cout << "{ "; 
   
   for(int idx = 0; idx < 5; idx++)
		gfs_count++;

   std::cout << gfs_count << std::endl;

   std::cout << "}" << std::endl; 
}

// file two
#include < iostream>

extern int gfs_count;
extern void print_gfs();

int main()
{
   std::cout << "{ "; 
   
   std::cout << gfs_count << std::endl;	// if remove this, no link error
	print_gfs();

   std::cout << "}" << std::endl; 
}

No error in building and in using function from file one but failed to link in file two:

kit@kit-vb:~/work$ make
echo '>> build use-main.cpp'
>> build use-main.cpp
g++ -std=c++0x -o main.o -c use-main.cpp
echo '>> build file-static.cpp'
>> build file-static.cpp
g++ -std=c++0x -o file.o -c file-static.cpp
echo '>> bulid main'
>> bulid main
g++ -std=c++0x -o out main.o file.o
main.o: In function `main':
use-main.cpp:(.text+0x1e): undefined reference to `gfs_count'
collect2: ld returned 1 exit status
make: *** [main] Error 1


{init-order-problem}

The second difference can be useful to avoid the intialisation order fiasco, where global
variables(non-local static) can be accessed before they are initialised. By replacing the global
variable with a function that returns a reference to a local static variable, you can guarantee that
it is initialised before anything accesses it. 


# file A
class FileSystem {
	 public:
	 ...
	 std::size_t numDisk() const;
	 ...
};

extern FileSystem tfs;

# file B
class Directory {
	 Directory()
	 {
		  std::size_t = tfs.numDisk();
		  ...
	 }
	 ..
};

Directory tempDir( params );

How can you be sure that tfs will be initialised before tempDir? Use <function-static>. See
*kt_dev_lang_001* for terms. EC++04 said it is common implementation of <singleton-pattern>

# file A
class FileSystem {
	 ...
};

# extern FileSystem tfs;
FileSystem& tfs()
{ >
	 static FileSystem fs; return fs;
}

# file B
class Directory {
	 ... use tfs
};

# Directory tempDir( params );
Directory& tempDir()
{ >
	 static Directory td(tempDir); return td;
}


{singleton-pattern}

<why-singleton>
From design pattern. Using global/static objects have two problems:

o Do not keep you from instantiating multiple objects of the same type(class). Not about the name.
class X one_instance; class X two_instance.  
o init-order-problem. 

Good things over global by making a class itself responsible for keeping track of its sole instance:

o instance control such as only one instance
o single point of controlled access. there is no such a thing for global objects.
o no creation if it is not called. See {limit-the-number-of-object}. In the following example, no
create unless a user call instance() but global do not.

<common-implementation>
class Singleton {
	 public:
	 'static' Singleton* Instance();   // single-point-of-access

	 'protected':                      // to-make-sure-one-instance
	 Singleton() {};                   // there should be an implementation. otherwise, undefined err

	 private:
	 'static' Singleton* _instance;    // can have different concrete classes
};

Singleton* Singleton::_Instance = 0;

The singleton is similar to factory-func in that it has a single point to create hence static func.
It is different in that it maintain only single instance and creates its instance. But factory-func
creates other class other than itself.

<no-preventing-copies>
No preventing-copies for singleton. Why? Because there is no object creation. See
{preventing-copies} for more.

<lazy-initialisation> 
Means that do not create instance until its first access.

Singleton* Singleton::Instance() {
	 if(_instance==0) {
		  _instance = new Singleton;
	 }
	 return _instance;
}

<singleton-and-factory-func>
Like to have singleton feature and flexibility to choose what to create?

// first-way

There are many ways to specify a derived class to create. See {interface-class}. The other way in
design pattern, use <registry> to find a class to create which is more flexible because it is open
to possible singleton class meaning no Instance() change when there are new sigleton class and to
set it at run-time.

class Singleton {
	 public:
	 'static' void Register( char* name, Singleton* );
	 'static' Singleton* Instance();

	 protected:
	 'static' Singleton* Lookup( const char* name );

	 private:
	 'static' Singleton* _instance;
	 'static' List< NameStingletonPair >* _registry;
};

Singleton* Singleton::Instance() {

	 if(_instance==0) {

		  const char* singletonName = getenv("SINGLETON");
		  _instance = Lookup(singletonName);
	 }
	 return _instance;
}

// to register
MySingleton::MySingleton() {
	 ...
	 Singleton::Register( "MYSINGLETON", this );
}

// to create and used file static. hence no protected ctor but how about parent class?
static MySingleton mySingleton;
static XXSingleton XXSingleton;

theSingleton.Instance(); 	// ? since it is staic function

The cons of this is that all possible singleton classes must be created before register since must
build a list to look up beforehand. Here single instance for a selcted class and can think a set of
single instance for each class. How about multiple instance of a class? 


// [second-way] from design pattern.

class MazeFactory {
	 public:
	 	static MazeFactory* Instance();
		... public interfaces ...

	 protected:
	 	MazeFactory();

	 private:
	 	static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::Instance () {
	 if( _instance == 0 ) {
		  _instance = new MazeFactory;
	 }

	 return _instance;
}

To create different classes:

MazeFactory* MazeFactory::Instance () {
	 if( _instance == 0 ) {
		  const char* mazeStyle = getenv("MAZESTYLE");

		  if( strcmp( mazeStyle, "bombed" ) == 0 ) {
		  		_instance = new BombedMazeFactory;
		  }
		  else if( strcmp( mazeStyle, "ehchanted" ) == 0 ) {
		  		_instance = new EnchantedMazeFactory;

		  // other possible subclasses which means this should be modified whenever there are new
		  // subclasses.

	 	  } else { // default
				_instance = new MazeFactory;
		  }
	 }

	 return _instance;
}

* [KT] How about this? NOT OK because there must be an instance to call Instance() but ctor is
protected. So MUST use <class-method>, staic-member-func, for singleton-pattern.

class MazeFactory {
	 public:
	 	'virtual' MazeFactory* Instance(); 
		... public interfaces ...

	 protected:
	 	MazeFactory();

	 private:
	 	static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

BombedMazeFactory* BombedMazeFactory::Instance () {
	 if( _instance == 0 ) {
		  _instance = new BombedMazeFactory;
	 }

	 return _instance;
}


{limit-the-number-of-object}

MEC++26. This is example of <function-static>

class PrintJob;

class Printer {
	public:
	 	void reset();
		...

		friend Printer& thePrinter(); # why need this? because need to call ctor.

	private:        # <ban-to-create-directly>
		Printer();
		Printer( const Printer& rhs );
		...
};

Printer& thePrinter()
{
	 static Printer p; 
	 return p;
}

Use:

thePrinter().reset();

The other approach is to make it static member and then it make use a bit wordier:

Printer::thePrinter().reset();

Recommend <funciton-static> over class-variable because:

o no creation if no func call. An object that is static in a class is, for all intents and purposes,
always constructed (and destructed), even if it is never used. KT: This has nothing to do with
static because class member object will be created regardless of static.

o prevent {init-order-problem} since this could happen anything but function-static.

KT. This method do lazy-initialisation automatically and seems to be a good alternative to
singletone?


{{control-the-number-of-object}}

class Printer {
	 public:
	 	class TooManyObjects { };

		Printer();
		~Printer();
		...

	private:
		static size_t numObjects;
		Printer(const Printer& rhs); # no-copy-ctor
};

size_t Printer::numObjects = 0;

Printer::Printer()
{
	 if( numObjects >= 1 ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}

Printer::~Printer()
{
	 ...
	 --numObjects;
}

The pros is that easy to understand and to support any number of objects.

The cons is that is not working in following cases; inheritance and <containment>. Both can be
prevented by having private ctor because cannot create object:

class ColorPrinter : public Printer {
	 ...
};

Printer p;
ColorPrinter cp;  # cause-an-exception


class X {
	 private:
	 	Printer p;
		...
};

X m1;
X m2;             # cause-an-exception

Both cases call ctor twice and these can be prevented by having ctor private. Here note that static
var, class-static, remains a single across objects of its class.


{{pseudo-ctor}}

class FSA {
	 public:
	 	static FSA* makeFSA();
	 	static FSA* makeFSA( const FSA& rhs );
		...

	private:
		FSA();
		FSA( const FSA& rhs );
		...
};

FSA* FSA::makeFSA()
{ return newFSA(); } # okay as it is member func

When make ctors private, cannot create object. Hence no derivation and containment. This pseudo-ctor
approcah means that client must delete and can use smart pointer for that.


{{multiple-time-instance-in-liecycle}}

<file-static> has only one instance for whole program life so not possible to do:

create Printer object p1;
use p1;
destroy p1;
create Printer object p2;
use p2;
destroy p2;

If use both control-the-number-of-object and prventing derivation, then have single instance in
multiple times for whole program life.

class Printer {
	 public:
	 	class TooManyObjects { ... };

		static Printer* makePrinter();
		~Printer();
		void reset();
		...

	private:
		static size_t numObjects;
		Printer();
		Printer( const Printer& rhs );
};

size_t Printer::numObjects = 0;

Printer::Printer()
{
	 if( numObjects >= 1 ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}

Printer* Printer::makePrinter()
{ return new Printer(); }

Can return null pointer instead of issuing an exception.

To supports more than one:

class Printer {
	 public:
	 	class TooManyObjects { ... };

		static Printer* makePrinter();
		~Printer();
		void reset();
		...

	private:
		static size_t numObjects;
		static const size_t maxObjects = 10;
		Printer();
		Printer( const Printer& rhs );
};

size_t Printer::numObjects = 0;
const size_t Printer::maxObjects;

Printer::Printer()
{
	 if( numObjects >= maxObjects ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}


{{to-support-different-instance}}

If there are many other types of instances to manage? Make it generalise and use template:

template< class T > # T is type being counted
class Counted {     # instance counting class
	 public:
	 	class TooManyObject { ... };
		static size_t objectCount() { return numObjects; }

	protected:       # <to-make-it-used-only-as-base-class>
		Counted();
		Counted( const Counted& rhs );
		~Counted() { --numObjects; };

	private:
		static size_t numObjects;
		static const size_t maxObjects;
		void int();
};

template< class T>
Counted< T >::Counted()
{ init(); }

template< class T>
Counted< T >::Counted( const Counted< T >& )
{ init(); }

template< class T>
void Counted< T>::init()
{
	 if( numObjects >= maxObjects )
		  throw TooManyObjects();
	
	++numObjects;
}


template< class T> size_t Counted< T>::numObjects;


Each derived class, Counted< T>, has independant counter and manage counting mechanism which is
<encapsulation>

Client use:

class Printer : private Counted< Printer> {
	 public:
	 	static Printer* makePrinter();
	 	static Printer* makePrinter( const Printer& rhs );
		 
		~Printer();
		void reset();
		...

		note: to make these public
		using Counted< Printer>::objectCount;
		using Counted< Printer>::TooManyObjects;

	private:
		Printer();
		Printer( const Printer& rhs );
};

note: Client should set static values which is a bit of loose end. If not, link error.

const size_t Counted< Printer>::maxObjects = 10;
const size_t Counted< FileDescripter>::maxObjects = 16;


{further-study}

(However, there is still no guarantee that it will not be destroyed before anything finishes
accessing it; you still need to take great care if you think you need a globally-accessible
variable. See the comments for a link to help in that situation.)

That is, init order fiaso means that there is no gurantee on the order of init when global and
global static init each other. e.g. if there are A and B object and B uses a method of A, then it is
a problem when B is created first.

The solution to this is to use local static:

http://www.parashift.com/c++-faq-lite/static-init-order-on-first-use.html
http://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746

note: KT. since it's best to avoid global object, do not study it further.


==============================================================================
*kt_dev_lang_002*	func pointer

In the past, void (*fptr)(); can define a func that has <any-args> but that is not the case any more
when tested with gcc and VC as of 2013.03.

{func-ptr-typedef}

This is wrong:

typedef int ENTRYTYPE;

typedef void(*)(int) TFUNC; // [KT] wrong

void stacktraverse( stack* stack, TFUNC func)
{
	func(val);
}

This is right:

typedef void(*TFUNC)(int);

void stacktraverse( stack* stack, TFUNC func)
{
	func(val);
}

Also, the following causes error:

queue-contig.cpp:60:35: error: expected identifier before '(' token
queue-contig.cpp:60:41: error: expected ',' or '...' before '*' token

void stacktraverse( stack* stack, (void)*func(int))
{
}


==============================================================================
*kt_dev_lang_003*	#error and #warning

// stops compilation
#error "unknwon cpu - you need to find out the stack grows downward or upward"

// get a mesg during compilation like:
// NDS_pthread.c:43:4: warning: #warning "xxx2" 
#warning "xxx2"


==============================================================================
*kt_dev_lang_004*	post and pre inc/dec

{when-different-pre-and-post-inc}

For example, there are situations where the value of post or pre makes differences: note when used
in string index such as examples *kt_dev_code_001*


{compounded-inc}

From C prog lang, p95, 105:

int *ip;

*ip++;		// inc ip itself
(*ip)++;		// inc *ip, not ip


NOTE: 
<post-inc> is higher than <pre-inc> and dereference. <pre-inc> and dereference has the same
precedence and right(right-to-left) assoc.  


/* strcpy: copy t to s; pointer version 
 * lib: The strcpy() and strncpy() functions return a pointer to the destination string dest
 */
void strcpy( char *s, char *t )
{
	 while( *s++ = *t++ ) 
		  ;
}

Here <right-to-left> for '=' op and <post-inc> are involved. "the value of *t++ is the char that t
pointed to 'before' t was incremented; the postfix does not change t until after this char has been
fetched." This is a bit confusing.

The before and after explanation says that ++n inc n 'before' its value is used and n++ inc n
'after'. Or some says that post-inc returns the previous copy. 

For *pbeg++, <post-inc> is high than dereference(*) so it's the same as *(pbeg++). but how this
behave as *(pbeg); pbeg++; ? because it returns the previous copy. This is how Primus explains. THIS
is answer and this matches to asm result.

Here there are three operations; fetch, increase and dereference. post-inc do fetch and increase but
return the value before increase and dereference it.


{post-inc-overload}

MEC++06. <post-inc> can be ineffective when used on user-type; overloads. 

 The prefix form of the increment operator is sometimes called - increment and fetch, while the
 postfix form is often known as fetch and increment.

class UPInt {                             // "unlimited precision int"
public:
	 UPInt& operator++();                  // prefix ++
	 'const' UPInt operator++(int);          // <postfix> ++
	 UPInt& operator--();                  // prefix --
	 const UPInt operator--(int);          // <postfix> --
	 UPInt& operator+=(int);               // a += operator for UPInts and ints
...
};

UPInt i;

++i; // calls i.operator++();
i++; // calls i.operator++(0);             // to distinguish with '++i'
--i; // calls i.operator--();
i--; // calls i.operator--(0);

// prefix form: increment and fetch
UPInt& UPInt::operator++()
{
	 *this += 1;                   // increment
	 return *this;                 // fetch
}

// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
	 const UPInt oldValue = *this; // fetch
	 ++(*this);                    // increment
	 return oldValue;              // return what was fetched
}

Note how the postfix operator makes no use of its parameter.


{tip}

The only purpose of the parameter is to distinguish prefix from postfix function invocation. Many
compilers issue warnings if you fail to use named parameters in the body of the function to which
they apply, and this can be annoying. To avoid such warnings, a common strategy is to omit names for
parameters you don't plan to use; that is what is been done above.


<why-const-in-post-inc> {const-return}

If you have ever wondered if it makes sense to have functions return const objects, now you know:
sometimes it does, and postfix increment and decrement are examples.

If not, it allows this:

i++++;

So to make it behave like premitive type, return const.

<should-prefer-post-inc-when-use-none-premitive>

The prefix increment function has no such temporaries. This leads to the possibly startling
conclusion that, for efficiency reasons alone, clients of UPInt should prefer prefix increment to
postfix increment unless they really need the behavior of postfix increment.

When dealing with user-defined types, prefix increment should be used whenever possible, because it
is inherently more efficient.

The principle is that postfix increment and decrement should be implemented in terms of their prefix
counterparts. You then need only maintain the prefix versions, because the postfix versions will
automatically behave in a consistent fashion.


<in-particular>

Primus(p148) recommends prefix version than postfix because post-inc increase first and
return(yield) the previous copy and it cost extra. it may have no effect for built-in types due to
optimization but may be expensive for <iterators>. See *kt_dev_stl_007* for iter++ example.

auto pbeg = v.begin();

while(...)
	 cout << *pbeg++ << endl;


{simple-post-asm}

Used gcc and de-asm for MIPS. when try simple post inc, it shows like that fetch and then inc. no
use of the previous copy.

## post
##

#include <stdio.h>

int main()
{
	int i = 0, j = 0;
	
	j = i++;
	printf("j is %d\n", j );
	return 0;
}

# 
#
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       afbf0024        sw      ra,36(sp)
  400598:       afbe0020        sw      s8,32(sp)
  40059c:       03a0f021        move    s8,sp       # save sp to s8. s8 is sp.
  4005a0:       afc0001c        sw      zero,28(s8) # i = 0
  4005a4:       afc00018        sw      zero,24(s8) # j = 0
  4005a8:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005ac:       afc20018        sw      v0,24(s8)   # j = i
  4005b0:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005b4:       24420001        addiu   v0,v0,1     # v0(i) = i+1
  4005b8:       afc2001c        sw      v0,28(s8)   # i = v0
  4005bc:       3c020040        lui     v0,0x40
  4005c0:       24440690        addiu   a0,v0,1680
  4005c4:       8fc50018        lw      a1,24(s8)   # get j and call print
  4005c8:       0c100124        jal     400490 <printf@plt>
  4005cc:       00000000        nop
  4005d0:       00001021        move    v0,zero
  4005d4:       03c0e821        move    sp,s8
  4005d8:       8fbf0024        lw      ra,36(sp)
  4005dc:       8fbe0020        lw      s8,32(sp)
  4005e0:       27bd0028        addiu   sp,sp,40
  4005e4:       03e00008        jr      ra
  4005e8:       00000000        nop
  4005ec:       00000000        nop

##
## -Os
##
00400590 <main>:
  400590:       3c040040        lui     a0,0x40
  400594:       27bdffe0        addiu   sp,sp,-32
  400598:       24840658        addiu   a0,a0,1624
  40059c:       afbf0018        sw      ra,24(sp)
  4005a0:       0c100124        jal     400490 <printf@plt>
  4005a4:       00002821        move    a1,zero
  4005a8:       8fbf0018        lw      ra,24(sp)
  4005ac:       00001021        move    v0,zero
  4005b0:       03e00008        jr      ra
  4005b4:       27bd0020        addiu   sp,sp,32  


{pointer-case}

#include <stdio.h>

void print_array(int arr[], int len)
{
	int *pend;
	
	pend = arr+len;

	while( arr != pend )
		printf("arr is : %d\n", *arr++ );
}

int main()
{
	int int_arr[] = { 1,2,3,4,5,6,7,8,9,10};
	
	print_array(int_arr, sizeof(int_arr)/sizeof(int));
	
	return 0;
}


004005c0 <print_array>:
  4005c0:       27bdffd8        addiu   sp,sp,-40
  4005c4:       afbf0024        sw      ra,36(sp)
  4005c8:       afbe0020        sw      s8,32(sp)
  4005cc:       03a0f021        move    s8,sp
  4005d0:       afc40028        sw      a0,40(s8)	# arr
  4005d4:       afc5002c        sw      a1,44(s8)	# len
  4005d8:       8fc2002c        lw      v0,44(s8)	# get len
  4005dc:       00021080        sll     v0,v0,0x2	# v0 = v0 << 2. 101000 (40)
  4005e0:       00401821        move    v1,v0		# v1 = len
  4005e4:       8fc20028        lw      v0,40(s8)	# get arr
  4005e8:       00621021        addu    v0,v1,v0	# v0 = len + arr {pend}
  4005ec:       afc20018        sw      v0,24(s8)	# save v0
  4005f0:       08100188        j       400620 <print_array+0x60>
  4005f4:       00000000        nop
{4005f8}:       8fc20028        lw      v0,40(s8)	# << get arr {inced-arr}
  4005fc:       8c430000        lw      v1,0(v0)	#    get *arr note. {deref} 0($x)
  400600:       8fc20028        lw      v0,40(s8)	#    get arr
  400604:       24420004        addiu   v0,v0,4		#    arr++
  400608:       afc20028        sw      v0,40(s8)	#    save arr++
  40060c:       3c020040        lui     v0,0x40		#    
  400610:       24440750        addiu   a0,v0,1872
  400614:       00602821        move    a1,v1		#    *arr
  400618:       0c10012c        jal     4004b0 <printf@plt>
  40061c:       00000000        nop
{400620}:       8fc30028        lw      v1,40(s8)	# < get arr {inced-arr}
  400624:       8fc20018        lw      v0,24(s8)	#   get pend {const}
  400628:       1462fff3        bne     v1,v0,4005f8 <print_array+0x38>	# !=
  40062c:       00000000        nop
  400630:       03c0e821        move    sp,s8
  400634:       8fbf0024        lw      ra,36(sp)
  400638:       8fbe0020        lw      s8,32(sp)
  40063c:       27bd0028        addiu   sp,sp,40
  400640:       03e00008        jr      ra
  400644:       00000000        nop

00400648 <main>:
  400648:       27bdffb8        addiu   sp,sp,-72
  40064c:       afbf0044        sw      ra,68(sp)
  400650:       afbe0040        sw      s8,64(sp)
  400654:       03a0f021        move    s8,sp
  400658:       3c020040        lui     v0,0x40
  40065c:       27c30018        addiu   v1,s8,24
  400660:       24420760        addiu   v0,v0,1888
  400664:       24060028        li      a2,40
  400668:       00602021        move    a0,v1
  40066c:       00402821        move    a1,v0
  400670:       0c100130        jal     4004c0 <memcpy@plt>	# may be copy array into stack (24)?
  400674:       00000000        nop
  400678:       27c20018        addiu   v0,s8,24
  40067c:       00402021        move    a0,v0
  400680:       2405000a        li      a1,10	# len
  400684:       0c100170        jal     4005c0 <print_array>
  400688:       00000000        nop
  40068c:       00001021        move    v0,zero
  400690:       03c0e821        move    sp,s8
  400694:       8fbf0044        lw      ra,68(sp)
  400698:       8fbe0040        lw      s8,64(sp)
  40069c:       27bd0048        addiu   sp,sp,72
  4006a0:       03e00008        jr      ra
  4006a4:       00000000        nop
        ...
		
004004c0 <memcpy@plt>:
  4004c0:       3c180040        lui     t8,0x40
  4004c4:       8f1917d8        lw      t9,6104(t8)
  4004c8:       03200008        jr      t9
  4004cc:       271817d8        addiu   t8,t8,6104


==============================================================================
*kt_dev_lang_005*	chaining

int v1, v2;
cin >> v1 >> v2;

cout << "Enter numbers:" << endl;

Because operators returns reference of {left-hand-operand} which is cin and cout.


==============================================================================
*kt_dev_lang_006*	copile error types

syntax, type mismatch, and declaration error


==============================================================================
*kt_dev_lang_007*	bool type

Do not have a minimum size. In VC, is the same as int type. 

There is differece in return value from main and bool type. In return from main,

int main()
{
	 return 0; # for okay. true seems to be 0?
	 return ?; # any other value, error code, for not okay 
}


{non-bool-to-bool}

When assign non-bool to bool type, type conversion happens and got 0 or 1 depending on the value of
non-bool. That is false for 0 and true for [any-other-values] other than 0.


bool b = 42;    # b is true

When bool to non-bool, has 1 or 0.


{true-and-false} {bool-to-non-bool}

The 'true' and 'false' are [literals-of-type-bool]. true is non-zero but not 1. 

if( val == true ) { ... }

If val is non-bool type, conversion to non-bool which is bigger type happens and this becomes 

if( val == 1 ) { ... }

This may not be what intented if meant for cases of non-zero because it runs only when val is 1.
Therefore, want the case of when val is 1 then do it directly. The direct form is:

if(val) or if(!val) 

It is usually bad idea to use the boolean literals true and false as operands in a comparison. These
literals should be used only to compare to [an object of type bool].


{not-use-in-computation}

Do not use bool and char for computation since there is conversion. For example:

bool b1 = true;
bool b2 = -b1;

b2 is true since b1 promoted to 1, negates to -1, and convert back to bool but it is not a zeor
hence true.


==============================================================================
*kt_dev_lang_008*	char type

The char is not singed char. there are char, signed, unsigned types because whether char is signed
or unsigned depends on compiler. So recommendation is that use signed or unsigned.


==============================================================================
*kt_dev_lang_009*	implicit conversion (built-in conversion)

See *kt_dev_cpp_005* for class-type conversion.

Primers p159. Happens when used in expression, func call and func matching

int ival = 3.541 + 3;

Causes promotion to double first and conversion to int next.

cases:

1. promote smaller types to int. when mixed, promote to a bigger type.
2. convert to bool in condition but not always possible. see below.
3. 'left = right' in init. promote right to left or can be truncated.
4. convert to signed to unsigned.


{bool-conversion} {equal-misspell}

<1>

The fact that we can use assignment in a condition can have surprising effects:

if (i = j)

The condition like this which assigns the value of j to i and then tests the result of the
assignment. If j is nonzero, the condition will be true. The author of this code almost surely
intended to test whether i and j have the same value:

if (i == j)

Bugs of this sort are notoriously difficult to find. Some, but not all, compilers are kind enough to
warn about code such as this example.


<2> 

auto loc = wordmap.find( sought );

if( loc = wordmap.end() )	// meant if( loc == wordmap.end() )

GCC error is:

tquery.cpp:63: error: could not convert '(loc <unknown operator> ((const
std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>,
std::allocator<char> >, std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>,
std::allocator<long unsigned int> > > > >&)((const std::_Rb_tree_const_iterator<std::pair<const
std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>, std::allocator<long
unsigned int> > > > >*)(&((const TextQuery*)this)->TextQuery::wordmap.std::map<_Key, _Tp, _Compare,
_Alloc>::end [with _Key = std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
_Tp = std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>, std::allocator<long
unsigned int> > >, _Compare = std::less<std::basic_string<char, std::char_traits<char>,
std::allocator<char> > >, _Alloc = std::allocator<std::pair<const std::basic_string<char,
std::char_traits<char>, std::allocator<char> >, std::shared_ptr<std::set<long unsigned int,
std::less<long unsigned int>, std::allocator<long unsigned int> > > > >]()))))' to 'bool'

This happens when tries to covert loc iterator to bool. If it were ==, then operator== would return
bool type.

<3>

Meant to be == and this if is always true.

bool QueueFull(Queue* queue)
{
   if( queue->count = MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}


{signed-vs-unsigned}

unsigned char uc = -1;	// out-of-range. 255. {wrap-around}
signed char sc = 256;	// out-of-range. -128...127. undefined value
 
Recommends that don't mix between them:

<one> Same as wrap-around

unsigned ui = 10; int i = -42;
cout << ui + i << endl;

<two> 

unsigned int u1 = 42, u2 = 10;
cout << u2 - u1 << endl;

These two cases shows the same result. 4294967264. why? because converted to unsigned.

<three>

for( unsigned u = 10; u >= 0; --u )
	 cout << n << endl;

Causes <infinite-loop> because u = -1 and means big number.


==============================================================================
*kt_dev_lang_010*	incomplete type

{text-query-example}
Primus p484. The output for query word 'element' is:

element occurs 112 times
	(line 36) A set element contains only a key;
	(line 158) operator creates a new element
	...

Requirements are that show line number, ascending order, no duplicates, and line text which contains
the word. Also support multi pass until user quit.


<more-abstract-solution>
Used class instead of using set, map, and vector directly. [DN] How to design what this query func
return without cost of copying? Yes, shared_ptr.

TextQuery:                         shared:dyn creted   QueryResult:
 shared_ptr vector : file           vector              shared_ptr
  line 0
  line 1
  line 2
  ...
 
 map : < word, ptr-to-set>
  word x, -> set : line nos         sets                shared_ptr
  word y, -> set : line nos


class QueryResult;	// forward declaration

class TextQuery {
  public:
    using line_no = std::vector<std::string>::size_type; // [type-member]

    TextQuery( std::ifstream& );
    QueryResult query( const std::string& ) const;

  private:
    std::shared_ptr<std::vector<std::string>> file; // input file
    std::map<std::string, std::shared_ptr< std::set< line_no >>> wm;
};

// TextQuery member definitions

TextQuery::TextQuery( ifstream& is ) : file( new vector< string >) // new vector
{
  string text;

  while( getline( is, text )) {     // for each line. std::getline
    file->push_back(text);          // save line
    int n = file->size() -1;        // get line num. -1 to make line num the same as vector index

    istringstream line(text);
    string word;

    while( line >> word ) {                  // for each word of a line
      // see that lines is reference
      auto& lines = wm[word];                // add new entry if word is not in wm
      // value-init and lines will be null
      if( !lines )                           // lines is shared_ptr
        lines.reset( new set< line_no > );   // new set

      lines->insert(n);                      // save line num which shown this word
      // word occurs more than once in the same line, do nothing.
    }
  }
}

Think what should return if the given string is not found because there is no set for this? Used
a empty set which is local static, function-static.

QueryResult TextQuery::query( const string& sought ) const
{
  static shared_ptr< set< line_no >> nodata( new set< line_no > );

  auto loc = wordmap.find( sought ); // [Quiz] why find instead of subscript?

  if( loc == wordmap.end() )
    return QueryResult( sought, nodata, file );
  else
    return QueryResult( sought, loc->second, file );		
}

class QueryResult {
  friend std::ostream& print( std::ostream&, const QueryResult& );

  public:
  // this is missed in the book.
  using line_no = std::vector<std::string>::size_type; // [type-member]

  QueryResult( std::string s,
      std::shared_ptr< std::set<line_no>> p,
      std::shared_ptr< std::vector< std::string >> f ): sought(s), lines(p), file(f) {}
  private:
  std::string sought;
  std::shared_ptr< std::set<line_no>> lines;
  std::shared_ptr< std::vector< std::string >> file;
};


{BP} When design a class, can be helpful to write programs using the class before implementing the
members. That way, can see whether the class has the operation we need. WHAT OPERATION WE NEED hels
us see WHAT DATA STRUCTURE we will need.

void runQueries(ifstream& infile)
{
  TextQuery tq(infile);

  while(true) {
    cout << "enter the word to look for, or q to quit: ";
    string s;

    // stop if hit eof or q
    if( !(cin >> s) || s == "q" ) break;

    print( cout, tq.query(s)) << endl;
  }
}

ostream &print( ostream& os, const QueryResult& qr)
{
  os << qr.sought << " occurs " << qr.lines->size() << " " << make_plural( qr.lines->size(),
      "time", "s") << endl;

  // when *qr.lines is empty, the loop will not be executed.
  for( auto num : *qr.lines )
    os << "\t(line " << num + 1 << ") " << *(qr.file->begin() + num) << endl;

  return os;
}

Got following errors:

tquery.cpp: In member function 'QueryResult TextQuery::query(const std::string&) const':
tquery.cpp:58: error: return type 'struct QueryResult' is incomplete ~
tquery.cpp:65: error: invalid use of incomplete type 'struct QueryResult' 
tquery.cpp:12: error: forward declaration of 'struct QueryResult'
tquery.cpp:67: error: invalid use of incomplete type 'struct QueryResult'
tquery.cpp:12: error: forward declaration of 'struct QueryResult'

When move query func after class QueryResult then these errors go away. Why?


{extented-text-query-example}
How to support these queries? ~(str), str, (str|str), (str&str), (str&str|str) which use normal C++
precedence rules.

<OOP-solution>
Can use TextQuery? No. To see why, consider a Not query and we would have to able to find the word
for which the Not query was searching. There is no such word. Instead a Not query has a query whose
value it negates. Similarly, And and Or query have two queries whose results it combines. This
suggests that we model our different kinds of queries as independent classes that share a common
base class. The solution is to have four classes which has the same interface and use ABC.

<DN-ABC>
o These four query types are not related to one another by inheritance; not related in vertically
and they are conceptually siblings and shares the same interface. This suggest that will need to
define ABC to represent that interface.

o The AndQuery and OrQuery share one property that the other classes do not. Each has two operands.
To model this, define another ABC to represent queries with two operands.

<DN-interface>
o We need to able to build queries. The simplest way is to write C++ expressions to create the
compounded queries:

   Query q = Query("fiery") & Query("bird") | Query("wind");

This suggests that user code won't use the inherited class directly. Instead, will define an
interface class named Query which hide the hierarchy and has the same operations as Query_base. It
will have three overloaded operators and ctor.

   - & operator will [create] a Query bound to a new AndQuery.
   - | operator will [create] a Query bound to a new OrQuery.
   - ~ operator will [create] a Query bound to a new NotQuery.
   - Query ctor that takes a string will create a Query bound to a new WordQuery.

<DN-SP>
o In each of these classes, the operand(s) can be an object of any of the concrete classes derived
from Query_base: NotQuery can be applied to an AndQuery. To allow this flexibility i.e., compound
query, the operands must be stored as pointers to Query_base so that can bind the pointer to
whichever concrete class we need. However, rather than storing a Query_base pointer, will themselves
use a Query object as [user] code is simplified by using the interface. [KT] This is why BinaryQuery
has Query members.

<DN-no-public-interface-in-implementation>
There is no public interface in Query_base hierarchy.

<creation>
So objects created by the expression are:

   Query q = Query("fiery") & Query("bird") | Query("wind");
             - new WQ         - new WQ                    // temp Queries
                       - new ANDQ             - new WQ    // temp Queries, copied Queries and copyed SPs
                                           - new ORQ
                                           
                                           Query q        // All temp Queries will be destoried

   q = Query      OrQuery        AndQuery          WordQuery
         [ ] ->   [ ]      ->    [ ]      ->       [fiery] 
                                                   WordQuery
                                 [ ]      ->       [bird]

                  [ ]      ->    WordQuery
                                 [wind]

Once the [tree-of-objects] is built up, evaluating(or generating the representation of) a query is
basically a process of following these links, asking each object to evaluate itself. Call eval on q
which is the root of the tree, that call asks the OrQuery to which q points to eval itself.
Evaluating this OrQuery calls eval on its two operands- on the AndQuery and the WordQuery that looks
for the word bind. Evaluating the AndQuery evaluates its two WordQuerys, generating the results for
the words fiery and bird.

<class-hierarchy>
Inheritance hierarchy is:                                    

User     Query class             Query Base
         - interface class       - ABC
         - hide QB from user        |           |           | 
                                 WordQuery   NotQuery    BinaryQuery
                                                         - ABC
                                                            |           |
                                                         AndQuery    ORQuery

Q        NOTQ     AND or ORQ
-sp<QB>  - Q      - Q lhs, rls

// private ctor which prevent a user from creating derived class directly and due to this, make
// operator overloads friend to use ctor.
//
class Query {
  friend Query operator~( const Query& );
  friend Query operator|( const Query&, const Query& );
  friend Query operator&( const Query&, const Query& );

  public:
    Query( const std::string& );

    // [interface] for Query_base
    QueryResult eval(const TextQuery &t) const { return q->eval(t); }
    std::string rep() const { return q->rep(); }

  private:
    Query( std::shared_ptr<Query_base> query ): q(query) {}

    std::shared_ptr<Query_base> q;
};

inline Query::Query( const std::string &s ): q(new WordQuery(s)) {}

// ABC and no public interface since do not intend users or the derived class to use it directly.
// Query friend since it use Query_base's virtual call. See protected dtor since it is used
// implicitly by the dtor in the derived class.
//
class Query_base {
  friend class Query;

  protected:
    using line_no = TextQuery::line_no;
    virtual ~Query_base() = default;

  private:  // [interface]
    virtual QueryResult eval( const TextQuery& ) const = 0;
    virtual std::string rep() const = 0;
};

class WordQuery: public Query_base {
  friend class Query;

  WordQuery( const std::string &s ): query_word(s) {}

  QueryResult eval( const TextQuery &t ) const { return t.query(query_word); }
  std::string rep() const { return query_word; }
  std::string query_word;
};

<not>
class NotQuery: public Query_base {
  // make a function friend
  friend Query operator~(const Query &);

  NotQuery( const Query &q ): query(q) {}

  // concrete class
  QueryResult eval( const TextQuery &t ) const;
  
  // [DN] This ultimately makes a virtual call to rep because query.rep() is nonvirtual call but
  // Query::rep in turn calls q->rep, which is virtual call through its Query_base pointer. However,
  // see that there is NO public interface in implementation class hierarchy and virtual funcs does
  // work for this case even if this is private.
  //
  // Query::rep()
  //  -> q->rep()
  //     ORQ::rep()
  //        -> lhs.rep(); Query::rep()
  //                       -> q->rep()
  //                          ANDQ::rep()
  //                             -> lhs.rep(); Query::rep()
  //                                            -> q->rep()
  //                                               WQ::rep()
  //
  std::string rep() const { return "~(" + query.rep() + ")"; }

  Query query; // [DN]
};

o [DN] The return Query type and [implicitly] uses Query ctor that takes the shared_ptr so this is
equivalent to:

o Here used Query( std::shared_ptr<Query_base> query )

shared_ptr<Query_base> tmp(new NotQuery(expr));
return Query(tmp);

inline Query operator~(const Query &operand)
{ return std::shared_ptr<Query_base>( new NotQuery(operand)); }

<binary-query>
// ABC and do not define eval().
//
class BinaryQuery : public Query_base {
  protected:
    BinaryQuery( const Query &l, const Query &r, std::string s ):
      lhs(l), rhs(r), opSym(s) {}

    // [DN] This ultimately makes a virtual call to rep.
    std::string rep() const 
      { return "(" + lhs.rep() + " " + opSym + " " + rhs.rep() + ")"; }

    Query lhs, rhs;  // [DN]
    std::string opSym;
};

<and>
class AndQuery : public BinaryQuery {
  friend Query operator&( const Query&, const Query& );     // to use ctor

  AndQuery( const Query &left, const Query &right ):
    BinaryQuery( left, right, "&") {}

  QueryResult eval(const TextQuery&) const;
};

inline Query operator&( const Query &lhs, const Query &rhs )
{ return std::shared_ptr<Query_base>( new AndQuery(lhs, rhs) ); }

<or>
class OrQuery : public BinaryQuery {
  friend Query operator|( const Query&, const Query& );     // to use ctor

  OrQuery( const Query &left, const Query &right ):
    BinaryQuery( left, right, "|") {}

  QueryResult eval(const TextQuery&) const;
};

inline Query operator|( const Query &lhs, const Query &rhs )
{ return std::shared_ptr<Query_base>( new OrQuery(lhs, rhs) ); }


{class-definition} {forward-declaration}
Primers p279.

struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;

The semicolon marks the end of the (usually empty) list of declarators. It is a common mistake among
new programmers to forget the semicolon at the end of a class definition.

This declaration, sometimes referred to as a <forward-declaration>, introduces the name Screen into
the program and indicates that Screen refers to a class type. After a declaration and 'before' a
definition is seen, the type Screen is an <incomplete-type>-it is known that Screen is a class type
but not known what members that type contains.

<limited-use>
We can use an incomplete type in only limited ways: We can define pointers or references to such
types, and we can declare (but not define) functions that use an incomplete type as a parameter or
return type.

A class must be defined-not just declared-before we can write code that creates objects of that
type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the
class must be defined before a reference or pointer is used to access a member of the type. After
all, if the class has not been defined, the compiler cannot know what members the class has.

In sum, two problems that a compiler need to know class layout:

o cannot create object
o cannot defines funcs using return or params of incomplete type.

In this example, cannot create temp return object.


{missing-declaration}
For this cases, similar errors happens:

/src/main.c: In function '_terminate':
/src/main.c:91:8: error: dereferencing pointer to incomplete type
/src/main.c:92:21: error: dereferencing pointer to incomplete type


{typedef-errors}

<error-case>
struct List;         // 7

typedef struct node
{
  EntryType 	entry;
  node*			pnext;
  List*     plist;
} Node;

typedef struct {
   int   count;
	Node*	header;
} List;              // 19

gen-list-linked.cpp:19:3: error: conflicting declaration ‘typedef struct List List’
gen-list-linked.cpp:7:8: error: ‘struct List’ has a previous declaration as ‘struct List’


<okay-case>

struct list;

typedef struct node
{
	EntryType 	entry;
	node*			pnext;
  list*     plist;
} Node;

typedef struct list {
   int   count;
	Node*	header;
} List;


==============================================================================
*kt_dev_lang_011*	literal type

To specify the type of a literal. Primus p40.

char and char string literals

prefix      meaning          type
u           unicode 16 char  char16_t
U           unicode 32 char  char32_t
L           wide char        wchar_t
u8          utf-8            char


==============================================================================
*kt_dev_lang_012*	array

{pointer-conversion}

Done by compiler and the followings are the same.

void print( const int* );
void print( const int[] );
void print( const int[10] );


{ref-to-array}

int arr[6];

arr     0        5
[ ] -> [ ][ ]...[ ]

Here arr, &arr[0], &arr have the same address. But arr type is int(*arr)[6].  Note that this is
similar to function pointer definition. The size is part of type, that is, int(&)[10] in the
following case. The parentheses are needed and read from inside to outside. 

int (&arrRef) [ 10 ] = arr;	// refers to an array of ten ints

the reference param is bound to the corresponding arg

void print( int (&arr) [ 10 ])
{
	for( auto elem : arr )
		cout << elem << endl;
}

This could also means the first low of multidimensional array and the both are the same.

void print( int (*matrix)[10], int rowsize );
void print( int matrix[][10], int rowsize );


{sizeof-operator}

Queries size of the object or type. Used when actual size of the object must be known: 

sizeof( type ) 		
sizeof expression 		

Both versions return a constant of type std::size_t.

Explanation

1) returns size in bytes of the object representation of type.
2) returns size in bytes of the object representation of the type, that would be returned by
expression, if evaluated.  

Notes

Depending on the computer architecture, a byte may consist of 8 or more bits, the exact number being
recorded in CHAR_BIT.

sizeof(char), sizeof(signed char), and sizeof(unsigned char) always return 1.

Cannot be used with function types, incomplete types, or bit-field lvalues.

When applied to a reference type, the result is the size of the referenced type.

When applied to a class type, the result is the size of an object of that class [plus] any additional
padding required to place such object in an array.

When applied to an empty class type, always returns 1. 


{sizeof-operator-caveat}

int func()
{
	int arr[] = { ... };
	int length= sizeof(arr)/sizeof(int);
	...
}

This works fine as expected but if you pass array in func, it is converted to a pointer and the
return of sizeof is the size of pointer but not the array.

int func(int arr[])
{
	int length = sizeof(arr)/sizeof(int)-1; Note: THIS DOESN'T WORK!
	...
}


{sizeof-to-get-string-length}

int main()
{
   std::cout << "length is " << sizeof("DSM:!") << std::endl;
   std::cout << "length is " << strlen("DSM:!") << std::endl;
   std::cout << "length is " << strlen("") << std::endl;
}

length is 6
length is 5
length is 0

The strlen() function calculates the length of the string s, [excluding] the terminating null byte
('\0').

 [KT] sizeof is better since it is not a func call and done in compile.


{array-subscript}

For library types such as string and vector, subscript type is size_type which is unsigned. So if
use negative value, then will be converted to the unsigned. However, for built-in array, it is not
so can have negative subscript.

int *p = &ia[2];
int j = p[1];
int k = p[-2];


{array-init}

int a3[5] = { 0, 1, 2 }; 	// { 0, 1, 2, 0, 0 } since value-init the rest
int a4[11] = {};				// { 0,...0 } since value-init all


==============================================================================
*kt_dev_lang_013*	allman style

<allman-style>

The Allman style is named after Eric Allman. It has been incorrectly referred to as "ANSI style"
supposedly for its use in the documents describing the ANSI C standard; later adopted as the ISO C
international standard, though in fact those documents use K&R style. It is also sometimes known as
"BSD style" since Allman wrote many of the utilities for BSD Unix although this should not be
confused with the different "BSD KNF style"; see below.

This style puts the brace associated with a control statement on the next line, indented to the same
level as the control statement. Statements within the braces are indented to the next level.

while (x == y)
{
    something();
    somethingelse();
}
 
finalthing();

This style is similar to the standard indentation used by the Pascal programming language and
Transact-SQL, where the braces are equivalent to the begin and end keywords.

Suggested advantages of this style are that the indented code is clearly set apart from the
containing statement by lines that are almost completely whitespace and the closing brace lines up
in the same column as the opening brace. Some people feel this makes it easy to find matching
braces. Additionally, the blocking style delineates the actual block of code from the associated
control statement itself. Commenting out the control statement, removing the control statement
entirely, refactoring, or removing of the block of code is less likely to introduce syntax errors
because of dangling or missing braces. Furthermore, it's consistent with brace placement for the
outer/function block.

For example, the following is still syntactically correct:

//while (x == y)
{
    something();
    somethingelse();
}

As is this:

//for (int i=0; i < x; i++)
//while (x == y)
if (x == y)
{
    something();
    somethingelse();
}

Even like this, with conditional compilation:

char c;
#ifdef HAS_GETCH
while ((c = getch()) != EOF)
#else
while ((c = getchar()) != EOF)
#endif
{
    do_something(c);
}

<k-and-r-style>

The K&R style, so named because it was used in Kernighan and Ritchie's book The C Programming
Language, is commonly used in C. It is also used for C++, C#, and other curly brace programming
languages.

When adhering to K&R, each function has its opening brace at the next line on the same indentation
level as its header, the statements within the braces are indented, and the closing brace at the end
is on the same indentation level as the header of the function at a line of its own. The blocks
inside a function, however, have their opening braces at the same line as their respective control
statements; closing braces remain in a line of their own, unless followed by an else or while
keyword.

In this style a control statement with only a single statement in its scope may omit the braces. The
C Programming Language refers to this as fertile soil for bugs (programming logical errors) and
discourages it.

int main(int argc, char *argv[])
{
    ...
    while (x == y) {
        something();
        somethingelse();
 
        if (some_error) {
            /* the curly braces around this code block could be omitted */
            do_correct();
        } else
            continue_as_usual();
    }
 
    finalthing();
    ...
}


# ============================================================================
#{

==============================================================================
*kt_dev_cpp_000*	operator-precedence

http://en.cppreference.com/w/cpp/language/operator_precedence

The following table lists the precedence and associativity of C++ operators. Operators are listed
top to bottom, in descending precedence. Where no associativity follows the above one.

Precedence 	Operator 	Description 	Associativity

1 	:: 		Scope resolution 												Left-to-right
 ----------------------------------------------------------------------------
2 	++   -- 				[Postfix] increment and decrement					(same as)
   () 					Function call
   [] 					Array subscripting
   . 						Element selection by reference
   -> 					Element selection through pointer
 ----------------------------------------------------------------------------
3 	++   -- 				[Prefix] increment and decrement				Right-to-left
   + 	- 					Unary plus(+) and minus(-)
	!   ~ 				Logical NOT and bitwise NOT
	(type) 				Type cast
	* 						Indirection (dereference)
	& 						Address-of
	sizeof 				Size-of
	new, new[] 			Dynamic memory allocation
	delete, delete[] 	Dynamic memory deallocation
 ----------------------------------------------------------------------------
4 	.*   ->* 	Pointer to member 										Left-to-right
 ----------------------------------------------------------------------------
5 	*   /   % 	Multiplication, division, and remainder
 ----------------------------------------------------------------------------
6 	+ - 			Addition(+) and subtraction(-)
 ----------------------------------------------------------------------------
7 	<<   >> 		Bitwise left shift and right shift
 ----------------------------------------------------------------------------
8	< 	<= 		For relational operators < and <= respectively
	>   >= 		For relational operators > and >= respectively
 ----------------------------------------------------------------------------
9 	==   != 		For [relational] = and != respectively
 ----------------------------------------------------------------------------
10	& 				Bitwise AND
 ----------------------------------------------------------------------------
11	^ 				Bitwise XOR (exclusive or)
 ----------------------------------------------------------------------------
12	| 				Bitwise OR (inclusive or)
 ----------------------------------------------------------------------------
13	&& 			Logical AND
 ----------------------------------------------------------------------------
14	|| 			Logical OR
 ----------------------------------------------------------------------------
15	?: 				Ternary conditional 									Right-to-left
  	= 					Direct [assignment] (provided by default for C++ classes)
  	+= -= 			Assignment by sum and difference
  	*=   /=   %= 	Assignment by product, quotient, and remainder
  	<<=   >>= 		Assignment by bitwise left shift and right shift
  	&=   ^=   |= 	Assignment by bitwise AND, XOR, and OR
 ----------------------------------------------------------------------------
16 throw 			Throw operator (for exceptions)
 ----------------------------------------------------------------------------
17 , 					Comma 													Left-to-right 


==============================================================================
*kt_dev_cpp_001*	virtual inheritance (interview)

MI and SI (single inheritance)

The problem is that a class inherit from the same base class more than once and this means there are
more than one subobject. Then what is the real problem or consequence out of having more than one
subobject?

From C++ Primer, p810, took this example from IO library:

basic_ios (ABC) <- istream <- iostream
                <- ostream <- iostream

basic_ios holds stream's buffer and state but iostream wants to use {the same buffer and condition
state for both reading and writing}. If an iostream object has two copies of its basic_ios, {this
sharing is not possible}.

That is, in iostream, cause ambiguity and can use both data using scope specifier like istream::x
and ostream::x. so real issue is <sharing>.

To solve this, use {virtual-inheritance} and this <shared> base class is called a
{virtual-base-class}. How? makes only <one> shared subobject for that virtual base class.


class istream : 'virtual' public basic_ios {};
class istream : virtual public basic_ios {};
class iostream : public istream, public ostream {}; 

From EC++ #40, p193,

This problem is called {deadly-MI-diamond}. Problems? ambiguity and replication in the derived. C++
takes no position on virtual inheritance problem. (checked with VC and no errors when there's a
deadly MI diamond) and its default is to perform the replication. 

However, VI costs in size, speed and initialization problem. So recommendation is {don't use VI
unless you need to}.
 

==============================================================================
*kt_dev_cpp_002*	pointer vs. reference (interview)

Refer to *kt_dev_cpp_013* for example uses.

In {ref-CPR}, p50:

Reference is not an object. object does not mean only object of class. Reference defines an
alternative name for an object. This is called <binding> hence <must-be-initialized>

Why reference?

o no copy made
o efficient code
o syntatic need such as operator[]

Difference of reference:

<0-0>
No null reference hence must be initialised. From MEC++01. Always refer to an object. Unlike
pointer, no need to check its validity.

void printDouble( const double& rd )
{ cout << rd; }

vs.

void printDouble( const double* pd )
{
	 if(pd)
		  cout << *pd;
}

So <efficient-code> 

<0-1>
Used operator funcs such as operator[]. {Q}

vector< T> v; v[5] = 10;

<1>
All operations on that reference are actually operations on the object to which the reference is
bound. Reference is bound <once> but for pointer, can change pointer itself and can point other
objects.

<2> 
There is no reference to a reference. but there's a pointer to a pointer. 

<3>
Reference should <match-type> and cannot bind to a literal.

int &ref = 10;                        // error
double dval = 3.14; int &ref = dval;  // error

<4>
Unlike reference, there's a const pointer because a pointer is object. Like any other const object
const pointer must be inited.

int *const cpi = &i;

Q. An object is a memory area that has type and data. given a ref isn't a object, a ref
shouldn't have an address.

int* ip; int &ri = a;
ip = &ri; ???

in VC, ip has a's address.

Q. on the same token:

struct {
	 int x; int y;
} int_str;

struct {
	 int x; int &rx = x;
} ref_str;

sizeof(int_str) == sizeof(ref_str) ??

in VC, they are the same.

It seems that a ref is a complete alias to a actual object.

<5>
No array and vector of reference.

int* ptrs[10];
int& refs[10];		// error. no arrays of ref


==============================================================================
*kt_dev_cpp_003* ctor and copy controls

{syn-operations}

The followings are synthesized by compiler if they are not defined:

copy ctor, copy assign, move ctor(C++11), move assign(C++11) : copy controls plus dtor and default ctor


{default-ctor} {default-init}

Recommendation: avoid syn version and do it explicitly: in-class init(C++11) or ctor init list. 

Why? because to avoid:

o default-init for built-in types. uninit/undefined.

o compile error when there's a class member that don't have def ctor. compiler cannot syn def ctor
for this case.

o if a class requires control to init an object in one case, then the class is likely to require
control in all cases.

Note: cannot be a 'const' member func.

syn ctor will:

o Use in-class init if there is. otherwise default init its member and use default ctor for its
class member.

o If there are other ctor, then compiler will not make a syn ctor. so want to force it to create
then use 'default' keyword.

note: There are cases when syn-operations are useful. See {{make-base-class-for-reference-counting}} 


{in-class-init}

From C++11.

<example-one>

For window_mgr calss to start up with a single, default-inited screen.

class window_mgr {
	 private:

	 vector< Screen> screens{ Screen(24, 80, ' ') };

	 or 

	 vector< Screen> screens = { Screen(24, 80, ' ') };
};


<example-two>

class T {
	 T() = default;
	 T(const string &s) : bookNo(s) {}
	 ...
	 string bookNo;
	 unsigned units_sold = 0;
	 double revenue = 0.0;
};

in-class-init do like 'default values' in func args because:

T(const string &s) : bookNo(s) {}

is equivalent to:

T(const string &s) : bookNo(s), units_sole(0), revenue(0) {}


{vexing-parse}

How to default init an object?

T object;		// OK
T object();		// NO. defines a func

From {temp-object-in-return} in *kt_dev_cpp_009*

return pair<string, int>();   // T()

From {default-and-value-init} in *kt_dev_stl_019*

int* pi = new int;				// def init
int* pi = new int();				// value init. new T()


{assignment-and-initialisation} {constructor-initializers}

ABEntry::ABEntry(...)
{
	 theName = name;
	 theAddress = address;
	 thePhones = phones;
	 numTimesConsulted = 0;
}

This is assignment but not init. init happens before ctor runs. Hence use constructor initializer or
in-class init.

(Primers p289 and EC#04)

Why use constructor-initializers? 

1) Avoid default-init.
2) Efficient than {assignment-and-initialisation}
3) By the time the body of ctor begins excuting, init is completed so there are <three> cases that~
must use ctor-init: {QUIZ}

const, reference, and class member that do not have a def-ctor.

For the last case, that is because try to use def-ctor for class memeber data but there is no way to
init. Hence this is error. This applies to all other cases that need a def-ctor and that's why def
ctor is almost nearly required.

See {exception-in-ctor} for the order of initialisation.

VC shows:

Error	1	error C2512: 'NoDefCtor' : no appropriate default constructor available


<syntax> It seems that it must be done in class definition. {TODO} confirm.

class Derived: public Base {
	 public:
	 	Derived( parms ) : Base( parms ), m_xxx(param), ... { ... }
};


{default-arg}

The default argument in function. If a parameter has a default argument, all the parameters that
follow it must also have default arguments. The default arguments are used from right-most
arguments.

typedef string::size_type sz;
string screen( sz ht = 24, sz wid = 80, char background = ' ' );

string window = screen();				// == screen( 24, 80, ' ');
string window = screen(66);			// == screen( 66, 80, ' ');
string window = screen(66,256);		// == screen( 66, 256, ' ');

So consider ordering the parameters so that those lesat likely to use a default value appear first.

class T {
	 T() = default;
	 T(const string s) : bookNo(s) {}
	 ...
	 string bookNo;
};

is equi to:

class T {
	 T(const string s = "") : bookNo(s) {}
	 ...
	 string bookNo;
};


Two points:

o Use carefully as there are logical cases where need to have args from the same source. For
example, it's logical error when one arg is from def init and the other is from the user.

o See the org in {default-ctor}:

	 T(const string &s) : bookNo(s) {}

default arg costs a copy op then?


{copy-controls}

copy ctor, copy assign, move ctor(C++11), move assign(C++11)

If not defined, syn version will be created. don't use syn version of copy controls when
use dyn allocated resource. *kt_dev_cpp_004* 


{copy-ctor} {copy-init}

When init object from the other of the same type.

The first arg is a reference to a class and the rest args can be defaults. Used for <four> context:~
copy init, <argument-pass>, <return>, and implicit coversion using temp object. For arg pass and
return they are <non-reference-type>, they are copy-inited; Hence called copy-ctor.

class Foo {
	Foo(const &Foo);	// wrong
	Foo(const Foo&);
};

Note: cannot be 'explicit' since used implicitly such as arg passing. 


direct and copy init

// direct init. use func matching in searching string ctor.
string dots(10, '.');
string s(dots);	

// copy init. use <copy-ctor>. see implicit conversion here and see more at *kt_dev_cpp_005*
string null_book = "9-999-99999-9";

string s1;
string s2 = s1;


{pass-by-reference-to-const}
(EC++20)

class Person {
	 ...
	 private:
		  string name;
		  string address;
};

class Student: public Person {
	 ...
	 private:
		  string schoolName;
		  string schoolAddress;
};

// when call this, it costs 6 ctor and dtor
bool validateStudent(Student s);

Student plato;
validateStudent(plato);

// to bypass these cost
bool validateStudent(const Student& s);

The points: 

1) Less expensive since no new object are being created. Typically, references are implemented as
pointers. So recommendation is that use pass-by-value for built-in, STL iterator, and function
objects types and use pass-by-reference for class types.

2) The const is necessary since otherwise caller would have to worry about a function making changes
to the object they passed in.

3) Avoid <sliced-off> problem. For example:

class Window {
	public:
		...
		std::string name() const;
		virtual void display() const;
};

class WindowWithScrollBars: public Window {
	public:
		...
		virtual void display() const;
};

void printNameAndDisplay(Window w)
{
	std::out << w.name();
	w.display();
}

WindowWithScrollBars wwsb; printNameAndDisplay(wwsb);

This will [ALWAYS] call Window::display since it is pass-by-value using Window ctor and is sliced-off.
Hence Window object.

To fix this, should change it to and it work for whatever kind of windows.

void printNameAndDisplay(const Window& w)
{
	std::out << w.name();
	w.display();
}


EC++21. Then always use reference? However, there are cases that must return a copy not a reference
such as operator*(). This is a operator* not dereferene operator. See {smart-pointer-internal}.
Q: How distinguish between two?

Do not pass reference to object that do not exist.

class Rational {
	 friend const Rational operator*( const Rational& lhs, const Rational& rhs );
	 ...
};

If change it to return reference

class Rational {
	 friend const Rational& operator*( const Rational& lhs, const Rational& rhs );
	 ...
};

Rational c = a*b;

When returning from operator*(), reference is no longer valid. Must return a copy.


{copy-assign}

Cannot use syn version when there are reference and const member data. Why? because syn copy assign
is defined as <deleted> if the class has a const or reference member. (Primes p508). For
<delete-keyword>, see *kt_dev_cpp_004* It uses op overloading and must be a member because <lhs> is
this pointer.

class Foo {
	Foo& operator=(const Foo&);
};

The copy-assign controls how objects of its class are assigned

Sales_data trans, accum;
trans = accum;

For assign with different types, need additional assign op and see *kt_dev_cpp_021*


{assignment-must-return-a-reference-to-this}

EC++10. All assign ops must follow this convention like built-in types because of chain of
assignment and should behave the same as built-in types.

x = y = z = 15;		// right associative

Widget wx, wy, wz;
wx = wy = wz = DefaultWidget;

class Widget {
	 public:
	 Widget& operator=( const Widget& rhs )
	 {
		  ...
		  return *this; ~
	 }
};


{avoid-unnecessary-default-ctor}

From MEC++04. There are two categories:

o For class that can be inited meaningfully without inputs from outside, do use default-ctor.
o For calss cannot be inited meaningfully without inputs from outside, recommend not to use
default-ctor.

TODO: more on problems and example

For example, think a class which has ID info and use default-ctor. This causes

o Limit a use of class as not able to use array of it.
o There should be checks in each member funcs to see if it is inited with a meaningful initial value
for ID. This means more error checking, handling and penalty of size and speed.

That means that a user provide a meaningful init value but once inited, can see efficient
implementation.


==============================================================================
*kt_dev_cpp_004* copy-controls when use dyn resource.

{when-use-resource-has-dyn-lifetime}

o don't know how many object is needed
o don't know the exact type of object
o share data between objects


{the-rule-of-three}

The rule of three (the rule of five in C++11) is a rule of thumb in C++ that claims that
if a class defines one of the following it should probably explicitly define all three:[1]

dtor, copy-ctor, and copy-assign operator


<case-example> C++ Primer p505

The syn version does not operate well for a class using dyn resource. The case is that if there's no
dtor defined, the syn dtor will not run delete on ps so must define own dtor but use syn versions
for copy and assign. 

class HasPtr {
	public:
		HasPtr(const std::string& s = std::string() )	// def arg. 
			: ps( new std::string(s), i(0) {}

		~HasPtr() { delete ps; }
	private:
		std::string* ps;
};


What problem?

HasPtr func(HasPtr hp)	// value and memberwise copy using a syn copy ctor.
{
	HasPtr ret = hp;		// a syn copy assign. ret and hp points the same.
	...
	return ret;				// <double-free> on ret and hp, when exit a call
}

Even if there is no return:

HasPrt p("...");
void func(p);		// p and func's arg points the same.
						// when func exits, func's arg is deleted and p has invalid
						// pointer which was already deleted after func().
HasPrt q(p);		// p and q have invalid pointer.


So, need to define copy-ctor and copy-assign op as well. Two methods on what copying an object will
mean: value or pointer like (what we do when copy pointer member)


For the same reason in {constructor-initializers} in *kt_dev_cpp_003* must define copy controls when
there are const and reference members because compiler will not create syn versions since cannot
rebind const and reference. But how to define user copy controls for these cases?


{copy-control-in-inheritance} {construct-and-copy-all-parts-of-an-object}

EC++12. When having own copy functions(copy-ctor and copy-assign) for [derived class], be careful to
handle base part because having own copy controls means to have [full responsibilities] of doing it.

// when add new member data

Customer& Customer::operator=( const Customer& rhs )
{
	 name = rhs.name;
	 return *this;
}

If add new member data, then must update all copy functions and ctors too. Otherwise, have copy
functions to copy parts of object.

// class inheritence

class PriorityCustomer: public Customer {
	 ...
	 PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs )
	 :priority( rhs.priority )
	 {
	 }

	 PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
	 {
		  priority = rhs.priority;
		  return *this;
	 }
};

must be:

class PriorityCustomer: public Customer {
	...
	PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs ) 
	:Customer(rhs),~
	priority( rhs.priority )
	{
	}

	PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
	{ 
	    Customer::operator=(rhs); ~
	    priority = rhs.priority;
	    return *this;
	}
};

If not, do nothing about base part and that means:
For construction, PriorityCustomer-ctor will use a default-ctor of Customer and Customer part will ~
be default-init. For copy, PriorityCustomer-copy-ctor will do nothing on Customer part and it will ~
remain unchanged. ~


{value-like} {deep-copy} {self-contained-object}

See {own-resource-managing-class} in *kt_dev_stl_018* for full discussion.	

The copy and the original are independent since copy underlying object as well. note: library containers
and string use value-like copy

class HasPtr {
	public:
		HasPtr(const std::string& s = std::string() )	// def arg. 
			: ps( new std::string(s), i(0) {}
>
		HasPtr(const HasPtr& p):
			ps( new std::string( *p.ps );

		HasPtr& operator=(const HasPtr& p);
<
		~HasPtr() { delete ps; }
	private:
		std::string* ps;
};

The below combine dtor and copy and handle self-assign and exception-safe see *kt_dev_cpp_019* for
self-assign and exception

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
	 auto newp = new string(*rhs.ps);
	 delete ps;
	 ps = newp;
	 return *this;
}


{pointer-like} {shallow-copy} {own-reference-counting} 

The copy and the original share underlying object like shared_ptr. *kt_dev_stl_018* for example.
Alternatively, use own reference counting as following:

class HasPtr {
	public:
		HasPtr(const std::string& s = std::string() )	// def arg. 
			: ps( new std::string(s), i(0), use(new std::size_t(1)) {}
>
		HasPtr(const HasPtr& p):
			ps( p.ps ), use( p.use ) { ++*use; };

		HasPtr& operator=(const HasPtr& p);
		~HasPtr();
<
	private:
		std::string* ps;
		std::size_t* use; ~
};


HasPtr::~HasPtr()
{
	 if( --*use == 0 )
	 {
		  delete ps; delete use;
	 }
}

// combine dtor and copy. handle self-assign
//
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
	 ++*rhs.use;

	 // lhs
	 if( --*use == 0 )
	 {
		  delete ps; delete use;
	 }

	 ps = rhs.ps;
	 use = rhs.use;

	 return *this;
}


{preventing-copies} {delete-keywords}
Primus p507. How can define a class to prevent copy or assign like iostream class? Do not defining
copy controls? This do not work as syn version will be made. Two ways: delete keyword and private
access control.

<delete-keyword> {C++11}
Signal to the compiler that intentionally not defining these members; do not make these
automatically and lead to <compile error> when try to use it. 

struct NoCopy {
	 NoCopy() = default;
	 NoCopy(const NoCopy&) = delete;                 # NO copy-ctor 
	 NoCopy& operator=(const NoCopy&) = delete;      # NO copy-assign
	 ~NoCopy() = default;
	 ...
};

<private-copy-control> prior C++11
class PrivateCopy {
  private:
	 // declare but not define ~
	 PrivateCopy(const PrivateCopy&);
	 PrivateCopy &operator=(const PrivateCopy&);

  public:
	 ...
};

However, friends and members still make copies so declare copy controls but not define. By doing
this, can cause link errors when there are attempts to use. {QQ} This causes compile error then why
link error? As below this is compile error.

#include <iostream>

using std::cout; using std::endl;

class Base {
	public:
		Base() = default;
		~Base() = default;
    private:
		 int m_iDataABCAnimal;
		 Base(const Base& base) { cout << "copy-ctor: base" << endl; }		// 11
		 Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

class D : public Base
{
  public:
    void getShout() { cout << "derived get shout" << endl; };
};

int main()
{
	std::cout << "--{ main " << std::endl;

	Base b1, b2;

//	Base b3(b1);		// <case-01> 21

  D d1, d2;

  d1.getShout();

  d2 = d1;           // <case-02>

	std::cout << "--} main " << std::endl;
}

<case-01>
kit@kit-vb:~/work$ ./comp.sh use-prevent-copy.cpp 
use-prevent-copy.cpp: In function ‘int main()’:
use-prevent-copy.cpp:11:4: error: ‘Base::Base(const Base&)’ is private
use-prevent-copy.cpp:21:12: error: within this context

<case-02>
base.cpp: In function ‘int main()’:
base.cpp:33:8: error: use of deleted function ‘D& D::operator=(const D&)’
base.cpp:15:7: error: ‘D& D::operator=(const D&)’ is implicitly deleted because the default definition would be ill-formed:
base.cpp:12:10: error: ‘Base& Base::operator=(const Base&)’ is private
base.cpp:15:7: error: within this context

<boost-noncopyable>
EC++06. To move the link-time error up to the compile-time error. {QQ} This still do not have
definitions but why compile error this time? By moving private up the inheritence, change link error
to compile error:. Just compile error.

#include <iostream>

class Uncopyable {
	 protected:
		  Uncopyable() {}
		  ~Uncopyable() {}

	 private:
		  Uncopyable(const Uncopyable&);
		  Uncopyable& operator=(const Uncopyable&);
};

class Foo : private Uncopyable {		// line 13
	public:
		void WhoAmI() { std::cout << "foo" << std::endl; }
};

int main()
{
   std::cout << "{ "; 
   
	Foo f;
	f.WhoAmI();

	// errors only when add followings
	Foo o;
	o = f;	// line 26

	std::cout << "size :" << sizeof(f) << std::endl;
   std::cout << "}" << std::endl; 
}

kit@kit-vb:~/work$ ./comp.sh use-noncopy.cpp 
use-noncopy.cpp: In function ‘int main()’:
use-noncopy.cpp:26:6: error: use of deleted function ‘Foo& Foo::operator=(const Foo&)’
use-noncopy.cpp:13:7: error: ‘Foo& Foo::operator=(const Foo&)’ is implicitly deleted 
								because the default definition would be ill-formed:
use-noncopy.cpp:10:17: error: ‘Uncopyable& Uncopyable::operator=(const Uncopyable&)’ is private
use-noncopy.cpp:13:7: error: within this context

syn copy and assign op for derived classes are supposed to handle base class parts but they can't
invoke member funcs since the derived class has no right to call. Again, the point is that derived
class part can't call the base class part as it's private. In boost, it's 'noncopyable'.


{self-assign-and-exception-safe}
When implement copy-assign, must think about self-assign and exception-safe. See
{self-assign-exception-safe} in *kt_dev_cpp_019*

Why? because ther are <less-obvious-assignments> to self cases:

<one> aliasing: having more than one way to refer to an object

a[i] = a[j];		// potential assign to self when i==j
*px = *py;			// potential assign to self when point to the same

<two> same class hierarchy. TODO: more detail.

void doSomething( const Base& rb, Derived& pd );


==============================================================================
*kt_dev_cpp_005* converting ctor

See *kt_dev_lang_009* for built-in conversion. converting-ctor and conversion-op are called
{class-type-conversion}. Two things.


In sum, converting-ctor is a coversion {to class; inwards} and conversion op is a conversion {from
others}

class T {       <- from other type to T. converting-ctor
	 ...         -> from T to other types. conversion-op
};


{converting-ctor}

Means ctor with single arg and enables 'implicit' converstion from arg type to class type. 

For example,

class Sale_data {
	...
	combine(const Sales_data&);
	Sales_data(const std::string &s);
	...
};

string str;
item.combine(str);

Here, combine() expect Sales_date type but it is given a string type. This equates to:

item.combine(Sales_data(str));

So implicit conversion happens and creates a temp Sales_data object. Because a temp-object is used,
this implicit conversion is not always useful.

class Sale_data {
	...
	combine(const Sales_data&);
	Sales_data(istream& in);
	...
};

item.combine(cin);

When combine finishes, temp-object is gone and lost input. To avoid this, can use
<explicit-keyword>:

class Sales_data {
	'explicit' Sales_data(const std::string &s);
	combine(const Sales_data&);
	...
};

Then this force user to speify it and means they know what they are doing:

string null_book;

// error: cannot use the copy form of initialization with an explicit constructor.
Sales_data item2 = null_book;

item.combine( Sales_data(str) );							// T()
item.combine( static_cast< Sales_data>(str) );

note: Whether or not use explicit-keyword, temp-object will be create so the point is about making
it explicit.


<stl-example-of-explicit>

The vector< T > v(number) is explicit so the following is in error.

// x.member(vector< string >& vec);
x.member(10);	// error


{conversion-op}

This is conversion from class type to other type. Use overloading and the form is:

operator T() const;

class SamallInt {
	 public:
	 'explicit' operator int() const { return val;}

	 private:
	 std::size_t val;
};


To avoid following problem, use explicit keyword:

int i = 42;
cin << 42;

There is no << operator in cin but there is conversion to bool. So works as if depending on the cin
state; 0 or 1.

0 or 1 << 42;


<bool-conversion-in-condition> {tip}

However, even if uses explicit, this explict has no effect when used in condition such as:

if, while, for and do statements. logical operators. conditional operators.
 
This make its use useful in condition like:

while( std::cin >> value )

It reads into value and return cin. cin converted to bool depending on cin state. This bool
conversion is the typical use of conversion-op.

<class-state>
note. Like cin, seems useful to have bool conversion when class has 'state'.~


{avoid-impicit-conversion}

From MEC++05. Recommend to use a member func to do the same.

<problem-case>

template< typename T>
class Array {
	 public:
	 	Array(int lowBound, int highBound);
		Array(int size);
		...
};

bool operator==(const Array< int> &lhs, const Array< int> &rhs );

Array< int > a(10); Array< int > b(10);

for( int i=0; i < 10; ++i )
	 if( a == b[i] ) {        # meant to be a[i] == b[i]
		  ...
	 }
	 else {
		  ...
	 }

There is no match candidate, ( operator==( Array< int>, int ), and compiler do convert the second
arg to Array because there is converting-ctor. This is the same as:

if( a == static_cast< Array< int>> (b[i]) )

This causes a creation and deletion of unknowm number of Array objects for each iteration.

How to prevent this?

o Use <explicit> keyword from GCC 4.5 and if a compiler do not support <explicit> see then for more.


==============================================================================
*kt_dev_cpp_006* swap 

{which-swap}

vector< string> svec1(10);
vector< string> svec2(24);

swap( svec1, svec2 );	

Is it a std::swap()? NO. This is non-member func in vector. This is not a element swap but a swap of
internal structure. Constant-time operation. 

Except string, iterator remains valid after swap. {really}? What if swapping containers that
has different size?


Primers p339. In C++, container provides member and non-member swap and previously supports member
only. Recommands non-member swap. {why}? for generic programming? 

If there's no type specific swap, use swap from the library, std::swap. is it a template or
function? Yes, this is template and memberwise operation.


{why-swap}

o It is for value-like class and use swap when used by algorithm such as reorder
elements. For pointer-like class, no need as it naturally swaps pointers. stl containers
are value-like. see {value-like} in *kt_dev_cpp_004*

Since value-like swap is expensive such as resource managing class which is value-like, need to have
better way and provide type specific swap which has efficient way to do it. So sounds like a topic
for container design?


{standard-swap}

namespace std {

  template<typename T>          // typical implementation of std::swap;
  void swap(T& a, T& b)         // swaps a's and b's values
  {
    T temp(a);
    a = b;
    b = temp;
  }
}

Cost three copies that use 'operator=' of value-like class. For some types, none of these copies are
really necessary. How to avoid these cost?


{define-swap-friend}

What we want is to use type speficic swap when there is and otherwise, fall back to use std::swap.

Primer p516. non-member swap and friend approach and example from {value-like} in *kt_dev_cpp_004*

class HasPtr {
>
	friend void swap( HasPrt&, HasPtr& );
<
	public:
		HasPtr(const std::string& s = std::string() )	// def arg. 
			: ps( new std::string(s), i(0) {}

		...

		~HasPtr() { delete ps; }
	private:
		std::string* ps;
};


To override the defaut behaviour of swap by class-specific swap. 

inline void swap( HasPtr& lhs, HasPtr& rhs )
{
	 using std::swap;
	 swap( lhs.ps, rhs.ps );	// std::swap as no swap in string
}


The following will use swap(HasPtr&, HasPtr&) through {arg-dependant-lookup} in *kt_dev_cpp_007*

HasPtr A, B;
swap(A,B);		

In this example, the following is the same as used on built-in memeber data, pointer in this case
but this can be mistake for class member data because it will always use std::swap.

inline void swap( HasPtr& lhs, HasPtr& rhs )
{
	 std::swap( lhs.ps, rhs.ps );	// std::swap as no swap in string
}


The one important subtlety in swapping class member which uses function matching:

1) use unqualified swap to search for class-specific swap version
2) use using std::swap to make it visiable in current scope so fall back on std::swap when there is
no class-specific version.

note: what will happen if there is no class-specific swap and no using declaration?


{copy-and-swap-idiom}

Combine dtor and copy. automatically handle self-assign and exception-safe from {value-like} in
*kt_dev_cpp_004*

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
	 auto newp = new string(*rhs.ps);
	 delete ps;
	 ps = newp;
	 return *this;
}

To rewrite using copy-and-swap-idiom

HasPtr& HasPtr::operator=(const HasPtr rhs)	// note. not ref and it's copy
{
	 swap(*this, rhs);
	 reutn *this;				// rhs is destroyed, which deletes the old ps.
}

>
 SO, have optimization, self and exception safe and neat implementation using swap.
 Also EC++11 says the compiler can generate more efficient code by passing by value.
<

{define-swap-use-pimpl-idiom}

EC++25. pimpl-idiom. See *kt_dev_ecpp_008* for pimpl-idiom.

class WidgetImpl {                          // class for Widget data;
public:                                     // details are unimportant
  ...

private:
  int a, b, c;                              
>
  std::vector< double > v;                  // possibly lots of data expensive to copy!
<
  ...
};

class Widget {                              // class using the pimpl idiom
public:
  Widget(const Widget& rhs);
>
  Widget& operator=(const Widget& rhs)      // to copy a Widget, copy its
  {                                         // WidgetImpl object. For
   ...                                      // details on implementing
   *pImpl = *(rhs.pImpl);                   // operator= in general,
   ...                                      // see Items 10, 11, and 12.
  }
  ...
<
private:
  WidgetImpl *pImpl;                        // ptr to object with this
};                                          // Widget's data


Imagine how expensive it may be when there's no swap for Widget and when use std::swap :

Widget A, B; swap(A,B);

All we really need to do is swap their pImpl pointers, but the default swap algorithm has no way to
know that. Instead, it would copy not only three Widgets, but also three WidgetImpl objects. Very
inefficient. To address this, should provide type specific swap version to be used by clients:


{{use-template-specialization}}

namespace std {					  

  template<typename T>          // typical implementation of std::swap;
  void swap(T& a, T& b)         // swaps a's and b's values
  {
    T temp(a);
    a = b;
    b = temp;
  }
}

There is a way to say exactly that: specialize std::swap for Widget.

namespace std {

  template<>                            // this is a specialized version
  void swap< Widget >(Widget& a,        // of std::swap for when T is
                    Widget& b)          // Widget; this won't compile
  {
    swap(a.pImpl, b.pImpl);             // to swap Widgets, just swap
  }                                     // their pImpl pointers
}


We are not permitted to alter the contents of the std namespace, but we are allowed to totally
specialize standard templates (like swap) for types of our own creation (such as Widget).

This function will not compile. That is because it is trying to access the pImpl pointers inside a
and b, and they are <private> so other ways might be:


o could declare our specialization a friend, but the convention is different: so not
consider. 

o have a public swap member and specialized std::swap calls this member swap. 'okay' since do not
use friend here.


# this is the solution

class Widget {                     // same as above, except for the
public:                            // addition of the swap mem func
  ...
  void swap(Widget& other)
  {
    using std::swap;               // the need for this declaration
                                   // is explained later in this Item

    swap(pImpl, other.pImpl);      // to swap Widgets, swap their
  }                                // pImpl pointers
  ...
};

namespace std {

  template<>                       // revised specialization of
  void swap< Widget >(Widget& a,   // std::swap
                    Widget& b)
  {
    a.swap(b);                     // to swap Widgets, call their
  }                                // swap member function
}

>
 Swap provides two characteritics: efficiency and strong exception-safety.
 
 Like STL containers, provide both memeber and non-member swap. To have the member version
 swap never throw exception (because it use swap on built-in types that never throw
 exception.) This offers the strong excepiton-safety gurantee.

However, suppose that Widget and WidgetImpl were class templates instead of classes. needs more
generic solution.

The solution would be: overloading function-template is fine, but std is a special namespace, and
the rules governing it are special, too. It's okay to totally specialize templates in std, but it's
not okay to add new templates (or classes or functions or anything else) to std.

The answer is that works as well for classes as for class templates: we just don't declare the
non-member to be a specialization or overloading of std::swap.

namespace WidgetStuff {
  ...                                     // templatized WidgetImpl, etc.

  template<typename T>                    // as before, including the swap
  class Widget { ... };                   // member function

  ...

  template<typename T>                    // non-member swap function;
  void swap(Widget< T >& a,               // not part of the std namespace
            Widget< T >& b)                                         
  {
    a.swap(b);
  }
}


Use swap(Widget< T >&, Widget< T >&) through {arg-dependant-lookup}

But, what you desire is to call a T-specific version if there is one, but to fall back on the
general version in std if there's not. Here's how you fulfill your desire:

template<typename T>
void doSomething(T& obj1, T& obj2)
{
  using std::swap;           // make std::swap available in this function
  ...
  swap(obj1, obj2);          // call the best swap for objects of type T
  ...
}


In addition, can have specialized std::swap to make type-specific swap implementations available to
code written in this misguided fashion.


# taken from vector template in gcc
#

  template<typename _Tp, typename _Alloc = std::allocator< _Tp >>
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
	  ...
	  
      /**
       *  @brief  Swaps data with another %vector.
       *  @param  x  A %vector of the same element and allocator types.
       *
       *  This exchanges the elements between two vectors in constant time.
       *  (Three pointers, so it should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(v1,v2) will feed to this function.
       */
      void
      swap(vector& __x)
      {
		std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
		std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
		std::swap(this->_M_impl._M_end_of_storage,
			  __x._M_impl._M_end_of_storage);

		// _GLIBCXX_RESOLVE_LIB_DEFECTS
		// 431. Swapping containers with unequal allocators.
		std::__alloc_swap< _Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
								__x._M_get_Tp_allocator());
      }
	  ...
	} # end of class template
	
	/// See std::vector::swap().
	template<typename _Tp, typename _Alloc>
	inline void
	swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
	{ __x.swap(__y); }


note TO DO Primers p518. summarise after studying template.


==============================================================================
*kt_dev_cpp_007* function matching and overload

{function-matching}

Also known as overload resolution. The name has 'scope' and object has 'lifetime'. Three possible
outcomes: best match, no match, and ambiguous call. For overload condition, see {const-on-overload} 

note: step 0 and 1 is called <normal-scope-or-name-lookup>?

step-0: <search>
For lookup of names inside a namespace, look in members in case class, and if not found, continue
looking in enclosing scope; which is a open scope having a name to look up. This can be block,
class, or namespace. So continue looking in classes up the chain of inheritance or
namespaces. This search goes upwards that means declared before use and before in reading
order. For example, int A::C1::f3() in qualified name. Plus use {arg-dependant-lookup} for
class type, reference, and pointer. For non-class, enclosing scope that is before the point
of use and is still open. See Primers p797. 'using' declaration or directive add names to
the candidate set. If found the name, the compiler looks no further.

step-1: <build-candidate>
Use name only hence called name-lookup. Build candidate functions which is the set of overloaded
functions and should be the same name and visible. Include any function-template instantiation for
which template arg deduction succeeds.

step-2: <build-viables>
Use the number of arguments to get viable functions and use conversion and type-match.

step-3: <best-match>
The exact match is better than a match that requires a conversion. non-template func is selected if
there's only one in the set. if not, more specialed func template is called. otherwise, the call is
ambiguous.

step-4: <check-access>
See accessibilty in case of inheritance. From EC++40

step-5: <virtual-or-not>
If it is virtual, generate a code for run-time binding. otherwise, generate a normal call.


{broader-candidate-set-op-overload}

a op b

is nothing to say about whether it calls member or non-member op overload. so the set is wider to
both member and non-member to be considered.  


{arg-dependant-lookup}
 
From {ref-CPR} p797.

std::string s;
std::cin >> s;

this is equi to:

operator>>(std::cin, s); 

This operator>>() func is defined in the 'string' libaray as a non-memeber and in 'std'. Why is it
okay without using either 'std::' or 'using'? When func has class type argument which is class
object, pointer or reference, the compiler searches <namespace-in-which-arg-defined> in addition to
the normal scope lookup.

In this case, searches the namespace, 'std', where cin and string is defined and found this func
from 'string'. note: it is namespace, not else.

Why this? This makes it easy to use non-member func which is conceptually part of class interface.
otherwise, should use

using std::operator>>; or std::operator>>(std::cin, s);


{scope-in-inheritance}

Primus p617. Hierarchical nesting of class scope; this means that the derived is nested in the base
scope and names in the derived can hide names declared in the base. See {override-keyword}
*kt_dev_cpp_023* The point is that the name-lookup happens at compile time and uses static-type. The
below shows that point.

class Disc_quote : public Quote {
	 public:
	 std::pair<a,b> discount_policy() const { ... }     # added in this class only
};

class Bulk_quote : public Disc_quote {
	 ...
};

Bulk_quote bulk;

Bulk_quote* bulkP = &bulk;
Quote* itemP = &bulk;        # static and dynamic type differ

bulkP->discount_policy();
itemP->discount_policy();    # error

What if discount_policy is virtual func? Doesn't matter in this case and it's still error because
this is not found in Quote class.

Tried with GCC and got an error:
.cpp:139:10: error: 'class Quote' has no member named 'discount_policy'

It is for non-virtual funcs. If the base has overloads and 'is-a' relationship then see EC++33 for more. 
note: seems need more clearer statement for the above.


==============================================================================
*kt_dev_cpp_008* const and conversion

{global-const-scope}

The const object must be inited when defined and it's local to file by default. so want to use in
multiple files, must use <extern-keyword> on [both] definition and declaration. This is different
from <file-staic-mean>. The important principle is that shouldn't change const object.

// fine one
extern const int gc_max = 100;

// file two
extern const int gc_max;


{top-low-level-const}

The top level const is for object itself. So there are <top-level-const> and <low-level-const> for a
reference and pointer. Top-level-const is for reference and pointer itself and lov-level-const is
for underlying object. Top can be ignored but low level 'NOT' because top-level-const do not say
anything about underlying object. const-pointer can point either const or non-const. Hence can
be ignored. 

int i = 42;
const int ci = i;
int j = ci;					// top-level const ignored.

The initialisation do not change the value of an object. Constness of ci matters only for operations
that might change ci. Copying doesn't change ci. The new object has no further access to the
original object. 


{reference-to-const}

But <reference-to-const> is different. There's no const-reference since reference is not object. The
reference-to-const restrics only what we can do [through] that reference and says nothing about
whether the underlying object itself. 

For pointer, there are <pointer-to-const> and <const-pointer>. The following initialsation is error
because should NOT be able to use a reference to change ci. Remember a reference is another name.

int &ri = i;
const int &r2 = i;
r1 = 0;
r2 = 0;						// error since r2 is reference-to-const

int &ri = ci;				// error because NO 'const to non-const'.

For ordinary reference, must match type and must bind to a object.

int &ri = 10;				// error
int &ri = double_val; 	// error

For pointer examples, see and remember that read from right to left; that is from modifiers to base
type.

const double *cptr = &pi;
int *const curErr = &errNumb;


{type-match-exceptions}

Two exceptions to type match: <reference-to-const> and <derived-to-base-reference> conversion. Can
bind <reference-to-const> to non-const, a literal, a temp, or other expression that evaluate to an
type.

const int &ri = 42;		// ok

double dval = 3.14;
const int &ri = dval;	// ok becuase will bind to <temp-object> and cannot change it via ri

note: KT. This is [to-maintain-constness] by creating [temp-object]. See <case-one-in-conversion>
 

{convert-to-const}

Implicit {convert-to-const} conversion for reference and pointer.

const  -- NO --> non-const
const <-- OK --  non-const

const int &ri = const object		// cannot change as both are const
const int &ri = non-const object	// cannot change via ri but can change object itself. 

When copy an object, both object must have the same low-level const or be conversion.

const int ci = 42;	// top-level
int i = ci;				// ignored

const int& r = ci;	// is 'always' low-level


If this is allowed, const object can be changed via non-const pointer and reference. So not allowed.

int i;
const int &j = i;		// conversion from non-const to const
const int *p = &i;
int &r = j, *q = p;	// error since conversion from const to non-const


{const-param-args}

The const matters when copying vars and do func params. That is why copy-ctor is usded here.

void fcn( const int i );		

fcn(j);	// const int i = j;
fcn(cj);	// const int i = cj;

void fcn( int i );

This is error because it redefines the same. Why? See {const-on-overload} for more cases.
These are all explained by the fact that fcn(const init i) can be used both fcn( const-pararm ) and
fcn( non-const-param ) and in other words, top-level-const can be ignored.

fcn(j);	// int i = j;
fcn(cj);	// int i = cj;


{const-reference-param}

Two implications when use plain reference param in func:

o A func that don't change a ref param, mislead its user to think it is.
o More importantly, it limit its use only to non-const param.

example

find_char(const string& s, char c);
find_char("Hello", 'o');	// OK because const-to-ref can match to literal.

find_char(string& s, char c);
find_char("Hello", 'o');	// compile error because temp object is const

So recommend const-reference-param over reference-param for flexibility. 


{const-on-iterators}

In iterator, begin() has overloads: const and non-const version because if it has only const
version, *this is const and any data member is also const. begin() may return its member.

// like 'T* const' and iter itself is const
const std::vector< int >::iterator iter = vec.begin();

// like 'const T*' and *iter is const
std::vector< int >::const_iterator iter = vec.begin();


{const-return} {equal-misspell}

EC++03. When use return by value as a return, use const to raise error when mistake happens:

const Rational operator*( const Rational& lhs, const Rational& rhs );

// typo. was meant if( a*b == c )
//
if( a*b = c )

If these are built-in tyeps, this is flat-out error but don't for class type. so better to be prepared
for this kind of mistakes. Also this is an example of returning a copy than reference.


==============================================================================
*kt_dev_cpp_009* undefined result and a temp-object

{undefined-result-in-return}

// example-one

#include < iostream>
#include < string>

using namespace std;

bool str_subrange( const string& str1, const string& str2 )
{
	if( str1.size() == str2.size() )
		return str1 == str2;

	auto small_size = ( str1.size() < str2.size() ) ? str1.size() : str2.size();

	for( decltype(small_size) i = 0; i != small_size; ++i )
		if( str1[i] != str2[i] )
			;			// NO ERROR in this case
			return;	// [ERROR-01]
			return false;
	
	// [ERROR-02]
}

int main()
{
	string str1 = "KYOUNG";
	//string str2 = "YOU";
	string str2 = "KYO";

	bool ret = false;

	ret = str_subrange(str1, str2);
	if( ret )
		cout << "return true" << endl;
	else
		cout << "return false" << endl;

	return 0;
}

{ERROR-01}
VC and GCC picks up this error. This is GCC case:

samcpp.cpp: In function bool str_subrange(const std::string&, const std::string&)
samcpp.cpp:16: error: return-statement with no value, in function returning bool

{ERROR-02}
Primus says that some picks up this error and some do not. Both VC adn GCC do not picks up this.

{undefined-result}

Primus also says that its result at runtime is 'undefined'. When running for VC and GCC showed
different result: VC returns true and GCC do false. Hence 'undefined'. 

Note: KT. This is a kind of logic error that compiler cannot catch. 

// example-two

const string& foo()
{
	 string ret;

	 ...
	 if
	 	return ret;
	 else
	 	return "Empty";
}

Both return cause [undefined-result] at the call site(caller) because it returns reference to local
string in foo().


{temp-object-in-return}

// example-one

Return the plural version of the word if the counter is greater than 1.

string make_plural( size_t ctr, const string& word, const string& ending)
{
	 return (ctr>1) ? word + ending : word;
}

The word is copied to the call(ing) site or unnamed string [temp-object] is copied to the call site for
'word + ending' case.

// example-two

pair<string, int> process(vector< string> &v)
{
	 ...
	 return pair<string, int>();
	 or
	 return pair<string, int>( v.back(), v.back().size() );
}

Here explicitly constructed return pair [temp-object]. 'pair<string, int>' is T. That is T() and so is
default constructed and value-init.

See {return-reference-vs-copy} for interesting case. So whether or not there is a temp object
created in called site, there is a copy to call site when a func is defined to return a copy.


{temp-object-in-converison} {cost-of-temp-object}
From MEC++19. The cost of temp-object which is called unnamed or temp object. When is it used?

<case-one-in-conversion>
Used in implicit type conversion, nonconst-to-const, in func call and return. Can have an impact on
the performance in construction and destruction. 

size_t countChar( const string& str, char ch );

char buffer[MAX_STRING_LEN];

countChar( buffer, c ); // string str = string temp-object(buffer);

When it is called, there is a type mismatch so string [temp-object-or-unmaned-object] will be
created, buffer is copied, and binding to str arg happens. Destruction happens when return. If
buffer size is big, then it is costly. It is for compiler to make a func call succeed.

How to eliminate this?

<1> write code to make sure there is no <implicit-conversion> such as <explicit-keyword> or member
function.
<2> MEC++21

This happens only <pass-by-value> and <reference-to-const>. Why? There are exceptions
[to-maintain-constness]. See {reference-to-const}. For reference-to-non-const, get type mismatch
errors:

void uppercasify( string& str );
char subtlebookplug[] = "...";

uppercasify( subtlebookplug );          // type-error

<case-two-in-return>
This must be temp-object and [const-return]. Why const return and temp-object? See {const-return}.
If not, the following is legal: 

const Number operator+( const Number& lhs, const Number& rhs );
Number a, b, c;
a + b = c;

How to eliminate this cost?

Not always possible to shun this. Can use operator+= and see MEC++22 for more. Or can use compiler's
<return-value-optimisation> in MEC++20.


==============================================================================
*kt_dev_cpp_010* def args

If a parm has a def argument, all the parms that follow it must have def arg.

string screen(sz ht = 24, sz wid = 80, char background = ' ');
string screen(sz ht = 24, sz wid, char background = ' ');	// ERROR

string window;
window = screen();			// screen(24, 80, ' ');
window = screen(66);			// screen(66, 80, ' ');
window = screen(66, 256);	// screen(66, 256, ' ');

so consider ordering: those least likely to use a def value {appear-first} in {declaration}.

See {default-arg-in-virtual} for use inheritance.


==============================================================================
*kt_dev_cpp_011*	inline

o can avoid function call overhead
o a request to the compiler and the compiler may choose to ignore this request.
o EC++30 says that can have compiler optimisation on inlined code area.

Inline has cost:

o) bigger size and performance penalty due to additional paging and reduced instruction cache hit.
o) impossible to provide binary upgrades. Force client to compile than to relink
o) problem with debugger.
o) ctor and dtor may be worse candiate for inline. Why? There are codes written by compilers and
inserted into program during compilation for construction, destruction, exception handling during
those, new and delete, and so forth. These are up to compiler implementation. So empty ctor can have
followings:
o) A compiler refuse to inline funcs that has calls to virtual funcs because cannot know it at
compile time.


{empty-ctor-represenstaion}

class Derived: public Base {
	 public:
	 	Derived() {}
		...
	 private:
	 	std::string dm1, dm2, dm3;
};

Derived::Derived()
{
	 Base::Base();

	 try{ dm1.std::string::string(); }
	 catch(...) {
		  Base::~Base();
		  throw;
	 }

	 try{ dm2.std::string::string(); }
	 catch(...) {
		  dm1.std::string::~string();
		  Base::~Base();
		  throw;
	 }

	 try{ dm3.std::string::string(); }
	 catch(...) {
		  dm1.std::string::~string();
		  dm2.std::string::~string();
		  Base::~Base();
		  throw;
	 }
}

This is unrepresentative of what real compiler emit but do what ctor must offer. When think ctors of
base class, class members, not attractive for inlining. 

{BP} Think about 80-20 rule and may use profiler to find out 20% as a candidate for inlining.


==============================================================================
*kt_dev_cpp_012*	const member func	

{why-const-member-func}

EC++03.

o Clearer interface to show which member func can change state
o Interface only for const objects. Useful cases?


{const-and-this-pointer}

total.isbn();

When call a member func, pseudo-code for actual call should looks:

Sales_data::isbn(&total); where Sales_data::isbn(Sales_data *const this);

That is "this = &total" because this is a <const-pointer> by default; pointer itself is const. This
means cannot call usual member function which is non-const member on const class object because when
it is called, this pointer will be set but cannot. Why? since it meants 'this=&const object' but
there's no {const-to-non-const} conversion.  *kt_dev_cpp_008*

this = &const_total; // ERROR

So if we make member function const, will make this pointer as a pointer to const then:

o Cannot change object via this member func(i.e. this pointer)
o Can be used on both const and non-const class object.

string isbn 'const' { return bookNo; }

it makes:

T *const this -> 'const' T *const this


{const-on-overload}

Conditons for overloading

o Shall be the same name
o Shall have different param list in the number or the type
o Shall be in the same scope

note: So don't see return type. See {virtual-copy-constructor} for override case.

// int *const currErr : const pointer. read from right to left

Record lookup( account * );      // pointer
Record lookup( account *const );	// const pointer. re-define.

Record lookup( account & );		// non-const version
Record lookup( const account &);	// const version


{const-non-const-version}

May need to have overloads of non-const and const version.

If there is only a const version and display is const member func, then following is a comile error.
Assume display() is const member func and set_set is non-const member func.

screen myscreen;
myscreen.display().set_set(10);

Solution?

<approach-one> Use overloads for non const and const

class screen{
	 public:
	 	screen& display( ostream& os ) 
			{ do_display(os); return *this; }

	 	'const' screen& display( ostream& os ) const 
			{ do_display(os); return *this; }

	 private:
	 	// {tip}
		// use a utility func for a common duplication
	 	void do_display( ostream& os ) const 
			{ os << counts; }
};


// gcc-eample

class Screen {
	public:
		Screen& display()
		//{ cout << "dis: this is non-const member" << endl; }
		{ cout << "dis: this is non-const member" << endl; return *this; }

		const Screen& display() const
		//const Screen& display() const
		//{ cout << "dis: this is const member" << endl; }
		{ cout << "dis: this is const member" << endl; return *this; }

		void set()
		{ cout << "set: this is non-const member" << endl; }
};


int main(int argc, char** argv)
{

	Screen screen;

	screen.display();
	screen.display().set();

	const Screen cscreen;

	cscreen.display();
	cscreen.display().set();	// error for note-02
}

note: 

Screen& display() const
{ cout << "dis: this is const member" << endl; return *this; }		// error line

test.cpp: In member function 'Screen& Screen::display() const':
test.cpp:14:58: error: invalid initialisation of reference of type 'Screen&' from expression of type
'const Screen'

note-02: 

const Screen& display() const
{ cout << "dis: this is const member" << endl; return *this; }

test.cpp: In function 'int main(int, char**)':
test.cpp:32:24: error: passing 'const Screen' as 'this' argument of 'void Screen::set()' discards
qualifiers [-fpermissive]

note: case
	
Screen& display() const
{ cout << "dis: this is const member" << endl; }

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is non-const member

Seems that returns as defined in func because no comiple error and works but 'const Screen&
display() const', get the same error as the note-02.

This means that const member func has always this form when use return. This matters only when
returns reference but not a copy.

const T func( ... ) const // OK
T func( ... ) const       // NO 


<approach-two> Have one implementation for both const and non-const

From EC++03, have non-const that calls const version and have only one implementation. Used
static_cast to call const version and const_cast to cast away const and return.

class TextBlock {
	 const char& operator[]( std::szie_t position ) const 
	 {
		  ..
		  return text[position];
	 }

	 char& operator[]( std::size_t position )
	 {
		  return const_cast<char&> ( static_cast<const TextBlock&>(*this)[position] );
	 }
};

From {ref-CPR} p233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
	return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
	auto &r = shorterString( const_cast< const string& >(s1),
			const_cast< const string& >(s2) );

	return const_cast< string& >(r);
}

This is safe to cast that string back to a plain string& in the return because it is bound to one of
original nonconst arguments. See that const_cast is used to give it const and const away.


<approach-three> Change the order

myscreen.set_set(10).display();
const_screen.display();


{const-in-func-definition}

class Stack {
	...
	bool empty() const;
	...
};

bool Stack::empty() const
{
	 ...
}


If miss out 'const' in the func definition then:

usedeskcalc.cpp:28:6: error: prototype for 'bool Stack::empty()' does not match any in class 'Stack'
usedeskcalc.cpp:13:7: error: candidate is: bool Stack::empty() const


{bitwise-const}

From EC++03. Bitwise-const(physical const) is C++'s definition and compiler only catches assignment to
member data which is read-only. Issues errors like:

// example-one

Error_code Stack::top(Stack_entry &item) const
{
	...
	else
		//item = entry[count--];	# count is member
		item = entry[count-1];

	return outcome;
}

usedeskcalc.cpp:53:21: error: decrement of member 'Stack::count' in read-only object


// example-two

int cube(const int& num)
{
	num = num * num;   // [error]
	return num;
}

test.cpp:22:14: error: assignment of read-only reference 'num'

// example

#include < iostream>

using namespace std;

class Sample {
public:
	Sample(const char* str) : text(str) {}

	// cannot remove const return as return used
	const char& operator[] (std::size_t pos) const
	{ return text[pos]; }

private:
	std::string text;
};

int main(int argc, char** argv)
{

	Sample sam("CONSTMEMEBER");

	std::cout << sam[1] << endl;

	sam[1] = 'X';	// error
}

use-const-second.cpp: In function ‘int main(int, char**)’:
use-const-second.cpp:25:11: error: assignment of read-only location ‘sam.Sample::operator[](1u)’

if change to:

class Sample {
public:
	Sample(const char* str) : ptext(new std::string(str)) {}

	// [no-error] but see no const return and if so, get the same error as above.
	//
	// also the below works as well only this case meaning bit-wise.
	//
	// char& operator[] (std::size_t pos) const
	// { (*ptext)[pos] = 'k'; reurn (*ptext)[pos]; }
	//
	char& operator[] (std::size_t pos) const
	{ return (*ptext)[pos]; }

	~Sample() { delete ptext; }

private: >
	 std::string* ptext;
};

int _tmain(int argc, _TCHAR* argv[])
{
	Sample sam("CONSTMEMEBER"); or const Sample sam("CONSTMEMEBER"); 

	std::cout << sam[1] << endl;

	sam[1] = 'X'; 											// [no-error] and can chage value

	std::cout << sam[1] << endl;
 
	return 0;
}

No compile errors because 'indirect' use of an object (outside of an object) can avoid C++'s const
check called bitwise-const. ( operator[] do not change member, pointer in this case, so compiler do
not complain) This means const member func can change object state. Break encapsulation.


<fix-to-this-hole>

From EC++28. Can fix this problem as below,

const char& operator[] (std::size_t pos) const		// NO error

However, <dangling-handles> problem still remains since it returns reference to internal member.
Therefore, recommend to use const T(...) const form as a default.


{logical-const}

EC++03. Hence logical-const. This is an example to cache the length whenever it is requested. cache
textLength. Although it changes its member, it has logical constness as it updates lengh to cache
purpose. 

class CTextBlock {
	 public:
		  std::size_t length() const;

	 private:
		  char* pText;
		  mutable std::size_t textLength;	// mutable
		  mutable bool lengthIsValid;			// mutable
};

Last calculated length of textblock

std::size_t CTextBlock::length() const
{
	 if( !lengthIsValid )
	 {
		  textLength = std::strlen( pText );
		  lengthIsValid = true;
	 }

	 return textLength;
}


{mutable}

To make member data writable from a const member func. A mutable data member is never const even
when it is a member of a const object.

class T {
	 public:
	 void some_member() const;

	 private:
	 'mutable' size_t access_ctr;
};


<when-useful>

- in debug, to count the number of calls for a member func.
- to use logical constness
- to use lock as a mutable member. seems useful.
- see {lazy-fetching} in *kt_dev_mecpp_002* 


==============================================================================
*kt_dev_cpp_013*	when use reference {called-by-reference}

{no-address-when-use}

There is a difference between called-by-reference(passed-by-reference) and called-by-value. For
example:

void reset( int i )
{ i = 0; }

int j = 42;
void reset (j); 	

what's the value of j here?


void reset( int* pi )
{ *pi = 100; pi = 100; }

int j = 42;
void reset( &j );

what's the value of j here?

Here reference i will be bounded to whatever int object we pass and say "pass an object" directly.
So no need to pass its address.

void reset(int &i)
{ i = 0; }

int j = 42;
reset(j);		// [KT] no need to pass its address

what's the value of j here?

For called-by-reference, C uses pointers and C++ uses reference. Use C++ way of doing it.


<code-example>

From list and tree from kt_dev_01.txt. The list example using pointer is:

typedef struct {
   int   count;
	Node*	header;
} List;

void CreatList( List* list )
{ 
   list->count = 0;
   list->header = NULL; 
}	

bool ListAdd( List* list, EntryType entry )
{
	list->header = pnode;
	...
}

int main()
{
	List list;
	CreatList(&list);

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		ListAdd(&list, item );
	}		
	...
}


This is tree example:

typedef struct treenode {
	TreeEntry entry; // application dependant
	treenode  *left;
	treenode  *right;
} TreeNode;

TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
	if(!root)
	{
		root = newnode;
		root->left = root->right = NULL;
		std::cout << "inserted: " << root->entry.key << std::endl;
	}
	else if( LT(newnode->entry.key, root->entry.key) )
		root->left = TreeInsert( root->left, newnode);
	else
		root->right = TreeInsert( root->right, newnode);
	
	return root;
}

int main()
{
	TreeNode *proot, *pnode;
	CreateTree( &proot );

   for(int idx = 0; idx < size; idx++)
	{
		pnode = MakeTreeNode( arr[idx] );
		proot = TreeInsert( proot, pnode );
		// TreeInsert( proot, pnode );	// This is an error case
	}
	...
}

If not use return from TreeInsert then changes to proot remains null. Whether or not use
called-by-reference or value, uses a local copy but its content and how to use it makes difference.
This shows how easy and clear it is to use reference than one of pointers.


{to-change}

for( auto c : str )
	 cout << c << endl;

// want to change
for( auto &c : str )
	 c = toupper(c);


{return-reference}

// where back() returns a reference
auto &v = container.back();
auto v = container.back();


{return-reference-vs-copy}

Beware a func that returns copy or reference. {quiz} maybe a quiz?

class screen {

public:
	screen() : move(0), set(0) {}
	<case-01> screen& set_move(int val) { move = val; return *this; }
	<case-02> screen set_move(int val) { move = val; return *this; }
	void set_set(int val) { set = val; }
	void print() { cout << "screen: move " << move << ", set: " << set << endl; }

private:
	int move;
	int set;
};

screen myscreen;
myscreen.set_move(5).set_set(10);
myscreen.print();

<case-01>

5, 10

<case-02>

5, 0

Because in <case-02> set_move return is [temp-object] and myscreen is copied to a temp-object. Then
set_set is called on this temp. 


==============================================================================
*kt_dev_cpp_014*	decltype, typedef, and using

{deltype-and-auto}

The 'auto' can use from func() return

sting s("...");
decltype( s.size() ) count = 0;


{typedef-and-using}

typedef double wages;
using wages = double;	// C++11


{typedef-of-class}

Effectively, make alias to classA. Useful when class name changes. Seen in Tizen code. typedef is
just a synonym for some type (from ESTL)

typedef classA classB;


{typedef-example}

typedef struct treenode TreeNode;
typedef struct treenode {
	TreeEntry entry; // application dependant
	TreeNode  *left;
	TreeNode  *right;
} TreeNode;

or

typedef struct treenode {
	TreeEntry entry; // application dependant
	treenode  *left;
	treenode  *right;
} TreeNode;


This is to create a pointer typedef.

typedef struct _fsm
{
  VRM_FSM_INIT  init;
  ...

} *FSM_T;

FSM_T			   new_fsm = 0;


{typedef-multiple}
Is it error to have multiple typedefs? See {string-is-typedef} in *kt_dev_stl_015*

{class-vs-struct}
The only difference between struct and class is the default access specifier for members and
derivation; struct is public and class is private. p616 in ref-CPR.

{typedef-vs-struct}

struct view_class {
	const char *title;
	const char *style;
	Evas_Object *(*create)(struct viewmgr *vmgr);
	void (*update)(Evas_Object *base, Elm_Object_Item *it);
	void (*show)(Evas_Object *base, Elm_Object_Item *it);
	void (*hide)(Evas_Object *base, Elm_Object_Item *it);
	void (*resume)(Evas_Object *base, Elm_Object_Item *it);
	void (*pause)(Evas_Object *base, Elm_Object_Item *it);
	void (*terminate)(Evas_Object *base);
	int show_bg;
};

This is struct declaration and not a typedef. So need to use struct keyword to create a object.

static struct view_class _vclass = {
	.title = NULL,
	.style = "homepanel/apps/1",
	.create = _create,
	.update = _update,
	.show = _show,
	.hide = _hide,
	.resume = _resume,
	.pause = _pause,
	.terminate = _terminate,
	.show_bg = 0,
};

If it was a typedef then would use like:

static view_class _vclass = {
	.title = NULL,
	.style = "homepanel/apps/1",
	.create = _create,
	.update = _update,
	.show = _show,
	.hide = _hide,
	.resume = _resume,
	.pause = _pause,
	.terminate = _terminate,
	.show_bg = 0,
};


==============================================================================
*kt_dev_cpp_015*	declaration and definition

extern int i;		// declare
int i;				// declare and define

void func(..);		// declare
void func(..)		// declare and define
{
	 ...
}

For class, see {class-definition} in *kt_dev_lang_010*


==============================================================================
*kt_dev_cpp_016*	statement {division-and-modulus}

{side-effect}

An expression, such as 'ival+5' becomes an expression statement when it is followed by a semicolon.
An expression statement contains an expression that has a side-effect-such as assigning a new value
or printing a result-when it is evaluated.


{division-and-modulus}

The division truncate the remainder and modulus(%) operator.

// plus to grade ending in 8 0r 9 and minus to grade ending in 0, 1, or 2.
const vector< string > scores = { "F", "D", "C", "B", "A", "A++" };

string lettergrade;

if( grade < 60 )
	lettergrade = score[0];
else
{
	lettergrade = score[ (grade-50)/10 ];
	if( grade % 10 > 7 )
		lettergrade += '+';
	else if( grade%10 < 3 )
		lettergrade += '+';
}


{switch}

To emphasize that the cases represent a range of values:

switch(ch)
{
	case 'a': case 'e': case 'i': case 'o': case 'u':
		...
	break;
}

It can be useful to define a default label even if there is no work for the case to indicate that
the case was considered.

<switch-under-the-hood>

http://stackoverflow.com/questions/3012011/switch-case-assembly-level-code

Here is the C source:

switch(i)
{
    case 1:
    {
        printf("Case 1\n");
        break;
    }
    case 2:
    {           printf("Case 2\n");
        break;
    }
    case 3:
    {
        printf("Case 3\n");
        break;
    }
    case 4:
    {
        printf("Case 4\n");
        break;
    }
	 // omitted to 10:
    default:
    {
        printf("Nothing\n");
        break;
    }
}  

Now the resultant assembly for the same is:

movl    $5, -4(%ebp)
cmpl    $10, -4(%ebp)
ja  L13
movl    -4(%ebp), %eax
sall    $2, %eax
movl    L14(%eax), %eax
jmp *%eax
.section .rdata,"dr"
.align 4
L14:
.long   L13
.long   L3
.long   L4
.long   L5
.long   L6
.long   L7
.long   L8
.long   L9
.long   L10
.long   L11
.long   L12
.text
L3:
movl    $LC0, (%esp)
call    _printf
jmp L2
L4:
movl    $LC1, (%esp)
call    _printf
jmp L2
L5:
movl    $LC2, (%esp)
call    _printf
jmp L2
L6:
movl    $LC3, (%esp)
call    _printf
jmp L2
L7:
movl    $LC4, (%esp)
call    _printf
jmp L2
L8:
movl    $LC5, (%esp)
call    _printf
jmp L2
L9:
movl    $LC6, (%esp)
call    _printf
jmp L2
L10:
movl    $LC7, (%esp)
call    _printf
jmp L2
L11:
movl    $LC8, (%esp)
call    _printf
jmp L2
L12:
movl    $LC9, (%esp)
call    _printf
jmp L2
L13:
movl    $LC10, (%esp)
call    _printf
L2:  



First the code is comparing the i to 10 and jumping to the default case when the value is greater
then 10 (cmpl $10, -4(%ebp) followed by ja L13). The next bit of code is shifting the input to the
left by two (sall $2, %eax) which is the same as multiple by four (it multiplies by 4 because each
entry in the jump table is 4 bytes long). So what is had done here is generated an offset into
the jump table. It then loads an address from the jump table (movl L14(%eax), %eax) and jumps to it
(jmp *%eax).

The jump table is simply a list of addresses (represented in assembly code by labels):

L14:
.long   L13
.long   L3
.long   L4
...

One thing to notice is that L13 represents the default case. It is both the first entry in the jump
table (for when i is 0) and is handled specially at the beginning (when i > 10).

<01>
@puffadder: most modern compilers use heuristics to determine when it's more efficient to use
branches versus a jump table. E.g. if your case levels were say 1, 100 and 1000 you might expect
branches to be used. –  Paul R Jun 10 '10 at 7:07 

<02>
You have a switch statement with 5 case statements and the cases all have numbers that are spread
far apart so a jump table will not be used, 'if type' will. {Q} May choose not to use a jump table
because there will be entries which are not used? Up to a compiler?


==============================================================================
*kt_dev_cpp_017*	static-members and class const

The staic-members that are associated with the class rather than objects. So can call
static-member-func as <class-method> or <class-operation> as in smalltalk. Then <class-variable> or
<class-static> for static member var. See <function-static> for this term.

{static-member-func-and-this}

The static-member-func don not bound to any object; do not have a this pointer. Aa a result
static-member-func may not be declared as const. 


{init-class-variable}

The objects do not contain data associated with class-static. The class-static
<must-be-defined-and-inited> outside of class because it's global objects.

<in-h>
class Foo {
	 private:
	 static double interest;					// declare
};

<in-cpp>
double Foo::interest = initRate();			// define and init


{class-const}

EC++02. If it's const, it limit the scope of a constant to a class and can use in-class-init. [Must]
be static const and otherwise got error:

usecomma.cpp:8:13: error: invalid use of non-static data member ‘Foo::MAX’

<in-h>
class Foo {
	 private:
	 static const double interest = 30;		// declare. in-class-init. <class-const>
	 double table[ interest ];             // can be used.
};

<in-cpp>

This class-const of integral type can be used in class definition without definition. But used in
other context such as passing it to func arg, must define.

double Foo::interest;							// define and 'must' not init


{what-class-method-can-access}

The static member func, class-method, do not have [this-pointer] because no need to distinguish
objects and this means static member func can only use static member data.


{summary}

After all, class-method and class-variable is to provide safer way to golbal objects.

o easy access as global, no need to create an object to use, but in the class scope.
o created only when it is used. It is true for <function-static> in {limit-the-number-of-object}.
o to solve {init-order-problem}

The bottom line is that static is global but we can limit its scope to file, class, or function.


==============================================================================
*kt_dev_cpp_018*	dtor			{non-virtual-destruction-problem}

{running-order}
It is opposite to ctor in destruction order; dtor body first and then implicit member destruction
under inheritence, 

------------> ctor
base 	derived
<------------ dtor

<example>
#include < iostream>

using std::cout; using std::endl;

class Base {
    private:
		 int m_iDataABCAnimal;
    public:
		 Base() { cout << "base ctor" << endl; }
		 ~Base() { cout << "base dtor" << endl; }
};

class Derived: public Base {
    private:
		int m_iDataAnimal;
    public:
		Derived() { cout << "derived ctor" << endl; }
		~Derived() { cout << "derived dtor" << endl; }
};

int main(int argc, char** argv)
{
    Derived dobj;

    cout << "end of main" << endl;
}

$ ./a.out 
base ctor
derived ctor
end of main
derived dtor
base dtor

KT: This is staic binding so compiler knows that this is derived object. Regardless of binding type
derived dtor has a call to base dtors. This {non-virtual-destruction-problem} only mean to fail to
pick up derived dtor since it goes through vtable.


{syn-version-is-non-virtual} {dtor-in-derived-classes}
dtor is one of copy controls in *kt_dev_cpp_003* and means if not defined, the compiler will make
one which is non-virtual. 

virtual is only used in class definition and for other functions, if it's virtual in base then all
deriveds are virtual. How about dtor? That's the same. 

Unlike the constructors and assignment operators, the destructor is reponsible only for destroying
the resources allocated by the derived class. From user or programmer POV.


{non-virtual-destruction-problem}
EC++07. Problem case: when dtor phase is run and derived-to-base(pointer) is used where the base
class don't have virtual dtor. 

In GCC spec, it will have 'undefined' result but in reality, destroy only the base part; partially
destroyed. In GCC, no runtime error in simple test. 

This is the same for other member functions. That is if miss out virtual keywords in a base, then
will have only base version even if expected derived version. Therefore, there are two cases when
override do not happen; one when argument is different and see {override-keyword} and one when miss
out virtual keyword in a base as shown here.

<example-code>
#include <iostream>

using std::cout; using std::endl;

class Base {
    private:
		 int m_iDataABCAnimal;
    public:
		 Base() { cout << "ctor: base" << endl; }
		 ~Base() { cout << "dtor: base" << endl; }				// [case-01]
		 virtual ~Base() { cout << "dtor: base" << endl; }		// [case-02]
};

class Derived: public Base {
    private:
		int m_iDataAnimal;
    public:
		Derived() { cout << "ctor: derived" << endl; }
		~Derived() { cout << "dtor: derived" << endl; }
};

class DDerived: public Derived {
    private:
		int m_iDataDAnimal;
    public:
		DDerived() { cout << "ctor: derived derived" << endl; }
		~DDerived() { cout << "dtor: derived derived" << endl; }
};

int main()
{
	std::cout << "--{ main " << std::endl;

	Base* pbase = new DDerived;

	delete pbase;

	std::cout << "--} main " << std::endl;
}

For case-01:

$ ./a.out 
--{ main 
ctor: base
ctor: derived
ctor: derived derived
dtor: base
--} main 

For case-02:

$ ./a.out 
--{ main 
ctor: base
ctor: derived
ctor: derived derived
dtor: derived derived
dtor: derived
dtor: base
--} main 


<explanation-one>

KT. Why only base part when no virtual dtor? Use [static-type]. The static-type is base class but no
virtual. So do not run down virtual to derived. Hence runs base dtor only. 

If base dtor was virtual, will run down virtual path and start from derived dtor which calls chains
up to base. This means that every base shall have virtual dtor. 

<explanation-two> {how-virtual-works}

KT. Why only base part when no virtual dtor? Simply derived class's vtable is not updated and still
have base one. Hence base dtor calls. 

Class1 (base)  <- Class2 (derived)

vtable            vtable
[1] -> C1::f2     [1] -> C2::f2  [virtual]
[2] -> C1::f1     [2] -> C1::f1  [non-virtual] dtor

If base dtor was virtual, will have code to follow vptr and to call derived dtor which calls chains
up to base. This means that every base shall have virtual dtor. 

From {summary-dynamic-binding}, {scope-in-inheritance}, {how-vtable-works}, {override-keyword} can
conclude: for non-virtuals use static and for virtuals use vtables.

class A vtable  class B vtable  class C vtable
[1] A::f        [1] { A sub     [1] { A sub
[2] A::f        [2] }           [2] }      
                [3] B::f        [3] { B sub
                [4] B::f        [4] }
                                [5] { C sub
                                [6] }

vptr            vptr            vptr
instances of A  instances of B  instances of C

For C's instances, if there are overrides, update its vtable and if not, sub objects remains the
same. That explains how override and virtual works.


{when-use-virtual-dtor}
Because there are costs of virtuals and virtual-destruction-problem, have <virtual-dtor> only for
<1> case as advised in EC++07. note: KT. All base class must have virtual-dtor and these are for <1>
and <2>

<1> polymorphic base class
designed for inheritance and defined virtual funcs. 'must' use virtual dtor.

<2> base class to extend 
designed for inheritance but no virtual funcs. means no overrides and add more funcs. However, if no
virtual dtor, this causes virtual-destruction-problem. 

<3> base class not to be inherited
designed for no inheritance like STL. See {preventing-inheritance} 


{pure-virtual-dtor}
EC++07. Why use this? Sometimes you have a class that you'd like to be abstract but you don't have
any pure virtual functions. This explains that dtor should be virtual and have implementation in
case pure virtual dtor and ABC. 

class AWOW {
	 public:
	 virtual ~AWOW() = 0;
};

AWOW::~AWOW() {}

The pure-virtual-dtor [must] have a definition(implementation) and [must] be implemeted outside
class definitions.

MEC++33. Pure virtual do not mean it has no implementation and means that the class is abstract and
the derived func must be nomal virtual. True, most pure virtual functions are never implemented, but
pure-virtual-dtor are a [special-case]. They must be implemented, because they are called whenever a
derived class destructor is invoked.  


<example-error>
class ABCAnimal {
    public:
    ...
    virtual ~ABCAnimal() = 0;       # pure dtor
};

class Lizard: public ABCAnimal {
    public:
	 ...                             # no dtor
};

int main(int argc, char** argv)
{
    ABCAnimal* pabc1;
    ABCAnimal* pabc2;

    cout << "end of main" << endl;
}

Upto here, NO comile error and works fine. However, the following emits errors:

int main(int argc, char** argv)
{
    ABCAnimal* pabc1;
    ABCAnimal* pabc2;

    Lizard liz1;

    cout << "end of main" << endl;
}

GCC error is:

/tmp/cciltEbG.o: In function `Lizard::~Lizard()':
abc.cpp:(.text._ZN6LizardD2Ev[_ZN6LizardD5Ev]+0x16): undefined reference to `ABCAnimal::~ABCAnimal()'
collect2: ld returned 1 exit status

To fix this, add implementation:

class ABCAnimal {
    public:
    ...
    virtual ~ABCAnimal() = 0;       # pure dtor
};

ABCAnimal::~ABCAnimal() {}


==============================================================================
*kt_dev_cpp_019*	exception

{intention}

The exception is intended for events that prevent the program from continuing normally. so when
found no matching catch and stop execution of the program; call the library 'terminate' function.

From MEC++09. What's different to the approach of returning error code? Exception cannot be ignored
and if do, it is terminated. From MEC++12. The execution return to call site for func call but never
for exception.

{standard-exception}

The stdexcept header defines several general purpose exception classes and the type_info header
defines the bad_cast exception type.


{stack-unwinding}

A throw-keyword is like a return; statements following a throw are not executed. If no
<matching-catch> found, current/calling function is exted until found in the call tree.

o not found. call 'terminate'. 
o found. run catch and coutinue running from the the end of the try block catched.

When no try-catch block in the chain, 1,2, and 3 runs only.  

func3()              func2()                func1()
{                    {                      {
	 (1)                   (2)                    (3)
	 func2();              func1();               throw...;
	 (6)                   (5)                    (4)
}                    }                      }


During stack-unwinding, func exits prematurely and means local objects are dstroyed. dtor is called.


{exception-in-ctor}

Partially constructed. Even if it's partially constructed, guaranteed that the constructed members
will be properly destroyed. From EC++30 p137 and see {empty-ctor-represenstaion}

But from MEC++10, it shows many ways to handle exceptions in ctor so not sure that it is properly
destroyed. Seems EC++ is the latest.


{function-try-block}

Primus p773, 18.1.3 shows function-try to handle exception when do {constructor-initializers} This
is for ctor and dtor as well and to handle exceptions happens before ctor body get runs because
exception handling in ctor cannot catch it.

o The members are initialised in the order of defined in class.
o The parameters are copied using copy-ctor. covered in caller site.
o Runs constructor-initializers if there are. covered by function-try-block.
o Runs ctor-body. covered by function-try-block.

template< typename T>
Blob< T>::Blob( std::initialzer_list< T>il) : data( std::make_shared< std::vector< T>> (il)) 
{}

template< typename T>
Blob< T>::Blob( std::initialzer_list< T>il) try : data( std::make_shared< std::vector< T>> (il)) 
{}
catch ( const std::bad_alloc& e) { handle_out_of_memory(e); }


{problem-of-exception-in-dtor}

Why exception in dtor is the problem? because as said, func call tree can exit prematurely during
stack-unwinding and this means local objects are destroyed. If dtor can raise an execption, ends up
having two exception which is not allowed so terminate will be called. EC++08 says that terminate is
called or undefined. Hence 

o The <permature-program-termination> which can means no chance to do useful things to handle
exception such as clean-up and to do what is useful before terminating or swallowing. For example,
make a log entry.

So usually no exception in dtor and if do, should handle in the same dtor. STL guarantee thar dtor
will not raise an execption.


{exception-and-resource-managing-class}

To handle exception, shall use resource-managing-class, ie., RAII and see {resource-managing-class}
in *kt_dev_stl_018* for various solutions.


{how-to-handle-exeception-in-dtor}

See {raii-for-resource-using-own-interface} for other examples. From EC++08. General recommendation
is not to raise exception in dtor. If own interface comes from external source then it could raise
an exception. What to do? These are how to handle when exception happens in dtor.

TODO: check code example

class DBConnection {
	 public:
	 ...
	 static DBConnection create();    // fatctory-func
	 void close();                    // can throw exception
};

// resource managing class
class DBConn {
	 public:
	 ~DBConn() { db.close(); }        

	 private:
	 DBConnection db;
};

// client use
//
{
	 DBConn dbc( DBConnection::create() );
	 ...
}

Two approach to address exception in dtor:

<1> terminate the program

DBConn::~DBConn()
{
	 try{ db.close() }
	 catch(...) {
		  // make log entry
		  std::abort();
	 }
}

note: or can use {noexcept} at below? seems not as no chance to do useful thing such as making a log
entry.

<2> swallow the exception

DBConn::~DBConn()
{
	 try{ db.close() }
	 catch(...) {
		  // make log entry
	 }
}

<3> However, said that the better way is:

class DBConn {
	 public:
	 >
	 void close()
	 {
		  db.close();							// can exception happen
		  closed = true;
	 }

	 ~DBConn() 
	 { 
		  if(!closed)
		  {
				try { db.close(); }			// resource managing class
				catch(...) {
					// make log enrtry
					// terminate or swallow
				}
		  }
	 }
<
	 private:
	 DBConnection db;
	 bool closed;
};


The client have an opportunity to handle the problem and if not handle, back to terminating or
swallowing. However, this need client to do more.

// client use
{
	 DBConn dbc( DBConnection::create() );

	 try{ DBConn dbc.close() }
	 catch(...)
	 {
		  // try to address exception and if successful, set closed to true.
	 }
}


{exception-object} {user-defined-exception-object}

try {
	 ...
	 throw runtime_error("data must refer to the same");	# throw expression

} catch (runtime_error err) {		                        # exception declaration
	 ...
	 cout << err.what();
	 ...
}

Use throw-expression [to-copy-init-special-object], exception object. if it's a class type, must
have dtor and copy or move op. If it's array or func type, it's converted to its pointer type. {QQ}
If it is array, must be in heap since there is no connection between call and called site?

Because there's a stack-unwinding, must not to throw a pointer to a local object. Hence exception
object is copied that is manintained by compiler and remains vaild <until> catched.

If thrown object comes from class inheritance and then deferences a pointer of base class that
points derived, a copy will be made but it will be sliced-off because used dereference to copy. See
{sliced-off} in *kt_dev_cpp_022* 

Exception is like a functin call and exception declaration is like a function with one param. Like
function call, [catch] param can be non-refernce or reference. if it's class type and non-reference
then {sliced-off} How can use reference in catch since there is separation between throw and catch
site? Because exception object is held in global space by a compiler.

throw arg -> (copy init) -> exception object -> (copy init) -> catch (param)


<exception-object-always-copied>

From MEC++12. The execution return to call site for func call but never for exception. This means
that when throw, a copy is <always> made regardless of catch type whether it is value or reference
because throw leaves a call site.

// example-one

catch( Widget& w )
{
	 ...
	 throw;
}

Use 'current' exception and throw it again. 'rethrow'. So there is no addtional copy made and w can
be a derived class in Widget inheritance. KT if throwed a derived.

// example-two

catch( Widget& w )
{
	 ...
	 throw w;
}

This create a new Widget type exception and cost create and copy operation. Also, always throw
Widget type. Therefore, <example-one> is recommended.


<exception-object-type-conversion>

Limited type conversion for exception. Support <inheritance-based-conversion> that means catch using
base class type can catch exception object of derived class. Also catch uses the order of appearance
in code, called <first-fit> strategy compared to <best-fit> in function-matching.

In STL exception tree, logic_error is up than invalid_argument

try {
	 ...
	} catch ( logic_error& ex ) {
	 ...
	} catch ( invalid_argument& ex ) {
	 ...
}

Should be:

try {
	 ...
	} catch ( invalid_argument& ex ) {
	 ...
	} catch ( logic_error& ex ) {
	 ...
}

Because if first-match is found then look no further. Menas that the second catch never gets run
regardless of throw type since conversion happens in the first catch.


<exception-catch-by-reference>

1. catch by pointer, do not know if it should call delete on it because do not know if it is created
by new or not.

2. catch by value, sliced-off can happen.
3. catch by reference, okay for both problems above.

These means catch by referecne is recommendation.


{when-exception-spec-mismatch}

From MEC++14. If there is a mismatch of 'spec' between throw and catch,
<permature-program-termination> happens: unexpected() -> terminated() -> abort(). This means no
clean-up so should be avoided.

// example

extern void f1();       // may throw anything
void f2() throw (int);  // says it will throw only int type exception

void f2() throw (int)
{
	 ...
	 f1();
	 ...
}

By this, can wrap old code with new code that handles exception. But if f1() raise exception other
than int type, 'violate' f2's exception specification.

How to minimise these?

<1> do not mix template and exception spec because do not know T type so not able to write spec.
<2> change default handler, unexpected(), to handle those. For example, if we use a library that
raise unexpected exception:


<default-exception-handler>

class UnexpectedException { };

void convertUnexpected()
{ throw UnexpectedException(); }

set_unexpected( convertUnexpected );

This convert <all-unhandled-exception> to UnexpectedException and there should be catch for that
type. This means to set default exception handler.

OR

void convertUnexpected()
{ throw; }

set_unexpected( convertUnexpected );

This convert all to <bad_exception> but no detail about why. Q: why bad_exec?


<another-permature-program-termination>

This can block a exception handling of higher level. If logDestruction is declared that raise no
exception but raise it, then terminated and do not reach to ~Session().

Session::~Session()
{
	 try {
		  logDestruction(this);
	 }
	 catch(...) { }
}


{exception-safe}

See {self-assign-and-exception-safe} for reasons why need to handle self-assign. If new raise
exception, lhs state don't change but the below don't. So the below isn't exception safe.

// NO self-assign and exception-safe in value-like case
// 
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
	 delete ps;
	 auto newp = new string(*rhs.ps);
	 ps = newp;
	 return *this;
}

// combine dtor and copy. handle self-assign and exception-safe by moving delete after new.
// 
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
	 auto newp = new string(*rhs.ps);
	 delete ps;
	 ps = newp;
	 return *this;
}

EC++11. Making operator= exception-safe typically renders it self-assign-safe too. So think about
exception-safe only. See {copy-and-swap-idiom} in *kt_dev_cpp_006*


{exception-safe-gurantees}

EC++29. Two requirements for exception safety when exception happens:

NO resource leak and NO change of object state.

Therfore, a function can offer one of four gurantees:

1. None. not exception-safe.
2. basic. valid object state.
3. strong. unchaned object state.
4. noexcept. never.
 
The following offers 'almost' strong guarantee when param Image ctor can emit exception in ctor :

// from the bad exaple
//
void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
	 delete bgImage;
	 ++imageChanges;
	 bgImage = new Image(imgSrc);
};

// offer strong
//
class PrettyMenu {
	 ...
	 std::shared_ptr< Image > bgImage;
	 ...
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
	 bgImage.reset( new Image(imgSrc) );	// bad_alloc or ctor exception
	 ++imageChanges;
};

The deletion of old image takes place only if the new image is successfully created because reset
will be called only if the parameter is successfully created.

General design to lead to the strong guarantee: use {copy-and-swap-idiom} and {pimpl-idiom} in
*kt_dev_cpp_006* 

<copy-and-swap-idiom-case>

HasPtr& HasPtr::operator=(const HasPtr rhs)	// note. not ref and it's copy
{
	 ... operations to change the copy
	 swap(*this, rhs);
	 reutn *this;				// rhs is destroyed, which deletes the old ps.
}

Make all needed changes to the copy. If any of the modifying operation throws an exception, the
original remains 'unchanged'. After all changes have been successfully completed, swap the modified
with the original in non-throwing op. 


<pimpl-idiom-case>

The object has a pointer to the implementation that has all object data. This can be rewritten as
general design although offer no better gurarantee than the previous for this particular example.

struct PMImpl {
	 std::shard_ptr< Image > bgImage;
	 int imageChanges;
};

class PrettyMenu {
	 private:
	 std::shared_ptr< PMImpl > pImpl;
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
	 using std::swap;

	 std::shared_ptr< PMImpl > pNew( new PMImpl(*pImpl) );

	 pNew->bgImage.reset( new Image(imgSrc) );	// bad_alloc or ctor exception
	 ++pNew->imageChanges;

	 swap(pImpl, pNew);
};

Note: copy-and-swap-idiom is a good way for strong only when operates on local object or state than
golbals.


{rethrow}

Partially handle the exception and rethrow it up to the chain.

catch( myerror& eobj ) {
	 eobj.status = errCodes::severeErr;
	 throw;
}


{noexcept}

void recomp(int) noexcept;		// C++11 style
void recomp(int) throw();		// old style

note: The nothrow-keyword is the same as noexcept but used in new expression. See {placement-new} in
*kt_dev_stl_019*

To state that a func will not throw an exception and check it at runtime. if an exception happens
even if it's declared it will not, 'terminate' is called. See {when-exception-spec-mismatch} So two
use cases:

o when absolutly sure that there's no exception.
o when not possible to handle an exception. exit the program.


{exception-cost}

MEC++15. Exception has cost:

<1> If not use exception, can save speed and space penalty. There is compiler option to disable it.

<2> the cost of try and exception spec in space and varies from compiler to compiler. As a rough
estimate, expect your overall code size to increase by 5-10% and your runtime to go up by a similar
amount if you use try blocks. So try to minimise the use.

But think 80-20 rule and that exception is rare. Recommendation is that think if it is feasible not
to use exception, if can minimise, if can use other compiler showing better exception
implementation, and if use profiler to find out 20% to use exception.


<exception-to-disable>

From stackoverflow and said G++ specific.

Option #1: Simply never catch exceptions. {QQ} really?

Exceptions don't have much overhead when they're not thrown or caught; if you're throwing and not
prepared to catch, well, you're doing to die anyway, so the performance impact at that point is
trivial. Note also that stack unwinding will not be performed if an exception is not handled; the
program will simply terminate without performing stack unwinding.

It's important to note that, in G++, exceptions have almost no overhead when not actually thrown.
G++ generates extra information sufficient to trace back the execution of the program through the
stack, and some extra code to invoke destructors, etc - however none of this extra code or data is
ever used until an exception is actually thrown. So you should not see a performance difference
between code with exceptions enabled but not used and code with exceptions disabled (through
whatever mechanism).

Q: not sure it means never throw or never catch.

Option #2: Pass -fno-exceptions.

This flag instructs G++ to do two things:
http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html

	 All exception handling in STL libraries are removed; throws are replaced with abort() calls
	 Stack unwind data and code is removed. This saves some code space, and may make register
	 allocation marginally easier for the compiler (but I doubt it'll have much performance impact).
	 Notably, however, if an exception is thrown, and the library tries to unwind through
	 -fno-exceptions code, it will abort at that point, as there is no unwind data.

This will, effectively, turn all exceptions into abort()s, as you would like. Note, however, that
you will not be allowed to throw - any actual throws or catchs in your code will result in a
compile-time error.

Option #3: (Nonportable and not recommended!) Hook __cxa_allocate_exception.

C++ exceptions are implemented using (among others) the __cxa_allocate_exception and __cxa_throw
internal library functions. You can implement a LD_PRELOAD library that hooks these functions to
abort():

void __cxa_allocate_exception() { abort(); }
void __cxa_throw() { abort(); }

WARNING: This is a horrible hack. It should work on x86 and x86-64, but I strongly recommend against
this. Notably, it won't actually improve performance or save code space, as -fno-exceptions might.
However, it will allow the throw syntax, while turning throws into abort()s.


==============================================================================
*kt_dev_cpp_020*	<empty>



==============================================================================
*kt_dev_cpp_021*	op overload

For class type because cannot overload operations for built-in types.

{member-or-non-member}

Whether to implement op overloads as either a member or non-member?

<assign-op> 
assign("=") should be member.

<symmetric-op>
arith, equality, relational or mixed-type arith that is commutative should be non-member.  

Why? think string u = "hi" + s; since a literal do not have member operations.

<io-op>
IO ops(<<, >>) should be non-member and usually a friend. If these are member op then can use like:

Sales_data data;
data << cout;

This is against to usual syntax. Why? Because when overloading op, lhs must be a class in which op
is defined.

class Sales_data {
	 ostream& operator<<( ostream& str ) const;
};

If want to use usual syntax like cout << data then means to change STL ostream class but cannot.
Therfore, these ops should be non-member. TODO: more explanation.

ostream& operator<<( ostream& os, const Sales_data& item )
{
	 os << item.isbn() << " " << item.revenue() << ...
	 return os;
}

note: no const for ostream& since it writes to stream and change its status and const and reference
for Sales_data


{member-op}

For member op, the first(left hand, lhs) operand is bound to the implict this pointer. This implies:

data1 += data2;

is 'always' equi to:

data1.operator+=(data2);

why not 'data2.operator+=(data1);' as these are the same type? because 'data2 = data1+data2' is
different.


{function-object}

If oveload operator() then can use a object as if it's a func call and 'call' a object. Hence
function object. must be a member and can have 'state' so it's flexible than usual func.

struct absInt {
	 int operator() (int val) const {
		  return val < 0 ? -val : val;
		  }
};

int i = -42;
absInt absObj;
int ui = absObj(i);
  

class PrintString {
	 public:

	 PrintString( ostream& o = cout, char c = ' ') : os(o), sep(c) {}

	 # const member func. works well. {QQ} wondered why const as os may change its state?
	 #
	 void operator() (const string &s) const { os << s << sep; }

	 private:
	 
	 ostream& os; char sep;
};

PrintString printer;
printer(s);

PrintString errors( cerr, '\n' );
errors(s);


The main use is to use with algorithm:

# create a temp PrintString object
#
for_each( vs.begin(), vs.end(), PrintString( cerr, '\n' ));

STL provides function objects for algorithms. #include <functional> as an example, to sort
descending order while it do ascending order by default.

sort( sv.begin(), sv.end(), greater< string >() );

See predicate in *kt_dev_stl_010*


==============================================================================
*kt_dev_cpp_022*	oop: inheritance

{subobject-and-derived-to-base-conversion}

The <dynamic-binding> at run-time so called run-time binding because <static-type> is different from
<dynamic-type> and it is from inheritance. This is:

pointer or reference of base class = the one of derived class;
<static-type>                        <dynamic-type>

1> this is an exception to normal type-match as this is a conversion between different types. See
{type-match-exceptions}

2> do not know which object to bind until runtime. 

Subobject is key to how inheritance and dynamic-binding works. From MEC++. Inheritance give rise to
pointer and reference with two different types: static and dynamic type.


{conceptual-structure-of-deirved-object}

| ----------- |
|  base part  |
| ----------- |
| drived part |	# non-static members
| ----------- |

Quote item; Bulk_quote bulk;

# implicit derived-to-base-conversion for ref and pointer.

Quote* p = &item;
p = &bulk;

Quote& r = bulk;

If do followings with p or r:

1: calls non-virtual funcs of base then get base version. static
2: calls virtual funcs of base then get derived version. dynamic
3: calls any func of derived then compile error. static
4: deference and copy then sliced-off. static

{QQ} How compiler know whether it is normal function or virtual function call?

class Bulk_quote : public Quote {
	 public:
	 	double net_price( std::size_t ) const override;
};

double print_total( ostream& os, const Quote& item, size_t n ) // [Quote-reference]
{
	 double ret = item.net_price(n);                            // [virtual-call]
	 os << ... ;
	 return ret;
}

Quote item;
Bulk_quote bulk_item;

print_total( item );          // Quote version
print_total( bulk_item );     // Bulk version. dynamic-binding.


{sliced-off} {static-binding} {dynamic-binding}

The staic binding is done at compile time. <copy-ctor> and <copy-assign> are func calls and
derived-to-base-conversion happens when base's copy-int and copy-assign is called. But knows only
about base and derived part is ignored because do copying and hence only know about <static-type>. 

class Foo {
	Foo(const Foo&);
	Foo& operator=(const Foo&);
};


KT: The above explanation is a bit vague. In summary, compiler always use <static-type> but use ~
dynamic-type only if it is virtual function call. ~

This should be revised as: The compiler always use static-type and if it is a virtual call then will
generate a code for run-time binding and could calls derived version. However, this could be broken
if fails to override in the derived.

// example-one

Quote item(bulk);         # sliced-off
item = bulk;              # sliced-off

// example-two

From MEC++33. When there are concrete classes like this:

base <- derived1
     <- derived2

The problem case is:

o obj = obj;               # the same class. fine
o baseobj = derivedobj;    # sliced-off
o derivedobj = baseobj;    # compile error

From GCC:
sam_slice.cpp:51:7: error: no match for 'operator=' in 'lo = bo'
sam_slice.cpp:51:7: note: candidate is:
sam_slice.cpp:30:8: note: Derived& Derived::operator=(const Left&)
sam_slice.cpp:30:8: note:   no known conversion for argument 1 from 'Base' to 'const Derived&'

Note: this is a syn coy-ctor that a compiler created.


o *baseptr = *baseptr;     # the same class. fine
o *baseptr = *baseptr;     # diff. base = derived. sliced-off. <1>
o *baseptr = *baseptr;     # diff. derived = base. sliced-off. <2> [no-compile-error] 

Why different in result? Because a compiler use <static-type> and only base part will be copied for
<1> and <2>.

So two problems here:

o sliced-off with no comiple error when use pointer
o real programmers write code like this.

How can we make it compile error to flag up two cases, <1> and <2>, in compile time? That is to make
it difficult to use incorrectly. <Q> TODO: So what's the solution? need to summarise the followings again.


<approach-one> 

Make operator= virtual. May thought it can use virtual mechanism. MEC++ said that derived's version
will be called and shall have the same params for virual funcs. But the return can be different.

class Base {
private:
	Animal& operator=(const Base& rhs); 
	...
};

class Derived: public Base {
public:
	Derived& operator=(const Base& rhs);
	...
};

However, in GCC 4.6.3, the params of virtual function can be different and derived's version is not
called. Note: Q: Changed in C++11?

Note: MEC++ seems to be wrong as a compiler use static-type and base version gets called. So don't
need to consider.

Note: see {override-keyword} and need to sum up if needed.

<approach-two-and-three>

Make operator= private and protected. Do not work when *pbase1 = *base2;

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is private
sam_slice.cpp:92:13: error: within this context

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is protected
sam_slice.cpp:92:13: error: within this context

So not a solution.


<approach-to-make-abstract-class>

To remove sliced-off cases, make the base abstract and all derived on the same level. MEC++ says it
as make non-leaf classes abstract.

This only enables copys between objects in the same class whether it is via object or pointer.

But MEC++ says it is more about uncovering the design need to have abstract class out of derived
classes.

{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for that function.
However must define every virtual function regardless of whether it is used because do not know
which version of a function is called until run time.

{virtual-and-resolution}
The compiler generates code to decide at run time which function to call when a virtual function is
called through a reference or pointer. This is run time binding and polymorphism in C++.

{preventing-inheritance}

<1>
class Last 'final' : Base { ... };

<2>
Use private ctor. See {{control-the-number-of-object}}


{init-in-inheritance}

Unless we say otherwise, the base part of a derived is default-init.

The usual way is:

class Disc_quote : public Quote {
	 public:

	 Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
	 	Quote(book, price), quantity(qty), discount(disc) {}

};

If omit base ctor, then base part, Quote, is default-init.

class Disc_quote : public Quote {
	 public:

	 Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
	 	quantity(qty), discount(disc) {}

};

As for ctor, copy controls must explicitly call base part and otherwise has 'oddly configured'
object such as the derived part copied as expected but the base part default-init. In other words,
dtor is the only exception where do only for its part. ~


class Base {
	 public:
	 	Base(int val) { ... }
};

class Left: public Base {
	 public:
	 	Left(int val) {}
		...
};

sam_slice.cpp: In constructor 'Left::Left(int)':
sam_slice.cpp:27:32: error: no matching function for call to 'Base::Base()'

Because Base has another ctor so default-ctor will not be made and shows this error.

{call-base-in-virtual-of-derived}

Use scope operator. This is called circumventing the virtual mechanism; base version do work common
to all types and the derived version do whatever additional work.

class Window {
  public:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow: public Window {
  public:
    virtual void onResize()
    {
      Window::onResize();
      ...
    }
};

{base-class-pointer-container} {RTTI}

// problem-one

MEC++03: In inheritance, base pointer can point to derived class and when passes a array of derived
instead of base, <undefined-result> can happen.

class BalancedBST: public BST { };

void printBSTArray(ostream& s, const BST array[], int numElements)
{
	 for (int i = 0; i < numElements; ++i) {
		 s << array[i]; // this assumes an operator<< is defined
	 } 
} // for BST objects

Because array[i] is *(array+i) and means can end up with wrong place. This warning applies to
deleting arrays like: delete [] array;

{Q} what is the real problem here? how does it relate to base class pointer? 


// problem-two

EC++27: Problem:

Use smart-pointers to base to access <ANY> possible derived class. Only SpecialWindow support
blinking. Means that need to have to check its type at rumtime.

class Window { ... }
class SpecialWindow: public Window {
	 public:
	 void blink( ... );
	 ...
};

typedef std::vector< std::shared_ptr< Window >> VPW;
                                      ^^^^^^
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
	 if( SpecialWindow* psw = dynamic_cast< SepecialWindow* >( iter->get() ) )
	 {                        ^^^^^^^^^^^^
		  psw->blink();
	 }
}

Undesirable because dynamic_cast is slow and also need to know to which type the object should be
cast. Means already you know what it is.


<dynamic_cast-vs-virtual>

From Primus C++ 19.2 RTTI:

The dynamic_cast operator is the part of RTTI(run-time type identification). These operators are
useful when we have a derived operation that we want to perform through a pointer or reference to a
base-class object and it is not possible to make that operation a virtual function. Ordinarily, we
should use virtual functions if we can.


// problem-three

From MEC++33: when showing virtual operator= to support mixed type assign in inheritance.

Derived& Derived::operator=(const Base& rhs)      # virtual member op
{
	 const Derived& rhs_derived = dynamic_cast<const Derived&>(rhs);

	 // proceed with a normal assignment of rhs_derived to left *this
}


<when-dynamic-cast-fails>

If a dynamic_cast to a pointer type fails, the result is 0. Error-reporting strategy for pointer.
For reference, bad_cast exception. 

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
	 
} else {  // bp points at a Base object

    // use the Base object to which bp points
}


<solution-one> type-safe container

typedef std::vector< std::shared_ptr< SpecialWindow >> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
	 (*iter)->blink();
}

Remove dynamic_cast BUT limited to SpecialWindow only. Not other possible derived class.


<solution-two> use virtual func in the hierarchy

class Window { 
	 public: >
	 virtual void blink {}		   // def-impl. do-nothing
<	 ... 
};

class SpecialWindow: public Window {
	 public: >
	 virtual void blink( ... );	// do real work
<   ...
};

//                                    ______
typedef std::vector< std::shared_ptr< Window >> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
	 (*iter)->blink();
}

{derivation-access-specifier}

class X : publuc/private/protected B {
  ...
};

This has no effect on whether members of a derived class may access the members of its direct base
class. The purpose is to control the access that users of the derived class.


==============================================================================
*kt_dev_cpp_023*	override

{dynamic-binding} {polymorphism}

Oppose to compile-time binding the compiler generates 'code' to decide at run time which function to
call. This dynamic binding or virtual mechanism is how C++ supports polymorphism. See
{static-binding}

Or some says static and dynamic polymorphism and expand it to type but not about function.
Polymorphism in general is when a piece of a program is designed to allow multiple different types
to be used in it.

Static polymorphism is a use of polymorphism that is determined when the program is constructed
(such as the Template system in C++). Once the program is constructed, the choice is made and the
type used is known.

Dynamic polymorphism is determined at run time. (Such as a pointer to a base class that allows for
descendant class pointers to be passed in. The base class provides the interface and the
descendants implement that interface in different ways that are suitable to the specifics of
the class.) Decisions are made during run time that choose which type to pass.

The important distinction is deciding at construction (compile) or run time. Generally, a well
designed static polymorphism performs better than dynamic, so it is to be preferred when the design
makes it possible. If the information to make a choice is not available until run time, dynamic is
the choice.


{override-keyword} {return-type-in-override}

To override, name and args should be the same but 'return' type is an exception to this. This is not
ture and see below. 


class CInterface 
{
	public:
		virtual void getName()
		{ std::cout << "this is CInterface" << std::endl; }
};

class CMyInterface : public CInterface
{
	public:
		//virtual bool getName()         // [case-three]
		//virtual void getName()         // [case-one]
		virtual void getName(int val)    // [case-two]
		{ std::cout << "this is CMyInterface" << std::endl; 
			//return true; 
		}
};

int main()
{
	std::cout << "-----{ main " << std::endl;

	CInterface* pinter = new CMyInterface();

	std::cout << "created CInterface" << std::endl;
	
	pinter->getName();

	delete pinter;

	std::cout << "-----} main " << std::endl;
}

This is [case-two] when arguments are different by mistake and there are two cases:

1> Like this example, the output is "this is CInterface" because starts from base class, and found
the name there but overriding does not happen. So got the base version.

2> This defines a new function in the derived and hide the name in the base. Like example in p619,
when uses example here, following error happens.

int main()
{
  ...
  CMyInterface cmy;
  cmy.getName();
}

override.cpp: In function ‘int main()’:
override.cpp:34:15: error: no matching function for call to ‘CMyInterface::getName()’
override.cpp:34:15: note: candidate is:
override.cpp:15:16: note: virtual void CMyInterface::getName(int)
override.cpp:15:16: note:   candidate expects 1 argument, 0 provided

This is [case-one] because was overrided.
this is CMyInterface

For [case-three], errors
error: conflicting return type specified for 'virtual bool CMyInterface::getName()'
error:   overriding 'virtual void CInterface::getName()'

However, tried pointer return type, no errors so return type in overrides can be different only
that is pointer. See p606 in ref-CPR.

As shown in {scope-in-inheritance} *kt_dev_cpp_007* this is to hide func in the derived and that is
derived version is not called as expected. It's surprisingly hard to find because there is no
compile error. To avoid this, use override keyword from C++11 and cause compile error when it's not
overrided:

class B {
	 void f1(int) const final;
	 virtual void f2();
	 void f3();
};

class D : public B {
	 void f1(int) const;		# error
	 void f2() override;
	 void f3() override;		# error
};

# VC error for f3 case:
Error	1	error C3668: 'Derived::sample' : method with override specifier 'override' did not override
any base class methods	

The final-keyword is used to end override. See final-keyword in inheritance.


{default-arg-in-virtual}

Default arg in virtual func will 'always' be used base's one even when the drived version is run
because default arg is statically bound and virtual is dynamic. See {default-arg} *kt_dev_cpp_003*

Problem case is:

class Shape {
	 public:
	 enum ShapeColor { Red, Green, Blue };
	 virtual void draw( ShapeColor color = Red ) const = 0;
	 ...
};

class Rectangle : public Shape {
	 public:
	 virtual void draw( ShapeColor color = Green ) const;
	 ...
};


==============================================================================
*kt_dev_cpp_024*	ABC

This is the previous approach to support several discounts:

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};

The abstract base class to represent the general concept and to prevent users creating a object of
this type.

Imagine that want to support several discount strategies by defining a new class named Disc_quote to
store the quantity and the discount amount. Each strategy is the same in that it requires a quantity
and a discount amount but implement its discount strategy by defining its own version of net_price.
Each discount class will inherit from Disc_quote. This raises a question: the Disc_quote do not
correspond to any particular discount strategy but user can create object of this type and can use
print_total. The result is the same when use Quote object since it inherits Quote version and no
discount even if user provided values. How can we prevent this nonsensical code?

This Disc_quote represent the general concept of a discounted book, not a concrete discount policy.~

To prevent users from creating Disc_quote objects, use pure-virtual and unlike usual virtuals,
pure-virtual do not have to be defined.

class Disc_quote : public Quote {
  public:
    Disc_quote() = default;
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

    # pure virtual function
    double net_price(std::size_t) const = 0;

  protected:
    std::size_t quantity = 0;
    double discount = 0.0;
};


class Bulk_quote : public Disc_quote {
  ...
};


{BP} Why define ctors although cannot define objects of this type directly? because of constuction
and destruction chain. See {non-virtual-destruction-problem} If user do not provide ctors, compiler
will provides so ther always is construction chain but not initialisation chain.

When deriving a class from the ABC, if don't override a pure virtual func then the derived also
becomes ABC. Also, ABC can have implementations and see interface-class and tizen case.


{refactoring}

This is refactoring-example. Refactoring involves redesigning a class hierarchy to move operations
and/or data from one class to another. It is that even though we changed the inheritance hierarchy
code that uses Bulk_quote or Quote would not need to change but need to recompile.


{error-when-create-abc}
This happens when tries to create an implementation class which is derived from ABC class; that is
interface class. Why? because implementation class did not override some of members.

/port/CPort.cpp: In static member function 'static CPort* CPort::getInstance()':
/port/CPort.cpp:36:27: error: cannot allocate an object of abstract type 'CPort'
/port/CPort.h:29:1: note:   because the following virtual functions are pure within 'CPort':
/interface/port/IPort.h:48:22: note: 	virtual IIframe* IPortingLayer::getIframe()
/interface/port/IPort.h:56:23: note: 	virtual ISession* IPortingLayer::getSession()
/port/CPort.cpp: In constructor 'CPort::CPort()':
/port/CPort.cpp:46:25: error: cannot allocate an object of abstract type 'CIframe'
/port/CIframe.h:27:1: note:   because the following virtual functions are pure within 'CIframe':
/interface/port/IIframe.h:73:18: note: 	virtual void IIframe::destory(uint32_t)
/interface/port/IIframe.h:80:18: note: 	virtual bool IIframe::isDisplayed()
/interface/port/IIframe.h:86:18: note: 	virtual bool IIframe::setDisplayFlag()
/interface/port/IIframe.h:94:18: note: 	virtual bool IIframe::isMHEG2(void*, uint32_t)
/interface/port/IIframe.h:102:18: note: 	virtual bool IIframe::isMHEG4(void*, uint32_t)

This may be a way to check whether it's overrieded or not?


==============================================================================
*kt_dev_cpp_025*	template

The types become known during complilation in generic programming whereas OOP deals with types that
are not known until run times.


{function-template}
For function template, the compiler uses the template argument to deduce the template parameter
type.

compare( 1, 0 );
compare( vec1, vec2 );

template <typename T>		# '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
	 if( v1 < v2 ) return v1;
	 if( v2 < v2 ) return v2;
	 return 0;
}

Here see that it uses only '<' operator and this means that class can only support '<' operator but
surely not for built-in types.

# error case as should be 'typename U'
template <typename T, U> inline T calc( const T&, const U& );

# can use typename or class but recommands typename
template <typename T, class U> inline T calc( const T&, const U& );


{class-template}
Unlike function-template, compiler cannot deduce the type of parameter so user must provide
additional information to instantiate it. That is an element type.


{instantiation}
Ordinarily, when call a function, the compiler needs to see only a declaration. Similarly, when use
objects of class type, the class definition must be available but the definition of the member
functions need not be present. As a result, put class definition and function declaration in header
file and definition of ordinary and class member function is source files.

For template member functions, it is instantiated only if it is used and if not, it is not
instantiated.

Generic programming. 'instantiation' is a process that create a concrete independant function or
class from a template when compiling. Must be defined in the same namespace that contains the
original template.

Template specialization must be defined in the same namespace that contains the original template.

namespace std {
	template <> struct hash< Sales_data >;
}

// Having added the declaration for the specialization to std namespce we can define the
// specialization outside the std.
template <> struct hash < Sales_data > 
{
	size_t operator() ( const Sales_data& s ) const
	{
		return hash<sring>()(s.bookNo);
	}
	// other members as before
}


{example}
<original-version>

<- new container class ->  <- companion class like iterator ->
   StrBlob                    StrBlobPtr
   - shared_ptr               - weak_ptr
                     vector[]
                     - underlying container

The weak_ptr do not participate in the reference count of shared_ptr and won't affect the lifetime
of the vector. However, can prevent the user from attempting to access a vector that no longer
exist.

class StrBlob {
  friend class StrBlobPtr;

  public:
    typedef std::vector< std::string >::size_type size_type;

    StrBlob();
    StrBlob( std::initializer_list<std::string> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const std::string &t ) { data->push_back(t); }
    void pop_back();

    std::string& front();
    std::string& back();

    // return a copy object like iterator
    StrBlobPtr begin() { return StrBlobPtr(*this); }
    StrBlobPtr end() { reutn StrBlobPtr(*this, data->size(); }

  private:
    std::shared_ptr< std::vector<std::string>> data;
    void check( size_type i, const std::string &msg ) const;
};

StrBlob::StrBlob: data( make_shared<vector<string>> ()) {}
StrBlob::StrBlob(initializer_list<string> il): data( make_shared<vector<string>> (il)) {}

void StrBlob::check( size_type i, const string &msg ) const
{
  if( i >= data->size() )
    throw out_of_range(msg);
}

string& StrBlob::front()
{
  check( 0, "front on empty StrBlob" );
  return data->front();
};

string& StrBlob::back()
{
  check( 0, "front on empty StrBlob" );
  return data->back();
};

string& StrBlob::pop_back()
{
  check( 0, "front on empty StrBlob" );
  return data->pop_back();
};

{Q} are these all operation on vector? what will happen when calls on empty vector?


class StrBlobPtr {
  public:
    StrBlobPtr(): curr(0) {}
    StrBlobPtr( StrBlob &a, size_t sz=0 ): wptr( a.data ), curr(sz) {}

    StrBlobPtr& incr();
    StrBlobPtr& deref() const;

  private:
    std::shared_ptr< std::vector<std::string>> check( std::size_t, const std::string& ) const;
    std::weak_ptr<std::vector<std::string>> wptr;
    std::size_t curr;
};

std::shared_ptr< std::vector<std::string>> 
StrBlobPtr::check( std::size_t, const std::string& ) const
{
  // ret is shared_ptr and is the vector still around?
  auto ret = wptr.lock();
  if(!ret)
    throw std::runtime_error("unbounded StrBlobPtr");

  if( i >= ret->size() )
    throw std::out_of_range(msg);

  return ret;
}

std::string& StrBlobPtr::deref() const
{
  auto p = check( curr, "dereference past end");
  return (*p)[curr];    // must since [] is higher than *
}

StrBlobPtr& StrBlobPtr::incr() const
{
  auto p = check( curr, "increment past end");
  curr++;
  return *this;
}

<template-version>
template<typename T>
class Blob {
  public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;

    Blob();
    Blob( std::initializer_list<T> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const T &t ) { data->push_back(t); }
    void pop_back();

    T& front();
    T& operator[](size_type i);

  private:
    std::shared_ptr< std::vector<T>> data;
    void check( size_type i, const std::string &msg ) const;
};

Blob<int> ia;
Blob<int> ia2 = { 0, 1, 2, 3, 4 };


{member-template} {IE}

Means member func is itself template. Primers p672. This example shows to have 'deleter'
which prints out mesg when dtor runs.

Like shared_ptr, unique_ptr can set deleter. See *kt_dev_stl_018* for more.

unique_ptr< objT, delT > p ( new objT, fcn );

delT is the deleter type. fcn is callable object of delT. callable objects are func, func
ptr, lambda, object binded, and class overloaded the call op.

unique_ptr< connection, decltype(end_connection)*> p ( &c, end_connection );


class DebugDelete {
	 public:
	 DebugDelete( std::ostream& s = std::cerr) : os(s) {}

    # this make it work for 'all' types by using member template.
	 #
	 template <typename T> void operator() (T* p) const
	 	{ os << "deleting unique_ptr" << std::endl; delete p; }

	private:
	std::ostream& os;
};

double* p = new double; DebugDelete d;
d(p);

When use it with unique_ptr:

unique_ptr<int, DebugDelete> p( new int, DebugDelete() );
unique_ptr<string, DebugDelete> p( new string, DebugDelete() );

These are equivalent to:

void DebugDelete::operator() (int*) const { delete p; }
void DebugDelete::operator() (string*) const { delete p; }

Because compiler deduce the type of func template when used(instantiated) so these will be
instantiated to correct type when deleter is called.


==============================================================================
*kt_dev_cpp_026*	enum			{enum-hack}

The enumerations group together sets of integral 'constants' and defines [new] type.

{scoped-enum}

C++11. note that used class keyword. Defines an object of 'open_modes' type and follows scoping rule
means type-erorr can happen. Scope means to specify explicitly where it come from

// enumerators
enum 'class' open_modes { input, output, append };

open_modes readfile = open_modes::input;
open_modes readfile = 2;	// error

{unscoped-enum}

The enumerator is const and need not be unique. By default, start at 0 and inc by 1.

enum color { red, yellow, green };				// unscoped
enum stoplight { red, yellow, green };			// error: redefines enumerators
enum class peppers { red, yellow, green };	// okay: enumerators are hidden

color eyes = green;

// error: enumerators from peppers are not in scope. color::green is in scope but has the wrong
// type.
peppers p = green;		

color hair = color::red;
peppers pp = peppers::red;

enum { floatPrec = 6, doublePrec = 10, double_doublePrec = 10 };	// unnamed, unscoped


{conversion} {enum-hack}

The 'unscoped' enumerators are implicitly converted to 'int' but not vice versa. Can be used where
an integral value is required. called <enum-hack>. By default scoped enums have int as the
underlying type. There is no default for unscoped enums; all we know is that the underlying type is
large enough to hold the enumerator values.

int i = color::red;
int j = peppers::red;	// error


{func-with-enum-arg}

Cannot pass an integral value to an enum parameter but can pass an object or enumerator of unscoped
enumaration to a parameter of integral type; the enum promotes to int or to a larger integral type.

enum Tokens { INLINE = 128, VIRTUAL = 129 }

void ff(Tokens);
void ff(int);

Tokens curr = INLINE;

ff(128);			// ff(int)
ff(INLINE);		// ff(Tokens)
ff(curr);		// ff(Tokens)


==============================================================================
*kt_dev_cpp_027*	volatile

This is non-portable feature. For values that is controlled by processes outside the direct control
of the program and might be changed in ways outside the control of the program.

It's a directive to the compiler telling that is shoud not perform 'optimisations' on such objects.


==============================================================================
*kt_dev_cpp_028*	namespace

To solve name pollution or collisions, namespace partitions the global namespace and a namespace is
a scope. It provides a much more controlled mechanism and any declaration can be put into a
namespace.

{global-namespace}
Names defined at global scope are in the global-namespace which is implicitly declared and exists in
every program. The scope operator can be used. {BP} use for global names.

::member_name


{named-namespace}
note: The namespce definition do not ends with a semi-colon.

namespace Foo {
	 ...
}

<namespace-is-a-scope>
Code outside the namespace must indicate the namspace in which the name is defined.

cplusplus_primer::Query q = cplusplus_primer::Query("Hello");

<can-be-discontiguous>
The namespace either defines a new namespace or adds to an existing one. Be sure only #include
appear before opening the namespace. If not, attempt to define all the names in that header as
members of the enclosing namespace. 

The declaration and definition should be in the same namespace and this means shall use namespace
block for header and source file.

// Sales_data.h
#include <string>

namespace cplusplus_primer {
	class Sales_data { ... };
	Sales_data operator+( const Sales_data&, const Sales_data&);
	// declarations for the remaining functions in the Sales_data interface
}

// Sales_data.cpp
#include "Sales_data.h"

namespace cplusplus_primer {
	// definitions for the Sales_data members and overloaded operators
}

// user.cpp
#include "Sales_data.h"

int main()
{
	using c_plusplus_primer::Sales_data;
	Sales_data trans;
	...
}


{unnamed-namespace} {file-static}
Unnamed namespace. variables in unnamed namespace has staic lifetime so has file scope as with
file-static. If a header file has vars in unnamed namespace, it create different static vars which
are local to file that includes that header file. This replace file-static of C. *kt_dev_lang_001*
This also means that unnamed-namespace never spans multiple files and do not recommend to have it in
a header since the names in that namespace define different entities local to each file that
includes the header.

namespace {
	 ...
}

<example>

#include <iostream>

int i;			// 3

namespace {
	int i;		// 6
}

int main()
{
	i = 10;		// 11. ambiguous: defined globally and in an unnested, unnamed namespace.

	return 0;
}

sam01.cpp: In function ‘int main()’:
sam01.cpp:11:2: error: reference to ‘i’ is ambiguous
sam01.cpp:3:5: error: candidates are: int i
sam01.cpp:6:6: error:                 int {anonymous}::i


{using-declaration-and-directive}

The <using-declaration> which brings one namespace member into the scope that uses it.

using std::cin;

The <using-directive> which brings whole namespace into the the scope that have both a namespace and
a scope that uses directive. This is enclosing scope that is outter scope than the one uses
directive.

using namespce std;

<avoid-use-of-directive>

Why? Other than else, late-detection; means that ambiguity errors are detected only at the point of
use when use directive. This late detection means that conflicts can arise long after introducing a
particular library. If the program begins using a new part of the library, perviously undetected
collisions may arise.

// example. blip namespace is injected into the global namespce but no compile error. Emit error
// when strat to use j. At a point of use. 

#include <iostream>

namespace blip {
	int i=16, j=15;
}

int j = 0;

int main()
{
	using namespace blip;

	//++j;

	return 0;
}


// example. immediate compile error regardless of using j. At a point of declaration.
// sam01.cpp:9:13: error: ‘j’ is already declared in this scope

#include <iostream>

namespace blip {
	int i=16, j=15;
}

int j = 0;

using blip::j; 

int main()
{
	return 0;
}


<avoid-use-in-header-file>

Why? A header that has a using directive or declaration at its top-level injects names into every
file that includes the header. 

<when-directive-useful>

{BP} One place where using directive are useful is in the implementation files of the namespace
itself.


{nested-namespace}

namespace X { namespace App
{
	 class X : public XXX
	 {
		  ...
	 };
}}


==============================================================================
*kt_dev_cpp_029*	nested class

The type member is a local name and unlike ordinary members, type member must appear before they are
used. So usually appear at the beginning of the class.

class Screen {
	public:
		typedef std::string::size_type pos;

	private:
		pos cursor 	= 0;
};


Called nested-type and think it as nested-scope. Most used to define implementation class. This
defines <type-member> of enclosing class. Means:

o no connection between objects. do not have memebers of each other.
o nest class is only visible in its enclosing class.

When use? Tightly coupled to enclosing class so little sense to use nested class for any other
purpose.

class TextQuery {
	 public:
	 	class QueryResult; // to be defined later but seen before use.

		...
};

class TextQuery::QueryResult {
	 friend std::ostream& print(..);

	 public:
	 	QueryResult( ... );
		...
};

Unlike the previous {text-query-example}, no need to define QueryResult::line_no because nested
class can have direct access to enclosing class.

enclosing scope {

	 nested scope {
		  ...
	 }

}


==============================================================================
*kt_dev_cpp_030*	case study: framework {tizen-case}

From Tizen and points to see are:

o Used factory-func to create a self in the derived class but used static-factory-func. Have
separation and single point of acess to create whole instances.

o Not used singleton but used protected and private ctor or/and dtor in a tree. The protected is
used like singleton to allow derived to create base part.

o Used pimpl-idiom but do not have the same interface between them. not necessary to have the same
interface 

o the way to pass cpp func addresses to c

 
App: ABC                                  _AppImpl: public interface classes
															friend class App
 'protected': ctor(); new _AppImpl           	'private': ctor and dtor (only App can create AppImpl)
 'static' App* GetInstance(); calls -> 			static _AppImpl* GetInstance()
                                           	Construct()
                                           	Execute()
 |
 |
 |
ServiceApp:                               _ServiceAppImpl: public interface classes
 'protected': ctor(); new _ServiceAppImpl    	'private': ctor and dtor
 static ServiceApp* GetInstance(); ->      	static _ServiceAppImpl* GetInstance()
 static Execute(); 
 	: use user provided factory-func to create user class and creates all instances
	: register a event listener and run efl_main

 | 
 | Framework 
 |-----------------------------------------------------------------------------
 | User classes
 |----------------------------------
 |                                 | ...
AppService:                       XXXService:
 static CreateInstance();
 	: member-static-factory-func to create AppService. This is interesting because used subclassing
	to decide what to create but used static-factory-func.

OspMain():
   result r = Tizen::App::Service::Execute( AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute( AppService::CreateInstance, &args); )

//
// App
//
class App
{
// interfaces
public: 
	virtual OnXXX()=0;
	virtual void OnLowMemory(void);

	// very few use of forwarding to impl.
	virtual OnYYY()
	{ __pAppImpl->OnYYY(); }

	static App* GetInstance();
	{
		_AppImpl* pAppImpl = _AppImpl::GetInstance();

		if (pAppImpl != null)
		{  // [KT] why need this as it returns App* which is passed to Impl?
			return pAppImpl->GetAppInstance();
		}

		return null;
	}

	virtual ~App(void)			# see virtual
	{ delete __pAppImpl; }

protected:
	App(void);
	{ __pAppImpl = 'new' (std::nothrow) _AppImpl('this'); }

private:
	class _AppImpl* __pAppImpl;
};

//
// _AppImpl
//
class _AppImpl : public IEventListener
{
public:
	'static' _AppImpl* GetInstance()
	{ return __pAppImpl; }

	App* _AppImpl::GetAppInstance(void)
	{ return __pApp; }

	result Construct(const Tizen::Base::Collection::IList* pArgs);
	result Execute(_IAppImpl* pIAppImpl);
	{
		pAppImpl->__pIAppImpl = pIAppImpl;

		app_event_callback_s state_handler;

		state_handler.create = &OnCreate;
		state_handler.service = &OnService;
		state_handler.terminate = &OnTerminate;
		state_handler.pause = &OnPause;
		state_handler.resume = &OnResume;
		state_handler.device_orientation = NULL;

		state_handler.low_memory = &OnLowMemory;
		state_handler.low_battery = NULL;
		state_handler.language_changed = &OnLanguageChanged;
		state_handler.region_format_changed = &OnRegionFormatChanged;

		// see how to pass data from cpp to c and efl_main should copy since it is local
		// 
		eflResult = app_efl_main(&argc, &pArgv, &state_handler, this);
	}

	// same name but static. what will happen?
	'static' void OnLowMemory(void* user_data);

private:

	_AppImpl::_AppImpl(App* pApp)
		: ...
		, __pApp(pApp)
		, __pIAppImpl(null)
	{ __pAppImpl = this; }

	virtual ~_AppImpl(void)
	{ __pAppImpl = null; }

	'static' _AppImpl* __pAppImpl;

	App* __pApp;
	_IAppImpl* __pIAppImpl;

   // [KT] otherwise, compile errer when App creates Impl
	friend class App;
};

//
// ServiceApp(Service) since used typedef ServiceApp Service
//
class ServiceApp : public Tizen::App::App
{
public:
	virtual ~ServiceApp(void)
	{ delete __pServiceAppImpl; }

	'static' ServiceApp* GetInstance(void)
	{
		_ServiceAppImpl* pServiceAppImpl = _ServiceAppImpl::GetInstance();
		if (pServiceAppImpl == null)
		{
			return null;
		}

		return pServiceAppImpl->GetServiceAppInstance();
	}

	'static' result Execute(ServiceAppInstanceFactory pServiceAppFactory, 
		const Tizen::Base::Collection::IList* pArguments);
	{
		result r = E_SUCCESS;

		ServiceApp* pServiceApp = null;
		_AppImpl* pAppImpl = null;

		// call AppService::CreateInstance. create <AppService> instance
		// use pServiceApp only when exception happens to delete. Here done all creations of objects. 
		pServiceApp = pServiceAppFactory();

		// free to use all instances
		pAppImpl = _AppImpl::GetInstance();

		_ServiceAppImpl* 'pServiceAppImpl' = _ServiceAppImpl::GetInstance();

		// add it as event listner and set app state to initializing
		r = pAppImpl->Construct(pArguments);

		// derive-to-base conversion as _ServiceAppImpl to _IAppImpl
		// pass cpp Onxx funcs to c efl and run app_efl_main
		r = pAppImpl->Execute(pServiceAppImpl); 
	}

protected:
	ServiceApp(void)
	{ __pServiceAppImpl = 'new' (std::nothrow) _ServiceAppImpl('this'); }

private:
	ServiceApp(const ServiceApp& rhs);
	ServiceApp& operator =(const ServiceApp& rhs);

	class _ServiceAppImpl* __pServiceAppImpl;
}

//
// _ServiceAppImpl
//
class _ServiceAppImpl
	: public Tizen::Base::Object
	, public Tizen::App::_IAppImpl
	, public Tizen::Base::Runtime::ITimerEventListener
   , virtual public Tizen::Base::Runtime::IEventListener
{
public:
	static _ServiceAppImpl* GetInstance();
	{ return __pServiceAppImpl; }

private:
	_ServiceAppImpl(ServiceApp* pServiceApp)
	: __pAppImpl(_AppImpl::GetInstance())
	, __pServiceApp(pServiceApp)
	, __pAppTerminatingInternalEventListener(null)
	, __pLifeDurationTimer(null)
	, __lifeDuration(0)
	, __pauseLifeDurationTimer(false)
	{
		__pServiceAppImpl = this;
	}

	ServiceApp*
	_ServiceAppImpl::GetServiceAppInstance(void)
	{
		return __pServiceApp;
	}

	virtual ~_ServiceAppImpl(void);

	static _ServiceAppImpl* __pServiceAppImpl;
	_AppImpl* __pAppImpl;
	ServiceApp* __pServiceApp;
	_IAppEventListener* __pAppTerminatingInternalEventListener;

	friend class ServiceApp;
};

//
// AppService. client class which is out of framework and namespace.
//
class AppService
	: public Tizen::App::ServiceApp
	, public Tizen::App::Package::IPackageInstallationEventListener
	, public Tizen::App::_IAppManagerEventListener
	, public Tizen::System::IBootEventListener
	, virtual public Tizen::Base::Runtime::IEventListener
{

public:
	// create self
	'static' Tizen::App::ServiceApp* CreateInstance(void)
	{
      // [KT] why static?
		'static' AppService* pAppService = new (std::nothrow) AppService();
		__pAppService = pAppService;

		// convert to base
		return pAppService;
	}

	static AppService* GetAppServiceInstance(void);
	AppService();
	virtual ~AppService();

	// OnXXX interfaces
	virtual bool OnAppInitializing(Tizen::App::AppRegistry& appRegistry);
	...
	virtual void OnLowMemory(void);

	static AppService* __pAppService;
};

OspMain() {

   result r = Tizen::App::Service::Execute(AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute(AppService::CreateInstance, &args); )
}

int main(int argc, char* pArgv[])
{
	int r = OspMain(argc, pArgv);
}


==============================================================================
*kt_dev_cpp_031*	wrapper

{example-one} {wrapper}
This is taken from *kt_dev_mecpp_007* to discuss it again: This case is that main is in c and is to
use some features written cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typedefs               {
										  int wraaper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Here wrapper is used to bridge between cpp and c:

int wrapper_func()
{
	ClassX* pclass = new Class( params );

	pclass->func();
	...
}


{example-two} {{add-reference-counting-to-existing-classes}} {wrapper} {forwarding}
How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


==============================================================================
*kt_dev_cpp_032*	case study: porting layer

{case-one}
The case which use singleton to have a porting layer for different platforms.

├── Interfaces
│   ├── Core
│   │   ├── IPluginRegister.h
│   │   └── SectionDataDefines.h
│   └── PortingLayer (has interface classes)
│       ├── IAPLAppLaunch.h
│       ├── IAPLAVControl.h
│       ├── ...
│       ├── IAPLMutex.h
│       ├── IAPLOSAbstraction.h
│       └── IApplitePortingLayer.h
├
├── PortingLayer (for platform A)
│   ├── Inc (headers for each class which implements each interface
│   │   ├── APLAVController.h
│   │   ├── APLDebug.h
│   │   ├── ...
│   │   ├── APLMutex.h
│   │   ├── APLOSAbstraction.h
│   │   └── ApplitePortingLayer.h
│   └── Src (sources for each class which implements eash interface, functionality)
│       ├── APLAVController.cpp
│       ├── APLDebug.cpp
│       ├── ...
│       └── ApplitePortingLayer.cpp (this is the gate class)


User                 CApplitePortingLayer : publuc IApplitePortingLayer
getInstace()         - get functions to get each interface pointer
Ins->getInterface(); - pointer members for each interface

                     CInterfaceA : public IInterfaceA             CInterfaceB ...
                     - *.h, *.cpp
                     - actual platform specific implementation


class CApplitePortingLayer : public IApplitePortingLayer
{

private:
	///default constructor
	CApplitePortingLayer(){};

public:
	uses singleton
	has all getXXX funcs for each functionality which returns member pointer for each.
	ctor creates all interface classes and set member pointers.

	///This function creates the porting layer interfaces. factory-func
	static CApplitePortingLayer* Instance(CReceiverAppBase* receiver);
	{
		 if (m_singleton == NULL)
		 {
			  m_singleton = new CApplitePortingLayer(receiver);
		 }
		 return m_singleton;
	}

	///This function gets the porting layer interfaces if created.
	static CApplitePortingLayer* GetInstance();
	{
		return m_singleton;
	}
}

Creates all concrete classes which implments interfaces.

CApplitePortingLayer::CApplitePortingLayer(CReceiverAppBase* receiver)
:m_receiver(receiver)
{
	m_graphics =  new CAPLGraphics((IReceiverAppPorting*)receiver, receiver->GetViewIndex());
	m_debug = new CAPLDebug((PCTask*)receiver, receiver->GetTCTv());
	m_mediaManager = new CAPLMediaManager((IReceiverAppPorting*)receiver, receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);		m_OSAbstraction = new CAPLOSAbstraction((IReceiverAppPorting*)receiver, receiver->GetTCTv(), (PCTask*)receiver);
	m_persistentStorage = new CAPLPersistentStorage();
	m_sectionFilter = new CAPLSectionFilter(receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);
	m_serviceInformation = CAPLServiceInformation::Instance((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_systemProperties = new CAPLSystemProperties((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_security = new CAPLSecurity();
	m_serial = new CAPLSerial();
	m_typeface = CAPLTypeface::getInstance();
	m_appLaunch = new CAPLAppLaunch((IReceiverAppPorting*)receiver);

    //initialise curl here, needed for both network and X509 operations
    CAPLCurl::InitCurl();
}

The good thing is that make CApplitePortingLayer singleton and manage other interfaces via it rather
than making every interface a singleton class.

This approach means that each concrete implementation calss, Cxx, implements interfaces and users
will use it directly. If the client is CPP file, that's fine and each Cxx can have typedefs, enums
and so on but if C file then do not work. For C files, each Cxx class provide C function and there
should be a way to share typedefs between CPP and C files. So should be a single header which has
common typedefs for C and CPP land.

Also can use that make all interface concrete class to have private interfaces and make a friend
between CApplitePortingLayer and otheres. That makes only CApplitePortingLayer can create and use
those.

{case-two}
├── OAL (OS AL)
│   ├── Inc
│   │   ├── ...h
│   │   └── ...h
│   └── Src 
│       ├── LINUX (this is folder which has platform implementation)
│       ├── WINDOWS
│       ├── VXWORS
│       ├── ...


# ============================================================================
#{

==============================================================================
*kt_dev_stl_000*	useful links

# stl
http://www.sgi.com/tech/stl/ 

{stl-design-rationale}

The idea behind the STL is to beat the combinatorial explosion of containers and functions that
implement the same data structures and algorithms without forcing all program structures to be
objects that are all in the same hierarchy. As long as a type has the needed properties, it works
with STL containers or algorithms, no matter what class hierarchies it is or isn't part of.

STL provides a collection of such things that are recognized as both useful and reasonable design.
The picky could point out std::string as a counter-example to good design, here. 


==============================================================================
*kt_dev_stl_001*	containers

{trade-offs}

Think different performance trade-offs in {insert/delete} and {random-access}.

vector      : random-access, fast insert/delete at the back, contig. mem
string      : random-access, fast insert/delete at the back, contig. mem

ESTL09: string, vector and deque has {contiguous-memory} Hence, insert/delete in the middle can be
expensive since have to move elements.

list        : double llist, bi-directional, fast insert/delete at any point
forward list: single llist, forward, support push_front only. [KT] See push_front

But don't support random access and can also have memory overhead.

deque       : double-ended q, random-access, fast insert/delete at front/back	

moves elements other than front/back {QQ} what is it?

array       : C++11. fixed size. possible to copy and assign.

note:
The forward_list don't support size() but others do. The size() has fast and constant time op which
is different from ESTL so seems it's true for C++11? Primus says C++ library has improved
significantly in recent.

The list and forward_list don't support <iterator-arith> and means this is for containers that
supports random access; string, vector, deque and array.

The random-access is different from contig. mem since there are containers which supports
random-access but not contig. mem.


==============================================================================
*kt_dev_stl_005*	assoc containers

These are node-based containers and use balanced tree as ESTL said. GCC is implemented using
red-black tree see {map-uses-rbtree} Provides bidirectional iterator. Three dimensions: set or map,
unique or multiple keys, and ordered or not.

ordered by key	: map, set, multiset/map
unordered		: unordered_set/map/multiset/multimap	

The unordered uses hash function since it is not ordered.

{operator}
The associative containers do not support the sequential container position-specific operators such
as push_front and push_back.


{use-typedef}
To simplify the declaration of containers, define a type alias:

using SD_multiset = unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*>;
SD_multiset bookstore(42, hasher, eqOp);

This is not supported in GCC 4.6 and use typedef instead.

typedef unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*> SD_multiset;


{key-value-pair} 
Thing to remember is the value_type is pair<const key_type, mapped_type> so implies key cannot be
changed. This affects the use with algorithms because key is const, only be used with algo that is
read-only and the use is limited to search but assoc is better in searching so little use of map
with algo. In practice, assoc can be used as a source or dest in algo.

map<string, int>::value_type v3;		// pair< const string, int>
map<string, int>::key_type v4;		// string
map<string, int>::mapped_type v5;	// int

See how return pair object explicitly and implicitly as a temp object. Here back() returns reference
to the last element.

pair<string, int>
process( vector< string > v )
{
	if( !v.empty())
		return {v.back(), v.back().size() };
	else
		return pair<string, int>();
}

The pair is defined in #include < utility > and the default pair ctor do value inits. see *kt_dev_cpp_009*

To make a new pair,
make_pair( v.back(), v.back().size() );

<key-type-requirement>
For ordered map, to compare the key, use '<' op of element so if use own type, must provide
comparison function and this is a part of type defintion. Rightly, map is ordered on key but not
mapped type. The example shows that use of key and comparison type which is func pointer type:

bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{ return lhs.isbn() < rhs.isbn(); }
 
// to initialise bookstore with func pointer as the ctor arg:
multiset< Sales_data, decltype( compareIsbn )* > bootstore(compareIsbn);

For unordered, use '==' op and hash func.


{subscript}

<in-map>
See {string-subscript}. When use [], index should be [in-range]. For fetching, only works for map
but not multimaps since there are multiple matches. Unlike other containers, [] op on map returns
mapped_type but dereferencing of iterator returns value_type. 

The [] <DOSE-ADD> element only for a map if there is no key already but can be costly since:

word_count[word] = 1; 

happens 3 setps but 3) could be extra

1) serch key and it is not found
2) insert element using temp pair{ word, 0 }. value-init
3) assign it with 1

See *kt_dev_stl_005* When index is out-of-range, <undefined-result> and to be safe, use c.at[index],
since can get a exception.

string word;
map<string, size_t> word_count;

while( cin >> word )
	++word_count[word];

for( const auto &w : word_count )
	cout << w.first << " occurs" << w.second << ((w.second>1) ? "times" : " time") << endl;

<in-set>
[] is only for containers such as sting, vector, deque, and array and map which suppors
<random-access>. NOT for set becuase set has only key. 


{multi-vs-single}
The ivec has two copies of 10 elements.

cout << ivec.size() << endl;	// 20
cout << iset.size() << endl;	// 10. no effects
cout << mset.size() << endl;	// 20

{Q} use case of multiset?


{insert-and-erase}
set.insert( ivec.begin(), ivec.end() );
set.insert( { 1, 2, 3, 4, 5} );

Should remember that the element type is pair when insert into a map.

map.insert( { word, 1} );								// C++11, brace-init
map.insert( make_pair(word, 1) );
map.insert( pair<string, size_t>(word, 1) );

map<string, size_t> word_count;
string word;

word_count.erase( removal_word );

// remove all with k(key) and returns size_t for the num of elements removed. For multiple, return
// number deleted and for single 1 or 0. 
c.erase(k)			
c.erase(iter)     // remove element by iter and return [after] iter
c.erase(b, e)     // remove range [b, e) and return e


{insert-return-pair}
insert() return pair{iter, bool} to indicate whether insertion happened so can use to count the
repeated key. This is for map and set. For multi containers, returns iterator to newly added element
since allows multiple keys and always inserts.

The previous:

map<string, size_t> word_count;
string word;

while( cin >> word )
	 ++word_count[word];

The way to use insert:

map<string, size_t> word_count;
string word;

while( cin >> word ) {
	 auto ret = word_count.insert( {word, 1} );

	 // word was already in word_count then second is false. ret.first is an value_type, {string,
	 // size_t}
	 if( !ret.second )
		  ++ret.first->second;
}


{find}

<in-set>

The set has only keys. key is const so iter is const. See that if not found, then return off-the-end
iterator.

set< string > exclude = { "The", "But", "And", "the" };

// count only word that are not in exclude
if( exclude.find(word) == exclude.end() )
	 ++word_count[word];

set< int> iset = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
iset.find(1);     // return iterator that refers to '1'
iset.count(1);		// return the number of elements. 1.

For containers with single key, find and count do the same but for containers with multiple key,
count has to do more work since still has to count how many elements have the same key. So if
don't need the count, it's best to use find.

<in-map>

For map, *iter is a reference of value_type, pair{key, ele} and it's the return from find().


<find-in-multi> {map-uses-rbtree}
There are three ways:

// <one>
// the way using count and the fact that. multiple elements of a given key will be 'adjacent' within
// the container. {ref-CPR} Primer p487.

// when misuse brace-init, got gcc crash, gcc 4.6 and errors: See _Rb_tree in errors

multimap< string, string > authors;
authors.inset( {"Barth, John"}, "Sot-Weed Factor"});
authors.inset( {"Barth, John"}, "Lost in the Funhouse"});
...

use-mmap.cpp:12:57: error: expected ')' before '}' token
use-mmap.cpp:12:57: error: expected ';' before '}' token
use-mmap.cpp: At global scope:
use-mmap.cpp:12:58: error: expected unqualified-id before ')' token
use-mmap.cpp:13:2: error: 'authors' does not name a type
use-mmap.cpp:13:33: error: expected unqualified-id before ',' token
use-mmap.cpp:13:35: error: expected unqualified-id before string constant
use-mmap.cpp:13:47: error: expected declaration before '}' token
In file included from /usr/include/c++/4.6/map:60:0,
                 from use-mmap.cpp:3:
/usr/include/c++/4.6/bits/stl_tree.h: In member function 'std::_Rb_tree<_Key, _Val, _KeyOfValue,
	_Compare, _Alloc>::iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
	_Alloc>::_M_insert_equal_(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
			_Alloc>::const_iterator, _Arg&&) [with _Arg = const char&, _Key = std::basic_string<char>,
	_Val = std::pair<const std::basic_string<char>, std::basic_string<char> >, _KeyOfValue =
	std::_Select1st<std::pair<const std::basic_string<char>, std::basic_string<char> > >, _Compare =
	std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >, std::_Rb_tree<_Key, _Val, _KeyOfValue,
	_Compare, _Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,
	std::basic_string<char> > >, std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
	_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,
	std::basic_string<char> > >]': /usr/include/c++/4.6/bits/stl_tree.h:1477:4:   instantiated from
	'void std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal(_II, _II) [with
	_InputIterator = const char*, _Key = std::basic_string<char>, _Val = std::pair<const
	std::basic_string<char>, std::basic_string<char> >, _KeyOfValue = std::_Select1st<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >, _Compare =
	std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >]'
	/usr/include/c++/4.6/bits/stl_multimap.h:502:11:   instantiated from 'void std::multimap<_Key,
	_Tp, _Compare, _Alloc>::insert(_InputIterator, _InputIterator) [with _InputIterator = const
	char*, _Key = std::basic_string<char>, _Tp = std::basic_string<char>, _Compare =
	std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >]' use-mmap.cpp:11:51:   instantiated from
	here /usr/include/c++/4.6/bits/stl_tree.h:1406:4: error: no match for call to
	'(std::_Select1st<std::pair<const std::basic_string<char>, std::basic_string<char> > >) (const
			char&)' /usr/include/c++/4.6/bits/stl_function.h:486:12: note: candidates are:
	/usr/include/c++/4.6/bits/stl_function.h:490:7: note: typename _Pair::first_type&
	std::_Select1st<_Pair>::operator()(_Pair&) const [with _Pair = std::pair<const
	std::basic_string<char>, std::basic_string<char> >, typename _Pair::first_type = const
	std::basic_string<char>] /usr/include/c++/4.6/bits/stl_function.h:490:7: note:   no known
	conversion for argument 1 from 'const char' to 'std::pair<const std::basic_string<char>,
	std::basic_string<char> >&' /usr/include/c++/4.6/bits/stl_function.h:494:7: note: const typename
	_Pair::first_type& std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair =
	std::pair<const std::basic_string<char>, std::basic_string<char> >, typename _Pair::first_type =
	const std::basic_string<char>] /usr/include/c++/4.6/bits/stl_function.h:494:7: note:   no known
	conversion for argument 1 from 'const char' to 'const std::pair<const std::basic_string<char>,
	std::basic_string<char> >&'

/usr/include/c++/4.6/bits/stl_tree.h:1406: confused by earlier errors, bailing out
Preprocessed source stored into /tmp/cceMitsA.out file, please attach this to your bugreport.
kit@kit-vb:~/work$ 


// examples run under gcc 4.6
//
#include < iostream>
#include < string>
#include < map>

int main()
{
	std::string str = "total";

	std::multimap< std::string, std::string > authors;
	authors.insert( {"Kit, Park", "How to get through"} );
	authors.insert( {"Barth, John", "Sot-Weed Factor"} );
	authors.insert( {"Barth, John", "Lost in the Funhouse"});
	authors.insert( {"Andy, Steve", "Enterprise"});
	authors.insert( {"Barth, John", "A way to success"});

	std::string search_item("Barth, John"); 						// author to look for

	auto entries = authors.count( search_item ); // num of elements
	std::cout << "entries: " << entries << std::endl;

	auto iter = authors.find( search_item );		// first entry

	while( entries ) {
	// print each title
		std::cout << "count: " << entries << ", title: " << iter->second << std::endl;
		 ++iter;
		 --entries;
	}

	iter = authors.begin();
	for( iter; iter != authors.end(); ++iter )
		std::cout << "title: " << iter->second << std::endl;
}


kit@kit-vb:~/work$ ./a.out 
entries: 3
count: 3, title: Sot-Weed Factor
count: 2, title: Lost in the Funhouse
count: 1, title: A way to success

title: Enterprise
title: Sot-Weed Factor
title: Lost in the Funhouse
title: A way to success
title: How to get through


See that sorted by key but was ordered as inserted in the same key. So the first is the one inserted
first.

// <two> use lower and upper_bound which return each iter of begin and end. If it is not in the map
// then both will return the same iterator which refer to the point at which the key can be
// inserted.

for(auto beg = authors.lower_bound( search_item ),
	      end = authors.upper_bound( search_item );
			beg != end;
			++beg )
	 cout << beg->second << endl;

// <three> use equal_range which is most direct and return pair of iter in [range] {first,
// off-the-end}. Like above, if not found return the same.

for( auto pos = authors.equal_range( search_item ); pos.first != pos.second; ++pos.first)
	 cout << pos.first->second << endl;


{brace-init}

#include <iostream>
#include <string>
#include <map>

int main()
{
	std::map< std::string, std::string > authors = {{"brabo", "yanky"}, { "alpha", "zulu"}, {"charle", "xiera"}};

	std::cout << "===========================" << std::endl;

	auto iter = authors.begin();
	for( iter; iter != authors.end(); ++iter )
		std::cout << "key: " << iter->first << ", title: " << iter->second << std::endl;
}


{examples} {shared-ptr-as-a-key}

Multiset. mutiple same key from {ref-CPR} p631

One of the ironies of OOP in C++ is that we cannot use objects directly to support it. Instead must
use pointers and references. So often define auxiliary class to help manage complexity that pointer
use impose.

Here Quote class hierarchy represents book purchase or transaction which supports several discount
strategy and each book has isbn number. The same book has the same isbn. The basket is not in the
hierarchy and has multiset to manage multiple purchase for the same book or isbn number. The
multiset has shared_ptr key but equality is decided by compare function. Therefore, the key is the
isbn but not shared_ptr itself. 

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};

double print_total( ostream &os, const Quote &item, size_t n )
{
  double ret = item.net_price(n);
  os << "ISBN: " << item.isbn()   // calls Quote::isbn
    << " # sold: " << n << " total due: " << ret << endl;
  return ret;
}

class Basket {
	public:
		  void add_item( const std::shared_ptr< Quote >& sale)	// see reference. 
			 { items.insert(sale); }

      double total_receipt( std::ostream& ) const;

	private:
		 static bool compare( const std::shared_ptr< Quote >& lhs,
									 const std::shared_ptr< Quote >& rhs )
			 { return lhs->isbn() < rhs->isbn(); }

		 // shared_ptr is a key
		 multiset< std::shared_ptr< Quote >, decltype(compare)*> items{ compare };
};

double Basket::total_receipt( ostream& os ) const 
{
  double sum = 0.0;

  // skip over all the elements that match the current key by calling upper_bound()
  //
  for( auto iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound( *iter ) ) 
  {
    // double print_total(ostream& os, const Quote& item, size_t n);
    // *iter is a key which is shared_ptr and **iter is a object that shared_ptr points
    sum += print_total( os, **iter, items.count( *iter ));
  }

  os << "Total sale: " << sum << endl;
  return sum;
}

User will:

Basket bsk;
bsk.add_item( make_shared< Quote >("123", 45) );
bsk.add_item( make_shared< Bulk_quote >("123", 45, 3, .15) );


{simulating-virtual-copy}
The basket class user still have to deal with dynamic memory and that means have to call
make_shared. So want to have add_item member like: 

<TODO> Here it is only about copy and in p633 in ref-CPR has move version as well.

void add_item( const Quote &sale );

Then this add_item member will use new in it but know only Quote type. If use this for derived
objects then sliced-down will happen. How to solve?

class Quote {
  public:
    // need to study further for reference qualifiers. p546.
    virtual Quote* clone() const & {return new Quote(*this); }
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote* clone() const & { return new Bulk_quote(*this); }
};

class Basket {
  public:
    void add_item( const Quote& sale )
    { items.insert( std::shard_ptr<Quote>( sale.clone() )); }
};


==============================================================================
*kt_dev_stl_002*	vector

{init-from-array}

int intarr[] = { 0, 1, ... };
vector< int > ivec( begin(intarr), end(intarr) );


{init-from-list} {brace-init}

List init. Not for VC as it's C++11 but g++ (GCC) 4.4.5 does.

vector< string > articles = { "a", "an", "the" };
vector< string > articles{ "a", "an", "the" };


{copy-assign}

<1>

vector< int > vi1(3, 5);	     # vi1(size, val)
vector< int > vi2(6, 2);

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:6

vi2 = vi1;                      # note:

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:3

<2>

Applies to the whole container.

vector< int> ivec = { 1, 2, 3, 4, 5, 6 };
ivec.size();	// 7

ivec = { 1, 2, 5 };
ivec.size(); 	// 3


{assign}

vector< string > v;
v = {"a", "the", "an"};

{subscript}

Does it add an element? NO. The result is [seg-fault] [core-dumped]

int absdistinct_vec(int A[], int n)
{
	if(n==0)
		return -1;
	
	vector<int> ivec;
	int count = 0;

	for( int i = 0; i < n; ++i )
		ivec[i] = abs(*(A+i)); 
}


{vector-operator}

v1 == v2
v1 != v2

{use-example}

// 01

vector< string > words;

for(const auto &str : words)
	 cout << str << " ";
cout << endl;


// 02

auto it = words.begin();

while( it != words.end() )
{
  cout << *it << " ";                # no str update??
  it++;
}

// 03

vector< unsigned > scores(11, 0);

++scores[grade/10];
scores[grade/10]=ix;


==============================================================================
*kt_dev_stl_003*	list

{list-erase}
Thing to show here is that the header from begin() gets updated when use erase(start, end) to trim
unused entries.

<code-example>

#include <iostream>
#include <list>

typedef std::list<double> LIST;

int main()
{
  int n;
  double item;
  LIST dlist; 
  LIST::iterator iHead;

  std::cout << "type in an integer n(loop count) followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    dlist.push_back(item);
  }

  std::cout << "input is done and you have entered " << dlist.size() << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }

  iHead = dlist.begin(); iHead++; iHead++;
  std::cout << "items: " << *iHead << std::endl; 
  dlist.erase( dlist.begin(), iHead );

  std::cout << "input is done and you have entered " << dlist.size() << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }
}


kit@kit-vb:~/work$ ./a.out 
type in an integer n(loop count) followed by n decimal numbers.
5
10
20
30
40
50
input is done and you have entered 5 items
items: 10
items: 20
items: 30
items: 40
items: 50
items: 30
input is done and you have entered 3 items
items: 30
items: 40
items: 50
kit@kit-vb:~/work$ 


==============================================================================
*kt_dev_stl_004*	adaptors

stack, queue, priority_queue

{stack-stl}

The {ref-001} says that STL stack uses deque by default and can change by giving it second
paramenter.

template <class T, class Container = deque< T> > class stack;


#include < iostream>
#include < stack>

int main()
{
	int n;
	double item;
	std::stack< double> numbers;

	std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

	std::cin >> n;

	for(int i=0; i<n; i++)
	{
		std::cin >> item;
		numbers.push(item);
	}

	std::cout << "input is done and you have entered." << std::endl;

	while( !numbers.empty() )
	{
		// access next element. top() returns a reference to the top element in a stack. 
		std::cout << numbers.top() << " : ";
		numbers.pop(); // void pop()
	}

	std::cout << std::endl;
}

kit@kit-vb:~/work$ ./usestack
type in an integer n followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 


{queue-stl}

Like stack, STL queue uses deque by default and can change by giving it second paramenter. Also see
that it has similar interface as stack:

template <class T, class Container = deque< T> > class queue;

#include < iostream>
#include < queue>

int main()
{
	int n;
	double item;
	std::queue< double> numbers;

	// n to specify the number of items and type iterms after
	std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

	std::cin >> n;

	for(int i=0; i<n; i++)
	{
		std::cin >> item;
		numbers.push(item);
	}

	std::cout << "input is done and you have entered." << std::endl;

	while( !numbers.empty() )
	{
		// access next element. front() returns a reference to the first element in a queue. 
		std::cout << numbers.front() << " : ";
		numbers.pop();
	}

	std::cout << std::endl;
}

kit@kit-vb:~/work$ ./usequeue
type in an integer n(loop count) followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 


==============================================================================
*kt_dev_stl_006*	iterator

Iterator is a generalization of pointers. Pointers themselves are iterators. Each T has its own
iterator; each STL container defines its own iterators. so should use T's member func to get a
iterator.

{iterator-notation}

[begin, end) notation and <off-the-end> iterator which is one past the last. this notation applies
to subrange as well in use of algorithm.
 

{iterator-style}

This is iterator style compared to C style using for loop:

while(begin != end) {
	 *begin  = val;
	 ++begin;
}


template< class T>
T* find( T* begin, T* end, const T& value )
{
	 while( begin != end && *begin != value ) ++begin;
	 return begin;
}


{for-vs-while-style}

map< string, T > mapT::iterator iter = mapT.begin();

while( iter != mapT.end() )
{
	cout << *iter << ...; // use iter
	++iter;
}

for( ; iter != mapT.end(); ++iter )
{
	cout << *iter << ...; // use iter
}

For this simple iteration, for( ; itr != HighLows.end() ; ++itr) is useful. You would never need to
worry about not increasing the iterator with it.


{insert-method}

The insert() insert value at place denoted by iter and return the same. In other words, shift items
from iter position and add an item. 

insert(iter, val);

// example

#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
	std::vector<int> veci = {1,2,3,4};
	std::vector<int>::iterator it;

	it = find(veci.begin(), veci.end(), 2);
	if( it != veci.end())
	{
		it = veci.insert( it, 7 );
		it = veci.insert( it, 6 );
		it = veci.insert( it, 5 );
	}

	it = veci.begin();
	while( it != veci.end() )
	{
		std::cout << *it << ":";
		it++;
	}
	std::cout << std::endl;
}

Output:
1:5:6:7:2:3:4:

// example

vec< int > veci;
veci.push_back(1); .. to (3); // [1,2,3,E)
veci.insert( veci.end(), 4 ); // is it [1,2,3,4] or [1,2,4] ?
it's [1,2,3,4]


// example

list< string > lst;
auto iter = lst.begin();

while( cin >> word )
	 iter = lst.insert( iter, word ); or lst.push_front(word);

[three, two, one]
be               end

while(...)
	 lst.insert(iter, word);

[one, two, three]                       # no iter update. see difference in order

Since iter remains the same(off-the-end) in list and works fine. However, this approach will creates
<core-dump> in case of vector because addition and deletion will invalidate iterator of vector.


{invalidated-iterators} {estl-009}

The following code creates <core-dump> for the same reason as above; invalidated iterators.

void removeOddNumbers( vector< int > numbers )
{
	 for( vector< int >::iterator it = numbers.begin(); it != numbers.end(); ++it )
	 {
		  if( isOdd( *it ))
				numbers.erase(it);
	 }
}

From ESTL09. See that here is about assoc-container but this applies only for containers which uses
contig. mem.

AssocContainer< int > ac;

for( AssocContainer< int >::iterator iter = ac.begin(); iter != ac.end(); ++iter ) {
	 if( badValue(*iter) )
		  ac.erase(iter);
}


// fix-one

for( AssocContainer< int >::iterator iter = ac.begin(); iter != ac.end(); /* [none] */ ) {
	 if( badValue(*iter) )
		  ac.erase(iter++);
}

Using post-inc, increase iter before being invalidated and use the previous.


// fix-two {recommanded}

for( SeqContainer< int >::iterator iter = ac.begin(); iter != ac.end(); /* <none> */ ) {
	 if( badValue(*iter) )
		  iter = ac.erase(iter);
}

For vector, string and deque. In ESTL, <fix-two> is only for seq-containers because erase() returns
void for assoc-containers. But from C++11, erase() returns after iterator for both container type
and can use it both type. Note: From C++11? Which gcc version?

From Primus p353.

o For list, forward-list, iterator remains valid after add/remove
o For vector, string, iterator becomes invalid after add/remove and realloc. (do not know when
realloc happens and think it always becomes invalid)

{Q} how about assoc-containers?

Therefore, two key things to do for each loop:

o call end() but not use the cached. this is the case for range-for
o update iterator


{range-for-caches-end}

for( auto &r : vec )
	 r *= 2;

becomes

for( auto beg = vec.begin(), end = vec.end(); beg != end; ++beg )
	 auto &r = *beg;
	 r *= 2;
}


==============================================================================
*kt_dev_stl_007*	iterator: inserter

These are additional iterators and actually iterator adaptors: insert, stream, reverse, and move iterators

{insert-iterator}

The insert iterator calls a container operation to add and it means that must use front_inserter
only if the container has push_front and use back_inserter only if it has push_back. These are
back_inserter, front_inserter, inserter which bind iterator to container operations.

Why are these useful? There is no need to increase or decrease iter but still need to think about
underlying container.

// example-one

*it = val;	// it from inserter

behave as the following and hence it still denotes the same element as before.

it = c.insert(it, val); ++it;

// example-two

#include < iterator>

vector< int > vec;
auto it = back_inserter(vec);
*it = 42;                                   // calls puch_back()
*it = 48;

[42, 48, E)

// example-three {algo-copy} 
// See the difference between inserter and front_inserter. 

list< int> lst = { 1, 2, 3, 4 }, lst2, lst3;

// OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result);
// 4,3,2,1
copy( lst.cbegin(), lst.cend(), front_inserter(lst2) );

// 1,2,3,4
copy( lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()) );


{stream-iterator}

Treat stream as a sequence of elements of a specified type that should have input/output op
defined(>>/<<) and bind iterator to a stream. In other words, see a stream as a sequence of {user
provided speficified type}. In summary, it makes us to use stream with algorithms.

// example which read the stdin into a vector

string word;
while( cin >> word )
	 // cout << word << endl;
	 vec.push_back(word);

or here postfix advances the stream by reading the next value but returns old value

istream_iterator< string > in_iter(cin), eof;
while( in_iter != eof )
	 vec.push_back(*in_iter++);

or

istream_iterator< string> in_iter(cin), eof;
vector< string> vec(in_iter, eof);                         // ctor use iter range


// for an algo use:

// template <class InputIterator, class T>
//   T accumulate (InputIterator first, InputIterator last, T init)

#include < numeric>

istream_iterator< int > in_iter(cin), eof;
cout << std::accumulate(in_iter, eof, 0) << endl;


// example for ostream. seems [useful] 

// template <class T, class charT=char, class traits=char_traits< charT>>
//  class ostream_iterator;
//
// ostream_iterator (ostream_type& s, const char_type* delimiter);

std::ostream_iterator< int> out_iter( std::cout, " " );
for( auto e : vec )
	 *out_iter++ = e;
cout << endl;

or

copy( vec.begin(), vec.end(), out_iter );
cout << endl;


// example for file

ifstream in("afile");
istream_iterator< string > str_it(in);


// how stream-iterator can make code neat

int main()
{
	Sales_item total;

	// read the first transaction
	if( std::cin >> total )
	{
		Sales_item trans;		// variable to hold the running sum

		while(std::cin >> trans )
		{
			// if we're still processing the same book, then update the running total
			if( total.isbn() == trans.isbn() )
				total += trans;
			// print results for the previous book
			else
			{
				std::cout << total << std::endl;
				total = trans;
			}
		}
		// print the last transaction
		std::cout << total << std::endl;
	} 
	// no input and return failure
	else
	{
		std::cerr << "No data?" << std::endl;
		return -1;
	}

	return 0;
}


This can be re-written as:

istream_iterator< Sales_item> item_iter(cin), eof;
ostream_iterator< Sales_item> out_iter(cout, "\n");

Sales_item sum = *item_iter++;

while( item_iter != eof )
{
	if( item_iter->isbn() == sum.isbn() )
		sum += *item_iter++;
	else
	{
		out_iter = sum;
		sum = *item_iter++;
	}
}

out_iter = sum;


{reverse-iterator}

For container except forward_list and stream iterator, supports reverse iterator; rbegin()/crbegin()
and rend() since reverse iterator use ++ and -- operator.

See *kt_dev_quiz_004* and *kt_dev_quiz_005* for more use cases

<difference-in-range>
The difference between reverse and normal iterator. When we initialize or assign a reverse iterator
from a plain iterator, the resulting iterator does not refer to the same element as the original.

rcomma.base()   cend()
	|       |
 , L A S T
 |       |
 rcomma  crbegin()

[crbegin(), rcomma ) which prints 'TSAL' and [rcomma.base(), cend() )


==============================================================================
*kt_dev_stl_008*	algorithm

Do not work directly on a container. Instead, they operate by traversing a range of elements bounded
by two iterators; operates in terms of iterators. container independent but element type dependent.
means that do not use container's operations (don't add/remove items but write/move items) but use
operations on element such as '==', '<', or '+'. 

{iterator-category}

input iter			: read only		single-pass		inc only
output iter			: write only	single-pass		inc only
forward iter		: r/w				multiple-pass	inc only
bidirectional iter: r/w				multiple-pass	inc/dec
random access iter: r/w				multiple-pass	full

On parameter patterns:

alg( beg, end, other args );
alg( beg, end, dest, other args );	// assumes dest is big enough as with sequence one
alg( beg, end, beg2, other args );	// assumes beg2 is big enough as with sequence one
alg( beg, end, beg2, end2, other args );

{assumptions}

There is architecture or the unifying principles that categorise 100+ algorithms: according to what
do on container or required arguments. Be careful since algorithms have assumtions: 

use right iter for a algo according to iter category since compilers will not complain.

<read-only> use single sequence(input range)

The third argument determines which addition operator is used and the type of return. Seems clever.

int sum = accumulate( vec.cbegin(), vec.cend(), 0 );
string sum = accumulate( vec.cbegin(), vec.cend(), string(""));

<read-only> use two sequences

This assumes that the second sequence is at least as big as the first.

equal( one.cbegin(), one.cend(), two.cbegin() );	// assumes two >= one


<write>

The destination is large enough to hold itmes being written.

fill(vec.begin(), vec.end(), 0);

This is fill_n( dest, size, value ); and assumes that vec is 10 size at least.

fill_n( vec.begin(), 10, 0 );	

vector< int > vec;
fill_n( vec.begin(), 10, 0 );	

This is an error and to make sure it works:

vector< int > vec;
auto it = back_inserter(vec); // *kt_dev_stl_009*
fill_n( vec.begin(), 10, 0 );	


{independent-between-sequences}

The element types need not be the exactly same as long as can use element operators or compatible
between them. This is also an example of copying version in algorithm.

replace( ilst.begin(), ilst.end(), 0, 42 );
// replace any element with 0 with 42

replace_copy( ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42 );
// to leave the original sequence unchanged. in this case, move list to vector.

// copy version
reverse( beg, end );
reverse_copy( beg, end, dest );

{if-version}

Algorithm that takes an element value typically have a second named version that takes a predicate
in place of the value. Compared to overloaded version.

// if version
find( beg, end, val);
find_if( beg, end, pred);

// overloaded version
unique( beg, end );
uniqie( beg, end, comp );

{container-specific}

The list and forward_list define several algorithms as memebers because can use generic ones with
list but at a cost in performance. These container spscific ones are merge, sort, unique, remove and
reserse. The member version should be used in preference to the generic for list and forward_list.

Also, a important difference between the list-specific and the generic is that the list version
change the underlying containers.


==============================================================================
*kt_dev_stl_009*	algorithm: sort, unique

template< class RandomIt>
void sort( RandomIt first, RandomIt last );
		
template< class RandomIt, class Compare>
void sort( RandomIt first, RandomIt last, Compare comp );

void elimDups( vector< string >& words )
{
	// sort by alphabet order since string element
	sort( words.begin(), words.end() );

	// re-order by moving adjacent element and return iter that duplicats
	// starts. [unique set, not unique set, end)
	auto end_unique = unique( words.begin(), words.end() );

	// actually use container operation to delete
	words.erase( end_unique, words.end() );
}


From *kt_dev_quiz_008*

bool absLessThan(int a, int b)
{
	return abs(a) < abs(b);
}

bool absEqual(int a, int b)
{
	return abs(a) == abs(b);
}

int absDistinct(int A[], int N)
{
	if(N==0)
		return -1;

	vector<int> ivec;
	int count = 0;

	for(int i = 0; i < N; ++i)
		ivec.push_back( *(A+i) );

	// sort do not change a container
	// before : -5: -3: -1: 0:  3: 6
	// after  :  0: -1: -3: 3: -5: 6

	sort( ivec.begin(), ivec.end(), absLessThan );
	auto it_end_unique = unique( ivec.begin(), ivec.end(), absEqual );

	auto it_begin = ivec.begin();

	while( it_begin != it_end_unique )
	{
		++it_begin;
		++count;
	}

	return count;
}


{stl-find}

If there is a match, returns an iterator to the first element and if not, return end iterator.

auto result = find( vec.cbegin(), vec.cend(), val);

int ia[] = { 27, 210, 12, 47, 109, 83 };
int* result = find( begin(ia), end(ia), val);

{sort-reverse}

sort( vec.begin(), vec.end() );

// sort in reverse; puts the smallest elements at the end of vec
sort( vec.rbegin(), vec.rend());


==============================================================================
*kt_dev_stl_010*	algorithm: predicate and lambda

This is {callables} to change a default operator of algorithms. For example,

1) sort() uses "<" on element to sort but if want to use different order
2) use user defined type that don't support "<"

Should use predicate to provide a way to compare. [ONLY] supports unary and binary predicate.

<01>

bool isShorter( const string& s1, const string& s2 )
{
	 return s1.size() < s2.size();
}

// sort by length
sort( words.begin(), words.end(), isShorter );


<02> stable_sort

sort by length and also want to keep the order among the 'equal' elements.

// sort by alphabet and remove dups
elimDups(words);

// sort by length but retain original order among equals that has the same size.
stable_sort( words.begin(), words.end(), isShorter );


{lambda}

The predicate only supports unary and binary which means must have one or two parameters. How to
support more arguments?


==============================================================================
*kt_dev_stl_011*	containers: restrictions on element type

There is nearly no restrictions on which type can be put in a container but some restrictions on
which operations can perform for element type. so there are some restriction on element type to use
in container.


==============================================================================
*kt_dev_stl_012*	containers: copy init

When copy init from other container, container and element type must be indentical. but use
iterators, it's okay if element is convertable. this is the same for other container operations.
e.g. c.assign( is, ie )


vector<const char*> articles = { "a", "an", "the" };
forward_list< string> words ( articles.begin(), articles.end() );


==============================================================================
*kt_dev_stl_013*	algorithm: copy

int a1[] = { 0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];

auto ret = copy( begin(a1), end(a1), a2 );
// ret points just past the last element copied into a2


==============================================================================
*kt_dev_stl_014*	<empty>



==============================================================================
*kt_dev_stl_015*	string: stringstream and io stream

{string-is-typedef}
The string is:
typedef std::basic_string< char > string;

Interestingly, do not get an error of multiple tydedef when try this even though expects error since
it is already typedefed in string header.

#include < iostream>
#include < string>

typedef std::basic_string<char> string;

typedef int EntryType;
typedef int EntryType;

Turned out that there is no multiple typedef errors as shown as EntryType example.


{string-subscript} <do-not-include-null>
string s("string");

This s does not include NULL and size() returns 6 not 7.

s[n]	

returns a ref to the char at pos n in s. pos starts from 0 to size()-1.

For negavite subscript, see {array-subscript}

How to ensure that subscript is in range? A good way is to aviod subscripting altogether by using a
range for whenever possible. However not all compiler supports and see {range-for}


{string-and-c-str}
const CharT* c_str() const;

This means it returns a poiner to const object.

Returns a pointer to a null-terminated character array with data equivalent to those stored in the
string. The pointer is such that the range [c_str(); c_str() + size()] is valid and the values in it
correspond to the values stored in the string with an additional null character after the last
position. 


{string-and-algorithm}
string one;
sort(one.begin(), one.end());


{stringstream}
#include < sstream>

Works as if the string is an IO stream. File parsing example

input file:
	lee 6095 20121212 800909094848

struct PersonInfo {
	 string name;
	 vector< string> phones;
};

ifstream input(argv[1]);
vector< PersonInfo> people;

string line;

// std::getline(std::basic_istrem, std::basic_string); not include a new line
while( getline(input, line) ) 	
{
	 PersonInfo info;
	 istringstream record(line);

	 record >> info.name;

	 while( record >> word )
		  info.phones.push_back(word);

	 people.push_back(info);
}


{operator==}
tquery.cpp:128: error: no match for 'operator==' in 's == 'q''

shoule be:

string s;
if( !(cin >> s) || s == "q" ) break;


{inefficient-concatnation}
In JAVA, the following shows inefficient +. Assume that strings are all the same length, x and there
are n strings. Just think about +. For 1st iteration, x copies char by char. Next iteration, 2x and
so on. This reduces to O(xn^2).

String sentence = "";

for( String w : words )
{
	 sentence = sentence + w;
}

This add string to sentence and copy the temp result to sentence for each loop. Should be written

StringBuffer
sentence = "";

sentence.append(w);

{Q} How about C++ string? This should be the same for C++ string class.


==============================================================================
*kt_dev_stl_016*	io stream

{io-stream}

// ifstream, istream_iterator, and freopen

The ifstream class binds file to stream and then need a call to read data from stream such as
getline(). Further, istream_iterator {stream-iterator} add iterator features to a stream. However
freopen from iostream.h binds file to stdin and can use cin >> to read data.


// error

from above example, if omit header include, error from gcc is:

ifstream input(argv[1]);

while( getline(input, line) )


error: cannot convert 'std::basic_ifstream<char, std::char_traits<char> >' to 'char**' for
argument '1' to '__ssize_t getline(char**, size_t*, FILE*)'

must have #include <fstream>

this suggest that it calls getline from <stdio.h> and <cstdio> for C++ maybe?


==============================================================================
*kt_dev_stl_017*	emplace_* member

c.emplace_back( "978-3403", 25, 15.99 );

c.push_back( Sales_data("978-3403", 25, 15.99) );	// use temp object

Here c means container and the emplace_* construct a object directly in a container. no copy.


==============================================================================
*kt_dev_stl_018*	smart pointer, RAII

{resource-acquisition-is-initialization} {resource-managing-class}

EC++13. Why RAII? When use dynamic resource, client is fully resposible for releasing it after use.
However, when exception happens, the usual path is interrupted and may cannot release it as
expected.

void f()
{
	 // createInvestment() is factory-func that returns a pointer to dyn created resource or derived
	 // class. client must delete it after use

	 Investment* pInv = createInvestment();

	 // [problem] code that throws an exception that is not caught inside f. may not reach to delete
	 // statement

	 delete pInv;
}

To solve this, use resource-managing-class and the fact that dtor is called automatically when
object is destroyed. Hence called RAII and solutions are: 

<try-block-approach>

void f()
{
	try {
	 Investment* pInv = createInvestment();
	}
	catch( ... ) {
		 delete pInv;
		 throw;           // propagate exception to caller of f. rethrow.
	}

	delete pInv;
}

This has duplicated clean-up code. How to improve this? 


<raii-auto-ptr-approach> unique_ptr

Approaches to implement RAII.

void f()
{
	 // createInvestment() is factory-func that returns a pointer to dyn created resource
	 // or derived class. client must delete it after use
	 >
	 std::auto_ptr< Investment > pInv( createInvestment() );
<
	 // code that throws an exception that is not caught inside f.

	 // NO need to concern about free resource regardless of how control leaves a block
	 // delete pInv;
}

Hence RAII; acquire and initialize a [resource-managing-class] in the same statement. In other
words, resource should be [encapsulated-in-a-object], resouce-managing-class, but raii do not exist
to encapsulate resource [but-to-prevent-leak]. 

However, auto_ptr is not the best way to manage all dyn resources since it's limitation on copying
to make sure there's only one ptr to object. So containers of auto_ptr aren't allowed since STL
requires normal copying, deep-copy.


<raii-shared-ptr-approach>

To return shared_ptr from a factory-func which is better way that supports normal copying. 

// use the fixed type, Foo that's the underlying object.
//
std::shared_ptr< Foo > factory(T arg)
{
	 return make_shared< Foo >(arg);
}

void use_factory(T arg)
{
	 shared_ptr< Foo > p = factory(arg);
	 // use p and deleted automatically.
}


{raii-for-resource-using-own-interface}

EC++14. There should be [own-raii-class] for resource that uses own interface to create and delete
it because cannot use delete operator on it as with generic case. 

<example-mutex-lock> {auto-lock}

void lock(Mutex* pm);		// int pthread_mutex_lock( pthread_mutex_t *mptr); 
void unlock(Mutex* pm);

class Lock {
	 public:
	 'explicit' Lock( Mutex* pm ) : mutexPtr(pm) 
	 { lock( mutexPtr ); }

	 ~Lock() { unlock( mutexPtr ); }

	 private:
	 Mutex* mutexPtr;
};


// client use

Mutex m;		// pthread_mutex_t m;
...
{
	 Lock ml(&m);
	 ...
}

This is a case example seen in the code:

static PCMutex* g_mhdebug_mutex;
#define AUTOLOCK() TCAutoLock lock(&g_mhdebug_mutex)

void func()
{ 
	AUTOLOCK();
	...
}


<example-window-handle>

MEC++09.

void displayInfo(const Information& info)
{
	 WINDOW_HANDLE w ( createWindow() );

	 ... display info in window w and exception can happen.

	 destoryWindow(w);
}


class WindowHandle {
	 public:
	 	WindowHandle( WINDOW_HANDLE handle ) : w(handle) {}
		~WindowHandle() { destoryWindow(w); }

      // [conversion-op]
		operator WINDOW_HANDLE() { return w; }

	 private:
	 	WINDOW_HANDLE w;

      // [preventing-copies]
		WindowHandle( const WindowHandle& );
		WindowHandle& operator=( const WindowHandle& );
};


void displayInfo(const Information& info)
{
	 WindowHandle w ( createWindow() );

	 ... display info in window w and exception can happen.
	 ... displayWindow(w); coversion-op runs to convert WindowHandle to WINDOW_HANDLE

	 // destoryWindow(w);
}


{raii-and-exception-in-dtor}

The raii is great but when use raii for own interface, it can raise exception in destructor. This
problem is described in {problem-of-exception-in-dtor}. 


{raii-and-copy-support}

OK but what should happen if a Lock object is copied? Generally RAII object is copied? Many
approaches depending on the type of resource.

<1> prohibit copying
Likely to be true for Lock. See {preventing-copies} in *kt_dev_cpp_004* So,

class Lock: private Uncopyable {
	 ...
};


<2> reference counting underlying resources
This is shared_ptr; {pointer-like} in *kt_dev_cpp_004* For this example, use 'deleter' to use unlock
instead.

class Lock {
	 public:
	 explicit Lock( Mutex* pm ) : mutexPtr(pm) 
	 { lock( mutexPtr ); }

	 ~Lock() { unlock( mutexPtr ); }

	 private:
	 Mutex* mutexPtr;
};

To:

class Lock {
	 public:
	 explicit Lock( Mutex* pm ) >
	 :mutexPtr( pm, unlock ) 
<	 {
		  lock( mutexPtr.get() );		// to get law pointer
	 }

	 private:
	 std::shared_ptr< Mutex > mutexPtr;
};

Set deleter using shared_ptr ctor in ctor init list. No dtor any longer. 

<3> copy the underlying resource
This is {value-like} in *kt_dev_cpp_004*

<4> transfer ownership of underlying resource
This is unique_ptr.


{shared-ptr}

#include <memory> and def init has a nullptr:

shared_ptr< T > plist;
shared_ptr<list<int >> plist;


{make-shared}

This will alloc and init T and return a shared_ptr< T>

shard_prt< string > p4 = make_shared< string>(10, '9');
auto p6 = make_shared<vector< sting>>();	// create empty vector< string>

This is recommeneded because do alloc and bind at the same time. By the way, it's possible to do
'alloc' and 'bind shared_ptr with ptr' later.


{when-use-reset-to-assign-new-pointer} {unique-and-reset}

Why not assignment instead of using reset? [KT] Think that = operator is to decrease a reference
counter of right and to do the opposite for left and cannot do it on new objects. To assign a new
pointer to a shared_ptr. Like assignment, reset updates reference count of left. If sp is the only
shared_ptr pointing at its object, reset frees sp's existing object. If q is passed, makes sp points
to q, otherwise makes sp null.

sp.reset(); or sp.reset(q);

shared_ptr< int> p (new int(42));
p = new int(1024);						// [error]
p.reset( new int(1024));


To check how many users are. Return bool on whether there is the only user of this sp.

sp.unique();

Often to check whether we are the only user before changing the underlying object:

if( !p.unique() )
	 p.reset( new string(*p) );		// we are not alone. allocate a new copy
*p += newValue;							// we are the only pointer, okay to change


{copy-shared-ptr}

auto p = make_shared< int>(42);

// p.use++
auto q(p);

// all prints 2
cout << "q: " << q.use_count() << ", p: " << p.use_count() << endl;

auto r = make_shared< int>(52);

// q.use++ and r.use--. destroies a object which r pointed. 
r = q;

// all prints 3
cout << "q: " << q.use_count() << ", p: " << p.use_count() << ", r: " << r.use_count() << endl;


{example}

class StrBlob {
	 public:

	 typedef std::vector<std::string>::size_type size_type;

	 StrBlob();
	 StrBlob(std::initializer_list<std::sting> il);

	 ...

	 private:
	 std::shared_ptr<std::vector<std::string>> data;
	 ...
};

StrBlob::StrBlob() : data( make_shared<vector<string >>() ) {}
StrBlob::StrBlob(initializer_list<string > il) : data( make_shared<vector<string >>(il) ) {}


// should have const version as well for followings
//

string& StrBlob::front()
{
	 return data->front();
}

string& StrBlob::back()
{
	 return data->back();
}

This case don't define 'copy-controls' and use syn versions but not a problem as it uses shared_ptr.
that's why shared_ptr is useful. ~


{use-example}

shared_ptr<vector< T >> pvec;

T var = (*pvec)[index];


{deleter}

void f()
{
	 shared_ptr< int > sp (new int(42) );
	 // use sp
	 // exception and no catch
}

This is exception safe. However, it is not for using resources which have own interfacces.

void f()
{
	 connection c = connect(&d);
	 // use connection
	 // if exception occur, no way to close conn
}

can set deleter of shared_ptr rather than the default delete op.

void end_connection( connection &p ) { disconnect(*p); }

void f()
{
	 connection c = connect(&d);
	 shared_ptr< connection > p (&c, end_connection);
	 // use connection
	 // if exception occur
}


{unique-ptr} {auto-ptr}

This was auto_ptr before and it has only one user because no copy and assign are supported. so limit
the use and it transfer ownerships.

The release() return the pointer it held and make it null so reset/release pair transfer ownerships.

unique_ptr< int > p2( new int(42) );
unique_ptr< string > p1( new string("Primus") );

unique_ptr< int > p2( p1.release() );				// p1 becomes null. transfer ownership.
unique_ptr< string > p3( new string("Fred") );

// reset delete a mem that p2 points and set it with pointer p3 points. transfer ownership.
p2.reset( p3.release() );								

As with shared_ptr, can set 'deleter' but use different form. refer to {member-template} in
*kt_dev_cpp_025*


{weak-ptr}

not sure when it's useful although p474 shows an example that's not appealing.


{get-func}

EC++15. Returns raw resource (underlying pointer). Said it converts an RAII object into the raw
resource. Explicit conversion.

>
 Is this contrary to encapsulation? true but RAII donesn't exist to encapsulate something.
 exist to ensure that a particular action - release resource - takes place.

 Encap is not for every classes !
<

{smart-pointer-internal}

MEC++28. The typical implementation is:

template< class T>
class SmartPtr {
	 public:
	 	SmartPtr( T* realPtr = 0 );
		SmartPtr( const SmartPtr& rhs );
		~SmartPtr();

		// const. though it may lead to modification of what the pointer points to
		T* operator->() const;
		T& operator*() const;

	private:
		T* pointee;
};


{{encapsulation}}

SP is testimony of encapsulation:

o Allow us to treat them as dumb, built-in, pointer. SP is object acts like a pointer.
o Other example. Handle local and remote DB access as if it is in the same place. Hide.

void editTuple(DBPtr<Tuple>& pt)
{
	 do {
		  pt->displayEditDialog();
	 } while (pt->isValid() == false);
}

The tuple to be edited inside editTuple may be physically located on a remote machine, but the
programmer writing editTuple need not be concerned with such matters;


{{ownership}}

Passing auto_ptr by value is often a bad idea. Why?

void printNode( ostream& s, auto_ptr< TreeNode> p ) { s << *p; }

int main()
{
	 auto_ptr< TreeNode> ptr( new TreeNode );
	 ...
	 printNode( cout, ptr );
	 ...
}

In printNode call, call copy-ctor and means transfer ownership. When returns, dtor runs and delete
pointee. When main ends, dtor runs again. <double-free> So use reference:

void printNode( ostream& s, auto_ptr< TreeNode>& p ) { s << *p; }

See {the-rule-of-three} for <double-free> example.


{{dereferencing-and-member-selection-operator}}

template< class T>
T& SmartPtr< T>::operator*() const
{
	 ...
	 return *pointee;
}

See return as reference because:

o *pointee can be derived class in inheritance. Avoid sliced-off.
o More efficient. No temp object.


pt->displayEditDialog(); -> (pt.operator->())->DisplayEditDialog();

So operator-> return either pointer or another smart pointer because can use -> on it.

template< class T>
T* SmartPtr< T>::operator->() const
{
	 ...
	 return pointee;
}

Both returns pointer and reference, virtual call through it works as supposed to.


{{nullness-of-smart-pointer}}

SmartPtr< T> ptr;
...
if( ptr == 0 ) ...
if( ptr ) ...
if(!ptr) ...

All issues compile error. NOTE: How about STL?

How to solve? Typical approach is to use conversion operators.

<approach-one> <conversion-to-void>

This is the way iostream uses so it is possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
	 public:
	 	operator void*(); // return 0 if smart pointer is null, non-zero otherwise.
		...
};

<approach-two> <conversion-to-bool>

Both approaches are not complete. Why? Cases where implicit conversion is a problem:

SmartPtr< Apple> pa; SmartPtr< Orange> po;

if( pa == po ) ...

Even if there is no operator== taking a SmartPtr<Apple> and a SmartPtr<Orange>, this compiles,
because both smart pointers can be implicitly converted into void* pointers, and there is a built-in
comparison function for built-in pointers.

<approach-three>

Use operator!() but still not complete.


{{smart-pointer-in-inheritance}}

If use smart pointer thinking it do derived-to-base conversion in inheritance, causes compile error.
Why? Template make a new class so inheritance no longer exist. Is it useful to maintain inheritance
when use template? If so, do further study.


{{smart-pointer-and-const}}

For built-in:

const T* const ptr = ...;

For smart pointer:

const SmartPtr< T> ptr = &goodCD;  // const pointer
SmartPtr< const CD> ptr = &goodCD;

Unlike built-in, there is no conversion from non-const to ptr-to-const.

const CD* pConstCD = pCD;

Because template create new classes. If need more, see further.


==============================================================================
*kt_dev_stl_019*	new and delete

{default-and-value-init}
#include <new>

string* ps = new string;		// default-init
string* ps = new string();		// value-init

int* pi = new int;				// default-init
int* pi = new int();				// value-init

Only for built-in types, value-init makes difference and this means that default-init for built-in
types has uninitialized values. For class types, both will use default ctors and so no difference.
<new-operator> combines allocation and construction. it creates 'unnamed' and then 'default-init'
objects e.g. calls ctor for class object.


{new-operator}
MEC++08: This operator is built into the language and, like sizeof, you can't change its meaning: it
always does the same thing. What it does is twofold: allocation and construction.

For new operator, use operator new (or operator new[]) to allocate raw memory, runs ctor to
construct, and returns pointer to constructed memory. Raise 'bad_alloc' exception when there no
memory.

For deletion, runs dtor and operator delete( or delete[]) to free memory.
	 

{operator-new-and-delete}
This is the C++ equivalent of calling malloc and free. What you can change is how the memory for an
object is allocated. The name of the function that the new operator calls to allocate memory is
operator-new. you can rewrite or overload that function to change its behavior.

The operator new function is usually declared like this:

void * operator new(size_t size);

The return type is void*, because this function returns a pointer to raw, uninitialized memory.

void *rawMemory = operator new(sizeof(string));

Like malloc, operator new's only responsibility is to allocate memory.

NOTE: Can define own operator new and delete but careful because it takes over responsibility for
<ALL> dynamic memory allocation. <BECAUSE> write your own version of operator new and then use the
new operator; it will automatically invoke your custom version of operator new.


{placement-new} <interview>
A [special] version of operator new called placement new which gives it more options. The placement
new is part of the standard C++ library. To use placement new, all you have to do is #include <new>
(or, if your compilers don't yet support the new-style header names, <new.h>).
However, do not need to include new header for a use of operator new.

<example-one>
One example is to tell not to raise exception. No exception and return nullptr instead.

int* pi = new (nothrow) int;

<example-two>
new (place_address) type 
new (place_address) type (initializers)

Widget * constructWidgetInBuffer(void *buffer, int widgetSize)
{
	return new (buffer) Widget(widgetSize);
}

This function returns a pointer to a Widget object that's constructed within the buffer passed to
the function.

<useful-case>
Such a function might be useful for applications using shared memory or memory-mapped I/O, because
objects in such applications must be placed at specific addresses or in memory allocated by special
routines.


{must-match-between-operator-new-and-delete}
// allocate enough memory to hold 50 chars; call no ctors
void *buffer = operator new(50*sizeof(char)); 
...

// deallocate the memory; call no dtors
operator delete(buffer); 

NOTE: Should undo the effect of the constructor by explicitly calling the object's destructor:

// functions for allocating and deallocating memory in shared memory
void * mallocShared(size_t size);
void freeShared(void *memory);
void *sharedMemory = mallocShared(sizeof(Widget));

// placement new is used
Widget *pw = constructWidgetInBuffer( sharedMemory, 10);           

...

// undefined! sharedMemory came from mallocShared, not operator new
delete pw; 

// fine, destructs the Widget pointed to by pw, but doesn't deallocate the memory containing the
// Widget
pw->~Widget(); 

// fine, deallocates the memory pointed to by pw, but calls no destructor
freeShared(pw); 

(From Primus?)
This is analogous to allocator.construct() but one important difference: allocator.construct()
must use memory allocated by the 'same' allocator but need not point to memory by operator
new and refer to dynamic memory.


{overloading-new-and-delete-as-a-member-func}
note: useful case? can implement memory allocation specific to class?

When see new/delete expr, looks for corresponding operator function to call. For class type
arg-dependant lookup applies. If class has a member new or delete operator, this will be used while
can use library version via ::new or ::delete.


{allocator}
#include <memory>

template<class T>
struct allocator;
		
template<>
struct allocator<void>;

Provides a way to decouple alloc/dealloc and construction/destruction and allows finer control. For
example, alloc big memory and construct objects and pay the overhead of construction only when needed.

The allocator provides 'type-aware' allocation and returns 'unconstructed' memory while operator-new
uses only size.

allocator< string > alloc;
auto const p = alloc.allocator(n);

// calls ctor. From C++11, supports many ctors. 
alloc.construct(p++);
alloc.construct(p++, 10, 'c');
alloc.construct(p++, "hi");

Should bec careful that using unconstructed memory is 'undefined'.

// calls dtor
alloc.destory(p);

// size must match
alloc.deallocate(p, n);


TODO: study Primers p524 as a case to use allocator.


{delete-caution}
It's okay delete nullptr but it's undefined when:

1) delete twice
2) delete ptr that was not from new operator.


==============================================================================
*kt_dev_stl_020*	gcc stl impl files

/usr/include/c++/4.4.4

algorithm        cinttypes           cstddef          exception            iostream  queue         thread
array            ciso646             cstdint          exception_defines.h  istream   random        tr1
backward         climits             cstdio           exception_ptr.h      iterator  ratio         tr1_impl
bits             clocale             cstdlib          ext                  limits    regex         tuple
bitset           cmath               cstring          fenv.h               list      set           typeinfo
c++0x_warning.h  complex             ctgmath          forward_list         locale    sstream       type_traits
cassert          complex.h           ctime            fstream              map       stack         unordered_map
ccomplex         condition_variable  cwchar           functional           memory    stdatomic.h   unordered_set
cctype           csetjmp             cwctype          i686-redhat-linux    mutex     stdexcept     utility
cerrno           csignal             cxxabi-forced.h  initializer_list     new       streambuf     valarray
cfenv            cstdarg             cxxabi.h         iomanip              numeric   string        vector
cfloat           cstdatomic          debug            ios                  ostream   system_error  x86_64-redhat-linux
chrono           cstdbool            deque            iosfwd               parallel  tgmath.h

bits dir has actual STL files.


==============================================================================
*kt_dev_stl_021*	algorithm: remove-erase idiom

If want to delete all elements with specific value from container, use remove-erase idiom.

When runs remove(), it will reorder like:

<elemenets not matched> <elements matched>
                       |
							  += return the past of the last element

c.erase( remove( c.begin(), c.end(), 1963 ), c.end() );

For list and assoc containers, use member func as c.remove(1963)


==============================================================================
*kt_dev_stl_022*	iterator: external and internal

Was asked in phone screening. 

http://gafter.blogspot.co.uk/2007/07/internal-versus-external-iterators.html

In the "Gang Of Four" Patterns book's discussion of the Iterator pattern, we read (page 260):

Who controls the iteration? A fundamental issue is deciding which party controls the iteration, the
iterator or the client that uses the iterator. When the client controls the iteration, the iterator
is called an external iterator (C++ and Java), and when the iterator controls it, the iterator is an
internal iterator (Lisp and functional languages). Clients that use an external iterator must
advance the traversal and request the next element explicitly from the iterator. In contrast, the
client hands an internal iterator an operation to perform, and the iterator applies that operation
to every element in the aggregate.

External iterators are more flexible than internal iterators. It's easy to compare two collections
for equality with an external iterator, for example, but it's practically impossible with internal
iterators. Internal iterators are especially weak in a language like C++ that does not provide
anonymous functions, closures, or continuations like Smalltalk and CLOS. But on the other hand,
internal iterators are easier to use, because they define the iteration logic for you.


# ============================================================================
#{

==============================================================================
*kt_dev_sys_001*	<empty>



==============================================================================
*kt_dev_sys_002*	endianess

representation

this is how {.byte 11} in MIPS is stores in memory:

0000 0000 0000 0000 0000 0000 0000 1011

big endian(e.g. intel)	little(e.g. spacc)
0000 0000					0000 1011
0000 0000					0000 0000
0000 0000					0000 0000
0000 1011					0000 0000


==============================================================================
*kt_dev_sys_003*	to check endianess at runtime

uint8_t ebuf[4];
uint32_t *ebuf32 = (uint32_t *)ebuf;

ebuf32[0] = 0x01000000;
if(ebuf[0] == 0x01) system_endian = TBIG_ENDIAN;
else system_endian = TLITTLE_ENDIAN;


==============================================================================
*kt_dev_sys_004*	to check address alignment

#define SYSTEM_ALIGNMENT (8)

/* check if an address is aligned to the given alignment boundry,
   NOTE: alignment boundry must be a power of two */
#define IS_ALIGNED(addr,alignb) (((((uint32_t)(addr))) & (((unsigned)alignb)-1)) == 0)

// ALIGNED
if (IS_ALIGNED(size, SYSTEM_ALIGNMENT)) 
{
	*p_aligned_size = size;
}
// NOT ALIGNED
else 
{
	*p_aligned_size = ((size / SYSTEM_ALIGNMENT) + 1) * SYSTEM_ALIGNMENT;
}

dec : bin
7      111   
8     1000
9   0 1001
10  0 1010
11  0 1011
12  0 1100
13  0 1101
14  0 1110
15  0 1111  
16  1 0000
32 10 0000


==============================================================================
*kt_dev_sys_005*	two's complement

type int on MIPS. size int: 4
s int		: -219874992
us int	: 4075092304

show the complement of a binary number by flipping all digits:

	 23:    1 0111
NOT 23: 1110 1000

X + NOT X =  -1 -> -X = 1 + NOT X
 
NOT 23: 1110 1000
+    1: 0000 0001
-----------------
   -23: 1110 1001

this method is called "the 2's complement".

Since the addition operation in the CPU is agnostic to whether the integer is signed or unsigned,
the same goes for signed integers. For 32-bit signed integers, the minimum value is 0x80000000
(-2147483648, 31th MSB is on) and the maximum value is 0x7fffffff (2147483647). Note that there is
no value than can hold 2147483648, so if you negate (int)0x80000000, you get (int)0x80000000 again.
That is something to look out for, because it means abs() returns a negative value when fed
-2147483648.

8bit two's complement

0000 0000 : 0
0000 0001 : 1
0000 0010 : 2
0000 0011 : 3
0000 0100 : 4
...
0111 1111 : 127
1000 0000 : -128 (127+1 = -128)
1000 0001 : -127 (0111 1110 + 1 = 0111 1111 (127))
1000 0010 : -126 (0111 1101 + 1 = 0111 1110 (126))
...
1111 1110 : -2
1111 1111 : -1


Get two's complement in programmatic way

uint32_t ins = 0x27BDFFE0 
0010.0111.1011.1101.1111.1111.1110.0000

two's complement
1101.1000.0100.0010.0000.0000.0001.1111 
+1
1101.1000.0100.0010.0000.0000.0010.0000 

(-ins) = 0xD8420020
1101.1000.0100.0010.0000.0000.0010.0000


{wrap-around}

unsigned = out-of-range signed value   # wrap-around. by compiler from Primus p35?
signed   = out-of-range unsigned value # undefined.


==============================================================================
*kt_dev_sys_007*	stack (MIPS)

http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html

To think about what's required, let's think about what happens in a function call. 

1.	When a function call is executed, the arguments need to be evaluated to values at least, for
C-like programming languages.  

2.	Then, control flow jumps to the body of the function, and code begins executing there.  

3.	Once a return statement has been encountered, we're done with the function, and return back to
the function call. 

Programming languages make functions easy to maintain and write by giving each function its own
section of memory to operate in. For example, suppose you have the following function. 

int pickMin( int x, int y, int z ) {
  int min = x ;
  if ( y < min )
    min = y ;
  if ( z < min )
    min = z ;
  return min ;
}

You declare parameters x, y, and z. You also declare local variables, min. You know that these
variables won't interfere with other variables in other functions, even if those functions use the
same variable names. In fact, you also know that these variables won't interfere with separate
invocations of itself. 

For example, consider this recursive function, 

    int fact( int n ) {
      if ( n == 0 )
        return 1 ;
      else
        return fact( n - 1 ) * n ;
    }

Each call to fact produces a new memory location for n. Thus, each separate call (or invocation) to
fact has its own copy of n. How does this get implemented? In order to understand function calls,
you need to understand the stack, and you need to understand how assembly languages like MIPS
deal with the stack. 


{stack-pointer}

When a program starts executing, a certain contiguous section of memory is set aside for the program
called the stack. Let's look at a stack. 

low addr  +---------+ stack limit (overflow)
          |         |
			 |         |
			 |=========| sp (grows up towards low addr)
			 |         |
high addr +---------+ stack bottom

The stack-pointer is usually a register that contains the top of the stack. The stack pointer
contains the smallest address x such that any address smaller than x is considered garbage, and any
address greater than or equal to x is considered valid. The shaded region of the diagram represents
valid parts of the stack. 


<push-and-pop>

Push: You can push one or more registers, by setting the stack pointer to a smaller value. Usually
by subtracting 4 times the number of registers to be pushed on the stack and copying the registers
to the stack.  

Pop: You can pop one or more registers, by copying the data from the stack to the registers, then to
add a value to the stack pointer. Usually adding 4 times the number of registers to be popped on the
stack

Thus, pushing is a way of saving the contents of the register to stack, and popping is a way of
restoring the contents of the register from stack. 

Some ISAs have an explicit push and pop instruction. However, {MIPS-does-not} However, you can get
the same behavior as push and pop by manipulating the stack pointer directly. 

The stack pointer, by convention, is r29(sp). That is, it's register 29. Here's how to implement the
equivalent of push $r2 in MIPS, which is to push register $r2 onto the stack. 

push:  addi $sp, $sp, -4  # Decrement stack pointer by 4
       sw   $r3, 0($sp)   # Save $r3 to stack

Here's a diagram of a push operation. 


<stack-pointer-convention>

You might wonder why it's necessary to update the stack pointer. Couldn't you just do the following? 

push:  sw $r3, -4($sp)   # Copy $r3 to stack

Certainly, this is equivalent in behavior as far as register 3 being saved to the stack. However
we'd like to maintain the invariant (condition) that all addresses greater than or equal to the
stack pointer hold valid data, and all the addresses less than the stack pointer hold invalid data.
It just makes bookkeeping that much easier if we follow these conventions.  

Popping off the stack is the opposite of pushing on the stack. First, you copy the data from the
stack to the register, then you adjust the stack pointer. 

pop:  lw   $r3, 0($sp)   # Copy from stack to $r3
      addi $sp, $sp, 4   # Increment stack pointer by 4


<call-by-value>

If you've ever made the error of returning a pointer to a local variable or to a parameter that was
passed by value and wondered why the value stayed valid initially, but later on got corrupted, you
should now know the reason. The data still stays on the garbage part of the stack until the next
push operation overwrites it. That's when the data gets corrupted.


push and pop for 3 regs

push:  addi $sp, $sp, -12  # Decrement stack pointer by 12
       sw   $r2, 0($sp)   # Save $r2 to stack
       sw   $r3, 4($sp)   # Save $r3 to stack
       sw   $r4, 8($sp)   # Save $r4 to stack

pop:  sw   $r2, 0($sp)   # Copy from stack to $r2
      sw   $r3, 4($sp)   # Copy from stack to $r3
      sw   $r4, 8($sp)   # Copy from stack to $r4
      addi $sp, $sp, 12  # Increment stack pointer by 12


{stack-frame}

The following is more of general when there is a frame pointer so not the same as MIPS. {KT} The
stack frame is a function call and scope. Arg is copied into a stack and hence need copy-ctor.


Let's now see how the stack is used to implement functions. For each function call, there's a
section of the stack reserved for the function. This is usually called a stack frame. Let's imagine
we're starting in main() in a C program. The stack looks something like this: 

We'll call this the stack frame for main(). A stack frame exists whenever a (called) function has
started, but yet to complete.

Suppose, inside of body of main() there's a call to foo(). Suppose foo() takes two arguments. One
way to pass the arguments to foo() is through the stack. Thus, there needs to be assembly language
code in main() to "push" arguments for foo() onto the the stack. The result looks like: 

As you can see, by placing the arguments on the stack, the stack frame for main() has increased in
size. We also reserved some space for the return value. The return value is computed by foo(), so it
will be filled out once foo() is done. 

Once we get into code for foo(), the function foo() may need local variables, so foo() needs to push
some space on the stack, which looks like: 
 
   |          |
SP +----------+
   | foo      |	foo() stack frame
   |          |
   +----------+   ++++
FP | ret val  |   main() stack frame
   +----------+
   | args     |
   +----------+
   | args     |
   +----------+
   | main     |
   |          |
   |          |
   +----------+   ++++

foo() can access the arguments passed to it from main() because the code in main() places the
arguments just as foo() expects it. 

We've added a new pointer called FP which stands for frame pointer. The frame pointer points to the
location where the stack pointer was, just before foo() moved the stack pointer for foo()'s own
local variables. 

<stack-pointer>
Almost all architectures have one register dedicated to point to the end of the stack; the stack
pointer. 

<frame-pointer> <not-for-mips>
Many have a second register which points to the start of the currently active stack frame; the frame
pointer. 

That's SP means the current level and FP means the start of current stack frame.

When your program is started, the stack has only one frame, that of the function main.  This is
called the initial frame or the outermost frame.  ==

Having a frame pointer is convenient when a function is likely to move the stack pointer several
times throughout the course of running the function. The idea is to keep the frame pointer fixed for
the duration of foo()'s stack frame. The stack pointer, in the meanwhile, can change values.  Thus,
    we can use the frame pointer to compute the locations in memory for both arguments as well as
    local variables. Since it doesn't move, the computations for those locations should be some
    fixed offset from the frame pointer. 

And, once it's time to exit foo(), you just have to set the stack pointer to where the frame pointer
is, which effectively pops off foo()'s stack frame. It's quite handy to have a frame pointer.  We
can imagine the stack growing if foo() calls another function, say, bar(). foo() would push
arguments on the stack just as main() pushed arguments on the stack for foo().  So when we exit
foo() the stack looks just as it did before we pushed on foo()'s stack frame, except this time the
return value has been filled in. Once main() has the return value, it can pop that and the arguments
to foo() off the stack. 


<MIPS-stack-frame>

Each called function in a program allocates a stack frame on the run-time stack, if necessary. A
frame is allocated for each non-leaf function and for each leaf function that requires stack
storage. A non-leaf function is one that calls other function(s); a leaf function is one that does
not itself make any function calls. Stack frames are allocated on the run-time stack; the stack
grows downward from high addresses to low addresses. 

A function allocates a stack frame by subtracting the size of the stack frame from $sp on entry to
the function. This $sp adjustment must occur before $sp is used within the function and prior to any
jump or branch instructions. 


base offset | contents       | frame
+-----------+----------------+--------------
$sp       +0| arg build      |   low	
            | area           |   
            +----------------+   current
            | f/point regs   |
				| save area      |	
            +----------------+
            | generl regs    |
				| save area      |	
            +----------------+   
            | local and temp |	
+-----------+----------------+--------------
old $sp   +0| space for      |	
            | incoming args  |
            | args 1-4       |	
            +----------------+
         +16| (if present)   |
            | incoming args  |	
            | passed in sp   |	previous
            +----------------+
            | unspecified    |	high
            | ...            |	
            | variable size  |	
            +----------------+


{standard-called-function-rules}

By convention, there is a set of rules that must be followed by every function that allocates a
stack frame. Following this set of rules ensures that, given an arbitrary program counter, return
address register $31, and stack pointer, there is a deterministic way of performing
{stack-backtracing}. These rules also make possible programs that translate already compiled
absolute code into position-independent

There is only one exit from a function that contains a stack adjustment: a jump register instruction
that transfers control to the location in the return address register $31. This instruction,
including the contents of its branch delay slot, mark the end of function.

MIPS stack frame alignment. Although the architecture requires only word alignment, software
convention and the operating system require every stack frame to be doubleword (8 byte) aligned.

In the previous discussion of function calls, we said that arguments are pushed on the stack and
space for the return value is also pushed. This is how CPUs used to do it. With the RISC revolution
(admittedly, nearly 20 years old now) and large numbers of registers used in typical RISC machines,
{the-goal-is-to-try-and-avoid-using-the-stack}. 

Why? The stack is in physical memory, which is RAM. Compared to accessing registers, accessing
memory is much slower---probably on the order of 100 to 500 times as slow to access RAM than to
access a register. 


http://msdn.microsoft.com/en-us/library/aa448706.aspx
(The MIPS microprocessor has 32 general-purpose registers.) 

(gdb) info registers

          zero       at       v0       v1       a0       a1       a2       a3
 R0   00000000 10008401 2aadf310 00d40b70 2aadc000 00000000 00000001 00000001 
            t0       t1       t2       t3       t4       t5       t6       t7
 R8   00000000 00008400 10008400 831a8000 00000002 00000000 831a9e7a 00000000 
            s0       s1       s2       s3       s4       s5       s6       s7
 R16  00a12870 009cc130 0098c4bc 00000001 00000004 00000008 009cd2fc 009cc23c 
            t8       t9       k0       k1       gp      {sp}      s8      {ra}
 R24  831a9d9a 2aada010 00000000 00000000 2aae5010 009cc078 00860000 2aad2590 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 00d40b74 0080000c 2aad0cac 
           fsr      fir
      00000000 00000000 


args $a0, $a1, $a2, $a3 ~

There are four registers used to pass arguments: $a0, $a1, $a2, $a3.  If a function has
more than four arguments, or if any of the arguments is a {large-structure} that's passed by
value, then the stack is used.  There must be a set procedure for passing arguments that's
known to everyone based on the types of the functions. That way, the caller of the
function knows how to pass the arguments, and the function being called knows how to
access them. Clearly, if this protocol is not established and followed, the function being
called would not get its arguments properly, and would likely compute bogus values or,
worse, crash. 


return $v0, $v1 ~

The return value is placed in registers $v0, and if necessary, in $v1. In general, this
makes calling functions a little easier. In particular, the calling function usually does
not need to place anything on the stack for the function being called. 

However, this is clearly not a panacea. In particular, imagine main() calls foo().
Arguments are passed using $a0 and $a1, say. What happens when foo() calls bar()? If foo()
has to pass arguments too, then by convention, it's supposed to pass them using $a0 and
$a1, etc. What if foo() needs the argument values from main() afterwards? To prevent its
own arguments from getting overwritten, foo() needs to save the arguments to the stack.
Thus, we don't entirely avoid using the stack. 


Example to show reg changes between SF.

(gdb) bt
#0  0x2aaf02d4 in ?? () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
#1  0x00b100c8 in SYSTEMITC_API_PendEvent (qhandle=<value optimized out>, timeout=-1) at systemitc.c:375
#2  0x00520fd0 in SrmLowPriorityMain (data=<value optimized out>) at srm_main.c:1597
#3  0x00b328d0 in SYSTEMUTIL_THR_P_ThreadPrologue (arg=<value optimized out>) at systemutil_thread.c:869
#4  0x2aad2f9c in pthread_join () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
Backtrace stopped: previous frame inner to this frame (corrupt stack?)

(gdb) bt
#0  0x2aaf02d4 in ?? () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbb0 00d40000 00b100c8 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 2aaf02d4 
      
#1  0x00b100c8 in SYSTEMITC_API_PendEvent (qhandle=<value optimized out>, timeout=-1) at systemitc.c:375
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbb0 00d40000 00b100c8 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00b100c8 
            
#2  0x00520fd0 in SrmLowPriorityMain (data=<value optimized out>) at srm_main.c:1597
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbe8 00d40000 00520fd0 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00520fd0 

(SP diff: 0139fe38 - 0139fbe8 = 0x250, 592)      

#3  0x00b328d0 in SYSTEMUTIL_THR_P_ThreadPrologue (arg=<value optimized out>) at systemutil_thread.c:869
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fe38 00f0eacc 00b328d0 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00b328d0 

(0139feb0 - 0139fe38 = 0x78, 128)
       
#4  0x2aad2f9c in pthread_join () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139feb0 00f0eacc 2aad2f9c 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 2aad2f9c 

40 registers in total and 40*4 = 160 bytes


==============================================================================
*kt_dev_sys_008*	stack asm example (MIPS)

# C
#

typedef struct {
	int struct_one;
	int struct_two;
	int struct_three;
} ENTRY;

int func_second(int arg1, int arg2)
{
	int local_val = 0;
	
	return local_val = arg1*2 + arg2;	
}

int func_first(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ENTRY entry)
{
	int local_val = 0;
	int one = 0, two = 0;
	
	one = arg5+arg1+entry.struct_one;
	two = arg6+arg2+entry.struct_two;
	
	local_val = arg1+arg2+arg3+arg4+func_second(one, two);
	
	return local_val;
}

int main(int argc, char* argv[])
{
	int ret = 0;
	ENTRY node = {0};
	
	node.struct_one = 10;
	node.struct_two = 20;
	node.struct_three = 30;
	
	ret = func_first( 1, 2, 3, 4, 5, 6, node );
	printf("ret = %d\n",  ret);	
	return 0;
}


# asm
#

int func_second(int arg1, int arg2)
{
  400590:	27bdffe8 	addiu	sp,sp,-24
  400594:	afbe0010 	sw	s8,16(sp)	# {no-need-to-save-ra}
  400598:	03a0f021 	move	s8,sp
  40059c:	afc40018 	sw	a0,24(s8)
  4005a0:	afc5001c 	sw	a1,28(s8)
	int local_val = 0;
  4005a4:	afc00008 	sw	zero,8(s8)
	
	return local_val = arg1*2 + arg2;	
  4005a8:	8fc20018 	lw	v0,24(s8)
  4005ac:	00021840 	sll	v1,v0,0x1
  4005b0:	8fc2001c 	lw	v0,28(s8)
  4005b4:	00621021 	addu	v0,v1,v0
  4005b8:	afc20008 	sw	v0,8(s8)
  4005bc:	8fc20008 	lw	v0,8(s8)
}
  4005c0:	03c0e821 	move	sp,s8
  4005c4:	8fbe0010 	lw	s8,16(sp)
  4005c8:	27bd0018 	addiu	sp,sp,24	# pop
  4005cc:	03e00008 	jr	ra				# {return-to-caller} 
  4005d0:	00000000 	nop

004005d4 <func_first>:

note no pass by value happend for struct arg. how about passing this struct to second
func? this struct will be copied again in stack?

int func_first(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ENTRY entry)
{
  4005d4:	27bdffc8 	addiu	sp,sp,-56
  4005d8:	afbf0030 	sw	ra,48(sp)	# {save-ra}
  4005dc:	afbe002c 	sw	s8,44(sp)
  4005e0:	afb00028 	sw	s0,40(sp)
  4005e4:	03a0f021 	move	s8,sp
  4005e8:	afc40038 	sw	a0,56(s8)	// save args in stack
  4005ec:	afc5003c 	sw	a1,60(s8)
  4005f0:	afc60040 	sw	a2,64(s8)
  4005f4:	afc70044 	sw	a3,68(s8)
	int local_val = 0;
  4005f8:	afc00020 	sw	zero,32(s8)
	int one = 0, two = 0;
  4005fc:	afc0001c 	sw	zero,28(s8)
  400600:	afc00018 	sw	zero,24(s8)
	
	one = arg5+arg1+entry.struct_one;
  400604:	8fc30048 	lw	v1,72(s8)	// arg5
  400608:	8fc20038 	lw	v0,56(s8)	// arg1
  40060c:	00621821 	addu	v1,v1,v0
  400610:	8fc20050 	lw	v0,80(s8)	// struct.one
  400614:	00621021 	addu	v0,v1,v0
  400618:	afc2001c 	sw	v0,28(s8)
	two = arg6+arg2+entry.struct_two;
  40061c:	8fc3004c 	lw	v1,76(s8)	// arg6
  400620:	8fc2003c 	lw	v0,60(s8)	// arg2
  400624:	00621821 	addu	v1,v1,v0
  400628:	8fc20054 	lw	v0,84(s8)
  40062c:	00621021 	addu	v0,v1,v0
  400630:	afc20018 	sw	v0,24(s8)
	
	local_val = arg1+arg2+arg3+arg4+func_second(one, two);
  400634:	8fc30038 	lw	v1,56(s8)
  400638:	8fc2003c 	lw	v0,60(s8)
  40063c:	00621821 	addu	v1,v1,v0
  400640:	8fc20040 	lw	v0,64(s8)
  400644:	00621821 	addu	v1,v1,v0
  400648:	8fc20044 	lw	v0,68(s8)
  40064c:	00628021 	addu	s0,v1,v0
  400650:	8fc4001c 	lw	a0,28(s8)
  400654:	8fc50018 	lw	a1,24(s8)
  400658:	0c100164 	jal	400590 <func_second>
  40065c:	00000000 	nop
  400660:	02021021 	addu	v0,s0,v0	// local_val = ... + return;
  400664:	afc20020 	sw	v0,32(s8)		 
	
	return local_val;
  400668:	8fc20020 	lw	v0,32(s8)
}
  40066c:	03c0e821 	move	sp,s8
  400670:	8fbf0030 	lw	ra,48(sp)
  400674:	8fbe002c 	lw	s8,44(sp)
  400678:	8fb00028 	lw	s0,40(sp)
  40067c:	27bd0038 	addiu	sp,sp,56
  400680:	03e00008 	jr	ra
  400684:	00000000 	nop

00400688 <main>:

int main(int argc, char* argv[])
{
  400688:	27bdffb8 	addiu	sp,sp,-72
  40068c:	afbf0044 	sw	ra,68(sp)	// save return
  400690:	afbe0040 	sw	s8,64(sp)
  400694:	03a0f021 	move	s8,sp
  400698:	afc40048 	sw	a0,72(s8)
  40069c:	afc5004c 	sw	a1,76(s8)
	int ret = 0;
  4006a0:	afc00030 	sw	zero,48(s8)
	ENTRY node = {0};
  4006a4:	afc00034 	sw	zero,52(s8)	// struct in stack
  4006a8:	afc00038 	sw	zero,56(s8)
  4006ac:	afc0003c 	sw	zero,60(s8)
	
	node.struct_one = 10;
  4006b0:	2402000a 	li	v0,10
  4006b4:	afc20034 	sw	v0,52(s8)
	node.struct_two = 20;
  4006b8:	24020014 	li	v0,20
  4006bc:	afc20038 	sw	v0,56(s8)
	node.struct_three = 30;
  4006c0:	2402001e 	li	v0,30
  4006c4:	afc2003c 	sw	v0,60(s8)
	
	ret = func_first( 1, 2, 3, 4, 5, 6, node );
  4006c8:	24020005 	li	v0,5		// arg in stack and move struct in stack
  4006cc:	afa20010 	sw	v0,16(sp)	// essentially, arg and strcut in stack
  4006d0:	24020006 	li	v0,6
  4006d4:	afa20014 	sw	v0,20(sp)
  4006d8:	8fc20034 	lw	v0,52(s8)
  4006dc:	8fc30038 	lw	v1,56(s8)
  4006e0:	8fc4003c 	lw	a0,60(s8)
  4006e4:	afa20018 	sw	v0,24(sp)
  4006e8:	afa3001c 	sw	v1,28(sp)
  4006ec:	afa40020 	sw	a0,32(sp)
  4006f0:	24040001 	li	a0,1
  4006f4:	24050002 	li	a1,2
  4006f8:	24060003 	li	a2,3
  4006fc:	24070004 	li	a3,4
  400700:	0c100175 	jal	4005d4 <func_first>	// func call
  400704:	00000000 	nop
  400708:	afc20030 	sw	v0,48(s8)
	printf("ret = %d\n",  ret);	
  40070c:	3c020040 	lui	v0,0x40
  400710:	244407e0 	addiu	a0,v0,2016
  400714:	8fc50030 	lw	a1,48(s8)
  400718:	0c100124 	jal	400490 <printf@plt>
  40071c:	00000000 	nop
	return 0;
  400720:	00001021 	move	v0,zero
}
  400724:	03c0e821 	move	sp,s8
  400728:	8fbf0044 	lw	ra,68(sp)
  40072c:	8fbe0040 	lw	s8,64(sp)
  400730:	27bd0048 	addiu	sp,sp,72
  400734:	03e00008 	jr	ra
  400738:	00000000 	nop
  40073c:	00000000 	nop


# SP and SF
#

 ----------------------------------- first
 56(00) : sp



   (16) : arg5
   (20) : arg6
   (24) : struct_one
   (28) : struct_one
   (32) : struct_one


 04(48) : ra
 00(56) : 
 ----------------------------------- main
 72(00) : sp



   (16) : arg5           (72)
   (20) : arg6           (76)
   (24) : struct_one     (80)
   (28) : struct_two     (84)
   (32) : struct_three


 04(68) : ra use 4(word) from here
 00(72) : 


# ra
# (caller update ra before jump)

 main
+------------+
| save ra    |
|            |
| update ra  |       first
| call first |  -> +------------+ 
|            |     | save ra    |
| get ra     |     |            |
| jump ra    |     | update ra  |      second
+------------+     | call secon | -> +------------+
                   |            |    | jump ra    |
                   | get ra     |    +------------+
                   | jump ra    |    
                   +------------+    


==============================================================================
*kt_dev_sys_009*	for and while asm (MIPS)

# c source
#
int main()
{
	 int i = 0;

	 while( i < 10 )
	 {
				printf("w iter %d\n", i );
				++i;
	 }

	 return 0;
}

#	when use -g (debug)
#
int main()
{
  400590:       27bdffd8        addiu   sp,sp,-40	     # push	:
  400594:       afbf0024        sw      ra,36(sp)	     # {copy-return-addr-into-a-stack}
  400598:       afbe0020        sw      s8,32(sp)	     # save s8(saved reg) into a stack. 
                                                        # s8 has one of s0-s7 that has values are preserved across function calls.
  40059c:       03a0f021        move    s8,sp	        # save sp to s8.
        int i = 0;
  4005a0:       afc00018        sw      zero,24(s8)     # int i = 0. save into a stack.			

        while( i < 10 )
  4005a4:       08100173        j       4005cc <main+0x3c> # { jump
  4005a8:       00000000        nop
        {
                printf("w iter %d\n", i );

{4005ac}:       3c020040        lui     v0,0x40		          # -> v0 = v0 << 16.
  4005b0:       244406a0        addiu   a0,v0,1696	          # a0 = v0 + 1696. a0-a3 used for passing args to functions.
  4005b4:       8fc50018        lw      a1,24(s8)			    # a1 = int i. 
  4005b8:       0c100124        jal     400490 <printf@plt>  # }} jump and link.
  4005bc:       00000000        nop
                ++i;

  4005c0:       8fc20018        lw      v0,24(s8)	    # v0 = int i.
  4005c4:       24420001        addiu   v0,v0,1		    # v0 = int i +1. inc i.
  4005c8:       afc20018        sw      v0,24(s8)	    # int i = v0.

{4005cc}:       8fc20018        lw      v0,24(s8)	    # -> v0 = int i 
  4005d0:       2842000a        slti    v0,v0,10	    # i < 10. 
  # slti(set on less than immediate. tests if one register is less than a constant.)
  4005d4:       1440fff5        bnez    v0,4005ac <main+0x1c>	
  # if( v0 != 0 ) then jump. bne(branch on not equal). v0 is 1(true).
  4005d8:       00000000        nop                    # }
        }

        return 0;
  4005dc:       00001021        move    v0,zero		# {copy-return-value}
}
  4005e0:       03c0e821        move    sp,s8
  4005e4:       8fbf0024        lw      ra,36(sp)
  4005e8:       8fbe0020        lw      s8,32(sp)
  4005ec:       27bd0028        addiu   sp,sp,40
  4005f0:       03e00008        jr      ra
  4005f4:       00000000        nop
  
#	when use -Os
#  
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40						# push. dec sp -40.
  400594:       3c020040        lui     v0,0x40							# v0 = v0 << 16.
  400598:       afb1001c        sw      s1,28(sp)						# save arg
  40059c:       afb00018        sw      s0,24(sp)						# save arg
  4005a0:       afbf0020        sw      ra,32(sp)						# save ra
  4005a4:       24510678        addiu   s1,v0,1656						# a1 = v0 + 1656.
  4005a8:       00008021        move    s0,zero							# s0 = 0. s0(int i) is free to use.
  4005ac:       02002821        move    a1,s0							# a1 = s0.
  																						# {
  4005b0:       0c100124        jal     400490 <printf@plt>			# call printf. as int i is 0 to start
  4005b4:       02202021        move    a0,s1							# a0 = s1
  4005b8:       26100001        addiu   s0,s0,1							# s0 = s0+1. 
  4005bc:       2402000a        li      v0,10							# v0 = 10. 
  4005c0:       1602fffb        bne     s0,v0,4005b0 <main+0x20>	# if( s0 != v0 )then jump.
                                                                  # }
  4005c4:       02002821        move    a1,s0							# a1 = s0(int i). exit while
  4005c8:       8fbf0020        lw      ra,32(sp)						# pop. recover ra.
  4005cc:       8fb1001c        lw      s1,28(sp)
  4005d0:       8fb00018        lw      s0,24(sp)
  4005d4:       00001021        move    v0,zero							# return 0.
  4005d8:       03e00008        jr      ra
  4005dc:       27bd0028        addiu   sp,sp,40

#
#
#include <stdio.h>

int main()
{
        int i = 0;

        for(i; i < 10; i++)
                printf("w iter %d\n", i );

        return 0;
}

# when use -Os. same as while case
#
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       3c020040        lui     v0,0x40
  400598:       afb1001c        sw      s1,28(sp)
  40059c:       afb00018        sw      s0,24(sp)
  4005a0:       afbf0020        sw      ra,32(sp)
  4005a4:       24510678        addiu   s1,v0,1656
  4005a8:       00008021        move    s0,zero
  4005ac:       02002821        move    a1,s0
                                                             # {
  4005b0:       0c100124        jal     400490 <printf@plt>
  4005b4:       02202021        move    a0,s1
  4005b8:       26100001        addiu   s0,s0,1
  4005bc:       2402000a        li      v0,10
  4005c0:       1602fffb        bne     s0,v0,4005b0 <main+0x20>
                                                             # }
  4005c4:       02002821        move    a1,s0
  4005c8:       8fbf0020        lw      ra,32(sp)
  4005cc:       8fb1001c        lw      s1,28(sp)
  4005d0:       8fb00018        lw      s0,24(sp)
  4005d4:       00001021        move    v0,zero
  4005d8:       03e00008        jr      ra
  4005dc:       27bd0028        addiu   sp,sp,40


==============================================================================
*kt_dev_sys_010*	POR(power on reset) (MIPS)

when POR, the start address by reset vector is 0xBFC0 0000

exception vector locations.

the reset, soft reset, and NMI exceptions are always vectored to location 0xBFC0_0000.
debug exceptions are vectored to location 0xBFC0_0480 or to location 0xFF20_0200 if the
ProbEn bit is 0 or 1, respectively, itn eht EJTAG control register(ECR).


==============================================================================
*kt_dev_sys_011*	instruction and addressing (MIPS)

I-Type(immediate)

|31      26|25    21|20     16|15              0|
|    op    |   rs   |    rt   |    immediate    |

when a word(4 bytes) is loaded and stored the memory address must be a multiple of four.
this is called an {alignment-restriction}. addresses that are a multiple of four are
called {word-aligned}. this resctiction makes the hardware simpler and faster.


The MIPS instruction that loads a word into a register is the lw instruction. The store
word instruction is sw. Each must specify a register and a memory address. A MIPS
instruction is 32 bits (always). A MIPS memory address is 32 bits (always). How can a load
or store instruction specify an address that is the same size as itself?

note. kt. means that instruction and args should fit into a word(32 bits)


An instruction that refers to memory uses a base register and an offset. The base register
is a general purpose register that contains a 32-bit address. The offset is a 16-bit
signed integer contained in the instruction. The sum of the address in the base register
with the (sign-extended) offset forms the memory address. 

For example:

if you want to load a byte by using the 'lb' instruction.

lb t1, 0x180003fb

it's not working and it simply stores the hexadecimal value into the register. in this
case 0x18000000. Because addresses are always signed 16-bit displacements relative to a
register 

# LUI -- The immediate value is shifted left 16 bits and stored in the register. The lower
# 16 bits are zeroes. lui $t, imm  # $t = (imm << 16)

so you'd wite to work

lui t1, 0x1800		
lbu t1, 0x3fb(t1)

Similarly, to store t1 into address 0x8009f000, you'd write:

# SW -- Store word. The contents of $t is stored at the specified address. 	
# sw $t, offset($s). MEM[$s + offset] = $t

lui at, 0x800a
sw t1, 0xf000(at) 

# Notice that in this case, the upper part of the address has to be incremented by one,
# since the lower part is negative.  0xf000(at) is negative and equates to -0x1000. so
# 0x800a0000 - 0x1000 = 0x8009f000

If you just want to load or store into an address between 0xffff8000 and 0x7fff, you can
skip the lui and use the register which various assemblers call zr, zero or 0 as the base
address. (??)

As you may already know, to load an arbitrary 32-bit value into a register, you use lui and addiu. 
Let's say you want to load 0xfedcba98 into v0. This becomes:

lui v0, 0xfedd
addiu v0, v0, 0xba98 # Add immediate unsigned (no overflow). addiu $t, $s, imm ($t = $s + imm)

Although addiu stands for "add immediate unsigned", the operand is nevertheless sign extended.

Example 02)
sw $12 , 0xFFF8($13)    or    sw $12 , -8($13)

Both are the same.


==============================================================================
*kt_dev_sys_012*	dump_stack

This function can be amended to print any failed capabilities checks using printk, and a
call to the kernel function dump_stack() should give you a pretty good idea of what the
middleware was attempting at the time of the failure. A little guesswork is still required
though, as this will only show you the stack in kernel space, not in the middleware
itself.

only for glibc?


==============================================================================
*kt_dev_sys_013*	clock_gettime and mktime



==============================================================================
*kt_dev_sys_014*	newlines between dos and linux

Q: what is it about?

Systems based on ASCII or a compatible character set use either LF (Line feed, '\n', 0x0A, 10 in
decimal) or CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF
(CR+LF, '\r\n', 0x0D0A).  These characters are based on printer commands: The line feed indicated
that one line of paper should feed out of the printer, and a carriage return indicated that the
printer carriage should return to the beginning of the current line. 

CR+LF: Microsoft Windows, DEC TOPS-10, RT-11 and most other early non-Unix and non-IBM OSes, CP/M,
MP/M, DOS (MS-DOS, PC-DOS, etc.) 

LF   : Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS,
Amiga, RISC OS, and others.

fgets() reads in at most one less than size characters from stream and stores them into the buffer
pointed to by s.  Reading stops after an EOF or a newline. If a newline is read, it is stored into
the buffer.  A '\0' is stored after the last character in the buffer. 

can check as below

[ktpark@cdilinux build_mlu]$ file platform.mk (for dos)
platform.mk: ASCII English text, with CRLF line terminators

[ktpark@cdilinux build_mlu]$ file platform.mk.kt (for unix)
platform.mk.kt: ASCII English text


# ============================================================================
#{

==============================================================================
*kt_dev_ecpp_001*	01: federation of language

C++ is:

Multiparadigm programming language. view it not as a single language but as a federation of related
sublanguages, each with its own rules and conventions.

C, object-oriendted (class), template, and STL


==============================================================================
*kt_dev_ecpp_002*	02: no to preprocessor

Prefer the compiler to the preprocessor because:

<0> type-checking

<1> better to decode compile error and to use symbolic debugger. 

#define ASPECT_RATIO 1.653

const double AspectRatio = 1.653

<2> smaller code (??)

<3> class-const

class specific const and better encapsulation. see *kt_dev_cpp_017*

<4> avoid problem when use macro with an expression

#define CALL_WITH_MAX(a,b) func((a) > (b) ? (a) : (b) )

int a= 5, b = 0;

CALL_WITH_MAX(++a, b);				// a is increased twice
CALL_WITH_MAX(++a, b+10);			// a is increased once

Use 'inline' instead.


==============================================================================
*kt_dev_ecpp_003*	09: no virtual call in ctor or dtor 

Problem:
Assume that each time a transaction object is created, an appropriate log entry needs to be created
in a log. If it is a derived object, then need to have a log entry for that.

Solution?:

class Transaction {
	 public:
	 Transaction();

	 virtual void logTransaction() const = 0;		// to make <type-dependent-log-entry>
	 ...
};

Transaction::Transaction()
{
	 ... >
	 logTransaction();
}

class BuyTransaction: public Transaction {
	 public:
	 virtual void logTransaction() const;
	 ...
};

class SellTransaction: public Transaction {
	 public:
	 virtual void logTransaction() const;
	 ...
};

// use
{
	 BuyTransaction buy;
}

Will it have a log entry of BuyTransaction? NO. base class version if available. 
>
 C++ don't allow because when base ctor runs, only base part is created. hence base version.
<
note: KT. That is becuase it is static bining at compile time.

1) Some compilers issue a warning. Even if there is no warnings, there will be a link error unless
there is a definition of pure virtual function. Remember pure virtual can have definition. 

2) Can use normal virtual function (not pure) but still get base version.


{one-solution}

class Transaction {
	 public:
	 explicit Transaction( const std::string& logInfo );

	 void logTransaction( const std::string& logInfo) const;		// <non-virtual-func>
	 ...
};

Transaction::Transaction( const std::string& logInfo )
{
	 ...
	 logTransaction( logInfo );
}

class BuyTransaction: public Transaction {
	 public:
	 BuyTransaction( parameters ) 
	 : Transaction( createLogString(parameters) )					// <pass-log-to-base-class>
	 { ... }
	 ...
	 private:
	 'static' std::string createLogString( parameters );				// <static-member-func>
};

See the use of func, createLogString, helper func, instead of member init list and it is more
convenient than member init. Think when there are many parameters.


{static-member-func-example} {reason-one}

Why static? By doing this, there is no danger of accidentally referring to the ByeTransaction
object's as-yet-uninitialized data members when base part runs.

Why logging call in the base class in the first place? that's becauase it's common to all type of
transactions. so move up as it's abstraction.


==============================================================================
*kt_dev_ecpp_004*	18: hard to use incorrectly 

1) Make compile error for incorrect uses (interface usage errors):

class Date {
	 public:
	 Date(int month, int day, int year);
	 ...
};

// client use
//
Date d(30, 3, 1995);		// wrong order
Date d(3, 40, 1995);		// invalid

How to make compile errros? Use <type-system>:

struct Day {
	 explicit Day(int day) : val(day) {}
	 int val;
};

struct Month {
	 explicit Month(int month) : val(month) {}
	 int val;
};

struct Year {
	 explicit Year(int year) : val(year) {}
	 int val;
};

class Date {
	 public:
	 Date( const Month& month, const Day& day, const Year& year);
	 ...
};

// client use
//
Date d(30, 3, 1995);									// wrong type. wrong order
Date d( Day(3), Month(40), Year(1995) );		// wrong type. invalid
Date d( Month(40), Day(3), Year(1995) );		// correct type. invalid but easy to see!


2) Make compile error for invalid values: 

enum? not type-safe. Safer solution is to predefine all vaild months.

class Month {
	 public:
	 static Month Jan() { return Month(1); }
	 ...
	 static Month Dec() { return Month(12); }

	 private:
	 explicit Month(int m);		// 'prevent' creation of new values
};

Date d( Month::Mar(), Day(30), Year(1995) );

Used functions to represent months. How about {class-const} in *kt_dev_cpp_017* instead of
using function?


3) Force client to follow interface rule

Investment* createInvestment();

This means that client remember to use RAII to prevent resource leaks. The better
interface decision is:

std::shated_ptr< Investment > createInvestment();

The same is {factory-func} in *kt_dev_stl_018* This force client to use smart_ptr.


==============================================================================
*kt_dev_ecpp_005*	23: prefer non-member non-friend func

EC++23. About considering encapsulation in design:

The greater something is encapsulated, then the greater our ability to change it. Roughly,
when there are more funcs to access data, it's less encapsulated. Assumes that it follows
the rule that member data must be private and therefore func interface to access data.

Plus points when use non-member non-friend func:

1) Greater encapsulation
Because only member func access private member data. Access control is a way to do encapsulation.

2) Partitioning functionality
Can have multiple header files that are functionaly separated and consist one namespace.
Like STL. Cannot do the same with class member.

3) Functional extensibility
When necessary, can extend functionality in the existing namespace by adding more. This is
horizental extension compared with vertical. e.g. class inheritence. 

Note: Looks like these come from STL arch.


==============================================================================
*kt_dev_ecpp_006*	26: postpone variable definitions

Postpone variable definitions as long as possible until is needed and have init value. Increases
clarity and efficiency.


{make-variable-available-only-for-some}

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
} else {  // bp points at a Base object
    // use the Base object to which bp points
}

By defining the variable in a condition, the pointer <dp> is not accessible outside the if. If the
cast fails, then the unbound pointer is not available for use in subsequent code where we might
forget to check whether the cast succeeded.


==============================================================================
*kt_dev_ecpp_007*	28: avoid returning handles to object internals

Here internals means everything except public interface and includes private and protected
member func. If returns handles (iterator, pointer and reference) to internals, it breaks
encapsulatation.


{compromising-encapsulation}

First problem.

Passing by ref is more efficient than passing by value and offer client a way to learn
what rectangle's points are, not to let clients modify. So:

class Rectangle {
	 public:
	 Point& upperLeft() const { return pData->ulhc; }

	 private:
	 std::shared_ptr< RectData > pData;
};

Is it okay? NO because client can change its value:

// use
const Rectangle rec( ... );
rec.upperLeft().setX(50);

Two problems:

1) it makes memeber data effectively public as returns reference to it.
2) the problem of bitwise-const. See {bitwise-const} in *kt_dev_cpp_012*

The solution is that it offers read-only access:

class Rectangle {
	 public: >
	 const Point& upperLeft() const { return pData->ulhc; }
<
	 private:
	 std::shared_ptr< RectData > pData;
};

Similar to the example of {const-member-func} in *kt_dev_cpp_012*

To see 1) only, see following example:

using namespace std;

class Sample {
private:
	int val;

public:
	Sample() : val(10) {}
	int& getx() { return val;}
	void printx() { cout << val << endl; }
};

int _tmain(int argc, _TCHAR* argv[])
{
	Sample sam;
	cout << "------" << endl;
	sam.printx();
	sam.getx() = 20;
	cout << "------" << endl;
	sam.printx();

	return 0;
}

This changes private member val to 20.


{dangling-handles}

Second problem. 

class GUIObject { ... }
const Rectangle boundingBox( const GUIObject& obj );

// use
GUIObject* pgo;
...
const Point* pUpperLeft = &( boundingBox(*pgo).upperLeft() );

This creates a temp Rectangle and returns its upper member. The problem is this temp is
destroyed when end this statement and pUpperLeft will dangle.

vector and string's [] operator returns reference but these are exceptions to this rule,
but not a general rule. Better not use [] operator.


==============================================================================
*kt_dev_ecpp_008*	31: minimize compilation dependencies

Two cases can cause complilation dependency problem:

o class interface changes. means header file changes.
o no separation between interface and implementation in class definition. means header file changes.

 [KT] The implementation separation can be achieved when use func tables which has a set of fixed
 interfaces and this is often done via registration. Such as OS abstraction or driver abstraction
 which happens when porting.
 
 But, how to handle when interface changes? For example, when replace graphic library which has
 different interfaces. Usually talk about how to design interfaces for user but if user uses it
 everywhere and replace library, need to find every place using it. If there is a single point or
 file to use interfaces then better to cope with changes? More about C. 

This item is about separating interface from implementation and this happens because C++ isn't very
good at separating interface from implementation.

// person.h
//
class Person {
	 public:
		  Preson( const Date& birthDay, const Address& addr );
		  std::string name() const;
		  ...

	 private:
		  std::string theName;
		  Date theBirthDate;
		  Address theAddress;
};

This member data is implementaion details and need class definition such as Date to compile. Hence
headers of these class are needed:

// person.cpp
//
#include < string>
#include "date.h"
#include "address.h"

This cause <cascading-compilation-dependencies>. Think if this person, date, or address class
changes then classes using one of these should be compiled.

date.h    -- persoh.h -- xxx.cpp that use person class. 
address.h --          -- xxx.cpp
                      -- ...

If change person class like adding or removing memeber data even if the interface remains the same,
will cause to compile every cpp files that includes person.h. Can use forward declaration to avoid
this? NO because cannot create an object. {forward-declaration} in *kt_dev_lang_010*	

If use foward declaration, the compiler cannot know the size of p and how big a Person object is. 

class Date;
class Address;

class Person {
	 public:
		  Preson( const Date& birthDay, const Address& addr );
		  std::string name() const;
		  ...

	 private:
		  std::string theName;
		  Date theBirthDate;
		  Address theAddress;
};

Person p(params);		// define a person object

To solve this, decouple interface from implementation and use dependencies on declaration than
definition. This move from <dependencies-on-definition> to <dependencies-on-declaration>. Two
approaches:


{pimpl-idiom} 

aka handle class. See {exception-safe} in *kt_dev_cpp_019*	

Have two classes. One is what client use and has a pointer to implementation. 
>
	 Use the fact that compiler has no problem to get size of built-in types like pointer. no
	 definition needed.


o Use built-in types such as reference and pointer.
o Need only declaration when func uses a class as pass or return by value because the definition is
needed only when call a func or define a func. {forward-declaration} in *kt_dev_lang_010*	

Date today(); void func(Date d);

No Date definition is needed. This removes dependency on unnecessary but not move the onus to
clients.


// person.h, interface class
//
class PersonImpl;											// forward-declaration
class Date;
class Address;

class Person {
	 ...
	 private:
		  std::shared_ptr< PersonImpl > pImpl;		// <set-pimpl>
};


// personimpl.h, implementation class
//

Both class must have the <same-interface>. If add or remove member data; changes implementation, no
need to compile clients.


// person.cpp, implementation class
//
#include "person.h"
#include "personimpl.h"												// for Impl class

Person::Person(...) : pImpl( new PersonImpl (...) ) {}   // <create-and-set-impl>

std::string Person::name() const                         // <forwarding>
{ return pImpl->name(); }

<summary>

(client)  (interface class)               (impl. class)
(client)		interface: no virtuals          interface
... 			set impl in ctor.               has real impl. and use other classes such as
				ptr to impl                     Date and Address in this example.

														(subclassing)

note:
o If impl class changes, need to change only cpp file of interface class but not clients.
o How about <subclassing> impl. class to have other impls? Seems okay.


<stl-case-example>

STL uses this approach: Two header files.

< iosfwd > has declaration only
< sstream > < streambuf > < fstream > < iostream > are all implementation files

note:
o Further study to look into STL?
o What is the relation between person and personimpl? implemented-in-terms-of?


{interface-class} 

Similar to JAVA's interface but C++ one can have data or func implementation. Use ABC and interface
class can have only interfaces or interface and default implementation.

class Person {                     	# class IPerson
	public:
	 virtual ~Person();					# see 'virtual'
	 virtual std::string name() const = 0; 
	 virtual std::string birthDate() const = 0; 
	 virtual std::string address() const = 0; 
	 ...
	 // factory-func *kt_dev_stl_018*
	 'static' std::shared_ptr< Person > create(
	 	const std::string& name, const Date& birthday, const Address& address);
};


std::shared_ptr< Person > Person::create(...)
{
	 return std::shared_ptr< Person > ( new RealPerson (...) );    # <create-and-set-impl>
}


// implementation
//
class RealPerson: public Person {  # public IPerson
	 private:
	 std::string theName;                            # <has-implementation-details>
	 Date theBirthDate;

	 public:
	 RealPerson(...): ... {}
	 virtual ~RealPerson() {}
	 virtual std::string name() const;
	 ... same interface
};


Then client use pointer or reference because ABC cannot create an object.

std::shared_ptr< Person > pp ( Person::create(...) );

<summary>

(client)  (interface class)   
(client)		interface: virtuals
... 			factory-function 
				ptr to impl      

			(subclassing) 
				real implementation : use other classes

o Like pimpl idiom, no interface change and can force class interface to derived class.
o Used subclassing.
o Like pimpl idiom, seperated implementation. When implementation, derived class, changes, no need
to compile clients. But re-link.

IPerson::create( RealPersonX )
 |
 |-return new RealPersonX or
 |-return new RealPersonY
 |-...
 |-return new RealPersonZ


{factory-func-pattern} {creational-pattern}

The factory-function plays the role of the ctor for the derived classes that are actually created.
Hence called [virtual-constructor]

<why-factory>

This is about a method but not a class. 

Pros:
o Separation. No code to create in the client and move it into factory-func. 
o Defer decision on what to create: create in the base such as parameterized factory-func or to
defer creation to subclass, so any product class in the tree. This subclassing often used in
framework since no need to make changes in framework.

Cons:
o Client should subclass to use specific product class.


<static-vs-virtual-factory-func>

The static-factory-func has efficient code because no virtual cost and has single point to access
but hard-wired to choose classes to create. Have to change it when the choice to create changes. As
shown in *kt_dev_cpp_030* static-factory-func is in the user class in a tree.

The virtual-factory-func has bigger code but subclassing can change class to create. So useful for
framework that cannot be changed. When factory-func is on the creator tree and uses virtual func:
pure virtual or virtual which as default implementation. Let client decide which class to create
using subclassing, application specific document, to create(manufacture) and defer instantiation to
subclass which is out of framework.


(client)                 (creator class, Application)           (product class, Document)       
-----------------------  ------------------------------------   ------------------------- 
Creator.NewDoc();        // factory-func.
                         // set impl in factory func.
								 //
                         'virtual' CreateDoc() = 0;
                         'virtual' CreateDoc();

								 NewDoc()                                Open();
								 { pDoc = CreateDoc(); pDoc->Open(); }

                         (subclass)                              (subclass)
								 -------------------------------------   -------------------------
								 WordApplication, DrawApplicaion, ...    WordDoc, DrawDoc, ...
								 'virtual' CreateDoc()
								 { return new WordDoc; }
								 { return new DrawDoc; }

note: This can be used in parallel class implementation. See design pattern book for more.

<virtual-factory-func> sample-code-from-design-pattern

The previous has hard-codes for classes to create:

Maze* MazeGame::CreateMaze() {
	 Maze* aMaze = new Maze;
	 Room* r1 = new Room(1);
	 Room* r2 = new Room(2);
	 Door* theDoor = new Door(r1, r2);

	 aMaze->AddRoom(r1);
	 ...
	 return aMaze;
}

This is revised to use factory which shows how framework works. The frameworks has all logics and
user implements interfaces as flatfrom defines and creats instance.

class MazeGame {
	 public:
	 Maze* CreateMaze();

	 // factory-funcs
	 virtual Maze* MakeMaze() const { return new Maze; }
	 virtual Room* MakeRoom( int n ) const { return new Room(n); }
	 virtual Wall* MakeWall(...);
	 virtual Door* MakeDoor(...);
};

Maze* MazeGame::CreateMaze() {
	 Maze* aMaze = MakeMaze();

	 Room* r1 = MakeRoom(1); Room* r2 = MakeRoom(2);
	 Door* theDoor = MakeDoor( r1, r2 );

	 aMaze->AddRoom(r1); aMaze->AddRoom(r2);
	 ...
	 return aMaze;
};

class BombedMazeGame : public MazeGame {
	 public:
	 virtual Wall* MakeWall() const { return new BombedWall; }
	 virtual Room* MakeRoom(int n) const { return new RoomWithABomb(n); }
};

class EnchantedMazeGame : public MazeGame {
	 public:
	 virtual Wall* MakeDoor() const { return new DoorNeedingSpell; }
	 virtual Room* MakeRoom(int n) const { return new EnchantedRoom(n); }
};

BombedMazeGame bombMaze;             	// BombedMazeGame
Maze* pMaze = bombMaze.CreateMaze();	// [KT] client know what to create
pMaze->func();

When CreateMaze is called, will use redefined factory-funcs to create application specific class.
See {template-pattern} for this way to use virtual.


<non-member-factory-func> <parameterized-factory-func>

Realistic examples may support different derived class to create using additional params, file, DB
or env var. See factory-pattern in design pattern book for an example of env. use. 

// example-one

From EC++40. Use id to select different concrete class and non-member factory-func and conditional
switch in it.

std::shared_ptr< IPerson > makePerson( DatabaseID personID );

DatabaseID id(askUserForDatabaseID());
std::shared_ptr< IPerson > pp ( makePerson(id) );

pp->name();
pp->birthDate();


// example-two. From design pattern 

class Creator {
	 public:
	 virtual Product* Create( ProductId );
};

Product* Creator::Create( ProductId id )
{
	 if( id == MINE ) return new MyProduct;
	 if( id == YOURS ) return new YourProduct;

	 return 0;
};

Product* MyCreator::Create( ProductId id )
{
	 if( id == YOURS ) return new MyProduct;       # note: changed ids
	 if( id == MINE ) return new YourProduct;

	 if( id == THEIRS ) return new TheirProduct;   # extented

	 return Creator::Create(id);                   # fall back on base class for otheres.
};


{on-disk-representation-factory-func}

From MEC++25. Creating objects from reading disk and there should be type to create in disk.

class NLComponents {
	 public:
	 ...
};

class TextBook : public NLComponents {
	 public:
	 ...
};

class Graphic : public NLComponents {
	 public:
	 ...
};

class NewsLetter {
	 public:
	 ...
	 private:
	 list< NLComponents* > components;
	 static NLComponents* readComponent( istream& str );      // <static-factory-func>
};

NewsLetter::NewsLetter( istream& str )
{
	 while( str ) {
		  components.push_back( readComponent( str ) );
	 }
}


{virtual-copy-constructor}

Two things to note here:

o return type can be different in virtual funcs. See {return-type-in-overrides}

o clone simply use real copy ctor and means it follows the same whether it is deep or shallow copy.

class NLComponent {
	 public:
	 	virtual NLComponent* clone() const = 0;
		...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual TextBlock* clone() const
		{ return new TextBlock(*this); }
		...
};

class Graphic : public NLComponent {
	 public:
	 	virtual Graphic* clone() const
		{ return new Graphic(*this); }
		...
};

class NewsLetter {
	 public:
	 	NewsLetter( const NewsLetter& rhs );
		...

	 private:
	 	list< NLComponents* > components;
};

NewsLetter::NewsLetter( const NewsLetter& rhs )
{
	 for( list< NLComponent* >::const_iterator it = rhs.components.begin();
	 	it != rhs.components.end(); ++it )
	 {
		  components.push_back( (*it)->clone() );
	 }
}

Why virtual copy ctor? This copies whatever the pointer really points to, that is calls type
dependant clone. If copying list is allowed this means copying pointers, not real objects. So this
is useful to implement deep copying.

Q: Can copy list?


{virtual-acting-non-member-func}

To have different output for different object? Can use virtual? That means member func.

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& operator<<( ostream& str ) const;
		...
};

TextBlock t; Graphic g;

t << cout; g << cout;

For usual syntax, must use non-member but then cannot use virtual. See kt_dev_cpp_021 for why it
must be non-member. How to solve?

class NLComponent {
	 public:
	 virtual ostream& print( ostream& os ) const = 0;
	 ...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& print( ostream& os ) const;
};

inline ostream& operator<<( ostream& os, const NLComponent& c )
{ return c.print(os); }

Used virtual mecanism on the second arg since it is reference.


{more-things-from-design-pattern}

o In C++, always use virtual. [KT] How about static func?
o Not to call factory-func which is virtual in the creator's ctor. see *kt_dev_ecpp_003* 

Create the product on demand and use <lazy-initialization>. 

class Creator {
	 public:
	 Product* GetProduct();            # accessor

	 protected:
	 virtual Product* CreateProduct(); # factory-func

	 private:
	 Product* _product;
};

Product* Creator::GetProduct() {
	 if(_product == 0) {
		  _product = CreateProduct();
	 }
	 return _product;
}

o Can use template instead of subclassing. For example,

class Creator {
	 public:
	 virtual Product* CreateProcut() = 0;
};

template <class T>
class StandardCreator : public Creator {
	 public:
	 virtual Product* CreateProduct();
};

template <class T>
Product* StandardCreator< T >::CreateProduct() {
	 return new T;
};

o Use naming convention for factory-funcs.
For MacApp framework example, class* DoMakeClass() where Class is the product class. 


==============================================================================
*kt_dev_ecpp_009*	: 32: public inheritance. is-a model

Public inheritance means is-a. 

Derived is Base. Base represent a more general concept than Derived, that Derived represent a more
specialised concept. Can use Derived where Base can be used. Anything that is true of Base is also
true of Derived.

"Base represent a more general concept than Derived, that Derived represent a more specialised
concept."

Usually general means bigger set but not in C++ which is smaller: The derived is bigger. Here
'general' means the common part, is-a. Think a model which is wrong:

Rectangle <- Square

But the score is opposite: the derived is nested in the base.

CodeComplete(p144): LSP (Liskov Substitution Principle)
All the routines defined in the base class should mean the same thing when they are used in each of
derived classes. semantic meaning. reduce complexity. 


==============================================================================
*kt_dev_ecpp_010*	34: interface and implementation inheritance

(EC++34)
When design classes, should think <three> separately.

1) Pure virtual (abstract). To have 'only' interface inherited. interface inheritence. 

2) (Simple) virtual (overridable). To have interface and 'default' implementation.

To be careful about that 'default' impl is inherited without request from the derived.  can be a
problem when the derived forgot to redefine it.

class Airplane {
	 public:
	 virtual void fly( const Airport& destination );
	 ...
};

void Airplane::fly( ... )
{
	 code for usual plane type. default.
}

class ModelA : public Airplane { ... };
class ModelB : public Airplane { ... };

class ModelC : public Airplane { ... };

Here it's okay for model A and B but not C because C is different type of plane that has different
way to fly and should have defined own fly(). If it's missed to redefine own, it will use the
default. Error. For early error detection, can use following approaches which force the derived
explicitly request implementation:


{approach-one}

class Airplane {
	 public: >
	 virtual void fly( const Airport& destination ) = 0; // make a pure
	 ...
	 protected:
	 void defaultFly( ... );
<
};

void Airplane::defaultFly( ... )
{
	 code for usual plane type. default.
}

class ModelA : public Airplane {
	 public:
	 virtual void fly( ... )  
 	 	{ defaultFly( ... ); }		// explicit
};

class ModelC : public Airplane {
	 public:
	 virtual void fly( ... )
	 { specific code for model C type }
};

If forget to redefine ModelC::fly then will get errors in compile time because cannot create ModelC
objects. it's ABC.


{approach-two}: use the fact that pure virtual can have its impl.

class Airplane {
	 public: >
	 virtual void fly( const Airport& destination ) = 0; // make a pure
	 ...
<
};

void Airplane::fly( ... )
{
	 code for usual plane type. default.
}

class ModelA : public Airplane {
	 public:
	 virtual void fly( ... )  
 	 	{ Airplance::fly( ... ); }		// explicit
};


3) Non-virtual (non-overridable). invariant over specialization. To have interface and 'mandatory'
implementation that is default implementation but not overridable. 

KT. This suggests the less use of simple virtual?


==============================================================================
*kt_dev_ecpp_011*	35: alternatives to virtual func

{template-pattern} 
From {ref-003}, it is called [template-method] and define skeleton of an algorithm in an operation,

o deferring [some] steps to subclass ( without default implementation of some steps ). must be
overridden.

o letting subclass redefine certain steps ( with default implementation ). may be overridden.
{hook-operation}

Without chaning the algorithm's structure. The template-method defines steps in terms of abstract
operations that subclass override to provide concrete behavior. Or it is to define {invariant-parts}
once and leave {variant-part} to subclass.

What is different from when common behavior among subclasses should be factored and localized in a
common class to avoid code duplication? This is also about code resuse but difference is steps, that
is template.

void Application::OpenDocument( const char* name ) {
	 if( !CanOpenDocument(name)) {
		  // cannot handle this document
		  return;
	 }

	 Document* doc = DoCreateDocument(); // {factory-func}

	 if(doc) {
		  _docs->AddDocument(doc);
		  AboutToOpenDocument(doc);
		  doc->Open();
		  doc->DoRead();
	 }
}


AbstractClass: (Don't call us, we'll call you)
 TemplateMethod
 { PrimitiveOperation1(); PrimitiveOperation2(); }

 PrimitiveOperation1(); 
 PrimitiveOperation2();

ConcreteClass:
 PrimitiveOperation1(); 
 PrimitiveOperation2();


EC++35. In the following example, different character may calculate their health in different ways.
Using virtual is obivious? This is alternatives to usual virtual design. Called as NVI(non-virtual
interface) idiom as a public non-virtual in the base call a private virtual func that can be
redefined but it's little more than window dressing as still use virtuals.

There are how and when: how is to redefine virtual funcs and when is the time to call this. This
template-method means that base controls when and derived control how.

class GameCharacter {
  public:
    int healthValue() const
    {
      // do 'before' stuff 
      int retVal = doHealthValue();
      // do 'after' stuff
    }

  private:     // [DN] See this is private and {text-query-example}
    virtual int doHealthValue() const
    {
      // default calc code
    }
};

In the base, set before and after stuff and when to call the derived part that is the derived
dependent. Before and after can be lock/unlock, logging, pre/post condition.


{name-and-related}
For a naming convention of primitive operation which should be overridden, prefix names with Do:
DoRead. Often used with {factory-func} as DoCreateDocument shown above. KT: Do prefix seems to
mean a func to be overridden.


{access-specifier}
#include < iostream>

using std::cout;
using std::endl;

class Base {
	public:
		Base()
		{ cout << "bas: this is ctor" << endl; }

		void doCalc()
		{
			cout << "bas: doCalc" << endl;
			doMorePub();
			doMorePri();
			doMorePro();
			cout << "bas: called doMore" << endl;
		}

		virtual void doMorePub()
		{
			cout << "bas: doMorePub" << endl;
		}

	private:
		virtual void doMorePri()
		{
			cout << "bas: doMorePri" << endl;
		}

	protected:
		virtual void doMorePro()
		{
			cout << "bas: doMorePro" << endl;
		}
};

class Derived : public Base {
	public:
		Derived() 
		{ cout << "der: this is ctor" << endl; }

		virtual void doMorePub()
		{
			cout << "der: doMorePub" << endl;
		}

	private:
		virtual void doMorePri()
		{
			// [error] Base::doMorePri();
			cout << "der: doMorePri" << endl;
		}

	protected:
		virtual void doMorePro()
		{
			cout << "der: doMorePro" << endl;
		}
		
};

 
int main(int argc, char** argv)
{
	Derived drv;

	drv.doCalc();

	cout << "end of main" << endl;
}

kit@kit-vb:~/work$ ./a.out 
bas: this is ctor
der: this is ctor
bas: doCalc
der: doMorePub
der: doMorePri
der: doMorePro
bas: called doMore
kit@kit-vb:~/work$ 

As {text-query-example}, the Do operation which to be overrided, should be protected or private?
Here, access-specifier do not work in derived class since virtuals get called even if these are
private in derived calss but when speified like [error], will get

usetemppattern.cpp: In member function 'virtual void Derived::doMorePri()':
usetemppattern.cpp:26:16: error: 'virtual void Base::doMorePri()' is private
usetemppattern.cpp:51:20: error: within this context

This is why it matters for hook-operation. This access-specifier is for user client and
hook-operation. This means that it is like {bitwise-const} as compiler picks up physical things.
Also can think it as indirection involved because uses vptr because: See {how-vtable-works} and
because it is in Derived class context.

vtable
[1] Derived.doCalc : Base.doCalc
[2] Drrived.doMore : Derived.doMore


{hook-operation}
The template-method can be used to extend parent class operation but not a class. 

class Window {
	 public:
	 virtual void onResize() { ... }
	 ...
};

class SpecialWindow : public Window {
	 public:
	 virtual void onResize() {
		  Window::onResize();
		  // additional to the derived
	 }
	 ...
};

But it is esay to forget to call the inherited function and can use template-method to give the
parent class a control over how subclasses extend it. {Q}

void ParentClass::Operation() {
	 // parent class behavior
	 HookOperation();
}

void ParentClass::HookOperation() { }

void DerivedClass::HookOperation() {
	 // derived class extension
}


{strategy-pattern}
Use no virtual. take the real calc func out of the class.

# 01 : use func pointer

class GameCharacter;

int defaultHealthCalc( const GameCharacter& gc );

class GameCharacter {
	 public:

	 typedef int(*HealthCalcFunc)(const GameCharacter&);

	 explicit GameCharacter( HealthCalcFunc hcf = defaultHealthCalc )
	 : healthFunc(hcf) {}

	 int healthValue() const
	 { return healthFunc(*this); }
	 ...

	 private:
	 HealthCalcFunc healthFunc;
};

Provide flexibilities than virual:

1) Each instance(object) of the same type can have different calc func. 
2) Can change the calc func at runtime.

One downside is that should weaken encapsulation when need access to non-public part of
class to calc. Like make it a friend or offer more public funcs that are private
otherwise.


# 02 : use tr1::function

class GameCharacter {
	 public:

	 typedef std::tr1::function<int(const GameCharacter&)>HealthCalcFunc;
	 ...
};

tr1::function is <generalized-pointer-to-a-function> and allow us to use any compatible
callable entities such as function object, member funcs, and funcs with different return
type. see {function-object} *kt_dev_cpp_021*


# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...

hierarchy 02:

class HealthCalcFunc {
	 public:
	 virtual int calc( const GameCharacter& gc ) const { ... }
	 ...
};

HealthCalcFunc defaultHealthCalc;

class GameCharacter {
	 public:
	 explicit GameCharacter( HealthCalcFunc* phcf = &defaultHealthCalc )
	 : pHealthCalc( phcf ) {}

	 int healthValue() const
	 { return pHealthCalc->calc(*this); }
	 ...

	 private:
	 HealthCalcFunc* pHealthCalc;
};

Can add/change calc func later because can have the drived classes in separate hierarchy.


==============================================================================
*kt_dev_ecpp_012*	: composition. has-a model 

Two types of composition(aggregation): has-a and is-implemented-in-terms-of model.

{has-a-model}

This kind of objects are in application domain.

class Person {
	 public:
	 ...
	 private: >
	 std::string name;
	 Address address;
	 PhoneNumber voiceNumber;
	 PhoneNumber faxNumber;
};


{is-implemented-in-terms-of}

Assume need to implement template class that is like set but should use less space so can we use
std::set? it is fast but has space overhead. Then can we use std::list instead? But cannot use
public inheritance as it is is-a model. So can be implemented by using it:

This kind of objects are in implementation domain.

template<class T>
class Set {
	 public:
	 bool member( ... ) const;
	 void insert( ... );
	 void remove( ... );
	 std::size_t size() const;

	 private: >
	 std::list< T > rep;
};

template<typename T>
void Set<T >::insert( ... )
{
	 if( !member(item) ) rep.push_back(item);
}


{private-inheritance}

class Student: private Person { ... };

void eat( const Person& p );

Person p; Student s;

eat(p);
eat(s);	// error which is different to the public inheritance case

So private inheritance is implementation inheritance; impelementation only but not interface. Then when
use either private inheritance or is-implemented? EC recommends is-implemented over private
inheritance.

Assume Widget class needs to keep track of how many times each member func is called and
periodically examine the information.

class Timer {
	 public:
	 explicit Timer( int tickFrequency );
	 virtual void onTick() const;
};

class Widget : public Timer { ... };

No as Wideet is not a timer. So

class Widget : private Timer {
	 private:
	 virtual void onTick() const;
	 ...
};

<OR>

Can use private nested class.

class Widget {
	 private:

	 class WidgetTimer: public Timer {
		  public:
		  virtual void onTick() const;
		  ...
	 };

	 WidgetTimer timer;
	 ...
};


Three resons why prefer other compositions over private:

1) when derive class from Widget but want the derived do not redefine onTick. Not possible private
inheritance. (KT can use final keyword as of now)

2) to minimize compilation dependency as Timer's definition must be available if use inheritance.
But if Widget use a pointer to WidgetTimer, no need to include.
 
3) eaiser to understand.

KT. Use private when need to access protected area of the base and to redefine virtual functions.
Know that other composition comes with greater design complexity.

CodeComplete(p143) PI violates encapsulation and tends to point to design errors that should be resolved.


==============================================================================
*kt_dev_ecpp_013*	22: data member must be private

(EC++#22)

Interface has only member funcs. The pros:

1) syntactically uniform access(consistency)
2) fine-grained access control. read-only. write-only. etc.
3) encapsulation.
Public means un-encapsulated, un-changeable.


==============================================================================
*kt_dev_ecpp_014*	27: minimize casting

(EC++#27)

The need for dynamic cast arises when want to use derived class ops on what you believe to be a
derived class objects via base pointer or ref. To avoid this, two approaches:

Problem:

class Window { ... };
class SpecialWindow: public Window {
	 public:
	 void blink();
};

typedef std::vector< std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
	 if( SpecialWindow *psw = dynamic_cast<SpecialWindow*> (iter->get()))
		  psw->blink();
}

{solution-one}

typedef std::vector< std::shared_ptr<SpecialWindow>> VPW;

But, do not support all possible window derivatives.


{solution-two}

Use virtual mechanism. 

class Window {
	 public:
	 virtual void blink() {}     
	 # default impl is no-op. See *kt_dev_ecpp_010* for why it can be a bad idea
};

class SpecialWindow : public Window {
	 public:
	 virtual void blink() { ... }
};


{named-cast}

From MEC++02. Casts in CPP provides:

o easier-to-recognise style. There is no error or warning from the compiler because we explicitly
said the conversion was okay.
o precision of meaning

Four types:

<const_cast>
This is not just about const away and see {const-non-const-version} for more.

<static_cast> 
like C

<reinterpret_cast>

Peforms a low-level reinterpretation of the bit pattern of its operands.

int *p;
char *pc = reinterpret_cast<char*>(ip);

# ?? difference to static_cast? took func pointer example. 

<dynamic_cast>      # RTTI

Can check the result of cast; nullprt for pointer and bad_cast for reference. Used in inheritance;
derived-to-base by compiler and base-to-derived by dynamic_cast. Cast down and accross.


==============================================================================
*kt_dev_ecpp_015*	30: ins and outs of inlining 

Minimize the use of inline and this provides:

1) debugging
2) binary upgradability ( think when changes ininline func. all clients should be recompiled. )

Do not inline ctor and dtor. why?

If an exception is thrown druing ctor, any parts of the object that have already been fully
constructed are destroyed. C++ spec says but do not say how. It is down to compiler implementation.
So some code written and inserted into during compilation. These can be big enough not to use
inline. So do not use inline for ctor and dtor.

class Derived: public Base {
	 public:
	 Derived() {}       # is empty - or is it?
	 ...
};


# ============================================================================
#{

==============================================================================
*kt_dev_mecpp_001* 16: 80-20 rule and profiler

Think about characteristics of your app such as IO-bound or CPU-bound. If a profiler tells you about
only the number of statments and func calls, then these can give you some insight but not enough.
The important thing is the time to wait. The input to profiler should represent 20%, called
<representative>, and use as many data set as possible. 


==============================================================================
*kt_dev_mecpp_002* 17: lazy evaluation

When you employ lazy evaluation, you write your classes in such a way that they defer computations
until the results of those computations are required. If the results are never required, the
computations are never performed.

Nevertheless, it's not always a good idea.  Lazy evaluation is only useful when there's a reasonable
chance your software will be asked to perform computations that can be avoided.

Yet C++ is particularly suitable as a vehicle for user-implemented lazy evaluation, because its
support for <encapsulation> makes it possible to add lazy evaluation to a class without clients of
that class knowing it's been done. 

That means it's possible to implement a class using a straightforward eager evaluation strategy, but
then, if your profiling investigations (see Item 16) show that class's implementation is a
performance bottleneck, you can replace its implementation with one based on lazy evaluation.


Four examples and one in *kt_dev_ecpp_006*	

{reference-counting}

class String { ... };

String s1 = "Hello";
String s2 = s1;

Such a copy constructor would incur a relatively large expense, because it would have to make a copy
of s1's value to give to s2, and that would typically entail allocating heap memory via the new
operator and calling strcpy to copy the data in s1 into the memory allocated by s2. This is eager
evaluation.

But s2 hasn't been used yet.

The lazy approach is a lot less work. Instead of giving s2 a copy of s1's value, we have s2 share
s1's value. Need some book-keeping and is transparent to clients: do not know difference.

Because they only read values, not write them. 

cout << s1;            // read s1's value
cout << s1 + s2;       // read s1's and s2's values

In fact, the only time the sharing of values makes a difference is when one or the other string is
modified;

s2.convertToUpperCase();

Inside convertToUpperCase, we can be lazy no longer: we have to make a copy of s2's (shared) value
for s2's private use.


{distinguish-read-and-write}

By using lazy evaluation and proxy classes as described in Item 30, however, we can defer the
decision on whether to take read actions or write actions until we can determine which is correct.


{lazy-fetching}

Imagine large objects containing many constituent fields which can be expensive to get from
database, even worse remote database. To restore a LargeObject is quite expensive.

class LargeObject {                   // large persistent objects
public:
	 LargeObject(ObjectID id);         // restore object from disk
	 const string& field1() const;     // value of field 1
	 int field2() const;               // value of field 2
	 double field3() const;            // ...
	 const string& field4() const;
	 const string& field5() const;
...
};

If need few fields like below,

void restoreAndProcessObject(ObjectID id)
{
	LargeObject object(id);

	if (object.field2() == 0) 
	{
	 	cout << "Object " << id << ": null field2.\n";
	}
}

Data is retrieved from the database only when that particular data is needed inside the object.
Here's one way to implement this kind of <demand-paged-object-initialization>

class LargeObject {
public:
	 LargeObject(ObjectID id);
	 const string& field1() const;
	 int field2() const;
	 double field3() const;
	 const string& field4() const;
	 ...
	 private:
	 ObjectID oid;
	 mutable string *field1Value;  // see below for a
	 mutable int *field2Value;     // discussion of "mutable"
	 mutable double *field3Value;
	 mutable string *field4Value;
	 ...
};

LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), ...
{}

const string& LargeObject::field1() const
{
	 if (field1Value == 0) {
		  read the data for field 1 from the database and make
		  field1Value point to it;
	 }
	 return *field1Value;
}

Null pointers signify fields that have not yet been read from the database. Each LargeObject member
function must check the state of a field's pointer before accessing the data it points to.


The problem that null pointers may need to be initialized to point to real data from inside any
member function. So need mutable keyword. <mutable-example>

NOTE: can use smart-pointer in item28

Refer to <lazy-initialisation>.



{lazy-expression-evaluation}

For numerical application.

template<class T>
class Matrix { ... }; // for homogeneous matrices

Matrix< int> m1(1000, 1000); // a 1000 by 1000 matrix
Matrix< int> m2(1000, 1000); // ditto
...

Matrix< int> m3 = m1 + m2; // add m1 and m2

Lazy evaluation strategy: Instead, it sets up a data structure inside m3 that indicates that m3's
value is the sum of m1 and m2. Such a data structure might consist of nothing more than a pointer to
each of m1 and m2, plus an enum indicating that the operation on them is addition.

Matrix< int> m4(1000, 1000);
... // give m4 some values
m3 = m4 * m1;

We can forget all about m3 being the sum of m1 and m2 (and thereby save the cost of the
computation),

A more common scenario is that we need only part of a computation. For example, suppose we use m3 as
follows after initializing it to the sum of m1 and m2:

cout << m3[4]; // print the 4th row of m3

Clearly we can be completely lazy no longer. But there's no reason we have to compute any more than
the fourth row of m3; the remainder of m3 can remain uncomputed until it's actually needed.

To be fair, laziness sometimes fails to pay off.

m3 = m1 + m2;  // remember that m3 is the sum of m1 and m2
m1 = m4;       // now m3 is the sum of m2 and the OLD value of m1!


Because of the need to store dependencies between values; to maintain data structures that can store
values, dependencies, or a combination of the two; and to overload operators like assignment,
copying, and addition, lazy evaluation in a numerical domain is a lot of work. 

KT. Need to understand expression like a compiler and need to see if it pays off.


==============================================================================
*kt_dev_mecpp_003* 18: over-eager evaluation

The idea behind over-eager evaluation is that if you expect a computation to be requested
frequently, you can lower the average cost per request by designing your data structures to handle
the requests especially efficiently.

<caching> and <prefetching> are examples. 

{space-and-time-trade-off}

that's that greater speed can often be purchased at a cost of increased memory usage.


{lazy-or-eager}

Lazy and eager are not contradictory to each other.

Lazy evaluation is a technique for improving the efficiency of programs when you must support
operations whose results are not always needed. Over-eager evaluation is a technique for improving
the efficiency of programs when you must support operations whose results are almost always needed
or whose results are often needed more than once.

both can yield significant performance improvements in programs whose behavioral characteristics
justify the extra programming effort.


==============================================================================
*kt_dev_mecpp_004* 24: virtual cost

{vtable-internal}

Every class which has virtual func has [vtable] which is a table of func ptr. So vtable for a class
and vptr for a instance. If one is overridden in derived, derived's vtable gets updated to point to
derived version.

Class1 (base)  <- Class2 (derived)

vtable            vtable
[1] -> C1::f2     [1] -> C2::f2  [virtual]
[2] -> C1::f1     [2] -> C1::f1  [non-virtual]


{first-cost}

Size cost of vtable per class and the number of entry as many as the number of virtual funcs.

{second-cost}

Size cost of vptr which links between objects which are of the same class and 'single' vtable.

| ------ |
| object |
| ------ |
| vptr   |	-> vtable
| ------ |

{third-cost}

Virtual func must not be inline because inline is done at compile time but virtual is dynamic. See
*kt_dev_ecpp_015* for more.


{how-vtable-works}

makeCall(C1* pC1)
{
	 pC1->f1();
}

Which one? C1::f1() or C2::f1()? pC1 can be really either C1, base or C2, derived.

<0> KT. some code to get dynamic type by compiler? dynamic-binding.
<1> get vptr of this object
<2> get vtable via vptr
<3> call a func from vtable entry

When the index of a func is i, effecitve code is:

pC1->f1(); -> (*pC1->vptr[i])(pC1);       // (pC1) becomes this pointer


{performance-cost}

Therefore there is a little performance impact due to virtual func calls but in size. In
inheritance, vtable mechanism gets more complicated. lots of vptrs for objects, vtables for classes.
There is a special vtable for base classes. Hence more cost.


{RTTI-and-vtable}

RTTI can discover info about object and class at run-time. How? That information is stored in an
object of type type_info, and you can access the type_info object for a class by using the typeid
operator. There is a single copy for a class. Typical implementation is:

vtable       
[0] -> type_info
[1] -> C1::f2  
[2] -> C1::f1 

{Q} does it mean each object has a type_infor and vptr as well.


==============================================================================
*kt_dev_mecpp_005* 29: reference-counting

See {own-reference-counting} for simple example. This chapter is about how to implement sharing
underlying object like stl string class.

Two motivations:

o To simplify the bookkeeping 'who is allowed to delete what'. simple form of garbage collection.
smart pointer is an example. This is what most uses.

o To share underlying objects. efficiency since use same memory and runs fast on assumption that
object will share values.


{summary}

This is optimization technique. When useful because reference-counting costs more moeny, code,
complex and work.

o For cases when objects are big and there are many sharings. More memory to save.
o For cases when there are many copy and assign between objects. More time to save.

Need profiling. However, there is a case which cannot use this technique: data structures using
self-reference which causes isolated collection of objects and reference count never drops to zero.
Therfore, industrial garbage collectors use special technique to find these.


{what-problem-to-solve}

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		char* data;
};

// handles self-assign but not exception safe
String& String::operator=( const String& rhs )
{
	 if( this == &rhs ) return *this;

	 delete[] data;
	 data = new char[ strlen(rhs.dat) +1 ];
	 strcpy( data, rhs.data );
	 return *this;
}

Use:

Sring a, b, c, d;
a = b = c = d = "Hello";

This means:

a -> "Hello"
b -> "Hello"
c -> "Hello"
d -> "Hello"

How can we make those share one copy of Hello?


{approach-one}

Have a reference count out of object. Why out of object? Because count per value but not per object.

a -> 4 -> "Hello"
b 
c
d 

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1) # <default-1>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

String::StringValue::~StringValue()
{
	 delete [] data;
}

Why private nested class? Because to make only String has a full access of it.


{{ctor-one}}

String::String( const char* initValue ) : value( new StringValue( initValue )) {}

Use:

String s("Hello");

s -> 1 -> "Hello"

But cannot avoid duplication:

String s1("Hello");
String s2("Hello");

s1 -> 1 -> "Hello"
s2 -> 1 -> "Hello"

Solution is to create new one only when it is unique string and leave it for further study.


{{ctor-two}}

// String S1(S2);
//
String::String( const String& rhs ) : value( rhs.value )
{
	 ++value->refCount;
}

String::~String()
{
	 if( --value->refCount == 0 ) delete value;
}

// S1 = S2; reference count of S1 is decresed by one and S2 is increased by one
//
String& String::operator=( const String& rhs )
{
	 if( value == rhs.value ) return *this;

	 if( --value->refCount == 0 ) delete value;

	 value = rhs.value;
	 ++value->refCount;

	 return *this;
}


See efficiency here since there is no alloc, free, and copy.


{{copy-on-write}}

class String {
	 const char& operator[] (int index) const;
	 char& operator[] (int index);
	 ...
};

const version is read-only so that is okay. If want to separate read and write for non-const, that
is to create new object only when writing. How?

cout << s[3];     // read 
s[5] = 'x';       // write

Not possible to separate. This separation could be done using proxy class, MEC++ 30, so now assume
all non-const as write.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}

	return value->data[index];
}

This if-block works only when there is sharing before and create new one only when writing happens.
So this is copy-on-write and the example of {lazy-evaluation}


{{sharable}}

However, there are cases not covered:

String s1 = "Hello";
char* p = &s1[1];

String s2 = s1;
*p = 'x';                // change s1 and s2 as well


s1 -> 2 -> "Hello"
s2 -> 

note: how about stl string class? possible?


The problem is to change underlying object not through String interface. See *kt_dev_ecpp_007* for
returning handles to internal objects.

How to solve?

o Ignore this problem
o Hava a shareable flag in which to create new object when tries to change from outside. This is
waht stl string uses. This is ON by default, operator[] turn it OFF, and cannot change it once it is
OFF. Kind of dirty flag.

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 >
			 bool sharable;
<
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1), sharable(true) # <default>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

There should be a check in member funcs.

String::String( const String& rhs )
{ >
	 if( rhs.value->sharable ) {
<		  value = rhs.value;
		  ++value->refCount;
	 }
	 else {
		  value = new StringValue( rhs.value->data );
	 }
}

Assume that returning from this call means someone outside will have a reference to internal so make
it non-sharable always.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}
>
	value->sharable = false;
<
	return value->data[index];
}

For example:

String s1 = s2 = s3 = "Hello";

s1 -> 3 -> "Hello"
s2 -> 
s3 ->

s3[3] = 'x';

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"

String s4(s3);

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"
s4 -> 1 -> "Hello"


{{make-base-class-for-reference-counting}}

To make this reference counting available to any other class, so make it base class. note there is
no data in this class.

class RCObject {
	 public:
	 	RCObject();
		RCObject( const RCObject& rhs );
		virtual ~RCObject() = 0;

		RCObject& operator= ( const RCObject& rhs );

		... public interface
		addReference();

	private:
		size_t refCount;
		bool sharable;
};


The pure virtual means it must be used as a base class.

See ctor and copy ctor in setting refCount as 0 because it simplfies thing for the client to set
refCount to 1. copy ctor always set refCount to 0 because creating a new value and new value are
always unshared and referenced only by their creator.

RCObject::RCObject(): refCount(0), sharable(true) {}
RCObject::RCObject(const RCObject&): refCount(0), sharable(true) {}

RCObject::~RCObject() {}     # see {pure-virtual-dtor}

Copy assign do nothing and will not be used in reality because it is a base class for a shared value
object(StringValue) which are not assigned to one another. Only String do. {{why-need}} It said it
is for future use but seems not useful to consider since do nothing about refCount.

RCObject& RCObject::operator=( const RCObject& )
{ return *this;}

note: Really need copy ctor and copy assign?

<delete-this> is safe only if *this is a heap object.

void RCObject::removeReference()
{
	 if(--refCount == 0 ) delete this;   # <delete-this>
}

void RCObject::addReference() { ++refCount; }


class String {
	 private:
	 	struct StringValue : public RCObject {    # <public-inheritance>
			 char* data;                           # <data>
			 StringValue( const char* initValue );
			 ~StringValue();
		};
		...
};

String::StringValue::StringValue(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
	 delete [] data;
}


          RCObject: has reference-counting feature
			 |
String -> StringValue -> data

StringValue is almost the same but now StringValue do not manipulate refCount and RCObject has. But
String should call explicitly interfaces to manage refCount. It is clumsy because String must call
these to manage reference counting. can we make it done automatically? move it out of user class?

If can detect access to StringValue through pointer, it could. This is objcet which acts like a
pointer such as smart pointer and which support member selection(->) and dereferencing(*). 


This template gives smart pointer objects control over what happens during their construction,
assignment, and destruction. When such <events> occur, this object can automatically perform the
appropriate manipulations of the refCount field in the objects to which they point.


template<class T>
class RCPtr {
public:
	RCPtr(T* realPtr = 0);
	RCPtr(const RCPtr& rhs);
	~RCPtr();
	RCPtr& operator=(const RCPtr& rhs);
	T* operator->() const; // see Item 28
	T& operator*() const;  // see Item 28
private:
	T *pointee;  // dumb pointer this object is emulating
	void init(); // common initialization code
}; 

template<class T>
RCPtr< T>::RCPtr(T* realPtr): pointee(realPtr)
{
	init();
}

template<class T>
RCPtr< T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)
{
	init();
}

template<class T>
void RCPtr< T>::init()
{
	// if the dumb pointer is null, so is the smart one
	if (pointee == 0) { 
		return;         
	}
	// if the value is not shareable, copy it
	if (pointee->isShareable() == false) { 
		pointee = new T(*pointee); 
	} 
	// note that there is now a new reference to the value
	pointee->addReference(); 
} 

The problem is when T is StringValue and the following happens:

pointee = new T(*pointee);

There is no copy ctor of StringValue and syn version will be used. So memberwise copy but not a deep
copy. Therefore, needs String::StringValue::StringValue( const StringValue& rhs ) 


{{putting-it-all-together}}

Sting is reference counted string class.

                        RCObject
			               |
String               -> StringValue -> data
+RCPtr
+nested StringValue


/*
** RCObject : base class for reference counted objects
*/
class RCObject { 
public:
	 RCObject();
	 RCObject(const RCObject& rhs);
	 RCObject& operator=(const RCObject& rhs);
	 virtual ~RCObject() = 0;
	 void addReference();
	 void removeReference();
	 void markUnshareable();
	 bool isShareable() const;
	 bool isShared() const;
private:
	 size_t refCount;
	 bool shareable;
};

RCObject::RCObject() : refCount(0), shareable(true) {}
RCObject::RCObject(const RCObject&) : refCount(0), shareable(true) {}
RCObject& RCObject::operator=(const RCObject&) { return *this; }
RCObject::~RCObject() {}
void RCObject::addReference() { ++refCount; }

void RCObject::removeReference()
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }
bool RCObject::isShareable() const
{ return shareable; }
bool RCObject::isShared() const
{ return refCount > 1; }


/*
 * RCPtr
 */
template<class T> 
class RCPtr { 
public: 
	 RCPtr(T* realPtr = 0);
	 RCPtr(const RCPtr& rhs);
	 ~RCPtr();
	 RCPtr& operator=(const RCPtr& rhs);
	 T* operator->() const;
	 T& operator*() const;
private:
	 T *pointee;
	 void init();
};

template<class T>
void RCPtr<T>::init()
{
	// if the dump pointer is null, so is the smart one
	if (pointee == 0) return;

	// if is not sharable, create new one
	if (pointee->isShareable() == false) {
		pointee = new T(*pointee);
	}
	
	// new reference
	pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr(T* realPtr) : pointee(realPtr)
{ init(); }

template<class T>
RCPtr<T>::RCPtr(const RCPtr& rhs) : pointee(rhs.pointee)
{ init(); }

template<class T>
RCPtr<T>::~RCPtr()
{ if (pointee) pointee->removeReference(); }    # <delete-this-in-removeReference>

template<class T>
RCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)
{
	 // skip when the value does not change
	 if (pointee != rhs.pointee) {

		  T *oldPointee = pointee;
		  pointee = rhs.pointee;

		  // if possible share it, else make own copy
		  init();

		  // decrease reference
		  if (oldPointee) oldPointee->removeReference();
	 }

	 return *this;
}

template<class T>
T* RCPtr<T>::operator->() const { return pointee; }

template<class T>
T& RCPtr<T>::operator*() const { return *pointee; }


/*
 * String : class to be used by users
 */
class String { 
public: 
	 String(const char *value = "");
	 const char& operator[](int index) const;
	 char& operator[](int index);

private:
	 // class representing string values
	 struct StringValue: public RCObject {
		  char *data;
		  StringValue(const char *initValue);
		  StringValue(const StringValue& rhs);
		  void init(const char *initValue);
		  ~StringValue();
	};

	RCPtr<StringValue> value;
};


void String::StringValue::init(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}
String::StringValue::StringValue(const char *initValue)
{ init(initValue); }
String::StringValue::StringValue(const StringValue& rhs)
{ init(rhs.data); }
String::StringValue::~StringValue()
{ delete [] data; }


String::String(const char *initValue)
: value( new StringValue(initValue) ) {}        # <set-rcptr>

const char& String::operator[](int index) const
{ return value->data[index]; }

char& String::operator[](int index)
{
	if (value->isShared()) {
		value = new StringValue(value->data);
	}
	value->markUnshareable();
	return value->data[index];
}

<assumption>

RCPtr< T> has:

o deep-copying copy constructor
o T inherit from RCObject, or at least that T provide all the functionality that RCObject does. T
must support the RCObject interface and it menas RCPtr and RCObject is tightly coupled.


<note-one> <difference-in-interface-of-sting>
Now there is no need to have String copy ctor, assign, and dtor because syn version doing memberwise
will call matching one of RCPtr which doing work of managing refCount. That is smart.

note: This is an example of using syn version compiler made.

Our original goal was to move the unreusable reference-counting code out of our hand-written String
class and into context-independent classes where it would be available for use with any class. Now
we've done it (in the form of the RCObject and RCPtr classes),

note: Also there is nearly no changes to String interface. encapsulation.


{{add-reference-counting-to-existing-classes}} {wrapper}

How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


==============================================================================
*kt_dev_mecpp_006* 28: log entry

Class template for making log entries whenever a T object is modified; see below for details

template<class T>
class LogEntry {
public:
	 LogEntry(const T& objectToBeModified);
	 ~LogEntry();
};

void editTuple(DBPtr< Tuple>& pt)
{
	 LogEntry< Tuple> entry(*pt); // make log entry for this operation

	 do {
	 	pt->displayEditDialog();
	 } while (pt->isValid() == false);
}


The LogEntry's constructor begins the log entry and its destructor ends the log entry. Two pros:

o handles exception case
o easier to create a single LogEntry object than to add separate calls to start and stop an entry 


==============================================================================
*kt_dev_mecpp_007* 34: combine C and C++

There are things to know when use both together in a program.

{name-mangling}
This is the process which C++ compiler give each function a unique name because supports
overloading. There is a directive to tell compiler not to mangle func name. This is called linkage
directive.


{extern-keyword}
The GCC compiles files based on extension. When compiles cpp files meaning cpp mane mangling you can
make sure that functions are c functions:

extern "C" void drawLine(int x1, int y1, int x2, int y2);

extern "C" {
	 ...
}

extern "C" {
	 #include <string.h>
}

If you want to build a function as a c function, then can do: 

extern "C" double calc( double dparam )
{
	 ...
}

To allow source or header to be compiled under either C or C++.

#ifdef __cplusplus
extern "C"
{
#endif

int strcmp( const char*, const char* );
...

#ifdef __cplusplus
}
#endif


<case-example> <wrapper-from-cpp-to-c>
This case is that main is in c and is to use some features written in cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typdefs               {
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Note This is a problem when use the same header in both c and cpp compile. Why extern C is needed in
the wrapper.h? If this is only used for C files then not needed but must for C and CPP source files.

Also because cpp file uses typedefs from it. So when compile cpp compiler thinks func defs are C++
linkage from wrapper header when there is no extern guard and then see wrapper_func in C linkage
from cpp file. So conflict and emits errors:

[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmosa.h:170:1: error: previous
declaration of 'pfmerr_t pfmThreadCreate(SPfmThreadParams*, void (*)(void*), void*)' with 'C++'
linkage 
[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmthread.cpp:80:80: error:
conflicts with new declaration with 'C' linkage

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)
#include "wrapper.h"                                 	extern "C"
                               typdefs                {
                                                          #include "wrapper.h" 
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									                                 ....
                                                          }
																			 ...
																		}

This can be avoided if design header and source files carefully. For example, if need some c
functions that can be used in c file and this function creates cpp objects and use it then simply
create a header which has normal declarations and no externs and only have externs in cpp. The point
is that the same header is used for both C and CPP.

// ususal c
#include "wrapper.h"
{
	wrapper_func();
}

// usual.h or wrapper.h
int wrapper_func();

// usual cpp or wrapper.cpp
extern "C"
{
  int wrapper_func()
  {
     ClassX* pclass = new Class( params );

     pclass->func();
     ...
  }
}

If usual cpp header or wrapper.h have other cpp headers, will work cpp compiles such as usual cpp
and others but when used in c compile, emits loads of errors since these cpp files have cpp things.
So better to have single header file which have all c functions from cpp land. Otherwise, will get
errors shown in *kt_dev_gcc_007* 


{example-from-code}
/* Define C declaration macros for C++ compatibility. */                                
#if !defined(BEGIN_C_DECLS) && !defined(END_C_DECLS)
#if defined(__cplusplus) || defined(c_plusplus)
# define BEGIN_C_DECLS extern "C" {
# define END_C_DECLS   }
#else /* !__cplusplus */
# define BEGIN_C_DECLS
# define END_C_DECLS
#endif /* __cplusplus */
#endif /* BEGIN_C_DECLS && END_C_DECLS */


{function-pointer-between}
If use function-pointer or function-pointer as arg between them, see Primus p859 for more.


{cpp-main}
The cpp-main has three stages: static-initialisation, main, and static-destruction. So if not use
cpp-main when use both, will not work as expected and shall use cpp-main.

extern "C" int realMain(...);

int main( ... )
{
	 return realMain( ... );
}

This is dependent on compiler and shall check with it.

KT: is it still ture? ture for gcc?


{new-delete-and-malloc-free}
Do not mix between new/delete and malloc/free. For example, char* strdup(char *ps), which is not
standard in C/C++. Need to free or delete? It depends on system and compiler so recommends that do
not use funcs which is not standard.


{data-structure-in-between}
The objects that have virtual and inheritance are not compatible with C. This affects when calling
funcs with return or args between them.


==============================================================================
*kt_dev_mecpp_008*	32: program in the future tense

To be prepared for the change. How?

{one}

Express design decision in code instead of comments or documents. For example,
preventing-derivation.


{two}

Design code so that when changes are necessary, the impact is localized. Asks how the class is
designed to be used. See future thense and this is a example of virtual dtor. Encapsulation.


# ============================================================================
#{

==============================================================================
*kt_dev_estl_001*	02: illusion of container-independent code

STL is based on generalizaiton: container is array generalization, iterator is pointer, and
algorithm is function. but do not mean that can write container-independent code because each
container has different interface and characteristics. To minimize impcats of changing containers,
use <encapsulation> using typedef and class.

{no-encapsulation}

class Widget { ... };
vector< Widget > vw;
Widget bestWidget;
...
vector< Widget >::iterator i = find( vw.begin(), vw.end(), bestWidget );


{first-improvement}

class Widget { ... };
>
 typedef vector< Widget > WidgetContainer;
 WidgetContainer vw;
<
Widget bestWidget;
...
>
 WidgetContainer::iterator i = find( vw.begin(), vw.end(), bestWidget );

Also, save you some typing as think about:

map< sting, vector< Widget >::iterator, CIStingCompare>;

Want to sell out the below?

map< sting, vector< Widget >::iterator, CIStingCompare>::const_iterator;


{second-improvement}

Using typdef is not enough to seperate client so use class:

class CustomerList {
	 private:
	 >
	 typedef list< Customer > CustomerContainer;
	 typedef CustomerContainer::iterator CCIterator;
	 CustomerContainer customers;
<
	 public:
	 // limit the list-specific detail visible through this interface
	 ...
};


# ============================================================================
#{

*kt_dev_blush_001*	accessing neighbors in array


2013.10. when had a problem solving which is to find a path in a maze, wrote a func like:

bool checkWhite( const Pos& pos)
{
	// upper-left
	if( A[pos.xpos-1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper
	else if ( A[pos.xpos][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper-right
	else if ( A[pos.xpos+1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// same-left
	else if ( A[pos.xpos-1][pos.ypos] == WHITE )
	{
		return true;
	}
	// same-right
	else if ( A[pos.xpos+1][pos.ypos] == WHITE )
	{
		return true;
	}
	// lower-left
	else if ( A[pos.xpos-1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower
	else if ( A[pos.xpos][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower-right
	else if ( A[pos.xpos+1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	else
		return false;
}

Although the above tried to give it some priority, this should be something like used in
*kt_dev_algo_006* :

int NeighborCount( Grid map, int row, int col)
{
	 int i, j, count = 0;

	 for( i = row-1; i <= row+1; i++ )
		  for( j = col-1; j <= col+1; j++ )
				if( map[i][j] == ALIVE )
					 count++;

	 // exclude one for itself
	 if( map[row][col] == ALIVE )
		  count--;

	 return count;
}


# ============================================================================
#{

==============================================================================
*kt_dev_uml_001*	aggragation

Two aggregations: weak and strong.

1) weak. white diamond-shaped arrowhead pointing towards the target or parent class.

2) strong. a black diamond-shaped arrowhead. composite aggragation.

# example

AddressBook <*>----------- ContactGroup
            1         0..*

(copied from *kt_dev_ecpp_011* )

# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...


# ============================================================================
#{

==============================================================================
*kt_dev_ref*	references

{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

{ref-003} design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

{ref-CPR} C++ primer, 5th Ed.

==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
