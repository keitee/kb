*kt_dev_01*                                                           tw=100, utf-8

/^[#=]{
Use #{ for a group and ={ for a item

TODO:
1. how to instantiate all members from a template? when it is useful? from youview interview 
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. DEVELOPMENT.

#{ sw eng and practice
|kt_dev_seng_001| first major hurdle in attacking a large problem
|kt_dev_seng_002| order of headers
|kt_dev_seng_003| comments in source
|kt_dev_seng_004| 80 and 20

#{ problems and CODES
|kt_dev_prob_001| memcpy considered danger
|kt_dev_prob_002| out of index of array
|kt_dev_prob_003| double free
|kt_dev_prob_004| DUMA, DML, KDEBUG, FTRACE, ASN, valgrind
|kt_dev_prob_005| use-after-free error
|kt_dev_prob_006| print ansi color 
|kt_dev_prob_007| random number
|kt_dev_prob_008| elapsed time {clock}
|kt_dev_prob_009| preprocessor {stdarg} {why-ellipses-dangerous} {ndebug}
|kt_dev_prob_010| bit manipulation: get max value of type <shift-operator>
|kt_dev_prob_011| handle or pointer
|kt_dev_prob_012| problem of incremental build or make
|kt_dev_prob_013| simple grep

#{ gnu core utils
|kt_dev_guti_000| gnu core util sites

#{ gcc
|kt_dev_gcc_000| gcc compile script
|kt_dev_gcc_001| error: two or more data types in declaration specifiers <bool> 
|kt_dev_gcc_002| error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]
|kt_dev_gcc_003| error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]
|kt_dev_gcc_004| error: variable-sized object 'out' may not be initialised
|kt_dev_gcc_005| error: expected '}' at end of input
|kt_dev_gcc_006| error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 
|kt_dev_gcc_007| error: expected '=', ',', ';', 'asm' or '__attribute__' before
|kt_dev_gcc_008| warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]
|kt_dev_gcc_009| error: jump to case label and crosses initialisation of 

|kt_dev_gcc_100| gcc and c++11 {how-to-use-gcc-optimisation} {gcc-profiling} {gcc-options}
|kt_dev_gcc_101| gcc typeof
|kt_dev_gcc_102| gcc: link: link script
|kt_dev_gcc_103| gcc: link: link order and cyclic dependencies
|kt_dev_gcc_104| gcc: C90 and C99 
|kt_dev_gcc_105| gcc likely and unlikely 
|kt_dev_gcc_106| gcc: link: lrt
|kt_dev_gcc_107| gcc: link: sysroot and rpath-link
|kt_dev_gcc_108| gcc: options
|kt_dev_gcc_109| gcc: options: get dependancies
|kt_dev_gcc_110| gcc: attributes
|kt_dev_gcc_111| gcc: profiling
|kt_dev_gcc_112| gcc: options: optimization
|kt_dev_gcc_113| gcc: options: warning

|kt_dev_gcc_200| gcc: cpp: preprocessor
|kt_dev_gcc_201| gcc: cpp: define? 
|kt_dev_gcc_202| gcc: cpp: how-to-get-filename-without-full-path

|kt_dev_gcc_300| gcc gprof

#{ lang basic
|kt_dev_lang_001| file and function static {singleton-pattern}
|kt_dev_lang_002| stdio
|kt_dev_lang_003| #error and #warning
|kt_dev_lang_004| post and pre inc {post-inc} {post-inc-overload} {tip}
|kt_dev_lang_005| chaining
|kt_dev_lang_006| compile error types
|kt_dev_lang_007| bool type {true-and-false}
|kt_dev_lang_008| data type, char type
|kt_dev_lang_009| implicit conversion {equal-misspell} {integer-division}
|kt_dev_lang_010| incomplete type {forward-declaration} {text-query-example}
|kt_dev_lang_011| literal type
|kt_dev_lang_012| pointer and array {option-handling} {std::begin} {sizeof-operator}
|kt_dev_lang_013| allman style 
|kt_dev_lang_014| interesting codes. printf-format
|kt_dev_lang_015| control flow {control-for-vs-while} {switch-under-the-hood}
|kt_dev_lang_016| operator-precedence, operators {evaulation-order}
|kt_dev_lang_017| identifier name rule
|kt_dev_lang_018| style consideration: define variable
|kt_dev_lang_019| function pointer

#{ cpp
|kt_dev_cpp_000| oop
|kt_dev_cpp_001| virtual inheritance (interview) {virtual-base-class}
|kt_dev_cpp_002| reference-vs-pointer (interview)
|kt_dev_cpp_003| ctor and copy controls. constructor-initializers
|kt_dev_cpp_004| copy controls of dyn resource. valuelike. preventing-copies. swap and move example
|kt_dev_cpp_005| converting ctor {class-type-conversion} {explicit-keyword}
|kt_dev_cpp_006| swap {copy-and-swap-idiom}
|kt_dev_cpp_007| function matching and overload {scope-in-inheritance}
|kt_dev_cpp_008| const {const-on-iterators} {equal-misspell} {bitwise-const} {mutable}
|kt_dev_cpp_009| undefined result
|kt_dev_cpp_010| temp-object
|kt_dev_cpp_011| inline {empty-ctor-represenstaion}
|kt_dev_cpp_012| list initialization. initializer_list
|kt_dev_cpp_013| use reference {called-by-reference} 
|kt_dev_cpp_014| auto, decltype, typedef, and struct {class-vs-struct} 
|kt_dev_cpp_015| declaration and definition
|kt_dev_cpp_016| array and struct
|kt_dev_cpp_017| static-members and class const {class-method} {class-const}
|kt_dev_cpp_018| dtor. non-virtual-destruction-problem. how-virtual-works.
|kt_dev_cpp_019| exception {problem-of-exception-in-dtor} {exception-safe}
|kt_dev_cpp_020| move semantics
|kt_dev_cpp_021| op overload {member-or-non-member}
|kt_dev_cpp_022| inheritance {static-type} {subobject-and-derived-to-base-conversion} {base-class-pointer-container} {RTTI}
|kt_dev_cpp_023| override {override-condition} {override-keyword}
|kt_dev_cpp_024| abstract base class {refactoring}
|kt_dev_cpp_025| 
|kt_dev_cpp_026| enum {enum-hack}
|kt_dev_cpp_027| volatile
|kt_dev_cpp_028| namespace {case-example} {unnamed-namespace}
|kt_dev_cpp_029| nested class

|kt_dev_cpp_050| template. debug-delete
|kt_dev_cpp_051| template: explicit argument and type transformation
|kt_dev_cpp_052| template: argument deduction
|kt_dev_cpp_053| template: variadic
|kt_dev_cpp_054| template: specialization
|kt_dev_cpp_060| template: how to initialize T member

|kt_dev_cpp_100| ref: C++ under the hood, Jan Gray
|kt_dev_cpp_101| ref: C++ under the hood, Scott Meyers
|kt_dev_cpp_102| ref: MEC++24 understand the cost of virtual functions
|kt_dev_cpp_103| ref: others
|kt_dev_cpp_104| ref: why singletons are controversial

|kt_dev_cpp_200| example: Quote example from primers

|kt_dev_cpp_300| case: framework {tizen-case}
|kt_dev_cpp_301| case: wrapper
|kt_dev_cpp_302| case: porting layer
|kt_dev_cpp_303| case: inheritance {how-gcc-build-vtable}
|kt_dev_cpp_304| case: overload

#{ stl follow <what-container-consideration> for points to consider
|kt_dev_stl_000| useful links and gcc stl {stl-design-rationale}
|kt_dev_stl_001| pair and tuple class
|kt_dev_stl_002| traits

|kt_dev_stl_006| stl concepts, error, exception handling
|kt_dev_stl_007| containers
|kt_dev_stl_008| containers: requirement on element type {value-reference-semantics}
|kt_dev_stl_009| containers: common operations and initialize
|kt_dev_stl_010| sequential containers {trade-offs}
|kt_dev_stl_011| sequential: vector
|kt_dev_stl_012| sequential: deque
|kt_dev_stl_013| sequential: array
|kt_dev_stl_014| sequential: list
|kt_dev_stl_015| sequential: forward list

|kt_dev_stl_020| associative containers
|kt_dev_stl_021| associative: set and multi
|kt_dev_stl_022| associative: map and multi

|kt_dev_stl_030| unordered containers

|kt_dev_stl_040| adaptor containers {stack} {queue}

|kt_dev_stl_050| iterator: range-for 
|kt_dev_stl_051| iterator: adaptors 
|kt_dev_stl_052| iterator: subscript for sequential and associative
|kt_dev_stl_053| iterator: invalid iterator, insert, remove
|kt_dev_stl_054| iterator: external and internal

|kt_dev_stl_060| algorithm
|kt_dev_stl_061| algorithm: predicate
|kt_dev_stl_062| algorithm: lambda
|kt_dev_stl_063| algorithm: function object
|kt_dev_stl_064| algorithm: function<>
|kt_dev_stl_065| algorithm: bind
|kt_dev_stl_065| algorithm: which is better?
|kt_dev_stl_066| algorithm: nonmodifying: equal, is_permutation
|kt_dev_stl_067| algorithm: nonmodifying: count

|kt_dev_stl_070| string
|kt_dev_stl_071| string: stringstream {inefficient-concatnation}

|kt_dev_stl_080| bitset

|kt_dev_stl_100| raii {factory-func} {auto-lock}
|kt_dev_stl_101| smart pointer
|kt_dev_stl_102| smart pointer: internal: auto_ptr
|kt_dev_stl_103| smart pointer: internal: shared_ptr
|kt_dev_stl_104| smart pointer: examples
|kt_dev_stl_105| make_shared
|kt_dev_stl_106| when to use which containers
|kt_dev_stl_107| smart pointers: deleter

|kt_dev_stl_110| allocator
|kt_dev_stl_111| gcc stl impl files

#{ STL Q
|kt_dev_stl_200| ref: can store unique_ptr in a container?

#{ SYSTEM 
|kt_dev_sys_001| <empty>
|kt_dev_sys_002| endianess
|kt_dev_sys_003| to check endianess at runtime
|kt_dev_sys_004| to check address alignment or boundary <bitwise>
|kt_dev_sys_005| two's complement
|kt_dev_sys_007| stack (MIPS)
|kt_dev_sys_008| stack asm example (MIPS)
|kt_dev_sys_009| for and while asm (MIPS)
|kt_dev_sys_010| POR(power on reset) (MIPS)
|kt_dev_sys_011| instruction and addressing (MIPS)
|kt_dev_sys_012| dump_stack
|kt_dev_sys_013| <empty>
|kt_dev_sys_014| newlines between dos and linux


#{ EFFECTIVE C++ 3RD
|kt_dev_ecpp_001| 01: federation of language
|kt_dev_ecpp_002| 02: no to preprocessor
|kt_dev_ecpp_003| 09: no virtual call in ctor or dtor {pass-log-to-base-class} {static-member-example}
|kt_dev_ecpp_004| 18: hard to use incorrectly 
|kt_dev_ecpp_005| 23: prefer non-member non-friend func {encapsulation}
|kt_dev_ecpp_006| 26: postpone variable definitions
|kt_dev_ecpp_007| 28: avoid returning handles to object internals
|kt_dev_ecpp_008| 31: minimize compilation dependencies {pimpl-idiom} {interface-class} {factory-pattern}
|kt_dev_ecpp_009| 32, 38, 39: inter-class relationship
|kt_dev_ecpp_010| 34: interface and implementation inheritance
|kt_dev_ecpp_011| 35: alternatives to virtual func {template-pattern} {strategy-pattern}
|kt_dev_ecpp_012| 33: avoid hiding inherited names
|kt_dev_ecpp_013| 22: data member must be private {encapsulation}
|kt_dev_ecpp_014| 27: minimize casting {named-cast}
|kt_dev_ecpp_015| new and delete
|kt_dev_ecpp_016| 49 : new handler
|kt_dev_ecpp_017| 50: when to replace new and delete
|kt_dev_ecpp_018| 52: placemane new


#{ MORE EFFECTIVE C++ 1ST, 1996, 25TH PRINTING
|kt_dev_mecpp_001| 16: 80-20 rule and profiler
|kt_dev_mecpp_002| 17: lazy evaluation
|kt_dev_mecpp_003| 18: over-eager evaluation
|kt_dev_mecpp_004| 
|kt_dev_mecpp_005| 25: reference-counting
|kt_dev_mecpp_006| 28: log entry
|kt_dev_mecpp_007| 34: combine C and C++
|kt_dev_mecpp_008| 32: program in the future tense

#{ EFFECTIVE STL 3RD
|kt_dev_estl_001| design: 02: illusion of container-independent code


#{ c++ concurrent in action
|kt_dev_ccon_000| std::thread build
|kt_dev_ccon_001| std::thread join and detach
|kt_dev_ccon_002| std::thread copy callables and arguments
|kt_dev_ccon_003| race condition, data race and approaches
|kt_dev_ccon_004| std::mutex and inherent race in thread-safe stack
|kt_dev_ccon_005| deadlock prevention and std::lock_guard
|kt_dev_ccon_006| std::unique_lock and deferred locking
|kt_dev_ccon_007| std::unique_lock and transferring mutex
|kt_dev_ccon_008| std::unique_lock and granulity
|kt_dev_ccon_009| std::call_once and protecting during initialization
|kt_dev_ccon_010| boost::shared_lock and read-write lock
|kt_dev_ccon_011| recursive lock
|kt_dev_ccon_012| std::condition_variable
|kt_dev_ccon_013| thread-safe queue
|kt_dev_ccon_014| std::future and std::async
|kt_dev_ccon_015| std::packaged_task
|kt_dev_ccon_016| std::promise
|kt_dev_ccon_017| std::shared_future in multiple threads

|kt_dev_ccon_002| std::future


#{ BLUSHES OR BUGS
|kt_dev_blush_001| accessing neighbors in array
|kt_dev_blush_002| default return values

#{ design
|kt_dev_design_001| generic structure access

|kt_dev_uml_001| aggragation

|kt_dev_ref_001| references
|kt_dev_ref_002| sites


# ============================================================================
#{
={============================================================================
*kt_dev_seng_001* first major hurdle in attacking a large problem

is deciding exactly what the problem because necessary 

1. to translate vague goals
2. contradictory requests
3. perhaps unstated desires into a precisely formulated project that can be programmed.


={============================================================================
*kt_dev_seng_002* order of headers

Included headers ordering but I think a nice and consistent way of including them is as all
alphabetically in each group:

local project headers
3PS library headers
OS specific headers
standard headers


={============================================================================
*kt_dev_seng_003* comments in source

why?

1) no gurantee that only one person maintain whole source tree. works as a team. no lifetime
employment. no unlimited memory.

2) code speaks themselves? not for big and real system which has history such as field fixes.
project/field specific requirement and one line worth a week long dev trip. 

Should have comment or reference for more detail or full history.


={============================================================================
*kt_dev_seng_004* 80 and 20

EC++ p139.

Typical program spends 80% of its time excuting only 20% of its code. Your goal as a software
developer is to identify the 20% of your code that can increase your program's overall performance.

From MEC++16:

The 80-20 Rule states that 80 percent of a program's resources are used by about 20 percent of the
code: 80 percent of the runtime is spent in approximately 20 percent of the code; 80 percent of the
memory is used by some 20 percent of the code; 80 percent of the disk accesses are performed for
about 20 percent of the code; 80 percent of the maintenance effort is devoted to around 20 percent
of the code. 

The rule has been repeatedly verified through examinations of countless machines, operating systems,
and applications. The 80-20 rule is more than just a catchy phrase; it's a guideline about system
performance that has both wide applicability and a solid empirical basis.


# ============================================================================
#{
={============================================================================
*kt_dev_prob_001* memcpy considered danger

Seen on NDS MW issue

MW_Process crash with core dump in SIM_dbc_query_ReadProgrammeInstanceInfo (during memcpy) 

# void *memcpy(void *dest, const void *src, size_t n);
(void)memcpy((void*)&obj_array[offset].sort_title[0], (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

# source when crashed
0x1d8dfec: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x1d8dffc: 0xc009 0x0 0x0 0x0

# dest
x/40a obj_array[0].sort_title
0x204eb20: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x204eb30: 0x0 0x0 0x0 0x0

# solution
strncpy(&obj_array[offset].sort_title[0], (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

note. So the problem is the accessing out of index; Why? When doing memcpy, there is no gurantee
that src and dest has all the vaild address up to 'n' size. So when the valid length of src is
smaller than 'n' then the area which is over the length of src, may not accessiable such as not
contiguous, not valid for this process, etc. 

So strncpy will ensure only the length of the value.text is copied when there is a null in src
(destination then padded out with nulls) or a maximum of 40 is copied if the source string is over
40.


={============================================================================
*kt_dev_prob_002* out of index of array

when acces out of index of array, 'undefined' so sometimes work or sometimes not.

<01>
int g_arr[3];

int main(int argc, char* argv[])
{
  if( g_arr[5] == 0 )
    printf("idx 5 is false\n");
  else
    printf("idx 5 is true\n");
}

$ ./a.out 
idx 5 is false

<02>
The issue was that index(dbConId) was -1(0xFFFFFFFF used as a handle) and worked sometimes. But
crashed

static MFS_STATUS MFSDBWRAP_GetDbContext(MFS_STORAGE_DB_CONTEXT_ID dbConId, MFS_DB_CONTEXT **ppContext)
{
  MFS_STATUS mfsStatus = MFS_STATUS_OK;

  XDEBUG_DEFINE_FUNC_INFO("MFSDBWRAP_GetDbContext");
  XDEBUG_TRACE2_1("start: dbConId=%d", dbConId);

  // the dbConId is the index into the db context array, so we can directly access it.
  // First check that the context is really in use. If not this is a bug.
  //
  if (db_contexts_array[dbConId].bInUse == XFALSE)
  {
    XDEBUG_ERR2_0("No free slots for contextes.  Returning the first one");
    mfsStatus = MFS_STATUS_ERROR;
  }
  else
  {
    *ppContext = &db_contexts_array[dbConId];
  }

  return mfsStatus;
}


={============================================================================
*kt_dev_prob_003* double free

When do double free under pc linux that uses glibc, make a core as below but run on a embedded linux
that uses uclibc, shows no problem.

$ ./a.out 
pstr = 
this is..
*** glibc detected *** ./a.out: double free or corruption (fasttop): 0x000000001834b010 ***
======= Backtrace: =========
/lib64/libc.so.6[0x393c07230f]
/lib64/libc.so.6(cfree+0x4b)[0x393c07276b]
./a.out[0x40062f]
/lib64/libc.so.6(__libc_start_main+0xf4)[0x393c01d994]
./a.out[0x4004b9]
======= Memory map: ========
00400000-00401000 r-xp 00000000 fd:02 37781700                           /data/home/NDS-UK/parkkt/work/a.out
00600000-00601000 rw-p 00000000 fd:02 37781700                           /data/home/NDS-UK/parkkt/work/a.out
1834b000-1836c000 rw-p 1834b000 00:00 0                                  [heap]
393bc00000-393bc1c000 r-xp 00000000 fd:00 3538948                        /lib64/ld-2.5.so
393be1b000-393be1c000 r--p 0001b000 fd:00 3538948                        /lib64/ld-2.5.so
393be1c000-393be1d000 rw-p 0001c000 fd:00 3538948                        /lib64/ld-2.5.so
393c000000-393c14e000 r-xp 00000000 fd:00 3538955                        /lib64/libc-2.5.so
393c14e000-393c34d000 ---p 0014e000 fd:00 3538955                        /lib64/libc-2.5.so
393c34d000-393c351000 r--p 0014d000 fd:00 3538955                        /lib64/libc-2.5.so
393c351000-393c352000 rw-p 00151000 fd:00 3538955                        /lib64/libc-2.5.so
393c352000-393c357000 rw-p 393c352000 00:00 0 
394b200000-394b20d000 r-xp 00000000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
394b20d000-394b40d000 ---p 0000d000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
394b40d000-394b40e000 rw-p 0000d000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
2ba0f68d2000-2ba0f68d4000 rw-p 2ba0f68d2000 00:00 0 
2ba0f68ec000-2ba0f68ee000 rw-p 2ba0f68ec000 00:00 0 
7fff1e6e4000-7fff1e6f9000 rw-p 7ffffffe9000 00:00 0                      [stack]
ffffffffff600000-ffffffffffe00000 ---p 00000000 00:00 0                  [vdso]
Aborted


# from man page

The free() function frees the memory space pointed to by ptr, which must have been returned by a
  previous call to malloc(), calloc() or realloc(). Otherwise, or if free(ptr) has already been
  called before, undefined behavior occurs. If ptr is NULL, no operation is performed.


={============================================================================
*kt_dev_prob_004* DUMA

{DUMA}
Purpose        User dynamic Memory Corruption
Technology     Library
ARCH           ARM, Mips
OS             Linux
Description

DUMA used for finding memory usage errors such as Overflow, Underflow, Memory used after free,
allocator/deallcator mismatch in user program. Below are the allocator Supported in DUMA(16 type)

malloc
calloc
free
memalign
posix_mem
realloc
valloc
strdup
memcpy
strcpy
strncpy
strcat
strncat
strndup
vasprintf
asprintf


{DML}
Purpose        User dynamic Memory Accounting
Technology     Library
ARCH           ARM, Mips
OS             Linux
Description

DML is used for memory accounting and find out memory 'leaks' in user program. Below are the
allocator Supported in DML(17 type)

memalign
valloc
posix_memalign
asprintf
strndup
strdup
wcsdup
malloc
realloc
calloc
free
operator new[]
operator new
operator delete
operator delete[]
prctl
pthread_create


{KDEBUGD}
Purpose        User tracer, debugger, and profiler
Technology     Kernel hooking
ARCH           ARM, Mips
OS             Linux
Description

Kdebugd is kernel mode debuger, tracer and profiler for user space programs below are the Major
feature provided by Kdebugd.

1- Find User program statistics (Maps/Stack and Register)
2- Run time Kernel and User backtrace
3- Resource Monitoring
4- Lock profiler
5- User program Profiling


{FTRACE}
Purpose        Kernel tracer
Technology     Tracepoint
ARCH           ARM, Mips
OS             Linux
Description

Ftrace is kernel mode tracer for kernel threads


{MEMPS} 
note: not open source
A 'Memps' tool is developed to show memory accounting information for the complete system and
individual processes through one common interface.

This tool combines various open source proc interface output and combined them together to show all
useful information at single place.

Various proc interfaces internally called are as follows:
a./proc/meminfo
b./proc/pid/status
c./proc/pid/cmdline
d./proc/mounts
e./proc/pid/smaps
f./proc/sys/vm/drop_caches

sh-4.1# ./memps --help

Usage: ./memps [OPTION]...

Options:
  -o, --output=FILE
  -p, --pid=PID
  -v, --verbose
  -t, --tmpfs
  -g, --geminfo
  -m, --maliinfo
  -r, --dropcaches
  -d, --description
  -c, --color
  -h, --help

If run without any argument output of memps utility would show
a.
PID     CODE     DATA     PEAK      PSS DEV(PSS) COMMAND
Output for all running processes in the system

b.
MemTotal       MemFree              MemUsed*       Buffers        Cached      SwapCached
Active         Inactive             Active(anon)   Inactive(anon)
Active(file)   Inactive(file)       SwapTotal  SwapFree    AnonPages
Free*          Used*             GemTotal    MaliTotal

Output for complete system, along with information for Graphics driver and Mali drivers.

sh-4.1#> ./memps
     PID     CODE     DATA     PEAK      PSS DEV(PSS) COMMAND
       1      292       36      328      200        0 init
      73      404       80      484      356        0 -/bin/sh
     211      556       76      632      632        0 ./memps

  TOTAL:     CODE     DATA               PSS DEV(PSS)
            1,252      192             1,188        0

MemTotal:  1181 MB ( 1,209,684 kB)
MemFree:  1160 MB ( 1,188,232 kB)
MemUsed*:    20 MB (    21,452 kB)
Buffers:     2 MB (     2,472 kB)
Cached:     3 MB (     3,976 kB)
SwapCached:     0 MB (         0 kB)
Active:     1 MB (     1,936 kB)
Inactive:     4 MB (     4,668 kB)
Active(anon):     0 MB (       164 kB)
Inactive(anon):     0 MB (         4 kB)
Active(file):     1 MB (     1,772 kB)
Inactive(file):     4 MB (     4,664 kB)
SwapTotal:     0 MB (         0 kB)
SwapFree:     0 MB (         0 kB)
AnonPages:     0 MB (       156 kB)
Free*:  1166 MB ( 1,194,668 kB)
Used*:    14 MB (    15,016 kB)
GemTotal:     0 MB (         0 kB)
(Contiguous:           0 kB)
(Non-contiguous:       0 kB)
MaliTotal:     0 MB (         0 kB)


{ASN}
AddressSanitizer (or ASan) is a programming tool that detects memory corruption bugs such as buffer
overflows or accesses to a dangling pointer (use-after-free). AddressSanitizer is based on compiler
instrumentation and directly-mapped shadow memory. AddressSanitizer is currently implemented in
Clang (starting from version 3.1[1]) and GCC (starting from version 4.8[2]).  The tool slows down
programs by approximately 2 times .[3]

From doc:
Applications are implemented in 'unmanaged' programming languages (C and C++) which do not provide
any protection against invalid memory accesses. Such accesses often result in memory corruption and
eventually cause program crashes or other abnormal behavior. AddressSanitizer (or ASan for short) is
a part of Google toolsuite for program quality assurance (the other tools being ThreadSanitizer,
    MemorySanitizer and UBSanitizer). 

The advantages of ASan are:
- much (~40x) faster than valgrind
- actively evolving (in contrast to mudflap which has been recently removed from Gcc)
- cross-platform (in contrast to MPX)

https://code.google.com/p/address-sanitizer/

Current AddressSanitizer handles the following classes of errors (see
http://code.google.com/p/address-sanitizer/wiki/AddressSanitizer#Introduction):

- use after free
- buffer overruns and wild pointers

This is not guaranteed to always work for static and stack variables. Runtime will only be able to
detect overrun (or wild pointer access) if it falls into one of the redzones which separate objects
on stack or in global memory. If buffer offset is too large it'll be able to overcome the redzone
and fool the checker. ASan developers report that >95% of bugs are detectable with current redzone
sizes.

- use after return / use after end-of-block


<example-1>: use after free
Here is an example usage (classical use-after-free error):

$ cat uaf.c

#include <stdlib.h>
int main() {
  int *x = malloc(10 * sizeof(int));
  free(x);
  return x[5];
}

Let's examine the generated code for return statement:

$ /opt/vd/arm-v7a15v5r1/bin/arm-v7a15v5r1-linux-gnueabi-gcc \
    -fsanitize=address -O2 -S -o - uaf.c

Below code is annotated for brevity:

// int *x = malloc(10 * sizeof(int));
  .loc 1 3 0
  mov     r0, #40
  bl      malloc
  mov     r4, r0
.LVL0:
// free(x);
  .loc 1 4 0
  bl      free
.LVL1:
// ASan instrumentation: check memory access
  .loc 1 5 0
  add     r0, r4, #20           // Checked memory address
  mov     r3, #536870912        // Base address of shadow region
  ldrb    r3, [r3, r0, lsr #3]
  and     r2, r0, #7
  add     r2, r2, #3
  sxtb    r3, r3
  cmp     r2, r3
  movlt   r2, #0
  movge   r2, #1
  cmp     r3, #0
  moveq   r2, #0
  cmp     r2, #0
  bne     .L4                    // Poisoned access, report error
  .loc 1 6 0
// return x[5];
  ldr     r0, [r4, #20]
  ldmfd   sp!, {r4, pc}
.L4:
// ASan instrumentation: handle poisoned access
  .loc 1 5 0
  bl      __asan_report_load4

We can see that ASan has inserted 11 additional instructions to check one memory access. Let's now
check that runtime behavior matches our expectations:

$ /opt/vd/arm-v7a15v5r1/bin/arm-v7a15v5r1-linux-gnueabi-gcc \
    -fsanitize=address uaf.c

$ scp a.out root@myboard:/
a.out
100%   12KB  12.1KB/s   00:00   

$ ssh root@myboard /a.out
=================================================================
==154== ERROR: AddressSanitizer: heap-use-after-free on address 0xb5500fe4
at pc 0x86b0 bp 0xbec1ecd4 sp 0xbec1eccc
READ of size 4 at 0xb5500fe4 thread T0
    #0 0x86af (/a.out+0x86af)
    #1 0xb57f3bcb (/lib/libc.so.6+0x17bcb)
0xb5500fe4 is located 20 bytes inside of 40-byte region [0xb5500fd0,0xb5500ff8)
freed by thread T0 here:
    #0 0xb59320f3 (/lib/libasan.so.0+0x150f3)
    #1 0x8647 (/a.out+0x8647)
    #2 0xb57f3bcb (/lib/libc.so.6+0x17bcb)
previously allocated by thread T0 here:
    #0 0xb59321bb (/lib/libasan.so.0+0x151bb)
    #1 0x8637 (/a.out+0x8637)
    #2 0xb57f3bcb (/lib/libc.so.6+0x17bcb)
Shadow bytes around the buggy address:
  0x36aa01a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa01b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa01c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa01d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa01e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
=>0x36aa01f0: fa fa fa fa fa fa fa fa fa fa fd fd[fd]fd fd fa        // x[5] means 20 bytes
  0x36aa0200: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0210: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0220: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0230: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0240: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes): // 8*5 = 40
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:     fa
  Heap righ redzone:     fb
  Freed Heap region:     fd
  Stack left redzone:    f1
  Stack mid redzone:     f2
  Stack right redzone:   f3
  Stack partial redzone: f4
  Stack after return:    f5
  Stack use after scope: f8
  Global redzone:        f9
  Global init order:     f6
  Poisoned by user:      f7
  ASan internal:         fe
==154== ABORTING

<example-2>: heap buffer overflow
Let's now examine another classical memory error: buffer overflow. These are handled differently
depending on memory type (stack, static or heap) which we'll examine separately.

$ cat heap_overflow.c

int main(int argc, char **argv) {
  int *array = new int[100];
  array[0] = 0;
  int res = array[argc + 100];  // Touch memory past end of buffer
  delete [] array;
  return res;
}

$ ssh root@myboard /a.out
=================================================================
==126== ERROR: AddressSanitizer: heap-buffer-overflow on address 0xb5503fb4
at pc 0x8788 bp 0xbefc7cec sp 0xbefc7ce4
READ of size m
    #0 0x8787 (/a.out+0x8787)
    #1 0xb5737bcb (/lib/libc.so.6+0x17bcb)
0xb5503fb4 is located 4 bytes to the right of 400-byte region [0xb5503e20,0xb5503fb0)
allocated by thread T0 here:
    #0 0xb59a8a77 (/lib/libasan.so.0+0x10a77)
    #1 0x8697 (/a.out+0x8697)
    #2 0xb5737bcb (/lib/libc.so.6+0x17bcb)
Shadow bytes around the buggy address:
  0x36aa07a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa07b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa07c0: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00
  0x36aa07d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x36aa07e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x36aa07f0: 00 00 00 00 00 00[fa]fa fa fa fa fa fa fa fa fa
  0x36aa0800: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0810: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0820: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0830: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x36aa0840: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:     fa
  Heap righ redzone:     fb
  Freed Heap region:     fd
  Stack left redzone:    f1
  Stack mid redzone:     f2
  Stack right redzone:   f3
  Stack partial redzone: f4
  Stack after return:    f5
  Stack use after scope: f8
  Global redzone:        f9
  Global init order:     f6
  Poisoned by user:      f7
  ASan internal:         fe
==126== ABORTING

<example-3>: stack buffer overflow
Now to stack buffers:

$ cat stack_oob.c

int main(int argc, char **argv) {
  int stack_array[100];
  stack_array[1] = 0;
  return stack_array[argc + 100];  // Touch memory past end of buffer
}

$ ssh root@myboard /a.out
=================================================================
==132== ERROR: AddressSanitizer: stack-buffer-overflow
on address 0xbec82ccc at pc 0x875c bp 0xbec82b0c sp 0xbec82b04
READ of size 4 at 0xbec82ccc thread T0
    #0 0x875b (/a.out+0x875b)
    #1 0xb56d6bcb (/lib/libc.so.6+0x17bcb)
Address 0xbec82ccc is located at offset 436 in frame <main> of T0's stack:
  This frame has 1 object(s):
    [32, 432) 'stack_array'
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
Shadow bytes around the buggy address:
  0x37d90540: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d90550: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d90560: 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00 00
  0x37d90570: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d90580: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x37d90590: 00 00 00 00 00 00 00 00 00[f4]f4 f3 f3 f3 f3 00
  0x37d905a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d905b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d905c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d905d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x37d905e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:     fa
  Heap righ redzone:     fb
  Freed Heap region:     fd
  Stack left redzone:    f1
  Stack mid redzone:     f2
  Stack right redzone:   f3
  Stack partial redzone: f4
  Stack after return:    f5
  Stack use after scope: f8
  Global redzone:        f9
  Global init order:     f6
  Poisoned by user:      f7
  ASan internal:         fe
==132== ABORTING

<example-4>: global buffer overflow
And finally static buffers:

$ cat global_oob.c

int global_array[100] = {-1};
int main(int argc, char **argv) {
  return global_array[argc + 100];  // Touch memory past end of buffer
}

$ ssh root@myboard /a.out
=================================================================
==138== ERROR: AddressSanitizer: global-buffer-overflow
on address 0x00010b54 at pc 0x86f0 bp 0xbee97cf4 sp 0xbee97cec
READ of size 4 at 0x00010b54 thread T0
    #0 0x86ef (/a.out+0x86ef)
    #1 0xb56ccbcb (/lib/libc.so.6+0x17bcb)
0x00010b54 is located 4 bytes to the right of global variable 'global_array (global_oob.c)' (0x109c0) of size 400
Shadow bytes around the buggy address:
  0x20002110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x20002120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x20002130: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x20002140: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x20002150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x20002160: 00 00 00 00 00 00 00 00 00 00[f9]f9 f9 f9 f9 f9
  0x20002170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x20002180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x20002190: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x200021a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x200021b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:     fa
  Heap righ redzone:     fb
  Freed Heap region:     fd
  Stack left redzone:    f1
  Stack mid redzone:     f2
  Stack right redzone:   f3
  Stack partial redzone: f4
  Stack after return:    f5
  Stack use after scope: f8
  Global redzone:        f9
  Global init order:     f6
  Poisoned by user:      f7
  ASan internal:         fe
==138== ABORTING


<appendix>: AddressSanitizer Design
AddressSanitizer is supported by two major open-source toolchains: LLVM and GCC (LLVM being the main
development platform). The tool introduces a new compiler pass which instruments the generated
memory operations by inserting instructions to perform memory checks.

Here's the bird's eye view of the performed instrumentation:

// Before
*address = ...;  // or: ... = *address;

// After
if (IsPoisoned(address)) {
  ReportError(address, kAccessSize, kIsWrite);
}
*address = ...;  // or: ... = *address;

The IsPoisoned check is implemented in such a way so as to minimize overhead in common case (i.e.
when memory access is valid). It works by mapping the memory address in question to a bit in a
special memory region called <shadow-memory>:

byte *shadow_address = MemToShadow(address);
byte shadow_value = *shadow_address;
if (shadow_value) {
  if (SlowPathCheck(shadow_value, address, kAccessSize)) {
    ReportError(address, kAccessSize, kIsWrite);
  }
}

// Check the cases where we access first k bytes of the qword
// and these k bytes are unpoisoned.
bool SlowPathCheck(shadow_value, address, kAccessSize) {
  last_accessed_byte = (address & 7) + kAccessSize - 1;
  return last_accessed_byte >= shadow_value);
}

inline byte *MemToShadow(byte *address) {
  return (address >> 3) | ShadowStartOffset;   // ShadowStartOffset depends on the target arch
}

The shadow memory region is invisible to the program and occupies 1/8 of address space . It?s
initialized in the following way:

- bits that correspond to static variables are marked as unpoisoned
- whenever new stack frame is allocated, addresses which correspond to entries are marked as
  unpoisoned; upon frame termination bits are reset Stack and static objects are interspersed with
  redzones (short poisoned memory blocks) to allow for catching of buffer overruns.

To allow checking of heap-allocated memory standard memory routines are overridden by ASan runtime
library (libasan.so) to check/change poisonness of memory regions. For example malloc changes the
status of allocated memory buffer to unpoisoned while free re-poisons it. Here is the full list of
instrumented functions:

// signal.h
sigaction
signal
 
// setjmp.h
longjmp
_longjmp
siglongjmp
__cxa_throw
 

// string.h
memcmp
memmove
memcpy
memset
strchr
strcat
strncat
strcpy
strncpy
strcmp
strncmp
strlen
strcasecmp
strncasecmp
strdup
strnlen
index

// stdlib.h
atoi
atol
strtol
atoll
strtoll
read
pread
pread64
write
pwrite
malloc
free
realloc
calloc
valloc
posix_memalign
 
// pthread.h
pthread_create

// time.h
localtime
localtime_r
gmtime
gmtime_r
ctime
ctime_r
asctime
asctime_r
vscanf
vsscanf
vfscanf
scanf
fscanf
sscanf
 
They also instrument builtin compiler intrinsic e.g. __builtin_memcpy, etc.


<example-real-1>    The following  heap buffer-overflow was detected by ASan:

==136== ERROR: AddressSanitizer: heap-buffer-overflow on address 0xad651b10
at pc 0xb4e03054 bp 0x75c35ac4 sp 0x75c35aac
READ of size 17 at 0xad651b10 thread T457 (homesetting)
    #0 0xb4e03053 (/mtd_exe/lib/libasan.so.0+0xf053)
    #1 0x1281917 (/mtd_exe/exeAPP+0x1281917)
    #3 0x1a27f2f (/mtd_exe/exeAPP+0x1a27f2f)
    #4 0x25d78e3 (/mtd_exe/exeAPP+0x25d78e3)
    #5 0x25d7ad7 (/mtd_exe/exeAPP+0x25d7ad7)
    #6 0x12841bb (/mtd_exe/exeAPP+0x12841bb)
    #7 0x128924b (/mtd_exe/exeAPP+0x128924b)
    #8 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
    #9 0xae7b50f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
0xad651b1a is located 0 bytes to the right of 10-byte region [0xad651b10,0xad651b1a)
Shadow bytes around the buggy address:
  0x35aca310: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04
  0x35aca320: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04
  0x35aca330: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04
  0x35aca340: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04
  0x35aca350: fa fa 00 04 fa fa 00 02 fa fa 00 02 fa fa fa fa
=>0x35aca360: fa fa[00]02 fa fa fa fa fa fa fa fa fa fa fa fa 
  0x35aca370: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x35aca380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x35aca390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x35aca3a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x35aca3b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:     fa
  Heap righ redzone:     fb
  Freed Heap region:     fd
  Stack left redzone:    f1
  Stack mid redzone:     f2
  Stack right redzone:   f3
  Stack partial redzone: f4
  Stack after return:    f5
  Stack use after scope: f8
  Global redzone:        f9
  Global init order:     f6
  Poisoned by user:      f7
  ASan internal:         fe


Reproducing scenario: play video from usb source. Here is the backtrace analyzed with addr2line tool:

#0 0xb4e03053 (/mtd_exe/lib/libasan.so.0+0xf053)
__interceptor_strlen /home/ygribov/build/tools/v4/sources/gcc_1/libsanitizer/asan/asan_interceptors.cc:454

note that 'strlen' in __interceptor_strlen

452   uptr length = REAL(strlen)(s);
453   if (flags()->replace_str) {
454     ASAN_READ_RANGE(s, length + 1);
                           ^^^^^^^^^^
455   }

#1 0x1281917 (/mtd_exe/exeAPP+0x1281917)
PCString::Length(char const*)
/home1/jsun.song/TV400_REL/BP/MAIN2014/Smart/CSP_Smart_2014_Prj/REL_4211/BP_CSP/CSP-4.0/CSP/Src/PCString.cpp:347

#2 0x1a286d7 (/mtd_exe/exeAPP+0x1a286d7)
CAppStateProp::operator=(CAppStateProp&)
/home2/m.guseva/TV_2014/DTV/BP_APP/BP_AppCM/Src/Common/AppStateProp.cpp:326 <326>

322    char* ntmp = prop.GetStateName();
323   if(ntmp != NULL)
324   {
325       m_pStateName = new char[PCString::Length(ntmp)+1];
326       PCString::Copy(m_pStateName, ntmp, PCString::Length(ntmp)); <326>
                                             ^^^^^^^^^^^^^^^^^^^^^^
327       m_pStateName[PCString::Length(ntmp)] = '\0';
328     }

So the issue happened in strlen() function called for the CAppStateProp member during coping from
one string to another.

The root cause is in CAppStateProp constructor method where m_pStateName is initialized withoul null
termitaning symbol. So the proposed fix is to add null symbol to the Length position.

diff -p AppStateProp.cpp.orig  AppStateProp.cpp
*** AppStateProp.cpp.orig       2013-12-18 12:48:15.284055908 +0400
--- AppStateProp.cpp    2013-12-18 12:48:31.668057275 +0400
*************** CAppStateProp::CAppStateProp(const char*
*** 46,51 ****
--- 46,52 ----
        {
                m_pStateName = new char[PCString::Length("UNDEFINED")+1];
                PCString::Copy(m_pStateName, "UNDEFINED", PCString::Length("UNDEFINED"));
+               m_pStateName[PCString::Length("UNDEFINED")] = '\0';
        }

        m_coexistBanner.clear();

KT: Although can see what was wrong, but not sure how it came to conclusion that is heap overflow
and why the first call of Length was not a problem.

<example-real-2> The following  unknown crash was detected by ASan:
==215== ERROR: AddressSanitizer: unknown-crash on address 0x8b8eb924
at pc 0xb4e03054 bp 0x789acad4 sp 0x789acabc
READ of size 65 at 0x8b8eb924 thread T247 (webserver)
    #0 0xb4e03053 (/mtd_exe/lib/libasan.so.0+0xf053)
    #1 0x8b8d8f7b (/mtd_exe/WebServerApp/bin/libwebserver.so+0x7f7b)
    #2 0x8b8d9727 (/mtd_exe/WebServerApp/bin/libwebserver.so+0x8727)
    #3 0x8b8d9ffb (/mtd_exe/WebServerApp/bin/libwebserver.so+0x8ffb)
    #4 0x8b8ddecf (/mtd_exe/WebServerApp/bin/libwebserver.so+0xcecf)
    #5 0x7d5c68b (/mtd_exe/exeAPP+0x7d5c68b)
    #6 0x7d471db (/mtd_exe/exeAPP+0x7d471db)
    #7 0x26f095f (/mtd_exe/exeAPP+0x26f095f)
    #8 0x132cca3 (/mtd_exe/exeAPP+0x132cca3)
    #9 0x132cb9b (/mtd_exe/exeAPP+0x132cb9b)
    #10 0x1331c07 (/mtd_exe/exeAPP+0x1331c07)
    #11 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
    #12 0xae5b70f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
0x8b8eb964 is located 0 bytes to the right of global variable 'g_lighttpd (WebServer.cpp)'
(0x8b8eb920) of size 68
==215== SetCurrent: 0xad89b000 for thread 0x7b4bf430
==215== T485: stack [0x7b480000,0x7b4c0000) size 0x40000; local=0x7b4bed74
Shadow bytes around the buggy address:
  0x3171d6d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x3171d6e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x3171d6f0: 00 00 00 00 00 00 00 00 00==2 00 00 00 f9 f9 f9
  0x3171d700: f9 f9 f9 f9 04 f9 f9 f9 f9 f9 f9 f9 04 f9 f9 f9
 ==215== T486 exited
 ==215== T486 TSDDtor
  0x3171d710: f9 f9 f9 f9 00 00 00 00 00 00 00 00 04 f9 f9
 ==215== T487: stack [0x556e8000,0x558e8000) size 0x200000; local=0x558e6d74
 ==215== SetCurrent: 0x8fa37000 for thread 0x847f3430
 ==215== T488: stack [0x845f4000,0x847f4000) size 0x200000; local=0x847f2d74
=>0x3171d720: f9 f9 f9[00]00 00 00 00 00 00 00 04 f9 f9 f9
==215== T488 TSDDtor
  0x3171d730: f9 f9 f9 f9 04 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9
  0x3171d740: f9 f9 f9 f9 01 f9 f9 f9 f9 f9 f9 00 f9 f9 f9
==215== SetCurrent: 0x8fa36000 for thread 0x573ff430
==2 = T489: stack [0x57300000,0x57400000) size 0x100000; local=0x573fed74
==215== T489 exited
==215== T489 TSDDtor
              f9 f9 f9 f9 04 f9 f9 f9 f9 f9 f9 f9 04 f9 f9 f9
  0x3171d760: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00
  0x3171d770: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

Here is the backtrace analyzed with addr2line tool:

#0 0xb4e03053 (/mtd_exe/lib/libasan.so.0+0xf053)
__interceptor_strlen
/home/ygribov/build/tools/v4/sources/gcc_1/libsanitizer/asan/asan_interceptors.cc:454
453   if (flags()->replace_str) {
454     ASAN_READ_RANGE(s, length + 1);
455   }

#1 0x8b8d8f7b (/mtd_exe/WebServerApp/bin/libwebserver.so+0x7f7b)
ProcessLauncher
/home2/m.guseva/TV_2014/AP/MAIN2014/Smart/AP_WP_Smart_2014_Prj/REL/AP_WebServer/WebServer
/Swift/src/runtime/webserver/WebServer.cpp:297
294   char k_command_str[80] = {'\0'}; //"-k + secure_db_key + '\0' = 36 bytes;
295   strncat(k_command_str,"-k ", 3);
296   strncat(k_command_str,_secure_db_key, strlen(_secure_db_key));
297  //logger().debug("WEBSERVER: k_command str: %s\n",k_command_str);

...

#6 0x7d471db (/mtd_exe/exeAPP+0x7d471db)
CWebServerAppBase::t_OnUserMessage(PTEvent const*)
/home2/m.guseva/TV_2014/DTV/AP_WP/AP_WebServer/WebServer/Src/WebServerAppBase.cpp:525
521  //Retrieve key from secure storage and set for Lighttpd and Pairing plugin.
522  std::string secureKey = getSecureDBKey();  <here>
523  WebServerSetDBKey(secureKey.c_str());
524
525  WebServerStart();
526  WebServerLoadModule("libfcgicallbackplugin.so",
                                     (void*)WebConv_internal_dispatch );
527  WS_DEBUG("Pre call to WebServerLoadModule");
528  WebServerLoadModule("libpairingplugin.so",(void*)GetPINData);

The issue happened in strlen() function called for the _secure_db_key field which was set to the
string secureKey (converted to C-string char*) via WebServerSetDBKey() call.

The root cause is in WebServer and Lighttpd classes definitions and setLighttpdDBKey() member
functions. The proposed fix is below:

$ diff WebServer.h.orig WebServer.h
96a97
> #define SECURE_DB_KEY_LEN 64
121c122
<     char _secure_db_key[64];
---
>     char _secure_db_key[SECURE_DB_KEY_LEN+1];

$ diff WebServer.cpp.orig WebServer.cpp
88a89
>
285c286
<               char _secure_db_key[64];
---
>               char _secure_db_key[SECURE_DB_KEY_LEN+1];
289c290
<                       memset(_secure_db_key,'\0',64);
---
>                       memset(_secure_db_key,'\0', SECURE_DB_KEY_LEN+1);
449c450,451
< memcpy(_secure_db_key,db_key_value,64);
---
> memcpy(_secure_db_key,db_key_value,SECURE_DB_KEY_LEN);
>                           _secure_db_key[SECURE_DB_KEY_LEN] = '\0';
506c508
<         memset(_secure_db_key,'\0',64);
---
>         memset(_secure_db_key,'\0', SECURE_DB_KEY_LEN+1);
601c603,604
<             memcpy(_secure_db_key,db_key_value,64);
---
>             memcpy(_secure_db_key,db_key_value,SECURE_DB_KEY_LEN);
>             _secure_db_key[SECURE_DB_KEY_LEN] = '\0';
 

<example-real-3> The following  heap buffer-overflow was detected by ASan:
==214== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x75929a70
at pc 0x3b6853c bp 0x533fed54 sp 0x533fed44
READ of size 4 at 0x75929a70 thread T488 (SMPA_CPHandover)
    #0 0x3b6853b (/mtd_exe/exeAPP+0x3b6853b)
    #1 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
    #2 0xae5b70f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
0xad38d7d2 is located 0 bytes to the right of 2-byte region [0xad38d7d0,0xad38d7d2)
allocated by thread T399 (SMP_AsyncSelect) here:
    #0 0x3b6853b (/mtd_exe/exeAPP+0x3b6853b)
    #1 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
    #2 0xae5b70f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
0x75929a72 is located 0 bytes to the right of 2-byte region [0x75929a70,0x75929a72)
allocated by thread T399 (SMP_AsyncSelect) here:
Thread T487 (SMPA_CPHandover) created by T399 (SMP_AsyncSelect) here:
Thread T488 (SMPA_CPHandover) created by T399 (SMP_AsyncSelect) here:
    #0 0xb4dff22f (/mtd_exe/lib/libasan.so.0+0xb22f)
    #1 0x3b67d5b (/mtd_exe/exeAPP+0x3b67d5b)
    #2 0x3b6014f (/mtd_exe/exeAPP+0x3b6014f)
    #3 0x3bd6a4b (/mtd_exe/exeAPP+0x3bd6a4b)
    #4 0x3c1116b (/mtd_exe/exeAPP+0x3c1116b)
    #5 0x3c16beb (/mtd_exe/exeAPP+0x3c16beb)
    #6 0x3c2d493 (/mtd_exe/exeAPP+0x3c2d493)
    #7 0x3ca049f (/mtd_exe/exeAPP+0x3ca049f)
    #8 0x3ca0ac7 (/mtd_exe/exeAPP+0x3ca0ac7)
    #9 0x3c2dc73 (/mtd_exe/exeAPP+0x3c2dc73)
    #10 0x3c9c713 (/mtd_exe/exeAPP+0x3c9c713)
    #11 0x3c9d46f (/mtd_exe/exeAPP+0x3c9d46f)
    #12 0x3c2f933 (/mtd_exe/exeAPP+0x3c2f933)
    #13 0x3c785ef (/mtd_exe/exeAPP+0x3c785ef)
    #14 0x3c610e3 (/mtd_exe/exeAPP+0x3c610e3)
    #15 0x3c60487 (/mtd_exe/exeAPP+0x3c60487)
    #16 0x3c606cb (/mtd_exe/exeAPP+0x3c606cb)
    #17 0x3c6090f (/mtd_exe/exeAPP+0x3c6090f)
    #18 0x3c53c13 (/mtd_exe/exeAPP+0x3c53c13)
    #0 0xb4dff22f    #19 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0xb22f)
 (/mtd_exe/lib/libasan.so.0+0x1d26b)
 (/mtd_exe/exeAPP+0x3b67d5b)
    #2 0x3b5fb87 (/mtd_exe/exeAPP+0x3b5fb87)
    #3 0x3bd6a4b (/mtd_exe/exeAPP+0x3bd6a4b)
    #4 0x3c1116b (/mtd_exe/exeAPP+0x3c1116b)
    #5 0x3c16beb
    #6 0x3c2d493 created by T395 (dualtv) here:
    #7 0x3ca049f (/mtd_exe/exeAPP+0x3ca049f)
    #8 0x3ca0ac7 (/mtd_exe/exeAPP+0x3ca0ac7)
    #9 0x3c2dc73 (/mtd_exe/exeAPP+0x3c2dc73)
    #10 0x3c9c713 (/mtd_exe/exeAPP+0x3c9c713)
    #11 0x3c9d46f (/mtd_exe/exeAPP+0x3c9d46f)
    #12 0x3c2f933 (/mtd_exe/exeAPP+0x3c2f933)
    #13 0x3c785ef (/mtd_exe/exeAPP+0x3c785ef)
    #14 0x3c610e3 (/mtd_exe/exeAPP+0x3c610e3)
    #15 0x3c60487 (/mtd_exe/exeAPP+0x3c60487)
    #16 0x3c606cb (/mtd_exe/exeAPP+0x3c606cb)
    #17 0x3c6090f (/mtd_exe/exeAPP+0x3c6090f)
    #18 0x3c53c13 (/mtd_exe/exeAPP+0x3c53c13)
    #19 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
    #20 0xae5b70f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
Shadow bytes around the buggy address:
  0x2eb252f0: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04
  0x2eb25300: fa fa 00 04 fa fa 00 04 fa fa 00 04 fa fa 00 04
  0x2eb25310: fa fa 00 04 fa fa 00 04 fa fa fd fd fa fa fd fd
  0x2eb25320: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fd fd
=>0x2eb25340: fa fd fa fa fa fa fa[02]fa fa fa fa fd fd fa fa


Here is the backtrace analyzed with addr2line tool:

#0 0x3b6853b (/mtd_exe/exeAPP+0x3b6853b)
_SMPACPHandOver(void*)
/home2/m.guseva/TV_2014/DTV/AP_CNC/AP_DLNA/SMP/smpadaptation/src/controlpoint/SMPACPInternals.cpp:2455

2453         pstCPActionId = ( stCP_ActionIdList * ) SMPMemAllocMA( sizeof( stCP_ActionIdList ) );
2454         pstCPActionId->cpHandle = nCPHandle;
2455         pstCPActionId->actionId = ((ControlResult*)pCbInfo)->nActionId;

#1 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
__asan::ASanThread::ThreadStart()
/home/ygribov/build/tools/v4/sources/gcc_1/libsanitizer/asan/asan_thread.cc:99

   #1 0x3b67d5b (/mtd_exe/exeAPP+0x3b67d5b)
   _SMPASendAppInfo(int nCPHandle, int nMessageType, void* pCbInfo) <here>
   /home2/m.guseva/TV_2014/DTV/AP_CNC/AP_DLNA/SMP/smpadaptation/src/controlpoint/SMPACPInternals.cpp:2579
   2571 pstAppCbArgs->pCbInfo = pCbInfo;
   ...
   2578 SMPADebug(SMP_INFO_LEVEL,"[_SMPASendAppInfo] Creating Thread");
   2579 nRet = pthread_create( &pHandOverTask, &pHandOverAttrTask,
                     _SMPACPHandOver, (SMPVoid *)pstAppCbArgs);
   
   #2 0x3b6014f (/mtd_exe/exeAPP+0x3b6014f)
   SMPAGenericDeviceNotifyCb(int, SMP_EVENT, SMP_ERROR_CODE, stSMPAppList*)
   /home2/m.guseva/TV_2014/DTV/AP_CNC/AP_DLNA/SMP/smpadaptation/src/controlpoint/SMPAControlPoint.cpp:327
   324 SMPInt8* pCopiedDeviceHandle = NULL;
   325 SMPString* pDeviceHandleString = new SMPString((SMPChar*)pDeviceHandle);
   326 pCopiedDeviceHandle = (SMPInt8*)pDeviceHandleString->GetString();                          
   327 nErrorCode = _SMPASendAppInfo( nIntendedCP, DEVICE_ADDED, pCopiedDeviceHandle );

The root cause is in SMPAGenericDeviceNotifyCb() function when _SMPASendAppInfo() is called. The
proposed fix is below:

$ diff SMPAControlPoint.cpp.orig SMPAControlPoint.cpp
227,228c227,228
<        SMPInt8* pCopiedDeviceHandle = NULL;
<
---
>        SMPInt8* pCopiedDeviceHandle = (SMPInt8*)malloc(16);
>        SMPMemSet(pCopiedDeviceHandle, 0, 16);
230c230,232
<        pCopiedDeviceHandle = (SMPInt8*)pDeviceHandleString->GetString();
---
>        SMPSize  DeviceHandleLength = pDeviceHandleString->GetStringLength();
>        if (DeviceHandleLength > 16) DeviceHandleLength = 16;
>        SMPMemCpy(pCopiedDeviceHandle, pDeviceHandleString->GetString(), DeviceHandleLength);
324,326c326,331
<  SMPInt8* pCopiedDeviceHandle = NULL;
<  SMPString* pDeviceHandleString = new SMPString((SMPChar*)pDeviceHandle);
<  pCopiedDeviceHandle = (SMPInt8*)pDeviceHandleString->GetString();
---
>  SMPInt8* pCopiedDeviceHandle = (SMPInt8*)malloc(16);
>  SMPMemSet(pCopiedDeviceHandle, 0, 16);
>  SMPString* pDeviceHandleString = new SMPString((SMPChar*)pDeviceHandle);
>  SMPSize  DeviceHandleLength = pDeviceHandleString->GetStringLength();
>  if (DeviceHandleLength > 16) DeviceHandleLength = 16;
>  SMPMemCpy(pCopiedDeviceHandle, pDeviceHandleString->GetString(), DeviceHandleLength);

<example-real-4> The following  stack buffer-overflow was detected by ASan:
==239== ERROR: AddressSanitizer: stack-buffer-overflow on address 0xab43da68
at pc 0xb4e023f4 bp 0xab43d644 sp 0xab43d224
READ of size 4 at 0xab43da68 thread T45 (AppInitializer)
    #0 0xb4e023f3 (/mtd_exe/lib/libasan.so.0+0xe3f3)
    #1 0x143e08f (/mtd_exe/exeAPP+0x143e08f)
    #2 0x144a547 (/mtd_exe/exeAPP+0x144a547)
    #3 0x1448cc3 (/mtd_exe/exeAPP+0x1448cc3)
    #4 0x5fb86bb (/mtd_exe/exeAPP+0x5fb86bb)
    #5 0x5fb756f (/mtd_exe/exeAPP+0x5fb756f)
    #6 0x4be0477 (/mtd_exe/exeAPP+0x4be0477)
    #7 0x4b646bf (/mtd_exe/exeAPP+0x4b646bf)
    #8 0x5b3fa7f (/mtd_exe/exeAPP+0x5b3fa7f)
    #9 0x5ad6ceb (/mtd_exe/exeAPP+0x5ad6ceb)
    #10 0x5ae930b (/mtd_exe/exeAPP+0x5ae930b)
    #11 0x4be7143 (/mtd_exe/exeAPP+0x4be7143)
    #12 0x4b64b3f (/mtd_exe/exeAPP+0x4b64b3f)
    #13 0x46eb767 (/mtd_exe/exeAPP+0x46eb767)
    #14 0x1433bbf (/mtd_exe/exeAPP+0x1433bbf)
    #15 0x1438c4f (/mtd_exe/exeAPP+0x1438c4f)
    #16 0xb4e1126b (/mtd_exe/lib/libasan.so.0+0x1d26b)
    #17 0xae2a00f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
==239== T43 exited
==239== T43 TSDDtor
Address 0xab43da68 is located at offset 416 in frame <ResetComponentsProfile> of T45's stack:
  This frame has 55 object(s):
    [32, 33) 'wlanEncryptionInfo'
    [96, 97) 'WFDSetupInfo'
    [160, 161) 'wlanSetupDone'
    [224, 225) 'moip_auto_start'
    [288, 289) 'moip_update_available'
    [352, 353) 'ucRecognitionGestureHelpbar'
    [416, 417) 'ucCamPosition'
    [480, 481) 'val'
    [544, 545) 'ucRecognitionVoice'
    [608, 609) 'ucRecognitionVoiceTVWakeOn'
    [672, 673) 'ucRecognitionVoiceHelpbar'
    [736, 737) 'ucRecognitionGesture'
    [800, 801) 'ucRecognitionFace'
    [864, 865) 'ucRecognitionFirstRecognized'
    [928, 929) 'b3DGlassPaired'
    [992, 993) 'eDTVStatus'
    [1056, 1057) 'MasterNum'
    [1120, 1121) 'TVNumForSlave'
    [1184, 1188) 'cec_enable_option'
    [1248, 1252) 'cec_auto_standby_option'
    [1312, 1316) 'cec_receiver_auto_turn_on_option'
    [1376, 1380) 'nRecognitionVoiceLanguage'
    [1440, 1444) 'nRecognitionVoiceMagicWord'
    [1504, 1508) 'nRecognitionGestureHandTheme'
    [1568, 1572) 'nRecognitionGesturePointerSpeed'
    [1632, 1636) 'nSensitivityLevel'
    [1696, 1700) 'nShopMode'
    [1760, 1764) 'nHowlingLevel'
    [1824, 1828) 'uiVFreq'
    [1888, 1892) 'nRecognitionFrequencey'
    [1952, 1956) 'nEnableTTS'
    [2016, 2020) 'nTTSSpeaker'
    [2080, 2084) 'nVolume'
    [2144, 2148) 'nSpeed'
    [2208, 2212) 'nEnableTTS_tv'
    [2272, 2276) 'nTTSSpeaker_tv'
    [2336, 2340) 'nVolume_tv'
    [2400, 2404) 'nSpeed_tv'
    [2464, 2468) 'nVoiceGuideUserLevel'
    [2528, 2532) 'nHandWlang'
    [2592, 2596) 'tValue'
    [2656, 2662) 'TVAddrForSlave'
    [2720, 2728) 'pms'
    [2784, 2812) 'NetworkDescriptor'
    [2848, 2876) 'NetworkDescriptor_2'
    [2912, 2940) 'WFDDescriptor'
    [2976, 3004) 'CEC_Descriptor'
    [3040, 3068) 'MoIP_Descriptor'
    [3104, 3132) 'MotionApp_Descriptor'
    [3168, 3196) 'VoiceApp_Descriptor'
    [3232, 3260) 'RecognitionMW_Descriptor'
    [3296, 3324) 'BluetoothDescriptor_3DDTVStatus'
    [3360, 3388) 'BluetoothDescriptor_MasterNum'
    [3424, 3452) 'BluetoothDescriptor_tvAddrForSlave'
    [3488, 3516) 'BluetoothDescriptor_MasterNumForSlave'
HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
      (longjmp and C++ exceptions *are* supported)
Shadow bytes around the buggy address:
  0x35687af0: f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x35687b00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x35687b10: 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 01 f4 f4
  0x35687b20: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4
  0x35687b30: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4
=>0x35687b40: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2[01]f4 f4
  0x35687b50: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4
  0x35687b60: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4
  0x35687b70: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4
  0x35687b80: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4
  0x35687b90: f4 f2 f2 f2 f2 01 f4 f4 f4 f2 f2 f2 f2 01 f4 f4


Here is the backtrace analyzed with addr2line tool:

#0 0xb4e023f3 (/mtd_exe/lib/libasan.so.0+0xe3f3)
__interceptor_memcpy    <memcpy>
/home/ygribov/build/tools/v4/sources/gcc_1/libsanitizer/asan/asan_interceptors.cc:288
288     ASAN_READ_RANGE(from, size);
289     ASAN_WRITE_RANGE(to, size);

#1 0x143e08f (/mtd_exe/exeAPP+0x143e08f)
CSP0400::PCParcel::Write(void const*, int)
.../PCParcel.cpp:340

#2 0x144a547 (/mtd_exe/exeAPP+0x144a547)
CCPMSProxy::Set(int profile, unsigned char const* pBuffer, unsigned int size)
/home2/m.guseva/TV_2014/DTV/BP_MW/BP_CommSS/Src/PMS/PROXY/PMSProxy.cpp:177
176         CHECK_MARSHALLING(data_parcel.WriteInt32(size));
177         CHECK_MARSHALLING(data_parcel.Write(pBuffer, size));
178

#3 0x1448cc3 (/mtd_exe/exeAPP+0x1448cc3)
CCPMS::Set(int profile, unsigned char const* pBuffer, unsigned int size)
/home2/m.guseva/TV_2014/DTV/BP_MW/BP_CommSS/Src/PMS/COMMON/PMS.cpp:75
 73 {
 74         CC_INT_ASSERT(m_pImp);
 75         return m_pImp->Set(profile, pBuffer, size);
 76 }

#4 0x5fb86bb (/mtd_exe/exeAPP+0x5fb86bb)
CAPCNCTaskManager::ResetComponentsProfile()
.../APCNCTaskConfig.cpp:1151
1150  unsigned char ucCamPosition = 0;
1151  if (pms.Set(PROFILE_MOTIONAPP_CAMERA_POSITION, &ucCamPosition,
               PROFILE_SIZE_MOTIONAPP_CAMERA_POSITION) == false)

So the issue happened in memcpy() function. The proposed workaround:

$diff APCNCTaskConfig.cpp.orig APCNCTaskConfig.cpp
1151c1151
<       if (pms.Set(PROFILE_MOTIONAPP_CAMERA_POSITION, &ucCamPosition,
               PROFILE_SIZE_MOTIONAPP_CAMERA_POSITION) == false)
---
>       if (pms.Set(PROFILE_MOTIONAPP_CAMERA_POSITION, &ucCamPosition,
               sizeof(ucCamPosition)) == false)

<example-real-4> The following  stack buffer-overflow was detected by ASan:
<strncpy>
==283== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x7c25d990
at pc 0xb4e02520 bp 0x989fe85c sp 0x989fe43c
READ of size 4 at 0x7c25d990 thread T145 (CnS Server Mana)
==283== SetCurrent: 0x9c230000 for thread 0x641ff430
==283== T503: stack [0x64100000,0x64200000) size 0x100000; local=0x641fed74
0x7d519d53 is located 0 bytes to the right of 3-byte region [0x7d519d50,0x7d519d53)
allocated by thread T144 (CnS Server Mana) here:
    #0 0xb4e0251f (/mtd_exe/lib/libasan.so.0+0xe51f)
    #1 0xa8cde413 (/mtd_exe/Comp_LIB/libjson.so+0x20413)
    #2 0xa8bf81f7 (/mtd_exe/lib/libstdc++.so.6.0.17+0xa31f7)
    #3 0x7cb85c3 (/mtd_exe/exeAPP+0x7cb85c3)
    #4 0x7cb8803 (/mtd_exe/exeAPP+0x7cb8803)
    #5 0x7c73cbf (/mtd_exe/exeAPP+0x7c73cbf)
    #6 0x7c8e13f (/mtd_exe/exeAPP+0x7c8e13f)
    #7 0x7c1d60f (/mtd_exe/exeAPP+0x7c1d60f)
    #8 0x7c1e74b (/mtd_exe/exeAPP+0x7c1e74b)
    #9 0x158c3db (/mtd_exe/exeAPP+0x158c3db)
    #10 0x158c2d3 (/mtd_exe/exeAPP+0x158c2d3)
    #11 0x159133f (/mtd_exe/exeAPP+0x159133f)
    #12 0xb4e11397 (/mtd_exe/lib/libasan.so.0+0x1d397)
    #13 0xa93070f7 (/mtd_exe/lib/libpthread-2.17.so+0x70f7)
Shadow bytes around the buggy address:
  0x2faa3350: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fd fd
  0x2faa3360: fa fa fa fa fa fa fa fa fa fa fd fd fa fa fd fd
  0x2faa3370: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fa fa
  0x2faa3380: fa fa fd fd fa fa fa fa fa fa fd fd fa fa fd fd
  0x2faa3390: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd
=>0x2faa33a0: fa fa fd fd fa fa 00 04 fa fa[03]fa fa fa fa fa
  0x2faa33b0: fa fa fd fa fa fa fd fd fa fa fa fa fa fa fd fd
  0x2faa33c0: fa fa fa fa fa fa fd fd fa fa fa fa fa fa fa fa
  0x2faa33d0: fa fa fa fa fa fa fd fa fa fa fd fd fa fa fd fa
  0x2faa33e0: fa fa fd fd fa fa fd fa fa fa fd fd fa fa fa fa
  0x2faa33f0: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fd

Here is the backtrace analyzed with addr2line tool:

#0 0xb4e0251f (/mtd_exe/lib/libasan.so.0+0xe51f)
__interceptor_memcpy
/home1/m.guseva/fox-p/vd47_a15/toolchain/build.arm.cortex-a15/sources/gcc_1/libsanitizer/
asan/asan_interceptors.cc:288
288     ASAN_READ_RANGE(from, size);
289     ASAN_WRITE_RANGE(to, size);

#1 0xa8cde413 (/mtd_exe/Comp_LIB/libjson.so+0x20413)
char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag)
??:?

#2 0xa8bf81f7 (/mtd_exe/lib/libstdc++.so.6.0.17+0xa31f7)
_S_construct_aux<const char*>
/home/alexey.merzlyakov/fox-p/vd47_a15/toolchain/build/obj/gcc_final/arm-v7a15v4r3-linux-gnueabi/
libstdc++-v3/include/bits/basic_string.h:1722

#3 0x7cb85c3 (/mtd_exe/exeAPP+0x7cb85c3)
CCNSVTP::PrintVTPLocal(CCNSVTP::CCNSVTP_TYPE type, char* str)
/home2/m.guseva/GOLFP_2014/AP_MM/AP_ConversationApp/ClientAgent/Src/CnSProfile.cpp:416
414         if (NULL != str)^M
415         {^M
416                 std::string str_text = (std::string)str;^M

#4 0x7cb8803 (/mtd_exe/exeAPP+0x7cb8803)
CCNSVTP::PrintVTP(CCNSVTP::CCNSVTP_TYPE type, char * str, int bool_result)
/home2/m.guseva/GOLFP_2014/AP_MM/AP_ConversationApp/ClientAgent/Src/CnSProfile.cpp:241
241   PrintVTPLocal(VTP_CONVERSATION_STATE_DATA,str);^M
242   break;^M


#5 0x7c73cbf (/mtd_exe/exeAPP+0x7c73cbf)
CCnSParsePacket::t_ParseConnectionInfo(std::string&)
/home2/m.guseva/GOLFP_2014/AP_MM/AP_ConversationApp/ClientAgent/Src/CnSParsePacket.cpp:639
635   char * pChar = NULL ;
636   int length = stConfServer.szStat.size();
637   pChar = new char[length+1];
638  ::strncpy(pChar,stConfServer.szStat.c_str(),length);
639  CCNSVTP::GetInstance()->PrintVTP(CCNSVTP::CCNSVTP_TYPE_STATE_DATA,pChar,0);

According the strncpy POSIX specification:
If there is no null byte in the first n bytes of the array pointed to by s2, the result will not be
null-terminated.

So the pChar array actually is not null terminated. The proposed fix is:

$ diff CnSParsePacket.cpp.orig CnSParsePacket.cpp
638c638
<  ::strncpy(pChar,stConfServer.szStat.c_str(),length);
---
>  ::strncpy(pChar,stConfServer.szStat.c_str(),length+1);


{KSAN}
Preface
Kernel address sanitizer is a solution suitable to catch bugs known as ?use
after free?, ?buffer-overflow?, ?use of non initialized memory?, etc. This
system software helps to inspect kernel code dynamically during its
execution. Testing of VDLinux kernel with KASAN has showed that it is a
good and efficient tool that make it possible to find really serious bugs in
kernel code (including Linux kernel generic functions).
The scope of issues that can be detected is much higher than in other
memory checking solutions, the performance is also a good side of KASAN
[1].
So, use of the tool can greatly help developers to fix most of mistakes made
during their projects and prepare the solutions to be integrated in the final
product.

Now KASAN supports a number of checkers: stack checker, SLUB checker, vmalloc checker and buddy-level checker.

Preparation
To check the kernel with KASAN you must perform a number of simple
preliminary steps (KASAN patches must be applied before the first step of the
following list):
1. Enable CONFIG_SLUB_DEBUG option in the kernel ?.config? file
(KASAN can work wihout the option, but it is highly recommended to
run KASAN with slub debug functionality enabled);
2. Enable CONFIG_KASAN option to turn on basic KASAN support in the
kernel;
3. Enable CONFIG_KASAN_SLUB option if SLUB-related analysis is
necessary;
4. Enable CONFIG_KASAN_VMALLOC option if vmalloc-related analysis is
necessary;
5. Enable CONFIG_KASAN_STACK option to turn on stack issues detection
6. Enable CONFIG_KASAN_GLOBALS option for usage of global variables
checker;
7. Enable CONFIG_KASAN_UAR option to use use-after-return checker;
8. Build the kernel and modules with appropriate toolchain which
supports KASAN instrumentation options
(arm-v7a15v5r2-linux-gnueabi).
Note
If you want to check the whole kernel enable the option
CONFIG_KASAN_SANITIZE_ALL. In other cases see the section ?Usage of
KASAN with Separate Kernel Files?.
KASAN-related build options enable all necessary toolchain flags. As a result
after these steps KASAN-instrumented kernel will be ready for debugging.
Note
On Orsay platform kernel image can be larger than available mmc partition,
in this case compressed kernel image should be used. An additional option is
required to be disabled: CONFIG_AUTO_ZRELADDR.
To run user space software with instrumented kernel it is necessary to rebuild
all kernel modules to instrument them with KASAN, because stack
instrumentation changes size of thread_info structure and this change affects
all the system. If some modules are not rebuilt the system cannot be
started properly.
Separate Instrumentation
It is possible to instrument only loads or stores by usage of special toolchain
parameters. The syntax for this parameters is:
--param <parameter name>=<value>
Where <parameter name> in this case can be asan-instrument-reads and
asan-instrument-writes and <value> is ?0? or ?1?. To enable disable
instrumentation of writes, for example, it is enough to provide an additional
parameter to the compiler:
--param asan-instrument-writes=0
To disable instrumentation of reads or writes in the context of the kernel it is
necessary to provide additional CFLAGS for the whole kernel or for separate
modules.
Usage of KASAN with Separate Kernel Files
To instrument only a set of files with KASAN the option
CONFIG_KASAN_SANITIZE_ALL should be disabled. For each file that should
be instrumented corresponding Makefile should include an entry of the
following format:
KASAN_SANITIZE_<object file name>.o := y
<object file name> here is a file name of the object file to be instrumented.

Example of Analysis
When all preliminary work is done it is possible to check the kernel with
KASAN. Kernel should be flashed to MMC using SERET ordinary way,
modules should be changed to instrumented modules (see the point 7 in
Preparation part of the document).
KASAN analysis is an automatic activity, no assistance of human is required.
For every detected issue KASAN prints a report which has typical structure
regardless of type of the issue.

Typical report has the following format:
AddressSanitizer: buffer overflow in kasan_do_bo_kmalloc+0x58/0x7c at addr
e07d0012
=============================================================================
BUG kmalloc-64 (Tainted: G B ): kasan error
-----------------------------------------------------------------------------
INFO: Allocated in kasan_do_bo_kmalloc+0x34/0x7c age=0 cpu=0 pid=1
        kasan_do_bo_kmalloc+0x34/0x7c
        kasan_tests_init+0x10/0x44
        do_one_initcall+0x11c/0x2bc
        kernel_init_freeable+0x29c/0x350
        kernel_init+0x14/0xf8
        ret_from_fork+0x14/0x3c
INFO: Freed in kasan_tests_init+0xc/0x44 age=1 cpu=0 pid=1
        do_one_initcall+0x11c/0x2bc
        kernel_init_freeable+0x29c/0x350
        kernel_init+0x14/0xf8
        ret_from_fork+0x14/0x3c
INFO: Slab 0xe1719a00 objects=16 used=1 fp=0xe07d0100 flags=0x0080
INFO: Object 0xe07d0000 @offset=0 fp=0xe07d0f00
Object e07d0000: 00 0f 7d e0 6e 5f 74 65 73 74 73 5f 69 6e 69
74 ..}.n_tests_init Object e07d0010: 00 5f 63 61 63 68 65 00 00 00 00 00 00 00
00 00 ._cache.........
Object e07d0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ................
Object e07d0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ................
Padding e07d00e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ................
Padding e07d00f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 ................
CPU: 0 PID: 1 Comm: swapper/0 Tainted: G B 3.16.0-rc1+ #129
[<8001a7c0>] (unwind_backtrace) from [<80015e6c>] (show_stack+0x14/0x20)
[<80015e6c>] (show_stack) from [<806bd594>] (dump_stack+0xa4/0xcc) [<806bd594>]
(dump_stack) from [<8014de0c>] (kasan_report_error+0x300/0x364) [<8014de0c>]
(kasan_report_error) from [<8014d3a0>] (check_memory_region+0x16c/0x234)
[<8014d3a0>] (check_memory_region) from [<8014df4c>]
(kasan_do_bo_kmalloc+0x58/0x7c) [<8014df4c>] (kasan_do_bo_kmalloc) from
[<808515b8>] (kasan_tests_init+0x10/0x44) [<808515b8>] (kasan_tests_init) from
[<80008d48>] (do_one_initcall+0x11c/0x2bc) [<80008d48>] (do_one_initcall) from
[<8083e0c8>] (kernel_init_freeable+0x29c/0x350)
[<8083e0c8>] (kernel_init_freeable) from [<806b6a30>] (kernel_init+0x14/0xf8)
[<806b6a30>] (kernel_init) from [<800109b8>] (ret_from_fork+0x14/0x3c) Write of
size 1 by thread T1:
Memory state around the buggy address:
e07cfd80: fd fd 00 00 00 00 00 00 00 00 00 00 00 fc fc fc
e07cfe00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
e07cfe80: fc 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc
e07cff00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
e07cff80: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
>e07d0000: 00 00 01 fc fc fc fc fc fc fc fc fc fc fc fc fc
^
e07d0080: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
e07d0100: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
e07d0180: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
e07d0200: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
e07d0280: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
==================================================================

This listing corresponds to newly detected buffer overflow issue at the
address 0xE07D0012. This log shows allocation/deallocation paths of the
memory, memory state around the address 0xE07D0012 and state of the
shadow memory.
Thus, it is possible to realize what kind of issue was found, which client
allocated the memory and which freed, what call-chain caused the issue and
why KASAN considers this behavior as a bug (shadow memory state helps to
understand the reason).
This shadow memory state shows that seven bytes correspond to redzone and
only one is allocated (because state of shadow memory entry corresponding
to the address is 0x01).
All possible states of shadow memory entries are defined in
?mm/kasan/kasan.h?.

#define KASAN_FREE_PAGE 0xFF /* page was freed */
#define KASAN_PAGE_REDZONE 0xFE /* redzone for kmalloc_large allocations
*/
#define KASAN_SLAB_REDZONE 0xFD /* Slab page redzone, does not belong to
any slub object */
#define KASAN_KMALLOC_REDZONE 0xFC /* redzone inside slub object */
#define KASAN_KMALLOC_FREE 0xFB /* object was freed
(kmem_cache_free/kfree) */
#define KASAN_SLAB_FREE 0xFA /* free slab page */
#define KASAN_SHADOW_GAP 0xF9 /* address belongs to shadow memory */
#define KASAN_VMALLOC_REDZONE 0xF8 /* address belongs to vmalloc guard page
*/
#define KASAN_VMALLOC_FREE 0xF7 /* memory was freed by vfree call */
/* Stack redzones */
#define KASAN_STACK_LEFT 0xF1
#define KASAN_STACK_MID 0xF2
#define KASAN_STACK_RIGHT 0xF3
#define KASAN_STACK_PARTIAL 0xF4

SLUB issues are represented by allocation/deallocation paths, backtrace
(sometimes it is not available), states of memory and shadow memory.
BUDDY (page) issues are represented by ?dump_page out?, backtrace and
shadow memory state.
Stack issues are represented by a backtrace and shadow memory state.
In all cases shadow memory state will be available for analysis.
Note
During development of KASAN 14_VDFuture project's team has found a
number of issues in the very core of the Linux kernel. We think that it is
usable and very effective tool appropriate for kernel engineers with any level
of expertise.
Often it is enough to know the address where the problem is happened, type
of the issue and a backtrace to fix it. Shadow memory helps to understand the
problem little bit deeper.

Examples of Real World Issues
To demonstrate an approach to find issues with KASAN a number of
real-world issues are described. All these issues were fixed and included in
KASAN patch set.
Lets look at log messages generated by KASAN stack checker:
First log:
==================================================================
AddressSanitizer: out of bounds on stack in idr_for_each+0x168/0x1d0 at addr
dfe49d3c
CPU: 0 PID: 128 Comm: fsnotify_mark Not tainted 3.16.0-rc3+ #256
[<8001a530>] (unwind_backtrace) from [<80015bf0>] (show_stack+0x14/0x20)
[<80015bf0>] (show_stack) from [<80699ad8>] (dump_stack+0x90/0xa0)
[<80699ad8>] (dump_stack) from [<8013dff8>] (kasan_report_error+0x158/0x3a4)
[<8013dff8>] (kasan_report_error) from [<8013d764>]
(check_memory_region+0x148/0x210)
[<8013d764>] (check_memory_region) from [<80336628>] (idr_for_each+0x168/0x1d0)
[<80336628>] (idr_for_each) from [<8019e688>]
(inotify_free_group_priv+0x28/0x70)
[<8019e688>] (inotify_free_group_priv) from [<8019b944>]
(fsnotify_final_destroy_group+0x38/0x50)
[<8019b944>] (fsnotify_final_destroy_group) from [<8019c6a0>]
(fsnotify_put_mark+0x50/0x7c)
[<8019c6a0>] (fsnotify_put_mark) from [<8019c894>]
(fsnotify_mark_destroy+0x1c8/0x254)
[<8019c894>] (fsnotify_mark_destroy) from [<8005b7c8>] (kthread+0x19c/0x1bc)
[<8005b7c8>] (kthread) from [<80010838>] (ret_from_fork+0x14/0x3c)
Read of size 4 by thread T128:
Memory state around the buggy address:
dfe49a80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
dfe49b00: 00 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00
dfe49b80: 00 00 00 00 00 00 00 00 03 f4 f4 f4 f3 f3 f3 f3
dfe49c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
dfe49c80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>dfe49d00: 00 00 00 00 f1 f1 f1 f1 00 00 04 f4 f3 f3 f3 f3
^
dfe49d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
dfe49e00: 00 00 00 00 f1 f1 f1 f1 00 f4 f4 f4 f2 f2 f2 f2
dfe49e80: 00 00 04 f4 f3 f3 f3 f3 00 00 00 00 00 00 00 00
dfe49f00: f1 f1 f1 f1 00 00 00 00 00 04 f4 f4 f3 f3 f3 f3
dfe49f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
==================================================================

Stack checker has found an out-of-bounds access issue on the stack. The first
one was detected in the function idr_for_each and the second in idr_destroy.
Both logs point to the same address: 0xdfe49d3c. Both logs provide back
traces showing how these functions were invoked. So, the faulting trace is
fsnotify_mark_destroy ? fsnotify_put_mark ? fsnotify_final_destroy_group ?
inotify_free_group_priv ? (idr_for_each/idr_destroy) .
Checking memory state helps to understand why KASAN thinks that this is
out-of-bounds issue: 0xF1 in both cases corresponds to KASAN_STACK_LEFT
redzone, thus it was an access at the left stack boundary.

Lets examine both faulty functions.
The first one:
int idr_for_each(struct idr *idp, int (*fn)(int id, void *p, void *data), void *data)
{
    int n, id, max, error = 0;
    struct idr_layer *p;
    struct idr_layer *pa[MAX_IDR_LEVEL];
    struct idr_layer **paa = &pa[0];
   
    n = idp->layers * IDR_BITS;
   
    p = rcu_dereference_raw(idp->top);
    max = 1 << n;
   
    id = 0;
    while (id < max)
    {
        while (n > 0 && p)
        {
            n -= IDR_BITS;
            *paa++ = p;
            p = rcu_dereference_raw(p->ary[(id >> n) & IDR_MASK]);
        }
        if (p)
        {
            error = fn(id, (void *)p, data);
            if (error)
            break;
        }
        id += 1 << n;
       
        while (n < fls(id))
        {
            n += IDR_BITS;
            p = *--paa;
        }
    }
    return error;
}

The pointer array pa is an evident candidate for out-of-bounds access. After
some analysis of a function it is easy to make sure that both functions access
the array out of bounds. The simplest fix is growing the array on the size of
one pointer and setting paa to point initially to the second (&pa[1]) entry of
the array.

Non-supported Functionality
This time only non-initialized-read checker is not implemented.
?Use-after-return? and global data ?out-of-bounds? checkers were
implemented in KASAN in the latest release, but little bit different to their
user space analogues.


={============================================================================
*kt_dev_prob_005* use-after-free error

<1>: use after free
Here is an example usage (classical use-after-free error):

$ cat uaf.c

#include <stdlib.h>
int main() {
  int *x = malloc(10 * sizeof(int));
  free(x);
  return x[5];
}

<2> from ansic, p167

for( p = haed; p != NULL; p = p->next )
   free(p);

shall be:

for( p = head; p != NULL; p = q )
{
   q = p->next;
   free(p);
}

for( p = head; p != NULL; )
{
  q = p;
  p = p->next;
  free(q);
}


={============================================================================
*kt_dev_prob_006* print ansi color 


debug() {
    # Note: echo -e doesn't work on OS X's default bash (3.2).
    printf '\n\033[0;32m%s\n' "$*"
    tput sgr0
}

Esc[Value;...;Valuem 	Set Graphics Mode:

Calls the graphics functions specified by the following values. These specified functions remain
active until the next occurrence of this escape sequence. Graphics mode changes the colors and
attributes of text (such as bold and underline) displayed on the screen.
 

Text attributes
0	All attributes off
1	Bold on
4	Underscore (on monochrome display adapter only)
5	Blink on
7	Reverse video on
8	Concealed on
 
Foreground colors
30	Black
31	Red
32	Green
33	Yellow
34	Blue
35	Magenta
36	Cyan
37	White
 
Background colors
40	Black
41	Red
42	Green
43	Yellow
44	Blue
45	Magenta
46	Cyan
47	White
 
Parameters 30 through 47 meet the ISO 6429 standard.

("\033[04;31;47m ansi: \033[m \n" );

#define ESC '\033'
#define EOE 'm'
#define DEFAULT_COLOR "04;31;47"
#define DEFAULT_COLOR "01;31"

int main()
{
    printf("\033[" DEFAULT_COLOR "m ansi: \033[m \n" );
    return 0;
}


={============================================================================
*kt_dev_prob_007* random number

#include <stdlib.h>

The seed

void Randomize()
{
  srand( (unsigned int) (time(NULL)%10000));
}

time() returns the number of seconds elapsed since 00:00:00 GMT, Jan. 1, 1970. 
time_t time(time_t *timeptr); 

int PoissonRandom( double expectedvalue )
{
  int n = 0;
  double limit;
  double x;

  limit = exp(-expectedvalue);
  x = rand()/(double) INT_MAX;
  while( x > limit )
  {
    n++;
    x *= rand()/(double) INT_MAX;
  }

  return n;
}


={============================================================================
*kt_dev_prob_008* elapsed time 

RETURN VALUE

The value returned is the CPU time used so far as a clock_t; to get the number of seconds used,
divide by CLOCKS_PER_SEC. If the processor time used is not available or its value cannot be
    represented, the function returns the value (clock_t) -1.

#include <time.h>

float Time(int flag)
{
  static clock_t start; // [note] static
  clock_t end;

  if( flag == START )
  {
    start = clock();
    return 0.0;
  }
  else
  {
    end = clock();
    return (end-start) / CLK_TCK; // or CLOCK_PER_SEC
  }
}

void Usuage()
{
  float elapsedtime;

  Time(START);

  ...

  elapsedtime = Time(END);

  printf("elapsed time to complete %d searches is %f seconds \n", searchcount, elapsedtime );
  ...
}


={============================================================================
*kt_dev_prob_009* debug printf 

{ndebug}
The assert macro is defined in cassert header. It depends on a preprocessor varaible named NDEBUG.
If NDEBUG is defined, assert do nothing. By default, it's not defined.

If the macro NDEBUG was defined at the moment <assert.h> was last included, the macro assert()
generates no code, and hence does nothing at all. Otherwise, the macro assert() prints an error
message to standard error and terminates the program by calling abort(3) if expression is 'false'
(i.e., compares equal to zero).

<exercise>
From ansic, p91. exercise 4-14. Define a macro swap(t,x,y) that interchanges two arguments of type
t. (Block structure will help.)

#define swap(t, x, y) do {\
   t z;\
   z = x;\
   x = y;\
   y = z;\
} while(0)

If use C++ then make it more useful:

#define swap(x, y) do {\
  decltype(x) z;\
  z = x;\
  x = y;\
  y = z;\
} while(0)


{conditional}

#define BSD 3
#define SYSV 4

#define HEHE BSD
//#define HEHE SYSV

#if HEHE == SYSV
  #define HDR "x/sysv.h"
#elif HEHE == BSD
  #define HDR "y/bsd.h"
#endif

int main() {
  printf("hdr %s\n", HDR);
  return 0;
}


{useful-macros}
#define abs(n) ((n) < 0 ? -(n) : (n))

#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

// a is array
#define NELEMENTS(a) (sizeof(a)/sizeof(*(a)))

// build enum and string table
#define FSM_E(x) {x,#x}

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  FSM_E(BOOT_EVENT_READY),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

enum Events
{
  // BOOT_EVENTS
  BOOT_EVENT_CLOSED = 0x01,
  BOOT_EVENT_READY,
  ...
  BOOT_EVENT_STOP,
};


{variable-arguments}
The va_arg, va_copy, va_end, and va_start macros provide a portable way to access the arguments to a
function when the function takes a variable number of arguments. There are two versions of the
macros: The macros defined in STDARG.H conform to the ISO C99 standard; the macros defined in
VARARGS.H are deprecated but are retained for backward compatibility with code that was written
before the ANSI C89 standard. 

<from-linux>
STDARG(3) Linux Programmer's Manual

NAME
stdarg, va_start, va_arg, va_end, va_copy - variable argument lists

SYNOPSIS
 #include <stdarg.h>

 void va_start(va_list ap, last);
 type va_arg(va_list ap, type); // [KT] see type
 void va_end(va_list ap);
 void va_copy(va_list dest, va_list src);

DESCRIPTION

A function may be called with a [varying-number] of arguments of [varying-types]. The include file
<stdarg.h> declares a type va_list and defines three [macros] for stepping through a list of arguments
whose number and types are not known to the called function.

The called function must declare an object of type va_list which is used by the macros va_start(),
va_arg(), and va_end().

va_start() 

The va_start() macro initializes [ap] for subsequent use by va_arg() and va_end(), and must be called
first.

The argument last is the name of the last argument before the variable argument list, that is, the
last argument of which the calling function knows the type.

Because the address of this argument may be used in the va_start() macro, it should not be declared
as a register variable, or as a function or an array type.

va_arg()

The va_arg() macro expands to an expression that has the type and value of the next argument in the
call. The  argument ap is the va_list ap initialized by va_start(). Each call to va_arg() modifies
ap so that the next call returns the next argument. The argument type is a type name specified so
that the type of a pointer to an object that has the specified type can be obtained simply by
adding a * to type.

The first use of the va_arg() macro after that of the va_start() macro returns the argument after
last. Successive invocations return the values of the remaining arguments.

If there is no next argument, or if type is not compatible with the type of the actual next argument
(as promoted according to the default argument promotions), random errors will occur. ~

If ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the
return of that function.

va_end()

Each invocation of va_start() must be matched by a corresponding invocation of va_end() in the same
function. After the call va_end(ap) the variable ap is undefined. Multiple traversals of the list,
each bracketed by va_start() and va_end() are possible. va_end() may be a macro or a function.

example

#include <iostream>
#include <cstdarg>

void argprint(int num_args, ...)
{
  va_list ap;

  va_start(ap, num_args);
  for( int i = 0; i < num_args; i++)
  {
    std::cout << "arg:" << i << " is " << va_arg(ap, int) << std::endl;
  }

  va_end(ap);
}

int main()
{
  std::cout << "--{ main " << std::endl;

  argprint( 3, 10, 20, 30 );

  std::cout << "--} main " << std::endl;
}

The function foo takes a string of format characters and prints out the argument associated with
each format character based on the type.

#include <stdio.h>
#include <stdarg.h>

void
foo(char *fmt, ...)
{
  va_list ap;
  int d;
  char c, *s;

  va_start(ap, fmt);
  while (*fmt)             // note null is a termination condition
      switch (*fmt++) {    // note see ++
      case 's':              /* string */
          s = va_arg(ap, char *);
          printf("string %s\n", s);
          break;
      case 'd':              /* int */
          d = va_arg(ap, int);
          printf("int %d\n", d);
          break;
      case 'c':              /* char */
          /* need a cast here since va_arg only
             takes fully promoted types */
          c = (char) va_arg(ap, int);
          printf("char %c\n", c);
          break;
      }
  va_end(ap);
}


{snprintf-and-vsnprintf}
#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

#include <stdarg.h>

int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);

The functions vprintf(), vfprintf(), vsprintf(), vsnprintf() are equivalent to the functions
printf(), fprintf(), sprintf(), snprintf(), respectively, except that they are called with a
<va_list> instead of a variable number of arguments.  These  functions  do not call the va_end
macro. Because they invoke the va_arg macro, the value of ap is undefined after the call.  See
stdarg(3).

The functions snprintf() and vsnprintf() do not write more than size bytes (including the
terminating null byte ('\0')). If the output was truncated due to this limit then the return value
is the number of characters (excluding the terminating null byte) which would have been written to
the final string if enough space had been available. Thus, a return value of size or more means that
the output was truncated.  (See also below under NOTES.) If an output error is encountered, a
negative value is returned.


{swallowing-the-semicolon}
http://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html#Swallowing-the-Semicolon

<keys>
This is only when uses macros which has block, is used like function in a single statement but not
in expression. For example, think

if( do { ... } while(0); )

Not valid code. This trick is useful but macros still has its own limiations.
<keys>

Often it is desirable to define a macro that expands into a compound statement. Consider, for
example, the following macro, that advances a pointer (the argument p says where to find it) across
whitespace characters:

#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
 while (p < lim) {            \
   if (*p++ != ' ') {         \
     p--; break; }}}

Here backslash-newline is used to split the macro definition, which must be a single logical line,
so that it resembles the way such code would be laid out if not part of a macro definition.

A call to this macro might be SKIP_SPACES (p, lim). Strictly speaking, the call expands to a
compound statement, which is a complete statement with no need for a semicolon to end it. However,
since it looks like a function call, it minimizes confusion if you can use it like a function call,
writing a semicolon afterward, as in SKIP_SPACES (p, lim);

This can cause trouble before 'else' statements, because the semicolon is actually a null statement.
Suppose you write

if (*p != 0)                     // if (*p != 0)
 SKIP_SPACES (p, lim);           //    {...};
else ...                         // else ...

The presence of two statements(the compound statement and a null statement) in between the if
condition and the else makes 'invalid' C code because must be one statement.

sam01.c:161:3: error: 'else' without a previous 'if'

The definition of the macro SKIP_SPACES can be altered to solve this problem, using a do ... while
statement. Here is how:

#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
    while (p < lim) {            \
      if (*p++ != ' ') {         \
        p--; break; }}}          \
while (0)

Now SKIP_SPACES (p, lim); expands into

if (*p != 0)
   do {...} while (0);
else ...

which is one statement. The loop executes exactly once; most compilers generate no extra code for
it. 

note that there should be NO spaces after \;otherwise compile error.


{stringification}
http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification

Sometimes you may want to convert a macro argument into a string constant. Parameters are not
replaced inside string constants, but you can use the '#' preprocessing operator instead. When a
macro parameter is used with a leading '#', the preprocessor replaces it with the literal text of
the actual argument, converted to a string constant. Unlike normal parameter replacement, the
argument is [not-macro-expanded-first]. This is called stringification.

There is no way to combine an argument with surrounding text and stringify it all together. Instead,
you can write a series of adjacent string constants and stringified arguments. The preprocessor will
replace the stringified arguments with string constants. The C compiler will then combine all the
adjacent string constants into one long string.

Here is an example of a macro definition that uses stringification:

     #define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

     WARN_IF (x == 0);
          ==> do { if (x == 0)
                fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);

The other example from ansic, p90.

#define dprint(expr)    printf(#expr " = %g\n", expr )

dprint(x/y);
   ==> printf( "x/y = %g\n", x/y );

The argument for EXP is substituted once, as-is, into the if statement, and once, stringified, into
the argument to fprintf. If x were a macro, it would be expanded in the if statement, but not in the
string.

The do and while (0) are a kludge to make it possible to write WARN_IF (arg);, which the resemblance
of WARN_IF to a function would make C programmers want to do; see Swallowing the Semicolon.

Stringification in C involves more than putting double-quote characters around the fragment. The
preprocessor backslash-escapes the quotes surrounding embedded string constants, and all backslashes
within string and character constants, in order to get a valid C string constant with the proper
contents. Thus, stringifying p = "foo\n"; results in "p = \"foo\\n\";". However, backslashes that
are not inside string or character constants are not duplicated: '\n' by itself stringifies to "\n".

All leading and trailing whitespace in text being stringified is ignored. Any sequence of whitespace
in the middle of the text is converted to a single space in the stringified result. Comments are
replaced by whitespace long before stringification happens, so they never appear in stringified
text.

There is no way to convert a macro argument into a character constant.

If you want to stringify [the-result-of-expansion] of a macro argument, you have to use [two-levels]
of macros.

#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
    ==> "foo"  // [KT] is not "4" because not macro-expanded
xstr (foo)
    ==> xstr (4)
    ==> str (4)
    ==> "4"

s is stringified when it is used in str, so it is not macro-expanded first. But s is an ordinary
argument to xstr, so it is completely macro-expanded before xstr itself is expanded (see Argument
Prescan). Therefore, by the time str gets to its argument, it has already been macro-expanded. 

#include <iostream>

#define PRINT_TRUE true

#define PRINT_STRING(exp) \
   do { \
      std::cout << "arg:" << #exp << std::endl; \
      std::cout << "arg:" << exp << std::endl; } \
   while(0)

#define XPRINT_STRING(s) PRINT_STRING(s)

int main()
{
  std::cout << "--{ main " << std::endl;

  PRINT_STRING(true);
  XPRINT_STRING(true);

  std::cout << "--} main " << std::endl;
}

arg:PRINT_TRUE    // stringified but not expanded
arg:1             // expanded
arg:true          // expanded before stringified
arg:1:            // expanded


<example-one>

Although macro expansion does not occur within a quoted string, the text of the macro arguments can
be quoted and treated as a string literal by using the "#" directive (also known as the "Stringizing
Operator"). For example, with the macro

#define QUOTEME(x) #x

the code

printf("%s\n", QUOTEME(1+2));

will expand to

printf("%s\n", "1+2");

This capability can be used with automatic string literal concatenation to
make debugging macros. For example, the macro in

#define dumpme(x, fmt) printf("%s:%u: %s=" fmt, __FILE__, __LINE__, #x, x)
 
int some_function() {
  int foo;
  /* a lot of complicated code goes here */
  dumpme(foo, "%d");
  /* more complicated code goes here */
}

would print the name of an [expression] and its value, along with the file name and the line number.

<example-two>

#define KT_CREATE(value)	JPA_CREATE( #value, value)

void JPA_CREATE(const char* vname, int value)
{
  printf("JPA_CREATE: value=%s value=%d...\n", vname, value );
}

int main(int argc, char *argv[])
{
  int val = 3;
  int is_this_my_own = 4;

  KT_CREATE(val);
  KT_CREATE(is_this_my_own);

  return;
}

output:
JPA_CREATE: value=val value=3...
JPA_CREATE: value=is_this_my_own value=4...


{variadic-macros}

http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html

A macro can be declared to accept a variable number of arguments much as a function can. The syntax
for defining the macro is similar to that of a function. Here is an example:

     #define eprintf(...) fprintf (stderr, __VA_ARGS__)

This kind of macro is called [variadic]. When the macro is invoked, all the tokens in its argument
list after the last named argument (this eprintf macro has none), including any commas, become the
variable argument. This sequence of tokens replaces the identifier __VA_ARGS__ in the macro body
wherever it appears. Thus, we have this expansion:

     eprintf ("%s:%d: ", input_file, lineno)
          ==>  fprintf (stderr, "%s:%d: ", input_file, lineno)

The variable argument is completely macro-expanded before it is inserted into the macro expansion,
just like an ordinary argument. You may use the '#' and '##' operators to stringify the variable
argument or to paste its leading or trailing token with another token. (But see below for an
important special case for '##'.)

If your macro is complicated, you may want a more [descriptive-name] for the variable argument than
__VA_ARGS__. CPP permits this, as an extension. You may write an argument name immediately before
the '...'; that name is used for the variable argument. The eprintf macro above could be written

     #define eprintf(args...) fprintf (stderr, args)

using this extension. You cannot use __VA_ARGS__ and this extension in the same macro.
 
<possible-problem>

You can have named arguments as well as variable arguments in a variadic macro. We could define
eprintf like this, instead:

     #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)

This formulation looks more descriptive, but unfortunately it is [less-flexible]: you must now
supply at [least-one-argument] after the format string. In standard C, you cannot omit the comma
separating the named argument from the variable arguments. Furthermore, if you leave the variable
argument empty, you will get a [syntax-error], because there will be an extra comma after the format
string.

     eprintf("success!\n", );
          ==> fprintf(stderr, "success!\n", );

GNU CPP has a pair of extensions which deal with this problem. First, you are allowed to leave the
variable argument out entirely:

     eprintf ("success!\n");
          ==> fprintf(stderr, "success!\n", );

 [KT] not works in 4.6 G++. 

Second, the '##' token paste operator has a special meaning when placed between a comma and a
variable argument. If you write

     #define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

and the variable argument is left out when the eprintf macro is used, then the comma before the '##'
will be deleted. This does not happen if you pass an empty argument, nor does it happen if the token
preceding '##' is anything other than a comma.

     eprintf ("success!\n")
          ==> fprintf(stderr, "success!\n");

 [KT] this works in 4.6 G++.

The above explanation is ambiguous about the case where the only macro parameter is a variable
arguments parameter, as it is meaningless to try to distinguish whether no argument at all is an
empty argument or a missing argument. In this case the C99 standard is clear that the comma must
remain, however the existing GCC extension used to swallow the comma. So CPP retains the comma when
conforming to a specific C standard, and drops it otherwise.

Variadic macros are a new feature in C99. GNU CPP has supported them for a long time, but only with
a named variable argument ('args...', not '...' and __VA_ARGS__). If you are concerned with
portability to previous versions of GCC, you should use only named variable arguments. On the other
hand, if you are concerned with portability to other conforming implementations of C99, you should
use only __VA_ARGS__.

Previous versions of CPP implemented the comma-deletion extension much more generally. We have
restricted it in this release ( [KT] version? ) to minimize the differences from C99. To get the
same effect with both this and previous versions of GCC, the token preceding the special '##' must
be a comma, and there must be white space between that comma and whatever comes immediately before
it:

     #define eprintf(format, args...) fprintf (stderr, format , ##args)


{case-example-one}

Use:

MHEGDebugInfo(eMHVdsm, "_mhvDsmEventCreate %d\n", num);

#if ...

 [KT] see debug output to use both module or single module(mhegdebug).

#define MHEGDebugInfo(comp, ...) {BP_PRINT(MHEGDebugCompToBPComp(comp), CCDebugBP::INFO, __VA_ARGS__);\
                                  MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__); }
...

#define MHEGOnlyDebugInfo(comp, ...) (MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
...

#else

#define MHEGDebugInfo(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugDebug(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelDebug, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugWarning(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelWarning, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugMajor(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelMajor, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugFatal(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelFatal, __FUNCTION__, __VA_ARGS__))

#endif

void MHEGDebugTrace(MHEGComponent comp, MHEGLevel level, const char* functionName, ...)
{
  // Always send to BP print, at least for now.
  if ((s_traceLevels[comp] >= level) && (s_traceLevels[comp] < eMHEGLevelOff))
  {
      va_list ap;
      va_start(ap, functionName);
      char *message = va_arg(ap, char*);
      output(comp, level, functionName, message, ap);
      va_end(ap);
  }
}

#define LINE_LIMIT 1024
static char temp_buffer[LINE_LIMIT + 1]; // Limit all strings to LINE_LIMIT

// [KT] here string is fmt
//
void output(MHEGComponent comp, MHEGLevel level, const char* function, const char* string, va_list arg)
{
   AUTOLOCK();

   // TODO, add support for timestamp.
   // Check for space
   // Construct final string
   long int tick = PCTime::Tick();

   // [KT] #define SNPRINTF snprintf
   int pos = SNPRINTF(temp_buffer, LINE_LIMIT, "[%ld:%ld][%s][%s][%s] ", 
      tick/1000, tick%1000, s_names[comp], s_traceLevelName[level], function);

   // [KT] string is format
   size_t len = vsnprintf(temp_buffer + pos, LINE_LIMIT - pos - 1, string, arg) + pos;
   if (temp_buffer[len - 1] != '\n')
   {
     temp_buffer[len] = '\n';
     len++;
     temp_buffer[len] = '\0';
   }

   BP_PRINTR(CCDebug::DEFAULT, CCDebugBP::INFO, temp_buffer);
}


Tried to use macro only to use frintf but seems not a solution because no way to build "format"
properly. Here get is ["fmt" __LINE__, __FUNC__, "fmt", args... ]

#define MHEGDebugInfo(comp, ...) TLOG("[%d:%s]\n",  __LINE__,  __PRETTY_FUNCTION__, __VA_ARGS__)
#define TLOG(...) fprintf( stderr, __VA_ARGS__)


{case-example-two}

From Tizen:

__pServiceAppImpl is pointer from creating objcets.

/*
 * @param[in]	NID			The Tizen namespace
 * @param[in]	condition		The condition that is expected to be true
 * @param[in]	r			The last result to set
 * @param[in]   ...			The message to display
 */

SysTryReturnResult(NID_APP, __pServiceAppImpl, E_OUT_OF_MEMORY, "[E_OUT_OF_MEMORY] Insufficient memory.");

#ifndef unlikely
#define unlikely(x)  __builtin_expect(!!(x), 0)    // see {likey-and-unlikely}
#endif

#define SysTryReturnVoidResult(NID, condition, r, ...)	\
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			return;	\
		} \
	} while (0);

#define SysLogException(NID, r, ...)               SysLogExceptionInternal(NID, r, __PRETTY_FUNCTION__, 
__LINE__, __VA_ARGS__)


void
SysLogExceptionInternal(unsigned long nid, result r, const char* pFunction, int lineNumber, 
const char* pFormat, ...)
{
	va_list args;

	SetLastResult(r);

	if (!logInfo.platformExceptionEnabled)
	{
		return;
	}

	va_start(args, pFormat);

	__PrintSysLog(static_cast<_LogType>(LOG_EXCEPTION), static_cast<LogID>(nid), pFunction, lineNumber, 
	pFormat, args);

	va_end(args);
}

void __PrintSysLog(_LogType type, LogID id, const char* pFunction, int lineNumber, const char* pFormat, 
va_list args)
{
	if (!iniLoaded)
	{
		__InitializeLogInfo();
	}

	if (!__GetEnableInfo(static_cast<LogID>(id)))
	{
		return;
	}

	char logBody[LOG_LEN_MAX];
	snprintf(logBody, LOG_LEN_MAX, "%s(%d) > %s", pFunction, lineNumber, pFormat);
	logBody[LOG_LEN_MAX -1] = '\0';

	char logTag[LOG_MODULE_NAME_LEN_MAX];

	snprintf(logTag, LOG_MODULE_NAME_LEN_MAX, "%s", __GetModuleName(static_cast<LogID>(id)));
	logTag[LOG_MODULE_NAME_LEN_MAX - 1] = '\0';

	switch (type)
	{
	case static_cast<_LogType>(LOG_INFO):
		LOG_VA(LOG_INFO, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_DEBUG):
		LOG_VA(LOG_DEBUG, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_EXCEPTION):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_USER):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	default:
		LOG_VA(LOG_DEBUG, LOG_TAG_NULL, logBody, args);
		break;
	}
}

#ifndef LOG_VA
#define LOG_VA(priority, tag, fmt, args) \
    vprint_log(D##priority, tag, fmt, args)
#endif

#define vprint_log(prio, tag, fmt...) \
	__dlog_vprint(LOG_ID_MAIN, prio, tag, fmt)


{case-example-try-catch}

result
ServiceApp::Execute(ServiceAppInstanceFactory pServiceAppFactory, const IList* pArguments)
{
	r = pAppImpl->Construct(pArguments);
	SysTryCatch(NID_APP, !IsFailed(r), r = E_SYSTEM, E_SYSTEM, "[E_SYSTEM] %s.", GetErrorMessage(r));
CATCH:
	delete pServiceApp;

	return r;
}

#define SysTryCatch(NID, condition, expr, r, ...) \
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			expr; \
			goto CATCH;	\
		} \
	} while (0);


{case-example-two}

_INFO("main:_terminate:leave\n");

#ifndef _ERR
#define _ERR(fmt, args...) LOGE("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _DBG
#define _DBG(fmt, args...) LOGD("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _INFO
#define _INFO(fmt, args...) LOGI("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)		[KT] multi-level
#endif

#ifndef LOGI
#define LOGI(...) ((void)LOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOGE
#define LOGE(...) ((void)LOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOG
#define LOG(priority, tag, ...) \
	print_log(D##priority, tag, __VA_ARGS__)
#endif

#define print_log(prio, tag, fmt...) \
	__dlog_print(LOG_ID_MAIN, prio, tag, fmt)

int __dlog_vprint(log_id_t log_id, int prio, const char *tag, const char *fmt, va_list ap)
{
    char buf[LOG_BUF_SIZE];

    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);

    return write_to_log(log_id, prio, tag, buf);
}

int __dlog_print(log_id_t log_id, int prio, const char *tag, const char *fmt, ...)
{
    va_list ap;
    char buf[LOG_BUF_SIZE];

    va_start(ap, fmt);
    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
    va_end(ap);

    return write_to_log(log_id, prio, tag, buf);
}

static int __write_to_log_kernel(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
	ssize_t ret;
	int log_fd;
	struct iovec vec[3];

	if( log_id < LOG_ID_MAX )
		log_fd = log_fds[log_id];
	else
		return -1; // for TC

	if (!tag)
		  tag = "";

	vec[0].iov_base	= (unsigned char *) &prio;
	vec[0].iov_len	= 1;
	vec[1].iov_base	= (void *) tag;
	vec[1].iov_len	= strlen(tag) + 1;
	vec[2].iov_base	= (void *) msg;
	vec[2].iov_len	= strlen(msg) + 1;

   // [KT] this is sys call
	ret = writev(log_fd, vec, 3);

	return ret;
}

static int __dlog_init(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
#ifdef HAVE_PTHREADS
		pthread_mutex_lock(&log_init_lock);
#endif
	// get filtering info

	// open device
	if( write_to_log == __dlog_init)
	{
		log_fds[LOG_ID_MAIN] = open("/dev/"LOG_MAIN, O_WRONLY);
		log_fds[LOG_ID_RADIO] = open("/dev/"LOG_RADIO, O_WRONLY);
		log_fds[LOG_ID_SYSTEM] = open("/dev/"LOG_SYSTEM, O_WRONLY);

		if( log_fds[LOG_ID_MAIN] < 0 || log_fds[LOG_ID_RADIO] < 0 )
		{
			fprintf(stderr, "open log dev is failed\n");
			write_to_log = __write_to_log_null;
		}
		else
			write_to_log = __write_to_log_kernel;

		if( log_fds[LOG_ID_SYSTEM] < 0 )
		{
			log_fds[LOG_ID_SYSTEM] = log_fds[LOG_ID_MAIN];
		}
	}
#ifdef HAVE_PTHREADS
    pthread_mutex_unlock(&log_init_lock);
#endif
	return write_to_log(log_id, prio, tag, msg);
}


{why-ellipses-dangerous}
http://www.learncpp.com/cpp-tutorial/714-ellipses-and-why-to-avoid-them/

Two points:

o no type checks on calling parameters
o no checks on the number of calling parameters

#include <cstdarg> // needed to use ellipses

// The ellipses must be the last parameter
double FindAverage(int nCount, ...)
{
  long lSum = 0;

  // We access the ellipses through a va_list, so let's declare one
  va_list list;

  // We initialize the va_list using va_start. The first parameter is
  // the list to initialize. The second parameter is the last non-ellipse
  // parameter.
  va_start(list, nCount);

  // Loop nCount times
  for (int nArg=0; nArg < nCount; nArg++)
    // We use va_arg to get parameters out of our ellipses
    // The first parameter is the va_list we're using
    // The second parameter is the type of the parameter
    lSum += va_arg(list, int);

  // Cleanup the va_list when we're done.
  va_end(list);

  return static_cast<double>(lSum) / nCount;
}
 
int main()
{
  cout << FindAverage(5, 1, 2, 3, 4, 5) << endl;
  cout << FindAverage(6, 1, 2, 3, 4, 5, 6) << endl;
}

Why ellipses are dangerous

Ellipses offer the programmer a lot of flexibility to implement functions that can take a variable
number of parameters. However, this flexibility comes with some very dangerous downsides.

With regular function parameters, the compiler uses type checking to ensure the types of the
function arguments match the types of the function parameters (or can be implicitly converted so
they match). This helps ensure you don't pass a function an integer when it was expecting a string,
or vice versa. However, note that ellipses parameters have no type declarations. When using
ellipses, the compiler completely suspends type checking for ellipses parameters. This means it is
possible to send arguments of any type to the ellipses! However, the downside is that the compiler
will no longer be able to warn you if you call the function with ellipses arguments that do not make
sense. When using the ellipses, it is completely up to the caller to ensure the function is called
with ellipses arguments that the function can handle. Obviously that leaves quite a bit of room for
error (especially if the caller wasn't the one who wrote the function).

Lets look at an example of a mistake that is pretty subtle:
	
cout << FindAverage(6, 1.0, 2, 3, 4, 5, 6) << endl;

Although this may look harmless enough at first glance, see that the second argument (the first
ellipse argument) is a double instead of an integer. This compiles fine, and produces a somewhat
surprising result:

1.78782e+008

which is a REALLY big number. How did this happen?

As you have learned in previous lessons, a computer stores all data as a sequence of bits. A
variable's type tells the computer how to translate that sequence of bits into a meaningful value.
However, you just learned that the ellipses throw away the variable's type! Consequently, the only
way to get a meaningful value back from the ellipses is to manually tell va_arg() what the expected
type of the next parameter is. This is what the second parameter of va_arg() does. If the actual
parameter type doesn't match the expected parameter type, bad things will usually happen.

In the above FindAverage program, we told va_arg() that our variables are all expected to have a
type of int. Consequently, each call to va_arg() will return the next sequence of bits translated as
an integer.

In this case, the problem is that the double we passed in as the first ellipse argument is 8 bytes,
whereas va_arg(list, int) will only return 4 bytes of data with each call. Consequently, the first
call to va_arg will only read the first 4 types of the double (producing a garbage result), and the
second call to va_arg will read the second 4 bytes of the double (producing another garbage result).
Thus, our overall result is garbage.

Because type checking is suspended, the compiler won't even complain if we do something completely
ridiculous, like this:
	
int nValue = 7; cout << FindAverage(6, 1.0, 2, "Hello, world!", 'G', &nValue, &FindAverage) << endl;

Believe it or not, this actually compiles just fine, and produces the following result on the
author's machine:

1.79766e+008

This result epitomizes the phrase, "Garbage in, garbage out" which is a popular computer science
phrase used primarily to call attention to the fact that computers, unlike humans, will
unquestioningly process the most nonsensical of input data and produce nonsensical output
(wikipedia).

So, in summary, type checking on the parameters is suspended, and we have to trust the caller to
pass in the right type of parameters. If they don't, the compiler won't complain; our program will
just produce garbage (or maybe crash).

<second-problem>
As if that wasn't dangerous enough, we run into a second potential problem. Not only do the ellipses
throw away the type of the parameters, it also throws away the number of parameters in the ellipses!
This means we have to devise our own solution for keeping track of the number of parameters passed
into the ellipses. Typically, this is done in one of two ways:

o One of the fixed parameters is used as a parameter count (this is the solution we use in the
FindAverage example above)

o The ellipse parameters are processed until a sentinel value is reached. A sentinel is a special
value that is used to terminate a loop when it is encountered. For example, we could pick a sentinel
value of 0, and continually process ellipse parameters until we find a 0 (which should be the last
value). Sentinel values only work well if you can find a sentinel value that is not a legal data
value. 

However, even here we run into trouble. For example, consider the following call:

For example:

cout << FindAverage(6, 1, 2, 3, 4, 5) << endl;

On the authors machine at the time of writing, this produced the result:

699773

What happened? We told FindAverage() we were going to give it 6 values, but we only gave it 5.
Consequently, the first five values that va_arg() returns were the ones we passed in. The 6th value
it returns was a garbage value somewhere in the stack. Consequently, we got a garbage answer.

When using a sentinel value, if the caller forgets to include the sentinel, the loop will run
continuously until it runs into garbage that matches the sentinel (or crashes).

Recommendations for safer use of ellipses

First, if possible, do not use ellipses at all! Oftentimes, other reasonable solutions are
available, even if they require slightly more work. For example, in our FindAverage() program, we
could have passed in a dynamically sized array of integers instead. This would have provided both
strong type checking (to make sure the caller doesn't try to do something nonsensical) while
preserving the ability to pass a variable number of integers to be averaged.

Second, if you do use ellipses, do not mix expected argument types within your ellipses if possible.
Doing so vastly increases the possibility of the caller inadvertently passing in data of the wrong
type and va_arg() producing a garbage result.

Third, using a count parameter as part of the argument list is generally safer than using a sentinel
as an ellipses parameter. This forces the user to pick an appropriate value for the count parameter,
which ensures the ellipses loop will terminate after a reasonable number of iterations even if it
produces a garbage value.


={============================================================================
*kt_dev_prob_010* bit manipulation: get max value of type

From glibc and see exercise 2-1 for examples.

# ifndef ULONG_MAX
#  define ULONG_MAX ((unsigned long int) ~(unsigned long int) 0)
# endif
# ifndef LONG_MAX
#  define LONG_MAX ((long int) (ULONG_MAX >> 1))
# endif

note: The key is 'must' use 'unsigned' for right shift to have guaranteed 0 values. This is why
glibc macro uses 'unsigned' type.

note: The key is that when do "not" on 0 or 1, the result size is independant and signess as well.
The result depends on the other operand and done at compile time. 

note: The signess must be known to compiler when do shift to have guaranteed result and use signed
by default.

<1>
<problem> To get largest negative int value since INT_MAX+1 has the same bit representation as
INT_MAX+1. So INT_MAX is ((~0)>>1). Right?

unsigned int val = ((~0) >> 1) +1;

However, gets wrong value and to get it correct, use like

unsigned int val = (((unsigned)~0) >> 1) +1; 
unsigned int val = ((unsigned)~0 >> 1) +1;      // since cast is higher than shift

Why? See this example:

int main()
{
  unsigned int val1 = ((~0) >> 1);
  std::bitset<16> bitset1{val1};
  std::cout << bitset1 << std::endl;

  unsigned int val2 = ((~0) >> 1);              // do signed 
  std::bitset<32> bitset2{val2};
  std::cout << bitset2 << std::endl;

  unsigned int val3 = ((unsigned)(~0) >> 1);    // do unsigned
  std::bitset<32> bitset3{val3};
  std::cout << bitset3 << std::endl;
}

1111111111111111
11111111111111111111111111111111
01111111111111111111111111111111


note: The summary is that for unsigned, zero filled when right shift and zero filled when left shift
regardless of sign. 

note: From above examples, means that compiler see it as 'signed' when do right shift by default. 


Left Shift(<<) and Right Shift(>>) Operators
http://msdn.microsoft.com/en-us/library/336xbhcz.aspx

"The 'right'-shift operator causes the bit pattern in shift-expression to be shifted to the right by
the number of positions specified by additive-expression. For 'unsigned' numbers, the bit positions
that have been vacated by the shift operation are 'zero'-filled. For 'signed' numbers, the sign bit is
used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if
the number is negative, 1 is used."

Important
The result of a right-shift of a signed negative number is implementation-'dependent'. Although Visual
C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other
implementations also do so.

The ansic says: Right shifting a 'signed' quantity will fill with sign bit (arithmetic shift) on
some machines and with 0 bits (logical shift) on others. 


<2>
The wrong assumption on (1<<n). To explain this point, try this exercise first:

<exercise>
From ansic, p49. The function getbits(x, p, n) returns the (right adjusted) n-bit field of x that
begins at position p. For example, getbits( x, 4, 3 ) returns the three bits; 4, 3, 2, right
adjusted.

unsigned getbits( unsigned x, int p, int n );

<wrong>
This version do not work as expected since "~(1<<3)" makes wrong mask. Why not make as 00...0111?

int getbits(int x, int p, int n)
{
  return x >> (p+1-n) & ~(1 << n);
}

<correct>
unsigned getbits( unsigned x, int p, int n )    // note unsigned
{
  return (x >> (p+1-n)) & ~(~0 << n);
}

this can be written using variables to make it easier to understand

unsigned getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  unsigned shift = (p+1-n);
  return (x >> shift) & mask;
}

note:
1. "~(~0 << n)" is interesting in making a 'mask' value.
2. Why (p+1-n) for a shift? Since p(position) starts from 0.

7 6 5 4 3 2 1 0   8 7 6 5 4 3 2 1  position
     [* * *]           [* * *]
4+1-3 = 2 shift   5-3 = 2 shift

3. Do not need () since >> is higher than & but advisable to make easier to see.

<analysis> To see the differnece, see the below result.
#include <iostream>
#include <bitset>

int main()
{
  int ival = 1;

  int ival2 = ~( 1 << 3 );
  std::bitset<32> bitset2{ival2};
  std::cout << bitset2 << std::endl;

  int ival3 = ~(~0 << 3 );
  std::bitset<32> bitset3{ival3};
  std::cout << bitset3 << std::endl;

  unsigned int val2 = (~0);
  std::bitset<32> bitset2{val2};
  std::cout << bitset2 << std::endl;

  unsigned int val3 = (~1);
  std::bitset<32> bitset3{val3};
  std::cout << bitset3 << std::endl;
}

11111111111111111111111111110111       // <- 0...0001000 <- 0000001
00000000000000000000000000000111       // <- 1...1111000

11111111111111111111111111111111       // (~0)
11111111111111111111111111111110       // (~1)

<3> independent-of-length
No difference when tried 'unsigned int'. The point is that "~0" is not the same as "1". This is
"independent of word length" in ansic p49. For example,

x = x & ~077

Set the last 'six' bits of x to zero since "x & ~077" is 'independent' of word length and it thus
perferable to, for example, x & 0177700, which assumes that x is a 16-bit quantity. The portable
form involves no extra cost, since ~077 is a constant expression that can be evaluated at compile
time and the value expands to fit the type of operand that is used with and that's why said
independent.


<exercise> bitcount
From ansic, p50. The function counts the number of 1 bits in its integer argument. 
int bitcount( unsigned x );

note: The key is not to use sizeof operator, unsigned argument, and use independent of type size.

int bitcount( unsigned x )
{
  int b;

  for(b = 0; x != 0; x >>= 1) // for(b = 0; x; x >>= 1) and see {operator-assign}
    if( x & 01 )              // x & 1 works as well
      b++;

  return b;
}


page 51. exercise 2-9. In a two's complement number system, x &= (x-1) deletes the rightmost 1-bit
in x. Explain why. Use this observation to write a 'faster' version of bitcount.

Answer:

If x is odd, then (x-1) has the same bit representation as x except that the rightmost 1-bit becomes
a 0. In this case, (x & (x-1)) == (x-1).

x = 5: 5(101) & 4(100) = 100  // 101 -> 100 by having rightmost 1 to 0

If x is even, the end result of anding(&) x and x-1 has the rightmost 1 of x to 0.

x = 4: 4(100) & 3(11)  = 0    // 100 -> 0   by having rightmost 1 to 0
         ^ rightmost 1
x = 6: 6(110) & 5(101) = 100  // 110 -> 100 by having rightmost 1 to 0
          ^ rightmost 1
x = 8: 8(1000) & 7(111) = 0   // 1000 -> 0  by having rightmost 1 to 0

000   0     All even numbers has tailing 0s and it becomes 1 when minus 1
001   1
010   2
011   3
100   4
101   5
110   6
111   7
...

note: This is about careful observation but not a mechanism of borrowing a carry for example. For
both odd and even case, has the effect of having rightmost 1 to 0. So clear 1 from x one by one and
no need to check on if to count bits.

note: And(&) is faster than shift operation? Yes and also there is no if inside for loop.

int bitcount(unsigned x)
{
  int b;

  for (b = 0; x != 0; x &= (x-1))
    b++;
  return b;
}


<exercise>
From ansic, exercise 2-6. Write a function setbits(x,p,n,y) that returns x with the n bits that
begin at position p set to the rightmost n bits of y, leaving the other bits unchanged.

Had difficult to understand a question. The question is that set n bits of x starting from p with
rightmost n bits of y and return the result.

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_6

int getbits( unsigned x, int p, int n );
int setbits( unsigned x, int p, int n, unsigned y );
void printbits( unsigned x );

// one
return (
    (x & ~(~(~0 << n) << p+1-n))    // set n bits of x to 0. x & ~(mask << shift)
    |
    (
     (~(~0 << n) & y)               // get rightmost n bits of y. mask & y
     << p+1-n                       // shift to be in p pos
    )
    );


// two
// The following function, "getbits", is from K&R p 49 */
// getbits: get n bits from position p
unsigned getbits(unsigned x, int p, int n)
{
  return (x >>(p+1-n) & ~(~0 << n));
}

// asbits - shows integers as bit strings. note <quiz> this is useful as bitset
// Usage:                                
//         asbits(x, sizeof(x), FLAG)    
// FLAG = 1|0, showing if newline desired
void asbits(unsigned x, size_t s, int nl)
{
  int i;

  for(i = s*8-1; i>=0; i--) {
    getbits(x, i, 1)? putchar('1') : putchar('0');
    if(!(i%4))putchar(' ');
  }
  if(nl)putchar('\n');
}

<example>
#include <iostream>

using namespace std;

int getbits( unsigned x, int p, int n );
int setbits( unsigned x, int p, int n, unsigned y );
void printbits( unsigned x );

int getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  return (x>>p-n+1) & mask;
}

int setbits( unsigned x, int p, int n, unsigned y )
{
  unsigned xi = x & ~(~(~0<<n) << p-n+1); // xi = x & ~mask << p-n+1;
  unsigned yi = (y & ~(~0<<n)) << p-n+1;  // yi = y & mask << p-n+1;
  return xi | yi;
}

void printbits( unsigned x )
{
  int bits;

  for( bits = sizeof x *8 -1; bits >= 0; bits-- )
  {
    getbits( x, bits, 1 ) ? putchar('1') : putchar('0');
    if( bits % 4 == 0 )
      putchar(' ');
  }
  
  putchar('\n');
}

int main()
{
  unsigned int val1 = 0x558088;
  unsigned int val2 = 0x07507;

  cout << "val1: ";
  printbits( val1 );

  cout << "val2: ";
  printbits( val2 );

  cout << "setb: ";
  printbits( setbits( val1, 14, 3, val2 ));
}

val1: 0000 0000 0101 0101 1000 0000 1000 1000 
val2: 0000 0000 0000 0000 0111 0101 0000 0111 
setb: 0000 0000 0101 0101 1111 0000 1000 1000 
                           ^^^

<key> To set some bits of x with some bits of y, then some bits of x must be 0 before oring.
| XA | 00 | XB |
        OR
| 00 | YY | 00 |

<to-print-a-bits-in-string>
The possible approach is to use right shift one by one, check if it's 0 or 1, and save or print it.
This approach has a problem since check on LSB, will get the reversed output. This is why "asbits"
strts from MSB by using getbits() but not LSB.

<stack-and-queue>
This reminds me stack and queue.
input: 11101
           ^ start

      0 1 2 3 4 pos in array
      1 1 1 0 1

read(pop) as a stack, FILO          read(get) as a queue, FIFO
note. reversed output
       10111                           11101
           ^ start                         ^ start

if putchar(printf) array for both cases
   11101

if putchar when get it
   10111


<exercise>
From ansic, exercise 2-7. Write a function invert(x,p,n) that returns x with the n bits that begin
at position p inverted (i.e., 1 changed into 0 and vice versa), leaving the others unchanged.

// setbits uses y to set x and here xin uses instead.
unsigned invert_mine(unsigned x, int p, int n)
{
  // this makes easier to see a code
  unsigned msk = ~(~0 << n);

  // [*][x ][*] : x
  // [0][1 ][0] : msk << p+1-n
  // [0][x ][0] : (msk << p+1-n) & x
  // [1][x'][1] : ~((msk << p+1-n) & x)
  // [0][1 ][0]
  // [0][x'][0] : &
  unsigned xin = (~((msk << p+1-n) & x)) & msk << p+1-n;

  // this is the same as setbits
  return (x & ~(msk<< p+1-n)) | ((xin & msk)<< p+1-n);
}

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_7    note: xor
GP is in error. Here is a correct solution. Pilcrow 17:45, 31 August 2011 (UTC) 
unsigned invert_online(unsigned x, int p, int n)
{
  return x ^ ((~(~0<<n))<< p+1-n);
  // return x ^ (mask << shift);
}


int main()
{
  unsigned int val1 = 0x558088;

  cout << "val1: ";
  printbits( val1 );

  cout << "invt: ";
  printbits( invert( val1, 14, 3 ));
}

val1: 0000 0000 0101 0101 1000 0000 1000 1000 
invt: 0000 0000 0101 0101 1111 0000 1000 1000 
                           ^^^

<exercise>
From ansic, exercise 2-8. Write a function rightrot(x,n) that returns the value of the integer x
rotated to the right by n bit positions.

note: the keys are
1. Cannot use single mask and bit operation since it 'rotates' so have to use loop.
2. Needs observation when the rightmost bit is either 1 or 0.

1) The type is 'unsigned' so do not need to concern about value when do right shift. If not, need to
know the the length of type, such as sizeof(x).

// one note: prefer this since do not use sizeof and function call
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned rightrot(unsigned x, unsigned n)
{
  while (n > 0) {
    if ((x & 1) == 1)
      x = (x >> 1) | ~(~0U >> 1);      // note: must use 'U' suffix or unsigned cast
    else
      x = (x >> 1);
    n--;
  }
  return x;
}

// two
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned int rightrot(unsigned int x, int n)
{
  int m, i;

  for(i=0; i < n; i++) {
    m = getbits(x, 0, 1);
    m <<= (sizeof(m)*8-1);       // notice the use of sizeof
    x >>= 1;
    x |= m;
  }
  return x;
}

int main()
{
  unsigned int val1 = 0x07507;

  cout << "val1: ";
  printbits( val1 );

  cout << "rrot: ";
  printbits( rightrot( val1, 3 ));
}

val1: 0000 0000 0000 0000 0111 0101 0000 0111 
rrot: 1110 0000 0000 0000 0000 1110 1010 0000 
      ^^^

{bitwise-octal}
A leading 0 on an integer constant means 'octal' and this seems better that hex to use with bit
pattern.

0 0
1 01
2 10
3 11
4 100
5 101 
6 110
7 110

0177 1.111.111
0x7F 111.1111


={============================================================================
*kt_dev_prob_011* pointer or handle

Use a pointer variable to hold handle.

#include <iostream>

using namespace std;

typedef void* HANDLE;

int _gval = 2;

int main()
{

  cout << "{ main == " << std::endl;

  HANDLE x = (HANDLE) _gval;

  std::cout << x << std::endl;

  cout << "} main == " << std::endl;
}


={============================================================================
*kt_dev_prob_012* problem of incremental build or make

2014.08.

Problem: Found that the old code was used in the long debugging sesseion and made me wonder why it
is still called since moved to new code already? Found that the state was the mix of new and old
code. Quite difficult to debug and to find out what's happened. Limiation of incremental build or
make system?

Why: The problem code is

CPort::CPort()
{
#ifdef FS_SUPPORTED
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CFs));
  MHEGDebugDebug(eMPORT, "CFs is created");
#else
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CDsm));
  MHEGDebugDebug(eMPORT, "CDsm is created");
#endif
...
}

What will happen when use incremental build after removing this #define? This file was not changed
so not compiled in the build. So other new codes were compiled without this def and this old code
compiled with this def. Therefore, had CFs object while believeing CDsm object.


={============================================================================
*kt_dev_prob_013* simple grep

{simple-grep} TODO: need to complete code from the book.
ansic example, p69. The outline is:

while( there's another line )
   if ( the line containes the pattern )
      print it

<code>
#include <stdio.h>

#define MAXLINE 1000

int getline( char line[], int max );
int strindex( char source[], char searchfor[] );

char pattern[] = "ould";

main()
{
  char line[MAXLINE];
  int found = 0;

  while( getline(line, MAXLINE) > 0 )
    if( strindex( line, pattern ) >= 0 )
    {
      printf( "%s", line );
      found++;
    }

  return found;
}


# ============================================================================
#{ GNU CORE UTILS
={============================================================================
*kt_dev_guti_000*   gnu core util sites

http://www.gnu.org/software/coreutils/
git clone git://git.sv.gnu.org/coreutils coreutils


# ============================================================================
#{ GCC
={============================================================================
*kt_dev_gcc_000* gcc compile script

#!/bin/bash
g++ -g -std=c++0x $1


={============================================================================
*kt_dev_gcc_001* error: two or more data types in declaration specifiers

This error happened under gcc c build when include a header having:

#ifndef __cplusplus
typedef uint8_t bool;
#endif

Thought that it means duplication defined in somewhere and tried followings in sample build:

{example-one} no error
#include <stdio.h>

typedef unsigned char bool;
typedef unsigned char bool;


{example-one} errors
#include <stdio.h>

typedef unsigned char bool;
typedef int bool;

testerrfunc.c:4:13: error: conflicting types for 'bool'
testerrfunc.c:3:23: note: previous declaration of 'bool' was here


{example-three} 
#include <stdio.h>

#define bool unsigned char
typedef int bool;

testerrfunc.c:4:13: error: two or more data types in declaration specifiers
testerrfunc.c:4:1: warning: useless type name in empty declaration [enabled by default]

Therefore, this means "typedef int unsigned char;" hence error.

{example-four} 
no error
#define bool unsigned char
#define bool unsigned char

#define MYBOOL 1
#define MYBOOL 3
sam01.cpp:6:0: warning: "MYBOOL" redefined [enabled by default]


{stdbool.h} {preprocessor-options}
Tried to preprocessor output using "-E" option but not that useful. But found following line from
the output and when followed that file, found what went wrong:

From -E output using GCC 453.  
# 1 "/usr/lib/gcc/armv7l-tizen-linux-gnueabi/4.5.3/include/stdbool.h" 1 3 4

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */

#ifndef _STDBOOL_H
#define _STDBOOL_H

#ifndef __cplusplus

#define bool	_Bool
#define true	1
#define false	0

#else /* __cplusplus */

/* Supporting <stdbool.h> in C++ is a GCC extension.  */
#define _Bool	bool
#define bool	bool
#define false	false
#define true	true

#endif /* __cplusplus */

/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined	1
#endif	/* stdbool.h */

note: it is not automatically included when use stdio.h.

From GCC: http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types

ISO C99 adds the following keywords:
     inline _Bool _Complex _Imaginary


={============================================================================
*kt_dev_gcc_002* error: ISO C++ forbids declaration of X with no type [-fpermissive]

<1>
class UseStaic
{
  public:
    UseStatic() { std::cout << "Use staic ctor" << std::endl; }

  private:
    Sclass m_sclass;
};

Happened when made a typo in class name and meant to be class UseStatic. Basically, not able to find
UseStatic type.

<2>
template <typename T>
PRINT_ELEMENTS( T& coll, const string optstr="" )
{
  cout << optstr;

  for( const auto &elem : coll )
    cout << elem << " ";

  cout << endl;
}

error: ISO C++ forbids declaration of PRINT_ELEMENTS with no type [-fpermissive]


{fpermissive}
-fpermissive

Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using
-fpermissive allows some nonconforming code to compile. 


{when-missed-include}

<example-one>

#include < iostream>
// #include < stack>

using namespace std;

int main()
{
	int n;
	double item;
	stack<double> numbers;
	...
}

usestack.cpp:11:2: error: 'stack' was not declared in this scope
usestack.cpp:11:8: error: expected primary-expression before 'double'
usestack.cpp:11:8: error: expected ';' before 'double'


<example-two>

#include < iostream>
// #include < stack>

int main()
{
	int n;
	double item;
	std::stack<double> numbers;
	...
}

usestack.cpp:8:2: error: 'stack' is not a member of 'std'
usestack.cpp:8:13: error: expected primary-expression before 'double'
usestack.cpp:8:13: error: expected ';' before 'double'

Does it mean that it gives more reason not to use using-directive?


==============================================================================
*kt_dev_gcc_003*	error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]

This is an error when tried convert from base to derived.

class Singleton
{
	protected:
	Singleton() {};

	public:
	virtual Singleton* Instance();

	protected:
	static Singleton* m_pins;
};

Singleton* Singleton::m_pins = 0;

Singleton* Singleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "Singleton::Instance" << std::endl;
		//m_pins = new Singleton;
	}

	return m_pins;
}

class MySingleton : public Singleton
{
	public:
	virtual MySingleton* Instance();
};

MySingleton* MySingleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "MySingleton::Instance" << std::endl;
		//_pins = new MySingleton;
	}

	return m_pins; // error
}

usestatic.cpp: In member function 'virtual MySingleton* MySingleton::Instance()':
usestatic.cpp:106:9: error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]


==============================================================================
*kt_dev_gcc_004*	error: variable-sized object 'out' may not be initialised

void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
	Entry out[length];			// this works fine but not inited.
	Entry out[length] = {0};	// this causes an error
	Entry out[30] = {0};			// this works
}


I am assuming that you are using a C99 compiler (with support for dynamically sized arrays). The
problem in your code is that at the time when the compilers sees your variable declaration it cannot
know how many elements there are in the array (I am also assuming here, from the compiler error that
length is not a compile time constant). 

So should use memset or alloc in a function. [KT] Think from compiler perspective.

==============================================================================
*kt_dev_gcc_005*	error: expected } at end of input


#include <iostream>
#include "Fsm.h"

int main()
{
	std::cout << "--{ main " << std::endl;

	std::cout << "--} main " << std::endl;
}

main.cpp:9:1: error: expected } at end of input

Have got this error and puzzled since there is not much in this file. Interestingly when remove
fsm.h include, builds. So thought it may not find this header? Spend some time to change makefile to
specify current directory in the gcc command line. This turns out that in fsm.h, there is a missing
closing brace and this cause this error.

#ifdef __cplusplus
extern "C"
{
#endif

  ...

//#ifdef __cplusplus
//}
//#endif


==============================================================================
*kt_dev_gcc_006*  error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

error: 'X' does not name a type 

This happens when there is no typedef or types declared before its use.

error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

This is the same as above but more difficult to find because it happes when include a lot of headers
and there is dependencies between them.

<buffer.h>

#include "semaphore.h" // here one of struct uses some from st.h
#include "st.h"

<buffer.c>

#include "buffer.h"
#include "st.h"

In file included from buffer.h:1, from buffer.c:4: 
semaphore.h:4: error: expected specifier-qualifier-list before 'st_cond_t'

This shows the order is important in header inclusion.

This also happens when use the same header guard for two different headers. This effectvely do not
include necessary header and hence the error.

#ifndef __MH5W_GPI_H__
#define __MH5W_GPI_H__


={============================================================================
*kt_dev_gcc_007*  error: expected '=', ',', ';', 'asm' or '__attribute__' before

<case-01>
Like this case when use CPP features in C, this is very obvious so errors are clear.

kit@kit-vb:~/work$ gcc repmanc.c 
repmanc.c:10:1: error: unknown type name 'class'
repmanc.c:11:1: error: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token

<case-02>
However, when there are many header files and they are cascaded each other, this is not obvious.
This happens because C file uses CPP header which defines classes and cannot handle class keyword.

In file included from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/OSAbstraction.h:10:0,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/app/MApp.h:26,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/main/view_main.c:28:
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/PCString.h:52:7: error: expected '=', ',',
';', 'asm' or '__attribute__' before 'PCMem'


={============================================================================
*kt_dev_gcc_008*  warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]

This happens when use string literal for char* member in GCC(g++) but it was fine before in C.

main.cpp:53:74: warning: deprecated conversion from string constant to 'char*' [-Wwrite-strings]

typedef struct fsm_instance {
   char*              name;
   ...
} fsm_instance_t;

fsm_instance_t Foo = { "Fsm", ... };

-Wwrite-strings

When compiling C, give string constants the type "const char[length]" so that copying the address of
one into a non-const char * pointer produces a warning. These warnings help you find at compile time
code that can try to 'write' into a string constant, but only if you have been very careful about
using 'const' in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not
make -Wall request these warnings.

When compiling C++, warn about the deprecated conversion from string literals to char *. This
warning is enabled by default for C++ programs. 

1) Should consider using std::string name; instead?
Not perferred since need to change other C codes to get c string. .c_str().

2) Should use const in declarations?

typedef struct fsm_instance {
   const char*              name;
   ...
} fsm_instance_t;

But this cause other warnings in other function defs using this strucrue due to const.

3) Should use char* where string literal used.
This (char*) is the easiest way.


={============================================================================
*kt_dev_gcc_009*  error: jump to case label [-fpermissive]

{code-example}
http://stackoverflow.com/questions/2392655/what-are-the-signs-of-crosses-initialization

<example-one>
#include <iostream>
using namespace std;

int main()
{
  int x, y, i;
  cin >> x >> y >> i;
  switch(i) {
    case 1:
      // int r;         // a) okay
      // int r = x + y; // b) fail to compile
      // int r = 1;     // c) fail to compile
      cout << r;
      break;
    case 2:
      r = x - y;
      cout << r;
      break;
  };
}

sam01.cpp:14:14: error: jump to case label [-fpermissive]   // NOTE. this is main error.
sam01.cpp:11:17: error:   crosses initialisation of int r

Why? Why is a) okay?

The Standard says (6.7/3):
It is possible to transfer into a block, but not in a way that bypasses declarations with
'initialization'. A program that jumps from a point where a local variable with automatic storage
duration is not in scope (KT, out of switch) to a point where it is in scope (KT, in switch) is
ill-formed unless the variable has POD type (3.9) and is declared without an initializer (8.5).

1) The problem is that it is possible for r to come to scope without its initializer being executed.
The code would compile fine if you removed the initializer completely (i.e. the line would read int
r;).

2) It will cause a "crosses initialization" error, because it is possible to skip the initialization
of r, but after that it will still be in scope, even though it was never created in the first place.
NOTE: this is not true since switch is a single scope. see below examples.

The best thing you can do is to limit the scope of the variable. That way you'll satisfy both the
compiler and the reader. Or declare variables before switch.

switch(i)
{
  case 1:
    {
      int r = 1;
      cout << r;
    }
    break;
  case 2:
    {
      int r = x - y;
      cout << r;
    }
    break;
};

<example-two>
CCi.cpp:281:10: error: jump to case label
CCi.cpp:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'
CCi.cpp:284:34: error: redeclaration of 'std::vector<unsigned char> abortCode'
CCi.cpp:260:34: error: 'std::vector<unsigned char> abortCode' previously declared here
CCi.cpp:295:5: error: jump to case label
CCi.cpp:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'

    case SIGNAL_CI_APP_MMI_ABORT_REQ:
260:      std::vector<unsigned char> abortCode;
      ...
      break;

281:case SIGNAL_CI_APP_MMI_ABORT_ACK:
      ...
284:      std::vector<unsigned char> abortCode;


KT. So the switch is a single scope but has multiple blocks(jumps). The problem is that code can be
executed without proper initiailisation. Hence 'intelligent' compiler flags up.


={============================================================================
*kt_dev_gcc_100* gcc and c++11

{reference}
http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html
http://gcc.gnu.org/wiki/HomePage

{gcc-headers}
For ubuntu:

/usr/lib/gcc/i686-linux-gnu/4.6/include
/usr/include/c++/4.6/


{override-keyword}
Explicit virtual overrides from GCC 4.7

{alias-declaration}
Primers p68. GCC 4.4.5 don't.

class Foo {

  using line_no = vector< string >::size_type;

  typedef vector< string >::size_type line_no;
};


{explicit}
From GCC 45. See *kt_dev_cpp_005* for more.


{class-initializers}
For GCC 463 it emit error:
usecomma.cpp:5:19: sorry, unimplemented: non-static data member initialisers


{c++11}
http://gcc.gnu.org/projects/cxx0x.html

C++0x was the working name of the ISO C++ 2011 standard, which introduced a host of new features
into the standard C++ language and library. This project sought to implement new C++11 features in
GCC, and made it the first compiler to bring feature-complete C++11 to C++ programmers.

C++11 features are available as part of the "mainline" GCC compiler in the trunk of GCC's Subversion
repository and in GCC 4.3 and later. 

>
 To enable C++0x support, add the command-line parameter -std=c++0x to your g++ command line. 
<
Or, to enable GNU extensions in addition to C++0x extensions,
add -std=gnu++0x to your g++ command line. GCC 4.7 and later support -std=c++11 and -std=gnu++11 as
well.

Important: GCC's support for C++11 is still experimental. Some features were implemented based on
early proposals, and no attempt will be made to maintain backward compatibility when they are
updated to match the final C++11 standard.

$ g++ -v --help | egrep "\-std"

  -std=c++0x                  Conform to the ISO 1998 C++ standard, with
                              extensions that are likely to become a part of
                              the upcoming ISO C++ standard, dubbed C++0x. Note
                              that the extensions enabled by this mode are
                              experimental and may be removed in future
                              releases of GCC.

note: when use gcc, got link errors that cannot find STLs. must use g++.
$ g++ -std=c++0x sample.cpp


{the-gnu-c++-library}
http://gcc.gnu.org/onlinedocs/libstdc++/index.html


{nullptr}
This is for C++11.

$ gcc sam01.c
sam01.c: In function main:
sam01.c:7:26: error: nullptr undeclared (first use in this function)
sam01.c:7:26: note: each undeclared identifier is reported only once for each function it appears in

$ g++ -g -std=c++0x sam01.c
kt@kt-ub-vb:~/work$ cat comp.sh 

This new feature especially helps to avoid mistakes that occurred when a null pointer was
interpreted as an integral value. For example:

void f(int);
void f(void*);

f(0);       // calls f(int)
f(NULL);    // calls f(int) if NULL is 0, ambiguous otherwise
f(nullptr); // calls f(void*)

nullptr is a new 'keyword' and literal that has special type and automatically converts into 'any'
other pointer type. Has type std::nullptr_t defined in <cstddef>, so you can now even overload
operations for the case that a null pointer is passed.


={============================================================================
*kt_dev_gcc_101* gcc typeof

To check actual type of some expression. For example:

http://gcc.gnu.org/onlinedocs/gcc/Typeof.html
http://stackoverflow.com/questions/16832863/behaviour-of-sizeof-in-c-gcc


={============================================================================
*kt_dev_gcc_102* gcc: link script

{relocation-problem}
CNXT embedded platform.

[bin]$ ./arm-linux-uclibcgnueabi-gcc -print-search-dirs
install: /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
...
libraries:=/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
:/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/
:/home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
:/usr/lib/gcc/arm-linux-uclibcgnueabi/4.1.1/
:/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/../../../../arm-linux-uclibcgnueabi/lib/arm-linux-uclibcgnueabi/4.1.1/
:/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/../../../../arm-linux-uclibcgnueabi/lib/
:/home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/arm-linux-uclibcgnueabi/lib/arm-linux-uclibcgnueabi/4.1.1/
:/home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/arm-linux-uclibcgnueabi/lib/

When do compile and link, look into a directory one by one in libraries setting above to find
libc.so and libc.a. 

The problem is that try to use fixed specific path to build

/home/ci/views/ci_fosh_pecosa_linux_int/vobs/SYSTEM_BIN/arm1176_gcc_x86_linux_01/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.1.1/../../../../arm-linux-uclibcgnueabi/bin/ld:
cannot find /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/libc.so.0
collect2: ld returned 1 exit status

At first, thought that it is a problem of not supporting relocation due to use fixed path. However,
   when have strace log, found libc.so using libraries path and try to find the real library looking
   at the content of libc.so. The libc.so is a text file.

[lib]$ cat libc.so
/* GNU ld script
 * Use the shared library, but some functions are only in
 * the static library, so try that secondarily. */
GROUP ( /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/libc.so.0
    /home/wgrobler/platforms/CnxtPecos/M2.1/SRC/host/linux/tools-4.1.1/lib/uclibc_nonshared.a  )

When fixed as below, works fine.

/* GNU ld script
 * Use the shared library, but some functions are only in
 * the static library, so try that secondarily. */
GROUP ( libc.so.0 uclibc_nonshared.a  )


={============================================================================
*kt_dev_gcc_103* gcc: link: link order and cyclic dependencies

{gcc-compliation-process}
Four phase: preprocessing, compilation, assembly and linking. 

<problem> Seen the case that during the porting work, built all files but when starts some funcs
which are part of files which are already built, seeing more errors of missing header files and
undefined symbols. Why?

From online:

Once the object file containing the machine code is produced in the step above, the linking step
makes sure that all the undefined symbols in code are resolved.

Enable warnings using -Wall flag, then you will see warning: Implicit call to function bprint() and
Implicit call to function aprint(). It's is basically compiler recognizes this function during
Linker stage and this does not give any error.

So gcc assumes implicit calls in compilation phase and starts to emit errors when 'actually' use it
which lead to link it. See the below for a correct answer.


{gcc-link-order}

<example>
Used different in link with the same objects. out file has different md5sum depending the link
order:

$ gcc simplemain.o simplefunc.o
$ gcc simplefunc.o simplemain.o

$ md5sum a.out
50b5f88fe5ed8aef16a3decd63a1dce7  a.out
$ md5sum a.out.one 
c33b4d44f06f21e0b378d8d1473b07d8  a.out.one

<reference>
http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/

Library order in static linking

July 9th, 2013 at 5:56 am

I'll start with a slightly sneaky but educational example. Suppose we have this code:

volatile char src[] = {1, 2, 3, 4, 5};
volatile char dst[50] = { 0 };

void* memcpy(void* dst, void* src, int len);

int main(int argc, const char* argv[])
{
  memcpy(dst, src, sizeof(src) / sizeof(src[0]));
  return dst[4];
}

It runs just fine and the return value is 5. Now, suppose this is part of a larger project that
consists of many object files and libraries, and somewhere within the project there is a 'library'
that contains this code:

void memcpy(char* aa, char* bb, char* cc) {
  int i;
  for (i = 0; i < 100; ++i) {
    cc[i] = aa[i] + bb[i];
  }
}

If the previous snippet gets linked with this library, what happens? Would you expect it to still
return 5? Return something else? Crash? The answer is: it 'depends' - the result can be either correct
or a segmentation fault. It depends on the 'order' in which the objects and libraries in the project
were fed to the linker.

If you fully understand why this depends on linking order, as well as how to avoid the problem (and
more serious problems, like circular dependencies) then congratulate yourself and move on - this
article is probably not for you. Otherwise, read on.

The basics

Let's start by defining the scope of this article: first, my examples are demonstrating the use of
the gcc and binutils toolchain on Linux. Compatible toolchains (like clang instead of gcc) apply
too. Second, the discussion here resolves around 'static' linking that's done at compile/link time.

To understand why-linking-order-matters, it's first instructional to understand how the linker
works with respect to linking libraries and objects together. Just as a quick reminder - an object
file both provides (exports) external symbols to other objects and libraries, and expects (imports)
symbols from other objects and libraries. For example, in this C code:

int imported(int);

static int internal(int x) {
    return x * 2;
}

int exported(int x) {
    return imported(x) * internal(x);
}

The names of the functions speak for themselves. Let's compile it and look at the symbol table:

$ gcc -c x.c
$ nm x.o
000000000000000e T exported
                 U imported         // note: undefined
0000000000000000 t internal         // note: static. 'lowercase' in nm means local.

This means: exported is an external symbol - defined in the object file and visible from the
outside. imported is an undefined symbol; in other words, the linker is expected to find it
elsewhere. When we talk about linking later, the term undefined can become confusing - so it helps
to remember that this is where it comes from originally. internal is defined within the object but
'invisible' from the outside. 

Now, a library is simply a 'collection' of object files. Just a bunch of object files glued together.
Creating a library is a very trivial operation that doesn't do anything special besides placing many
object files into the same file. This in itself is important, because a horde of object files is not
convenient to deal with. For example, on my system libc.a (the static version of the C library)
consists of almost 1500 object files. It's way nicer to just carry libc.a around.  

The linking process {gcc-link-algorithm}

This section defines the linking process in a somewhat dry, algorithmic manner. This process is the
key to understanding why linking order matters.

Consider a linker invocation:

$ gcc main.o -L/some/lib/dir -lfoo -lbar -lbaz

<caution>
The following do not work:
gcc -lfoo main.c

The linker is almost always invoked through the-compiler-'driver'-gcc when compiling C or C++ code.
This is because the driver knows how to provide the correct command-line arguments to the linker
itself (ld) with all the support libraries, etc. We'll see more of this later.

Anyhow, as you can see the object files and libraries are provided in a certain order on the
command-line, from left to right. This is the-linking-'order'. Here's what the linker does:

<symbol-table>
The linker maintains a symbol table. This symbol table does a bunch of things, but among them is
keeping two lists:

1. A list of symbols 'exported' by all the objects and libraries encountered so far.
2. A list of 'undefined' symbols that the encountered objects and libraries requested to import and
were not found yet.

<for-object-file>
When the linker encounters a new object-file, it looks at:

1.The symbols it exports: these are added to the list of exported symbols mentioned above. If any
symbol is in the undefined list, it's removed from there because it has now been found. If any
symbol has already been in the exported list, we get a "multiple definition" error: two different
objects export the same symbol and the linker is confused.

2. The symbols it imports: these are added to the list of undefined symbols, unless they can be
found in the list of exported symbols.

<for-library>
note: the key is that linker tries to find a symbol only when it's in the 'undefine' list in the
symbol table.

When the linker encounters a new library, things are a bit more interesting. The linker goes over
all the objects in the library. For each one, it 'first' looks at the symbols it exports.

1. If any of the symbols it exports are on the undefined list, the object is 'added' to the link and
the next step is executed. Otherwise, the next step is skipped. note: This means that if it is not
used, this object is not be added to the link. 

2. If the object has been added to the link, it's treated as described above - its undefined and
exported symbols get added to the symbol table. 

3. Finally, if any of the objects in the library has been included in the link, the library is
'rescanned' again - it's possible that symbols imported by the included object can be found in other
objects within the same library.

When the linker finishes, it looks at the symbol table. If any symbols remain in the undefined list
the linker will throw an "undefined reference" error. For example, when you create an executable and
forget to include the file with the main function, you'll get something like:

/usr/lib/x86_64-linux-gnu/crt1.o: In function '_start':
(.text+0x20): undefined reference to 'main'
collect2: ld returned 1 exit status

<rescan>
Note that after the linker has looked at a library, it won't look at it again. Even if it exports
symbols that may be needed by some later library. The only time where a linker goes back to rescan
objects it has already seen, happens within a single library - as mentioned above, once an object
from some library is taken into the link, all other objects in the same library will be rescanned.
Flags passed to the linker can tweak this process - again, we'll see some examples later.

<added-when-really-used>
Also note that when a library is examined, an object file within it can be left out of the link if
it does not provide symbols that the symbol table needs. This is a very important feature of static
linking. The C library I mentioned before makes a heavy use of this feature, by mostly splitting
itself to an-object-per-function. So, for example if the only C standard library function your code
'uses' is strlen, only strlen.o will be taken into the link from libc.a - and your executable will
be very small.

Simple examples note: these examples works on ubuntu as they are shown.

The previous section can be hard to digest, so here are some simple examples that show the process
in action.

Let's start with the most basic case, of linking two objects together:

$ cat simplefunc.c
int func(int i) {
    return i + 21;
}

$ cat simplemain.c
int func(int);

int main(int argc, const char* argv[])
{
    return func(argc);
}

$ gcc -c simplefunc.c
$ gcc -c simplemain.c
$ gcc simplefunc.o simplemain.o
$ ./a.out ; echo $?
22

note: $? means the exit status which is return value in this case.

note: <key> linking order only matters when use a libaray

:~/work$ nm simplefunc.o
00000000 T func

:~/work$ nm simplemain.o 
         U func
00000000 T main

Since these are object files, the linking order does 'not' matter. Object files are always taken into
the link. We can pass them to the linker in reversed order and it still works: 

$ gcc simplemain.o simplefunc.o
$ ./a.out ; echo $?
22

Now let's do something different. Let's put simplefunc.c into a library:

$ ar r libsimplefunc.a simplefunc.o    // ar rs to skip ranlib command.
$ ranlib libsimplefunc.a
$ gcc  simplemain.o -L. -lsimplefunc
$ ./a.out ; echo $?
22

Works like a charm. But note what happens if the linking order is reversed now:

$ gcc  -L. -lsimplefunc  simplemain.o
simplemain.o: In function 'main':
simplemain.c:(.text+0x15): undefined reference to 'func'
collect2: ld returned 1 exit status

Understanding the linking algorithm outlined above makes this case simple to explain. When the
linker encounters libsimplefunc.a, it still hasn't seen simplemain.o, which means that func is not
yet on the undefined list. When the linker looks into the library it sees simplefunc.o that exports
func. But since it doesn't need func, this object file is 'not' included in the link. When the
linker does reach simplemain.o and sees that func is, indeed required, it's added to the undefined
list (because it's not on the exported list). The linker then reaches the end of the link and func
is still undefined.

See how this doesn't happen in the previous linking order - since simplemain.o comes first, func is
on the undefined list before the linker sees the library, so the object file exporting it does get
included.

This brings us to the most important corollary of the linking process outlined above:

If object or library AA needs a symbol from library BB, then AA should come before library BB in the
command-line invocation of the linker. [KT] slightly not correct.


Circular dependency {cyclic-dependencies}

The corollary above is an important summary of the linking process - it's certainly much more
practical to keep in mind because it's so short. But it makes one wonder - what happens if AA needs
a symbol from BB, but BB also needs a symbol from AA? While officially this isn't a good programming
practice, in reality it happens quite a lot. But AA can't come both before and after BB on the
command-line, right? That's just silly. Wait, is it, really?

Let's see an example and start simple. Imagine that instead of simplefunc.c, the func symbol is
provided thus:

$ cat func_dep.c
int bar(int);

int func(int i) {
    return bar(i + 1);
}

$ cat bar_dep.c
int func(int);

int bar(int i) {
    if (i > 3)
        return i;
    else
        return func(i);
}

These two files depend on each other and get placed into different libraries. If we link them in one
order, we fail:

$ gcc  simplemain.o -L.  -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

However, the other order does work:

$ gcc  simplemain.o -L. -lfunc_dep -lbar_dep
$ ./a.out ; echo $?
4

Quiz: can you figure out why? Hint: just go over the linking process algorithm with this
command-line. What undefined symbols does the symbol table contain when the linker first sees
-lfunc_dep?

<analysis-on-okay-case>
simplemain:
         U func

symbol table: undefined: func          // needs func

func_dep.a:
         U bar  (import)
00000000 T func (export)               // found func and needs bar 

bar_dep.a:
00000000 T bar  (export)               // found bar
         U func (import)

<analysis-on-not-okay-case>
simplemain:
         U func

symbol table: undefined: func                      // needs func

bar_dep.a:
00000000 T bar  (export)
         U func (import)                           // still needs func

func_dep.a:
         U bar
00000000 T func (undefined reference to 'bar')     // found func and needs bar but link ends.

The symbol table has func but not bar. Hence, error.

But this is a very simple case. Let's look at a trickier one. We'll add a dependency to bar on
another function from libfunc_dep.a, but one that lives in a different object:

$ cat bar_dep.c
int func(int);
int frodo(int);

int bar(int i) {
    if (i > 3)
        return frodo(i);
    else
        return func(i);
}

$ cat frodo_dep.c
int frodo(int i) {
    return 6 * i;
}

We'll recompile all these files into separate objects, and the libfunc_dep.a library will now be:

$ ar r libfunc_dep.a func_dep.o frodo_dep.o
$ ranlib libfunc_dep.a

Here's a drawing of the libraries, with arrows showing the dependencies:

simplemain:
			U func

 libfunc_dep.a        libbar_dep.a
  - func_dep.o  ->  <- - bar_dep.o (need func and frodo)
  - frodo_dep.o     <-

Now linking fails no matter what order we list the libraries in:

U func; func and bar; bar and frodo

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep
./libbar_dep.a(bar_dep.o): In function 'bar':
bar_dep.c:(.text+0x17): undefined reference to 'frodo'
collect2: ld returned 1 exit status

U func; nothing for bar_dep; func and bar

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

To solve this, consider that it's perfectly valid to list a library more than once on the link; so
in fact, we can provide libfunc_dep.a both before and after libbar_dep.a:

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Another quiz: will the same trick work providing -lbar_dep twice? Why not?

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep -lbar_dep

U func; nothing for bar_dep; func and bar(U); bar

./libbar.a(bar_dep.o): In function `bar':
bar_dep.c:(.text+0x13): undefined reference to `frodo'
collect2: ld returned 1 exit status

Becase frodo is in the libaray but was not added to the link because of object-per-function-linking.

Using linker flags to control the process

As I've mentioned above, the linker has a number of interesting flags that can be used to control
the process in a fine-grained manner. For example, circular dependency problems can be easily
resolved with --start-group and --end-group. Here's an instructive portion from man ld:

-start-group archives -end-group

The specified archives are searched repeatedly until no new undefined references are created.
Normally, an archive is searched only once in the order that it is specified on the command line. If
a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an
archive that appears later on the command line, the linker would not be able to resolve that
reference. By grouping the archives, they all be searched repeatedly until all possible references
are resolved.

Using this option has a significant performance cost. It is best to use it only when there are
unavoidable circular references between two or more archives.

Here's how this helps in our case:

$ gcc simplemain.o -L. -Wl,--start-group -lbar_dep -lfunc_dep -Wl,--end-group
$ ./a.out ; echo $?
24

It's interesting to note the "significant performance cost" warning in the excerpt above. This
explains why the linking process is the way it is. Presumably, linkers could just re-scan the whole
library list until no new symbols got resolved. This would eliminate most circular-dependency and
linking order problems in the world, but it would also be slow. Linking is already a critical part
of the compilation time of large systems, since it looks at the whole program and requires quite a
bit of memory. It's better to make it as fast as possible for well-behaved programs (that got their
linking order right), and provide special options like groups for the difficult circular dependency
cases. [KT] This is only about cost in linking?

There's at least one another linker flag that can help us resolve the circular dependency here. We
can use the --undefined flag to tell the linker - "buddy, here's a symbol I want you to add to the
undefined list". In our case this makes the link error go away even though the libraries are
specified only once:

$ gcc simplemain.o -L. -Wl,--undefined=bar -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Figuring out why this works is left as an exercise to the reader.

____________________________
Back to the original example

Let's go back to the example this article started with. main assumes it gets the correct memcpy from
the C library, but the memcpy it gets linked with does something else. Assuming the memcpy here was
packed into the libstray_memcpy.a library:

$ gcc  -L. main_using_memcpy.o -lstray_memcpy
$ ./a.out
Segmentation fault (core dumped)

This is the expected behavior. Since -lstray_memcpy was provided after main_using_memcpy.o on the
command-line, it gets linked in. But what happens if the order is reversed:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o
$ ./a.out ; echo $?
5

The program links and works correctly. The reason for this is simple: even without us explicitly
asking for it, gcc asks the linker to link the C library as well. The full linker invocation command
of gcc is pretty complex, and can be examined by passing the -### flag to gcc. But in our case this
amounts to:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o -lc

When the linker sees -lstray_memcpy, the symbol table does not yet have an undefined entry for
memcpy, so the object file with the wrong function does not get linked. The linker adds this
undefined entry only after it sees main_using_memcpy.o. Then, when it reaches -lc, the object file
holding memcpy from the C library does get linked in because by now memcpy is on the undefined list.

Conclusion

The algorithm used by the linker to resolve symbols between objects and libraries is pretty simple.
As long as you keep it in mind, linker errors and related problems should be easy to understand. If
you still run into problematic situations you're not sure how to resolve, this article mentioned two
tools that can be very useful in debugging such problems: one is nm, which shows the symbol table of
an object or a whole library. The other is the -### flag that gcc accepts and as a result shows the
full commands it passes to the underlying tools.

note: KT. When use this option, it appears that linker cannot detect duplicated symbols and use one
of symbols. There are duplicated in the same lib archive but picked up wrong one. 


={============================================================================
*kt_dev_gcc_104* gcc: C90 and C99

Preface

This is a reference manual for the C programming language as implemented by the GNU Compiler
Collection (GCC). Specifically, this manual aims to document:

The 1989 ANSI C standard, commonly known as C89/C90

The 1999 ISO C standard, commonly known as C99, ISO/IEC 9899:1999, to the extent that C99 is
implemented by GCC

The current state of GNU extensions to standard C 

This manual describes C89 as its baseline. C99 features and GNU extensions are explicitly labeled as
such.

By default, GCC will compile code as C89 plus GNU-specific extensions. Much of C99 is supported;
once full support is available, the default compilation dialect will be C99 plus GNU-specific
extensions. (Some of the GNU extensions to C89 ended up, sometimes slightly modified, as standard
language features in C99.)

The C language includes a set of preprocessor directives, which are used for things such as macro
text replacement, conditional compilation, and file inclusion. Although normally described in a C
language manual, the GNU C preprocessor has been thoroughly documented in The C Preprocessor, a
separate manual which covers preprocessing for C, C++, and Objective-C programs, so it is not
included here. 


{C90-C99}
After ANSI produced the official standard for the C programming language in 1989, which became an
international standard in 1990, the C language specification remained relatively static for some
time, while C++ continued to evolve, largely during its own standardization effort. Normative
Amendment 1 created a new standard for C in 1995, but only to correct some details of the 1989
standard and to add more extensive support for international character sets. The standard underwent
further revision in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which
was adopted as an ANSI standard in May 2000. The language defined by that version of the standard is
commonly referred to as "C99". 

<for-example>
for(int i = 0; i < 0; i++)
   ;

sam01.c:153:3: error: for loop initial declarations are only allowed in C99 mode
sam01.c:153:3: note: use option -std=c99 or -std=gnu99 to compile your code

<for-C99>
The following causes error:
usecomma.cpp:70:42: error: invalid conversion from 'Node* {aka node*}' to 'int' [-fpermissive]
usecomma.cpp:72:22: error: base operand of '->' is not a pointer

{
   // search the end using count
70:   for( int current = 1, pend = list->header; current < list->count; current++)
72:      pend = pend->pnext;
}

{
   // search the end using count
   pend = list->header;
   for( int current = 1; current < list->count; current++)
      pend = pend->pnext;

   or

   // search the end using count
   int current;
   for( current = 1, pend = list->header; current < list->count; current++) 
      pend = pend->pnext;
}

Why? Because cannot define different types in the init part of for. See declaration.

From ISO/IEC 9899-1999

6.8.5 Iteration statements
Syntax

for ( expression opt ; expression opt ; expression opt) statement
for ( declaration expression opt ; expression opt) statement

note: This is why the var declared in a for has a scope
5 An iteration statement is a block whose scope is a strict subset of the scope of its enclosing
block. The loop body is also a block whose scope is a strict subset of the scope of the iteration
statement. 

Now the 'block wrapped around the loop' comes into its own; it explains why the variable i cannot be
accessed outside the loop. You can declare more than one variable, but they must all be of
the-'same' -type:

for (int i = 0, j = sizeof(something); i < j; i++, j--) { ... }


={============================================================================
*kt_dev_gcc_105* gcc likely and unlikely 

{likey-and-unlikely}
This is built-in function: long __builtin_expect (long exp, long c)

You may use __builtin_expect to provide the compiler with branch prediction information. In general,
you should prefer to use actual profile feedback for this (-fprofile-arcs), as programmers are
notoriously bad at predicting how their programs actually perform. However, there are applications
in which this data is hard to collect.


{reading-two}
http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html
As the gcc documentation says, you can use this compiler built-in function to give the optimizer a
clue about the likely result of an integer (or Boolean) expression. In the context of an if
statement, this enables the optimizer to reorder the code in a way that gives best performance, by
ensuring that the code that is most likely to execute after the conditional immediately follows the
conditional when the instruction stream is fed to the CPU pipeline.

The __builtin_expect() function takes two arguments: a value to be tested, and the expected result.
Both of these are integral values. The interface is a little clumsy for most uses, since the common
case is that we want to test for "true" (non-zero) or "false" (zero). Thus, the Linux kernel defines
two simpler interfaces: likely() and unlikely() (in include/linux/compiler.h):

    #define likely(x)      __builtin_expect(!!(x), 1)
    #define unlikely(x)    __builtin_expect(!!(x), 0)

In other words, likely(x) means "I expect x is true", and and unlikely(x) means "I expect x is
false".

Here's my test program. The comments should be enough to help you understand some of the more
obscure pieces. Below, I'll just skip to looking at the test results.

The program essentially repeatedly scans a one-million-element integer array whose contents are zero
(in the default case). Using the program, we can time the results of the checks that are performed
either with or without using __builtin_expect().

For example, here we scan the array without  __builtin_expect():

    $ cc -DDONT_EXPECT -O3 builtin_expect_test.c -o bn
    $ time -f "%E real, %U user, %S sys" ./bn 1000
    0, 1000000000
    0:02.68 real,  2.67 user, 0.00 sys

In this case, the program looped one thousand times through the array, to perform a total of one
billion checks, and the real time for execution was 2.68 seconds. (The test machine is an Intel Core
Duo 2.53GHz, and the gcc version is 4.6.3.)

Here's what happens if we employ  __builtin_expect(), telling the compiler that the expected result
of the test is 0.

    [KT] expects 0 and best case
    $ cc -DEXPECT_RESULT=0 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    0, 1000000000
    0:02.28 real,  2.28 user, 0.00 sys

The execution time fell to 2.28 seconds. In other words (for this particular CPU, compiler version,
and program), __builtin_expect() improved the execution time of each check by 0.4 nanoseconds (0.4
seconds for one billion checks).

Well and good. What if we tell __builtin_expect() to expect the wrong value?

    [KT] expects 1 when all elements are 0 so worst case
    $ cc -DEXPECT_RESULT=1 -O3 builtin_expect_test.c -o b1
    $ time -f "%E real, %U user, %S sys" ./b1 1000
    0, 1000000000
    0:04.19 real,  4.18 user, 0.00 sys

In this case, unsurprisingly, we made each check run slower, by about 1.5 (i.e., 4.19 - 2.68)
nanoseconds. So, should you use __builtin_expect()?  

You should only use __builtin_expect()-or the Linux kernel's likely() and unlikely()-if it's "very
likely" that your code will follow the predicted branch. How much is "very likely"? If you're
looking for actual numbers, the answer will depend on your compiler version, CPU, and code. But to
illustrate that you should generally [avoid] these optimizations unless your code is very likely to
follow one branch, here's some further tests using the above code.

In this test, the program first injects some nonzero values into the array before doing tests for
zero using __builtin_expect(). Nonzero values are placed at every tenth element in the array:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000000, 900000000
    0:02.79 real,  2.76 user, 0.01 sys

Note what happened. Even though most array elements contained the expected zero value, execution
speed was actually worse (2.79 seconds versus 2.69 seconds) than not using __builtin_expect() at
all! In fact, even when only one in ten thousand values is nonzero, we're still at only roughly the
break-even point:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10000 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000, 999900000
    0:02.66 real,  2.64 user, 0.00 sys

The point where using these optimizations becomes worthwhile will depend on the factors mention
above, but the point is that you should really only use them when your predicted path is very
likely, and if your predicted path is not very likely, then you're better off avoiding them, as
you'll actually slow your code down a little. Compiler-assisted run-time profiling The gcc
documentation contains the following advice regarding the use of __builtin_expect():

    In general, you should prefer to use actual profile feedback for this (-fprofile-arcs), as
    programmers are notoriously bad at predicting how their programs actually perform. However,
    there are applications in which this data is hard to collect. 

That's good concise advice. To put things another way, the only time you should use
__builtin_expect() is when you can't use compiler-assisted runtime optimization (perhaps because
your program has no easily repeatable pattern of execution-the Linux kernel is an obvious example)
and you are certain that your predicted code path is very (very) likely to be the one that will be
taken.


{reading-one}
This is about branch-prediction and optimisation in a compiler. 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "else" block is more probable by saying that x is more likely to be
  // false(0)
  if(__builtin_expect(x, 0)) 
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
 
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
 
abc.o:     file format elf32-i386
 
Disassembly of section .text:
 
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   75 07                   jne    11 < testfun+0x11 >
   The compiler branches the "if" block and keeps "else" sequential
   a:   b8 06 00 00 00          mov    $0x6,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 19 00 00 00          mov    $0x19,%eax
  16:   eb f7                   jmp    f < testfun+0xf > 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "if" block is more probable by saying that x is more likely to be
  // true(1), non-zero.
  if(__builtin_expect(x, 1))
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
                                                                                                   
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
                                                                                                   
abc.o:     file format elf32-i386
                                                                                                   
Disassembly of section .text:
                                                                                                   
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   74 07                   je     11 < testfun+0x11 >
   The compiler branches the "else" block and keeps "if" sequential
   a:   b8 19 00 00 00          mov    $0x19,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 06 00 00 00          mov    $0x6,%eax
  16:   eb f7                   jmp    f < testfun+0xf >
<

 [KT] As shown, the probable cases are placed in sequential and menas in the pipe line. So most of
 case there is no jump.


{example-from-glibc}
#if __GNUC__ >= 3
# define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
# define __glibc_likely(cond)	__builtin_expect ((cond), 1)
#else
# define __glibc_unlikely(cond)	(cond)
# define __glibc_likely(cond)	(cond)
#endif

if (__glibc_unlikely (*s == L_('\0')))
   goto noconv;


G_LIKELY()

#define G_LIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 1))

if (G_LIKELY (random () != 1))
  g_print ("not one");

#define G_UNLIKELY(expr) (__builtin_expect (_G_BOOLEAN_EXPR(expr), 0))

if (G_UNLIKELY (random () == 1))
  g_print ("a random one");


if (G_UNLIKELY (!stream->caps)) {
    // when "stream->caps" is null, handle error case
}

So, do read code as if there is no likely/unlikely thing.


={============================================================================
*kt_dev_gcc_106* gcc: link: lrt

-lrt 

Means that librt.a to use clock_gettime.


={============================================================================
*kt_dev_gcc_107* gcc: link: sysroot and rpath-link

When not use sysroot with NXP toolchain, cause the problem:

-Wl,-rpath-link=/home/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools/usr/lib
-Xlinker --end-group -o
/home/NDS-UK/parkkt/TestBuild/APOLLO_01/LittleEndian/components/FOSH/FOSH_App/debug/FOSH_App
/backup/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools/usr/bin/../lib/gcc/arm-linux-uclibcgnueabi/4.4.0/../../../../arm-linux-uclibcgnueabi/bin/ld:
crt1.o: No such file: No such file or directory


--sysroot=directory
Use directory as the location of the sysroot, overriding the configure-time default. This option is
only supported by linkers that were configured using --with-sysroot.

e.g., --sysroot=/home/NDS-UK/parkkt/platforms/apollo/gnu_cortex-a9_tools, which is the top directory of toolchain.

-rpath-link=dir
When using ELF or SunOS, one shared library may require another. This happens when an ld -shared
link includes a shared library as one of the input files.

When the linker encounters such a dependency when doing a non-shared, non-relocatable link, it will
automatically try to locate the required shared library and include it in the link, if it is not
included explicitly. In such a case, the -rpath-link option specifies the first set of directories
to search. The -rpath-link option may specify a sequence of directory names either by specifying a
list of names separated by colons, or by appearing multiple times.

This option should be used with caution as it overrides the search path that may have been hard
compiled into a shared library. In such a case it is possible to use unintentionally a different
search path than the runtime linker would do.

The linker uses the following search paths to locate required shared libraries:

1. Any directories specified by -rpath-link options.

2. Any directories specified by -rpath options. The difference between -rpath and -rpath-link is
that directories specified by -rpath options are included in the executable and used at runtime,
whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is only
  supported by native linkers and cross linkers which have been configured with the --with-sysroot
  option.

3. On an ELF system, for native linkers, if the -rpath and -rpath-link options were not used, search
the contents of the environment variable LD_RUN_PATH.

4. On SunOS, if the -rpath option was not used, search any directories specified using -L options.

5. For a native linker, the search the contents of the environment variable LD_LIBRARY_PATH.

6. For a native ELF linker, the directories in DT_RUNPATH or DT_RPATH of a shared library are
searched for shared libraries needed by it. The DT_RPATH entries are ignored if DT_RUNPATH entries
exist.

7. The default directories, normally /lib and /usr/lib.

8. For a native linker on an ELF system, if the file /etc/ld.so.conf exists, the list of directories
found in that file. 

If the required shared library is not found, the linker will issue a warning and continue with the
link.


={============================================================================
*kt_dev_gcc_108* gcc: options

{reference}
https://gcc.gnu.org/onlinedocs/gcc/Option-Index.html#Option-Index

-v
Print (on standard error output) the commands executed to run the stages of compilation. Also print
the version number of the compiler driver program and of the preprocessor and the compiler proper.
note: can see spec and include path

-###
Like -v except the commands are not executed and arguments are quoted unless they contain only
alphanumeric characters or ./-_. This is useful for shell scripts to capture the driver-generated
command lines. 

-print-search-dirs 
note: to check path for lib

<debug-options>
https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html#Debugging-Options

-g
Produce debugging information in the operating system's native format (stabs, COFF, XCOFF, or DWARF
    2). GDB can work with this debugging information.

On most systems that use stabs format, -g enables use of extra debugging information that only GDB
can use; this extra information makes debugging work better in GDB but probably makes other
debuggers crash or refuse to read the program. If you want to control for certain whether to
generate the extra information, use -gstabs+, -gstabs, -gxcoff+, -gxcoff, or -gvms (see below).

GCC allows you to use -g with -O. The shortcuts taken by optimized code may occasionally produce
surprising results: some variables you declared may not exist at all; flow of control may briefly
move where you did not expect it; some statements may not be executed because they compute constant
results or their values are already at hand; some statements may execute in different places because
they have been moved out of loops.

Nevertheless it proves possible to debug optimized output. This makes it reasonable to use the
optimizer for programs that might have bugs.

The following options are useful when GCC is generated with the capability for more than one
debugging format. 

<code-gen-options>
-fpic or -fPIC
Generate position-independent code (PIC) suitable for use in a shared library, if supported for the
target machine. Such code accesses all constant addresses through a global offset table (GOT). The
dynamic loader resolves the GOT entries when the program starts (the dynamic loader is not part of
    GCC; it is part of the operating system). If the GOT size for the linked executable exceeds a
machine-specific maximum size, you get an error message from the linker indicating that -fpic does
not work; in that case, recompile with -fPIC instead. (These maximums are 8k on the SPARC and 32k on
    the m68k and RS/6000. The 386 has no such limit.)

Position-independent code requires special support, and therefore works only on certain machines.
For the 386, GCC supports PIC for System V but not for the Sun 386i. Code generated for the IBM
RS/6000 is always position-independent.

When this flag is set, the macros __pic__ and __PIC__ are defined to 1. 

<search-options>
https://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html#Directory-Options

-Ldir
Add directory dir to the list of directories to be searched for -l. 
note: used when compile.

-Lsearchdir 
--library-path=searchdir 

Add path searchdir to the list of paths that ld will search for archive libraries and ld control
scripts. You may use this option any number of times. The directories are searched in the order in
which they are specified on the command line. Directories specified on the command line are searched
before the default directories. All -L options apply to all -l options, regardless of the order in
which the options appear. 

If searchdir begins with =, then the = will be replaced by the sysroot prefix, a path specified when
the linker is configured. 

The default set of paths searched (without being specified with `-L') depends on which emulation
mode ld is using, and in some cases also on how it was configured. See Environment. 

The paths can also be specified in a link script with the SEARCH_DIR command. Directories specified
this way are searched at the point in which the linker script appears in the command line. 

<link-options>
http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options

-llibrary
-l library
Search the library named library when 'linking'. 

It makes a difference where in the command you write this option; the linker searches and processes
libraries and object files in the order they are specified. Thus, 'foo.o -lz bar.o' searches library
'z' after file foo.o but before bar.o. If bar.o refers to functions in 'z', those functions may not
be loaded.

The linker searches a standard list of directories for the library, which is actually a file named
liblibrary.a. The linker then uses this file as if it had been specified precisely by name.

The directories searched include several standard system directories plus any that you specify with
-L.

Normally the files found this way are library files-archive files whose members are object files.
The linker handles an archive file by scanning through it for members which define symbols that have
so far been referenced but not defined. But if the file that is found is an ordinary object file, it
is linked in the usual fashion. The only difference between using an -l option and specifying a file
name is that -l surrounds library with 'lib' and '.a' and searches several directories.

-shared
Produce a shared object which can then be linked with other objects to form an executable. Not all
systems support this option. For predictable results, you must also specify the same set of options
used for compilation (-fpic, -fPIC, or model suboptions) when you specify this linker option.1 

-Wl,option
Pass option as an option to the linker. If option contains commas, it is split into multiple options
at the commas. You can use this syntax to pass an argument to the option. For example,
-Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also
get the same effect with -Wl,-Map=output.map. 

-nostdlib
Do not use the standard system startup files or libraries when linking. No startup files and only
the libraries you specify are passed to the linker, and options specifying linkage of the system
libraries, such as -static-libgcc or -shared-libgcc, are ignored.

The compiler may generate calls to memcmp, memset, memcpy and memmove. These entries are usually
resolved by entries in libc. These entry points should be supplied through some other mechanism when
this option is specified.

One of the standard libraries bypassed by -nostdlib and -nodefaultlibs is libgcc.a, a library of
internal subroutines which GCC uses to overcome shortcomings of particular machines, or special
needs for some languages. (See Interfacing to GCC Output, for more discussion of libgcc.a.) In most
cases, you need libgcc.a even when you want to avoid other standard libraries. In other words, when
you specify -nostdlib or -nodefaultlibs you should usually specify -lgcc as well. This ensures that
you have no unresolved references to internal GCC library subroutines. (An example of such an
internal subroutine is '__main', used to ensure C++ constructors are called; see collect2.) 


={============================================================================
*kt_dev_gcc_109* gcc: options: get dependancies

https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html

<E-option>
-E

If you use the -E option, nothing is done except preprocessing. Some of these options make sense
only together with -E because they cause the preprocessor output to be 'unsuitable' for actual
compilation. 

$ g++ -std=c++0x -E useargs.cpp > out.txt

<save-temp>
To produce three extra files with .i, .s and .o extension. The temporary files produced by
-save-temps flag in one go can be produced one by one by using the gcc flags -E, -C and -S at each
of the preprocessing, compilation and assembly steps respectively.

note: -save-temps is in debugging options.

<wall>
-Wall

Turns on all optional warnings which are desirable for normal code. At present this is -Wcomment,
-Wtrigraphs, -Wmultichar and a warning about integer promotion causing a change of sign in #if
  expressions. Note that many of the preprocessor's warnings are on by default and have no options
  to control them. 

note: it is different from -Wall in warning options.

<dependancies-output>
Found that there is .deps dir which has dependancy output.

$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF ./deps/$*.Tpo -c -o $@ $<

-DNDEBUG -O2 -pipe -MT nexusMgr.lo -MD -MP -MF .deps/nexusMgr.Tpo -c src/nexusMgr.c  -fPIC -DPIC -o
.libs/nexusMgr.o

-MP
This option instructs CPP to add a phony target for each dependency other than the main file,
causing each to depend on nothing. These dummy rules work around errors make gives if you remove
  header files without updating the Makefile to match.

    This is typical output:

              test.o: test.c test.h
              
              test.h:

-MD
-MD is equivalent to -M -MF file, except that -E is not implied. The driver determines file based on
whether an -o option is given. If it is, the driver uses its argument but with a suffix of .d,
otherwise it takes the name of the input file, removes any directory components and suffix, and
  applies a .d suffix.

If -MD is used in conjunction with -E, any -o switch is understood to specify the dependency output
file (see -MF), but if used without -E, each -o is understood to specify a target object file.

Since -E is not implied, -MD can be used to generate a dependency output file as a side-effect of
the compilation process. 

-M
Instead of outputting the result of preprocessing, output a rule suitable for make describing the
dependencies of the main source file. The preprocessor outputs one make rule containing the object
file name for that source file, a colon, and the names of 'all' the 'included' files, including those
coming from -include or -imacros command line options.

Unless specified explicitly (with -MT or -MQ), the object file name consists of the name of the
source file with any suffix replaced with object file suffix and with any leading directory parts
removed. If there are many included files then the rule is split into several lines using
\ newline. The rule has no commands.

This option does not suppress the preprocessor's debug output, such as -dM. To 'avoid' mixing such
debug output with the dependency rules you should explicitly specify the dependency output file with
-MF, or use an environment variable like DEPENDENCIES_OUTPUT (see Environment Variables). Debug
output will still be sent to the regular output stream as normal.

Passing -M to the driver implies -E, and suppresses warnings with an implicit -w.

note: gcc -M tgetopt.c

tgetopt.o: tgetopt.c /usr/include/unistd.h /usr/include/features.h \
 /usr/include/x86_64-linux-gnu/bits/predefs.h \
 /usr/include/x86_64-linux-gnu/sys/cdefs.h \
 /usr/include/x86_64-linux-gnu/bits/wordsize.h \
 /usr/include/x86_64-linux-gnu/gnu/stubs.h \
 ...


-MF file
When used with -M or -MM, specifies a file to write the dependencies to. If no -MF switch is given
the preprocessor sends the rules to the same place it would have sent preprocessed output.

When used with the driver options -MD or -MMD, -MF overrides the default dependency output file. 

<debugging>
-dCHARS

CHARS is a sequence of one or more of the following characters, and must not be preceded by a space.
Other characters are interpreted by the compiler proper, or reserved for future versions of GCC, and
so are silently ignored. If you specify characters whose behavior conflicts, the result is
undefined.

   'M'
   Instead of the normal output, generate a list of '#define' directives for all the macros defined
   during the execution of the preprocessor, including predefined macros. This gives you a way of
   'finding' out what is predefined in your version of the preprocessor. Assuming you have no file
   foo.h, the command

   touch foo.h; cpp -dM foo.h

   will show all the predefined macros.

   If you use -dM without the -E option, -dM is interpreted as a synonym for -fdump-rtl-mach. See
   Debugging Options. 

note: can see #defines

$ cpp -dM tgetopt.c
$ echo '#include <errno.h>' | cpp -dM


={============================================================================
*kt_dev_gcc_110* gcc: attributes

https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html

5.24 Declaring Attributes of Functions

In GNU C, you declare certain things about functions which help the compiler optimize function calls
and check your code more carefully.

The keyword __attribute__ allows you to specify special attributes when making a declaration. This
keyword is followed by an attribute specification inside double parentheses. The following
attributes are currently defined for functions on all targets: noreturn, returns_twice, noinline,
always_inline, flatten, pure, const, nothrow, sentinel, format, format_arg, no_instrument_function,
section, constructor, destructor, used, unused, deprecated, weak, malloc, alias, warn_unused_result,
nonnull and externally_visible. 
  
Several other attributes are defined for functions on particular target systems.

<visibility>
visibility ("visibility_type")

The visibility attribute on ELF targets causes the declaration to be emitted with default, hidden,
protected or internal visibility.

void __attribute__ ((visibility ("protected")))
f () { /* Do something. */; }

int i __attribute__ ((visibility ("hidden")));
         

See the ELF gABI for complete details, but the short story is:

default
Default visibility is the normal case for ELF. This value is available for the visibility attribute
to override other options that may change the assumed visibility of symbols.

hidden
Hidden visibility indicates that the symbol will not be placed into the dynamic symbol table, so no
other module (executable or shared library) can reference it directly.  

internal 
Internal visibility is like hidden visibility, but with additional processor specific semantics.
Unless otherwise specified by the psABI, GCC defines internal visibility to mean that the function
is never called from another module. Note that hidden symbols, while they cannot be referenced
directly by other modules, can be referenced indirectly via function pointers. By indicating that a
symbol cannot be called from outside the module, GCC may for instance omit the load of a PIC
register since it is known that the calling function loaded the correct value.  

protected 
Protected visibility indicates
that the symbol will be placed in the dynamic symbol table, but that references within the defining
module will bind to the local symbol. That is, the symbol cannot be overridden by another module. 

Not all ELF targets support this attribute. 

={============================================================================
*kt_dev_gcc_111* gcc: profiling

{how-to-use-gcc-optimisation} {gcc-profiling}
The example program above does have a very predictable, repeatable flow of execution. Let's see what
happens when we use compiler-assisted optimization. Building the programming now involves two steps:
a profiling phase and an optimized compile. In the profiling phase, we build and run an instrumented
version of the executable. We build as follows:

    $ cc -O3 -DDONT_EXPECT -fprofile-generate builtin_expect_test.c -o bn.prof

(The -fprofile-generate option implies -fprofile-arcs, as well as one or two other profiling
options.)

We then run the executable, which generates profiling information that is stored in a file (with the
extension .gcda).

    $ time -f "%E real, %U user, %S sys" ./bn.prof 1000
    0, 1000000000
    0:05.39 real,  5.37 user, 0.00 sys

Note that, because of the instrumentation code, the profiled version runs rather slower that the
normally compiled code.  Running this code created a file containing the profiling results:

    $ ls *.gcda
    builtin_expect_test.gcda

We then employ the -fprofile-use compiler option,which (implicitly) uses the profiling results to
create an optimized executable.

    $ cc -O3 -DDONT_EXPECT -fprofile-use builtin_expect_test.c -o bn.opt

And then we run the optimized program:

    $ time -f "%E real, %U user, %S sys" ./bn.opt 1000
    0, 1000000000
    0:01.95 real,  1.94 user, 0.00 sys

This optimized version runs significantly faster (1.95 versus 2.28 seconds) than our version that
used __builtin_expect(). This is because, in addition to the branching in the if statement, the
branching in the for loops was also optimized.

It's left as an exercise for the reader to show that employing __builtin_expect() (to expect 0) in
conjunction with compiler-assisted optimization doesn't improve things: the compiler already
optimizes the if branching as well as the programmer-directed optimization. One other interesting
exercise  is, of course, to compare the assembler (cc -S) code generated for each of the above
cases. 


={============================================================================
*kt_dev_gcc_112* gcc: options: optimization

From LPI 41.

In addition, on some architectures, such as x86-32, the fomitframepointer option should not be
specified because this makes debugging impossible. On some architectures, such as x86-64, this
option is enabled by default since it doesn't prevent debugging. For the same reason, executables
and libraries should not be stripped of debugging information using strip(1).

From gcc doc:

-fomit-frame-pointer
Don't keep the frame pointer in a register for functions that don't need one. This avoids the
instructions to save, set up and restore frame pointers; it also makes an extra register available
in many functions. It also makes debugging impossible on some machines.

On some machines, such as the VAX, this flag has no effect, because the standard calling sequence
automatically handles the frame pointer and nothing is saved by pretending it doesn't exist. The
machine-description macro FRAME_POINTER_REQUIRED controls whether a target machine supports this
flag. See Register Usage.

Enabled at levels -O, -O2, -O3, -Os. 


={============================================================================
*kt_dev_gcc_113* gcc: options: warnings

https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html

-Wextra
This enables some extra warning flags that are not enabled by -Wall. (This option used to be called
    -W. The older name is still supported, but the newer name is more descriptive.)

              -Wclobbered  
              -Wempty-body  
              -Wignored-qualifiers 
              -Wmissing-field-initializers  
              -Wmissing-parameter-type (C only)  
              -Wold-style-declaration (C only)  
              -Woverride-init  
              -Wsign-compare  
              -Wtype-limits  
              -Wuninitialized  
              -Wunused-parameter (only with -Wunused or -Wall) 
              -Wunused-but-set-parameter (only with -Wunused or -Wall)  
              

The option -Wextra also prints warning messages for the following cases:

        A pointer is compared against integer zero with <, <=, >, or >=.
        (C++ only) An enumerator and a non-enumerator both appear in a conditional expression.
        (C++ only) Ambiguous virtual bases.
        (C++ only) Subscripting an array that has been declared register.
        (C++ only) Taking the address of a variable that has been declared register.
        (C++ only) A base class is not initialized in a derived class's copy constructor. 


={============================================================================
*kt_dev_gcc_200* gcc: cpp: preprocessor

http://gcc.gnu.org/onlinedocs/cpp/
/usr/bin/cpp

The C preprocessor, often known as cpp, is a "macro processor" that is used automatically by the C
compiler to transform your program before compilation. It is called a macro processor because it
allows you to define 'macros', which are brief abbreviations for longer constructs. 


={============================================================================
*kt_dev_gcc_201* gcc: cpp: define? 

Q: What's the difference between "define _LIMITS_H" and "define _LIMITS_H 1"?

# ifndef _LIMITS_H
#  define _LIMITS_H 1
...
# endif /* limits.h  */

2.4 Once-Only Headers

If a header file happens to be included twice, the compiler will process its contents twice. This is
very likely to cause an error, e.g. when the compiler sees the same structure definition twice. Even
if it does not, it will certainly waste time.

The standard way to prevent this is to enclose the entire real contents of the file in a
conditional, like this:

     /* File foo.  */
     #ifndef FILE_FOO_SEEN
     #define FILE_FOO_SEEN
     
     the entire file
     
     #endif /* !FILE_FOO_SEEN */

This construct is commonly known as a "wrapper #ifndef". When the header is included again, the
conditional will be false, because FILE_FOO_SEEN is defined. The preprocessor will skip over the
entire contents of the file, and the compiler will not see it twice.

CPP optimizes even further. It remembers when a header file has a wrapper #ifndef. If a subsequent
#include specifies that header, and the macro in the #ifndef is still defined, it does not
bother to rescan the file at all.

You can put comments outside the wrapper. They will not interfere with this optimization.

The macro FILE_FOO_SEEN is called the controlling macro or "guard macro". In a user header file, the
macro name should 'not' begin with '_'. In a system header file, it 'should' begin with '__' to
avoid conflicts with user programs. In any kind of header file, the macro name should contain the
name of the file and some additional text, to avoid conflicts with other header files.  

Q: Is it a problem to use '_' for user headers?

-D name 
Predefine name as a macro, with definition 1. 

-D name=definition
The contents of definition are tokenized and processed as if they appeared during translation phase
three in a '#define' directive. In particular, the definition will be truncated by embedded newline
characters.

If you are invoking the preprocessor from a shell or shell-like program you may need to use the
shell's quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its argument list with
surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells,
so you will need to quote the option. With sh and csh, -D'name(args...)=definition' works.

-D and -U options are processed in the order they are given on the command line. All -imacros file
and -include file options are processed after all -D and -U options. 

4.2.3 Defined

The special operator defined is used in '#if' and '#elif' expressions to test whether a certain name
is defined as a macro. "defined name" and "defined (name)" are both expressions whose value is <1>
if name is defined as a macro at the current point in the program, and 0 otherwise. Thus, #if
defined MACRO is precisely equivalent to #ifdef MACRO.

defined is useful when you wish to test more than one macro for existence at once. For example,

     #if defined (__vax__) || defined (__ns16000__)

would succeed if either of the names __vax__ or __ns16000__ is defined as a macro.

Conditionals written like this:

     #if defined BUFSIZE && BUFSIZE >= 1024

can generally be simplified to just #if BUFSIZE >= 1024, since if BUFSIZE is not defined, it will be
interpreted as having the value zero.

If the defined operator appears as a result of a macro expansion, the C standard says the behavior
is undefined. GNU cpp treats it as a genuine defined operator and evaluates it normally. It will
warn wherever your code uses this feature if you use the command-line option -pedantic, since other
compilers may handle it differently. 

<example>
#define SAMPLE
#define SAMPLE 1
#define SAMPLE 2

// This works for all three cases
#ifdef SAMPLE
  printf("sample is def\n");
#endif

// For 1, emit error like: 
// sam01.c:39:12: error: operator '>' has no left operand
// Only works for 2 case.
#if SAMPLE == 1
  printf("sample is =1\n");
#endif

// For 1, emit error like: 
// sam01.c:39:12: error: operator '>' has no left operand
// Only works for 3 case.
#if SAMPLE > 1
  printf("sample is >1 \n");
#endif

After all, "define MACRO x" is to use macro value and no real needs as a guard macro.


={============================================================================
*kt_dev_gcc_202* gcc: cpp: how-to-get-filename-without-full-path

http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros

The standard predefined macros are specified by the relevant language standards, so they are
available with all compilers that implement those standards. Older compilers may not provide all of
them. Their names all start with double underscores.

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus to test whether a
header is compiled by a C compiler or a C++ compiler. This macro is similar to __STDC_VERSION__, in
that it expands to a version number. Depending on the language standard selected, the value of the
macro is 199711L, as mandated by the 1998 C++ standard; 201103L, per the 2011 C++ standard; an
unspecified value strictly larger than 201103L for the experimental languages enabled by -std=c++1y
and -std=gnu++1y. 

__FILE__

This macro expands to the name of the current input file, in the form of a C string constant. This
is the path by which the preprocessor opened the file, not the short name specified in '#include' or
as the input file name argument. For example, "/usr/local/include/myheader.h" is a possible
expansion of this macro. [KT] For c files, this is a path from where run gcc to build.

<how-to-get-filename-without-full-path>

char *strrchr(const char *s, int c);
The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

#include <string.h>
#define FILE (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

int main()
{
   printf("file is %s\n", __FILE__);
   printf("file is %s:%d:%s\n", FILE, __LINE__, __PRETTY_FUNCTION__ );
}

__LINE__

This macro expands to the current input line number, in the form of a decimal integer constant.
While we call it a predefined macro, it's a pretty strange macro, since its "definition" changes
with each new line of source code. 

__FILE__ and __LINE__ are useful in generating an error message to report an inconsistency detected
by the program; the message can state the source line at which the inconsistency was detected. For
example,

     fprintf (stderr, "Internal error: "
                      "negative string length "
                      "%d at %s, line %d.",
              length, __FILE__, __LINE__);

An '#include' directive changes the expansions of __FILE__ and __LINE__ to correspond to the
included file. At the end of that file, when processing resumes on the input file that contained the
'#include' directive, the expansions of __FILE__ and __LINE__ revert to the values they had before
the '#include' (but __LINE__ is then incremented by one as processing moves to the line after the
'#include').

A '#line' directive changes __LINE__, and may change __FILE__ as well. See Line Control.

__func__ and __FUNCTION__ 

C99 introduces __func__, and GCC has provided __FUNCTION__ for a long time. Both of these are
strings containing the name of the current function (there are slight semantic differences; see the
GCC manual). Neither of them is a macro; the preprocessor does not know the name of the current
function. They tend to be useful in conjunction with __FILE__ and __LINE__, though. 

__PRETTY_FUNCTION__

http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html

GCC provides three magic variables that hold the name of the current function, as a string. The
first of these is __func__, which is part of the C99 standard:

The identifier __func__ is implicitly declared by the translator as if, immediately following the
opening brace of each function definition, the declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing function. This name is the
unadorned name of the function.

__FUNCTION__ is another name for __func__. Older versions of GCC recognize only this name. However,
it is not standardized. For maximum portability, we recommend you use __func__, but provide a
fallback definition with the preprocessor:

     #if __STDC_VERSION__ < 199901L
     # if __GNUC__ >= 2
     #  define __func__ __FUNCTION__
     # else
     #  define __func__ "<unknown>"
     # endif
     #endif

In C, __PRETTY_FUNCTION__ is yet another name for __func__. 

>
 However, in C++, __PRETTY_FUNCTION__ contains the type signature of the function as well as its bare
 name. For example, this program:
<
     extern "C" {
     extern int printf (char *, ...);
     }
     
     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };
     
     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)  // [KT] seems useful

These identifiers are not preprocessor macros. In GCC 3.3 and earlier, in C only, __FUNCTION__ and
__PRETTY_FUNCTION__ were treated as string literals; they could be used to initialize char arrays,
and they could be concatenated with other string literals. GCC 3.4 and later treat them as
variables, like __func__. In C++, __FUNCTION__ and __PRETTY_FUNCTION__ have always been variables. 


={============================================================================
*kt_dev_gcc_203* gcc: cpp: isystem option

-isystem dir
Mark it as a system directory, so that it gets the same special treatment as is applied to the
standard system directories. See System Headers. If dir begins with =, then the = will be replaced
by the sysroot prefix; see --sysroot and -isysroot. 

2.8 System Headers

The header files declaring interfaces to the operating system and runtime libraries often cannot be
written in strictly conforming C. Therefore, GCC gives code found in system headers 'special'
treatment. All warnings, other than those generated by '#warning' are suppressed while GCC is
processing a system header. Macros defined in a system header are immune to a few warnings wherever
they are expanded. This immunity is granted on an ad-hoc basis, when we find that a warning
generates lots of false positives because of code in macros defined in system headers.

Normally, only the headers found in specific directories are considered system headers. These
directories are determined when GCC is compiled. There are, however, two ways to make normal headers
into system headers.

The -isystem command line option adds its argument to the list of directories to search for headers,
just like -I. Any headers found in that directory will be considered system headers. 

All directories named by -isystem are searched after all directories named by -I, no matter what
their order was on the command line. If the same directory is named by both -I and -isystem, the -I
option is ignored. GCC provides an informative message when this occurs if -v is used.


={============================================================================
*kt_dev_gcc_300* gcc gprof

http://sourceware.org/binutils/docs/gprof/


# ============================================================================
#{ C AND C++
={============================================================================
*kt_dev_lang_001* global, file and local static

{problem}
# file A
class FileSystem {
  public:
    ...
      std::size_t numDisk() const;
    ...
};

// global tfs
extern FileSystem tfs;

# file B
class Directory {
  Directory()
  {
    std::size_t = tfs.numDisk();    // here uses FileSystem
    ...
  }
  ..
};

Directory tempDir( params );

How can you be sure that tfs will be initialised before tempDir? 

<init-order-problem>
This is called the intialization order fiasco, where global variables can be accessed before they
are initialised. This is the race-condition on global variables. How to solve? By replacing the
global variable with a function that returns a reference to a local static variable, this guarantee
that it is initialised before anything accesses it. This is only true for single-threaded. 

note: on single thread <static-and-race-condition>
From C++ concurrency in action, p62, the initialization of function static is defined to occur the
first time control passes through its declaration; for multiple threads calling the function, this
means there's the potential for a race condition to define first. On many pre-C++11 compilers this
race condition is problematic in practice because multiple threads may believe they're first and try
to initialize the variable, or threads may try to use it after initialization has started on another
thread but before it's finished. In C++11 this problem is solved: the initialization is defined to
happen on exactly one thread.


{what-static-is} function-static, file-static
Global vars has a program scope, global(file) static has a file scope and local(function) static has
a function scope>. note: on C++. file-static is from C and should use <unnamed-namespace> in C++.

void foo () {   
  static int x = 0;
  ++x;
  cout << x << endl;
}

int main (int argc, char const *argv[]) {
  foo();  // 1
  foo();  // 2
  foo();  // 3
  return 0;
}

<limit-scope>
The function static is only accessible within the function, and has no linkage.(?) It is initialised
the first time execution reaches the definition, not necessarily during the program's initialization
phases.

From ansic, p83.
So static is to 'limit' the scope of the object whether is to file or function. The file-static is
private to a file and will not conflict with the same names in other files of the same program. The
file static can be used on both variables and functions.

<limit-scope-meaning>
This applies to a function so if define static function, it has file-scope. 

// file one
#include < iostream>

static int gfs_count;
// extern static int gfs_count; 
// this causes an compile error: conflicting specifiers in declaration of 'gfs_count'

void print_gfs()
{
  std::cout << "{ "; 

  for(int idx = 0; idx < 5; idx++)
    gfs_count++;

  std::cout << gfs_count << std::endl;

  std::cout << "}" << std::endl; 
}

// file two
#include <iostream>

extern int gfs_count;
extern void print_gfs();

int main()
{
  std::cout << "{ "; 

  std::cout << gfs_count << std::endl;    // if remove this, no link error
  print_gfs();

  std::cout << "}" << std::endl; 
}

No error in building and in using a function in file one but failed to link in file two:

kit@kit-vb:~/work$ make
echo '>> build use-main.cpp'
g++ -std=c++0x -o main.o -c use-main.cpp
echo '>> build file-static.cpp'
g++ -std=c++0x -o file.o -c file-static.cpp
echo '>> bulid main'
g++ -std=c++0x -o out main.o file.o
main.o: In function `main':
use-main.cpp:(.text+0x1e): undefined reference to `gfs_count'
collect2: ld returned 1 exit status
make: *** [main] Error 1


{solution}
Use function-static. EC++04 said it is common implementation of <singleton-pattern>

# file A
class FileSystem {
   ...
};

# extern FileSystem tfs;
FileSystem& tfs()
{ >
  static FileSystem fs; return fs;
}

# file B
class Directory {
   ... use tfs
};

# Directory tempDir( params );
Directory& tempDir()
{ >
  static Directory td(tempDir); return td;
}


{singleton-pattern}
<why-singleton>
From design pattern. Using global/static objects have two problems:

1. Do not keep you from instantiating multiple objects of the same type(class). Not about the name.
class X one_instance; class X two_instance.

2. No control of access. e.g., init-order-problem.

Good things over global by making a class itself 'responsible' for keeping track of its sole instance:

1. instance control such as only one instance
2. single point of controlled access. there is no such a thing for global objects.
3. no creation if it is not called. See {limit-the-number-of-object}. In the following example, no
create unless a user call instance() but global do not.

<common-implementation>
1. For C, use function static as shown above.

2. For C++, use singleton class/pattern. Put simply. sigleton can be called class static in the same
sense as function static.

note: dynamic creation and must have destructor.

class Singleton {
  public:
    // single point of access
    // <lazy-initialisation> means that do not create instance until its first access.
    'static' Singleton* Instance()
    {
      if(_instance==0) {
        _instance = new Singleton;
      }
      return _instance;
    }

  // <no-user-creation>
  // shall be an implementation since gets created in Instance() anyway.
  // <Q> why not private?
  protected:                         
    Singleton() {};                  

  // can have different concrete classes in different hierachy
  private:
    'static' Singleton* _instance;
};

Singleton* Singleton::_Instance = 0;

<no-user-creation>
No preventing-copies for singleton. Why? Because no direct creation from a user. See
preventing-copies for more.


{singleton-plus-factory}
The singleton is similar to factory-func in that both has a single point to create hence static
func. However, the aim is different. The singleton is to create a single instance and the factory is
to choose what to create. 

Like to have singleton feature and flexibility to choose what to create? Here are ways:

<first-way> use env + use subclassing + static creation
There are many ways to specify what derived class to create. See {interface-class}. The other way in
design pattern, use 'registry' to find a class to create which is more flexible because it is open
to possible singleton class meaning no Instance() change when there are new sigleton class and to
set it at run-time.

class Singleton {
  public:
    'static' void Register( char* name, Singleton* );
    'static' Singleton* Instance();

  protected:
    'static' Singleton* Lookup( const char* name );

  private:
    'static' Singleton* _instance;
    'static' List<NameStingletonPair>* _registry;
};

Singleton* Singleton::Instance() 
{
  if(_instance==0) {

    const char* singletonName = getenv("SINGLETON");
    _instance = Lookup(singletonName);
  }
  return _instance;
}

// to register
MySingleton::MySingleton() 
{
  ...
  Singleton::Register( "MYSINGLETON", this );
}

// create and used file static since no protected ctor but how about parent class?
static MySingleton mySingleton;
static XXSingleton XXSingleton;

theSingleton.Instance();         // ? should be Singleton::Instance()->xxx();

The downside is that 'all' possible singleton classes must be created before register since must
build a list to look up beforehand. Here have single instance for a selcted class in container. How
about multiple instance of a class? 

<second-way> from design pattern. use env + use subclassing + use dynamic creation

class MazeFactory {
  public:
    static MazeFactory* Instance();
    ... public interfaces ...

  protected:
      MazeFactory();

  private:
      static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new MazeFactory;
  }

  return _instance;
}

To create different classes:

MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    const char* mazeStyle = getenv("MAZESTYLE");

    if( strcmp( mazeStyle, "bombed" ) == 0 ) {
      _instance = new BombedMazeFactory;
    }
    else if( strcmp( mazeStyle, "ehchanted" ) == 0 ) {
      _instance = new EnchantedMazeFactory;

      // other possible subclasses which means this should be modified whenever there are new
      // subclasses.

    } else { // default
      _instance = new MazeFactory;
    }
  }

  return _instance;
}

'quiz': How about overriding Instance() in class hierachy? NOT OK because there must be an instance
to call Instance() but ctor is protected. So MUST use <class-method>, staic-member-func, for
singleton-pattern.

class MazeFactory {
  public:
    'virtual' MazeFactory* Instance(); 
    ... public interfaces ...

  protected:
      MazeFactory();

  private:
      static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

BombedMazeFactory* BombedMazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new BombedMazeFactory;
  }

  return _instance;
}


{limit-the-number-of-object} TODO: more tidy up
MEC++26. This is example of <function-static>

class PrintJob;

class Printer {
  public:
    void reset();
    ...

  friend Printer& thePrinter();  // why need this? because need to call ctor.

  private:                       // <ban-to-create-directly>
   Printer();
   Printer( const Printer& rhs );
   ...
};

Printer& thePrinter()
{
  static Printer p; 
  return p;
}

Use:

thePrinter().reset();

The other approach is to make it static member function and then it make use a bit wordier:

Printer::thePrinter().reset();

Recommend <funciton-static> over class-variable because:

1. no creation if no func call. An object that is static in a class is, for all intents and purposes,
always constructed (and destructed), even if it is never used. KT: This has nothing to do with
static because class member object will be created regardless of static.

o prevent {init-order-problem} since this could happen anything but function-static.

KT. This method do lazy-initialisation automatically and seems to be a good alternative to
singletone?


{{control-the-number-of-object}}

class Printer {
	 public:
	 	class TooManyObjects { };

		Printer();
		~Printer();
		...

	private:
		static size_t numObjects;
		Printer(const Printer& rhs); # no-copy-ctor
};

size_t Printer::numObjects = 0;

Printer::Printer()
{
	 if( numObjects >= 1 ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}

Printer::~Printer()
{
	 ...
	 --numObjects;
}

The pros is that easy to understand and to support any number of objects.

The cons is that is not working in following cases; inheritance and <containment>. Both can be
prevented by having private ctor because cannot create object:

class ColorPrinter : public Printer {
	 ...
};

Printer p;
ColorPrinter cp;  # cause-an-exception


class X {
	 private:
	 	Printer p;
		...
};

X m1;
X m2;             # cause-an-exception

Both cases call ctor twice and these can be prevented by having ctor private. Here note that static
var, class-static, remains a single across objects of its class.


{{pseudo-ctor}}

class FSA {
	 public:
	 	static FSA* makeFSA();
	 	static FSA* makeFSA( const FSA& rhs );
		...

	private:
		FSA();
		FSA( const FSA& rhs );
		...
};

FSA* FSA::makeFSA()
{ return newFSA(); } # okay as it is member func

When make ctors private, cannot create object. Hence no derivation and containment. This pseudo-ctor
approcah means that client must delete and can use smart pointer for that.


{{multiple-time-instance-in-liecycle}}

<file-static> has only one instance for whole program life so not possible to do:

create Printer object p1;
use p1;
destroy p1;
create Printer object p2;
use p2;
destroy p2;

If use both control-the-number-of-object and prventing derivation, then have single instance in
multiple times for whole program life.

class Printer {
	 public:
	 	class TooManyObjects { ... };

		static Printer* makePrinter();
		~Printer();
		void reset();
		...

	private:
		static size_t numObjects;
		Printer();
		Printer( const Printer& rhs );
};

size_t Printer::numObjects = 0;

Printer::Printer()
{
	 if( numObjects >= 1 ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}

Printer* Printer::makePrinter()
{ return new Printer(); }

Can return null pointer instead of issuing an exception.

To supports more than one:

class Printer {
	 public:
	 	class TooManyObjects { ... };

		static Printer* makePrinter();
		~Printer();
		void reset();
		...

	private:
		static size_t numObjects;
		static const size_t maxObjects = 10;
		Printer();
		Printer( const Printer& rhs );
};

size_t Printer::numObjects = 0;
const size_t Printer::maxObjects;

Printer::Printer()
{
	 if( numObjects >= maxObjects ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}


{{to-support-different-instance}}

If there are many other types of instances to manage? Make it generalise and use template:

template< class T > # T is type being counted
class Counted {     # instance counting class
	 public:
	 	class TooManyObject { ... };
		static size_t objectCount() { return numObjects; }

	protected:       # <to-make-it-used-only-as-base-class>
		Counted();
		Counted( const Counted& rhs );
		~Counted() { --numObjects; };

	private:
		static size_t numObjects;
		static const size_t maxObjects;
		void int();
};

template< class T>
Counted< T >::Counted()
{ init(); }

template< class T>
Counted< T >::Counted( const Counted< T >& )
{ init(); }

template< class T>
void Counted< T>::init()
{
	 if( numObjects >= maxObjects )
		  throw TooManyObjects();
	
	++numObjects;
}


template< class T> size_t Counted< T>::numObjects;


Each derived class, Counted< T>, has independent counter and manage counting mechanism which is
<encapsulation>

Client use:

class Printer : private Counted< Printer> {
	 public:
	 	static Printer* makePrinter();
	 	static Printer* makePrinter( const Printer& rhs );
		 
		~Printer();
		void reset();
		...

		note: to make these public
		using Counted< Printer>::objectCount;
		using Counted< Printer>::TooManyObjects;

	private:
		Printer();
		Printer( const Printer& rhs );
};

note: Client should set static values which is a bit of loose end. If not, link error.

const size_t Counted< Printer>::maxObjects = 10;
const size_t Counted< FileDescripter>::maxObjects = 16;


{further-study}
(However, there is still no guarantee that it will not be destroyed before anything finishes
accessing it; you still need to take great care if you think you need a globally-accessible
variable. See the comments for a link to help in that situation.)

That is, init order fiaso means that there is no gurantee on the order of init when global and
global static init each other. e.g. if there are A and B object and B uses a method of A, then it is
a problem when B is created first.

The solution to this is to use local static:

http://www.parashift.com/c++-faq-lite/static-init-order-on-first-use.html
http://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746

note: KT. since it's best to avoid global object, do not study it further.


={============================================================================
*kt_dev_lang_002* stdio

{redirection}
When shell runs a program, three files are open, with file descriotors 0, 1, 2, called standard
input, output, and error. For redirectins, shell changes default assignment for 0,1,2 to the named
files. All done by shell, but not by a program.

prog <infile
otherprog | prog
prog >outfile
prog | otherprog


{file-io}
library level                                system level
FILE* fopen( char *name, char *mode);        open
int getc( FILE* fp );
int putc( int c, FILE *fp );

#define getchar()    getc(stdin)
#define putchar(c)   putc((c), stdout)

FILE* stdin       stdout, strerr
      keyboard    screen

Every program has these FILE pointers opened automatically.

<example> simple cat program
#include <stdio.h>
#include <stdlib.h>

void filecopy( FILE *ifp, FILE *ofp )
{
  int c;

  while((c = getc(ifp)) != EOF )
    putc( c, ofp );
}

// cat: concatenate files
main( int argc, char *argv[] )
{
  FILE* fp;

  char *prog = argv[0];

  // no args; copy standard input
  if( argc == 1 )
    filecopy( stdin, stdout );
  else
    while(--argc > 0)
      if((fp = fopen( *++argv, "r" )) == NULL )
      {
        fprintf( stderr, "%s: can't open %s\n", prog, *argv );
        exit(1);
      }
      else
      {
        filecopy(fp, stdout);
        fclose(fp);
      }

  // check stream status
  if( ferror(stdout) )
  {
    fprintf( stderr, "%s: error writing stdout\n", prog );
    exit(2);
  }

  exit(0);
}

<why-stderr>
Output written on stderr normally appears on the screen even if the standard output is redirected.

<freopen>
The freopen in stdio.h enables us to bind a file to stdin so can have < redirection effect.

The freopen() function opens the file whose name is the string pointed to by path and associates the
stream pointed to by stream with it. The original stream (if it exists) is closed. The mode argument
is used just as in the fopen() function. The primary use of the freopen() function is to change the
file associated with a standard text stream (stderr, stdin, or stdout).

freopen("input.txt","r",stdin);     // redirects standard input
freopen("output.txt","w",stdout);   // redirects standard output
int x;
cin>>x;           // reads from input.txt
cout<<x<<endl;    // writes to output.txt

<example> compare with stringstream example
#include <iostream>
#include <string>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  StockLine sline;

  freopen("input.txt", "r", stdin);

  while(!feof(stdin))
  {
    cin >> sline.name;
    cin >> sline.time;
    cin >> sline.volume;
    cin >> sline.high;
    cin >> sline.low;

    cout << "{ " 
      << sline.name << ", "
      << sline.time << ", "
      << sline.volume << ", "
      << showpoint 
      << sline.high << ", "
      << sline.low << " }" << endl;
  }
}

// input file
VOD.L 1 100 184.0 183.7
ITV.L 4 45 184.55 183.7

// <Q> Why three lines?
{ VOD.L, 1, 100, 184.000, 183.700 }
{ ITV.L, 4, 45, 184.550, 183.700 }
{ ITV.L, 4, 45, 184.550, 183.700 }

The fixed version:

#include <iostream>
#include <string>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  StockLine sline;

  freopen("input.txt", "r", stdin);

  while(!feof(stdin))
  {
    cin >> sline.name;
    cin >> sline.time;
    cin >> sline.volume;
    cin >> sline.high;
    cin >> sline.low;

    if(!feof(stdin))                      // note: difference
    {
      cout << "{ " 
        << sline.name << ", "
        << sline.time << ", "
        << sline.volume << ", "
        << showpoint 
        << sline.high << ", "
        << sline.low << " }" << endl;
    }
  }
}


{readline}
<getline> from ansic, section 1.9, p29.
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#define MAXLINE 1000 // maximum input line size

// <one> notice that it includes '\n'
int mygetline(char line[], int maxlen )
{
  int c, i;

  // <Q1> also notice that ' < maxlen-1' leave one space for a null
  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  // <Q2>
  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
  return i;
}

// <two>
int mygetline(char line[], int maxlen )
{
  int c, i;

  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF); i++)
    line[i] = c;

  line[i] = '\0';
  return i;
}

// copy 'from' into 'to'; assume 'to' is big enough
void copy( char to[], char from[] )
{
  while( *to++ = *from++ )
    ;
}

// print the longest line from stdin
int main()
{
  int curlen;              // current line length
  int maxlen;              // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  maxlen = 0;
  while(( curlen = mygetline( line, MAXLINE )) > 0 )
  {
    printf("while: %s", line);

    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


<Q1> What's the difference between one and two?

one: "...\n"

kt@kt-ub-vb:~/work$ ./a.out 
this is one.
while: this is one.
this is two line.
while: this is two line.
this is three line.
while: this is three line.
this is three line.


two: "...\n...\n...\n" 

kt@kt-ub-vb:~/work$ ./a.out 
this is one.
this is two line.
this is three line.
while: this is one.     // pressed C-d
this is two line.
this is three line.

this is one.            // pressed C-d
this is two line.
this is three line.

Notice that use of 'return' size in this call since starts from 0.

0  1  2  3  4  5  6  (return)
h  e  l  l  o  \n \0
1  2  3  4  5  6  7

<Q2> Does it cause accessing out of array index when \n falls in the last of read loop?
When array size is 10, then 0-9 is valid index. The first loop is for [0,8], and [9] for '\n', and
[10] for '\0'?

{
  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
}

NO since when 8th reads '\n' and loop stops so no increase. [8] = '\n' and [9] = '\0'. That is the
first loop is [0,8). The [size-1] is reserved for null to make it a string.

read idx: 0 1 2 3 4 5 6 7 8   9
input   : a a a a a a a a '\n'

If use standard liberay to get line, can use:

char *fgets( char *line, int maxline, FILE *fp);
int fputs( char *line, FILE *fp);

However, getline is more useful since returns the line length.

int getline( char *line, int max )
{
  if( fgets( line, max, stdin ) == NULL )
    return 0;
  else
    return strlen(line);
}


<stdio-getline>
ssize_t getline(char **lineptr, size_t *n, FILE *stream);

int main()
{
  int curlen; // current line length
  int maxlen; // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  char* pline = line;
  size_t max = MAXLINE;

  maxlen = 0;
  while(( curlen = getline( &pline, &max, stdin )) > 0 )
  {
    printf("while: %s", line);

    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


{io-stream} C++
The ifstream class binds file to stream and then need a call to read data from stream such as
getline(). Further, istream_iterator {stream-iterator} add iterator features to a stream. However
freopen binds file to stdin and can use cin >> to read data.

<which-getline>
Without including <fstream>, then compiler emits error since there are getline from stdio and
getline from fstream. Updated since there is no error without fstream header when use g++.

<example> for ifstream
#include <iostream>
#include <fstream>
#include <string>

int main()
{
  std::string line;
  int lnum = 0;
  std::ifstream ifs("sample.SWD", std::ifstream::in );

  // while( std::getline( ifs, line ))
  // {
  //   std::cout << lnum << ":" << line << std::endl;
  //   lnum++;
  // }

  std::getline( ifs, line );

  std::string hid = line.substr( 13, 6 );

  int hidi = std::stoi(hid);
  std:: cout << "hid :" << hid << "hid i: " << hidi << std::endl;

  ifs.close();
}


#include <iostream>
#include <fstream>

int main()
{
    std::ofstream ofile("test-out.txt");

    if( !ofile )
    {
        std::cerr << "cannot open output file" << std::endl;
        exit(EXIT_FAILURE);
    }

    ofile << "0: this is sample output file" << std::endl;
    ofile << "1: this is sample output file" << std::endl;
}


{buffered-io} 
In the previous example, uses getline on file stream but when use it with stdin stream, it behaves
differntly. Why? As with FILE, it is buffered.

<example>
#include <iostream>
#include <string>

using namespace std;

int main()
{
  string line;

  while( cin >> line )
    cout << "cout: " << line << endl;

  cout << "end: " << line << endl;
}

$ ./a.out 
this
cout: this
that
cout: that
this is a long line <enter>
cout: this
cout: is
cout: a
cout: long
cout: line
end: line


={============================================================================
*kt_dev_lang_003* #error and #warning

// stops compilation
#error "unknwon cpu - you need to find out the stack grows downward or upward"

// get a mesg during compilation like:
// NDS_pthread.c:43:4: warning: #warning "xxx2" 
#warning "xxx2"


={============================================================================
*kt_dev_lang_004* post and pre inc/dec

{when-different-pre-and-post-inc}
For example, there are situations where the 'value' of increase is different from the
'effect'; post increase has difference in value and effect.

when n is 5, 

x = n++;    // x has 5 which is 'value'
x = ++n;    // x has 6

In both cases, n becomes 6 which is 'effect'. So where no value is used and just use effect, pre and
post are the same as below

# when valus is not used
if( c == '\n' )
   nl++;

# when value is used
int val = 5;

fcall( ++val );   // fcall(6);
fcall( val++ );   // fcall(5);

<example> squeeze: delete all c from string s. void squeeze(char s[], int c)
From C prog language, p47. All these are example where post version is required.

// ansic version. squeeze: delete all c from string s
void squeeze(char s[], int c)
{
  int i, j;

  for( i = j = 0; s[i] != '\0'; i++ )
    if( s[i] != c )
      s[j++] = s[i];

  s[j] = '\0';
}

void squeeze( char s[], int c )
{
  char* scan;

  for( scan = s; *scan; scan++ )
  {
    // if not matches: copy s[current] = s[sacn] and increase s
    if( *scan != c )
      *s++ = *scan;
  }

  *s = *scan;
}

int main()
{
  char arr[] = "this is a program to squeeze";

  cout << arr << endl;

  squeeze( arr, 'e' );

  cout << arr << endl;
}

this is a program to squeeze
this is a program to squz

// mine
void squeeze( char s[], int c )
{
  char *run;

  for( run = s; *run; run++)
  {
    if( *run != c )
      *s++ = *run;
  }

  // this has a bug. why?
  // for( run = s; *run;)
  // {
  //   if( *run != c )
  //     *s++ = *run++;
  // }

  *s = '\0';
}


<example> strcat: concatenate t to end of s; s must be big enough 
// note lib version returns a pointer of resulting string
void strcat( char s[], char t[] )
{
  int i, j;

  i = j = 0;
  while( s[i] != '\0' )    /* find end of s */
    i++;

  while( (s[i++] = t[j++]) != '\0' )   /* copy t */
    ;
}


<exercise> squeeze: from ansic, exercise 2-4.
Write an alternate version of squeeze(s1,s2) that deletes each character in the string s1 that
matches 'any' character in the string s2 .

// one http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_4
// j: current, k:s2, i: s2 index
void squeeze2(char s[], char t[]) {
    int i, j, k;
    for (k = 0; t[k] != '\0'; k++) {
        for (i = j = 0; s[i] != '\0'; i++)      // { squeeze1()
            if (s[i] != t[k])
                s[j++] = s[i];
        s[j] = '\0';                            // }
    }
}


void squeeze_mine( char s[], char t[] )
{
  char *run, *write;

  for(; *t; t++)
  {
    for( write = run = s; *run; run++ )
    {
      if( *run != *t )
        *write++ = *run;
    }

    *write = '\0';
  }
}

int main()
{
  char mesg[] = "hello world";
  char mesg2[] = "hello world";

  printf("mesg : %s\n", mesg );
  squeeze( mesg, "l" );
  printf("mesg : %s\n", mesg );

  printf("mesg2 : %s\n", mesg2 );
  squeeze3( mesg2, "ol" );
  printf("mesg2 : %s\n", mesg2 );
}

mesg : hello world
mesg : heo word
mesg2 : hello world
mesg2 : he wrd

note. All approaches above has the worst case of O(nm). There is an approach to have O(n+m).

#include <iostream>
#include <vector>

using namespace std;

// cannot use bset[(*t-'a')] since this assumes input is all lower characters. For example, for
// space char(32) index becomes -65 (32-97) and makes a core.

void squeeze( char s[], char t[] )
{
  vector<bool> bset(256); 

  while(*t)
  {
    bset[*t] = true;
    t++;
  }

  for( char* run = s; *run; run++ )
  {
    // *run is different, that is not in the bset then copy
    if( bset[*run] == false )
      *s++ = *run;
  }

  *s = '\0';
}

mesg : hello world
mesg : heo word
mesg2 : hello world
mesg2 : he wrd


<exercise> any: from ansic, exercise 2-5. 
Write the function any(s1,s2), which returns the first location in the string s1 where any character
from the string s2 occurs, or -1 if s1 contains no characters from s2.

note: The standard library function strpbrk does the same job but returns a pointer to the location.

char *strpbrk(const char *s, const char *accept);

// one
// not good since based on the "squeeze" approach which means more work to find the first time since
// key chars can happen any order and did not stop on "first" match
int any_mine( char s[], char t[] )
{
  int ret = -1;
  int i;

  // run through t[]
  for(; *t; t++)
  {
    // run through s[]
    for( i = 0; s[i]; i++ )
    {
      // found a match
      if( s[i] == *t )
      {
        // update found index when either it's the first time or found the less than the previous
        if( ret < 0 || i < ret )
        {
          ret = i;
          break;
        }
      }
    }
  }

  return ret;
}


// two
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_5

// The pedestrian solution is Richard Heathfield's
// Here is my solution, which is very simple but quite naive and inefficient. It has a worst-case
// time complexity of O(nm) where n and m are the lengths of the two strings.

int any_online_one(char s1[], char s2[])
{
  int i;
  int j;
  int pos;

  pos = -1;

  // by having "pos == -1" checks, two for loops stops as soon as found a match and means the
  // "first" location as the problem states. But the worst still O(nm).
  //
  // <Q> is this check on pos really needed? 
  for(i = 0; pos == -1 && s1[i] != '\0'; i++)
  {
    for(j = 0; pos == -1 && s2[j] != '\0'; j++)
    {
      if(s2[j] == s1[i])
      {
        return pos = i;
      }
    }
  }

  return pos;
}

// three
// Could anything be simpler? Pilcrow 22:46, 24 August 2011 (UTC)
int any_online_two(char s1[], char s2[])
{
  int i;
  int j;

  // no need for further code when found a match
  for(i = 0; s1[i] != '\0'; i++)
  {
    for(j = 0; s2[j] != '\0'; j++)
    {
      if(s2[j] == s1[i])
      {
        return i;
      }
    }
  }

  return -1;
}

// four
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_5

Here's a much better solution, by Partha Seetala. This solution has a worst- case time complexity of
only O(n + m) which is considerably better.

It works in a very interesting way. He first defines an array with one element for each possible
character in the character set, and then takes the second string and 'ticks' the array at each
position where the second string contains the character corresponding to that position. It's then a
simple matter to loop through the first string, quitting as soon as he hits a 'ticked' position in
the array.

#include <stdio.h> /* for NULL */

int any(char *s1, char *s2)
{
  char array[256]; /* rjh comments
                    * (a) by making this char array[256] = {0}; the first loop becomes unnecessary.
                    * (b) for full ANSIness, #include <limits.h>, make the array unsigned char,
                    *     cast as required, and specify an array size of UCHAR_MAX(255) + 1.
                    * (c) the return statements' (parentheses) are not required.
                    */
  int  i;
  if (s1 == NULL) {
    if (s2 == NULL) {
      return(0);
    } else {
      return(-1);
    }
  }

  for(i = 0; i < 256; i++) {
    array[i] = 0;
  }

  while(*s2 != '\0') {
    array[*s2] = 1;
    s2++;
  }

  i = 0;
  while(s1[i] != '\0') {
    if (array[s1[i]] == 1) {
      return(i);
    }
    i++;
  }
  return(-1);
}


{compounded-inc}
From C prog lang, p95, 105:

int *ip;

*ip++;      // inc ip itself
(*ip)++;    // inc *ip, not ip


<post-inc> is higher than <pre-inc> and dereference. <pre-inc> and dereference has the same
precedence and right(right-to-left) assoc.  

// strcpy: copy t to s; pointer version 
// lib: The strcpy() and strncpy() functions return a pointer to the destination string dest
void strcpy( char *s, char *t )
{
  while( *s++ = *t++ ) 
    ;
}

Here <right-to-left> for '=' op and <post-inc> are involved. "the value of *t++ is the char that t
pointed to 'before' t was incremented; the postfix does not change t until after this char has been
fetched." This is a bit confusing.

The before and after explanation says that ++n inc n 'before' its value is used and n++ inc n
'after'. Or some says that post-inc returns the previous copy. 

For *pbeg++, <post-inc> is high than dereference(*) so it's the same as *(pbeg++). but how this
behave as *(pbeg); pbeg++; ? because it returns the previous copy. This is how Primus explains. <THIS>
is answer and this matches to asm result.

Here there are three operations; fetch, increase and dereference. post-inc do fetch and increase but
return the value before increase and dereference it.


{post-inc-overload}
MEC++06. <post-inc> can be ineffective when used on user-type; overloads. 

The prefix form of the increment operator is sometimes called - increment and fetch, while the
postfix form is often known as fetch and increment.

class UPInt {                             // "unlimited precision int"
  public:
    UPInt& operator++();                  // prefix ++
    'const' UPInt operator++(int);        // <postfix> ++
    UPInt& operator--();                  // prefix --
    const UPInt operator--(int);          // <postfix> --

    UPInt& operator+=(int);               // a += operator for UPInts and ints
    ...
};

UPInt i;

++i; // calls i.operator++();
i++; // calls i.operator++(0);             // to distinguish with '++i'
--i; // calls i.operator--();
i--; // calls i.operator--(0);

// prefix form: increment and fetch
UPInt& UPInt::operator++()
{
  *this += 1;                   // increment
  return *this;                 // fetch
}

// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
  const UPInt oldValue = *this; // fetch
  ++(*this);                    // increment
  return oldValue;              // return what was fetched
}

The only purpose of the parameter is to distinguish prefix from postfix function invocation. Many
compilers issue warnings if you fail to use named parameters in the body of the function to which
they apply, and this can be annoying. To avoid such warnings, a common strategy is to omit names for
parameters you don't plan to use; that is what is been done above.

<why-const-in-post-inc> const-return
If you have ever wondered if it makes sense to have functions return const objects, now you know:
sometimes it does, and postfix increment and decrement are examples.

If not, it allows this:

i++++;

So to make this behave like premitive type, return const. 

#include <iostream>

using namespace std;

int main()
{
  int i = 2;

  cout << i << endl;

  // x.c:11:6: error: lvalue required as increment operand
  // i++++;

  cout << i << endl;

  ++++i;

  cout << i << endl;
}

2
2
4

<should-prefer-pre-inc-when-use-none-premitive>
The prefix increment function has no such temporaries. This leads to the possibly startling
conclusion that, for efficiency reasons alone, clients of UPInt should prefer prefix increment to
postfix increment unless they really need the behavior of postfix increment.

When dealing with 'user' types, prefix increment should be used whenever possible, because it is
inherently more efficient.

The principle is that postfix increment and decrement should be implemented in terms of their prefix
counterparts. You then need only maintain the prefix versions, because the postfix versions will
automatically behave in a consistent fashion.

Again, Primus(p148) recommends prefix version than postfix because post-inc increase first and
return(yield) the previous copy and it cost extra. it may have no effect for built-in types due to
optimization but may be expensive for <iterators>. See *kt_dev_stl_007* for iter++ example.

auto pbeg = v.begin();

while(...)
   cout << *pbeg++ << endl;


{simple-post-asm}
Used gcc and de-asm for MIPS. when try simple post inc, it shows like that fetch and then inc. no
use of the previous copy. simply do j=i; and i+=i; in asm.

## post

#include <stdio.h>

int main()
{
  int i = 0, j = 0;

  j = i++;
  printf("j is %d\n", j );
  return 0;
}

# 
#
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       afbf0024        sw      ra,36(sp)
  400598:       afbe0020        sw      s8,32(sp)
  40059c:       03a0f021        move    s8,sp       # save sp to s8. s8 is sp.
  4005a0:       afc0001c        sw      zero,28(s8) # i = 0
  4005a4:       afc00018        sw      zero,24(s8) # j = 0
  4005a8:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005ac:       afc20018        sw      v0,24(s8)   # j = i
  4005b0:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005b4:       24420001        addiu   v0,v0,1     # v0(i) = i+1    // i++
  4005b8:       afc2001c        sw      v0,28(s8)   # i = v0
  4005bc:       3c020040        lui     v0,0x40
  4005c0:       24440690        addiu   a0,v0,1680
  4005c4:       8fc50018        lw      a1,24(s8)   # get j and call print
  4005c8:       0c100124        jal     400490 <printf@plt>
  4005cc:       00000000        nop
  4005d0:       00001021        move    v0,zero
  4005d4:       03c0e821        move    sp,s8
  4005d8:       8fbf0024        lw      ra,36(sp)
  4005dc:       8fbe0020        lw      s8,32(sp)
  4005e0:       27bd0028        addiu   sp,sp,40
  4005e4:       03e00008        jr      ra
  4005e8:       00000000        nop
  4005ec:       00000000        nop

## -Os. See how it's done. Just use zero to print and no increase.

00400590 <main>:
  400590:       3c040040        lui     a0,0x40
  400594:       27bdffe0        addiu   sp,sp,-32
  400598:       24840658        addiu   a0,a0,1624
  40059c:       afbf0018        sw      ra,24(sp)
  4005a0:       0c100124        jal     400490 <printf@plt>
  4005a4:       00002821        move    a1,zero
  4005a8:       8fbf0018        lw      ra,24(sp)
  4005ac:       00001021        move    v0,zero
  4005b0:       03e00008        jr      ra
  4005b4:       27bd0020        addiu   sp,sp,32  


## pointer case

#include <stdio.h>

void print_array(int arr[], int len)
{
  int *pend;

  pend = arr+len;

  while( arr != pend )
    printf("arr is : %d\n", *arr++ );
}

int main()
{
  int int_arr[] = { 1,2,3,4,5,6,7,8,9,10};

  print_array(int_arr, sizeof(int_arr)/sizeof(int));

  return 0;
}


004005c0 <print_array>:
  4005c0:       27bdffd8        addiu   sp,sp,-40
  4005c4:       afbf0024        sw      ra,36(sp)
  4005c8:       afbe0020        sw      s8,32(sp)
  4005cc:       03a0f021        move    s8,sp
  4005d0:       afc40028        sw      a0,40(s8)  # save arr
  4005d4:       afc5002c        sw      a1,44(s8)  # save len
  4005d8:       8fc2002c        lw      v0,44(s8)  # get len
  4005dc:       00021080        sll     v0,v0,0x2  # v0 = v0 << 2. 101000 (40) for 10 integers
  4005e0:       00401821        move    v1,v0      # v1 = len
  4005e4:       8fc20028        lw      v0,40(s8)  # get arr
  4005e8:       00621021        addu    v0,v1,v0   # v0 = len + arr {pend}
  4005ec:       afc20018        sw      v0,24(s8)  # save v0
  4005f0:       08100188        j       400620 <print_array+0x60>
  4005f4:       00000000        nop
{4005f8}:       8fc20028        lw      v0,40(s8)  #<2> get arr {inced-arr}
  4005fc:       8c430000        lw      v1,0(v0)   #    get *arr note. {deref} 0($x)
  400600:       8fc20028        lw      v0,40(s8)  #    get arr
  400604:       24420004        addiu   v0,v0,4    #    arr++
  400608:       afc20028        sw      v0,40(s8)  #    save arr++
  40060c:       3c020040        lui     v0,0x40    #    
  400610:       24440750        addiu   a0,v0,1872
  400614:       00602821        move    a1,v1      #    *arr
  400618:       0c10012c        jal     4004b0 <printf@plt>
  40061c:       00000000        nop
{400620}:       8fc30028        lw      v1,40(s8)  # <1> get arr {inced-arr}
  400624:       8fc20018        lw      v0,24(s8)  #   get pend {const}
  400628:       1462fff3        bne     v1,v0,4005f8 <print_array+0x38>    # !=
  40062c:       00000000        nop
  400630:       03c0e821        move    sp,s8
  400634:       8fbf0024        lw      ra,36(sp)
  400638:       8fbe0020        lw      s8,32(sp)
  40063c:       27bd0028        addiu   sp,sp,40
  400640:       03e00008        jr      ra
  400644:       00000000        nop

00400648 <main>:
  400648:       27bdffb8        addiu   sp,sp,-72
  40064c:       afbf0044        sw      ra,68(sp)
  400650:       afbe0040        sw      s8,64(sp)
  400654:       03a0f021        move    s8,sp
  400658:       3c020040        lui     v0,0x40
  40065c:       27c30018        addiu   v1,s8,24
  400660:       24420760        addiu   v0,v0,1888
  400664:       24060028        li      a2,40
  400668:       00602021        move    a0,v1
  40066c:       00402821        move    a1,v0
  400670:       0c100130        jal     4004c0 <memcpy@plt> # may be copy array into stack (24)?
  400674:       00000000        nop
  400678:       27c20018        addiu   v0,s8,24
  40067c:       00402021        move    a0,v0   # arr address
  400680:       2405000a        li      a1,10   # len
  400684:       0c100170        jal     4005c0 <print_array>
  400688:       00000000        nop
  40068c:       00001021        move    v0,zero
  400690:       03c0e821        move    sp,s8
  400694:       8fbf0044        lw      ra,68(sp)
  400698:       8fbe0040        lw      s8,64(sp)
  40069c:       27bd0048        addiu   sp,sp,72
  4006a0:       03e00008        jr      ra
  4006a4:       00000000        nop
        ...
004004c0 <memcpy@plt>:
  4004c0:       3c180040        lui     t8,0x40
  4004c4:       8f1917d8        lw      t9,6104(t8)
  4004c8:       03200008        jr      t9
  4004cc:       271817d8        addiu   t8,t8,6104

See <2> since dereference first and increase later.


={============================================================================
*kt_dev_lang_005* chaining

int v1, v2;
cin >> v1 >> v2;

cout << "Enter numbers:" << endl;

Why does it work? Because operators returns reference of 'left'-hand-operand which is cin and cout.


={============================================================================
*kt_dev_lang_006* compile error types

syntax, type mismatch, and declaration error


={============================================================================
*kt_dev_lang_007* bool type

Do not have a minimum size. In VC, is the same as int type. 

There is differece of meaning between return value from main and bool type. In return from main,

int main()
{
   return 0; // for okay. true seems to be 0?
   return ?; // any other value, error code, for not okay 
}

<gcc-case> on ubuntu linux
#include <iostream>
#include <bitset>

using std::cout;
using std::endl;

int main () {

  bool* parr = new bool(20);

  cout << "size: " << sizeof(parr) << endl;
  cout << "size: " << sizeof(*parr) << endl;
  cout << "valu: " << *parr << endl;

  return 0;
}

size: 4
size: 1
valu: 1


{non-bool-to-bool}
When assign non-bool to bool type, type 'conversion' happens and got 0 or 1 depending on the value of
non-bool. That is false for 0 and 'true' for 'any' other values other than 0.

bool b = 42;    # b is true

When bool to non-bool, has 1 or 0.


{true-and-false} {bool-to-non-bool}
The 'true' and 'false' are literals-of-type-bool. true is any non-zero but not only 1. 

if( val == true ) { ... }

If val is non-bool type, conversion to <non-bool> which is bigger type happens and this becomes 

if( val == 1 ) { ... }

This may not be what intented if meant for cases of non-zero because it runs only when val is 1.
Therefore, want the case of when val is 1 then do it directly. The direct form is:

if(val) or if(!val) 

It is usually bad idea to use the boolean literals true and false as operands 'in' a comparison. These
literals should be used 'only' to compare to an object of type 'bool'.


{not-use-in-computation}
Do not use bool and char for computation since there is conversion. For example:

bool b1 = true;
bool b2 = -b1;

b2 is true since b1 promoted to 1, negates to -1, and convert back to bool but it is not a zero
hence true. <Q> why promoted? due to negate operator?


={============================================================================
*kt_dev_lang_008* data type, char type

{data-type} From ansic:

char
int      an integer, typically reflecting the natural size of integers on the host machine
float
double

short, long, signed and unsigned 'qualifiers'. short is 'at-least' 16 bits, long 'at-least' 32 bits
and int either 16 or 32 bits. Each compiler is free to choose appropriate sizes for its own
hardware.

note:
The char is not singed char. there are char, signed, unsigned types because whether char is signed
or unsigned 'depends' on compiler. From ansic, "whether plain chars are signed or unsigned is
machine-dependent". So recommendation is that 'not' use char but use signed or unsigned.

The standard header <limits.h> and <float.h> contain symbolic constants for all of these sizes along
with other properties of the machine and compiler.


From C++: 2.1.1 Arithmetic Types

Type        Meaning           Minimum Size
------------------------------------------
bool        boolean           NA
short       short integer     16 bits
int         integer           16 bits
long        long integer      32 bits 
long long   long integer      64 bits           // from C++11

<exercise>
The ansic, page 36, exercise 2-1. Write a program to determine the range of char, short, int, and
long variables, both signed and unsigned, by printing appropriate values from standard headers and
by direct computation. Harder if you compute them: determine the range of the various floating-point
types.

// based on *kt_dev_prob_010* for a macro to get max value of a type. 

#include <limits.h>

#define MY_ULONG_MAX (~(unsigned long)0) // see difference in *kt_dev_prob_010* 

int main(int argc, char* argv[])
{
  printf("ulong max from limits: %luL\n", ULONG_MAX );
  printf("ulong max from calc: %luL\n", MY_ULONG_MAX );
}

<use-headers>
From http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_1

#include <stdio.h>
#include <limits.h>

int main(void)
{
  printf("\nBits of type char: %d\n\n", CHAR_BIT);                     /* IV */

  printf("Maximum numeric value of type char: %d\n", CHAR_MAX);        /* IV */
  printf("Minimum numeric value of type char: %d\n\n", CHAR_MIN);      /* IV */

  printf("Maximum value of type signed char: %d\n", SCHAR_MAX);        /* IV */
  printf("Minimum value of type signed char: %d\n\n", SCHAR_MIN);      /* IV */

  printf("Maximum value of type unsigned char: %u\n\n", (unsigned) UCHAR_MAX);    /* SF */  /* IV */
  
  printf("Maximum value of type short: %d\n", SHRT_MAX);               /* IV */
  printf("Minimum value of type short: %d\n\n", SHRT_MIN);             /* IV */

  printf("Maximum value of type unsigned short: %u\n\n", (unsigned) USHRT_MAX);   /* SF */  /* IV */


  printf("Maximum value of type int: %d\n", INT_MAX);                  /* IV */
  printf("Minimum value of type int: %d\n\n", INT_MIN);                /* IV */

  printf("Maximum value of type unsigned int: %u\n\n", UINT_MAX);      /* RB */   /* IV */

  printf("Maximum value of type long: %ld\n", LONG_MAX);               /* RB */   /* IV */
  printf("Minimum value of type long: %ld\n\n", LONG_MIN);             /* RB */   /* IV */

  printf("Maximum value of type unsigned long: %lu\n\n", ULONG_MAX);   /* RB */   /* IV */

  return 0;
}

<use-calculation> use variables for each type
Integer solution. Floats to follow. I know 'long long' is not in K&R. Pilcrow 12:00, 31 July 2011
(UTC)

/* calculate the ranges of various types */
#include <stdio.h>
#include <limits.h>

int main(void)
{
  /* integer types */
  unsigned char c;
  unsigned short s;
  unsigned int i;
  unsigned long l;
  unsigned long long ll;

  putchar('\n');
  printf("VALUE RANGES FOR INTEGER TYPES\nUPPERCASE comes from <limits.h>\n"
      "lowercase is calculated.\n\n");

  /* char */
  c = ~0;     // note: this is Uxxx_MAX
  c >>= 1;    // note: this is xxx_MAX. why this work? since it's 'unsigned'
  printf("signed char:   %4d,           %4d\n",-c-1,c);
  printf("SCHAR_MIN:     %4d, SCHAR_MAX %4d\n",SCHAR_MIN,SCHAR_MAX);
  printf("unsigned char: %4u,           %4u\n",0,c*2+1);
  printf("UCHAR_MAX:                     %4u\n",UCHAR_MAX);
  putchar('\n');

  // kt@kt-ub-vb:~/work$ ./a.out 
  // 
  // VALUE RANGES FOR INTEGER TYPES
  // UPPERCASE comes from <limits.h>
  // lowercase is calculated.
  // 
  // signed char:   -128,            127
  // SCHAR_MIN:     -128, SCHAR_MAX  127
  // unsigned char:    0,            255
  // UCHAR_MAX:                      255

  /* short */
  s = ~0;
  s >>= 1;
  printf("signed short:   %6d,           %6d\n",-s-1,s);
  printf("SHRT_MIN:       %6d, SHRT_MAX: %6d\n",SHRT_MIN,SHRT_MAX);
  printf("unsigned short: %6u,           %6u\n",0,s*2+1);
  printf("USHRT_MAX:                        %6u\n",USHRT_MAX);
  putchar('\n');

  /* int */
  i = ~0;
  i >>= 1;
  printf("signed int:    %11d,          %11d\n",-i-1,i);
  printf("INT_MIN:       %11d, INT_MAX: %11d\n",INT_MIN, INT_MAX);
  printf("unsigned int:  %11u,          %11u\n",0,i*2+1);
  printf("UINT_MAX:                            %11u\n",UINT_MAX);
  putchar('\n');

  /* long */
  l = ~0;
  l >>= 1;
  printf("signed long:   %11ld,           %11ld\n",-l-1,l);
  printf("LONG_MIN:      %11ld, LONG_MAX: %11ld\n",LONG_MIN, LONG_MAX);
  printf("unsigned long: %11lu,           %11lu\n",0l,l*2+1);
  printf("ULONG_MAX:                            %11lu\n", ULONG_MAX);
  putchar('\n');


  /* long long */
  ll = ~0;
  ll >>= 1;
  printf("signed long long:   %20lld,            %20lld\n",-ll-1,ll);
  printf("LLONG_MIN:          %20lld, LLONG_MAX: %20lld\n",LLONG_MIN, LLONG_MAX);
  printf("unsigned long long: %20llu,            %20llu\n",0ll,ll*2+1);
  printf("ULLONG_MAX:                                          %20llu\n", ULLONG_MAX);

  return 0;
}


<Q>
Interesting thing found is that when use calculation to get MIN and MAX, cout prints out MIN without
minus sign but printf do. When use real value as limits.h do, cout prints out minus sign.

#include <iostream>
#include <climits>
#include <cstdio>

using namespace std;

#define MUINT_MAX (~(unsigned)0)

// #define MINT_MAX ((unsigned)~0>>1)
// #define MINT_MIN (-MINT_MAX-1)

// taken from limits.h
#define MINT_MIN  (-MINT_MAX - 1)
#define MINT_MAX  2147483647

int main()
{
  cout << "uint: " << 0 << " - " << UINT_MAX << endl;
  cout << " int: " << INT_MIN << " - " << INT_MAX << endl;

  cout << "uint: " << 0 << " ~ " << MUINT_MAX << endl;
  cout << " int: " << -MINT_MAX-1 << " ~ " << MINT_MAX << endl;

  printf("signed int : %4d ~ %4d \n", MINT_MIN, MINT_MAX );
}

uint: 0 - 4294967295
 int: -2147483648 - 2147483647
uint: 0 ~ 4294967295
 int: -2147483648 ~ 2147483647            // note:
signed int : -2147483648 ~ 2147483647 


={============================================================================
*kt_dev_lang_009* implicit conversion (built-in conversion)

{common-type}
When an operator has operands of 'different' types, they are converted to a 'widest' "common-type"
to preserve precision. See *kt_dev_cpp_005* for class-type conversion.

Primers p159. Happens when used in expression, func call and func matching

int ival = 3.541 + 3;

Here, two conversion.
1. 3 becomes double since double is common-type.
2. The result of addition becomes int since in assignment, the left type dominates.

cases:

1. integral promotion. promote smaller types to int. when mixed, promote to a bigger type.
2. In conditions, nonbool are converted to bool. However, not always possible. see below.
3. In assignment or initialization, converted to the left or the type of variable. Can be 'truncated'.
4. common-type for mixed types.
4. convert between signed and unsigned.


{truncated-and-undefined}
If the conversion is from a floating-point type to an integer type, the value is truncated; the
fractional part is removed.

signed char sc = 256;   // out-of-range. -128...127. undefined value
int ival = 3.541 + 3;


{integral-promotion} known as standard conversion
The integral promotion converts the small types(bool, char, short, unsigned short) to a larger
type(int) if all possible values of that type fit in an int. Otherwise, to unsigned int. 


{when-type-and-signess-different}
Depends on the relative size of the 'integral' type on the machine. When signess is the same,
converted to the bigger type. When signess differ, two cases:

1. If unsigned >= signed then, the signed is converted to unsigned.
2. If unsigned < signed then: 
if all values of unsigned fits in the larger type, unsigned operand is conveted to signed.
if the values don't fit, the signed operand is converted to unsigned. 


<signed-vs-unsigned> <careful> when type is same
unsigned char uc = -1;  // out-of-range. 255. <wrap-around>


Recommends that don't mix between them:

1.
unsigned ui = 10; int i = -42;
cout << ui + i << endl;

2.
unsigned int u1 = 42, u2 = 10;
cout << u2 - u1 << endl;

These two cases shows the same result. 4294967264. why? because converted to unsigned.

3. infinite loop due to wrap around
for( unsigned u = 10; u >= 0; --u )
   cout << n << endl;

Causes 'infinite' loop because u = -1 and means big number.

4. infinite loop due to implicit conversion

unsigned int begi;

for( int i = endi-1; i >= begi; --i )
   cout << line[i];

When begi is 0 and "i >= begi" cause implicit conversion to unsigned since it is comparison between
signed and unsigned. note: this is a problem of string-npos.


{bool-conversion} equal-misspell
<1>
The fact that we can use assignment in a condition can have surprising effects:

if (i = j)

<true-means>
The condition like this which assigns the value of j to i and then tests the result of the
assignment. If j is nonzero, the condition will be true. This is what "true" means in the 'test'
part of if, while, for, etc and 'true' means 'nonzero' (all other value than zero). 

The author of this code almost surely intended to test whether i and j have the same value:

if (i == j)

Bugs of this sort are notoriously difficult to find. Some, but not all, compilers are kind enough to
warn about code such as this example.

<2> 
auto loc = wordmap.find( sought );

if( loc = wordmap.end() )  // meant if( loc == wordmap.end() )

GCC error is:

tquery.cpp:63: error: could not convert '(loc <unknown operator> ((const
std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>,
std::allocator<char> >, std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>,
std::allocator<long unsigned int> > > > >&)((const std::_Rb_tree_const_iterator<std::pair<const
std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>, std::allocator<long
unsigned int> > > > >*)(&((const TextQuery*)this)->TextQuery::wordmap.std::map<_Key, _Tp, _Compare,
_Alloc>::end [with _Key = std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
_Tp = std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>, std::allocator<long
unsigned int> > >, _Compare = std::less<std::basic_string<char, std::char_traits<char>,
std::allocator<char> > >, _Alloc = std::allocator<std::pair<const std::basic_string<char,
std::char_traits<char>, std::allocator<char> >, std::shared_ptr<std::set<long unsigned int,
std::less<long unsigned int>, std::allocator<long unsigned int> > > > >]()))))' to 'bool'

This happens when tries to covert loc iterator to bool. If it were ==, then operator== would return
bool type.

<3>
Meant to be == and this if is always true.

bool QueueFull(Queue* queue)
{
   if( queue->count = MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}


{integer-division}
From ansic 1.2., this is a program to implement a formula "C = (5/9)(F-32)" to print a table of
Fahrenheit and Celsius.

<1> print Fahrenheit-Celsius table
int main(int argc, char* argv[])
{
  int fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step = 20;

  fahr = lower;
  while( fahr <= upper ) 
  {
    celsius = 5 * (fahr-32) / 9;
    printf("%d\t%d\n", fahr, celsius );
    fahr = fahr + step;
  }
}

Why "celsius = 5 * (fahr-32) / 9;" but not "celsius = 5/9 * (fahr-32);"? Since integer division
truncates: any fractional part is discarded so 5/9 would be trancated to zero.

0     -17
20    -6
40    4
60    15
80    26
100   37
120   48
140   60
160   71
180   82
200   93
220   104
240   115
260   126
280   137
300   148

0     0
20    0
40    0
60    0
80    0
100   0
120   0
140   0
160   0
180   0
200   0
220   0
240   0
260   0
280   0
300   0

<2> print Fahrenheit-Celsius table: floating-point version to be accurate
int main(int argc, char* argv[])
{
  float fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step = 20;

  fahr = lower;
  while( fahr <= upper ) 
  {
    // celsius = 5/9 * (fahr-32);
    // celsius = 5/9 * (fahr-32.0);
    celsius = 5.0/9.0 * (fahr-32.0);
    printf("%3.0f %6.1f\n", fahr, celsius );
    fahr = fahr + step;
  }
}

1. "5/9" is still integer division.
  0   -0.0
 20   -0.0
 40    0.0
 60    0.0
 80    0.0
100    0.0
120    0.0

If an arithmetic operator has integer operands, an integer operation is performed. If an arithmetic
operator has on floating-point operand and one integer operand, howerver, the integer will be
converted to floating point before the operation is done. 

while(fhar <= upper) and fahr-32 would be converted to floating point. Nevertheless, writing
floating-point constants with explicit decimal point 'emphasizes' their floating-point nature for
human readers.

<example-from-cpp>
The division truncate the remainder and modulus(%) operator.

// plus to grade ending in 8 or 9 and minus to grade ending in 0, 1, or 2.
const vector<string> scores = { "F", "D", "C", "B", "A", "A++" };

string lettergrade;

if( grade < 60 )
  lettergrade = score[0];
else
{
  lettergrade = score[ (grade-50)/10 ];

  if( grade % 10 > 7 )
    lettergrade += '+';
  else if( grade%10 < 3 )
    lettergrade += '-';
}


{char-to-int} <example> From ansic, p43.

int atoi(char s[])
{
  int n, i;

  for(n = 0, i = 0; s[i] >= '0' && s[i] <= '9'; i++)
    n = n*10 + (s[i]-'0'); // here s[i]-'0'

  return n;
}

// ASCII only and upper case comes first and lower case comes later in the table. Why ASCII only?
int lower(int c)
{
  if( c => 'A' && c <= 'Z' )
    return c + 'a' - 'A';     // c -'A' + 'a' or c + 'A' - 'a' ?
  else
    return c;
}


{problem}
Amazon interview. Explain a problem to print money value to string such as ONE HUNDRED AND FOURTY
FIVE PENCE for $100.45. This simplifies handling of fractional part and can get it by x100. The rest
is string process.

int main()
{
  float fval = 3.14;
  int decimal = fval;
  int fraction = (fval - decimal)*100;

  cout << "float   : " << fval << endl;
  cout << "decimal : " << decimal << endl;
  cout << "fraction: " << fraction << endl;
}


={============================================================================
*kt_dev_lang_010* incomplete type

{text-query-example}
Primus p484. The output for query word 'element' is:

element occurs 112 times
	(line 36) A set element contains only a key;
	(line 158) operator creates a new element
	...

Requirements are that show line number, ascending order, no duplicates, and line text which contains
the word. Also support multi pass until user quit.

<more-abstract-solution>
Used class instead of using set, map, and vector directly. [DN] How to design what this query func
return without cost of copying? Yes, shared_ptr.

TextQuery:                         shared:dyn creted   QueryResult:
 shared_ptr<vector> : file           vector              shared_ptr<vector>
  line 0
  line 1
  line 2
  ...
 
 map : < word, ptr-to-set>
  word x, -> set : line nos         sets                shared_ptr
  word y, -> set : line nos


class QueryResult;	// forward declaration

class TextQuery {
  public:
    using line_no = std::vector<std::string>::size_type; // [type-member]

    TextQuery( std::ifstream& );
    QueryResult query( const std::string& ) const;

  private:
    std::shared_ptr<std::vector<std::string>> file; // input file
    std::map<std::string, std::shared_ptr< std::set< line_no >>> wm;
};

// TextQuery member definitions

TextQuery::TextQuery( ifstream& is ) : file( new vector<string>) // new vector
{
  string text;

  while( getline( is, text )) {     // for each line. std::getline
    file->push_back(text);          // save line
    int n = file->size() -1;        // get line num. -1 to make line num the same as vector index

    istringstream line(text);
    string word;

    while( line >> word ) {                  // for each word of a line
      // see that lines is reference
      auto& lines = wm[word];                // add new entry if word is not in wm
      // value-init and lines will be null
      if( !lines )                           // lines is shared_ptr
        lines.reset( new set< line_no > );   // new set

      lines->insert(n);                      // save line num which shown this word
      // word occurs more than once in the same line, do nothing since it is a set
    }
  }
}

Think what should return if the given string is not found because there is no set for this? Used
a empty set which is local static, function-static.

QueryResult TextQuery::query( const string& sought ) const
{
  static shared_ptr< set< line_no >> nodata( new set< line_no > );

  auto loc = wordmap.find( sought ); // [Quiz] why find instead of subscript?

  if( loc == wordmap.end() )
    return QueryResult( sought, nodata, file );
  else
    return QueryResult( sought, loc->second, file );		
}

class QueryResult {
  friend std::ostream& print( std::ostream&, const QueryResult& );

  public:
  // this is missed in the book.
  using line_no = std::vector<std::string>::size_type; // [type-member]

  QueryResult( std::string s,
      std::shared_ptr< std::set<line_no>> p,
      std::shared_ptr< std::vector< std::string >> f ): sought(s), lines(p), file(f) {}
  private:
  std::string sought;
  std::shared_ptr< std::set<line_no>> lines;
  std::shared_ptr< std::vector< std::string >> file;
};


{BP} When design a class, can be helpful to write programs using the class before implementing the
members. That way, can see whether the class has the operation we need. WHAT OPERATION WE NEED hels
us see WHAT DATA STRUCTURE we will need.

void runQueries(ifstream& infile)
{
  TextQuery tq(infile);

  while(true) {
    cout << "enter the word to look for, or q to quit: ";
    string s;

    // stop if hit eof or q
    if( !(cin >> s) || s == "q" ) break;

    print( cout, tq.query(s)) << endl;
  }
}

ostream &print( ostream& os, const QueryResult& qr)
{
  os << qr.sought << " occurs " << qr.lines->size() << " " << make_plural( qr.lines->size(),
      "time", "s") << endl;

  // when *qr.lines is empty, the loop will not be executed.
  for( auto num : *qr.lines )
    os << "\t(line " << num + 1 << ") " << *(qr.file->begin() + num) << endl;

  return os;
}

Got following errors:

tquery.cpp: In member function 'QueryResult TextQuery::query(const std::string&) const':
tquery.cpp:58: error: return type 'struct QueryResult' is incomplete ~
tquery.cpp:65: error: invalid use of incomplete type 'struct QueryResult' 
tquery.cpp:12: error: forward declaration of 'struct QueryResult'
tquery.cpp:67: error: invalid use of incomplete type 'struct QueryResult'
tquery.cpp:12: error: forward declaration of 'struct QueryResult'

When move query func after class QueryResult then these errors go away. Why?


{extented-text-query-example}
How to support these queries? ~(str), str, (str|str), (str&str), (str&str|str) which use normal C++
precedence rules.

<OOP-solution>
Can use TextQuery? No. To see why, consider a Not query and we would have to able to find the word
for which the Not query was searching. There is no such word. Instead a Not query has a query whose
value it negates. Similarly, And and Or query have two queries whose results it combines. This
suggests that we model our different kinds of queries as independent classes that share a common
base class. The solution is to have four classes which has the same interface and use ABC.

<DN-ABC>
o These four query types are not related to one another by inheritance; not related in vertically
and they are conceptually siblings and shares the same interface. This suggest that will need to
define ABC to represent that interface.

o The AndQuery and OrQuery share one property that the other classes do not. Each has two operands.
To model this, define another ABC to represent queries with two operands.

<DN-interface>
o We need to able to build queries. The simplest way is to write C++ expressions to create the
compounded queries:

   Query q = Query("fiery") & Query("bird") | Query("wind");

This suggests that user code won't use the inherited class directly. Instead, will define an
interface class named Query which hide the hierarchy and has the same operations as Query_base. It
will have three overloaded operators and ctor.

   - & operator will [create] a Query bound to a new AndQuery.
   - | operator will [create] a Query bound to a new OrQuery.
   - ~ operator will [create] a Query bound to a new NotQuery.
   - Query ctor that takes a string will create a Query bound to a new WordQuery.

<DN-SP>
o In each of these classes, the operand(s) can be an object of any of the concrete classes derived
from Query_base: NotQuery can be applied to an AndQuery. To allow this flexibility i.e., compound
query, the operands must be stored as pointers to Query_base so that can bind the pointer to
whichever concrete class we need. However, rather than storing a Query_base pointer, will themselves
use a Query object as [user] code is simplified by using the interface. [KT] This is why BinaryQuery
has Query members.

<DN-no-public-interface-in-implementation>
There is no public interface in Query_base hierarchy.

<creation>
So objects created by the expression are:

   Query q = Query("fiery") & Query("bird") | Query("wind");
             - new WQ         - new WQ                    // temp Queries
                       - new ANDQ             - new WQ    // temp Queries, copied Queries and copyed SPs
                                           - new ORQ
                                           
                                           Query q        // All temp Queries will be destoried

   q = Query      OrQuery        AndQuery          WordQuery
         [ ] ->   [ ]      ->    [ ]      ->       [fiery] 
                                                   WordQuery
                                 [ ]      ->       [bird]

                  [ ]      ->    WordQuery
                                 [wind]

Once the [tree-of-objects] is built up, evaluating(or generating the representation of) a query is
basically a process of following these links, asking each object to evaluate itself. Call eval on q
which is the root of the tree, that call asks the OrQuery to which q points to eval itself.
Evaluating this OrQuery calls eval on its two operands- on the AndQuery and the WordQuery that looks
for the word bind. Evaluating the AndQuery evaluates its two WordQuerys, generating the results for
the words fiery and bird.

<class-hierarchy>
Inheritance hierarchy is:                                    

User     Query class             Query Base
         - interface class       - ABC
         - hide QB from user        |           |           | 
                                 WordQuery   NotQuery    BinaryQuery
                                                         - ABC
                                                            |           |
                                                         AndQuery    ORQuery

Q        NOTQ     AND or ORQ
-sp<QB>  - Q      - Q lhs, rls

// private ctor which prevent a user from creating derived class directly and due to this, make
// operator overloads friend to use ctor.
//
class Query {
  friend Query operator~( const Query& );
  friend Query operator|( const Query&, const Query& );
  friend Query operator&( const Query&, const Query& );

  public:
    Query( const std::string& );

    // [interface] for Query_base
    QueryResult eval(const TextQuery &t) const { return q->eval(t); }
    std::string rep() const { return q->rep(); }

  private:
    Query( std::shared_ptr<Query_base> query ): q(query) {}

    std::shared_ptr<Query_base> q;
};

inline Query::Query( const std::string &s ): q(new WordQuery(s)) {}

// ABC and no public interface since do not intend users or the derived class to use it directly.
// Query friend since it use Query_base's virtual call. See protected dtor since it is used
// implicitly by the dtor in the derived class.
//
class Query_base {
  friend class Query;

  protected:
    using line_no = TextQuery::line_no;
    virtual ~Query_base() = default;

  private:  // [interface]
    virtual QueryResult eval( const TextQuery& ) const = 0;
    virtual std::string rep() const = 0;
};

class WordQuery: public Query_base {
  friend class Query;

  WordQuery( const std::string &s ): query_word(s) {}

  QueryResult eval( const TextQuery &t ) const { return t.query(query_word); }
  std::string rep() const { return query_word; }
  std::string query_word;
};

<not>
class NotQuery: public Query_base {
  // make a function friend
  friend Query operator~(const Query &);

  NotQuery( const Query &q ): query(q) {}

  // concrete class
  QueryResult eval( const TextQuery &t ) const;
  
  // [DN] This ultimately makes a virtual call to rep because query.rep() is nonvirtual call but
  // Query::rep in turn calls q->rep, which is virtual call through its Query_base pointer. However,
  // see that there is NO public interface in implementation class hierarchy and virtual funcs does
  // work for this case even if this is private.
  //
  // Query::rep()
  //  -> q->rep()
  //     ORQ::rep()
  //        -> lhs.rep(); Query::rep()
  //                       -> q->rep()
  //                          ANDQ::rep()
  //                             -> lhs.rep(); Query::rep()
  //                                            -> q->rep()
  //                                               WQ::rep()
  //
  std::string rep() const { return "~(" + query.rep() + ")"; }

  Query query; // [DN]
};

o [DN] The return Query type and [implicitly] uses Query ctor that takes the shared_ptr so this is
equivalent to:

o Here used Query( std::shared_ptr<Query_base> query )

shared_ptr<Query_base> tmp(new NotQuery(expr));
return Query(tmp);

inline Query operator~(const Query &operand)
{ return std::shared_ptr<Query_base>( new NotQuery(operand)); }

<binary-query>
// ABC and do not define eval().
//
class BinaryQuery : public Query_base {
  protected:
    BinaryQuery( const Query &l, const Query &r, std::string s ):
      lhs(l), rhs(r), opSym(s) {}

    // [DN] This ultimately makes a virtual call to rep.
    std::string rep() const 
      { return "(" + lhs.rep() + " " + opSym + " " + rhs.rep() + ")"; }

    Query lhs, rhs;  // [DN]
    std::string opSym;
};

<and>
class AndQuery : public BinaryQuery {
  friend Query operator&( const Query&, const Query& );     // to use ctor

  AndQuery( const Query &left, const Query &right ):
    BinaryQuery( left, right, "&") {}

  QueryResult eval(const TextQuery&) const;
};

inline Query operator&( const Query &lhs, const Query &rhs )
{ return std::shared_ptr<Query_base>( new AndQuery(lhs, rhs) ); }

<or>
class OrQuery : public BinaryQuery {
  friend Query operator|( const Query&, const Query& );     // to use ctor

  OrQuery( const Query &left, const Query &right ):
    BinaryQuery( left, right, "|") {}

  QueryResult eval(const TextQuery&) const;
};

inline Query operator|( const Query &lhs, const Query &rhs )
{ return std::shared_ptr<Query_base>( new OrQuery(lhs, rhs) ); }


{class-definition} {forward-declaration}
Primers p279.

struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;

The semicolon marks the end of the (usually empty) list of declarators. It is a common mistake among
new programmers to forget the semicolon at the end of a class definition.

This declaration, sometimes referred to as a <forward-declaration>, introduces the name Screen into
the program and indicates that Screen refers to a class type. After a declaration and 'before' a
definition is seen, the type Screen is an <incomplete-type>-it is known that Screen is a class type
but not known what members that type contains.

<limited-use>
We can use an incomplete type in only limited ways: We can define pointers or references to such
types, and we can declare (but not define) functions that use an incomplete type as a parameter or
return type.

A class must be defined-not just declared-before we can write code that creates objects of that
type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the
class must be defined before a reference or pointer is used to access a member of the type. After
all, if the class has not been defined, the compiler cannot know what members the class has.

In sum, two problems when use incomplete type, that is a compiler don't know the class(type) layout:

o cannot create object
o cannot defines funcs using return or params of incomplete type.

In this example, cannot create temp return object.


{missing-declaration}
For this cases, similar errors happens:

/src/main.c: In function '_terminate':
/src/main.c:91:8: error: dereferencing pointer to incomplete type
/src/main.c:92:21: error: dereferencing pointer to incomplete type


={============================================================================
*kt_dev_lang_011* literal type

To specify the type of a literal. Primus p40.

{char-and-char-string-literals}

<prefix>    meaning          type
u           unicode 16 char  char16_t
U           unicode 32 char  char32_t
L           wide char        wchar_t
u8          utf-8            char

L'a'
u8"hi!"


{integer-literals}

<suffix>    minimum type
u/U         unsigned
l/L         long
ll/LL       long long

42ULL       // unsigned long long


{floating-literals}

<suffix>    type
f/F         unsigned
l/L         long double

3.14159L    // long double


={============================================================================
*kt_dev_lang_012* pointer and array

{pointer}
A pointer is a 'variable' that contains the address of a variable. In other words, pointer type
variable and variable is a label of address. The type defines the size of variable. For pointer,
defines two things; this is a pointer and the type that this pointer points to. The unary
operator * is the indirection or dereferencing operator; when applied pointer, it accesses the
'object' that pointer points to. The declaration of the pointer ip is intended as a mnemonic:

int *ip;

It says that the expression '*ip' is an 'int'. *ip is used as an 'ordinary' int variable. note the
implication that a pointer is constrained to point to a particular kind of object: every pointer
points to a specific 'type'. 

<void-pointer> 
There is one exception: a pointer to void is used to hold any 'type' of pointer but 'cannot' be
dereferenced itself.

++*ip;
(*ip)++;

The parentheses are necessary in the second example. note that ANSI C explains "without them, the
expression would increase ip instead of what it points to, because unary operators like * and ++
associate right to left." However, in C++, postfix ++ has higher precedence. The both has the same
result. This effect having a pointer increased used in strcpy example. 

Also, any pointer can be cast to void* and back again without loss of information. See qsort example.

<push-and-pop-idiom>
*p++ = val;    // push val onto stack
val = *--p;    // pop top of stack into val

Here *--p decrements p before fetching the character that p points to since right-to-left applies.

<read-and-write>
note that variable is a readable lable of address whether or not a pointer, so read or write to it
means to get its content but not the address. 

variable = xxx;   // this is an write operation to a memory.
xxx = variable;   // this is an read operation(fetch) from a memory.


{call-by-value-and-reference}
C passes arguments to function by value.

swap( a, b );

void swap(int x, int y)
{
  int temp;

  temp = x;
  x = y;
  y = temp;
}

swap( &a, &b );

void swap(int *x, int *y)
{
  int temp;

  temp = *x;
  *x = *y;
  *y = temp;
}

TODO: C++ reference example


{pointer-and-array}
An array is a data structure that is similar to the library vector type but offers different
trade-off. Like vector, is a container of unnamed object of a 'single' type. Unlike vector, has
'fixed' size. That run-time advantage comes at the cost of lost flexibility.

In C++ pointers and arrays are closely interwined. The elements in an array are objects. When
subscript an array, the result is the object at that location in the array. Array has special
property. the compiler automatically substitute array(name) with a pointer to the first element.

The ansic said the name of array is a 'synonym' for the location of the initial element.

string name[] = {"one", "two", "three"};
string* p = &name[0];   // same
string* p = name;       // same

This means that operations on array are really operations on pointers.

<indexing> from-ansic, indexing and pointer arithmetic
In short, an array-and-index expression is equivalent to one written as a pointer and offset. The
pointer version will in general be 'faster'. There is one difference between an array name and a
pointer that must be kept in mind. A pointer is variable but array name is 'not' a variable. However
when pass an array to a function call as a argument? This is a variable such as strlen(char *);

a[i] can also be written as *(a+i)

int a[10]; int *pa;

pa = a; pa++;     // okay
a = pa; a++;      // yako since array name is not variable

- a[n] has [0, n-1]. so a+n points to the off-the-end.
- q-p+1 means the number of elements from p to q 'inclusive' when q > p and p and q are pointers
within the array. q-p is the size when p is &arr[0] and q is &arr[off-the-end]
- a length of a has +1 than a index. Run loop from [0, n-1] or [1, n]

// index
char array[length];  // 10

[0,9] // 10 loops
for( i = 0; i < length; i++ )
   array[i];

[1,10] // 10 loops when not need index
while( length-- > 0 )
  *ptr++;

<exercise> strlen: ansic, p103. excluding NULL.
int strlen( char *s )
{
  char *p = s;

  while( *p != '\0' )
    p++;

  return p-s;  // this means size-1 when s[size]
}

<defining-array>
An array declarator has the form a[d], where a is the name and d is the dimension. note that the
number of elements in an array is 'part' of the array's 'type' so must be known at compile time.
That means the dimension is constant expression.

<array-subscript>
For library types such as string and vector, subscript type is size_type which is 'unsigned'. So if
use negative value, then will be 'converted' to the unsigned. However, for built-in array, it is not
so can have negative subscript. ansic p100.

int *p = &ia[2];
int j = p[1];
int k = p[-2];

<array-init>
int a3[5] = { 0, 1, 2 };   // { 0, 1, 2, 0, 0 } since value-init the rest
int a4[11] = {};           // { 0,...0 } since value-init all

<complicated-array-declaration>
int arr[6];

arr     0        5
[ ] -> [ ][ ]...[ ]

Here arr, &arr[0], &arr have the same address and arr type is int(*arr)[6]. note that this is
similar to function pointer definition. The size is part of type, that is, int(&)[10] in the
following case. The parentheses are needed and read from inside to outside. 

int (&arrRef) [ 10 ] = arr;   // refers to an array of ten ints

the reference param is bound to the corresponding arg

void print( int (&arr) [ 10 ])
{
  for( auto elem : arr )
    cout << elem << endl;
}

This could also means the first low of multidimensional array and the both are the same.

void print( int (*matrix)[10], int rowsize );
void print( int matrix[][10], int rowsize );

<complicated-array-type>
As seen above, array arr type is int(*)[6]. Likewise, state_list is **.

typedef struct fsm_instance {
   char*              name;
   fsm_state_t**      state_list;
   fsm_event_t*       event_list;
   fsm_state_t*       current_state;
   fsm_state_t*       previous_state;
} fsm_instance_t;

static Fsm::fsm_state_t* bootStateList[] = {
  &stateClosed,
  ...
  FSM_INVALID_STATE
};

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

fsm_instance fsm = { "...", &bootStateList, &bootEventList, ... };

<pointers-to-pointers>
From ansic, p107. A stripped-down sort utility. Can use shell and qsort but need a data
representation that will cope efficiently and conveniently with variable-length text lines. The
array of pointers elimiates the twin problems of complicated storage management and high overhead of
moving elements. This is similar to difference between contiguous and linked list of sort
algorithms. 

[ ] -> defghi         [ ]  +->      defghi      
[ ] -> jklmnopqrst    [ ] -+ +->    jklmnopqrst 
[ ] -> abc            [ ] ---+   -> abc         

<code>
#include <stdio.h>
#include <string.h>

#define MAXLINES 5000         // max #lines to be sorted

// char lineptr[MAXLINES];
// char *lineptr[MAXLINES];
// char *lineptr;
//
// Here "char *lineptr[MAXLINES]" means that 1) is a pointer, 2) an array, and 3) has char * type
// element.
char *lineptr[MAXLINES];

int readlines( char *lineptr[], int nlines );
int writelines( char *lineptr[], int nlines );

void qsort( char *lineptr, int left, int right );

main()
{
  int nlines;     // number of input line read

  if( (nlines = readlines( lineptr, MAXLINES )) >= 0 )
  {
    qsort( lineptr, 0, nlines-1 );     // see [0, nlines-1]
    writelines( lineptr, nlines );
    return 0;
  }
  else
  {
    printf("error: input too big to sort\n");
    return 1;
  }
}

#define MAXLEN 1000     // max length of any input line

int getline( char *, int );
char *alloc(int);

// read inupt lines
int readlines( char *lineptr[], int maxlines )
{
  int len, nlines;
  char *p, line[MAXLEN];

  nlines = 0;

  while( (len = getline( line, MAXLEN )) > 0 )
    if( nlines >= maxlines || (p = alloc(len)) == NULL )
      return -1;
    else
    {
      line[len-1] = '\0';     // delete newline since getline includes a newline.
      strcpy( p, line );
      lineptr[nlines++] = p;  // this makes [0, nlines-1]
    }

  return nlines;
}

void writelines( char *lineptr[], int nlines )
{
  int i;

  for( i = 0; i < nlines; i++ )
    printf("%s\n", lineptr[i] );
}

// or can be written as
void writelines( char *lineptr[], int nlines )
{
  while( nlines-- > 0 )
    printf("%s\n", *lineptr++ );
}

There should be minor changes to qsort and swap.

void swap( char *v[], int i, int j )
{
  char *temp;     // <diff>

  temp = v[i], v[i] = v[j], v[j] = temp;
}

void qsort( char *v[], int left, int right )
{
  int i, last;

  if( left >= right )
    return;

  swap( v, left, (left+right)/2 );

  last = left;

  for( i = left+1; i <= right; i++ )
   if( strcmp( v[i], v[left] ) < 0 )   // <diff>
     swap( v, ++last, i );

  swap( v, left, last );

  qsort( v, left, last-1 );
  qsort( v, last+1, right );
}


<pointers-and-malloc>
How to use malloc to have pointer array?

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main( int argc, char *argv[] )
{
  // char *result[5];
  char** result = malloc(5*sizeof(*result));

  result[0] = strdup("one");
  result[1] = strdup("two");
  result[2] = strdup("three");
  result[3] = strdup("four");
  result[4] = NULL; // strdup("five");

  // Since it is 'pointer' type array, pointer++ always moves 4 bytes wheather or not array element
  // has char or int pointer. In other words, pointer size is the same regardless of type.

  char** it;
  for(it=result; it && *it; ++it)   // to end loop there should be an element which has NULL.
  {
    printf("%s\n", *it);
    free(*it);
  }

  free(result);
}

Can use "char* result = malloc(...);" However problem is how to use/access allocated memory
afterwards. If use result[0] or result++, it moves 1 but not 4. The compiler warns you as:

test2.c:21:13: warning: assignment makes integer from pointer without a cast [enabled by default]
test2.c:26:9: warning: assignment from incompatible pointer type [enabled by default]

After all, memory is memory and address is address. The 'type' is all about how a compiler 'view'
it; how to access it via [] or ++. sub script is pointer arithmetic after all.


<pointers-vs-multi-dimensional>
From ansic, p112. When pass two dimensional array to a function f, can be declared as

f( int daytab[2][13] );
f( int daytab[][13] );
f( int (*daytab)[13] );

The last needs () since [] is higher than *. Othewise, it is an array of 13 pointers to integers.
The key is that the number of rows is irrelevant to a compiler and this is how a compiler see an
array in contiguous memory.

[0][13]                [1][13]                [2][13]                ...
<-------- 13 ---------><-------- 13 ---------><-------- 13 ---------><-------- 13 --------->


The other case is that followings are the same.

void print( const int* );
void print( const int[] );
void print( const int[10] );


From ansic, p113. Given the definitions:

int a[10][20];
int *b[10];

then a[3][4] and b[3][4] are 'both' syntactically legal references to a single int. Here legal means
both type is the same but can have different representation. The a is a true two dimensional array;
200 int-sized locations have been set aside; 20*row+col. For b, however, only allocates 10 pointers.
When each of b has 20 long, it has 200 plus 10 pointers.

The important advantage of the pointer array is that the rows of the array may be of different
length. So can be one int or array of int. In other words, int *b[10], int **b[10], int ***b[10] are
the same.

char *names[] = { "Illegal month", "Jan", "Feb", "Mar" };

names:
[] -> "Illegal month\0"
[] -> "Jan\0"
[] -> "Feb\0"
[] -> "Mar\0"

char names[][15] = { "Illegal month", "Jan", "Feb", "Mar" };

names:
[] -> "Illegal month\0"
[] -> "Jan\0          "
[] -> "Feb\0          "
[] -> "Mar\0          "


<example>
ansic, p116. argv example of option handling such as:

// echo command-line arguments
main( int argc, char *argv[] )
{
  while( --argc > 0 )
    printf("%s%s", *++argv, ( argc > 1 ) ? " " : "" );
    // or
    printf(( argc > 1 ) ? "%s " : "%s", *++argv );

  printf("\n");
  return 0;
}


find -x -n pattern
find -xn pattern

int main( int argc, char *argv[] )
{
  int c;

  // <1>
  while( --argc > 0 && (*++argv)[0] == '-' )
    while( c = *++argv[0] )
      switch(c) 
      {
        case 'x':
          printf("x option\n");
          break;
        case 'n':
          printf("n option\n");
          break;
        default:
          printf("unknown option\n");
          break;
      }

  // <2>
  if( argc != 1 )
    printf("usage: find -n -x pattern\n");

  return 0;
}

In <1>, argv is a pointer variable to a array but not array name so can increase it. so (*++argv)[0]
is the first character of argv[1]. Alternative be **++argv. See the skill of using 0 index without
using argv[i] indexing.

while( --argc > 0 && ((*++argv)[0] == '-' ))    // -
    while( c = *++argv[0] )                     // x or n
      printf("%c\n", c );

The *++argv[0] increments the pointer argv[0] but not argv itself. Since argv is alreay increased,
argv[0] means "-nx or -n", then ++ and * means "n".

(gdb) p argv
$5 = (char **) 0xbffff358
(gdb) p *argv
$6 = 0xbffff4f1 "-nx"

<2> this shall always be 1 if all are processed. If argc != 1 but loops ends, means that there are
argvs which does not start with -.


<example>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
  char arr[] = "abcd";
  char *parr = arr;
    
  printf("%c",   *(arr+0) ); // same as printf("%c",   arr[0] );
  printf("%c",   *(arr+1) ); // same as printf("%c",   arr[1] );
  printf("%c",   *(arr+2) ); // same as printf("%c",   arr[2] );
  printf("%c\n", *(arr+3) ); // same as printf("%c\n", arr[3] );

  printf("%c",   *(parr+0) ); // same as printf("%c",   parr[0] );
  printf("%c",   *(parr+1) ); // same as printf("%c",   parr[1] );
  printf("%c",   *(parr+2) ); // same as printf("%c",   parr[2] );
  printf("%c\n", *(parr+3) ); // same as printf("%c\n", parr[3] );

  // error: subscripted value is neither array nor pointer nor vector
  // printf("%c",   (*parr)[0] );
  // printf("%c",   (*parr)[1] );
  // printf("%c",   (*parr)[2] );
  // printf("%c\n", (*parr)[3] );

  printf("%c",   (&*parr)[0] );
  printf("%c",   (&*parr)[1] );
  printf("%c",   (&*parr)[2] );
  printf("%c\n", (&*parr)[3] );
  
  char *pparr[] = {"this is one line", "this is second line"};
  char **ppchar = pparr;

  printf("%s\n",   ppchar[0] );       // this is one line
  printf("%s\n",   ppchar[1] );       // this is second line

  printf("%c\n",   (*ppchar)[0] );    // t
  printf("%c\n",   (*ppchar)[1] );    // h

  printf("%c\n",   *((*ppchar)+0) );  // t
  printf("%c\n",   *((*ppchar)+1) );  // h
} 


<exercise> tail: was a question of google first phone screening.
The ansic, page 118, exercise 5-13. Write the <tail-program>, which prints the last n lines of its
input. By default, n is 10, say, but it can be changed by an optional argument, so that

tail -n

prints the last n lines. The program should behave rationally no matter how unreasonable the input
or the value of n. Write the program so it makes the best use of available storage; lines should be
stored as in the sorting program of Section 5.6, not in a two-dimensional array of fixed size.

see *kt_dev_glib_006* tail-program for a solution.


{null-pointer}
C gurantees that zero is never a valid address for data. Pointer and integers are not
interchangeable but zero is the sole exception. NULL symbolic constant.


{pointer-and-string}
char amessage[] = "now is the time";
char *pmessage = "now is the time";

The important difference is that amessage is an array that is 'initialised' with string constant.
Individual characters may be changed. On the other hand, pmessage is a pointer, initialised to point
to a string constant and can be modified but undefined if you try to modify the string contents.

<article>
Difference between char *a and char a[]

char * and char [] both are used to access character array, Though functionally both are same, they
are syntactically different. See how both works in order to access string.

A. How char a[] works?

Consider following example for storing and accessing string using character array -

char a[] = "HELLO";

In the example string "Hello" is stored in character array 'a'. Character array is used to store
characters in 'contiguous' memory location. It will take following form after 'initialization'. We
have not specified array size in this example. Each array location will get following values -

a[0] = 'H'
a[1] = 'E'
a[2] = 'L'
a[3] = 'L'
a[4] = 'O'
a[5] = '\0'

It will Looks Like This
array a :  H    E    L    L    O '\0'
         a[0] a[1] a[2] a[3] a[4]


Accessing Individual Element :
Suppose we have to find out a[3] then firstly compiler will check whether 'a' is array or pointer.
If 'a' is array variable then it starts at the location 'a', goes three elements past it, and
returns the character there. In this method element is accessed sequentially

B. How char *a works?

String "Hello" will be stored at any anonymous location in the form of array. We even don't know the
location where we have stored string, However string will have its starting address. Syntax of char
*a :

char *a = "HELLO";

the above syntax will take following form -

pointer a :  H    E    L    L    O '\0'
           a[0] a[1] a[2] a[3] a[4]
           anonymous array

We have declared pointer of type character i.e pointer variable is able to hold the address of
character variable. Now base address of anonymous array is stored in character pointer variable. 'a'
stores base address of the anonymous array(unknown array)

Address = [Base Address of Anonymous Array]  + [i]

Accessing Individual Element :

Consider we have to access a[3] then -
In short if 'a' is a pointer, it starts at the location "a", gets the pointer value there, adds 3 to
the pointer value, and gets the character pointed to by that value. In both cases a[3] returns same
character but procedure is different.

<c-string>
int main(int argc, char* argv[])
{
  //char *str1 = "\n";
  //char *str2 = "";
  //char *str3 = "one";

  char str1[] = "\n"; 
  // note: '\n' is character constant(single character) and "\n" is s string constant 
  char str2[] = ""; 
  char str3[] = "one"; 

  printf("size is %d\n", sizeof(str2));
  printf("size is 0x%x\n", '\n');
}

(gdb) p str1
$1 = "\n"
(gdb) p str2
$2 = ""
(gdb) p str3
$3 = "one"

(gdb) p /x str1
$4 = {0xa, 0x0}
(gdb) p /x str2
$5 = {0x0}
(gdb) p /x str3
$6 = {0x6f, 0x6e, 0x65, 0x0}
(gdb) 


<exercise> strcat: shows the same problem of control-for-vs-while
From ansic, exercise 5-3. Write a pointer version of the function strcat that we showed in Chapter
2: strcat(s,t) copies the string t to the end of s.

#include <stdio.h>

#define STR_BUFFER 10000

void mstrcat_one(char *, char *);
void mstrcat_two(char *s, char *t);
void mstrcat_three(char *s, char *t);
void mstrcat_four(char *s, char *t);

int main(int argc, char *argv[])
{
  //char string1[STR_BUFFER] = "What A ";
  char string1[STR_BUFFER] = "";
  char string2[STR_BUFFER] = "Wonderful World!";

  printf ("String 1:%s\n", string1);

  //mstrcat_one(string1, string2);
  //mstrcat_two(string1, string2);
  mstrcat_three(string1, string2);

  printf ("String 2:%s\n", string2);
  printf ("Cat Result:%s\n", string1);

  return 0;
}

// NOT OK when s is empty
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_3
/* Concatenate t to s. */
void mstrcat_one(char *s, char *t)
{
  /* note: this is the comment for mstrcat_three
   * '*++s' is used to reference the pointer before incremmenting it so
   * that the check for falsehood ('\0') is done with the next character
   * instead of '*s++' which would check, then increment. Using '*s++'
   * would increment the pointer to the base string past the null
   * termination character. When outputting the string, this made it
   * appear that no concatenation occurred because the base string is
   * cut off by the null termination character ('\0') that was never
   * copied over.
   */
  while(*++s); /* Get to the end of the string */
  while((*s++ = *t++));
}

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_3
void mstrcat_two(char *s, char *t)
{
  /* run through the destination string until we point at the terminating '\0' */ 
  while('\0' != *s)
  {
    ++s;
  }

  /* now copy until we run out of string to copy */
  while('\0' != (*s = *t))
  {
    ++s;
    ++t;
  }
}

// NOT OK since s points after null char and this is the same problem as control-for-vs-while
void mstrcat_three(char *s, char *t)
{
  while(*s++)
    ;

  while(*s++ = *t++)
    ;
}

void mstrcat_four(char *s, char *t)
{
  while(*s)
    s++;

  while(*s++ = *t++)
    ;
}

<exercise> strend: from ansic, exercise 5-4. pointer arithmetic
Write the function strend(s,t), which returns 1 if the string t occurs at the end of the string s,
and zero otherwise.

Is the same approach as the above exercise 4-1? Not necessarily.

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_5:Exercise_4
int strend(char *s, char *t)
{
  s += (strlen(s) - strlen(t));     // increments to the point of comparison
  while (*s++ == *t++)              // tests for equality
    if (*s == '\0')                 // or *t == '\0'; checks for null character while lines are equal
      return 1;
  return 0;
}

The above has an assumption that s is bigger than t. So a version has a check:

int strend(char *s, char *t)
{
  int slen = strlen(s);
  int tlen = strlen(t);

  if( slen >= tlen )
  {
    s += (slen - tlen);     //increments to the point of comparison

    while (*s++ == *t++)              //tests for equality
      if (*s == '\0')                 //checks for null character while lines are equal
        return 1;

    return 0;
  }

  return -1;
}

<key> The key is "s += (strlen(s) - strlen(t));" since this reduces cases to when s and t ends at
the same point. There are many cases when move t window from the start of s.


{off-the-end}
Pointer arithmetic or comparison is 'undefined' when use pointers that do not point to members of
the 'same' array. It is not legal to add two pointers while pointer addition is legal; pointer add
integer. There is one exception: the address of the first element past the end of an array can be
used in pointer arithmetic.

<exercise> keyword counting program, ansic p137.

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

struct key 
{
  char *word;
  int count;
} keytab[NKEYS] = { "auto", 0, "break", 0, ... };

int getword( char *, int );
struct key *binsearch( char *, struct key *, int );

main()
{
  char word[MAXWORD];

  struct key *p;

  while( getword( word, MAXWORD ) != EOF )
    if( isalpha( word[0] ) )
      if((p = binsearch( word, keytab, NKEYS )) != NULL )
        p->count++;

  for( p = keytab; p < keytab + NKEYS; p++ )
    if( p->count > 0 )
      printf("%4d %s\n", p->count, p->word );

  return 0;
}

// note: see how binsearch is modified to use structure.
struct key *binsearch( char *word, struct key *tab, int n)
{
  int cond;
  struct key *low = &tab[0];
  struct key *high = &tab[n];       // this is off-the-end
  struct key *mid;

  // "low < high" since use of off-the-end but not because of Binary1/Binary2 difference.
  while( low < high )
  {
    // "high-low" is "size" which is different from (low + (size-1))/2. Howerver, doesn't matter.
    mid = low + ( high-low )/2;

    if((cond = strcmp( word, mid->word )) < 0 )
      high = mid;  // why not mid-1? since high is excluded in while condition. not sure.
    else if( cond > 0 )
      low = mid+1;
    else
      return mid;
  }

  return NULL;
}


<pointers-are-iterator>
Like, off-the-end iterator, can use off-the-end pointer which is the address of the 'nonexistent'
element one past the last element of an array. note that just take address but not element(not
access it). So must not derefernce or increment an off-the-end pointer.

#include <iostream>

using namespace std;

int main()
{
  
  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  cout << "{";

  for( int* b = arr, *e = &arr[10]; b != e; ++b )
    cout << *b << ", ";

  cout << "}" << endl;
}

<begin-and-end-function> <std::begin>
Said defined in iterator header but do not need to include to use and easy to write C++ loop.

int* pbeg = begin(arr), *pend = end(arr);

for( pbeg; pbeg != pend && *pbeg > = 0; ++pbeg )
  ...;

<difference-between-arr-and-parr>
int main () {

  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int* parr = new int[100];

  std::vector<int> ivec( std::begin(arr), std::end(arr) );     // 1
  std::vector<int> ivec( std::begin(parr), std::end(parr) );   // 2
  std::vector<int> ivec( std::begin(*parr), std::end(*parr) ); // 3
  
  return 0;
}

The "1" is okay but this "2" and 3 causes an error:

For 2, error: no matching function for call to begin(int*&)  // here typename int*
For 3, error: no matching function for call to begin(int&)   // here typename int

sam01.cpp:14:41: note: candidates are:
/usr/include/c++/4.6/bits/range_access.h:48:5: note: 
  template<class _Container> decltype (__cont.begin()) std::begin(_Container&)
/usr/include/c++/4.6/bits/range_access.h:58:5: note: 
  template<class _Container> decltype (__cont.begin()) std::begin(const _Container&)
/usr/include/c++/4.6/bits/range_access.h:87:5: note: 
  template<class _Tp, unsigned int _Nm> _Tp* std::begin(_Tp (&)[_Nm])
/usr/include/c++/4.6/initializer_list:86:5: note: 
  template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)

Why? std::begin shall work with array? Array is different from block of memory. Here are the libary
implementation:

/usr/include/c++/4.6/bits/range_access.h:87:5:

/**
 *  @brief  Return an iterator pointing to the first element of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  begin(_Tp (&__arr)[_Nm])    // note see the size
  { return __arr; }

/**
 *  @brief  Return an iterator pointing to one past the last element
 *          of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  end(_Tp (&__arr)[_Nm])
  { return __arr + _Nm; }

<1> Array is 'sized' data structure and size is known at 'compile' time and can be used implicitly.
<2> Array is different.

char parray[] = "this is sample string";
char *pnew = "this is sample string";

printf("0: %0x 1: %0x \n", &parray, &parray[0] );
printf("0: %0x 1: %0x \n", &pnew, &pnew[0] );

0: bfc09896 1: bfc09896
0: bfc09890 1: 80489c5 

<3> decltype seems return char * for both but typeid are different. Why?
decltype( parray ) x;
decltype( pnew ) x;

tid: A22_c  // parray
tid: Pc     // pnew

Since the special conversion in array do not happen when use decltype. Really? YES.

decltype(arr) x = 100;

$ ./comp.sh sam01.cpp 
sam01.cpp: In function int main():
sam01.cpp:13:21: error: array must be initialised with a brace-enclosed initialiser

decltype(arr) x;
int y = x;

$ ./comp.sh sam01.cpp 
sam01.cpp: In function int main():
sam01.cpp:14:11: error: invalid conversion from int* to int [-fpermissive]

<4> sizeof see {sizeof-operator} for more
cout << "size: " << sizeof(arr) << endl;
cout << "size: " << sizeof(parr) << endl;
cout << "size: " << sizeof(*parr) << endl;

size: 40
size: 4
size: 4


{sizeof-operator}
Queries size of the 'object' or 'type'. Used when actual size of the object must be known at compile
time:

sizeof( type )
sizeof expression/object

Both versions return a constant of type std::size_t.

Explanation

1) returns size in bytes of the object representation of type.
2) returns size in bytes of the object representation of the type, that would be returned by
expression, if evaluated.  

1. Depending on the computer architecture, a byte may consist of 8 or more bits, the exact number being
recorded in CHAR_BIT.

2. sizeof(char), sizeof(signed char), and sizeof(unsigned char) always return 1.

3. Cannot be used with function types, incomplete types, or bit-field lvalues.

4. When applied to a reference type, the result is the size of the referenced type.

5. When applied to a class type, the result is the size of an object of that class 'plus' any
additional padding required to place such object in an array.

6. When applied to an empty class type, always returns 1. 

<sizeof-which-version>
sizeof( type )
sizeof expression/object

Seen compile error when use both. Does it mean that sizeof(argv[0]) do not work?

int main()
{
  char **lineptr;

  int val = sizeof lineptr * 10;
  printf("value %d\n", val );

  val = sizeof(lineptr);
  printf("value %d\n", val );

  val = sizeof lineptr;
  printf("value %d\n", val );

  // This cause an error
  // test.c:16:24: error: invalid operands to binary * (have char ** and int)
  val = sizeof(lineptr * 10);
  printf("value %d\n", val );

  val = sizeof *lineptr * 10;
  printf("value %d\n", val );
}


struct nlist {
  struct nlist *next;
  char *name;
  char *defn;
};

int main( int argc, char *argv[] )
{
  char val = sizeof(val);
  printf("sizeof is %d\n", val );

  int *pint;
  printf("sizeof is %d\n", sizeof(*pint));

  struct nlist *plist;
  printf("sizeof is %d\n", sizeof(*plist));  
  // <Q> 4 or 12? 12 since it is the same as printf("sizeof is %d\n", sizeof(struct nlist));
}

Here a pointer points to a 'type' and this is a struct in this case.

<to-get-array-size>
Two forms and the 'latter' is 'better' since do not need to be changed if the type changes.

int length= sizeof(arr)/sizeof(int); or int length= sizeof(arr)/sizeof(arr[0]);

<caveat>
int func()
{
  int arr[] = { ... };
  int length= sizeof(arr)/sizeof(int);
  ...
}

This works fine as expected; sizeof(array) returns a size of an array, but if you pass array in
func, it is converted to a pointer and the return of sizeof is the size of pointer but not the
array.

int func(int arr[])
{
  int length = sizeof(arr)/sizeof(int);   // note: THIS DOESN'T WORK!
  ...
}

Why? {difference-between-arr-and-parr} explains.


<sizeof-to-get-string-length>
int main()
{
  std::cout << "length is " << sizeof("DSM:!") << std::endl;
  std::cout << "length is " << strlen("DSM:!") << std::endl;
  std::cout << "length is " << sizeof("") << std::endl;
  std::cout << "length is " << strlen("") << std::endl;
}

length is 6    // sizeof
length is 5
length is 1    // sizeof
length is 0

The strlen() function calculates the length of the string s, 'excluding' the terminating null byte
('\0'). In other words, strlen knows about a c string but sizeof do not. Hence sizeof returns +1
more. KT. sizeof is better since it is not a func call and done in compile.


{function-pointer}
In the past, void (*fptr)(); can define a func that has <any-args> but that is not the case any more
when tested with gcc and VC as of 2013.03. This is wrong:

typedef int ENTRYTYPE;

typedef void(*)(int) TFUNC; // error

void stacktraverse( stack* stack, TFUNC func)
{
  func(val);
}

This is right:

typedef void(*TFUNC)(int);

void stacktraverse( stack* stack, TFUNC func)
{
  func(val);
}

Also, the following causes error:

queue-contig.cpp:60:35: error: expected identifier before '(' token
queue-contig.cpp:60:41: error: expected ',' or '...' before '*' token

void stacktraverse( stack* stack, (void)*func(int))
{
}


={============================================================================
*kt_dev_lang_013* allman style


={============================================================================
*kt_dev_lang_014* interesting codes

{1} The format argument of printf can be an expression too.
printf((argc>1) ? "%s " : "%s", *++argv );

{2} printf-format
int main()
{
  char *pmesg = "0123456789";

  printf("0: %.*s \n", 2, pmesg );
  printf("0: %.*s \n", 3, pmesg );
  printf("0: %.*s \n", 4, pmesg );
  printf("0: %.*s \n", 5, pmesg );
  printf("0: %.*s \n", 6, pmesg );
}

0: 01
0: 012
0: 0123
0: 01234
0: 012345

The precision
An optional precision, in the form of a period ('.') followed by an optional decimal digit string.
Instead of a decimal digit string one may write "*" or "*m$" (for some decimal integer m) to specify
that the precision is given in the next  argu ment,  or in the m-th argument, respectively, which
must be of type int.  If the precision is given as just '.', or the preci sion is negative, the
precision is taken to be zero.  This gives the minimum number of digits to appear for d, i, o, u, x,
and X conversions, the number of digits to appear after the radix character for a, A, e,
E, f, and F conversions, the maximum num ber of significant digits for g and G
conversions, or the maximum number of characters to be printed from a string for s and S
conversions.

MHEGDebugDebug(eMHEGengRuntime,"OS-OctetStringVariable Append %.*s, %.*s -> %.*s\n",
              (OctetStringVariableEntry(pEntry).m_osValue).size,
              (OctetStringVariableEntry(pEntry).m_osValue).buf,
              osValue.size, osValue.buf,
              osNewValue.size, osNewValue.buf);

{3} print unsigned long value

printf("ulong max from limits: %luL\n", ULONG_MAX );


={============================================================================
*kt_dev_lang_015* control flow

{control-switch}
To emphasize that the cases represent a range of values:

switch(ch)
{
  case 'a': case 'e': case 'i': case 'o': case 'u':
    ...
  break;
}

note: It can be useful to define a default label even if there is no work for the case to indicate
that the case was considered.

<switch-under-the-hood>
http://stackoverflow.com/questions/3012011/switch-case-assembly-level-code

Here is the C source:

switch(i)
{
    case 1:
    {
        printf("Case 1\n");
        break;
    }
    case 2:
    {           printf("Case 2\n");
        break;
    }
    case 3:
    {
        printf("Case 3\n");
        break;
    }
    case 4:
    {
        printf("Case 4\n");
        break;
    }
    // omitted to 10:
    default:
    {
        printf("Nothing\n");
        break;
    }
}  

Now the resultant assembly for the same is:

movl    $5, -4(%ebp)
cmpl    $10, -4(%ebp)
ja  L13
movl    -4(%ebp), %eax
sall    $2, %eax
movl    L14(%eax), %eax
jmp *%eax
.section .rdata,"dr"
.align 4
L14:
.long   L13
.long   L3
.long   L4
.long   L5
.long   L6
.long   L7
.long   L8
.long   L9
.long   L10
.long   L11
.long   L12
.text
L3:
movl    $LC0, (%esp)
call    _printf
jmp L2
L4:
movl    $LC1, (%esp)
call    _printf
jmp L2
L5:
movl    $LC2, (%esp)
call    _printf
jmp L2
L6:
movl    $LC3, (%esp)
call    _printf
jmp L2
L7:
movl    $LC4, (%esp)
call    _printf
jmp L2
L8:
movl    $LC5, (%esp)
call    _printf
jmp L2
L9:
movl    $LC6, (%esp)
call    _printf
jmp L2
L10:
movl    $LC7, (%esp)
call    _printf
jmp L2
L11:
movl    $LC8, (%esp)
call    _printf
jmp L2
L12:
movl    $LC9, (%esp)
call    _printf
jmp L2
L13:
movl    $LC10, (%esp)
call    _printf
L2:  

First the code is comparing the i to 10 and jumping to the default case when the value is greater
then 10 (cmpl $10, -4(%ebp) followed by ja L13). The next bit of code is shifting the input to the
left by two (sall $2, %eax) which is the same as multiple by four (it multiplies by 4 because each
entry in the jump table is 4 bytes long). So what is had done here is generated an offset into
the jump table. It then loads an address from the jump table (movl L14(%eax), %eax) and jumps to it
(jmp *%eax).

The jump table is simply a list of addresses (represented in assembly code by labels):

L14:
.long   L13
.long   L3
.long   L4
...

One thing to notice is that L13 represents the default case. It is both the first entry in the jump
table (for when i is 0) and is handled specially at the beginning (when i > 10).

<01>
@puffadder: most modern compilers use heuristics to determine when it's more efficient to use
branches versus a jump table. E.g. if your case levels were say 1, 100 and 1000 you might expect
branches to be used. - Paul R Jun 10 '10 at 7:07 

<02>
You have a switch statement with 5 case statements and the cases all have numbers that are spread
far apart so a jump table will not be used, 'if type' will. {Q} May choose not to use a jump table
because there will be entries which are not used? Up to a compiler?

<switch-grouping>

typedef enum {
  E_01,    //
  E_02,
  E_03,
  E_11,    //
  E_12,
  E_13,
  E_21,    //
  E_22,
  E_23,
  E_31,    //
  E_32,
  E_33
} EVENTS;

typedef enum {
  E_G00, E_G01, E_G02, E_G03, E_GNO
} GROUPS;

int getEventGroup( int events )
{
  switch( events )
  {
    case E_01: case E_02: case E_03:
      return E_G00;
      break;
      ...

    default:
        return E_GNO;
        break;
        std::cout << "IS IT EXECUTED?? " << events << std::endl;
  }
}

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( getEventGroup(events) )
    {
      case E_G00:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

OR

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( events )
    {
      case E_01: case E_02: case E_03:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

The both do the same. The second is a bit clearer at the expense of one function call?


<does-it-work>
Found it in the real code. Does the line after default get executed? NO.

switch( events )
{
  case E_01: case E_02: case E_03:
    ...
      break;
  default:
    return E_GNO;
    break;
    std::cout << "IS IT EXECUTED?? " << events << std::endl;
}


{control-for-vs-while}
<exercise> escape: from ansic, exercise 3-2. 
Write a function escape(s,t) that converts characters like newline and tab into visible escape
sequences like \n and \t as it copies the string t to s. Use a switch. Write a function for the
other direction as well, converting escape sequences into the real characters.

// mine to show idea
void escape(char* s, char* t)
{
  // while( *t++ )
  while( *t )
  {
    switch(*t)
    {
      case '\t':
        *s++ = '\\';    // note
        *s++ = 't';
        break;

      default:
        *s++ = *t;
        break;
    }

    t++;
  }
  
  *s = '\0';
}

note: When use "while(*t++)", the result missed out the first char. Why? When think about strcpy:

void strcpy( char *s, char *t )
{
  while( *s++ = *t++ ) 
    ;
}

while(expression)
  statement

"If expression is non-zero, statement is executed and expression is re-evaluated." So in strcpy,
copied by evaluating and increased by the side effect. Not used in statement. This means that if use
"s" or "t" in the statement then will get the side effect, that is, increased one. See the
following.

<exercise> atoi: atoi second version in ansic p61
The for is preferable when there is a simple initialization and increment since it keeps the loop
control statement 'close''together' and visiable at the top of the loop.

#include <ctype.h>

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;

  sign = (s[i] == '-') ? -1 : 1;

  // skip sign
  if( s[i] == '+' || s[i] == '-' )
    i++;

  for(n = 0; isdigit( s[i] ); i++)
    n = n*10 + (s[i]-'0');

  return sign*n;
}

This is the right version. However, if use while as below then miss out the one char.

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  while( isspace(s[i++]) )
    ;
}

For example, when there is no leading space, expect i==0 when loop ends but i==1 since will have the
side effect. This is the same problem of expand() example above. Two solutions:

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;
}

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  while( isspace(s[i]) )
    i++;
}


<exercise> expand: From ansic, exercise 3-3. 
Write a function expand(s1,s2) that expands shorthand notations like a-z in the string s1 into the
equivalent complete list abc...xyz in s2. Allow for letters of either case and digits, and be
prepared to handle cases like a-b-c and a-z0-9 and -a-z . Arrange that a leading or trailing - is
taken literally

#include <stdio.h>
#include <ctype.h>

#define UP(N) ((N) >= 'A' && (N) <= 'Z')
#define LO(N) ((N) >= 'a' && (N) <= 'z')
#define NU(N) ((N) >= '0' && (N) <= '9')
#define AN(N) (UP(N) || LO(N) || NU(N))

// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_3
// Pilcrow 20:33, 14 September 2011 (UTC) 
int expand_online(const char s1[], char s2[], int sz)
{
  int i, j, temp;

  j=0;
  for(i = 0; s1[i] != '\0'; i++) {
    if(j >= sz) return 0;                                   /* buffer overflow */
    if(i==0 || s1[i] != '-') {                              /* first character or not '-'*/
      s2[j++] = s1[i];
      continue;
    }
    if(s1[i] == '-' && (!AN(s1[i-1]) || !AN(s1[i+1]))) {    /* leading, trailing, isolated '-' */
      s2[j++] = s1[i];
      continue;
    }
    if(s1[i] == '-' && (
          (UP(s1[i-1]) && UP(s1[i+1]) && s1[i-1] < s1[i+1]-1) ||
          (LO(s1[i-1]) && LO(s1[i+1]) && s1[i-1] < s1[i+1]-1) ||
          (NU(s1[i-1]) && NU(s1[i+1]) && s1[i-1] < s1[i+1]-1))) {
      temp = s1[i-1]+1;
      while (temp < s1[i+1]) {
        s2[j++] = temp++;
      }
      continue;
    }
    s2[j++] = s1[i];                                            /* didn't hit any 'continue's */
  }
  s2[j] = '\0';
  return 1;
}

// mine
int check( char a, char b )
{
  // do not support 'z-a-' and this outputs 'a-'
  // if( (isalpha(a) && isalpha(b)) || (isdigit(a) && isdigit(b)) )
  //   return 1;

  if( (isalpha(a) && isalpha(b)) && (a <= b) )
    return 1;

  if( (isdigit(a) && isdigit(b)) && (a <= b) )
    return 1;

  return 0;
}

void expand( const char s1[], char s2[] )
{
  // a-a
  // a-!
  // a-z
  // aa-z
  // a-9
  // a- a-z
  // ---a
  // a-z0-9
  // a-c-f
  // a-0-8 -> 012345678
  // -a-z
  // so "a-" is a signal to check

  // <outline-second>
  // while( s1 is not null )
  // {
  //    // a-z, a-z0-9, a-b-d,
  //    if( s1 is alphabet or number AND s1+1 is - )
  //    {
  //      // check if it is valid token; alpha and alpha or number and number
  //      if(check(s1,s1+2)) // valid
  //      {
  //        for(char first = s1[]; first <= s1+2; )
  //        {
  //          copy first; s2++; first +=1;
  //        }
  //      }
  //      else
  //        copy s1, s1+1 to S2; // 'a-'
  //        s1 += s1+2; // move two
  //    }
  //    else // handles all invaild cases including a leading or trailing - is taken literally
  //    {
  //      copy s1 to s2;
  //      s1++;
  //    }
  //
  //  } // while end

  while( *s1 )
  {
    if( isalnum(*s1) && (*(s1+1) == '-' ) )
    {
      if( check( *s1, *(s1+2)) )
      {
        for( char start = *s1; start < *(s1+2); start +=1 )
          *s2++ = start;

        s1 += 2;
      }
      else
      {
        *s2++ = *s1++;
        *s2++ = *s1++;
      }
    }
    else
    {
      *s2++ = *s1++;
    }
  } // while end

  // note that missed this in the first place
  *s2 = '\0';
}

int main(int argc, char* argv[])
{
  const char *s[] = {   // <pointers-to-pointers>
    "a-z-", 
    "z-a-", 
    "-1-6-",
    "a-ee-a", 
    "a-R-L", 
    "1-9-1",
    "5-5", 
    "C-Y", 
    "a-z0-9", 
    NULL };

  // one
  {
    char result[100]={0};
    int i = 0;

    printf("=============\n");

    while ( s[i] ) {

      /*  Expand and print the next string in our array s[]  */
      expand_online(s[i], result, 99);
      printf("Unexpanded: %s\n", s[i]);
      printf("Expanded  : %s\n", result);
      ++i;
    }
  }

  // two
  {
    char result[100]={0};
    int i = 0;

    printf("=============\n");

    while ( s[i] ) {

      /*  Expand and print the next string in our array s[]  */
      expand(s[i], result);
      printf("Unexpanded: %s\n", s[i]);
      printf("Expanded  : %s\n", result);
      ++i;
    }
  }

  return 0;
} 

Q: //how will the input 5-5-5 can be handled ? will it output to "555" or "55" or "5" ? 

$ ./a.out 
=============
Unexpanded: a-z-
Expanded  : abcdefghijklmnopqrstuvwxyz-
Unexpanded: z-a-
Expanded  : z-a-
Unexpanded: -1-6-
Expanded  : -123456-
Unexpanded: a-ee-a
Expanded  : abcdee-a
Unexpanded: a-R-L
Expanded  : a-R-L
Unexpanded: 1-9-1
Expanded  : 123456789-1
Unexpanded: 5-5
Expanded  : 5-5
Unexpanded: C-Y
Expanded  : CDEFGHIJKLMNOPQRSTUVWXY
Unexpanded: a-z0-9
Expanded  : abcdefghijklmnopqrstuvwxyz0123456789
=============
Unexpanded: a-z-
Expanded  : abcdefghijklmnopqrstuvwxyz-
Unexpanded: z-a-
Expanded  : z-a-
Unexpanded: -1-6-
Expanded  : -123456-
Unexpanded: a-ee-a
Expanded  : abcdee-a
Unexpanded: a-R-L
Expanded  : a-R-L
Unexpanded: 1-9-1
Expanded  : 123456789-1
Unexpanded: 5-5
Expanded  : 5
Unexpanded: C-Y
Expanded  : CDEFGHIJKLMNOPQRSTUVWXY
Unexpanded: a-z0-9
Expanded  : abcdefghijklmnopqrstuvwxyz0123456789


{comma-operator}
The comma operator is a sequence point (as they are && and ||) so the order of evaluation of the
operands is 'fixed'. It is a binary operator that evaluates its first operand, performs all side
effects and discards the result, and then evaluates the second operand and returns its value.

Any number of expressions separated by commas can form a single expression because the comma
operator is associative. The use of the comma operator guarantees that the subexpressions will be
evaluated in <left-to-right> order, and the value of the last becomes the value of the entire
expression. type so:

x = (y, z);

will do y and, after performing all side effects, will discard it, then do z and finally will set x
to z.

Because the comma operator discards its first operand, it is useful where the first operand has
<desirable-side-effects>, such as in the initializer or the counting expression of a for loop. Used
to produce side effects.

For example, this for statement:

for( p=0; p+=(a&1)*b,a!=1; a>>=1,b<<=1 )
   ...

can be re-written:

p=0;
p+=(a&1)*b;          // see
while (a!=1) {
    ...
    a>>=1;
    b<<=1;
    p+=(a&1)*b;      // see
}

The primary use of the comma operator is to 'produce' side effects in the following situations:

Calling a function
Entering or repeating an iteration loop
Testing a condition
Other situations where a side effect is required but the result of the expression is not immediately needed

for (i=0; i<2; ++i, f() );

A for statement in which i is incremented and f() is called at each iteration.

if ( f(), ++i, i>1 ) { /* ... */ } 

An if statement in which function f() is called, variable i is incremented, and variable i is tested
against a value. The first two expressions within this comma expression are evaluated before the
expression i>1. Regardless of the results of the first two expressions, the third is evaluated and
its result determines whether the if statement is processed.

func( ( ++a, f(a) ) ); 

A function call to func() in which a is incremented, the resulting value is passed to a function
f(), and the return value of f() is passed to func(). The function func() is passed only a single
argument, because the comma expression is enclosed in parentheses within the function argument list.

<exercise> reverse: ansic, p62

#include <string.h>

void reverse(char s[])
{
  int c, i, j;

  for( i = 0, j = strlen(s)-1; i < j; i++, j-- )
  {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}

Suitable when strongly related to each other and the exchange can be 'thought' of as a single
operation.

void reverse(char s[])
{
  int c, i, j;

  for( i = 0, j = strlen(s)-1; i < j; i++, j-- )
    c = s[i], s[i] = s[j], s[j] = c;
}

note: strlen()-1 to exclude NULL in calculation.


{control-break-continue}
<exercise> trim: from ansic, p65. Remove trailing blanks, tabs, newlines.

int trim( char s[] )
{
  int n;

  for(n = strlen(s)-1; n > 0; n--)
    if( s[n] != ' ' && s[n] != '\t' && s[n] != '\n' )
      break;

  s[n+1] = '\0';
  return n;
}

Sacn backwards looking for the first character that is not a blank, tab or newline. May perform
better than searching from the beginning.

for( i = 0; i < n; i++ )
{
  // skip negative elements
  if( a[i] < 0 )
    continue;

  // do positive elements
}


{control-goto}
From ansic, p66, this organization is handy if the error handling is non 'trivial' and can occur in
several places.

for( ... )
  for( ... )
  {
    ...

    if(disaster)
      goto error:
  }
...

error:
   clean up the mess

The goto can always be written without one.

for( i = 0; i < n; i++ )
   for( j = 0; j < m; j++ )
      if( a[i] == b[j] )
         goto found;          // how about return

// didn't find any common elements

found:
  // got one


found = 0;
for( i = 0; i < n && !found; i++ )     // note !found <goto-alternative>
   for( j = 0; j < m && !found; j++ )
      if( a[i] == b[j] )
         found = 1;

if(found)
  // got one
else
  ...
  // didn't find any common elements


={============================================================================
*kt_dev_lang_016* operator-precedence, operators

http://en.cppreference.com/w/cpp/language/operator_precedence

The following table lists the precedence and associativity of C++ operators. Operators are listed
top to bottom, in descending precedence. Where no associativity follows the above one.
note that is from C++ Primus and hence updated.

Precedence Operator, Description, Use, Associativity, (L)eft-to-right

 ::               global scope                  ::name                      L
                  class                         class::name
                  namespace                     namespace::name
 ----------------------------------------------------------------------------
 .                member selector               object.member               L
 ->               member selector               pointer->member
 []               subscript                     expr[ expr ]
 ()               function call                 name( expr_list )
 ()               type construction             type( expr_list )
 ----------------------------------------------------------------------------
 ++               post increment                lvalue++                    R
 --               post decrement                lvalue++
 typeid           type ID                       typeid(type)
 explicit cast    type conversion               cast_name<type> expr
 ----------------------------------------------------------------------------
 ++               pre increment                 ++lvalue++                  R
 --               pre decrement                 --lvalue++
 ~                'bitwise' not                   ~expr
 !                logical not                   !expr
 -                unary minus                   -expr
 +                unary plus                    +expr
 *                dereference                   *expr
 (TODO)

3 ++   -- [Prefix] increment and decrement            Right-to-left
  + -                Unary plus(+) and minus(-)
  ! ~                Logical NOT and bitwise NOT
  (type)             Type cast
  *                  Indirection (dereference)
  &                  Address-of
  sizeof             Size-of
  new, new[]         Dynamic memory allocation
  delete, delete[]   Dynamic memory deallocation
 ----------------------------------------------------------------------------
4 .* ->*    Pointer to member                         Left-to-right
 ----------------------------------------------------------------------------
5 * / %     Multiplication, division, and remainder
 ----------------------------------------------------------------------------
6 + -       Addition(+) and subtraction(-)
 ----------------------------------------------------------------------------
7 << >>     'bitwise' left shift and right shift
 ----------------------------------------------------------------------------
8 < <=      For relational operators < and <= respectively
  > >=      For relational operators > and >= respectively
 ----------------------------------------------------------------------------
9 == !=     For [relational] = and != respectively
 ----------------------------------------------------------------------------
10 &        Bitwise AND
 ----------------------------------------------------------------------------
11 ^        Bitwise XOR (exclusive or)
 ----------------------------------------------------------------------------
12 |        Bitwise OR (inclusive or)
 ----------------------------------------------------------------------------
13 &&       Logical AND
 ----------------------------------------------------------------------------
14 ||       Logical OR
 ----------------------------------------------------------------------------
15 ?:             Ternary conditional                       Right-to-left
   =              Direct [assignment] (provided by default for C++ classes)
   += -=          Assignment by sum and difference
   *=  /=  %=     Assignment by product, quotient, and remainder
   <<= >>=        Assignment by bitwise left shift and right shift
   &=  ^=   |=    Assignment by bitwise AND, XOR, and OR
 ----------------------------------------------------------------------------
16 throw          Throw operator (for exceptions)
 ----------------------------------------------------------------------------
17 ,              Comma                                     Left-to-right 


{parentheses}
CPP p136. The parentheses override the normal grouping since parenthesized expressions are evaluated
by treating it 'subexpressions' as a 'unit' and otherwise applying the normal precedence rules.


{side-effect} <evaluation-order>
An expression, such as 'ival+5' becomes an expression statement when it is followed by a semicolon.
An expression statement contains an expression that has a <side-effect> such as assigning a new
value or printing a result when it is evaluated.

From ansic, p53. C do not specify the 'order' in which the operands of an operator are evaluated. 

x = f() + g();                         // f may be evaluated before g or vice versa

Function calls, nested assignment statements, and increment and decrement operators
cause "side effect" - some variable is changed as a by-product of the evaluation of an expression.
In any expression involving side effects, there can be subtle dependencies on the 'order' in which
variables taking part in the expression are updated.

printf("%d %d\n", ++n, power(2, n));   // WRONG this is not a comma operator

a[i] = i++;

When side effects take place is left to discretion of the compiler, since the best order depends
strongly on machine architecture.

<1>
while (fgets(line, 256, file))
{
  sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], &Highs[i], &Lows[i++]);
}

Review comment from Ian Park.
You made big mistake here. Increasing 'i' in the parameter is very dangerous. The evaluation order
of function parameter is undefined in spec and usually they are evaluated in reverse order in most
of compilers. Therefore 'i' will be increased firstly and the data for Stocks,Intervals,Volumes and
Highs will be stored in the next row. The data will be totally mangled. Increase 'i' in the
separated line.

<2> see reverse polish calculator
The + and * are commutative operators, the order in which the popped operands are combined is
irrelevant, but for - and / the left and right operands must be distinguished.

push( pop() - pop () );

This is wrong since the order in which the two calls of pop are evaluated is not 'defined'.


{operator-unary}
The unary negation operator ! converts a non-zero operand into 0 and a zero operand into 1. A common
use of ! is in constructions like:

if(!valid) rather then if(valid==0)

<exercise>
From ansic, exercise 2-2. Write a loop equivalent to the for loop above without using && or ||.

for(i=0; i<lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
   s[i] = c;

# 01

while (i < (lim - 1))
{
  c = getchar();

  if (c == EOF)
    break;
  else if (c == '\n')
    break;

  s[i++] = c;
}

# 02

for(i=0; i<lim-1 ? (c=getchar()) != '\n' ? c != EOF : 0 : 0; ++i)
   s[i] = c;


{operator-assign}
The operator "+=" is called "assignment operator" and most binary operators have a corresponding
assignment operator "op=", where op is + - * / % << >> & ^ |.

note: that "expr1 op= expr2" is equivalent to "expr1 = (expr1) op (expr2)" and notice that () around
expr since:

x *= y + 1; means x = x * ( y + 1 ); rather than x = x * y + 1;

Notice that "assignment statement" is: c = getchar(); and the 'type' of an assignement expression is
the type of its left operand in case of assignement operator. The point is that expresssion has a
'type'.


{operator-conditional}
The conditional expression often leads to 'succint' code.

Prints newline after every 10th element and after n-th and blank for all other elements.

for( i = 0; i < n; i++ )
   printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ' );


printf("You have %d item%s.\n", n, n==1 ? "" : "s" );

<exercise> lower: The ansic, page 52, exercise 2-10. 
Rewrite the function lower, which converts upper case letters to lower case, with a conditional
expression instead of if-else.

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_10

the natural solution for simply making this a conditional (ternary) return instead of an if end
else. Won't work on EBCDIC machines.

// lower: convert c to lower case; ASCII only
int lower(int c)
{
  return c >= 'A' && c <= 'Z' ? c + 'a' - 'A' : c;
}

note: KT. This shall works for ASCII and EBCDIC since both has constant offset for alphabet chars
and sequential values for numbers.

the more 'portable' solution, requiring string.h for strchr but keeping the idea of a conditional
return.  

// lower: convert c to lower case
int lower(int c)
{
  char *Uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char *Lowercase = "abcdefghijklmnopqrstuvwxyz";
  char *p = NULL;

  return NULL == (p = strchr(Uppercase, c)) ? c : *(Lowercase + (p - Uppercase));
}

char *strchr(const char *s, int c);
The strchr() function returns a pointer to the first occurrence of the character c in the string s

<same-type>
The conditional 'must' use the same type.

int cond = 0;
printf("this is char %s\n", cond ? "ture" : cond );

C   compile: warning: pointer/integer type mismatch in conditional expression [enabled by default]
C++ compile: error: operands to ?: have different types const char* and int


={============================================================================
*kt_dev_lang_017* identifier name rule

Q: Is it okay to use like #define _DECLTYPE(_T) typeof(_T) ?

NO.

http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier

From the 2003 C++ Standard:

17.4.3.2.1 Global names [lib.global.names]

Certain sets of names and function signatures are always reserved to the implementation:

Each name that contains a double underscore (_ _) or begins with an underscore followed by an
uppercase letter (2.11) is reserved to the implementation for any use.  

Each name that begins with an underscore is reserved to the implementation for use as a name in the
global namespace.165

165) Such names are also reserved in namespace ::std (17.4.3.1).

C++P 2.3.3
The standard also reserves a set of names for use in the standard library. May not contain two
consecutive underscores, nor can an identifier begin with an underscore followed immediately by an
uppercase letter.


={============================================================================
*kt_dev_lang_018* style consideration: define variable

{two-style-to-define}
Since type modifier(* or &) is different from base type, there are two style choices:

1.
int *p1, *p2;

2. 
int* p1;
int* p2;


={============================================================================
*kt_dev_lang_019* function pointer

{function-type}
The function pointer points a particular 'type', function type.

bool (*pf) ( const string &, const string & );

bool bq = pf( "hello", "goodbye" );

<automatic-conversion>
In this example, the third parameter is "function type" and when use function directly, it is
'automatically' converted to function pointer. 

void useBigger( const string &s1, const string &s2, bool pf( const string &, const string & ) );

useBigger( s1, s2, lengthCompare );

note: this is why stl algorithm can take opeartion as typename.

The equivalent declaration but 'explicit'.

void useBigger( const string &s1, const string &s2, bool (*pf)( const string &, const string & ) );

Can use type alias and see that decltype() returns function type.

typedef bool Func( const string &, const string & );
typedef decltype( lengthCompare ) Func;                  // same

typedef bool (*FuncP)( const string &, const string & );
typedef decltype( lengthCompare ) *FuncP;                // same

useBigger( s1, s2, Func );
useBigger( s1, s2, FuncP );


{member-function-pointer}

void (SystemClientEventRepository::*masCallback)
(boost::shared_ptr<X>, const NS_ZINC::Value<Y> &) = &SystemClientEventRepository::eventsReceived;


{function-template-pointer}
The function pointer can points to the instantiation of function template.

template <typename T> int compare( const T&, const T& );

int (*pf1) ( const T&, const T& ) = compare;

However, by looking at the function's parameter, not possible to determine a unique type for the
template arguments.

void func( int (*) (const string&, const string&) );
void func( int (*) (const int&, const int&) );

func( compare );     // error: which instantiation of compare?

Can solve this ambiguity by using explicit template arguments.

func( compare<int> );


={============================================================================
*kt_dev_lang_020* style: bracing: allman

{allman-style}
The Allman style is named after Eric Allman. It has been incorrectly referred to as "ANSI style"
supposedly for its use in the documents describing the ANSI C standard; later adopted as the ISO C
international standard, though in fact those documents use K&R style. It is also sometimes known as
"BSD style" since Allman wrote many of the utilities for BSD Unix although this should not be
confused with the different "BSD KNF style"; see below.

This style puts the brace associated with a control statement on the next line, indented to the same
level as the control statement. Statements within the braces are indented to the next level.

while (x == y)
{
    something();
    somethingelse();
}
 
finalthing();

This style is similar to the standard indentation used by the Pascal programming language and
Transact-SQL, where the braces are equivalent to the begin and end keywords.

Suggested advantages of this style are that the indented code is clearly set apart from the
containing statement by lines that are almost completely whitespace and the closing brace lines up
in the same column as the opening brace. Some people feel this makes it easy to find matching
braces. Additionally, the blocking style delineates the actual block of code from the associated
control statement itself. Commenting out the control statement, removing the control statement
entirely, refactoring, or removing of the block of code is less likely to introduce syntax errors
because of dangling or missing braces. Furthermore, it's consistent with brace placement for the
outer/function block.

For example, the following is still syntactically correct:

//while (x == y)
{
    something();
    somethingelse();
}

As is this:

//for (int i=0; i < x; i++)
//while (x == y)
if (x == y)
{
    something();
    somethingelse();
}

Even like this, with conditional compilation:

char c;
#ifdef HAS_GETCH
while ((c = getch()) != EOF)
#else
while ((c = getchar()) != EOF)
#endif
{
    do_something(c);
}

{k-and-r-style}
The K&R style, so named because it was used in Kernighan and Ritchie's book The C Programming
Language, is commonly used in C. It is also used for C++, C#, and other curly brace programming
languages.

When adhering to K&R, each function has its opening brace at the next line on the same indentation
level as its header, the statements within the braces are indented, and the closing brace at the end
is on the same indentation level as the header of the function at a line of its own. The blocks
inside a function, however, have their opening braces at the same line as their respective control
statements; closing braces remain in a line of their own, unless followed by an else or while
keyword.

In this style a control statement with only a single statement in its scope may omit the braces. The
C Programming Language refers to this as fertile soil for bugs (programming logical errors) and
discourages it.

int main(int argc, char *argv[])
{
    ...
    while (x == y) {
        something();
        somethingelse();
 
        if (some_error) {
            /* the curly braces around this code block could be omitted */
            do_correct();
        } else
            continue_as_usual();
    }
 
    finalthing();
    ...
}


={============================================================================
*kt_dev_lang_021* style: layout

{type-declaration}
<1>
Foo *msg1, *msg2;

Foo& Foo::operator=( Foo &rhs )
{
  ...
}

<2>
Foo* msg1, *msg2;

Foo& Foo::operator=( Foo& rhs )
{
  ...
}

note: The second seems to be preferable by others and do not define multiple variables in the same
line.


{layout}
C++ Layout Conventions

Code layout

These guidelines are generally accepted practice. However, when editing pre-existing code please
remember that these guidelines are only to aid readability. As such, if a particular source file
deviates from our current standards, please be "locally consistent" and make your changes fit in
with the style in use there (eg. tabs vs. spaces). Multiple competing coding styles in a file really
harms readability.

If you are making large-scale changes to a file, that might be an opportunity to tidy up the
styling. But don't go changing a whole file when you only want to make a one-line functional change.


Bracing style

New projects should use Allman.


Line Length

Line length is roughly 80 characters maximum. This used to be 120 characters but since a number of
people like to use split-screen editing, 80 characters generally means lines don't wrap in this
mode. Also, printed code doesn't wrap.

This limit of 80 characters isn't a do-or-die hard limit. Sometimes with the verbose syntax of C++
it can be impractical, but generally if there's a chance of putting a line break in there, please do
for the sake of your neighbours, remembering to follow the standard convention of indenting by 4
spaces. 


Trailing space

Never have trailing whitespace. git will show you this as a whitespace error (in red) when you look
at your diffs and most editors allow you to show just trailing spaces too.


Non-ASCII Characters

Where possible non-ASCII characters should be represented as escape sequences for the appropriate
unicode code point, e.g. "\uA2DF"

Non-ASCII characters should be rare, and must use UTF-8 format.

The UTF-8 BOM marker shall not be used in files.


Spaces vs. Tabs

Use only spaces, and indent 4 spaces at a time.


Function Declarations and Definitions

Return type on the same line as function name, parameters on the same line if they fit.

If the function is templated place the template definition on the line above.

For pointer and reference parameters do not include a space after the type name, e.g.: void
foo(string* bar, int& baz);


Const

note: Is it something for preference?

The const keyword shall be placed as per this example:

char const* bar             // preferred
const char* bar
 
char const* const baz
// const char* const baz       DISALLOWED !


Function Calls

note: my preference is function( param ). is it less readable?

On one line if it fits; otherwise, wrapped lines should be indented.

Parameters should be followed by a comma and a space. There should be 'no' spaces either side of
parentheses.

E.g.:
var = functionWithRatherLongName(argumentWithRatherLongName, anotherRatherLongNamedArgument,
     aFinalArgumentThatDidntFitOnTheLineAbove);


Conditionals

note: how about if( a ==b )?

No spaces immediately after opening parenthesis nor before closing parenthesis. Place a space
'before' the opening parenthesis.

The else/else if keywords belong on a new line.

Always use block bracing even for single line blocks.

E.g.:
if (a == b)
{
    foo = bar;
    boz = jabber;
}
else if (c == d)
{
    foo = jabber;
}
else
{
    boz = baz;
}

The ternary ? operator is allowed and the expression should be enclosed in parentheses, e.g.:

i = (isFoo ? 42 : 13);


Switch Statements

Switch statements must use braces for blocks. E.g.:

switch (foo)
{
    case 13:
    case 42:
    {
        int bar = foo * 2;
        cout << bar;
        break;
    }
    default:
    {
         cout << foo;
         break;
    }
}


Loops

Empty loop bodies should use {}, e.g.:

while (dispatcher.processNextEvent()) {}


Pointer and Reference Expressions

No spaces around period or arrow. Pointer operators do not have trailing spaces.  E.g.:

foo = jabber.jab();
foo = jabber->jab();
baz = *jabber;


Return Values

Do not surround the return expression with parentheses.  E.g.:

return true;

Unless the return value is a complex expression.  E.g.:

return (a < b);


Preprocessor Directives

Preprocessor directives should be indented as shown below:

#define ZINC_FUNC_TRACE(logger) \
    boost::shared_ptr<NS_ZINC::ScopeLogger> _zinc_func_trace_logger; \
    if((logger).isEnabledFor(NS_ZINC::traceLog)) \
        _zinc_func_trace_logger.reset(new NS_ZINC::ScopeLogger(logger, __PRETTY_FUNCTION__, __FILE__, __LINE__, true));


Class Format

Sections in public, protected and private 'order'. The exceptions to the rule are that

*. a virtual destructor should always be the first virtual function declared in the class,
    regardless of what its access specifier is.

*. If, for whatever reason your class has members with different access (possibly protected and
        private members) you may need the private one to be initialised first in the constructor.

The words public, protected and private should not be indented.

If the class extends more than one abstract class (or interface), separate the
public/protected/private sections by class being extended.

E.g.:

class Hybrid : public Cow, public Sheep
{
public: // Implements Cow
    Milk milk();
    Beef slaughter();
 
public: // Implements Sheep
    Wool shear();
 
public: // Hybrid
    std::auto_ptr<Hybrid> clone() const;
 
private:
    string name;
};


Constructor Initializer Lists

Can be all on one line or with subsequent lines indented four spaces. The colon that begins the
initialiser-list specification should be at the end of the line of the constructor function rather
than the line of the first element.

All non static class members must be initialised in Constructor initializer list in the order of
their declaration.

E.g.:

MyClass::MyClass(int a_, double b_) :
    a(a_),
    b(b_) {}


Namespace Formatting

The contents of namespaces are 'not' indented.

E.g.:

namespace iron
{
namespace client
{
 
class Event
{
};
 
}
}

However namespaces shall be defined as macros in a file named "macros.h" in the include folder of
the project.

E.g.:

NS_IRON_CLIENT_OPEN
 
class Event
{
};
 
NS_IRON_CLIENT_CLOSE

Exceptions (to the Rules)

Existing Non-conformant Code, where changing this code carries a level of risk. Adding comments,
         however, adds no risk at all, and it should be encouraged where code is currently
         under-documented.

If modifying a file just to convert its style, make this change as a separate changeset, and do not
combine it with actual logical coding changes at the same time.


# ============================================================================
#{ CPP
={============================================================================
*kt_dev_cpp_000* oop

{oop}
The key ideas in OOP are data abstraction, inheritance, and dynamic binding.

1. The data 'abstration'. C++P p254. 
The data abstraction is a programming and design technique that relies on the separation of
interface and implementation. Encapsulation enforces the separation of a class' interface and
implementation and hides its implementation. Class users need not know how the type works and can
instead think 'abstractly' about what the type does. 

note: would say that encapsulation is a way to do and abstraction is notion to achieve or effect of
encapsulation.

2. The 'inheritance' can define classes that model the relationships among similar types. note:
abstraction.

Conceptually, neither the kind of device nor the character size affects the IO operations we want to
perform. For example, we would like to use >> to read data regardless of whether we are reading a
console window, a disk file, or a string. Similarly, we would like to use that operator regardless
of whether the characters we read fit in a char or require a wchar_t.

The library lets us ignore the differences among these different kinds of streams by using
inheritance. As with templates, we can use classes related by inheritance without understanding the
details of how inheritance works.

inheritance lets us say that a particular class inherits from another class. Ordinarily, we can use
an object of an inherited class as if it were an object of the same type as the class from which it
inherits.

3. dynamic-binding can use objects of these types while ignoring the details of how they differ.
note: this is mechnism to make inheritance work along with virtual mechnism and object
layout(subobject) scheme.


={============================================================================
*kt_dev_cpp_001* virtual inheritance (interview)

MI and SI (single inheritance)

The problem is that a class inherit from the same base class more than once and this means there are
more than one subobject. Then what is the real problem or consequence out of having more than one
subobject?

From C++ Primer, p810, took this example from IO library:

basic_ios (ABC) <- istream <- iostream
                <- ostream <- iostream

basic_ios holds stream's buffer and state but iostream wants to use "the same buffer and condition
state for both reading and writing". If an iostream object has two copies of its basic_ios, this
'sharing' is not possible.

That is, in iostream, cause ambiguity and can use both data using scope specifier like istream::x
and ostream::x. so real issue is 'sharing'

To solve this, use 'virtual'-inheritance and this shared base class is called a virtual-base-class.
How? makes only 'one' shared subobject for that virtual base class.


class istream : 'virtual' public basic_ios {};
class istream : virtual public basic_ios {};
class iostream : public istream, public ostream {}; 

From EC++40, p193,

This problem is called "deadly-MI-diamond" Problems? 'ambiguity' and 'replication' in the derived. C++
takes 'no' position on virtual inheritance problem. (checked with VC and no errors when there's a
deadly MI diamond) and its default is to perform the replication. 

However, VI 'costs' in size, speed and initialization problem. So recommendation is don't use VI
unless you need to.

<syntax>
Which one is right to have public inheritance from Y and Z?

class X : public Y, Z {
  ...
};

class X : public Y, public Z {
  ...
};


={============================================================================
*kt_dev_cpp_002* reference-vs-pointer (interview)

Refer to *kt_dev_cpp_013* for example uses.

EC++20. If you peek under the hood of a C++ compiler, will find that references are typically
implemented as pointers. note: KT. To this question, reference may or may not be the same as
pointer. In user level, there are differences and in compiler level, implemented as pointers. The
reference is a sub set of pointer which is limited in use?


{why-reference}
1. no copy made so efficient code
2. syntatic need such as operator[]


{differences}
<1>
No 'null' reference hence 'must' be initialized. From MEC++01. Always refer to an object. Unlike
pointer, no need to check its validity.

void printDouble( const double& rd )
{ cout << rd; }

vs.

void printDouble( const double* pd )
{
  if(pd)
    cout << *pd;
}

So efficient code.

<2>
Used operator funcs such as operator[]. {Q}

vector<T> v; v[5] = 10;

<4>
All operations on that reference are actually operations on the object to which the reference is
bound. Reference is bound 'once' but for pointer, can change pointer itself and can point any other
objects.

<5> 
There is no reference to a reference. but there's a pointer to a pointer. 

note: this do not mean it's a compile error but mean it has not effect as pointer has. This refVal3
binds to iVal but not to refVal.

int &refVal = iVal;
int &refVal3 = refVal;

int &refVal = iVal;        // the same
int &refVal3 = iVal;

<6>
Reference should 'match' to type and cannot bind to a literal.

int &ref = 10;                        // error
double dval = 3.14; int &ref = dval;  // error

<7>
There is no const reference but there's a const pointer because a pointer is object. Like any other
const object, const pointer must be initialized. Why?

error: uninitialised const pint [-fpermissive]

In {ref-CPR}, p50: Reference is not an object. object does not mean only object of class. Reference
defines an alternative name for an object. This is called binding hence 'must' be initialized.

int *const cpi = &i;

Q. An object is a memory area that has type and data. Given a ref isn't a object, a ref
shouldn't have an address.

int* ip; int &ri = a;
ip = &ri; ???

in VC, ip has a's address.

Q. on the same token:

struct {
  int x; int y;
} int_str;

struct {
  int x; int &rx = x;
} ref_str;

sizeof(int_str) == sizeof(ref_str) ??

in VC, they are the same.

It seems that a ref is a complete alias to a actual object.

<8>
No array and vector of reference.

int* ptrs[10];
int& refs[10];    // error. no arrays of ref


={============================================================================
*kt_dev_cpp_003* ctor and copy controls

{syn-operations} behind-the-scene-code
The following operations are synthesized by compiler if they are not defined and 'only' if they are
needed. These are 'public' and inline according to EC++05.

destructor and default constructor. four copy controls which are copy ctor, copy assign, move
ctor(C++11), move assign(C++11)

However, it is 'not' always possible since there are cases when compiler refuse to create those such
as:

1. When a class has reference or const member. why not const?
2. When base class have private on syn-operations. what private?
3. When there's a class member that don't have default ctor.


{default-ctor} default-initialization
Recommendation on initialization is to avoid syn version and do it explicitly: in-class init(C++11)
or ctor init list. Why? because to avoid:

1. Default-init for built-in types which means 'undefined' value.

2. Compile error when there's a class member that don't have default ctor since compiler cannot syn
default ctor for this class.

3. If a class requires control to init an object in one case, then the class is likely to require
control in all cases.


<constructor-and-const>
The ctor cannot be a 'const' member func. Why? When create a const object of a class type, the
object does not assume its 'constness' until after the ctor completes the object's initialisation.
Thus, ctor can write to const objects during their construction.


<default-keyword>
If there are other ctor, then compiler will 'not' make a default ctor and this is 'only' for
default ctor. So want to force it to create then use 'default' keyword.

note: There are cases when syn-operations are useful. See {make-base-class-for-reference-counting}


{default-initialization-mean}
The detault synthesised ctor will use in-class init if there is. Otherwise default init its member
and use default ctor for its class member. So 'undefined' value for built-in types and default
constructed value for user types.


{in-class-init} C++11
For window_mgr calss to start up with a single, default-inited screen.

class window_mgr {

  private:
   vector<Screen> screens{ Screen(24, 80, ' ') }; or 
   vector<Screen> screens = { Screen(24, 80, ' ') };
};

class T {
  T() = default;
  T(const string &s) : bookNo(s) {}
  ...
  string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

The in-class-init do like 'default' values in func args because:

T(const string &s) : bookNo(s) {}

is equivalent to:

T(const string &s) : bookNo(s), units_sole(0), revenue(0) {}

In case when use before C++11 then:

class T {
  T(): bookNo(), units_sold(0), revenue(0.0) {}
  T(const string &s) : bookNo(s) {}
  ...
  string bookNo;
  unsigned units_sold;
  double revenue;
};


{constructor-initializers} 
The following is initialization and assignment but not initialization since members are default
initialized 'before' ctor body runs. 

ABEntry::ABEntry(...)
{
  theName = name;
  theAddress = address;
  thePhones = phones;
  numTimesConsulted = 0;
}

Why use constructor-initializers? From C++P 289 and EC++04.

1. Efficient than initialization-and-assignment.

<when-constructor-initializer-is-must> reference-member.
2. By the time the body of ctor begins excuting, init is completed so there are 'three' cases that
must use ctor-init: 

const, reference, and class member that do not have a default ctor.

note: Again the same reason as recommendation on initialization above. For the last case, that is
because will try to use def-ctor for class memeber data when there is no constructor initializer but
there is no def-ctor and 'no' way to init. Hence this is error. This applies to all other cases that
need a def-ctor and that's why def ctor is almost nearly required.

For example, VC shows:
Error 1 error C2512: 'NoDefCtor' : no appropriate default constructor available

<use-constructor-initializer-always>
The examples are:

ABEntry::ABEntry(...)
: theName(name),
  theAddress(address),
  thePhones(phones),
  numTimesConsulted(0)
{
}

ABEntry::ABEntry(...)
: theName(),                  // value-init
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{
}

The constructor initializer is all about making sure that built-in type do not have undefined values
since user type has constructors so no undefined value. Is it overkill when use constructor
initializer for all members since default ctor will be used when omitted? Use constructor
initializer always since:

1. Avoid to remember which memebers may go uninitialized if they are omitted.
2. Cover data members which are const or reference.

<syntax> 
It seems that it must be done in class definition. NO since can be done in memeber definition in cpp
file.

class Derived: public Base 
{ 
  public: Derived( parms ) : Base( parms ), m_xxx(param), ... 
          { ... }
};


{default-arg}
The default argument in function. If a parameter has a default argument, all the parameters that
follow it 'must' also have default arguments. The default arguments are used from right most
arguments that means that user provided arguments are used from left most.

typedef string::size_type sz;
string screen( sz ht = 24, sz wid = 80, char background = ' ' );
string screen( sz ht = 24, sz wid, char background = ' ');           // ERROR

string window = screen();        // == screen( 24, 80, ' ');
string window = screen(66);      // == screen( 66, 80, ' ');
string window = screen(66,256);  // == screen( 66, 256, ' ');

So consider ordering the parameters in declaration so that those lesat likely to use a default value
appear first. See {default-arg-in-virtual} for use inheritance.

class T {
  T() = default;
  T(const string s) : bookNo(s) {}
  ...
  string bookNo;
};

equals to: see there is no default ctor here

class T {
  T(const string s = "") : bookNo(s) {}
  ...
  string bookNo;
};


Two points:
Use carefully as there are logical cases where need to have args from the same source. For
example, it's logical error when one arg is from def init and the other is from the user.


{copy-controls}
copy ctor, copy assign, move ctor(C++11), move assign(C++11)

If not defined, syn version will be created. Don't use syn version of copy controls when
use dyn allocated resource. *kt_dev_cpp_004* 


{copy-constructor} copy-init, pass-by-value
Initialize object from the other of the 'same' type. Ask compiler to copy the right hand operand
into the object being created, and to convert that operand if necessary.

The first arg is a reference to a class and the rest args can be defaults. 

class Foo {
  Foo(const &Foo);   // wrong
  Foo(const Foo&);   // okay
};

Used in contexts:

1. copy form initialization
2. function call pass by value. pass an object as an argument to a parameter of nonreference type.
3. return an object by value, nonreference type. 
4. brace initialization.
5. implicit 'coversion' using temp object. 

For pass and return by value they are rightly non reference type, they are copy-inited. Hence called
copy-ctor. In other words, defines how pass-by-value is implemented for that type.


{direct-and-copy-form-initialization}
// default initialzation. empty
string s1;                 

// direct form of initialzation.
string s2( s1 );           
string dots(10, '.');
string null_book( "9-999-99999-9" );

// copy form of initialzation. 
string null_book = "9-999-99999-9";
string s2 = s1;

<copy-initialization-use-copy-ctor>
The direct form of initialization use ordinary function matching in searching string ctor and the
copy form use copy ctor or move ctor if there is. In both cases, implicit conversion on arguments
can happen.

class MSTR
{
    public:
        MSTR() : mesg() {}

        // MSTR(const string &str) : mesg(str) {}
        // explicit MSTR(const char *pchar) : mesg(pchar) {}

        // copy ctor
        MSTR( const MSTR &mstr )
        {
            cout << "mstr:copy ctor" << endl;
            mesg = mstr.mesg;
        }
};

MSTR m3("mstring three");

: In function int main():
:75:28: error: no matching function for call to MSTR::MSTR(const char [14])
:75:28: note: candidates are:
:40:9: note: MSTR::MSTR(const MSTR&)
:40:9: note:   no known conversion for argument 1 from const char [14] to const MSTR&
:35:9: note: MSTR::MSTR()
:35:9: note:   candidate expects 0 arguments, 1 provided

As you can see, compiler do "function matching" to find the best match. When a class has MSTR(const
        string &) then use this and no errors.

MSTR m3 = "mstring three";

: In function int main():
:76:15: error: conversion from const char [14] to non-scalar type MSTR requested

No function matching and simply use copy ctor but complains about type mismatch of argument.


note:
1. The copy ctor cannot be 'explicit' since used implicitly in cases mentioned above such as pass by
value. 

2. The copy form uses implicit conversion and that means it uses 'converting' constructor to make a
call succeed. If that converting constructor is explicit or is not defined, then cannot make it
succeed and is in error. See "converting ctor" for more.

MSTR m3 = "mstring three";

:78:15: error: conversion from const char [14] to non-scalar type MSTR requested

The C++SLR says that you can't use the assignment notation here because that is considered to be an
implicit conversion.


<synthesized-copy-constructor>
Do 'memberwise' copies the members of its argument. The type of each member determines how that
member is copied. Members of class type are copied by the copy constructor for that class and
members of built-in are copied directly.

class Sales_data
{
    public:
        Sales_data( const Sales_data & );

    private:
        std::string bookNo;
        int units_sold = 0;
        double revenue = 0.0;
};

The equivalent copy constructor that would be synthesized:

Sales_data::Sales_data( const Sales_data& orig ):
    bookNo( orig.bookNo ),          // note: use string copy constructor
    units_sold( orig.units_sold ),  // direct copies orig.units_sold
    revenue( orig.revenue )
{}


<example>
#include<iostream>
#include<string>
#include<memory>

using namespace std;

class Foo 
{
    public:

        Foo()
        { cout << "Foo's def ctor" << endl; }

        Foo( int val ) 
        { fval = val; }

        Foo( const Foo &f )
        { fval = f.fval; cout << "Foo's copy ctor: " << fval << endl; }

        int get() { return fval; }

    private:
        int fval;
};

class FooFoo
{
    public:
        FooFoo(int val) : foo(val) 
        { cout << "FooFoo's ctor: " << val << endl; }

        // note: this is why constructor cannot be a const
        // error: passing 'const Foo' as 'this' argument of 'int Foo::get()' 
        // discards qualifiers [-fpermissive]
        // FooFoo(const FooFoo& arg) const : foo()
        // { cout << "FooFoo's copy ctor: " << arg.foo.get() << endl; }

        // note: calls foo's copy constructor.
        // FooFoo(const FooFoo& arg): foo(arg.foo) 
        // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

        // note: calls foo's default constructor. value-init
        // FooFoo(const FooFoo& arg): foo() 
        // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

        // note: calls foo's default constructor. value-init
        // FooFoo(const FooFoo& arg) 
        // { cout << "FooFoo's copy ctor: " << foo.get() << endl; }

    private:
        Foo foo;
};

int main()
{
    FooFoo ax(100);
    FooFoo bx(200);

    FooFoo cx = bx;

    // note: this direct from also has the same call as above. calls copy constructor.
    FooFoo cx(bx);
}


<why-reference-parameter>
Why the copy constructor's own parameter 'must' be a reference? If it is not a reference, then the
call would never succeed. To call the copy constructor, need to use copy constructor to copy the
argument and to copy the argument, need to use copy constructor. indefinite recursive call.


{pass-by-reference-to-const} EC++20.

class Person {
  ...
  private:
    string name;
    string address;
};

class Student: public Person {
  ...
  private:
    string schoolName;
    string schoolAddress;
};

When call this, it costs '6' ctor and dtor:

bool validateStudent(Student s);

Student plato;
validateStudent(plato);

To bypass these cost of copying:

bool validateStudent(const Student& s);

The points: 

1. Less expensive since no object creation so more 'performance'. Typically, references are
implemented as pointers. <key> So recommendation is that use pass-by-value for built-in, STL
iterator, and function objects types and use pass-by-reference for class types.

2. The const is necessary since in pass-by-value case, the caller know that they are shielded from
any changes the function might make. To have the same for pass-by-reference, need const. 

3. Avoid <sliced-off> problem. For example:

class Window {
  public:
    ...
    std::string name() const;
    virtual void display() const;
};

class WindowWithScrollBars: public Window {
  public:
    ...
    virtual void display() const;
};

void printNameAndDisplay(Window w)  // see
{
  std::out << w.name();
  w.display();
}

WindowWithScrollBars wwsb; 
printNameAndDisplay(wwsb);

Which version of display will be called? It will 'always' be the Window::display since it is
pass-by-value using Window copy ctor and is sliced-offed. Hence Window object. To fix this, should
use pass-by-reference.

void printNameAndDisplay(const Window& w)
{
  std::out << w.name();
  w.display();
}

EC++21. The pass-by-reference is great. Then always use reference? However, there are cases that
must return a copy not a reference such as operator*(). This is a operator* not dereferene operator.
See {smart-pointer-internal}. Q: How distinguish between two?

These are tries to save a construction cost by using pass-by-reference but not right:

<1> use stack but remember a refenrece is a name for some 'existing' object. Here returns a
reference to object that no longer exist.

Rational c = a*b;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational retult( lhs.n*rhs.n, lhs.d*rhs.d );
    return result;
  }
};

<2> use heap? there is no way to delete in case: 
Rational w, x, y, z;
w = x*y*z;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational *retult = new Rational( lhs.n*rhs.n, lhs.d*rhs.d );
    return *result;
  }
};

<3> use function static? Not right for multi-threaded and even for single-threaded.

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    static Rational retult;
    ...
    return result;
  }

  bool operator==( const Rational& lhs, const Rational& rhs);
};

Rational a, b, c, d;

if( (a*b) == (c*d) )
{
  ...
}

This will always true since it is evaluated as
if( operator==( operator*(a,b), operator*(c,d) ) )

Therefore, in summary, should return a copy and pay a small cost for correct behavior.

class Rational {
  friend const Rational operator*( const Rational& lhs, const Rational& rhs );
  ...
};


{copy-assign} deleted-copy-controls. reference-member.
As with copy constructor, cannot use syn version when there are reference and const member data.
Why? because syn copy assign is defined as 'deleted' if the class has a const or reference member.
C++P p508

It uses op overloading and must be a 'member' because 'lhs' is this pointer.

class Foo {
  Foo& operator=(const Foo&);
};

The copy-assign controls how objects of its class are assigned

Sales_data trans, accum;
trans = accum;

For assign with different types, need additional assign op and see *kt_dev_cpp_021*

<assignment-must-return-a-reference-to-this>
EC++10. All assign ops must follow this convention like built-in types because of 'chain' of
assignment and should behave the same as built-in types.

x = y = z = 15;   // right associative

Widget wx, wy, wz;
wx = wy = wz = DefaultWidget;

class Widget {
  public:
    Widget& operator=( const Widget& rhs )
    {
      ...
        return *this; ~
    }
};


{avoid-unnecessary-default-ctor}
From MEC++04. There are two categories:

1. For class that can be inited meaningfully without inputs from outside, do use default-ctor.
2. For calss cannot be inited meaningfully without inputs from outside, recommend not to use
default-ctor.

TODO: more on problems and example

For example, think a class which has ID info and use default-ctor. This causes

o Limit a use of class since not able to use array of it.
o There should be checks in each member funcs to see if it is inited with a meaningful initial value
for ID. This means more error checking, handling and penalty of size and speed.

That means that a user provide a meaningful init value but once inited, can see efficient
implementation.

<example>
struct SomeLargeData {

  SomeLargeData(int id_)
    : id(id_)
  { cout << "Foo[" << this << "] ctor(" << id << ")" << endl; }
  ~SomeLargeData() { cout << "Foo[" << this << "] dtor(" << id << ")" << endl; }
  int id;
  int arr[100];
};

int main()
{
  uint64_t be, af;
  int n = 400;

  vector<SomeLargeData> vec_byval;
  vec_byval.push_back( SomeLargeData(100));     // note. this is copy-ctor
}

Foo[0xbfc60f4c] ctor(100)
Foo[0xbfc60f4c] dtor(100)
Foo[0x9aba008] dtor(100)


{ctor-use}
From C++BS 8.2.3. Constructors are needed if you need to reorder arguments, validate arguments,
modify arguments. For example:

struct Address {
  string name; // "Jim Dandy"
  int number; // 61
  string street; // "South St"
  string town; // "New Providence"
  char state[2]; // N J
  char zip[5]; // 07974

  Address(const string n, int nu, const string& s, const string& t, const string& st, int z);
};

note: this is a case to modify arguments and see conversion from

struct Address {
  ...
  char state[2]; // N J
  char zip[5]; // 07974

  Address(..., const string& st, int z);
};


={============================================================================
*kt_dev_cpp_004* copy controls of dyn resource. valuelike. preventing-copies. swap and move example

{when-use-resource-has-dyn-lifetime}
1. don't know how many object is needed
2. don't know the exact type of object
3. share data between objects


{the-rule-of-three-or-five}
The rule of three (the rule of five in C++11) is a rule of thumb in C++ that claims that
if a class defines one of the following it should probably explicitly define all three:[1]

dtor, copy-ctor, and copy-assign operator

<case-example> C++P p505
The need of own dtor for a class allocating dynamic resources is obvious. Since if there's no dtor
defined, the syn dtor will not run delete on the pointer, ps, so must define own dtor. how possibly
the compiler can know what pointer member points to?

The need of own copy ctor and assign is less clear. See what will happen when use syn versions of
copy and assign. 

class HasPtr {
  public:
    HasPtr(const std::string& s = std::string() )  // def arg. 
      : ps( new std::string(s)), i(0) {}

    ~HasPtr() { delete ps; }

  private:
    std::string* ps;
};

<not-a-choice-of-style>
What are the problems? The syn versions does not operate well for a class using dyn resource.

HasPtr func(HasPtr hp)  // value and member-wise copy using a syn copy ctor.
{
  HasPtr ret = hp;      // a syn copy assign. ret and hp points the same.
  ...
  return ret;           // 'double' free on ret and hp, when exit a call
}

There still is an issue even if there is no return:

HasPrt p("...");
void func(p);
// p and func's arg points the same. when func exits, func's arg is deleted and p has invalid
// pointer which was already deleted after func().

HasPrt q(p);
// p and q have invalid pointer.

So must define copy-ctor and copy-assign as well. Two methods on what copying an object will 'mean':
valuelike or pointerlike (what we do when copying pointer member)

For the same reason in constructor initializers in *kt_dev_cpp_003* must define copy controls when
there are const and reference members because compiler will not create syn versions since cannot
'rebind' const and reference. <Q> How to define user copy controls for these cases? real use case?


{construct-and-copy-all-parts-of-an-object}
EC++12. When having own copy functions(copy-ctor and copy-assign), then means that you shall have
full responsibility for copying. Two cases: 

1. When add member variables to a class.

Customer& Customer::operator=( const Customer& rhs )
{
  name = rhs.name;
  return *this;
}

If add new member data, then must update 'all' copy functions and ctors too. Otherwise, have copy
functions to copy 'parts' of object.

2. When defines copy functions for derived class. Be 'careful' to handle 'base' part as well because
having own copy controls means to have full responsibilities of doing it.

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs )
  :priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  {
    priority = rhs.priority;
    return *this;
  }
};

<problem>
These do nothing about base part and that means: For construction, PriorityCustomer ctor will use a
default ctor of Customer and Customer part will be default init. For copy, PriorityCustomer
copy-ctor will do nothing on Customer part and it will remain unchanged. So shall be:

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs ) 
  :Customer(rhs),~
  priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  { 
    Customer::operator=(rhs); ~
    priority = rhs.priority;
    return *this;
  }
};


{valuelike} deep-copy, self-contained-object
The copy and the original are independent since copy underlying object as well. note: library containers
and string use valuelike copy

class HasPtr {
  public:
    HasPtr(const std::string& s = std::string() )  // def arg. 
      : ps( new std::string(s)), i(0) {}
    >
    // copy ctor
    HasPtr(const HasPtr& p):
        ps( new std::string( *p.ps ));

    HasPtr& operator=(const HasPtr& p);

    ~HasPtr() { delete ps; }

  private:
    std::string* ps; 
    int i;
};

Think about self-assign and exception safe. The below covers self-assign and exception-safe.
See *kt_dev_cpp_019* for self-assign and exception

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}


{pointerlike} shallow-copy, own-reference-counting
The copy and the original share underlying object like shared_ptr. To show own reference counting:

class HasPtr {
  public:
    // see default arg and new size_t
    HasPtr(const std::string& s = std::string() ) 
        : ps( new std::string(s)), i(0), use( new std::size_t(1) ) {}

    // if separate constructors in two. the difference is a cost of temporary.
    // HasPtr() 
    //     : ps( new std::string()), i(0), use( new std::size_t(1) ) {}

    // HasPtr(const std::string &s) 
    //     : ps( new std::string(s)), i(0), use( new std::size_t(1) ) {}

    HasPtr(const HasPtr& p): ps( p.ps ), use( p.use ) { ++*use; };

    HasPtr& operator=(const HasPtr& p);
    ~HasPtr();
      
  private:
    std::string* ps;
    std::size_t* use; 
};

HasPtr::~HasPtr()
{
   if( --*use == 0 )
   {
      delete ps; delete use;
   }
}

The copy assign do dtor and copy constructor. handle self-assign

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use;

  // lhs
  if( --*use == 0 )
  {
    delete ps; delete use;
  }

  ps = rhs.ps;
  use = rhs.use;

  return *this;
}


{copy-control-for-bookkeeping} message class example
C++P p519. Although copy control is most often needed for classes that allocate resources, that is
not the only reason and some class have bookkeeping or other actions that copy control must perform.

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set
...                                  ...

<lits-of-operations-message-class> how to sketch a class
o To keep track of which Message are in which Folders, each message has a set of pointers to Folders
and each Folder will have a set of pointers to its Message.

note: Why set of pointers for Message and Folder? This example have seperate interface for Folder
and Message and if do operations on Message, there is a need to update Folder as weel such as
deleting a Message. So need to have a set for each object.

o Message class provide save and remove operations to add or remove a Message from a specified
folder. To create a new Message, specify the contents of the message but no folder. To put a message
call save. note: Why? Can have ctor(Folder&) but needs remove() member anyway. So better to have
save and remove pair?

o To copy a message, the copy and the original will be distinct and be in the same 'set' of Folders.
Thus will copy the contents and Folder-set; copying-set. To appear in the same Folders as the
original message, must traverse the Folder-set to add a pointer to the new into each Folder.
traverse().

o To destroy a Message, remove pointers to that from the Folders. traverse().

o To assign a Message, will replace the contents and also update Folder-set of lhs by removing lhs
Message from lhs Folder-set and adding that Message to rhs Folder-set. traverse().

Looking at this list of operations, both the dtor and the copy assign have to 'remove' this Message
from the Folders. Both the copy ctor and the copy assign 'add' a Message to a given list of Folders.

<copy-assign-do-dtor-and-copy-ctor>
The copy assign often does the same work as is needed in the copy ctor and dtor. In such case the
'common' work should be put in private utility functions.

class Message {
  friend class Folder;

  public:
  // folders is implicitly initialized to the empty set
  explicit Message( const std::string &str = "" ): contents(str) {}

  // copy controls to manage pointers to this message
  Message( const Message& );
  Message& operator=( const Message& );
  ~Message();

  // add/remove this message from the specified Folder's set
  void save(Folder&);
  void remove(Folder&);

  private:
  std::string contents;
  std::set<Folder*> folders;

  void add_to_Folders( const Message& );
  void remove_from_Folders();
};

void Message::save( Folder& f )
{
  folders.insert( &f );    // add the given Folder to our list of Folders. note: &f is pointer.
  f.addMsg(this);          // add this Message to Folder's set of Message.
}

void Message::remove( Folder& f )
{
  folders.erase( &f );    // remove the given Folder to our list of Folders. note: &f is pointer.
  f.remMsg(this);         // remove this Message to f's set of Message.
}

void Message::add_to_Folders( const Message &m )   // m is the original
{
  for( auto f : m.folders )
    f->addMsg(this);
}

void Message::remove_from_Folders()
{
  for( auto f : folders )
    f->remMsg(this);

  folders.clear();
}

// copy ctor. <copying-set>
Message::Message( const Message &m ) : contents(m.contents), folders(m.folders)
{
  add_to_Folders(m);
}

// dtor
Message::~Message()
{
  remove_from_Folders();
}

// copy assign which do copy ctor and dtor. 
Message& Message::operator=(const Message& rhs)
{
  remove_from_Folders();   // for lhs

  contents = rhs.contents;
  folders = rhs.folders;   // <copying-set>

  add_to_Folders(rhs);

  return *this;
}

note:
Handle self-assign by removing pointers to this message from lhs before inserting pointers to rhs.
If do inserting first, adding has no effect since adds the same address(message) to a set in a
folder. So would have removed this from 'all' of its corresponding Folders.

Again, HasPtr example for self-assign and exception safe. 

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

This handles "rhs" first and "lhs" later. However, this message example do "lhs" first. So
self-assign and exception safe is 'context' dependant.


<swap-consideration>
Since the library string and set defines own swap, Message class will benefit from defining own
version of swap to avoid extraneous copies of 'folder' set member.

However, must update a set of pointers that Folders have since after a swap(m1, m2) call, the
Folders that had pointed to m1 must now point to m2.

void swap( Message &lhs, Message &rhs )
{
  // not necessary in this case but good habit.
  using std::swap;

  // first pass. remove pointers to each message from Folders
  for( auto f: lhs.folders )
    f->remMsg(&lhs);
  for( auto f: rhs.folders )
    f->remMsg(&rhs);

  swap( lhs.folders, rhs.folders );       // swap(set&, set&). set::swap
  swap( lhs.contents, rhs.contents );     // swap(string&, string&). string::swap

  // second pass. add pointers to each message from Folders
  for( auto f: lhs.folders )
    f->addMsg(&lhs);
  for( auto f: rhs.folders )
    f->addMsg(&rhs);
}


<move-consideration>
By defining move operations, the Message class can use string::move and set::move operations to
avoid the overhead of copying the contents and folders members.

As with copy and swap, moving must update each Folder and both move ctor and assign need to update
Folder pointers. So make it common work.

// move Folder pointers 'from' m 'to' this message
void Message::move_Folders(Message *m)
{
    // note: use set move assign rather than copy, folders = m->folders
    folders = std::move(m->folders);  

    // note: use 'folders' for both add and remove but not m.folders
    for( auto f : folders ) 
    {
        f->remMsg(m);
        f->addMsg(this);
    }

    m->folders.clear();      // ensure that destroying m is harmless
}

note: that inserting an element to a set might throw since it requires memory to be allocated. As a
result, unlike HasPtr and StrVec case, will not mark move operations as noexcept. Q: whether or not
noexcept is necessary requirement on move operations? 

// move ctor
Message::Message( Message &&m ) : contents(std::move(m.contents))    // string::move
{
  move_Folders(&m);
}

// move assign
Message& Message::operator=( Message &&rhs )
{
  if( this != &rhs )    // direct check for self-assign
  {
    remove_from_Folders();    // destroy the old state of lhs
    contents = std::move( rhs.contents );
    move_Folders(&rhs);
  }

  return *this;
}


{preventing-copies} delete-keywords
Primus p507 and EC++06. How can define a class to prevent copy or assign like iostream class? Do not
defining copy controls? This do not work as syn version will be made. Two ways: delete keyword and
private access control.

<delete-keyword> since C++11
Signal to the compiler not to define these members and lead to compile error when try to use it. Or
syn version will be deleted when compiler cannot make it.

struct NoCopy {
  NoCopy() = default;
  NoCopy(const NoCopy&) = delete;                 # NO copy-ctor 
  NoCopy& operator=(const NoCopy&) = delete;      # NO copy-assign
  ~NoCopy() = default;
  ...
};

<private-copy-control> before C++11
class PrivateCopy {
  private:
    // declare but not define ~
    PrivateCopy(const PrivateCopy&);
    PrivateCopy &operator=(const PrivateCopy&);

  public:
    ...
};

This is an example and see errors when use private to prevent copies and note that won't compile
regardless of whether there is copy control definition(implementation) in base class.

#include <iostream>

using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  private:
    int m_iDataABCAnimal;
    Base(const Base& base) { cout << "copy-ctor: base" << endl; }                // 11
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

class D : public Base
{
  public:
    void getShout() { cout << "derived get shout" << endl; };
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base b1, b2;

  Base b3(b1);       // note: 01. line: 21

  D d1, d2;

  d1.getShout();

  d2 = d1;           // note: 02

  std::cout << "--} main " << std::endl;
}

note: 01
use-prevent-copy.cpp: In function int main():
use-prevent-copy.cpp:11:4: error: Base::Base(const Base&) is private
use-prevent-copy.cpp:21:12: error: within this context

note: 02
base.cpp: In function int main():
base.cpp:33:8: error: use of deleted function D& D::operator=(const D&)
base.cpp:15:7: error: D& D::operator=(const D&) is implicitly deleted because the default definition would be ill-formed:
base.cpp:12:10: error: Base& Base::operator=(const Base&) is private
base.cpp:15:7: error: within this context


<friend-can-access> 
However, friend and members still can access private. How to prevent this? Use link error by not
defining in addition to private trick.

using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  public:
    int m_iDataABCAnimal;
    Base(const Base& base);      // NO definition
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

int main()
{
  Base b1, b2;

  Base b3(b1);
}

$ ./comp.sh use-prevent-copy.cpp 
/tmp/ccskAMRR.o: In function `main':
/home/kit/work/use-prevent-copy.cpp:22: undefined reference to `Base::Base(Base const&)'
collect2: ld returned 1 exit status

note: summary

o To prevent access from derived classes, make copy control private and cause compile error.

o To prevent access from friend or members, so declare copy controls but not define. By doing this,
  can cause 'link' errors when there are attempts to use. Because when used, compiler will try to
  link but no definition. The example is ios_base, basic_ios, and sentry of STL implementation.


<boost-noncopyable>
EC++06. For a easy use of adding preventing copy features discussed above, use uncopyable class as a
base which is boost::noncopyable. This has couple of consideration for inheritance.

#include <iostream>

class Uncopyable {
  protected:                                                   // note
    Uncopyable() {}
    ~Uncopyable() {}

  private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};

// class Foo : public/protected Uncopyable {                   // note
class Foo : private Uncopyable {                               // line 13
  public:
    void WhoAmI() { std::cout << "foo" << std::endl; }
};

int main()
{
  Foo f;
  f.WhoAmI();

  // errors only when add followings
  Foo o;
  o = f;                                  // line 26
}

use-noncopy.cpp: In function int main():
use-noncopy.cpp:26:6: error: use of deleted function Foo& Foo::operator=(const Foo&)
use-noncopy.cpp:13:7: error: Foo& Foo::operator=(const Foo&) is implicitly deleted 
   because the default definition would be ill-formed:
use-noncopy.cpp:10:17: error: Uncopyable& Uncopyable::operator=(const Uncopyable&) is private
use-noncopy.cpp:13:7: error: within this context

note: Why protected on ctor and dtor? Only possible to create it via inheritance. e.g. derived
class.

note: Regardless of inheritance type, won't compile. Why shouldn't be public? Since it is not is-a
relationship and the case use is 'private'.

note: Why not virtual dtor in base? By using protected dtor, make it error to use delete on base but
able to run dtor via derived class. See non-virtual-destruction-problem. 

<Q> Why this error on calling test_f()? Since use of reference parameter do not cost copy
constructor, what calls are involved here?

error: 'Uncopyable' is an inaccessible base of Foo

void test_f( Uncopyable &uc )
{
    uc.WhoAmI();
}

int main()
{
    Foo fo;
    test_f(fo);
}


{self-assign}
EC++11. When implement copy-assign, must think about self-assign and exception-safe. See
{self-assign-exception-safe} in *kt_dev_cpp_019*

Why? because there are 'less' obvious self-assignment cases and are the result of aliasing: having
more than one way to refer to an object.

<one> aliasing

a[i] = a[j];   // potential assign to self when i==j
*px = *py;     // potential assign to self when point to the same

<two> aliasing in same class hierarchy since base ptr can point to derived. Here, rb and *pd might
actually be the same.

void doSomething( const Base& rb, Derived* pd );


={============================================================================
*kt_dev_cpp_005* converting ctor

{converting-ctor}
The converting-ctor is a coversion 'to' class type from other type and conversion op is a conversion
to the other.

class T {       <- from other type to T. converting-ctor
   ...          -> from T to other types. conversion-op
};

The converting ctor is 'every' ctor with single argument and do 'implicit' conversion from arg type
to class type. 

class Sale_data {

   combine(const Sales_data&);
   Sales_data(const std::string &s);
   Sales_data(std::istream &);

};

string null_book;

item.combine(null_book);
item.combine(cin);

The combine() expect Sales_date type but it is given a string and istream. How can make it work? The
compiler do implicit conversion to make a call succeed and creates a temporary Sales_data object. So
this equates to:

item.combine(Sales_data(str));


{implicit-conversion}
See *kt_dev_lang_009* for built-in conversion. The converting-ctor and conversion-op are called
"class-type-conversion".


<only-single-conversion-allowed>
The compiler will do only 'one' "implicit conversion" and the following is error.

item.combine("9-999-99999-9");

Since this requires two conversion to make it succeed.

item.combine(string("9-999-99999-9"));
item.combine(Sales_data("9-999-99999-9"));


<why-explicit-keyword>
Whether the conversion is desiable depends on how users wil use the conversion. Also, When combine
finishes, temporary is gone and lost input. To avoid this, can use explicit-keyword:

class Sales_data {

  'explicit' Sales_data(const std::string &s);
  combine(const Sales_data&);

};

Now have to use it 'explicitly':

item.combine( Sales_data(null_book) );                   // T()
item.combine( static_cast<Sales_data>(cin) );


note:
1. So explicit-keyward 'supress' conversion or use of constructor in a context that requires an
implicit conversion.

2. The explicit-keyword is 'meaningful' only on constructors that can be called with a 'single'
arguments since constructors with more arguments are 'not' used to perform an implicit conversion.

3. The explicit-keyword is used only in constructor 'declaration' inside a class.


<errors>

class Base {
  public:
    explicit Base(const string &s) : mesg(s) {}
    // Base(const string &s) : mesg(s) {}
    void message( const Base & b ) 
    { 
      cout << "base: " << b.mesg << endl;
      cout << "base: " << mesg << endl; 
    }

  private:
    string mesg;
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base ba(string("iam base"));
  Base baa = string("iam base two");            <2>

  ba.message(string("this is mesg for base"));  <1>

  std::cout << "--} main " << std::endl;
}

<1>
sam03.cpp:24:45: error: no matching function for call to Base::message(std::string)
sam03.cpp:24:45: note: candidate is:
sam03.cpp:9:10: note: void Base::message(const Base&)
sam03.cpp:9:10: note:   no known conversion for argument 1 from std::string {aka std::basic_string<char>} to const Base&

<2>
sam03.cpp:25:35: error: conversion from std::string {aka std::basic_string<char>} to non-scalar type Base requested

<avoid-implicit-conversion>
From MEC++05. Recommend to use a member func to do the same.

<problem-case>
template< typename T>
class Array {
  public:
    Array(int lowBound, int highBound);
    Array(int size);
    ...
};

bool operator==(const Array<int> &lhs, const Array<int> &rhs );

Array<int> a(10); Array<int> b(10);

for( int i=0; i < 10; ++i )
  if( a == b[i] ) {        # meant to be a[i] == b[i]
    ...
  }
  else {
    ...
  }

There is no match candidate, ( operator==( Array< int>, int ), and compiler do convert the second
arg to Array because there is converting-ctor. This is the same as:

if( a == static_cast< Array<int>> (b[i]) )

This causes a creation and deletion of unknowm number of Array objects for each iteration. How to
prevent this?

<key> 
The implicit conversion is not always useful since temporary is made. More expensive, lost
state(input), or making changes on temporary. So the point is about making it explicit in code and
forcing user to know what they are doing.

<stl-example-of-explicit>
The vector<T> v(number) is explicit so the following is in error.

explicit container::container (size_type num)
- Creates a container with num elements.
- The elements are created by their default constructor.
- Provided by vector, deque, list, forward list.

// x.member(vector<string>& vec);
x.member(10);  // error


{conversion-op}
This is conversion from class type to other type. Use overloading and the form is:

operator T() const;

class SamallInt {
  public:
    'explicit' operator int() const { return val;}

  private:
    std::size_t val;
};

To avoid following problem, use explicit keyword:

int i = 42;
cin << 42;

There is no << operator in cin but there is conversion to bool. So works as if depending on the cin
state; 0 or 1.

0 or 1 << 42;


<conversion-to-bool>
However, even if uses explicit, this explicit has no effect when used in condition such as:

if, while, for and do statements. logical operators. conditional operators.
 
Why this exception? Conversion to bool is 'intended' for use in conditions and hence ordinarily
should be defined as explicit to avoid problems in other uses:

while( std::cin >> value )

It reads into value, 'return' cin, and  cin converted to bool depending on cin state. This bool
conversion is the typical use of conversion-op.

note: In earlier version of the library, the IO types defined a conversion to void and under the new
standard, instead defines an explicit conversiton to bool.


<class-state>
note. Like cin, seems useful to have bool conversion when class has 'state'.


={============================================================================
*kt_dev_cpp_006* swap 

{why-swap}

1. efficiency
Better performance for valuelike class that used by algorithm such as reorder elements and remember
that STL assumes copy context. note: requires copy assign.

Since valuelike swap is expensive, need to have better way and efficient way to do it; not to swap
all elements but swap its internal structure. Constant-time operation. 

So the approach is that if type defines its own swap then STL use it and if not, use std::swap from
library. Means that STL is implemented to use type's swap and if there isn't, use std::swap.

For pointerlike class, no need sind std::swap do what it is requireds; swaps pointers. 

2. exception-safety

Like STL containers, provide both memeber and non-member swap. To have the member version swap never
throw exception (because it use swap on built-in types that never throw exception.) This offers the
strong excepiton-safety gurantee.


<typical-swap>
The typical swap involves "one copy and two assignments"

T temp = v1;
v1 = v2;
v2 = temp;


<nonmember-friend-swap> C++P p516. non-member and friend swap.
Take "valuelike" example from kt_dev_cpp_004 and see how swap can be uses in copy assign.

class HasPtr {

  friend void swap( HasPrt&, HasPtr& );               // note: friend

  public:
   HasPtr(const std::string& s = std::string() )
    : ps( new std::string(s)), i(0) {}
        
   ~HasPtr() { delete ps; }

  private:
   std::string* ps;
};

inline void swap( HasPtr& lhs, HasPtr& rhs )
{
  using std::swap;                                    // note:  
  swap( lhs.ps, rhs.ps );
  
  OR 

  std::swap( lhs.ps, rhs.ps );
}

note: 
Although doesn't matter in this case since there is no type specific swap for built-in types because
ps is a pointer to string, 'must' use swap() but not std::swap() to try type specific version first.


<how-finding-swap-work>
How "try type version and std version next" works? Two things:

{
    using std::swap;
    swap( T, T );
}

1. Type specific version is better match in function matching and std::swap is template.
2. Use 'arg-dependent-lookup' in *kt_dev_cpp_007* in swap( HasPtr&, HasPtr& ).

note: 
Why not "using std::swap" hide swap(T)? Since arg-dependant-lookup adds swap(T) in to search which
is better match than std::swap.


<copy-and-swap-idiom>
To rewrite using copy-and-swap-idiom which is exception-safe code which automatically handle
self-assign

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

To rewrite using copy-and-swap-idiom: <Q> does swap change const HasPtr?

HasPtr& HasPtr::operator=(const HasPtr rhs)  // note. not ref and it's copy so copy ctor used.
{
  swap(*this, rhs);
  return *this;      // rhs is destroyed, which deletes the old ps.
}

Also EC++11 says the compiler can generate more efficient code by moving copying from the function
body to parameter construction. 

<Q> does swap change const HasPtr?


{define-swap-use-specialisation}
EC++25. pimpl-idiom. See *kt_dev_ecpp_008* for pimpl-idiom.

class WidgetImpl {                           // class for Widget data;
   public:                                   // details are unimportant
      ...

   private:
      std::vector<double> v;                 // possibly lots of data expensive to copy!
};

class Widget {                               // class using the pimpl idiom
   public:
      Widget(const Widget& rhs);
>
      Widget& operator=(const Widget& rhs)      // to copy a Widget, copy its
      {                                         // WidgetImpl object. For
       ...                                      // details on implementing
       *pImpl = *(rhs.pImpl);                   // operator= in general,
       ...                                      // see Items 10, 11, and 12.
      }
<
   private:
      WidgetImpl *pImpl;                        // ptr to object with this
};                                              

Imagine how expensive it may be when there's no swap for Widget and when use std::swap:

Widget A, B; swap(A,B);

All we really need to do is swap their pImpl pointers, but the default swap algorithm has no way to
know that. Instead, it would copy not only three Widgets, but also three WidgetImpl objects. Very
inefficient. In other words, cost three copies that use 'operator=' of valuelike class. For some
types such as pimpl-idiom, none of these copies are really necessary. How to avoid these cost? To
address this, should provide 'type' 'specific' swap to be used by clients:

<attempt-one> total-template-specialization

namespace std {

  template<typename T>          // typical implementation of std::swap;
  void swap(T& a, T& b)         // swaps a's and b's values
  {
    T temp(a);
    a = b;
    b = temp;
  }
}

This is a way to say that to specialize std::swap for Widget. This is called 'total' template
specialization. Why? Since it specify T as Widget so it is from generic to speficic one. 

namespace std {                              // note see in 'std'

  template<>                                 // this is a specialized version of std::swap when T is Widget
  void swap<Widget>(Widget& a, Widget& b)    // note syntax
  {
    swap(a.pImpl, b.pImpl);                  // to swap Widgets, just swap their pImpl pointers
  }
}

We are 'not' permitted to 'alter' the contents of the std namespace, but we are allowed to totally
specialize standard templates (like swap) for types of our own creation (such as Widget).

This function will not compile. That is because it is trying to access the pImpl pointers inside a
and b, and they are 'private' so other ways might be:

1. could declare our specialization a friend, but the convention is different: so not
consider. 

2. have a public swap member and specialized std::swap calls this member swap. 'okay' since do not
use friend here.

class Widget {                     // same as above, except for the
public:                            // addition of the swap mem func
  ...
  void swap(Widget& other)
  {
    using std::swap;               // the need for this declaration is explained later in this Item

    swap(pImpl, other.pImpl);      // to swap Widgets, swap their pImpl pointers
  }
  ...
};

namespace std {

  template<>                       // revised specialization of std::swap
  void swap<Widget>(Widget& a, Widget& b)
  {
    a.swap(b);                     // to swap Widgets, call their swap member function
  }
}

<attempt-two> use-template-specialization for class template
However, suppose that Widget and WidgetImpl were class templates instead of classes. Needs more
generic solution but cannot use the same as before since the specialization would look like:

namespace std {

  template<typename T>                       
  void swap<Widget<T>>(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);                     // to swap Widgets, call their
  }                                // swap member function
}

This is 'illegal' code since C++ do not allow 'partial' specialization for function template. If this is
possible, then it means that can add a template into std namespace.

The overloading function-template is fine, but std is a special namespace, and the rules governing
it are special, too. It's okay to totally specialize templates in std, but it's not okay to add new
templates (or classes or functions or anything else) to std. Undefined behavior.

<attempt-three> solution
This works as well for classes as for class templates. Just don't declare the non-member to be a
specialization or overloading of std::swap.

namespace WidgetStuff {
  ...                                     // templatized WidgetImpl, etc.

  template<typename T>                    // as before, including the swap member function
  class Widget { ... };                   

  ...

  template<typename T>                    // non-member swap function. not part of the std namespace
  void swap(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);
  }
}

This use swap(Widget<T>&, Widget<T>&) through {arg-dependent-lookup}

<why-using-std-swap>
What you desire is to call a type-specific version if there is one, but to fall back on the general
version in std if there's not. Here's how you fulfill your desire:

template<typename T>
void doSomething(T& obj1, T& obj2)
{
  using std::swap;           // make std::swap available in this function
  ...
  swap(obj1, obj2);          // try the best swap for objects of type T via ADT(arg-dependent-lookup)
  ...
}

There are important subtleties:
1. use unqualified swap to search for class-specific swap version
2. use using std::swap to make it visiable in current scope so fall back on std::swap when there is
no class-specific version.

<attempt-four> attempt-treee and plus std::swap specialization when write class but not class templeate
Why? To cover possible wrong use like:

std::swap(obj1, obj2);

This force compiler to consider only the swap in std including any template specialization. In
addition to the type specific swap in a class, have specialized std::swap to call member swap. This
is to make type-specific swap implementations available to code written in this fashion.

{real-case}
<example> used attempt-three and stl-vector-code taken from vector template in gcc

As shown the reference, to provide special implementations for more complex types by using function
overloading.

<member>
template<typename _Tp, typename _Alloc = std::allocator< _Tp >>
class vector : protected _Vector_base<_Tp, _Alloc>
{
  ...

    /**
     *  @brief  Swaps data with another %vector.
     *  @param  x  A %vector of the same element and allocator types.
     *
     *  This exchanges the elements between two vectors in constant time.
     *  (Three pointers, so it should be quite fast.)
     *  Note that the global std::swap() function is specialized such that
     *  std::swap(v1,v2) will feed to this function.
     */
    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
          __x._M_impl._M_end_of_storage);

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 431. Swapping containers with unequal allocators.
      std::__alloc_swap< _Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
    }
  ...
} # end of class template

<nonmember>
The key is that this is 'overloaded' global swap() for 'this' type. That means that every container
has member and nonmember swap.

/// See std::vector::swap().
template<typename _Tp, typename _Alloc>
  inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
  { __x.swap(__y); }


{swap-usuage}
There are two use cases:
<1>

As with "Widget A, B; swap(A,B);"

vector<string> svec1(10);
vector<string> svec2(24);

swap( svec1, svec2 );

Which swap will this call? The type specific which is nonmember in vector because ADT try to find
nonmember swap in std namespace and leads to call member swap as seen vector code above. This is why
nonmbmer swap is introduced in the first place. 

<key> Primers p339. In C++, STL container provides member and non-member swap and previously
supports member only.

<2>
As with an example of copy-and-swap-idiom, to implement class copy controls. 

<Q> The reference says that this is std::swap implementation
The function swap() is provided to swap the values of two objects. The general implementation of
swap() is defined in <utility> as follows

namespace std {
  template <typename T>
    inline void swap(T& a, T& b) ... {
      T tmp(std::move(a));
      a = std::move(b);
      b = std::move(tmp);
    }
}

So which one is better between type specific swap or std::swap given move sementics are supported by
all containers?


={============================================================================
*kt_dev_cpp_007* function matching and overload

{function-matching}
Also known as overload resolution. The name has 'scope' and object has 'lifetime'. Three possible
outcomes: best match, no match, and ambiguous call. For overload condition, see {const-on-overload} 

note: step 0 and 1 is called <normal-scope-or-name-lookup>?

step-0: <search> search namaspace or class
For lookup of names inside a namespace, look in members in case class, and if not found, continue
looking in enclosing scope; which is a open scope having a name to look up. This can be block,
class, or namespace. So continue looking in classes up the chain of inheritance or
namespaces. This search goes upwards that means declared before use and before in reading
order. For example, int A::C1::f3() in qualified name. Plus use {arg-dependent-lookup} for
class type, reference, and pointer. For non-class, enclosing scope that is before the point
of use and is still open. See Primers p797. 'using' declaration or directive add names to
the candidate set. If found the name, the compiler looks no further.

step-1: <build-candidate> use name and build candiate of overloads and template instantiations
Use 'name' only hence called name-lookup. Build candidate functions which is the set of overloaded
functions and should be the same name and visible. Include any function-template instantiation for
which template arg deduction succeeds.

step-2: <build-viables>
Use the number of arguments, type match, and conversion to get viable functions.

step-3: <find-best-match> prefer best and nontemplate
The exact match is better than a match that requires a conversion. non-template func is selected if
there's only one in the set. if not, more specialized func template is called. otherwise, the call
is ambiguous.

step-4: <check-access>
See accessibilty in case of inheritance. From EC++40

step-5: <virtual-or-not>
If it is virtual, generate a code for run-time binding. otherwise, generate a normal call.


{wider-candidate-set-op-overload}
a op b

is nothing to say about whether it calls member or non-member op overload. so the set is wider to
both member and non-member to be considered.  


{scope-and-search}
The search looks 'outwards' or 'upwards' through the 'enclosing' scopes which are declared 'before'
the point of use and are still 'open'. The enclosing scopdes are blocks, namespaces, and base
classes and search goes upwards and ends 'global' namespace. Hence 'hiding' name can happen.


<in-inheritance>
C++P p617. Hierarchical nesting of class scope; this means that the derived is nested in the base
scope and names in the derived can hide names declared in the base. See {override-keyword}
*kt_dev_cpp_023* The point is that the name-lookup happens at compile time and uses static-type. The
below shows that point.

class Disc_quote : public Quote {
  public:
    std::pair<a,b> discount_policy() const { ... }     # added in this class only
};

class Bulk_quote : public Disc_quote {
  ...
};

Bulk_quote bulk;

Bulk_quote* bulkP = &bulk;
Quote* itemP = &bulk;        # static and dynamic type differ

bulkP->discount_policy();
itemP->discount_policy();    # error

What if discount_policy is virtual func? Doesn't matter in this case and it's still error because
this is not found in Quote class.

Tried with GCC and got an error:
.cpp:139:10: error: 'class Quote' has no member named 'discount_policy'


{arg-dependent-lookup} C++P p797.
See this statements:

std::string s;
std::cin >> s;

this is equi to:

operator>>(std::cin, s); 

This operator>>() is defined in the string libaray as a nonmemeber and in std namespace. 

Why is it okay without using either "std::" or "using"? 

When func has class type argument which is class object, pointer or reference, the compiler searches
'namespace' in which arg defined in addition to the normal scope to lookup. This is 'exception' to
the rule that names defined in a (closed) namespace are hidden.

In this case, searches the namespace std, where cin and string is defined and found this func
from string. note: it is namespace, not else.

Why this exception? This makes it easy to use non-member func which is conceptually part of class
interface. Otherwise, should use

using std::operator>>; or std::operator>>(std::cin, s);

Either would make simple use of the IO library more complicated.


={============================================================================
*kt_dev_cpp_008* const and conversion

{constant-expression}
A constant expression is an expression that involves only constants:

#define MAXLINE 100
char line[MAXLINE+1];


{const-scope}
To support seperate compilation of const variable, the variable must be defined in every file so
compiler make it 'local' to file as if had written definitions for separate variables in each file.
C++P p60. So can have same name in different files.  

So want to use in multiple files, must use 'extern' keyword on 'both' definition and declaration.
This is different from <file-staic-mean>. The important principle is that shouldn't change const
object.

// file one
extern const int gc_max = 100;

// file two
extern const int gc_max;


{top-and-low-level-const}
The reference and pointer are 'indirect' access so makes two level in terms of constness. This
matters when copy an object.

               const int *const <variable-name>
               <-- 1 --> <- 2 ->

               const int * <variable-name>            // pointer to const
               const int *const <variable-name>       // const pointer to const
               const int & <variable-name>            // reference to const

1. base type part which is for underlying object and for low-level. That is a object that points or
reference to.

2. declarator part which is for compound type, reference or pointer, and for top-level. That is
pointer or reference itself.

The point is that it is compiler POV and for static type checking. To maintain constness, low-level
'never' be ignored but top-level can be since it's not about underlying object. 

In other words, top-level restrics only what we can do 'through' that reference or pointer and says
nothing about whether the underlying object itself. 

int i = 42;
const int ci = i;
int j = ci;

The initialization do not change the value of an object. Constness of ci matters 'only' for
operations that might change ci. Copying doesn't change ci. The new object has no further access to
the original object. 


<reference-to-const> 
Unlike pointer, there is only reference-to-const since reference is not object. 

int &ri = i;
const int &r2 = i;

r1 = 0;
r2 = 0;              // error since r2 is reference-to-const


<no-const-to-nonconst>
This is an error because this is not a copy and 'no' const to non-const conversion.

int main()
{
  const int ci = 100;
  int &ri = ci;               // 6. 
  // int &ri = (int&) ci;     // no error since uses cast
}

:6:13: error: invalid initialisation of reference of type int& from expression of type const int

const GstCaps *caps = gst_caps_from_string()
GstCaps const *caps = gst_caps_from_string()
gst_caps_unref(GetCaps *caps);

:44: error: invalid conversion from 'const GstCaps*' to 'GstCaps*'
:44: error:   initializing argument 1 of 'void gst_caps_unref(GstCaps*)'

<nonconst-to-const> type-match-exceptions. C++P p61
As long as maintain constness, allow conversion and so two 'exceptions' to type match rule. If
necessary, compiler make a temporary to allow conversion and maintain constness.

These exception are 'implicit' nonconst-to-const and derived-to-base-reference conversion. Can bind
reference-to-const to non-const, a literal, a temp, or other expression that evaluate to an type.

const int ci = 42;      
int i = ci;             

const int& r = ci;      // is 'always' low-level

int i;
const int &j = i;       // conversion from non-const to const
const int *p = &i;
int &r = j, *q = p;     // error since conversion from const to non-const

const int &ri = 42;     // ok but int &ri = 42 is an error
int &ri = 10;           // error
int &ri = double_val;   // error

double dval = 3.14;
const int &ri = dval;   // ok becuase will bind to temp-object and cannot change it via ri

The reference is alias for something exist and also need to maintain constness. This is all about
for 'compiler' to maintain constness by creating temporary. So the compiler transforms this:

const int temp = dval;     // temp-object. see const and tempoary is const object.
cont int &di = temp;

This also shows an example of creating a temporary through const conversion.

int main()
{
  int i{100};
  const int &ri = i;

  i = 200;

  std::cout << "i: " << i << std::endl;
  std::cout << "ri: " << ri << std::endl;

  double dval{3.14};
  const int &di = dval;

  dval = 6.28;

  std::cout << "d: " << dval << std::endl;
  std::cout << "rd: " << di << std::endl;
}

i: 200
ri: 200
d: 6.28
rd: 3          // see


{const-return} equal-misspell
EC++03. When use return by value as a return, use const to raise error when mistake happens:

const Rational operator*( const Rational& lhs, const Rational& rhs );

// typo. was meant if( a*b == c )
if( a*b = c )

If these are built-in tyeps, this is flat-out error but don't for class type. It is never legal to
modify the return value of a function that returns a built-in type. Even if it were legal, the fact
that it returns object by value would mean that a copy would be modified and that's not the behavior
you want. 

So better to be prepared for this kind of mistakes. Also this is an example of returning a copy than
reference.


{why-const-member-func}
EC++03. Two points:

1. Clearer interface to show which member func can change state; read or write.
2. Make it possible to work with const objects. 


<const-and-this-pointer> why cannot call non-const member function on const object
When call a member func, pseudo-code for actual call should looks:

total.isbn();

Sales_data::isbn(&total);  // where Sales_data::isbn(Sales_data *const this);

That is "this = &total" because this-pointer is a 'const' pointer to nonconst by default. This means
that can use only for nonconst objects since fails to set this pointer when calls nonconst member
function on const object. Why? Means 'this=&(const object)' but there's no const-to-nonconst
conversion.

note: This is what keyword const in const member function do. The const member function will make
this-pointer as a "const T *const this":

o Cannot change object via this member func(i.e. this-pointer)
o Can be used on 'both' const and nonconst class object.


string isbn 'const' { return bookNo; }

it makes:

T *const this -> 'const' T *const this


{constness-and-overload} overload-condition
Member functions differing only in their constness can be overloaded. Conditons for overloading

1. Shall be the same 'name'
2. Shall have different param list in the number or the type
3. Shall be in the same 'scope'

So don't see return type. See {virtual-copy-constructor} for override case.

// int *const currErr : const pointer. read from right to left

Record lookup( account * );      // pointer
Record lookup( account *const ); // const pointer. re-define.

Record lookup( account & );      // non-const version
Record lookup( const account &); // const version


{const-on-base-type}
When use const with type alias, it can be surprising. For example,

typedef char *pstring;

const pstring cstr = 0;    // cstr is a const pointer to char
const pstring *ps;         // ps is a pointer to const pointer to char

The important thing is that type alias is not "replacing string" but it a type and const applies on
base type.

// wrong interpretation. base type is char and * is part of declarator. cstr is pointer to "const
// char" 
const char* cstr = 0;      

// base type is "pstring" so const is on pstring type is a const pointer to char
const pstring cstr = 0;    


{const-on-iterators}
In iterator, begin() has overloads: const and non-const version because if it has only const
version, *this is const and any data member is also const. 

note: see how it has overloads 'depending' on object called upon and how to use const iterator.

/**
*  Returns a read/write iterator that points to the first
*  element in the %vector.  Iteration is done in ordinary
*  element order.
*/
iterator
begin() _GLIBCXX_NOEXCEPT
{ return iterator(this->_M_impl._M_start); }

/**
*  Returns a read-only (constant) iterator that points to the
*  first element in the %vector.  Iteration is done in ordinary
*  element order.
*/
const_iterator
begin() const _GLIBCXX_NOEXCEPT
{ return const_iterator(this->_M_impl._M_start); }

// like 'T* const' and iter itself is const
const std::vector<T>::iterator iter = vec.begin();

// like 'const T*' and *iter is const
std::vector<T>::const_iterator iter = vec.begin();


<const-non-const-version>
Why neeeds const and nonconst version? When use reference to const argument for better performance
and clearer interface about constness, required to have both version. 

The const matters when copying vars and func params. That is why copy-ctor is usded here.

void fcn( const int i );
fcn(j);     // const int i = j;
fcn(cj);    // const int i = cj;

void fcn( int i );
fcn(j);     // int i = j;
fcn(cj);    // int i = cj; ERROR

These are all explained by the fact that fcn(const int i) can be used both fcn( const-pararm ) and
fcn( non-const-param ) and in other words, top-level-const can be ignored.


<const-reference-param>
Two implications when use 'plain' reference param in func:

1. A func that don't change a ref param, mislead its user to think it does change.
2. More importantly, it limit its use only to non-const param.

find_char(const string& s, char c);
find_char("Hello", 'o');   // OK because const-to-ref can match to literal.

find_char(string& s, char c);
find_char("Hello", 'o');   // compile error because temp object is const

So recommend const-reference-param over plain reference-param for flexibility: can use for both
const and nonconst parameter. can use conversion.

example. this force to have const and nonconst version.

class Screen {
  public:
    string getMesg() const { return mesg; }     // OK
    string getMesg() { return mesg; }           // ERROR
};

void print_screen( const Screen &s )
{
  cout << s.getMesg() << endl;                  // call on const but getMesg is nonconst version
}

example

void print( const TextBlock& cbt )
{
  std::cout << cbt[0];                    // operator[] shall be const version
}

example

If there is only a const version of display() then following is a compile error. Assume display() is
const member func and set_set is non-const member func.

screen myscreen;
myscreen.display().set_set(10);

Since display() returns const and cannot call nonconst, set_set() on const object. Solution?

<approach-one> Use overloads for nonconst and const

class screen{
  public:
    screen& display( ostream& os ) 
    { do_display(os); return *this; }

    'const' screen& display( ostream& os ) const 
    { do_display(os); return *this; }

  private:
    // {tip} use a utility func for a common duplication
    void do_display( ostream& os ) const 
    { os << counts; }
};


example

class Screen {
  public:
    Screen& display()
    { cout << "dis: this is non-const member" << endl; return *this; }

    const Screen& display() const
    { cout << "dis: this is const member" << endl; return *this; }

    void set()
    { cout << "set: this is non-const member" << endl; }

    void set() const
    { cout << "set: this is const member" << endl; }
};


int main(int argc, char** argv)
{
  Screen screen;

  screen.display();
  screen.display().set();

  const Screen cscreen;

  cscreen.display();
  cscreen.display().set();    // error for note-02
}


note: 1. const member function 'must' return reference-to-const

If it were written:

Screen& display() const
{ cout << "dis: this is const member" << endl; return *this; }

test.cpp: In member function 'Screen& Screen::display() const':
test.cpp:14:58: error: invalid initialisation of reference of type 'Screen&' from expression of type
'const Screen'

This is an error on "const to nonconst conversion" So const member 'must' have this form since const
applies to this pointer: 


note: 2. this shows why cannot use nonconst member on const object

cscreen.display().set();

This causes an error since set is nonconst version

test.cpp: In function 'int main(int, char**)':
test.cpp:32:24: error: passing 'const Screen' as 'this' argument of 'void Screen::set()' discards
qualifiers [-fpermissive]

note: 3. when remove const return and function do not return *this.

Screen& display() const                               // not "const Screen& display() const"
{ cout << "dis: this is const member" << endl; }      // do not return *this

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is non-const member

The const display() returns as 'declared' since no comiple error and works. 

The point is taht the const member func has always this form when use return. why? see bitwise-const
for more.  This matters only when returns reference but not a copy.

const T func( ... ) const // OK
T func( ... ) const       // NO 


<approach-two> Have one implementation for both const and non-const <const_cast>

From EC++03. Why need? If member function is big, code duplication. So implement once and use it
twice. Have non-const that calls const version and have only one implementation. Why this direction?
If you were to call a non-const from a const one, you'd run the risk that that object you'd promised
not to modify would be changed. 

Used static_cast to call const version and const_cast to cast away const and return.

class TextBlock {
  const char& operator[]( std::szie_t position ) const 
  {
    ...
    return text[position];
  }

  char& operator[]( std::size_t position )
  {
    return const_cast<char&> ( static_cast<const TextBlock&>(*this)[position] );
  }
};

From C++P p233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
	return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
	auto &r = shorterString( const_cast<const string&>(s1), const_cast<const string&>(s2) );

	return const_cast< string& >(r);
}

This is safe to cast that string back to a plain string & in the return because it is one of
original nonconst arguments.


<approach-three> Change the order

myscreen.set_set(10).display();
const_screen.display();


{const-in-func-definition}
If miss out 'const' in the func definition then:

usedeskcalc.cpp:28:6: error: prototype for 'bool Stack::empty()' does not match any in class 'Stack'
usedeskcalc.cpp:13:7: error: candidate is: bool Stack::empty() const

class Stack {
  ...
  bool empty() const;
  ...
};

bool Stack::empty() const     // must use
{
  ...
}


{bitwise-const} physical constness
From EC++03. Bitwise-const(physical const) is C++'s definition and compiler only catches assignment to
member data which is read-only. Issues errors like:

<example>
Error_code Stack::top(Stack_entry &item) const
{
  else
    item = entry[count--];   // ERROR. count is member
    // item = entry[count-1];

  return outcome;
}

usedeskcalc.cpp:53:21: error: decrement of member 'Stack::count' in read-only object


<example>
int cube(const int& num)
{
  num = num * num;   // ERROR
  return num;
}

test.cpp:22:14: error: assignment of read-only reference 'num'

<example>
#include <iostream>

using namespace std;

class Sample {
  public:
    Sample(const char* str) : text(str) {}

    const char& operator[] (std::size_t pos) const       // note: 1
    // char& operator[] (std::size_t pos) const          // note: 2
    { return text[pos]; }

  private:
    std::string text;
};

int main(int argc, char** argv)
{
  Sample sam("CONSTMEMEBER");

  std::cout << sam[1] << endl;

  sam[1] = 'X';                  // error
}

note: 1. read-only assignment error
use-const-second.cpp: In function int main(int, char**):
use-const-second.cpp:25:11: error: assignment of read-only location sam.Sample::operator[](1u)

note: 2. const to nonconst error

<example>
#include <iostream>

using namespace std;

class Sample {
  public:
    Sample(const char* str) : ptext(new std::string(str)) {}

    char& operator[] (std::size_t pos) const             // note: 1. no const to nonconst error and works
    const char& operator[] (std::size_t pos) const       // note: 2. read-only assignment error
    { return (*ptext)[pos]; }

    ~Sample() { delete ptext; }

  private:
    std::string* ptext;
};

int main(int argc, char** argv)
{
  Sample sam("CONSTMEMEBER");

  std::cout << sam[1] << endl;
  sam[1] = 'X';                  // no error and can chage the value
  std::cout << sam[1] << endl;
}

O
X

No compile errors because 'indirect' use of an object (outside of an object) can avoid C++'s const
check called bitwise-const. Since do not make changes to *this, member, pointer in this case, so
compiler do not complain. This means const member func can change object state. Break encapsulation.

<solution-one>
From EC++28. Can fix this problem as below,

const char& operator[] (std::size_t pos) const     // not able to modify via this call

However, 'dangling' handles problem still remains since it returns reference to internal member such
as reading it which is already gone.

<key> Therefore, recommend to use const T(...) const form as a 'default'.

<solution-two> logical constness
EC++03. Hence logical-const. This is an example to cache the length whenever it is requested. cache
textLength. Although it changes its member, it has logical constness as it updates length to cache
purpose. 

class CTextBlock {
  public:
    std::size_t length() const;

  private:
    char* pText;
    mutable std::size_t textLength;    // mutable
    mutable bool lengthIsValid;        // mutable
};

Last calculated length of textblock

std::size_t CTextBlock::length() const
{
  if( !lengthIsValid )
  {
    textLength = std::strlen( pText );
    lengthIsValid = true;
  }

  return textLength;
}


{mutable}
To make member data writable from a const member func. A mutable data member is never const even
when it is a member of a const object.

class T {
  public:
    void some_member() const;

  private:
    'mutable' size_t access_ctr;
};

<when-useful>
- in debug, to count the number of calls for a member func.
- to use logical constness
- to use lock as a mutable member. seems useful.
- see {lazy-fetching} in *kt_dev_mecpp_002* 

All these cases are about 'logical' constness and the snippet from online:

A mutable variable could be used for example for tracking lifetime of an object and regularly prints
a log of its internal state. In this case, nothing changes for the object from the external point of
view, but some thing in its internal state changes. This does not contradict to promise to not
modify the object, because in this case, const can be seen as "I promise to my user that this
operation will not modify any visible state / information he could access". 

Why logical? Since do it in ways that clients cannot detect or that maintain constness in terms of
logic. 


{case-example}
When use the mix of C and C++, face an build error when builds C++ source.

SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
...
  source = _determineSource(in, &sourcelen, &inIndex, &usePath);
}

const char* _determineSource(const char*in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');      // C++ version
  ...
}

Session.cpp:876:23: error: invalid conversion from 'const char*' to 'char*'

Looked at the strchr man page and it says:

NAME
       strchr, strrchr, strchrnul - locate character in string

SYNOPSIS
       #include <string.h>

       char *strchr(const char *s, int c);
       
What? What's going on here?!

<answer>
Found that from glibc string.h

/* Find the first occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO            // IF
extern "C++"
{
extern char *strchr (char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
extern __const char *strchr (__const char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strchr (char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}

__extern_always_inline __const char *
strchr (__const char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}
# endif
}
#else                                              // ELSE for C
extern char *strchr (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif

That says that will use non-const version for C++ build and const version for C.

<solution>
SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
  ...
  source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);    <DN>
}

const char* _determineSource(char*in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');
  ...
}


={============================================================================
*kt_dev_cpp_009* undefined result and a temp-object

{undefined-result-in-return}

<no-return-when-expected>
#include <iostream>
#include <string>

using namespace std;

bool str_subrange( const string& str1, const string& str2 )
{
  if( str1.size() == str2.size() )
    return str1 == str2;

  auto small_size = ( str1.size() < str2.size() ) ? str1.size() : str2.size();

  for( decltype(small_size) i = 0; i != small_size; ++i )
    if( str1[i] != str2[i] )
      ;                          // NO ERROR in this case
  return;                        // ERROR-01
                                 // ERROR-02
}

int main()
{
  string str1 = "KYOUNG";
  //string str2 = "YOU";
  string str2 = "KYO";

  bool ret = false;

  ret = str_subrange(str1, str2);
  if( ret )
    cout << "return true" << endl;
  else
    cout << "return false" << endl;

  return 0;
}

<ERROR-01>
VC and GCC picks up this error. This is GCC case:

samcpp.cpp: In function bool str_subrange(const std::string&, const std::string&)
samcpp.cpp:16: error: return-statement with no value, in function returning bool

<ERROR-02> undefined-result
Primus says that some picks up this error and some do not. Both VC adn GCC do not picks up this
error.

Primus also says that its result at runtime is 'undefined'. When running for VC and GCC showed
different result: VC returns true and GCC do false. Hence 'undefined'. 


<when-return-local>
const string& foo()
{
  string ret;

  if
    return ret;
  else
    return "Empty";
}

Both return cause 'undefined'-result at the call site(caller) because it returns reference to local
to function foo().


={============================================================================
*kt_dev_cpp_010* temp-object

{temp-object}
From MEC++19. The temp-object is used in implicit type conversion, nonconst-to-const, func call,
casting and return. Can have an impact on the performance in construction and destruction.

TODO: need more to see if temp object is really a cost

<temp-object-in-return>
<1> 
Return the plural version of the word if the counter is greater than 1.

string make_plural( size_t ctr, const string& word, const string& ending)
{
  return (ctr>1) ? word + ending : word;
}

The word is copied to the call(ing) site or unnamed string 'temp'-object is copied to the call site for
'word + ending' case.

<2>
Here explicitly constructed return pair 'temporary'. 'pair<string, int>' is T. That is T() and so is
default constructed and value-init.

See {return-reference-vs-copy} for interesting case. So whether or not there is a temp object
created in called site, there is a copy to call site when a func is defined to return a copy.

pair<string, int> process( vector< string > v )
{
  if( !v.empty())
   return {v.back(), v.back().size() };
   // or return pair<string, int>( v.back(), v.back().size() );
  else
    return pair<string, int>();
}

<3> 
This must be 'const' return and see {const-return}. If not, the following is legal: 

const Number operator+( const Number& lhs, const Number& rhs );
Number a, b, c;
a + b = c;

How to eliminate this cost?
Not always possible to shun this. Can use operator+= and see MEC++22 for more. Or can use compiler's
<return-value-optimisation> in MEC++20.

<4>
const char* PersonInfo::theName() const;

virtual std::string name() const
{ return PersonInfo::theName(); }


<temp-object-in-converison> cost-of-temp-object

<implicit-conversion>
<1>
size_t countChar( const string& str, char ch );    // see const here

char buffer[MAX_STRING_LEN];

countChar( buffer, c ); // string str = string temp-object(buffer);

When it is called, there is a type mismatch so string temp object will be created, buffer is copied,
and 'binding' to argument happens. Destruction happens when return. If buffer size is big, then
it is costly. It is for compiler to make a func call succeed.

note: Tried sample code and confirmed that even if use value copy of argument, there is no copy
ctor.

<Q> do not understand this: This happens only for <pass-by-value> and <reference-to-const>. Why?
There are exceptions and see {type-match-exceptions}. So if use reference to non-const then no
conversion, sounds better and possible?

<2> if remove const from the above
size_t countChar( string& str, char ch );    // see no const here

Then there is an error:
:19:19: error: invalid initialisation of non-const reference of type std::string& {aka
  std::basic_string<char>&} from an rvalue of type char*


<temp-object-is-const>
<key> WHY? In any case, compiler will create temporary due to type mismatch and if temporary was not
const (means mutable or can change this) then make a changes to temporary. Not expected result.
That's why the language prohibits the generation of temporaries for non-const reference parameters.
Reference-to-const parameters don't suffer from this problem, because such parameters, by virtue of
being const, can't be changed.

How to eliminate this?
1. Write code to make sure there is no implicit conversion such as explicit-keyword or member
function. note: This don't seem to eliminate the cost since having explicit keyword forces user to
do it explicitly than compiler do implicitly.

2. MEC++21

<in-casting>
From ansic, p45.
The cast produces the 'value' of n in the proper type; n itself is not altered. 

squrt( (double)n );

item.combine( static_cast<Sales_data>(str) );


={============================================================================
*kt_dev_cpp_011* inline

EC++30 recommends to minimize use of inline.

Inlining could have:

1. Can avoid function call overhead
2. Request to the compiler but not a command since the compiler may choose to ignore this request.
3. EC++30 says that can have compiler optimisation on inlined code area.

As with macro, inline has cost:

1. bigger size and performance penalty which can cause additional paging and reduced instruction cache hit.
2. impossible to provide binary upgrades. Force client to compile than to relink. Think when changes
inline func. All clients should be recompiled.
3. problem with debugger.
4. A compiler refuse to inline funcs that has calls to 'virtual' funcs because cannot know it at
compile time.


<empty-ctor-represenstaion>
ctor and dtor may be 'worse' candiate for inline. Why? There are codes written by compilers and
inserted into program during compilation for construction, destruction, exception handling during
those, new and delete, and so forth. These are up to compiler implementation. So empty ctor can have
followings:

class Derived: public Base {
  public:
    Derived() {}              // is it really empty?
    ...
  private:
    std::string dm1, dm2, dm3;
};

Derived::Derived()
{
  Base::Base();

  try{ dm1.std::string::string(); }
  catch(...) {
    Base::~Base();
    throw;
  }

  try{ dm2.std::string::string(); }
  catch(...) {
    dm1.std::string::~string();
    Base::~Base();
    throw;
  }

  try{ dm3.std::string::string(); }
  catch(...) {
    dm1.std::string::~string();
    dm2.std::string::~string();
    Base::~Base();
    throw;
  }
}

This is unrepresentative of what real compiler emit but do what ctor must offer. When think ctors of
base class, class members, not attractive for inlining. 

<key> 
The logical strategy for determining which function should be declared inline and which should not.
Initially don't inline anything, or at least limit your inlining to those functions that must be
inline. Employ inlines cautiously including templates functions. Think about 80-20 rule and may use
profiler to find out 20% as a candidate for inlining.


={============================================================================
*kt_dev_cpp_012* list initialization. initializer_list 

{why-list-initialization}
Many different ways to initialize.So the generalized use of curly brace was introduced in new
standard.

int units_sold = 0;
int units_sold = {0};
int units_sold{0};            // list initialzation.
int units_sold(0);
int units_sold{};

<in-constructor>
ABEntry::ABEntry(...)
: theName(),                  // var(). same as units_sold(0)
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}

<temporary>
void doSomething(B bObject);
doSomething(B(28));           // T(val). converting ctor

return pair<string, int>();   // T()

<direct-initialization>
string dots(10, '.');
string s(dots);

<default-and-value-initialzation>
string* ps = new string;      // default-init
string* ps = new string();    // value-init. new T()

int* pi = new int;            // default-init
int* pi = new int();          // value-init. new T()

vector<T> v3(n, val);         // has n elements with value val
vector<T> v4(n);              // has n copies of a value-init objects

note:
The value-init uses the form T() and is a special or narrow case of default initialization.

#include <iostream>
#include <vector>

using namespace std;

template <typename T>
void PRINT_ELEMENTS( T& coll, const string str="" )
{
    cout << str << ":" << endl;
    cout << "{ ";

    for( auto &elem : coll )
        cout << elem << ", ";

    cout << "}" << endl;
}

int main(int argc, char** argv)
{
    vector<int> ivec;

    for(int i = 0; i < 5; i++ )
    {
        int val;

        ivec.push_back(val);
    }

    PRINT_ELEMENTS(ivec, "default inited");

    vector<int> vivec(5);
    // vector<int> vivec(5, 10);

    PRINT_ELEMENTS(vivec, "value-inited");
}

default inited:
{ 32767, 32767, 32767, 32767, 32767, }
value-inited:
{ 10, 10, 10, 10, 10, }

default inited:
{ 32767, 32767, 32767, 32767, 32767, }
value-inited:
{ 0, 0, 0, 0, 0, }


{list-initialization} uniform initialization
C++11 introduced the concept of uniform initialization, which means that for any initialization. 

note: >
Must use -std=c++0x or -std=gnu++0x. Otherwise, compile error.

The followings are possible now:

const std::string hybrid_str{"hybrid:"};
int values[] { 1, 2, 3 };
std::vector<int> v { 2, 3, 5, 7, 11, 13, 17 };
std::vector<std::string> cities {"Berlin", "New York", "London", "Braunschweig", "Cairo", "Cologne" };
std::complex<double> c{4.0,3.0}; // equivalent to c(4.0,3.0)

The good things are:

1. default value for built-in types

An initializer list forces so-called value initialization, which means that even local variables of
fundamental data types, which usually have an 'undefined' value, are initialized by zero, or
nullptr, if it is a pointer.

int i;      // i has undefined value
int j{};    // j is initialized by 0
int* p;     // p has undefined value
int* q{};   // q is initialized by nullptr

note: why it is for built-in type? class type will have default values since ctors would do if ctors
do the right work.

note: C++P p44. Some classes require that every object be explicitly initialized. The compiler will
complain if try to create an object of such a class with no initializer. HOW?


2. narrowing conversion

The list initialization do not allow narrowing conversion of 'built-in' type.

int x3{5.0};      // ERROR: narrowing
int x4 = {5.3};   // ERROR: narrowing

note: Worthwhile to use this property? Since unlikely to directly initialize an int from a long
double? However such initialization might happen unintentionally in template. 'todo'

3. use single form of initialization

4. avoid vexing-parse

<example>
From C++CA 2.1.1, if you pass a 'temporary' rather than a named variable the the syntax can be the
same as that of a fuction declaration.

class background_task;
std::thread my_thread( background_task() );     // T()

This declares the function my_thread that takes a single parameter which is type pointer to a
function taking no parameters and returning a background_task object. However, the intention was to
create std::thread instance with function object to run.

Solution?

std::thread my_thread( (background_task()) );   // extra ()
std::thread my_thread{ background_task() };     // brace-init

<example>
The intention is to have value-init but defines a function.

std::string source();
source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);

error: assignment of function 'std::string source()'     // see 'function' in error message
error: cannot convert 'std::string' to 'std::string()' in assignment

note: to make it as intended and this create a temporary and use copy initialzation. not useful.

std::string source = string();


{initializer-list}
To 'support' the concept of initializer lists for user-defined types. It is a library template type
that repersents an 'array' of values of the specified type. The element in a list are always const.

#include "initializer_list"

initializer_list<int> li; 
initializer_list<string> ls;

Since it's array, it supports begin()/end() and can process elements.

<1>
void error_msg( initializer_list<string> ls )
{
    for( auto beg = ls.begin(); beg != ls.end(); ++beg )
        cout << *beg << " ";

    cout << endl;
}

<2>
void error_msg( ErrorCode e, initializer_list<string> ls )
{
    cout << e.msg() << " ";

    for( const auto &elem : ls )
        cout << *elem << " ";

    cout << endl;
}

<3>
print( {12,3,5,7,11,13,17} );

void print( std::initializer_list<int> vals )
{
    for (auto p=vals.begin(); p!=vals.end(); ++p)  
        std::cout << *p << "\n";
}


={============================================================================
*kt_dev_cpp_013* when use reference {called-by-reference}

{no-address-when-use}
There is a difference between called-by-reference(passed-by-reference) and called-by-value. For
example:

void reset( int i )
{ i = 0; }

int j = 42;
void reset (j); 

what's the value of j here?


void reset( int* pi )
{ *pi = 100; pi = 100; }

int j = 42;
void reset( &j );

what's the value of j here?

Here reference i will be bounded to whatever int object we pass and say "pass an object" directly.
So no need to pass its address.

void reset(int &i)
{ i = 0; }

int j = 42;
reset(j);      // note: no need to pass its address

what's the value of j here?

For called-by-reference, C uses pointers and C++ uses reference. Use C++ way of doing it.


{reference-vs-pointer}
<pointer-example> tree example
TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
  if(!root)
  {
    root = newnode;
    root->left = root->right = NULL;
  }
  else if( LT(newnode->entry.key, root->entry.key) )
    root->left = TreeInsert( root->left, newnode);
  else
    root->right = TreeInsert( root->right, newnode);

  return root;
}

int main()
{
  TreeNode *proot, *pnode;
  CreateTree( &proot );

  for(int idx = 0; idx < size; idx++)
  {
    pnode = MakeTreeNode( arr[idx] );
    proot = TreeInsert( proot, pnode );
    // TreeInsert( proot, pnode );        // ERROR
  }
  ...
}

note: If not update proot with the return from TreeInsert then changes to proot made in the function
call do not have effect so proot still remains null. Why? Since this passes pointer by value; that
is pass by value but value is a pointer although uses pointer form. The point is that this do not
change what pointer points to but change pointer itself. Therefore, the return is necessary to
update proot as pass by value does.

This is the revised version to use pass by reference approach.

void TreeInsert( TreeNode** root, TreeNode* newnode )
{
  if(!*root)
  {
    *root = newnode;
    (*root)->left = (*root)->right = NULL;
  }
  else if( LT(newnode->entry.key, (*root)->entry.key) )
    TreeInsert( &((*root)->left), newnode);
  else
    TreeInsert( &((*root)->right), newnode);
}

int main()
{
  for(int idx = 0; idx < size; idx++)
  {
    pnode = MakeTreeNode( arr[idx] );
    TreeInsert( &proot, pnode );
  }
}

<key> The pass by reference is not about the form but about how to access 'pointed' object.

<reference-example> tree example from random-binary-search-tree-template-version

template <typename Entry>
class Binary_tree 
{
   Binary_node<Entry> *root;
};

template <typename Record>
Error_code Search_tree<Record>::insert( const Record &new_data )
{
  return search_and_insert( this->root, new_data );
}

// <call-by-value-problem> notice the use of "*&" here. If not, suffer the same problem of
// TreeInsert() since sub_root is a local copy.
//
// Error_code Search_tree<Record>::search_and_insert( 
//  Binary_node<Record> *sub_root, 
//  const Record &new_data); 
//
template <typename Record>
Error_code Search_tree<Record>::search_and_insert( 
    Binary_node<Record> *&sub_root, 
    const Record &new_data ) 
{
  if( sub_root == NULL )
  {
    sub_root = new Binary_node<Record>(new_data);
    return success;
  }
  else if( new_data < sub_root->data )
    return search_and_insert( sub_root->left, new_data );
  else if( new_data > sub_root->data )
    return search_and_insert( sub_root->right, new_data );
  else 
    return duplicate_error;
}

<key> See how using a reference can make a code simple and neat to implement pass by reference
approach than using a pointer.


{range-for}

for( auto c : str )
   cout << c << endl;

// want to change
for( auto &c : str )
   c = toupper(c);


{return-reference}
// where back() returns a reference
auto &v = container.back();
auto v = container.back();

<Q> cannot overload by having different return since overload do not see return type. Then how this
back() work?


{return-reference-vs-copy}
Beware a func that returns copy or reference. {quiz} maybe a quiz?

class Screen {
  public:
    Screen() : move(0), set(0) {}
    <01> Screen& set_move(int val) { move = val; return *this; }
    <01> Screen& set_move(int val) { move = val; }
    <02> Screen set_move(int val) { move = val; return *this; }
    <02> Screen set_move(int val) { move = val; }
    void set_set(int val) { set = val; }
    void print() { cout << "Screen: move " << move << ", set: " << set << endl; }

  private:
    int move;
    int set;
};

int main()
{
  Screen myscreen;
  myscreen.set_move(5).set_set(10);
  myscreen.print();
}

<01>
5, 10

<02>
5, 0

Since <02> set_move returns a copy and set_set is called upon the copy, no changes on myscreen
object.


={============================================================================
*kt_dev_cpp_014* auto, decltype, typedef, and struct

{auto-specifier}
The name of each object becomes visible 'immediately' so possible to initialize a variable to the
value of one defined earlier in the same definition.

double price = 109.99, discount = price * 0.16;
double salePrice = applyDiscout( price, discount );

When initialize it from a expression, have to know the type of that expression and can be difficult.

Under new standard, let the compiler figure out the type by using auto type specifier and by
deducing the type from the initializer.

note: GCC 4.4.5 supports.

auto item = val1 + val2;


{decltype-specifier}
Want to use type that the compiler decuces but do not want to use that to initialize the variable.
Return the type of expression but do not 'evaluate' it, that is, do not call expression.

string s("...");
decltype( s.size() ) count = 0;

<when-decltype-return-reference-type> to get reference type of expression
The decltype return reference type when expression yields objects that is lvalue, that can stand on
the left hand side of assignment.

int i = 42, *p = &i, &r = i;

decltype( r + 0 ) b;          // int b
decltype( *p ) c;             // int& c; error.

The decltype of a parenthesized variable is always a reference.

decltype((i)) d;              // int& d; error.
decltype(i) e;                // int e;

The side effect when decltype returns a reference is that variable must be initialized as usual
reference variable does.


<typeof-and-decltype>
The 'typeof' is gcc one and decltype is C++.

The problem is:

std::vector<typeof(k)> myVec;
    
C++0x standard introduces an alternative called 'decltype', which can be used to replace uses of
typeof. Unfortunately, in some more complex use cases when deduced types are used as parameters for
templates resolving into types declared as 'constexpr', use of typeof() triggers a compile-error.

note: decltype usage. decltype is used to get type for template.
note: solution was to have #define to use decltype only for C++0x but typeof for before C++0x.


{struct-and-typedef}
The structure is declared like this. No space allocated since it is declaration.

struct point {
  int x;
  int y;
};

note: As with class, see terminating ";".

Here point is that "structure tag" defines a 'type'. So defining structure objects is
analogous to defining objects of any type.

"struct { ... } x, y, z;" is analogus to "int x, y, z;"

Why 'tag'? The tag can be used 'later' in definition of instances of the structure since cannot use
the above later. Given the declaration above:

struct point pt = { 320, 200 };

The only 'legal' operation on structure are copy and assign as a unit but not compare.

<why-typedef>
From ansic, p146.
The typedef creates a new data type 'names'. It does not create a new 'type' in any sense; merely adds
a new name for some 'existing' type. In effect, typedef is like #define, except that it is
interpreted by the compiler.

So using typedef is convenient:

Point top; vs. struct point top;

<c-vs-cpp>
However, this only applies to C. See these:

struct Node
{
  int     a;
  int     arr[2];
  int     b;
};

int main(int argc, char** argv)
{
  Node node = {1, {2,3}, 4};        # note: This is error in C but not in C++.
}


{initialization}

typedef struct {
  int a;
  int b;
  int arr[2];
} NODE;

int main()
{
  // note: this warning happens due to -Wextra
  // sample.c:11:3: warning: missing initializer [-Wmissing-field-initializers]
  // sample.c:11:3: warning: (near initialization for 'node.arr') [-Wmissing-field-initializers]
  // NODE node = {0,0};

  NODE node = {0,0,{0,0}};

  return 0;
}

note: to avoid warning, may have {0} for a single element array

typedef struct {
  int a;
  int b;
  int arr[1];
  int c;
} NODE;

NODE node = {0,0,{0},0};


<designated-initializers> note: about the initialzation order but not layout.
https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html

Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the
order of the elements in the array or structure being initialized.

In ISO C99 you can give the elements in 'any' order, specifying the array indices or structure field
names they apply to, and GNU C allows this as an extension in C90 mode as well. This extension is
not implemented in GNU C++.

struct view_class {
  const char *title;
  const char *style;
  Evas_Object *(*create)(struct viewmgr *vmgr);
  void (*update)(Evas_Object *base, Elm_Object_Item *it);
  void (*show)(Evas_Object *base, Elm_Object_Item *it);
  void (*hide)(Evas_Object *base, Elm_Object_Item *it);
  void (*resume)(Evas_Object *base, Elm_Object_Item *it);
  void (*pause)(Evas_Object *base, Elm_Object_Item *it);
  void (*terminate)(Evas_Object *base);
  int show_bg;
};                                                          

This is struct declaration and not a typedef. So need to use struct keyword to create a object. All
three examples below creates objects.

note: see use of comma for below examples to create a object.

static struct view_class _vclass = {   static struct view_class _vclass = {
  .title = NULL,                         NULL,                             
  .style = "homepanel/apps/1",           "homepanel/apps/1",               
  .create = _create,                     _create,                          
  .update = _update,                     _update,                          
  .show = _show,                         _show,                            
  .hide = _hide,                         _hide,                            
  .resume = _resume,                     _resume,                          
  .pause = _pause,                       _pause,                           
  .terminate = _terminate,               _terminate,                       
  .show_bg = 0,                          0,                                
};                                     };                                  

or

struct view_class {
  const char *title;
  const char *style;
  Evas_Object *(*create)(struct viewmgr *vmgr);
  void (*update)(Evas_Object *base, Elm_Object_Item *it);
  void (*show)(Evas_Object *base, Elm_Object_Item *it);
  void (*hide)(Evas_Object *base, Elm_Object_Item *it);
  void (*resume)(Evas_Object *base, Elm_Object_Item *it);
  void (*pause)(Evas_Object *base, Elm_Object_Item *it);
  void (*terminate)(Evas_Object *base);
  int show_bg;
} x = {
  NULL,
  "homepanel/apps/1",
  _create,
  _update,
  _show,
  _hide,
  _resume,
  _pause,
  _terminate,
  0,
};

If it was a typedef then would use like:

static view_class _vclass = {
  .title = NULL,
  .style = "homepanel/apps/1",
  .create = _create,
  .update = _update,
  .show = _show,
  .hide = _hide,
  .resume = _resume,
  .pause = _pause,
  .terminate = _terminate,
  .show_bg = 0,
};

<example> creates a type name but not object. 
typedef struct tnode {
  char *word;
  int count;
  struct tnode* left;
  struct tnode* right;

  // note: <diff-between-c-and-cpp> error for C but okay for CPP since it is a pointer and okay as
  // long as not define object. To define object, compiler may see whole definition.
  //
  // msort-list.c:7:3: error: unknown type name 'tnode' when use C.
  //
  tnode* left;
  tnode* right;

} Treenode;

<example> both creates a type name.
typedef struct tnode *Treeptr;

typedef struct tnode {
  char *word;
  int count;
  Treeptr left;
  Treeptr right;
} Treenode;


<example>
typedef struct treenode TreeNode;

typedef struct treenode {
  TreeEntry entry;
  TreeNode  *left;
  TreeNode  *right;
} TreeNode;

or

typedef struct treenode {
  TreeEntry entry; 
  treenode  *left;
  treenode  *right;
} TreeNode;

<example>
<error>
struct List;         // 7

typedef struct node
{
  EntryType entry;
  node*     pnext;         // okay for CPP
  List*     plist;
} Node;

typedef struct {
   int   count;
   Node* header;
} List;              // 19

gen-list-linked.cpp:19:3: error: conflicting declaration typedef struct List List
gen-list-linked.cpp:7:8: error: struct List has a previous declaration as struct List

<okay>
struct list;

typedef struct node
{
  EntryType entry;
  node*     pnext;
  list*     plist;
} Node;

typedef struct list {
  int    count;
  Node*  header;
} List;

OR

typedef struct list List;

typedef struct node
{
  EntryType entry;
  node*     pnext;
  List*     plist; or list* plist;
} Node;

typedef struct list {
  int    count;
  Node*  header;
} List;

<example> this is to create a pointer type name but not object.
typedef struct _fsm
{
  VRM_FSM_INIT  init;
  ...

} *FSM_T;

FSM_T new_fsm = 0;


{type-alias}
typedef double wages;
using wages = double;         // C++11

note: can be suprising result when use alias with compound type and const

typedef char *pstring;
const pstring cstr = 0;       // do not interpret as "const char *pstring cstr"
const pstring *ps;

The cstr is "const pointer to char" but not "pointer to const char" since base type is "char *" and
const applies on base type.

<typedef-in-class>
Effectively, make alias to classA. Useful when class name changes. Seen in Tizen code. typedef is
just a 'synonym' for some type (from ESTL)

typedef classA classB;

<typedef-multiple>
Is it error to have multiple typedefs? No. See *kt_dev_gcc_001* and the error is to have conflicting
typedefs.

<two-reasons-to-use-typedef>
1. To parameterize a program against portability problems. If typedef are used for data types that
may be machine-dependent, only the typedef need change when the program is moved.

2. To provide better documentation for a program. A type Treeprt may be easier to understand.


{class-vs-struct}
The only difference between struct and class is the default access specifier for members and
derivation; struct is 'public' and class is private by default. p616 in ref-CPR.


{layout-order-and-size}
From C++BS 8.2.1.

An object of a struct holds its members in the order they are declared.

struct Readout {
  char hour;
  int value;
  char seq;
};

A more realistic layout of a Readout on a machine with 4-byte int would be:

hour :   [*      ]
value:   [* * * *]
seq  :   [*      ]

In this case, as on many machines, sizeof(Readout) is 12, and not 6 as one would naively expect from
simply adding the sizes of the individual members.

You can minimize wasted space by simply ordering members by size (largest member first).

struct Readout {
  int value;
  char hour;
  char seq;
};

This would give us:

value:      [* * * *]
hour: seq : [* *    ]

It is usually best to order members for readability and sort them by size only if there is a
demonstrated need to optimize.


={============================================================================
*kt_dev_cpp_015* declaration and definition

A declaration tells compilers about the name and type of something and a definition provides
compilers with the details a a declartation omits. For an object, the definition is where compilers
set aside memory for the object. For a function or function template, it provides the code body. For
a class or class template, it list the members of the class or template.

{compilation}
From p656. Ordinarily, when call a function, the compiler needs to see only a declaration.
Similarly, when use objects of class type, the class definition must be available but the definition
of the member functions need not be present. As a result, put class definition and function
declaration in header file and definition of ordinary and class member function is source files.

{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for that function. This
is true. The code below works fine with no errors.

#include <iostream>

class AA {
  public:
  void member_defined() { std::cout << "has definition" << std::endl; }
  void member_nodefined();
};

int main()
{
  AA aa;

  aa.member_defined();

  return 0;
}

However must define every virtual function regardless of whether it is used because do not know
which version of a function is called until run time.

extern int i;     // declare
int i;            // declare and define

void func(..);    // declare
void func(..)     // declare and define
{
   ...
}

For class, see {class-definition} in *kt_dev_lang_010*

From ansic, p80. A declaration announces the properties of a variable(primarily its type) and a
definition 'also' cuases storage to be set aside.

int sp;
double val[MAXVAL];

this 'define' the external variables and cause storage to be set aside and 'also' serve as the
declaration for the rest of that source file.


extern int sp;
extern double val[];

this 'declare' for the rest of the source file that sp is an int and val is a double array.


={============================================================================
*kt_dev_cpp_016* array and struct

{array-vs-struct}
1. From C++BS 8.2. Objects of structure types can be assigned, passed as function arguments, and
returned as the result from a function. For example:

Address current;
Address set_current(Address next)
{
  address prev = current;
  current = next;
  return prev;
}

Other plausible operations, such as comparison (== and !=), are not available by default. However,
      the user can define such operators.

2. An array is an aggregate of elements of the same type. In its simplest form, a struct is an
aggregate of elements of arbitrary types.


{array-as-an-object}
Placing a built-in array in a struct allows us to treat that array as an 'object': we can copy the
struct containing it in initialization (including argument passing and function return) and
assignment. For example:

struct Point {
  int x,y
};

struct Array {
  Point elem[3];
};

Array shift(Array a, Point p)
{
  for (int i=0; i!=3; ++i) {
    a.elem[i].x += p.x;
    a.elem[i].y += p.y;
  }
  return a;
}

Array points2 {{1,2},{3,4},{5,6}};

Array ax = shift(points2,{10,20});

The notation for Array is a bit primitive: Why i!=3? Why keep repeating .elem[i]? Why just elements
of type Point? The standard library provides std::array as a more complete and elegant development
of the idea of a fixed-size array as a struct:

This array is a template to allow arbitrary numbers of elements of arbitrary types. It also deals
directly with the possibility of exceptions and const objects.

struct Point {
   int x,y
};

using Array = array<Point,3>; // array of 3 Points

Array points {{1,2},{3,4},{5,6}};

int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
  for (int i=0; i!=a.size(); ++i) {
    a[i].x += p.x;
    a[i].y += p.y;
  }
  return a;
}

Array ax = shift(points,{10,20});

<pros-and-cons>
The main advantages of std::array over a built-in array are that it is a 'proper' object type (has
    assignment, etc.) and does not implicitly convert to a pointer to an individual element:

The disadvantage of std::array compared to a built-in array is that we can't 'deduce' the number of
elements from the length of the 'initializer':

Point point1[] = {{1,2},{3,4},{5,6}}; // 3 elements
array<Point,3> point2 = {{1,2},{3,4},{5,6}}; // 3 elements
array<Point> point3 = {{1,2},{3,4},{5,6}}; // error : number of elements not given


={============================================================================
*kt_dev_cpp_017* static-members and class const

{static-members}
The staic-members that are associated with the class rather than objects. So can call static member
func as "class method" or class operation as in smalltalk and static member var as "class variable"
or class static. See function-static for other terms.

note: static members 'obey' normal access control.

<static-member-func-and-this>
The static-member-func do not bound to any object; do not have a this pointer. Aa a result
static-member-func may not be declared as const. 

<init-class-variable>
The objects do not contain data associated with class variable. When initialized? The default
constructor 'implicitly' default initialize static-member-variable. The class-static
<must-be-defined-and-inited> outside of class because it's global objects.

<in-h>
class Foo {
  private:
    static double interest;         // declare
};

<in-cpp>
double Foo::interest = initRate();  // define and init


{class-const}
EC++02. If it's const, it limit the scope of a constant to a class and can be used in-class-init.
Hence it's called class-variable and be static. Otherwise got error:

usecomma.cpp:8:13: error: invalid use of non-static data member Foo::MAX

<in-h>
class Foo {
  private:
    static const double interest = 30;    // declaration. in-class-init. 
    double table[ interest ];             // can be used.
};

<in-cpp>
This class-const of integral type can be used in class definition without definition. But used in
other context such as passing it to func arg, must define.

double Foo::interest;                     // definition and 'must' not init


{what-class-method-can-access}
The static member func, class-method, do not have 'this'-pointer because no need to distinguish
objects and this means static member func can only use static member data.


{summary}
After all, class-method and class-variable is to limit a scope of golbal objects as with file or
function static. The bottom line is that static is global but we can limit its scope to file, class,
or function.

1. SCOPE. easy access as global, no need to create an object to use, but in the class scope.
2. created only when it is used. It is true for <function-static> in {limit-the-number-of-object}.
3. to solve {init-order-problem}


={============================================================================
*kt_dev_cpp_018* dtor. non-virtual-destruction-problem

{running-order}
Opposite to ctor in destruction order so dtor body first and then implicit member destruction phase.

Under inheritence: 

------------> ctor
base     derived
<------------ dtor

<example>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;
  public:
    Base() { cout << "base ctor" << endl; }
    ~Base() { cout << "base dtor" << endl; }
};

class Derived: public Base {
  private:
    int m_iDataAnimal;
  public:
    Derived() { cout << "derived ctor" << endl; }
    ~Derived() { cout << "derived dtor" << endl; }
};

int main(int argc, char** argv)
{
  Derived dobj;

  cout << "end of main" << endl;
}

base ctor
derived ctor
end of main
derived dtor
base dtor

Unlike {non-virtual-destruction-problem}, this case uses only static binding and no vtable is
involved. The compiler knows only about derived type and do not emits code to follow vtables.


{syn-version-is-non-virtual} {dtor-in-derived-classes}
The dtor is one of copy controls in *kt_dev_cpp_003* and means if not defined, the compiler will make
one which is non-virtual when the base don't have a virtual dtor.

The virtual is only used in class definition and for other functions, if it's virtual in base then
all overrides in derived classes are virtual. How about dtor? That's the same. 

Unlike the constructors and assignment operators, the destructor is reponsible only for destroying
the resources allocated by the derived class. From user or programmer POV.


{non-virtual-destruction-problem}
EC++07. The problem is that only base dtor runs when derived-to-base(pointer) is used and the base
class don't have virtual dtor. note: only when derived to base is used. 

In GCC spec, it will have 'undefined' result but in reality, destroy only the base part; partially
destroyed. In GCC, no runtime error in simple test. 

This is the same for other member functions. That is if miss out virtual keywords in a base, then
will have only base version even if expected derived version. 

note: Therefore, there are two cases when override do not happen; one when argument is different,
see {override-keyword}, and one when miss out virtual keyword in a base as shown here.

<example-code>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;
  public:                                             // <3>
    Base() { cout << "ctor: base" << endl; }
    ~Base() { cout << "dtor: base" << endl; }         // <1>
    virtual ~Base() { cout << "dtor: base" << endl; } // <2>
};

class Derived: public Base {
  private:
    int m_iDataAnimal;
  public:
    Derived() { cout << "ctor: derived" << endl; }
    ~Derived() { cout << "dtor: derived" << endl; }
};

class DDerived: public Derived {
  private:
    int m_iDataDAnimal;
  public:
    DDerived() { cout << "ctor: derived derived" << endl; }
    ~DDerived() { cout << "dtor: derived derived" << endl; }
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base* pbase = new DDerived;

  delete pbase;

  std::cout << "--} main " << std::endl;
}

<1>
--{ main 
ctor: base
ctor: derived
ctor: derived derived
dtor: base
--} main 

<2>
--{ main 
ctor: base
ctor: derived
ctor: derived derived
dtor: derived derived
dtor: derived
dtor: base
--} main 

<3> compile error
sam01.cpp: In function int main():
sam01.cpp:12:5: error: Base::~Base() is protected
sam01.cpp:38:10: error: within this context                 // this on delete statement


<how-virtual-works>
Why only base part when no virtual dtor? The compiler always use static type and vtable for dynamic
binding. The reason is that the base class's vtable is not updated and still have base one. Hence
base dtor calls.

Class1 (base)        <- Class2 (derived)
vtable               vtable
[1] -> C2::ddtor     [1] -> C2::ddtor     // virtual dtor
[1] -> C1::bdtor     [1] -> C2::ddtor     // non-virtual dtor

If base dtor was virtual, vtable is updated, will have code to follow vptr, and call derived dtor
which calls chains up to base. This means that every base shall have virtual dtor. Why not ctor?
Since construction is already done and here is talking about when use base pointer, derived to base.

From {summary-dynamic-binding}, {scope-in-inheritance}, {how-vtable-works}, {override-keyword} can
conclude: for non-virtuals use static type only and for virtuals use vtables as well.

<virtual-and-override>
class A vtable  class B vtable  class C vtable
[1] A::f        [1] { A sub     [1] { A sub
[2] A::f        [2] }           [2] }      
                [3] B::f        [3] { B sub
                [4] B::f        [4] }
                                [5] { C sub
                                [6] }

vptr            vptr            vptr
instances of A  instances of B  instances of C

<key> The virtual and override are different. For C's instances, if functions are overrides and are
virtual, then update related vtable in the chain and if no virtual, compiler will not generate code
to run virtual mechanism and related vtables remains the same and only overriding in C class
happens. Therefore, override is to redefine or hide function in the derived.

<1> One theory. For virtuals, if was overrideded in derived class, then update all vtables of parent
class. All done in compile time and simple code to see vtable. note: this seems to be the case.

<2> The other theory. For virtuals, compiler generate code to decide runtime type and run through
vtable and if was overrided in derived class, update the vtable of that derived class. Needs more
runtime overhead.

note: the above about vtable is wrong and see <vtable-per-class> since there is only one vtable for
all classes in the same inheritance.


{when-use-virtual-dtor}
Because there are costs of virtuals and virtual-destruction-problem, All base class 'must' have
virtual-dtor and these are <1> and <2> as advised in EC++07.

<1> polymorphic base class
designed for inheritance and defined virtual funcs. 'must' use virtual dtor.

<2> base class to extend 
designed for inheritance but no virtual funcs. means no overrides and add more funcs. However, if no
virtual dtor, this causes virtual-destruction-problem. 

<3> a class not to be inherited
designed for no inheritance like STL. DO NOT use virtual-dtor sicne it will increate a size of
instance and make it not portable. See {preventing-inheritance} 


{pure-virtual-dtor}
EC++07. Why use this? Sometimes you have a class that you'd like to be abstract but you don't have
any pure virtual functions. Like <2> base class to extend. 

class AWOW {
  public:
    virtual ~AWOW() = 0;
};

AWOW::~AWOW() {}

The pure-virtual-dtor 'must' have a definition(implementation) and 'must' be implemeted outside
class definitions.

MEC++33. Pure virtual do not mean it has no implementation and means that the class is abstract and
the derived func must be nomal virtual. True, most pure virtual functions are never implemented, but
pure-virtual-dtor are a special-case. They must be implemented, because they are called whenever a
derived class destructor is invoked.  

<example-when-pure-virtual-has-implementation>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;

  public:
    virtual ~Base() {};
    virtual void shout(void)=0;
};

void Base::shout(void)
{ cout << "base shout" << endl; }

class Derived: public Base {
  private:
    int m_iDataAnimal;

  public:
    void sample() { cout << "sample: derived" << endl; }
    void shout(void) { Base::shout(); cout << "derived shout" << endl; }
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Derived d;
  d.shout();

  std::cout << "--} main " << std::endl;
}

--{ main 
base shout
derived shout
--} main 

<example-error>
class ABCAnimal {
  public:
    ...
    virtual ~ABCAnimal() = 0;     # pure-virtual-dtor
};

class Lizard: public ABCAnimal {
  public:
    ...                             # no dtor
};

int main(int argc, char** argv)
{
  ABCAnimal* pabc1;
  ABCAnimal* pabc2;

  cout << "end of main" << endl;
}

Upto here, NO comile error and works fine. However, the following emits errors:

int main(int argc, char** argv)
{
  ABCAnimal* pabc1;
  ABCAnimal* pabc2;

  Lizard liz1;

  cout << "end of main" << endl;
}

GCC error is:

/tmp/cciltEbG.o: In function `Lizard::~Lizard()':
abc.cpp:(.text._ZN6LizardD2Ev[_ZN6LizardD5Ev]+0x16): undefined reference to `ABCAnimal::~ABCAnimal()'
collect2: ld returned 1 exit status

To fix this, add implementation:

class ABCAnimal {
  public:
    ...
      virtual ~ABCAnimal() = 0;       # pure dtor
};

ABCAnimal::~ABCAnimal() {}


={============================================================================
*kt_dev_cpp_019* exception

{intention}
The exception is intended for events that prevent the program from continuing normally. so when
found no matching catch and stop execution of the program; call the library 'terminate' function.

MEC++09: What's different to the approach of returning error code? Exception 'cannot' be 'ignored'
and if do, it is terminated. From MEC++12. The execution return to call site for func call but never
for exception when think that throw is a function call.


{standard-exception}
The 'stdexcept' header defines several general purpose exception classes and the typeinfo header
defines the bad_cast exception type. 

The C++ Standard library provides a base class specifically designed to declare objects to be thrown
as exceptions. It is called std::exception and is defined in the 'exception' header. This class has
a virtual member function called what() that returns a null-terminated character sequence and that
can be overwritten in derived classes to contain some sort of description of the exception. note:
seems that exception header is older one and both works anyway.

<example>
#include <iostream>
// #include <stdexcept>
#include <exception>

using namespace std;

class myexception: public exception
{
  virtual const char* what() const throw()
  {
    return "My exception happened";
  }
} myex;

int main () {
  try
  {
    throw myex;      // see myex but not myex()
  }
  catch (exception& e)
  {
    cout << e.what() << '\n';
  }
  return 0;
}

My exception happened


All exceptions thrown by components of the C++ Standard library derived from this exception class.
These are:

bad_alloc            thrown by new on allocation failure
bad_cast             thrown by dynamic_cast when it fails in a dynamic cast
bad_exception        thrown by certain dynamic exception specifiers
bad_typeid           thrown by typeid
bad_function_call    thrown by empty function objects
bad_weak_ptr         thrown by shared_ptr when passed a bad weak_ptr

Also deriving from exception, exception header defines two generic exception types that can be
inherited by custom exceptions to report errors:

logic_error          error related to the internal logic of the program
runtime_error        error detected during runtime


{stack-unwinding}
A throw-keyword is like a return; statements following a throw are not executed. If no
'matching' catch found, current/calling function is exted until found one in the call tree.

If not found a matching catch and call 'terminate'. If found, run catch and coutinue running from
the the end of the try block catched but not the point where throw is called.

When no try-catch block in the chain, 1,2, and 3 runs only.  

func3()              func2()                func1()
{                    {                      {
   (1)                   (2)                    (3)
   func2();              func1();               throw...;
   (6)                   (5)                    (4)
}                    }                      }


During stack-unwinding, func exits 'prematurely' and means local objects are dstroyed and dtor is
called.


{exception-in-ctor}
Partially constructed. Even if it's partially constructed, guaranteed that the constructed members
will be properly destroyed. From EC++30 p137 and see {empty-ctor-represenstaion}

But from MEC++10, it shows many ways to handle exceptions in ctor so not sure that it is properly
destroyed. Seems EC++ is the latest.


{function-try-block}
Primus p773, 18.1.3 shows function-try to handle exception when do {constructor-initializers} This
is for ctor and dtor as well and to handle exceptions happens before ctor body get runs because
exception handling in ctor body cannot catch it.

1. The members are initialised in the order of defined in class.
2. The parameters are copied using copy-ctor and if exception happens, covered in caller site.
3. Runs constructor-initializers if there are. covered by function-try-block.
4. Runs ctor-body. covered by function-try-block.

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) : data( std::make_shared< std::vector<T>> (il)) 
{}

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) try : data( std::make_shared< std::vector<T>> (il)) 
{}
catch ( const std::bad_alloc& e) { handle_out_of_memory(e); }


{problem-of-exception-in-dtor}
Why exception in dtor is the problem? Since stack-unwinding starts to find matching catch and local
objects are destroyed. If dtor of object being destroyed can raise an execption, then would have two
running exceptions and it is not allowed in C++. EC++08 says that terminate is called or undefined.

The main problem is 'permature'-program-termination which means 'no' chance to do useful things as
resource clean-up and making a log entry in handling exception or before terminating or swallowing.
So premature termination means the undefined state of an application or system.

So no exception in dtor and if necessary, should handle in the same dtor. This is the base
assumption STL has and STL guarantee that any class's dtor will not raise an execption.


{exception-and-resource-managing-class}
To handle exception, shall use resource-managing-class, ie., raii and see {resource-managing-class}
in *kt_dev_stl_018* for various solutions since destruction will be handled when do stack unwinding.


{how-to-handle-exeception-in-dtor}
See {raii-for-resource-using-own-interface} for other examples. From EC++08. General recommendation
is not to raise exception in dtor. If interface to use comes from external source then it could
raise an exception. What to do? These are how to handle when exception happens in dtor.

// think this external source
class DBConnection {
  public:
    ...
    static DBConnection create();    // fatctory-func
    void close();                    // can throw exception
};

// resource managing class
class DBConn {
  public:
    ~DBConn() { db.close(); }

  private:
    DBConnection db;
};

// client use
{
  DBConn dbc( DBConnection::create() );
  ...
}

Two approach to address exception in dtor:

<1> terminate the program
By doing this, make a log entry to see and prevent undefined behavior.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
    std::abort();
  }
}

Can use {noexcept} at below? Seems not as it has the same effect when not handling exaction from a
dtor: no chance to do useful thing such as making a log entry.

<2> swallow the exception
Can be used when the program must be able to continue execution even after exception is happened.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
  }
}

<3> However, said that the better way is:

class DBConn {
  public:
    void close()
    {
      db.close();             // can exception happen
      closed = true;
    }

    ~DBConn() 
    { 
      if(!closed)
      {
        try { db.close(); }
        catch(...) {
          // make log enrtry
          // terminate or swallow
        }
      }
    }

  private:
      DBConnection db;
      bool closed;
};


The client have an opportunity to handle the exception and if the client choose not to handle it
then fall back to default action: terminating or swallowing. It appears that it make raii less
useful and pass the burden on to the client but it is not since it gives them opportunity to handle.
it. See {raii-and-exception-in-dtor} for the point to consider when use raii.

// client use
{
  DBConn dbc( DBConnection::create() );

  try{ dbc.close() }
  catch(...)
  {
    // try to address exception and if successful, set closed to true.
  }
}


{exception-object} user-defined-exception-object
The throw and catch expression use special-object, exception object. If it's a class type, must
have dtor and copy or move op. 

If it's array or func type, it's converted to its pointer type. {QQ}
If it is array, must be in heap since there is no connection between call and called site?

try {
  ...
  throw runtime_error("data must refer to the same"); // throw expression

} catch (runtime_error err) {                         // exception declaration
  ...
  cout << err.what();
  ...
}

Because there's a stack-unwinding, must not to throw a pointer to a local object. Hence exception
object is 'copied' that is manintained by compiler and remains vaild 'until' catched.

Exception is like a functin call and exception declaration is like a function with one param. Like
function call, catch 'parameter' can be non-refernce or reference. If it's class type from inheritance
and non-reference then {sliced-off} *kt_dev_cpp_022* can happen. How can use reference in catch?
Since there is separation between throw and catch site. That is the exception object is held in
'global' space by a compiler.

throw arg -> (copy init) -> exception object -> (copy init) -> catch (param)

#include <iostream>
using namespace std;

class B 
{
  public:
  B() { cout << "B ctor" << endl; }
  B(const B& b) { cout << "B copy ctor" << endl; }
  ~B() { cout << "B dtor" << endl; }
  virtual string what() { return "i'm B"; }
};

class CD : public B
{
  public:
  CD() { cout << "CD ctor" << endl; }
  CD(const CD& b) { cout << "CD copy ctor" << endl; }
  ~CD() { cout << "CD dtor" << endl; }
  string what() { return "i'm CD"; }
};

int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor            // {
going to throw
B copy ctor                            // {  exception object
B dtor            // }
B copy ctor                // {
An exception occurred. Exception Nr. i'm B
B dtor                     // }
B dtor                                 // }
end

<exception-catch-by-reference>
The catch by referecne is recommendation.

1. catch by pointer, do not know if should call delete on it because do not know if it is created by
new or not.
2. catch by value, sliced-off can happen.
3. catch by reference, okay for both problems above.

// example when throw derived and catch base. sliced-off.
int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
B ctor               // {  copy init for derived
CD copy ctor         // }
CD dtor
B dtor
B copy ctor
An exception occurred. Exception Nr. i'm B
B dtor
CD dtor              // { dtor for exception object
B dtor               // } 
end

// example when catch reference
int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
B ctor
CD copy ctor
CD dtor
B dtor               // note to see there is no copy init for catch argument
An exception occurred. Exception Nr. i'm CD
CD dtor              // { dtor for exception object
B dtor               // } 
end

// example when throw base and catch derived
int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (CD& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
going to throw
terminate called after throwing an instance of 'B'
Aborted (core dumped) note: the exception spec mismatches hence terminated.

<exception-type-conversion-and-order>
Limited type conversion for exception. Support 'inheritance'-based-conversion that means catch using
base class type can catch exception object of derived class. Also catch uses the order of appearance
in code, called 'first'-fit strategy compared to 'best'-fit in function-matching.

In STL exception tree, logic_error is higher than invalid_argument

try {
  ...
} catch ( logic_error& ex ) {
  ...
} catch ( invalid_argument& ex ) {
  ...
}

Should be:

try {
  ...
} catch ( invalid_argument& ex ) {
  ...
} catch ( logic_error& ex ) {
  ...
}

Because if first-match is found then look no further. In the first case, if throw base then
terminated called and if throw derived then first catch will run. So second catch never gets run.
Therefore, the catch for base must come first in order. 

<exception-object-always-copied>
The execution returns to call site for func call but never for exception. This means that whenever
throw happens, a copy is 'always' made regardless of catch type whether it is value or reference
because throw leaves a call site. This is natural since there should be execption object anyway.

// example-one
catch( Widget& w )
{
  ...
  throw;
}

Use 'current' exception and throw it again. 'rethrow'. So there is no addtional copy made and w can
be a derived class in Widget inheritance.

// example-two
catch( Widget& w )
{
  ...
  throw w;        // see
}

This create a new Widget type exception and cost copy ctor and dtor even if catch reference. Checked
with code. Therefore, 'rethrow' recommended if possible.


{exception-spec}
Older code may contain dynamic exception specifications. They are now 'deprecated' in C++, but still
supported. A 'dynamic' exception specification follows the declaration of a function, appending a
throw specifier to it. For example:

double myfunction (char param) throw (int);

<exception-spec-mismatch>
This declares a function called myfunction, which takes one argument of type char and returns a
value of type double. If this function throws an exception of some type other 'than' int, the
function calls std::unexpected or std::terminate, which by default calls std::abort()

If this throw specifier is left empty with no type, this means that std::unexpected is called for
any exception. Functions with no throw specifier (regular functions) never call std::unexpected, but
follow the normal path of looking for their exception handler.

int myfunction (int param) throw(); // all exceptions call unexpected. the same as 'noexcept' in C++11
int myfunction (int param);         // normal exception handling 

MEC++14. If there is a mismatch of 'spec' between throw and catch <permature-program-termination>
happens: unexpected() -> terminated() -> abort(). This means no clean-up so should be avoided.

extern void f1();       // may throw anything
void f2() throw (int);  // says it will throw only int type exception

void f2() throw (int)
{
  ...
  f1();
  ...
}

By this, can wrap old code with new code that handles exception. But if f1() raise exception other
than int type, 'violate' f2's exception specification.

How to minimise these?

1. do not mix template and exception spec because do not know T type so not able to write spec.
2. change default handler, unexpected(), to handle those. For example, if we use a library that
raise unexpected exception:

When to use throw()?

Since if an exception happens when it's declared it will not, 'terminate' is called. So two use
cases:

1. when absolutly sure that there's no exception.
2. when not possible to handle an exception. exit the program.

<why-deprecated-and-dynamic>
From stl reference, p24. noexcept targets a lot of problems (empty) exception specifications,
throw(), have. (also lot of problems of specifying the spec)

1. Runtime checking: C++ exception specifications are checked at runtime rather than at compile
time, so they offer no programmer guarantees that all exceptions have been handled. The runtime
failure mode (calling std::unexpected()) does not lend itself to recovery.

2. Runtime overhead: Runtime checking requires the compiler to produce additional code that also
hampers optimizations.

3. Unusable in generic code: Within generic code, it is not generally possible to know what types of
exceptions may be thrown from operations on template arguments, so a precise exception specification
cannot be written.

In practice, only two forms of exception-throwing guarantees are useful: An operation might throw an
exception (any exception) or an operation will never throw any exception. The former is expressed by
omitting the exception-specification entirely, while the latter can be expressed as throw() but
rarely is, due to performance considerations.

Especially because noexcept does not require stack unwinding, programmers can now express the
nothrow guarantee without additional overhead. As a result, the use of exception specifications is
'deprecated' since C++11. <Q> not clear

<noexcept-operator>
void recomp(int) noexcept;    // C++11 style

The noexcept on both the declaration in the class header and on the definition if that appears outside
the class.

class Foo {
  public:
    Foo( Foo&& ) noexcept;
    ...
};

Foo::Foo( Foo && ) noexcept : // member initializers
{
  ...
}

<default-exception-handler>

class UnexpectedException { };

void convertUnexpected()
{ throw UnexpectedException(); }

set_unexpected( convertUnexpected );

This convert <all-unhandled-exception> to UnexpectedException and there should be catch for that
type. This means to set default exception handler.

OR

void convertUnexpected()
{ throw; }

set_unexpected( convertUnexpected );

This convert all to <bad_exception> but no detail about why. Q: why bad_exec?

<another-permature-program-termination>
This can block a exception handling of higher level. If logDestruction is declared that raise no
exception but raise it, then terminated and do not reach to ~Session().

Session::~Session()
{
  try {
    logDestruction(this);
  }
  catch(...) { }
}


{self-assign-exception-safe}
See {self-assign} for reasons why need to handle self-assign. Also if not, then it's not exception
safe as well. If this is exception safe, then lhs state shouldn't change when new raise exception,
but the below don't and the below isn't exception safe.

// NO self-assign and exception-safe in valuelike case
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  delete ps;
  auto newp = new string(*rhs.ps);
  ps = newp;
  return *this;
}

// combine dtor and copy. handle self-assign and exception-safe by moving delete after new.
// careful-statement-ordering
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

EC++11. Making operator= exception-safe typically renders it self-assign-safe too. So think about
exception-safe only. Alternatively, can use {copy-and-swap-idiom} in *kt_dev_cpp_006*


{exception-safe-gurantees}
EC++29. Two requirements for exception safety when exception happens:

NO resource leak and NO change of object state.

Therefore, a function can offer one of four gurantees:

1. none. no exception safety.
2. basic. valid object state but can be any state and not be predictable.
3. strong. unchaned object state as if they'd never called.
4. noexcept. never throw exception.
 
<example>
// from the bad example
void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  Lock ml(&mutex);

  delete bgImage;
  ++imageChanges;
  bgImage = new Image(imgSrc);
};

// offer strong

class PrettyMenu {
  ...
  std::shared_ptr<Image> bgImage;
  ...
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  Lock ml(&mutex);

  bgImage.reset( new Image(imgSrc) );  // bad_alloc or ctor exception
  ++imageChanges;
};

The deletion of old image takes place 'only' if the new image is successfully created because reset
will be called only if the parameter is successfully created.

note: This offers 'almost' strong guarantee and offers the basic exception since if the parameter
imgSrc constructor throws an exception, possible that the read marker for the input stream has been
moved and such movement would be a change in state visible to the rest of the program.

General design to lead to the strong guarantee: use {copy-and-swap-idiom} and {pimpl-idiom} in
*kt_dev_cpp_006* 

<copy-and-swap-idiom-case>
Make a copy and all changes to the copy. If any of the modifying operation throws an exception, the
original remains 'unchanged'. After all changes have been successfully completed, swap the modified
with the original in non-throwing swap operation.

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

HasPtr& HasPtr::operator=(const HasPtr rhs)  // note. not ref and it's copy
{
  ...                // operations to change the copy if there are more to do
  swap(*this, rhs);
  reutn *this;       // rhs is destroyed, which deletes the old ps.
}

<pimpl-idiom-case>
This is the same as copy-and-swap and is different from usual pimpl-idiom. The object has a pointer
to the implementation that has all object data. This can be rewritten as general design although
offer no better gurarantee than the previous for this particular example.

struct PMImpl {
  std::shared_ptr<Image> bgImage;
  int imageChanges;
};

class PrettyMenu {
  private:
    std::shared_ptr<PMImpl> pImpl;
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
  using std::swap;

  std::shared_ptr<PMImpl> pNew( new PMImpl(*pImpl) );

  pNew->bgImage.reset( new Image(imgSrc) );  // bad_alloc or ctor exception
  ++pNew->imageChanges;

  swap(pImpl, pNew);
};

<exception-safety-is-difficult>
Although copy-and-swap-idiom is a good way for strong but doesn't guarentee that the overall
function is strongly exception safe.

void someFunc()   // uses copy-and-swap
{
  ...
  f1();
  f2();
  ...
}

Although f1 and f2 provide strong exception, difficult to have strong for someFunc to guarantee
since the state of the program is not the same as it was when someFunc was called, even though f2
didn't change anything. f1 has strong exception but may change state.

Two reasons for difficulty:

1. side effect
As long as functions operate only on local state, relatively easy to offer the strong guarantee but
when on non-local data, it's much harder such as database.

2. efficiency
Copy and swap idiom requires more space and time.

<recommendation>
The strong guarantee is desiable but not always practical. Especially, when use third party or
legacy code which do not provide exception safety. In other words, can offer no stronger than the
weakest guarantee of the functions it uses.

Aim to provide basic guarantee which is resonable for many functions and think carefully about
strong safety: if it's practical in terms of efforts, cost in efficiency and complexity, how many
functions should have strong safety. 80-20 rule?


{rethrow}
Partially handle the exception and rethrow it up to the chain.

catch( myerror& eobj ) {
  eobj.status = errCodes::severeErr;
  throw;
}


{exception-cost}
MEC++15. Exception has cost:

1. If not use exception, can save speed and space penalty. There is compiler option to disable it.

2. the cost of try and exception spec in space varies from compiler to compiler. As a rough
estimate, expect your overall code size to increase by 5-10% and your runtime to go up by a similar
amount if you use try blocks. So try to 'minimise' the use.

<80-20-rule>
But think 80-20 rule and that exception is rare. The recommendation is that think if it is feasible
not to use exception, if can minimise, if can use other compiler showing better exception
implementation, and if use profiler to find out 20% to use exception.

<exception-to-disable>
From stackoverflow and said G++ specific.

Option #1: Simply never catch exceptions. {QQ} really?

Exceptions don't have much overhead when they're not thrown or caught; if you're throwing and not
prepared to catch, well, you're doing to die anyway, so the performance impact at that point is
trivial. Note also that stack unwinding will not be performed if an exception is not handled; the
program will simply terminate without performing stack unwinding.

It's important to note that, in G++, exceptions have almost no overhead when not actually thrown.
G++ generates extra information sufficient to trace back the execution of the program through the
stack, and some extra code to invoke destructors, etc - however none of this extra code or data is
ever used until an exception is actually thrown. So you should not see a performance difference
between code with exceptions enabled but not used and code with exceptions disabled (through
whatever mechanism).

Q: not sure it means never throw or never catch.

Option #2: Pass -fno-exceptions.

This flag instructs G++ to do two things:
http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html

All exception handling in STL libraries are removed; throws are replaced with abort() calls Stack
unwind data and code is removed. This saves some code space, and may make register allocation
marginally easier for the compiler (but I doubt it'll have much performance impact).  Notably,
however, if an exception is thrown, and the library tries to unwind through
-fno-exceptions code, it will abort at that point, as there is no unwind data.

This will, effectively, turn all exceptions into abort()s, as you would like. Note, however, that
you will not be allowed to throw - any actual throws or catchs in your code will result in a
compile-time error.

Option #3: (Nonportable and not recommended!) Hook __cxa_allocate_exception.

C++ exceptions are implemented using (among others) the __cxa_allocate_exception and __cxa_throw
internal library functions. You can implement a LD_PRELOAD library that hooks these functions to
abort():

void __cxa_allocate_exception() { abort(); }
void __cxa_throw() { abort(); }

WARNING: This is a horrible hack. It should work on x86 and x86-64, but I strongly recommend against
this. Notably, it won't actually improve performance or save code space, as -fno-exceptions might.
However, it will allow the throw syntax, while turning throws into abort()s.


={============================================================================
*kt_dev_cpp_020* move semantics

{why}
In some circumstances, an object is 'immediately' destroyed after it is copied. In those cases,
moving rather than copying the object can provide a significant performance boost. Or IO or
unique_ptr classes which cannot be copied but can be moved.

note: In previous library, class stored in a container had to be 'copyable'. Under new standard, can
use container on types that cannot be copied so long as they can be moved.

<own-allocation-example>
StrVec example which is a simplification of the library vector class. Like vector, supports
reallocation. If there is not enough space left, then obtains new space, moves the existing elements
into that space, free the old space, and adds the new elements.

| 0 | 1 | 2 | 3 | 4 | unconstructed elements |

^                     ^                        ^
elements              first_free               cap

class StrVec {
  public:
    std::string* begin() const { return elements; }
    std::string* end() const { return first_free; }
    ...
  private:

    static std::allocator<std::string> alloc;

    std::string *elements;
    std::string *first_free;
    std::string *cap;
    ...
};

<copy-context> valuelike

pair<string*, string*>
StrVec::alloc_n_copy( const string *begin, const string *end )
{
    // allocate space to hold as many elements as are in the range
    auto data = alloc.allocate( end - begin );     // iterator-arithmetic

    // uninitialized_copy 'construct' copies of given elements in 'uninitialized' space.
    // return { begin, end }
    return { data, uninitialized_copy( begin, end, data ) };
}

StrVec::StrVec( const StrVec& s )
{
    // memeber function to allocate and copy exactly as many elements as in s
    auto newdata = alloc_n_copy( s.begin(), s.end() );
    elements = newdata.first;
    first_free = cap = newdata.second;
}

void StrVec::free()
{
    // may not pass deallocate a null pointer. moves backwards
    if(elements)
    {
        for( auto p = first_free; p != elements; /* empty */ )
            alloc.destroy(--p);

        alloc.deallocate( elements, cap - elements );
    }
}

StrVec::~StrVec() { free(); }

StrVec &StrVec::operator=( const StrVec &rhs )
{
    // for self-assign
    auto data = alloc_n_copy( rhs.begin(), rhs.end() );
    free();
    elements = data.first;
    first_free = cap = data.second;
    return *this;
}


<reallocation>
The string is valuelike and has own memory for those characters. When copy a string, the new and the
old are independent from each other. However, when reallocates copies, there will be only 'one' user
after the copy and as soon as copy is done, no need to keep the old.

So copying the data in these strings in the old is 'unnecessary' in this case so StrVec's
'performance' will be much better if can avoid the overhead of allocating and deallocating the
strings themselves each time we reallocate.


<how-to-avoid-coping>
Two facilities by C++11. 

1. move constructor. 
Several library classes, including string, define so called move constructor. Presumably the string
move ctor copies the pointer rather than allocating spaces.

2. std::move().
The library 'move' which is defined 'utility' header. Two things. must use move to signal it want to
use the string move ctor. Otherwise, copy ctor will be used. Use std::move() not move().

void chk_n_alloc() 
{ if( size() == capacity() ) reallocate(); }

void StrVec::push_back( const string &s )
{
    chk_n_alloc();

    // note: construct() calls string's copy ctor
    alloc.construct( first_free++, s );
}

void StrVec::reallocate()
{
    auto newcapacity = size() ? 2 * size() : 1;

    auto newdata = alloc.allocate(newcapacity);

    auto dest = newdata;      // start in the new array
    auto elem = elements;     // start in the old array

    // note: construct() calls string's move ctor. move existing elements.
    for( size_t i = 0; i != size(); ++i )
        alloc.construct( dest++, std::move(*elem++) );

    // note: this frees up the old allocated memory and string element but not string's memory for
    // characters
    free();

    elements = newdata;
    first_free = dest;
    cap = elements + newcapacity;
}

note: the std::move() returns a result that cause construct() to use the string move ctor.


{rvalue-reference}
An rvalue reference is obtained by using '&&' rather than '&'. Has 'important' property that be bound
'only' to an object that is about to be 'destroyed'. As a result, free to 'move' resource from an
rvalue reference(moved-from) 'to' another object(moved-to).

<lvalue-and-rvalue>
In C, lvalue could stand on the left-hand side of an assignment whereas rvalues could 'not'. In C++
this distinction is less simple. Generally speaking, when use an object as an rvalue, use the
object's value(its contents) and when use lvalue, use the object's identity (its location in
memory).

From ansic: In C, any assignment, such as "c = getchar()" is an expression and has a value, which is
the value of the left hand side after the assignment. This means that an assignment can appear as
part of a larger expression, such as "while((c = getchar()) != EOF)"

These, lvalue/rvalue, are 'properties' of an expression. Expressions yield or require rvalue/lvalue.
Operators 'differ' as to whether require lvalue or rvalue operands and as to whether return lvalue or
rvalues. Some yield or require lvalues and others yield or require rvalues:

Assignment requires a (nonconst) lvalue as its left hand operand and yields its left-hand operand as
an lvalue.

The address-of operator(&) requires an lvalue operand and returns a 'pointer' to its operand as an
'rvalue'.

<example> show that x++ returns rvalue which is the previous.
int main(int argc, char* argv[])
{
  int x = 10;
  int* pint;

  pint = &(++x);
  pint = &(x++);        // error: lvalue required as unary & operand
}


<bindings> like const 
Binding properties for lvalue reference is that cannot bind regular(lvalue) reference to expression
that requires a conversion, to literals, or to expression that return an rvalue. Rvalue properties
have the opposite. The important point is that can use lvalue when an rvalue is required but cannot
use an rvalue when lvalue is required.

int i = 42;

int &r = i;             // okay  bind lvalue to lref
int &&rr = i;           // error bind lvalue to rref
                        // since cannot bind an rvalue reference to an lvalue.

const int &r3 = i*42;   // okay  bind rvalue to 

int &r2 = i*42;         // error bind rvalue to lref.
int &&r2 = i*42;        // okay  bind rvalue to rref.

note: NEEDs more understanding?


<rvalue-is-temporary> implicit move sementics
Functions that 'return' a nonreference type, along with the arithmetic, relational, bitwise, and
postfix increment/decrement operators, all yield rvalues. So can bind rvalue to such expressions.

Looking at the list of rvalue and lvalue expressions, lvalue has 'persitent' state, whereas rvalue
are either literals or 'temporary' objects created in the course of evaluating expressions.

The rvalue reference can only be bound to temporaries: the referred-to object is about to be
destroyed and there can be 'no' other users of that object. So the code that uses an rvalue
reference is 'free' to 'take' over resources from the object to which the reference refers.


{std-move}
This is defined in <utility> header and to 'return' rvalue reference to an lvalue.

int &&rr = std::move(rr1);
moved-to             moved-from

Essentially to tell or signal compiler that we do 'not' intend to use rr1 again except to 'assign'
to it or destroy it. So after move, cannot make any assumptions about the value of the moved-from
object. note: Think a string case that can destory string object itself and can assign new memory
for characters. 


<why-std-move>
Since there is argument dependant lookup, if user defines move() then overloading rule picks up the
right version. However, std::move is template and rvalue matches to 'any' type so name collision are
more likely but less likely to be intentional. Therefore, suggest fully qualified one, std::move().


<move-context>
See 'no' const in parameter and noexcept since do 'not' allocate any new memory and take over the
memory from its argument. See <noexcept-keyword> for more.

After move, the moved-from object continues to 'exist' and eventually will be destroyed, meaning
that the dtor will be run on that. That is 'why' set pointer members null not to deallocate memory
in dtor and eventually free(). Otherwise, would delete the memory we have taken over. Also thus is
'why' do not have const on s since changes its state.

StrVec::StrVec( StrVec&& s ) noexcept
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    // leave s(moved-from) in a state in which it is safe to tun the dtor
    s.elements = s.first_free = s.cap = nullptr;
}

The move assign does the same work as the dtor and the move ctor. If move assign won't throw any
exceptions, should make it noexcept and must guard against self-assignment.

StrVec &StrVec::operator=( StrVec &&rhs ) noexcept
{
    // direct test for self-assignment. note "&rhs" is address of rhs.
    if( this != &rhs )
    {
        // free existing elements
        free();    

        // member initializers take over the resources from rhs. this is move as with move ctor.
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;

        // leave rhs(moved-from) in a destructible state
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }

    return *this;
}


<destructible-state>
Be careful about meaning of move: The actual move happens on elements which is string in this
case and move is done by copying and setting pointer members in StrVec POV and is not to free the
memory moved. This is a meaning of taking over the resources in s, StrVec.

Moving from an object does not destroy that object. Therefore, must ensure that the moved-from
object is in a state in which the dtor can be run. In this example, if not set these pointer members
null, there shall be a problem when dtor runs and calls free().

In addition to that, move operations guarantee that the object remains 'valid' meaning that can runs
operations but no guarantees/assumptions about its 'value'. Can safely be given a new value or used
in other ways that do not depend on its current value. StrVec move leave the moved-from object in
the same state as a default initialized object and other classes may behave differently.


{synthesized-move-operations}
If class do not define copy ctor and assign then compiler 'always' make these operations; defined
either as memberwise or deleted.

Move operations are different. The compiler make move operations 'only' if a class does 'not' define
any copy ctor and assign and 'only' if all data members can be move ctored and assigned. So if class
has own copy ctor and assign then move will 'not' be synthesized.

// the compiler will synthesize the move operations for X and hasX
struct X {
  int i;
  std::string s;
};

struct hasX {
  X mem;
};

X x, x2 = std::move(x);          // use the synthesized move ctor
hasX hx, hx2 = std::move(hx);

If class defines either move ctor and/or move assign, the synthesized copy ctor and copy assign will
de defined 'deleted' So class that define move operations 'must' also define own copy operations.
Otherwise, those members are deleted by default.


{copy-or-move}
When class has both a move and copy ctor, how does the library know what to use? Use function
matching since copy ctor takes const StrVec& and move only takes StrVec&&.

StrVec v1, v2;
v1 = v2;                   // copy assign

StrVec getVec(istream &);  // assume getVec returns an rvalue
v2 = getVec(cin);          // note: move assign
   
Like const, can bind lvalue to rvale but cannot bind rvalue to lvalue. So in the second assign, both
are viable but copy assign requires conversion to const. Hence move is used since it is exact match.


{conditions-to-use-move}
1. noexcept on move
The library containers provide guarantees as to what they do if an exception happens; vector
guarantees that if an exception happens when call push_back, the vector itself will be left
unchanged.

Imagine that push_back in StrVec causes reallocation as vector, uses move ctor but exceptions
happens in the middle of moving. There would be a problem. However, if used copy ctor, not a problem
when exception happens since the original copy still remains. Like, exception safe condition in
using dynamic resources.

To avoid this potential problem, vector must use a copy ctor instead move during reallocation
'unless' it knows that 'element's type move ctor cannot throw an exception. How to tell the library
that move ctor is safe to use? Do so by using explicitly noexcept keyword on move ctor and assign.

2. copy is bigger than move 
Using the copy controls in place of move controls is safe and will meet the requirement of move
controls since objects is moved by copying operations. In other words, copy controls are more of
necessary to work properly, move controls are more of performace choice so if there are no move
operations, copy controls will be used instead.

If a class has no move operations, copy operations will be used 'even if' attempt to use move by
calling std::move().

// define copy but no move operations
class Foo {
  public:
    Foo() = default;
    Foo(const Foo&);
};

Foo x;
Foo y(x);                  // copy ctor
Foo z( std::move(x) );     // copy ctor

Here copy initialization happens but std::move returns rvalue, Foo&&, but no move ctor. So can
convert a Foo&& to const Foo&, copy ctor is viable and it is called. "can bind rvalue to
lreference".


<move-example>
Using the HasPtr copy-and-swap example this shows that single assignment operator acts as both copy
and move assign.

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

HasPtr& HasPtr::operator=(const HasPtr rhs)  // note. not ref and it's copy
{
  ...                // operations to change the copy if there are more to do
  swap(*this, rhs);
  reutn *this;       // rhs is destroyed, which deletes the old ps.
}

If add move ctor to HasPtr class then effectively add move assign as well. The assign operator is
both the move and copy assign. note that this is from copy-and-swap-idiom which is for valuelike
case. Hence move is safe.

class HasPtr {
  public:
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i), { p.ps = 0; }

    // note: HasPtr& operator=(const HasPtr rhs)
    HasPtr& operator=(HasPtr rhs)
    { swap(*this, rhs); return *this; }
    ...
};

Since operator=() uses nonreference type, uses copy initialization. Depending on the type of
argument, it uses either the copy ctor or the move ctor.

HadPtr hp, hp2;

hp = hp2;                        // copy assign is viable
hp = std::move(hp2);             // move assign is exact match

In the second assignment, std::move return rvalue and move assign used. Since copy-and-swap do
allocation and deallocation and allocation is done by move, there are no other thing to do to
maintaion move assign behaviour. So no need to have move assign.

note: see <nonmember-friend-swap> for swap in HasPtr
This was HasPtr& operator=(const HasPtr rhs) in the original example as copy context and do not have
const now as move context even if the code of function is the same. Means that swap works always
regardless of const. Why? Here swap works on built-in type, pointer which is not affected by
constness check; bitwise const.


{move-iterator-adaptor}
The StrVec::reallocate can be rewritten using move iterator which would be easier. The
initialized_copy copy and costruct elements but there is no analogous to move. Instead, library
defines move iterator adaptor which changes the behavior of iterator's dereference operator to
'fetch' elements; return rvalue or lvalue. 

void StrVec::reallocate()
{
  auto newcapacity = size() ? 2 * size() : 1;
  auto first = alloc.allocate(newcapacity);

  // 'before'
  // for( size_t i = 0; i != size(); ++i )
  //  alloc.construct( last++, std::move(*elem++) );

  // 'after'
  auto last = uninitialized_copy( make_move_iterator( begin() ), make_move_iterator( end() ), first );

  free();   // member which destroy and deallocate

  elements = first;
  first_free = last;
  cap = elements + newcapacity;
}


note:
STL makes no guarantees about which algorithms can be used with move iterators or which cannot since
move can disappear the source. Should pass move iterators to algorithms only when confident that
algorithms does not access an element after it has assigned to that element.


{move-can-be-dangerous}
Since moved-from object has 'indeterminate' state, std::move is a dangerous operation. When we call
std::move must be certain that there can be 'no' user of the moved-from object. Judiciously use
class implementation such as move operations for significant performance benefit.

Use it in user code(outside of class implementation) ONLY when 'certain' that you need to do a move
and is guaranteeted to be safe.


{move-and-overload}
Member functions other than constructors and assignment can benefit from providing both copy and
move versions.

copy version: lvalue reference to const
move version: rvalue reference to nonconst

class StrVec {
  public:
    void push_back( const std::string& );
    void push_back( std::string&& );
    ...
};

void StrVec::push_back( const std::string& s )
{
  chk_n_alloc();
  alloc.construct( first_free++, s );
}

void StrVec::push_back( std::string&& s )
{
  chk_n_alloc();
  alloc.construct( first_free++, std::move(s) );   // use string move ctor
}

StrVec vec;
string s = "some string or another";

vec.push_back(s);                                  // calls push_back(const string&)
vec.push_back("done");                             // calls push_back(string&&). temporary string.


note:
Move operations is about moving pointers and nothing special about that. The std::move is to signal
to compiler to pick up move operations. The std::move() doesn't itself do any moving, but merely
converts its argument into a so-called rvalue reference.


{assign-to-rvalue} 
Can call a member function regardless of whether that is an lvalue or rvalue.

auto n = ( s1 + s2 ).find('a');

Here assign to the rvalue result of concatentating these strings.

s1 + s2 = "wow!";

<reference-quailifier>
Prior to the new standard, no way to prevent such usage. The new standard have a way to prevent such
usage by forcing the left-hand operand to be an lvalue.

The reference qualifier indicate the lvalue/rvalue property of 'this' in the same way that define
const member function.

class Foo
{
    public:
        // may assign only to modifiable lvalue
        Foo &operator=( const Foo & ) &;           // note: "&"
};

Foo &Foo::operator=( const Foo &rhs ) &
{
    // do whatever is needed to assign rhs to this object
    return *this;
}

May run a function qualified by & only on an lvalue and by && only on an rvalue.

Foo &retFoo();    // return a reference
Foo retVal();     // return by value; a call to retVal is an rvalue

Foo i, j;
i = j;

retFoo() = j;
retVal() = j;     // error: retVal() returns an rvalue

i = retVal();


={============================================================================
*kt_dev_cpp_021* op overload

{two-considerations}
When design a class, should think about what operations the class will provide and then two:

o whether to define each operation as an ordinary function or overloaded operator?
o if use overloaded operator then whether to be member or nonmember?

{default-arguments}
Except for overloaded function call operator, overloaded operator must not have default arguments.


{member-or-non-member}
Whether to implement op overloads as either a member or non-member?

<assign-op> 
assign("=") should be member.

<symmetric-op>
arith, equality, relational or mixed-type arith that is commutative should be non-member.  

Why? think string u = "hi" + s; since a literal do not have member operations.

<io-op>
IO ops(<<, >>) should be non-member and usually a 'friend' since uses private members. If these are
member op then can use like:

Sales_data data;
data << cout;

This is against to usual syntax. Why? Because when overloading op, lhs must be a class in which op
is defined.

class Sales_data {
   ostream& operator<<( ostream& str ) const;
};

If want to use usual syntax like cout << data then means to change STL ostream class but cannot.
Therfore, these ops should be non-member. TODO: more explanation.

ostream& operator<<( ostream& os, const Sales_data& item )
{
  os << item.isbn() << " " << item.revenue() << ...
    return os;
}

note: no const for ostream& since it writes to stream and change its status and const and reference
for Sales_data


{member-op}
For member op, the first(left hand, lhs) operand is bound to the implict this pointer. This implies:

data1 += data2;

is 'always' equi to:

data1.operator+=(data2);

Why not 'data2.operator+=(data1);' as these are the same type? because 'data2 = data1+data2' is
different.


{equal-and-relational} operator-less
There is a subtle difference between equal and relational(operator <) as to define 'ordering'.

<equal>
bool operator==( const Sales_data *lhs, const Sales_data *rhs )
{
    return lhs.isbn() == rhs.isbn() &&
        lhs.units_sold == rhs.units_sold &&
        lhs.revenue == rhs.revenue;
}

bool operator!=( const Sales_data *lhs, const Sales_data *rhs )
{
    return !(lhs == rhs);
}


<operator-less>
The relational should be consistent in both "strict weak ordering" and "equal". Suppose there are
two Sales_data object which has the same ISBN but different other members. 

Then operator==() treats them 'unequal' but compareIsbn() which is operator less and is used in
ordered container, treats them 'equal' since neither of which is "less than" the other.

So the ordering depends on how plan to use the class. For Sales_data class there is no single
logical defintion of < so better not to define < at all.


={============================================================================
*kt_dev_cpp_022* inheritance

{subobject-and-derived-to-base-conversion}
The dynamic-binding at run-time so called run-time binding because static-type is different from
dynamic-type and it is from inheritance. This is:

pointer or reference of base class = the one of derived class;
<static-type>                        <dynamic-type>

1. this is an exception to normal type-match as this is a conversion between different types. See
{type-match-exceptions}

2. do not know which object to bind until runtime. 

Subobject is key to how inheritance and dynamic-binding works. From MEC++. Inheritance give rise to
pointer and reference with two different types: static and dynamic type.


{conceptual-structure-of-deirved-object}

| ----------- |
|  base part  |
| ----------- |
| drived part |   // non-static members
| ----------- |

Quote item; Bulk_quote bulk;

# implicit derived-to-base-conversion for ref and pointer.

Quote* p = &item;
p = &bulk;

Quote& r = bulk;

If do followings with p or r:

1. calls non-virtual funcs of base then get base version. static
2. calls virtual funcs of base then get derived version. dynamic
3. calls any func of derived then compile error. static
4. deference and copy then sliced-off. static

class Bulk_quote : public Quote {
  public:
    double net_price( std::size_t ) const override;
};

double print_total( ostream& os, const Quote& item, size_t n ) // Quote-reference
{
  double ret = item.net_price(n);                              // virtual-call
  os << ... ;
  return ret;
}

Quote item;
Bulk_quote bulk_item;

print_total( item );          // Quote version
print_total( bulk_item );     // Bulk version. dynamic-binding.


{sliced-off} {static-binding} {dynamic-binding}
The staic binding is done at compile time. copy-ctor and copy-assign are func calls and
derived-to-base-conversion happens when base's copy-int and copy-assign is called.

class Foo {
  Foo(const Foo&);
  Foo& operator=(const Foo&);
};

The compiler always use static-type and if it is a virtual call then will generate a code for
run-time binding and could calls derived version. However, this could be broken if fails to override
in the derived.

// example-one where item is base and bulk is derived

Quote item(bulk);         # sliced-off
item = bulk;              # sliced-off

// example-two

From MEC++33. When there are concrete classes like this:

base <- derived1
     <- derived2

The problem case is:

obj = obj;               # the same class. fine
baseobj = derivedobj;    # sliced-off
derivedobj = baseobj;    # compile error

From GCC:
sam_slice.cpp:51:7: error: no match for 'operator=' in 'lo = bo'
sam_slice.cpp:51:7: note: candidate is:
sam_slice.cpp:30:8: note: Derived& Derived::operator=(const Left&)
sam_slice.cpp:30:8: note:   no known conversion for argument 1 from 'Base' to 'const Derived&'
note: this is a syn coy-ctor that a compiler created.

*baseptr = *baseptr;     # the same class. fine
*baseptr = *baseptr;     # diff. base = derived. sliced-off. <1>
*baseptr = *baseptr;     # diff. derived = base. sliced-off. <2> no-compile-error

Why different in result? Because a compiler use <static-type> and only base part will be copied for
<1> and <2>.

So two problems here:

1. sliced-off with no comiple error can happen when use pointer
2. real programmers write code like this.

How can we make it compile error to flag up two cases, <1> and <2>, in compile time? That is to make
it difficult to use incorrectly. <Q> TODO: So what's the solution? need to summarise the followings again.

<approach-one> 
Make operator= virtual. May thought it can use virtual mechanism. MEC++ said that derived's version
will be called and shall have the same params for virual funcs. But the return can be different.

class Base {
private:
	Animal& operator=(const Base& rhs); 
	...
};

class Derived: public Base {
public:
	Derived& operator=(const Base& rhs);
	...
};

However, in GCC 4.6.3, the params of virtual function can be different and derived's version is not
called. Note: Q: Changed in C++11?

Note: MEC++ seems to be wrong as a compiler use static-type and base version gets called. So don't
need to consider.

Note: see {override-keyword} and need to sum up if needed.

<approach-two-and-three>
Make operator= private and protected. Do not work when *pbase1 = *base2;

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is private
sam_slice.cpp:92:13: error: within this context

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is protected
sam_slice.cpp:92:13: error: within this context

So not a solution.


<approach-to-make-abstract-class>
To remove sliced-off cases, make the base abstract and all derived on the same level. MEC++ says it
as make non-leaf classes abstract.

This only enables copys between objects in the same class whether it is via object or pointer.

But MEC++ says it is more about uncovering the design need to have abstract class out of derived
classes.


{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for that function.
However must define every virtual function regardless of whether it is used because do not know
which version of a function is called until run time. note: to make a vtable in compile time.


{virtual-and-resolution}
The compiler generates code to decide at run time which function to call when a virtual function is
called through a reference or pointer. This is run time binding and polymorphism in C++.


{preventing-inheritance}

<1>
class Last 'final' : Base { ... };

<2>
Use private ctor. See {{control-the-number-of-object}}


{constructor-initializers-in-inheritance}
Unless we say otherwise, the base part of a derived is 'default' initialized.

The usual way is:

class Disc_quote : public Quote {
  public:
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

};

If omit base ctor, then base part, Quote, is default-init.

class Disc_quote : public Quote {
  public:
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      quantity(qty), discount(disc) {}

};

As for ctor, 'copy' controls must explicitly call base part and otherwise has 'oddly configured'
object such as the derived part copied as expected but the base part 'default'-init. note: dtor is
the only exception that do only for its own part.

class Base {
  public:
    Base(int val) { ... }
};

class Left: public Base {
  public:
    Left(int val) {}
    ...
};

sam_slice.cpp: In constructor 'Left::Left(int)':
sam_slice.cpp:27:32: error: no matching function for call to 'Base::Base()'

Because Base has another ctor so default-ctor will not be made and shows this error.


{call-base-in-virtual-of-derived}
Use scope operator. This is called circumventing the virtual mechanism; base version do work common
to all types and the derived version do whatever additional work.

class Window {
  public:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow: public Window {
  public:
    virtual void onResize()
    {
      Window::onResize();
      ...
    }
};


{base-class-pointer-container} {RTTI}
<problem-one>
MEC++03: In inheritance, base pointer can point to derived class and when passes a array of derived
instead of base, <undefined-result> can happen.

class BalancedBST: public BST { };

void printBSTArray(ostream& s, const BST array[], int numElements)
{
  for (int i = 0; i < numElements; ++i) {
    s << array[i]; // this assumes an operator<< is defined
  } 
} // for BST objects

Because array[i] is *(array+i) and means can end up with wrong place. This warning applies to
deleting arrays like: delete [] array;

{Q} what is the real problem here? how does it relate to base class pointer? 

<problem-two> when use dynamic_cast
EC++27. Use smart-pointers to base to access 'any' possible derived class. Only SpecialWindow
support blinking. Means that need to have to check its type at rumtime.

class Window { ... }
class SpecialWindow: public Window {
  public:
    void blink( ... );
    ...
};

typedef std::vector<std::shared_ptr<Window>> VPW;
                                    ^^^^^^
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow* psw = dynamic_cast<SepecialWindow*>( iter->get() ) )
  {                        ^^^^^^^^^^^^
    psw->blink();
  }
}

Undesirable because dynamic_cast is slow and also need to know to which type the object should be
cast since dynamic_case 'must' refer 'complete' object. Means already you know what it is.

<dynamic_cast-vs-virtual>
From Primus C++ 19.2 RTTI:
The dynamic_cast operator is the part of RTTI(run-time type identification). These operators are
useful when we have a derived operation that we want to perform through a pointer or reference to a
base-class object and it is not possible to make that operation a virtual function. Ordinarily, we
'should' use virtual functions if we can.

<problem-three>
From MEC++33: when showing virtual operator= to support mixed type assign in inheritance.

Derived& Derived::operator=(const Base& rhs)      # virtual member op
{
	 const Derived& rhs_derived = dynamic_cast<const Derived&>(rhs);

	 // proceed with a normal assignment of rhs_derived to left *this
}


<when-dynamic-cast-fails>
If a dynamic_cast to a pointer type fails, the result is 0. Error-reporting strategy for pointer.
For reference, bad_cast exception. 

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
  // use the Derived object to which dp points

} else {  // bp points at a Base object

    // use the Base object to which bp points
}


<solution-one> type-safe container

typedef std::vector<std::shared_ptr<SpecialWindow>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
  (*iter)->blink();
}

Remove dynamic_cast BUT limited to SpecialWindow only. Not other possible derived class.


<solution-two> use virtual func in the hierarchy

class Window { 
  public: >
   virtual void blink {}      // def-impl. do-nothing
};

class SpecialWindow: public Window {
  public: >
   virtual void blink( ... ); // do real work
};

typedef std::vector<std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
   (*iter)->blink();
}


{derivation-access-specifier}
This has no effect on the single inheritance which is between direct base and the derived. The
purpose is to control the access of 'users'; user of derived class and derived class from the
derived. If omits this, it will be private by default. 

class X : publuc/private/protected B {
  ...
};

<on-derived-base-conversion>
As with this, this remains the same when derived to base conversion happens. That is: 

User code may use the derived to base conversion only if inherits publicly from base and may not
for other derivations.


{typeid-operator}
typeid allows to check the type of an expression:

typeid (expression)

This operator returns a reference to a constant object of type type_info that is defined in the
standard header <typeinfo>. A value returned by typeid can be compared with another value returned
by typeid using operators == and != or can serve to obtain a null-terminated character sequence
representing the data type or class name by using its name() member.

<example>
#include <iostream>
#include <typeinfo>

using namespace std;

int main () {
  int * a,b;
  a=0; b=0;
  if (typeid(a) != typeid(b))
  {
    cout << "a and b are of different types:\n";
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
  }
  return 0;
}

// on GCC 4.6.3, VM.
a and b are of different types:
a is: Pi
b is: i

// on the text.
a and b are of different types:
a is: int *
b is: int  

note: The string returned by member name of type_info depends on the specific implementation of your
compiler and library. It is not necessarily a simple string with its typical type name, like in the
compiler used to produce this output. 

When typeid is applied to classes, typeid uses the RTTI to keep track of the type of dynamic
objects. When typeid is applied to an expression whose type is a polymorphic class, the result is
the type of the most derived complete object:

<example>
// typeid, polymorphic class
#include <iostream>
#include <typeinfo>
#include <exception>
using namespace std;

class Base { virtual void f(){} };
class Derived : public Base {};

int main () {
  try {
    Base* a = new Base;
    Base* b = new Derived;
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
    cout << "*a is: " << typeid(*a).name() << '\n';
    cout << "*b is: " << typeid(*b).name() << '\n';
  } catch (exception& e) { cout << "Exception: " << e.what() << '\n'; }
  return 0;
}

// on GCC 4.6.3, VM.
a is: P4Base
b is: P4Base
*a is: 4Base
*b is: 7Derived

// on the text.
a is: class Base *
b is: class Base *
*a is: class Base
*b is: class Derived

Notice how the type that typeid considers for pointers is the pointer type itself (both a and b are
of type class Base *). However, when typeid is applied to objects (like *a and *b) typeid yields
their dynamic type (i.e. the type of their most derived complete object).

If the type that typeid evaluates is a pointer preceded by the dereference operator (*), and this
pointer has a null value, typeid throws a bad_typeid exception.


={============================================================================
*kt_dev_cpp_023* override

{dynamic-binding} polymorphism
<words>
Polymorphism is derived from a Greek words meaning "many forms".

<cpps-answer>
Oppose to compile-time static binding, the compiler generates 'code' to decide at run time which
function to call. This dynamic binding or virtual mechanism based on the fact that the static and
dynamic types of reference and pointers can differ is how C++ supports polymorphism.

Polymorphism in general is when a piece of a program is designed to allow multiple different types
to be used in it.

'static' polymorphism is a use of polymorphism that is determined when the program is constructed
(such as the Template system in C++). Once the program is constructed, the choice is made and the
type used is known.

'dynamic' polymorphism is determined at run time. (Such as a pointer to a base class that allows for
descendant class pointers to be passed in. The base class provides the interface and the
descendants implement that interface in different ways that are suitable to the specifics of
the class.) Decisions are made during run time that choose which type to pass.

The important distinction is deciding at construction (compile) or run time. Generally, a well
designed static polymorphism performs better than dynamic, so it is to be preferred when the design
makes it possible. If the information to make a choice is not available until run time, dynamic is
the choice.


{override-condition}
To override, 'name' and 'args' type should be the 'same' but 'return' type is an exception to this
when that is a pointer or reference.

#include <iostream>

using namespace std;

class Base {
  public:
    virtual int fcn() { cout << "base: fcn" << endl; }
};

class D1 : public Base {
  public:
    // bool fcn() { cout << "d1: fcn" << endl; }
    int fcn(int) { cout << "d1: fcn(int) " << endl; }
};

class D2 : public D1 {
  public:
    int fcn() { cout << "d2: fcn" << endl; }
};

int main()
{
  Base bobj; D1 d1obj; D2 d2obj;

  Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;

  bp1->fcn();
  bp2->fcn();
  bp3->fcn();

  D1* dp1 = &d1obj;
  dp1->fcn();           // hide
  dp1->Base::fcn();     // can call explicitly
  dp1->fcn(1);
}

base: fcn
base: fcn
d2: fcn

base: fcn
d1: fcn(int) 

<name-hide-in-override>
When argument is different, two things happens:

1. Used virtual but no override due to different argument. No vtable update and hence base version.
2. Effectively defines a new function in the derived and 'hide' the name in the base. To resolve a
call, dp1->fcn(), compiler look for name fcn in D1 since uses static type and found fcn and stops
the search. However, this name expects int argument so compile error:

sam01.cpp:32:12: error: no matching function for call to D1::fcn()
sam01.cpp:32:12: note: candidate is:
sam01.cpp:13:9: note: int D1::fcn(int)
sam01.cpp:13:9: note:   candidate expects 1 argument, 0 provided

Effectively, D1 has two functions named fcn and can call fcn() explicitly. Hiding name affects name
lookup. This is why name and arguments 'must' be the same to override.

<return-type-in-override> 
when return type is different, errors

sam01.cpp:13:10: error: conflicting return type specified for virtual bool D1::fcn()
sam01.cpp:7:17: error:   overriding virtual int Base::fcn()
sam01.cpp:18:9: error: conflicting return type specified for virtual int D2::fcn()
sam01.cpp:13:10: error:   overriding virtual bool D1::fcn()

note: However, tried pointer return type, no errors so return type in overrides can be different
only that is pointer. See p606 in ref-CPR.


{override-keyword}
As for <2> case, this hide a name in the derived and derived version is not called as expected. It's
surprisingly hard to find because there is no compile error. To avoid this, use override keyword
from C++11 and cause compile error when it's not overrided:

class B {
  void f1(int) const final;
  virtual void f2();
  void f3();
};

class D : public B {
  void f1(int) const;      // error
  void f2() override;
  void f3() override;      // error
};

# VC error for f3 case:
error C3668: 'Derived::sample' : method with override specifier 'override' did not override
any base class methods

The final-keyword is used to end override as with final-keyword in inheritance.


{default-arg-in-virtual}
The default arg in 'virtual' func will 'always' be used base's one even when the drived version is
run because default arg is statically bound. So the recommendation is that should use the same
argument values in the base and derived. See {default-arg}

Problem case is:

class Shape {
  public:
    enum ShapeColor { Red, Green, Blue };
    virtual void draw( ShapeColor color = Red ) const = 0;
    ...
};

class Rectangle : public Shape {
  public:
    virtual void draw( ShapeColor color = Green ) const;
    ...
};


={============================================================================
*kt_dev_cpp_024* abstract base class

<before> This is the previous approach to support several discounts:

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};

<problem>
Imagine that want to support several discount strategies by defining a new class. How? Two
approaches.

1. Define a class which represents each strategy under Bulk_quote. For example:

Quote -> Bulk_quote -> School_quote
                    -> Xmas_quote
                    ...

However, Bulk_quote do not represent the general concept.

2. Modify Quote to support discount strategy and in this case, move up data members to Quote from
Bulk_quote. What if there are already so many classes and use codes tied up with Quote?

<after> Have seperate Disc_quote to represent the general concept but make it abstract class to
prevent users creating a object of this type.

So each discount class will inherit from Disc_quote and Disc_quote represent the general concept of
a discounted book, not a concrete discount policy.

class Disc_quote : public Quote {
  public:
    Disc_quote() = default;
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

    // pure virtual function
    double net_price(std::size_t) const = 0;

  protected:
    std::size_t quantity = 0;
    double discount = 0.0;
};

class Bulk_quote : public Disc_quote {
  ...
};

note: this ABC has implementation details in a class.
note: this ABS has no destructor.
note: pure virtual function can has definition. see {pure-virtual-dtor}
note: Q. If ABC has class type member data which requires construction and destruction? Need a
destructor?

<construction> 
Why define constructors in abstract class although cannot define objects of this type directly?
because of constuction and destruction chain. See {non-virtual-destruction-problem} If user do not
provide ctors, compiler will provides so ther always is construction chain but base class will be
default initialized. In this example, base part is not initialized with values from derived
constructor.

<refactoring>
This is refactoring example. Refactoring involves redesigning a class hierarchy to move operations
and/or data from one class to another. It is that even though we changed the inheritance hierarchy
code that uses Bulk_quote or Quote would 'not' need to change but need to recompile.


{error-when-create-abc}
This happens when tries to create an implementation class which is derived from ABC class; that is
interface class. Why? because implementation class did not override some of members.

/port/CPort.cpp: In static member function 'static CPort* CPort::getInstance()':
/port/CPort.cpp:36:27: error: cannot allocate an object of abstract type 'CPort'
/port/CPort.h:29:1: note:   because the following virtual functions are pure within 'CPort':
/interface/port/IPort.h:48:22: note: 	virtual IIframe* IPortingLayer::getIframe()
/interface/port/IPort.h:56:23: note: 	virtual ISession* IPortingLayer::getSession()
/port/CPort.cpp: In constructor 'CPort::CPort()':
/port/CPort.cpp:46:25: error: cannot allocate an object of abstract type 'CIframe'
/port/CIframe.h:27:1: note:   because the following virtual functions are pure within 'CIframe':
/interface/port/IIframe.h:73:18: note: 	virtual void IIframe::destory(uint32_t)
/interface/port/IIframe.h:80:18: note: 	virtual bool IIframe::isDisplayed()
/interface/port/IIframe.h:86:18: note: 	virtual bool IIframe::setDisplayFlag()
/interface/port/IIframe.h:94:18: note: 	virtual bool IIframe::isMHEG2(void*, uint32_t)
/interface/port/IIframe.h:102:18: note: 	virtual bool IIframe::isMHEG4(void*, uint32_t)

<key> Why? When deriving a ABC class, if don't override a pure virtual func then the derived also
becomes ABC. Hence errors.

This may be a way to check whether overrides happens or not? Yes, when use ABC and only one
override. No when not use ABC and there are multiple overrides down the inheritance.


={============================================================================
*kt_dev_cpp_025* 


={============================================================================
*kt_dev_cpp_026* enum {enum-hack}

The enumerations group together sets of integral 'constants' and defines 'new' type. From ansic,
there are two advantages over #define:

1. provide a convenient way to associate constant value with names.
2. a debugger may be able to print values of enumeration variables. confirmed on gcc.


{scoped-enum}
C++11. note that used 'class' keyword. Defines an object of 'open_modes' type and follows scoping
rule means 'type'-erorr can happen. Scope means to specify explicitly where it come from

// see that "enum class"
enum class open_modes { input, output, append };

note: see the difference enum and struct; for enum, do not use "enum open_modes" as a stuct one.
open_modes readfile = open_modes::input;
open_modes readfile = 2;                     // error

Why this error? Unlike C, implicit conversions to and from int are not possible.

<in-c>
enum color eyes = green;   // okay
enum color eyes = 2;       // okay


{unscoped-enum}
The enumerator is const and need 'not' be unique. <Q> shall be unique? By default, start at 0 and
inc by 1.

enum color { red, yellow, green };           // unscoped
enum stoplight { red, yellow, green };       // error: redefines enumerators
error: conflicting declaration red
error: red has a previous declaration as main()::color red

enum class peppers { red, yellow, green };   // okay: enumerators are hidden

color eyes = green;                          // okay for C++ unlike C

// error: enumerators from peppers are not in scope. color::green is in scope but has the wrong
// type.
// error: cannot convert main()::color to main()::peppers in initialisation
peppers p = green;

color hair = color::red;
peppers pp = peppers::red;

enum { floatPrec = 6, doublePrec = 10, double_doublePrec = 10 };  // unnamed, unscoped

<key> C++11 enum support scope and type checks


{conversion} {enum-hack}
The 'unscoped' enumerators are implicitly converted to 'int' but not vice versa. Can be used where
an integral value is required. Called <enum-hack>. By default scoped enums have int as the
underlying type. There is no default for unscoped enums; all we know is that the underlying type is
large enough to hold the enumerator values.

int i = color::red;
int j = peppers::red;   // error <Q> why is this?

class GamePlayer {
  private:
    enum { NumTurns = 5; }

    int scopes[NumTurns];
    ...
};


{func-with-enum-arg}
Cannot pass an integral value to an enum parameter but can pass an object or enumerator of unscoped
enumaration to a parameter of integral type; the enum promotes to int or to a larger integral type.

enum Tokens { INLINE = 128, VIRTUAL = 129 }

void ff(Tokens);
void ff(int);

Tokens curr = INLINE;

ff(128);       // ff(int)
ff(INLINE);    // ff(Tokens)
ff(curr);      // ff(Tokens)


={============================================================================
*kt_dev_cpp_027* volatile

This is non-portable feature. For values that is controlled by processes outside the direct control
of the program and might be changed in ways outside the control of the program.

It's a directive to the compiler telling that is shoud not perform 'optimisations' on such objects.


={============================================================================
*kt_dev_cpp_028* namespace

{case-example}
03/07/2014. At samsung. 
When moves application which was a process and uses static link to the shared library application to
be used by other processes. The codes which works well before starts to fail since crash happens
when try to create a thread using custom thread library. 

Problem of linking? Problem of the thread library when used in shared library application? Somehow
linker picks up the wrong libaray since a debugger shows odd address when thread creation call is
made and causes a crash? 

Tried various directions and spent many days. Eventually, found out that PCThread::Create() is a
problem and works fine when changes parameter orders. The problem was that the process loads a lot
of shared library and one of those has the same PCThread class in it but different signature. When
our library make a call, it picks it up from the other shared library in which has different
signature so crashes. Sovled when wraps PCThread class with a namespace.

note: So this was a problem of symbols between shared libraries.

The typical example is to use third party library and name conflict happens when other parties
develops a libaray separately. Howerver, in static link, conflict happens in link stage. In dynamic
loading, this happens at run time and called dynamic binding. So more difficult to find out.

See *kt_linux_core_107* shared library: search and resove


{namespace}
To solve name pollution or collisions, namespace partitions the global namespace and a namespace is
a scope. It provides a much more controlled mechanism and any declaration can be put into a
namespace.


{global-namespace}
Names defined at global scope are in the global-namespace which is implicitly declared and exists in
every program. The scope operator can be used. <key> use "::" for global variables.

::member_name


{named-namespace}
note: The namespce definition do not ends with a semi-colon.

namespace Foo {
  ...
}

<namespace-is-a-scope>
Code outside the namespace must indicate the namspace in which the name is defined.

cplusplus_primer::Query q = cplusplus_primer::Query("Hello");

<can-be-discontiguous>
The namespace either defines a new namespace or adds to an existing one. Be sure only #include
appear before opening the namespace. If not, attempt to define all the names in that header as
members of the enclosing namespace. 

<key> The declaration and definition should be in the same namespace and this means shall use
namespace block in 'both' header and source file as well.

// Sales_data.h
#include <string>

namespace cplusplus_primer {
  class Sales_data { ... };
  Sales_data operator+( const Sales_data&, const Sales_data&);
  // declarations for the remaining functions in the Sales_data interface
}

// Sales_data.cpp
#include "Sales_data.h"

namespace cplusplus_primer {
  // definitions for the Sales_data members and overloaded operators
}

// user.cpp
#include "Sales_data.h"

int main()
{
  using c_plusplus_primer::Sales_data;
  Sales_data trans;
  ...
}

<use-marco>

#define NS_OPEN namespace XXX {
#define NS_CLOSE }

# header or source file

# include <xxx>

NS_OPEN
...
NS_CLOSE


{unnamed-namespace} {file-static}
Unnamed namespace. variables in unnamed namespace has staic lifetime so has file scope as with file
static. If a header file has vars in unnamed namespace, it create different static vars which are
local to file that includes that header file. This also means that unnamed-namespace never spans
multiple files and do 'not' recommend to have it in a header since the names in that namespace define
different entities local to each file that includes the header.

<key> This replace file-static of C. *kt_dev_lang_001*

namespace {
  ...
}

<example>
#include <iostream>

int i;         // 3

namespace {
   int i;      // 6
}

int main()
{
   i = 10;     // 11. ambiguous: defined globally and in an unnested, unnamed namespace.

   return 0;
}

sam01.cpp: In function int main():
sam01.cpp:11:2: error: reference to i is ambiguous
sam01.cpp:3:5: error: candidates are: int i
sam01.cpp:6:6: error:                 int {anonymous}::i

<same-as-static>
For static variable, try to use extern keyword and fails to link in the end. This is the same when
use unnamed namespace. If not use extern then have multiple definition error. 

<global-variables>
Can use namespace for global variables:

// file one
namespace NG {
  int gfs_count;
}

// file two
namespace NG {
  extern int gfs_count;
}


{using-declaration-and-directive}
The <using-declaration> which brings one namespace member into the scope that uses it.

using std::cin;

The <using-directive> which brings whole namespace into the the scope that have both a namespace and
a scope that uses directive. This is enclosing scope that is outter scope than the one uses
directive.

using namespce std;

<avoid-use-of-directive>
Why? Other than else, 'late'-detection; means that ambiguity errors are detected only at the point
of use when use directive. This late detection means that conflicts can arise long after introducing
a particular library. If the program begins using a new part of the library, perviously undetected
collisions may arise.

// example. blip namespace is injected into the global namespce but no compile error. Emit error
// when strat to use j. At a point of use.

#include <iostream>

namespace blip {
  int i=16, j=15;
}

int j = 0;

int main()
{
  using namespace blip;

  //++j;

  return 0;
}


// example. immediate compile error regardless of using j. At a point of declaration.
// sam01.cpp:9:13: error: j is already declared in this scope

#include <iostream>

namespace blip {
  int i=16, j=15;
}

int j = 0;

using blip::j; 

int main()
{
   return 0;
}


<avoid-use-in-header-file>
Why? A header that has a using directive or declaration at its top-level injects names into every
file that includes the header. 

<when-directive-useful>
One place where using directive are useful is in the implementation files of the namespace itself.


{nested-namespace}
namespace X { 
  namespace App {
    class X : public XXX
    {
      ...
    };
  }
}


={============================================================================
*kt_dev_cpp_029* nested class

The type member is a local name and unlike ordinary members, type member must appear before they are
used. So usually appear at the beginning of the class.

class Screen {
  public:
    typedef std::string::size_type pos;

  private:
    pos cursor = 0;
};


Called nested-type and think it as nested-scope. Most used to define implementation class. This
defines <type-member> of enclosing class. Means:

o no connection between objects. do not have memebers of each other.
o nest class is only visible in its enclosing class.

When use? Tightly coupled to enclosing class so little sense to use nested class for any other
purpose.

class TextQuery {
  public:
    class QueryResult; // to be defined later but seen before use.

    ...
};

class TextQuery::QueryResult {
  friend std::ostream& print(..);

  public:
  QueryResult( ... );
  ...
};

Unlike the previous {text-query-example}, no need to define QueryResult::line_no because nested
class can have direct access to enclosing class.

enclosing scope {
  nested scope {
    ...
  }

}


={============================================================================
*kt_dev_cpp_050* template. debug-delete

The types become known during complilation in generic programming whereas OOP deals with types that
are not known until run times.

The STL library algorithms are function template and containers are class template.


{space-in-template-expression}
The requirement to put a space between two closing template expressions has gone:

vector<list<int> >;  // OK in each C++ version
vector<list<int>>;   // OK since C++11


{function-template}
For function template, the compiler uses the argument of call to 'deduce' the template argument type
which is to determine what type to 'bind' to the template parameter T.

compare( 1, 0 );
compare( vec1, vec2 );

template <typename T>   // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

<principle-to-write-generic-code>
Here two important principles to write generic codes from this example:

1. The function parameters in the templeate are reference to const.
This makes the function runs faster and also it can be uses with types that cannot be copied such as
unique_ptr. Why? do not need to copy.

2. Used only < comparison. More genarally, reduce the requirement on underlying type. Type
independence and portability. Can write it as:

template <typename T>
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v1 > v2 ) return 1;
  return 0;
}

<example> 
#include <iostream>
#include <vector>

template<typename T>
void printElements( const T& col )
{
  for( const auto& elem : col )
    std::cout << ":" << elem << std::endl;
}

int main()
{
  std::vector<int> v{ 1, 2, 3 };

  for( auto ele : v )
    std::cout << ":" << ele << std::endl;

  printElements(v);
}

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

# error case as should be 'typename U'
template <typename T, U> inline T calc( const T&, const U& );

# can use typename or class but recommands typename
template <typename T, class U> inline T calc( const T&, const U& );


<overloading-and-templates>
function templetes can be overloaded by other templates or by ordinary nontemplate functions. The
things to remember is:

As shown function-matching, nontemplate and then the more speciailized function are preferred.


{instantiation}
Ordinarily, when call a function, the compiler needs to see only a declaration. Similarly, when use
objects of class type, the class definition must be available but the definition of the member
functions need not be present. As a result, put class definition and function declaration in header
file and definition of ordinary and class member function is source files. 

Templates are 'different' since the compiler generates code 'only' when use a template; instantiate
a specific instance of the template. So to generate an instantiation, needs to have the code that
defines a function and class template member function. As a result, headers includes definitions as
well as declarations.

Generic programming. 'instantiation' is a process that create a concrete 'independent' function or
class from a template when compiling. Code generation and these compiler generated function or class
are an 'instantiation' of the template. Must be defined in the same namespace that contains the
original template. See p675 for C++ feature to control this.  note: what does it mean?


{class-template}
Unlike function-template, compiler 'cannot' deduce the type of parameter so user must provide
'additional' information to instantiate it. That is an element type.

Also it is up to the user to gurantee that the template argument support any operations that
template uses, and that those operations behave correctly in the context in which the template uses
them. Include headers for any type to instantiate that template.


<example> 
This is the original StrBlob class from C++P p455 which show how to implement a new collection type
to share.

This shows when shared_ptr is useful than own raii since this case don't have 'copy-controls' and
use syn versions but not a problem as it has only one member which is shared_ptr.

class StrBlob {
  friend class StrBlobPtr;

  public:
    typedef std::vector<std::string>::size_type size_type;

    StrBlob();
    StrBlob( std::initializer_list<std::string> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const std::string &t ) { data->push_back(t); }
    void pop_back();

    std::string& front();
    std::string& back();

    // return a copy object like iterator. vector[0] and vector[size] that is off-the-end
    //
    // note: how the weak pointer in StrBlobPtr get set from *this
    StrBlobPtr begin() { return StrBlobPtr(*this); }
    StrBlobPtr end() { reutn StrBlobPtr(*this, data->size(); }

  private:
    std::shared_ptr<std::vector<std::string>> data;
    void check( size_type i, const std::string &msg ) const;
};

# ctors

StrBlob::StrBlob: data( make_shared<vector<string>> ()) {}
StrBlob::StrBlob( initializer_list<string> il ) : data( make_shared<vector<string>> (il)) {}

# see that return type is void when raise an exception.

void StrBlob::check( size_type i, const string &msg ) const
{
  if( i >= data->size() )
    throw out_of_range(msg);
}

string& StrBlob::front()
{
  check( 0, "front on empty StrBlob" );
  return data->front();
};

string& StrBlob::back()
{
  check( 0, "back on empty StrBlob" );
  return data->back();
};

string& StrBlob::pop_back()
{
  check( 0, "pop_back on empty StrBlob" );
  return data->pop_back();
};


This is the template-version of the same. No longer specific to string.

template<typename T>
class Blob {
  public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type; // <use-class-type-members>

    Blob();
    Blob( std::initializer_list<T> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const T &t ) { data->push_back(t); }
    void pop_back();

    T& front();
    T& operator[](size_type i);

  private:
    std::shared_ptr< std::vector<T>> data;
    void check( size_type i, const std::string &msg ) const;
};


<extra-information>
Unlike function template, must provide the element type which is extra information and is template
argument which binds to tempalte parameter. Use these argument to instantiate a 'specific' class
from the template. constitutes an 'independent' class.  So 'specialization' is what compiler do.

Blob<int> ia;
Blob<int> ia2 = { 0, 1, 2, 3, 4 };
Blob<string> names;

These use the same "type-specific" version of Blob<int>. From these definitions, compiler will
instantiate a class:

template <> class Blob<int> {
  typedef typename std::vector<int>::size_type size_type;
  Blob();
  Blob(std::initializer_list<int> il);
  ...
  private:
    std::shared_ptr<std::vector<int>> data;
    ...
};


<instantiated-type>
A class template is used to instantiate a 'type' and an instantiated type always includes template
arguments.

shared_ptr< vector< T >>      -> shared_ptr< vector< string >>
                                 shared_ptr< vector< int >>


<template-member-function>
For member functions of class template, it is instantiated 'only' if it is used and if not, it is
not instantiated.

To write a member function of class template in 'outside' of class definition, remember that the
instantiated type is a new type and must say to which class the member belongs.

template <typename T>
void Blob<T>::check( size_type i, const std::string &msg ) const
{
  if( i >= data->size())
    throw std::out_of_range(msg);
}


{template-friend}
When a class contains a friend declaration, the class and the friend can independently be template
or not.

<one-to-one>
The one-to-one friendship is the most common form of friendship from a class template to another
template( class or function ).

// forward declaration needed for friend declaration in Blob

template <typename T> class BlobPtr;
template <typename T> class Blob;
template <typename T> bool operator==( const Blob<T> &, const Blob<T> & );

template <typename T> class Blob {

    // each intantiation of Blob grants access to the instantiation of BlobPtr and the equality
    // operator with the same type. Use Blob's template parameter.

    friend class BlobPt<T>;
    friend bool operator==<T>( const Blob<T> &, const Blob<T> & );
};

note: Here intantiation means both intantiated type and objects.


<one-to-many>
Can also make every(all) instantiation(type) of another template its friend or may limit friendship
to a specific instantiation.

note: See C++P 665 for more.


{template-static}
As with a static in ordinary class, there must be exactly one definition of each static member. Each
instantiation has its own instance of static members.

template <typename T> class Foo {
  public:
    static std::size_t count() { return ctr; }
    ...
  private:
      static std::size_t ctr;
};

template <typename T>
size_t Foo<T>::ctr = 0;

Foo<int> fi;

auto ct = Foo<int>::count();     // via scope operator
ct = fi.count();                 // via an object


{use-class-type-members} <typename-keyword>
Uses scope operator(::) to access both static member and type members. e.g., string::size_type. In
nontemplate code, the compiler has access to the class definition and knows whether a name accessed
through the scope operator is a type or static member.

However, in template code, when it see code such as T::mem, won't know 'until' instantiation whether
name is a type or a static member. By default, the language assumes that a name accessed through the
scope operator is 'not' a type. So if want to use type member of template must 'explicitly' tell.

template<typename T> 
typename T::value_type top( const T& c )
{
  if( !c.empty() )
    return c.book();
  else
    return typename T::value_type();      // "typename T::value_type" is a type
}

EC++42. This is called 'dependant' type names since it depends on the template parameter. This
causes 'parsing' difficulty and this is why must tell it to compiler and use 'typename' but not
class.

template<typename T>
void print2nd( const T& container )
{
  T::const_iterator iter( container.begin() );           // iter is dependant name
  ...
}

template<typename T>
void print2nd( const T& container )
{
  typename T::const_iterator iter( container.begin() );  // must use typename
  ...
}

The exception to this is when typename is used in base class type. Suppose that if it have to use
typename in this case, then how difficult it is to parse. Suppose Nested is a type(class) in this
example.

template<typename T>
class Derived: public Base<T>::Nested {               // not use typename here
  public:
    explicit Derived(int x) : Base<T>::Nested(x) {    // not use typename here
      typename Base<T>::Nested temp;                  // use as usual
      ...
    }
    ...
};


Use typedef alias for a dependant name. This example is to create a local variable which is the type
pointed by a iterator.

template<typename iterT>
void workWithIterator(iterT iter)
{
  typename std::iterator_traits<iterT>::value_type temp(*iter);
  ...
}

template<typename iterT>
void workWithIterator(iterT iter)
{
  typedef typename std::iterator_traits<iterT>::value_type value_type;
  value_type temp(*iter);
  ...
}


{template-default-argument}
Under new standard, supports default argument for both function and class template while the earlier
version support only for class.

o function template

The rewritten example of the previous example and see that F represent the type of a callable
objects.

template <typename T>
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

template <typename T, typename F = less<T>>        // default template argument, the type of callable 
int compare( const T &v1, const T &v2, F f = F())  // default function argument, F()
{
  if( f(v1, v2) ) return -1;
  if( f(v2, v1) ) return 1;
  return 0;
}

See what user can call.

bool i = compare(0,42);

Sales_data item1(cin), item2(cin);

bool compareIsbn( const Sales_data &lhs, const Sales_data &rhs )
{
    return lhs.isbn() < rhs.isbn();
}

bool j = compare( item1, item2, compareIsbn );

note: If type of item1 supports operator<() then the previous works and if not, this version using
compareIsbn() works. Matter of choice?


o class template

template <typename T, typename container = vector<T>>
class MyClass;

template <typename T = int> 
class Numbers {
  public:
    Numbers(T v = 0): val(v) {}
  private:
    T val;
};

Numbers<long double> lots_of_precision;

The empty braket says we want the 'default' type to instantiate.

Numbers<> average_precision;


{member-template}
Either an ordinary class or class template may have a member function that is itself a template;
member template. See this word ordering since it summarise that it is member function and function
template.

note: member template may 'not' be virtual.

<with-ordinary-class>
The member template of ordinary class from C++P 672. This example is similar to the default
unique_ptr and deleter since overloads operator(). To support any type, use template.

// function object class as a replacement for delete
class DebugDelete {
  public:
    DebugDelete( std::ostream& s = std::cerr) : os(s) {}

    // note: as with any function template, the type of T is 'deduced'

    template <typename T> void operator() (T* p) const
    { os << "deleting unique_ptr" << std::endl; delete p; }

  private:
    std::ostream& os;               // note: reference-member
};


#include <iostream>
#include <string>
#include <typeinfo>

using namespace std;

class DebugDelete
{
  private:
    ostream &os;

  public:
    DebugDelete(ostream &s = cerr) : os(s) {}

    template<typename T>
      void operator() (T* p) const
      { os << "deleting " << typeid(p).name() << ", p = " << p << endl; delete p; }
};

int main()
{
  double *pd = new double();
  int *pi = new int();
  DebugDelete d;

  cout << "in main" << endl;

  d(pd); // now instantiated
  d(pi); // now instantiated

  cout << "end main" << endl;
}

in main
deleting Pd, p = 0x9be7008
deleting Pi, p = 0x9be7018
end main

Since it uses delete internally, can be used with unique_ptr:

unique_ptr<int, DebugDelete> p( new int, DebugDelete() );
unique_ptr<string, DebugDelete> p( new string, DebugDelete() );

How will DebugDelete be instanticated for these cases? These are equivalent to:

void DebugDelete::operator() (int*) const { delete p; }
void DebugDelete::operator() (string*) const { delete p; }

Why? Whenever unique_ptr's dtor is instantiated, DebugDelete's call operator will also be
instantiated.

After all, whether it is for ordinary class or class template, member template is function template
so compiler 'deduce' the type of func template when used(instantiated) so these will be instantiated
to correct type when deleter is called.


<with-template-class>
Both the class and member have their own, independent, template parameters so must provide both.

template <typename T> class Blob {
  template <typename It> Bolb(It b, It e);
  ...
};

template <typename T>
template <typename It>
   Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b,e)) {}

Blob<int> a1( begin(iarray), end(iarray));
Blob<int> a1( ivec.begin(), ivec.end());
Blob<string> a1( svec.begin(), svec.end());

As with "with-ordinary-class", function parameter types are 'deduced' as it is function template.


{control-instantiation}
The fact that instantiations are 'generated' when a template is used means that the same
instantiation may appear in multiple object files. This overhead can become significant in large
systems. Under new standard, can avoid this through explicit instantiation.

That is to instruct compiler generate all members for specific type and to say there is somewhere in
the program.

// file1.cc

// "instantiation declaration"
extern template class Blob<string>;
extern template int compare( const int&, const int& );

// instantiation(code) will appear elsewhere
Blob<string> sa1, sa2;

// Blob<int>, initializer_list ctor, and copy ctor instantiated in this file.
Blob<int> a1 = { 0, 1, 2, 3, 4 };
Blob<int> a2(a1);

// instantiation(code) will appear elsewhere
int i = compare( a1[0], a2[0] );


// file2.cc
// compiler generate 'all' members when see "instantiation definition" and must link file1.o with
// file2.o 

template class Blob<string>;
template int compare( const int&, const int& );

Therefore, "instantiation definition" can be used only for types that can be used with every member
function of a class template.


={============================================================================
*kt_dev_cpp_051* template: type transformation

{function-template-explicit-arguments} when use template type for a return
To allow the user 'specify' the type of template arguments. Why? Since in some cases, not possible
for the compiler to deduce the types and in others want to allow the user control it.

<when-cannot-deduce>
Since the resurn, T1, do not appear in the function parameter list, cannot be deduced. The caller
'must' provide an "explicit template argument" on each call to sum. note: The user can choose
whatever precision is approciate.

template< typename T1, typename T2, typename T3 >
T1 sum( T2, T3 );

auto val3 = sum<long long>(i, lng);          // long long sum( int, long )


<can-specify-all>
The "explicit template argument" matches from left to right and the below is poor design since to
use T3, will have to specify all of them. BTW shows that it is possible to specify all of them.

template< typename T1, typename T2, typename T3 >
T3 alternative_sum( T2, T1 );

alternative_sum<long long, int, long>(i, lng);


<normal-conversion>
As with <normal-conversion-for-ordinary-argument>, the same applies on "explicit arguments".

long lng;

compare( lng, 1024 );            // error since parameters do not match
compare<long>( lng, 1024 );      // okay. compare( long, long )
In other cases, "explicit template argument" imposes a burden on the user. What's alternative?

template< typename T > 
??? &fcn( It beg, It end )
{
    // process the range
    return *beg;  // return a reference to an element from the range
}

vector<int> vi = { 1, 2, 3, 4 };
Blob<string> ca = { "hi", "bye" };

auto &i = fcn( vi.begin(), vi.end() );    // should return int&
auto &i = fcn( ca.begin(), ca.end() );    // should return string&

Do not know the exact type to return but know that want that type to be a reference to the element
type of the sequence.


<trailing-return-type> C++11
May use decltype(*beg) to get the type but beg don't exist until the parameter list has been seen.
How to solve? The trailing return type allows us define the return type after the parameter list is
seen.

template< typename T > 
auto &fcn( It beg, It end )    -> decltype(*beg)
{
    // process the range
    return *beg;  // return a reference to an element from the range
}


<type-transformation>
How to return value instead in this example? The problem is that we know almost nothing about the
types we're passed. To obtain the element type (as opposed to reference to element), use "type
transformation" template in the "type_traits" header.

The remove_reference has one type parameter and public type memeber, type, which is the
'referred-to-type'. 

remove_reference<int&>     // type is int

template< typename T > 
auto &fcn( It beg, It end )    -> typename remove_reference<decltype(*beg)>::type
{
    // process the range
    return *beg;  // return a reference to an element from the range
}

note: See another example of explicit argument in template function pointer.


={============================================================================
*kt_dev_cpp_052* template: argument deduction

{template-argument-deduction}
For function template, this is process of determining the template arguments from the function
arguments. In other words, this is a binding from function parameter to template parameter.

<limited-conversion>
Only allows two converison in a call to function template but not others such as derived-to-base,
     arithmetic, and user defined conversion.

o nonconst-to-const and array or function-to-pointer conversion.

<more-than-one-type>
The function template can have more than one type to allow normal conversion on the arguments.

template <typename T>   // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

long lng;
compare( lng, 1024 );      // compare( long, int );

This is an error since compare do not have the same type. To allow normal converison:

template <typename A, typename B>
int flexibleCompare( const A& v1, const B& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

Of course, < operator must exist that can compare those types.

<normal-conversion-for-ordinary-argument>
template <typename T>
ostream &print( ostream &os, const T &obj )
{
    return os << obj;
}

print( cout, 42 );         // print( ostream&, int )

ofstream f("output");
print( f, 10 );            // convert ofstream to ostream&


{argument-deduction-and-reference}

1. deduction from lvalue reference function parameters

template <typename T> void f1( T& );

f1(i);
f1(ci);
f1(5);      // error since & cannot bound to rvalue and must be an lvalue.

template <typename T> void f1( const T& );

f1(5);      // okay since const & can be bound to rvalue.

so use "const T&" to pass 'any' type.


2. deduction from rvalue reference function parameters

template <typename T> void f1( const T&& );

f3(5);      // T is int
f3(i);      // T is int&

In this case, T is deuced to "int &" due to collapising rule, C++P 688. (not understand fully). The
important thing to remember is that can pass 'any' type of argument to T&& function parameter;
rvalue or lvalue.

<implication>
This matters when write template.

template <typename T> void f3( T&& val )
{ 
    T t = val;
    t = fcn(t);
    ...
}

o when call f3 on rvalue, T is int and "int t = val". so t and val is independant.
o when call f3 on lvalue, T is int& and "int& t = val". so when change t, will change val as well.

note: In summary, when pass rvalue on rvalue reference parameter, T is "type" and when pass lvalue
on rvalue parameter, T is "type &".

It is suprisingly difficult to write code that is correct when type is plain nonreference or
reference type. In practice, rvlue reference used in one of two context: argument forwading or
template overload.

// const overloading
Record lookup( account & );      // non-const version
Record lookup( const account &); // const version

// copy and move overloading
void push_back( const X& );
void push_back( X&& );

template <typename T> void f( const T& );       // binds to lvalue and const rvalue
template <typename T> void f( T&& );            // binds to nonconst rvalue


<std-move-example>
Again, copied from {copy-or-move}:

Like const, can bind lvalue to rvale but cannot bind rvalue to lvalue. So in the second assign, both
are viable but copy assign requires conversion to const. Hence move is used since it is exact match.

In other words, cannot directly bind an rvalue reference to lvalue but can use move() to obtain an
rvalue reference bound to an lvalue.

The standard defines move() which is example that works on rvalue and lvalue arguments.

template <typename T>
typename remove_reference<T>::type&& move( T&& t )
{
    return static_cast<typename remove_reference<T>::type &&> (t);
}

string s1("hi!"), s2;

s2 = std::move( string("bye") );       // temporary, rvalue.
s2 = std::move( s1 );                  // lvalue.

note: for more details on how this works, see C++P 690.


={============================================================================
*kt_dev_cpp_053* template: variadic

{variadic-templates}
A template function or class that can take varying number of parameters which is is called as a
parameter pack. Two kinds: template parameter pack and function parameter pack(list).

template <typename T, typename... Args>         // Args is template parameter pack
void foo( const T &t, const Args& ... rest);    // rest is function parameter pack.

int i = 0; double d = 3.14; string s = "how now brown cow";
foo( i, s, 42, d );  // three parameters in the pack
foo( s, 42, "hi" );  // two parameters in the pack
foo( d, s );         // one parameters in the pack
foo( "hi" );         // empty pack

the compiler deduces the template parameter types and instantiate four different foo:

void foo( const int&, const string&, const int&, const double&);
void foo( const string&, const int&, const char[3]&);
void foo( const double&, const string&);
void foo( const char[3]&);


<variadic-sizeof-operator>
C++11. Use the sizeof... operator to know how many elements are in a pack.

template <typename... Args> void g( Args... args)
{
  cout << sizeof... (Args) << endl;    // number of template parameters
  cout << sizeof... (args) << endl;    // number of function parameters
}

Determine what sizeof... (Args) and sizeof... (rest) return for all foo instances?

Used GCC 4.6.3

#include <iostream>
#include <string>

template <typename T, typename... Args>
void foo(const T &t, const Args &... rest) 
{
  std::cout << "-------" << std::endl;
  std::cout << sizeof... (Args) << std::endl;
  std::cout << sizeof... (rest) << std::endl;
}

int main()
{
  int i = 0; double d = 3.14; std::string s = "how now brown cow";
  foo( i, s, 42, d );  // three parameters in the pack
  foo( s, 42, "hi" );  // two parameters in the pack
  foo( d, s );         // one parameters in the pack
  foo( "hi" );         // empty pack
}

-------
3
3
-------
2
2
-------
1
1
-------
0
0


<why-variadic> 
Can use an initializer-list to define a function that can take a varying number of arguments.
However, the arguments must have the 'same' type.

The point is that variadic functions are used when we know neither the number nor the types of the
arguments to process.


<variadic-recursive>
Variadic are often recursive on arguments in a pack. To stop the recustion, we also need nonvariadic
funtion.

template <typename T> 
ostream &print( ostream &os, const T &t)
{ return os << t; }

template <typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args&... rest)
{
  os << t << ", ";            // print the first argument.
  return print(os, rest...);  // recursive call; print the other arguments.
}

The key part is that the first argument in rest gets bound to t. That pops up a argument in the pack
and the remaining in rest 'form' the pack for the next call until there is the last since variadic
is only viable match. 

print( cout, i, s, 42 );
...
print( cout, s, 42 );
print( cout, 42 );

When the last remains, the variadic and the nonvariadic are viable and the nonvariadic gets called
since it is more speciailized. Stop recursion.

note: The declaration of the nonvariadic version of print 'must' be 'before' variadic version, that
is in scope, since be in scope when the variadic version is defined. Otherwise, the variadic will
recurse indefinitely.


<pack-expansion>
Again, in the same example.

template <typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args&... rest)     // 1
{
  os << t << ", ";          
  return print(os, rest...);                                      // 2
}

1, expand template pack to generate function pack
2. expand function pack to call argument list of print()

When expand function pack, can apply 'pattern' which applies on each elememt in the pack and
'defines' the type of arguments.


template <typename T> string debug_rep( const T &t );

template <typename T, typename... Args>
ostream &errorMsg( ostream &os, const Args&... rest)     // 1
{
  return print(os, debug_rep(rest)...);                  // pattern
}

This expands to:

print( os, debug_rep(a1), debug_rep(a2), ... );

This call expands:

errorMsg( cerr, fcnName, code.num(), otherData, "other", item );

print( cerr, debug_rep(fcnName), debug_rep(code.num()), 
               debug_rep(otherData), debug_rep("other"), debug_rep(item) );

note: debug_rep is function template and can be overloaded for many types.


When write this:

template <typename T, typename... Args>
ostream &errorMsg( ostream &os, const Args&... rest)     // 1
{
  return print(os, debug_rep(rest...) );                 // pattern
}

print( cerr, fcnName, code.num(), otherData, "other", item );


={============================================================================
*kt_dev_cpp_054* template: specialization

{why-specialization}
When cannot or do not want to use the template version, can define a specialized version of the
class or function template.

o when the general template definition might not compile or might do the wrong thing.
o when can take advantage of some specific knowledge to write more efficient code.


{why-problem}
Again, compare() is an example for which the general definition is not appropriate for a particular
type, character pointers.

// first version to compare any two types
template <typename T> int compare( const T&, const T& );

// second version to compare string literals
template <size_t N, size_t M> int compare( const char (&) [N], const (&) [M] );


If call compare() with character pointers, the first version will be called but want to compare
pointers by strcmp() rather than by comparing the pointer values.

const char *p1 = "hi", *p2 = "mom";

compare( p1, p2 );
compare( "hi", "mom" );


{specialization}
Is a separate definition, specific instantiation in which one or more template parameters are
specified to have particular types.


<function-template-specialization>
Must supply arguments for every template parameter in the original template.

// first version to compare any two types
template <typename T> int compare( const T&, const T& );

// specialization
template <>
int compare( const char* const &p1, const char* const &p2 )
{ return strcmp( p1, p2 ); }

The hard part is the function parameter type.

const char *p1 = "hi", *p2 = "mom";

compare( p1, p2 );

Want to use T as "const char *" and our function requires "const" version of this type. As with 
{const-on-base-type}, the type to use in specialization is "const char const *".


<class-template-specialization>
As an example, specialize the library hash template to store Sales_data object in an unordered
container. Must do so in the same namespace in which the original template is defined.

C++P 709. To use unordered map with our own data type, must define a specialization of the hash
template and it must define:

1. An overloaded call operator that return a size_t and takes an object of the container's key type.
2. Two type members, result_type and argument_type, which are the return and argument types,
  respectively, of the call operator.
3. The default constructor and copy-assign operator.

To add members to a namespace

namespace std {
    template <>
        struct hash <Sales_data>
        {
            typedef size_t result_type;
            typedef Sales_data argument_type;

            size_t operator() ( const Sales_data& s ) constl
        };

    size_t hash<Sales_data>::operator() const Sales_data& s) const
    {
        return hash<string>() (s.bookNo) ^ hash<unsigned>() (s.units_sold) ^ hash<double>() (s.revenue);
    }
}  // no semicolon after the close curly

Assuming this speciailization is in scope, use it:

unordered_multiset<Sales_data> SDest;

Since hash<Sales_data> uses the private members of Sales_data, must make this calss, the specific
instantiation, a friend of Sales_data.

template <class T> class std::hash;

class Sales_data {
  friend class std::hash<Sales_data>;
  ...
};


The second way: Having added the declaration for the specialization to std namespce we can define
the specialization outside the std.

namespace std {
   template <> struct hash< Sales_data >;
}

template <> struct hash <Sales_data> 
{
  size_t operator() ( const Sales_data& s ) const
  {
    return hash<sring>()(s.bookNo);
  }
  // other members as before
}


{partial-specialization}
Differently from function template, can specify some, but not all, of the template parameters of
class template. Partial speciailization is itself a template and user must supply arguments that are
not specified.

The library remove_reference template works through a series of specialization.

template <typename T> struct remove_reference 
{
    typedef T type;
};

// partial specialization used for lvalue and rvalue reference

template <typename T> struct remove_reference <T&> 
{
    typedef T type;
};

template <typename T> struct remove_reference <T&&> 
{
    typedef T type;
};

In this case, the specialization have the same number of parameters as the original but the
parameter's type in the specialization 'differ' from the original.

int i;

remove_reference< decltype(42) >::type a;
remove_reference< decltype(i) >::type b;
remove_reference< decltype(std::move(i)) >::type c;

All three, a, b, and c, have type int.


{member-specialization}
Rather then specialize the whole template, can specialize specific member function(s). If Foo is a
template with a member Bar.

template <typename T> struct Foo 
{
    Foo(const T &t = T()): mem(t) {}
    void Bar() { /* ... */ }
    T mem;
};

template <> void Foo<int>::Bar()
{
  ...
}

Here specializing one member of the Foo<int> class.

Foo<string> fs;   // instantiate Foo<string>::Foo()
fs.Bar();         // instantiate Foo<string>::Bar()

Foo<int> fi;      // instantiate Foo<int>::Foo()
fi.Bar();         // use specialization version of Foo<int>::Bar()


{template-inheritance}
Have got an error on GCC in following case:

template <typename Entry>
class Binary_tree 
{
  ...

  protected:
    Binary_node<Entry> *root;
};


template <typename Record>
class Search_tree: public Binary_tree<Record>
{
  public:
    ...
    Error_code tree_search( Record &target ) const;
};

template <typename Record>
Error_code Search_tree<Record>::tree_search( Record &target ) const
{
  Error_code result = success;

  // <1> Binary_node<Record> *found = search_for_node( root, target );
  // Binary_node<Record> *found = search_for_node( Search_tree<Record>::root, target );
  // Binary_node<Record> *found = search_for_node( Binary_tree<Record>::root, target );
  // Binary_node<Record> *found = search_for_node( this->root, target );
  if( found == NULL )
    return not_present;
  else
    target = found->data;

  return result;
}

The <1> caues an error:
bintree.cpp: In member function Error_code Search_tree<Record>::tree_search(Record&) const:
bintree.cpp:107:49: error: root was not declared in this scope

Why? Googled and found:

http://www.parashift.com/c++-faq-lite/nondependent-name-lookup-members.html
[35.19] Why am I getting errors when my template-derived-class uses a member it inherits from its
template-base-class? 

Perhaps surprisingly, the following code is not valid C++, even though some compilers accept it:

template<typename T>
class B {
  public:
    void f() { }  // member of class B<T>
};

template<typename T>
class D : public B<T> {
  public:
    void g()
    {
      f();        // bad (even though some compilers erroneously (temporarily?) accept it)
    }
};

This might hurt your head; better if you sit down.

Within D<T>::g(), the name f does not depend on template parameter T, so f is known as a
nondependent name. On the other hand, B<T> is dependent on template parameter T so B<T> is called a
dependent name.

Here's the rule: the compiler does 'not' look in dependent base classes (like B<T>) when looking up
nondependent names (like f).

This doesn't mean that inheritance doesn't work. Class D<int> is still derived from class B<int>,
the compiler still lets you implicitly do the is-a conversions (e.g., D<int>* to B<int>*),
dynamic binding still works when virtual functions are invoked, etc. But there is an issue
about how names are looked up.

Workarounds:
1) Change the call from f() to this->f(). <note> this is interesting. "Since this is always
implicitly dependent in a template", this->f is dependent and the lookup is therefore deferred until
the template is actually instantiated, at which point all base classes are considered.

2) Insert using B<T>::f; just prior to calling f().

3) Change the call from f() to B<T>::f(). Note however that this might not give you what you want if
f() is virtual, since it inhibits the virtual dispatch mechanism.

So in the above example, all other cases works other than <1>


={============================================================================
*kt_dev_cpp_060* template: how to initialize T member

No problem to define T member when use template. How set initial value to them?

1. Taken from the example of template default type

template <typename T = int> 
class Numbers {
  public:
    Numbers(T v = 0): val(v) {}
  private:
    T val;
};

However, it assumes that T would be integral type. How about user or class type?


2. Uses copy assign with temporary, T().

template <typename T>
class MovingAverage
{
    public:
        MovingAverage(size_t initial_size=10)
        {
            resize(initial_size);
        }

        void reset()
        {
            accumulated_value = T();
            head = 0;
            tail = 0;
        }

        void resize(size_t new_size)
        {
            reset();
            values.resize(new_size, T());
        }

    private:
        T accumulated_value;
};


3. Other way?


={============================================================================
*kt_dev_cpp_100* ref: C++ under the hood

Visual C and C++ (General) Technical Articles

C++: Under the Hood Jan Gray March 1994

Jan Gray is a Software Design Engineer in Microsoft's Visual C++ Business Unit. He helped
design and implement the Microsoft Visual C++ compiler. 

Introduction

It is important to understand how your programming language is implemented. Such knowledge dispels
the fear and wonder of "What on earth is the compiler doing here?"; imparts confidence to use the
new features; and provides insight when debugging and learning other language features. It also
gives a feel for the relative costs of different coding choices that is necessary to write the
most efficient code day to day. This paper looks "under the hood" of C++, explaining "run-time" C++
implementation details such as class layout techniques and the virtual function call mechanism.

Questions to be answered include: 

1. How are classes laid out?  
2. How are data members accessed?
3. How are member functions called?
4. What is an adjuster thunk?
5. What are the costs: Of single, multiple, and virtual inheritance? Of virtual functions and
virtual function calls?  Of casts to bases, to virtual bases? Of exception handling? 

First, we'll look at struct layout of C-like structs, single inheritance, multiple inheritance, and
virtual inheritance, then consider data member access and member functions, virtual and not. We'll
examine the workings of constructors, destructors, and assignment operator special member functions
and dynamic construction and destruction of arrays. Finally, we'll briefly consider the impact of
exception-handling support. For each language feature topic, we'll very briefly present motivation
and semantics for the language feature (although "Introduction to C++" this is not), and examine how
the language feature was implemented in Microsoft Visual C++. Note the distinction between abstract
language semantics and a particular concrete implementation. Other vendors have sometimes made
different implemen tation choices for what ever reasons. In a few cases we contrast the Visual C++
implementation with others. 

Class Layout

In this section we'll consider the storage layouts required for different kinds of inheritance.

C-like Structs

As C++ is based upon C, it is "mostly" upwards-compatible with C. In particular, the working papers
specify the same simple struct layout rules that C has: Members are laid out in their declaration
order, subject to implementation defined alignment padding. All C/C++ vendors ensure
that valid C structs are stored identically by their C and C++ compilers.

Here A is a simple C struct with the ob vious expected member layout and padding.

A*->   A::c (padding)
       A::i

struct A {
  char c;
  int i;
}; 


C-like Structs with C++ Features

Of course, C++ is an object-oriented programming language: It provides inheritance, encapsulation,
and polymorphism by extending the mundane C struct into the wondrous C++ class. Besides data
members, C++ classes can also encapsulate member functions and many other things. However,
except for 'hidden' data members introduced to implement virtual functions and virtual inheritance,
the instance size is 'solely' determined by a class's data members and base classes.

Here B is a C-like struct with some C++ features : There are public/protected/private access control
declarations, member functions, static members, and nested type declarations. Only the non-virtual
data members occupy space in each instance. Note that the standards committee working papers permit
implementations to reorder data members separated by an access declarator, so these three members
could have been laid out in 'any' order. (In Visual C++, members are always laid out in declaration
order, just as if they were members of a C struct) 

B*->   B::bm1
       B::bm2
       B::bm3

struct B {
  public:
    int bm1;
  protected:
    int bm2;
  private:
    int bm3;
    static int bsm;
    void bf();
    static void bsf();
    typedef void* bpv;
    struct N { };
};


Single Inheritance

C++ provides inheritance to factor out and share 'common' aspects of different types. A good example
of a classes-with-inheritance data type organization is biology's classification of living things
into kingdoms, phyla, orders, families, genus, species, and so on. This organization makes it
possible to specify attrib utes, such as "mammals bear live young" at the most appropriate level of
classi fication; these attributes are then inherited by other classes, so we can conclude without
further sp ecification that whales, squirrels, and people bear live young. Exceptional cases, such
as platypi (a mammal, yet lays eggs), will require that we override the inherited attribute or
behavior with one more appropriate for the derived class. More on that later. 

In C++, inheritance is specified by using the ": base" syntax when defining the derived class. Here
D is derived from its base class C.

C* ->    C::c1

struct C {
  int c1;
  void cf();
};

C*, D* ->   C::c1
            D::d1

struct D : C {
  int d1;
  void df();
};

Since a derived class inherits all the properties and behavior of its base class, each instance of
the derived class will contain a 'complete' copy of the instance data of the base class. Within D,
there is no requirement that C's instance data precede D's. But by laying D out this way, we ensure
that the address of the C object within D corresponds to the address of the first byte of the D
object. As we shall see, this eliminates adding a displacement to a D* when we need to obtain the
address of its embedded C. This layout is used by all known C++ implementations.

Thus, in a single inheritance class hierarchy, new instance data introduced in each derived class is
simply appended to the layout of the base class. Note our layout diagram labels the "address
'points'" of pointers to the C and D objects within a D . 

Multiple Inheritance

Single inheritance is quite versatile and powerful, and generally adequate for expressing the
(typically limited) degree of inheritance present in most design problems. Sometimes, however, we
have two or more sets of behavior that we wish our derived class to acquire. C++ provides multiple
inheritance to combine them. For instance, say we have a model for an organization that has a class
Manager (who delegates) and class Worker (who actually does the work). Now how can we model a class
MiddleManager, who, like a Worker, accepts work assignments from his/her manager and who, like a
Manager, delegates this work to his/her employees? This is awkward to express using single
inheritance: For MiddleManager to inherit behavior from both Manager and Worker, both must be base
classes. If this is arranged so that MiddleManager inherits from Manager which inherits from Worker
, it erroneously ascribes Worker behavior to Managers. (Vice versa, the same problem.) Of course,
  MiddleManager could inherit from just one (or neither) of Worker or Manager, and instead,
  duplicate (redeclare) both interfaces, but that defeats polymorphism, fails to reuse the existing
  interface, and leads to maintenance woes as interfaces evolve over time.

Instead, C++ allows a class to inherit from multiple base classes:

struct Manager ... { ... };
struct Worker ... { ... };
struct MiddleManager : Manager, Worker { ... };

How might this be represented? Continuing with our "classes of the alphabet" example: 

struct C {
  int c1;
  void cf();
};

E* ->   E::e1

struct E {
  int e1;
  void ef();
};

C*, F* ->   C::c1
    E* ->   E::e1
            F::f1

struct F : C, E {
  int f1;
  void ff();
}; 

Struct F multiply inherits from C and E. As with single inheritance, F contains a copy of the
instance data of each of its base classes. Unlike single inheritance, it is not possible to make the
address point of each bases' embedded instance correspond to the address of the derived class:
note: since E do not have C in it therefore E should not have the same point as C.

F f;
// (void*)&f == (void*)(C*)&f;
// (void*)&f < (void*)(E*)&f; 

Here, the address point of the embedded E within F is not at the address of the F itself. As we
shall see when we consider casts and member functions, this 'displacement' leads to a small
'overhead' that single inheritance does not generally require. An implementation is free to lay out
the various embedded base instances and the new instance data in any order. Visual C++ is typical in
laying out the base instances in declaration order, followed by the new data members, also in
declaration order. (As we shall see, this is not necessarily the case when some bases have virtual
functions and others don't). 

Virtual Inheritance

Returning to the MiddleManager example which motivated multiple inheritance in the first place, we
have a problem. What if both Manager and Worker are derived from Employee?

struct Employee { ... };
struct Manager : Employee { ... };
struct Worker : Employee { ... };
struct MiddleManager : Manager, Worker { ... };

Since both Worker and Manager inherit from Employee, they each contain a copy of the Employee
instance data. Unless something is done, each MiddleManager will contain 'two' instances of
Employee, one from each base. If Employee is a large object, this 'duplication' may represent an
unacceptable storage overhead. More seriously, the two copies of the Employee instance might get
modified separately or inconsistently. We need a way to declare that Manager and Worker are each
willing to share a single embedded instance of their Employee base class, should Manager or Worker
ever be inherited with some other class that also wishes to share the Employee base class. In C++,
     this "sharing inheritance" is (unfortunately) called virtual inheritance and is indicated by
     specifying that a base class is virtual.

struct Employee { ... };
struct Manager : virtual Employee { ... };
struct Worker : virtual Employee { ... };
struct MiddleManager : Manager, Worker { ... };

Virtual inheritance is considerably more 'expensive' to implement and use than single and multiple
inheritance. Recall that for single (and multiple) inherited bases and derived classes, the embedded
base instances and their derived classes either share a common address point (as with single
    inheritance and the 'leftmost' base inherited via multiple inheritance), or have a simple
'constant' displacement to the embedded base instance as with multiple inherited non-leftmost bases,
such as E. 
note: so use constant displacement for multiple inheritance.

With virtual inheritance, on the other hand, there can (in general) be no fixed displacement from
the address point of the derived class to its virtual base. If such a derived class is further
derived from, the further deriving class may have to place the one shared copy of the virtual base
at some other, different offset in the further derived class. Consider this example: 

struct C {
  int c1;
  void cf();
};

struct G : virtual C {
  int g1;
  void gf();
}; 

G* -> G::vbptr    -> GdGvbptrG
      G::g1          GdGvbptrC
C* -> C::c1

struct H : virtual C {
  int h1;
  void hf();
}; 

H* -> H::vbptr    -> HdHvbptrH
      H::h1          HdHvbptrC
C* -> C::c1

struct I : G, H {
  int i1;
  void _if();
}; 

IdGvbptrC {              G*, *I ->  G::vbptr    -> IdGvbptrG
                                    G::g1          IdGvbptrC
            IdHvbptrC {  H* ->      H::vbptr    -> IdHvbptrH
                                    H::h1          IdHvbptrC
          }           }             I::i1
                         C* ->      C::c1

Ignoring the vbptr members for a moment, notice that within a G object, the embedded C immediately
follows the G data member, and similarly notice that within an H, the embedded C immediately follows
the H data member. Now when we layout I , we can't preserve both relationships. In the Visual C++
layout above, the displacements from G to C in a G instance and in an I instance are different.
Since classes are generally compiled without knowledge of how they will be derived from, each class
with a virtual base must have a 'way' to compute the location of the virtual base from the address
point of its derived class. 

In Visual C++, this is implemented by 'adding' a 'hidden' 'vbptr' ("virtual base table pointer")
field to 'each' instance of a class with virtual bases. This field points to a shared, per-class
table of displacements from the address point of the vbptr field to the class's virtual base(s). 

note: Only G and H has vbptr and this is offset to get common C through G or H

Other implementations use embedded pointers from the derived class to its virtual bases, one per
base. This other representation has the advantage of a smaller code sequence to address the virtual
base, although an optimizing code generator can often common-subexpression-eliminate repeated
virtual base access computations. However, it also has the disadvantages of larger instance sizes
for classes with multiple virtual bases, of slower access to virtual bases of virtual bases (unle
    ss one incurs yet further hidden pointers), and of a less regular pointer to member dereference.

In Visual C++, G has a hidden vbptr which addresses a virtual base table whose second entry is
GdGvbptrC. (This is our notation for "in G, the displacement from G's vbptr to C". 

We omit the prefix to "d" if the quantity is constant in all derived classes.

For example, on a 32-bit platform, GdGvbptrC would be 8 (bytes). Similarly, the embedded G instance
within an I addresses a vbtable customized for G's within I's, and so IdGvbptrC would be 20. As can
be seen from the layouts of G , H , and I , Visual C++ lays out classes with virtual bases by: 

note: 8 and 20 is offset value

1. Placing embedded instances of the non-virtually inherited bases first, 

2. Adding a hidden vbptr unless a suitable one was inherited from one of the non-virtual bases, 

3. Placing the new data members declared in the derived class, and, finally, 

4. Placing a single instance of each of the virtually inherited bases at the end of the instance.

This representation lets the virtually inherited bases "float" within the derived class (and its
  further derived classes) while keeping together and at constant relative displacements those parts
of the object that are not virtual bases. 

Data Member Access

Now that we have seen how classes are laid out, let's consider the cost to access data members of
these classes. No inheritance. In absence of inheritance, data member access is the same as in C: a
dereference off some displacement from the pointer to the object. 

C* pc;
pc->c1; // *(pc + dCc1); 

Single inheritance.

Since the displacement from the derived object to its embedded base instance is a constant 0, that
constant 0 can be folded with the constant offset of the member within that base.

D* pd;
pd->c1; // *(pd + dDC + dCc1); // *(pd + dDCc1);
pd->d1; // *(pd + dDd1); 

Multiple inheritance. Although the displacement to a give n base, or to a base of a base, and so
on, might be non-zero, it is still constant, and so any set of such displacements can be folded
together into one constant displacement off the object pointer. Thus even with multiple
inheritance, access to any member is inexpensive.

F* pf;
pf->c1; // *(pf + dFC + dCc1); // *(pf + dFc1);
pf->e1; // *(pf + dFE + dEe1); // *(pf + dFe1);
pf->f1; // *(pf + dFf1); 

Virtual inheritance. Within a class with virtual bases, access to a data member or non-virtually
inherited base class is again just a constant displacement off the object pointer. However, access
to a data member of a virtual base is comparatively expensive, since it is necessary to fetch the
vbptr, fetch a vbtable entry, and then add that displacement to the vbptr address point, just to
compute the address of the data member. However, as shown for i.c1 below, if the type of the derived
class is statically known, the layout is also known, and it is unnecessary to load a vbtable entry
to find the displacement to the virtual base.

I* pi;
pi->c1; // *(pi + dIGvbptr + (*(pi+dIGvbptr))[1] + dCc1);
pi->g1; // *(pi + dIG + dGg1); // *(pi + dIg1);
pi->h1; // *(pi + dIH + dHh1); // *(pi + dIh1);
pi->i1; // *(pi + dIi1);
I i;
i.c1; // *(&i + IdIC + dCc1); // *(&i + IdIc1); 

What about access to members of transitive virtual bases, for example, members of virtual bases of
virtual bases (and so on)? Some implementations follow one embedded virtual base pointer to the
intermediate virtual base, then follow its virtual base pointer to its virtual base, and so on.
Visual C++ optimizes such access by using additional vbtable entries which provide displacements
from the de rived class to any transitive virtual bases. 

Casts

Except for classes with virtual bases, it is relatively inexpensive to explicitly cast a pointer
into another pointer type. If there is a base-derived relationship between class pointers, the
compiler simply adds or subtracts the displacement between the two (often 0). 

F* pf;
(C*)pf; // (C*)(pf ? pf + dFC : 0); // (C*)pf;
(E*)pf; // (E*)(pf ? pf + dFE : 0); 

In the C* cast, no computations are required, because dFC is 0. In the E* cast, we must add dFE , a
non-zero constant, to the pointer. C++ requires that null pointers (0) remain null after a cast.
Therefore Visual C++ checks for null before performing the addition. This check occurs only when a
pointe r is implicitly or explicitly converted to a related pointer type, not when a derived* is
implicitly converted to a base*const this pointer when a base member function is invoked on a
derived object. 

As you might expect, casting over a virtual inheritance path is relatively expensive: about the
same cost as accessing a member of a virtual base: 

I* pi;
(G*)pi; // (G*)pi;
(H*)pi; // (H*)(pi ? pi + dIH : 0);
(C*)pi; // (C*)(pi ? (pi+dIGvbptr + (*(pi+dIGvbptr))[1]) : 0); 

In general, you can avoid a lot of expensive virtual base field accesses by replacing them with one
cast to the virtual base and base relative accesses: 

/* before: */              ... pi->c1 ... pi->c1 ...
/* faster: */ C* pc = pi;  ... pc->c1 ... pc->c1 ... 

Member Functions

A C++ member function is just another member in the scope of its class. Each (non-static) member
function of a class X receives a special hidden this parameter of type X *const , which is
implicitly initialized from the object the member function is applied to. Also, within the body of a
member function, member access off the 'this' pointer is implicit. 

struct P {
  int p1;
  void pf(); // new
  virtual void pvf(); // new
}; 

P* ->    P::vfptr    -> &P::pvf
         P::p1

P has a non-virtual member function pf() and a virtual member function pvf(). It is apparent that
virtual member functions incur an instance size hit, as they require a virtual function table
pointer. More on that later. Notice there is no instance cost to declaring non-virtual member
functions. Now consider the definition of P::pf() : 

void P::pf() { // void P::pf([P *const this])
  ++p1;        // ++(this->p1);
} 

Here P::pf() receives a hidden this parameter, which the compiler has to pass each call. Also note
that member access can be more expensive than it looks, because member accesses are this relative.
On the other hand, compilers commonly enregister this so member access cost is often no worse than a
ccessing a local variable. On the other hand, compilers may not be able to enregister the instance
data itself because of the possibility this is aliased with some other data. 

Overriding Member Functions <how-virtual-works>

Member functions are inherited just as data members are. Unlike data members, a derived class can
override, or replace, the actual function definition to be used when an inherited member function is
applied to a derived instance. Whether the override is static (determined at compile time by the
static types involved in the member function call) or dynamic (determined at run-time by the dynamic
object addressed by the object pointer) depends upon whether the member function is declared
virtual.  

Class Q inherits P's data and function members. It declares pf(), overriding P::pf(). It also
declares pvf(), a virtual function overriding P::pvf(), and declares a new non-virtual member
function qf(), and a new virtual function qvf(). 

struct P {
  int p1;
  void pf();            // new
  virtual void pvf();   // new
}; 

struct Q : P {
  int q1;
  void pf();            // overrides P::pf
  void qf();            // new
  void pvf();           // overrides P::pvf
  virtual void qvf();   // new
};

P*, Q*   ->    P::vfptr    -> &Q::pvf
               P::p1       -> &Q::qvf
               Q::q1

note: this is Q instance

For non-virtual function calls, the member function to call is statically determined, at compile
time, by the type of the pointer expression to the left of the -> operator. <key> In particular,
  even though ppq points to an instance of Q, ppq->pf() calls P::pf(). Also notice the pointer
  expression left of the -> is passed as the hidden this parameter. 

P p; P* pp = &p; Q q; P* ppq = &q; Q* pq = &q;
pp->pf();   // pp->P::pf();   // P::pf(pp);
ppq->pf();  // ppq->P::pf();  // P::pf(ppq);
pq->pf();   // pq->Q::pf();   // Q::pf((P*)pq);
pq->qf();   // pq->Q::qf();   // Q::qf(pq); 


For virtual function calls, the member function to call is determined at run-time. Regardless of the
declared type of the pointer expression left of the -> operator, the virtual function to call is the
one appropriate to the type of the 'actual' instance addressed by the pointer. In particular, although
ppq has type P*, it addresses a Q, and so Q::pvf() is called.

pp->pvf();  // pp->P::pvf();  // P::pvf(pp);
ppq->pvf(); // ppq->Q::pvf(); // Q::pvf((Q*)ppq);
pq->pvf();  // pq->Q::pvf();  // Q::pvf((P*)pq); 

Hidden vfptr members are introduced to implement this mechanism. A vfptr is added to a class (if it
    doesn't already have one) to address that class's virtual function table (vftable). Each virtual
function in a class has a corresponding entry in that class's vftable. Each entry holds the address
of the virtual function override appropriate to that class. Therefore, calling a virtual function
requires 'fetching' the instance's vfptr, and indirectly calling through one of the vftable entries
addressed by that pointer. This is in 'addition' to the usual function call overhead of parameter
passing, call, and return instructions. In the example below, we fetch q's vfptr, which addresses
Q's vftable, whose first entry is &Q::pvf. Thus Q::pvf() is called. 

Looking back at the layouts of P and Q, we see that the Visual C++ compiler has placed the hidden
'vfptr' member at the start of the P and Q instances. This helps ensure that virtual function dispatch
is as fast as possible. In fact, the Visual C++ implementation ensures that the first field in any
class 'with' virtual functions is always a vfptr. This can require inserting the new vfptr before base
classes in the instance layout, or even require that a right base class that does begin with a vfptr
be placed before a left base that does not have one.

<vtable-per-class>
Most C++ implementations will share or reuse an inherited base's vfptr. Here Q did 'not' receive an
'additional' vfptr to address a table for its new virtual function qvf(). Instead, a qvf entry is
appended to the end of P's vftable layout. In this way, 'single' inheritance remains inexpensive.
Once an instance has a vfptr it doesn't need another one. New derived classes can introduce yet more
virtual functions, and their vftable entries are simply 'appended' to the end of their one per-class
vftable. 

note: vtable is made per class so in this example, there are P's vtable and Q's vtable. 
note: single inheritance means one level of inheritance so single inheritance is different from
single hierachy of inheritance.

Virtual Functions: Multiple Inheritance

<understand-trunk>
It is possible for an instance to contain more than one vfptr if it inherits them from multiple
bases, each with virtual functions. Consider R and S: 

struct P {
  int p1;
  void pf();            // new
  virtual void pvf();   // new
}; 

struct R {
  int r1;
  virtual void pvf(); // new
  virtual void rvf(); // new
}; 

R*    ->    R::vfptr    -> &R::pvf
            R::r1       -> &R::rvf

note: see R has its own vfptr

struct S : P, R {
  int s1;
  void pvf(); // overrides P::pvf and R::pvf
  void rvf(); // overrides R::rvf
  void svf(); // new
}; 

P*, S*->    P::vfptr    -> &S::pvf
            P::r1
    R*->    R::vfptr    -> &thunk1     // note: this is vtable entry
            R::r1       -> &S::rvf
            S::s1

            trunk1: this -= SdPR; goto S::pvf

Here R is just another class with some virtual functions. Since S multiply inherits, from P and R,
     it contains an embedded instance of each, plus its own instance data contribution, S::s1.
     Notice the right base R has a different address point than do P and S, as expected with
     multiple inheritance. S::pvf() overrides both P::pvf() and R::pvf(), and S::rvf() overrides
     R::rvf(). Here are the required semantics for the pvf override: 

S s; S* ps = &s;
((P*)ps)->pvf();  // ((P*)ps)->P::vfptr[0])((S*)(P*)ps)
((R*)ps)->pvf();  // ((R*)ps)->R::vfptr[0])((S*)(R*)ps)
ps->pvf();        // one of the above; calls S::pvf() 

Since S::pvf() overrides both P::pvf() and R::pvf(), it must replace their vftable entries in the S
vftable s. However, notice that it is possible to invoke pvf() both as a P and an R. The problem is
that R's address point does not correspond to P's and S's. The expression (R*)ps does not point to
the same part of the class as does (P*)ps. Since the function S::pvf() expects to receive an S* as
its hidden this parameter, the virtual function call itself must automatically convert the R* at the
call site into an S* at the callee. Therefore, S's copy of R's vftable's pvf slot takes the address
of an adjuster thunk, which applies the address adjustment necessary to convert an R* pointer into
an S* as desired. In MSC++, for multiple inheritance with virtual functions, adjuster thunks are
required only when a derived class virtual function overrides virtual functions of multiple base
classes. 

Address Points and "Logical This Adjustment"

Consider next S::rvf(), which overrides R::rvf(). Most implementations note that S::rvf() must have
a hidden this parameter of type S*. Since R's rvf vftable slot may be used when this call occurs:

((R*)ps)->rvf(); // (*((R*)ps)->R::vfptr[1])((R*)ps)

Most implementations add another thunk to convert the R* passed to rvf into an S*. Some also add an
additional vftable entry to the end of Ss vftable to provide a way to call ps->rvf() without first
converting to an R*. MSC++ avoids this by intentionally compiling S::rvf() so as to expect a this
pointer which addresses not the S object but rather the R embedded instance within the S. (We call
    this "giving overrides the same expected address point as in the class that first introduced
    this virtual function".) This is all done transparently, by applying a "logical this adjustment"
to all member fetches, conversions from this , and so on, that occur within the member function.
(Just as with multiple inheritance member access, this adjustment is constant-folded into other
 member displacement address arithmetic.) Of course, we have to compensate fo r this adjustment in
our debugger. 

ps->rvf(); // ((R*)ps)->rvf(); // S::rvf((R*)ps)

Thus MSC++ generally avoids creating a thunk and an 'additional' extra vftable entry when overriding
virtual functions of non-leftmost bases. 

Adjuster Thunks

As described, an adjuster thunk is sometimes called for, to adjust this (which is found just below
    the return address on the stack, or in a register) by some constant displacement en route to the
called virtual function. Some implementations (especially cfront-based ones) do not employ adjuster
thunks. Rather, they add additional displacement fields to each virtual function table entry.
Whenever a virtual function is called, the displacement field, which is quite often 0, is added to
the object address as it is passed in to become the this pointer: 

ps->rvf();
// struct { void (*pfn)(void*); size_t disp; };
// (*ps->vfptr[i].pfn)(ps + ps->vfptr[i].disp);


The disadvantages of this approach include both larger vftable s and larger code sequences to call
virtual functions. More modern PC-based implementations use adjust-and-jump techniques:


S::pvf-adjust: // MSC++
this -= SdPR;
goto S::pvf()

Of course, the following code sequence is even better (but no current implementation generates it):

S::pvf-adjust:
this -= SdPR; // fall into S::pvf()
S::pvf() { ... } 


Virtual Functions: Virtual Inheritance

Here T virtually inherits P and overrides some of its member functions. In Visual C++, to avoid
costly conversions to the virtual base P when fetching a vftable entry, new virtual functions of T
receive entries in a 'new' vftable, requiring a new vfptr, introduced at the top of T. 

struct T : virtual P {
  int t1;
  void pvf();           // overrides P::pvf
  virtual void tvf();   // new
}; 

note: this layout is different from usual inheritance.

TdTvbptrP {  T* ->  T::vfptr     -> &T::tvf
                    T::vbptr     -> TdTvbptrT
          }         T::t1           TdTvbptrP
             P* ->  P::vfptr     -> &T::pvf
                    P::p1

void T::pvf() {
  ++p1;           // ((P*)this)->p1++; // vbtable lookup!
  ++t1;           // this->t1++;
}

As shown above, even within the definition of a virtual function, access to data members of a
virtual base must still use the vbtable to fetch a displacement to the virtual base. This is
necessary because the virtual function can be subsequently inherited by a further derived class with
different layout with respect to virtual base placement. And here is just such a class: 

struct U : T {
  int u1;
}; 


             T* ->  T::vfptr     -> &T::tvf
UdTvbptrP {         T::vbptr     -> UdTvbptrT
                    T::t1           UdTvbptrP
          }         U::u1
             P* ->  P::vfptr     -> &trunk2
                    P::p1

                    trunk2: this -= (UdP-TdP); goto T::pvf

Here U adds another data member, which changes the dP , the displacement to P . Since T::pvf expects
to be called with a P* in a T , an adjuster thunk is necessary to adjust T this so it arrives at the
callee addressing just past T::t1 (the address point of a P* in a T T). (Whew!  Thats about as
complex as things get!) 

Special Member Functions

This section examines hidden code compiled into (or around) your special member functions.

Constructors and Destructors

As we have seen, sometimes there are hidden members that need to be initialized during construction
and destruction. Worst case, a constructor may perform these activities

1. If "most-derived," initialize vbptr field(s) and call constructors of virtual bases.
2. Call constructors of direct non-virtual base classes.
3. Call constructors of data members.
4. Initialize vfptr field(s).
5. Perform user-specified initialization code in body of constructor definition.

A "most-derived" instance is an instance th at is not an embedded base instance within some other
derived class.

So, if you have a deep inheritance hierarchy, even a single inheritance one, construction of an
object may require many successive initializations of a class's vfptr. (Where appropriate, Visual
    C++ will optimize away these redundant stores.) Conversely, a destructor must tear down the
object in the exact reverse order to how it was initialized:

1. Initialize vfptr field(s).
2. Perform user-specified destruction code in body of destructor definition.
3. Call destructors of data members (in reverse order).
4. Call destructors of direct non-virtual bases (in reverse order).
5. If "most-derived," call destructors of virtual bases (in reverse order).

In Visual C++, constructors for classes with virtual bases receive a hidden most-derived flag to
indicate whether or not virtual bases should be initialized. For destructors, we use a "layered
destructor model," so that one (hidden) destructor function is synthesized and called to destroy a
class including its virtual bases (a "most-derived" instance) and another to destroy a class
excluding its virtual bases. The former calls the latter, then destroys virtual bases (in reverse
    order). 

Virtual Destructors and Operator Delete

Consider structs V and W. 

V*    ->    V::vfptr    -> &V::~V

struct V {
  virtual ~V();
}; 

W*    ->    V::vfptr    -> &W::~W

struct W : V {
  operator delete();
}; 

Destructors can be virtual. A class with a virtual destructor receives a hidden vfptr member, as
usual, which addresses a vftable. The table contains an entry holding the address of the virtual
destructor function appropriate for the class. What is special about virtual destructors is they are
implicitly invoked when an instance of a class is deleted. The call site (delete site) does not know
what the dynamic type being destroyed is, and yet it must invoke the appropriate operator delete for
that type. 

For instance, when pv below addresses a W, after W::~W() is called, its storage must be destroyed
using W::operator delete() .

V* pv = new V;
delete pv;           // pv->~V::V(); // use ::operator delete()
pv = new W;
delete pv;           // pv->~W::W(); // use W::operator delete()
pv = new W;
::delete pv;         // pv->~W::W(); // use ::operator delete()

To implement these semantics, Visual C++ extends its "layered destructor model" to automatically
create another hidden destructor helper function, the "deleting destructor," whose address replaces
that of the "real" virtual destructor in the virtual function table. This function calls the
destructor appropriate for the class, then optionally invokes the appropriate operator delete for
the class. 

Arrays

Dynamic (heap allocated) arrays further co mplicate the responsib ilities of a virtual destructor.
There are two sources of complexity.  First, the dynamic size of a heap allocated array must be
stored along with the arra y itself, so dynamically allocated arrays automatically allocate extra
storage to hold the number of array elements. The other complication occurs because a derived class
may be larger than a base class, yet it is imperative that an array delete correctly de stroy each
array elemen t, even in contexts where the array size is not evident:

struct WW : W { int w1; };
pv = new W[m];
delete [] pv; // delete m W's (sizeof(W) == sizeof(V))
pv = new WW[n];
delete [] pv; // delete n WW's (sizeof(WW) > sizeof(V))

Although, strictly speaking, polymorphic array delete is undefined behavior, we had several customer
requests to implement it anyway. Th erefore, in MSC++, th is is implemented by yet another
synthesized virtual destructor he lper function, the so-called vector delete destructor, which
(since it is custom ized for a particular class, such as WW) has no difficulty iterating through the
array elem ents (in reverse order), callin g the appropriate destructor for each. 

Exception Handling

Briefly, the exception handling proposal in the C++ standards committee working papers provides a
facility by which a function can notify its callers of an exceptional condition and select
appropriate code to deal with the situation. This provides an alternative mechanism to the
conventional method of checking error status return codes at every function call return site.

Since C++ is object-oriented, it should come as no surprise that objects are employed to represent
the exception state, and that the appropriate exception handler is selected based upon the static
or dynamic type of except ion object "thrown." Also, since C++ always ensures that frame objects
that are going out of scope are properly destroyed, implementations must ensure that in
transferring control (unwinding the stack frame) from throw site to "catch" site, (automatic) frame
objects are properly destroyed. Consider this example: 

struct X { X(); };         // exception object class
struct Z { Z(); ~Z(); };   // class with a destructor
extern void recover(const X&);
void f(int), g(int);

int main() {
  try {
    f(0);
  } catch (const X& rx) {
    recover(rx);
  }
  return 0;
}

void f(int i) {
  Z z1;
  g(i);
  Z z2;
  g(i-1);
}

void g(int j) {
  if (j < 0)
    throw X();
}

This program will throw an exception. main() establishes an exception handler context for its call
to f(0), which in turn constructs z1, calls g(0), constructs z2, and calls g(-1). g() detects the
negative argument condition and throws an X object exception to whatever caller can handle it.
Since neither g() nor f() established an exception handler context, we consider whether the
exception handler established by main() can handle an X object exception. Indeed it can. Before
control is transferred to the catch clause in main(), however, objects on the frame between the
throw site in g() and the catch site in main() must be destroyed. In this case, z2 and z1 are
therefore destroyed.

An exception handling implementation might employ tables at the throw site and the catch site to
describe the set of types that might catch the thrown object (in general) and can catch the thrown
object at this specific catch site, respectively, and generally, how the thrown object should
initialize the catch clause "actual parameter." Reasonable encoding choices can ensure that these
tables do not occupy too much space.

However, let us reconsider function f(). It looks innocuous enough. Certainly it contains neither
try, catch, nor throw keywords, so exception handling would not appear to have much of an impact
on f(). Wrong! The compiler must ensure that, once z1 is constructed, if any subsequently called
function were to raise an exception ("throw") back to f(), and therefore out of f(), that the z1
object is properly destroyed. Similarly, once z2 is constructed, it must ensure that a subsequent
throw is sure to destroy z2 and then z1.

To implement these "unwind semantics," an implementation must, behind the scenes, provide a
mechanism to dynamically determine the context (site), in a caller function, of the call that is
raising the exception. This can involve additional code in each function prolog and epilog, and
worse, updates of state variables between each set of object initializations. For instance, in the
example above, the context in which z1 should be destroyed is clearly distinct from the subsequent
context in which z2 and then z1 should be destroyed, and therefore Visual C++ updates (stores) a new
value in a state variable after construction of z1 and again after construction of z2. All these
tables, function prologs, epilogs, and state variable updates, can make exception handling
functionality a significant space and speed 'expense'. As we have seen, this expense is incurred
even in functions that do not employ exception handling constructs. Fortunately, some compilers
provide a compilation switch and other mechanisms to disable exception handling and its overhead
from code that does not require it. 

Summary

There, now go write your own compiler. Seriously, we have considered many of the significant C++
run-time implementation issues. We see that some wonderful language features are almost free, and
others can incur significant overhead. These implementation mechanisms are applied quietly for you,
       behind the curtains, so to speak, and it is often hard to tell what a piece of code costs
       when looking at it in isolation. The frugal coder is well advised to study the generated
       native code from time to time and question whether use of this or that particularly cool
       language feature is worth its overhead. 


={============================================================================
*kt_dev_cpp_101* ref: C++ under the hood, Scott Meyers

http://www.han-ese.nl/~ewout/ESE/INF2/CPP_onder_de_motorkap.pdf

Overview

This talk offers a detailed look at how C++ compilers typically implement language features,
focusing on the cost of those features - or, more typically, the lack thereof - compared to
  equivalent functionality in C. It begins with an extremely detailed examination of the
  implementation of virtual functions under both single and multiple inheritance, explaining how
  performance considerations have influenced both the design and implementation of this language
  feature. It then moves to an overview of the implementation of all other features of C++, dividing
  them into "no-cost" and "low-cost" categories. The information in this paper is an overview of
  more detailed information covered in the conference presentation.

Implementing Virtual Functions

Given a class such as this,

class B {
  public:
    B();
    virtual ~B();                            // 0
    virtual void f1();                       // 1
    virtual int f2(char c) const;            // 2
    virtual void f3(const std::string& s);   // 3
    void f4() const;
};

Compilers number the virtual functions in the order in which they are encountered. Different
compilers may start the numbering with different values, but it's common to start counting at 0.
Assuming 0 is the initial value, the virtuals in B would be numbered as indicated by the comments.
Note that neither B's constructor nor its member function f4 receive numbers. That's because they're
not virtual functions, hence are implemented differently - like non-member functions, which
themselves are implemented like functions in C.

For each class with at least one virtual function, compilers generate a virtual function table
(often abbreviated vtbl). A vtbl is an array of function pointers such that the n th entry of the
table points to the implementations of the virtual function numbered n. B's vtbl would look like
this:

B's vtbl []    -> impl of B::~B
         []    -> impl of B::f1
         []    -> impl of B::f2
         []    -> impl of B::f3

In the case of pure virtual functions, there is typically no implementation to point to. In that
case, the vtbl slot for the function generally points to a compiler-generated function that, when
called, issues a runtime error message (e.g., "Pure virtual function called") and exits the
program. 

Consider now a derived class D :

class D: public B {
  public:
    D();                          // nonvirtual  - no number
    virtual ~D();                 // redefined   - number 0 (as in base class)
    virtual void f1();            // redefined   - number 1 (as in base class)
    virtual void f5(char *str);   // new virtual - number 4
};

Compilers set up a vtbl for D in the same way they do for B, except that when D redefines a virtual
function it inherits, that function gets the same number in D as in B. D's vtbl thus looks like
this:

D's vtbl []    -> impl of D::~D
         []    -> impl of D::f1
         []    -> impl of B::f2
         []    -> impl of B::f3
         []    -> impl of D::f5

Note that in cases where D inherits its virtual function implementations from B, D's vtbl points to
functions implemented in B. This reveals that the cost of a virtual function call is 'independent' of
the depth of the hierarchy. At runtime, when a virtual is to be called, there is no need to search
the hierarchy for the "right" implementation, because the hierarchy was flattened during
construction of the vtbls.  

Every object of a class with at least one virtual function contains a virtual table pointer - a vptr
- inside it. This pointer is added by the compiler, and its location may vary from compiler to
compiler. An object's vptr points to the vtbl appropriate for the type of the object; compilers
automatically insert code to achieve this into constructors and destructors. note: to set vptr. At
runtime we could have the following situation where all B objects have a vptr pointing to B's vtbl
and all D objects have a vptr pointing to D's vtbl:

For the following C++ source code,

void makeACall(B *pB)
{
  pB->f1(); // call the implementation of f1 appropriate for whatever type of object pB points to
} 

Compilers emit code equivalent to this:

(*pB->vptr[1])(pB); 

Call the function pointed to by vtbl entry 1 (f1's number/index) in the vtbl pointed to by pB->vptr;
pass pB as the "this" pointer

note: this means that the code to select 1 entry in the vtbl is done at compile time but still need
to decide what pB actually points at runtime.

Virtual Functions Under Multiple Inheritance

Under multiple inheritance (MI), a new issues arises: a single object has multiple addresses, and
different addresses need to be passed to different functions. For example, suppose D has two base
classes

class B1 { ... };
class B2 { ... };
class D: public B1, public B2 { ... };

A D object can be pointed to by pointers of any of three different types (excluding void*): B1*,
B2*, or D*. 

At runtime, such an object is likely to be laid out in memory like this, where the diagram shows
where pointers of each of these different types point:

B1*, D* ->  B1 data
B2*     ->  B2 data
            D data

Given these functions,

void f(B1 *pb1);  // expects pb1 to point to the top of a B1
void g(B2 *pb2);  // expects pb2 to point to the top of a B2

consider:

D *pd = new D;    // pD points to top of object
f(pd);            // fine, f expects a pointer to top of object
g(pd);            // pointer adjustment required : g expects a pointer to B2 part of object

In fact, offset adjustments may be necessary even for something as simple as a pointer
initialization:

B2 *pb2 = pd;     // pb2 should point to B2 part of object, not to top

Unfortunately, the need for an offset adjustment may not be determinable during compilation. For
example, given this hierarchy

class B1 {
  public:
    virtual void mf();     // may be overridden in derived classes
};

class B2 {
  public:
    virtual void mf();     // may be overridden in derived classes
};

and this implementation of g,

void g(B2 *pb2)
{
  pb2->mf();               // offset adjustment required?
}

The this pointer passed to mf may or may not require an offset adjustment. If the mf called is
implemented in B2, no adjustment is needed, but if the mf called is implemented in B1 or D, an
adjustment typically is required. During compilation, however, there is no way to know the type of
object pb2 points to, hence no way to know which implementation of mf is being called.

<key> Compilers 'solve' this problem by creating 'extra' vptrs and vtbls in MI hierarchies. In
particular a class with n 'base' classes can be expected to give rise to objects with n vptrs and n
vtbls, e.g.:

note: this means extra vptr and vtbl entry(trunk) for each additional 'base' class
note: Here again, single inheritance means one level of inheritance so single inheritance is
different from single hierachy of inheritance.

B1*, D* ->  B1/D vptr   -> D vtbl [] impls of virtuals declared in B1 or D (and maybe B2)
            B1 data
B2*     ->  B2 vptr     -> D as B2 vtbl [] impls of virtuals declared in B2
            B2 data
            D data

When compilers generate code for a call to a virtual function, they 'know' which vptr they are using
hence where the object pointer currently points and they know which vtbl they are using hence the
this pointer expected by the function pointed to by each vtbl entry, so they can determine whether
an offset adjustment is required for the call.


The code for the offset adjustment itself is typically placed in a thunk 
- a small piece of code not part of any function. Vtbl entries 'requiring' offset adjustments then
point to thunks, and thunks forward calls to the target function implementation after performing the
offset:

<key> 
In the above example, called g(B2*) with D and D's version should be called. However, B2's vtable
entry has B2's version and so update that entry with trunk which adjust this to D and call D's
version. See <understand-trunk> for more. Thunks themselves are often implemented as alternative
vtbl function entry points:

This treatment of the implementation of virtual functions under MI is still incomplete, because it
fails to take into account the possibility of virtual base classes, but, as Stan Lippman comments
in Inside the C++ Object Model , "Virtual base class support wanders off into the Byzantine...The
material is simply too esoteric to warrant discussion...." 

However, one thing should be clear: virtual functions are implemented very efficiently. In fact,
their implementation is both smaller and faster than most C approximations (e.g., anything based
on cascading if/then/else type tests).

note: this article has lots of references to refer to when necessary.


={============================================================================
*kt_dev_cpp_102* ref: MEC++24 understand the cost of virtual functions

Each class in a program that 'declares' or 'inherits' virtual functions has its own vtbl, and the
entries in a class's vtbl are pointers to the implementations of the virtual functions for that
class.

<first-cost>
Space for a virtual table for each class that contains virtual functions. The size of a class's vtbl
is proportional to the number of virtual functions declared for that class including those it
inherits from its base classes.

The total amount of space required for virtual tables is not usually significant, but if you have a
large number of classes or a large number of virtual functions in each class, you may find that the
vtbls take a significant bite out of your address space.

<second-cost>
Size cost of vptr which links between objects which are of the same class and per-class vtable.

Even on systems with unconstrained memory, you may find that the performance of your software
decreases, because larger objects mean fewer fit on each cache or virtual memory page, and that
means your paging activity will probably increase.

<third-cost>
You effectively give up inlining since inline is done at compile time but virtual uses dynamic
mechanism so compiler do not inline virtuals.

<Q> This section said that virtual functions per se are not usually a performance bottleneck.
Really?

<forth-cost>
With multiple inheritance, offset calculations to find vptrs within objects become more complicated.
there are multiple vptrs within a single object (one per base class). As a result, both the
per-class and the per-object space overhead for virtual functions increases, and the runtime
invocation cost grows slightly, too. See references for more.

<fifth-cost>
With virtual base class, implementations of virtual base classes often use pointers to virtual base
class parts as the means for avoiding the replication, and one or more of those pointers may be
stored inside your objects. See adding pointer to virtual base in a object.

class A { ... };
class B: virtual public A { ... };
class C: virtual public A { ... };
class D: public B, public C { ... };

            B data 
            pointer to virtual base class
            C data
            pointer to virtual base class
            D data
            A data


{RTTI-cost}
RTTI can discover info about object and class at run-time. How? That information is stored in an
object of type type_info, and you can access the type_info object for a class by using the typeid
operator. There is a single copy for each class. 

The language specification states that we're guaranteed accurate information on an object's dynamic
type 'only' if that type has at least one virtual function. This makes RTTI data sound a lot like a
virtual function table. So RTTI was designed to be implementable in terms of a class's vtbl.

Typical implementation is:

vtable       
[0] -> C1's type_info   // pointer to type_info object
[1] -> C1::~C1  
[2] -> C1::f1  
[3] -> C1::f2  
[4] -> C1::f3 

Therefore, no size increase in object but in vtbl.


={============================================================================
*kt_dev_cpp_103* ref: others

This is the link found above articles and there are more yet to see.
http://cloudfundoo.wordpress.com/2012/04/27/deep-c-understanding-c-object-layout/


={============================================================================
*kt_dev_cpp_104* ref: why singletons are controversial

https://code.google.com/p/google-singleton-detector/wiki/WhySingletonsAreControversial

note: here suppose that talks about class singleton but singleton+factory.

Why Singletons Are Controversial

The use of singletons is actually a fairly controversial subject in the Java community; what was
once an often-used design pattern is now being looked at as a less than desirable coding practice.

The problem with singletons is that they introduce global state into a program, allowing anyone to
access them at anytime (ignoring scope). Even worse, singletons are one of the most overused design
patterns today, meaning that many people introduce this possibly detrimental global state in
instances where it isn't even necessary. What's wrong with singletons' use of global state?

First, programs using global state are very difficult to test. One of the hallmarks of testability
is a loose coupling of classes, allowing you to isolate a single class and test it completely. When
one class uses a singleton (and I'm talking about a classic singleton, one that enforces it own
    singularity thorough a static getInstance() method), the singleton user and the singleton become
inextricably coupled together. It is no longer possible to test the user (class) without also testing the
singleton. In many cases, this is a deal breaker that can prevent a developer from testing a class
at all, especially if the singleton represents a 'resource' that should not be updated by tests (i.e.
    an important database). The ideal solution here is to pass in the singleton as a parameter in
the user's constructor, allowing a tester to easily mock out the singleton for tests. The singleton
then doesn't have to enforce its own singularity; this can be handled by the client or a factory
class, which could produce the real version or a test version, eliminating the global state
altogether. In fact, it should be considered a violation of the Single Responsibility Principle of
OO design to have an object responsible for its own singularity as well as its normal tasks.

Second, programs that rely on global state hide their dependencies. One of the unique abilities of a
singleton is that it can be accessed anywhere though its globally available static method (i.e.
    getInstance()), allowing programmers to use it inside of a method without having to pass it in
expressly through parameters. While this may seem easier to the programmer, relying on this static
instance means that the signatures of methods no longer show their 'dependencies', because the method
could pull a singleton "out of thin air." This means that users need knowledge of the inner workings
of code to properly use it, making it more difficult to use and test.

Tying these two problems together shows another issue with singletons. In todays world of
test-driven and agile development, it is more important than ever to have small tests covering most
of your code. One of the important things about these tests is that they must be able to be run in
any order (not dependent on each other), which can become a problem with singleton usage. Because
the dependencies of some given methods aren't 'clear' when they rely on singletons (getting them from
static getters), a tester may unknowing write two tests that actually depend on each other by
modifying a shared resource (the singleton). This can produce flaky tests, ones that pass when run
in one order but fail when run in another, which aren't very useful.

Still not convinced? Well, this certainly wasn't originally my idea, and it's not even that new. If
you're looking for some more compelling arguments, check out some of these sources:

All pages with Singleton in their title at the Portland Pattern Repository Wiki

Use Your Singletons Wisely (IBM developerWorks) 


={============================================================================
*kt_dev_cpp_200* example: Quote example from primers

<TODO> need further study for C++11 version, reference qualifiers, and move support.

Here Quote class hierarchy represents book purchase or transaction which supports several discount
strategy and each book has isbn number. The same book has the same isbn. 

{containers-and-inheritance}
In order to use objects of inheritance in containers, must use pointer or reference due to slice
problem. For example, cannot use this approach.

vector<Quote> sales; or vector<Bulk_quote> sales;

One of the ironies of OOP in C++ is that we cannot use objects directly to support it. Instead must
use pointers and references. So often define auxiliary class to help manage complexity that pointer
use impose.


{key-and-comparison}
The basket is not in the hierarchy and has multiset to manage 'multiple' purchase for the 'same'
book that is isbn number. The multiset has shared_ptr key but equality is decided by compare function.
Therefore, the comparison uses the isbn but not shared_ptr itself. That is shared_ptr is a key in
multiset but the same 'key' is the same isbn number since comparison function defines the meaning of
the same.

{virtual-copy}
The user have to deal with dynamic memory and have to use:

sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
sale.add_item(make_shared<Quote>("def", 35));

How can we make add_item() to handle all allocation so that users no longer need to do so? So like
to have:

void add_item( const Quote &sale );    // copy version
void add_item( Quote &&sale );         // move version

The problem is that add_item do not know what type to allocate and the above form only handles Quote
even if passes Bulke_quote. How to solve? Use virtual clone() function to have right version. 

virtual Quote* clone() const { cout << "q clone" << endl; return new Quote(*this); }
Bulk_quote* clone() const { cout << "b clone" << endl; return new Bulk_quote(*this); }

void add_item( const Quote& sale )
{ items.insert( shared_ptr<Quote>( sale.clone())); }

<errors-on-const>
If miss out const as below then emits errors:

virtual Quote* clone() { cout << "q clone" << endl; return new Quote(*this); }

void add_item( const Quote& sale )
{ items.insert( shared_ptr<Quote>( sale.clone())); }

: In member function 'void Basket::add_item(const Quote&)':
: error: passing 'const Quote' as 'this' argument of 'virtual Quote* Quote::clone()' discards qualifiers [-fpermissive]

This is the same problem as <const-and-this-pointer> since add_item has const arguments and clone is
nonconst version. There is no const to nonconst conversion. So must use const on clone.

<matching-on-const> <const-and-override>
Interestingly, when no const on Bulk_quote, no compile error but always have Quote::clone. When have
const, works as expected. Why? This is also <const-non-const-version> so no override.

virtual Quote* clone() const { cout << "q clone" << endl; return new Quote(*this); }
Bulk_quote* clone() { cout << "b clone" << endl; return new Bulk_quote(*this); }


<example> this is for before C++11
#include <iostream>
#include <string>
#include <set>
#include <memory>

using namespace std;

// base class. normal, undiscounted price
class Quote {
  public:
    Quote(): price(0.0) {}
    Quote( const string &book, double sales_price ) :
      bookNo(book), price(sales_price) {}
    virtual ~Quote() {}

    string isbn() const { return bookNo; }
    virtual double net_price( size_t n ) const { return n*price; }

    virtual Quote* clone() const { cout << "q clone" << endl; return new Quote(*this); }

  private:
    string bookNo;
  protected:
    double price;
};

// abstract base class. hold the discount rate and minimum quantity to get discount
class Disc_quote : public Quote {
  public:
    Disc_quote(): quantity(0), discount(0.0) {}
    Disc_quote( const string &book, double price, size_t qty, double disc ):
      Quote(book, price), quantity(qty), discount(disc) {}

    double net_price(size_t n) const = 0;

    pair<size_t, double> discount_policy() const
    { return make_pair(quantity, discount); }

  protected:
    size_t quantity;
    double discount;
};

// derived class. apply discount when sold more than minimum quantity
class Bulk_quote : public Disc_quote {
  public:
    Bulk_quote() = default;
    Bulk_quote( const string &book, double price, size_t qty, double disc ) :
      Disc_quote( book, price, qty, disc) {}

    // different price scheme. no override keyword since supported from gcc 4.7
    // note: why can use base's member? since derived is nested in base's scope.
    double net_price( std::size_t cnt ) const
    {
      if( cnt >= quantity )
        return cnt*(1-discount)*price;
      else
        return cnt*price;
    }

    // Bulk_quote* clone() { cout << "b clone" << endl; return new Bulk_quote(*this); }
    Bulk_quote* clone() const { cout << "b clone" << endl; return new Bulk_quote(*this); }
};

double print_total( ostream &os, const Quote &item, size_t sold )
{
  double ret = item.net_price(sold);      // calls overrided version
  os << "ISBN: " << item.isbn()                          
    << " # sold: " << sold << " total due: " << ret << endl;
  return ret;
}

class Basket {
  public:
    // since no support of in-class initializer, use ctor instead
    Basket(): items(compare) {}

    void add_item( const std::shared_ptr<Quote>& sale)    // shared_ptr's pointer
    { items.insert(sale); }

    void add_item( const Quote& sale )
    { items.insert( shared_ptr<Quote>( sale.clone())); }

    double total_receipt( std::ostream& ) const;

    void display(std::ostream&) const;

  private:
    // note: why static? since used before ctor runs such as in in-class initializer
    static bool compare( const std::shared_ptr<Quote>& lhs, const std::shared_ptr<Quote>& rhs )
    { return lhs->isbn() < rhs->isbn(); }

    typedef bool (*Comp)( const std::shared_ptr<Quote>& lhs, const std::shared_ptr<Quote>& rhs );

    // note: since there is no less-than operator for shared_ptr, must provide own comparison
    multiset< std::shared_ptr<Quote>, Comp> items;

    // note: this is in-class initializer
    // multiset< std::shared_ptr<Quote>, decltype(compare)*> items{compare};  // for C++11
};

// debugging routine to check contents in a Basket
void Basket::display( ostream &os ) const
{
  os << "Basket size: " << items.size() << endl;

  // print each 'distinct' ISBN in the Basket
  for( multiset<shared_ptr<Quote>>::iterator next_item = items.begin();
      next_item != items.end();
      next_item = items.upper_bound(*next_item))
  {
    // know that there's at least one element with this key in the Basket
    os << (*next_item)->isbn() << " occurs "
      << items.count(*next_item) << " times"
      << " for a price of "
      << (*next_item)->net_price( items.count(*next_item))
      << endl;
  }
}

double Basket::total_receipt( ostream& os ) const 
{
  double sum = 0.0;

  // skip over all the duplicates that match the current key(book) by calling upper_bound() since
  // do not need to see all the duplicates(same book) and only need to know the number of each
  // different book. Done this using skipping by upper_bound and the number by count().
  
  for( auto iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound( *iter ) ) 
  {
    // double print_total(ostream& os, const Quote& item, size_t n);
    // *iter is a key which is shared_ptr and **iter is a object that shared_ptr points
    sum += print_total( os, **iter, items.count( *iter ));
  }

  os << "Total sale: " << sum << endl;
  return sum;
}

// int main()
// {
//   // (book, price)
//   Quote basic("0-201-54848-8", 45);
//   // (book, price, quantity, discount. 15%
//   Bulk_quote bulk("0-201-82470-1", 45, 3, .15 );
// 
//   // 20 sold, no discount
//   print_total( cout, basic, 20 );
//   // 20 sold, 15% discount
//   print_total( cout, bulk, 20 );
//   // ISBN: 0-201-54848-8 # sold: 20 total due: 900    (45*20)
//   // ISBN: 0-201-82470-1 # sold: 20 total due: 765
//   
//   cout << "----------------------------------------" << endl;
//   Quote base("0-201-82470-2", 40);
//   Bulk_quote derived("0-201-82470-1", 50, 5, .19);
//   cout << derived.net_price(20) << endl;
//   // 810    // 50*(1-0.19)*20
//   
//   cout << "----------------------------------------" << endl;
//   // copies the Quote parts of derived
//   base = derived;
//   cout << base.net_price(20) << endl;
//   // 1000   // 50*20 but not 40*20
// 
//   cout << "----------------------------------------" << endl;
//   // calls Bulk::
//   Quote &item = derived;
//   cout << item.net_price(20) << endl;
//   // 810
// 
//   cout << "----------------------------------------" << endl;
//   // isbn() not virtual so calls Bulk::
//   cout << item.isbn() << endl;
//   // 0-201-82470-1
// }

int main()
{
  Basket sale;
  sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
  sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
  sale.add_item(shared_ptr<Quote>(new Quote("123", 45)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("345", 45, 3, .15)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(shared_ptr<Quote>(new Bulk_quote("678", 55, 5, .25)));
  sale.add_item(make_shared<Quote>("def", 35));
  sale.add_item(make_shared<Quote>("def", 35));

  sale.add_item(Quote("def", 35));
  sale.add_item(Bulk_quote("678", 55, 5, .25));

  sale.total_receipt(cout);
}

q clone
b clone
ISBN: 123 # sold: 3 total due: 135
ISBN: 345 # sold: 8 total due: 306
ISBN: 678 # sold: 9 total due: 371.25
ISBN: def # sold: 3 total due: 105
Total sale: 917.25


={============================================================================
*kt_dev_cpp_300* case: framework {tizen-case}

From Tizen and points to see are:

o Used factory-func to create a self in the derived class but used static-factory-func. Have
separation and single point of acess to create whole instances.

o Not used singleton but used protected and private ctor or/and dtor in a tree. The protected is
used like singleton to allow derived to create base part.

o Used pimpl-idiom but do not have the same interface between them. not necessary to have the same
interface 

o the way to pass cpp func addresses to c

 
App: ABC                                     _AppImpl: public interface classes
                                                friend class App
 'protected': ctor(); new _AppImpl              'private': ctor and dtor (only App can create AppImpl)
 'static' App* GetInstance(); calls ->          static _AppImpl* GetInstance()
                                                Construct()
                                                Execute()
 |
 |
 |
ServiceApp:                                  _ServiceAppImpl: public interface classes
 'protected': ctor(); new _ServiceAppImpl       'private': ctor and dtor
 static ServiceApp* GetInstance(); ->           static _ServiceAppImpl* GetInstance()
 static Execute(); 
   : use user provided factory-func to create user class and creates all instances
   : register a event listener and run efl_main

 | 
 | Framework 
 |-----------------------------------------------------------------------------
 | User classes
 |----------------------------------
 |                                 | ...
AppService:                       XXXService:
 static CreateInstance();
   : member-static-factory-func to create AppService. This is interesting because used subclassing
   to decide what to create but used static-factory-func.

OspMain():
   result r = Tizen::App::Service::Execute( AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute( AppService::CreateInstance, &args); )


// App

class App
{
  // interfaces
  public: 
    virtual OnXXX()=0;
    virtual void OnLowMemory(void);

    // very few use of forwarding to impl.
    virtual OnYYY()
    { __pAppImpl->OnYYY(); }

    static App* GetInstance();
    {
      _AppImpl* pAppImpl = _AppImpl::GetInstance();

      if (pAppImpl != null)
      {  // [KT] why need this as it returns App* which is passed to Impl?
        return pAppImpl->GetAppInstance();
      }

      return null;
    }

    virtual ~App(void)			# see virtual
    { delete __pAppImpl; }

  protected:
    App(void);
    { __pAppImpl = 'new' (std::nothrow) _AppImpl('this'); }

  private:
    class _AppImpl* __pAppImpl;
};


// _AppImpl

class _AppImpl : public IEventListener
{
  public:
    'static' _AppImpl* GetInstance()
    { return __pAppImpl; }

    App* _AppImpl::GetAppInstance(void)
    { return __pApp; }

    result Construct(const Tizen::Base::Collection::IList* pArgs);
    result Execute(_IAppImpl* pIAppImpl);
    {
      pAppImpl->__pIAppImpl = pIAppImpl;

      app_event_callback_s state_handler;

      state_handler.create = &OnCreate;
      state_handler.service = &OnService;
      state_handler.terminate = &OnTerminate;
      state_handler.pause = &OnPause;
      state_handler.resume = &OnResume;
      state_handler.device_orientation = NULL;

      state_handler.low_memory = &OnLowMemory;
      state_handler.low_battery = NULL;
      state_handler.language_changed = &OnLanguageChanged;
      state_handler.region_format_changed = &OnRegionFormatChanged;

      // see how to pass data from cpp to c and efl_main should copy since it is local
      // 
      eflResult = app_efl_main(&argc, &pArgv, &state_handler, this);
    }

    // same name but static. what will happen?
    'static' void OnLowMemory(void* user_data);

  private:

    _AppImpl::_AppImpl(App* pApp)
      : ...
        , __pApp(pApp)
          , __pIAppImpl(null)
  { __pAppImpl = this; }

    virtual ~_AppImpl(void)
    { __pAppImpl = null; }

    'static' _AppImpl* __pAppImpl;

    App* __pApp;
    _IAppImpl* __pIAppImpl;

    // [KT] otherwise, compile errer when App creates Impl
    friend class App;
};


// ServiceApp(Service) since used typedef ServiceApp Service

class ServiceApp : public Tizen::App::App
{
  public:
    virtual ~ServiceApp(void)
    { delete __pServiceAppImpl; }

    'static' ServiceApp* GetInstance(void)
    {
      _ServiceAppImpl* pServiceAppImpl = _ServiceAppImpl::GetInstance();
      if (pServiceAppImpl == null)
      {
        return null;
      }

      return pServiceAppImpl->GetServiceAppInstance();
    }

    'static' result Execute(ServiceAppInstanceFactory pServiceAppFactory, 
        const Tizen::Base::Collection::IList* pArguments);
    {
      result r = E_SUCCESS;

      ServiceApp* pServiceApp = null;
      _AppImpl* pAppImpl = null;

      // call AppService::CreateInstance. create <AppService> instance
      // use pServiceApp only when exception happens to delete. Here done all creations of objects. 
      pServiceApp = pServiceAppFactory();

      // free to use all instances
      pAppImpl = _AppImpl::GetInstance();

      _ServiceAppImpl* 'pServiceAppImpl' = _ServiceAppImpl::GetInstance();

      // add it as event listner and set app state to initializing
      r = pAppImpl->Construct(pArguments);

      // derive-to-base conversion as _ServiceAppImpl to _IAppImpl
      // pass cpp Onxx funcs to c efl and run app_efl_main
      r = pAppImpl->Execute(pServiceAppImpl); 
    }

  protected:
    ServiceApp(void)
    { __pServiceAppImpl = 'new' (std::nothrow) _ServiceAppImpl('this'); }

  private:
    ServiceApp(const ServiceApp& rhs);
    ServiceApp& operator =(const ServiceApp& rhs);

    class _ServiceAppImpl* __pServiceAppImpl;
}


// _ServiceAppImpl

class _ServiceAppImpl
: public Tizen::Base::Object
, public Tizen::App::_IAppImpl
, public Tizen::Base::Runtime::ITimerEventListener
, virtual public Tizen::Base::Runtime::IEventListener
{
  public:
    static _ServiceAppImpl* GetInstance();
    { return __pServiceAppImpl; }

  private:
    _ServiceAppImpl(ServiceApp* pServiceApp)
      : __pAppImpl(_AppImpl::GetInstance())
        , __pServiceApp(pServiceApp)
        , __pAppTerminatingInternalEventListener(null)
        , __pLifeDurationTimer(null)
        , __lifeDuration(0)
        , __pauseLifeDurationTimer(false)
  {
    __pServiceAppImpl = this;
  }

    ServiceApp*
      _ServiceAppImpl::GetServiceAppInstance(void)
      {
        return __pServiceApp;
      }

    virtual ~_ServiceAppImpl(void);

    static _ServiceAppImpl* __pServiceAppImpl;
    _AppImpl* __pAppImpl;
    ServiceApp* __pServiceApp;
    _IAppEventListener* __pAppTerminatingInternalEventListener;

    friend class ServiceApp;
};


// AppService. client class which is out of framework and namespace.

class AppService
: public Tizen::App::ServiceApp
, public Tizen::App::Package::IPackageInstallationEventListener
, public Tizen::App::_IAppManagerEventListener
, public Tizen::System::IBootEventListener
, virtual public Tizen::Base::Runtime::IEventListener
{

  public:
    // create self
    'static' Tizen::App::ServiceApp* CreateInstance(void)
    {
      // [KT] why static?
      'static' AppService* pAppService = new (std::nothrow) AppService();
      __pAppService = pAppService;

      // convert to base
      return pAppService;
    }

    static AppService* GetAppServiceInstance(void);
    AppService();
    virtual ~AppService();

    // OnXXX interfaces
    virtual bool OnAppInitializing(Tizen::App::AppRegistry& appRegistry);
    ...
      virtual void OnLowMemory(void);

    static AppService* __pAppService;
};

OspMain() {

   result r = Tizen::App::Service::Execute(AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute(AppService::CreateInstance, &args); )
}

int main(int argc, char* pArgv[])
{
   int r = OspMain(argc, pArgv);
}


={============================================================================
*kt_dev_cpp_301* case: wrapper

{example-one} {wrapper}
This is taken from *kt_dev_mecpp_007* to discuss it again: This case is that main is in c and is to
use some features written cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typedefs               {
										  int wraaper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Here wrapper is used to bridge between cpp and c:

int wrapper_func()
{
	ClassX* pclass = new Class( params );

	pclass->func();
	...
}


{example-two} {{add-reference-counting-to-existing-classes}} {wrapper} {forwarding}
How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


={============================================================================
*kt_dev_cpp_302* case: porting layer

{case-one}
The case which use singleton to have a porting layer for different platforms.

 Interfaces
  Core
   IPluginRegister.h
   SectionDataDefines.h
  PortingLayer (has interface classes)
      IAPLAppLaunch.h
      IAPLAVControl.h
      ...
      IAPLMutex.h
      IAPLOSAbstraction.h
      IApplitePortingLayer.h

 PortingLayer (for platform A)
  Inc (headers for each class which implements each interface
   APLAVController.h
   APLDebug.h
   ...
   APLMutex.h
   APLOSAbstraction.h
   ApplitePortingLayer.h
  Src (sources for each class which implements eash interface, functionality)
      APLAVController.cpp
      APLDebug.cpp
      ...
      ApplitePortingLayer.cpp (this is the gate class)


User                 CApplitePortingLayer : publuc IApplitePortingLayer
getInstace()         - get functions to get each interface pointer
Ins->getInterface(); - pointer members for each interface

                     CInterfaceA : public IInterfaceA             CInterfaceB ...
                     - *.h, *.cpp
                     - actual platform specific implementation


class CApplitePortingLayer : public IApplitePortingLayer
{

private:
	///default constructor
	CApplitePortingLayer(){};

public:
	uses singleton
	has all getXXX funcs for each functionality which returns member pointer for each.
	ctor creates all interface classes and set member pointers.

	///This function creates the porting layer interfaces. factory-func
	static CApplitePortingLayer* Instance(CReceiverAppBase* receiver);
	{
		 if (m_singleton == NULL)
		 {
			  m_singleton = new CApplitePortingLayer(receiver);
		 }
		 return m_singleton;
	}

	///This function gets the porting layer interfaces if created.
	static CApplitePortingLayer* GetInstance();
	{
		return m_singleton;
	}
}

Creates all concrete classes which implments interfaces.

CApplitePortingLayer::CApplitePortingLayer(CReceiverAppBase* receiver)
:m_receiver(receiver)
{
	m_graphics =  new CAPLGraphics((IReceiverAppPorting*)receiver, receiver->GetViewIndex());
	m_debug = new CAPLDebug((PCTask*)receiver, receiver->GetTCTv());
	m_mediaManager = new CAPLMediaManager((IReceiverAppPorting*)receiver, receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);		m_OSAbstraction = new CAPLOSAbstraction((IReceiverAppPorting*)receiver, receiver->GetTCTv(), (PCTask*)receiver);
	m_persistentStorage = new CAPLPersistentStorage();
	m_sectionFilter = new CAPLSectionFilter(receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);
	m_serviceInformation = CAPLServiceInformation::Instance((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_systemProperties = new CAPLSystemProperties((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_security = new CAPLSecurity();
	m_serial = new CAPLSerial();
	m_typeface = CAPLTypeface::getInstance();
	m_appLaunch = new CAPLAppLaunch((IReceiverAppPorting*)receiver);

    //initialise curl here, needed for both network and X509 operations
    CAPLCurl::InitCurl();
}

The good thing is that make CApplitePortingLayer singleton and manage other interfaces via it rather
than making every interface a singleton class.

This approach means that each concrete implementation calss, Cxx, implements interfaces and users
will use it directly. If the client is CPP file, that's fine and each Cxx can have typedefs, enums
and so on but if C file then do not work. For C files, each Cxx class provide C function and there
should be a way to share typedefs between CPP and C files. So should be a single header which has
common typedefs for C and CPP land.

Also can use that make all interface concrete class to have private interfaces and make a friend
between CApplitePortingLayer and otheres. That makes only CApplitePortingLayer can create and use
those.

{case-two}
 OAL (OS AL)
  Inc
   ...h
   ...h
  Src 
      LINUX (this is folder which has platform implementation)
      WINDOWS
      VXWORS
      ...


={============================================================================
*kt_dev_cpp_303* case: inheritance

In the porting layer design and implementation, have drawn the class hierarchy.

 ISession (ABC) and more...      IEvent 

 IDriver : public ISession, public IEvent

 CDsm : public IDriver and more...

When add more interface classes which are ABC and add more concrete derived classes, shall add the
same member functions in a header and source of a derived class. Otherwise, will have compile/link
error since ABC forces derived class to define functions. See {error-when-create-abc} for what
happens when not overrides pure virtual functions. Tedious. Any other better way?

1> How about having a pure-virtual-dtor to make a ABC and having normal virtual members?  If have a
class definition and the defintion of a pure-virtual-dtor in the header, get a multiple defintion
error since this is included in every file which use it. Can have source file which has a dtor
definition but still needs definitions for other members. If not, get errors as 3>.

2> How about having a virtual members for interface classes? Since it has implementation, that is
okay for a derived class not to override or implement it. So no tedious work. However, cannot force
derived to override and can forget to implement it. Here talking about 'interface' class.

3> What will happen when changes pure virtual functions to normal virtual functions but do not have
implementation? Simply changes a header since it has a header only as a interface class.

Linking CXX executable mhegproto
port/libmhport.a(CDsm.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `~IDriver':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x94): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x98): undefined reference to `IEvent::unsubscribeEvent(void*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x9c): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTI7IDriver[typeinfo for IDriver]+0x28): undefined reference to `typeinfo for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `.LANCHOR0':
CDsm.cpp:(.rodata+0x5ac): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
CDsm.cpp:(.rodata+0x5b0): undefined reference to `IEvent::unsubscribeEvent(void*)'
CDsm.cpp:(.rodata+0x5b4): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CCi.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'

This shows how GCC implements vtables for a class.


={============================================================================
*kt_dev_cpp_304* case: overloads

{overloads-ctor}
Has many ctor overloads to create different SCE objects depending on different event sources.

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos,
   const std::string& lang,
   const NS_IRON_SYSTEM::Event& dttEvent) :
{}


SCE::SCE(shared_ptr<SCE>& dttEvent, shared_ptr<SCE>& masEvent):
{
}

SCE::SCE(shared_ptr<SCE>& masEvent, const uint32_t start_, const uint32_t end_):
{}

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos, const SystemEventWrapper& masEvent) :
{
}

SCE::SCE(boost::weak_ptr<MetadataRepositories> repos, 
    boost::shared_ptr<Service> service_, uint32_t start_, uint32_t end_):
    synopsis(),
{}


{overloads-call-operator}
Likewise, has many () overloads to call () operator depending on arguments. 

ServicePtrVecPtr operator()(
        const std::vector<NS_SYSTEM::Result>& sysServices,
        ServicePtrVecPtr) const;

SummaryResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, SummaryResultSetPtr, uint32_t requestedStartIndex = 0) const;

CategoryResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, CategoryResultSetPtr) const;

PublicationResultSetPtr operator()(
        const NS_SYSTEM::ResultSet&, PublicationResultSetPtr) const;

ProgrammePtr operator()(
        const NS_SYSTEM::Result&, ProgrammePtr) const;

FullEventPtr operator()(
        const NS_SYSTEM::Result&, FullEventPtr) const;


# ============================================================================
#{ STL
={============================================================================
*kt_dev_stl_000* useful links

http://www.sgi.com/tech/stl/ 
l
{stl-design-rationale}
The idea behind the STL is to beat the combinatorial explosion of containers and functions that
implement the same data structures and algorithms without forcing all program structures to be
objects that are all in the same hierarchy. As long as a type has the needed properties, it works
with STL containers or algorithms, no matter what class hierarchies it is or isn't part of.

STL provides a collection of such things that are recognized as both useful and reasonable design.
The picky could point out std::string as a counter-example to good design, here. 


{gcc-stl-code}
For example, less<T> in functional header is 

</usr/include/c++/4.6/functional>
...
#include <bits/c++config.h>
#include <bits/stl_function.h>
...

</usr/include/c++/4.6/bits/stl_function.h>

/** @file bits/stl_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */

...
  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
...


={============================================================================
*kt_dev_stl_001* pair and turple

{pair-class}
The class pair treats two values as a 'single' unit. The pair is defined in "utility" header and the
default pair ctor do value inits since it will use T(). As usual, pair class is dependant on type T;
menas that dependant on operations provided by type T.

namespace std {
  template <typename T1, typename T2>
    struct pair {
      // member
      T1 first;
      T2 second;
      ...
    };
}

See that it is declared as struct instead of class so that all members are public. Here are some
operations to see:

pair<T1,T2> p
Default constructor; creates a pair of values of types T1 and T2, initialized with their default
constructors

pair<T1,T2> p(val1,val1)
Creates a pair of values of types T1 and T2, initialized with val1 and val1

pair<T1,T2> p(rv1,rv2)
Creates a pair of values of types T1 and T2, move initialized with rv1 and rv2

p.first 
Yields the first value inside the pair (direct member access)

p.second 
Yields the second value inside the pair (direct member access)

p1 == p2 
Returns whether p1 is equal to p2 (equivalent to p1.first==p2.first && p1.second==p2.second)

p1.swap(p2) Swaps the data of p1 and p2 (since C++11)
swap(p1,p2) Same (as global function) (since C++11)

make_pair(val1,val2) 
Returns a pair with types and values of val1 and val2. The make_pair() function template enables you
to create a value pair 'without' writing the types explicitly.

std::pair<int,char>(42,@)
std::make_pair(42,@)

# code before C++11
#
namespace std {
  // create value pair only by providing the values
  template <template T1, template T2>
    pair<T1,T2> make_pair (const T1& x, const T2& y) {   // note: see how to 'deduce' types
      return pair<T1,T2>(x,y);
    }
}

<example>
note: no need to include "utility" and make_pair uses ().

#include <iostream>

using namespace std;

template <typename T1, typename T2>
std::ostream& operator<< (std::ostream& strm, const std::pair<T1,T2> &p)
{
  strm << "{" << p.first << " ," << p.second << "}";
}

int main()
{
  pair<int,int> ipair(80,88);
  cout << ipair << endl;
  cout << pair<int,int>(55,88) << endl;

  cout << make_pair(80,88) << endl;
  cout << make_pair(55,88) << endl;
}

{80 ,88}
{55 ,88}
{80 ,88}
{55 ,88}

<move-or-copy>
You can influence the type make_pair() yields by forcing either move or reference semantics.

For move semantics, you simply use std::move() to declare that the passed argument is no longer
used:

std::string s, t;
...
auto p = std::make_pair(std::move(s),std::move(t));
... // s and t are no longer used

To force reference semantics, you have to use ref(), which forces a reference type, or cref(), which
forces a constant reference type (both provided by <functional>). For example, in the following
statements, a pair refers to an int twice so that, finally, i has the value 2:

#include <iostream>
#include <functional>

int main()
{
  int i = 0;
  auto p = std::make_pair(std::ref(i), std::ref(i));

  p.first++;
  p.second++;

  std::cout << "i: " << i << std::endl;
}

i: 2

note: see how references are pakced into the pair.

<comparison>

namespace std {
  template <typename T1, typename T2>
    bool operator== (const pair<T1,T2>& x, const pair<T1,T2>& y) {
      return x.first == y.first && x.second == y.second;
    }
}

note: The first value has higher priority. Thus, if the first values of two pairs differ, the result
of their comparison is used as the result of the overall comparison of the pairs.


{tuple-class}
Tuples extends the concept of pairs to an arbitrary number of heterogeneous elements.

<example>
#include <iostream>

using namespace std;

int main()
{
  tuple<int, float, string> t1( 41, 6.3, "nico" );

  // iterate over elements
  cout << get<0>(t1) << " ";
  cout << get<1>(t1) << " ";
  cout << get<2>(t1) << " ";
  cout << endl;

  auto t2 = make_tuple( 22, 44, "two" );

  // assign second value in t2 to t1
  get<1>(t1) = get<1>(t2);

  if( t1 > t2 )
  {
    cout << "t1 is bigger than t2" << endl;
    t1 = t2;
  }

  // iterate over elements
  cout << get<0>(t1) << " ";
  cout << get<1>(t1) << " ";
  cout << get<2>(t1) << " ";
  cout << endl;
}

41 6.3 nico 
t1 is bigger than t2
22 44 two 

<iteration>
A tuple is no ordinary container class where you can iterate over the elements. Instead, you have to
know the index of elements you want to access at compile time.

Passing an index at runtime is not possible:

int i;
get<i>(t1) // compile-time error: i is no compile-time value

The good news is that it is also a compile-time error to pass an 'invalid' index:

get<3>(t1) // compile-time error if t1 has only three elements

<move-or-copy>
As with pair, can force move or copy of tuple.

<tuple-initializer>
The constructor taking a variable number of arguments to initialize a tuple is declared as 'explicit':

namespace std {
  template <typename... Types>
    class tuple {
      public:
        explicit tuple(const Types&...);
        template <typename... UTypes> explicit tuple(UTypes&&...);
        ...
    };
}

This situation, however, has consequences when using initializer lists to define values of a tuple.
For example, you can't use the assignment syntax to initialize a tuple because that is considered to
be an implicit conversion:

std::tuple<int,double> t1(42,3.14);    // OK, old syntax
std::tuple<int,double> t2{42,3.14};    // OK, new syntax
std::tuple<int,double> t3 = {42,3.14}; // ERROR <Q> why? See copy ctor


std::vector<std::tuple<int,float>> v { {1,1.0}, {2,2.0} }; // ERROR

std::tuple<int,int,int> foo() {
  return { 1, 2, 3 }; // ERROR
}


std::vector<std::pair<int,float>> v1 { {1,1.0}, {2,2.0} }; // OK

std::vector<int> foo2() {
  return { 1, 2, 3 }; // OK
}

For tuples, you have to 'explicitly' convert the initial values into a tuple

std::vector<std::tuple<int,float>> v { std::make_tuple(1,1.0), std::make_tuple(2,2.0) }; // OK

std::tuple<int,int,int> foo() {
  return std::make_tuple(1,2,3); // OK
}

<tuple-print>
The tuple class was first made public in the 'boost' library. There, tuple had an interface to write
values to output streams, but there is no support for this in the C++ standard library. With the
following header file, you can print any tuple with the standard output operator <<

#include <iostream>
#include <tuple>

using namespace std;

// helper: print element with index IDX of tuple with MAX elements
template <int IDX, int MAX, typename... Args>
struct PRINT_TUPLE {
  static void print( std::ostream& strm, const std::tuple<Args...> &t)
  {
    strm << std::get<IDX>(t) << (IDX+1==MAX ? "" : ",");
    PRINT_TUPLE<IDX+1, MAX, Args...>::print(strm, t);
  }
};

// partial specialization to end the recursion
template <int MAX, typename... Args>
struct PRINT_TUPLE<MAX, MAX, Args...>
{
  static void print( std::ostream& strm, const std::tuple<Args...>& t)
  {}
};

template <typename... Args>
std::ostream& operator<<( std::ostream& strm, const std::tuple<Args...> &t)
{
  strm << "[";
  PRINT_TUPLE<0, sizeof...(Args), Args...>::print(strm, t);
  return strm << "]";
}


int main()
{
  tuple<int, float, string> t1( 41, 6.3, "nico" );
  cout << "io: " << t1 << endl; 
}


This code makes heavy use of template metaprogramming to recursively iterate at compile time over
the elements of a tuple. Each call of PRINT_TUPLE<>::print() prints one element and calls the same
function for the next element. A partial specialization, where the current index IDX and the number
of elements in the tuple MAX are equal, ends this recursion.


<tuple-tie>
tie(ref1,ref2,...)
Creates a tuple of references, which allows extracting (individual) values out of a tuple

To make the use of references in tuples even more convenient, the use of tie() creates a tuple of
references:

std::tuple <int,float,std::string> t(77,1.1,"more light");

int i;
float f;
std::string s;

std::tie(i,f,s) = t;          // assigns values of t to i, f, and s

Here, std::tie(i,f,s) creates a tuple with references to i, f, and s, so the assignment of t assigns
the elements in t to i, f, and s.

The use of std::ignore allows ignoring tuple elements while parsing with tie(). This can be used to
extract tuple values partially:

std::tuple <int,float,std::string> t(77,1.1,"more light");

int i;
std::string s;
std::tie(i,std::ignore,s) = t; // assigns first and third value of t to i and s


={============================================================================
*kt_dev_stl_002* type and iterator traits

{type-traits}
from the ref 5.4
Almost everything in the C++ standard library is template based. To support the programming of
templates, sometimes called metaprogramming, template 'utilities' are provided to help both
programmers and library implementers.

Type traits, which were introduced with TR1 and extended with C++11, provide a 'mechanism' to define
behavior 'depending' on types. They can be used to optimize code for types that provide special
abilities. A type trait provides a way to deal with the properties of a type.

<example>
#include <iostream>

using namespace std;

template <typename T>
void foo (const T& val)
{
  if (std::is_pointer<T>::value) {
    std::cout << "foo() called for a pointer" << std::endl;
  }
  else {
    std::cout << "foo() called for a value" << std::endl;
  }
}

int main()
{
  int *p;

  foo(p);
}

foo() called for a pointer

The 'trait' std::is_pointer, defined in <type_traits>, is used to check whether type T is a pointer
type. In fact, is_pointer<> yields either a type true_type or a type false_type, for which ::value
either yields true or false.


{traits-and-overloads}
Why is the way using traits to provide two actions based on type better than providing two overloads
of foo(): one for ordinary types and one for pointer types?

One answer is that sometimes, too many overloads are necessary. In general, the power of type traits
comes more from the fact that they are building blocks for generic code, which can be demonstrated
by two examples.

<example>
Suppose that you have a function foo() that should be implemented differently for integral and
floating-point type arguments. The usual approach would be to overload this function for all
available integral and floating-point types:

void foo (short);             // provide integral version
void foo (unsigned short);
void foo (int);
...
void foo (float);             // provide floating-point version
void foo (double);
void foo (long double);

This repetition is not only tedious but also introduces the problem that it might not work for new
integral or floating-point types, either provided by the standard, such as long long, or provided as
user-defined types.

With the type traits, you can provide the following instead:

template <typename T>
void foo_impl (T val, true_type);   // provide integral version

template <typename T>
void foo_impl (T val, false_type);  // provide floating-point version

template <typename T>
void foo (T val)
{
  foo_impl (val, std::is_integral<T>());
}

std::is_integral<T>() at compile time yields std::true_type or std::false_type, which defines which
of the provided foo_impl() overloads gets instantiated.

note: do not see benefit since even when use template version, implicit conversion still happen
between types as do when provide single foo() for all integral types.

<example>
Another example for the usability of type traits is the need to process the "common type" of two or
more types.

For example, it would be an appropriate type of the minimum or the sum of two values of different
type. Otherwise, if I want to implement a function that yields the minimum of two values of
different types, which return type should it have:

template <typename T1, typename T2>
??? min (const T1& x, const T2& y);

Using the type traits, you can simply use the std::common_type<> to declare this type:

template <typename T1, typename T2>
typename std::common_type<T1,T2>::type min (const T1& x, const T2& y);


{iterator-traits} for writing algorithm?
It might be useful or even necessary to be able to overload behavior for different iterator
categories. By using iterator tags and iterator traits (both provided in <iterator>), such an
overloading can be performed.

For each iterator category, the C++ standard library provides an iterator tag that can be used as a
"label" for iterators:

namespace std {
  struct output_iterator_tag {
  };
  struct input_iterator_tag {
  };
  struct forward_iterator_tag
    : public input_iterator_tag {
    };
  struct bidirectional_iterator_tag
    : public forward_iterator_tag {
    };
  struct random_access_iterator_tag
    : public bidirectional_iterator_tag {
    };
}

If you write generic code, you might not be interested only in the iterator category. You may need
the type of the elements to which the iterator refers. Therefore, the C++ standard library provides
a special template structure to define the iterator traits.

This structure contains all relevant information about an iterator and is used as a common interface
for all the type definitions an iterator should have (the category, the type of the elements, and so
on):

namespace std {
  template <typename T>
    struct iterator_traits {
      typedef typename T::iterator_category iterator_category;
      typedef typename T::value_type value_type;
      typedef typename T::difference_type difference_type;
      typedef typename T::pointer pointer;
      typedef typename T::reference reference;
    };
}


={============================================================================
*kt_dev_stl_006* stl concepts

The concept of the STL is based on a 'separation' of data and operations. The data is managed by
container classes, and the operations are defined by configurable algorithms. Iterators are the 'glue'
between these two components.

This STL concept contradicts the original idea of object-oriented programming: However, the reason
for doing so is very important. In principle, you can combine every kind of container with every
kind of algorithm, so the result is a very 'flexible' but still rather 'small' framework.

One fundamental aspect of the STL is that all components work with 'arbitrary' types. Thus, the STL is
a good example of the concept of 'generic' programming. Containers and algorithms are generic for
arbitrary types and classes, respectively.


{components}
1. container
Containers are used to manage 'collections' of objects of a certain kind. Every kind of container
has its own advantages and disadvantages, so having different container types reflects different
requirements for collections in programs.

2. iterator
Iterators are used to step through the elements of collections of objects. The major advantage of
iterators is that they offer a small but common interface for any arbitrary container type. 

The interface for iterators is almost the same as for ordinary pointers. To increment an iterator,
you call operator ++. To access the value of an iterator, you use operator *. 

So, you might consider an iterator a kind of a smart pointer that translates the call "go to the
next element" into whatever is appropriate.

3. algorithm
Algorithms are used to process the elements of collections. Algorithms use iterators. Thus, because
the iterator interface for iterators is common for all container types, an algorithm has to be
written only once to work with arbitrary containers.


{error-handling}
The design goal of the STL was the best performance rather than the highest security. Error checking
wastes time, so almost 'none' is done. Two reasons:

1. Error checking reduces performance, and speed is still a general goal of programs. As mentioned,
good performance was one of the design goals of the STL.

2. If you prefer safety over speed, you can still get it, either by adding wrappers or by using
special versions of the STL. But when error checking is built into all basic operations, you can't
program to avoid error checking to get better performance. For example, when every subscript
operation checks whether a range is valid, you can't write your own subscripts without checking.
However, it is possible the other way around.

The C++ standard library states that any STL use that violates preconditions results in undefined
behavior because these errors occur at 'runtime', not at compile time, they cause undefined
behavior. In particular, the use of the STL requires that the following be met:

<precondition>
1. Iterators must be valid. For example, they must be initialized before they are used. Note that
iterators may become invalid as a side effect of other operations. In particular, iterators become
invalid

- for vectors and deques, if elements are inserted or deleted or reallocation takes place, and
- for unordered containers, if 'rehashing' takes place (which also might be the result of an
insertion).

2. Iterators that refer to the past-the-end position have no element to which to refer. Thus,
  calling operator * or operator -> is not allowed. This is especially true for the return values of
  the end(), cend(), and rend() container member functions.

3. Ranges must be valid:
- Both iterators that specify a range must refer to the same container.
- The second iterator must be reachable from the first iterator.

4. If more than one source range is used, the second and later ranges usually must have at least as
many elements as the first one.

5. Destination ranges must have enough elements that can be overwritten; otherwise, insert iterators
must be used.

<safe-stl>
The STL is not required to protect you from yourself and the STL is as error prone as pointers are
in C. Thus, it is a good idea to use a "safe" STL, at least during software development.

[SafeSTL]
Cay S. Horstmann. Safe STL
http://www.horstmann.com/safestl.html

[STLport]
STLport
http://www.stlport.org/


{exception-handling}
As a result of these discussions, the C++ standard library since C++98 gives the following basic
guarantee for exception safety: The C++ standard library will not leak resources or violate
container invariants in the face of exceptions.

Regarding this stronger guarantee; atomic with respect to exceptions or transaction safe, the C++
standard library now guarantees the following:

The library reference, p249 for details.

Note that all these guarantees are based on the requirement that 'destructors' never throw, which
should always be the case in C++. The C++ standard library makes this promise, and so must the
'application' programmer.

<what-container-consideration>
If you need a container with full commit-or-rollback ability, you should use either a list (without
calling or special handling for remove(), remove_if(), merge(), sort(), and unique()) or an
associative/unordered container (without calling their multiple-element insert operations). This
avoids having to make copies before a modifying operation to ensure that no data gets lost. Note
that making copies of a container could be very expensive.

If you can't use a node-based container and need the full commit-or-rollback ability, you have to
provide wrappers for each critical operation.


{guarantees}
From ESTL p5. The revolutionary aspect of STL is its complexity guarantees regardless of the STL
platform you are using.


={============================================================================
*kt_dev_stl_007* containers

According to the way the order of elements is defined.

{sequence} ordered vs sorted
Sequence containers are 'ordered' collections in which every element has a certain 'position'. This
position depends on the time and place of the insertion, but it is 'independent' of the value of the
element. 

For example, if you put six elements into an ordered collection by appending each element at the end
of the collection, these elements are in the 'exact' order in which you put them.

The STL contains five predefined sequence container classes: array, vector, deque, list, and
forward_list.

{associative}
Associative containers are 'sorted' collections in which the position of an element depends on its
'value' (or key, if its a key/value pair) due to a certain 'sorting' criterion. 

If you put six elements into a collection, their 'value' determines their order. The order of
insertion doesn't matter. atomatic sorting.

The STL contains four predefined associative container classes: set, multiset, map, and multimap.

{unordered}
Unordered (associative) containers are 'unordered' collections in which the position of an element
doesn't matter. The only important question is whether a specific element is 'in' such a collection.

Thus, if you put six elements into a collection, their order is undefined and might change over
time. 

The STL contains four predefined unordered container classes: unordered_set, unordered_multiset,
unordered_map, and unordered_multimap.


{implementation}
Sorted collections have the additional ability to be ordered according to a sorting criterion.

However, the STL collection types are completely distinct from one another and have very different
implementations that are not derived from one another. As we will see:

* Sequence containers are usually implemented as arrays or linked lists.
* Associative containers are usually implemented as binary trees.
* Unordered containers are usually implemented as hash tables.

The particular implementation of any container is not defined by the C++ standard library. However,
the behavior and complexity specified by the standard do not leave much room for variation. So, in
practice, the implementations differ only in minor details.


<contiguous-and-node-based> the other category
string, vector, deque, and array are 'contiguous' memory. Hence, insert/delete in the middle can be
expensive since have to move elements but fast access.

All node-based containers (lists, forward lists, sets, multisets, maps, and multimaps), including
the unordered containers,


={============================================================================
*kt_dev_stl_008* containers: requirements on element type

From the library reference, p244.
Containers, iterators, and algorithms of the STL are templates. Thus, they can process both
predefined or user-defined types. However, because of the operations that are called, some
requirements apply. The elements of STL containers must meet the following three fundamental
requirements:

1. An element must be 'copyable' or 'movable'. Thus, an element type implicitly or explicitly has to
provide a copy or move constructor. A generated copy should be equivalent to the source. This means
that any test for equality returns that both are equal and that both source and copy behave the
same.

2. An element must be (move) 'assignable' by the assignment operator. Containers and algorithms
use assignment operators to overwrite old elements with new elements.

3. An element must be 'destroyable' by a destructor. Containers destroy their internal copies of
elements when these elements are removed from the container. Thus, the destructor must not be
private. Also, as usual in C++, a destructor must not throw; otherwise, all bets are off.

These three operations are generated implicitly for any class. Thus, a class meets the requirements
automatically, provided that no special versions of these operations are defined and no special
members disable the sanity of those operations.

Elements might also have to meet the following requirements:

1. For some member functions of sequence containers, the default constructor must be available. For
example, it is possible to create a nonempty container or increase the number of elements with no
hint of the values those new elements should have. These elements are created without any arguments
by calling the default constructor of their type.

2. For several operations, the test of equality with operator == must be defined and is especially
needed when elements are searched. For unordered containers, however, you can provide your own
definition of equivalence if the elements do not support operator == (see Section 7.9.7, page 379).

3. For associative containers, the operations of the sorting criterion must be provided by the
elements. By default, this is the operator <, which is called by the less<> function object.

4. For unordered containers, a hash function and an equivalence criterion must be provided for the
elements. See Section 7.9.2, page 363, for details.


{requirement-on-key-type-for-ordered-container} 
C++P 425. The ordered container uses opearator-less(<) for ordering relation which defines so called
"strick weak ordering":

o Two keys cannot both be "less than" each other; if k1 is less than k2 then k2 must never be less
than k1.

o Neither two keys "less than" the other, then those are "equivalent"

Here the library <template-less>

namespace std {
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
};


{value-reference-semantics}
Copying values means that the STL containers provide 'value' semantics. The containers contain the
values of the objects you insert rather than the objects themselves. In practice, however, you may
also need 'reference' semantics. This means that the containers contain references to the objects
that are their elements.

The approach of the STL to support only value semantics has both strengths and weaknesses.

<strength>
1. Copying elements is simple.
2. References are error prone. You must ensure that references don't refer to objects that no longer
exist. You also have to manage circular references, which might occur.

<weaknesses>
1. Copying elements might result in bad performance or may not even be possible.
2. Managing the same object in several containers at the same time is not possible.

In practice, you need both approaches; Unfortunately, there is no support for reference semantics in
the C++ standard library. However, you can implement reference semantics in terms of value
semantics. The obvious approach to implementing reference semantics is to use pointers as elements.
However, ordinary pointers have the usual problems. A better approach is to use a kind of smart
pointer.


={============================================================================
*kt_dev_stl_009* containers: common operations and initialize

{common-operations}
Usually, the STL containers provide only those special member functions that in general have "good"
performance, where "good" normally means constant or logarithmic complexity. This prevents a
programmer from calling a function that might cause bad performance.

<emplace>
Here c means container and the emplace_* construct a object 'directly' in a container. 'no' copy.

c.emplace_back( "978-3403", 25, 15.99 );

c.push_back( Sales_data("978-3403", 25, 15.99) );  // use temp object

<initialize-from-c-array> from C++11, supports std::begin()
int intarr[] = { 0, 1, ... };
vector<int> ivec( std::begin(intarr), std::end(intarr) );

// further example of std::begin()
#include <iterator>
#include <vector>
#include <iostream>

using namespace std;

int main()
{
  int vals[] = { 33, 67, -4, 13, 5, 2 };

  // use begin() and end() for ordinary C arrays
  std::vector<int> v(std::begin(vals), std::end(vals));

  // use global begin() and end() for containers:
  std::copy (std::begin(v), std::end(v), std::ostream_iterator<int>(std::cout," "));
  std::cout << std::endl;
}

<initialize-from-list> from C++11.
ContType c(initlist)
ContType c = initlist

vector<string> articles = { "a", "an", "the" };
vector<string> articles{ "a", "an", "the" };

<initialize-from-range>
ContType c(beg,end)
Creates a container and initializes it with copies of all elements of [beg,end) (not for array<>)

When copy init from other container, container and 'element' type must be indentical. The constructor
for a given range provides the ability to initialize the container with elements of another
container if there is an automatic conversion from the source element type to the destination
element type.  e.g. c.assign( is, ie )

vector<const char*> articles = { "a", "an", "the" };
forward_list<string> words ( articles.begin(), articles.end() );

<initialize-from-move> from C++11
std::list<std::string> l; // l is a linked list of strings

// move all elements of the list into a vector
std::vector<std::string> c(std::make_move_iterator(l.begin()),
                           std::make_move_iterator(l.end()) );

<initialize-from-move-ctor>
note: This constructor provides significant performance improvements

ContType c(rv)
ContType c = rv
Move constructor; creates a new container, taking the contents of the rvalue rv (since C++11; not
for array<>)

std::vector<int> v1;

// move contents of v1 into v2, state of v1 undefined afterward
std::vector<int> v2 = std::move(v1);

<assign> constant complexity
c = c2         Assigns all elements of c2 to c
c = rv         Move assigns all elements of the rvalue rv to c (since C++11; not for array<>)
c = initlist   Assigns all elements of the initializer list initlist (since C++11; not for array<>)

If you assign containers, you copy all elements of the source container and remove all old elements
in the destination container. Thus, assignment of containers is relatively expensive.

# examples

vector<int> vi1(3, 5);  // vi1(size, val)
vector<int> vi2(6, 2);

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:6

vi2 = vi1;              // see

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:3


Applies to the whole container.

vector<int> ivec = { 1, 2, 3, 4, 5, 6 };
ivec.size();         // 7

ivec = { 1, 2, 5 };
ivec.size();         // 3


vector<string> v;
v = {"a", "the", "an"};

<key> Since C++11, for performance reasons, you should use move assignment which internally just
swap pointers to the memory of values rather than copying all values 'if' after an assignment, the
contents of the container on the right-hand side are no longer used.

std::vector<int> v1;
std::vector<int> v2;

// move contents of v1 into v2, state of v1 undefined afterward
v2 = std::move(v1);

note: this moves really since v2 becomes empty after move.
#include <iostream>
#include <vector>

using namespace std;

template <typename T>
inline void printItems( const std::string &msg, const T& coll )
{
  std::cout << msg;

  for( const auto &elem : coll )
    std::cout << ' ' << elem << ": ";

  std::cout << std::endl;
}

int main()
{
  vector<int> ivec1{1,2,3,4,5,6};
  printItems("ivec1 : ", ivec1 );

  vector<int> ivec2{7,8,9};
  printItems("ivec2 : ", ivec2 );

  // ivec1 = ivec2;
  ivec1 = std::move(ivec2);

  printItems("ivec1 : ", ivec1 );
  cout << "ivec1 : size : " << ivec1.size() << endl;

  printItems("ivec2 : ", ivec2 );
  cout << "ivec2 : size : " << ivec2.size() << endl;
}

ivec1 :  1:  2:  3:  4:  5:  6: 
ivec2 :  7:  8:  9: 
ivec1 :  7:  8:  9: 
ivec1 : size : 3
ivec2 : 
ivec2 : size : 0

<swap> constant complexity
In addition and since C++98, 'all' containers provide a swap() 'member' function to swap contents of
two containers. In fact, it swaps only some 'internal' pointers that refer to the data (elements,
allocator, sorting criterion, if any). So, swap() is guaranteed to have only 'constant' complexity,
not the linear complexity of a copy assignment.

Iterators and references to elements of a container follow swapped elements. After swap(), iterators
and references 'still' refer to the elements they referred to before, which, however, are in a
different container then.

c1.swap(c2) Swaps the data of c1 and c2
swap(c1,c2) Swaps the data of c1 and c2

note: that for containers of type array<>, the behavior of swap() is slightly different. Because you
can't internally just swap pointers, swap() has 'linear' complexity, and iterators and references
refer to the same container but different elements afterward. <Q> only for array?

<push_back>
is provided for all sequence containers, where appending an element is possible and reasonably fast.

coll.push_back(i);

<size>
is provided for any container class except forward_list because it couldn't have constant complexity
there.

coll.size();

<empty>
empty() returns whether the number of elements is zero (begin()==end()). You 'should' prefer it over
size()==0, because it might be implemented more efficiently than size(), and size() is not provided
for forward lists.

<resize>
is used to change the number of elements except array including increse from size 0. If the size
grows, you can pass an additional parameter to specify the value of the 'new' elements. Otherwise,
use default ctor.

coll.resize(10,99);

<comparison>
For all but unordered containers, the usual comparison operators ==, !=, <, <=, >, and >= are
defined according to the following three rules:

1. Both containers must have the same 'type'.
2. Two containers are equal if their elements are 'equal' and have the same 'order'. To check
equality of elements, operator == is used.
3. To check whether a container is less than another container, a lexicographical comparison is done

For unordered containers, only the operators == and != are defined. They return true when each
element in one container has an equal element in the other container. The order doesn't matter
(that's why they are unordered containers).

<clear>
Removes all elements (empties the container; not for array<>)


={============================================================================
*kt_dev_stl_010* sequential containers

Consider different performance trade-offs between insert/delete and random-access.

vector      : random-access, fast insert/delete at the back, contig. mem
string      : random-access, fast insert/delete at the back, contig. mem
deque       : double-ended q, random-access, fast insert/delete at front/back
array       : C++11. fixed size. possible to copy and assign.

string, vector, deque, and array are 'contiguous' memory. Hence, insert/delete in the middle can be
expensive since have to move elements but fast access.

list        : double llist, bi-directional, fast insert/delete at any point
forward list: single llist, forward, support push_front only.

these provides sequential access and may have memory overhead but fast insert/delete.

note:
The forward_list don't support size() but others do. The size() has fast and constant time op which
is different from ESTL so seems it's true for C++11? Primus says C++ library has improved
significantly in recent.

The list and forward_list don't support iterator arithmetic since this is for containers that
supports random access; string, vector, deque and array.


={============================================================================
*kt_dev_stl_011* sequential: vector

A vector manages its elements in a 'dynamic' array. It enables random access, which means that you
can access each element directly with the corresponding index.

#include <vector>

namespace std {
  template <typename T,
  typename Allocator = allocator<T> >
    class vector;
}


{ctor-and-dtor}
vector<Elem> c(n,elem)              Creates a vector initialized with n copies of element elem


{performance}
Appending and removing elements at the end of the array is very fast. However, inserting an element
in the middle or at the beginning of the array takes time. So consider that multiple elements are
inserted by a single call rather than by multiple calls which is faster.

<example>
#include <iostream>
#include <memory>
#include <vector>

using namespace std;

int main()
{
  vector<int> coll;

  for(int i=1; i <= 6; i++)
    coll.push_back(i);

  for(int i=0; i < coll.size(); i++)
    cout << coll[i] << ' ';

  cout << endl;
}


{reallocation} how-a-vector-grows
To support fast random access, vector elements are stored 'contiguously'. To maintain contiguous
memory and to avoid reallocating a container each time an element is added, the allocation strategy
is: when they have to get new memory, vector and 'string' implementations typically allocate
'capacity' beyond what is immediately needed. Thus there is no need to 'reallocate' the container
for each new element. The vector has to move all of its elements each time it reallocates memory.

<why-realocation-matter>
The capacity of a vector is important for two reasons:
1. Reallocation invalidates all references, pointers, and iterators for elements of the vector.
2. Reallocation takes time.

c.shrink_to_fit();   C++11. request to reduce capacity() to equal size()
c.capacity();        number of elements c can have before reallocation is necessary.
c.reserve(n);        allocate space for at least n elements

<reserve-or-constructor>
To avoid reallocation, you can use reserve() to ensure a certain capacity before you really need it.
In this way, you can ensure that references remain valid as long as the capacity is not exceeded

std::vector<int> v;  // create an empty vector
v.reserve(80);       // reserve memory for 80 elements

Or is to initialize a vector with enough elements by passing additional arguments to the
constructor.

std::vector<T> v(5); // creates a vector and initializes it with five values
                     // (calls five times the default constructor of type T)

note: The type of the elements must provide a default constructor for this ability. For fundamental
types, zero initialization is guaranteed. 

<key> But for complex types, even if a default constructor is provided, the initialization takes
time. If the only reason for initialization is to reserve memory, you should use reserve().

<capacity>
Unlike for strings, it is not possible to call reserve() for vectors to shrink the capacity. Calling
reserve() with an argument that is less than the current capacity is a no-op. Furthermore, how to
reach an optimal performance regarding speed and memory use is implementation defined. When
reallocation is needed, how much memory it will allocate is implementation specific.

Because the capacity of vectors never shrinks, it is guaranteed that references, pointers, and
iterators remain valid even when elements are deleted, provided that they refer to a position before
the manipulated elements.

C++11 introduced shrink_to_fit() which is a 'nonbinding' request to shrink the capacity to fit the
current number of elements: Valid only for vector, string, and deque. capacity and reserve valid
only for vector and string.

There is no guarantee that shrink_to_fit will return a memory since it's a only 'request'.


{element-access}
Does it add an element? NO. The result is undefined, usually core-dumped.

int absdistinct_vec(int A[], int n)
{
  if(n==0)
    return -1;

  vector<int> ivec;
  int count = 0;

  for( int i = 0; i < n; ++i )
    ivec[i] = abs(*(A+i)); 
}

<use-array-as-c-array>
As with array<>, can use vector as a C array. Which array<> or vector<> is better?

<example>
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  // create empty vector for strings
  vector<string> sentence;
  // reserve memory for five elements to avoid reallocation
  sentence.reserve(5);

  // append some elements
  sentence.push_back("Hello,");
  sentence.insert(sentence.end(),{"how","are","you","?"});

  // print elements separated with spaces
  copy (sentence.cbegin(), sentence.cend(),
      ostream_iterator<string>(cout," "));
  cout << endl;

  // print technical data
  cout << " max_size(): " << sentence.max_size() << endl;
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // swap second and fourth element
  swap (sentence[1], sentence[3]);
  // insert element "always" before element "?"
  sentence.insert (find(sentence.begin(),sentence.end(),"?"), "always");
  // assign "!" to the last element
  sentence.back() = "!";

  // print elements separated with spaces
  copy (sentence.cbegin(), sentence.cend(),
      ostream_iterator<string>(cout," "));
  cout << endl;

  // print some technical data again
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;

  // delete last two elements
  sentence.pop_back();
  sentence.pop_back();

  // shrink capacity (since C++11)
  sentence.shrink_to_fit();
  // print some technical data again
  cout << " size()    : " << sentence.size() << endl;
  cout << " capacity(): " << sentence.capacity() << endl;
}

Hello, how are you ? 
 max_size(): 1073741823
 size()    : 5
 capacity(): 5
Hello, you are how always ! 
 size()    : 6
 capacity(): 10         // x2
 size()    : 4
 capacity(): 10         // no change


{vector-bool}
For Boolean elements, the C++ standard library provides a 'specialization' of vector<>. Such a usual
implementation would reserve at least 1 byte for each element. The vector<bool> specialization
usually uses internally only 1 bit for an element, so it is typically eight times smaller.

But such an optimization also has a snag: In C++, the smallest addressable value must have a size of
at least 1 byte. Thus, such a specialization of a vector needs special handling for references and
iterators.

As a result, a vector<bool> does not meet all requirements of other vectors. For example, a
vector<bool>::reference is not a true lvalue and vector<bool>::iterator is 'not' a randomaccess
iterator.

In addition, vector<bool> might perform 'worse' than normal implementations, because element
operations have to be transformed into bit operations. However, how vector<bool> is implemented is
implementation specific. Thus, the performance (speed and memory) might differ.

class vector<bool> is more than a specialization of vector<> for bool. It also provides some special
bit operations. You can handle bits or flags in a more convenient way.

vector<bool> has a 'dynamic' size, so you can consider it a bitfield with dynamic size. Thus, you can
add and remove bits. If you need a bitfield with static size, you should use bitset rather than a
vector<bool>.

The additional operations of vector<bool> are:
c.flip()             Negates all Boolean elements (complement of all bits)
c[idx].flip()        Negates the Boolean element with index idx (complement of a single bit)
c[idx] = val         Assigns val to the Boolean element with index idx (assignment to a single bit)
c[idx1] = c[idx2]    Assigns the value of the element with index idx2 to the element with index idx1

note: default value is false.

<proxy-design>
How this "c[idx].flip()" possible since type bool is fundamental type? Here, the class vector<bool>
uses a common trick, called a proxy. For vector<bool>, the return type of the subscript operator
(and other operators that return an element) is an auxiliary class. If you need the return value to
be bool, an automatic type conversion is used. For other operations, the member functions are
provided. The relevant part of the declaration of vector<bool> looks like this:

namespace std {
  template <typename Allocator> class vector<bool,Allocator> {
    public:
      // auxiliary proxy type for element modifications:
      class reference {
        ...
        public:
          reference& operator= (const bool) noexcept; // assignments
          reference& operator= (const reference&) noexcept;
          operator bool() const noexcept; // automatic type conversion to bool
          void flip() noexcept; // bit complement
      };

      ...

      // operations for element access return reference proxy instead of bool:
      reference operator[](size_type idx);
      reference at(size_type idx);
      reference front();
      reference back();
      ...
  };
}


={============================================================================
*kt_dev_stl_012* sequential: deque 

This is an abbreviation for "double-ended queue." It is a dynamic 'array' that can grow in 'both'
directions. Thus, inserting elements at the end and at the beginning is fast. However, inserting
elements in the middle takes time because elements must be moved.


{element-access}
c[idx]    Returns the element with index idx (no range checking)
c.at(idx) Returns the element with index idx (throws range-error exception if idx is out of range)

<example>
#include <iostream>
#include <deque>

using namespace std;

int main()
{
  deque<float> coll;

  for(int i=1; i <= 6; i++)
    coll.push_front(i*1.1);

  for(int i=0; i < coll.size(); i++)
    cout << coll[i] << ' ';

  cout << endl;
}

6.6 5.5 4.4 3.3 2.2 1.1


={============================================================================
*kt_dev_stl_013* sequential: array 

An array(an instance of the container class array<>) models a static array. It wraps an ordinary
static C-style array providing the interface of an STL container. Only a replacement of element
values is possible.

This manages its elements in an array of fixed size and the number of elements is a part of the type
of an array.

If you need a sequence with a fixed number of elements, class array<> has the best performance
because memory is allocated on the 'stack' (if possible), reallocation never happens, and you have
random access.

#include <array>

namespace std {
  template <typename T, size_t N>
    class array;
}

<initialize>
note: that array<> is the 'only' container whose elements are default initialized when nothing is
passed to initialize the elements. This means that for fundamental types, the initial value might be
undefined rather than zero like vector

std::array<int,4> x;       // OOPS: elements of x have undefined value
std::array<int,4> x = {};  // OK: all elements of x have value 0 (int())

<element-access>
For nonconstant arrays, these operations return a reference to the element. Thus, you could modify
an element by using one of these operations

c[idx]      Returns the element with index idx (no range checking)
c.at(idx)   Returns the element with index idx (throws range-error exception if idx is out of range)
c.front()   Returns the first element (no check whether a first element exists)
c.back()    Returns the last element (no check whether a last element exists)

<use-array-as-c-array>
Guarantees that the elements of an array<> are in contiguous memory. Thus, you can expect that for
any valid index i in array a, the following yields true:

&a[i] == &a[0] + i

This guarantee has some important consequences. It simply means that you can use an array<> wherever
you can use an ordinary C-style array.

std::array<char,41> a;           // create static array of 41 chars
strcpy(&a[0],"hello, world");    // copy a C-string into the array
printf("%s\n", &a[0]);           // print contents of the array as C-string

you don't have to use the expression &a[0] to get direct access to the elements in the array,
because the member function data() is provided for this purpose:

std::array<char,41> a;           // create static array of 41 chars
strcpy(a.data(),"hello, world"); // copy a C-string into the array
printf("%s\n", a.data());        // print contents of the array as C-string

<example>
#include <iostream>
#include <array>

using namespace std;

int main()
{
  array<string, 5> coll{"hello", "world"};

  for(int i=0; i < coll.size(); i++)
    cout << i << ": " << coll[i] << endl;
}


0: hello
1: world
2: 
3: 
4: 

<example>
#include <iostream>
#include <array>
#include <functional>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  array<int, 10> coll = {11,22,33,44};

  PRINT_ELEMENTS(coll, "initialized: " );

  coll.back() = 9999999;
  coll[coll.size()-2] = 42;

  PRINT_ELEMENTS(coll, "modified   : " );

  cout << "sum: " << accumulate( coll.begin(), coll.end(), 0 ) << endl;

  transform( coll.cbegin(), coll.cend(),        // source
              coll.begin(), negate<int>());     // destination, operation

  PRINT_ELEMENTS(coll, "negated    : " );
}

initialized: 11 22 33 44 0 0 0 0 0 0 
modified   : 11 22 33 44 0 0 0 0 42 9999999 
sum: 10000151
negated    : -11 -22 -33 -44 0 0 0 0 -42 -9999999 

<example>
#include <iostream>
#include <array>
#include <cstring>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  array<char, 41> coll = {"this is an char array"};
  PRINT_ELEMENTS(coll, "initialized: " );

  strcpy( &coll[0], "use the address of first");
  PRINT_ELEMENTS(coll, "strcpyed   : " );

  strcpy( coll.data(), "use data member");
  PRINT_ELEMENTS(coll, "strcpyed   : " );
}

initialized: t h i s   i s   a n   c h a r   a r r a y                     
strcpyed   : u s e   t h e   a d d r e s s   o f   f i r s t                  
strcpyed   : u s e   d a t a   m e m b e r  o f   f i r s t                  


={============================================================================
*kt_dev_stl_014* sequential: list

A list<> is implemented as a 'doubly' linked list of elements and do not provide random access. The
advantage of a list is that the insertion or removal of an element is fast at any position.

<example>
#include <iostream>
#include <list>

using namespace std;

int main()
{
  list<char> coll;

  for(char c = 'a'; c <= 'z'; c++ )
    coll.push_back(c);

  for( auto &elem : coll )
    cout << elem << ' ';
  
  cout << endl;
}


{no-random-access}
A direct element access by using operator [ ] is not provided for lists. This is because lists don't
provide random access, and so an operator [ ] would have bad performance.


{list-erase}
note: that the header from begin() gets updated when use erase(start, end) to trim entries in the
front.

<code-example>
#include <iostream>
#include <list>

typedef std::list<double> LIST;

int main()
{
  int n;
  double item;
  LIST dlist; 
  LIST::iterator iHead;

  std::cout << "type in an integer n(loop count) followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    dlist.push_back(item);
  }

  std::cout << "input is done and you have entered " << dlist.size() << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }

  iHead = dlist.begin(); iHead++; iHead++;
  std::cout << "items: " << *iHead << std::endl; 
  dlist.erase( dlist.begin(), iHead );

  std::cout << "input is done and you have entered " << dlist.size() << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }
}

$ ./a.out 
type in an integer n(loop count) followed by n decimal numbers.
5
10
20
30
40
50
input is done and you have entered 5 items
items: 10
items: 20
items: 30
items: 40
items: 50
items: 30
input is done and you have entered 3 items
items: 30
items: 40
items: 50


={============================================================================
*kt_dev_stl_015* sequential: forward list

A forward_list<> is implemented as a 'singly' linked list of elements. As a consequence, where all
operations that move backward or would cause a performance penalty are not supported. note: For this
reason, member functions such as push_back() and even size() are not provided.

<example>
#include <iostream>
#include <forward_list>

using namespace std;

int main()
{
  forward_list<long> coll{2,3,5,7,11,13,17};

  // poor performance
  coll.resize(9);
  coll.resize(10,99);

  for( auto &elem : coll )
    cout << elem << ' ';
  
  cout << endl;
}

2 3 5 7 11 13 17 0 0 99

<example> 
This is <is-implemented-in-terms-of-example> to have size() which is not supported.

#include <iostream>
#include <forward_list>

template<typename T>
class Forward_list {
  private:
    size_t count;
    std::forward_list<T> list;

  public:
    typedef typename std::forward_list<T>::iterator iterator;

    Forward_list() : count(0) {}

    void push_front(const T& elem) {
      count++;
      list.push_front(elem);
    }

    size_t size() const {
      return count;
    }

    // note: "iterator begin() const" causes compile error
    iterator begin() {
      return list.begin();
    }

    iterator end() {
      return list.end();
    }
};

int main()
{
  int n, item;
  Forward_list<int> ilist;
  Forward_list<int>::iterator ihead;

  std::cout << "type in an integer n(loop count) followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    ilist.push_front(item);
  }

  std::cout << "input is done and you have entered " << ilist.size() << " items" << std::endl;

  ihead = ilist.begin();

  for(; ihead != ilist.end(); ihead++) 
  {
    std::cout << "items: " << *ihead << std::endl; 
  }
}

type in an integer n(loop count) followed by n decimal numbers.
5
10
20
30
40
50
input is done and you have entered 5 items
items: 50
items: 40
items: 30
items: 20
items: 10


={============================================================================
*kt_dev_stl_020* associative containers

Associative containers sort their elements automatically according to a certain ordering criterion.
By default, the containers compare the elements or the keys with operator <. However, you can supply
your own comparison function to define another sort criterion.

<what-container-consideration>
Typically implemented as binary trees. The associative containers differ in the kinds of elements
they support and how they handle duplicates. Node based containers and use balanced tree as ESTL
said. GCC is implemented using red-black tree. In fact, search functions have 'logarithmic'
complexity.

From gcc errors:
In file included from /usr/include/c++/4.6/map:60:0,
                 from use-mmap.cpp:3:
/usr/include/c++/4.6/bits/stl_tree.h: In member function 'std::_Rb_tree<_Key, _Val, _KeyOfValue,

<set-and-map>
You can consider a set as a special kind of map, in which the value is 'identical' to the key.


{change-sorting-criterion}
set c(op) Creates an empty set/multiset that uses op as the sorting criterion

Here, set may be one of the following types:
set<Elem>         A set that by default sorts with less<> (operator <)
set<Elem,Op>      A set that by default sorts with Op
multiset<Elem>    A multiset that by default sorts with less<> (operator <)
multiset<Elem,Op> A multiset that by default sorts with Op

note: also that if two 'containers' are 'compared' by operator ==, the elements in both containers
are compared using their operator ==, which means that operator == has to be provided for the
'element' type.

map c(op) Creates an empty map/multimap that uses op as the sorting criterion

map<Key,Val>         A map that by default sorts keys with less<> (operator <)
map<Key,Val,Op>      A map that by default sorts keys with Op
multimap<Key,Val>    A multimap that by default sorts keys with less<> (operator <)
multimap<Key,Val,Op> A multimap that by default sorts keys with Op

There are two ways to set sorting criterion.

<as-a-template-parameter>
In this case, the sorting criterion is 'part' of the type. This is the usual way to specify the
sorting criterion. To be more precise, the second parameter is the 'type' of the sorting criterion.
The concrete sorting criterion is the function 'object' that gets created with the container. To do
this, the constructor of the container calls the default constructor of the type of the sorting
criterion.

typedef std::set<int,std::greater<int>> IntSet;
typedef std::map<float,std::string,std::greater<float>> coll;


<as-a-constructor-parameter>
You might have a type for several sorting criteria that allows having different initial values or
states. This is useful when processing the sorting criterion at 'runtime' and when sorting criteria
are needed that are different (criterion) but of the same data type.

<example>
multiset< std::shared_ptr<Quote>, decltype(compare)*> items{ compare };

<example>
You need a special type for the sorting criterion: one that lets you pass your sorting details at
runtime.

#include <iostream>
#include <set>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

class RuntimeCmp
{
  public:
    enum cmp_mode {normal, reverse};

  private:
    cmp_mode mode;

  public:
    RuntimeCmp( cmp_mode m = normal ) : mode(m) { }

    // call operator. comparison of 'elements': member function for any element type
    template<typename T>
      bool operator() ( const T& t1, const T& t2 ) const
      { return mode == normal ? t1 < t2 : t2 < t1; }

    // comparison of sorting criteria
    bool operator==( const RuntimeCmp& rc ) const 
    { return mode == rc.mode; }
};

typedef set<int, RuntimeCmp> IntSet;

int main()
{
  // use default sorting criterion
  IntSet coll1{ 4, 7, 5, 1, 6, 2, 5 }; 
  PRINT_ELEMENTS(coll1, "coll1 : ");

  // create sorting criterion with reverse order
  RuntimeCmp reverse_order(RuntimeCmp::reverse);

  IntSet coll2(reverse_order);            // <key> set c(op)
  coll2 = { 4, 7, 5, 1, 6, 2, 5 };
  PRINT_ELEMENTS(coll2, "coll2 : ");

  coll1 = coll2;                          // <key> instant change of criterion
  coll1.insert(3);
  PRINT_ELEMENTS(coll1, "coll1 : ");

  // One of Nonmodifying operations for set family
  // c.key_comp() Returns the comparison criterion
  // c.value_comp() Returns the comparison criterion for values as a whole (same as key_comp())

  if( coll1.value_comp() == coll2.value_comp() )
    cout << "coll1 and coll2 have the same sorting criterion" << endl;
  else
    cout << "coll1 and coll2 have the different sorting criterion" << endl;
}

coll1 : 1 2 4 5 6 7 
coll2 : 7 6 5 4 2 1 
coll1 : 7 6 5 4 3 2 1 
coll1 and coll2 have the same sorting criterion

note: the class RuntimeCmp provides the general ability to specify, at runtime, the sorting
criterion for any type.

note: that coll1 and coll2 have the same type, which is 'not' the case when passing less<> and
greater<> as sorting criteria. 

If try to use set c<elem, op> then not compile since they are different type.

typedef set<int> LessSet;
typedef set<int, greater<int>> GreaterSet;

int main()
{
  // use default sorting criterion
  LessSet coll1{ 4, 7, 5, 1, 6, 2, 5 }; 
  PRINT_ELEMENTS(coll1, "coll1 : ");

  GreaterSet coll2{ 4, 7, 5, 1, 6, 2, 5 };
  PRINT_ELEMENTS(coll2, "coll2 : ");

  // coll1 = coll2;                       // ERROR
  // coll1.insert(3);
  // PRINT_ELEMENTS(coll2, "coll1 : ");

  //if( coll1.value_comp() == coll2.value_comp() )    // ERROR
  //  cout << "coll1 and coll2 have the same sorting criterion" << endl;
  //else
  //  cout << "coll1 and coll2 have the different sorting criterion" << endl;
}

note: also that the assignment operator assigns the elements and the sorting criterion;
If change coll1 as below and run the program:

  IntSet coll1{ 4, 7 }; 

Then the result:

coll1 : 4 7 
coll2 : 7 6 5 4 2 1 
coll1 : 7 6 5 4 3 2 1 
coll1 and coll2 have the same sorting criterion

That seems useful since if use c<elem, op> approach, copy each item into the other set which has
different sorting criterion.

<example>
1. How to define a sorting criterion at runtime
2. How to compare strings in a case-insensitive way

#include <iostream>
#include <map>
#include <algorithm>
#include <iomanip>      // for setw()

using namespace std;

class RuntimeStringCmp
{
  public:
    enum cmp_mode {normal, nocase};

  private:
    const cmp_mode mode;

    // aux to compare case insensitive
    static bool nocase_compare( char c1, char c2 )
    { return toupper(c1) < toupper(c2); }

  public:
    RuntimeStringCmp( cmp_mode m = normal ) : mode(m) { }
    
    // the comparison. must be const on all args; otherwise type mismatch compile error
    // 
    // The reference p548. 
    // Lexicographical comparison means that sequences are compared element-by-element. For string
    // element is char
    //
    // bool
    // lexicographical_compare (InputIterator1 beg1, InputIterator1 end1, 
    //                          InputIterator2 beg2, InputIterator2 end2, 
    //                          CompFunc op)
    //
    bool operator() ( const string &s1, const string &s2 ) const 
    {
      if( mode == normal )
        return s1 < s2;
      else
        return lexicographical_compare( s1.begin(), s1.end(),
            s2.begin(), s2.end(), nocase_compare );
    }
};

// container type
typedef map<string, string, RuntimeStringCmp> ssmap;

// fill and print container
void fillAndPrint( ssmap &coll );

int main()
{
  ssmap coll1;
  fillAndPrint(coll1);

  RuntimeStringCmp ignorecase(RuntimeStringCmp::nocase);

  ssmap coll2(ignorecase);
  fillAndPrint(coll2);
}

void fillAndPrint( ssmap &coll )
{
  // insert elements in random order
  coll["Deutschland"] = "Germany";
  coll["deutsch"] = "German";
  coll["Haken"] = "snag";
  coll["arbeiten"] = "work";
  coll["Hund"] = "dog";
  coll["gehen"] = "go";
  coll["Unternehmen"] = "enterprise";     // duplicate
  coll["unternehmen"] = "undertake";
  coll["gehen"] = "walk";
  coll["Bestatter"] = "undertaker";

  // prints
  cout.setf( ios::left, ios::adjustfield );

  for( const auto &elem : coll )
    cout << setw(15) << elem.first << " " << elem.second << endl;

  cout << endl;
}

Bestatter       undertaker
Deutschland     Germany
Haken           snag
Hund            dog
Unternehmen     enterprise
arbeiten        work
deutsch         German
gehen           walk
unternehmen     undertake

arbeiten        work
Bestatter       undertaker
deutsch         German
Deutschland     Germany
gehen           walk
Haken           snag
Hund            dog
Unternehmen     undertake

note: The second block changed the order due to 'nocase' criterion. 
note: that the second block has one item 'less' because the uppercase word "Unternehmen" is, from a
case-insensitive point of view, equal to the lowercase word "unternehmen"
note: The signature of operator() must be const.


{iterator-category}
As with all associative container classes, the iterators are 'bidirectional' iterators. Thus, you
can't use them in algorithms that are provided 'only' for random-access iterators, such as algorithms
for sorting or random shuffling.


{use-typedef}
To simplify the declaration of containers, define a type alias:

using SD_multiset = unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*>;
SD_multiset bookstore(42, hasher, eqOp);

This is not supported in GCC 4.6 and use typedef instead.

typedef unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*> SD_multiset;
SD_multiset bookstore(42, hasher, eqOp);
SD_multiset::iterator it;


={============================================================================
*kt_dev_stl_021* associative: set and multi

#include <set>

namespace std {
  template <typename T,
  typename Compare = less<T>,
  typename Allocator = allocator<T> >
    class set;

  template <typename T,
  typename Compare = less<T>,
  typename Allocator = allocator<T> >
    class multiset;
}


{type-requirement}
The elements of a set or a multiset may have any type T that is 'comparable' according to the
sorting criterion. The optional second template argument defines the sorting criterion. If a special
sorting criterion is not passed, the default criterion less is used.


{same-type}
The same type for sets includes sorting criterion and this is ture for comparison and assign.
Comparisons are provided only for containers of the same type. Thus, the elements and the sorting
criterion must have the same types; otherwise, a type error occurs at compile time. For example:

std::set<float> c1;                       // sorting criterion: std::less<>
std::set<float,std::greater<float> > c2;  // std::greater<>
...
if (c1 == c2) { // ERROR: different types
...
}


{special-search-operations}
You should always 'prefer' the optimized versions for sets and multisets to achieve logarithmic
complexity instead of the linear complexity of the general algorithms.

c.count(val)      
Returns the number of elements with value val

c.find(val)       
Returns the position of the 'first' element with value val (or end() if none found)

c.lower_bound(val) 
Returns the first 'position', where val would get inserted (the first element >= val)

c.upper_bound(val) 
Returns the last position, where val would get inserted (the first element > val)

c.equal_range(val) 
Returns a range with all elements with a value equal to val (i.e., the first and last position,
where val would get inserted)

In other words, lower_bound() returns the position of the first element that has the same or a
greater value than the argument, whereas upper_bound() returns the position of the first element
with a greater value. Thus, equal_range() returns the range of elements that have the same value as
the argument.

If lower_bound() or the first value of equal_range() is equal to upper_bound() or the second value
of equal_range(), 'no' elements with the same value exist in the set or multiset. note: The key is
that it is sorted container and return a position to be inserted in sorted order.

note: For containers with single key, find and count do the same but for containers with multiple
key, count has to do more work since still has to count how many elements have the same key. So if
don't need the count, it's best to use find.

<example>
#include <iostream>
#include <set>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  set<int> coll;

  coll.insert(1);
  coll.insert(2);
  // coll.insert(3);
  coll.insert(4);
  coll.insert(5);
  coll.insert(6);

  PRINT_ELEMENTS( coll, "coll: ");

  cout << "lower_bound(3): " << *coll.lower_bound(3) << endl;
  cout << "upper_bound(3): " << *coll.upper_bound(3) << endl;
  cout << "equal_range(3): " << *coll.equal_range(3).first << " "
                             << *coll.equal_range(3).second << endl;

  cout << "lower_bound(5): " << *coll.lower_bound(5) << endl;
  cout << "upper_bound(5): " << *coll.upper_bound(5) << endl;
  cout << "equal_range(5): " << *coll.equal_range(5).first << " "
                             << *coll.equal_range(5).second << endl;
}

coll: 1 2 4 5 6
lower_bound(3): 4
upper_bound(3): 4          // see it is > 3
equal_range(3): 4 4
lower_bound(5): 5
upper_bound(5): 6          // see it is > 5
equal_range(5): 5 6

note: Although these _bound members usually used for multiset, can be used with set.


{no-direct-change-of-value}
Automatic sorting also imposes an important constraint on sets and multisets: You may 'not' change the
value of an element directly, because doing so might compromise the correct order.

Therefore, to modify the value of an element, you must remove the element having the old value and
insert a new element that has the new value. The interface reflects this behavior:

1. Sets and multisets don't provide operations for direct element access. However, maps have some.
2. Indirect access via iterators has the constraint that, from the iterator's point of view, the
element value is 'constant'.


{set-insert-erase}
Again, bidirectional iterator and from an iterator's point of view, all elements are considered
'constant'. Means that iterators are also constant.

As a result, you can't call any 'modifying' algorithm on the elements of a set or a multiset. For
example, you can't call the algorithm-remove, because it "removes" by overwriting "removed" elements
with the following elements. To remove elements in sets and multisets, you can use only 'member'
functions provided by the container.

c.insert(val)
c.insert(pos,val)
c.insert(beg,end)
c.insert(initlist)

c.erase(val)
c.erase(pos)
c.erase(beg,end)

c.clear()

set.insert( ivec.begin(), ivec.end() );
set.insert( { 1, 2, 3, 4, 5} );

<order-of-duplicates>
For multisets, since C++11 it is guaranteed that insert(), emplace(), and erase() preserve the
relative ordering of equivalent elements, and that inserted elements are placed at the end of
existing equivalent values.

<different-return>
The return types of the inserting functions insert() and emplace() differ as follows:

Sets provide the following interface:

pair<iterator,bool>  insert (const value_type& val);
iterator             insert (const_iterator posHint, const value_type& val);

template <typename... Args> pair<iterator, bool> emplace (Args&&... args);
template <typename... Args> iterator emplace_hint (const_iterator posHint, Args&&... args);

Multisets provide the following interface:

iterator insert (const value_type& val);
iterator insert (const_iterator posHint, const value_type& val);

template <typename... Args> iterator emplace (Args&&... args);
template <typename... Args> iterator emplace_hint (const_iterator posHint, Args&&... args);

note: Only for set since insert in multiset always succeed. multisets allow duplicates, whereas sets
do not. Thus, the insertion of an element might fail for a set if it already contains an element
with the same value. Therefore, the return type for a set returns two values by using a pair
structure

1. The member second of the pair structure returns whether the insertion was successful.
2. The member first of the pair structure returns the position of the newly inserted element or the
position of the still existing element.

Why two insert for the same purpose? As said about position in {invalidated-iterator}, used it as a
'hint'. The prime purpose is that you have one insert function that has the same interface for all
container types. Remember sequense containers use insert(pos, val) interface. 

<erase>
std::set<Elem> coll;
...
// remove all elements with passed value and return # of erased elements
coll.erase(value);

// removes the element at iterator position pos or range[beg, eng) and returns the 'following'
// position (returned nothing before C++11)
coll.erase(pos)
coll.erase(beg,end)

If a multiset contains duplicates, you can't use erase() to remove only the first element of these
duplicates. Instead, you can code as follows:

std::multiset<Elem> coll;
...
// remove first element with passed value
std::multiset<Elem>::iterator pos;

pos = coll.find(value);

if (pos != coll.end()) {
   coll.erase(pos);
}


={============================================================================
*kt_dev_stl_022* associative: map and multi

#include <map>

namespace std {
  template <typename Key, typename T,
  typename Compare = less<Key>,
  typename Allocator = allocator<pair<const Key,T> > >
    class map;

  template <typename Key, typename T,
  typename Compare = less<Key>,
  typename Allocator = allocator<pair<const Key,T> > >
    class multimap;
}


{type-requirement}
The elements of a map or a multimap may have any types Key and T that meet the following two
requirements:

1. Both key and value must be copyable or movable.
2. The key must be comparable with the sorting criterion.

note: As with set, key is 'constant'. However, a direct modification of the value of the element is
still possible, provided that the type of the value is not constant.

<key-value-pair> value-type
Thing to remember is the value_type is pair<'const' key_type, mapped_type> so implies key cannot be
changed. This affects the use with algorithms because key is const, only be used with algorithm that
is read-only and the use is limited to search but associative is better in searching so little use
of map with algorithm. In practice, associative can be used as a source or dest in algorithm.

map<string, int>::value_type v3;    // pair< const string, int > 
map<string, int>::key_type v4;      // string
map<string, int>::mapped_type v5;   // int

<what-container-consideration>
1. Searching for elements that have a certain 'value' promotes bad performance.


{element-access}
As for set, maps and multimaps do not provide direct element access, so the usual way to access
elements is via range-based for loops or iterators. An exception to that rule is that maps provide
at() and the subscript operator[] to access elements directly

<associative-array>
The 'both' maps and unordered maps can also be thought of as an associative array, an array whose
index is not an integer value. As a consequence, both containers provide the subscript operator [ ].

However, that the subscript operator does not behave like the usual subscript operator for arrays:
Not having an element for an index is 'not' an error. A new index (or key) is taken as a reason to
create and 'insert' a new map element that has the index as the key. Thus, you can't have an invalid
index.

c[key] 
Inserts an element with key, if it does not yet exist, and returns a reference to the value of the
element with key (only for nonconstant maps)

c.at(key) 
Returns a reference to the value of the element with key (since C++11)

<fetch>
The fecth 'only' works for map but not multimaps since there are multiple matches. Why not set?
since set has only key. Unlike other containers, [] op on map returns mapped_type but dereferencing
of iterator returns value_type. 

Thus, to use this feature, you can't use a value type that has no default constructor. note: that
the 'fundamental' data types provide a default constructor that initializes their values to zero

<insert-can-be-costly-or-mistake>
word_count[word] = 1; 

happens 3 setps but 3) could be extra

1. search key and it is not found
2. insert element using temp pair{ word, 0 }. value init since default ctor is called
3. assign it with 1

note: when accessing map with key which is not exist, cause addition.

This 'also' inserts a new element with key "ottto" and prints its value, which is 0 by default.

std::cout << coll["ottto"];

<out-of-index>
Since C++11, you can, alternatively, use at() to access values of elements while passing the key.

coll.at("vat1") = 0.16;

<example> word counts

string word;
map<string, size_t> word_count;

while( cin >> word )
   ++word_count[word];

// since C++11
for( const auto &w : word_count )
   cout << w.first << " occurs" << w.second << ((w.second>1) ? "times" : " time") << endl;

// before C++11
std::map<std::string,float> coll;
std::map<std::string,float>::iterator pos;

for (pos = coll.begin(); pos != coll.end(); ++pos) {
  std::cout << "key: " << pos->first << "\t" << "value: " << pos->second << std::endl;
}


{special-search-operations}
As for sets and multisets, maps and multimaps provide special search member functions that perform
better because of their internal tree structure

c.count(val) 
Returns the number of elements with 'key' val

c.find(val) 
Returns the position(iterator) of the first element with 'key' val (or end() if none found)

c.lower_bound(val) 
c.upper_bound(val) 
c.equal_range(val) 

<to-find-element-for-value>
You can't use the find() member function to search for an element that has a certain 'value'.
Instead, have to use a general algorithm, such as the find_if() algorithm, or program an explicit
loop. Here is an example of a simple loop:

std::multimap<std::string,float> coll;

// do something with all elements having a certain value
std::multimap<std::string,float>::iterator pos;

for (pos = coll.begin(); pos != coll.end(); ++pos) {
  if (pos->second == value) {
    do_something();
  }
}

<example> algorithm-find_if
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main()
{
  map<float,float> coll = { {1,7}, {2,4}, {3,2}, {4,3}, {5,6}, {6,1}, {7,3} };

  auto posKey = coll.find(3.0);
  if( posKey != coll.end() )
  {
    cout << "key 3.0 found!(" << posKey->first << "," << posKey->second << ")" << endl;
  }

  auto posVal = find_if( coll.cbegin(), coll.cend(),
      [] ( const pair<float,float> &elem ) {
        return elem.second == 3.0;
        } );
  if( posVal != coll.end() )
  {
    cout << "value 3.0 found!(" << posVal->first << "," << posVal->second << ")" << endl;
  }
}

key 3.0 found!(3,2)
value 3.0 found!(4,3)


{map-insert-erase}
As for set, you can't call any modifying algorithm on the elements of a set or a multiset as a
destination since key is constant.

<to-change-key>
To change the key of an element, you have only one choice: You must replace the old element with a
new element that has the same value.

namespace MyLib {
  template <typename Cont>
    inline
    bool replace_key (Cont& c,
        const typename Cont::key_type& old_key,
        const typename Cont::key_type& new_key)
    {
      typename Cont::iterator pos;
      pos = c.find(old_key);
      if (pos != c.end()) {

        // insert new element with value of old element
        c.insert(typename Cont::value_type(new_key, pos->second));

        // remove old element
        c.erase(pos);

        return true;
      }
      else {
        // key not found
        return false;
      }
    }
}

note that maps provide a more convenient way to modify the key of an element. Instead of calling
replace_key(), you can simply write the following:

// insert new element with value of old element
coll["new_key"] = coll["old_key"];

// remove old element
coll.erase("old_key");

c.insert(val)           // note: different from sequence
c.insert(pos,val)
c.insert(beg,end)
c.insert(initlist)

c.erase(val)
c.erase(pos)
c.erase(beg,end)

c.clear()

note: that the elements here are key/value pairs.

std::map<std::string,int> coll;
coll.insert( { word, 1} );           // C++11, most convenient way
coll.insert( std::map<std::string,int>::value_type( word, 1) );
coll.insert( decltype(coll)::value_type( word, 1) );
coll.insert( make_pair(word, 1) );
coll.insert( pair<string, size_t>(word, 1) );

note: As for set, different iterator return for map and multimap.

As for multiset, you can't use erase() to remove only the first element of these duplicates.

std::multimap<std::string,float> coll;

auto pos = coll.find(key);
if (pos != coll.end()) {
  coll.erase(pos);
}

<to-erase-element-for-value> saw-off-the-bench
you can't use the find() member functions to remove elements that have a certain value instead of a
certain key. As shown in <to-find-element-for-value>, can use loop but careful not to saw off the
branch on which you are sitting.

std::map<std::string,float> coll;

for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
  if (pos->second == value) {
    coll.erase(pos);          // RUNTIME ERROR
  }
}

Calling erase() for the element to which you are referring with pos 'invalidates' pos as an iterator
of coll. In fact, calling ++pos results in undefined behavior. note: this invalidates only current
one but not else.

Since C++11:

std::map<std::string,float> coll;

for (auto pos = coll.begin(); pos != coll.end(); ) {
  if (pos->second == value) {
    pos = coll.erase(pos);                // possible only since C++11
  }
  else {
    ++pos;
  }
}

The correct way before C++11:

// remove all elements having a certain value
for (pos = coll.begin(); pos != coll.end(); ) {
  if (pos->second == value) {
    coll.erase(pos++);                    // <key>
  }
  else {
    ++pos;
  }
}

Or can use remove-erase idiom: algorithm-remove. <Q> really since modifying algorithm? No see
<manipulate-associative> for details.

coll.erase( remove( c.begin(), c.end(), value ), c.end() );

<order-of-duplicates> same as multiset
Before C++11, there was no clear guarantee for the order of equivalent elements. C++11 guarantees
that newly inserted elements are inserted at the 'end' of equivalent elements that multisets and
multimaps already contain. In addition, the 'order' of equivalent elements is guaranteed to remain
stable if insert(), emplace(), or erase() is called.

<example> print duplicates in multimap
#include <iostream>
#include <string>
#include <map>

int main()
{
  std::string str = "total";

  std::multimap<std::string, std::string> authors;

  authors.insert( {"Kit, Park", "How to get through"} );
  authors.insert( {"Barth, John", "Sot-Weed Factor"} );
  authors.insert( {"Barth, John", "Lost in the Funhouse"});
  authors.insert( {"Andy, Steve", "Enterprise"});
  authors.insert( {"Barth, John", "A way to success"});

  std::string search_item("Barth, John");

  auto entries = authors.count( search_item );  // num of elements
  std::cout << "entries: " << entries << std::endl;

  auto iter = authors.find( search_item );      // first entry

  while( entries ) {
    // print each title
    std::cout << "count: " << entries << ", title: " << iter->second << std::endl;
    ++iter;
    --entries;
  }

  iter = authors.begin();
  for( iter; iter != authors.end(); ++iter )
    std::cout << "title: " << iter->second << std::endl;
}


entries: 3
count: 3, title: Sot-Weed Factor          // {
count: 2, title: Lost in the Funhouse
count: 1, title: A way to success         // }

title: Enterprise
title: Sot-Weed Factor                    // {
title: Lost in the Funhouse
title: A way to success                   // }
title: How to get through

See that the order of duplicates is maintained.

<example> or use _bound calls
for(auto beg = authors.lower_bound( search_item ), end = authors.upper_bound( search_item );
   beg != end;
   ++beg )
   cout << beg->second << endl;

<example> or use equal_range()
// most direct way and return pair of iter in range [first, off-the-end). Like above, if not found
// return the same.

for( auto pos = authors.equal_range( search_item ); pos.first != pos.second; ++pos.first)
   cout << pos.first->second << endl;

<example> algorithm-max_element with multimap
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main()
{
  multimap<int,string> coll = { {1, "one"}, {2, "two"}, {7, "seven"}, {3, "three"}, 
    {4, "four"}, {5, "five"}, {6, "six"}, {7, "seventh"}, {7, "7th"} };

  auto posKey = coll.find(3);
  if( posKey != coll.end() )
  {
    cout << "key 3 found (" << posKey->first << ", " << posKey->second << ")" << endl;
  }

  auto maxpos = max_element( coll.cbegin(), coll.cend() );
  if( maxpos != coll.end() )
  {
    cout << "max found (" << maxpos->first << ", " << maxpos->second << ")" << endl;
  }

  cout << "{";

  for( auto pos = coll.equal_range(maxpos->first); pos.first != pos.second; ++pos.first )
    cout << pos.first->second << ", ";
  
  cout << "}" << endl;
}

key 3 found (3, three)
max found (7, seventh)
{seven, seventh, 7th, }


={============================================================================
*kt_dev_stl_030* unordered containers

In unordered containers, elements have no defined order. Thus, if you insert three elements, they
might have any order when you 'iterate' over all the elements in the container. If you insert a
fourth element, the order of the elements previously inserted might change due to 'rehasing'. The
only important fact is that a specific element is somewhere in the container. Even when you have two
containers with equal elements inside, the order might be different. Think of it as like a 'bag'.

Unordered containers are typically implemented as a 'hash' table. Thus, internally, the container is
an array of linked lists. But because such a fast perfect hash function is not always possible or
might require that the array consumes a huge amount of memory, the elements in the array are linked
lists so that you can store more than one element at each array position.

<default-hash>
A default hash function is provided for fundamental types and strings, but we would have to declare
our own hash function for other types.

All these unordered container classes have optional template arguments to specify a hash function
and an 'equivalence' criterion. note: why equal? since no order.


{type-requirement}
Use '==' op and hash func.


{performance} amortized complexity
Because the complexity for element access is amortized constant for unordered maps rather than
logarithmic for maps, you should usually prefer unordered maps over maps unless you need the
sorting.

Some complexity definitions in the C++ reference manual are specified as amortized. This means that
the operations in the long term behave as described. However, a single operation may take longer
than specified. For example, if you append elements to a dynamic array, the runtime depends on
whether the array has enough memory for one more element. If there is enough memory, the complexity
is constant because inserting a new last element always takes the same time. However, if there is
not enough memory, the complexity is linear because, depending on the number of elements, you have
to allocate new memory and copy all elements. Reallocations are rather rare, so any sufficiently
long sequence of that operation behaves as if each operation has constant complexity.  Thus, the
complexity of the insertion is 'amortized' constant time.


{duplicate-order}
The only guarantee is that duplicates, which are possible because a multiset is used, are grouped
together in the order of their insertion.

<example>
#include <iostream>
#include <string>
#include <unordered_set>

using namespace std;

int main()
{
  unordered_multiset<string> cities{"Braunschweig", "Hanover", "Frankfurt", "New York",
    "Chicago", "Toronto", "Paris", "Frankfurt"};

  for( const auto &elem : cities )
    cout << elem << ' ';
  
  cout << endl;

  // insert additional elements
  cities.insert({"London", "Munich", "Hanover", "Braunschweig"});

  for( const auto &elem : cities )
    cout << elem << ' ';
  
  cout << endl;
}

Hanover Paris Frankfurt Frankfurt Chicago New York Braunschweig Toronto 
Munich Chicago New York Toronto London Frankfurt Frankfurt Paris Hanover Hanover Braunschweig
Braunschweig 


={============================================================================
*kt_dev_stl_040* adaptor containers

stack, queue, priority_queue

{stack-stl}
The {ref-001} says that STL stack uses deque by default and can change by giving it second
paramenter.

template <class T, class Container = deque<T> > class stack;

std::stack<int,std::vector<int>> st;

<container>
The deque was chosen because, unlike vectors, deques free their memory when elements are removed and
don't have to copy all elements on reallocation (see Section 7.12, page 392, for a discussion of
when to use which container).

<interface>
This interface is somewhat inconvenient, but it performs better if you want only to remove the next
element without processing it. Note that the behavior of top() and pop() is 'undefined' if the stack
contains no elements. The member functions size() and empty() are provided to check whether the
stack contains elements.

<example>
#include <iostream>
#include <stack>

int main()
{
  int n;
  double item;
  std::stack<double> numbers;

  std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    numbers.push(item);
  }

  std::cout << "input is done and you have entered." << std::endl;

  numbers.top() = 99;         // modify top element

  while( !numbers.empty() )
  {
    // access next element. top() returns a reference to the top element in a stack. 
    std::cout << numbers.top() << " : ";
    numbers.pop();            // void pop()
  }

  std::cout << std::endl;
}

$ ./usestack
type in an integer n followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
99 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 

<example> from the reference 12.1.3 <is-implemented-in-terms-of-example>
The standard class stack<> prefers speed over convenience and safety. This is own stack class, which
has the following two advantages:

1. pop() returns the next element.
2. pop() and top() throw exceptions when the stack is empty. Unlike the standard stack class, this
one throws an exception rather than resulting in undefined behavior.

In addition, have skipped the members that are not necessary for the ordinary stack user, such as
the comparison operations.

#include <deque>
#include <exception>

template<typename T>
class Stack {
  private:
    std::deque<T> coll;

  public:
    // exception class for pop and top with empty stack
    class ReadEmptyStack : public std::exception {
      public:
        virtual const char* what() const noexcept {
          return "read empty stack";
        }
    };

    typename std::deque<T>::size_type size() const {
      return coll.size();
    }

    bool empty() const {
      return coll.empty();
    }

    void push(const T& elem) {
      coll.push_back(elem);
    }

    T pop() {
      if( coll.empty() )
        throw ReadEmptyStack();

      T elem( coll.back() );
      coll.pop_back();
      return elem;
    }

    T& top() {
      if( coll.empty() )
        throw ReadEmptyStack();

      return coll.back();
    }
};

#include <iostream>

using namespace std;

int main()
{
  cout << "main: { " << endl;

  try {
    Stack<int> st;

    st.push(1); st.push(2); st.push(3);

    cout << st.pop() << ' ' << st.pop() << ' ';

    st.top() = 77;

    st.push(4); st.push(5);

    st.pop();

    // at this point, there are two elements in the stack and expect a exception.
    cout << st.pop() << ' ';
    cout << st.pop() << endl;
    cout << st.pop() << endl;
  }
  catch( const exception& e ) {
    cerr << "execption: " << e.what() << endl;
  }

  cout << "main: } " << endl;
}

main: { 
2 3 4 77
execption: read empty stack
main: } 


{queue-stl}
Like stack, STL queue uses deque by default and can change by giving it second paramenter. Also see
that it has similar interface as stack:

template <class T, class Container = deque< T> > class queue;

#include <iostream>
#include <queue>

int main()
{
  int n;
  double item;
  std::queue<double> numbers;

  // n to specify the number of items and type iterms after
  std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    numbers.push(item);
  }

  std::cout << "input is done and you have entered." << std::endl;

  while( !numbers.empty() )
  {
    // access next element. front() returns a reference to the first element in a queue. 
    std::cout << numbers.front() << " : ";
    numbers.pop();
  }

  std::cout << std::endl;
}

kit@kit-vb:~/work$ ./usequeue
type in an integer n(loop count) followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 


={============================================================================
*kt_dev_stl_050* iterator

{generalization-of-pointer}
A concept of an object that represents positions of elements in a container. This concept exists.
Objects that fulfill this concept are called iterators.

The following fundamental operations define the behavior of an iterator:

1. Operator * returns the element of the current position. If the elements have members, you can
use operator -> to access those members directly from the iterator.

2. Operator ++ lets the iterator step forward to the next element. 'most' iterators also allow stepping
backward by using operator --.

3. Operators == and != return whether two iterators represent the same position.

4. Operator = assigns an iterator (the position of the element to which it refers).

These operations provide exactly the interface of ordinary pointers in C and C++ when these pointers
are used to iterate over the elements of an ordinary array. The difference is that iterators may be
'smart' pointers. Or iterators are an abstraction to represent a 'position' in a container.

<generic-programming>
The internal 'behavior' of iterators depends on the data structure over which they iterate. For
example iterator of associative containers would do inorder traversal internally. Hence, each
container type supplies its 'own' kind of iterator which knows 'how' to iterate over. As a result,
iterators share the same interface but have different types.


{iterator-categories}
An iterator of a higher category provides all the operations of lower categories.

1. input iterator. read but not write, single-pass, increment only
Must supports ==, !=, ++, *, -> and cannot save the state of an input iterator such as stream. Hence
single pass.

2. output iterator. write but not read, single-pass, increment only
Must supports ++, * and as with input, single pass.

3. forward iterator. read and write, multi-pass, increment only
Can read and write a sequence forward only; ++ operator. unordered_set, unordered_multiset,
unordered_map, and unordered_multimap are "at least" forward iterators

4. bidirectional iterator. read and write, multi-pass, increment and decrement
Can read and write a sequence forward or backword; ++ and -- operator. list, set, multiset, map, and
multimap.

5. random-access iterator. read and write, multi-pass, full iterator arithmetic
Provide constant-time access to any position in the sequence. Supports all the functionality of
bidirectional iterators. In addition, supports:

'relational' operators, addition and subtraction operators on an iterator and an integral value,
subtraction operator when applied to two iterators, and subscript operator.

vector, deque, array, and strings


{begin-end}
begin() and end(). 

<notation>
[begin, end) notation and <off-the-end> iterator which is one past the last. This notation applies
to subrange as well in use of algorithm. A half-open range has two advantages:

1. You have a simple end criterion for loops that iterate over the elements: They simply continue as
long as end() is not reached.

2. It avoids special handling for empty ranges. For empty ranges, begin() is equal to end().

<loop-style>

while(begin != end) {
  *begin  = val;
  ++begin;
}

template< class T>
T* find( T* begin, T* end, const T& value )
{
  while( begin != end && *begin != value ) ++begin;
  return begin;
}

map<string,T> mapT::iterator iter = mapT.begin();
while( iter != mapT.end() )
{
  cout << *iter << ...; // use iter
  ++iter;
}

for( iter = mapT.begin(); iter != mapT.end(); ++iter )
{
  cout << *iter << ...; // use iter
}

<key> The for loop is useful for iterator since you would never need to worry about not increasing
the iterator with it.

<iterator-category-and-generic-programming>
Iterator has different categories according to the abilities of iterator and this affect how to
code. To write generic code that is as independent of the container type as possible, you should not
use special operations for random-access iterators.

for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
}

for (auto pos = coll.begin(); pos < coll.end(); ++pos) {
}

The second loop does not work with lists, sets, and maps. Why? Because operator < is provided only
for 'random' access iterators.

<pre-vs-post>
The preincrement operator (++pos) might have 'better' performance than the postincrement operator.
The latter internally involves a temporary object because it must return the old position of the
iterator.

<cbegin-cend>
Why cbegin and cend?

for (list<char>::const_iterator pos = coll.begin(); pos != coll.end(); ++pos) {
  cout << *pos <<  ;
}

for (auto pos = coll.begin(); pos != coll.end(); ++pos) {
  cout << *pos <<  ;
}

By using auto, the loop is robust for such code modifications as changing the type of the container.
However, the drawback is that the iterator loses its constness since begin() returns non-const
iterator. Hence cbegin and cend.

for (auto pos = coll.cbegin(); pos != coll.cend(); ++pos) {
  cout << *pos <<  ;
}


{range-for}
VC 2012 supports but g++ (GCC) 4.4.5 don't. This 'range based for' is supported from 4.6

This shows two points:
1. range for caches begin and end so has risk of using 'invalidated' iterators.
2. shall use const & in for loop statement to avoid unnecessary copy.

for( const T &r : vec )
   r *= 2;

is interpreted as:

for( auto beg = vec.begin(), end = vec.end(); beg != end; ++beg )
{
  const T &r = *beg;
  r *= 2;
}


template <typename T>
void PRINT_ELEMENTS( const T& coll, const string optstr="" )
{
  cout << optstr;

  for( const auto &elem : coll )
    cout << elem << " ";

  cout << endl;
}


={============================================================================
*kt_dev_stl_051* iterator adaptors

These are several predefined special iterators, called iterator adaptors: 
insert, stream, reverse, and move iterators

{insert} inserter
Insert iterators, or inserters, are used to let algorithms operate in 'insert' mode rather than in
overwrite mode. (for overwrite example, algorithms using multiple range) They fall under the
category of 'output' iterators, which are able to write/assign values only 'while' iterating
forward.

Three different insert iterators: at the front, at the end, or at a given position.

The inserters calls a container operation to add and must use front_inserter only if the container
has push_front and use back_inserter only if it has push_back. These are back_inserter,
front_inserter, inserter which bind iterator to container operations.

<why-useful>
1. There is 'no' need to increase or decrease iter but still need to care about underlying
container. note: Seems less convincing.
2. Less 'generic' since need to know about element type. However, it's convenient. note: Can use
usual interator interface in code while doing insertion. How? increment operator is no-op as i the
reference 9.4.2.

<inserter>
Calls insert(pos, val) member and insert elements directly in front of the position that is passed
as the argument of its initialization and as the start to insert. For all containers except array
and forward_list.

Passing a position(iterator) to insert doesn't sound useful? So for associative and unordered
containers, the position is taken as a 'hint' to start the search for the correct position. However,
containers are free to ignore it.

<example> algorithm-copy
note: copy(beg, end, a2) return points just past the last element copied into a2

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <list>
#include <deque>

using namespace std;

template<typename T>
void PRINT_ELEMENTS( T& coll, const std::string& mesg = "" )
{
  cout << mesg << ": {";

  for( const auto &elem : coll )
    cout << elem << ",";

  cout << "}" << endl;
}

int main()
{
  list<int> coll1{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  // copy the elements of coll1 into coll2 by appending them
  vector<int> coll2;
  copy (coll1.cbegin(), coll1.cend(),  // source
      back_inserter(coll2));           // destination

  PRINT_ELEMENTS( coll2, "vector" );

  // copy the elements of coll1 into coll3 by inserting them at the front
  // note: reverses the order of the elements
  deque<int> coll3;
  copy (coll1.cbegin(), coll1.cend(),  // source
      front_inserter(coll3));          // destination

  PRINT_ELEMENTS( coll3, "deque " );

  // copy elements of coll1 into coll4
  // note: 'only' inserter that works for 'associative' collections
  set<int> coll4;
  copy (coll1.cbegin(), coll1.cend(), // source
      inserter(coll4,coll4.begin())); // destination

  PRINT_ELEMENTS( coll4, "set   " );

  // note: Q: what order of output do you expect?
  vector<int> coll5;
  copy (coll1.cbegin(), coll1.cend(),  // source
      inserter(coll5, coll5.begin())); // destination

  PRINT_ELEMENTS( coll5, "vector" );
}

vector: {1,2,3,4,5,6,7,8,9,}
deque : {9,8,7,6,5,4,3,2,1,}
set   : {1,2,3,4,5,6,7,8,9,}
vector: {1,2,3,4,5,6,7,8,9,}

note: see that uses 'collection' in inserter template as a argument without type.

<why-the-order-maintained-in-inserter>
The general inserter does followings; update and increase pos.

pos = container.insert(pos,value);
++pos;

<example>
#include <iostream>
#include <list>
#include <iterator>

using namespace std;

template<typename T>
void PRINT_ELEMENTS( T& coll, const std::string& mesg = "" )
{
  cout << mesg << ": {";

  for( const auto &elem : coll )
    cout << elem << ",";

  cout << "}" << endl;
}

int main()
{
  list<int> coll1, coll2;

  // note: inconvenient way to create inserter
  insert_iterator<list<int>> iter( coll1, coll1.begin() );

  // use usual iterator interface which has the same result
  // *iter = 1; iter++;
  // *iter = 2; iter++;
  // *iter = 3; iter++;

  *iter = 1; *iter = 2; *iter = 3; *iter = 44; *iter = 55;
  PRINT_ELEMENTS( coll1, "list1: " );

  coll2.push_back(1); coll2.push_back(2); coll2.push_back(3);
  coll2.push_back(44); coll2.push_back(55);
  PRINT_ELEMENTS( coll2, "list2: " );

  list<int> coll3;
  // note: convenient way to create inserter
  copy( coll1.begin(), coll1.end(), inserter( coll3, coll3.begin()) );
  PRINT_ELEMENTS( coll3, "list3: " );

  copy( coll1.begin(), coll1.end(), inserter( coll3, ++coll3.begin()) );
  PRINT_ELEMENTS( coll3, "list3: " );
}

list1: : {1,2,3,44,55,}
list2: : {1,2,3,44,55,}
list3: : {1,2,3,44,55,}
list3: : {1,1,2,3,44,55,2,3,44,55,}

<back-inserter>
Calls push_back so back inserters can be used 'only' for containers that provide push_back() as a
member function: these containers are vector, deque, list, and strings.

<example>
#include <iostream>
#include <vector>
#include <iterator>

using namespace std;

template<typename T>
void PRINT_ELEMENTS( T& coll, const std::string& mesg = "" )
{
  cout << mesg << ": {";

  for( const auto &elem : coll )
    cout << elem << ",";

  cout << "}" << endl;
}

int main()
{
  vector<int> coll;

  back_insert_iterator<vector<int>> iter( coll );

  // use usual iterator interface
  *iter = 1; iter++;
  *iter = 2; iter++;
  *iter = 3; iter++;
  *iter = 44; iter++;
  *iter = 45; iter++;

  // *iter = 1; *iter = 2; *iter = 3; *iter = 44; *iter = 55;
  PRINT_ELEMENTS( coll, "coll: " );

  coll.reserve( 2*coll.size() );
  copy( coll.begin(), coll.end(), back_inserter(coll) );
  PRINT_ELEMENTS( coll, "coll: " );
}

note: that you 'must' not forget to reserve enough space before calling copy(). The reason is that
the back inserter inserts elements, which might cause relocation; invalidate all other iterators
referring to the same vector. Thus, the algorithm invalidates the passed source iterators while
running.

<front-inserter>
Calls push_front so back inserters can be used 'only' for containers that provide push_front() as a
member function: these containers are deque, list, and forward_list.


{stream-iterator}
A stream is an object that represent I/O channel. Treat stream as a sequence of elements of a
specified 'type' that should have input/output op defined(>>/<<) and bind iterator to a stream. In
other words, see a stream as a sequence of user provided speficified type. Why need this? To use
stream with algorithms.

// example which read the stdin into a vector

string word;
while( cin >> word )
  // cout << word << endl;
  vec.push_back(word);

// here postfix advances the stream by reading the next value but returns old value

istream_iterator<string> in_iter(cin), eof;
while( in_iter != eof )
  vec.push_back(*in_iter++);

or

istream_iterator<string> in_iter(cin), eof;
vector<string> vec(in_iter, eof);                         // ctor use iter range


// for an algo use:

// template <class InputIterator, class T>
//   T accumulate (InputIterator first, InputIterator last, T init)

#include <numeric>

istream_iterator<int> in_iter(cin), eof;
cout << std::accumulate(in_iter, eof, 0) << endl;


// example for ostream. seems useful

// template <class T, class charT=char, class traits=char_traits< charT>>
//  class ostream_iterator;
//
// ostream_iterator (ostream_type& s, const char_type* delimiter);

std::ostream_iterator<int> out_iter( std::cout, " " );
for( auto e : vec )
  *out_iter++ = e;
cout << endl;

or

copy( vec.begin(), vec.end(), out_iter );
cout << endl;


// example for file

ifstream in("afile");
istream_iterator<string> str_it(in);


<example> how stream-iterator can make code neat
int main()
{
  Sales_item total;

  // read the first transaction
  if( std::cin >> total )
  {
    Sales_item trans;   // variable to hold the running sum

    while(std::cin >> trans )
    {
      // if we're still processing the same book, then update the running total
      if( total.isbn() == trans.isbn() )
        total += trans;
      // print results for the previous book
      else
      {
        std::cout << total << std::endl;
        total = trans;
      }
    }
    // print the last transaction
    std::cout << total << std::endl;
  } 
  // no input and return failure
  else
  {
    std::cerr << "No data?" << std::endl;
    return -1;
  }

  return 0;
}


This can be re-written as:

istream_iterator<Sales_item> item_iter(cin), eof;
ostream_iterator<Sales_item> out_iter(cout, "\n");

// store first transaction in sum and read the next record
Sales_item sum = *item_iter++;

while( item_iter != eof )
{
  if( item_iter->isbn() == sum.isbn() )
    sum += *item_iter++;   // add it to sum and read the next record
  else
  {
    out_iter = sum;
    sum = *item_iter++;    // read the next record
  }
}

out_iter = sum;

<example> algorithm-unique_copy
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  vector<string> coll;

  // read all words from stdin
  // istream_iterator<string>() is "end of stream" iterator
  copy( istream_iterator<string>(cin), istream_iterator<string>(),
      back_inserter(coll));

  cout << "===========" << endl;

  sort( coll.begin(), coll.end() );

  // print all without duplicates
  unique_copy( coll.begin(), coll.end(), ostream_iterator<string>(cout, "\n"));
}


{reverse-iterator}
Allow algorithms operate backward by switching the call of an increment operator internally into a
call of the decrement operator, and vice versa. The advantage of using reverse iterators is that all
algorithms are able to operate in the opposite direction without special code.

sort( vec.begin(), vec.end() );     // sort in normal, ascending order
sort( vec.rbegin(), vec.rend() );   // sort in reverse, decending order

   .cbegin()              .cend()
  [ ] [ ] [ ] [ ] ... [ ]
.crend()               .crbegin() 

All containers with 'bidirectional' iterators or random-access iterators can create reverse
interator. That is all containers as well as string except forward_list and unordered, supports
ability to use reverse iterators.

note: Primers read "The containers, aside from forward_list, all have reverse iterators". 

So container shall support ++/-- operator and rbegin/rend/crbegin/crend().

See *kt_dev_quiz_004* and *kt_dev_quiz_005* for more use cases

<example>
#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

void reverse_cpp_two(char* str)
{
  if(!str) return;
  string istr(str);

  string::reverse_iterator it = istr.rbegin();
  while( it != istr.rend() )
  {
    cout << *it << endl;
    ++it;
  }
}

int main () {
  cout << "=====" << endl;
  reverse_cpp_two("KEITEE PARK");
  return 0;
}

<example>
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  vector<int> coll;

  for(int i = 1; i <= 9; ++i )
    coll.push_back(i);

  // print all without duplicates
  copy( coll.crbegin(), coll.crend(), ostream_iterator<int>(cout, " "));

  cout << endl;
}

<difference-between-reverse-and-other-iterators> conversion between them
As the sort example shown above, then use reverse iterator as a range, don't need to care about this
difference but see the difference when use it as a single iterator.

<example> Primers p408

string line("FIRST,MIDDLE,LAST");

// print the first word, "FIRST"
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma ) << endl;

// print the last word, "LAST"?
auto rcomma = find(line.crbegin(), line.crend(), ',');
cout << string(line.crbegin(), rcomma ) << endl;

The result is "TSAL" since iterator goes backward and means [crbegin(), rcomma ). To get the
expected result, shall use instead [rcomma.base(), cend() ) which converts reverse iterator to
normal interator.

cout << string(rcomma.base(), line.cend() ) << endl;

   rcomma.base()   
           cend()
 |       |
 , L A S T
 |       |
 rcomma  crbegin()

There is the difference when converting reverse to and from since the resulting iterator does 'not'
refer to the same element. This is a consequence of the fact that ranges are half open.

Thus, rbegin() is simply:
container::reverse_iterator(end())

and rend() is simply:
container::reverse_iterator(begin())

<example> shows the difference and to convert interators
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
  // create list with elements from 1 to 9
  vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  // find position of element with value 5
  vector<int>::const_iterator pos;

  pos = find (coll.cbegin(), coll.cend(), 5);

  // print value to which iterator pos refers
  cout << "pos : " << *pos << endl;

  // convert iterator to reverse iterator rpos
  vector<int>::const_reverse_iterator rpos(pos);

  // print value to which reverse iterator rpos refers
  cout << "rpos: " << *rpos << endl;
}

pos : 5
rpos: 4

<example> when use it as a range
#include <iostream>
#include <deque>
#include <algorithm>

using namespace std;

void print(int elem)
{
  cout << elem << ' ';
}

int main()
{
  // create deque with elements from 1 to 9
  deque<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

  // find position of element with value 2
  deque<int>::const_iterator pos1;
  pos1 = find (coll.cbegin(), coll.cend(), 2);

  // find position of element with value 7
  deque<int>::const_iterator pos2;
  pos2 = find (coll.cbegin(), coll.cend(), 7);

  // print all elements in range [pos1,pos2)
  for_each (pos1, pos2, print);
  cout << endl;

  // convert iterators to reverse iterators
  deque<int>::const_reverse_iterator rpos1(pos1);
  deque<int>::const_reverse_iterator rpos2(pos2);

  // print all elements in range [pos1,pos2) in reverse order
  for_each (rpos2, rpos1, print); 
  cout << endl;
}

2 3 4 5 6 
6 5 4 3 2 


={============================================================================
*kt_dev_stl_052* iterator: subscript

The operator[] has different sementics in sequential and associative.

{return-reference}
s[n]  return a reference to the element at position n in string.
v[n]  return a reference to the element at position n in vector.


{for-sequential}
The index must be 'in' range as C array does. The operator does 'not' check whether the index is in
range and the program must ensure that the index is valid. To ensure that can use at() that throws
out_of_range if the index is invalid.

A safer way to access a character is to use the at() member function. However, such a check costs
runtime, so the check is 'not' provided for the usual accessing of characters of a string.


{for-associative}
As explained in {associative-array}, since not having an element for an index is not an error, so
insert a new element. Also use at() not to insert element accidentally in which throw out_of_range.


={============================================================================
*kt_dev_stl_053* iterator: invalid iterator, insert, remove


{erase}

<list>
list.erase( start, end );

<set>
m/set.erase(val);             // return # of erased elements
m/set.erase(pos);             // note 2
m/set.erase(beg,end);

note 1: why cannot use modifying algorithm on set. copied again from set

Again, bidirectional iterator and from an iterator's point of view, all elements are considered
'constant'. Means that iterators are also constant.

As a result, you can't call any 'modifying' algorithm on the elements of a set or a multiset. For
example, you can't call the algorithm-remove, because it "removes" by overwriting "removed" elements
with the following elements. To remove elements in sets and multisets, you can use only 'member'
functions provided by the container.

note 2:
These removes the element at iterator position pos or range[beg, eng) and returns the 'following'
position. Returned nothing before C++11.


{invalidated-iterator} from Primers p353.
After add an element:

Operations that add or remove elements from a container can invalidate pointers, references, or
iterator to container elements. Using an invalidated pointer is the same kind of problems as using
an unitialized pointer. <key> this is only for sequential containers that use 'contiguous' memory.

1. Iterators, pointers, and references to a 'vector' or 'string' are invalid if the container was
reallocated. If no rellocation happens, indirect references before the insertion remain valid; those
after insertion are invalid.

2. Same for 'deque' if we add elements anywhere but at the front or back. If we add at the front or
back, iterators are invalidated but references and pointers to exisiting elements are not.

3. Iterators, pointers, and references to 'list' or 'forward_list' remain valid.

After remove an element:

1. All other iterators, references, and pointers to a 'vector' or 'string' remain valid 'before' the
removal point. The off-the-end iterator is always invalidated.

2. All others to a 'deque' are invalidated if the removed elements are anywhere but the front or
back.

3. All others to 'list' or 'forward_list' remains valid.

note: here iterators includes off-the-end iterator.


{insert}
All predefined containers except array and forward_list have such an insert() member function. There
are overloads and each containers have some differences.

<insert-interface>
The difference is that all sequence containers except array has only insert(pos, val) but
associatives have insert(val) and insert(pos, val). That's why associatives has two versions for the
same purpose.

<position>
The text reads "c.insert(pos, elem): inserts a copy of elem 'before' iterator position pos and returns
the position of the new element"

This text says rather 'imaginary' pos by saying before.

   [ pos-1 ] [ pos ] [pos+1]

In my words, insert() member insert value at pos and return pos by making a space at pos. Updated.
Better to think 'before' in the sense that insert(pos,val) invalidate pos and invalidate pos after
insertion position. So insert before pos.


<position-hint>
Passing a position(iterator) to insert doesn't sound useful? So for associative and unordered
containers, the position is taken as a 'hint' to start the search for the correct position. However,
containers are free to ignore it.

note: This is why should be careful about using range for.

<example>
#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
  std::vector<int> veci{1,2,3,4};
  std::vector<int>::iterator it;

  it = find(veci.begin(), veci.end(), 2);
  if( it != veci.end())
  {
    it = veci.insert( it, 7 );
    it = veci.insert( it, 6 );
    it = veci.insert( it, 5 );

    // <Q> This seems okay since inserting element at the same pos,2? what will happen?
    // veci.insert( it, 7 );
    // veci.insert( it, 6 );
    // veci.insert( it, 5 );
  }

  it = veci.begin();
  while( it != veci.end() )
  {
    std::cout << *it << ":";
    it++;
  }
  std::cout << std::endl;
}

1:5:6:7:2:3:4:                   // note: see the order of 5:6:7:

<A> Core dumped since insert element in the middle and invalidate pos "it". However, set uses
insert(elem) without pos.

<example> use list initializer from C++11

// insert additional values:
unordered_multiset<string> cities;
cities.insert( {"London", "Munich", "Hanover", "Braunschweig"} );

<example> see end() call
vec<int> veci;
veci.push_back(1); .. to (3); // [1,2,3,E)
veci.insert( veci.end(), 4 );

Q: What's the output if print veci?  A: 1 2 3 4

<example>
list<string> lst;
auto iter = lst.begin();

while( cin >> word )
   iter = lst.insert( iter, word ); or lst.push_front(word);

[three, two, one]

while(...)
   lst.insert(iter, word);

[one, two, three]                       // see no iter update

note: see the different output. why? since iter remains the same(off-the-end) in list and works
fine. However, this approach will creates core dump in case of vector because addition and deletion
will invalidate iterator of vector.

<insert-loop>
So the recommened is to refresh on each trip through the loop. 

// This is to remove even-valued elements and insert a duplicate of odd-valued elements.
vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
auto iter = vi.begin();

while( iter != vi.end() )              // note: keep calling end()
{
  if( *iter % 2 )                      // when it is odd 
  {
    iter = vi.insert(iter, *iter);     // note: updates iter
    iter += 2;
  }
  else
    iter = vi.erase(iter);
}

note: Two thing from ESTL09 to clarify:
1. said that invalidated iterators also apply to associative containers. Yes, see erase for map
which invalidate iterators for erased elements.
2. said that erase()/insert() returns void for associative containers. not any more since C++11 and
see map cases.

Primers p344. Under the new standard, the version of insert that take a count or range return
iterator to the 'first' element that was inserted. This seems to be the same for erase() which
returns 'after' the one deleted.


{manipulate-containers} algorithm-remove
In practice, there are some limits and workarounds you should know. Many of these have to do with
modifications. These aspects are surprising and show the 'price' of the STL concept that separates
containers and algorithms with great flexibility.

<example>
#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  list<int> coll;

  // insert elements from 6 to 1 and 1 to 6
  for(int i = 1; i <= 6; ++i )
  {
    coll.push_back(i);
    coll.push_front(i);
  }

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  // remove all with value 3
  remove( coll.begin(), coll.end(), 3);

  // print 
  cout << "post: " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

pre : 12 elements
6 5 4 3 2 1 1 2 3 4 5 6 
post: 12 elements
6 5 4 2 1 1 2 4 5 6 5 6 

When runs algorithm-remove, it will reorder like:

<elemenets not matched> <elements matched>
                       |
                        += return the past of the last element

<key> Thus, remove() did not change the number of elements in the collection for which it was
called. Revised the code to actually remove by calling 'member' function. 

note: coll.remove() is only for list and forward_list since no such member function for others.

Why don't algorithms call erase() by themselves? This question highlights the price of the
flexibility of the STL. The STL separates data structures and algorithms by using iterators as the
interface. However, iterators are an abstraction to represent a 'position' in a container. In
general, iterators do not know their containers. Thus, the algorithms, which use the iterators to
access the elements of the container, can't call any member function for it.

#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  list<int> coll;

  // insert elements from 6 to 1 and 1 to 6
  for(int i = 1; i <= 6; ++i )
  {
    coll.push_back(i);
    coll.push_front(i);
  }

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  // remove all with value 3. algorithm-remove
  // note: get the logical end
  list<int>::iterator end = remove( coll.begin(), coll.end(), 3);

  // print 
  cout << "post: " << coll.size() << " elements" << endl;
  copy( coll.begin(), end, ostream_iterator<int>(cout, " "));
  cout << endl;

  // print number of removed elements
  // algorithm-distance
  cout << "number of removed elements: " << distance( end, coll.end()) << endl;

  // note: actually remove "removed" elements
  coll.erase( end, coll.end() );

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

<manipulate-associative>
Manipulation algorithms-those that remove elements and those that reorder or modify elements-have
another 'problem' when you try to use them with associative or unordered containers:

Associative and unordered containers can't be used as a destination. The reason is simple:

If they would work for associative or unordered containers, modifying algorithms could change the
value or position of elements, thereby violating the order maintained by the container

In order to maintain internal order, every iterator for an associative and unordered container is
declared as an iterator for a 'constant' value or key.

<example>
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  set<int> coll{1,2,3,4,5,6,7,8,9};

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  remove( coll.begin(), coll.end(), 3 );        // note: 17

  // print 
  cout << "post: " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

In file included from /usr/include/c++/4.6/algorithm:63:0,
                 from sam01.cpp:3:
/usr/include/c++/4.6/bits/stl_algo.h: In function '_FIter std::remove(_FIter, _FIter, const _Tp&) 
   [with _FIter = std::_Rb_tree_const_iterator<int>, _Tp = int]':
sam01.cpp:17:39:   instantiated from here
/usr/include/c++/4.6/bits/stl_algo.h:1106:13: error: assignment of read-only location 
   '__result.std::_Rb_tree_const_iterator<_Tp>::operator* [with _Tp = int, std::_Rb_tree_const_iterator<_Tp>::reference = const int&]()'

<key> How does one remove elements in associative containers? The answer is simple: Call their
member functions

<example>
#include <iostream>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

int main()
{
  set<int> coll{1,2,3,4,5,6,7,8,9};

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;

  int num = coll.erase(3);

  // print number of removed elements
  cout << "number of removed elements: " << num << endl;

  // print 
  cout << "pre : " << coll.size() << " elements" << endl;
  copy( coll.cbegin(), coll.cend(), ostream_iterator<int>(cout, " "));
  cout << endl;
}

pre : 9 elements
1 2 3 4 5 6 7 8 9 
number of removed elements: 1
pre : 8 elements
1 2 4 5 6 7 8 9 

<algorithm-or-member-function>
Even if you are able to use an algorithm, it might be a bad idea to do so. A container might have
member functions that provide much better performance.

Calling remove(val) for elements of a 'list' is a good example of this. If you call remove() for
elements of a list, the algorithm doesn't know that it is operating on a list and thus does what it
does for any container: reorder the elements by changing their values. If, for example, the
algorithm removes the first element, all the following elements are assigned to their previous
elements. This behavior contradicts the main advantage of lists: the ability to insert, move, and
remove elements by modifying the links instead of the values.

note: remove family is only for list and forward_list and erase for others.

To avoid bad performance, lists provide special member functions for all manipulating algorithms.
You should 'always' prefer them. 

The problem is, you have to know that a member function exists that has significantly better
performance for a certain container. You have to change the code when you switch to another
container type.

<container-specific>
The list and forward_list define several algorithms as memebers because can use generic ones with
list but at a cost in performance. These container spscific ones are merge, sort, unique, remove and
reserse. The member version should be used in preference to the generic for list and forward_list.

Also, a important difference between the list-specific and the generic is that the list version
change the underlying containers.

// algorithm-remove
int main()
{
  list<int> coll;

  // insert elements from 6 to 1 and 1 to 6
  for (int i=1; i<=6; ++i) {
    coll.push_front(i);
    coll.push_back(i);
  }

  // remove all elements with value 3 (poor performance)
  coll.erase (remove(coll.begin(),coll.end(), 3), coll.end());

  // remove(val) 'all' elements with value 4 (good performance)
  coll.remove (4);
}


={============================================================================
*kt_dev_stl_054* iterator: external and internal

Was asked in phone screening. 

http://gafter.blogspot.co.uk/2007/07/internal-versus-external-iterators.html

In the "Gang Of Four" Patterns book's discussion of the Iterator pattern, we read (page 260):

Who controls the iteration? A fundamental issue is deciding which party controls the iteration, the
iterator or the 'client' that uses the iterator. When the client controls the iteration, the iterator
is called an 'external' iterator (C++ and Java), and when the iterator controls it, the iterator is an
internal iterator (Lisp and functional languages). Clients that use an external iterator must
advance the traversal and request the next element explicitly from the iterator. In contrast, the
client hands an internal iterator an operation to perform, and the iterator applies that operation
to every element in the aggregate.

'External' iterators are more 'flexible' than internal iterators. It's easy to compare two collections
for equality with an external iterator, for example, but it's practically impossible with internal
iterators. Internal iterators are especially weak in a language like C++ that does not provide
anonymous functions, closures, or continuations like Smalltalk and CLOS. But on the other hand,
internal iterators are easier to use, because they define the iteration logic for you.


={============================================================================
*kt_dev_stl_060* algorithm

Algorithms are not member functions of the container classes and do not work directly on a
container. All in all, this concept reduces the amount of code and increases the power and the
flexibility of the library. 

Operates in terms of iterators and container independent but element type dependent; means that do
not use container's operations (don't add/remove items but write/move items) but use operations on
element such as '==', '<', or '+'. 

This is not an object-oriented programming paradigm; it is a generic functional programming
paradigm. However, this concept also has its price: 

First, the usage is not intuitive. 

Second, some combinations of data structures and algorithms might not work. Even worse, a
combination of a container type and an algorithm might be possible but not useful (for example, it
may lead to bad performance).

<key>
Thus, it is important to learn the 'concepts' and the 'pitfalls' of the STL to benefit from it
without abusing it.

<example> algorighm: max_element, min_element, find, sort, reverse
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
  vector<int> coll{2,5,4,1,6,3};

  // find and print min and max. 
  // If there is more than one minimum element, the algorithm returns the first.
  auto minpos = min_element( coll.cbegin(), coll.cend() );
  cout << "min: " << *minpos << endl;

  auto maxpos = max_element( coll.cbegin(), coll.cend() );
  cout << "max: " << *maxpos << endl;

  // sort
  sort( coll.begin(), coll.end() );

  // find the first with value 3
  // no cbegin since used in reverse() later. otherwise, compile error in reverse
  auto pos3 = find( coll.begin(), coll.end(), 3 );

  // reverse the order of the found and all following elements
  reverse( pos3, coll.end() );

  for( const auto &elem : coll )
    cout << elem << ' ';
  
  cout << endl;
}

min: 1
max: 6
1 2 6 5 4 3 


{algorithm-category}
There is architecture or the unifying principles that categorise 100+ algorithms: according to what
do on container or required arguments. Be careful since algorithms have assumtions and use right
iter for a algo according to iter category since compilers will 'not' complain.

According to parameter patterns:

alg( beg, end, other args );
alg( beg, end, dest, other args );     // assumes dest is big enough as with range one to 'overwrite'
alg( beg, end, beg2, other args );     // assumes beg2 is big enough as with range one
alg( beg, end, beg2, end2, other args );

<example> algorithm-accumulate
The third argument determines which addition operator is used and the type of return. Seems clever.

int sum = accumulate( vec.cbegin(), vec.cend(), 0 );
string sum = accumulate( vec.cbegin(), vec.cend(), string(""));


{assumption-on-ranges}
<single-range>
To be able to handle subsets of container elements, you pass the beginning and the end of the range
as two separate arguments rather than the whole collection. This interface is flexible but dangerous.

The caller must ensure that the first and second arguments define a valid range. Otherwise, the
behavior is 'undefined', and endless loops or forbidden memory access may result. This means that it
is up to the programmer to ensure that.

Two things about 'valid' range when [beg, end) use with algorithm:

1. The range do not include end.
2. The beg must come 'first' in order. Othewise, it is not valid range and 'undefined'.
3. The range shall exist.

// fill_n( dest, size, value ) and assumes that vec is 10 size at least. so if there is no 10
// elements before calling fill_n then undefined.
vector<int> vec;
fill_n( vec.begin(), 10, 0 );

<multiple-range>
Assumption on the second range is it as big as the first since the number of elements of the second
is 'deduced' from the first range. If not, undefined. For example, copy algorithm 'overwrite' rather
then 'insert'.

This is for only sequence containers with algorithms because associative and unordered containers
cannot be used as a destination for overwriting algorithms.

# reads

equal( one.cbegin(), one.cend(), two.cbegin() );   // assumes two >= one

# write, 'destination'

// coll2 must have enough room to copy
copy (coll1.cbegin(), coll1.cend(), coll2.begin()); // destination


{copy-version} algorithm-replace, algorithm-reverse
Independent-between-sequences/containers. The element types need not be the exactly same as long as
can use element operators or compatible between them. This is also an example of copying version in
algorithm.

replace( ilst.begin(), ilst.end(), 0, 42 );
// replace any element with 0 with 42

replace_copy( ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42 );
// to leave the original sequence unchanged. in this case, copy list to vector.

// copy version
reverse( beg, end );
reverse_copy( beg, end, dest );


{if-version} algorithm-find
Algorithm that takes an element value typically have a second named version that takes a predicate
in place of the value. Compared to overloaded version.

// if version
// If there is a match, returns an iterator to the first element and if not, return end iterator.
find( beg, end, val );
find_if( beg, end, pred );

// overloaded version
unique( beg, end );
uniqie( beg, end, comp );


={============================================================================
*kt_dev_stl_061* algorithm: predicate

{why-aux-functions-like-predicate}
To increase their flexibility and power, several algorithms allow the passing of user-defined
auxiliary functions. This is 'callables' to change a default operator of algorithms. For example,

*. sort() uses "<" on element to sort but want to use different order
*. want to use user defined type that don't support "<"

<example> algorithm-for_each
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void print(int elem)
{ cout << elem << ' '; }

int main()
{
  vector<int> coll{1,2,3,4,5,6,7,8,9};

  for_each( coll.cbegin(), coll.cend(), print );
  cout << endl;
}

<example> algorithm-transform
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int square(int value)
{ return value*value; }

int main()
{
  set<int> coll1{1,2,3,4,5,6,7,8,9};
  vector<int> coll2;

  PRINT_ELEMENTS(coll1, "initialized: ");

  transform( coll1.cbegin(), coll1.cend(), back_inserter(coll2), square );

  PRINT_ELEMENTS(coll2, "squared    : ");
}


{predicate}
A predicate is a special kind of auxiliary function. Predicates return a 'boolean' value and are
often used to specify a sorting or a search criterion. Depending on their purpose, predicates are
unary or binary.

Not every unary or binary function that returns a boolean value is a valid predicate. In addition,
the STL requires that predicates be stateless, meaning that they should always yield the same result
for the same value.

<example> algorithm-sort

template< class RandomIt>
void sort( RandomIt first, RandomIt last );

template< class RandomIt, class Compare>
void sort( RandomIt first, RandomIt last, Compare comp );


<example> algorithm-stable-sort, algorithm-unique
sort by length and also want to keep the order among the 'equal' elements.

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

// binary predicate and sort by size
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

// sort by alphabet and remove dups. unique() also move elements.
void elimDups(vector<string> &words)
{
  // sort( words.begin(), words.end(), isShorter );
  sort( words.begin(), words.end() );

  PRINT_ELEMENTS(words, "sorted       : ");

  auto end_unique = unique( words.begin(), words.end() );

  words.erase( end_unique, words.end() );
}

int main()
{
  vector<string> coll{"over", "quick", "red", "fox", "jumps", "red", "the", "slow", "turtle", "the"};

  PRINT_ELEMENTS(coll, "initialized  : ");

  elimDups(coll);

  PRINT_ELEMENTS(coll, "eliminated   : ");

  stable_sort( coll.begin(), coll.end(), isShorter );

  PRINT_ELEMENTS(coll, "stable sorted: ");
}

initialized  : over quick red fox jumps red the slow turtle the 
sorted       : fox jumps over quick red red slow the the turtle      // sorted by alphabet
eliminated   : fox jumps over quick red slow the turtle 
stable sorted: fox red the over slow jumps quick turtle              // sorted by size

<example> algorithm-find-if
#include <iostream>
#include <list>
#include <string>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

bool isPrime(int number)
{
  number = abs(number);
  
  // 0 and 1 are no prime numbers
  if( number == 0 || number == 1 )
    return false;

  int divisor;

  // find divisor that divides without a remainder
  for( divisor = number/2; number % divisor != 0; --divisor )
    ;

  // if no divisor greater than 1 is found, it is a prime number
  return divisor == 1;
}

int main()
{
  list<int> coll;

  for( int i = 24; i <= 30; i++ )
    coll.push_back(i);

  PRINT_ELEMENTS(coll, "initialized  : ");

  // is used to search for the 'first' element of the given range for which the passed unary
  // predicate yields true. If it does not find any element that matches the predicate, the
  // algorithm returns the end of the range (its 'second' argument).

  auto pos = find_if( coll.cbegin(), coll.cend(), isPrime );
  if( pos != coll.end() )
    cout << *pos << " is first prime number found" << endl;
  else
    cout << "no prime number found" << endl;
}


<predicate-is-limited>
Depending on algorithms to use, can use only unary and binary since the predicate only supports
unary and binary which means must have one or two parameters. How to support more arguments?

Revise the above algorithm-stable-sort example to report how many words are of a given size or
greater. (From Primers 10.3.2) The sketch is:

void biggies( vector<string> &words, vector<string>::size_type sz )
{
  elimDups( words );
  stable_sort( words.begin(), words.end(), isShorter );

  // 1. get an iterator to the first element whose size is >= sz
  // 2. compute the number of elements with size >= sz
  // 3. print words of the given size or longer
}

<1> Can use find_if to find the first whose size is >= sz? However, find_if takes 'unary' predicate
so cannot use F(elem, size_type). How to solve this?


={============================================================================
*kt_dev_stl_062* algorithm: lambda

{lambda}
Lambdas, introduced with C++11, define a way to specify functional behavior 'inside' an expression
or statement. You can define 'objects' that represent functional behavior and pass these objects as
unnamed 'inline' function to algorithms to be used as predicates or for other purposes.

Like any other function, lambda has return, parameter, and function body but unlike function, be
defined inside a function.

<form>
[capture list] (parameter list) -> return type { body }

The capture list is a list of 'local' variables in the 'enclosing' function. The parameter and
return are optional. If omits them, will be void for parameter or return. When return used in the
body, has an 'inferred' return type. 

<example>
#include<iostream>

using namespace std;

int main()
{
  auto f = [] { return 42; };

  cout << f() << endl;
}

Revise this with lambda.

// stable_sort( coll.begin(), coll.end(), isShorter );
stable_sort( coll.begin(), coll.end(), 
    [](const string &a, const string &b)
    { return a.size() < b.size(); } );

<2> To solve the above problem, use lambda. note: Here the lambda is 'temporary' function objects.

auto wc = find_if( words.begin(), words.end(),
               [sz](const string &a)
               { return a.size() >= sz; } );

Here [sz] is used to capture a variable from enclosing function and can use two arguments; one from
capture and one from parameter and return bool.

<putting-it-all-together>
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template<typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &opt = "")
{
  std::cout << opt;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

void elimDups( vector<string> &words)
{
  sort( words.begin(), words.end() );

  PRINT_ELEMENTS( words, "sorted       : ");

  auto end_unique = unique( words.begin(), words.end() );

  words.erase( end_unique, words.end() );
}

// note: "return ctr>1 ? word + ending : word;" works.
//
string make_plural( size_t ctr, const string &word, const string &ending )
{
  return (ctr>1) ? word + ending : word;
}

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

void biggies( vector<string> &words, vector<string>::size_type sz )
{
  elimDups( words );

  PRINT_ELEMENTS(words, "eliminated   : ");

  stable_sort( words.begin(), words.end(), 
      [](const string &a, const string &b)
      { return a.size() < b.size(); } );

  PRINT_ELEMENTS(words, "stable sorted: ");

  // 1. get an iterator to the first element whose size is >= sz
  // auto wc = find_if( words.begin(), words.end(),
  //                [sz](const string &a)
  //                { return a.size() >= sz; } );

  auto wc = find_if( words.begin(), words.end(),
                 bind( check_size, _1, sz ));

  // 2. compute the number of elements with size >= sz. <iterator-arithmetic> since vector
  auto count = words.end() - wc;          

  cout << count << " " << make_plural( count, "word", "s" ) << " of length " << sz << " or longer"
    << endl;

  PRINT_ELEMENTS(words, "for_each     : ");

  // 3. print words of the given size or longer
  for_each( wc, words.end(), [](const string &s) { cout << s << " "; });

  cout << endl;
}

int main()
{
  vector<string> coll{"over", "quick", "red", 
    "fox", "jumps", "red", "the", "slow", "turtle", "the"};

  PRINT_ELEMENTS( coll, "initialized  : ");

  biggies( coll, 5 );
}

// both lambda and bind version
//
initialized  : over quick red fox jumps red the slow turtle the 
sorted       : fox jumps over quick red red slow the the turtle 
eliminated   : fox jumps over quick red slow the turtle 
stable sorted: fox red the over slow jumps quick turtle 
3 words of length 5 or longer
for_each     : fox red the over slow jumps quick turtle 
jumps quick turtle 

In lambda in for_each, can use cout directly since cout is staic name and capture list can use only
on local nonstatic variables.


<lambda-capture>
When define lambda, compiler generates a new unnamed class so when pass it to a function, defines
both a new type and an object of that type. So the data member of a lambda are initialized when a
lambda object is created. That means that the variable captured by a lambda is 'local' to a lambda.

<capture-by-value-or-reference>
v1 = 42;
auto f = [v1] { return v1; };
v1 = 0;
auto j = f();     // j is 42. f is callable

v1 = 42;
auto f = [&v1] { return v1; };
v1 = 0;
auto j = f();     // j is 0.

Unlike parameters, the value of captured variable is copied when the lambda is 'created', not when
it is called (executed). When pass lambda such as return a lambda, careful for the same reason that
a function must not return a reference to a local variable. If possible, avoid capturing pointers or
reference.

<implicit-capture>
Let the compiler 'infer' variables we use from the code in the lambda body. Use an & or = in the
capture list. The revised is:

// 1. get an iterator to the first element whose size is >= sz
auto wc = find_if( words.begin(), words.end(),
               [=](const string &a)
               { return a.size() >= sz; } );

<limits-of-lambda>
Cannot be used sorting-criterion for associative containers and have state as function object does.


={============================================================================
*kt_dev_stl_063* algorithm: function object and function type

{function-object}

C++SLR 6.10

Functional arguments for algorithms don't have to be functions. As seen with lambdas, functional
arguments can be objects that behave like functions. Such an object is called a function object, or
functor.

Since C++11, the standard uses the term function object for every object that can be used as a
function call. Thus, function pointers, objects of classes with operator () or with a conversion to
a pointer to function, and lambdas are function objects. Here in this book, however, I use the term
for objects of classes with operator() defined.

So, what is the behavior of a function? A functional behavior is something that you can call by
using parentheses and passing arguments. For example:

function(arg1,arg2);       // a function call

C++P p571. When overloads function call operator() then can use a object as if it's a func call and
'call' a object. Hence function object. Must be a member and can have 'state' so more flexible than
usual function.

struct absInt {
  int operator() (int val) const {
    return val < 0 ? -val : val;
  }
};

int i = -42;
absInt absObj;
int ui = absObj(i);  // is equivalent to absObj.operator()(i)

<example> when use function object
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class PrintInt
{
  public:
    void operator() (int elem) const
    {
      cout << elem << ' ';
    }
};

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  // print all elements
  for_each (coll.cbegin(), coll.cend(), // range
      PrintInt());                      // operation note: T() is temporary

  cout << endl;
}


<example> when use a usual function

void print(int elem)
{ cout << elem << ' '; }

int main()
{
  vector<int> coll{1,2,3,4,5,6,7,8,9};

  for_each( coll.cbegin(), coll.cend(), print );
  cout << endl;
}


{advantages}
The function object have advantages:

1. "functions with state."
They can be "smart functions" because may have other member functions and attributes. This means
that function objects have a state.

In fact, the same functionality, represented by two 'different' function objects instances of the
same class, may have different 'states' at the same time. This is not possible for ordinary
functions. Another advantage of function objects is that you can initialize them at 'runtime' before
you use/call them.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class PrintString {
  public:
    PrintString( ostream& o = cout, char c = ' ') : os(o), sep(c) {}

    // const member func. works well. 
    // Q: why const as os may change its state? As with "bitwise-const", emits errors only when
    // "assignment" is used on members.
    void operator() (const string &s) const { os << s << sep; }

  private:
    ostream& os; char sep;
};

int main()
{
  PrintString printer;
  printer("printer");

  PrintString errors( cerr, '\n' );
  errors("errors");
}


2. Each function object has its own type. Ordinary functions have different types 'only' when their
signatures differ. However, function objects can have different types even when their signatures are
the same. See function<> example below. In fact, each functional behavior defined by a function
object has its own type. This is a significant improvement for generic programming using 'templates'
because you can 'pass' functional behavior as a template parameter. Doing so enables containers of
different types to use the same kind of function object as a sorting criterion, ensuring that you
don't assign, combine, or compare collections that have different sorting criteria. You can even
design hierarchies of function objects so that you can, for example, have different, special kinds
of one general criterion.

note: not sure since no example provided.
In particular, Chapter 10 shows how to benefit from the ability to pass functional behavior as a
template parameter.


3. Function objects are usually faster than ordinary functions; function pointer. The concept of
templates usually allows better optimization because more details are defined at compile time. Thus
passing function objects instead of ordinary functions often results in better performance.


<example>
Suppose that you want to add a certain value to all elements of a collection. If you know the value
to add at 'compile' time, you could use an ordinary function, predicate.

void add10 (int& elem)
{
    elem += 10;
}

for_each (coll.begin(), coll.end(), add10);


If you know the different values to add at 'compile' time, you could use template.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

template <int theValue>       // see no typename
void add( int& elem )
{
  elem += theValue;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  // note: when use cbegin() instead, causes compile error. however, works in previous examples?
  //
  // : error: invalid initialization of reference of type "int&" from expression of type "const int"
  //
  // The reason is that 
  //
  // 1. from for_each code:
  //     __f(*__first);
  //
  // 2. from operation code:
  //     void add( int& elem )
  //
  // Therefore, add(*__first) and this is "int& elem <- const int". For previous examples, the
  // argument type was int and no problem.

  for_each (coll.begin(), coll.end(),   // range
      add<10>);                         // operation

  PRINT_ELEMENTS(coll, "added      : " );
}


initialized: 1 2 3 4 5 6 7 8 9 
added      : 11 12 13 14 15 16 17 18 19 

If you process the value to add at runtime, things get complicated. This normally results in a
global variable that is used both by the function that calls the algorithm and by the function that
is called by the algorithm. Did you ever copy the definition of a function because it had a static
variable to keep its state(the value to add) and you needed the same function with another state at
the same time? This is exactly the same type of problem. You can't achieve this with one ordinary
function. The below solves it by using two different function object but same type and
functionality.

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class AddValue
{
  private:
    int theValue;

  public:
    AddValue( int v ) : theValue(v) { }

    void operator() (int &elem) const
    { elem += theValue; }
};

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(),   // range
      AddValue(10));                    // operation

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(),   // range
      AddValue(*coll.begin()));         // operation

  PRINT_ELEMENTS(coll, "added first: " );
}

initialized: 1 2 3 4 5 6 7 8 9 
added 10   : 11 12 13 14 15 16 17 18 19 
added first: 22 23 24 25 26 27 28 29 30 


<why-is-this>
With this technique, two different function objects can solve the problem of having a function with
two 'states' at the same time. For example, you could simply declare two function objects and use them
independently:

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class AddValue
{
  private:
    int theValue;

  public:
    AddValue( int v ) : theValue(v)
    {
        cout << "ctor is called: " << theValue << endl;
    }

    AddValue(const AddValue& rhs)
    {
        cout << "copy ctor is called: " << theValue << endl;
    }

    // note: What might be the result when use this? there is no changes to a container.
    // void operator() (int elem) const

    void operator() (int &elem) const
    { elem += theValue; }
};

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  AddValue addx(10);
  AddValue addy(20);

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(), addx);
  cout << "-----------------------------" << endl;

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(), addy); 
  cout << "-----------------------------" << endl;

  PRINT_ELEMENTS(coll, "added first: " );
}

ctor is called: 10
ctor is called: 20
initialized: 1 2 3 4 5 6 7 8 9 
copy ctor is called: 0
copy ctor is called: -1218374876
-----------------------------
added 10   : 1 2 3 4 5 6 7 8 9 
copy ctor is called: 134519579
copy ctor is called: -1218374876
-----------------------------
added first: 134519580 134519581 134519582 134519583 134519584 134519585 134519586 134519587 134519588 

note: why this wrong result? since copy ctor is wrong and should be:

class AddValue
{
    AddValue(const AddValue& rhs)
    {
        cout << "copy ctor is called: " << rhs.theValue << endl;
        theValue = rhs.theValue;
    }
};

ctor is called: 10
ctor is called: 20
initialized: 1 2 3 4 5 6 7 8 9 
copy ctor is called: 10
copy ctor is called: 10
-----------------------------
added 10   : 11 12 13 14 15 16 17 18 19 
copy ctor is called: 20
copy ctor is called: 20
-----------------------------
added first: 31 32 33 34 35 36 37 38 39 


note: why is copy ctor called two times? since for_each<> returns _Function and confirms that there
is one copy ctor when changes its definition in stl_algo.h

<algorithm-for-each>

namespace std {
  template <typename Iterator, typename Operation>
    Operation for_each (Iterator act, Iterator end, Operation op)
    {
      while (act != end) {    // as long as not reached the end
        op(*act);             // call op() on an element
        ++act;                // move iterator to the next element
      }
      return op;
    }
}

The code from bits/stl_algo.h:

/**
*  @brief Apply a function to every element of a sequence.
*  @ingroup non_mutating_algorithms
*  @param  __first  An input iterator.
*  @param  __last   An input iterator.
*  @param  __f      A unary function object.                   // note: speficy 'unary'
*  @return   @p __f (std::move(@p __f) in C++0x).
*
*  Applies the function object @p __f to each element in the range
*  @p [first,last).  @p __f must not modify the order of the sequence.
*  If @p __f has a return value it is ignored.
*/
template<typename _InputIterator, typename _Function>
_Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f)
{
    // concept requirements
    __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
        __glibcxx_requires_valid_range(__first, __last);

    for (; __first != __last; ++__first)
        __f(*__first);

    return _GLIBCXX_MOVE(__f);
}


{function-automatic-conversion}
As with "function-type", involves automatic conversion to function type(pointer). When use a usual
function, compiler converts it to function type and a function call is a operator() on this function
pointer. 

When use a function object, do the same. So in for_each case, takes a 'pointer' from a 'temporary'
function object and there is 'no' object creation for function type template parameter.

note: this is wrong since as shown above, copy is made for argument and return.


{function-object-passed-by-value} C++SLR 10.1.2, 3
As with the same example, a function that may have more than one state at the same time.

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  PRINT_ELEMENTS(coll, "initialized: " );

  for_each (coll.begin(), coll.end(), AddValue(10));

  PRINT_ELEMENTS(coll, "added 10   : " );

  for_each (coll.begin(), coll.end(), AddValue(20)); 

  PRINT_ELEMENTS(coll, "added first: " );
}

By default, function objects are passed by value rather than by reference. Thus, the algorithm
does not change the state of the function object.

Passing function objects by value instead of by reference has the advantage that you can pass
constant and temporary expressions. Otherwise, passing IntSequence(1) would not be possible. note:
since a copy of temporary is safe to use.

The disadvantage of passing the function object by value is that you can't benefit from
modifications of the state of the function objects. However, access to the final state might be
necessary.

There are three ways to get a "result" from function objects passed to algorithms:

1. You can keep the state externally and let the function object refer to it.
2. You can pass the function objects by reference.
3. You can use the return value of the for_each() algorithm.

<2>
To pass a function object by reference, you simply have to qualify the call of the algorithm so that
the function object type is a reference.

class IntSequence {
    private:
        int value;

    public:

        IntSequence (int initialValue)
            : value(initialValue) { }

        int operator() () 
        {
            return ++value;
        }
};

int main()
{
    list<int> coll;
    IntSequence seq(1); // integral sequence starting with 1

    // insert values from 1 to 4
    // - pass function object by reference so that it will continue with 5
    generate_n<back_insert_iterator<list<int>>, int, IntSequence&>(     // note: see reference
            back_inserter(coll),    // start
            4,                      // number of elements
            seq);                   // generates values

    PRINT_ELEMENTS(coll);

    // insert values from 42 to 45
    generate_n ( back_inserter(coll),  // start
                  4,                   // number of elements
                  IntSequence(42));    // generates values

    PRINT_ELEMENTS(coll);

    // continue with first sequence
    // - pass function object by value but it will continue with 5 again
    generate_n ( back_inserter(coll),     // start
                  4,                      // number of elements
                  seq);                   // generates values

    PRINT_ELEMENTS(coll);

    // continue with first sequence again
    generate_n ( back_inserter(coll),     // start
                  4,                      // number of elements
                  seq);                   // generates values

    PRINT_ELEMENTS(coll);
}

2 3 4 5
2 3 4 5 43 44 45 46
2 3 4 5 43 44 45 46 6 7 8 9
2 3 4 5 43 44 45 46 6 7 8 9 6 7 8 9


<3>
The passing a function object by reference in order to access its final state is not necessary if
you use the for_each() algorithm. for_each() has the 'unique' ability to return its function object
(no other algorithm can do this). Thus, you can query the state of your function object by checking
the return value of for_each().

The following program is a nice example of the use of the return value of for_each() and shows how
to process the mean value of a sequence:

// function object to process the mean value
class MeanValue {
    private:
        long num; // number of elements
        long sum; // sum of all element values

    public:
        MeanValue () : num(0), sum(0) {
        }

        void operator() (int elem) {
            ++num; // increment count
            sum += elem; // add value
        }

        // return mean value
        double value () {
            return static_cast<double>(sum) / static_cast<double>(num);
        }
};

int main()
{
    vector<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8 };

    // process and print mean value
    MeanValue mv = for_each (coll.begin(), coll.end(),   // range
                              MeanValue());              // operation

    cout << "mean value: " << mv.value() << endl;
}


{match-to-element-type}
How relates to the element? Is it possible to have different type for the element type of container
and the element type of function-object? How function object gets the argument?

These stl class generates a function object that invokes the corresponding operator of the
underlying element type.

<example>
class PrintInt
{
  public:
    void operator() (string elem) const   // note: string
    {
      cout << elem << ' ';
    }
};

int main()
{
  vector<int> coll;

  // insert elements from 1 to 9
  for (int i=1; i<=9; ++i) {
    coll.push_back(i);
  }

  // print all elements
  for_each (coll.cbegin(), coll.cend(), // range
      PrintInt());                      // operation

  cout << endl;
}

$ ./cppbl.sh sample.cpp 
In file included from /usr/include/c++/4.7/algorithm:63:0,
                 from sample.cpp:3:
/usr/include/c++/4.7/bits/stl_algo.h: In instantiation of _Funct std::for_each(_IIter, _IIter,
        _Funct) [with _IIter = __gnu_cxx::__normal_iterator<const int*, std::vector<int> >; _Funct =
PrintInt]:

sample.cpp:27:17:   required from here
/usr/include/c++/4.7/bits/stl_algo.h:4442:2: error: invalid conversion from int to const char*
[-fpermissive]
In file included from /usr/include/c++/4.7/string:54:0,
                 from /usr/include/c++/4.7/bits/locale_classes.h:42,
                 from /usr/include/c++/4.7/bits/ios_base.h:43,
                 from /usr/include/c++/4.7/ios:43,
                 from /usr/include/c++/4.7/ostream:40,
                 from /usr/include/c++/4.7/iostream:40,
                 from sample.cpp:1:

/usr/include/c++/4.7/bits/basic_string.h:487:7: error:   initializing argument 1 of
std::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT
= char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] [-fpermissive]


{as-sorting-criteria} C++SLR 10.1.1
Need a sorted collection of elements that have a class for example, a collection of Persons.
However, can't use the usual operator < to sort the objects. How?

class Person {
    public:
        string firstname() const;
        string lastname() const;
        ...
};

// class for function predicate
// - operator () returns whether a person is less than another person
class PersonSortCriterion {
    public:
        bool operator() (const Person& p1, const Person& p2) const {
            // a person is less than another person
            // - if the last name is less
            // - if the last name is equal and the first name is less
            return p1.lastname()<p2.lastname() ||
                (p1.lastname()==p2.lastname() &&
                 p1.firstname()<p2.firstname());
        }
};

// create a set with special sorting criterion
set<Person,PersonSortCriterion> coll;

Note that the sorting criterion PersonSortCriterion is a type. Thus, you can use it as a template
argument for the set and can design function objects that represent different sorting criteria with
the same type. This would not be possible if you implement the sorting criterion as a plain function


{predicate-must-stateless} C++SLR 10.1.4
Predicates are functions or function objects that return a Boolean value or a value that is
convertible into bool. However, 'not' every function that returns a Boolean value is a valid
predicate for the STL. This may lead to surprising behavior.

#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

class Nth { // function object that returns true for the nth call
    private:
        int nth; // call for which to return true
        int count; // call counter
    public:
        Nth (int n) : nth(n), count(0) {
        }
        bool operator() (int) {
            return ++count == nth;
        }
};

int main()
{
    list<int> coll = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    PRINT_ELEMENTS(coll,"coll       : ");

    // remove third element
    list<int>::iterator pos;
    pos = remove_if(coll.begin(),coll.end(), // range
            Nth(3)); // remove criterion

    coll.erase(pos,coll.end());
    PRINT_ELEMENTS(coll,"3rd removed: ");
}

// run under GCC 4.7.2
coll       : 1 2 3 4 5 6 7 8 9 10 
3rd removed: 1 2 4 5 7 8 9 10 

Two elements, the third and sixth elements, are removed. This happens because the usual implementation
of the algorithm copies the predicate internally during the algorithm:

template <typename ForwIter, typename Predicate>
ForwIter std::remove_if(ForwIter beg, ForwIter end, Predicate op)
{
    // copied here
    beg = find_if(beg, end, op);

    if (beg == end) {
        return beg;
    }
    else {
        ForwIter next = beg;

        // copied again
        return remove_copy_if(++next, end, beg, op);
    }
}

However, the algorithm then uses a copy of the passed predicate op to process the remaining
elements, if any. Here, Nth in its original state is used again and also removes the third element
of the remaining elements, which is in fact the sixth element.

The standard does not specify how often a predicate might be copied internally by an algorithm.
Thus, to get the guaranteed behavior of the C++ standard library, you should not pass a function
object for which the behavior depends on how often it is copied or called. In other words: A
predicate should always be 'stateless'.

<to-resolve>
To ensure that you can't change the state of a predicate due to a function call, you should declare
operator () as a constant member function. 

Or possible to avoid this surprising behavior and to guarantee that this algorithm works as expected
even for a function object such as Nth, without any performance penalties. You could implement
remove_if() in such a way that the call of find_if() is replaced by its contents:


template <typename ForwIter, typename Predicate>
ForwIter std::remove_if(ForwIter beg, ForwIter end, Predicate op)
{
    while (beg != end && !op(*beg)) {
        ++beg;
    }
    if (beg == end) {
        return beg;
    }
    else {
        ForwIter next = beg;
        return remove_copy_if(++next, end, beg, op);
    }
}

To my knowledge, this problem arises in current implementations only with the remove_if() algorithm.
If you use remove_copy_if(), all works as expected. 

However, for portability, you should never rely on this implementation detail. You should always
declare the function call operator of predicates as being a constant member function.


<support-for-pointers> any real case which is useful?
p575. Recall that comparing two unrelated pointers is undefined. However, might want to sort a
vector of pointers. Although it would be undefined for us to do directly, can do through library
function object. 

vector<string *> nameTable;
sort(nameTable.begin(), nameTable.end(), less<string *>());

<example> note: needs more since not sure why it is useful to know
Again, compare example.

template <typename T>   // '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

This is function template and is useful. However, only supports '<' on type.  How about others such
as '>'? If write a template supporting function object, then supports whatever operations user
selects. See <template-default-argument> for more.

template <typename T, typename F = less<T>>
int compare( const T &v1, const T &v2, F f = F())
{
  if( f(v1, v2) ) return -1;
  if( f(v2, v1) ) return 1;
  return 0;
}


={============================================================================
*kt_dev_stl_064* algorithm: function

{function-type}
Assume to build a simple desk calculator and to define a function table to store pointers to these
callables since all have the same call signature. 

// ordinary function
int add(int i, int j) { return i+j;}

// lambda
auto mod = [](int i, int j) { return i%j; };

// function object
struct divide {
  int operator () (int denominator, int divisor) {
    return denominator/divisor;
  }
};

map<string, int(*)(int, int)> binops;

binops.insert( {"+", add} );
binops.insert( {"%", mod} );     // error since mod is 'not' a pointer to function

The second is in error since like any other object, a callable object has a type and lambda type
does not match the type of the values in the map.

Can solve this using library 'type' named 'function' defined in functional header. This represent
'any' callables that has the same call signature. This is additional information for a template.

function<int(int,int)>

function<int(int,int)> f1 = add;
function<int(int,int)> f2 = divide();
function<int(int,int)> f3 = [](int i, int j) { return i%j; };

cout << f1(4,2) << endl;
cout << f2(4,2) << endl;
cout << f3(4,2) << endl;

Can redefine a map to build a calculator.

map<string, function<int(int, int)>> binops = {
  {"+", add},
  {"-", std::minus<int>()},
  {"/", divide()},
  ...
};

And when index a map, get a reference to the associated value, use

binops["+"](10,5);   // adds(10,5)
binops["-"](10,5);   // minus<int>(10,5)
...


={============================================================================
*kt_dev_stl_065* algorithm: bind

C++11 from boost::bind. function adaptor. Defined in functional header. 

In general, bind() generates a new callable and binds parameters for callable objects. Thus, if a
function, member function, function object, or lambda requires some parameters, you can bind them to
specific or passed arguments. Specific arguments you simply name. For passed arguments, you can use
the predefined placeholders _1, _2, ... defined in namespace std::placeholders.

auto newCallable = bind( callable, arg_list );

In other words, bind(f, _1, 5)(x) is equivalent to f(x, 5). when f(arg1, arg2) and 'binds' args1 to
    the passed x.


{arg-list}
_n 'placeholder' where n is 'number' representing the parameters of 'newCallable'. That is _1 is
first parameter in newCallable.

<algorithm-find-if>
// bits/stl_algo.h
// This is an overload used by find_if() for the Input Iterator case.
template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred, input_iterator_tag)
    {
        while (__first != __last && !bool(__pred(*__first)))
            ++__first;
        return __first;
    }


bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

auto check6 = bind( check_size, _1, 6 );

string s = "hello";
bool b1 = check6(s);    // bool check_size(s, 6)

auto wc = find_if( words.begin(), words.end(), 
                     [sz] (const string &a)
                     { return a.size() >= sz; } );

auto wc = find_if( words.begin(), words.end(), 
                     bind(check_size, _1, 6) );


<placeholder-namespace>
The placeholder is defined in std::placeholders namespace in functional header.

sample.cpp:20:25: error: "_1" was not declared in this scope

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

int main()
{
  vector<string> coll{"over", "quick", "red", 
    "fox", "jumps", "red", "the", "slow", "turtle", "the"};

  sort( coll.begin(), coll.end() );

  PRINT_ELEMENTS( coll, "sorted: " );

  auto wc = find_if( coll.begin(), coll.end(),
      bind( check_size, _1, 4 ));

  cout << "wc = " << *wc << endl;
}

sorted: fox jumps over quick red red slow the the turtle 
wc = jumps

<rearrange-arguments>
Can use bind to bind or rearrange the parameters in the given collable.

auto g = bind( f, a, b, _2, c, _1 );      
g(X, Y); // f( a, b, Y, c, X );

As an example, invert the meaning of isShorter.

bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

sort( words.begin(), words.end(), isShorter );
sort( words.begin(), words.end(), bind( isShorter, _2, _1 ));

<not-use-arguments>
Possible not to use arguments at all. If changes the example above as:

auto wc = find_if( coll.begin(), coll.end(),
   bind( check_size, "bind", 4 ));


sorted: fox jumps over quick red red slow the the turtle 
wc = fox


{predefined-function-objects}
#include <functional> defines a set of function 'object' classes.

negate<type>()          - param
plus<type>()            param1 + param2
minus<type>()           param1 - param2
multiplies<type>()      param1 * param2
divides<type>()         param1 / param2
modulus<type>()         param1 % param2
equal_to<type>()        param1 == param2
not_equal_to<type>()    param1 != param2
less<type>()            param1 < param2
greater<type>()         param1 > param2
less_equal<type>()      param1 <= param2
greater_equal<type>()   param1 >= param2
logical_not<type>()     ! param
logical_and<type>()     param1 && param2
logical_or<type>()      param1 || param2
bit_and<type>()         param1 & param2
bit_or<type>()          param1 | param2
bit_xor<type>()         param1 ^ param2


set<int,less<int>> coll;      // = set<int> coll. sort elements with <
set<int,greater<int>> coll;   // sort elements with > 


# template-less from bits/stl_function.h
namespace std {

  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };

  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };

  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };

  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
};

# algorithm-transform from bits/stl_algo.h
namespace std {

  /**
   *  @brief Perform an operation on a sequence.
   *  @ingroup mutating_algorithms                    // note: mutating
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A unary operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  */
  template<typename _InputIterator, typename _OutputIterator, typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result, _UnaryOperation __unary_op)
    {
      // ...
      for (; __first != __last; ++__first, ++__result)
         *__result = __unary_op(*__first);                  // note: write to output and unary
      return __result;
    }

  /**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A binary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */
  template<typename _InputIterator1, typename _InputIterator2, 
      typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _OutputIterator __result,
         _BinaryOperation __binary_op)
    {
      // ...
      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
         *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
}


<example>
#include <iostream>
#include <deque>
#include <functional>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main()
{
  deque<int> coll{1,2,3,4,5,6,7,8,9};

  PRINT_ELEMENTS(coll, "initialized: " );

  // If source and destination are equal, as in this case, the returned negated elements overwrite
  // themselves.

  transform( coll.cbegin(), coll.cend(),        // source
              coll.begin(), negate<int>());     // destination, operation

  PRINT_ELEMENTS(coll, "negated    : " );

  transform( coll.cbegin(), coll.cend(),        // first source
              coll.cbegin(),                    // second source 
              coll.begin(),                     // destination
              multiplies<int>());               // operation

  PRINT_ELEMENTS(coll, "multiplies : " );
}


{functional-composition} nested-bind
This kind of programming results in functional composition. What is interesting is that all these
function objects are usually declared 'inline'. Thus, use a function-like notation or abstraction
but you get good performance.

#include<iostream>
#include<set>
#include<deque>
#include<string>
#include<algorithm>
#include<functional>

using namespace std;
using namespace std::placeholders;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

bool check_size( const string &s, string::size_type sz )
{
  return s.size() >= sz;
}

int main()
{
    set<int, greater<int>> coll1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    deque<int> coll2;

    PRINT_ELEMENTS( coll1, "initialized: " );

    transform( coll1.cbegin(), coll1.cend(),        // source
                back_inserter( coll2 ),             // destination
                bind( multiplies<int>(), _1, 10 )); // operation

    PRINT_ELEMENTS( coll2, "transformed: " );

    replace_if( coll2.begin(), coll2.end(),         // range
                bind( equal_to<int>(), _1, 70 ),    // criterion
                42 );                               // new value

    PRINT_ELEMENTS( coll2, "replaced   : " );

    coll2.erase( remove_if( coll2.begin(), coll2.end(),
                            bind( logical_and<bool>(),
                                bind(greater_equal<int>(), _1, 50),
                                bind(less_equal<int>(), _1, 80)) ),
                    coll2.end());

    PRINT_ELEMENTS( coll2, "removed    : " );
}

initialized: 9 8 7 6 5 4 3 2 1 
transformed: 90 80 70 60 50 40 30 20 10 
replaced   : 90 80 42 60 50 40 30 20 10 
removed    : 90 42 40 30 20 10 


note: Specifies for a parameter x the unary predicate "x>=50&&x<=80." and see that is the same
signature for greater_equal and less_equal so can be used in logical_and<>.

note: As you can see, the expressions are evaluated from the inside to the outside. So inner
callable returns bool type and outer callable uses that as element type. No function call involved.

template<typename _Tp>
struct logical_and : public binary_function<_Tp, _Tp, bool>
{
  bool
  operator()(const _Tp& __x, const _Tp& __y) const
  { return __x && __y; }
};

return bind(greater_equal<int>(), _1, 50) && bind(less_equal<int>(), _1, 80);

__x is not bind(greater_equal<int>(), _1, 50) and __y is not bind(less_equal<int>(), _1, 80) but __x
and __y are the returned type which is bool in this case.


<algorithm-remove-if>
{
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {
      // ...

      __first = _GLIBCXX_STD_A::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = _GLIBCXX_MOVE(*__first);
            ++__result;
          }
      return __result;
    }
}

# template-logical-and from bits/stl_function.h
namespace std 
{
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };

  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };

  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
};


{dependant-on-original}
Always have to specify the argument type of the predefined function object used. If the type doesn't
match, a type conversion is forced, or the expression results in a compile-time error. 

int main()
{
    multiplies<int> mt;
    cout << mt(10,20) << endl;
    cout << mt(20,10) << endl;

    // note 1:
    cout << bind(multiplies<int>(), _1, 10)(20) << endl;

    cout << mt(10,40) << endl;

    // note 2:
    cout << mt(10) << endl;
}

note 1:
The return and element type are dependant on the original callable.

note 2:
The number of arguments are dependant on the original callable.

t_functional.cpp:17:18: error: no match for call to (std::multiplies<int>) (int)

/usr/include/c++/4.7/bits/stl_function.h:160:12: 
      note: candidate is:
/usr/include/c++/4.7/bits/stl_function.h:163:7: 
      note: _Tp std::multiplies<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = int]
/usr/include/c++/4.7/bits/stl_function.h:163:7: 
      note:   candidate expects 2 arguments, 1 provided


{copy-arguments}
bind() internally copies passed arguments. To let the function object use a reference to a passed
argument, use ref() or cref() (see Section 5.4.3, page 132). For example:

void incr (int& i)
{
    ++i;
}

int i=0;

bind(incr,i)();            // increments a copy of i, no effect for i
bind(incr,ref(i))();       // increments i


{use-global-function}
Can use it directly.

char myToupper (char c)
{
    std::locale loc;
    return std::use_facet<std::ctype<char> >(loc).toupper(c);
}

bind(myToupper,_1);


{use-member-function}
The bind() works with member function, modifying member function, and virtual function.

For each element of the collection coll, the member function save() of class Person is called. Of
course, this works only if the elements of the coll have type Person or a type derived from Person.

class Person {
    public:
        Person (const string& n);
        void print () const;
        void print2 (const string& prefix) const;

        void setName (const std::string& n) {
            name = n;
        }
};

// call member function print() for each person
for_each (coll.begin(), coll.end(), bind(&Person::print,_1));

// call member function print2() with additional argument for each person
for_each (coll.begin(), coll.end(), bind(&Person::print2,_1,"Person: "));

// call modifying member function setName()
for_each (coll.begin(), coll.end(), bind(&Person::setName,_1,"Paul"));


{use-pointers}
The bind() works with pointers.

vector<Person*> cp;
for_each (cp.begin(), cp.end(), bind(&Person::print, _1));

std::vector<std::shared_ptr<Person>> sp;
for_each (sp.begin(), sp.end(), bind(&Person::print, _1));


={============================================================================
*kt_dev_stl_065* algorithm: which is better?

C++SLR 6.10

Suppose that you search in a collection for the first element with a value that is between x and y.

If need to use in more than one or two places, use function than a lambda. However, it is not easy
to write function to replace a lambda that captures local variables. For example, find_if takes
unary predicate and no way to pass more than one as this example.

#include <algorithm>
#include <deque>
#include <iostream>

using namespace std;

int main()
{
  deque<int> coll = { 1, 3, 19, 5, 13, 7, 11, 2, 17 };

  int x = 5;
  int y = 12;

  auto pos = find_if (coll.cbegin(), coll.cend(),  // range
      [=](int i) {                                 // search criterion
         return i > x && i < y;
      });

  cout << "first elem >5 and <12: " << *pos << endl;
}

Now compare this way to search for "the first element >5 and <12" with the 'other' approaches
provided by C++ before lambdas were introduced

1. handwritten loop

// find first element > x and < y

vector<int>::iterator pos;

for (pos = coll.begin() ; pos != coll.end(); ++pos) 
{
  if (*pos > x && *pos < y) {
    break; // the loop
  }
}

2. predicate, function object

class Pred
{
    private:
        int x;
        int y;
    public:
        Pred (int xx, int yy) : x(xx), y(yy) {
        }
        bool operator() (int i) const {
            return i > x && i < y;
        }
};

pos = find_if(coll.begin(), coll.end(), Pred(x,y) );     // note T()

note: 
1. You have to scroll up to find out what find_if() exactly is looking for
2. C++ compilers 'optimize' lambdas better than they do ordinary functions.
3. What's more, access to x and y becomes really ugly in this scenario.

3. bind

pos = find_if (coll.begin(), coll.end(),  // range
            bind(logical_and<bool>(),     // search criterion
               bind(greater<int>(),_1,x), // _1 > x
               bind(less<int>(),_1,y)));  // _1 < y


Lambdas are a kind of implicitly defined function object. Thus lambdas usually provide the more
intuitive approach to defining functional behavior of STL algorithms. In addition, lambdas should be
as fast as function objects.

However, there are also some drawbacks to lambdas:

* You can't have a hidden internal state of such a function object. Instead, all data that defines a
state is defined by the caller and passed as a capture.

* The advantage of specifying the functional behavior where it is needed partially goes away when
it is needed at 'multiple' places. You can define a lambda and assign it to an auto object then, but
whether this is more readable than directly defining a function object is probably a matter of
taste.


={============================================================================
*kt_dev_stl_066* algorithm: nonmodifying

{comparing-ranges}

<algorithm-equal> determines whether two sequences are equal
bool equal (InputIterator1 beg, InputIterator1 end, InputIterator2 cmpBeg)
bool equal (InputIterator1 beg, InputIterator1 end, InputIterator2 cmpBeg, BinaryPredicate op)

note: 
The caller must ensure that the range starting with cmpBeg contains enough elements.
Complexity: linear (at most, numElems comparisons or calls of op(), respectively).

#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

using namespace std;

// note: no half-open range
template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}
bool bothEvenOrOdd( int elem1, int elem2 )
{
  return elem1 %2 == elem2 %2;
}

int main()
{
  vector<int> coll1;
  list<int> coll2;
  list<int> coll3;

  INSERT_ELEMENTS( coll1, 1, 7 );
  INSERT_ELEMENTS( coll2, 3, 9 );
  INSERT_ELEMENTS( coll3, 1, 7 );

  PRINT_ELEMENTS( coll1, "coll1(vector): " );
  PRINT_ELEMENTS( coll2, "coll2(list)  : " );
  PRINT_ELEMENTS( coll3, "coll3(list)  : " );

  cout << endl;

  if( equal( coll1.begin(), coll1.end(),  // first range
        coll2.begin()))                   // second range
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  if( equal( coll1.begin(), coll1.end(),  // first range
        coll3.begin()))                   // second range
  {
    cout << "coll1 == coll3" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  // check for corresponding even and odd elements
  if( equal( coll1.begin(), coll1.end(),  
        coll2.begin(),
        bothEvenOrOdd ))                // comparison criterion
  {
    cout << "coll1 and coll2, even and odd elements correspond" << endl;
  }
  else
    cout << "coll1 and coll2, even and odd elements do not correspond" << endl;
}

coll1(vector): 1 2 3 4 5 6 7 
coll2(list)  : 3 4 5 6 7 8 9 
coll3(list)  : 1 2 3 4 5 6 7 

coll1 != coll2

coll1 == coll3

coll1 and coll2, even and odd elements correspond


<algorithm-is_permutation> testing for unordered equality
bool is_permutation (ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2)
bool is_permutation (ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2, CompFunc op)

note:
1. These algorithms are available since C++11.
2. The first form compares the elements by using operator ==.
3. The second form compares the elements by using the binary predicate op(elem1,elem2) which should
return true when elem1 is equal to elem2.
4. Complexity: at worst quadratic (numElems1 comparisons or calls of op(), if all elements are equal
and have the same order).

#include <iostream>
#include <vector>
#include <list>
#include <deque>
#include <algorithm>

using namespace std;

// note: no half-open range
template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}
bool bothEvenOrOdd( int elem1, int elem2 )
{
  return elem1 %2 == elem2 %2;
}

int main()
{
  vector<int> coll1 = { 1, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  list<int> coll2 = { 1, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
  deque<int> coll3 = { 11, 12, 13, 19, 18, 17, 16, 15, 14, 11 };

  PRINT_ELEMENTS( coll1, "coll1(vector): " );
  PRINT_ELEMENTS( coll2, "coll2(list)  : " );
  PRINT_ELEMENTS( coll3, "coll3(deque) : " );

  cout << endl;

  if( is_permutation( coll1.cbegin(), coll1.cend(), // first range
        coll2.cbegin()))                            // second range
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  if( equal( coll1.cbegin(), coll1.cend(),  // first range
        coll2.cbegin()))
  {
    cout << "coll1 == coll2" << endl;
  }
  else 
    cout << "coll1 != coll2" << endl;

  cout << endl;

  // check for corresponding even and odd elements
  if( is_permutation( coll1.cbegin(), coll1.cend(),  
        coll3.cbegin(),
        bothEvenOrOdd ))                // comparison criterion
  {
    cout << "coll1 and coll3, even and odd elements correspond" << endl;
  }
  else
    cout << "coll1 and coll3, even and odd elements do not correspond" << endl;
}

coll1(vector): 1 1 2 3 4 5 6 7 8 9 
coll2(list)  : 1 9 8 7 6 5 4 3 2 1 
coll3(deque) : 11 12 13 19 18 17 16 15 14 11 

coll1 == coll2

coll1 != coll2

coll1 and coll3, even and odd elements correspond


={============================================================================
*kt_dev_stl_067* algorithm: nonmodifying: count

{counting-elements}

<algorithm-count> count elements
difference_type count (InputIterator beg, InputIterator end, const T& value)
difference_type count_if (InputIterator beg, InputIterator end, UnaryPredicate op)

1. The first form counts the elements in the range [beg,end) that are equal to value value.
2. Complexity: linear (numElems comparisons or calls of op(), respectively).
3. Associative and unordered containers provide a similar member function, count(), to count the
number of elements that have a certain value as key

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

template<typename T>
inline void INSERT_ELEMENTS( T& coll, int first, int last )
{
  for( int i = first; i <= last; i++ )
    coll.insert( coll.end(), i );
}

template<typename T>
inline void PRINT_ELEMENTS( T& coll, const std::string& optcstr="")
{
  cout << optcstr;

  for( auto &elem : coll )
    cout << elem << ' ';

  cout << endl;
}

int main()
{
  vector<int> coll;
  int num;

  INSERT_ELEMENTS( coll, 1, 9 );
  PRINT_ELEMENTS( coll, "coll: " );

  // count elements with value 4
  num = count( coll.cbegin(), coll.cend(), 4 );
  cout << "number of elements equal to 4:      " << num << endl;

  // count elements with even value
  num = count_if( coll.cbegin(), coll.cend(), 
              [] (int elem) {
                return elem%2==0;
                });
  cout << "number of elememts with even value: " << num << endl;

  // count elements that are greater than 4
  num = count_if( coll.cbegin(), coll.cend(), 
              [] (int elem) {
                return elem > 4;
                });
  cout << "number of elememts than 4         : " << num << endl;

  return 0;
}

coll: 1 2 3 4 5 6 7 8 9 
number of elements equal to 4:      1
number of elememts with even value: 4
number of elememts than 4         : 5


={============================================================================
*kt_dev_stl_070* string

In short, the string types of the C++ standard library are designed to behave as if they were a kind
of fundamental data type that does not cause any trouble (at least in principle).

The usual interface for strings is not based on the concept of the STL. However, some iterator
support for strings is provided

The string classes are an example of the 'invasive' approach of writing STL containers. Strings can
be considered containers of characters. The characters inside the string build a sequence over which
you can iterate to process the individual characters. Thus, the standard string classes provide the
container interface of the STL.


{string-vs-vector}
This is no surprise because both are containers that are typically implemented as dynamic arrays.
Thus, you could consider a string as a special kind of a vector that has characters as elements.

However, considering a string as a special kind of vector is dangerous because there are
many fundamental differences between the two. Chief among these are their two primary goals:

1. The primary goal of vectors is to handle and to manipulate the elements of the container, not the
container as a whole. Thus, vector implementations are optimized to operate on elements inside the
container.

2. The primary goal of strings is to handle and to manipulate the container (the string) as a whole.
Thus, strings are optimized to reduce the costs of assigning and passing the whole container.

These different goals typically result in completely different implementations.


{sting-size-type-and-npos}
The return type of all find functions is string::size_type, an 'unsigned' integral type that is
defined inside the string class. 

Be very 'careful' that you always use string::size_type, not int or unsigned, for the return type
when you want to check the return value of a find function. Otherwise, the comparison with
string::npos might not work.

<string-element-access>
Accessing a single character of the string is done with operator[]

1. An argument specifying the index must have a 'valid' value. That value must be less than the
number of characters of the string. As usual, the first character has index 0, and the last
character has index length()-1. In addition, the index of the position after the last character
could be used to specify the end.

string s[s.length()];      // OK
string s.at(s.length());   // ERROR. the current number of characters is 'not' a valid index.

The operator[] does 'not' check whether the index of the string is valid. Thus, a safer way to
access a character is to use the at() member function. 

However, such a check costs runtime, so the check is 'not' provided for the usual accessing of
characters of a string. A good way is to aviod subscripting altogether by using a range-for whenever
possible. However not all compiler supports and see range-for

note: However, all functions that search for a character or a position allow any index. If the index
exceeds the number of characters, these functions simply return string::npos ("not found").

2. An argument specifying the number of characters could have 'any' value. If the size is greater
than the remaining number of characters, all remaining characters are used. string::npos always
works as a 'synonym' for "all remaining characters." or "until the end of the string". 

Why? -1, which because size_t is an unsigned integral type, it is the largest possible representable
value for this type.

Thus, the following expression throws an exception if the period is not found:
note: no exception under gcc 4.6.3.

filename.substr(filename.find(.))

But the following expression does not throw an exception: If the period is not found, it results in
the whole filename.

filename.substr(0, filename.find(.))


example: string-find, string-substr, string-replace

#include <iostream>
#include <string>

using namespace std;

int main(int argc, char* argv[])
{
  string filename, basename, extname, tmpname;

  const string suffix{"tmp"};

  // for each command line args
  while( --argc > 0 )
  // for( int i = 1; i < argc; i++ )
  {
    // filename = argv[i];
    filename = *++argv;

    // search period in filename
    // note: searches for the 'first' occurrence of a period inside the string filename and return
    // position. If the search fails, a special value is needed to return the failure. That value is
    // npos.

    string::size_type idx = filename.find('.');
    if( idx == string::npos )
    {
      // filename does not contain any period
      tmpname = filename + '.' + suffix;
    }
    else
    {
      // split filename into basename(before period) and extension(after period)
      // note: The first parameter of the substr() function is the 'starting' index. The optional
      // second argument is the 'number' of characters, not the end index. If the second argument is
      // not used, all remaining characters of the string are returned as a substring.

      basename  = filename.substr(0, idx);
      extname   = filename.substr(idx+1);

      if( extname.empty() )
      {
        // contains period but no extension
        tmpname = filename + suffix;
      }
      else if( extname == suffix )
      {
        // replace tmp with xxx
        tmpname = filename;
        tmpname.replace( idx+1, extname.size(), "xxx" );
      }
      else
      {
        // replace any with tmp
        tmpname = filename;
        tmpname.replace( idx+1, string::npos, suffix ); 
      }
    }

    // print filename and temporary name
    cout << filename << " => " << tmpname << endl;
  }
}

$ string1 prog.dat mydir hello. oops.tmp end.dat
prog.dat => prog.tmp
mydir => mydir.tmp
hello. => hello.tmp
oops.tmp => oops.xxx
end.dat => end.tmp


<example> string-find_first_of
#include <iostream>
#include <string>

using namespace std;

// This example extracts single words from standard input and prints the characters of each word in
// reverse order. The words are separated by the usual whitespaces (newline, space, and tab) and by
// commas, periods, or semicolons:

int main(int argc, char* argv[])
{
  // note: The newline character is also used as a delimiter. However, no special processing is
  // necessary for it because the program reads line by line.
  const string delims(" \t,.;");
  string line;

  while( getline( cin, line ) )
  {
    string::size_type begi, endi;

    // The find_first_not_of() function returns the 'first' index of a character that is not part of
    // the passed string argument.
    begi = line.find_first_not_of(delims);

    // while beginning of a word found
    while( begi != string::npos )
    {
      // searches for the end of the current word.
      // an optional second argument is used that specifies where to 'start' the search in the string.
      endi = line.find_first_of( delims, begi ); 
      if( endi == string::npos )
      {
        // end of word is end of line
        endi = line.length();
      }

      // print characters in reverse
      // <careful>
      for( int i = endi-1; i >= static_cast<int>(begi); --i )
        cout << line[i];

      cout << ' ';

      // search beginning of the next word
      begi = line.find_first_not_of( delims, endi );
    }

    // to have next input on next getline
    cout << endl;
  }
}

pots & pans
stop & snap 
I saw a reed
I was a deer 
deliver no pets
reviled on step 
nametag on diaper
gateman no repaid 


{string-type}
namespace std {
  template <typename charT,
           typename traits = char_traits<charT>,
           typename Allocator = allocator<charT> >
             class basic_string;
}

namespace std {
  typedef basic_string<char> string;
}


{operations}

<initialization> operation-arg-scheme
The operations that manipulate the value of a string have several overloaded versions that use the
argument scheme:

const string & str 
   The whole string str

const string & str, size_type idx, size_type num 
   At most, the first num characters of str starting with index idx

const char* cstr 
   The whole C-string cstr

const char* chars, size_type len 
   len characters of the character array chars

char c 
   The character c

size_type num, char c 
   num occurrences of character c

const_iterator beg, const_iterator end 
   All characters in range [beg,end) 

initlist 
   All characters in initlist (since C++11)

std::string s1("nico");    // initializes s1 with: n i c o
std::string s2("nico",5);  // initializes s2 with: n i c o \0
std::string s3(5,\0);    // initializes s3 with: \0 \0 \0 \0 \0

s1.length() // yields 4
s2.length() // yields 5
s3.length() // yields 5

string s1;                 // default initialzation. empty

string s2( s1 );           // direct form of initialzation.
string s2 = s1;            // copy form of initialzation.

string s3( "value" );
string s3 = "value";

string s4( n, 'c' );


<no-null> TODO: needs more to clarify

string s3( "value" );      // 'not' including the null

This end-of-string character is initialized by the default constructor of the character type (\0
for class string):

string s;
s[s.length()] // yields \0

note: that only the single-argument version const char* handles the character \0 as a special
character that terminates the string. In all other cases, \0 is not a special character: strings
do not provide a special meaning for the character \0, which is used as a special character in an
ordinary C-string to mark the end of the string. The character \0 may be part of a string just
like every other character.

<string-nullptr> <caution>
If you use an old-style null pointer (NULL) instead of nullptr or a char* parameter, strange
behavior results. The reason is that NULL has an integral type and is interpreted as the number 0 or
the character with value 0 if the operation is overloaded for a single integral type. So you should
always use nullptr or char* pointers.

<string-to-array>
const CharT* c_str() const;

copy()            Copies or writes the contents to a character array
data(), c_str()   Returns the value as C-string or character array

data() and c_str() return the contents of the string as an array of characters. The array 'includes'
the end-of-string character at position [size()]. note: that before C++11, the return type of data()
was not a valid C-string, because 'no' \0 character was guaranteed to get appended.

copy() copies the contents of the string 'into' a character array provided by the caller. An \0
character is not appended.

<caution> data() and c_str() return an array that is owned by the string. Thus, the caller must not
modify or free the memory. note: seems not possible since it is const?

<caution> convert string into C-strings or character arrays only immediately before you need the
contents as type char*. Since the return value of c_str() and data() is valid 'only' until the next
call of a nonconstant member function for the same string:

const char* p;
p = s.c_str();    // p refers to the contents of s as a C-string
foo(p);           // OK (p is still valid)
s += "ext";       // invalidates p
foo(p);           // ERROR: argument p is not valid

<string-capacity>
As for vector, string has the same interfaces: size(), length(), max_size(), capacity(), and
reserve().

There is one big difference: Unlike with vectors, calling reserve() for strings might be a call to
shrink the capacity. If the argument is less than the current number of characters, it is a
'nonbinding' shrink-to-fit request.

So, a call of reserve() without any argument is always a nonbinding shrink-to-fit request:
s.reserve();         // would like to shrink capacity to fit the current size

Since C++11, shrink_to_fit() provides the same effect:
s.shrink_to_fit();   // would like to shrink capacity to fit the current size (C++11)


<string-back>
Since C++11, front() and back() are provided to also access the first or last character,
respectively.

<caution> When called for an empty string, back() results in undefined behavior.

<string-reallocation>
std::string s("abcde");    // s contains: a b c d e

char& r = s[2];            // reference to third character
char* p = &s[3];           // pointer to fourth character

r = X;                   // OK, s contains: a b X d e
*p = Y;                  // OK, s contains: a b X Y e

s = "new long value";      // 'reallocation' invalidates r and p

r = X;                   // ERROR: undefined behavior
*p = Y;                  // ERROR: undefined behavior

{comparison}
tquery.cpp:128: error: no match for 'operator==' in 's == 'q''

shoule be:

string s;
if( !(cin >> s) || s == "q" ) break;


{modifiers}
<assign>
The assign() member functions provide more than operator=().

s.assign(aString);                     // assign "othello" (equivalent to operator =)
s.assign(aString,1,3);                 // assign "the"
s.assign(aString,2,std::string::npos); // assign "hello"

s.assign("two\nlines");                // assign a C-string (equivalent to operator =)
s.assign("nico",5);                    // assign the character array: n i c o \0
s.assign(5,x);                       // assign five characters: x x x x x

<swap>
The specialization of swap() for strings guarantees constant complexity

<empty>
To remove all characters in a string:

s = "";     // assign the empty string
s.clear();  // clear contents
s.erase();  // erase all characters

<insert-and-remove>
To append characters, you can use operator +=, append(), and push_back().

s += \n; // append single character

s.append(aString);                     // append "othello" (equivalent to operator +=)
s.append(aString,1,3);                 // append "the"
s.append(aString,2,std::string::npos); // append "hello"
s.append("two\nlines");                // append C-string (equivalent to operator +=)
s.append("nico",5);                    // append character array: n i c o \0
s.append(5,x);                       // append five characters: x x x x x

Several insert() member functions enable you to insert characters.

const std::string aString("age");
std::string s("p");
s.insert(1,aString);    // s: page
s.insert(1,"ersifl");   // s: persiflage

Several erase() functions and pop_back() (since C++11) remove characters, and several replace()
functions replace characters.

std::string s = "i18n";                // s: i18n
s.replace(1,2,"nternationalizatio");   // s: internationalization. note: change of size
s.erase(13);                           // s: international. note: from 13
s.erase(7,5);                          // s: internal
s.pop_back();                          // s: interna (since C++11)
s.replace(0,2,"ex");                   // s: externa

Use resize() to change the number of characters. If the new size that is passed as an argument is
less than the current number of characters, characters are removed from the end. If the new size is
greater than the current number of characters, characters are appended at the end.  You can pass the
character that is appended if the size of the string grows. If you dont, the default constructor
for the character type is used (which is the \0 character for type char).

<substring-and-concatenation>
string substr (size_t pos = 0, size_t len = npos) const;

std::string s("interchangeability");
s.substr(s.find(c))   // returns string("changeability")

Use operator + to concatenate two strings or C-strings or one of those with single characters

<inefficient-concatenation>
In JAVA, the following shows inefficient +. Assume that strings are all the same length, x and there
are n strings. Just think about +. For 1st iteration, x copies char by char. Next iteration, 2x and
so on. This reduces to O(xn^2) but not O((xn)^2)

String sentence = "";

for( String w : words )
   sentence = sentence + w;

This add string to sentence and copy the temp result to sentence for each loop. note: that there is
no append() member in String class. Should be written

StringBuffer sentence = new StringBuffer();

for( String w : words )
   sentence.append(w);

<use-append>
As for the above, use append since string has append member function.

<use-move>
operator + is also overloaded for strings that are rvalue references to support the move semantics
if a string argument passed to operator + is no longer needed afterward.

string foo()
{
  std::string s1("international");
  std::string s2("ization");

  std::string s = std::move(s1) + std::move(s2); // OK
  // s1 and s2 have valid state with unspecified value

  return s;
}


{io-operation}
<getline>
This comes from string but do not need to qualify std:: due to ADL(argument dependent lookup).

This function reads all characters, including leading whitespaces, until the line delimiter or
end-of-file is reached. The line delimiter is extracted but 'not' appended. Means that not include a
new line character.

// can set delimiter
while (getline(std::cin,s,:)) { // for each token separated by :
...
}

// can use stringstream
void process (const std::string& filecontents)
{
  // process first line of passed string:
  std::string firstLine;
  std::getline(std::stringstream(filecontents), // OK since C++11
      firstLine);
  ...
}

<Q> In the reference, is declared as:

istream& getline (istream& strm, string& str)

All characters, including leading whitespaces, are extracted until any of the following happens:
- strm.good() is false (which might cause an appropriate exception)
- delim or strm.widen(\n) is extracted
- str.max_size() characters are stored

Then how can we use "while( getline(...))" to read multiple lines when see the new line and returns?

From stackoverflow: It returns a stream so that we can chain the operation. But when you use an
object in a boolean context the compiler looks for an conversion operator that can convert it into a
type that can be used in the boolean context.

In this case stream has operator void*(). As this results in a pointer it can be used in a boolean
context. When called it checks the error flags. If either failbit or badbit are set then it returns
NULL which is equivalent to FALSE otherwise it returns a pointer to self (or something else valid
though you should not use this fact)).

So you can use a stream in any context that would require a boolean test:


{search}
There are three ways to search: by using member functions, the regex library, and STL algorithms.

All search functions return the index of the first character of the character sequence that matches
the search. If the search fails, they return npos.

Unfortunately, following search argument scheme differs from that of the other string functions.

1. The first argument is always the value that is searched for.
2. The optional second value indicates an index at which to start the search in the string.
3. The optional third argument is the number of characters of the value to search.

note: value can be either character or string

find()               Finds the first occurrence of value
rfind()              Finds the last occurrence of value (reverse find)

find_first_of()      Finds the first 'character' that is 'part' of value
find_last_of()       Finds the last character that is part of value
find_first_not_of()  Finds the first character that is not part of value
find_last_not_of()   Finds the last character that is not part of value


{string-npos}
Should be 'careful' when using the string value npos and string::size_type. When you want to check
the return value, 'always' use string::size_type, not int or unsigned for the type of the return
value; otherwise, the comparison of the return value with string::npos might not work.

The reason is the result of the design decision that npos is defined as -1:

namespace std {
  class basic_string {
    public:
      typedef typename Allocator::size_type size_type;   // note: allocator's type
      ...
      static const size_type npos = -1;
      ...
  };
}

<problem>
From the above example: 

string::size_type begi, endi;

begi = line.find_first_not_of(delims);

// <careful>
for( int i = endi-1; i >= static_cast<int>(begi); --i )
   cout << line[i];

Again, be very 'careful' when you use string::size_type which is 'unsigned'.

The nasty problem is, if you 'omit' the cast of begIdx to int, this program might run in an endless
loop or might crash. The problem is that string::size_type is an 'unsigned' integral type. Without
the cast, the signed value i is converted 'automatically' into an 'unsigned' value because it is
compared with a unsigned type. 

In this case, the following expression always yields true if the current word starts at the
beginning of the line:

i>=begIdx

The reason is that begIdx is then 0, and any unsigned value is greater than or equal to 0. For
example, when i == -1. So, an endless loop results that might get stopped by a crash due to an
illegal memory access. For this reason, I don't like the concept of string::size_type and
string::npos.

note: see implicit conversion

The size_type, which is defined by the allocator of the string, must be an unsigned integral type.
The default allocator, allocator, uses type size_t as size_type. Because -1 is converted into an
unsigned integral type, npos is the 'maximum' unsigned value of its type. 

However, the exact value 'depends' on the exact definition of 'type' size_type: (unsigned long)-1
differs from (unsigned short)-1 if the size of the types differs. so maximum values differ.

int idx = s.find("xx");
if (idx == std::string::npos) {
  ...
}

might yield false if idx has the value -1 and idx and string::npos have 'different' types: <Q>
really? not promoted to the bigger type? convertion done first or promotion?

<solution>
One way to avoid this error is to check whether the search fails directly:

if (s.find("hi") == std::string::npos) {
...
}

However, often you need the index of the matching character position. Thus, another simple solution
is to define your own signed value for npos:

const int NPOS = -1;

if (idx == NPOS) { // works almost always
...
}

Unfortunately, this solution is not perfect, because the comparison fails if either idx has type
unsigned short or the index is greater than the maximum value of int. Because of these problems, the
standard did not define it that way. 

However, because both might happen very 'rarely', the solution works in most situations. To write
portable code, however, you should always use string::size_type for any index of your string type.
For a perfect solution, you'd need some overloaded functions that consider the exact type of
string::size_type. I still hope the standard will provide a better solution in the future although
with C++11 nothing changed.


{numeric-conversion}
Since C++11, the C++ standard library provides convenience functions to convert strings into numeric
values or to convert numeric values to strings. Only for types string and wstring, not u16string and
u32string.

stoi(str,idxRet=nullptr, base=10)      Converts str to an int
stol(str,idxRet=nullptr, base=10)      Converts str to a long
stoul(str,idxRet=nullptr, base=10)     Converts str to an unsigned long
stoll(str,idxRet=nullptr, base=10)     Converts str to a long long
stoull(str,idxRet=nullptr, base=10)    Converts str to an unsigned long long
stof(str,idxRet=nullptr)               Converts str to a float
stod(str,idxRet=nullptr)               Converts str to a double
stold(str,idxRet=nullptr)              Converts str to a long double
to_string(val)                         Converts val to a string
to_wstring(val)                        Converts val to a wstring

<example>
#include <iostream>
#include <string>
#include <exception>
#include <limits>

using namespace std;

int main(int argc, char* argv[])
{
  try {
    // convert to numeric
    cout << std::stoi("  77") << endl;
    cout << std::stoi("  77.7") << endl;

    // note that std::stoi("-0x77") yields 0 because it parses only -0, interpreting the x as the
    // end of the numeric value found.
    cout << std::stoi("-0x77") << endl;

    // use index of chars not processed
    size_t idx;

    cout << std::stoi("  42 is the truth", &idx ) << endl;
    cout << " idx of first unprocessed char: " << idx << endl;

    // use base 16 and 8
    cout << std::stoi("  42", nullptr, 16 ) << endl;

    // note that std::stol("789",&idx,8) parses only the first character of the string because 8 is
    // not a valid character for octal numbers.
    cout << std::stoi("789", &idx, 8 ) << endl;
    cout << " idx of first unprocessed char: " << idx << endl;

    // convert numeric to string
    long long ll = std::numeric_limits<long long>::max();
    string s = std::to_string(ll);
    cout << s << endl;

    // try to convert back
    cout << std::stoi(s) << endl; // throws out_of_range
  }
  catch( const std::exception& e ) {
    cout << e.what() << endl;
  }
}

77
77
0
42
 idx of first unprocessed char: 4
66
7
 idx of first unprocessed char: 1
9223372036854775807
stoi


{iterator-support}
A string is an ordered collection of characters. As a consequence, the C++ standard library provides
an interface for strings that lets you use them as STL containers. 

String iterators are random-access iterators. The exact type is implementation defined, but string
iterators are often defined simply as ordinary pointers.

<example> algorithm-search, algorithm-transform
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(int argc, char* argv[])
{
  // create a string
  string s("The zip code of Braunschweig in Germany is 38100");
  cout << "original: " << s << endl;

  // to lowercase
  transform( s.cbegin(), s.cend(), s.begin(),
      [] (char c) {
        return tolower(c);
        });
  cout << "lowered : " << s << endl;

  // to uppercase
  transform( s.cbegin(), s.cend(), s.begin(),
      [] (char c) {
        return toupper(c);
        });
  cout << "uppered : " << s << endl;

  // search case-insensitive
  string g{"Germany"};
  string::const_iterator pos;

  pos = search( s.cbegin(), s.cend(),   // source string
                g.cbegin(), g.cend(),   // string to search
                [](char c1, char c2) {
                  return toupper(c1) == toupper(c2);
                  });
  if( pos != s.cend() )
  {
    cout << "substring \"" << g << "\" found at index "
      << pos - s.cbegin() << endl;
  }
}

original: The zip code of Braunschweig in Germany is 38100
lowered : the zip code of braunschweig in germany is 38100
uppered : THE ZIP CODE OF BRAUNSCHWEIG IN GERMANY IS 38100
substring "Germany" found at index 32

<example> algorithm-unique
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(int argc, char* argv[])
{
  // create constant string
  const string hello("Hello, how are you?");

  string s( hello.cbegin(), hello.cend() );

  for( char c : s )
    cout << c;

  cout << endl;

  // reverse a string
  reverse( s.begin(), s.end() );
  cout << "reversed     : " << s << endl;

  // sort
  sort( s.begin(), s.end() );
  cout << "sorted       : " << s << endl;

  // remove duplicates
  s.erase( unique( s.begin(), s.end() ), s.end() );
  cout << "no duplicates: " << s << endl;
}

Hello, how are you?
reversed     : ?uoy era woh ,olleH
sorted       :    ,?Haeehlloooruwy
no duplicates:  ,?Haehloruwy

<example>
algorithm-unique:
ForwardIterator unique (ForwardIterator beg, ForwardIterator end) 
ForwardIterator unique (ForwardIterator beg, ForwardIterator end, BinaryPredicate op)

The first form removes from the range [beg,end) all elements that are equal to the previous
elements. Thus, only when the elements in the sequence are 'sorted', or at least when all elements
of the same value are adjacent, does it remove all duplicates.

The second form removes all elements(elem) that follow an element e and for which the binary
predicate op(e,elem) yields true. For example:

#include <iostream>
#include <list>
#include <algorithm>

using namespace std;

template <typename T>
inline void PRINT_ELEMENTS( const T& coll, const std::string &optstr = "" )
{
  std::cout << optstr;

  for( const auto &elem : coll )
    std::cout << elem << ' ';

  std::cout << std::endl;
}

int main(int argc, char* argv[])
{
  // source data
  list<int> coll{ 1, 4, 4, 6, 1, 2, 2, 3, 1, 6, 6, 6, 5, 7, 5, 4, 4 };

  PRINT_ELEMENTS(coll);

  // remove elements if there was a previous greater element
  coll.erase (unique (coll.begin(), coll.end(),
        greater<int>()),
      coll.end());
  PRINT_ELEMENTS(coll);
}

1 4 4 6 1 2 2 3 1 6 6 6 5 7 5 4 4
1 4 4 6 6 6 6 7
      ^
The first 6(e) is greater than the following(elms) 1, 2, 2, 3, and 1, so all these elements are
removed.

In other words, the predicate is not used to compare an element with its predecessor; the element is
compared with the previous element(e) that was not removed


#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <locale>

using namespace std;

int main(int argc, char* argv[])
{

  string input;

  // do not skip whitespaces
  cin.unsetf(ios::skipws);

  // read all chars while compressing whitespaces
  const locale &loc(cin.getloc());
  unique_copy( istream_iterator<char>(cin), istream_iterator<char>(),
      back_inserter(input),
      [=] ( char c1, char c2 ) {
        return isspace(c1, loc) && isspace(c2, loc);
        });

  cout << input;
}


   ,?Haeehlloooruwy
 ,?Haeehlloooruwy

<Q> why still duplicates?


={============================================================================
*kt_dev_stl_071* string: stringstream and io stream

{stringstream}
Supports in-memory IO and read from or write to a string as if the string were an IO stream. In
other words, read(>>) and write(<<) to a stream are string manipulations. 

#include <sstream> add memebers as:

sstream strm(s);  strm is an sstream that holds a copy of the string s.
strm.str();       return a copy of the string that strm holds.
strm.str(s);      copies the string s into strm.

<example> istringstream example. file parsing example
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>

using namespace std;

// sample input line
// VOD.L 1 100 184.0 183.7
struct StockLine
{
  string  name;
  int     time;
  int     volume;
  float   high;
  float   low;
};

int main()
{
  std::string line;

  StockLine sline;

  std::ifstream ifs("input.txt", std::ifstream::in );

  if( ifs.is_open() )
  {
    getline( ifs, line );
  
    cout << "line: " << line << endl;

    istringstream iss(line);

    iss >> sline.name;
    iss >> sline.time;
    iss >> sline.volume;
    iss >> sline.high;
    iss >> sline.low;

    cout << "{ " 
      << sline.name << ", "
      << sline.time << ", "
      << sline.volume << ", "
      << showpoint 
      << sline.high << ", "
      << sline.low << " }" << endl;

    ifs.close();
  }
}

line: VOD.L 1 100 184.0 183.7
{ VOD.L, 1, 100, 184.000, 183.700 }

<example> ostrringstream example
ostringstream is useful when need to 'build up' our output a little at a time but do not want to print
the output until later.

for( const auto &entry : people ) 
{
  ostringstream formatted, badNums;

  for( const auto &nums : entry.phones ) 
  {
    if( !valid(nums))
    {
      badNums << " " << nums;             // string in badNums
    }
    else
    {
      formatted << " " << format(nums);   // writes to formatted's string
    }

    if( badNums.str().empty() )           // there are no bad numbers
      os << entry.name << " " << formatted.str() << endl;   // print the name and reformatted numbers
    else
      cerr << "input error: " << entry.name << " invalid numbers(s) " << badNums.str() << endl;
  }
}


={============================================================================
*kt_dev_stl_080* bitset

The bitset is a class template and is defined in bitset header. Like array class, has a 'fixed' size.
This is a exmple of a nontype template parameter and this is then considered part of the type.


{why-bitset}
Mostly to reduce space complexity. bitset < vector<bool> < bool array

#include <iostream>
#include <vector>
#include <bitset>

using namespace std;

int main()
{
  vector<bool> boolvec(32,1);
  bitset<32> bitvec(1U);
  bool bitbool[32];

  cout << "size: " << boolvec.size() << " sizeof : " << sizeof(boolvec) << endl;
  cout << "size: " << bitvec.size() << " sizeof : " << sizeof(bitvec) << endl;
  cout << "size: " << sizeof(bitbool) << endl;
}

size: 32 sizeof : 20
size: 32 sizeof : 4
size: 32

note: can use variable to set size of bitset.
const int x = 40;
bitset<x> bitvec(1U);


{bitset-ctors}

bitset<n> b;   
b has n bits; each bit is 0.

bitset<n> b(u);   
b is a copy of the n low-order bits of unsigned long long(ULL) value u.

<init-from-unsigned>
If the size of bitset > the number of bits in ULL, the remaining high-order are set to 0.
If the size of bitset < the number of bits in ULL, the only low-order bits are used. 

<init-from-string>
bitset<n> b(s, pos, m);
'b' is a copy of the 'm' characters from the 'string' starting at position 'pos'. s may contain only
0 and 1 and if contains any other characters, throws invalid_argument.

The characters with the lowest indices in the string correspond to the high-order bits and vice
versa.

bitset<n> b(cp, pos, m);
same as the above but copies from the character array to which cp points.


{bitset-operations}
<about-the-state-of-the-entire-bitset>
b.any();       is any bit in b on?           <DN> Do not use is?? style although returns a bool.
b.all();       are all the bits on?
b.none();      are no bits on?
b.count();     number of bits that are on.
b.size();      return the number of bits in b.

<change-the-bitset>
b.test(pos);   return true if bit at position is on.
b.set(pos, v); set the bit at pos to the bool value v.
b.set();       set all bits.
b.reset(pos);  turn off the bit at pos.
b.reset();     turn off all bits.
b.flip(pos);   change the state of the bit at pos.
b.flip();      flip all bits.

<subsctipt>
when read, that is const version, return a bool true if it's on. when write, which is non-const
return special type that let us change bit at pos.

bool ret = b[pos];
b[31] = 0;
b[0].flip();

<retrive-the-value>
These return a value that holds the same bit pattern. Can use ONLY IF the size of the bitset is less
than or equal to the corresponding size; UL or ULL. Otherwise, throw overflow_error exception.

b.to_ulong();
b.to_ullong();

<io-operations>
This read into a temp string and read until it has read as many as the size of bitset.

os << b;
is >> b;


{code-example}
Tested with GCC 4.6.3.

#include <iostream>
#include <bitset>

using std::cout;
using std::endl;
using std::bitset;

int main()
{
  bitset<32> bitvec(1U);

  bool is_set = bitvec.any();
  bool is_not_set = bitvec.none();
  bool all_set = bitvec.all();
  size_t on_bits = bitvec.count();
  size_t size = bitvec.size();

  cout << "is_set: " << is_set << ", is_not_set: " << is_not_set 
    << ", all_set: " << all_set << ", on_bits: " << on_bits
    << ", size: " << size << endl;

  bitvec.flip();
  bitvec.reset();
  bitvec.set();

  bitset<16> bitvec2("01011001011");
  cout << bitvec2 << endl;             <DN>

  return 0;
}

<example>
#include <iostream>
#include <bitset>
using namespace std;

int main() {
  unsigned short short11 = 1024;
  bitset<16> bitset11{short11};
  cout << bitset11 << endl;     // 0000010000000000

  unsigned short short12 = short11 >> 1;  // 512
  bitset<16> bitset12{short12};
  cout << bitset12 << endl;      // 0000010000000000

  unsigned short short13 = short11 >> 10;  // 1
  bitset<16> bitset13{short13};
  cout << bitset13 << endl;      // 0000000000000001

  unsigned short short14 = short11 >> 11;  // 0
  bitset<16> bitset14{short14};
  cout << bitset14 << endl;      // 0000000000000000
}

see the use of bitset and bitset only supports fixed size.  

{Q} How can use bitset with dynamic size since the size is constant expression? Options are:
0> vector<bool>
1> boost has a dynamic_bitset you can use.


={============================================================================
*kt_dev_stl_100* raii

{resource-acquisition-is-initialization} {resource-managing-class}
EC++13. Why raii? When use dynamic resource, client is fully resposible for releasing it after use
but it is very difficult to do 'bookkeeping' and problems are:

1. Very tricky to ensure that reference lifetime and the lifetime of the objects they refer to
match, especially when multiple pointers refer to the same object.

1.1. When the objects outlives, means resource leak. 

1.2. When the references outlives, means dangling reference. 

   o Double free that means to try to release what it do not own. For example, passing pointers via
   function calls or between components. 

   o Invalid access to objects which are released already. 

3. Interrupted code path due to exception. the usual path is interrupted and may cannot release it
as expected.

With raii, such as smart poitners, good things are: 

1. Make resource bookkeeping easier.
2. Can minimize client's burden to use resource properly. For example, raii with deleter.
3. Support sharing resources.

<exception-problem>
void f()
{
  // createInvestment() is factory-func that returns a pointer to dynamically created resource or
  // derived class. client must delete it after use

  Investment* pInv = createInvestment();

  // <key> problem: code that throws an exception that is not caught inside f. may not reach to
  // delete statement

  delete pInv;
}

How about using catch? 

void f()
{
  try {
    Investment* pInv = createInvestment();
  }
  catch( ... ) {
    delete pInv;
    throw;           // propagate exception to caller of f. rethrow.
  }

  delete pInv;
}

This approach has duplicated clean-up code. How to improve this? 


{raii} <raii-auto-ptr-approach> unique_ptr
Approaches to implement raii.

void f()
{
  // createInvestment() is factory-func that returns a pointer to dyn created resource
  // or derived class. client must delete it after use

  std::auto_ptr<Investment> pInv( createInvestment() );

  // code that throws an exception that is not caught inside f.

  // NO need to concern about free resource regardless of how control leaves a block
  // delete pInv;
}

To solve this, use resource-managing-class by putting reference(resource) 'inside' object and use
the fact that dtor is called automatically when object is destroyed; use object lifetime. As soon as
get resource, initialize a object. How? In a 'constructor' and hence called raii.

Acquire and initialize a resource-managing-class in the same statement. In other words, reference
should be 'encapsulated' in a object, resouce-managing-class, but raii do not exist to encapsulate
resource but to 'prevent' leak.

However, auto_ptr is not the best way to manage all dyn resources since it's limitation on copying
to make sure there's only one ptr to object. So containers of auto_ptr aren't allowed since STL
requires normal copying, deep-copy.

<raii-shared-ptr-approach>
Returning shared_ptr from a factory-func is a better way that supports normal copying than auto_ptr. 

// use the fixed type, Foo that's the underlying object.

std::shared_ptr<Foo> factory(T arg)
{
  return make_shared<Foo>(arg);
}

void use_factory(T arg)
{
  shared_ptr<Foo> p = factory(arg);
  // use p and deleted automatically.
}


{raii-for-resource-using-own-interface}
EC++14. There should be 'own' raii class for resource that uses own interface to create and delete
it because cannot use delete operator on it.

<example-mutex-lock> {auto-lock}
void lock(Mutex* pm);      // int pthread_mutex_lock( pthread_mutex_t *mptr); 
void unlock(Mutex* pm);

class Lock {
  public:
    'explicit' Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};


// client use

Mutex m;    // pthread_mutex_t m;
...
function()
{
  Lock ml(&m);
  ...
}

<example> # AUTOLOCK example
This is a case example seen in the code:

class CCAutoLock
{
  private:
    PCMutex* m_mutex;
  public:
    CCAutoLock(PCMutex* mutex) { m_mutex = mutex; m_mutex->Lock(); };
    ~CCAutoLock() { m_mutex->Unlock(); };
};

static PCMutex* g_mhdebug_mutex;
#define AUTOLOCK() CCAutoLock lock(&g_mhdebug_mutex)

void func()
{ 
  AUTOLOCK();
  ...
}


<Q> When there is a nested call tree used AUTOLOCK, will the lock be maintained? That is the lock of
func1 in the below example will BE VALID/LOCKED when func3 gets run? Will do. However, all three
uses the same lock then deadlock.

#include <iostream>

using std::cout; using std::endl;

class ALOCK {
  private:
    int m_num;
  public:
    ALOCK(int val):m_num(val) { cout << "ctor: ALOCK" << m_num << endl; }
    ~ALOCK() { cout << "dtor: ALOCK: " << m_num << endl; }
};

int func3()
{
  ALOCK LOCK(3);

  std::cout << "func 3" << std::endl;

  return 1;
}

int func2()
{
  ALOCK LOCK(2);

  std::cout << "func 2" << std::endl;

  return func3();
}

int func1()
{
  ALOCK LOCK(1);

  std::cout << "func 1" << std::endl;

  return func2();
}

int main()
{
  std::cout << "--{ main " << std::endl;

  func1();

  std::cout << "--} main " << std::endl;
}

Expected output?

--{ main
ctor: ALOCK1
func 1
ctor: ALOCK2
func 2
ctor: ALOCK3
func 3
dtor: ALOCK: 3
dtor: ALOCK: 2
dtor: ALOCK: 1
--} main 

<example-window-handle> MEC++09.
void displayInfo(const Information& info)
{
  WINDOW_HANDLE w ( createWindow() );

  ... display info in window w and exception can happen.

  destoryWindow(w);
}

class WindowHandle {
  public:
    WindowHandle( WINDOW_HANDLE handle ) : w(handle) {}
    ~WindowHandle() { destoryWindow(w); }

    // note: conversion-op
    operator WINDOW_HANDLE() { return w; }

  private:
    WINDOW_HANDLE w;

    // note: preventing-copies
    WindowHandle( const WindowHandle& );
    WindowHandle& operator=( const WindowHandle& );
};

void displayInfo(const Information& info)
{
  WindowHandle w ( createWindow() );

  ... display info in window w and exception can happen.
  ... displayWindow(w); coversion-op runs to convert WindowHandle to WINDOW_HANDLE

  // destoryWindow(w);
}

<example>
For example, if your object is an array allocated with new[], you have to define that the cleanup
performs a delete[]. note: this show that smart pointer is useful to lessen client's burden since
this can be done in smart pointer so client no need to know.


{raii-and-two-cautions}
The raii is great but there are two cautions when use raii.

1. When use resources which has own interface such as mutex and db connection, it can raise
exception in destructor. Since raii uses destructor, it can cause the problem is described in
{problem-of-exception-in-dtor}.

2. Acquire and initialize a raii in the same statement. In other words, use constructor. If not, can
be a problem as described in EC++17. <evaluation-order>

processWidget( std::shared_ptr<Widget>( new Widget ), priority() );

The problem is that there is no order in evaluating the arguments between new, shared_ptr
constructor, and priority() call. note: ctor is also under evaluation order here. So if complier
reorder calls as new, priority, and shared_ptr and priority raise exception then raii is broken.
Means newed pointer will be lost. The better way is:

std::shared_ptr<Widget> pw( new Widget );
processWidget( pw, priority() );


{raii-and-copy-support}
EC++14. What should happen when a Lock object, more generally raii object, is 'copied' or
'assigned'? There are four approaches depending on the type of resource.

<1> no copying
Likely to be true for Lock. See {preventing-copies} in *kt_dev_cpp_004* So,

class Lock: private Uncopyable {
  ...
};

<2> reference counting underlying resources
By using shared_ptr with delete, do not need to concern about clean up. 

<raii-vs-shared-pointer>
note: this is a decision point; use raii and concern about copy or use shared_ptr with deleter and
don't concern about copy. {pointerlike} in *kt_dev_cpp_004* For this example, use 'deleter' to use
unlock instead of default delete.

class Lock {
  public:
    explicit Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};

To:

class Lock {
  public:
    explicit Lock( Mutex* pm )
      :mutexPtr( pm, unlock )    // note: deleter
      {
        lock( mutexPtr.get() );  // to get law pointer assuming this is C interface
      }

  private:
    std::shared_ptr<Mutex> mutexPtr;
};

Set deleter using shared_ptr ctor in ctor init list. No longer declares a destructor.

<3> copy the underlying resource
This is {valuelike} in *kt_dev_cpp_004* Such as string class which uses heap for characters.
Copying the resource managing object should also copy the resource it wraps. deep-copy.

<4> transfer ownership of underlying resource
This is unique_ptr. Only one raii refers to a raw resource and when raii is copied ownership of the
resource is transfered. 


={============================================================================
*kt_dev_stl_101* smart pointers

{shared-ptr}
A pointer that implements the concept of 'shared' ownership so that the object and its associated
resources get released whenever the last reference to it gets destroyed. To perform this task in
more complicated scenarios, helper classes, such as weak_ptr, bad_weak_ptr, and
enable_shared_from_this are provided.

#include <memory> and default initialization is a nullptr. note that "T" but not "T*".

shared_ptr<T> plist;
shared_ptr<list<int>> plist;

<example>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

using namespace std;

int main()
{
  shared_ptr<string> pNico(new string("nico"));
  shared_ptr<string> pJutta(new string("jutta"));

  // capitalize the first char
  (*pNico)[0] = 'N';
  pJutta->replace(0,1,"J");

  // put them multiple times in a container
  vector<shared_ptr<string>> whoMadeCoffee;
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);

  // print all
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << endl; 

  // overwrite a name
  *pNico = "Nicolai";

  cout << "------------" << endl;

  // print all again
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << endl; 

  cout << "use_count: " << whoMadeCoffee[0].use_count() << endl;
}

Here use_count is 4.

<to-init>
shared_ptr<string> pNico(new string("nico"));            // OK
shared_ptr<string> pNico{new string("nico")};            // OK
shared_ptr<string> pNico = make_shared<string>("nico");  // OK
shared_ptr<string> pNico = new string("nico");           // NO

note: Because the constructor taking a pointer as single argument is 'explicit', can't use the
assignment notation here because that is considered to be an implicit conversion.

<make-shared>
This will allocate, initialize T and return a shared_ptr<T>

shard_prt<string> p4 = make_shared<string>(10, '9');
auto p6 = make_shared<vector<sting>>();      // create empty vector<string>

This is recommended because do alloc and bind at the same time. 

note: make_shared is faster and safer because it uses one instead of two allocations: one for the T
object and the other for the shared data that shared pointer uses to control the object

note: what's the use_count when uses make_shared?

int main()
{
  shared_ptr<string> spstr = make_shared<string>("this is string");

  cout << "spstr.count() : " << spstr.use_count() << endl;
}

spstr.count() : 1

This question comes from:

bsk.add_item( make_shared<Quote>("123", 45) );
// void add_item( const std::shared_ptr<Quote>& sale);

<reset-but-not-assign>
Why not assignment instead of using reset when assign a shared pointer with a new resource? Think
that operator=() is to decrease a reference counter of left and to increase the one of right.
However, cannot increase a count of new objects. 

To assign a new pointer to a sp, reset 'updates' reference count of sp. If sp is the only sp
pointing at its object, reset frees sp's existing object. If q is passed, makes sp points to q
otherwise makes sp nullptr. 

note: After all, reset() decrease count of left and set SP with the given pointer or nullptr.

sp.reset(); or sp.reset(q);

This is used to alloc a SP first and 'bind' it later.

shared_ptr<string> pNico4;
pNico4 = new string("nico");        // ERROR: no assignment for ordinary pointers
pNico4.reset(new string("nico"));   // OK

shared_ptr<int> p (new int(42));
p = new int(1024);                  // ERROR
p.reset( new int(1024));


<access-to-pointee>
The SP provide 'only' operators * and ->. Pointer arithmetic and operator [ ] are not provided. 

When shared_ptr points to memory block as shm example above, to access the memory, you have to use
get(), which yields the internal pointer wrapped by shared_ptr to provide the full pointer
semantics:

smp.get()[i] = i*42;

Thus, get() provides an alternative of calling:

(&*smp)[i] = i*42;

shared_ptr<vector<T>> pvec;
T var = (*pvec)[index];          // () is necessary since [] is higher than *


<check-users> do not rely on use_count()
To check how many users are. Return bool on whether there is the only user of this sp.

sp.unique();

Often to check whether we are the only user before changing the underlying object:

if( !p.unique() )
   p.reset( new string(*p) );    // we are not alone. allocate a new copy
*p += newValue;                  // we are the only pointer, okay to change

note: Like example in when-deletion-happens, use_count() may not be reliable since C++P 453 reads
"may be a slow operation, intended primarily for debugging purpose"


# copy-shared-ptr

auto p = make_shared<int>(42);

// p.use++
auto q(p);

// all prints 2
cout << "q: " << q.use_count() << ", p: " << p.use_count() << endl;

auto r = make_shared<int>(52);

// q.use++ and r.use--. destroies a object which r pointed. 
r = q;

// all prints 3
cout << "q: " << q.use_count() << ", p: " << p.use_count() << ", r: " << r.use_count() << endl;


<example> # StrBlob from p455 which show how to implement a new collection type to share.

This shows when shared_ptr is useful than own raii since this case don't have 'copy-controls' and
use syn versions but not a problem as it has only one member which is shared_ptr.

class StrBlob {
  friend class StrBlobPtr;

  public:
    typedef std::vector<std::string>::size_type size_type;

    StrBlob();
    StrBlob( std::initializer_list<std::string> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const std::string &t ) { data->push_back(t); }
    void pop_back();

    std::string& front();
    std::string& back();

    // return a copy object like iterator. vector[0] and vector[size] that is off-the-end
    //
    // note: how the weak pointer in StrBlobPtr get set from *this
    StrBlobPtr begin() { return StrBlobPtr(*this); }
    StrBlobPtr end() { reutn StrBlobPtr(*this, data->size(); }

  private:
    std::shared_ptr<std::vector<std::string>> data;
    void check( size_type i, const std::string &msg ) const;
};

# ctors

StrBlob::StrBlob: data( make_shared<vector<string>> ()) {}
StrBlob::StrBlob(initializer_list<string> il): data( make_shared<vector<string>> (il)) {}

# see return type is void when raise an exception.

void StrBlob::check( size_type i, const string &msg ) const
{
  if( i >= data->size() )
    throw out_of_range(msg);
}

string& StrBlob::front()
{
  check( 0, "front on empty StrBlob" );
  return data->front();
};

string& StrBlob::back()
{
  check( 0, "back on empty StrBlob" );
  return data->back();
};

string& StrBlob::pop_back()
{
  check( 0, "pop_back on empty StrBlob" );
  return data->pop_back();
};

{Q} are these all operation on vector? what will happen when calls on empty vector?


{weak-ptr}
The major reason to use shared_ptrs is to avoid taking care of the resources a pointer refers to.
Two points:

1. The weak_ptr do not participate in the reference count of shared_ptr and won't affect the
lifetime of the vector. 

2. However, can prevent the user from attempting to access a vector that no longer exist.

<use-cases>
shared_ptrs are provided to automatically release resources associated with objects no longer
needed. However, under certain circumstances, this behavior doesn't work or is not what is intended:

1. One example is 'cyclic' references. If two objects refer to each other using shared_ptrs, and you
want to release the objects and their associated resource if no other references to these objects
exist, shared_ptr won't release the data, because the use_count() of each object is still 1. You
might want to use ordinary pointers in this situation, but doing so requires explicitly caring for
and managing the release of associated resources.

2. Another example occurs when you explicitly want to share but 'not''own' an object. Thus, you have
the semantics that the lifetime of a reference to an object 'outlives' the object it refers to. Here,
shared_ptrs would never release the object, and ordinary pointers might not notice that the object
they refer to is not valid anymore, which introduces the risk of accessing released data.

<properties>
1. This class requires a shared pointer to get created.

2. Whenever the last shared pointer owning the object loses its ownership, any weak pointer
automatically becomes empty. 

3. Thus, besides default and copy constructors, class weak_ptr provides only a constructor taking a
shared_ptr.

4. You can't use operators * and -> to access a referenced object of a weak_ptr directly. Instead,
you have to 'create' a shared pointer out of it. This makes sense for two reasons:

4.1 Creating a shared pointer out of a weak pointer checks whether there is (still) an associated
object. If not, this operation will throw an exception or create an 'empty' shared pointer; what
exactly happens depends on the operation used.

4.2 While dealing with the referenced object, the shared pointer can't get released since shared
pointer was created out of weak pointer.

As a consequence, class weak_ptr provides only a small number of operations:

<example>
# cyclic reference. none of the Persons gets released, because each still has at least one shared
# pointer referring to it.

#include <iostream>
#include <string>
#include <vector>
#include <memory>

using namespace std;

class Person {
  public:
    string name;
    shared_ptr<Person> mother;
    shared_ptr<Person> father;
    vector<shared_ptr<Person>> kids;

    Person (const string& n,
        shared_ptr<Person> m = nullptr,
        shared_ptr<Person> f = nullptr)
      : name(n), mother(m), father(f) {
      }
    ~Person() {
      cout << "delete " << name << endl;
    }
};

shared_ptr<Person> initFamily (const string& name)
{
  shared_ptr<Person> mom(new Person(name+"'s mom"));
  shared_ptr<Person> dad(new Person(name+"'s dad"));
  shared_ptr<Person> kid(new Person(name,mom,dad));
  mom->kids.push_back(kid);
  dad->kids.push_back(kid);
  return kid;                                 // return kid
}

int main()
{
  {
    shared_ptr<Person> p = initFamily("nico");
    cout << "nico's family exists" << endl;
    cout << "- nico is shared " << p.use_count() << " times" << endl;
    cout << "- name of 1st kid of nico's mom: " << p->mother->kids[0]->name << endl;

    p = initFamily("jim");                     // note: this is when expect dtor happens but not.
    cout << "jim's family exists" << endl;
    cout << "- jim is shared " << p.use_count() << " times" << endl;
    cout << "- name of 1st kid of jim's mom: " << p->mother->kids[0]->name << endl;
  }
}

nico's family exists
- nico is shared 3 times
- name of 1st kid of nico's mom: nico
jim's family exists
- jim is shared 3 times
- name of 1st kid of jim's mom: jim
                                             mom dad
                                               \  \
mom [ 0, 0, kids ]   dad [ 0, 0, kids ]   kid [ m, f, kids ]
               \ (shared or weak)   \
               kid                  kid

Why there is no dtor for two family at all? When assign jim to p, lost nico family and even if p
hold jim family, no dtor since p's count is not 0.

Solution?

class Person {
  public:
    string name;
    shared_ptr<Person> mother;
    shared_ptr<Person> father;
    vector<weak_ptr<Person>> kids;           // note: weak pointer

    Person (const string& n,
        shared_ptr<Person> m = nullptr,
        shared_ptr<Person> f = nullptr)
      : name(n), mother(m), father(f) {
      }
    ~Person() {
      cout << "delete " << name << endl;
    }
};

By doing so, we can break the cycle of shared pointers. The output:

nicos family exists
- nico shared 1 times
- name of 1st kid of nicos mom: nico
delete nico
delete nicos dad
delete nicos mom
jims family exists
delete jim
delete jims dad
delete jims mom

<key>
As soon as we lose our handle into a kid created - either by assigning a new value to p or by
leaving main() - the kid's object of the family loses its last owner, which has the effect that both
parents lose their last owner. So 'all' objects, initially created by new, are deleted now so that
their destructors get called since weak pointer don't increase count.

# StrBlobPtr example
#
<- new container class ->  <- companion class like iterator ->
   StrBlob                    StrBlobPtr
   - shared_ptr               - weak_ptr
                     vector[]
                     - underlying container


class StrBlobPtr {
  public:
    StrBlobPtr(): curr(0) {}

    // note: wptr gets created out of shared ptr, a.data
    StrBlobPtr( StrBlob &a, size_t sz=0 ): wptr( a.data ), curr(sz) {}

    StrBlobPtr& incr();
    std::string& deref() const;

  private:
    std::shared_ptr<std::vector<std::string>> check( std::size_t, const std::string& ) const;
    std::weak_ptr<std::vector<std::string>> wptr;
    std::size_t curr;
};

// returns a shared_ptr to the vector if the check succeeds. Because a weak ptr does not participate
// in the reference count of its corresponding shared ptr, the vector might have been deleted. If
// the vector is gone, lock() will return a null pointer. 

std::shared_ptr<std::vector<std::string>>
StrBlobPtr::check( std::size_t i, const std::string &msg ) const
{
  // note: lock returns 'shared' pointer when the vector is still around. If it's gone, lock()
  // returns null.
  auto ret = wptr.lock();
  if(!ret)
    throw std::runtime_error("unbounded StrBlobPtr");

  if( i >= ret->size() )
    throw std::out_of_range(msg);

  // otherwise, return a shared ptr to the vector
  return ret;
}

std::string& StrBlobPtr::deref() const
{
  auto p = check( curr, "dereference past end");
  return (*p)[curr];    // () is necessary since [] is higher than *
}

// prefix: return a reference to the incremented object
StrBlobPtr& StrBlobPtr::incr() const
{
    // if curr already points past the end of the container, can't increment it.
    check( curr, "increment past end");
    curr++;
    return *this;
}


<Q> Expected output?
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <exception>
#include <stdexcept>

class StrBlob {
  public:
    typedef std::vector<std::string>::size_type size_type;

    StrBlob(std::string n);
    StrBlob(std::string n, std::initializer_list<std::string> il);
    ~StrBlob();

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const std::string &t) { data->push_back(t); }
    // void pop_back();
    // std::string front();
    // std::string back();

  private:
    std::string name;
    std::shared_ptr<std::vector<std::string>> data;
    void checks( size_type i, const std::string &msg) const;
};

StrBlob::StrBlob(std::string n): name(n), data( std::make_shared<std::vector<std::string>>() )
{
  std::cout << "ctor for " << name << std::endl;
}

StrBlob::StrBlob(std::string n, std::initializer_list<std::string> il): 
  name(n), data( std::make_shared<std::vector<std::string>>(il))
{
  std::cout << "ctor for " << name << std::endl;
}

StrBlob::~StrBlob()
{
  std::cout << "dtor for " << name << std::endl;
}

void StrBlob::checks( size_type i, const std::string &msg) const
{
  if( i >= data->size() )
    throw std::out_of_range(msg);
}

int main()
{
  std::cout << "-{ main ---" << std::endl;

  StrBlob b1("b1");
  {
    std::cout << "-b1 size: " << b1.size() << "-" << std::endl;

    StrBlob b2("b2", { "this", "is", "second blob" });
    b1 = b2;
    b2.push_back(". really?");

    std::cout << "-b2 size: " << b2.size() << "-" << std::endl;
  }

  std::cout << "-b1 size: " << b1.size() << "-" << std::endl;

  std::cout << "-} main ---" << std::endl;
}

$ ./a.out
-{ main ---
ctor for b1
-b1 size: 0-
ctor for b2
-b2 size: 4-
dtor for b2
-b1 size: 4-   // pointing to the same underlying vector.
-} main ---
dtor for b2    // why not b1? since name is copied using the syn copy assign in b1=b2.


<check-on-weak-pointer>
To use weak pointer approach, instead of calling

p->mother->kids[0]->name

we now have to insert lock() into the expression

p->mother->kids[0].lock()->name

This lock() yields a shared_ptr out of the weak_ptr the vector of kids contains. If this
modification is not possible, lock() yields an empty shared_ptr. In that case, calling operator * or
-> would cause 'undefined' behavior. note: using lock() is optional since still can use directly.

you have several options to check that the object still exist: 

1. You can call expired(), which returns true if the weak_ptr doesn't share an object any longer.
This option is equivalent to checking whether use_count() is equal to 0 but might be 'faster'.

2. You can explicitly convert a weak_ptr into a shared_ptr by using a corresponding shared_ptr
constructor. If there is no valid referenced object, this constructor will throw a bad_weak_ptr
exception. note: or use lock().

3. Use use_count. Not recommended since it is slow and not reliable.

<mis-use-shared-pointer> group notion
1. Cyclic reference shown above.

2. double delete. Have to ensure that only one 'group' of shared pointers owns an object.

int* p = new int;
shared_ptr<int> sp1(p);
shared_ptr<int> sp2(p);    // ERROR note: no compile error but error in double delete.

For this reason, you should always directly initialize a smart pointer the moment you create the
object with its associated resource:

shared_ptr<int> sp1(new int);
shared_ptr<int> sp2(sp1);  // OK

3. Indirectly double delete.
Suppose that we want to introduce a member function for a Person that creates both the reference
from a kid to the parent and a corresponding reference back:

// shared_ptr<Person> initFamily (const string& name)
// {
//   shared_ptr<Person> mom(new Person(name+"'s mom"));
//   shared_ptr<Person> dad(new Person(name+"'s dad"));
//   shared_ptr<Person> kid(new Person(name,mom,dad));
//   mom->kids.push_back(kid);
//   dad->kids.push_back(kid);
//   return kid;                                 // return kid
// }

shared_ptr<Person> initFamily (const string& name)
{
  shared_ptr<Person> mom(new Person(name+"'s mom"));
  shared_ptr<Person> dad(new Person(name+"'s dad"));
  shared_ptr<Person> kid(new Person(name));
  kid->setParentsAndTheirKids(mom,dad);
  return kid;                                 // return kid
}

void setParentsAndTheirKids (shared_ptr<Person> m = nullptr, shared_ptr<Person> f = nullptr) 
{
  mother = m;
  father = f;
  if (m != nullptr) {
    m->kids.push_back(shared_ptr<Person>(this)); // ERROR 
  }
  if (f != nullptr) {
    f->kids.push_back(shared_ptr<Person>(this)); // ERROR
  }
}

The problem is the creation of a shared pointer out of this pointer. Want to set the kids of members
mother and father. But to do that, we need a shared pointer to the kid, which we don't have at hand
since this pointer is not shared pointer. This then creates a 'new' group of owners which is
temporary. Two 'temporary' to kids and double delete in the end.

One way to deal with this problem is to pass the shared pointer to the kid as a third argument. But
the C++ standard library provides another option: class std::enable_shared_from_this<>.

<further-details>
1. make_shared is faster
note that shared_ptr<T>(new X(...)) performs two allocations: one for X and one for the control
block used, for example, by the shared pointer to manage its use count. 
  
Using make_shared<T>(...) instead is considerably faster, performing only one allocation, and safer
because a situation where the allocation of X succeeds but the allocation of the control block fails
cannot occur.

2. cast operation
note that using the ordinary cast operators is not possible, because it results in undefined
behavior:

shared_ptr<void> sp(new int);                // shared pointer holds a void* internally
...
shared_ptr<int>(static_cast<int*>(sp.get())) // ERROR: undefined behavior
static_pointer_cast<int*>(sp)                // OK


{unique-ptr} no copy support
A pointer that implements the concept of 'exclusive' ownership and is a kind of a smart pointer that
helps to avoid resource leaks when 'exceptions' are thrown. This was auto_ptr before C++11 and it has
only one user because 'no' ordinary copy and assign are supported. Only 'one' unique_ptr at a time
can point to a given object. So limit the use and it transfer ownerships.

note: In contrast to shared pointers, a 'minimum' space and time overhead is the focus of this class.

<why>
The unique_ptr tries to solve the exactly same problem of raii. Say that unique_ptr is one of raii
implementations.

<uses>
Pretty much same as shared_ptr.

std::unique_ptr<std::string> up(new std::string("nico"));
std::string* sp = up.release();  // "up" loses ownership

u.release() relinquishes control of the pointer u has held; returns the pointer u has held and makes
u null.

You can check whether a unique pointer owns an object by calling operator bool():

if (up) {   // if up is not empty
   std::cout << *up << std::endl;
}

u.reset() delete the object to which u points. same as u = nullptr.

#include <iostream>
#include <memory>

using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
  unique_ptr<Foo> p1(new Foo(1));
  unique_ptr<Foo> p2(new Foo(2));
  unique_ptr<Foo> p3(new Foo(3));

  p2.reset( p3.release() );
}

$ ./a.out 
Foo ctor(1)
Foo ctor(2)
Foo ctor(3)
Foo dtor(2)
Foo dtor(3)
Foo dtor(1)

<ownership>
The unique_ptr do not support copy so have to transfer ownership. Two options:

1. Use release and reset
The release() return the pointer it held and make the unique ptr null so using reset/release pair to
transfer ownerships.

// p1 becomes null. transfer ownership. Like copy ctor
unique_ptr<string> p2( p1.release() );

// reset 'delete' a mem that p2 points if P2 owned an object 'before' and set it with pointer p3
// points. transfer ownership. Like copy assign.
unique_ptr<string> p3( new string("Fred") ); 
p2.reset( p3.release() );

2. Use move semantics.

# copy

// initialize a unique_ptr with a new object
std::unique_ptr<ClassA> up1(new ClassA);

std::unique_ptr<ClassA> up2(up1);            // ERROR in compile since no copy support
std::unique_ptr<ClassA> up3(std::move(up1)); // copy the unique_ptr. transfer ownership of the unique_ptr

# assign

// initialize a unique_ptr with a new object
std::unique_ptr<ClassA> up1(new ClassA);
std::unique_ptr<ClassA> up2; // create another unique_ptr

up2 = up1;              // ERROR: not possible since no copy support
up2 = std::move(up1);   // assign the unique_ptr - transfers ownership from up1 to up2

<source-sink>
# sink: when called, gets ownership

void sink(std::unique_ptr<ClassA> up)  // sink() gets ownership. <Q> why not rvalue argument?
{
...
}

std::unique_ptr<ClassA> up(new ClassA);
...
sink(std::move(up));                   // up loses ownership


note: Q: why not rvalue argument? As with "copy-or-move", whether or not to use copy or move
constructor depends on function matching and that's why std::move() is used in sink() call.


# source: when exit, transfer ownership 

std::unique_ptr<ClassA> source()
{
   std::unique_ptr<ClassA> ptr(new ClassA);  // ptr owns the new object
   ...
   return ptr;                               // transfer ownership to calling function
}

void g()
{
  std::unique_ptr<ClassA> p;
  for (int i=0; i<10; ++i) {
    p = source(); // p gets ownership of the returned object
    // (previously returned object of f() gets deleted)
    ...
  }
} // last-owned object of p gets deleted

In any case, 'no' resource leak is possible. Even if an exception is thrown, any unique_ptr that owns
data ensures that this data is deleted.

note: Q: Why no std::move() in the return statement of source()?

<return-unique-ptr> move-operation
One exception to the rule that cannot copy a unique_ptr; that according to the language rules of
C++11, the compiler will try a 'move' automatically. 

unique_ptr<int> clone(int p) {
  ...
  // explicitly create a pointer
  return unique_ptr<int>( new int(p) );
}

unique_ptr<int> clone(int p) {
  unique_ptr<int> ret( new int(p) );
  ...
  // can return a copy of local object
  return ret;
}

<mis-use-unique-pointer>
# lost pointer

// WRONG. p2 won't free the memory and have lost the pointer.
p2.release();

// OK. but must remember to delete(p).
auto p = p2.release();

<use-as-members> exception-in-ctor
A unique_ptr helps to avoid resource leaks caused by exceptions thrown during the initialization of
an object. Note that destructors are called 'only' if any construction is completed. So, if an
exception occurs inside a constructor, destructors are called 'only' for objects that have been fully
constructed. This can result in resource leaks for classes with multiple raw pointers if during the
construction the first new was successful but the second was not.

class ClassB {
  private:
    ClassA* ptr1; // pointer members
    ClassA* ptr2;

  public:
    // constructor that initializes the pointers - will cause resource leak if second new throws
    ClassB (int val1, int val2)
      : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
      }

    // copy constructor - might cause resource leak if second new throws
    ClassB (const ClassB& x)
      : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
      }

    ~ClassB () {
      delete ptr1;
      delete ptr2;
    }
};

To avoid such a 'possible' resource leak,

class ClassB {
  private:
    std::unique_ptr<ClassA> ptr1; // unique_ptr members
    std::unique_ptr<ClassA> ptr2;

  public:
    // constructor that initializes the unique_ptrs - no resource leak possible
    ClassB (int val1, int val2)
      : ptr1(new ClassA(val1)), ptr2(new ClassA(val2)) {
      }

    // copy constructor - no resource leak possible
    ClassB (const ClassB& x)
      : ptr1(new ClassA(*x.ptr1)), ptr2(new ClassA(*x.ptr2)) {
      }

    // no destructor necessary
    // (default destructor lets ptr1 and ptr2 delete their objects)
};

note: First, that you can skip the destructor now because unique_ptr does the job for you. 
note: You also have to implement the copy constructor and assignment operator. By default, both
would try to copy or assign the members, which isn't possible. If you don't provide them, ClassB
also would provide only move semantics. <Q> by compiler? Here valuelike used.


<use-with-containers>
In auto_ptr, it is not possible to store an auto_ptr in a container, nor could we return one from a
function. See *kt_dev_stl_100* ref: can store unique_ptr in a container?


<get-vs-conversion>
EC++15. Have to provide access to raw underlying resource? There are two ways: implicit and explicit
conversion. Explicit conversion is safer. Said it converts an RAII object into the raw resource.

# explicit-conversion

Provide get() funtion.

std::shared_ptr<Investment> pInv( createInvestment());

int daysHeld( const Investment *pi );

int days = daysHeld( pInv.get() );

# implicit-conversion

Provide conversion operator. FontHandle is raw resource. This makes calling into C API easy and
natural but increase the chance of errors.

class Font {
  public:
    explicit Font( FontHandle fh ) : f(fh) {}

    ~Font() { releaseFont(f); }

    operator FontHandle() const
    { return f; }

  private:
    FontHandle f;
};

Font f( getFont() );
changeFontSize( f, newFontSize );

Font f1(getFont());
FontHandle f2 = f1;     // oops. meant "Font f2=f1";

# encapsulation

Is this contrary to encapsulation? true but raii donesn't exist to encapsulate something. It exist
to ensure that a particular action - release resource - takes place. Encapsulation is not for every
classes.



={============================================================================
*kt_dev_stl_102* smart pointers internal

{auto-ptr}
MEC++28 that is about auto_ptr. The typical implementation is:

template<class T>
class SmartPtr {
  public:
    // create a smart ptr to an obj given a dumb ptr to it. uninitialized ptr default to 0.
    SmartPtr( T* realPtr = 0 );

    // copy and assign a smart ptr
    SmartPtr( const SmartPtr& rhs );
    SmartPtr& operator=( cont SmartPtr& rhs );

    ~SmartPtr();

    // const. though it may lead to modification of what the pointer points to
    T* operator->() const;
    T& operator*() const;

  private:
    // dump(real) pointer
    T* pointee;
};

note: here copy and assign are public and if not allow those, should be private.

<encapsulation>
This smart pointer is testimony to the effectiveness of encapsulation:

1. Allow us to treat smart pointer as built-in pointer. Hide difference.
2. Other example. Handle local and remote DB access as if it is in the same place. Hide.

// template for smart ptrs to objects in a distributed DB
template<class T>
class DBPtr {
  public:
    // create a smart ptr to DB object given a local dumb pointer to it
    DBPtr(T *realPtr = 0);
    DBPtr(DataBaseID id);
    ...
};

class Tuple {
  ...
};

void editTuple(DBPtr<Tuple>& pt)
{
  do {
    pt->displayEditDialog();
  } while (pt->isValid() == false);
}

The tuple to be edited inside editTuple may be physically located on a remote machine, but the
programmer writing editTuple need not be concerned with such matters.

<copy-and-assign> ownership
How support copy semantics? Here implements ownership.

// the book said it has taken from stl
template<class T>
class auto_ptr {
  public:
    auto_ptr(T *ptr = 0): pointee(ptr) {}
    ~auto_ptr() { delete pointee; }

    auto_ptr(auto_ptr<T> &rhs)
    {
      // transfer ownership
      pointee = rhs.pointee;

      // no longer owns anything
      rhs.pointee = 0;
    }

    auto_ptr<T>& operator=( auto_ptr<T> &rhs )
    {
      // self-assign guard
      if( this == &rhs )
        return *this;

      // delete currently owned objects
      delete pointee;

      // transfer ownership
      pointee = rhs.pointee;
      rhs.pointee = 0;

      return *this;
    }

  private:
    T *pointee;
};

note: unconventional copy and assign operator since do not use const on parameters. These have to
change rhs so not use const.

<pass-by-value>
note: this is only for auto_ptr since compile error for unique_ptr for the same code.

Since ownership is transferred, passing auto_ptr by value is often a bad idea. Why?

void printNode( ostream& s, auto_ptr<TreeNode> p ) { s << *p; }

int main()
{
  auto_ptr<TreeNode> ptr( new TreeNode );
  ...
  printNode( cout, ptr );
  ...
}

In printNode call, call copy-ctor and means transfer ownership. When returns, dtor runs and delete
pointee. When main ends, dtor runs again and do double-free. So use reference:

void printNode( ostream& s, auto_ptr<TreeNode>& p ) { s << *p; }

See {the-rule-of-three} for <double-free> example.


<dereferencing-operators>

template< class T>
T& SmartPtr<T>::operator*() const
{
  // perform "smart pointer" processing
  return *pointee;
}

See return as reference because:

1. *pointee can be derived class in inheritance. To avoid sliced-off.
2. More efficient. No temp object.

For operator->(), the statement is interpreted by as:

pt->displayEditDialog(); -> (pt.operator->())->DisplayEditDialog();

So operator-> return either pointer or another smart pointer because can use -> on it.

template< class T>
T* SmartPtr<T>::operator->() const
{
  // perform "smart pointer" processing
  return pointee;
}

Both returns pointer and reference, virtual call through it works as supposed to. This will be fine
for most applications.

<nullness-of-smart-pointer>
If you want to push your smart pointers further, however, you must know more about dumb pointer
behavior and how smart pointers can and cannot emulate it. The followings are for this.

One of the things we cannot do is find out if a smart pointer is null:

SmartPtr<T> ptr;
...
if( ptr == 0 ) ...
if( ptr ) ...
if(!ptr) ...


How to solve? Add isNull member function? Not a solution since do not act like usual pointers.
Typical approach is to use conversion operators.

<approach-one> conversion-to-void
Use implicit conversion operator which is traditional. This is the way iostream uses so it is
possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
  public:
    operator void*(); // return 0 if smart pointer is null, non-zero otherwise.
    ...
};

note: Q: why void*? how it works?

This approach has a problem since it allows following: 

SmartPtr<Apple> pa; SmartPtr<Orange> po;

if( pa == po ) ...

Even if there is no operator== taking a SmartPtr<Apple> and a SmartPtr<Orange>, this compiles,
because both smart pointers can be implicitly converted into void* pointers, and there is a built-in
comparison function for built-in pointers.

<approach-two>
There are many variations and the other is:

template< class T>
class SmartPtr {
  public:
    bool operator!() const; // return true only if smart pointer is null
    ...
};

However, still not complete.

if(!ptn) {           // OK
  ...
}

if( ptn == 0 ) ...   // ERROR
if( ptn) ...


note: How about STL?

<get-dumb-pointer>
TODO: converting smart pointers to dumb pointers.

<smart-pointer-in-inheritance>
class MusicProduct {
  public:
    MusicProduct( const string& title );
    virtual void play() const = 0;
    virtual void displayTitle() const = 0;
    ...
};

class Cassette: public MusicProduct {
  ...
};

class CD: public MusicProduct {
  ...
};

void displayAndPlay( const MusicProduct* pmp, int numTimes )
{
  for( int i=1; i <= numTimes; ++i )
  {
    pmp->displayTitle();
    pmp->play();
  }
}

Cassette *funMusic = new Cassette("Jazz");
CD *nightmareMusic = new CD("Disco Hits of the 70s");

displayAndPlay( funMusic, 10 );
displayAndPlay( nightmareMusic, 0 );

No surprise here but if replace it with smart pointers, then compile errors:

void displayAndPlay( const SmartPtr<MusicProduct> &pmp, int numTimes );

SmartPtr<Cassette> funMusic(new Cassette("Jazz"));
SmartPtr<CD> nightmareMusic(new CD("Disco Hits of the 70s"));

displayAndPlay( funMusic, 10 );
displayAndPlay( nightmareMusic, 0 );

Why won't these compile? Template make a new class so inheritance no longer exist. Is it useful to
maintain inheritance when use template? If so, do further reading.


<smart-pointer-and-const>
For built-in:

const T* const ptr = ...;

For smart pointer:

const SmartPtr< T> ptr = &goodCD;  // const pointer
SmartPtr< const CD> ptr = &goodCD;

Unlike built-in, there is no conversion from non-const to ptr-to-const.

const CD* pConstCD = pCD;

Because template create new classes. If need more, see further.

<example>
#include <iostream>
#include <memory>

using namespace std;

class Foo {  
  public:
    void whoami() { cout << "this is foo" << endl; }
};

template<typename T>
class mauto_ptr {
  public:
    mauto_ptr(T* arg=nullptr) : pointee(arg) { cout << "ctor on :" << arg << endl; }
    ~mauto_ptr() { cout << "dtor on :" << pointee << endl; delete pointee; }

    // * operator
    mauto_ptr<T>& operator*() { return *pointee; }

    // -> operator
    T* operator->() { return pointee; }

    // copy ctor: transfer ownership
    mauto_ptr( mauto_ptr<T>& rhs )
    {
      pointee = rhs.pointee;
      rhs.pointee = nullptr;
    }

    // copy assign:
    mauto_ptr<T>& operator=( mauto_ptr<T>& rhs )
    {
      // self-assign guard
      if( this == &rhs )
        return *this;

      delete pointee;

      pointee = rhs.pointee;
      rhs.pointee = nullptr;

      return *this;
    }

  private:
    T* pointee;
};

void printptr( auto_ptr<int> p )
{
  cout << "value is: " << *p << endl;
}

int main()
{
  {
    cout << "{ start block: " << endl;
    mauto_ptr<Foo> p(new Foo());
    p->whoami();
    cout << "} end block: " << endl;
  }
}

{ start block: 
ctor on :0x9fdf008
this is foo
} end block: 
dtor on :0x9fdf008


={============================================================================
*kt_dev_stl_103* smart pointer internal: shared_ptr

MEC++29.

<motivation>
1. Once an object is allocated by calling new, it's crucial to keep track of who owns that object
because the owner - and only the owner - is responsible for calling delete on it. But ownership can
be transferred from object to object as a program runs by passing pointers as parameters, for
example, so keeping track of an object's ownership is hard work. Classes like auto_ptr can help with
this task, but experience has shown that most programs still fail to get it right. 

Reference counting eliminates the burden of tracking object ownership, because when an object
employs reference counting, it owns itself. When nobody is using it any longer, it destroys itself
automatically. Thus, reference counting constitutes a simple form of garbage collection.

To simplify the 'bookkeeping' 'who is allowed to delete what'. smart pointer is an example. This is
what most uses.

2. To share underlying objects. Save memory and runtime efficiency since use same memory and runs
fast on assumption that object will share values.


<problem-to-solve>
class String {
  public:
    String( const char *value="" );
    String& operator=( const String& rhs );
    ...
  private:
      char* data;
};

// handles self-assign but not exception safe
String& String::operator=( const String& rhs )
{
  if( this == &rhs ) return *this;

  delete[] data;
  data = new char[ strlen(rhs.dat) +1 ];
  strcpy( data, rhs.data );
  return *this;
}

With this implementation, use:

String a, b, c, d;
a = b = c = d = "Hello";

This means:

a -> "Hello"
b -> "Hello"
c -> "Hello"
d -> "Hello"

How can we make those share one copy of Hello?

<approach-one>
Need one reference count per string 'value', not one reference count per string object. That implies
a coupling between values and reference counts, so we'll create a class to store reference counts
and the values they track. StringValue. Since this is only to help implement String, nest it inside
in private and as a struct to give full access to String members but nothing else. note: said it's
worth knowing technique.

class String {
  public:
    String( const char *initValue = "" );
    String( const String& rhs );

    String& operator=( const String& rhs );
    ...
  private:
      struct StringValue {
        size_t refCount;
        char* data;
        StringValue( const char* initValue );
        ~StringValue();
      };

      StringValue* value;
};

// note: this StringValue implementation and default value of refCount
String::StringValue::StringValue( const char* initValue ) : refCount(1)
{
  data = new char[ strlen(initValue) +1 ];
  strcpy( data, initValue );
}

String::StringValue::~StringValue()
{
  delete [] data;
}

<implementation>
// String s("Hello");   // s -> 1 -> "Hello"
//
String::String( const char* initValue ) : value( 'new' StringValue( initValue )) {}

But cannot avoid duplication:

String s1("Hello");
String s2("Hello");

s1 -> 1 -> "Hello"
s2 -> 1 -> "Hello"

The solution is to create new one only when it is unique string and leave it as exercise. Does it
need for shared pointer?


// String S1(S2);
//
String::String( const String& rhs ) : value( rhs.value )
{
  ++value->refCount;
}

String::~String()
{
  if( --value->refCount == 0 ) delete value;
}

// S1 = S2; reference count of S1 is decresed by one and S2 is increased by one
//
String& String::operator=( const String& rhs )
{
  if( value == rhs.value ) return *this;

  if( --value->refCount == 0 ) delete value;

  value = rhs.value;
  ++value->refCount;

  return *this;
}

See efficiency here since there is no alloc, free, and copy.

<example> from pointerlike again.

class HasPtr {
  public:
    // see default arg and new size_t
    HasPtr(const std::string& s = std::string() ) : ps( new std::string(s)), i(0), use( new std::size_t(1) ) {}

    HasPtr(const HasPtr& p): ps( p.ps ), use( p.use ) { ++*use; };

    HasPtr& operator=(const HasPtr& p);
    ~HasPtr();
      
  private:
    std::string* ps;
    std::size_t* use; 
};

HasPtr::~HasPtr()
{
   if( --*use == 0 )             // note: --*use but not --use
   {
      delete ps; delete use;
   }
}

// Combine dtor and copy ctor. handle self-assign so no need to have if check.
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use;

  // lhs
  if( --*use == 0 )
  {
    delete ps; delete use;
  }

  ps = rhs.ps;
  use = rhs.use;

  return *this;
}

<example>
#include <iostream>
#include <memory>

using namespace std;

class Foo {  
  public:
    void whoami() { cout << "this is foo" << endl; }
};

template<typename T>
class mshared_ptr {
  public:
    mshared_ptr( T* arg = nullptr ): pointee(arg), prefcount( new size_t(1)) 
    { cout << "mshared ctor: " << endl; }

    ~mshared_ptr()
    { 
      if(--*prefcount == 0)
      {
        cout << "mshared dtor: " << endl; 
        delete pointee; delete prefcount;
      }
    }

    // copy ctor
    mshared_ptr( const mshared_ptr<T> & rhs )
    {
      pointee = rhs.pointee;
      prefcount = rhs.prefcount;
      ++*prefcount;
    }

    // copy assign
    mshared_ptr<T> & operator=( const mshared_ptr<T> & rhs )
    {
      // note: no need to have this for correctness but seems better to have for efficiency 
      if( this == &rhs ) return *this;

      ++*rhs.prefcount;

      if( --*prefcount == 0 )
      {
        delete pointee; delete prefcount;
      }

      pointee = rhs.pointee;
      prefcount = rhs.prefcount;

      return *this;
    }

    // * operator
    T& operator*() { return *pointee; }

    // -> operator
    T* operator->() { return pointee; }

    operator void*() { return pointee === nullptr ? (void*)0 : 1; }

    size_t use_count() { return *prefcount; };

  private:
    T* pointee;
    size_t* prefcount;
};

int main()
{
  {
    cout << "{ start block: " << endl;
    mshared_ptr<Foo> p(new Foo());
    cout << "  use_count: " << p.use_count() << ", p->whoami: ";
    p->whoami();

    {
      mshared_ptr<Foo> q(p);
      cout << "  use_count: " << q.use_count() << ", q->whoami: ";
      q->whoami();
    }

    cout << "  use_count: " << p.use_count() << ", p->whoami: " << endl;

    cout << "} end block: " << endl;
  }

  cout << "} end main: " << endl;
}

{ start block: 
mshared ctor: 
  use_count: 1, p->whoami: this is foo
  use_count: 2, q->whoami: this is foo
  use_count: 1, p->whoami: 
} end block: 
mshared dtor: 
} end main: 


={============================================================================
*kt_dev_stl_104* smart pointers examples

If you want reference semantics in STL containers - whether because copying elements is expensive or
because identical elements will be shared by different collections - you should use a smart pointer
class that avoids possible errors. In addition, using a reference wrapper is possible.

<example> algorithm-find_if
#include <iostream>
#include <iterator>
#include <set>
#include <deque>
#include <string>
#include <memory>
#include <algorithm>

using namespace std;

template <typename T>
inline void printItems( const std::string &msg, const T& coll )
{
  std::cout << msg;

  for( const auto &elem : coll )
    std::cout << ' ' << elem->getName() << ": " << elem->getPrice() << std::endl;
}

class Item 
{
  private: 
    string name;
    float price;

  public:
    Item( const string &n, float p = 0 ) : name(n), price(p) { }

    string getName() const { return name; }
    void setName( const string & n ) { name = n; }
    float getPrice() const { return price; }
    float setPrice( float p ) { price = p; }
};

int main()
{
  typedef shared_ptr<Item> ItemPtr;

  set<ItemPtr> allItems;
  deque<ItemPtr> bestsellers;

  // insert objects into collections
  bestsellers = { ItemPtr(new Item("Kong Yize",20.10)),
    ItemPtr(new Item("A Midsummer Nights Dream",14.99)),
    ItemPtr(new Item("The Maltese Falcon",9.88)) };

  allItems = { ItemPtr(new Item("Water",0.44)),
    ItemPtr(new Item("Pizza",2.22)) };

  allItems.insert(bestsellers.begin(),bestsellers.end());

  // print
  printItems( "best sellers: ", bestsellers );
  printItems( "all         : ", allItems );

  cout << endl;

  // double price of bestsellers
  for_each( bestsellers.begin(), bestsellers.end(),
      [] (shared_ptr<Item> &elem) {
        elem->setPrice(elem->getPrice()*2);
        });

  // replace 2nd bestseller by 1st item with name "Pizza"
  //
  // The following causes compile error. why?
  //      [] (shared_ptr<Item> &elem) {
  // <key> Adding 'const' solves.
  bestsellers[1] = *(find_if( allItems.begin(), allItems.end(),
        [] (const shared_ptr<Item> &elem) {
          return elem->getName() == "Pizza";
          }));

  bestsellers[0]->setPrice(44.77);

  // print
  printItems( "best sellers: ", bestsellers );
  printItems( "all         : ", allItems );
}

best sellers:  Kong Yize: 20.1
 A Midsummer Nights Dream: 14.99
 The Maltese Falcon: 9.88
all         :  Kong Yize: 20.1
 A Midsummer Nights Dream: 14.99
 The Maltese Falcon: 9.88
 Water: 0.44
 Pizza: 2.22

best sellers:  Kong Yize: 44.77
 Pizza: 2.22
 The Maltese Falcon: 19.76
all         :  Kong Yize: 44.77
 A Midsummer Nights Dream: 29.98
 The Maltese Falcon: 19.76
 Water: 0.44
 Pizza: 2.22


={============================================================================
*kt_dev_stl_105* make_shared

#include<iostream>
#include<string>
#include<memory>

using namespace std;

class XX
{
    public:
        XX(int value): price(value) {}
        int get() { return price; }

    private:
        int price;
};

int main()
{
    XX x(100);
    cout << "XX get: " << x.get() << endl;

    shared_ptr<XX> sp1 = make_shared<XX>(x);
    cout << "sp1->get: " << sp1->get() << endl;
    cout << "sp1.count() : " << sp1.use_count() << endl;
}

Q: Why does this work when XX do not have XX::XX(XX &)?
A: Since XX's copy constructor is used and if there isn't, will be synthesized.

From shared_ptr.h

/**
 *  @brief  Create an object that is owned by a shared_ptr.
 *  @param  __args  Arguments for the @a _Tp object's constructor.
 *  @return A shared_ptr that owns the newly created object.
 *  @throw  std::bad_alloc, or an exception thrown from the
 *          constructor of @a _Tp.
 */
template<typename _Tp, typename... _Args>
  inline shared_ptr<_Tp>
  make_shared(_Args&&... __args)
{
    typedef typename std::remove_const<_Tp>::type _Tp_nc;
    return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
            std::forward<_Args>(__args)...);
}


={============================================================================
*kt_dev_stl_106* when to use which container

However, it contains 'general' statements that might not fit in reality. For example, if you manage
only a few elements, you can ignore the complexity because short element processing with linear
complexity is better than long element processing with logarithmic complexity (in practice, "few"
might become very large here).  

As a supplement to the table, the following rules of thumb might help:

1. By 'default', you should use a 'vector'. It has the simplest internal data structure and provides
random access. Thus, data access is convenient and flexible, and data processing is often fast
enough.

2. If you insert and/or remove elements often at the beginning and the end of a sequence, you should
use a 'deque'. You should also use a deque if it is important that the amount of internal memory used
by the container shrinks when elements are removed. Also, because a vector usually uses one block of
memory for its elements, a deque might be able to contain more elements because it uses several
blocks. <TODO> does deque do memory shrink better than vector?

3. If you insert, remove, and move elements often in the middle of a container, consider using a
'list'. Lists provide special member functions to move elements from one container to another
in constant time. Note, however, that because a list provides no random access, you might
suffer significant performance penalties on access to elements inside the list if you have only the
beginning of the list.

Like all node-based containers, a list doesn't invalidate iterators that refer to elements, as long
as those elements are part of the container. Vectors invalidate all their iterators, pointers, and
references whenever they exceed their capacity and part of their iterators, pointers, and references
on insertions and deletions. Deques invalidate iterators, pointers, and references when they change
their size, respectively.

4. If you need a container that handles 'exceptions' so that each operation either succeeds or has no
effect, you should use either a list or an associative/unordered container. note: all node-based

5. If you often need to 'search' for elements according to a certain criterion, use an 'unordered'
set or multiset that hashes according to this criterion. However, hash containers have no ordering,
so if you need to rely on element order, you should use a set or a multiset that sorts elements
according to the search criterion.

6. To process key/value 'pairs', use an unordered (multi)map or, if the element order matters, a
(multi)map.

7. If you need an 'associative' array, use an unordered map or, if the element order matters, a map.

8. If you need a 'dictionary', use an unordered multimap or, if the element order matters, a multimap.


{problem}
A problem that is 'not' easy to solve is how to sort objects according to two different sorting
criteria.

The automatic sorting of associative containers does 'not' mean that these containers perform better
when sorting is needed. This is because an associative container sorts 'each' time a new element
gets inserted. An often 'faster' way is to use a sequence container and to sort 'all' elements
'after' they are all inserted, by using one of the several sort algorithms

<set-version>
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <set>

using namespace std;

int main()
{
  // create a string set - initialized by all words from standard input
  set<string> coll((istream_iterator<string>(cin)), istream_iterator<string>());

  // print all elements
  copy (coll.cbegin(), coll.cend(), ostream_iterator<string>(cout, "\n"));
}

<vector-version> algorithm-unique_copy
#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include <vector>

using namespace std;

int main()
{
  // create a string vector - initialized by all words from standard input
  vector<string> coll((istream_iterator<string>(cin)), istream_iterator<string>());

  // sort elements
  sort (coll.begin(), coll.end());

  // print all elements ignoring subsequent duplicates
  copy (coll.cbegin(), coll.cend(), ostream_iterator<string>(cout, "\n"));
  // unique_copy (coll.cbegin(), coll.cend(), ostream_iterator<string>(cout, "\n"));
}

<result>
When I tried both programs with about 350,000 strings on one system, the 'vector' version was
approximately 10% 'faster'. Inserting a call of reserve() made the vector version 5% faster. 

Allowing duplicates - using a multiset instead of a set and calling copy() instead of unique_copy(),
respectively - changed things dramatically: The vector version was more than 40% faster. 
note: make both run fast

However, on 'another' system, the vector versions were up to 50% slower. These measurements are not
representative, but they show that it is often 'worth' trying 'different' ways of processing
elements.

In practice, predicting which container type is the best is often difficult. 

The big 'advantage' of the STL is that you can try different versions 'without' much effort. The
major work - implementing the different data structures and algorithms - is done. You have only to
combine them in a way that is best for you.


={============================================================================
*kt_dev_stl_107* smart pointers: deleter

{default-deleter}
The deleter is callable and is called when is needed. Here the excerpt from stl unique_ptr.h. See
default_delete is overload operator().

/// Primary template, default_delete.
template<typename _Tp>
struct default_delete
{
    constexpr default_delete() noexcept = default;

    template<typename _Up, typename = typename
        std::enable_if<std::is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

    void
        operator()(_Tp* __ptr) const
        {
            static_assert(sizeof(_Tp)>0, "can't delete pointer to incomplete type");

            delete __ptr;
        }
};

/// 20.7.12.2 unique_ptr for single objects.
template <typename _Tp, typename _Dp = default_delete<_Tp> >
class unique_ptr
{
    class _Pointer 
    { 

    };

    typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;
    __tuple_type                                      _M_t;

    explicit
        unique_ptr(pointer __p) noexcept
        : _M_t(__p, deleter_type())                      // note: default ctored deleter
        { static_assert(!std::is_pointer<deleter_type>::value,
                "constructed with null function pointer deleter"); }

    // Destructor.
    ~unique_ptr() noexcept
    {
        auto& __ptr = std::get<0>(_M_t);
        if (__ptr != nullptr)
            get_deleter()(__ptr);                        // note: call deleter()
        __ptr = pointer();
    }

    deleter_type&
        get_deleter() noexcept
        { return std::get<1>(_M_t); }
}


{set-own-deleter}
SP is exception safe. However, how can we make it sense when using resources which have own
interfaces since default deleter is delete op.

void f()
{
  shared_ptr<int> sp (new int(42) );
  // use sp
  // exception occur and no catch
}

void f()
{
  connection c = connect(&d);
  // use connection
  // if exception occur, no way to close conn
}

User can set deleter of shared_ptr rather than the default deleter, delete.

note: this deleter must take a 'single' argument of type T*. otherwise, compile error
void end_connection( connection *p ) { disconnect(*p); }

void f()
{
  connection c = connect(&d);
  shared_ptr<connection> p (&c, end_connection);
  // use connection
  // if exception occur
}


{when-deletion-happens}
Such a deletion does not necessarily have to happen at the end of the scope. For example, assigning
the nullptr to pNico or resizing the vector so that it contains only the first two elements and
would delete when the last owner of the string set to nullptr, pNico.

#include <iostream>
#include <memory>
#include <string>
#include <vector>

using namespace std;

void delete_mesg( string *str )
{
  cout << "deleter called: " << *str << endl;
}

int main()
{
  shared_ptr<string> pNico(new string("nico"), delete_mesg );
  shared_ptr<string> pJutta(new string("jutta"), delete_mesg);

  // lambda
  // shared_ptr<string> pJutta(new string("jutta"), 
  //     [](string *p) {
  //     cout << "delete " << *p << endl; 
  //     delete p;
  //     });

  // capitalize the first char
  (*pNico)[0] = 'N';
  pJutta->replace(0,1,"J");

  // put them multiple times in a container
  vector<shared_ptr<string>> whoMadeCoffee;
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);
  whoMadeCoffee.push_back(pJutta);
  whoMadeCoffee.push_back(pNico);

  // print all
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << "    "; 

  // overwrite a name
  *pNico = "Nicolai";

  cout << endl << "------------" << endl;

  // print all again
  for( auto ptr : whoMadeCoffee )
    cout << "*ptr: " << *ptr << "    "; 

  cout << endl;
  cout << "use_count(jutta): " << whoMadeCoffee[0].use_count() << endl;

  pJutta = nullptr;

  cout << "use_count(jutta): " << whoMadeCoffee[0].use_count() << endl;
  cout << "use_count(nico ): " << whoMadeCoffee[2].use_count() << endl;

  whoMadeCoffee.resize(2);
  cout << "resize to 2 " << endl;

  pNico = nullptr;

  cout << "use_count(jutta): " << pJutta.use_count() << endl;
  cout << "use_count(nico ): " << pNico.use_count() << endl;
}


kt@kt-ub-vb:~/work$ ./a.out 
*ptr: Jutta    *ptr: Jutta    *ptr: Nico    *ptr: Jutta    *ptr: Nico    
------------
*ptr: Jutta    *ptr: Jutta    *ptr: Nicolai    *ptr: Jutta    *ptr: Nicolai    
use_count(jutta): 4
use_count(jutta): 3              // after set nullptr
use_count(nico ): 3
resize to 2 
deleter called: Nicolai          // when set nullptr
use_count(jutta): 0              // why? see "check-users"
use_count(nico ): 0
deleter called: Jutta


# delete with array (p80, revisit when necessary)


# delete with other destruction policy 
When resource cleaning up is more complicated than a single function call, needs destruction policy.
note: this examples shows how function object is useful.
note: the passed deleter is not allowed to throw exceptions.

// first example: to ensure that a temporary file gets removed when the last reference to it gets
// destroyed. see function object that handles more than a single argument passed in deleter.

#include <string>
#include <fstream>   // for ofstream
#include <memory>    // for shared_ptr
#include <cstdio>    // for remove()

class FileDeleter
{
  private:
    std::string filename;
  public:
    FileDeleter (const std::string& fn)
      : filename(fn) {
      }
    void operator () (std::ofstream* fp) {      // T is ofstream and T*
      fp->close();                              // close.file
      std::remove(filename.c_str());            // delete file
    }
};

int main()
{
  // create and open temporary file:
  std::shared_ptr<std::ofstream> fp(new std::ofstream("tmpfile.txt"),
      FileDeleter("tmpfile.txt"));
  ...
}

// second example: to use shared_ptrs to deal with shared memory

#include <memory> // for shared_ptr
#include <sys/mman.h> // for shared memory
#include <fcntl.h>
#include <unistd.h>
#include <cstring> // for strerror()
#include <cerrno> // for errno
#include <string>
#include <iostream>

class SharedMemoryDetacher
{
  public:
    void operator () (int* p) {
      std::cout << "unlink /tmp1234" << std::endl;
      if (shm_unlink("/tmp1234") != 0) {
        std::cerr << "OOPS: shm_unlink() failed" << std::endl;
      }
    }
};

std::shared_ptr<int> getSharedIntMemory (int num)
{
  void* mem;
  int shmfd = shm_open("/tmp1234", O_CREAT|O_RDWR, S_IRWXU|S_IRWXG);
  if (shmfd < 0) {
    throw std::string(strerror(errno));
  }
  if (ftruncate(shmfd, num*sizeof(int)) == -1) {
    throw std::string(strerror(errno));
  }
  mem = mmap(nullptr, num*sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);
  if (mem == MAP_FAILED) {
    throw std::string(strerror(errno));
  }

  // note: here
  return std::shared_ptr<int>(static_cast<int*>(mem), SharedMemoryDetacher());
}

int main()
{
  // get and attach shared memory for 100 ints:
  std::shared_ptr<int> smp(getSharedIntMemory(100));

  // init the shared memory
  for (int i=0; i<100; ++i) {
    smp.get()[i] = i*42;               // see get
  }
  // deal with shared memory somewhere else:
  ...

  std::cout << "<return>" << std::endl;
  std::cin.get();

  // release shared memory here:
  smp.reset();
  ...
}


{deleter-form}
As with shared_ptr, can set 'deleter' but use different form. p678 said that:

By binding the deleter at compile time, unique_ptr avoids the run-time cost of an indirect call to
its deleter. In contrast, by binding at run time, shared_ptr makes it easier for users to override
the deleter. (significant cost?)

shared_ptr<connection> p (&c, end_connection);
unique_ptr<connection, decltype(end_connection)*> p ( &c, end_connection );

note: C++P 678 says that shared_ptr stores deleter indirectly and has a cost of indirect call to
support any type which can be known runtime.

template<typename _Tp1, typename _Deleter> 
   __shared_ptr(_Tp1* __p, _Deleter __d)    // from ctor

  ...

   __d(__p); // Call _Deleter on __p.  // from other function


={============================================================================
*kt_dev_stl_110* allocator

(From Primus?)
This is analogous to allocator.construct() but one important difference: allocator.construct()
must use memory allocated by the 'same' allocator but need not point to memory by operator
new and refer to dynamic memory.

{allocator}
The C++ standard library uses special objects to handle the allocation and deallocation of memory.
Such objects are called allocators. They represent a special "memory model" and are used as an
abstraction to translate the need to use memory into a raw call for memory. The use of different
allocator objects at the same time allows you to use different memory models in a program.

Originally, allocators were introduced as part of the STL to handle the nasty problem of different
pointer types on PCs (such as near, far, and huge pointers). Now, allocators serve as a base for
technical solutions that use certain memory models, such as shared memory, garbage collection, and
object-oriented databases, without changing the interfaces.

The 'default' allocator is used as the default value everywhere an allocator can be used as an
argument.

#include <memory>

template<class T>
struct allocator;

template<>
struct allocator<void>;

Provides a way to decouple alloc/dealloc and construction/destruction and allows finer control. For
example, allocate big memory and pay the overhead of construction 'only' when needed.

note: The allocator provides 'type-aware' allocation and returns 'unconstructed' memory while
operator-new uses only 'size'. Be careful since using unconstructed memory is 'undefined'.

allocator<string> alloc;
auto const p = alloc.allocator(n);

// calls ctor. From C++11, supports many ctors of the 'type' The first argument to construct() must
// be a pointer to unconstructed space allocated by allocate(). The second and subsequent argument
// determine ctor to use.
alloc.construct(p++);
alloc.construct(p++, 10, 'c');
alloc.construct(p++, "hi");

// calls dtor
alloc.destory(p);

// size must match
alloc.deallocate(p, n);

Some needs to allocate a varying amount of storage at run time and use a library container.
However, some needs to do their 'own' allocation. Such classes must define own copy controls. As an
example, see StrVec in Primers p524.

<companion-algorithms>
The library defines two that calls 'construct' on each element in uninitialsed memory.

uninitialized_copy(b, e, b2);
copies elements from the input range by iterator b and e into 'unconstructed' memory by iterator b2.
Like copy, return its incremented destination iterator.

uninitialized_copy_n(b, n, b2);
copies n elements from b to b2.

uninitialized_fill(b, e, t);
construct objects in raw memory denoted by b and e as a copy of t.

uninitialized_fill_n(b, n, t);

auto p = alloc.allocate( vi.size()*2 );
auto q = uninitialized_copy( vi.begin(), vi.end(), p );
uninitialized_fill_n( q, vi.size(), 42 );


={============================================================================
*kt_dev_stl_111* gcc stl impl files

/usr/include/c++/4.4.4

algorithm        cinttypes           cstddef          exception            iostream  queue         thread
array            ciso646             cstdint          exception_defines.h  istream   random        tr1
backward         climits             cstdio           exception_ptr.h      iterator  ratio         tr1_impl
bits             clocale             cstdlib          ext                  limits    regex         tuple
bitset           cmath               cstring          fenv.h               list      set           typeinfo
c++0x_warning.h  complex             ctgmath          forward_list         locale    sstream       type_traits
cassert          complex.h           ctime            fstream              map       stack         unordered_map
ccomplex         condition_variable  cwchar           functional           memory    stdatomic.h   unordered_set
cctype           csetjmp             cwctype          i686-redhat-linux    mutex     stdexcept     utility
cerrno           csignal             cxxabi-forced.h  initializer_list     new       streambuf     valarray
cfenv            cstdarg             cxxabi.h         iomanip              numeric   string        vector
cfloat           cstdatomic          debug            ios                  ostream   system_error  x86_64-redhat-linux
chrono           cstdbool            deque            iosfwd               parallel  tgmath.h

bits dir has actual STL files.


={============================================================================
*kt_dev_stl_200* ref: can store unique_ptr in a container?

For unique-ptr,  no copy support and has to transfer ownership. For containers, the element to store
had to be copyable.

<try>
#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
  unique_ptr<Foo> p1( new Foo(1) );
  unique_ptr<Foo> p2( new Foo(2) );
  unique_ptr<Foo> p3( new Foo(3) );
  unique_ptr<Foo> p4( new Foo(4) );

  // put them into a container
  vector< unique_ptr<Foo>> pvec;
  pvec.push_back(p1);
}

error: use of deleted function std::unique_ptr<_Tp, _Dp>::unique_ptr(const std::unique_ptr<_Tp,
_Dp>&) [with _Tp = Foo, _Dp = std::default_delete<Foo>, std::unique_ptr<_Tp, _Dp> =
std::unique_ptr<Foo>]

This error means that there is no copy ctor since unique_ptr do not support copy. Hence deleted. So
cannot store unique_ptr in a container? No can since C++11 since not copyable but moveable.

note: Even if unique_ptr is copyable, it's difficult to get the expected result right. For example,
when get a pointer from a container and use it which means pointer in a container is no longer
vaild. What will happen when container destructor runs?

http://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers/

C++11: using unique_ptr with standard library containers
June 20th, 2012 at 8:46 pm

Before C++11, the only "smart" pointer available in the standard C++ library was auto_ptr. Alas,
auto_ptr isn't very smart. It has very problematic copy semantics that make it difficult to use in
several important scenarios. In particular, auto_ptr can not be used with standard containers and
algorithms!

To quote from Herb Sutter:

auto_ptr is most charitably characterized as a valiant attempt to create a unique_ptr before C++ had
move semantics. auto_ptr is now deprecated, and should not be used in new code. When you get a
chance, try doing a global search-and-replace of auto_ptr to unique_ptr in your code base

So what is this unique_ptr thing, and what can it be used for?

Basic capabilities

To put it simply, unique_ptr 'should' be the 'default' smart pointer used by new C++ code, replacing
"raw" pointers as much as possible. unique_ptr cleanly represents the single ownership idiom - it
cannot be copied and assigned, and it cleans up the pointed object when it's destructed.

Here's some code to demonstrate this [1]:

#include <iostream>
#include <cstdlib>
#include <memory>          // note header

using namespace std;

struct Foo {
    Foo() {cerr << "Foo [" << this << "] constructed\n";}  // note use of this to get address 
    virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

int main(int argc, char** argv) 
{
  // .. some code
  {
    unique_ptr<Foo> fp(new Foo());

    unique_ptr<Foo> fp2(fp);    // ERROR! can't copy unique_ptr
    unique_ptr<Foo> fp3;
    fp3 = fp;                   // ERROR! can't assign unique_ptr

    cerr << "Exiting scope\n";
  } // fp will be destroyed, and will destruct the pointed object

  return 0;
}

The lines marked with the ERROR! comment won't actually compile. The compiler will complain saying
something like:

error: use of deleted function
 'std::unique_ptr<_Tp, _Dp>::unique_ptr(const std::unique_ptr<_Tp, _Dp>&)

If these two lines are commented out, the code will print:

Foo [0x845010] constructed
Exiting scope
Foo [0x845010] destructed

In addition to managing the pointed object's lifetime, unique_ptr provides the other expected
capabilities of a smart pointer: it overloads operator* and operator->, provides a means to obtain
the raw pointer (get), to relinquish control of the pointed object (release), and to replace the
object it manages (reset). It also lets you customize the way the pointed object is deleted (if you
don't want it to be the default delete operator), and has some other niceties - just consult
your favorite C++ reference.

What about sources and sinks?

In this article I want to focus not on the grocery list of unique_ptr's features, but its
interesting move semantics. Specifically, given that unique_ptr forbids copying and assignment, one
may wonder how it can fit in the source and sink idiom which is so useful for smart pointers.

In other words, we'd like this to work:

// source creates a Foo object, wraps it in a smart pointer for safety and provides the result to
// the caller, giving it the ownership of the object in the process.
unique_ptr<Foo> source();

// sink gets a Foo object wrapped in a smart pointer for safety. It also assumes ownership of the
// provided object.
void sink(unique_ptr<Foo> p);

And in C++11, it does! Even though unique_ptr can't be copied, it can be 'moved'. Move semantics are a
perfect match for unique_ptr - the two concepts reinforce each other. With move semantics,
unique_ptr is both safe and efficient. Here's some code to demonstrate this:

#include <iostream>
#include <cstdlib>
#include <memory>

using namespace std;

struct Foo {
  Foo() {cerr << "Foo [" << this << "] constructed\n";}
  virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

void sink(unique_ptr<Foo> p) {
  cerr << "Sink owns Foo [" << p.get() << "]\n";
}

unique_ptr<Foo> source() {
  cerr << "Creating Foo in source\n";
  return unique_ptr<Foo>(new Foo);
}

int main(int argc, char** argv) {
  cerr << "Calling source\n";
  unique_ptr<Foo> pmain = source();  // Can also be written as auto pmain = source();

  cerr << "Now pmain owns Foo [" << pmain.get() << "]\n";
  cerr << "Passing it to sink\n";
  sink(pmain);                    // ERROR! can't copy unique_ptr
  sink(move(pmain));              // OK: can move it!    // meant std::move

  cerr << "Main done\n";
  return 0;
}

Again, there's a line marked with ERROR! here - it demonstrates once again that a unique_ptr can't
be copied. However, it can be explicitly moved, as the next line shows [2]. When the erroneous line
is commented out, this code prints:

[2] It can also be taken from an rvalue: sink(unique_ptr<Foo>(new Foo)) would work, because rvalue
references can be moved directly. note. here again temp object hence rvalue

Calling source
Creating Foo in source
Foo [0x1767010] constructed
Now pmain owns Foo [0x1767010]
Passing it to sink
Sink owns Foo [0x1767010]
Foo [0x1767010] destructed
Main done

Note how cleanly the ownership is being passed between the functions in this code. At each point in
time, only a single unique_ptr owns the pointed Foo object. Moreover, this is efficient - the actual
pointed object only gets constructed once and destructed once.

Containers - motivation

So unique_ptr is a useful single-ownership smart pointer. But what makes it really shine (especially
when compared to auto_ptr) is that it can be used in standard containers.

Why is it so important to be able to place smart pointers into containers? Because holding objects
by value is sometimes very expensive. Containers, especially when coupled with algorithms, tend to
move objects around. Large objects are expensive to copy, hence we'd like to keep pointers to
objects inside containers instead.

What follows is a very simplistic example that demonstrates this. It shows how much more expensive
it is to sort a vector of large objects that are stored by value, than it is when they're stored by
pointer [3].

Also, I explicitly said to take the container example with a grain of salt as it was synthetically
built to demonstrate the point. Yes, it is best to avoid huge objects, but that's not always
possible.

First, let's create a synthetic "large" object that has well defined ordering properties by some
numeric ID:

struct SomeLargeData {
    SomeLargeData(int id_)
        : id(id_)
    {}
    int id;
    int arr[100];
};

We also need a function to compare two such objects. Actually, we need two - one for a container
that holds object by value, and another for the by pointer version:

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
    return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
    return a->id < b->id;
}

Let's now create two vectors and populate them with random objects:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));
}

Finally, we'll sort the two vectors with the standard sort algorithm, and measure the runtime for
some large n:

sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

The timing results I get are quite consistent - the by-pointer sorting is 2-3x faster than the
by-value sorting [4]. That's a very significant difference, and it's all due to the copying sort has
to do for moving the objects around inside the container.

[4] The speedup grows as the size of the object grows. Increasing the arr member to hold 1000
integers makes the speedup 10x.

So holding objects of non-trivial size inside standard containers is not a good idea in terms of
performance. But holding raw pointers to them is also not so great, because of all the safety issues
that come with raw pointers. The container can't own the pointed objects because its destructor will
just "destruct" the pointer(note not pointed object), which does nothing. So the calling code(note
client) has to own the actual objects which are being shuffled around by the container. Add
exceptions and/or early returns to the mix, and this is a recipe for memory leaks or even worse
problems.

What we'd really like to do is let our objects be managed by a smart pointer and put that into a
container. This would guarantee a clean ownership strategy - the container destroys its contents
when it gets destroyed itself - just the way it should be. This is why unique_ptr is so exciting.

Containers of unique_ptr

Adapting the by-pointer version of the code above to hold unique_ptr is very simple. First, we need
another comparison function:

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a,
                        const unique_ptr<SomeLargeData>& b) {
    return a->id < b->id;
}

And then we just need to create the vector, populate it and then sort it, similarly to the way we've
done for the other vectors:

vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    // ...
    vec_byuniqptr.push_back(
        unique_ptr<SomeLargeData>(new SomeLargeData(id)));  
    // note temp object. shall be this form since no copy supported or use std::move
}

sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);

That's it! And the performance? 'almost' identical to the by-pointer version (I measured differences
of 1-5%, depending on the data).

What about shared pointers?

Another smart pointer C++11 brings with it is the shared_ptr/weak_ptr pair, implementing a
reference-counted approach to shared ownership. While much more flexible than unique_ptr, shared_ptr
is slower and consumes more memory; managing the reference count is not free [5].

[5] For the sorting benchmark demonstrated in this article shared_ptr is about 10% slower than
unique_ptr. As for size, while the size of unique_ptr is exactly the size of a raw pointer,
shared_ptr is about twice as large.

Which one to use depends on your exact needs, but I agree with Herb Sutter's proposal of using
unique_ptr by default and switching to shared_ptr if the need arises.

In addition, it is my personal opinion that preferring unique_ptr imposes a certain memory
management discipline on the code, since you know at each point exactly who owns what. Shared
pointers give you a sense of security you can over use and end up with reference leaks, which are
tricky to debug (just like when writing Python C extension code). 

Moreover, shared pointers signal the intention of APIs less clearly than owning pointers. When some
factory returns a shared pointer, does it mean it keeps a reference to the object too? With an
owning pointer, the API is self documenting (source returns a unique_ptr? then source is for sure
giving away ownership). With a shared pointer, it does not, and need external documentation to
clarify.

Conclusion

I have mentioned how rvalue references and move semantics can make code more efficient with C++11.
unique_ptr is another great example that makes me want to use a C++11-capable compiler as soon as
possible.

unique_ptr provides an excellent mix of efficiency and safe memory management. IMHO it's a great
example of how several ideas in language design interact to create a whole that is larger than its
parts.

Replies:

<1>
fanNo Gravatar Says:
June 25th, 2012 at 14:48

Cant we get the best of all worlds, by doing this:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(&vec_byval.back());
}

sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

This gives us 'fast' by-pointer sorting AND 'ownership' of the pointed objects. So I don't get the
excitement about unique_ptr.

<2>
westforkNo Gravatar Says:
November 5th, 2012 at 12:22

Hi

Nice article. But my results are different from what you wrote.  I implemented your code using gcc
4.7 (g++ (Ubuntu/Linaro 4.7.2-4precise1) 4.7.2) on my desktop (OS xubuntu 12.04, Intel(R) Core(TM)2
Duo CPU, E8400 @ 3.00GHz).  I build a vector of 2010000 containing SomeLargeData objects, raw
pointers to SomeLargeData objects and unique-pointers to SomeLargeData objects. The results are that
raw pointer container is the faster to sort (as expected) but the container with the unique pointers
is the slower!!!  Here a dump of my tests

By value test
TIMESTAMP-START 11:18:23:127277 (ms ~ 40703127)
TIMESTAMP-END 11:18:27:378556 (ms ~ 40707378)
ELAPSED TIME (ms) 4251

By pointer test
TIMESTAMP-START 11:18:27:378658 (ms ~ 40707378)
TIMESTAMP-END 11:18:29:841735 (ms ~ 40709841)
ELAPSED TIME (ms) 2463

By unique_pointer test
TIMESTAMP-START 11:18:29:841816 (ms ~ 40709841)
TIMESTAMP-END 11:18:35:674064 (ms ~ 40715674)
ELAPSED TIME (ms) 5833

What do you think? The overhead of the unique-ptr over the raw pointer is so heavy?

Regards
westfork

<3>
SqeakyNo Gravatar Says:
March 19th, 2013 at 11:58

@Fan The first time the value vector grows it will invalidate all the pointers in the pointer
vector. Since it never tells you when this happens, but can happen on any insertion, you have to
assume that the pointer is invalid after the next insertion.

@Westfork I would guess that the implementation just hasnt had enough time to mature yet. There
must be at least as much over with the unique_ptr as raw pointers, but double does seem excessive.
Did you remember to delete in the raw pointer example?


<4>
This is my result on the VM in a laptop.

#include <iostream>
#include <memory>
#include <vector>
#include <sys/time.h>
#include <algorithm>

using namespace std;

typedef uint64_t u64;

static u64 nsec() {
  struct timeval tv;
  if(gettimeofday(&tv, 0) < 0)
    return -1;
  return (u64)tv.tv_sec*1000*1000*1000 + tv.tv_usec*1000;
}

struct SomeLargeData {
  SomeLargeData(int id_)
    : id(id_)
  {}

  // SomeLargeData(int id_)
  //   : id(id_)
  // { cout << "Foo[" << this << "] ctor(" << id << ")" << endl; }
  // ~SomeLargeData() { cout << "Foo[" << this << "] dtor(" << id << ")" << endl; }

  int id;
  int arr[100];
};

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
  return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
  return a->id < b->id;
}

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a, const unique_ptr<SomeLargeData>& b) {
  return a->id < b->id;
}

int main()
{
  uint64_t be, af;
  int n = 400;

  vector<SomeLargeData> vec_byval;
  vector<SomeLargeData*> vec_byptr;
  vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

  for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));    // note. shall be deleted later
    vec_byuniqptr.push_back(unique_ptr<SomeLargeData>(new SomeLargeData(id)));
  }  

  be = nsec();
  sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
  af = nsec();
  cout << "by value: diff(ns): " << af-be << endl;
  cout << "by value: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);
  af = nsec();
  cout << "by ptr: diff(ns): " << af-be << endl;
  cout << "by ptr: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);
  af = nsec();
  cout << "by uptr: diff(ns): " << af-be << endl;
  cout << "by uptr: diff(ms): " << (af-be)/(1000) << endl;
}

$ ./a.out 
by value: diff(ns): 302000
by value: diff(ms): 302
by ptr: diff(ns): 127000
by ptr: diff(ms): 127
by uptr: diff(ns): 585000
by uptr: diff(ms): 585


# ============================================================================
#{ SYSTEM
={============================================================================
*kt_dev_sys_001*	<empty>


={============================================================================
*kt_dev_sys_002* endianess

representation

this is how {.byte 11} in MIPS is stores in memory:

high                                low
0000 0000 0000 0000 0000 0000 0000 1011

big endian(e.g. intel)  little(e.g. spacc)
0000 0000               0000 1011         low
0000 0000               0000 0000
0000 0000               0000 0000
0000 1011               0000 0000         high


={============================================================================
*kt_dev_sys_003* to check endianess at runtime

uint8_t ebuf[4];
uint32_t *ebuf32 = (uint32_t *)ebuf;

ebuf32[0] = 0x01000000;
if(ebuf[0] == 0x01) system_endian = TBIG_ENDIAN;
else system_endian = TLITTLE_ENDIAN;


={============================================================================
*kt_dev_sys_004* to check address alignment

#define SYSTEM_ALIGNMENT (8)

/* check if an address is aligned to the given alignment boundry,
   NOTE: alignment boundry must be a power of two */
#define IS_ALIGNED(addr,alignb) (((((uint32_t)(addr))) & (((unsigned)alignb)-1)) == 0)

// ALIGNED
if (IS_ALIGNED(size, SYSTEM_ALIGNMENT)) 
{
	*p_aligned_size = size;
}
// NOT ALIGNED
else 
{
	*p_aligned_size = ((size / SYSTEM_ALIGNMENT) + 1) * SYSTEM_ALIGNMENT;
}

Why 'alignment byte -1'? 7(111) in this case.

dec : bin
0     0000        ==0 <- ALIGNED for 4/8 bytes
1     0001        !=0
2     0010        !=0
3     0011  [11]  !=0
----------
4     0100        <- ALIGNED for 8
5     0101
6     0110
7     0111  [11] or [111] 
----------
8     1000        <- ALIGNED
9   0 1001
10  0 1010
11  0 1011 [11]
----------
12  0 1100
13  0 1101
14  0 1110
15  0 1111 [11] or [111] 
----------
16  1 0000
32 10 0000

For 4 bytes align, 4-1=3 [11] and get the start or boundary by & [11].
For 8 bytes align, 7-1=3 [111] and get the start or boundary by & [111].


={============================================================================
*kt_dev_sys_005* two's complement

type int on MIPS. size int: 4
s int  : -219874992
us int : 4075092304

show the complement of a binary number by flipping all digits:

    23:    1 0111
NOT 23: 1110 1000
-----------------
        1111 1111

X + NOT X = -1  ->  "1 + NOT X = -X"

NOT 23: 1110 1000
+    1: 0000 0001
-----------------
   -23: 1110 1001

this method is called "the 2's complement".

8bit two's complement
---------------------------------------------------------------------------- 128 elements [0,127]
0000 0000    : 0
---------------------------------------------------------------------------- 
0000 0001 {{ : 1
0000 0010    : 2
0000 0011    : 3
0000 0100    : 4
...
0111 1111 }} : 127                                       //         -(127)-2
---------------------------------------------------------------------------- 128 elements [-1, -128]
1000 0000    : -128                                      // not -0. -(127)-1
---------------------------------------------------------------------------- 
1000 0001 {{ : -127 (0111 1110 + 1 = 0111 1111 (127))    // not -1. -(127)
1000 0010    : -126 (0111 1101 + 1 = 0111 1110 (126))    // not -2
...
1111 1110    : -2
1111 1111 }} : -1
---------------------------------------------------------------------------- 
Get two's complement in programmatic way

uint32_t ins = 0x27BDFFE0 
0010.0111.1011.1101.1111.1111.1110.0000

two's complement
1101.1000.0100.0010.0000.0000.0001.1111      // ~X
+1                                           // +1
--------------------------------------------------
1101.1000.0100.0010.0000.0000.0010.0000      // -X

(-ins) = 0xD8420020
1101.1000.0100.0010.0000.0000.0010.0000

Since the addition operation in the CPU is agnostic to whether the integer is signed or unsigned,
the same goes for signed integers. For 32-bit signed integers, the minimum value is 0x80000000
(-2147483648, 31th MSB is on) and the maximum value is 0x7fffffff (2147483647). note that there is
no value than can hold 2147483648, so:

<key> if you 'negate' (int)0x80000000, you get the same again and that is something to look out for
because there is no change in bit representation. This means abs() has no effect when fed the
largest negative number. So bit representation is 'agnostic' to whether it's signed or unsigned.

int main()
{
  int uint_max = ((unsigned int)(~0) >> 1)+1;

  std::bitset<32> bitset2{uint_max};
  std::cout << bitset2 << std::endl;

  unsigned int minus_uint_max = -uint_max;
  std::bitset<32> bitset3{minus_uint_max};
  std::cout << bitset3 << std::endl;
}

10000000000000000000000000000000
10000000000000000000000000000000

unsigned int x = ~0;    // 11....1 UINT_MAX
             x >>= 1;   // 01....1 INT_MAX

signed   -INT_MAX-1 ... INT_MAX        // -128 ~ 127
unsigned 0          ... UNIT_MAX       // 0 ~ 256

-INT_MAX-2? -INT_MAX-2 becomes INT_MAX since plus and minus moves up/down in bit representation.

<exercise>
See exercise 2-1 for more.

<exercise>
The ansic, page 64, exercise 3-4. In a two's complement number representation, our version of itoa
does 'not' handle the 'largest' negative number, that is, the value of n equal to -(2 to the power
    (wordsize - 1)). Explain why not. Modify it to print that value correctly regardless of the
machine on which it runs. 

void itoa( int n, char s[] );

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_4
In other words, to find the two's complement representation of a negative number, find the one's
complement of it, and add one. The important thing to notice is that the range of an 8 bit variable
using a two's complement representation is -128 to 127, as opposed to -127 to 127 using one's
complement. Thus, the absolute value of the largest negative number cannot be represented (i.e. we
cannot represent +128 in 'sigined' type). Since the itoa() function in Chapter 3 handles
negative numbers by reversing the sign of the number before processing, then adding a '-' to the
string, passing the largest negative number will result it in being translated to 'itself':

# the original version
# note: make always input positive and cannot use for loop since when input is 0, must run once.

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )        // record sign
    n = -n;                   // make n positive. 

  i = 0;

  do {                        // generate digits in reverse order
    s[i++] = '0' + n % 10;    // get next digit
  } while( (n /= 10) > 0 );   // delete it.

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}

Therefore, because (n /= 10) will be negative since -n has no effect and n is negative. The do-while
loop will run once only since n will be negative, and will place in the string a '-', followed by a
single character since (INT_MIN % 10 + '0') that is (n=-2147483648) % 10 = -8.

In ansic, p41, arithmetic operators, "The direction of truncation for / and the sign of result for
% are machine dependent for negative operands, as is the action taken on overflow or
underflow". this causes (n /= 10) has negative value. From n=-2147483648 to n=-214748364(0xf3333334)

How can we remedy these two bugs?

# the revised version

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )
    n = -n; 

  i = 0;

  do { 
    s[i++] = '0' + abs(n % 10);     // <note-1>
  } while( n /= 10 );               // <note-2>

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}

note-2: change 'while ((n /= 10) > 0)' to 'while (n /= 10)' to make the loop continue 'divide' and n
will eventually equal zero after successive divides by 10, and 'n /= 10' will evaluate to false
sooner or later. If use "while((n/=10)>0)" then handles only positive and stops on the first check
since n/=10 becomes negative.

note-1: change 'n % 10 + '0 to 'abs(n % 10) + '0, to get the correct character since n%10 is
negative so need to make positive to get correct char back. 

note-3: If use abs(XXX_MIN), will get the same? That is okay since it was already reduced to smaller
one.


={============================================================================
*kt_dev_sys_007*	stack (MIPS)

http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html

To think about what's required, let's think about what happens in a function call. 

1.	When a function call is executed, the arguments need to be evaluated to values at least, for
C-like programming languages.  

2.	Then, control flow jumps to the body of the function, and code begins executing there.  

3.	Once a return statement has been encountered, we're done with the function, and return back to
the function call. 

Programming languages make functions easy to maintain and write by giving each function its own
section of memory to operate in. For example, suppose you have the following function. 

int pickMin( int x, int y, int z ) {
  int min = x ;
  if ( y < min )
    min = y ;
  if ( z < min )
    min = z ;
  return min ;
}

You declare parameters x, y, and z. You also declare local variables, min. You know that these
variables won't interfere with other variables in other functions, even if those functions use the
same variable names. In fact, you also know that these variables won't interfere with separate
invocations of itself. 

For example, consider this recursive function, 

    int fact( int n ) {
      if ( n == 0 )
        return 1 ;
      else
        return fact( n - 1 ) * n ;
    }

Each call to fact produces a new memory location for n. Thus, each separate call (or invocation) to
fact has its own copy of n. How does this get implemented? In order to understand function calls,
you need to understand the stack, and you need to understand how assembly languages like MIPS
deal with the stack. 


{stack-pointer}

When a program starts executing, a certain contiguous section of memory is set aside for the program
called the stack. Let's look at a stack. 

low addr  +---------+ stack limit (overflow)
          |         |
			 |         |
			 |=========| sp (grows up towards low addr)
			 |         |
high addr +---------+ stack bottom

The stack-pointer is usually a register that contains the top of the stack. The stack pointer
contains the smallest address x such that any address smaller than x is considered garbage, and any
address greater than or equal to x is considered valid. The shaded region of the diagram represents
valid parts of the stack. 


<push-and-pop>

Push: You can push one or more registers, by setting the stack pointer to a smaller value. Usually
by subtracting 4 times the number of registers to be pushed on the stack and copying the registers
to the stack.  

Pop: You can pop one or more registers, by copying the data from the stack to the registers, then to
add a value to the stack pointer. Usually adding 4 times the number of registers to be popped on the
stack

Thus, pushing is a way of saving the contents of the register to stack, and popping is a way of
restoring the contents of the register from stack. 

Some ISAs have an explicit push and pop instruction. However, {MIPS-does-not} However, you can get
the same behavior as push and pop by manipulating the stack pointer directly. 

The stack pointer, by convention, is r29(sp). That is, it's register 29. Here's how to implement the
equivalent of push $r2 in MIPS, which is to push register $r2 onto the stack. 

push:  addi $sp, $sp, -4  # Decrement stack pointer by 4
       sw   $r3, 0($sp)   # Save $r3 to stack

Here's a diagram of a push operation. 


<stack-pointer-convention>

You might wonder why it's necessary to update the stack pointer. Couldn't you just do the following? 

push:  sw $r3, -4($sp)   # Copy $r3 to stack

Certainly, this is equivalent in behavior as far as register 3 being saved to the stack. However
we'd like to maintain the invariant (condition) that all addresses greater than or equal to the
stack pointer hold valid data, and all the addresses less than the stack pointer hold invalid data.
It just makes bookkeeping that much easier if we follow these conventions.  

Popping off the stack is the opposite of pushing on the stack. First, you copy the data from the
stack to the register, then you adjust the stack pointer. 

pop:  lw   $r3, 0($sp)   # Copy from stack to $r3
      addi $sp, $sp, 4   # Increment stack pointer by 4


<call-by-value>
If you've ever made the error of returning a pointer to a local variable or to a parameter that was
passed by value and wondered why the value stayed valid initially, but later on got corrupted, you
should now know the reason. The data still stays on the garbage part of the stack until the next
push operation overwrites it. That's when the data gets corrupted.

push and pop for 3 regs

push:  addi $sp, $sp, -12  # Decrement stack pointer by 12
       sw   $r2, 0($sp)   # Save $r2 to stack
       sw   $r3, 4($sp)   # Save $r3 to stack
       sw   $r4, 8($sp)   # Save $r4 to stack

pop:  sw   $r2, 0($sp)   # Copy from stack to $r2
      sw   $r3, 4($sp)   # Copy from stack to $r3
      sw   $r4, 8($sp)   # Copy from stack to $r4
      addi $sp, $sp, 12  # Increment stack pointer by 12


{stack-frame}
The following is more of general when there is a frame pointer so not the same as MIPS. {KT} The
stack frame is a function call and scope. Arg is copied into a stack and hence need copy-ctor.


Let's now see how the stack is used to implement functions. For each function call, there's a
section of the stack reserved for the function. This is usually called a stack frame. Let's imagine
we're starting in main() in a C program. The stack looks something like this: 

We'll call this the stack frame for main(). A stack frame exists whenever a (called) function has
started, but yet to complete.

Suppose, inside of body of main() there's a call to foo(). Suppose foo() takes two arguments. One
way to pass the arguments to foo() is through the stack. Thus, there needs to be assembly language
code in main() to "push" arguments for foo() onto the the stack. The result looks like: 

As you can see, by placing the arguments on the stack, the stack frame for main() has increased in
size. We also reserved some space for the return value. The return value is computed by foo(), so it
will be filled out once foo() is done. 

Once we get into code for foo(), the function foo() may need local variables, so foo() needs to push
some space on the stack, which looks like: 
 
   |          |
SP +----------+
   | foo      |	foo() stack frame
   |          |
   +----------+   ++++
FP | ret val  |   main() stack frame
   +----------+
   | args     |
   +----------+
   | args     |
   +----------+
   | main     |
   |          |
   |          |
   +----------+   ++++

foo() can access the arguments passed to it from main() because the code in main() places the
arguments just as foo() expects it. 

We've added a new pointer called FP which stands for frame pointer. The frame pointer points to the
location where the stack pointer was, just before foo() moved the stack pointer for foo()'s own
local variables. 

<stack-pointer>
Almost all architectures have one register dedicated to point to the end of the stack; the stack
pointer. 

<frame-pointer> <not-for-mips>
Many have a second register which points to the start of the currently active stack frame; the frame
pointer. 

That's SP means the current level and FP means the start of current stack frame.

When your program is started, the stack has only one frame, that of the function main.  This is
called the initial frame or the outermost frame.  ==

Having a frame pointer is convenient when a function is likely to move the stack pointer several
times throughout the course of running the function. The idea is to keep the frame pointer fixed for
the duration of foo()'s stack frame. The stack pointer, in the meanwhile, can change values.  Thus,
    we can use the frame pointer to compute the locations in memory for both arguments as well as
    local variables. Since it doesn't move, the computations for those locations should be some
    fixed offset from the frame pointer. 

And, once it's time to exit foo(), you just have to set the stack pointer to where the frame pointer
is, which effectively pops off foo()'s stack frame. It's quite handy to have a frame pointer.  We
can imagine the stack growing if foo() calls another function, say, bar(). foo() would push
arguments on the stack just as main() pushed arguments on the stack for foo().  So when we exit
foo() the stack looks just as it did before we pushed on foo()'s stack frame, except this time the
return value has been filled in. Once main() has the return value, it can pop that and the arguments
to foo() off the stack. 


<MIPS-stack-frame>

Each called function in a program allocates a stack frame on the run-time stack, if necessary. A
frame is allocated for each non-leaf function and for each leaf function that requires stack
storage. A non-leaf function is one that calls other function(s); a leaf function is one that does
not itself make any function calls. Stack frames are allocated on the run-time stack; the stack
grows downward from high addresses to low addresses. 

A function allocates a stack frame by subtracting the size of the stack frame from $sp on entry to
the function. This $sp adjustment must occur before $sp is used within the function and prior to any
jump or branch instructions. 


base offset | contents       | frame
+-----------+----------------+--------------
$sp       +0| arg build      |   low	
            | area           |   
            +----------------+   current
            | f/point regs   |
				| save area      |	
            +----------------+
            | generl regs    |
				| save area      |	
            +----------------+   
            | local and temp |	
+-----------+----------------+--------------
old $sp   +0| space for      |	
            | incoming args  |
            | args 1-4       |	
            +----------------+
         +16| (if present)   |
            | incoming args  |	
            | passed in sp   |	previous
            +----------------+
            | unspecified    |	high
            | ...            |	
            | variable size  |	
            +----------------+


{standard-called-function-rules}

By convention, there is a set of rules that must be followed by every function that allocates a
stack frame. Following this set of rules ensures that, given an arbitrary program counter, return
address register $31, and stack pointer, there is a deterministic way of performing
{stack-backtracing}. These rules also make possible programs that translate already compiled
absolute code into position-independent

There is only one exit from a function that contains a stack adjustment: a jump register instruction
that transfers control to the location in the return address register $31. This instruction,
including the contents of its branch delay slot, mark the end of function.

MIPS stack frame alignment. Although the architecture requires only word alignment, software
convention and the operating system require every stack frame to be doubleword (8 byte) aligned.

In the previous discussion of function calls, we said that arguments are pushed on the stack and
space for the return value is also pushed. This is how CPUs used to do it. With the RISC revolution
(admittedly, nearly 20 years old now) and large numbers of registers used in typical RISC machines,
{the-goal-is-to-try-and-avoid-using-the-stack}. 

Why? The stack is in physical memory, which is RAM. Compared to accessing registers, accessing
memory is much slower---probably on the order of 100 to 500 times as slow to access RAM than to
access a register. 


http://msdn.microsoft.com/en-us/library/aa448706.aspx
(The MIPS microprocessor has 32 general-purpose registers.) 

(gdb) info registers

          zero       at       v0       v1       a0       a1       a2       a3
 R0   00000000 10008401 2aadf310 00d40b70 2aadc000 00000000 00000001 00000001 
            t0       t1       t2       t3       t4       t5       t6       t7
 R8   00000000 00008400 10008400 831a8000 00000002 00000000 831a9e7a 00000000 
            s0       s1       s2       s3       s4       s5       s6       s7
 R16  00a12870 009cc130 0098c4bc 00000001 00000004 00000008 009cd2fc 009cc23c 
            t8       t9       k0       k1       gp      {sp}      s8      {ra}
 R24  831a9d9a 2aada010 00000000 00000000 2aae5010 009cc078 00860000 2aad2590 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 00d40b74 0080000c 2aad0cac 
           fsr      fir
      00000000 00000000 


args $a0, $a1, $a2, $a3 ~

There are four registers used to pass arguments: $a0, $a1, $a2, $a3.  If a function has
more than four arguments, or if any of the arguments is a {large-structure} that's passed by
value, then the stack is used.  There must be a set procedure for passing arguments that's
known to everyone based on the types of the functions. That way, the caller of the
function knows how to pass the arguments, and the function being called knows how to
access them. Clearly, if this protocol is not established and followed, the function being
called would not get its arguments properly, and would likely compute bogus values or,
worse, crash. 


return $v0, $v1 ~

The return value is placed in registers $v0, and if necessary, in $v1. In general, this
makes calling functions a little easier. In particular, the calling function usually does
not need to place anything on the stack for the function being called. 

However, this is clearly not a panacea. In particular, imagine main() calls foo().
Arguments are passed using $a0 and $a1, say. What happens when foo() calls bar()? If foo()
has to pass arguments too, then by convention, it's supposed to pass them using $a0 and
$a1, etc. What if foo() needs the argument values from main() afterwards? To prevent its
own arguments from getting overwritten, foo() needs to save the arguments to the stack.
Thus, we don't entirely avoid using the stack. 


Example to show reg changes between SF.

(gdb) bt
#0  0x2aaf02d4 in ?? () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
#1  0x00b100c8 in SYSTEMITC_API_PendEvent (qhandle=<value optimized out>, timeout=-1) at systemitc.c:375
#2  0x00520fd0 in SrmLowPriorityMain (data=<value optimized out>) at srm_main.c:1597
#3  0x00b328d0 in SYSTEMUTIL_THR_P_ThreadPrologue (arg=<value optimized out>) at systemutil_thread.c:869
#4  0x2aad2f9c in pthread_join () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
Backtrace stopped: previous frame inner to this frame (corrupt stack?)

(gdb) bt
#0  0x2aaf02d4 in ?? () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbb0 00d40000 00b100c8 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 2aaf02d4 
      
#1  0x00b100c8 in SYSTEMITC_API_PendEvent (qhandle=<value optimized out>, timeout=-1) at systemitc.c:375
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbb0 00d40000 00b100c8 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00b100c8 
            
#2  0x00520fd0 in SrmLowPriorityMain (data=<value optimized out>) at srm_main.c:1597
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbe8 00d40000 00520fd0 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00520fd0 

(SP diff: 0139fe38 - 0139fbe8 = 0x250, 592)      

#3  0x00b328d0 in SYSTEMUTIL_THR_P_ThreadPrologue (arg=<value optimized out>) at systemutil_thread.c:869
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fe38 00f0eacc 00b328d0 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00b328d0 

(0139feb0 - 0139fe38 = 0x78, 128)
       
#4  0x2aad2f9c in pthread_join () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139feb0 00f0eacc 2aad2f9c 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 2aad2f9c 

40 registers in total and 40*4 = 160 bytes


={============================================================================
*kt_dev_sys_008*	stack asm example (MIPS)

## C

typedef struct {
  int struct_one;
  int struct_two;
  int struct_three;
} ENTRY;

int func_second(int arg1, int arg2)
{
  int local_val = 0;

  return local_val = arg1*2 + arg2;
}

int func_first(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ENTRY entry)
{
  int local_val = 0;
  int one = 0, two = 0;

  one = arg5+arg1+entry.struct_one;
  two = arg6+arg2+entry.struct_two;

  local_val = arg1+arg2+arg3+arg4+func_second(one, two);

  return local_val;
}

int main(int argc, char* argv[])
{
  int ret = 0;
  ENTRY node = {0};

  node.struct_one = 10;
  node.struct_two = 20;
  node.struct_three = 30;

  ret = func_first( 1, 2, 3, 4, 5, 6, node );
  printf("ret = %d\n",  ret);
  return 0;
}

## asm

int func_second(int arg1, int arg2)
{
  400590:	27bdffe8 	addiu	sp,sp,-24
  400594:	afbe0010 	sw	s8,16(sp)	# {no-need-to-save-ra}
  400598:	03a0f021 	move	s8,sp
  40059c:	afc40018 	sw	a0,24(s8)
  4005a0:	afc5001c 	sw	a1,28(s8)
	int local_val = 0;
  4005a4:	afc00008 	sw	zero,8(s8)
	
	return local_val = arg1*2 + arg2;	
  4005a8:	8fc20018 	lw	v0,24(s8)
  4005ac:	00021840 	sll	v1,v0,0x1
  4005b0:	8fc2001c 	lw	v0,28(s8)
  4005b4:	00621021 	addu	v0,v1,v0
  4005b8:	afc20008 	sw	v0,8(s8)
  4005bc:	8fc20008 	lw	v0,8(s8)
}
  4005c0:	03c0e821 	move	sp,s8
  4005c4:	8fbe0010 	lw	s8,16(sp)
  4005c8:	27bd0018 	addiu	sp,sp,24	# pop
  4005cc:	03e00008 	jr	ra				# {return-to-caller} 
  4005d0:	00000000 	nop

004005d4 <func_first>:

note no pass by value happend for struct arg. how about passing this struct to second
func? this struct will be copied again in stack?

int func_first(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ENTRY entry)
{
  4005d4:	27bdffc8 addiu sp,sp,-56
  4005d8:	afbf0030 sw    ra,48(sp)   // {save-ra}
  4005dc:	afbe002c sw    s8,44(sp)
  4005e0:	afb00028 sw    s0,40(sp)
  4005e4:	03a0f021 move  s8,sp       // save sp to s8
  4005e8:	afc40038 sw    a0,56(s8)   // save args in stack
  4005ec:	afc5003c sw    a1,60(s8)
  4005f0:	afc60040 sw    a2,64(s8)
  4005f4:	afc70044 sw    a3,68(s8)
	int local_val = 0;
  4005f8:	afc00020 	sw	zero,32(s8)
	int one = 0, two = 0;
  4005fc:	afc0001c 	sw	zero,28(s8)
  400600:	afc00018 	sw	zero,24(s8)
	
	one = arg5+arg1+entry.struct_one;
  400604:	8fc30048 	lw	v1,72(s8)	// arg5
  400608:	8fc20038 	lw	v0,56(s8)	// arg1
  40060c:	00621821 	addu	v1,v1,v0
  400610:	8fc20050 	lw	v0,80(s8)	// struct.one
  400614:	00621021 	addu	v0,v1,v0
  400618:	afc2001c 	sw	v0,28(s8)
	two = arg6+arg2+entry.struct_two;
  40061c:	8fc3004c 	lw	v1,76(s8)	// arg6
  400620:	8fc2003c 	lw	v0,60(s8)	// arg2
  400624:	00621821 	addu	v1,v1,v0
  400628:	8fc20054 	lw	v0,84(s8)
  40062c:	00621021 	addu	v0,v1,v0
  400630:	afc20018 	sw	v0,24(s8)
	
	local_val = arg1+arg2+arg3+arg4+func_second(one, two);
  400634:	8fc30038 	lw	v1,56(s8)
  400638:	8fc2003c 	lw	v0,60(s8)
  40063c:	00621821 	addu	v1,v1,v0
  400640:	8fc20040 	lw	v0,64(s8)
  400644:	00621821 	addu	v1,v1,v0
  400648:	8fc20044 	lw	v0,68(s8)
  40064c:	00628021 	addu	s0,v1,v0
  400650:	8fc4001c 	lw	a0,28(s8)
  400654:	8fc50018 	lw	a1,24(s8)
  400658:	0c100164 	jal	400590 <func_second>
  40065c:	00000000 	nop
  400660:	02021021 	addu	v0,s0,v0	// local_val = ... + return;
  400664:	afc20020 	sw	v0,32(s8)		 
	
	return local_val;
  400668:	8fc20020 	lw	v0,32(s8)
}
  40066c:	03c0e821 	move	sp,s8
  400670:	8fbf0030 	lw	ra,48(sp)
  400674:	8fbe002c 	lw	s8,44(sp)
  400678:	8fb00028 	lw	s0,40(sp)
  40067c:	27bd0038 	addiu	sp,sp,56
  400680:	03e00008 	jr	ra
  400684:	00000000 	nop

00400688 <main>:

int main(int argc, char* argv[])
{
  400688:	27bdffb8 	addiu	sp,sp,-72
  40068c:	afbf0044 	sw	ra,68(sp)	// save return
  400690:	afbe0040 	sw	s8,64(sp)
  400694:	03a0f021 	move	s8,sp
  400698:	afc40048 	sw	a0,72(s8)
  40069c:	afc5004c 	sw	a1,76(s8)
	int ret = 0;
  4006a0:	afc00030 	sw	zero,48(s8)
	ENTRY node = {0};
  4006a4:	afc00034 	sw	zero,52(s8)	// struct in stack
  4006a8:	afc00038 	sw	zero,56(s8)
  4006ac:	afc0003c 	sw	zero,60(s8)
	
	node.struct_one = 10;
  4006b0:	2402000a 	li	v0,10
  4006b4:	afc20034 	sw	v0,52(s8)
	node.struct_two = 20;
  4006b8:	24020014 	li	v0,20
  4006bc:	afc20038 	sw	v0,56(s8)
	node.struct_three = 30;
  4006c0:	2402001e 	li	v0,30
  4006c4:	afc2003c 	sw	v0,60(s8)
	
	ret = func_first( 1, 2, 3, 4, 5, 6, node );
  4006c8:	24020005 	li	v0,5		// arg in stack and move struct in stack
  4006cc:	afa20010 	sw	v0,16(sp)	// essentially, arg and strcut in stack
  4006d0:	24020006 	li	v0,6
  4006d4:	afa20014 	sw	v0,20(sp)
  4006d8:	8fc20034 	lw	v0,52(s8)
  4006dc:	8fc30038 	lw	v1,56(s8)
  4006e0:	8fc4003c 	lw	a0,60(s8)
  4006e4:	afa20018 	sw	v0,24(sp)
  4006e8:	afa3001c 	sw	v1,28(sp)
  4006ec:	afa40020 	sw	a0,32(sp)
  4006f0:	24040001 	li	a0,1
  4006f4:	24050002 	li	a1,2
  4006f8:	24060003 	li	a2,3
  4006fc:	24070004 	li	a3,4
  400700:	0c100175 	jal	4005d4 <func_first>	// func call
  400704:	00000000 	nop
  400708:	afc20030 	sw	v0,48(s8)
	printf("ret = %d\n",  ret);	
  40070c:	3c020040 	lui	v0,0x40
  400710:	244407e0 	addiu	a0,v0,2016
  400714:	8fc50030 	lw	a1,48(s8)
  400718:	0c100124 	jal	400490 <printf@plt>
  40071c:	00000000 	nop
	return 0;
  400720:	00001021 	move	v0,zero
}
  400724:	03c0e821 	move	sp,s8
  400728:	8fbf0044 	lw	ra,68(sp)
  40072c:	8fbe0040 	lw	s8,64(sp)
  400730:	27bd0048 	addiu	sp,sp,72
  400734:	03e00008 	jr	ra
  400738:	00000000 	nop
  40073c:	00000000 	nop


# SP and SF
#

 ----------------------------------- first
 56(00) : sp



   (16) : arg5
   (20) : arg6
   (24) : struct_one
   (28) : struct_one
   (32) : struct_one


 04(48) : ra
 00(56) : 
 ----------------------------------- main
 72(00) : sp



   (16) : arg5           (72)
   (20) : arg6           (76)
   (24) : struct_one     (80)
   (28) : struct_two     (84)
   (32) : struct_three


 04(68) : ra use 4(word) from here
 00(72) : 


# ra
# (caller update ra before jump)

 main
+------------+
| save ra    |
|            |
| update ra  |       first
| call first |  -> +------------+ 
|            |     | save ra    |
| get ra     |     |            |
| jump ra    |     | update ra  |      second
+------------+     | call secon | -> +------------+
                   |            |    | jump ra    |
                   | get ra     |    +------------+
                   | jump ra    |    
                   +------------+    


==============================================================================
*kt_dev_sys_009*	for and while asm (MIPS)

<asm-while-loop> in C
int main()
{
  int i = 0;

  while( i < 10 )
  {
    printf("w iter %d\n", i );
    ++i;
  }

  return 0;
}

#	when use -g (debug)
#
int main()
{
  400590:       27bdffd8        addiu   sp,sp,-40	     # push	:
  400594:       afbf0024        sw      ra,36(sp)	     # {copy-return-addr-into-a-stack}
  400598:       afbe0020        sw      s8,32(sp)	     # save s8(saved reg) into a stack. 
                                                        # s8 has one of s0-s7 that has values are preserved across function calls.
  40059c:       03a0f021        move    s8,sp	        # save sp to s8.
        int i = 0;
  4005a0:       afc00018        sw      zero,24(s8)     # int i = 0. save into a stack.			

        while( i < 10 )
  4005a4:       08100173        j       4005cc <main+0x3c> # { jump
  4005a8:       00000000        nop
        {
                printf("w iter %d\n", i );

{4005ac}:       3c020040        lui     v0,0x40		          # -> v0 = v0 << 16.
  4005b0:       244406a0        addiu   a0,v0,1696	          # a0 = v0 + 1696. a0-a3 used for passing args to functions.
  4005b4:       8fc50018        lw      a1,24(s8)			    # a1 = int i. 
  4005b8:       0c100124        jal     400490 <printf@plt>  # }} jump and link.
  4005bc:       00000000        nop
                ++i;

  4005c0:       8fc20018        lw      v0,24(s8)	    # v0 = int i.
  4005c4:       24420001        addiu   v0,v0,1		    # v0 = int i +1. inc i.
  4005c8:       afc20018        sw      v0,24(s8)	    # int i = v0.

{4005cc}:       8fc20018        lw      v0,24(s8)	    # -> v0 = int i 
  4005d0:       2842000a        slti    v0,v0,10	    # i < 10. 
  # slti(set on less than immediate. tests if one register is less than a constant.)
  4005d4:       1440fff5        bnez    v0,4005ac <main+0x1c>	
  # if( v0 != 0 ) then jump. bne(branch on not equal). v0 is 1(true).
  4005d8:       00000000        nop                    # }
        }

        return 0;
  4005dc:       00001021        move    v0,zero		# {copy-return-value}
}
  4005e0:       03c0e821        move    sp,s8
  4005e4:       8fbf0024        lw      ra,36(sp)
  4005e8:       8fbe0020        lw      s8,32(sp)
  4005ec:       27bd0028        addiu   sp,sp,40
  4005f0:       03e00008        jr      ra
  4005f4:       00000000        nop
  
#	when use -Os
#  
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40						# push. dec sp -40.
  400594:       3c020040        lui     v0,0x40							# v0 = v0 << 16.
  400598:       afb1001c        sw      s1,28(sp)						# save arg
  40059c:       afb00018        sw      s0,24(sp)						# save arg
  4005a0:       afbf0020        sw      ra,32(sp)						# save ra
  4005a4:       24510678        addiu   s1,v0,1656						# a1 = v0 + 1656.
  4005a8:       00008021        move    s0,zero							# s0 = 0. s0(int i) is free to use.
  4005ac:       02002821        move    a1,s0							# a1 = s0.
  																						# {
  4005b0:       0c100124        jal     400490 <printf@plt>			# call printf. as int i is 0 to start
  4005b4:       02202021        move    a0,s1							# a0 = s1
  4005b8:       26100001        addiu   s0,s0,1							# s0 = s0+1. 
  4005bc:       2402000a        li      v0,10							# v0 = 10. 
  4005c0:       1602fffb        bne     s0,v0,4005b0 <main+0x20>	# if( s0 != v0 )then jump.
                                                                  # }
  4005c4:       02002821        move    a1,s0							# a1 = s0(int i). exit while
  4005c8:       8fbf0020        lw      ra,32(sp)						# pop. recover ra.
  4005cc:       8fb1001c        lw      s1,28(sp)
  4005d0:       8fb00018        lw      s0,24(sp)
  4005d4:       00001021        move    v0,zero							# return 0.
  4005d8:       03e00008        jr      ra
  4005dc:       27bd0028        addiu   sp,sp,40


<asm-for-loop>
#include <stdio.h>

int main()
{
  int i = 0;

  for(i; i < 10; i++)
    printf("w iter %d\n", i );

  return 0;
}

# when use -Os. same as while case
#
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       3c020040        lui     v0,0x40
  400598:       afb1001c        sw      s1,28(sp)
  40059c:       afb00018        sw      s0,24(sp)
  4005a0:       afbf0020        sw      ra,32(sp)
  4005a4:       24510678        addiu   s1,v0,1656
  4005a8:       00008021        move    s0,zero
  4005ac:       02002821        move    a1,s0
                                                             # {
  4005b0:       0c100124        jal     400490 <printf@plt>
  4005b4:       02202021        move    a0,s1
  4005b8:       26100001        addiu   s0,s0,1
  4005bc:       2402000a        li      v0,10
  4005c0:       1602fffb        bne     s0,v0,4005b0 <main+0x20>
                                                             # }
  4005c4:       02002821        move    a1,s0
  4005c8:       8fbf0020        lw      ra,32(sp)
  4005cc:       8fb1001c        lw      s1,28(sp)
  4005d0:       8fb00018        lw      s0,24(sp)
  4005d4:       00001021        move    v0,zero
  4005d8:       03e00008        jr      ra
  4005dc:       27bd0028        addiu   sp,sp,40


==============================================================================
*kt_dev_sys_010*	POR(power on reset) (MIPS)

when POR, the start address by reset vector is 0xBFC0 0000

exception vector locations.

the reset, soft reset, and NMI exceptions are always vectored to location 0xBFC0_0000.
debug exceptions are vectored to location 0xBFC0_0480 or to location 0xFF20_0200 if the
ProbEn bit is 0 or 1, respectively, itn eht EJTAG control register(ECR).


==============================================================================
*kt_dev_sys_011*	instruction and addressing (MIPS)

I-Type(immediate)

|31      26|25    21|20     16|15              0|
|    op    |   rs   |    rt   |    immediate    |

when a word(4 bytes) is loaded and stored the memory address must be a multiple of four.
this is called an {alignment-restriction}. addresses that are a multiple of four are
called {word-aligned}. this resctiction makes the hardware simpler and faster.


The MIPS instruction that loads a word into a register is the lw instruction. The store
word instruction is sw. Each must specify a register and a memory address. A MIPS
instruction is 32 bits (always). A MIPS memory address is 32 bits (always). How can a load
or store instruction specify an address that is the same size as itself?

note. kt. means that instruction and args should fit into a word(32 bits)


An instruction that refers to memory uses a base register and an offset. The base register
is a general purpose register that contains a 32-bit address. The offset is a 16-bit
signed integer contained in the instruction. The sum of the address in the base register
with the (sign-extended) offset forms the memory address. 

For example:

if you want to load a byte by using the 'lb' instruction.

lb t1, 0x180003fb

it's not working and it simply stores the hexadecimal value into the register. in this
case 0x18000000. Because addresses are always signed 16-bit displacements relative to a
register 

# LUI -- The immediate value is shifted left 16 bits and stored in the register. The lower
# 16 bits are zeroes. lui $t, imm  # $t = (imm << 16)

so you'd wite to work

lui t1, 0x1800		
lbu t1, 0x3fb(t1)

Similarly, to store t1 into address 0x8009f000, you'd write:

# SW -- Store word. The contents of $t is stored at the specified address. 	
# sw $t, offset($s). MEM[$s + offset] = $t

lui at, 0x800a
sw t1, 0xf000(at) 

# Notice that in this case, the upper part of the address has to be incremented by one,
# since the lower part is negative.  0xf000(at) is negative and equates to -0x1000. so
# 0x800a0000 - 0x1000 = 0x8009f000

If you just want to load or store into an address between 0xffff8000 and 0x7fff, you can
skip the lui and use the register which various assemblers call zr, zero or 0 as the base
address. (??)

As you may already know, to load an arbitrary 32-bit value into a register, you use lui and addiu. 
Let's say you want to load 0xfedcba98 into v0. This becomes:

lui v0, 0xfedd
addiu v0, v0, 0xba98 # Add immediate unsigned (no overflow). addiu $t, $s, imm ($t = $s + imm)

Although addiu stands for "add immediate unsigned", the operand is nevertheless sign extended.

Example 02)
sw $12 , 0xFFF8($13)    or    sw $12 , -8($13)

Both are the same.


==============================================================================
*kt_dev_sys_012*	dump_stack

This function can be amended to print any failed capabilities checks using printk, and a
call to the kernel function dump_stack() should give you a pretty good idea of what the
middleware was attempting at the time of the failure. A little guesswork is still required
though, as this will only show you the stack in kernel space, not in the middleware
itself.

only for glibc?


==============================================================================
*kt_dev_sys_013*	clock_gettime and mktime



==============================================================================
*kt_dev_sys_014*	newlines between dos and linux

Q: what is it about?

Systems based on ASCII or a compatible character set use either LF (Line feed, '\n', 0x0A, 10 in
decimal) or CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF
(CR+LF, '\r\n', 0x0D0A).  These characters are based on printer commands: The line feed indicated
that one line of paper should feed out of the printer, and a carriage return indicated that the
printer carriage should return to the beginning of the current line. 

CR+LF: Microsoft Windows, DEC TOPS-10, RT-11 and most other early non-Unix and non-IBM OSes, CP/M,
MP/M, DOS (MS-DOS, PC-DOS, etc.) 

LF   : Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS,
Amiga, RISC OS, and others.

fgets() reads in at most one less than size characters from stream and stores them into the buffer
pointed to by s.  Reading stops after an EOF or a newline. If a newline is read, it is stored into
the buffer.  A '\0' is stored after the last character in the buffer. 

can check as below

[ktpark@cdilinux build_mlu]$ file platform.mk (for dos)
platform.mk: ASCII English text, with CRLF line terminators

[ktpark@cdilinux build_mlu]$ file platform.mk.kt (for unix)
platform.mk.kt: ASCII English text


# ============================================================================
#{
={============================================================================
*kt_dev_ecpp_001* 01: federation of language

C++ is:

Multiparadigm programming language. view it not as a single language but as a federation of related
sublanguages, each with its own rules and conventions.

C, object-oriendted (class), template, and STL


={============================================================================
*kt_dev_ecpp_002* 02: no to preprocessor {macro}

Prefer the compiler to the preprocessor because:

<0> type-checking

<1> better to decode compile error and to use symbolic debugger. 

#define ASPECT_RATIO 1.653

const double AspectRatio = 1.653

<2> smaller code (?) since blind substitution could result in multiple copies in your object code.

<3> class-const
class specific const and better encapsulation. see *kt_dev_cpp_017*

<4> avoid problem when use macro with an expression

// one
#define CALL_WITH_MAX(a,b) func((a) > (b) ? (a) : (b) )

int a= 5, b = 0;

CALL_WITH_MAX(++a, b);     // a is increased twice
CALL_WITH_MAX(++a, b+10);  // a is increased once

// two when the order of evaluation matters
#define square(x)    x*x

square(z+1);

If want to avoid function call cost, use 'inline' instead.


={============================================================================
*kt_dev_ecpp_003* 09: no virtual call in ctor or dtor 

<problem>
Assume that each time a transaction object is created, an appropriate log entry needs to be created
in a log. If it is a derived object, then need to have a log entry for that type.

Solution?:

class Transaction {
  public:
    Transaction();

    virtual void logTransaction() const = 0;    // to make <type-dependent-log-entry>
    ...
};

Transaction::Transaction()
{
  ... >
  logTransaction();
}

class BuyTransaction: public Transaction {
  public:
    virtual void logTransaction() const;
    ...
};

class SellTransaction: public Transaction {
  public:
    virtual void logTransaction() const;
    ...
};

// use
{
   BuyTransaction buy;
}

Will it have a log entry of BuyTransaction as expected? NO. Will have the base class version if
there is one. 

C++ don't allow this because when base ctor runs, 'only' base part is created. Hence base version.
If it was allowed, then derived call would access derived part which is not created or initialized.
This is undefined so 'not' allowed. note: Remember that construction happens first from base. Also
this can be explained as this is becuase it is static bining at compile time. Has nothing to do with
virtual mechanism since not through reference or pointer.

1. For the example above, some compilers issue a warning. Even if there is no warnings, there will
be a link error unless there is a definition of pure virtual function. Remember pure virtual can
have definition. 

2) Can use normal virtual function (not pure) but still get base version.

<solution>
Make it non-virtual, move up the implementation to log in the tree and pass up the type-dependent
info to the base class in the tree.

class Transaction {
  public:
    explicit Transaction( const std::string& logInfo );

    void logTransaction( const std::string& logInfo) const;       // non-virtual-func
    ...
};

Transaction::Transaction( const std::string& logInfo )
{
  ...
  logTransaction( logInfo );
}

class BuyTransaction: public Transaction {
  public:
    BuyTransaction( parameters ) 
      : Transaction( createLogString(parameters) )                // pass-log-to-base-class
    { ... }
    ...
  private:
      'static' std::string createLogString( parameters );         // static-member-func
};

note: See the use of func, createLogString, helper func, instead of initializing each member and it
is more convenient and consider this  when there are many parameters.

<why-static> static-member-func-example
Why static? By doing this, there is no danger of accidentally referring to the BuyTransaction
object's as-yet-uninitialized data or function members when base ctor and part runs.

Why logging call in the base class in the first place? that's becauase it's common to all type of
transactions. So move up as it's abstraction.


={============================================================================
*kt_dev_ecpp_004* 18: hard to use incorrectly 

1) Make compile error for incorrect uses (interface usage errors):

class Date {
  public:
    Date(int month, int day, int year);
    ...
};

// client use

Date d(30, 3, 1995);    // wrong order
Date d(3, 40, 1995);    // invalid

How to make compile errros? Use <type-system>:

struct Day {
  explicit Day(int day) : val(day) {}
  int val;
};

struct Month {
  explicit Month(int month) : val(month) {}
  int val;
};

struct Year {
  explicit Year(int year) : val(year) {}
  int val;
};

class Date {
  public:
    Date( const Month& month, const Day& day, const Year& year);
    ...
};

// client use

Date d(30, 3, 1995);                      // wrong type. wrong order
Date d( Day(3), Month(40), Year(1995) );  // wrong type. invalid
Date d( Month(40), Day(3), Year(1995) );  // correct type. invalid value but easy to 'see'!


2) Make compile error for invalid values: 

Consider enum? NO since not type-safe. Safer solution is to predefine all vaild months. note: C++11
enum suppors type checks. 

class Month {
  public:
    static Month Jan() { return Month(1); }
    ...
    static Month Dec() { return Month(12); }

  private:
    explicit Month(int m); // 'prevent' creation of new values
};

Date d( Month::Mar(), Day(30), Year(1995) );

Used functions to represent months. How about {class-const} in *kt_dev_cpp_017* instead of using
function?


3) Force client to follow interface rule

Investment* createInvestment();

This means that client remember to use raii to prevent resource leaks. The better interface decision
is:

std::shated_ptr<Investment> createInvestment();

The same is {factory-func} in *kt_dev_stl_018* which force client to use smart_ptr.


={============================================================================
*kt_dev_ecpp_005* 23: prefer non-member non-friend func

EC++23. About considering encapsulation in design:

OOD principle dictates that data and functions that operates on them should be bundled together.
Does it suggest that member function is a better choice? No since OOD is about encapsulation. The
nonmember and non-friend provides more encapsulation, packaging flexibility, and extensibility.

The greater something is encapsulated, then the greater our ability to change it later without
breaking user codes. Roughly, when there are 'more' funcs to access data, it's less encapsulated.
Assumes that it follows the rule in EC++22 that member data must be private and therefore provide
only funtional interfaces to access data.

If use private member data, then only member function and friend can use it. If member function and
non-member non-friend function provides the same functionality, which is better? non-member
non-friend function <key> since it doesn't increase the number of functions that can access the
private part of the class or dependant on memeber data. 

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
};

<1> approach one. add more interface?
class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    void clearEverything();
    ...
};

<2> approach two. add non-member non-friend function?
void clearBrowser( Webbrowser& wb )
{
  wb.clearCache();
  wb.clearHistory();
  wb.removeCookies();
}

How to use the approach two? Use namespace in C++ due to ADL.

namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}


{partitioning-or-packaging-functionality}
The namespace can be spread across multiple sources.

<1> partitioning on convenience functions
The convenience function can't offer any functionality a WebBrowser client couldn't already get in
some other way. However, can make client to be compliation dependent on only what they uses.

// <webbrowser.h> for class WebBrowser and 'core' WebBrowser-related functionality.
namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}

// <webbrowserbookmarks.h> for bookmark related convenience functions.
namespace WebBrowserStuff {
  ...
}

// <webbrowsercookies.h> for cookies related convenience functions.
namespace WebBrowserStuff {
  ...
}

<2> partitioning on functionality
Use the same approach but on separated functionality. Like STL, vector, list and etc are in each
header but in the same namespce. Cannot do the same with class member since a class cannot be split
into pieces.


{functional-extensibility}
When necessary, can extend functionality in the existing namespace by adding more. This is
'horizental' extension compared with 'vertical', i.e., class inheritence. 

<key> After all, it's all about encapsulation and seperation. The class is closed or tightly coupled
approach since if it changes, the client will be broken. By having non-member non-friend in the
middle, can have seperation between classes and client. This is like indirect access or interface
class approach.


={============================================================================
*kt_dev_ecpp_006* 26: postpone variable definitions

{cost}
Avoid unused varaibles but see that there are variables which aren't completely unused so to
postpone variable definitions as long as possible until is needed and have init value. Increases
clarity and efficiency.

std::string encryptPassword( const std::string& password )
{
  using namespace std;

  string encrypted;

  if( password.length() < MinimumPasswordLength )
  {
    throw logic_error("Password is too short");
  }

  ...

  return encrypted;
}

The real meaning of 'as long as possible': postpone a variable's definition until right before you
have to use the variable, also try to postpone the definition until you have initialsation arguments
for it. Avoid cost of construction, destruction and default construction.


{what-about-loop}
# approach A                           # approach B
Widget w;
for( int i=0; i < n; i++ )             for( int i = 0; i < n; i++ )
{                                      {
  w = some value;                         Widget w(some value);
  ...                                     ...
}                                      }

1 ctor, 1 dtor, n assign.              n ctor and dtor.

Choose depending on whether ctor/dtor is expensive than assign.

The approach B makes that the name w is only visible in the loop. This is good for comprehensibility
and maintainability. So approach B is 'recommended' unless performance analysis shows approach A is
better.


{make-variable-available-only-for-some}
By defining the variable in a condition, the pointer <dp> is not accessible outside the if. If the
cast fails, then the unbound pointer is not available for use in subsequent code where we might
forget to check whether the cast succeeded.

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
   
} else {  // bp points at a Base object

    // use the Base object to which bp points
}


={============================================================================
*kt_dev_ecpp_007* 28: avoid returning handles to object internals

EC++28. Here internals means everything except public interface and includes private and protected
member func. If returns handles (iterator, pointer and reference) to internals, causes three
problems: breaks encapsulatation, constness, and dangling-handles.

{compromising-encapsulation-and-constness}
The passing by ref is more efficient than passing by value and the interface offer client a way to
learn what rectangle's points are:

class Rectangle {
  public:
    Point& upperLeft() const { return pData->ulhc; }

  private:
    std::shared_ptr<RectData> pData;
};

Is it okay? NO because client can change its value:

// use
const Rectangle rec( ... );
rec.upperLeft().setX(50);

The problem is that makes memeber data effectively public as returns reference to it from a public
member function since this is bitwise-const. See {bitwise-const} in *kt_dev_cpp_008*

The solution is that it offers read-only access:

class Rectangle {
  public: >
   const Point& upperLeft() const { return pData->ulhc; }

  private:
   std::shared_ptr<RectData> pData;
};

Similar to the example of {const-member-func} in *kt_dev_cpp_008*

The other example:

using namespace std;

class Sample {
  private:
    int val;

  public:
    Sample() : val(10) {}
    int& getx() { return val;}
    void printx() { cout << val << endl; }
};

int _tmain(int argc, _TCHAR* argv[])
{
  Sample sam;
  cout << "------" << endl;
  sam.printx();
  sam.getx() = 20;
  cout << "------" << endl;
  sam.printx();

  return 0;
}

This changes private member val to 20.


{dangling-handles}
class GUIObject { ... }
const Rectangle boundingBox( const GUIObject& obj );

// use
GUIObject* pgo;
...
const Point* pUpperLeft = &( boundingBox(*pgo).upperLeft() );

This returns a temporary Rectangle and returns its upper member. The problem is this temporary is
destroyed when end this statement and pUpperLeft will dangle even if const use.

note: vector and string's [] operator returns reference but these are exceptions to this rule, but
not a general rule. Better not use [] operator.


={============================================================================
*kt_dev_ecpp_008* 31: minimize compilation dependencies

Two cases can cause complilation dependency problem:

o class interface changes. means header file changes.
o no separation between interface and implementation in class definition. means header file changes.

note: The implementation separation can be achieved when use func tables which has a set of fixed
interfaces and this is often done via registration. Such as OS abstraction or driver abstraction
which happens when porting.
 
But, how to handle when interface changes? For example, when replace graphic library which has
different interfaces. Usually talk about how to design interfaces for user but if user uses it
everywhere and replace library, need to find every place using it. If there is a single point or
file to use interfaces then better to cope with changes? More about C. 

This item is to reduce compliation dependancy by separating interface from implementation and this
happens because C++ isn't very good at separating interface from implementation.

{cascading-compilation-dependencies}

// person.h
class Person {
  public:
    Preson( const Date& birthDay, const Address& addr );
    std::string name() const;
    ...

  private:
    std::string theName;
    Date theBirthDate;
    Address theAddress;
};

This member 'data' is 'implementaion' details and need class definition such as Date to compile.
Hence headers of these class are needed:

// person.cpp
#include <string>
#include "date.h"
#include "address.h"

This cause cascading-compilation-dependencies. Suppose if this date or address class changes then
classes using one of these should be compiled. 


date.h    -- persoh.h -- xxx.cpp that use person class. 
address.h --          -- xxx.cpp
                      -- ...

<problems>
1. But also any files using Person class as well even if not use member functions using date or
address.

2. No interface change. If only change implementation like adding or removing memeber data, will
cause to compile every cpp files that includes person.h. 

Can use forward declaration to avoid this? NO because cannot create an object. {forward-declaration}
in *kt_dev_lang_010* since the compiler cannot know the size of p and how big a Person object is. 

note: When tried like this forward declaration, compile errors like
sam01.cpp:10:10: error: field theBirthDate has incomplete type
sam01.cpp:11:13: error: field theAddress has incomplete type

note: When tried to define class with no member data and no member function definitions, compile
errors:
/home/kt/work/sam01.cpp:13: undefined reference to `Base::Base(int)'
/home/kt/work/sam01.cpp:14: undefined reference to `Base::Base(int)'

So forward declaration approach do not work anyway but not because do not know the size.

class Date;
class Address;

class Person {
  private:
      std::string theName;
      Date theBirthDate;
      Address theAddress;
};

Person p(params);    // define a person object

<solution>
1. Decouple interface from implementation 
2. Use dependencies on declaration than definition. This moves from dependencies-on-definition to
dependencies-on-declaration

<stl-case-example>
STL uses this approach: Two header files.

<iosfwd> has declaration only
<sstream> <streambuf> <fstream> <iostream> are all implementation files


{pimpl-idiom} 
Aka handle class. See {exception-safe} in *kt_dev_cpp_019* Have two classes. One is what client use
and has a pointer to implementation. 
>
Use the fact that compiler has no problem to get size of built-in types like pointer. no definition
needed.

1. Use built-in types such as reference and pointer.
2. Need only 'declaration' for member function which uses a class as argument or return by value
because the definition is needed only when call a func or define a func. So if Date class changes
then only need to recompile clients that actually uses them but not all clients.
{forward-declaration} in *kt_dev_lang_010*

Date today(); void func(Date d);

No Date definition is needed to declare these function. This removes dependency on definition and
client should include necessary headers to 'actually' call these.

// person.h, interface class
class PersonImpl; // forward-declaration
class Date;
class Address;

class Person {
  ...
  private:
    std::shared_ptr<PersonImpl> pImpl;    // set pimpl
};


// personimpl.h, implementation class
Both class must have the 'same'-interface. If add or remove member data; changes implementation, no
need to compile clients.


// person.cpp, interface class
#include "person.h"
#include "personimpl.h"    // for Impl class

Person::Person(...) : pImpl( new PersonImpl (...) ) {}   // create-and-set-impl

std::string Person::name() const                         // forwarding
{ return pImpl->name(); }

<summary>
(client)    (interface class)                (impl. class)
use         interface: no virtuals           interface
            set impl in ctor.                has real impl. and use other classes such as
            ptr to impl                      Date and Address in this example.

                                             (subclassing)

note:
1. If impl class changes, need to change only cpp file of interface class but not clients.
2. How about subclassing impl class to have other impls? okay.


{interface-class}
Similar to JAVA's interface but C++ one can have data or func implementation. Use ABC and interface
class can have only interfaces or interface and default implementation.

class Person {                      // class IPerson(ABC)
  public:
    virtual ~Person();              // see 'virtual'
    virtual std::string name() const = 0; 
    virtual std::string birthDate() const = 0; 
    virtual std::string address() const = 0; 
    ...
    // factory-func *kt_dev_stl_018*
    'static' std::shared_ptr<Person> create(
        const std::string& name, const Date& birthday, const Address& address);
};


std::shared_ptr<Person> Person::create(...)
{
  return std::shared_ptr<Person> ( new RealPerson (...) );    // create "RealPerson" <create-and-set-impl>
}


// implementation
//
class RealPerson: public Person {         // public IPerson
  private:
    std::string theName;                  // has-implementation-details
    Date theBirthDate;

  public:
    RealPerson(...): ... {}
    virtual ~RealPerson() {}
    virtual std::string name() const;

    ... same interface
};


Then client use:

std::shared_ptr<Person> pp ( Person::create(...) );

<summary>
(client) (interface class)   
(client)    interface: virtuals
...         factory-function 
            ptr to impl      

         (subclassing) 
            real implementation : use other classes

1. Like pimpl idiom, no interface change and can force class interface to derived class.
2. Used subclassing.
3. Like pimpl idiom, separated implementation. When implementation, derived class, changes, no need
to compile clients. But re-link.
4. No singleton class style but effectively singleton since cannot create ABC class and only ABC has
a interface to create. note: not a singleton.

IPerson::create(...)
 |
 |-return new RealPersonX or
 |-return new RealPersonY
 |-...
 +-return new RealPersonZ


{factory-func-pattern} {creational-pattern}
The factory-function plays the role of the ctor for the derived classes that are actually created.
Hence called 'virtual''constructor'

<why-factory>
This is about a method but not a class. Two points:

1. Encapsulation. No code to create in the client and move it into factory-func. 
2. Defer decision on what to create: creation in the base such as parameterized factory-func or to
defer creation to subclass, so any product class in the tree. This subclassing often used in
framework since no need to make changes in framework.

<static-vs-virtual-factory-func>
The static-factory-func has efficient code because no virtual cost and has single point to access
but hard-wired to choose classes to create. Have to change it when the choice to create changes. The
interface class is an example. As shown in *kt_dev_cpp_030* static-factory-func is in the user class
in a tree.

The virtual-factory-func has bigger code but subclassing can change class to create. So useful for
framework that cannot be changed. When factory-func is on the creator tree and uses virtual func:
pure virtual or virtual which as default implementation. Let client decide which class to create
using subclassing, application specific document, to create(manufacture) and defer instantiation to
subclass which is out of framework.

(client)                   (creator class, Application)           (product class, Document) 
-----------------------    ------------------------------------   ------------------------- 
Creator.NewDoc();          // factory-func.
                           // set impl in factory func.
                           'virtual' CreateDoc() = 0;
                           'virtual' CreateDoc();

                           NewDoc()                                Open();
                           { pDoc = CreateDoc(); pDoc->Open(); }

                           (subclass)                              (subclass)
                           -------------------------------------   -------------------------
                           WordApplication, DrawApplicaion, ...    WordDoc, DrawDoc, ...
                           'virtual' CreateDoc()
                           { return new WordDoc; }
                           { return new DrawDoc; }

note: This can be used in parallel class implementation. See design pattern book for more.
note: This looks like factory + pimpl and create object in the different tree.

<virtual-factory-func> sample-code-from-design-pattern
The previous has hard-codes for classes to create:

Maze* MazeGame::CreateMaze() {         // As with NewDoc()
  Maze* aMaze = new Maze;
  Room* r1 = new Room(1);
  Room* r2 = new Room(2);
  Door* theDoor = new Door(r1, r2);

  aMaze->AddRoom(r1);
  ...
  return aMaze;
}

This is revised to use factory which shows how framework works. The frameworks has all logics and
user implements interfaces as framework defines and creats instance.

class MazeGame {
  public:
    Maze* CreateMaze();

    // factory-funcs
    virtual Maze* MakeMaze() const { return new Maze; }
    virtual Room* MakeRoom( int n ) const { return new Room(n); }
    virtual Wall* MakeWall(...);
    virtual Door* MakeDoor(...);
};

Maze* MazeGame::CreateMaze() {
  Maze* aMaze = MakeMaze();

  Room* r1 = MakeRoom(1); Room* r2 = MakeRoom(2);
  Door* theDoor = MakeDoor( r1, r2 );

  aMaze->AddRoom(r1); aMaze->AddRoom(r2);
  ...
  return aMaze;
};

class BombedMazeGame : public MazeGame {
  public:
    virtual Wall* MakeWall() const { return new BombedWall; }
    virtual Room* MakeRoom(int n) const { return new RoomWithABomb(n); }
};

class EnchantedMazeGame : public MazeGame {
  public:
    virtual Wall* MakeDoor() const { return new DoorNeedingSpell; }
    virtual Room* MakeRoom(int n) const { return new EnchantedRoom(n); }
};

BombedMazeGame bombMaze;               // BombedMazeGame
Maze* pMaze = bombMaze.CreateMaze();   // note: client know what to create
pMaze->func();

When CreateMaze is called, will use redefined factory-funcs to create application specific class.
See {template-pattern} for this way to use virtual.


{parameterized-factory-func}
The realistic examples may support different derived class to create using additional params, file,
DB or env var. See factory-pattern in design pattern book for an example of env. use. 

<example> non-member-factory-func
From EC++40. Use id to select different concrete class and non-member factory-func and conditional
switch in it.

std::shared_ptr<IPerson> makePerson( DatabaseID personID );

DatabaseID id(askUserForDatabaseID());
std::shared_ptr<IPerson> pp ( makePerson(id) );

pp->name();
pp->birthDate();

<example> from design pattern 
class Creator {
  public:
    virtual Product* Create( ProductId );
};

Product* Creator::Create( ProductId id )
{
  if( id == MINE ) return new MyProduct;
  if( id == YOURS ) return new YourProduct;

  return 0;
};

Product* MyCreator::Create( ProductId id )
{
  if( id == YOURS ) return new MyProduct;          // note: changed ids
    if( id == MINE ) return new YourProduct;

  if( id == THEIRS ) return new TheirProduct;      // extented

  return Creator::Create(id);                      // fall back on base class for others.
};

<example> on-disk-representation-factory-func
From MEC++25. Creating objects from reading disk and there should be type to create in disk.

class NLComponents {
  public:
    ...
};

class TextBook : public NLComponents {
  public:
    ...
};

class Graphic : public NLComponents {
  public:
    ...
};

class NewsLetter {
  public:
    ...
  private:
    list<NLComponents*> components;
    static NLComponents* readComponent( istream& str );      // <static-factory-func>
};

NewsLetter::NewsLetter( istream& str )
{
  while( str ) {
    components.push_back( readComponent( str ) );
  }
}


{virtual-copy-constructor}
Two things to note here:

1. return pointer type can be different in virtual func. See {override-condition}
2. clone simply use real copy ctor and means it follows the same whether it is deep or shallow copy.

class NLComponent {
  public:
    virtual NLComponent* clone() const = 0;
    ...
};

class TextBlock : public NLComponent {
  public:
    virtual TextBlock* clone() const
    { return new TextBlock(*this); }
    ...
};

class Graphic : public NLComponent {
  public:
    virtual Graphic* clone() const
    { return new Graphic(*this); }
    ...
};

class NewsLetter {
  public:
    NewsLetter( const NewsLetter& rhs );
    ...

  private:
      list<NLComponents*> components;
};

NewsLetter::NewsLetter( const NewsLetter& rhs )
{
  for( list<NLComponent*>::const_iterator it = rhs.components.begin();
      it != rhs.components.end(); ++it )
  {
    components.push_back( (*it)->clone() );
  }
}

Why virtual copy ctor? This copies whatever the pointer really points to, that is calls type
dependent clone. If copying list is allowed this means copying pointers, not real objects. So this
is useful to implement deep copying.

Q: Can copy list?


{virtual-acting-non-member-func}
To have different output for different object? Can use virtual? That means member func.

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& operator<<( ostream& str ) const;
		...
};

TextBlock t; Graphic g;

t << cout; g << cout;

For usual syntax, must use non-member but then cannot use virtual. See kt_dev_cpp_021 for why it
must be non-member. How to solve?

class NLComponent {
	 public:
	 virtual ostream& print( ostream& os ) const = 0;
	 ...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& print( ostream& os ) const;
};

inline ostream& operator<<( ostream& os, const NLComponent& c )
{ return c.print(os); }

Used virtual mecanism on the second arg since it is reference.


{more-things-from-design-pattern}
o In C++, always use virtual. [KT] How about static func?
o Not to call factory-func which is virtual in the creator's ctor. see *kt_dev_ecpp_003* 

Create the product on demand and use <lazy-initialization>. note: factory + singleton 

class Creator {
  public:
    Product* GetProduct();             // accessor

  protected:
    virtual Product* CreateProduct();  // factory-func

  private:
    Product* _product;
};

Product* Creator::GetProduct() {
  if(_product == 0) {
    _product = CreateProduct();
  }
  return _product;
}

o Can use template instead of subclassing. For example,

class Creator {
  public:
    virtual Product* CreateProcut() = 0;
};

template <class T>
class StandardCreator : public Creator {
  public:
    virtual Product* CreateProduct();
};

template <class T>
Product* StandardCreator<T>::CreateProduct() {
   return new T;
};

o Use naming convention for factory-funcs.
For MacApp framework example, class* DoMakeClass() where Class is the product class. 


={============================================================================
*kt_dev_ecpp_009* 32, 38, 39: inter-class relationship

{is-a-model} public-inheritance #32
The base represent a more 'general' concept than the derived since the derived represent a more
specialised concept. Means that can use the derived where the base can be used. 

Think this example and is it right relationship in C++?

class Square : public Rectangle {...};

No. Usually general means bigger set but not in C++ which is smaller. Therefore, it's better to use
"abstract" word than general and limits general to mean the common between them.

As with scope rule in name search, the derived is nested in the base in logical. In C++, in order to
be public inheritance, there shall be "is-a" relationship that means anything that is true of the
base is also true of the derived.

CodeComplete(p144): LSP (Liskov Substitution Principle)
All the routines defined in the base class should mean the same thing when they are used in each of
derived classes. Semantic meaning. Reduce complexity. 


{has-a-model} EC++38
The composition has other synonyms such as containment and aggregation. Two types of composition:
has-a in application domain and is-implemented-in-terms-of model in implementation domain.

<has-a-example>
This is a composition in application domain and says that Person 'has' a name. 

class Person {
  public:
    ...
  private: >
   std::string name;             // composition
   Address address;
   PhoneNumber voiceNumber;
   PhoneNumber faxNumber;
};

<is-implemented-in-terms-of-example>
Suppose that need to implement template class that supports no duplicates and std::set is an option.
However, set is fast but has space overhead per element but space is more important for your
applicaion. Then can we use std::list instead? 

template<typename T>
class Set: public std::list<T> {...}

Cannot use public inheritance as it is is-a model and list can have duplicates. The right way is to
implement by using it and this is a composition in implementation domain.

template<class T>
class Set {
  public:
    bool member( ... ) const;
    void insert( ... );
    void remove( ... );
    std::size_t size() const;

  private: >
    std::list<T> rep;
};

template<typename T>
bool Set<T>::member( const T& item ) const
{
  // note: is there find member function in list? 
  return std::find( rep.begin(), rep.end(), item ) != rep.end() );
}

template<typename T>
void Set<T>::remove( const T& item )
{
  typename std::list<T>::iterator it = std::find( rep.begin(), rep.end(), item );
  
  if( it != rep.end() ) rep.erase(it);
}

template<typename T>
void Set<T>::insert( const T& item )
{
   if( !member(item) ) rep.push_back(item);
}

template<typename T>
std::size_t Set<T>::size() const
{
  return rep.size();
}


{private-inheritance} EC++39
The private inheritance is implementation inheritance and inherits impelementation only but not
interface. It means is-implemented-in-terms-of. The composition is also is-implemented-in-terms-of
so which do we need to use between them? Use composition whenever possible. 

Assume Widget class needs to keep track of how many times each member func is called and
periodically examine the information. Can redefine that virtual function so that it examines the
current state of the Widget.

class Timer {
  public:
    explicit Timer( int tickFrequency );
    virtual void onTick() const;
};

class Widget : public Timer { ... };

No as Wideet is not a timer, that is it is not is-a relationship. So use private inheritance.

class Widget : private Timer {
  private:
    virtual void onTick() const;
    ...
};

<composition>
Instead, can use composition approach.

class Widget {

  private:

    class WidgetTimer: public Timer {
      public:
        virtual void onTick() const;
        ...
    };

    WidgetTimer timer;
    ...
};


note: When derive class from Widget but want the derived do not redefine onTick. Not possible private
inheritance. So this is approach before C++11 to prevant derivation and final keyword in C++11.

<reasons> should prefer compositions over private
1. If use composition, take out WidgetTimer out of Widget, and pointer instead, then can minimize
compilation dependency since otherwise inheritance must see base class definition. Timer's
definition. No need to include Timer header in Widget user.
 
2. The composition is eaiser to understand.

The private inheritance is when need to access protected area of the base and to redefine virtual
functions of base but no conceptual relationship. 

CodeComplete(p143) PI violates encapsulation and tends to point to design errors that should be resolved.


={============================================================================
*kt_dev_ecpp_010* 34: interface and implementation inheritance

EC++34: When design classes, should think 'three', pure virtual, virtual, and non-virtual,
separately to specify with precision what you want derived classes to inherit.

1. Pure virtual (abstract). To have 'only' interface inherited. interface inheritence. 

2. (Simple) virtual (overridable). To have interface and 'default' implementation.


{no-separation-between-interface-and-default-implementation}
When use simple virtual, shall be careful since 'default' implementation is inherited without
'request' from the derived. This can be a problem when the derived not to redefine it.

class Airplane {
  public:
    virtual void fly( const Airport& destination ) 
    { code for usual plane type. default. }
    ...
};

class ModelA : public Airplane { ... };
class ModelB : public Airplane { ... };
class ModelC : public Airplane { ... };

Although this is classic OOD, has a problem. This is okay for model A and B but not C because C is
different type of plane that has different way to fly and should have defined own fly(). If it's
missed to redefine own, it will use the default. The solution is to force the derived 'explicitly'
request implementation if they need.

<approach-one> use ABC
Has separation between interface and default implementation.

class Airplane {
  public: >
    virtual void fly( const Airport& destination ) = 0;  // pure and interface
    ...
  protected:
    void defaultFly( ... );                              // implementation
};

void Airplane::defaultFly( ... )
{
   code for usual plane type. default.
}

class ModelA : public Airplane {
  public:
    virtual void fly( ... ) { defaultFly( ... ); }    // explicit request
};

class ModelC : public Airplane {
  public:
    virtual void fly( ... ) { specific code for model C type }
};

If forget to redefine ModelC::fly then will get errors in compile time because cannot create ModelC
objects. That's because ModelC is ABC.

<approach-two> 
Use the fact that pure virtual can have its implementation.

class Airplane {
  public: >
    virtual void fly( const Airport& destination ) = 0; // make a pure
};

// pure virtual implementation
void Airplane::fly( ... )
{
   code for usual plane type. default.
}

class ModelA : public Airplane {
  public:
    virtual void fly( ... )  { Airplance::fly( ... ); }  // explicit
};

class ModelC : public Airplane {
  public:
    virtual void fly( ... ) { specific code for model C type }
};

note: The both approaches are the essentially same in that force the derived to override, to request
default implementation and if not override, emits errors.

3. Non-virtual (non-overridable). invariant over specialization. To have interface and 'mandatory'
implementation that is default implementation but not overridable. 


={============================================================================
*kt_dev_ecpp_011* 35: alternatives to virtual func

{template-pattern} 
The design pattern, {ref-003}, called it template-method and define skeleton of an algorithm in an
operation.

Deferring 'some' steps to subclass without default implementation of some steps. Must be overridden.

note: it says that that template method is non-virtual function in base and protected pure virtual
function in derived.

note: The template method has "Don't call us, we'll call you" that means parent class calls derived
compared with when derived calls parent class.

<example>
Application framework where application subclass application and document to suit speficif needs.
For example, a drawing application defines DrawApplication and DrawDocument subclass.

Document                Application
+Save()                 +AddDocument()
+Open()                 +OpenDocument()
+Close()                +DoCreateDocument()*
+DoRead()*              +CanOpenDocument()*
                        +AboutToOpenDocument()*

MyDocument              MyApplication
+DoRead()               +DoCreateDocument()           // return new MyDocument
                        +CanOpenDocument()
                        +AboutToOpenDocument()

// this is template method
void Application::OpenDocument( const char* name ) {
  if( !CanOpenDocument(name)) {
    // cannot handle this document
    return;
  }

  Document* doc = DoCreateDocument();  // factory-func to create application specific document

  if(doc) {
    _docs->AddDocument(doc);
    AboutToOpenDocument(doc);
    doc->Open();
    doc->DoRead();
  }
}

Use case:

1. Without chaning the algorithm's structure, the template-method defines steps in terms of abstract
operations that subclass override to provide concrete behavior. Or it is to define 'invariant' parts
once and leave 'variant' part to subclass.

2. Refactoring. To avoid code duplication, identify the differences among existing subclasses and
then separate the differences into new operations, replace the differing code with a template
method(in base) that calls one of these new operations. This is also about code resuse but
difference is steps, that is template.

3. Hook operations.

<private-virtual>
EC++35. In the following example, different character may calculate their health in different ways.
Use virtual? This is alternatives to usual virtual design. Called NVI(non-virtual interface) idiom
as a 'public' non-virtual in the base call a 'private' virtual func that can be redefined but it's
little more than window dressing as still use virtuals. There are 'how' and 'when': template-method
means that base controls when and derived control how.

note: this book limits template method when it uses private virtual.

class GameCharacter {
  public:
    int healthValue() const
    {
      // do 'before' stuff 
      int retVal = doHealthValue();
      // do 'after' stuff
    }

  private:     // note: see this is private and {text-query-example}
    virtual int doHealthValue() const
    {
      // default calc code
    }
};

The base defines before and after stuff and when to call the derived part that is the derived
dependent. The before and after can be lock/unlock, logging, pre/post condition.

note: name-and-related
For a naming convention of primitive operation which should be overridden, prefix names with Do:
DoRead. Often used with {factory-func} as DoCreateDocument shown above.

<example> shows that virtual functions can be overridden regardless of access specifier
#include <iostream>

using std::cout;
using std::endl;

class Base {
  public:
    Base() { cout << "bas: this is ctor" << endl; }

    void doCalc()
    {
      cout << "bas: doCalc" << endl;
      doMorePub();
      doMorePri();
      doMorePro();
      cout << "bas: called doMore" << endl;
    }

    virtual void doMorePub() { cout << "bas: doMorePub" << endl; }

  private:
    virtual void doMorePri() { cout << "bas: doMorePri" << endl; }

  protected:
    virtual void doMorePro() { cout << "bas: doMorePro" << endl; }
};

class Derived : public Base {
  public:
    Derived() { cout << "der: this is ctor" << endl; }

    virtual void doMorePub() { cout << "der: doMorePub" << endl; }

  private:
    virtual void doMorePri()
    {
      // error Base::doMorePri();
      cout << "der: doMorePri" << endl;
    }

  protected:
    virtual void doMorePro() { cout << "der: doMorePro" << endl; }
};

int main(int argc, char** argv)
{
  Derived drv;
  drv.doCalc();
  cout << "end of main" << endl;
}

bas: this is ctor
der: this is ctor
bas: doCalc
der: doMorePub
der: doMorePri
der: doMorePro
bas: called doMore

note: why this works? This is like {bitwise-const} as compiler picks up physical things since
virtual calls are indirect calls which uses vptr to vtable.

<hook-operation>
The template-method can be used to 'extend' parent class 'operation' but not a class. 

virtual void DerivedClass::Operation() {
  ParentClass::Operation();
  // additional
}

But it is esay to forget to call the inherited function so can use template-method to give the
parent class a control over how subclasses extend it. This is called 'hook'-operation. 

void ParentClass::Operation() {
  // parent class behavior
  HookOperation();
}

virtual void ParentClass::HookOperation() { }

virtual void DerivedClass::HookOperation() {
  // derived class extension
}

<private-or-protected>
This example is from <cast-create-a-temp-object> to show the problem of cast and to show case that
virtual memeber function in derived calls base class conterparts first.

class Window {
  public:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow : public Window {
  public:
    virtual void onResize() {
      Window::onResize();
      // additional to the derived
    }
    ...
};

As with hook operation, this is to extend operation and should the Do operation be protected or
private? If it was private, then errors so should be protected. note: However, can use hook
operation instead.

usetemppattern.cpp: In member function 'virtual void Derived::doMorePri()':
usetemppattern.cpp:26:16: error: 'virtual void Base::doMorePri()' is private
usetemppattern.cpp:51:20: error: within this context


{strategy-pattern} TODO: more clearer
As with the same example as template pattern, calculate a health for a different game character.
This design use no virtual and that calculating a health is independent of the character's type. So
take a calculation out of the class.

<key> The idea is to use function pointer for a calculation. This is simple application of strategy
pattern.

class GameCharacter;

// default calculation
int defaultHealthCalc( const GameCharacter& gc );

class GameCharacter {
  public:
    typedef int(*HealthCalcFunc)(const GameCharacter&);

    explicit GameCharacter( HealthCalcFunc hcf = defaultHealthCalc ) : healthFunc(hcf) {}

    int healthValue() const
    { return healthFunc(*this); }
    ...

  private:
      HealthCalcFunc healthFunc;
};

<comparison>
Interesting flexibilities than virtual approach, template pattern:

1. Each 'instance'(object) of the same type can have different calculation since use constructor to
set calculation function.

2. Can change the calculation function at runtime.

The possible downside is that calculation function is not member function so could weaken
encapsulation if need access to non-public part of class to calculation. For example, make it a
friend or offer more public funcs that are private otherwise.

<when-use-function-type>
Can use function type to support different callables. See {function-type} for more.

class GameCharacter {
  public:

    typedef std::tr1::function<int(const GameCharacter&)>HealthCalcFunc;
    ...
};

The stl function type is 'generalized' function pointer and allow us to use any compatible callable
entities such as function object, member funcs, and funcs with different return type.

<classic-strategy-pattern>
Use two hierarchy. One for characters and the other for calculations. Make calculation function a
virtual member function of the calculation hierarchy.

GameCharacter <--- CharacterX
               |- CharacterY
               |- ...
    <*>
    |
    | composition aggregation
   1|
HealCalcFunc  <--- SlowHealthLoser
               |- FastHealthLoser
               |- ...

class GameCharacter;

class HealthCalcFunc {
  public:
    virtual int calc( const GameCharacter& gc ) const { ... }
    ...
};

HealthCalcFunc defaultHealthCalc;

class GameCharacter {
  public:
    explicit GameCharacter( HealthCalcFunc* phcf = &defaultHealthCalc )
      : pHealthCalc( phcf ) {}

    int healthValue() const
    { return pHealthCalc->calc(*this); }     // see
    ...

  private:
      HealthCalcFunc* pHealthCalc;           // see
};

Can add/change calc func later because can have the drived classes in separate hierarchy.


={============================================================================
*kt_dev_ecpp_012* 33: avoid hiding inherited names

EC++33. As with {scope-in-inheritance}, names in the derived can hide names in the base. The other
problem is that when base has overloads, derived must inherited all of them to have "is-a"
relationship.  However, if derived redefine or override only some of them then you would be hiding.

class Base {
  public:
    virtual void mf1() = 0;
    virtual void mf1(int);

    virtual void mf2();
    void mf3();
    void mf3(double);
};

class Derived : public Base {
  public:
    virtual void mf1();
    void mf3();
    void mf4();
};

Derived d;

d.mf1();
d.mf1(x);      // error
d.mf3();
d.mf3(x);      // error

To solve this, use using declaration to make all visible or inherit all.

class Base {
  public:
    virtual void mf1() = 0;
    virtual void mf1(int);

    virtual void mf2();
    void mf3();
    void mf3(double);
};

class Derived : public Base {
  public:
    using Base::mf1;
    using Base::mf3;

    virtual void mf1();
    void mf3();
    void mf4();
};

Derived d;

d.mf1();
d.mf1(x);      // okay
d.mf3();
d.mf3(x);      // okay

note: Used using declaration in public since it is public inheritance.

On the other hand, want to inherit only some of them then use private inheritance and 'forwarding'
function. Effectively, the below only inherits mf1() version from the base.

class Base {
  public:
    virtual void mf1() = 0;
    virtual void mf1(int);
};

class Derived : private Base {
  public:
    virtual void mf1() { Base::mf1(); }
};

Derived d;

d.mf1();
d.mf1(x);      // okay


EC++36. If you redefine non-virtual, as you seen, it hides names. The other problem is to exhibit
'inconsistent' behavior depending on type of pointer used.

class D: public B {
  public:
    void mf();
};

D x;
B* pB = &x; D* pD = &x;

pB->mf();      // same object but B::mf
pD->mf();      // same object but D::mf


={============================================================================
*kt_dev_ecpp_013* 22: data member must be private

EC++22. How about using public or protected member data in class?

If class interface has only member funcs then the good things are:

1) syntactically uniform access(consistency) since do not need to remember which one is function or
member data. Always use function interface.

2) fine-grained access control. read-only. write-only. etc.

3) Encapsulation. Hiding data members behind <functional-interface> can offer all kinds of
implementation flexibility as with benefits from separation between interfacea and implementation.
For example, change implementation later.

The encapsulation is inversely proportional to the amount of code that might be broken if that
something changes. 

The point is that do not use public and protected members since this means un-encapsulated and
un-changeable.


={============================================================================
*kt_dev_ecpp_014* 27: minimize casting

{type-casting-and-type-conversion}
http://www.cplusplus.com/doc/tutorial/typecasting/

<upcast>
o Pointer upcast: pointers to a derived class can be converted to a pointer of an accessible and
unambiguous base class, without modifying its const or volatile qualification.
 
<implicit-conversions-with-classes>
In the world of classes, implicit conversions can be controlled by means of three member functions:

o Single-argument constructors: allow implicit conversion from a particular type to initialize an
object.  
o Assignment operator: allow implicit conversion from a particular type on assignments.  
o Type-cast operator: allow implicit conversion to a particular type.

// implicit conversion of classes:
#include <iostream>
using namespace std;

class A {};

class B {
  public:
    // conversion from A (constructor):
    B (const A& x) {}

    // conversion from A (assignment):
    B& operator= (const A& x) {return *this;}

    // conversion to A (type-cast operator)
    operator A() {return A();}
};

int main ()
{
  A foo;
  B bar = foo;    // calls constructor
  bar = foo;      // calls assignment
  foo = bar;      // calls type-cast operator
  return 0;
}

The type-cast operator uses a particular syntax: it uses the operator keyword followed by the
destination type and an empty set of parentheses. Notice that the return type is the destination
type and thus is not specified before the operator keyword.

<type-casting>
C++ is a strong-typed language. Many conversions, specially those that imply a different
interpretation of the value, require an explicit conversion, known in C++ as type-casting. There
exist two main syntaxes for generic type-casting: functional and c-like:

double x = 10.3;
int y;
y = int (x);    // functional notation
y = (int) x;    // c-like cast notation

The functionality of these generic forms of type-casting is enough for most needs with fundamental
data types. 

However, these operators can be applied indiscriminately on classes and pointers to classes, which
can lead to code that - while being syntactically correct - can cause runtime errors. For example,
the following code compiles without errors: 

// class type-casting
#include <iostream>
using namespace std;

class Dummy {
  double i,j;
};

class Addition {
    int x,y;

  public:
    Addition (int a, int b) { x=a; y=b; }
    int result() { return x+y;}
};

int main () {
  Dummy d;
  Addition * padd;
  padd = (Addition*) &d;
  cout << padd->result();
  return 0;
}

The program declares a pointer to Addition, but then it assigns to it a reference to an object of
another 'unrelated' type using explicit type-casting:

'unrestricted' 'explicit' type-casting allows to convert any pointer into any other pointer type,
independently of the types they point to. The subsequent call to member result will
produce either a run-time error or some other unexpected results.

In order to control these types of conversions between classes, we have four specific casting
operators: dynamic_cast, reinterpret_cast, static_cast and const_cast. Their format is to follow the
new type enclosed between angle-brackets (<>) and immediately after, the expression to be converted
between parentheses.

dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)

The traditional type-casting equivalents to these expressions would be:

(new_type) expression
new_type (expression)

but each one with its own special characteristics:

<dynamic_cast> 
dynamic_cast can only be used with <pointers and references> to 'classes' (or with void*). Its purpose
is to ensure that the result of the type conversion points to a valid complete object of the
destination pointer type.

This naturally includes pointer 'upcast' (converting from pointer-to-derived to pointer-to-base), in
the same way as allowed as an implicit conversion. DONE BY COMPILER.

But dynamic_cast can also 'downcast' (convert from pointer-to-base to pointer-to-derived)
polymorphic classes (those with virtual members) if-and 'only' if-the pointed object is a valid
'complete' object of the target type. For example:

// dynamic_cast
#include <iostream>
#include <exception>
using namespace std;

class Base { virtual void dummy() {} };
class Derived: public Base { int a; };

int main () {
  try {
    Base * pba = new Derived;
    Base * pbb = new Base;
    Derived * pd;

    pd = dynamic_cast<Derived*>(pba);
    if (pd==0) cout << "Null pointer on first type-cast.\n";

    pd = dynamic_cast<Derived*>(pbb);
    if (pd==0) cout << "Null pointer on second type-cast.\n";

  } catch (exception& e) {cout << "Exception: " << e.what();}
  return 0;
}

The result: Null pointer on second type-cast.

Compatibility note: This type of dynamic_cast requires RTTI to keep track of dynamic types. Some
compilers support this feature as an option which is disabled by default. This needs to be enabled
for runtime type checking using dynamic_cast to work properly with these types.

The code above tries to perform two dynamic casts from pointer objects of type Base* (pba and pbb)
to a pointer object of type Derived*, but only the first one is successful. Notice their
respective initializations:

Even though both are pointers of type Base*, pba actually points to an object of type Derived, while
pbb points to an object of type Base. Therefore, when their respective type-casts are performed
using dynamic_cast, pba is pointing to a full object of class Derived, whereas pbb is pointing to an
object of class Base, which is an incomplete object of class Derived.

<when-pointer> <Q> not pointers?
When dynamic_cast cannot cast a pointer because it is not a complete object of the required class
-as in the second conversion in the previous example- it 'returns' a null pointer to indicate the
failure. 

<when-reference>
If dynamic_cast is used to convert to a reference type and the conversion is not possible, an
exception of type bad_cast is thrown instead.

dynamic_cast can also perform the other implicit casts allowed on pointers: casting null pointers
between pointers types (even between unrelated classes), and casting any pointer of any type to a
void* pointer.

<static_cast>
static_cast can perform conversions between pointers to 'related' classes, not only upcasts but also
downcasts. 'no' checkes are performed during runtime to guarantee that the object being converted is in
fact a full object of the destination type. Therefore, it is up to the programmer to ensure that the
conversion is safe. On the other side, it does 'not' incur the overhead of the type-safety checks of
dynamic_cast.

class Base {};
class Derived: public Base {};
Base * a = new Base;
Derived * b = static_cast<Derived*>(a);

This would be valid code, although b would point to an incomplete object of the class and could lead
to runtime errors if 'dereferenced'.

static_cast is also able to perform all conversions allowed implicitly; not only those with pointers
to classes, and is also able to perform the opposite of these. It can:

o Convert from void* to any pointer type. In this case, it guarantees that if the void* value was
obtained by converting from that same pointer type, the resulting pointer value is the same.

o Convert integers, floating-point values and enum types to enum types.

Additionally, static_cast can also perform the following:

o Explicitly call a single-argument constructor or a conversion operator.
o Convert to rvalue references.
o Convert enum class values into integers or floating-point values.
o Convert any type to void, evaluating and discarding the value.

<reinterpret_cast>
reinterpret_cast converts any pointer type to any other pointer type, even of <unrelated> classes.
The operation result is a simple binary copy of the value from one pointer to the other. All pointer
conversions are allowed: neither the content pointed nor the pointer type itself is checked.

It can also cast pointers to or from integer types. The format in which this integer value
represents a pointer is platform-specific. The only guarantee is that a pointer cast to an integer
type large enough to fully contain it (such as intptr_t), is guaranteed to be able to be cast back
to a valid pointer.

The conversions that can be performed by reinterpret_cast but not by static_cast are low-level
operations based on reinterpreting the binary representations of the types, which on most cases
results in code which is system-specific, and thus non-portable. For example:

class A { /* ... */ };
class B { /* ... */ };
A * a = new A;
B * b = reinterpret_cast<B*>(a);

This code compiles, although it does not make much sense, since now b points to an object of a
totally unrelated and likely incompatible class. Dereferencing b is unsafe.

The other example is that it peforms a low-level reinterpretation of the bit pattern of its
operands.

int *p;
char *pc = reinterpret_cast<char*>(ip);

<const_cast>
This manipulates the constness of the object pointed by a pointer, either to set or to removed. For
example, in order to pass a const pointer to a function that expects a non-const argument:

// const_cast
#include <iostream>
using namespace std;

void print (char * str)
{
  cout << str << '\n';
}

int main () {
  const char * c = "sample text";
  print ( const_cast<char *> (c) );
  return 0;
}

The example above is safe because function print does not write to the pointed object. After
removing the constness of a pointed object, writing to it causes undefined behavior.

From C++P p233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
	return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
	auto &r = shorterString( const_cast<const string&>(s1), const_cast<const string&>(s2) );

	return const_cast< string& >(r);
}

This is safe to cast that string back to a plain string & in the return because it is one of
original nonconst arguments.


{named-cast}
From MEC++02. These casts are called named cast and these provides:

1. Easier-to-recognise style in code both for humans and for tools.
2. The more narrowly specified purpose and precision of meaning. Better for a comipler to diagnose
usuage errors.


{why-careful-about-cast}
<function-style-cast>

doSomething(Widget(15);
doSomething(static_cast<Widget>(15));

The both do exactly the same although doesn't feel like a cast.

<do-not-assume-how-things-are-laid-out>
C++ can have an object that might have more than one address; that is when pointed by a Base*
pointer and when pointed by Derived*. This cannot happen in C and other lanauages.

Derived d;
Base *pb = &d;

Sometimes, a base class pointer and derived class pointer values will not be the same. When that's
the case, an offset is applied at runtime to the Derived* pointer to get the correct Base* pointer
value. DO not use "I know how things are laid out" casts.

<cast-means-more-code>
The cast do nothing but tell compilers to treat one type as another? Mistaken since type conversion
often lead to 'additional' code that is executed at runtime. 

int x, y;
...
double d = static_cast<double>(x)/y;

Use division but use floating point division.

<cast-create-a-temp-object> 
Assume that a virtual function in derived class call their base class counterparts first.

class Window 
{
  virtual void onResize() {...}
};

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      static_cast<Window>(*this).onResize();
      ...
    }
    ...
};

It does call onResize but on the temp object. WHY? The solution is:

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      Window.onResize();
      ...
    }
    ...
};

<cast-is-expensive>
The dymamic cast is expensive and slow since often is implemented using string comparison in the
hierarchy. The compier supports 'upcast' that is implicit derived-to-base conversion so a base
pointer can point either base object and derived object. How to know which? The need for dynamic
cast arises when want to use derived class ops on what you believe to be a derived class objects via
base pointer or reference. This is 'downcast'. 

This example is repeated in *kt_dev_cpp_022* inheritance

class Window { ... };
class SpecialWindow: public Window {
  public:
    void blink();
};

typedef std::vector< std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow *psw = dynamic_cast<SpecialWindow*> (iter->get()))
    psw->blink();
}

Here used dymamic_cast to meet the condition which only derived class supports blink(). To avoid
this dymamic_cast, two approaches:


<solution-one>
typedef std::vector< std::shared_ptr<SpecialWindow>> VPW;

But, do not support all possible window derivatives.

<solution-two>
Use virtual mechanism. 

class Window {
  public:
    virtual void blink() {}     
    // default impl is no-op. see *kt_dev_ecpp_010* for why it can be a bad idea
};

class SpecialWindow : public Window {
  public:
    virtual void blink() { ... }
};

<other-things-to-remember>
Avoid cascading dynamic cast and try to hide cast inside a function.

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow1 *psw = dynamic_cast<SpecialWindow1*> (iter->get()))
    psw->blink();
  else if( SpecialWindow2 *psw = dynamic_cast<SpecialWindow2*> (iter->get()))
    psw->blink();
  ...
}


={============================================================================
*kt_dev_ecpp_015* new and delete

{default-value-initialize}

string* ps = new string;      // default-init
string* ps = new string();    // value-init. T()

int* pi = new int;            // default-init
int* pi = new int();          // value-init. T()

Only for built-in types, value-init makes difference and this means that default-init for built-in
types has 'uninitialized' values. For class types, both will use default ctors and so no difference.
"new operator" combines allocation and construction; creates 'unnamed' and then 'default-init'
objects e.g. calls ctor for class object.


{new-operator-and-operator-new}
MEC++08: This operator is built into the language and, like sizeof, you can't change its meaning: it
always does the same thing. What it does is twofold: allocation and construction.

For new operator, use operator new (or operator new[]) to allocate raw memory, runs ctor to
construct, and returns pointer to constructed memory. Raise 'bad_alloc' exception when there no
memory.

For deletion, do opposite; runs dtor and operator delete( or delete[]) to free memory.

note: C++ runtime gurantees that delete nullptr do nothing.


{do-not-mix-with-array-form}
EC++16. Use the same form in corresponding uses of new and delete since these do two things but
think what will happen when call destructor(s) less or more than needed. Undefined in both ways. 

std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100]; 

delete stringPtr1;
delete[] stringPtr2;

This can be not obvious when use typedef: 

typedef std::string AddressLines[4];
std::string *pal = new AddressLines;

delete pal;    // undefined
delete[] pal;

If do not know that there is a typedef, for example, it is in a file somewhere in huge source tree
then may be a problem.


{operator-new-and-delete}
This is the C++ equivalent of calling malloc and free. What you can change is how the memory for an
object is allocated. The name of the function that the new operator calls to allocate memory is
operator new. Can rewrite or overload that function to change its behavior.

The operator new function is usually declared like this:

void * operator new(size_t size);

The return type is void*, because this function returns a pointer to raw, uninitialized memory.

void *rawMemory = operator new(sizeof(string));

Like malloc, operator new's only responsibility is to allocate memory.

note: Can define own operator new and delete but careful because it takes over responsibility for
'all' dynamic memory allocation. Since it changes global one so new operator will automatically
invoke your custom version of operator new.


={============================================================================
*kt_dev_ecpp_016* 49: new handler

Before operator new throws an exception in response to an unsatisfiable request for memory, calls a
error handling function called new handler. Can set user's handler by calling set_new_handler for
'flexibility' of handling allocation errors.

namespace std {
  typedef void (*new_handler)();
  new_handler set_new_handler( new_handler p ) throw();     // see noexcept
};

void outOfMem()
{
  std::cerr << "Unable to satisfy request for memory\n";
  std::abort();
}

int main()
{
  std::set_new_handler( outOfMem );
  int *pBigDataMemory = new int[10000000000L];
  ...
}

When operator new is unable to fulfill a memory request, calls new handler 'repeatedly' until it can
find enough memory. So handler must do one of followings:

1. Make more memory avaiable
For example, allocate a large block of memory at program start-up, then release it for use the first
time thw handler is invoked.

2. Install a different handler
If the current handler can't make any more memory available, perhaps it knows of a different handler
that can and next time operator new calls the new handler. note: May have hierachy of handler.

3. Deinstall handler
Call set_new_handler(0). With no handler installed, operator new will throws an exception when
allocation is unsuccessful.

4. Throw an exception
Throw a type bad_alloc or derived from bad_alloc.

5. Not return
Typically calls abort or exit.


{class-specific-handler}
Instead of using 'global' handler, can use class specific handler.

// Widget

class Widget {
  public:
    static std::new_handler set_new_handler( std::new_handler p ) throw ();
    static void *operator new( std::size_t size ) throw ( std::bad_alloc );

  private:
    static std::new_handler currentHandler;
};

std::new_handler Widget::currentHandler = 0;

std::new_handler Widget::set_new_handler( std::new_handler p ) throw ()
{
  // note: this merely set currentHandler
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}

void* Widget::operator new( std::size_t size ) throw( std::bad_alloc )
{
  // note: save old global handler and set new one
  NewHandlerHolder h( std::set_new_handler(currentHandler));

  // note: call global operator new
  return ::operator new(size);
}

// HandlerHolder
// note: uses raii to restore global handler back when done

class NewHandlerHolder {
  public:
    explicit NewHandlerHolder( std::new_handler nh ) : handler(nh) {}
    ~NewHandlerHolder() { std::set_new_handler(handler); }

  private:
    std::new_handler handler;

    // preventing copies
    NewHandlerHolder( const NewHandlerHolder& );
    NewHandlerHolder& operator=( const NewHandlerHolder& );
};

// Use

void outOfMem();

Widget::set_new_handler( outOfMem );

// note: see how Widget's operator new is called due to arg-dependent lookup.
Widget* pw1 = new Widget;              // if allocation fails, call outOfMem

std::string* ps = new std::string;     // if allocation fails, call global one if there is

Widget::set_new_handler(0);            // set no handler for Widget

Widget* pw2 = new Widget;              // if allocation fails, throw exception immediately

<to-support-other-class>
This scheme is the same regardless of the class and then use template to support other types.

template<typename T>
class NewHandlerSupport {
  public:
    static std::new_handler set_new_handler( std::new_handler p ) throw ();
    static void* operator new( std::size_t size ) throw (std::bad_alloc);

    // other versions of operator new.
  private:
    static std::new_handler currentHandler;
};

template<typename T>
std::new_handler NewHandlerSupport<T>::currentHandler = 0;

template<typename T>
std::new_handler NewHandlerSupport<T>::set_new_handler( std::new_handler p ) throw ()
{
  std::new_handler oldHandler = currentHandler;
  currentHandler = p;
  return oldHandler;
}

template<typename T>
void* NewHandlerSupport<T>::operator new( std::size_t size ) throw( std::bad_alloc )
{
  NewHandlerHolder h( std::set_new_handler(currentHandler));

  return ::operator new(size);
}

class Widget : public NewHandlerSupprt<Widget> {
  // as before but without set_new_handler and operator new
};

note: never use type parameter T. All need is a different copy of NewHandlerSupport, in particular
its static data member currentHandler. Template mechanism do.

note: this is useful and called 'mixin' style inheritance. how about "is-a" relationship?


={============================================================================
*kt_dev_ecpp_017* 50: when to replace new and delete

Three common reasons to replace complier provided operator new and delete.

1. To detect usage errors

1.1. Operator new keeps a list of allocated addresses and operator delete removes addresses from the
list, easy to detect usage errors.

1.2. Overrun and underrun. Have signature before and after the memory made available to clients.
Operator delete can check if the signatures are still intact, can log when overrun or underrun
occurred along with the value of the offending pointer.

2. To improve efficiency

2.1. The default operator new and delete is general purpose such as large blocks, small blocks, and
mixtures of the two. Have to worry about heap fragmentation. If know allocation 'pattern' of an
application, can use custom operator new and delete to have performance improvements.

2.2. Custom version for objects of a particular type such as class-specific allocators. Boot pool
libaray for fixed-size allocators.

2.3. Reduce space overhead. The general version often incur some overhead for each allocated block.
Allocators tuned for small objects such as boost pool library essentially eliminate such overhead.

2.4. Cluster related objects. If know that particular data structures are used together and like to
minimize page 'fault', can create a separate 'heap' for the data so they are clustered together as
few pages as possible. Placement version can make it possible to achieve such clustering. note:
placement new use case.

3. To collect usage statics

Before writing custom new and delete, gather information about how application uses dynamic memory.
Distribution of allocated block size, their lifetime, allocation and deallocation order such as
FIFO, LIFO, or random, usage pattern changes in different stages of execution, maximum amount of
allocated memory in use at any one time (high water mark or peak value). Custom version make it easy
to collect this kind of information.

4. To have unconventioal behavior

4.1. Allocate and deallocate blocks in shared memory which has a C API or memory-mapped I/O. note:
placement new use case.

4.2. Overwrite deallocated blocks with zeros in order to increase the security of application data.

<example> to show how to replace global operator new and see EC++51 for details
static const int signature = 0xDEADBEEF;

typedef unsigned char Byte;

// this code has several flaws
void* operator new( std::size_t size ) throw( std::bad_alloc )
{
  using namespace std;

  size_t realSize = size + 2*sizeof(int);

  void *pMem = malloc( realSize );
  if( !pMem ) throw bad_alloc();

  *(static_cast<int*>(pMem)) = signature;
  *(reinterpret_cast<int*>(static_cast<Byte*>(pMem)+realSize-sizeof(int)) ) = signature;

  return static_cast<Byte*>(pMem)+sizeof(int);
}

<alignment-consideration>
Many computer architectures require that data of particular type be placed in memory in particular
kinds of address. Called alignments. If not, cause hardware exception or slow performance. If simly
uses malloc then no problem since C++ guarantees malloc returns alligned pointer. However, the above
code is not returning a pointer we got from malloc. So this is consideration when think of custom
new and delete.

Two options: Compiler can have options for different memory managers or open source memory managers
such as boost pool library for allocation of a large number of small objects, fixed-size allocator.


={============================================================================
*kt_dev_ecpp_018* 52: placemane new

Widget* pw = new Widget;

Two functions are called: operator new and constructor. What would happen when operator new
  allocated memory but constructor raised exception? C++ runtime system gurantees to undo operator
  new.

{normal-new-and-delete-form}
The normal global new and delete are:

void* operator new( std::size_t ) throw (std::bad_alloc);            // normal new
void* operator new( std::size_t, void* ) throw();                    // placement new
void* operator new( std::size_t, const std::nothrow_t& ) throw();    // nothrow new
void operator delete( void* rawMemory ) throw ();
void operator delete( void* rawMemory, std::size_t ) throw ();       // at class scope


{placement-new} interview question
Means operator new function that takes extra parameters other than the size. To use this version of
new, include 'new' header.

note: see how passes parameters to operator new
note: operator new and deletes use 'overloads' mechanism.

// placement version to log allocations to ostream
static void* operator new( std::size_t size, std::ostream& os ) throw (std::bad_alloc);

// particularly useful placement version
void* operator new( std::size_t size, void *pMemory) throw();

<example>
One example is to tell not to raise exception. No exception and return nullptr instead. 

note: This is for older code which expect null pointer when allocation fails since newer C++ raise
an exception instead. This is called 'nothrow' new. This only guarentees no exception in operator
new but not whole expression since constructor can still raise an exception. So will never have a
need for nothrow new.

note: The nothrow keyword is the same as noexcept but used in new operator expression.

int* pi = new (std::nothrow) int;

<example>
The other example is that it is used inside vector<> to create objects in the vector's unused
capacity. note: not sure when looked at gcc code. 

<example>
new (place_address) type 
new (place_address) type (initializers)

Widget * constructWidgetInBuffer(void *buffer, int widgetSize)
{
  return new (buffer) Widget(widgetSize);
}

This function returns a pointer to a Widget object that's constructed within the buffer passed to
the function.

<must-provide-all>
C++ choose corresponding delete when undo operator new so must provide 'both' when customize new and
delete. If not found, no delete is called.

Suppose class specific new and delete that logs allocations to ostream.

class Widget {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);

    // normal class specific form of delete
    static void operator delete( void *p, std::size_t size ) throw();
};

Widget* pw = new (std::cerr) Widget;

As with nothrow version, the problem is that C++ cannot find the corresponding delete when
constructor raises exception. So must have placement 'delete' as well.

void operator delete(void*, std::ostream&) throw();

If not, no delete is called if constructor throws an exception.

However, consider what happens if no exception is thrown and get to delete in client code. This
calls the normal operator delete but not placement version. Placement delete is called 'only' if an
exception arises from a 'constructor' that's coupled to a call to a placement new.

delete pw;

Therefore, must provide all to forestall all memory leaks associated with placement versions of new.

class Widget {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);

    // placement version
    static void operator delete(void *p, std::ostream& os) throw();

    // normal delete
    static void operator delete(void *p) throw();
};

<consider-name-hide>
Since member function names hides functions in outer scopes, class specific new and delete hides
normal new and delete.

class Base {
  public:
    // non-normal from of new
    static void* operator new( std::size_t, std::ostream& os ) throw (std::bad_alloc);
};

Base* pb = new Base;                // error since normal new is hidden
Base* pb = new (std::cerr) Base;    // okay

Similarly, new in derived hides both global and inherited versions.

class Derived : public Base {
  static void* operator new( std::size_t size ) throw( std::bad_alloc );
};

Derived* pd = new (std::clog) Derived;    // error
Derived* pd = new Derived;                // okay

So unless mean to prevent class clients from using these forms, be sure to make them available in
addition to any custom versions you create.

<conclusion>
An easy way is to create base class containing all and client just use inheritance to get the
standard forms.

class StandardNewDeleteForms {
  public:
    // normal new/delete
    static void* operator new( std::size_t size ) throw (std::bad_alloc)
    { return ::operator new(size); }
    static void operator delete( void* rawMemory ) throw ()
    { ::operator delete(rawMemory); }

    // placement new/delete
    static void* operator new( std::size_t size, void* pMem ) throw()
    { return ::operator new(size, pMem); }
    static void operator delete( void* rawMemory, void* pMem) throw()
    { ::operator delete( rawMemory, pMem ); }

    // nothrow new/delete
    static void* operator new( std::size_t size, const std::nothrow_t& nt ) throw()
    { return ::operator new(size, nt); }
    static void operator delete( void* rawMemory, const std::nothrow_t&) throw()
    { ::operator delete( rawMemory ); }
};

class Widget : public StandardNewDeleteForms {
  public:
    // make those visible
    using StandardNewDeleteForms::operator new;
    using StandardNewDeleteForms::operator delete;

    static void* operator new( std::size_t size, std::ostream& os ) throw( std::bad_alloc );
    static void operator delete( void* rawMemory, std::ostream& os ) throw();
};


# ============================================================================
#{
={============================================================================
*kt_dev_mecpp_001* 16: 80-20 rule and profiler

Think about characteristics of your app such as IO-bound or CPU-bound. If a profiler tells you about
only the number of statments and func calls, then these can give you some insight but not enough.
The important thing is the time to wait. The input to profiler should represent 20%, called
<representative>, and use as many data set as possible. 


==============================================================================
*kt_dev_mecpp_002* 17: lazy evaluation

When you employ lazy evaluation, you write your classes in such a way that they defer computations
until the results of those computations are required. If the results are never required, the
computations are never performed.

Nevertheless, it's not always a good idea.  Lazy evaluation is only useful when there's a reasonable
chance your software will be asked to perform computations that can be avoided.

Yet C++ is particularly suitable as a vehicle for user-implemented lazy evaluation, because its
support for <encapsulation> makes it possible to add lazy evaluation to a class without clients of
that class knowing it's been done. 

That means it's possible to implement a class using a straightforward eager evaluation strategy, but
then, if your profiling investigations (see Item 16) show that class's implementation is a
performance bottleneck, you can replace its implementation with one based on lazy evaluation.


Four examples and one in *kt_dev_ecpp_006*	

{reference-counting}

class String { ... };

String s1 = "Hello";
String s2 = s1;

Such a copy constructor would incur a relatively large expense, because it would have to make a copy
of s1's value to give to s2, and that would typically entail allocating heap memory via the new
operator and calling strcpy to copy the data in s1 into the memory allocated by s2. This is eager
evaluation.

But s2 hasn't been used yet.

The lazy approach is a lot less work. Instead of giving s2 a copy of s1's value, we have s2 share
s1's value. Need some book-keeping and is transparent to clients: do not know difference.

Because they only read values, not write them. 

cout << s1;            // read s1's value
cout << s1 + s2;       // read s1's and s2's values

In fact, the only time the sharing of values makes a difference is when one or the other string is
modified;

s2.convertToUpperCase();

Inside convertToUpperCase, we can be lazy no longer: we have to make a copy of s2's (shared) value
for s2's private use.


{distinguish-read-and-write}

By using lazy evaluation and proxy classes as described in Item 30, however, we can defer the
decision on whether to take read actions or write actions until we can determine which is correct.


{lazy-fetching}

Imagine large objects containing many constituent fields which can be expensive to get from
database, even worse remote database. To restore a LargeObject is quite expensive.

class LargeObject {                   // large persistent objects
public:
	 LargeObject(ObjectID id);         // restore object from disk
	 const string& field1() const;     // value of field 1
	 int field2() const;               // value of field 2
	 double field3() const;            // ...
	 const string& field4() const;
	 const string& field5() const;
...
};

If need few fields like below,

void restoreAndProcessObject(ObjectID id)
{
	LargeObject object(id);

	if (object.field2() == 0) 
	{
	 	cout << "Object " << id << ": null field2.\n";
	}
}

Data is retrieved from the database only when that particular data is needed inside the object.
Here's one way to implement this kind of <demand-paged-object-initialization>

class LargeObject {
public:
	 LargeObject(ObjectID id);
	 const string& field1() const;
	 int field2() const;
	 double field3() const;
	 const string& field4() const;
	 ...
	 private:
	 ObjectID oid;
	 mutable string *field1Value;  // see below for a
	 mutable int *field2Value;     // discussion of "mutable"
	 mutable double *field3Value;
	 mutable string *field4Value;
	 ...
};

LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), ...
{}

const string& LargeObject::field1() const
{
	 if (field1Value == 0) {
		  read the data for field 1 from the database and make
		  field1Value point to it;
	 }
	 return *field1Value;
}

Null pointers signify fields that have not yet been read from the database. Each LargeObject member
function must check the state of a field's pointer before accessing the data it points to.


The problem that null pointers may need to be initialized to point to real data from inside any
member function. So need mutable keyword. <mutable-example>

NOTE: can use smart-pointer in item28

Refer to <lazy-initialisation>.



{lazy-expression-evaluation}

For numerical application.

template<class T>
class Matrix { ... }; // for homogeneous matrices

Matrix< int> m1(1000, 1000); // a 1000 by 1000 matrix
Matrix< int> m2(1000, 1000); // ditto
...

Matrix< int> m3 = m1 + m2; // add m1 and m2

Lazy evaluation strategy: Instead, it sets up a data structure inside m3 that indicates that m3's
value is the sum of m1 and m2. Such a data structure might consist of nothing more than a pointer to
each of m1 and m2, plus an enum indicating that the operation on them is addition.

Matrix< int> m4(1000, 1000);
... // give m4 some values
m3 = m4 * m1;

We can forget all about m3 being the sum of m1 and m2 (and thereby save the cost of the
computation),

A more common scenario is that we need only part of a computation. For example, suppose we use m3 as
follows after initializing it to the sum of m1 and m2:

cout << m3[4]; // print the 4th row of m3

Clearly we can be completely lazy no longer. But there's no reason we have to compute any more than
the fourth row of m3; the remainder of m3 can remain uncomputed until it's actually needed.

To be fair, laziness sometimes fails to pay off.

m3 = m1 + m2;  // remember that m3 is the sum of m1 and m2
m1 = m4;       // now m3 is the sum of m2 and the OLD value of m1!


Because of the need to store dependencies between values; to maintain data structures that can store
values, dependencies, or a combination of the two; and to overload operators like assignment,
copying, and addition, lazy evaluation in a numerical domain is a lot of work. 

KT. Need to understand expression like a compiler and need to see if it pays off.


==============================================================================
*kt_dev_mecpp_003* 18: over-eager evaluation

The idea behind over-eager evaluation is that if you expect a computation to be requested
frequently, you can lower the average cost per request by designing your data structures to handle
the requests especially efficiently.

<caching> and <prefetching> are examples. 

{space-and-time-trade-off}

that's that greater speed can often be purchased at a cost of increased memory usage.


{lazy-or-eager}

Lazy and eager are not contradictory to each other.

Lazy evaluation is a technique for improving the efficiency of programs when you must support
operations whose results are not always needed. Over-eager evaluation is a technique for improving
the efficiency of programs when you must support operations whose results are almost always needed
or whose results are often needed more than once.

both can yield significant performance improvements in programs whose behavioral characteristics
justify the extra programming effort.


={============================================================================
*kt_dev_mecpp_004* 


={============================================================================
*kt_dev_mecpp_005* 29: reference-counting

See {own-reference-counting} for simple example. This chapter is about how to implement sharing
underlying object like stl string class.

Two motivations:




{summary}

This is optimization technique. When useful because reference-counting costs more moeny, code,
complex and work.

o For cases when objects are big and there are many sharings. More memory to save.
o For cases when there are many copy and assign between objects. More time to save.

Need profiling. However, there is a case which cannot use this technique: data structures using
self-reference which causes isolated collection of objects and reference count never drops to zero.
Therfore, industrial garbage collectors use special technique to find these.


{approach-one}

{{copy-on-write}}

class String {
	 const char& operator[] (int index) const;
	 char& operator[] (int index);
	 ...
};

const version is read-only so that is okay. If want to separate read and write for non-const, that
is to create new object only when writing. How?

cout << s[3];     // read 
s[5] = 'x';       // write

Not possible to separate. This separation could be done using proxy class, MEC++ 30, so now assume
all non-const as write.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}

	return value->data[index];
}

This if-block works only when there is sharing before and create new one only when writing happens.
So this is copy-on-write and the example of {lazy-evaluation}


{{sharable}}

However, there are cases not covered:

String s1 = "Hello";
char* p = &s1[1];

String s2 = s1;
*p = 'x';                // change s1 and s2 as well


s1 -> 2 -> "Hello"
s2 -> 

note: how about stl string class? possible?


The problem is to change underlying object not through String interface. See *kt_dev_ecpp_007* for
returning handles to internal objects.

How to solve?

o Ignore this problem
o Hava a shareable flag in which to create new object when tries to change from outside. This is
waht stl string uses. This is ON by default, operator[] turn it OFF, and cannot change it once it is
OFF. Kind of dirty flag.

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 >
			 bool sharable;
<
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1), sharable(true) # <default>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

There should be a check in member funcs.

String::String( const String& rhs )
{ >
	 if( rhs.value->sharable ) {
<		  value = rhs.value;
		  ++value->refCount;
	 }
	 else {
		  value = new StringValue( rhs.value->data );
	 }
}

Assume that returning from this call means someone outside will have a reference to internal so make
it non-sharable always.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}
>
	value->sharable = false;
<
	return value->data[index];
}

For example:

String s1 = s2 = s3 = "Hello";

s1 -> 3 -> "Hello"
s2 -> 
s3 ->

s3[3] = 'x';

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"

String s4(s3);

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"
s4 -> 1 -> "Hello"


{{make-base-class-for-reference-counting}}

To make this reference counting available to any other class, so make it base class. note there is
no data in this class.

class RCObject {
	 public:
	 	RCObject();
		RCObject( const RCObject& rhs );
		virtual ~RCObject() = 0;

		RCObject& operator= ( const RCObject& rhs );

		... public interface
		addReference();

	private:
		size_t refCount;
		bool sharable;
};


The pure virtual means it must be used as a base class.

See ctor and copy ctor in setting refCount as 0 because it simplfies thing for the client to set
refCount to 1. copy ctor always set refCount to 0 because creating a new value and new value are
always unshared and referenced only by their creator.

RCObject::RCObject(): refCount(0), sharable(true) {}
RCObject::RCObject(const RCObject&): refCount(0), sharable(true) {}

RCObject::~RCObject() {}     # see {pure-virtual-dtor}

Copy assign do nothing and will not be used in reality because it is a base class for a shared value
object(StringValue) which are not assigned to one another. Only String do. {{why-need}} It said it
is for future use but seems not useful to consider since do nothing about refCount.

RCObject& RCObject::operator=( const RCObject& )
{ return *this;}

note: Really need copy ctor and copy assign?

<delete-this> is safe only if *this is a heap object.

void RCObject::removeReference()
{
	 if(--refCount == 0 ) delete this;   # <delete-this>
}

void RCObject::addReference() { ++refCount; }


class String {
	 private:
	 	struct StringValue : public RCObject {    # <public-inheritance>
			 char* data;                           # <data>
			 StringValue( const char* initValue );
			 ~StringValue();
		};
		...
};

String::StringValue::StringValue(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
	 delete [] data;
}


          RCObject: has reference-counting feature
			 |
String -> StringValue -> data

StringValue is almost the same but now StringValue do not manipulate refCount and RCObject has. But
String should call explicitly interfaces to manage refCount. It is clumsy because String must call
these to manage reference counting. can we make it done automatically? move it out of user class?

If can detect access to StringValue through pointer, it could. This is objcet which acts like a
pointer such as smart pointer and which support member selection(->) and dereferencing(*). 


This template gives smart pointer objects control over what happens during their construction,
assignment, and destruction. When such <events> occur, this object can automatically perform the
appropriate manipulations of the refCount field in the objects to which they point.


template<class T>
class RCPtr {
public:
	RCPtr(T* realPtr = 0);
	RCPtr(const RCPtr& rhs);
	~RCPtr();
	RCPtr& operator=(const RCPtr& rhs);
	T* operator->() const; // see Item 28
	T& operator*() const;  // see Item 28
private:
	T *pointee;  // dumb pointer this object is emulating
	void init(); // common initialization code
}; 

template<class T>
RCPtr< T>::RCPtr(T* realPtr): pointee(realPtr)
{
	init();
}

template<class T>
RCPtr< T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)
{
	init();
}

template<class T>
void RCPtr< T>::init()
{
	// if the dumb pointer is null, so is the smart one
	if (pointee == 0) { 
		return;         
	}
	// if the value is not shareable, copy it
	if (pointee->isShareable() == false) { 
		pointee = new T(*pointee); 
	} 
	// note that there is now a new reference to the value
	pointee->addReference(); 
} 

The problem is when T is StringValue and the following happens:

pointee = new T(*pointee);

There is no copy ctor of StringValue and syn version will be used. So memberwise copy but not a deep
copy. Therefore, needs String::StringValue::StringValue( const StringValue& rhs ) 


{{putting-it-all-together}}

Sting is reference counted string class.

                        RCObject
			               |
String               -> StringValue -> data
+RCPtr
+nested StringValue


/*
** RCObject : base class for reference counted objects
*/
class RCObject { 
public:
	 RCObject();
	 RCObject(const RCObject& rhs);
	 RCObject& operator=(const RCObject& rhs);
	 virtual ~RCObject() = 0;
	 void addReference();
	 void removeReference();
	 void markUnshareable();
	 bool isShareable() const;
	 bool isShared() const;
private:
	 size_t refCount;
	 bool shareable;
};

RCObject::RCObject() : refCount(0), shareable(true) {}
RCObject::RCObject(const RCObject&) : refCount(0), shareable(true) {}
RCObject& RCObject::operator=(const RCObject&) { return *this; }
RCObject::~RCObject() {}
void RCObject::addReference() { ++refCount; }

void RCObject::removeReference()
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }
bool RCObject::isShareable() const
{ return shareable; }
bool RCObject::isShared() const
{ return refCount > 1; }


/*
 * RCPtr
 */
template<class T> 
class RCPtr { 
public: 
	 RCPtr(T* realPtr = 0);
	 RCPtr(const RCPtr& rhs);
	 ~RCPtr();
	 RCPtr& operator=(const RCPtr& rhs);
	 T* operator->() const;
	 T& operator*() const;
private:
	 T *pointee;
	 void init();
};

template<class T>
void RCPtr<T>::init()
{
	// if the dump pointer is null, so is the smart one
	if (pointee == 0) return;

	// if is not sharable, create new one
	if (pointee->isShareable() == false) {
		pointee = new T(*pointee);
	}
	
	// new reference
	pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr(T* realPtr) : pointee(realPtr)
{ init(); }

template<class T>
RCPtr<T>::RCPtr(const RCPtr& rhs) : pointee(rhs.pointee)
{ init(); }

template<class T>
RCPtr<T>::~RCPtr()
{ if (pointee) pointee->removeReference(); }    # <delete-this-in-removeReference>

template<class T>
RCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)
{
	 // skip when the value does not change
	 if (pointee != rhs.pointee) {

		  T *oldPointee = pointee;
		  pointee = rhs.pointee;

		  // if possible share it, else make own copy
		  init();

		  // decrease reference
		  if (oldPointee) oldPointee->removeReference();
	 }

	 return *this;
}

template<class T>
T* RCPtr<T>::operator->() const { return pointee; }

template<class T>
T& RCPtr<T>::operator*() const { return *pointee; }


/*
 * String : class to be used by users
 */
class String { 
public: 
	 String(const char *value = "");
	 const char& operator[](int index) const;
	 char& operator[](int index);

private:
	 // class representing string values
	 struct StringValue: public RCObject {
		  char *data;
		  StringValue(const char *initValue);
		  StringValue(const StringValue& rhs);
		  void init(const char *initValue);
		  ~StringValue();
	};

	RCPtr<StringValue> value;
};


void String::StringValue::init(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}
String::StringValue::StringValue(const char *initValue)
{ init(initValue); }
String::StringValue::StringValue(const StringValue& rhs)
{ init(rhs.data); }
String::StringValue::~StringValue()
{ delete [] data; }


String::String(const char *initValue)
: value( new StringValue(initValue) ) {}        # <set-rcptr>

const char& String::operator[](int index) const
{ return value->data[index]; }

char& String::operator[](int index)
{
	if (value->isShared()) {
		value = new StringValue(value->data);
	}
	value->markUnshareable();
	return value->data[index];
}

<assumption>

RCPtr< T> has:

o deep-copying copy constructor
o T inherit from RCObject, or at least that T provide all the functionality that RCObject does. T
must support the RCObject interface and it menas RCPtr and RCObject is tightly coupled.


<note-one> <difference-in-interface-of-sting>
Now there is no need to have String copy ctor, assign, and dtor because syn version doing memberwise
will call matching one of RCPtr which doing work of managing refCount. That is smart.

note: This is an example of using syn version compiler made.

Our original goal was to move the unreusable reference-counting code out of our hand-written String
class and into context-independent classes where it would be available for use with any class. Now
we've done it (in the form of the RCObject and RCPtr classes),

note: Also there is nearly no changes to String interface. encapsulation.


{{add-reference-counting-to-existing-classes}} {wrapper}

How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


={============================================================================
*kt_dev_mecpp_006* 28: log entry

Class template for making log entries whenever a T object is modified; see below for details

template<class T>
class LogEntry {
  public:
    LogEntry(const T& objectToBeModified);
    ~LogEntry();
};

void editTuple(DBPtr<Tuple>& pt)
{
  LogEntry< Tuple> entry(*pt); // make log entry for this operation

  do {
    pt->displayEditDialog();
  } while (pt->isValid() == false);
}


The LogEntry's constructor begins the log entry and its destructor ends the log entry. Two pros:

1. handles exception case
2. easier to create a single LogEntry object than to add separate calls to start and stop an entry 

#include <iostream>

using namespace std;

template<typename T>
class LogEntry {
  public:
  LogEntry( const T& obj ) { cout << "{ modifed: " << obj << endl; }
  ~LogEntry() { cout << "}" << endl; }
};

void a_function(int arg)
{
  LogEntry<int> log(arg);

  cout << "this is a function" << endl;
}

int main()
{
  cout << "this is main { " << endl;

  a_function(5);

  cout << "this is main } " << endl;
}

this is main { 
{ modifed: 5
this is a function
}
this is main } 


={============================================================================
*kt_dev_mecpp_007* 34: combine C and C++

There are things to know when use both together in a program.

{name-mangling}
This is the process which C++ compiler give each function a unique name because supports
overloading. There is a directive to tell compiler not to mangle func name. This is called linkage
directive.


{extern-keyword}
The GCC compiles files based on extension. When compiles cpp files meaning cpp mangles names, you
can make sure that functions are c functions (not to mangle) :

extern "C" void drawLine(int x1, int y1, int x2, int y2);

extern "C" {
	 ...
}

extern "C" {
	 #include <string.h>
}

If you want to build a function as a c function, then can do: 

extern "C" double calc( double dparam )
{
	 ...
}

To allow source or header to be compiled under either C or C++.

#ifdef __cplusplus
extern "C"
{
#endif

int strcmp( const char*, const char* );
...

#ifdef __cplusplus
}
#endif


<extern-on-typedef>
Not only for function but also for function pointer typedef.

extern "C" typedef Plugin* createFunction_t(const char *);


<case-example> <wrapper-from-cpp-to-c>
This case is that main is in c and is to use some features written in cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typdefs               {
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Note This is a problem when use the same header in both c and cpp compile. Why extern C is needed in
the wrapper.h? If this is only used for C files then not needed but must for C and CPP source files.

Also because cpp file uses typedefs from it. So when compile cpp compiler thinks func defs are C++
linkage from wrapper header when there is no extern guard and then see wrapper_func in C linkage
from cpp file. So conflict and emits errors:

[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmosa.h:170:1: error: previous
declaration of 'pfmerr_t pfmThreadCreate(SPfmThreadParams*, void (*)(void*), void*)' with 'C++'
linkage 
[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmthread.cpp:80:80: error:
conflicts with new declaration with 'C' linkage

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)
#include "wrapper.h"                                 	extern "C"
                               typdefs                {
                                                          #include "wrapper.h" 
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									                                 ....
                                                          }
																			 ...
																		}

This can be avoided if design header and source files carefully. For example, if need some c
functions that can be used in c file and this function creates cpp objects and use it then simply
create a header which has normal declarations and no externs and only have externs in cpp. The point
is that the same header is used for both C and CPP.

// ususal c
#include "wrapper.h"
{
	wrapper_func();
}

// usual.h or wrapper.h
int wrapper_func();

// usual cpp or wrapper.cpp
extern "C"
{
  int wrapper_func()
  {
     ClassX* pclass = new Class( params );

     pclass->func();
     ...
  }
}

If usual cpp header or wrapper.h have other cpp headers, will work cpp compiles such as usual cpp
and others but when used in c compile, emits loads of errors since these cpp files have cpp things.
So better to have single header file which have all c functions from cpp land. Otherwise, will get
errors shown in *kt_dev_gcc_007* 

<extern-linkage>
Using extern to Specify Linkage
http://msdn.microsoft.com/en-us/library/0603949d.aspx

extern string-literal { declaration-list }
extern string-literal declaration

The extern keyword declares a variable or function and specifies that it has external linkage (its
    name is visible from files other than the one in which it's defined). When modifying a variable,
    extern specifies that the variable has static duration (it is allocated when the program begins
        and deallocated when the program ends). The variable or function may be defined in another
    source file, or later in the same file. Declarations of variables and functions at file scope
    are external by default.

In C++, when used with a string, extern specifies that the linkage conventions of another language
are being used for the declarator(s). C functions and data can be accessed only if they are
previously declared as having C linkage. However, they must be defined in a separately compiled
translation unit.

Microsoft C++ supports the strings "C" and "C++" in the string-literal field. All of the standard
include files use the extern "C" syntax to allow the run-time library functions to be used in C++
programs.

The following example shows alternative ways to declare names that have C linkage:

// specifying_linkage2.cpp
// compile with: /c
// Declare printf with C linkage.
extern "C" int printf( const char *fmt, ... );

//  Cause everything in the specified header files
//   to have C linkage.
extern "C" {
   // add your #include statements here
   #include <stdio.h>
}

//  Declare the two functions ShowChar and GetChar
//   with C linkage.
extern "C" {
   char ShowChar( char ch );
   char GetChar( void );
}

//  Define the two functions ShowChar and GetChar
//   with C linkage.
extern "C" char ShowChar( char ch ) {
   putchar( ch );
   return ch;
}

extern "C" char GetChar( void ) {
   char ch;

   ch = getchar();
   return ch;
}

// Declare a global variable, errno, with C linkage.
extern "C" int errno;


{example-from-code}
/* Define C declaration macros for C++ compatibility. */                                
#if !defined(BEGIN_C_DECLS) && !defined(END_C_DECLS)
#if defined(__cplusplus) || defined(c_plusplus)
# define BEGIN_C_DECLS extern "C" {
# define END_C_DECLS   }
#else /* !__cplusplus */
# define BEGIN_C_DECLS
# define END_C_DECLS
#endif /* __cplusplus */
#endif /* BEGIN_C_DECLS && END_C_DECLS */


{function-pointer-between}
If use function-pointer or function-pointer as arg between them, see Primus p859 for more.


{cpp-main}
The cpp-main has three stages: static-initialisation, main, and static-destruction. So if not use
cpp-main when use both, will not work as expected and shall use cpp-main.

extern "C" int realMain(...);

int main( ... )
{
	 return realMain( ... );
}

This is dependent on compiler and shall check with it.

KT: is it still ture? ture for gcc?


{new-delete-and-malloc-free}
Do not mix between new/delete and malloc/free. For example, char* strdup(char *ps), which is not
standard in C/C++. Need to free or delete? It depends on system and compiler so recommends that do
not use funcs which is not standard.

<Q> not standard? The ansic book do not have strdup in string.h in appendix. This is what was said
it's not standard. Now seems it's part of string.h in GCC.

<online>
strdup is not a standard C++ function. but it is apparently a Posix function, and anyway it's a well
known function which has been there since K&R C. so if you absolutely must use it, do not fret about
any possible name collision, and just write strdup for maximum portability.

Why is strdup considered to be evil? Two reasons I can think of:

It's not strictly ANSI C, but rather POSIX. Consequently, some compilers (e.g. MSVC) discourage use
(MSVC prefers _strdup), and technically the C standard could define its own strdup with different
semantics since str is a reserved prefix. So, there are some potential portability concerns with its
use. 

It hides its memory allocation. Most other str functions don't allocate memory, so users might be
misled (as you say) into believing the returned string doesn't need to be freed.

But, aside from these points, I think that careful use of strdup is justified, as it can reduce code
duplication and provides a nice implementation for common idioms (such as strdup("constant string")
to get a mutable, returnable copy of a literal string).


{data-structure-in-between}
The objects that have virtual and inheritance are not compatible with C. This affects when calling
funcs with return or args between them.


==============================================================================
*kt_dev_mecpp_008*	32: program in the future tense

To be prepared for the change. How?

{one}

Express design decision in code instead of comments or documents. For example,
preventing-derivation.


{two}

Design code so that when changes are necessary, the impact is localized. Asks how the class is
designed to be used. See future thense and this is a example of virtual dtor. Encapsulation.


# ============================================================================
#{
={============================================================================
*kt_dev_estl_001*	02: illusion of container-independent code

STL is based on generalizaiton: container is array generalization, iterator is pointer, and
algorithm is function. but do not mean that can write container-independent code because each
container has different interface and characteristics. To minimize impcats of changing containers,
use <encapsulation> using typedef and class.

{no-encapsulation}

class Widget { ... };
vector< Widget > vw;
Widget bestWidget;
...
vector< Widget >::iterator i = find( vw.begin(), vw.end(), bestWidget );


{first-improvement}

class Widget { ... };
>
 typedef vector< Widget > WidgetContainer;
 WidgetContainer vw;
<
Widget bestWidget;
...
>
 WidgetContainer::iterator i = find( vw.begin(), vw.end(), bestWidget );

Also, save you some typing as think about:

map< sting, vector< Widget >::iterator, CIStingCompare>;

Want to sell out the below?

map< sting, vector< Widget >::iterator, CIStingCompare>::const_iterator;


{second-improvement}
Using typdef is not enough to separate client so use class:

class CustomerList {
	 private:
	 >
	 typedef list< Customer > CustomerContainer;
	 typedef CustomerContainer::iterator CCIterator;
	 CustomerContainer customers;
<
	 public:
	 // limit the list-specific detail visible through this interface
	 ...
};


# ============================================================================
#{ c++ concurrent in action
={============================================================================
*kt_dev_ccon_000* std::thread build

Listing 1.1

#include <iostream>
#include <thread>

using namespace std;

void hello()
{
    std::cout << "Hello concurrent world\n";
}

int main(int argc, char** argv)
{
    std::thread t(hello);
    t.join();
}

$ g++ -g -std=c++0x tthread.cpp 
$ ./a.out 
terminate called after throwing an instance of 'std::system_error'
  what():  Operation not permitted
Aborted

$ g++ -g -std=c++0x -pthread tthread.cpp 
$ ./a.out 
Hello concurrent world


={============================================================================
*kt_dev_ccon_001* std::thread join and detach

Once started a thread, need to explicitly decide whether to wait for it to finish by joining or
leave it to run on its own by detaching.

If don't decide before thread object is destoryed, then your program is terminated. the std::thread
destructor calls std::terminate().

If don't wait for a thread to finish, lifetime issues can happen and that's why must use
self-contained approach.

struct func
{
    int i;

    func( int & i_ ): i(i_) {}

    void operator()()
    {
        ...
    }
};

void oops()
{
    int some_local_state = 0;

    func my_func( some_local_state );

    std::thread my_thread( my_func );  // new thread might still be running after oops()

    my_thread.detach();                // should be my_thread.join();
}


={============================================================================
*kt_dev_ccon_002* std::thread copy callables and arguments

The std::thread object must be self-contained and this means initial function and its arguments
should be copied into a thread object.

class background_task
{
    public:
        void operator()() const
        {
            do_something();
            do_something_else();
        }
};

background_task f;

std::thread my_thread(f);

If use callable object, it is 'copied' into the storage belonging to the newly created thread of
execution and invoked from there. It's therefore essential that the copy behave equivalently to the
original, or the result may not be what's expected.

note: std::bind uses the same mechanism.

Really?

If not, can cause lifefime issue. For stl algorithms and predicates, use either usual function or
temporary functional object and passes it as argument. Since the temporty object is self-contained
and it is okay to use with stl algorithms. 

When thread object is self-contained and is detached, no need to worry about lifetime issue. Really?
See this example:

void f( int i, std::string const& s );
std::thread t( f, 3, "hello" );

This creates a new thread which calls f( 3, "hello" ) and the second argument is passed as a "char
const *" and converted to a std::string. This is particularly important when the argument supplied
is a pointer to an automatic variable, as follows:

void f( int i, std::string const& s );

void oops( int some_param )
{
    char buffer[1024];

    sprintf( buffer, "%i", some_param );
    std::thread t( f, 3, buffer );
    t.detach();
}

The problem is that there is a significance chance that the function oops will exit before the
buffer has been converted to a std::string on the new thread, thus leading to undefined behavior
because it relies on implicit conversion and it is copied.

The solution is to do it explicitly before passing the buffer to the std::thread constructor:

void oops( int some_param )
{
    char buffer[1024];

    sprintf( buffer, "%i", some_param );
    std::thread t( f, 3, std::string(buffer) );
    t.detach();
}

The other problem is:

void update_data_for_widget( widget_id w, widget_data& data );

void oops_again( widget_id w )
{
    widget_data data;

    std::thread t( update_data_for_widget, w, data );
    display_status();
    t.join();
    process_widget_data(data);
}

Although passed by reference, still copied and has internal copy. The problem is that
process_widget_data will be passed an unchanged data rather than a correctly updated version.

The solution is to use:

std::thread t( update_data_for_widget, w, std::ref(data) );

Since it uses t.join() it is safe to use reference to local variable.

<member-function-pointer>

class X
{
    public:
        void do_lengthy_work();
};

X my_x;

std::thread t( &X::do_lengthy_work, &my_x );

<noncopyable-arguments>
Since unique_ptr is only moveable and not a temporary but named object, must be requested explicitly
by std::move().

void process_big_object( std::unique_ptr<big_object> );

std::unique_ptr<big_object> p( new big_object );
p->prepare_data(42);
std::thread t( process_big_object, std::move(p) );

<thread-movable>
This means that std::thread is movable to ensure that only one thread object is associated with a
particular thread of execution at any one time.


<from-stl-code>
/// thread
class thread
{
    template<typename _Callable>
        struct _Impl : public _Impl_base
    {
        _Callable    _M_func;          // note:

        _Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
        { }

        void
            _M_run() { _M_func(); }
    };

    private:
    void _M_start_thread(__shared_base_type);

    public:

    thread() noexcept = default;
    thread(thread&) = delete;
    thread(const thread&) = delete;

    thread(thread&& __t) noexcept
    { swap(__t); }
    template<typename _Callable, typename... _Args>
        explicit 
        thread(_Callable&& __f, _Args&&... __args)
        {
            _M_start_thread(_M_make_routine(std::__bind_simple(
                            std::forward<_Callable>(__f),
                            std::forward<_Args>(__args)...)));
        }

    template<typename _Callable> shared_ptr<_Impl<_Callable>> _M_make_routine(_Callable&& __f)
    {
        // Create and allocate full data structure, not base.
        return std::make_shared<_Impl<_Callable>>(std::forward<_Callable>(__f));
    }
};


={============================================================================
*kt_dev_ccon_003* race condition, data race and approaches 

{broken-invariant}
There are problems with sharing data between threads due to the consequences of modifying data. The
concept used is 'invariant' that is statement always true about a particular data structures.
The problem is when the invariants of the system cannot be maintained. Broken invariants.

{race-conditions}
A race condition is anything where the outcome depends on the relative ordering of execution of
operations on two or more threads. It is when the race condition leads to broken invariants that
there is a problem.

Such problems will show up at the most inconvenient time since the race conditions are "timing
sensitive" and hard to find and duplicate because the window of opportunity is small.

<data-race>
The C++ Standard also defines the term data race to mean the specific type of race condition that
arises because of concurrent modification to a single 'object'

<approaches-to-solve>
o The simplest option is to wrap your data structure with a protection mechanism

o lock-free programming

o software transactional memory (STM)


={============================================================================
*kt_dev_ccon_004* std::mutex and inherent race in thread-safe stack

{std-mutex}
Mutexes are the most general of the data-protection mechanisms. But they're not a silver bullet;
it's important to structure your code to protect the right data and avoid race conditions inherent
in your interfaces. Mutexes also come with their own problems, in the form of a deadlock and
protecting either too much or too little data.

<lock-guard>
Not recommended practice to call the member functions, lock() and unlock(), directly, because this
means that you have to remember to call unlock() on every code path out of a function, including
those due to exceptions.

the std::lock_guard class template, which implements that RAII idiom for a mutex;

#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    some_list.push_back(new_value);
}

bool list_contains(int value_to_find)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();
}

Can encapsulate the functionality and enforce the protection and it's common to group the mutex and
the protected data together in a class rather than use global variables.


{design-considerations}
If all the member functions of the class lock the mutex before accessing any other data members and
unlock it when done, the data is nicely protected from all comers.

Really?

Well, thats not quite true. If one of the member functions returns a pointer or reference to the
protected data? doesn't matter that the member functions all lock the mutex

Protecting data with a mutex therefore requires careful interface design, to ensure that the mutex
is locked before there's any access to the protected data and that there are no backdoors.


<do-not-pass-protected-data>
If do careful design, the data is safe now? No. If you dig a little deeper, it's not that
straightforward. Nothing ever is.

As well as checking that the member functions don't pass out pointers or references to their
callers. also to check that they don't pass such pointers or references in to functions they call
that aren't under your control; functions that are supplied at runtime via a function argument or
other means

Accidentally passing out a reference to protected data

class some_data
{
    int a;
    std::string b;
    public:
    void do_something();
};

class data_wrapper
{
    private:
        some_data data;
        std::mutex m;
    public:
        template<typename Function> void process_data(Function func)
        {
            std::lock_guard<std::mutex> l(m);
            func(data);                         // pass "protected" data to user-supplied function
        }
};

some_data* unprotected;

void malicious_function(some_data& protected_data)
{
    unprotected=&protected_data;
}

data_wrapper x;

void foo()
{
    x.process_data(malicious_function);
    unprotected->do_something();                // unprotected access to protected data
}


{race-condition-inherent-in-interface}
Consider the doubly linked list example again. In order for a thread to safely delete a node, you
need to ensure that you're preventing concurrent accesses to three nodes: the node being deleted and
the nodes on either side. If you protected accesses to the pointers of each node individually, you'd
be no better off than with code that used no mutexes, because the race condition could still happen:

it's not the individual nodes that need protecting for the individual steps but the whole data
structure, for the whole delete operation. The easiest solution in this case is to have a single
mutex that protects the entire list.

Just because individual operations on the list are safe, you can still get race conditions, even
with a really simple interface since interface is not well designed. Consider std::stack<>.

template< typename T, typename Container=std::deque<T> >
class stack
{
    public:

        // ...
        
        bool empty() const;
        size_t size() const;
        
        T& top();
        T const& top() const;

        void push(const T& );
        void push(T &&);

        void pop();
};

The problem is not about mutex-based implementation. it's an interface problem so the race condition
would still occur with a lock-free implementation. this interface is inherently subject to race.

The problem is that the result of empty() and size() can't be relied on. 

stack<int> s;

if(!s.empty())                            <-
{
    int const value = s.top();      <-    <-
    s.pop();                        <-
    do_something(value);
}

1. empty-and-top sequence
Calling top() on an empty stack is undefined. classic race.

2. top-and-pop sequence
One of the two values on the stack is discarded without ever having been read, whereas the other is
processed twice. another race and far more 'insidious'. there's never anything obviously wrong going
on and the consequence of the bug are far from the cause although depends on exactly what
do_something really dose.

<option-1> note: this is a discusssion in Exceptional C++
one that combine the calls to top() and pop() under the mutex. that is pop() return the value as
well as remove it from the stack. However, can leads to issue if the copy constructor for the
objects on the stack can throw an exception.

Consider stack<vector<int>>. Now, a vector is a dynamically sized container, so when you copy a
vector the library has to allocate some more memory from the heap in order to copy the contents. If
the system is heavily loaded, or there are significant resource constraints, this memory allocation
can fail, so the copy constructor for vector might throw a std::bad_alloc exception. This is
especially likely if the vector contains a lot of elements. If the pop() function was defined to
return the value popped, as well as remove it from the stack, you have a potential problem: the
value being popped is returned to the caller 'only' after the stack has been modified, but the
process of copying the data to return to the caller might throw an exception. If this happens, the
data just popped is lost; it has been removed from the stack, but the copy was unsuccessful! 
    
The designers of the std::stack interface helpfully split the operation in two: get the top element
(top()) and then remove it from the stack (pop()), so that if you can't safely copy the data, it
stays on the stack. If the problem was lack of heap memory, maybe the application can free some
memory and try again. Unfortunately, it's precisely this split that you're trying to avoid in
eliminating the race condition!

<option-2>
Pass a reference to receive the popped value.

std::vector<int> result;
some_stack.pop(result);

Has the distinct disadvantage; the stored type is assignable which is restriction since many user
type do not support it.

<option-3>
Use no-throw copy or move constructor. Limited since restrict the use of this thread-safe stack to
those types that can safely be returned by value without an exception. note: may change as more type
supports move semantics. 

<option-4>
Return a pointer to the popped item. That is to use dynamically allocated item and pass its pointer.
The advantage here is that pointers can be freely copied without throwing an exception, so you've
avoided Cargills exception problem.

However, requiring that each object in the stack be allocated separately with new would impose quite
an overhead compared to the original non-thread-safe version.

<option-5>
Provide both option 2 and either option 3 or 4. Flexibility should never be ruled out.

<thread-safe-stack>
This implements option 2 and 4.

#include <exception>
#include <memory>
#include <mutex>
#include <stack>

struct empty_stack: std::exception
{
    const char* what() const throw();
};

template<typename T>
class threadsafe_stack
{
    private:
        std::stack<T> data;
        mutable std::mutex m;             // <mutable>
    public:
        threadsafe_stack(){}
        threadsafe_stack(const threadsafe_stack& other)
        {
            std::lock_guard<std::mutex> lock(other.m);
            data=other.data;
        }
        threadsafe_stack& operator=(const threadsafe_stack&) = delete;

        void push(T new_value)
        {
            std::lock_guard<std::mutex> lock(m);
            data.push(new_value);
        }
        std::shared_ptr<T> pop()
        {
            std::lock_guard<std::mutex> lock(m);
            if(data.empty()) throw empty_stack();
            std::shared_ptr<T> const res(std::make_shared<T>(data.top()));
            data.pop();
            return res;
        }
        void pop(T& value)
        {
            std::lock_guard<std::mutex> lock(m);
            if(data.empty()) throw empty_stack();
            value=data.top();
            data.pop();
        }
        bool empty() const
        {
            std::lock_guard<std::mutex> lock(m);
            return data.empty();
        }
};

note: when initializer-list is not useful
This stack implementation is actually copyable; the copy constructor locks the mutex in the source
object and then copies the internal stack. You do the copy in the constructor body rather than the
member initializer list in order to ensure that the mutex is held across the copy.

note: no need empty() since use exception.
Your five stack operations have now become three: push(), pop(), and empty(). Even empty() is
superfluous.


={============================================================================
*kt_dev_ccon_005* deadlock prevention and std::lock_guard

deadlock does not just occur with locks: can occur any synchronization construct that can lead to a
wait cycle. "neither thread can make progress because it is waiting for
the other to finish."

Simple rules that can help you to write deadlock-free code.

o Avoid nested locks
o Avoid calling user-supplied code while holding a lock
o Acquire locks in a fixed or the same order

Although fixed order used, deadlock can still occur. Consider that use a mutex to protect each
instance of the same class, use operation that exchanges data between two instances. The mutexes on
both instances must be locked. If two threads calls this operation with the parametars(instances)
swapped then you have deadlock. 

std::lock() can lock two or more mutexes at 'once' without risk of deadlock and provides
'all-or-nothing' semantics.

class X
{
    private:
        std::mutex m;

    public:

        friend void swap( X& lhs, X& rhs )
        {
            if( &lhs == &rhs )
                return;

            // lock two mutexes
            std::lock( lhs.m, rhs.m );
            
            // std::adopt_lock to indicate to std::lock_guard objects that the mutexes are 'already'
            // locked.
            std::lock_guard<std::mutex> lock_a( lhs.m, std::adopt_lock );
            std::lock_guard<std::mutex> lock_b( rhs.m, std::adopt_lock );

            swap( lhs.some_detail, rhs.some_detail );
        }
};


o Use a lock hierarchy
This is really a particular case of lock-ordering and can provide a means of checking at runtime.
The idea is to divide an application into 'layers' and identify all the mutexes that may be locked
in any given layer.

hierarchical_mutex high_level_mutex(10000);
hierarchical_mutex low_level_mutex(5000);

int do_low_level_stuff();

int low_level_func()
{
    std::lock_guard< hierarchical_mutex> lk( low_level_mutex );
    return do_low_level_stuff();
}

void high_level_stuff(int some_param);

void high_level_func()
{
    std::lock_guard< hierarchical_mutex > lk( high_level_mutex );
    high_level_stuff( low_level_func() );
}

void thread_a()
{
    high_level_func();
}

hierarchical_mutex other_mutex(100);

void do_other_stuff();

void other_stuff()
{
    high_level_func();
    do_other_stuff();
}

void thread_b()
{
    std::lock_guard< hierarchical_mutex > lk(other_mutex);
    other_stuff();
}

1. thread_b() is not fine. this does mean that can't hold two locks at the same time if they're the
same level in the hierarchy so hand-over-hand locking schemes require that each mutex in the chain
have a lower value than the prior one which my be impractical in some cases.

2. show the use of std::lock_guard with user-defined mutex type. should have three member functions:
lock, unlock and try_lock which forward to the same name on the underlying mutex. 

class hierarchical_mutex
{
    std::mutex internal_mutex;

    unsigned long const hierarchy_value;
    uisigned long previous_hierarchy_value;

    static thread_local unsigned long this_thread_hierarchy_value;

    void check_for_hierarchy_violation()
    {
        if( this_threa_hierarchy_value <= hierarchy_value )
        {
            throw std::logic_error( "mutex hierarchy violated" );
        }
    }

    void update_hierarchy_value()
    {
        previous_hierarchy_value = this_thread_hierarchy_value;
        this_thread_hierarchy_value = hierarchy_value;
    }

    public:
    explicit hierarchical_mutex( unsigned long value ):
        hierarchy_value( value ), previous_hierarchy_value( 0 )
    {}

    void lock()
    {
        check_for_hierarchy_violation();
        internal_mutex.lock();
        update_hierarchy_value();
    }

    void unlock()
    {
        this_thread_hierarchy_value = previous_hierarchy_value;
        internal_mutex.unlock();
    }

    bool try_lock()
    {
        check_for_hierarchy_violation();
        if( internal_mutex.try_lock() )
            return false;
        update_hierarchy_value();
        return true;
    }
};

// <thread-local> since it is declared thread_local, every thread has its 'own' copy
thread_local unsigned long
   hierarchical_mutex::this_thread_hierarchy_value( ULONG_MAX );


={============================================================================
*kt_dev_ccon_006* std::unique_lock and deferred locking

std::unique_lock provides more 'flexibility' than std::lock_guard.

1. std::defer_lock to indicate that the mutex should remian unlocked on construction then later
locked by calling std::unique_lock.lock().

2. std::uniqie_lock is typically larger and has a slight performance penalty so lock_guard is in
preference if it suits.

class X
{
    private:
        std::mutex m;

    public:

        friend void swap( X& lhs, X& rhs )
        {
            if( &lhs == &rhs )
                return;

            std::unique_lock<std::mutex> lock_a( lhs.m, std::defer_lock );
            std::unique_lock<std::mutex> lock_b( rhs.m, std::defer_lock );

            // lock two mutexes
            std::lock( lock_a, lock_b );

            swap( lhs.some_detail, rhs.some_detail );
        }
};


={============================================================================
*kt_dev_ccon_007* std::unique_lock and transferring mutex

{flexible-unique-lock}
Because unique_lock instances don't have to own their associated mutexes, the ownership of a mutex
can be transferred between instances by moving the instances around.

One possible use is to allow a function to lock a mutex and transfer ownership of that lock to the
caller, so the caller can then perform additional actions under the protection of the same lock.

std::unique_lock<std::mutex> get_lock()
{
    extern std::mutex some_mutex;

    std::unique_lock<std::mutex> lk( some_mutex );
    prepare_data();

    return lk;
}

note: lk is local variable and can be returned without calling std::move since the compiler takes
care of calling the move constructor.

note: some_mutex is 'extern'

void process_data()
{
    std::unique_lock<std::mutex> lk(get_lock());
    do_something();
}

<gatweay-class>
One such usage is where the lock isn't returned directly but is a data member of a gateway class
used to ensure correctly locked access to some protected data. 

In this case, all access to the data is through this gateway class; when you wish to access the
data, you obtain an instance of the gateway class (by calling a function such as get_lock() in the
        preceding example), which acquires the lock. You can then access the data through member
functions of the gateway object. 
        
When you're finished, you destroy the gateway object, which releases the lock and allows other
threads to access the protected data. Such a gateway object may well be movable so that it can be
returned from a function, in which case the lock object data member also needs to be movable.

<manual-option>
The flexibility of std::unique_lock also allows instances to relinquish their locks before they're
destroyed. You can do this with the unlock() member function, just like for a mutex:
std::unique_lock supports the same basic set of member functions for locking and unlocking as a
mutex does, in order that it can be used with generic functions such as std::lock.


={============================================================================
*kt_dev_ccon_008* std::unique_lock and granulity

Not only is it important to choose a sufficiently coarse lock granularity to ensure the required
data is protected, but it's also important to ensure that a lock is held only for the operations
that actually require it since holding the lock will 'delay' other threads unnecessary. less
contention.

std::unique_lock works well in this situation, because you can call unlock() when the code no longer
needs access to the shared data and then call lock() again if access is required later in the code:

void get_and_process_data()
{
    std::unique_lock<std::mutex> my_lock(the_mutex);

    some_class data_to_process = get_next_data_chunk();

    my_lock.unlock();

    retult_type result = process( data_to_process );

    my_lock.lock();

    write_result( data_to_process, result );
}

The previous swap examples using locks must lock both instance. If you were trying to compare a
simple data member that is int and is cheap to copy compared to big_data in previous examples then
can minimize locking time by holding single lock as below?

// listing 3.10

class Y
{
    private:
        int some_detail;
        mutable std::mutex m;
        int get_detail() const
        {
            std::lock_guard<std::mutex> lock_a(m);
            return some_detail;
        }
    public:
        Y(int sd):some_detail(sd){}
        friend bool operator==(Y const& lhs, Y const& rhs)
        {
            if(&lhs==&rhs)
                return true;
            int const lhs_value=lhs.get_detail();
            int const rhs_value=rhs.get_detail();
            return lhs_value==rhs_value;
        }
};

NO. this has changed the semantics of operations since compare values from different point in time.
So comparison is meaningless and race condition.

To be careful that the semantics of the operation are not changed in a problematic fashion.


={============================================================================
*kt_dev_ccon_009* std::call_once and protecting during initialization

One particularly extreme (but remarkably common) case is where the shared data needs protection only
from concurrent access while its being initialized, but after that no explicit synchronization is
required. This might be because the data is read-only once created, and so there are no possible
synchronization issues, or it might be because the necessary protection is performed implicitly as
part of the operations on the data.

It's for this reason that the C++ Standard provides a mechanism purely for protecting shared data
during initialization.

Suppose you have a shared resource that's so expensive to construct that you want to do so only if
it's actually required; maybe it opens a database connection or allocates a lot of memory. Lazy
initialization such as this is common in single-threaded code

std::shared_ptr<some_resource> resource_ptr;

void foo()
{
    if(!resource_ptr)
    {
        resource_ptr.reset(new some_resource);
    }
    resource_ptr->do_something();
}


A naive translation to multithreaded code which cause unnecessary serialization of threads using the
resource. This is because each thread must wait on the mutex in order to check whether the resource
has already been initialized.


std::shared_ptr<some_resource> resource_ptr;

std::mutex resource_mutex;

void foo()
{
    std::unique_lock<std::mutex> lk(resource_mutex);
    if(!resource_ptr)
    {
        resource_ptr.reset(new some_resource);
    }
    lk.unlock();

    resource_ptr->do_something();
}


<data-race>
This so called "double-checked locking" is better?

void undefined_behaviour_with_double_checked_locking()
{
    if(!resource_ptr)
    {
        std::lock_guard<std::mutex> lk(resource_mutex);
        if(!resource_ptr)
        {
            resource_ptr.reset(new some_resource);
        }
    }
    resource_ptr->do_something();
}


No it cause race condition since read to resource_ptr outside the lock and write inside the lock are
not synchronized. May run on different instance. This is defined "data race".


<std-once>
C++ provides std::once_flag and std::call_once to handle this situation. Every thread can just use
std::call_once and this do the same as "naive translation" but has a lower overhead.


std::shared_ptr<some_resource> resource_ptr;

std::once_flag resource_flag;

void init_resource()
{
    resource_ptr.reset(new some_resource);
}

void foo()
{
    std::call_once(resource_flag,init_resource);      // is called exactly once
    resource_ptr->do_something();
}


The example when used with a class:

class X
{
    private:
        connection_info connection_details;
        connection_handle connection;
        std::once_flag connection_init_flag;
        void open_connection()
        {
            connection=connection_manager.open(connection_details);
        }
    public:
        X(connection_info const& connection_details_):
            connection_details(connection_details_)
    {}

        void send_data(data_packet const& data)
        {
            std::call_once(connection_init_flag,&X::open_connection,this);
            connection.send_data(data);
        }

        data_packet receive_data()
        {
            std::call_once(connection_init_flag,&X::open_connection,this);
            return connection.receive_data();
        }
};

As with std::thread and std::bind, used additional argument to call_once.


note:
It's worth noting that, like std::mutex, std::once_flag instances can't be copied or moved, so if
you use them as a class member like this, you'll have to explicitly define these special member
functions should you require them.


<alternative-to-call-once>
One scenario where there's a potential race condition over initialization is that of a local
variable declared with static.

see <init-order-problem>

In C++11 this problem is solved: the initialization is defined to happen on exactly one thread, and
no other threads will proceed until that initialization is complete, so the race condition is just
over which thread gets to do the initialization rather than anything more problematic. This can be
used as an alternative to std::call_once for those cases where a single global instance is required:


Protecting data only for initialization is a special case of a more general scenario: that of a
rarely updated data structure. For most of the time, such a data structure is read-only and can
therefore be merrily read by multiple threads concurrently.

note: singleton is read-only


={============================================================================
*kt_dev_ccon_010* boost::shared_lock and read-write lock

For most of the time, such a data structure is read-only and can therefore be merrily read by
multiple threads concurrently, but on occasion the data structure may need updating?

What's needed is a different kind of mutex. This new kind of mutex is typically called a
reader-writer mutex, because it allows for two different kinds of usage: exclusive access by a
single "writer" thread or shared, concurrent access by multiple "reader" threads.

The new C++ Standard Library doesn't provide such a mutex out of the box and is provided by the
boost library, which is based on the proposal.

note: 
The performance is dependent on the number of processors involved and the relative workloads of the
reader and updater threads. therefore important to profile the performance of the code on the target
system to ensure that there's actually a benefit to the additional complexity.

Typically, a given DNS entry will remain unchanged for a long period of time in many cases DNS
entries remain unchanged for years. Although new entries may be added to the table from time to time
as users access different websites, this data will therefore remain largely unchanged throughout its
life.

Those threads that don't need to update the data structure can instead use
boost::shared_lock<boost::shared_mutex> to obtain shared access. This is used just the same as
std::unique_lock, except that multiple threads may have a shared lock on the same
boost::shared_mutex at the same time. 

#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>

class dns_entry;

class dns_cache
{
    std::map<std::string,dns_entry> entries;

    mutable boost::shared_mutex entry_mutex;          // <mutable>

    public:
    dns_entry find_entry(std::string const& domain) const
    {
        boost::shared_lock<boost::shared_mutex> lk(entry_mutex);

        std::map<std::string,dns_entry>::const_iterator const it= entries.find(domain);
        return (it==entries.end()) ? dns_entry() : it->second;
    }

    void update_or_add_entry(std::string const& domain, dns_entry const& dns_details)
    {
        std::lock_guard<boost::shared_mutex> lk(entry_mutex);
        entries[domain]=dns_details;
    }
};

The only constraint is that if any thread has a shared lock, a thread that tries to acquire an
exclusive lock will block until all other threads have relinquished their locks, and likewise if any
thread has an exclusive lock, no other thread may acquire a shared or exclusive lock until the first
thread has relinquished its lock.

So update_or_add_entry() uses an instance of std::lock_guard<> to provide exclusive access while the
table is updated; not only are other threads prevented from doing updates in a call
update_or_add_entry(), but threads that call find_entry() are blocked too.


={============================================================================
*kt_dev_ccon_011* recursive lock

With std::mutex, it's an error for a thread to try to lock a mutex it already owns, and attempting
to do so will result in undefined behavior. However, in some circumstances it would be desirable for
a thread to reacquire the same mutex several times without having first released it. For this
purpose, the C++ Standard Library provides std::recursive_mutex.

Most of the time, if you think you want a recursive mutex, you probably need to change your design
instead.

Since, in particular, the class invariants are typically broken while the lock is held.


={============================================================================
*kt_dev_ccon_012* std::condition_variable

Because std::condition_variable_any is more general, there's the potential for additional costs in
terms of size, performance, or operating system resources, so std::condition_variable should be
preferred unless the additional flexibility is required.

std::mutex mut;
std::queue<data_chunk> data_queue;
std::condition_variable data_cond;

void data_preparation_thread()
{
    while(more_data_to_prepare())
    {
        data_chunk const data=prepare_data();

        std::lock_guard<std::mutex> lk(mut);                   // note

        data_queue.push(data);
        data_cond.notify_one();
    }
}

void data_processing_thread()
{
    while(true)
    {
        std::unique_lock<std::mutex> lk(mut);                  // note

        data_cond.wait(lk,[]{return !data_queue.empty();});    // note

        data_chunk data=data_queue.front();
        data_queue.pop();

        lk.unlock();                                           // note

        process(data);

        if(is_last_chunk(data))
            break;
    }
}

note: condition and why unique_lock
a lambda function that expresses the condition being waited for. checks to see if the data_queue is
not empty() - that is, there's some data in the queue ready for processing.

The implementation of wait() then checks the condition (by calling the supplied lambda function) and
returns if the expression returned true. If the condition isn't satisfied, wait() unlocks the mutex
and puts the thread in a blocked or waiting state.

the thread wakes from its slumber (unblocks it), reacquires the lock on the mutex, and checks the
condition again, returning from wait() with the mutex still locked if the condition has been
satisfied. If the condition hasn't been satisfied, the thread unlocks the mutex and resumes waiting.
This is 'why' you need the std::unique_lock rather than the std::lock_guard.

The flexibility to unlock a std::unique_lock isn't just used for the call to wait(); it's also used
once you have the data to process but before processing it

<suprious-wake>
When the waiting thread reacquires the mutex and checks the condition, if it isn't in direct
response to a notification from another thread, it's called a spurious wake. Because the number and
frequency of any such spurious wakes are by definition indeterminate, it is 'not' advisable to use a
function with side effects for the condition check. If you do so, you must be prepared for the "side
effects" to occur multiple times.


={============================================================================
*kt_dev_ccon_013* thread-safe queue

TODO 4.1.2


={============================================================================
*kt_dev_ccon_014* std::future and std::async

<one-off-event-and-asynchronous-result>
The C++ Standard Library models this sort of one-off event with something called a future. Wait for
the future to become ready. A future may have 'data' associated with it, or it may not. Once an
event has happened (and the future has become ready), the future can't be 'reset'.

<two-types>
There are two sorts of futures in the C++ Standard Library, implemented as two class templates
declared in the <future> library header: unique futures (std::future<>) and shared futures
(std::shared_future<>). These are modeled after std::unique_ptr and std::shared_ptr. An instance of
std::future is the one and only instance that refers to its associated event, whereas multiple
instances of std::shared_future may refer to the same event. In the latter case, all the instances
will become ready at the same time, and they may all access any data associated with the event. 

This associated data is the reason these are templates; just like std::unique_ptr and
std::shared_ptr, the template parameter is the type of the associated data.

<no-data>
The std:future<void>, std::shared_future<void> template specializations should be used where there's
no associated data.


{return-from-task}
std::thread doesn't provide an easy means of returning a value from such a task. This is where the
std::async function template (also declared in the <future> header) comes in.

Use std::async to start an asynchronous task for which you don't need the result right away. Rather
than giving you back a std::thread object to wait on, std::async returns a std::future object, which
will eventually hold the return value of the function. 

When you need the value, you just call get() on the future, and the thread blocks until the future
is ready and then returns the value. 

#include <future>
#include <iostream>

int find_the_answer_to_ltuae();

void do_other_stuff();

int main()
{
    std::future<int> the_answer = std::async( find_the_answer_to_ltuae );
    do_other_stuff();
    std::cout << "The answer is " << the_answer.get() << std::endl;
}


std::async allows you to pass additional arguments to the function by adding extra arguments to the
call, in the same way that std::thread does. If the arguments are rvalues, the copies are created by
moving the originals. This allows the use of move-only types as both the function object and the
arguments.

#include <string>
#include <future>

struct X
{
    void foo(int,std::string const&);
    std::string bar(std::string const&);
};

X x;

auto f1=std::async(&X::foo,&x,42,"hello"); // calls p->foo(42, "hello") where p is &x
auto f2=std::async(&X::bar,x,"goodbye");   // calls tempx.bar("goodbye") where tempx is a copy of x

struct Y
{
    double operator()(double);
};

Y y;

auto f3=std::async(Y(),3.141);         // calls tempy(3.141) where tempy is move-constructed
auto f4=std::async(std::ref(y),2.718); // calls y(2.718)

X baz(X&);

std::async(baz,std::ref(x));

class move_only
{
    public:
        move_only();
        move_only(move_only&&);
        move_only(const &move_only) = delete;
        move_only& operator=(move_only&&);
        move_only& operator=(const &move_only) = delete;
        void operator()();
};

auto f5=std::async(move_only()); // calls tmp() where tmp is constructed from std::move(move_only())


<specify-how-to-run>
By default, it's up to the implementation whether std::async starts a new thread, or whether the
task runs synchronously when the future is waited for. You can specify which to use with an
additional parameter to std::async. 

This parameter is of the type std::launch, and can either be std::launch::deferred to indicate that
the function call is to be deferred until either wait() or get() is called on the future. If the
function call is deferred, it may never actually run. note: this is sync call.

std::launch::async to indicate that the function must be run on its own thread

std::launch::deferred | std::launch::async to indicate that the implementation may choose. This last
option is the 'default'. 

auto f6=std::async(std::launch::async,Y(),1.2);
auto f7=std::async(std::launch::deferred,baz,std::ref(x));

auto f8=std::async(std::launch::deferred | std::launch::async, baz,std::ref(x));
auto f9=std::async(baz,std::ref(x));

f7.wait();

f8 and f9 that implementation chooses and f7 is a sync call.


{why-async}
the use of std::async makes it easy to divide algorithms into tasks that can be run concurrently.


={============================================================================
*kt_dev_ccon_015* std::packaged_task

However, std::async is not the only way to associate a std::future with a task; you can also do it
by wrapping the task in an instance of the std::packaged_task<> class template which is a
higher-level abstraction

<how-works>
When the std::packaged_task<> object is invoked, it calls the associated function or callable object
and makes the future ready, with the return value stored as the associated data.


<why-packaged-task>
This can be used as a building block for thread pools or other task management schemes, such as
running each task on its own thread, or running them all sequentially on a particular background
thread. If a large operation can be divided into "self-contained sub-tasks", each of these can be
wrapped in a std::packaged_task<> instance, and then that instance passed to the task scheduler or
thread pool. This abstracts out the details of the tasks; the scheduler 'just' deals with
std::packaged_ task<> instances rather than individual functions.


{associate-a-task-with-future}
The template parameter for the std::packaged_task<> class template is a function signature. The
return type of the specified function signature identifies the type of the std::future<> returned
from the get_future() member function, whereas the argument list of the function signature is used
to specify the signature of the packaged task's function call operator.

A partial class definition for std::packaged_task <std::string(std::vector<char>*,int)> would be: 

template<>
class packaged_task<std::string(std::vector<char>*,int)>
{
    public:
        template<typename Callable>
            explicit packaged_task(Callable&& f);

        std::future<std::string> get_future();

        void operator()(std::vector<char>*,int);
};

The std::packaged_task object is thus a 'callable' object, and it can be wrapped in a std::function
object, passed to a std::thread as the thread function, passed to another function that requires a
callable object, or even invoked directly. 

note: packaged_task is itself callable object which is different from async.

When the std::packaged_task is invoked as a function object, the arguments supplied to the function
call operator are passed on to the contained function, and the return value is stored as the
asynchronous result in the std::future obtained from get_future(). You can thus wrap a task in a
std::packaged_task and retrieve the future before passing the std::packaged_task object elsewhere to
be invoked in due course. When you need the result, you can wait for the future to become ready.


<example>
Many GUI frameworks require that updates to the GUI be done from specific threads, so if another
thread needs to update the GUI, it must send a message to the right thread in order to do so.
std:packaged_task provides one way of doing this without requiring a custom message for each and
every GUI-related activity.

#include <deque>
#include <mutex>
#include <future>
#include <thread>
#include <utility>

std::mutex m;
std::deque<std::packaged_task<void()> > tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

the GUI thread loops until a message has been received telling the GUI to shut down, repeatedly
'polling' for GUI messages to handle, such as user clicks, and for tasks on the task queue. If there
are no tasks on the queue, it loops again; otherwise, it extracts the task from the queue, and then
runs the task. The future associated with the task will then be made ready when the task completes.

void gui_thread()
{
    while(!gui_shutdown_message_received())
    {
        get_and_process_gui_message();

        std::packaged_task<void()> task;
        {
            std::lock_guard<std::mutex> lk(m);

            if(tasks.empty())
                continue;

            task=std::move(tasks.front());

            tasks.pop_front();
        }

        task();
    }
}

std::thread gui_bg_thread(gui_thread);


Posting a task on the queue is equally simple: a new packaged task is created from the supplied
function, the future is obtained from that task by calling the get_future() member function, and the
task is put on the list before the future is returned to the caller. The code that posted the
message to the GUI thread can then wait for the future if it needs to know that the task has been
completed, or it can discard the future if it doesn't need to know.

note: this uses a future as a completion indicator since no associated data, future<void>.

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{
    std::packaged_task<void()> task(f);
    std::future<void> res=task.get_future();
    std::lock_guard<std::mutex> lk(m);
    tasks.push_back(std::move(task));
    return res;
}

std::packaged_task can also be used in more complex situations; by specifying a different function
signature as the template parameter, can change the return type and thus the type of data stored in
the future's associated state and also the argument types of the function call operator.


={============================================================================
*kt_dev_ccon_016* std::promise

What about those tasks that can't be expressed as a simple function call or those tasks where the
result may come from more than one place? These cases are dealt with by the third way of creating a
future: using a std::promise to set the value 'explicitly'.

std::promise<T> provides a means of setting a value (of type T), which can later be read through an
associated std::future<T> object. A std::promise/std::future pair would provide one possible
mechanism for this facility; the waiting thread could block on the future, while the thread
providing the data could use the promise half of the pairing to set the associated value and make
the future ready.

You can obtain the std::future object associated with a given std::promise by calling the
get_future() member function, just like with std::packaged_task. When the value of the promise is
set (using the set_value() member function), the future becomes ready and can be used to retrieve
the stored value. 

If you destroy the std::promise without setting a value, an exception is stored instead.

#include <future>

void process_connections(connection_set& connections)
{
    while(!done(connections))
    {
        for(connection_iterator
                connection=connections.begin(),end=connections.end();
                connection!=end;
                ++connection)
        {
            // This assumes that an incoming packet has some ID and a payload with the actual data
            // in it. The ID is mapped to a std::promise
            //
            // For incoming packets, the data associated with the future is the 'payload' of the
            // data packet.

            if(connection->has_incoming_data())
            {
                data_packet data=connection->incoming();

                std::promise<payload_type>& p = connection->get_promise(data.id);
                p.set_value(data.payload);
            }

            // the promise associated with the outgoing data is set to true to indicate successful
            // transmission

            if(connection->has_outgoing_data())
            {
                outgoing_packet data = connection->top_of_outgoing_queue();

                connection->send(data.payload);
                data.promise.set_value(true);
            }
        }
    }
}


{exception-for-future}
If you pass in -1 to the square_root() function, it throws an exception, and this gets seen by the
caller:

double square_root(double x)
{
    if(x<0)
    {
        throw std::out_of_range(x<0);
    }
    return sqrt(x);
}

Now suppose that instead of just invoking square_root() from the current thread,

double y=square_root(-1);

you run the call as an asynchronous call:

std::future<double> f=std::async(square_root,-1);
double y=f.get();

If the function call invoked as part of std::async throws an exception, that exception is stored in
the future "in place of" a stored value, the future becomes ready, and a call to get() rethrows that
stored exception. The same happens if you wrap the function in a std::packaged_task.

If you wish to store an exception rather than a value, you call the set_exception() member function
rather than set_value().

extern std::promise<double> some_promise;

try
{
    some_promise.set_value(calculate_value());
}
catch(...)
{
    some_promise.set_exception(std::current_exception());      // note: std::current_ex
}

the alternative here would be to use std::copy_exception() to store a new exception directly without
throwing: some_promise.set_exception(std::copy_exception(std::logic_error("foo "))); This is much
cleaner than using a try/catch block if the type of the exception is known, and it should be used in
preference; not only does it simplify the code, but it also provides the compiler with greater
opportunity to optimize the code.

note: ?

<broken-promise>
Another way to store an exception in a future is to destroy the std::promise or std::packaged_task
associated with the future 'without' calling either of the set functions on the promise or invoking
the packaged task. In either case, the destructor of the std::promise or std::packaged_task will
store a std::future_error exception with an error code of std::future_errc::broken_promise in the
associated state if the future isn't already ready; by creating a future you make a promise to
provide a value or exception, and by destroying the source of that value or exception without
providing one, you break that promise.


={============================================================================
*kt_dev_ccon_017* std::shared_future in multiple threads

std::future has its limitations, not the least of which being that only one thread can wait for the
result. If you need to wait for the same event from more than one thread, you need to use
std::shared_future instead.

Although std::future handles all the 'synchronization' necessary to transfer data from one thread to
another, calls to the member functions of a particular std::future instance are not synchronized
with each other. If you access a single std::future object from multiple threads without additional
synchronization, you have a data race and undefined behavior. This is by design: std::future models
"unique ownership of the asynchronous result", and the one-shot nature of get() makes such
concurrent access pointless anyway-only one thread can retrieve the value, because after the first
call to get() there's no value left to retrieve.

note: what will happen if do call get() more than once?

<shared-is-copyable>
Whereas std::future is only moveable, so ownership can be transferred between instances, but only
one instance refers to a particular asynchronous result at a time, std::shared_future instances are
copyable, so you can have multiple (future) objects referring to "the same associated state".


<no-additional-sync>
Now, with std::shared_future, member functions on an individual object are still unsynchronized, so
to avoid data races when accessing a single future object from multiple threads, you must protect
accesses with a lock. The preferred way to use it would be to take a copy of the object instead and
have each thread access its own copy of future since accesses to the shared asynchronous state from
multiple threads are 'safe' if each thread accesses that state through its own std::shared_future
object.

note: why safe? not sure about figure 4.1

<constructed-from-future>
std::shared_future that reference some asynchronous state are constructed 'from' instances of
std::future that reference that state. Since std::future objects don't share ownership of the
asynchronous state with any other object, the ownership 'must' be transferred into the
std::shared_future using std::move, leaving the std::future in an empty state, as if it was default
constructed.

std::promise<int> p;
std::future<int> f(p.get_future());
assert(f.valid());

std::shared_future<int> sf(std::move(f));
assert(!f.valid());                             // f is no longer valid
assert(sf.valid());

can construct a std::shared_future 'directly' from the return value of the get_future() member
    function of a std::promise object since transfer is implicit for rvalue.

std::promise<std::string> p;
std::shared_future<std::string> sf(p.get_future());

The other eay that save a lot of typing and makes code easier to change since

std::future also has an additional feature to automatically deducing the type of a variable from its
initializer and has a share() member function that creates a new std::shared_future and transfers
ownership to it directly.

std::promise< std::map< SomeIndexType, SomeDataType, SomeComparator, SomeAllocator>::iterator> p;
auto sf=p.get_future().share();

If type of variable changes, you only need to change the type of the promise; the type of the future
is automatically updated to match.


={============================================================================
*kt_dev_ccon_002* std::future

{task-based-concurrency}
From C++ 42.4.

<task-model>
Focuses on specifying a simple kind of task: a task that does one thing given arguments and produces
one result. Hiding uses of the messier threads-and-locks level.

Often, we would like to provide a lot of small tasks and let 'the system' worry about how to map
their execution onto hardware resources and how to keep them out of problems with data races,
      spurious wake-ups, excessive waits, etc.

The importance of these facilities is their 'simplicity'. In a sequential program, we usually write
something like:

res = task(args);                // perform a task given arguments and get the result

The concurrent version becomes:

auto handle = async(task,args);  // perform a task given arguments

// ... do something else ...

res = handle.get()               // get the result

    
{future-and-promise}
Communication between tasks is handled by a future/promise pair. A task 'puts' its result into a
promise, and a task that needs the result 'retrieves' the result from the corresponding future:

task 1                                       task 2:
-----------------------                      ------------------------------------------
get()    ->    future    <->  value   <->    promise    <- set_value(), set_exception()

The value is known as "shared state". In addition to the return value or exception, it contains the
information needed for two threads to 'safely' exchange the information. For example:

o A ready bit to indicate whether a value or exception is ready to be extracted by a future.

An implementation can take action on a shared state:

o Make ready: Set the 'ready bit' and unblock any waiting threads.


{promise}
A promise is the 'handle' to a shared state. It is where a task can deposit its result to be
retrieved through a future.

<operations>

promise pr {};       Default constructor: pr has a shared state that is not yet ready

fu=pr.get_future()   fu is the future corresponding to pr

pr.set_value(x)      The result of the task is the value x
pr.set_value()       Set the result of the task for a void future

pr.set_exception(p)  The result of the task is the exception pointed to by p; p is an exception_ptr

note: there are 'no' copy operations for a promise. A set function throws future_error if a value or
exception is already set.


<single-value>
Only possible to transmit a 'single' result value through a promise. That may seem restrictive, but
remember that the value is moved into and out of the shared state, rather than copied, so that we
can cheaply pass a collection of objects. For example:

promise<map<string,int>> pr;
map<string,int>> m;

// ... fill m with a million <string,int> pairs ...

pr.set_value(m);

A task may then extract that map from a corresponding future at essentially zero cost.


{future}
A future is a handle to a shared state. It is where a task can retrieve a result deposited by a
promise.

<operations>

future fu {fu2};

    Move constructor: fu gets fu2's shared state, if any; fu2 no longer has a shared state; noexcept

fu.get()

    For future<void>: like x=fu.get(), but dont move any value

fu.wait() 

    Block until a value arrives

example:

I can easily implement a version of wait_for_all():

template<typename T>
vector<T> wait_for_all(vector<future<T>>& vf)
{
    vector<T> res;
    for (auto& fu : vf)
        res.push_back(fu.get());
    return res;
}


{associate-future-with-task}
There are couple of ways to use future.

{with-background-task} from C++ CIA 4.2.1
Could start a new thread to perform a long-running calculation but have to take care of transferring
the result back.

Use std::async function template in <future> header to start an 'asynchronous' task for which you
don't need the result right away and it returns std::future object.

When need the value, call fu.get() and the thread blocks until the future is 'ready' and then
returns the value.

note: this way is to set future 'implicitly'.

example:

#include <future>

int main()
{
    std::future<int> the_answer = std::async( find_the_answer_to_ltuae );
    do_other_stuff();
    std::cout << "The answer is " << the_answer.get() << std::endl;
}

example: passing args to a function with std::async

struct X 
{
    void foo( int, std::string const & );
    std::string bar( std::string const & );
};

X x;

// arg1 is a pointer to a member function
// arg2 is the object on which apply the member function
// args... are passed as args to the member function

auto f1 = std::async( &X::foo, &x, 42, "hello" );  // p->foo( 42, "hello" ); where p is &x
auto f2 = std::async( &X::bar, x, "goodbye" );     // tmpx.bar("goodbye"); where tmpx is copy of x


struct Y
{
    double operator() (double);
};

Y y;

// arg1 is function or callable
// args... are passed as args

auto f3 = std::async( Y(), 3.141 );          // tmpy(3.141) where tmpy is move-constructed from Y()
auto f4 = std::async( std::ref(y), 2.718 );  // y(2.718)

<specify-how-to-run>
Use additional parameter of std::lanuch type.

std::launch::async      mean that the function 'must' be run on its own thread
std::launch::deferred   mean that the function is deffered until wait() or get() called on future.
std::launch::async | std::launch::async      mean that the implementation may choose. default. 

auto f6 = std::async( std::launch::async, Y(), 1.2 );
auto f6 = std::async( std::launch::deferred, Y(), 1.2 );
auto f6 = std::async( std::launch::async | std::launch::async, Y(), 1.2 );


{packaged-task}
A packaged_task holds a 'task' and a future/promise 'pair'.

task 1                                       packaged_task: 
                                                                              task 2:
-----------------------                      ------------------------------------------
get()    ->    future    <->  value   <->    promise  <- set_value(x)         <- return x
                                                      <- set_exception(px)    <- throw x

We pass a task (a function or a function object) that we want executed to a packaged_task. When our
task executes a return x, it 'causes' a set_value(x) on the packaged_task's promise. Similarly, a
throw x causes a set_exception(px) where px is an exception_ptr for x. Basically, the packaged_task
executes its task, f(args), like this:

try {
   pr.set_value(f(args));  // assume that the promise is called pr
}
catch(...) {
   pr.set_exception(current_exception());
}

<operations>

packaged_task pt {f};

Construct pt holding f; f is moved into pt; use the default allocator; explicit

pt()(args)     
    
Execute f(args); a return x in f() does a set_value(x) to pt's promise, a throw x in f() does a
set_exception(px) to pt's promise; px is an exception_ptr to x

fu=pt.get_future()

fu is the future for pt's promise; throws future_error if called twice

<example>
For a really simple example we don't even need any threads. First define a simple task:

int ff(int i)
{
    if (i) return i;
    throw runtime_error("ff(0)");
}

packaged_task<int(int)> pt1 {ff};   // store ff in pt1
packaged_task<int(int)> pt2 {ff};   // store ff in pt2

pt1(1);  // let pt1 call ff(1);
pt2(0);  // let pt2 call ff(0);

So far, nothing appears to have happened. In particular, we don't see the exception triggered by
ff(0). In fact, pt1(1) did a set_value(1) on the promise attached to pt1, and pt1(0) did a
set_exception(px) on the promise attached to pt2; that px is an exception_ptr to a
runtime_error("ff(0)").

'later', we can try to retrieve the results. The get_future() operation is used to get hold of the
future into which the packaged thread will deposit the result of its task.

auto v1 = pt1.get_future();
auto v2 = pt2.get_future();

try {
    cout << v1.get() << '\n'; // will print
    cout << v2.get() << '\n'; // will throw
}
catch (exception& e) {
    cout << "exception: " << e.what() << '\n';
}

The output is:

1
exception: ff(0)

We could have gotten exactly the same effect by simply writing:

try {
    cout << ff(1) << '\n'; // will print
    cout << ff(0) << '\n'; // will throw
}
catch (exception& e) {
    cout << "exception: " << e.what() << '\n';
}

Then why use task model?

note:
The 'point' is that the packaged_task version works exactly like the version using 'ordinary'
function calls even when the calls of the task (here ff) and the calls of the get()s are in
'different' 'threads'. We can concentrate on specifying the tasks 'rather' than thinking about
threads and locks.

We can move the future, the packaged_task, or both around. Eventually, the packaged_task is invoked
and its task deposits its result in the future without having to know either which thread executed
it or which thread will receive the result. This is simple and general.

The packaged_tasks are actually easier for the server to use than ordinary functions because the
handling of their exceptions has been taken care of.

From C++ CIA 4.2.1. The use of task make it easy to 'divide' algorithms into tasks taht can be run
concurrently.


<example> From C++ CIA 4.2.2
This can be used as a building block for thread pools (see chapter 9) or other task management
schemes, such as running each task on its own thread, or running them all sequentially on a
particular background thread. 

If a large operation can be divided into 'self-contained' sub-tasks, each of these can be wrapped in
a std::packaged_task<> instance, and then that instance passed to the task scheduler or thread pool.
This abstracts out the details of the tasks; the scheduler just deals with std::packaged_task<>
instances rather than individual functions.

The template parameter for the std::packaged_task<> class template is a function signature. The
return type of the specified function signature identifies the type of the std::future<> returned
from the get_future() member function, whereas the argument list of the function signature is used
to specify the signature of the packaged task's function call operator.

Partial class definition for a specialization of std::packaged_task<>

template<>
class packaged_task<std::string(std::vector<char>*,int)>
{
    public:
        template<typename Callable>
            explicit packaged_task(Callable&& f);
        std::future<std::string> get_future();
        void operator()(std::vector<char>*,int);
};

Can thus wrap a task in a std::packaged_task and retrieve the future 'before' passing the
std::packaged_task object elsewhere to be invoked in due course. When you need the result, you can
wait for the future to become ready.

Many GUI frameworks require that updates to the GUI be done from specific threads, so if another
thread needs to update the GUI, it must send a message to the right thread in order to do so.

std:packaged_task provides one way of doing this 'without' requiring a 'custom' message for each and
every GUI-related activity, as shown here.

#include <deque>
#include <mutex>
#include <future>
#include <thread>
#include <utility>

std::mutex m;
std::deque<std::packaged_task<void()> > tasks;

bool gui_shutdown_message_received();
void get_and_process_gui_message();

// note: future will be fired
// The future associated with the task will then be 'made' 'ready' when the task completes.

// loops until a message has been received telling the GUI to shut down.
void gui_thread()
{
    // polling for GUI message
    while(!gui_shutdown_message_received())
    {
        get_and_process_gui_message();

        std::packaged_task<void()> task;
        {
            std::lock_guard<std::mutex> lk(m);

            // 'tasks' but not task. loops again if there are no tasks on the queue.
            if(tasks.empty())
                continue;

            task=std::move(tasks.front());
            tasks.pop_front();
        }
        task();
    }
}


std::thread gui_bg_thread(gui_thread);

// The code that posted the message to the GUI thread can then wait for the future if it needs to
// know that the task has been completed, or it can discard the future if it doesnt need to know.

template<typename Func>
std::future<void> post_task_for_gui_thread(Func f)
{
    std::packaged_task<void()> task(f);
    std::future<void> res=task.get_future();
    std::lock_guard<std::mutex> lk(m);
    tasks.push_back(std::move(task));
    return res;
}

note: That is packaged_task is a callable which wraps the given f and associated future and returns
a future. The user has a returnted future and can wait on that.

note: this way is to set future 'implicitly'.


{promise}
What about those tasks that can't be expressed as a simple function call or those tasks where the
result may come from more than one place? These cases are dealt with by the 'third' way of creating
a future: using a std::promise to set the value 'explicitly'.

std::promise<T> provides a means of setting a value (of type T), which can later be read through an
associated std::future<T> object. A std::promise/std::future pair would provide one possible
mechanism for this facility; the waiting thread could block on the future, while the thread
providing the data could use the promise half of the pairing to set the associated value and make
the future ready.

When the value of the promise is set (using the set_value() member function), the future becomes
'ready' and can be used to retrieve the stored value.

#include <future>

void process_connections(connection_set& connections)
{
    // every time through the loop, checks each connection in turn.
    while(!done(connections))
    {
        for(connection_iterator
                connection=connections.begin(),end=connections.end();
                connection!=end;
                ++connection)
        {
            // assumes that packet has some ID and payload
            if(connection->has_incoming_data())
            {
                data_packet data=connection->incoming();

                // ID is mapped to 'promise' and the value is set to payload. future is assocoated
                // with payload.

                std::promise<payload_type>& p = connection->get_promise(data.id);
                p.set_value(data.payload);
            }

            if(connection->has_outgoing_data())
            {
                outgoing_packet data= connection->top_of_outgoing_queue();

                connection->send(data.payload);

                // set to true to indicate successful transmission. std::promise<bool> and
                // std::future<bool>. The value associated with the future is a simple
                // success/failure flag.

                data.promise.set_value(true);
            }
        }
    }
}

note: there is no section that describe get_promise() so don't know how to associate promise/future
pair with user data.

The C++PL says: There is no get_promise() operation to match get_future(). The use of the promise is
completely handled by the packaged_task.


# ============================================================================
#{
={============================================================================
*kt_dev_blush_001*	accessing neighbors in array

2013.10. when had a problem solving which is to find a path in a maze, wrote a func like:

bool checkWhite( const Pos& pos)
{
	// upper-left
	if( A[pos.xpos-1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper
	else if ( A[pos.xpos][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper-right
	else if ( A[pos.xpos+1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// same-left
	else if ( A[pos.xpos-1][pos.ypos] == WHITE )
	{
		return true;
	}
	// same-right
	else if ( A[pos.xpos+1][pos.ypos] == WHITE )
	{
		return true;
	}
	// lower-left
	else if ( A[pos.xpos-1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower
	else if ( A[pos.xpos][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower-right
	else if ( A[pos.xpos+1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	else
		return false;
}

Although the above tried to give it some priority, this should be something like used in
*kt_dev_algo_006* :

int NeighborCount( Grid map, int row, int col)
{
	 int i, j, count = 0;

	 for( i = row-1; i <= row+1; i++ )
		  for( j = col-1; j <= col+1; j++ )
				if( map[i][j] == ALIVE )
					 count++;

	 // exclude one for itself
	 if( map[row][col] == ALIVE )
		  count--;

	 return count;
}


={===========================================================================
*kt_dev_blush_002* default return values

Have spent a day to find out why a program crashes. Two lessons:

1) It is better to have a core dump rather then narrowing down where a crash happens. Since looked
like there are other places to be suspicious while doing gdb session until reachs to the real cause
such as constructors, map insertions, and so on.

2) From the '89 standard as quoted in the new testament: Flowing off the end of a function is
equivalent to a return with no expression. In either case, the return value is undefined.

This is a debug trace routines and defines enums, strings for enums. It is easy to make a mismatch
between enum and strings when add more enums. So better to have strings from enums using macro
stringfication. However, in that case, enum should be sequential.

typedef enum MHEGComponent_
{
    eMHEGNull       = 0x00000001,
    eMHEGeng        = 0x00000002,
    eMHEGengRuntime = 0x00000004,
    ...
} MHEGComponent;

const char* s_names[] =
{
    "Null",
    "MHEGEng",
    "MHEGEngRun",
    ...
};

const uint32_t getIndex(MHEGComponent comp)
{
  switch (comp)
  {
    case 0x00000001: return 0; break;
    case 0x00000002: return 1; break;
    case 0x00000004: return 2; break;
    case 0x00000008: return 3; break;
    case 0x00000010: return 4; break;
    ...
    case 0x00000040: return 6; break;
    case 0x00000080: return 7; break;
    case 0x00000100: return 8; break;
    case 0x00000200: return 9; break;
    case 0x00000400: return 10; break;
  }
}

This didn't have default case and when there is a enum which don't have a matching case, no return
statement but this function returns int. Which value will you get? Quick test shows undefined return
value.

case: 3000
val: 134520896


# ============================================================================
#{ design
={============================================================================
*kt_dev_design_001* generic structure access

Q: How to design generic interface to support different structures in size or format?

{one} 
As shown in *kt_linux_core_300* ipc: socket: LPI 56, socket system calls uses generic interface to
supports different address structures with common call signatures.

See {generic-address-structure} for more details and accept() is an example:

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

Here, since kernel do not know the type of structure and no type in call signature, uses lenth and
kernel use this to move addr structure between user and kernel space and to check size and report
back the size written.


{two}
This is the way that NDS CDI ioctl use.

note: capabilitySize is really no use since version(type) tells you what type it uses.
note: then why *CapEx structure? Appears that CDI limits the number of arguments in ioctl() to 3
although POSIX ioctl() supports ioctl with varying arguments. That's why it uses *CapEx structure to
use more arguments. Not sure the background of this limitation.

Q: what's call signature of ioctl in kernel?

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX_VERSION, uint32_t *version);

#define VIDEO_DECODER_CAP_V0     (0x00000001)
#define VIDEO_DECODER_CAP_V1     (0x00000002)
#define VIDEO_DECODER_CAP_V2     (0x00000004)
#define VIDEO_DECODER_CAP_V3     (0x00000008)

typedef struct {
  ...
} VideoDecoderCapsV2;

typedef struct {
  ...
} VideoDecoderCapsV3;

typedef struct {
   uint32_t    version;             // @in
   void        *capability;         // @out
   uint32_t    capabilitySize;      // @in
} VideoDecoderCapEx;

int ioctl(int fd, int request == VIDEO_DECODER_GET_CAP_EX, VideoDecoderCapEx *arg);


{
  uint32_t                video_dec_caps_version;
  VideoDecoderCapsEx      video_decoder_caps;
  VideoDecoderCapsV0      caps_v0 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV1      caps_v1 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};
  VideoDecoderCapsV2      caps_v2 = {0U, 0U, 0U, 0U, 0U, 0U, 0U};

  if (ioctl(fd, VIDEO_DECODER_GET_CAPS_EX_VERSIONS, &video_dec_caps_version) == 0)
  {
    if (video_dec_caps_version & VIDEO_DECODER_CAP_V2)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V2;
      video_decoder_caps.capability = &caps_v2;
      video_decoder_caps.capabilitySize = sizeof(caps_v2);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v2.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
    else (video_dec_caps_version & VIDEO_DECODER_CAP_V1)
    {
      video_decoder_caps.version = VIDEO_DECODER_CAP_V1;
      video_decoder_caps.capability = &caps_v1;
      video_decoder_caps.capabilitySize = sizeof(caps_v1);

      if (ioctl( fd, VIDEO_DECODER_GET_CAPS_EX, &video_decoder_caps) == 0)
      {
        *(uint32_t *)data = caps_v1.decodingModes;
      }
      else
      {
        *(uint32_t *)data = VIDEO_DECODER_SKIP_NONE;
      }
    }
  }
}


# ============================================================================
#{
={{===========================================================================
*kt_dev_uml_001*	aggragation

Two aggregations: weak and strong.

1) weak. white diamond-shaped arrowhead pointing towards the target or parent class.

2) strong. a black diamond-shaped arrowhead. composite aggragation.

# example

AddressBook <*>----------- ContactGroup
            1         0..*

(copied from *kt_dev_ecpp_011* )

# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...


# ============================================================================
#{
={============================================================================
*kt_dev_ref_001* references

{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

{ref-003} design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

C++P. C++ primer, 5th Ed.
http://www.informit.com/store/c-plus-plus-primer-9780321714114


={============================================================================
*kt_dev_ref_002* sites

http://eli.thegreenplace.net/


==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
