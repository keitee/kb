*kt_dev_01*		tw=100

/^[#=]{ 
Use #{ for a group and ={ for a item

aMon 13 Jan 2014 15:34:27 GMT

Keywords:
{QQ} for questions to find out more
{DN} for design considerations and points
{BP} for best practice
{IE} for interesting example

KT KB. DEVELOPMENT.

#{ SE
|kt_dev_seng_001| first major hurdle in attacking a large problem
|kt_dev_seng_002| information hiding and oop
|kt_dev_seng_003| comments in source
|kt_dev_seng_004| 80 and 20

#{ ISSUES and CODES
|kt_dev_prob_001| memcpy considered danger
|kt_dev_prob_002| out of index of array
|kt_dev_prob_003| double free
|kt_dev_prob_004| eval-order
|kt_dev_prob_005| 
|kt_dev_prob_006| print ansi color 
|kt_dev_prob_007| random number {time}
|kt_dev_prob_008| elapsed time {clock}
|kt_dev_prob_009| debug printf {stdarg} {macro} {why-ellipses-dangerous} {ndebug}
|kt_dev_prob_010| macro: get max value of type <bitwise> <shift-operator>
|kt_dev_prob_011| handle or pointer
|kt_dev_prob_012| problem of incremental build or make

#{ GNU CORE UTILS
|kt_dev_guti_000| gnu core util sites

#{ GCC
|kt_dev_gcc_000| gcc compile script
|kt_dev_gcc_001| error: two or more data types in declaration specifiers {preprocessor} 
|kt_dev_gcc_002| error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]
|kt_dev_gcc_003| error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]
|kt_dev_gcc_004| error: variable-sized object 'out' may not be initialised
|kt_dev_gcc_005| error: expected ‘}’ at end of input
|kt_dev_gcc_006| error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 
|kt_dev_gcc_007| error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before
|kt_dev_gcc_008| warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]
|kt_dev_gcc_009| error: jump to case label and crosses initialisation of 
|kt_dev_gcc_100| gcc and c++11 {how-to-use-gcc-optimisation} {gcc-profiling} {gcc-options}
|kt_dev_gcc_101| gcc typeof
|kt_dev_gcc_102| gcc binutil
|kt_dev_gcc_103| gcc link and ld {cyclic-dependencies}
|kt_dev_gcc_104| gcc: C90 and C99 
|kt_dev_gcc_105| gcc likely and unlikely 
|kt_dev_gcc_200| gcc: cpp: preprocessor
|kt_dev_gcc_201| gcc: cpp: define? 
|kt_dev_gcc_202| gcc: cpp: how-to-get-filename-without-full-path
|kt_dev_gcc_300| gcc gprof

#{ C AND C++
|kt_dev_lang_001| global, file and local static	{singleton-pattern} {file-scope}
|kt_dev_lang_002| func pointer
|kt_dev_lang_003| #error and #warning
|kt_dev_lang_004| post and pre inc {post-inc} {post-inc-overload} {tip}
|kt_dev_lang_005| chaining
|kt_dev_lang_006| compile error types
|kt_dev_lang_007| bool type {true-and-false}
|kt_dev_lang_008| data type, char type
|kt_dev_lang_009| implicit conversion {equal-misspell} {integer-division}
|kt_dev_lang_010| incomplete type {forward-declaration} {text-query-example}
|kt_dev_lang_011| literal type
|kt_dev_lang_012| pointer and array {option-handling} {std::begin} {sizeof-operator}
|kt_dev_lang_013| allman style 
|kt_dev_lang_014| interesting codes
|kt_dev_lang_015| statement, control flow {division-and-modulus} {switch-under-the-hood}

#{ CPP
|kt_dev_cpp_000| operator-precedence, operators
|kt_dev_cpp_001| virtual inheritance (interview) {virtual-base-class}
|kt_dev_cpp_002| reference-vs-pointer (interview)
|kt_dev_cpp_003| ctor and copy controls {pass-by-reference-to-const} {default-arg} {constructor-initializers}
|kt_dev_cpp_004| copy-controls when use dyn resource	{the-rule-of-three} {valuelike} {preventing-copies} {self-assign}
|kt_dev_cpp_005| converting ctor {class-type-conversion} {explicit-keyword}
|kt_dev_cpp_006| swap {copy-and-swap-idiom} {pimpl-idiom}
|kt_dev_cpp_007| function matching and overload 	{scope-in-inheritance}
|kt_dev_cpp_008| const {const-on-iterators} {equal-misspell} {bitwise-const} {mutable}
|kt_dev_cpp_009| undefined result and a temp-object {temp-object-in-return} {cost-of-temp-object}
|kt_dev_cpp_010| def args
|kt_dev_cpp_011| inline {empty-ctor-represenstaion}
|kt_dev_cpp_012| initializer_list
|kt_dev_cpp_013| when use reference {called-by-reference} 
|kt_dev_cpp_014| decltype, typedef, and using {class-vs-struct} 
|kt_dev_cpp_015| declaration and definition
|kt_dev_cpp_016| 
|kt_dev_cpp_017| static-members and class const	{class-method} {class-const}
|kt_dev_cpp_018| dtor {non-virtual-destruction-problem} {how-virtual-works}
|kt_dev_cpp_019| exception {problem-of-exception-in-dtor} {exception-safe}
|kt_dev_cpp_020| move semantics
|kt_dev_cpp_021| op overload	{member-or-non-member} {function-object}
|kt_dev_cpp_022| inheritance {static-type} {subobject-and-derived-to-base-conversion} {base-class-pointer-container} {RTTI}
|kt_dev_cpp_023| override		{override-keyword} {dynamic-binding} {default-arg-in-virtual}
|kt_dev_cpp_024| ABC {refactoring}
|kt_dev_cpp_025| template {debug-delete}
|kt_dev_cpp_026| enum {enum-hack}
|kt_dev_cpp_027| volatile
|kt_dev_cpp_028| namespace  {unnamed-namespace}
|kt_dev_cpp_029| nested class
|kt_dev_cpp_030| case study: framework {tizen-case}
|kt_dev_cpp_031| wrapper
|kt_dev_cpp_032| case study: porting layer
|kt_dev_cpp_033| case study: inheritance {how-gcc-build-vtable}

#{ STL 
|kt_dev_stl_000| useful links {stl-design-rationale}
|kt_dev_stl_001| sequential containers {trade-offs}
|kt_dev_stl_005| assoc-containers {insert-erase} {key-type-requirement} {use-typedef} {find-in-multi}
|kt_dev_stl_002| vector
|kt_dev_stl_003| list
|kt_dev_stl_004| adaptors {stack} {queue}
|kt_dev_stl_006| iterator	{category} {insert-method} {invalidated-iterators}	{estl-009}
|kt_dev_stl_007| iterator: inserter {algo-copy} {stream-iterator}
|kt_dev_stl_008| algorithm
|kt_dev_stl_009| algorithm: sort, unique
|kt_dev_stl_010| algorithm: predicate and lambda
|kt_dev_stl_011| containers: restrictions on element type
|kt_dev_stl_012| containers: copy init
|kt_dev_stl_013| algorithm: copy
|kt_dev_stl_014| bitset
|kt_dev_stl_015| string: stringstream {inefficient-concatnation}
|kt_dev_stl_016| io stream {getline}
|kt_dev_stl_017| emplace_* member
|kt_dev_stl_018| smart pointer, RAII {factory-func} {auto-lock}
|kt_dev_stl_019| new and delete {default-and-value-init} {placement-new} {allocator}
|kt_dev_stl_020| gcc stl impl files
|kt_dev_stl_021| algorithm: remove-erase idiom
|kt_dev_stl_022| iterator: external and internal

#{ STL Q
|kt_dev_stl_100| ref: can store unique_ptr in a container?

#{ SYSTEM 
|kt_dev_sys_001| <empty>
|kt_dev_sys_002| endianess
|kt_dev_sys_003| to check endianess at runtime
|kt_dev_sys_004| to check address alignment or boundary <bitwise>
|kt_dev_sys_005| two's complement
|kt_dev_sys_007| stack (MIPS)
|kt_dev_sys_008| stack asm example (MIPS)
|kt_dev_sys_009| for and while asm (MIPS)
|kt_dev_sys_010| POR(power on reset) (MIPS)
|kt_dev_sys_011| instruction and addressing (MIPS)
|kt_dev_sys_012| dump_stack
|kt_dev_sys_013| <empty>
|kt_dev_sys_014| newlines between dos and linux


#{ EFFECTIVE C++ 3RD
|kt_dev_ecpp_001| 01: federation of language
|kt_dev_ecpp_002| 02: no to preprocessor
|kt_dev_ecpp_003| 09: no virtual call in ctor or dtor {pass-log-to-base-class} {static-member-example}
|kt_dev_ecpp_004| 18: hard to use incorrectly 
|kt_dev_ecpp_005| 23: prefer non-member non-friend func {encapsulation}
|kt_dev_ecpp_006| 26: postpone variable definitions
|kt_dev_ecpp_007| 28: avoid returning handles to object internals
|kt_dev_ecpp_008| 31: minimize compilation dependencies	{pimpl-idiom} {interface-class} {factory-pattern}
|kt_dev_ecpp_009| 32: public inheritance. is-a model 
|kt_dev_ecpp_010| 34: interface and implementation inheritance
|kt_dev_ecpp_011| 35: alternatives to virtual func {template-pattern} {strategy-pattern}
|kt_dev_ecpp_012| 38: composition. has-a model {private-inheritance} {is-implemented-in-terms-of}
|kt_dev_ecpp_013| 22: data member must be private {encapsulation}
|kt_dev_ecpp_014| 27: minimize casting {named-cast}
|kt_dev_ecpp_015| 30: ins and outs of inlining 


#{ MORE EFFECTIVE C++ 1ST, 1996, 25TH PRINTING
|kt_dev_mecpp_001| 16: 80-20 rule and profiler
|kt_dev_mecpp_002| 17: lazy evaluation
|kt_dev_mecpp_003| 18: over-eager evaluation
|kt_dev_mecpp_004| 24: virtual cost {how-vtable-works}
|kt_dev_mecpp_005| 25: reference-counting
|kt_dev_mecpp_006| 28: log entry
|kt_dev_mecpp_007| 34: combine C and C++
|kt_dev_mecpp_008| 32: program in the future tense

#{ EFFECTIVE STL 3RD
|kt_dev_estl_001| design: 02: illusion of container-independent code


#{ BLUSHES OR BUGS
|kt_dev_blush_001| accessing neighbors in array
|kt_dev_blush_002| default return values


|kt_dev_uml_001| aggragation

|kt_dev_ref_001| references
|kt_dev_ref_002| sites


# ============================================================================
#{
={============================================================================
*kt_dev_seng_001*	first major hurdle in attacking a large problem

is deciding exactly what the problem because necessary 

1) to translate vague goals
2) contradictory requests
3) perhaps unstated desires into a precisely formulated project that can be programmed.


={============================================================================
*kt_dev_seng_002*	information hiding and oop 

<information-hiding> whether is done by sepration beteen interface and implementation, or by having
module or #defines, has

1) changes of implementation
2) clarity of program
3) top-down design


{oop}
The key ideas in OOP are data abstraction, inheritance, and dynamic binding.

1> The <data-abstration> can define classes that separate interface from implementation.

2> The <inheritance> can define classes that model the relationships among similar types.

Conceptually, neither the kind of device nor the character size affects the IO operations we want to
perform. For example, we would like to use >> to read data regardless of whether we are reading a
console window, a disk file, or a string. Similarly, we would like to use that operator regardless
of whether the characters we read fit in a char or require a wchar_t.

The library lets us ignore the differences among these different kinds of streams by using
inheritance. As with templates (§ 3.3, p. 96), we can use classes related by inheritance without
understanding the details of how inheritance works

inheritance lets us say that a particular class inherits from another class. Ordinarily, we can use
an object of an inherited class as if it were an object of the same type as the class from which it
inherits.

3> <dynamic-binding> can use objects of these types while ignoring the details of how they differ.


==============================================================================
*kt_dev_seng_003*	comments in source

why?

1) no gurantee that only one person maintain whole source tree. works as a team. no lifetime
employment. no unlimited memory.

2) code speaks themselves? not for big and real system which has history such as field fixes.
project/field specific requirement and one line worth a week long dev trip. 

Should have comment or reference for more detail or full history.


==============================================================================
*kt_dev_seng_004*	80 and 20

EC++ p139.

Typical program spends 80% of its time excuting only 20% of its code. Your goal as a software
developer is to identify the 20% of your code that can increase your program's overall performance.

From MEC++16:

The 80-20 Rule states that 80 percent of a program's resources are used by about 20 percent of the
code: 80 percent of the runtime is spent in approximately 20 percent of the code; 80 percent of the
memory is used by some 20 percent of the code; 80 percent of the disk accesses are performed for
about 20 percent of the code; 80 percent of the maintenance effort is devoted to around 20 percent
of the code. 

The rule has been repeatedly verified through examinations of countless machines, operating systems,
and applications. The 80-20 rule is more than just a catchy phrase; it's a guideline about
system performance that has both wide applicability and a solid empirical basis.


# ============================================================================
#{
={============================================================================
*kt_dev_prob_001*	memcpy considered danger

Seen on NDS MW issue

MW_Process crash with core dump in SIM_dbc_query_ReadProgrammeInstanceInfo (during memcpy) 

# void *memcpy(void *dest, const void *src, size_t n);
(void)memcpy((void*)&obj_array[offset].sort_title[0], (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

# source when crashed
0x1d8dfec: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x1d8dffc: 0xc009 0x0 0x0 0x0

# dest
x/40a obj_array[0].sort_title
0x204eb20: 0x54495050 0x494e4720 0x504f494e 0x54000000
0x204eb30: 0x0 0x0 0x0 0x0

# solution
strncpy(&obj_array[offset].sort_title[0], (const char*)results[24].value.text, SIM_DBC_MAX_SORT_STRING_LEN);

note. So the problem is the accessing out of index; Why? When doing memcpy, there is no gurantee
that src and dest has all the vaild address up to 'n' size. So when the valid length of src is
smaller than 'n' then the area which is over the length of src, may not accessiable such as not
contiguous, not valid for this process, etc. 

So strncpy will ensure only the length of the value.text is copied when there is a null in src
(destination then padded out with nulls) or a maximum of 40 is copied if the source string is over
40.


={============================================================================
*kt_dev_prob_002*	out of index of array

when acces out of index of array, 'undefined' so sometimes work or sometimes not.


# 01
#

int g_arr[3];

int main(int argc, char* argv[])
{
    if( g_arr[5] == 0 )
        printf("idx 5 is false\n");
    else
        printf("idx 5 is true\n");
                                                                                                                                
}

$ ./a.out 
idx 5 is false


# 02
#

/* the issue was that index(dbConId) was -1(0xFFFFFFFF used as a handle) and worked
 * sometimes. But crashed
 */

static MFS_STATUS MFSDBWRAP_GetDbContext(MFS_STORAGE_DB_CONTEXT_ID            dbConId,
										 MFS_DB_CONTEXT						**ppContext)
{
    MFS_STATUS					mfsStatus = MFS_STATUS_OK;

    XDEBUG_DEFINE_FUNC_INFO("MFSDBWRAP_GetDbContext");
	XDEBUG_TRACE2_1("start: dbConId=%d", dbConId);
    	

	/* the dbConId is the index into the db context array,
	   so we can directly access it.
	   First check that the context is really in use. 
	   If not this is a bug.
	*/
	if (db_contexts_array[dbConId].bInUse == XFALSE)
	{
		XDEBUG_ERR2_0("No free slots for contextes.  Returning the first one");
		mfsStatus = MFS_STATUS_ERROR;
	}
	else
	{
		*ppContext = &db_contexts_array[dbConId];
	}
	
    return mfsStatus;
}


==============================================================================
*kt_dev_prob_003*	double free

when do double free under pc linux that uses glibc, make a core as below but run on a
embedded linux that uses uclibc, shows no problem.

$ ./a.out 
pstr = 
this is..
*** glibc detected *** ./a.out: double free or corruption (fasttop): 0x000000001834b010 ***
======= Backtrace: =========
/lib64/libc.so.6[0x393c07230f]
/lib64/libc.so.6(cfree+0x4b)[0x393c07276b]
./a.out[0x40062f]
/lib64/libc.so.6(__libc_start_main+0xf4)[0x393c01d994]
./a.out[0x4004b9]
======= Memory map: ========
00400000-00401000 r-xp 00000000 fd:02 37781700                           /data/home/NDS-UK/parkkt/work/a.out
00600000-00601000 rw-p 00000000 fd:02 37781700                           /data/home/NDS-UK/parkkt/work/a.out
1834b000-1836c000 rw-p 1834b000 00:00 0                                  [heap]
393bc00000-393bc1c000 r-xp 00000000 fd:00 3538948                        /lib64/ld-2.5.so
393be1b000-393be1c000 r--p 0001b000 fd:00 3538948                        /lib64/ld-2.5.so
393be1c000-393be1d000 rw-p 0001c000 fd:00 3538948                        /lib64/ld-2.5.so
393c000000-393c14e000 r-xp 00000000 fd:00 3538955                        /lib64/libc-2.5.so
393c14e000-393c34d000 ---p 0014e000 fd:00 3538955                        /lib64/libc-2.5.so
393c34d000-393c351000 r--p 0014d000 fd:00 3538955                        /lib64/libc-2.5.so
393c351000-393c352000 rw-p 00151000 fd:00 3538955                        /lib64/libc-2.5.so
393c352000-393c357000 rw-p 393c352000 00:00 0 
394b200000-394b20d000 r-xp 00000000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
394b20d000-394b40d000 ---p 0000d000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
394b40d000-394b40e000 rw-p 0000d000 fd:00 3539281                        /lib64/libgcc_s-4.1.2-20080825.so.1
2ba0f68d2000-2ba0f68d4000 rw-p 2ba0f68d2000 00:00 0 
2ba0f68ec000-2ba0f68ee000 rw-p 2ba0f68ec000 00:00 0 
7fff1e6e4000-7fff1e6f9000 rw-p 7ffffffe9000 00:00 0                      [stack]
ffffffffff600000-ffffffffffe00000 ---p 00000000 00:00 0                  [vdso]
Aborted


==============================================================================
*kt_dev_prob_004*	eval-order

while (fgets(line, 256, file))
{
        sscanf(line, "%s %d %d %f %f", Stocks[i], &Intervals[i], &Volumes[i], &Highs[i], &Lows[i++]);
}

Review comment from Ian Park.
You made big mistake here. Increasing 'i' in the parameter is very dangerous. The evaluation order
of function parameter is undefined in spec and usually they are evaluated in reverse order in most
of compilers. Therefore 'i' will be increased firstly and the data for Stocks,Intervals,Volumes and
Highs will be stored in the next row. The data will be totally mangled. Increase 'i' in the
separated line.


={============================================================================
*kt_dev_prob_005*	


==============================================================================
*kt_dev_prob_006*	print ansi color 


# dark blue
printf("\033[34m CR-1048: NVRAM Retry Byte set to 0x%X \033[0m \n",nvram_retry_bytes);


==============================================================================
*kt_dev_prob_007*	random number

#include <stdlib.h>

The seed

void Randomize()
{
	 srand( (unsigned int) (time(NULL)%10000));
}

time() returns the number of seconds elapsed since 00:00:00 GMT, Jan. 1, 1970. 
time_t time(time_t *timeptr); 

int PoissonRandom( double expectedvalue )
{
	 int n = 0;
	 double limit;
	 double x;

	 limit = exp(-expectedvalue);
	 x = rand()/(double) INT_MAX;
	 while( x > limit )
	 {
		  n++;
		  x *= rand()/(double) INT_MAX;
	 }

	 return n;
}


==============================================================================
*kt_dev_prob_008*	elapsed time 

#include <time.h>

float Time(int flag)
{
	 static clock_t start; // [note] static
	 clock_t end;

	 if( flag == START )
	 {
		  start = clock();
		  return 0.0;
	 }
	 else
	 {
		  end = clock();
		  return (end-start) / CLK_TCK; // or CLOCK_PER_SEC
	 }
}

void Usuage()
{
	 float elapsedtime;

	 Time(START);

	 ...

	 elapsedtime = Time(END);

	 printf("elapsed time to complete %d searches is %f seconds \n", searchcount, elapsedtime );
	 ...
}


={============================================================================
*kt_dev_prob_009*	debug printf 

{ndebug}
The assert macro is defined in cassert header. It depends on a preprocessor varaible named NDEBUG.
If NDEBUG is defined, assert do nothing. By default, it's not defined.

If the macro NDEBUG was defined at the moment <assert.h> was last included, the macro assert()
generates no code, and hence does nothing at all. Otherwise, the macro assert() prints an error
message to standard error and terminates the program by calling abort(3) if expression is false
(i.e., compares equal to zero).


{useful-macros}
#define abs(n) ((n) < 0 ? -(n) : (n))

#define EQ(a,b) (!strcmp((a),(b)))
#define LT(a,b) (strcmp((a),(b)) < 0)

#define EQ(a,b) ((a) == (b))
#define LT(a,b) ((a) < (b))

// a is array
#define NELEMENTS(a) (sizeof(a)/sizeof(*(a)))

// build enum and string table
#define FSM_E(x) {x,#x}

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  FSM_E(BOOT_EVENT_READY),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

enum Events
{
  // BOOT_EVENTS
  BOOT_EVENT_CLOSED = 0x01,
  BOOT_EVENT_READY,
  ...
  BOOT_EVENT_STOP,
};


{variable-arguments}
The va_arg, va_copy, va_end, and va_start macros provide a portable way to access the arguments to a
function when the function takes a variable number of arguments. There are two versions of the
macros: The macros defined in STDARG.H conform to the ISO C99 standard; the macros defined in
VARARGS.H are deprecated but are retained for backward compatibility with code that was written
before the ANSI C89 standard. 

<from-linux>
STDARG(3) Linux Programmer's Manual

NAME
stdarg, va_start, va_arg, va_end, va_copy - variable argument lists

SYNOPSIS
 #include <stdarg.h>

 void va_start(va_list ap, last);
 type va_arg(va_list ap, type); // [KT] see type
 void va_end(va_list ap);
 void va_copy(va_list dest, va_list src);

DESCRIPTION

A function may be called with a [varying-number] of arguments of [varying-types]. The include file
<stdarg.h> declares a type va_list and defines three [macros] for stepping through a list of arguments
whose number and types are not known to the called function.

The called function must declare an object of type va_list which is used by the macros va_start(),
va_arg(), and va_end().

va_start() 

The va_start() macro initializes [ap] for subsequent use by va_arg() and va_end(), and must be called
first.

The argument last is the name of the last argument before the variable argument list, that is, the
last argument of which the calling function knows the type.

Because the address of this argument may be used in the va_start() macro, it should not be declared
as a register variable, or as a function or an array type.

va_arg()

The va_arg() macro expands to an expression that has the type and value of the next argument in the
call. The  argument ap is the va_list ap initialized by va_start(). Each call to va_arg() modifies
ap so that the next call returns the next argument. The argument type is a type name specified so
that the type of a pointer to an object that has the specified type can be obtained simply by
adding a * to type.

The first use of the va_arg() macro after that of the va_start() macro returns the argument after
last. Successive invocations return the values of the remaining arguments.

If there is no next argument, or if type is not compatible with the type of the actual next argument
(as promoted according to the default argument promotions), random errors will occur. ~

If ap is passed to a function that uses va_arg(ap,type) then the value of ap is undefined after the
return of that function.

va_end()

Each invocation of va_start() must be matched by a corresponding invocation of va_end() in the same
function. After the call va_end(ap) the variable ap is undefined. Multiple traversals of the list,
each bracketed by va_start() and va_end() are possible. va_end() may be a macro or a function.

example

#include <iostream>
#include <cstdarg>

void argprint(int num_args, ...)
{
  va_list ap;

  va_start(ap, num_args);
  for( int i = 0; i < num_args; i++)
  {
    std::cout << "arg:" << i << " is " << va_arg(ap, int) << std::endl;
  }

  va_end(ap);
}

int main()
{
  std::cout << "--{ main " << std::endl;

  argprint( 3, 10, 20, 30 );

  std::cout << "--} main " << std::endl;
}

The function foo takes a string of format characters and prints out the argument associated with
each format character based on the type.

#include <stdio.h>
#include <stdarg.h>

void
foo(char *fmt, ...)
{
  va_list ap;
  int d;
  char c, *s;

  va_start(ap, fmt);
  while (*fmt)					// [KT] null is a termination condition
      switch (*fmt++) {    // [KT] see ++
      case 's':              /* string */
          s = va_arg(ap, char *);
          printf("string %s\n", s);
          break;
      case 'd':              /* int */
          d = va_arg(ap, int);
          printf("int %d\n", d);
          break;
      case 'c':              /* char */
          /* need a cast here since va_arg only
             takes fully promoted types */
          c = (char) va_arg(ap, int);
          printf("char %c\n", c);
          break;
      }
  va_end(ap);
}


{snprintf-and-vsnprintf}
#include <stdio.h>

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);

#include <stdarg.h>

int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);

The functions vprintf(), vfprintf(), vsprintf(), vsnprintf() are equivalent to the functions
printf(), fprintf(), sprintf(), snprintf(), respectively, except that they are called with a
<va_list> instead of a variable number of arguments.  These  functions  do not call the va_end
macro. Because they invoke the va_arg macro, the value of ap is undefined after the call.  See
stdarg(3).

The functions snprintf() and vsnprintf() do not write more than size bytes (including the
terminating null byte ('\0')). If the output was truncated due to this limit then the return value
is the number of characters (excluding the terminating null byte) which would have been written to
the final string if enough space had been available. Thus, a return value of size or more means that
the output was truncated.  (See also below under NOTES.) If an output error is encountered, a
negative value is returned.


{swallowing-the-semicolon}
http://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html#Swallowing-the-Semicolon

Often it is desirable to define a macro that expands into a compound statement. Consider, for
example, the following macro, that advances a pointer (the argument p says where to find it) across
whitespace characters:

#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
 while (p < lim) {            \
   if (*p++ != ' ') {         \
     p--; break; }}}

Here backslash-newline is used to split the macro definition, which must be a single logical line,
so that it resembles the way such code would be laid out if not part of a macro definition.

A call to this macro might be SKIP_SPACES (p, lim). Strictly speaking, the call expands to a
compound statement, which is a complete statement with no need for a semicolon to end it. However,
since it looks like a function call, it minimizes confusion if you can use it like a function call,
writing a semicolon afterward, as in SKIP_SPACES (p, lim);

This can cause trouble before else statements, because the semicolon is actually a null statement.
Suppose you write

if (*p != 0)
 SKIP_SPACES (p, lim);
else ...

The presence of two statements-the compound statement and a null statement-in between the if
condition and the else makes [invalid] C code.

The definition of the macro SKIP_SPACES can be altered to solve this problem, using a do ... while
statement. Here is how:

#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
    while (p < lim) {            \
      if (*p++ != ' ') {         \
        p--; break; }}}          \
while (0)

Now SKIP_SPACES (p, lim); expands into

do {...} while (0);

which is one statement. The loop executes exactly once; most compilers generate no extra code for
it. 

 [KT] There should be NO spaces after \;otherwise compile error.


{stringification}
http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification

Sometimes you may want to convert a macro argument into a string constant. Parameters are not
replaced inside string constants, but you can use the '#' preprocessing operator instead. When a
macro parameter is used with a leading '#', the preprocessor replaces it with the literal text of
the actual argument, converted to a string constant. Unlike normal parameter replacement, the
argument is [not-macro-expanded-first]. This is called stringification.

There is no way to combine an argument with surrounding text and stringify it all together. Instead,
you can write a series of adjacent string constants and stringified arguments. The preprocessor will
replace the stringified arguments with string constants. The C compiler will then combine all the
adjacent string constants into one long string.

Here is an example of a macro definition that uses stringification:

     #define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

     WARN_IF (x == 0);
          ==> do { if (x == 0)
                fprintf (stderr, "Warning: " "x == 0" "\n"); } while (0);

The argument for EXP is substituted once, as-is, into the if statement, and once, stringified, into
the argument to fprintf. If x were a macro, it would be expanded in the if statement, but not in the
string.

The do and while (0) are a kludge to make it possible to write WARN_IF (arg);, which the resemblance
of WARN_IF to a function would make C programmers want to do; see Swallowing the Semicolon.

Stringification in C involves more than putting double-quote characters around the fragment. The
preprocessor backslash-escapes the quotes surrounding embedded string constants, and all backslashes
within string and character constants, in order to get a valid C string constant with the proper
contents. Thus, stringifying p = "foo\n"; results in "p = \"foo\\n\";". However, backslashes that
are not inside string or character constants are not duplicated: '\n' by itself stringifies to "\n".

All leading and trailing whitespace in text being stringified is ignored. Any sequence of whitespace
in the middle of the text is converted to a single space in the stringified result. Comments are
replaced by whitespace long before stringification happens, so they never appear in stringified
text.

There is no way to convert a macro argument into a character constant.

If you want to stringify [the-result-of-expansion] of a macro argument, you have to use [two-levels]
of macros.

#define xstr(s) str(s)
#define str(s) #s
#define foo 4

str (foo)
    ==> "foo"  // [KT] is not "4" because not macro-expanded
xstr (foo)
    ==> xstr (4)
    ==> str (4)
    ==> "4"

s is stringified when it is used in str, so it is not macro-expanded first. But s is an ordinary
argument to xstr, so it is completely macro-expanded before xstr itself is expanded (see Argument
Prescan). Therefore, by the time str gets to its argument, it has already been macro-expanded. 

#include <iostream>

#define PRINT_TRUE true

#define PRINT_STRING(exp) \
   do { \
      std::cout << "arg:" << #exp << std::endl; \
      std::cout << "arg:" << exp << std::endl; } \
   while(0)

#define XPRINT_STRING(s) PRINT_STRING(s)

int main()
{
	std::cout << "--{ main " << std::endl;

   PRINT_STRING(true);
   XPRINT_STRING(true);

	std::cout << "--} main " << std::endl;
}

arg:PRINT_TRUE		// stringified but not expanded
arg:1					// expanded
arg:true				// expanded before stringified
arg:1:				// expanded


<example-one>

Although macro expansion does not occur within a quoted string, the text of the macro arguments can
be quoted and treated as a string literal by using the "#" directive (also known as the "Stringizing
Operator"). For example, with the macro

#define QUOTEME(x) #x

the code

printf("%s\n", QUOTEME(1+2));

will expand to

printf("%s\n", "1+2");

This capability can be used with automatic string literal concatenation to
make debugging macros. For example, the macro in

#define dumpme(x, fmt) printf("%s:%u: %s=" fmt, __FILE__, __LINE__, #x, x)
 
int some_function() {
	int foo;
	/* a lot of complicated code goes here */
	dumpme(foo, "%d");
	/* more complicated code goes here */
}

would print the name of an [expression] and its value, along with the file name and the line number.

<example-two>

#define KT_CREATE(value)	JPA_CREATE( #value, value)

void JPA_CREATE(const char* vname, int value)
{
  printf("JPA_CREATE: value=%s value=%d...\n", vname, value );
}

int main(int argc, char *argv[])
{
	 int val = 3;
	 int is_this_my_own = 4;

	 KT_CREATE(val);
	 KT_CREATE(is_this_my_own);

	 return;
}

output:
JPA_CREATE: value=val value=3...
JPA_CREATE: value=is_this_my_own value=4...


{variadic-macros}

http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html

A macro can be declared to accept a variable number of arguments much as a function can. The syntax
for defining the macro is similar to that of a function. Here is an example:

     #define eprintf(...) fprintf (stderr, __VA_ARGS__)

This kind of macro is called [variadic]. When the macro is invoked, all the tokens in its argument
list after the last named argument (this eprintf macro has none), including any commas, become the
variable argument. This sequence of tokens replaces the identifier __VA_ARGS__ in the macro body
wherever it appears. Thus, we have this expansion:

     eprintf ("%s:%d: ", input_file, lineno)
          ==>  fprintf (stderr, "%s:%d: ", input_file, lineno)

The variable argument is completely macro-expanded before it is inserted into the macro expansion,
just like an ordinary argument. You may use the '#' and '##' operators to stringify the variable
argument or to paste its leading or trailing token with another token. (But see below for an
important special case for '##'.)

If your macro is complicated, you may want a more [descriptive-name] for the variable argument than
__VA_ARGS__. CPP permits this, as an extension. You may write an argument name immediately before
the '...'; that name is used for the variable argument. The eprintf macro above could be written

     #define eprintf(args...) fprintf (stderr, args)

using this extension. You cannot use __VA_ARGS__ and this extension in the same macro.
 
<possible-problem>

You can have named arguments as well as variable arguments in a variadic macro. We could define
eprintf like this, instead:

     #define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)

This formulation looks more descriptive, but unfortunately it is [less-flexible]: you must now
supply at [least-one-argument] after the format string. In standard C, you cannot omit the comma
separating the named argument from the variable arguments. Furthermore, if you leave the variable
argument empty, you will get a [syntax-error], because there will be an extra comma after the format
string.

     eprintf("success!\n", );
          ==> fprintf(stderr, "success!\n", );

GNU CPP has a pair of extensions which deal with this problem. First, you are allowed to leave the
variable argument out entirely:

     eprintf ("success!\n");
          ==> fprintf(stderr, "success!\n", );

 [KT] not works in 4.6 G++. 

Second, the '##' token paste operator has a special meaning when placed between a comma and a
variable argument. If you write

     #define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)

and the variable argument is left out when the eprintf macro is used, then the comma before the '##'
will be deleted. This does not happen if you pass an empty argument, nor does it happen if the token
preceding '##' is anything other than a comma.

     eprintf ("success!\n")
          ==> fprintf(stderr, "success!\n");

 [KT] this works in 4.6 G++.

The above explanation is ambiguous about the case where the only macro parameter is a variable
arguments parameter, as it is meaningless to try to distinguish whether no argument at all is an
empty argument or a missing argument. In this case the C99 standard is clear that the comma must
remain, however the existing GCC extension used to swallow the comma. So CPP retains the comma when
conforming to a specific C standard, and drops it otherwise.

Variadic macros are a new feature in C99. GNU CPP has supported them for a long time, but only with
a named variable argument ('args...', not '...' and __VA_ARGS__). If you are concerned with
portability to previous versions of GCC, you should use only named variable arguments. On the other
hand, if you are concerned with portability to other conforming implementations of C99, you should
use only __VA_ARGS__.

Previous versions of CPP implemented the comma-deletion extension much more generally. We have
restricted it in this release ( [KT] version? ) to minimize the differences from C99. To get the
same effect with both this and previous versions of GCC, the token preceding the special '##' must
be a comma, and there must be white space between that comma and whatever comes immediately before
it:

     #define eprintf(format, args...) fprintf (stderr, format , ##args)


{case-example-one}

Use:

MHEGDebugInfo(eMHVdsm, "_mhvDsmEventCreate %d\n", num);

#if ...

 [KT] see debug output to use both module or single module(mhegdebug).

#define MHEGDebugInfo(comp, ...) {BP_PRINT(MHEGDebugCompToBPComp(comp), CCDebugBP::INFO, __VA_ARGS__);\
                                  MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__); }
...

#define MHEGOnlyDebugInfo(comp, ...) (MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
...

#else

#define MHEGDebugInfo(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelInfo, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugDebug(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelDebug, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugWarning(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelWarning, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugMajor(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelMajor, __FUNCTION__, __VA_ARGS__))
#define MHEGDebugFatal(comp, ...)(MHEGDebugTrace(comp, eMHEGLevelFatal, __FUNCTION__, __VA_ARGS__))

#endif

void MHEGDebugTrace(MHEGComponent comp, MHEGLevel level, const char* functionName, ...)
{
  // Always send to BP print, at least for now.
  if ((s_traceLevels[comp] >= level) && (s_traceLevels[comp] < eMHEGLevelOff))
  {
      va_list ap;
      va_start(ap, functionName);
      char *message = va_arg(ap, char*);
      output(comp, level, functionName, message, ap);
      va_end(ap);
  }
}

#define LINE_LIMIT 1024
static char temp_buffer[LINE_LIMIT + 1]; // Limit all strings to LINE_LIMIT

// [KT] here string is fmt
//
void output(MHEGComponent comp, MHEGLevel level, const char* function, const char* string, va_list arg)
{
   AUTOLOCK();

   // TODO, add support for timestamp.
   // Check for space
   // Construct final string
   long int tick = PCTime::Tick();

   // [KT] #define SNPRINTF snprintf
   int pos = SNPRINTF(temp_buffer, LINE_LIMIT, "[%ld:%ld][%s][%s][%s] ", 
      tick/1000, tick%1000, s_names[comp], s_traceLevelName[level], function);

   // [KT] string is format
   size_t len = vsnprintf(temp_buffer + pos, LINE_LIMIT - pos - 1, string, arg) + pos;
   if (temp_buffer[len - 1] != '\n')
   {
     temp_buffer[len] = '\n';
     len++;
     temp_buffer[len] = '\0';
   }

   BP_PRINTR(CCDebug::DEFAULT, CCDebugBP::INFO, temp_buffer);
}


Tried to use macro only to use frintf but seems not a solution because no way to build "format"
properly. Here get is ["fmt" __LINE__, __FUNC__, "fmt", args... ]

#define MHEGDebugInfo(comp, ...) TLOG("[%d:%s]\n",  __LINE__,  __PRETTY_FUNCTION__, __VA_ARGS__)
#define TLOG(...) fprintf( stderr, __VA_ARGS__)


{case-example-two}

From Tizen:

__pServiceAppImpl is pointer from creating objcets.

/*
 * @param[in]	NID			The Tizen namespace
 * @param[in]	condition		The condition that is expected to be true
 * @param[in]	r			The last result to set
 * @param[in]   ...			The message to display
 */

SysTryReturnResult(NID_APP, __pServiceAppImpl, E_OUT_OF_MEMORY, "[E_OUT_OF_MEMORY] Insufficient memory.");

#ifndef unlikely
#define unlikely(x)  __builtin_expect(!!(x), 0)    // see {likey-and-unlikely}
#endif

#define SysTryReturnVoidResult(NID, condition, r, ...)	\
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			return;	\
		} \
	} while (0);

#define SysLogException(NID, r, ...)               SysLogExceptionInternal(NID, r, __PRETTY_FUNCTION__, 
__LINE__, __VA_ARGS__)


void
SysLogExceptionInternal(unsigned long nid, result r, const char* pFunction, int lineNumber, 
const char* pFormat, ...)
{
	va_list args;

	SetLastResult(r);

	if (!logInfo.platformExceptionEnabled)
	{
		return;
	}

	va_start(args, pFormat);

	__PrintSysLog(static_cast<_LogType>(LOG_EXCEPTION), static_cast<LogID>(nid), pFunction, lineNumber, 
	pFormat, args);

	va_end(args);
}

void __PrintSysLog(_LogType type, LogID id, const char* pFunction, int lineNumber, const char* pFormat, 
va_list args)
{
	if (!iniLoaded)
	{
		__InitializeLogInfo();
	}

	if (!__GetEnableInfo(static_cast<LogID>(id)))
	{
		return;
	}

	char logBody[LOG_LEN_MAX];
	snprintf(logBody, LOG_LEN_MAX, "%s(%d) > %s", pFunction, lineNumber, pFormat);
	logBody[LOG_LEN_MAX -1] = '\0';

	char logTag[LOG_MODULE_NAME_LEN_MAX];

	snprintf(logTag, LOG_MODULE_NAME_LEN_MAX, "%s", __GetModuleName(static_cast<LogID>(id)));
	logTag[LOG_MODULE_NAME_LEN_MAX - 1] = '\0';

	switch (type)
	{
	case static_cast<_LogType>(LOG_INFO):
		LOG_VA(LOG_INFO, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_DEBUG):
		LOG_VA(LOG_DEBUG, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_EXCEPTION):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	case static_cast<_LogType>(LOG_USER):
		ALOG_VA(LOG_ERROR, logTag, logBody, args);
		break;

	default:
		LOG_VA(LOG_DEBUG, LOG_TAG_NULL, logBody, args);
		break;
	}
}

#ifndef LOG_VA
#define LOG_VA(priority, tag, fmt, args) \
    vprint_log(D##priority, tag, fmt, args)
#endif

#define vprint_log(prio, tag, fmt...) \
	__dlog_vprint(LOG_ID_MAIN, prio, tag, fmt)


{case-example-try-catch}

result
ServiceApp::Execute(ServiceAppInstanceFactory pServiceAppFactory, const IList* pArguments)
{
	r = pAppImpl->Construct(pArguments);
	SysTryCatch(NID_APP, !IsFailed(r), r = E_SYSTEM, E_SYSTEM, "[E_SYSTEM] %s.", GetErrorMessage(r));
CATCH:
	delete pServiceApp;

	return r;
}

#define SysTryCatch(NID, condition, expr, r, ...) \
	do \
	{ \
		if (unlikely(!(condition))) {	\
			SysLogException(NID, r, __VA_ARGS__); \
			expr; \
			goto CATCH;	\
		} \
	} while (0);


{case-example-two}

_INFO("main:_terminate:leave\n");

#ifndef _ERR
#define _ERR(fmt, args...) LOGE("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _DBG
#define _DBG(fmt, args...) LOGD("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)
#endif

#ifndef _INFO
#define _INFO(fmt, args...) LOGI("[%s:%d] "fmt"\n", __func__, __LINE__, ##args)		[KT] multi-level
#endif

#ifndef LOGI
#define LOGI(...) ((void)LOG(LOG_INFO, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOGE
#define LOGE(...) ((void)LOG(LOG_ERROR, LOG_TAG, __VA_ARGS__))
#endif

#ifndef LOG
#define LOG(priority, tag, ...) \
	print_log(D##priority, tag, __VA_ARGS__)
#endif

#define print_log(prio, tag, fmt...) \
	__dlog_print(LOG_ID_MAIN, prio, tag, fmt)

int __dlog_vprint(log_id_t log_id, int prio, const char *tag, const char *fmt, va_list ap)
{
    char buf[LOG_BUF_SIZE];

    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);

    return write_to_log(log_id, prio, tag, buf);
}

int __dlog_print(log_id_t log_id, int prio, const char *tag, const char *fmt, ...)
{
    va_list ap;
    char buf[LOG_BUF_SIZE];

    va_start(ap, fmt);
    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);
    va_end(ap);

    return write_to_log(log_id, prio, tag, buf);
}

static int __write_to_log_kernel(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
	ssize_t ret;
	int log_fd;
	struct iovec vec[3];

	if( log_id < LOG_ID_MAX )
		log_fd = log_fds[log_id];
	else
		return -1; // for TC

	if (!tag)
		  tag = "";

	vec[0].iov_base	= (unsigned char *) &prio;
	vec[0].iov_len	= 1;
	vec[1].iov_base	= (void *) tag;
	vec[1].iov_len	= strlen(tag) + 1;
	vec[2].iov_base	= (void *) msg;
	vec[2].iov_len	= strlen(msg) + 1;

   // [KT] this is sys call
	ret = writev(log_fd, vec, 3);

	return ret;
}

static int __dlog_init(log_id_t log_id, log_priority prio, const char *tag, const char *msg)
{
#ifdef HAVE_PTHREADS
		pthread_mutex_lock(&log_init_lock);
#endif
	// get filtering info

	// open device
	if( write_to_log == __dlog_init)
	{
		log_fds[LOG_ID_MAIN] = open("/dev/"LOG_MAIN, O_WRONLY);
		log_fds[LOG_ID_RADIO] = open("/dev/"LOG_RADIO, O_WRONLY);
		log_fds[LOG_ID_SYSTEM] = open("/dev/"LOG_SYSTEM, O_WRONLY);

		if( log_fds[LOG_ID_MAIN] < 0 || log_fds[LOG_ID_RADIO] < 0 )
		{
			fprintf(stderr, "open log dev is failed\n");
			write_to_log = __write_to_log_null;
		}
		else
			write_to_log = __write_to_log_kernel;

		if( log_fds[LOG_ID_SYSTEM] < 0 )
		{
			log_fds[LOG_ID_SYSTEM] = log_fds[LOG_ID_MAIN];
		}
	}
#ifdef HAVE_PTHREADS
    pthread_mutex_unlock(&log_init_lock);
#endif
	return write_to_log(log_id, prio, tag, msg);
}


{why-ellipses-dangerous}
http://www.learncpp.com/cpp-tutorial/714-ellipses-and-why-to-avoid-them/

Two points:

o no type checks on calling parameters
o no checks on the mumber of calling parameters

#include <cstdarg> // needed to use ellipses

// The ellipses must be the last parameter
double FindAverage(int nCount, ...)
{
  long lSum = 0;

  // We access the ellipses through a va_list, so let's declare one
  va_list list;

  // We initialize the va_list using va_start. The first parameter is
  // the list to initialize. The second parameter is the last non-ellipse
  // parameter.
  va_start(list, nCount);

  // Loop nCount times
  for (int nArg=0; nArg < nCount; nArg++)
    // We use va_arg to get parameters out of our ellipses
    // The first parameter is the va_list we're using
    // The second parameter is the type of the parameter
    lSum += va_arg(list, int);

  // Cleanup the va_list when we're done.
  va_end(list);

  return static_cast<double>(lSum) / nCount;
}
 
int main()
{
  cout << FindAverage(5, 1, 2, 3, 4, 5) << endl;
  cout << FindAverage(6, 1, 2, 3, 4, 5, 6) << endl;
}

Why ellipses are dangerous

Ellipses offer the programmer a lot of flexibility to implement functions that can take a variable
number of parameters. However, this flexibility comes with some very dangerous downsides.

With regular function parameters, the compiler uses type checking to ensure the types of the
function arguments match the types of the function parameters (or can be implicitly converted so
they match). This helps ensure you don't pass a function an integer when it was expecting a string,
or vice versa. However, note that ellipses parameters have no type declarations. When using
ellipses, the compiler completely suspends type checking for ellipses parameters. This means it is
possible to send arguments of any type to the ellipses! However, the downside is that the compiler
will no longer be able to warn you if you call the function with ellipses arguments that do not make
sense. When using the ellipses, it is completely up to the caller to ensure the function is called
with ellipses arguments that the function can handle. Obviously that leaves quite a bit of room for
error (especially if the caller wasn't the one who wrote the function).

Lets look at an example of a mistake that is pretty subtle:
	
cout << FindAverage(6, 1.0, 2, 3, 4, 5, 6) << endl;

Although this may look harmless enough at first glance, see that the second argument (the first
ellipse argument) is a double instead of an integer. This compiles fine, and produces a somewhat
surprising result:

1.78782e+008

which is a REALLY big number. How did this happen?

As you have learned in previous lessons, a computer stores all data as a sequence of bits. A
variable's type tells the computer how to translate that sequence of bits into a meaningful value.
However, you just learned that the ellipses throw away the variable's type! Consequently, the only
way to get a meaningful value back from the ellipses is to manually tell va_arg() what the expected
type of the next parameter is. This is what the second parameter of va_arg() does. If the actual
parameter type doesn't match the expected parameter type, bad things will usually happen.

In the above FindAverage program, we told va_arg() that our variables are all expected to have a
type of int. Consequently, each call to va_arg() will return the next sequence of bits translated as
an integer.

In this case, the problem is that the double we passed in as the first ellipse argument is 8 bytes,
whereas va_arg(list, int) will only return 4 bytes of data with each call. Consequently, the first
call to va_arg will only read the first 4 types of the double (producing a garbage result), and the
second call to va_arg will read the second 4 bytes of the double (producing another garbage result).
Thus, our overall result is garbage.

Because type checking is suspended, the compiler won't even complain if we do something completely
ridiculous, like this:
	
int nValue = 7; cout << FindAverage(6, 1.0, 2, "Hello, world!", 'G', &nValue, &FindAverage) << endl;

Believe it or not, this actually compiles just fine, and produces the following result on the
author's machine:

1.79766e+008

This result epitomizes the phrase, "Garbage in, garbage out" which is a popular computer science
phrase used primarily to call attention to the fact that computers, unlike humans, will
unquestioningly process the most nonsensical of input data and produce nonsensical output
(wikipedia).

So, in summary, type checking on the parameters is suspended, and we have to trust the caller to
pass in the right type of parameters. If they don't, the compiler won't complain; our program will
just produce garbage (or maybe crash).

<second-problem>
As if that wasn't dangerous enough, we run into a second potential problem. Not only do the ellipses
throw away the type of the parameters, it also throws away the number of parameters in the ellipses!
This means we have to devise our own solution for keeping track of the number of parameters passed
into the ellipses. Typically, this is done in one of two ways:

o One of the fixed parameters is used as a parameter count (this is the solution we use in the
FindAverage example above)

o The ellipse parameters are processed until a sentinel value is reached. A sentinel is a special
value that is used to terminate a loop when it is encountered. For example, we could pick a sentinel
value of 0, and continually process ellipse parameters until we find a 0 (which should be the last
value). Sentinel values only work well if you can find a sentinel value that is not a legal data
value. 

However, even here we run into trouble. For example, consider the following call:

For example:
	
cout << FindAverage(6, 1, 2, 3, 4, 5) << endl;

On the authors machine at the time of writing, this produced the result:

699773

What happened? We told FindAverage() we were going to give it 6 values, but we only gave it 5.
Consequently, the first five values that va_arg() returns were the ones we passed in. The 6th value
it returns was a garbage value somewhere in the stack. Consequently, we got a garbage answer.

When using a sentinel value, if the caller forgets to include the sentinel, the loop will run
continuously until it runs into garbage that matches the sentinel (or crashes).

Recommendations for safer use of ellipses

First, if possible, do not use ellipses at all! Oftentimes, other reasonable solutions are
available, even if they require slightly more work. For example, in our FindAverage() program, we
could have passed in a dynamically sized array of integers instead. This would have provided both
strong type checking (to make sure the caller doesn't try to do something nonsensical) while
preserving the ability to pass a variable number of integers to be averaged.

Second, if you do use ellipses, do not mix expected argument types within your ellipses if possible.
Doing so vastly increases the possibility of the caller inadvertently passing in data of the wrong
type and va_arg() producing a garbage result.

Third, using a count parameter as part of the argument list is generally safer than using a sentinel
as an ellipses parameter. This forces the user to pick an appropriate value for the count parameter,
which ensures the ellipses loop will terminate after a reasonable number of iterations even if it
produces a garbage value.


={============================================================================
*kt_dev_prob_010*	macro: get max value of type

From glibc

# ifndef ULONG_MAX
#  define ULONG_MAX ((unsigned long int) ~(unsigned long int) 0)
# endif
# ifndef LONG_MAX
#  define LONG_MAX ((long int) (ULONG_MAX >> 1))
# endif

<problem> TODO: don't know what point it is to say here
From "*kt_dev_quiz_001* bits: how to swap two vars without using a temp"

x = 1010; y = 0011;

x =  1001 =  1010  ^ 0011   (x^y)
y =  1010 = [1001] ^ 0011   (x^y) # y = x = (x^y)^y = (x^0)
x = [0011] =  1001 ^ [1010] (x^y) # x = y = (x^y)^x = (y^0)

x = 0011; y = 1010;

Does it mean that x^1 yields ~x since 0 becomes 1 and 1 becomes 0?

int main () {
  const int ival = 3;

  cout << "ival: " << std::hex << ival << endl;
  cout << "ival: " << std::hex << (ival^0) << endl;
  cout << "ival: " << std::hex << (ival^1) << endl;
  cout << "ival: " << std::hex << (ival^(~0)) << endl;
  cout << "ival: " << std::hex << ~ival << endl;
}

ival: 3
ival: 3
ival: 2
ival: fffffffc
ival: fffffffc

{bitwise-shift}
cout << "ival: " << std::hex << ((unsigned int) (~(unsigned int)0) )<< endl;
cout << "ival: " << std::hex << ((int) ((~(unsigned int)0) >> 1))<< endl;
cout << "ival: " << std::hex << ((int) (~(unsigned int)0) >> 1)<< endl;
cout << "ival: " << std::hex << ((~(unsigned int)0) >> 1)<< endl;
// ival: ffffffff
// ival: 7fffffff
// ival: ffffffff {Q} why?
// ival: 7fffffff

Here two things happens. (Type) is higher than shift operator so singed cast happens first. Then
right shift happens. According to the below article:

shift-expression >> additive-expression

"The right-shift operator causes the bit pattern in shift-expression to be shifted to the right by
the number of positions specified by additive-expression. For 'unsigned' numbers, the bit positions
that have been vacated by the shift operation are <zero-filled>. For 'signed' numbers, the sign bit is
used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if
the number is negative, 1 is used."

Important
The result of a right-shift of a signed negative number is implementation-'dependent'. Although Visual
C++ uses the sign bit to fill vacated bit positions, there is no guarantee that other
implementations also do so.

The ansic says: Right shifting a 'signed' quantity will fill with sign bit (arithmetic shift) on
some machines and with 0 bits (logical shift) on others. Q: How about left shift(<<)? Filling
vacated bits with 0!

Left Shift(<<) and Right Shift(>>) Operators
http://msdn.microsoft.com/en-us/library/336xbhcz.aspx
<example>
#include <iostream>
#include <bitset>
using namespace std;

int main() {
  unsigned short short11 = 1024;
  bitset<16> bitset11{short11};
  cout << bitset11 << endl;     // 0000010000000000

  unsigned short short12 = short11 >> 1;  // 512
  bitset<16> bitset12{short12};
  cout << bitset12 << endl;      // 0000010000000000

  unsigned short short13 = short11 >> 10;  // 1
  bitset<16> bitset13{short13};
  cout << bitset13 << endl;      // 0000000000000001

  unsigned short short14 = short11 >> 11;  // 0
  bitset<16> bitset14{short14};
  cout << bitset14 << endl;      // 0000000000000000
}

see the use of bitset and bitset only supports fixed size.  

<exercise>
From ansic, p49. The function getbits(x, p, n) returns the (right adjusted) n-bit field of x that
begins at position p. For example, getbits( x, 4, 3 ) returns the three bits; 4, 3, 2, right
adjusted.

unsigned getbits( unsigned x, int p, int n )    // note unsigned
{
  return (x >> (p+1-n)) & ~(~0 << n);
}

this can be written using variables to make it easier to understand

unsigned getbits( unsigned x, int p, int n )
{
  unsigned mask = ~(~0 << n);
  unsigned shift = (p+1-n);
  return (x >> shift)) & mask;
}

1) "~(~0 << n)" is interesting in making a 'mask' value.
2) Why (p+1-n) for a shift? Since p(position) starts from 0.

7 6 5 4 3 2 1 0   8 7 6 5 4 3 2 1  position
     [* * *]           [* * *]
4+1-3 = 2 shift   5-3 = 2 shift

3) Do not need () since >> is higher than & but advisable to make easier to see.

<independent-of-length>
// this do not work since getting mask bit is wrong
int getbits(int x, int p, int n)
{
  return x >> (p+1-n) & ~(1 << n);
}

To see the differnece, see the below result.

#include <iostream>
#include <bitset>

int main()
{
  int ival = 1;

  std::bitset<32> bitset1{ival};
  std::cout << bitset1 << std::endl;

  int ival2 = ~( 1 << 3 );
  std::bitset<32> bitset2{ival2};
  std::cout << bitset2 << std::endl;

  int ival3 = ~(~0 << 3 );
  std::bitset<32> bitset3{ival3};
  std::cout << bitset3 << std::endl;
}

kit@kit-vb:~/work$ ./a.out
00000000000000000000000000000001
11111111111111111111111111110111       // 0...0001000
00000000000000000000000000000111       // 1...1111000

No difference when tried 'unsigned int'. The point is that "~0" is not the same as "1". This is
"independent of word length" in ansic p49. For example,

x = x & ~077

set the last 'six' bits of x to zero since "x & ~077" is 'independent' of word length and it thus
perferable to, for example, x & 0177700, which assumes that x is a 16-bit quantity. The portable
form involves no extra cost, since ~077 is a constant expression that can be evaluated at compile
time.

<exercise>
From ansic, p50. The function counts the number of 1 bits in its integer argument. 

int bitcount( unsigned x )    // note unsigned
{
  int b;

  for(b = 0; x != 0; x >>= 1) // for(b = 0; x; x >>= 1) and see {operator-assign}
    if( x & 01 )              // x & 1 works as well
      b++;

  return b;
}

page 51. exercise 2-9. In a two's complement number system, x &= (x-1) deletes the rightmost 1-bit
in x. Explain why. Use this observation to write a 'faster' version of bitcount.

Answer:

If x is odd, then (x-1) has the same bit representation as x except that the rightmost 1-bit is now
a 0. In this case, (x & (x-1)) == (x-1).

x = 5: 5(101) & 4(100) = 100

If x is even, then the representation of (x-1) has the rightmost zeros of x becoming ones and the
rightmost one becoming a zero. Anding the two clears the rightmost 1-bit in x and all the rightmost
1-bits from (x-1).

x = 4: 4(100) & 3(11)  = 0
         ^ rightmost 1
x = 6: 6(110) & 5(101) = 100
          ^ rightmost 1

000   0     All even numbers has tailing 0s and it becomes 1 when -1
001   1
010   2
011   3
100   4
101   5
110   6
111   7
...

Here's the new version of bitcount:

int bitcount(unsigned x)
{
  int b;

  for (b = 0; x != 0; x &= (x-1))
    b++;
  return b;
}

<why-unsigned>
Why "unsigned x" argument? To ensure that vacated bits will be filled with 0 regardless of the
machine the program is run on.

<exercise>
From ansic, exercise 2-6.
Write a function setbits(x,p,n,y) that returns x with the n bits that begin at position p set to the
rightmost n bits of y, leaving the other bits unchanged.

Had difficult to understand a question. The question is that set n bits of x starting from p with
rightmost n bits of y and return the result.

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_6

// one
return (
    (x & ~(~(~0 << n) << p+1-n))    // set n bits of x to 0. x & ~(mask << shift)
    |
    (
     (~(~0 << n) & y)               // get rightmost n bits of y. mask & y
     << p+1-n                       // shift to be in p pos
    )
    );


// two
// The following function, "getbits", is from K&R p 49 */
// getbits: get n bits from position p
unsigned getbits(unsigned x, int p, int n)
{
   return (x >>(p+1-n) & ~(~0 << n));
}

// asbits - shows integers as bit strings. note this is useful as bitset
// Usage:                                
//         asbits(x, sizeof(x), FLAG)    
// FLAG = 1|0, showing if newline desired
void asbits(unsigned x, size_t s, int nl)
{
    int i;

    for(i = s*8-1; i>=0; i--) {
         getbits(x, i, 1)? putchar('1') : putchar('0');
         if(!(i%4))putchar(' ');
    }
    if(nl)putchar('\n');
}

// slightly modified
void asbits( unsigned x )
{
  int i;

  for(i = 8*sizeof(x)-1; i >= 0; i--)
  // for(i = 8*sizeof(x)-1; i; i--) // this is an error
  {
    getbits(x, i, 1) ? putchar('1') : putchar('0');
    if(!(i % 4))
      putchar(' ');
  } 
  putchar('\n');
}

// this is the same as the one
unsigned setbits(unsigned x, int p, int n, unsigned y)
{
    unsigned msk = ~(~0 << n);
    return (x & ~(msk<< p+1-n)) | ((y & msk)<< p+1-n);
}

<to-print-a-bits-in-string>
The possible approach is to right shift one by one, check if it's 0 or 1, and save or print it. This
has a problem since if use loop and putchar, the will get the reversed output. This is why "asbits"
strts from MSB but not LSB.

<stack-and-queue>
This reminds me stack and queue.
input: 11101
           ^ start

      0 1 2 3 4 pos in array
      1 1 1 0 1

read(pop) as a stack, FILO          read(get) as a queue, FIFO
note. reversed output
       10111                           11101
           ^ start                         ^ start

if putchar(printf) array for both cases
   11101

if putchar when get it
   10111

<exercise>
From ansic, exercise 2-7.
Write a function invert(x,p,n) that returns x with the n bits that begin at position p inverted
(i.e., 1 changed into 0 and vice versa), leaving the others unchanged.

// setbits uses y to set x and here xin uses instead.
unsigned invert_mine(unsigned x, int p, int n)
{
  // this makes easier to see a code
  unsigned msk = ~(~0 << n);

  // [*][x ][*] : x
  // [0][1 ][0] : msk << p+1-n
  // [0][x ][0] : (msk << p+1-n) & x
  // [1][x'][1] : ~((msk << p+1-n) & x)
  // [0][1 ][0]
  // [0][x'][0] : &
  unsigned xin = (~((msk << p+1-n) & x)) & msk << p+1-n;

  // this is the same as setbits
  return (x & ~(msk<< p+1-n)) | ((xin & msk)<< p+1-n);
}

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_7    {xor}
GP is in error. Here is a correct solution. Pilcrow 17:45, 31 August 2011 (UTC) 
unsigned invert_online(unsigned x, int p, int n)
{
	return x ^ ((~(~0<<n))<< p+1-n);
	// return x ^ (mask << shift);
}

<exercise>
From ansic, exercise 2-8.
Write a function rightrot(x,n) that returns the value of the integer x rotated to the right by n bit
positions.

The two things to think: 
1) The type is 'unsigned' so do not need to concern about value when do right shift. If not, need to
know the the length of type, such as sizeof(x).

// one
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned rightrot(unsigned x, unsigned n)
{
  while (n > 0) {
    if ((x & 1) == 1)
      x = (x >> 1) | ~(~0U >> 1);
    else
      x = (x >> 1);
    n--;
  }
  return x;
}

// two
// http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_8
unsigned int rightrot(unsigned int x, int n)
{
  int m, i;

  for(i=0; i < n; i++) {
    m = getbits(x, 0, 1);
    m <<= (sizeof(m)*8-1);       // notice the use of sizeof
    x >>= 1;
    x |= m;
  }
  return x;
}


{bitwise-octal}
A leading 0 on an integer constant means 'octal' and this seems better that hex to use with bit
pattern.

0 0
1 01
2 10
3 11
4 100
5 101 
6 110
7 110

0177 1.111.111
0x7F 111.1111


={============================================================================
*kt_dev_prob_011* pointer or handle

Use a pointer variable to hold handle.

#include <iostream>

using namespace std;

typedef void* HANDLE;

int _gval = 2;

int main()
{

  cout << "{ main == " << std::endl;

  HANDLE x = (HANDLE) _gval;

  std::cout << x << std::endl;

  cout << "} main == " << std::endl;
}


={============================================================================
*kt_dev_prob_012* problem of incremental build or make

2014.08.

Problem: Found that the old code was used in the long debugging sesseion and made me wonder why it
is still called since moved to new code already? Found that the state was the mix of new and old
code. Quite difficult to debug and to find out what's happened. Limiation of incremental build or
make system?

Why: The problem code is

CPort::CPort()
{
#ifdef FS_SUPPORTED
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CFs));
  MHEGDebugDebug(eMPORT, "CFs is created");
#else
  _smap.insert( std::pair<std::string, IDriver*>("DSM:", new CDsm));
  MHEGDebugDebug(eMPORT, "CDsm is created");
#endif
...
}

What will happen when use incremental build after removing this #define? This file was not changed
so not compiled in the build. So other new codes were compiled without this def and this old code
compiled with this def. Therefore, had CFs object while believeing CDsm object.


# ============================================================================
#{ GNU CORE UTILS
={============================================================================
*kt_dev_guti_000*   gnu core util sites

http://www.gnu.org/software/coreutils/
git clone git://git.sv.gnu.org/coreutils coreutils


# ============================================================================
#{ GCC
={============================================================================
*kt_dev_gcc_000*	gcc compile script

#!/bin/bash
g++ -g -std=c++0x $1


==============================================================================
*kt_dev_gcc_001*	error: two or more data types in declaration specifiers

This error happened under gcc c build when include a header having:

#ifndef __cplusplus
typedef uint8_t bool;
#endif

Thought that it means duplication defined in somewhere and tried followings in sample build:

{example-one} no error

#include <stdio.h>

typedef unsigned char bool;
typedef unsigned char bool;


{example-one} errors

#include <stdio.h>

typedef unsigned char bool;
typedef int bool;

testerrfunc.c:4:13: error: conflicting types for 'bool'
testerrfunc.c:3:23: note: previous declaration of 'bool' was here


{example-three} 

#include <stdio.h>

#define bool unsigned char
typedef int bool;

testerrfunc.c:4:13: error: two or more data types in declaration specifiers
testerrfunc.c:4:1: warning: useless type name in empty declaration [enabled by default]

Therefore, this means "typedef int unsigned char;" hence error.


{stdbool.h} {preprocessor-options}

Tried to preprocessor output using "-E" option but not that useful. But found following line from
the output and when followed that file, found what went wrong:

From -E output using GCC 453.  
# 1 "/usr/lib/gcc/armv7l-tizen-linux-gnueabi/4.5.3/include/stdbool.h" 1 3 4

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */

#ifndef _STDBOOL_H
#define _STDBOOL_H

#ifndef __cplusplus

#define bool	_Bool
#define true	1
#define false	0

#else /* __cplusplus */

/* Supporting <stdbool.h> in C++ is a GCC extension.  */
#define _Bool	bool
#define bool	bool
#define false	false
#define true	true

#endif /* __cplusplus */

/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined	1
#endif	/* stdbool.h */

note: it is not automatically included when use stdio.h.

From GCC: http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Data-Types

ISO C99 adds the following keywords:
     inline _Bool _Complex _Imaginary


==============================================================================
*kt_dev_gcc_002*	error: ISO C++ forbids declaration of 'UseStatic' with no type [-fpermissive]

class UseStaic
{
	public:
	UseStatic() { std::cout << "Use staic ctor" << std::endl; }

	private:
	Sclass m_sclass;
};

Happened when made a typo in class name and meant to be class UseStatic. Basically, not able to find
UseStatic type.

From GCC:

-fpermissive

Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using
-fpermissive allows some nonconforming code to compile. 


{when-missed-include}

<example-one>

#include < iostream>
// #include < stack>

using namespace std;

int main()
{
	int n;
	double item;
	stack<double> numbers;
	...
}

usestack.cpp:11:2: error: 'stack' was not declared in this scope
usestack.cpp:11:8: error: expected primary-expression before 'double'
usestack.cpp:11:8: error: expected ';' before 'double'


<example-two>

#include < iostream>
// #include < stack>

int main()
{
	int n;
	double item;
	std::stack<double> numbers;
	...
}

usestack.cpp:8:2: error: 'stack' is not a member of 'std'
usestack.cpp:8:13: error: expected primary-expression before 'double'
usestack.cpp:8:13: error: expected ';' before 'double'

Does it mean that it gives more reason not to use using-directive?


==============================================================================
*kt_dev_gcc_003*	error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]

This is an error when tried convert from base to derived.

class Singleton
{
	protected:
	Singleton() {};

	public:
	virtual Singleton* Instance();

	protected:
	static Singleton* m_pins;
};

Singleton* Singleton::m_pins = 0;

Singleton* Singleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "Singleton::Instance" << std::endl;
		//m_pins = new Singleton;
	}

	return m_pins;
}

class MySingleton : public Singleton
{
	public:
	virtual MySingleton* Instance();
};

MySingleton* MySingleton::Instance() 
{
	if( m_pins == 0 )
	{
		std::cout << "MySingleton::Instance" << std::endl;
		//_pins = new MySingleton;
	}

	return m_pins; // error
}

usestatic.cpp: In member function 'virtual MySingleton* MySingleton::Instance()':
usestatic.cpp:106:9: error: invalid conversion from 'Singleton*' to 'MySingleton*' [-fpermissive]


==============================================================================
*kt_dev_gcc_004*	error: variable-sized object 'out' may not be initialised

void Merge( Entry* array, Position length, Position start, Position middle, Position end )
{
	Entry out[length];			// this works fine but not inited.
	Entry out[length] = {0};	// this causes an error
	Entry out[30] = {0};			// this works
}


I am assuming that you are using a C99 compiler (with support for dynamically sized arrays). The
problem in your code is that at the time when the compilers sees your variable declaration it cannot
know how many elements there are in the array (I am also assuming here, from the compiler error that
length is not a compile time constant). 

So should use memset or alloc in a function. [KT] Think from compiler perspective.

==============================================================================
*kt_dev_gcc_005*	error: expected ‘}’ at end of input


#include <iostream>
#include "Fsm.h"

int main()
{
	std::cout << "--{ main " << std::endl;

	std::cout << "--} main " << std::endl;
}

main.cpp:9:1: error: expected ‘}’ at end of input

Have got this error and puzzled since there is not much in this file. Interestingly when remove
fsm.h include, builds. So thought it may not find this header? Spend some time to change makefile to
specify current directory in the gcc command line. This turns out that in fsm.h, there is a missing
closing brace and this cause this error.

#ifdef __cplusplus
extern "C"
{
#endif

  ...

//#ifdef __cplusplus
//}
//#endif


==============================================================================
*kt_dev_gcc_006*  error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

error: 'X' does not name a type 

This happens when there is no typedef or types declared before its use.

error: expected specifier-qualifier-list before 'X' or error: 'X' does not name a type 

This is the same as above but more difficult to find because it happes when include a lot of headers
and there is dependencies between them.

<buffer.h>

#include "semaphore.h" // here one of struct uses some from st.h
#include "st.h"

<buffer.c>

#include "buffer.h"
#include "st.h"

In file included from buffer.h:1, from buffer.c:4: 
semaphore.h:4: error: expected specifier-qualifier-list before 'st_cond_t'

This shows the order is important in header inclusion.

This also happens when use the same header guard for two different headers. This effectvely do not
include necessary header and hence the error.

#ifndef __MH5W_GPI_H__
#define __MH5W_GPI_H__


={============================================================================
*kt_dev_gcc_007*  error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before

<case-01>
Like this case when use CPP features in C, this is very obvious so errors are clear.

kit@kit-vb:~/work$ gcc repmanc.c 
repmanc.c:10:1: error: unknown type name ‘class’
repmanc.c:11:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token

<case-02>
However, when there are many header files and they are cascaded each other, this is not obvious.
This happens because C file uses CPP header which defines classes and cannot handle class keyword.

In file included from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/OSAbstraction.h:10:0,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/app/MApp.h:26,
                 from /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/main/view_main.c:28:
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/PCString.h:52:7: error: expected '=', ',',
';', 'asm' or '__attribute__' before 'PCMem'


={============================================================================
*kt_dev_gcc_008*  warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]

This happens when use string literal for char* member in GCC(g++) but it was fine before in C.

main.cpp:53:74: warning: deprecated conversion from string constant to ‘char*’ [-Wwrite-strings]

typedef struct fsm_instance {
   char*              name;
   ...
} fsm_instance_t;

fsm_instance_t Foo = { "Fsm", ... };

-Wwrite-strings

When compiling C, give string constants the type "const char[length]" so that copying the address of
one into a non-const char * pointer produces a warning. These warnings help you find at compile time
code that can try to 'write' into a string constant, but only if you have been very careful about
using 'const' in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not
make -Wall request these warnings.

When compiling C++, warn about the deprecated conversion from string literals to char *. This
warning is enabled by default for C++ programs. 

1) Should consider using std::string name; instead?
Not perferred since need to change other C codes to get c string. .c_str().

2) Should use const in declarations?

typedef struct fsm_instance {
   const char*              name;
   ...
} fsm_instance_t;

But this cause other warnings in other function defs using this strucrue due to const.

3) Should use char* where string literal used.
This (char*) is the easiest way.


={============================================================================
*kt_dev_gcc_009*  error: jump to case label [-fpermissive]

{code-example}
http://stackoverflow.com/questions/2392655/what-are-the-signs-of-crosses-initialization

<example-one>
#include <iostream>
using namespace std;

int main()
{
  int x, y, i;
  cin >> x >> y >> i;
  switch(i) {
    case 1:
      // int r;         // a) okay
      // int r = x + y; // b) fail to compile
      // int r = 1;     // c) fail to compile
      cout << r;
      break;
    case 2:
      r = x - y;
      cout << r;
      break;
  };
}

sam01.cpp:14:14: error: jump to case label [-fpermissive]   // NOTE. this is main error.
sam01.cpp:11:17: error:   crosses initialisation of ‘int r’

Why? Why is a) okay?

The Standard says (6.7/3):
It is possible to transfer into a block, but not in a way that bypasses declarations with
'initialization'. A program that jumps from a point where a local variable with automatic storage
duration is not in scope (KT, out of switch) to a point where it is in scope (KT, in switch) is
ill-formed unless the variable has POD type (3.9) and is declared without an initializer (8.5).

1) The problem is that it is possible for r to come to scope without its initializer being executed.
The code would compile fine if you removed the initializer completely (i.e. the line would read int
r;).

2) It will cause a "crosses initialization" error, because it is possible to skip the initialization
of r, but after that it will still be in scope, even though it was never created in the first place.
NOTE: this is not true since switch is a single scope. see below examples.

The best thing you can do is to limit the scope of the variable. That way you'll satisfy both the
compiler and the reader. Or declare variables before switch.

switch(i)
{
  case 1:
    {
      int r = 1;
      cout << r;
    }
    break;
  case 2:
    {
      int r = x - y;
      cout << r;
    }
    break;
};

<example-two>
CCi.cpp:281:10: error: jump to case label
CCi.cpp:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'
CCi.cpp:284:34: error: redeclaration of 'std::vector<unsigned char> abortCode'
CCi.cpp:260:34: error: 'std::vector<unsigned char> abortCode' previously declared here
CCi.cpp:295:5: error: jump to case label
CCi.cpp:260:34: error:   crosses initialization of 'std::vector<unsigned char> abortCode'

    case SIGNAL_CI_APP_MMI_ABORT_REQ:
260:      std::vector<unsigned char> abortCode;
      ...
      break;

281:case SIGNAL_CI_APP_MMI_ABORT_ACK:
      ...
284:      std::vector<unsigned char> abortCode;


KT. So the switch is a single scope but has multiple blocks(jumps). The problem is that code can be
executed without proper initiailisation. Hence 'intelligent' compiler flags up.


={============================================================================
*kt_dev_gcc_100*	gcc and c++11

{reference}
http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html
http://gcc.gnu.org/wiki/HomePage

{gcc-headers}
For ubuntu:

/usr/lib/gcc/i686-linux-gnu/4.6/include
/usr/include/c++/4.6/


{override-keyword}
Explicit virtual overrides from GCC 4.7

{range-for}
VC 2012 supports but g++ (GCC) 4.4.5 don't. This 'range based for' is supported from 4.6

vector< int > v = { ... };

for(auto& r : v )
	 r *= 2;

is equals to:

for(auto beg = v.begin(), end = v.end(); beg != end; ++beg )
{
	 auto& r = *beg;
	 r *= 2;
}


{alias-declaration}
Primers p68. GCC 4.4.5 don't.

class Foo {

	 using line_no = vector< string >::size_type;

	 typedef vector< string >::size_type line_no;
};


{auto}
GCC 4.4.5 do.


{explicit}
From GCC 45. See *kt_dev_cpp_005* for more.


{class-initializers}
For GCC 463 it emit error:
usecomma.cpp:5:19: sorry, unimplemented: non-static data member initialisers


{c++11}
http://gcc.gnu.org/projects/cxx0x.html

C++0x was the working name of the ISO C++ 2011 standard, which introduced a host of new features
into the standard C++ language and library. This project sought to implement new C++11 features in
GCC, and made it the first compiler to bring feature-complete C++11 to C++ programmers.

C++11 features are available as part of the "mainline" GCC compiler in the trunk of GCC's Subversion
repository and in GCC 4.3 and later. 

>
 To enable C++0x support, add the command-line parameter -std=c++0x to your g++ command line. 
<
Or, to enable GNU extensions in addition to C++0x extensions,
add -std=gnu++0x to your g++ command line. GCC 4.7 and later support -std=c++11 and -std=gnu++11 as
well.

Important: GCC's support for C++11 is still experimental. Some features were implemented based on
early proposals, and no attempt will be made to maintain backward compatibility when they are
updated to match the final C++11 standard.

$ g++ -v --help | egrep "\-std"

  -std=c++0x                  Conform to the ISO 1998 C++ standard, with
                              extensions that are likely to become a part of
                              the upcoming ISO C++ standard, dubbed C++0x. Note
                              that the extensions enabled by this mode are
                              experimental and may be removed in future
                              releases of GCC.

note: when use gcc, got link errors that cannot find STLs. must use g++.
$ g++ -std=c++0x sample.cpp

{the-gnu-c++-library}
http://gcc.gnu.org/onlinedocs/libstdc++/index.html


{how-to-use-gcc-optimisation} {gcc-profiling}
The example program above does have a very predictable, repeatable flow of execution. Let's see what
happens when we use compiler-assisted optimization. Building the programming now involves two steps:
a profiling phase and an optimized compile. In the profiling phase, we build and run an instrumented
version of the executable. We build as follows:

    $ cc -O3 -DDONT_EXPECT -fprofile-generate builtin_expect_test.c -o bn.prof

(The -fprofile-generate option implies -fprofile-arcs, as well as one or two other profiling
options.)

We then run the executable, which generates profiling information that is stored in a file (with the
extension .gcda).

    $ time -f "%E real, %U user, %S sys" ./bn.prof 1000
    0, 1000000000
    0:05.39 real,  5.37 user, 0.00 sys

Note that, because of the instrumentation code, the profiled version runs rather slower that the
normally compiled code.  Running this code created a file containing the profiling results:

    $ ls *.gcda
    builtin_expect_test.gcda

We then employ the -fprofile-use compiler option,which (implicitly) uses the profiling results to
create an optimized executable.

    $ cc -O3 -DDONT_EXPECT -fprofile-use builtin_expect_test.c -o bn.opt

And then we run the optimized program:

    $ time -f "%E real, %U user, %S sys" ./bn.opt 1000
    0, 1000000000
    0:01.95 real,  1.94 user, 0.00 sys

This optimized version runs significantly faster (1.95 versus 2.28 seconds) than our version that
used __builtin_expect(). This is because, in addition to the branching in the if statement, the
branching in the for loops was also optimized.

It's left as an exercise for the reader to show that employing __builtin_expect() (to expect 0) in
conjunction with compiler-assisted optimization doesn't improve things: the compiler already
optimizes the if branching as well as the programmer-directed optimization. One other interesting
exercise  is, of course, to compare the assembler (cc -S) code generated for each of the above
cases. 

{gcc-options}
http://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC

-v
Print (on standard error output) the commands executed to run the stages of compilation. Also print
the version number of the compiler driver program and of the preprocessor and the compiler proper.
 [KT] can see spec and include path

-###
Like -v except the commands are not executed and arguments are quoted unless they contain only
alphanumeric characters or ./-_. This is useful for shell scripts to capture the driver-generated
command lines. 

-print-search-dirs [KT] to check path for lib


{nullptr}
This is for C++11.

$ gcc sam01.c
sam01.c: In function ‘main’:
sam01.c:7:26: error: ‘nullptr’ undeclared (first use in this function)
sam01.c:7:26: note: each undeclared identifier is reported only once for each function it appears in

$ g++ -g -std=c++0x sam01.c
kt@kt-ub-vb:~/work$ cat comp.sh 


={============================================================================
*kt_dev_gcc_101*	gcc typeof

To check actual type of some expression. For example:

http://gcc.gnu.org/onlinedocs/gcc/Typeof.html
http://stackoverflow.com/questions/16832863/behaviour-of-sizeof-in-c-gcc


==============================================================================
*kt_dev_gcc_102*	gcc binutil

{gcc-binutil}

http://sourceware.org/binutils/docs-2.20/
http://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html

GCC provides a large number of built-in functions other than the ones mentioned above. Some of these
are for internal use in the processing of exceptions or variable-length argument lists and are not
documented here because they may change from time to time; we do not recommend general use of these
functions. 


{nm-find-symbol}

%nm *.a

%/opt/toolchains/bin/mipsel-linux-uclibc-nm
%nm libicammulti.a | grep vendor

00000bc0 t _GLOBAL__I_vendor_init
00000980 T vendor_cleanup
00000000 T vendor_init
000002c8 T vendor_setup
000000bc r _ZZ12vendor_setupE12__FUNCTION__
00000088 r _ZZ12vendor_setupE19__PRETTY_FUNCTION__

where: for more details %man nm
 
Uppercase means global and lowercase means local. 
B is bss
T/t is text and means symbols defined in this object file. 
D data
A is this address is absolute and is not subject to modification by an additional link stage
U is undefined meaning extern

Cannot use nm for a stripped object


==============================================================================
*kt_dev_gcc_103*	gcc link and ld

{gcc-compliation-process}

Four phase: preprocessing, compilation, assembly and linking. [KT] Seen the case that during the
porting work, built all files but when starts some funcs which are part of files which are already
built, seeing more errors of missing header files and undefined symbols. Why?

From online:

Once the object file containing the machine code is produced in the step above, the linking step
makes sure that all the undefined symbols in code are resolved.

Enable warnings using -Wall flag, then you will see warning: Implicit call to function bprint() and
Implicit call to function aprint(). It's is basically compiler recognizes this function during
Linker stage and this does not give any error.

So gcc assumes implicit calls in compilation phase and starts to emit errors when actually use it
which lead to link it. See the below for a correct answer.

{gcc-link-order}

http://eli.thegreenplace.net/2013/07/09/library-order-in-static-linking/
_______________________________
Library order in static linking

July 9th, 2013 at 5:56 am

I'll start with a slightly sneaky but educational example. Suppose we have this code:

volatile char src[] = {1, 2, 3, 4, 5};
volatile char dst[50] = { 0 };

void* memcpy(void* dst, void* src, int len);

int main(int argc, const char* argv[])
{
    memcpy(dst, src, sizeof(src) / sizeof(src[0]));
    return dst[4];
}

It runs just fine and the return value is 5. Now, suppose this is part of a larger project that
consists of many object files and libraries, and somewhere within the project there is a library
that contains this code:

void memcpy(char* aa, char* bb, char* cc) {
    int i;
    for (i = 0; i < 100; ++i) {
        cc[i] = aa[i] + bb[i];
    }
}

If the previous snippet gets linked with this library, what happens? Would you expect it to still
return 5? Return something else? Crash? The answer is: it depends - the result can be either correct
or a segmentation fault. It depends on the order in which the objects and libraries in the project
were fed to the linker.

If you fully understand why this depends on linking order, as well as how to avoid the problem (and
more serious problems, like circular dependencies) then congratulate yourself and move on - this
article is probably not for you. Otherwise, read on.  

__________
The basics

Let's start by defining the scope of this article: first, my examples are demonstrating the use of
the gcc and binutils toolchain on Linux. Compatible toolchains (like clang instead of gcc) apply
too. Second, the discussion here resolves around [static-linking] that's done at compile/link time.

To understand [why-linking-order-matters], it's first instructional to understand how the linker
works with respect to linking libraries and objects together. Just as a quick reminder - an object
file both provides (exports) external symbols to other objects and libraries, and expects (imports)
symbols from other objects and libraries. For example, in this C code:

int imported(int);

static int internal(int x) {
    return x * 2;
}

int exported(int x) {
    return imported(x) * internal(x);
}

The names of the functions speak for themselves. Let's compile it and look at the symbol table:

$ gcc -c x.c
$ nm x.o
000000000000000e T exported
                 U imported
0000000000000000 t internal

This means: exported is an external symbol - defined in the object file and visible from the
outside. [imported-is-an-undefined-symbol]; in other words, the linker is expected to find it
elsewhere. When we talk about linking later, the term undefined can become confusing - so it helps
to remember that this is where it comes from originally. internal is defined within the object but
invisible from the outside.

Now, a library is simply a collection of object files. Just a bunch of object files glued together.
Creating a library is a very trivial operation that doesn't do anything special besides placing many
object files into the same file. This in itself is important, because a horde of object files is not
convenient to deal with. For example, on my system libc.a (the static version of the C library)
consists of almost 1500 object files. It's way nicer to just carry libc.a around.  

The linking process {gcc-link-algorithm}

This section defines the linking process in a somewhat dry, algorithmic manner. This process is the
key to understanding why linking order matters.

Consider a linker invocation:

$ gcc main.o -L/some/lib/dir -lfoo -lbar -lbaz

<caution>
The following do not work:
gcc -lfoo main.c

The linker is almost always invoked through [the-compiler-driver-gcc] when compiling C or C++ code.
This is because the driver knows how to provide the correct command-line arguments to the linker
itself (ld) with all the support libraries, etc. We'll see more of this later.

Anyhow, as you can see the object files and libraries are provided in a certain order on the
command-line, from left to right. This is [the-linking-order]. Here's what the linker does:

The linker maintains a [symbol-table]. This symbol table does a bunch of things, but among them is
keeping two lists:

1. A list of symbols exported by all the objects and libraries encountered so far.
2. A list of undefined symbols that the encountered objects and libraries requested to import and
were not found yet.

<for-object-file>

When the linker encounters a new object-file, it looks at:

1.The symbols it exports: these are added to the list of exported symbols mentioned above. If any
symbol is in the undefined list, it's removed from there because it has now been found. If any
symbol has already been in the exported list, we get a "multiple definition" error: two different
objects export the same symbol and the linker is confused.

2. The symbols it imports: these are added to the list of undefined symbols, unless they can be
found in the list of exported symbols.

<for-library>

When the linker encounters a new library, things are a bit more interesting. The linker goes over
all the objects in the library. For each one, it [first] looks at the symbols it exports.

1. If any of the symbols it exports are on the undefined list, the object is [added] to the link and
the next step is executed. Otherwise, the next step is skipped. [KT] this means that if not, this
object is not be added to the link. 

2. If the object has been added to the link, it's treated as described above - its undefined and
exported symbols get added to the symbol table. [KT] added to the link.

3. Finally, if any of the objects in the library has been included in the link, the library is
rescanned again - it's possible that symbols imported by the included object can be found in other
objects within the same library.

When the linker finishes, it looks at the symbol table. If any symbols remain in the undefined list,
the linker will throw an "undefined reference" error. For example, when you create an executable and
forget to include the file with the main function, you'll get something like:

/usr/lib/x86_64-linux-gnu/crt1.o: In function '_start':
(.text+0x20): undefined reference to 'main'
collect2: ld returned 1 exit status

Note that after the linker has looked at a library, it won't look at it again. Even if it exports
symbols that may be needed by some later library. The only time where a linker goes back to rescan
objects it has already seen, happens within a single library - as mentioned above, once an object
from some library is taken into the link, all other objects in the same library will be rescanned.
Flags passed to the linker can tweak this process - again, we'll see some examples later.

>
 Also note that when a library is examined, an object file within it can be left out of the link if
 it does not provide symbols that the symbol table needs. This is a very important feature of static
 linking. The C library I mentioned before makes a heavy use of this feature, by mostly splitting
 itself to an-object-per-function. So, for example if the only C standard library function your code
 <uses> is strlen, only strlen.o will be taken into the link from libc.a - and your executable will
 be very small.
<
_______________
Simple examples [KT] these examples works on ubuntu as they are shown.

The previous section can be hard to digest, so here are some simple examples that show the process
in action.

Let's start with the most basic case, of linking two objects together:

$ cat simplefunc.c
int func(int i) {
    return i + 21;
}

$ cat simplemain.c
int func(int);

int main(int argc, const char* argv[])
{
    return func(argc);
}

$ gcc -c simplefunc.c
$ gcc -c simplemain.c
$ gcc simplefunc.o simplemain.o
$ ./a.out ; echo $?
22

>
 Note that since these are object files, the linking order does not matter. Object files are always
 taken into the link. We can pass them to the linker in reversed order and it still works: 
<

$ gcc simplemain.o simplefunc.o
$ ./a.out ; echo $?
22

Now let's do something different. Let's put simplefunc.c into a library:

$ ar r libsimplefunc.a simplefunc.o [KT] or ar rs to skip ranlib command.
$ ranlib libsimplefunc.a
$ gcc  simplemain.o -L. -lsimplefunc
$ ./a.out ; echo $?
22

Works like a charm. But note what happens if the linking order is reversed now:

$ gcc  -L. -lsimplefunc  simplemain.o
simplemain.o: In function 'main':
simplemain.c:(.text+0x15): undefined reference to 'func'
collect2: ld returned 1 exit status

Understanding the linking algorithm outlined above makes this case simple to explain. When the
linker encounters libsimplefunc.a, it still hasn't seen simplemain.o, which means that func is not
yet on the undefined list. When the linker looks into the library it sees simplefunc.o that exports
func. But since it doesn't need func, this object file is [not] included in the link. When the
linker does reach simplemain.o and sees that func is, indeed required, it's added to the undefined
list (because it's not on the exported list). The linker then reaches the end of the link and func
is still undefined.

Note how this doesn't happen in the previous linking order - since simplemain.o comes first, func is
on the undefined list before the linker sees the library, so the object file exporting it does get
included.

This brings us to the most important corollary of the linking process outlined above:

If object or library AA needs a symbol from library BB, then AA should come before library BB in the
command-line invocation of the linker. [KT] slightly not correct.

___________________
Circular dependency {cyclic-dependencies}

The corollary above is an important summary of the linking process - it's certainly much more
practical to keep in mind because it's so short. But it makes one wonder - what happens if AA needs
a symbol from BB, but BB also needs a symbol from AA? While officially this isn't a good programming
practice, in reality it happens quite a lot. But AA can't come both before and after BB on the
command-line, right? That's just silly. Wait, is it, really?

Let's see an example and start simple. Imagine that instead of simplefunc.c, the func symbol is
provided thus:

$ cat func_dep.c
int bar(int);

int func(int i) {
    return bar(i + 1);
}

$ cat bar_dep.c
int func(int);

int bar(int i) {
    if (i > 3)
        return i;
    else
        return func(i);
}

These two files depend on each other and get placed into different libraries. If we link them in one
order, we fail:

$ gcc  simplemain.o -L.  -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

However, the other order does work:

$ gcc  simplemain.o -L. -lfunc_dep -lbar_dep
$ ./a.out ; echo $?
4

Quiz: can you figure out why? Hint: just go over the linking process algorithm with this
command-line. What undefined symbols does the symbol table contain when the linker first sees
-lfunc_dep?

<analysis-on-okay-case>

simplemain:
			U func

symbol table: undefined: func

func_dep.a:
         U bar  (import)
00000000 T func (export)

okay, add func to the link.

bar_dep.a:
00000000 T bar  (export)
         U func (import)

The symbol table has func and bar.

<analysis-on-not-okay-case>

simplemain:
			U func

symbol table: undefined: func

bar_dep.a:
00000000 T bar  (export)
         U func (import)

Here, bar is not added to the link.

func_dep.a:
         U bar
00000000 T func (undefined reference to 'bar')

The symbol table has func but not bar. Hence, error.

But this is a very simple case. Let's look at a trickier one. We'll add a dependency to bar on
another function from libfunc_dep.a, but one that lives in a different object:

$ cat bar_dep.c
int func(int);
int frodo(int);

int bar(int i) {
    if (i > 3)
        return frodo(i);
    else
        return func(i);
}

$ cat frodo_dep.c
int frodo(int i) {
    return 6 * i;
}

We'll recompile all these files into separate objects, and the libfunc_dep.a library will now be:

$ ar r libfunc_dep.a func_dep.o frodo_dep.o
$ ranlib libfunc_dep.a

Here's a drawing of the libraries, with arrows showing the dependencies:

simplemain:
			U func

 libfunc_dep.a        libbar_dep.a
  - func_dep.o  ->  <- - bar_dep.o (need func and frodo)
  - frodo_dep.o     <-

Now linking fails no matter what order we list the libraries in:

U func; func and bar; bar and frodo

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep
./libbar_dep.a(bar_dep.o): In function 'bar':
bar_dep.c:(.text+0x17): undefined reference to 'frodo'
collect2: ld returned 1 exit status

U func; nothing for bar_dep; func and bar

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep
./libfunc_dep.a(func_dep.o): In function 'func':
func_dep.c:(.text+0x14): undefined reference to 'bar'
collect2: ld returned 1 exit status

To solve this, consider that it's perfectly valid to list a library more than once on the link; so
in fact, we can provide libfunc_dep.a both before and after libbar_dep.a:

$ gcc  -L. simplemain.o -lfunc_dep -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Another quiz: will the same trick work providing -lbar_dep twice? Why not?

$ gcc  -L. simplemain.o -lbar_dep -lfunc_dep -lbar_dep

U func; nothing for bar_dep; func and bar(U); bar

./libbar.a(bar_dep.o): In function `bar':
bar_dep.c:(.text+0x13): undefined reference to `frodo'
collect2: ld returned 1 exit status

Becase frodo is in the libaray but was not added to the link because of object-per-function-linking.

_________________________________________
Using linker flags to control the process

As I've mentioned above, the linker has a number of interesting flags that can be used to control
the process in a fine-grained manner. For example, circular dependency problems can be easily
resolved with --start-group and --end-group. Here's an instructive portion from man ld:

-start-group archives -end-group

The specified archives are searched repeatedly until no new undefined references are created.
Normally, an archive is searched only once in the order that it is specified on the command line. If
a symbol in that archive is needed to resolve an undefined symbol referred to by an object in an
archive that appears later on the command line, the linker would not be able to resolve that
reference. By grouping the archives, they all be searched repeatedly until all possible references
are resolved.

Using this option has a significant performance cost. It is best to use it only when there are
unavoidable circular references between two or more archives.

Here's how this helps in our case:

$ gcc simplemain.o -L. -Wl,--start-group -lbar_dep -lfunc_dep -Wl,--end-group
$ ./a.out ; echo $?
24

It's interesting to note the "significant performance cost" warning in the excerpt above. This
explains why the linking process is the way it is. Presumably, linkers could just re-scan the whole
library list until no new symbols got resolved. This would eliminate most circular-dependency and
linking order problems in the world, but it would also be slow. Linking is already a critical part
of the compilation time of large systems, since it looks at the whole program and requires quite a
bit of memory. It's better to make it as fast as possible for well-behaved programs (that got their
linking order right), and provide special options like groups for the difficult circular dependency
cases. [KT] This is only about cost in linking?

There's at least one another linker flag that can help us resolve the circular dependency here. We
can use the --undefined flag to tell the linker - "buddy, here's a symbol I want you to add to the
undefined list". In our case this makes the link error go away even though the libraries are
specified only once:

$ gcc simplemain.o -L. -Wl,--undefined=bar -lbar_dep -lfunc_dep
$ ./a.out ; echo $?
24

Figuring out why this works is left as an exercise to the reader.

____________________________
Back to the original example

Let's go back to the example this article started with. main assumes it gets the correct memcpy from
the C library, but the memcpy it gets linked with does something else. Assuming the memcpy here was
packed into the libstray_memcpy.a library:

$ gcc  -L. main_using_memcpy.o -lstray_memcpy
$ ./a.out
Segmentation fault (core dumped)

This is the expected behavior. Since -lstray_memcpy was provided after main_using_memcpy.o on the
command-line, it gets linked in. But what happens if the order is reversed:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o
$ ./a.out ; echo $?
5

The program links and works correctly. The reason for this is simple: even without us explicitly
asking for it, gcc asks the linker to link the C library as well. The full linker invocation command
of gcc is pretty complex, and can be examined by passing the -### flag to gcc. But in our case this
amounts to:

$ gcc  -L. -lstray_memcpy main_using_memcpy.o -lc

When the linker sees -lstray_memcpy, the symbol table does not yet have an undefined entry for
memcpy, so the object file with the wrong function does not get linked. The linker adds this
undefined entry only after it sees main_using_memcpy.o. Then, when it reaches -lc, the object file
holding memcpy from the C library does get linked in because by now memcpy is on the undefined list.

__________
Conclusion

The algorithm used by the linker to resolve symbols between objects and libraries is pretty simple.
As long as you keep it in mind, linker errors and related problems should be easy to understand. If
you still run into problematic situations you're not sure how to resolve, this article mentioned two
tools that can be very useful in debugging such problems: one is nm, which shows the symbol table of
an object or a whole library. The other is the -### flag that gcc accepts and as a result shows the
full commands it passes to the underlying tools.

 [KT] When use this option, it appears that linker cannot detect duplicated symbols and use one of
 symbols. There are duplicated in the same lib archive but picked up wrong one. 


{gcc-link-search-path}

-Lsearchdir 
--library-path=searchdir 

Add path searchdir to the list of paths that ld will search for archive libraries and ld control
scripts. You may use this option any number of times. The directories are searched in the order in
which they are specified on the command line. Directories specified on the command line are searched
before the default directories. All -L options apply to all -l options, regardless of the order in
which the options appear.  If searchdir begins with =, then the = will be replaced by the sysroot
prefix, a path specified when the linker is configured.  The default set of paths searched (without
being specified with `-L') depends on which emulation mode ld is using, and in some cases also on
how it was configured. See Environment.  The paths can also be specified in a link script with the
SEARCH_DIR command. Directories specified this way are searched at the point in which the linker
script appears in the command line. 

{gcc-link-option}

http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options
https://sourceware.org/binutils/docs/ld/Options.html

-Wl,option

Pass option as an option to the linker. If option contains commas, it is split into multiple options
at the commas. You can use this syntax to pass an argument to the option. For example,
-Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also
get the same effect with -Wl,-Map=output.map. 

-nostdlib

Do not use the standard system startup files or libraries when linking. No startup files and only
the libraries you specify are passed to the linker, and options specifying linkage of the system
libraries, such as -static-libgcc or -shared-libgcc, are ignored.

The compiler may generate calls to memcmp, memset, memcpy and memmove. These entries are usually
resolved by entries in libc. These entry points should be supplied through some other mechanism when
this option is specified.

One of the standard libraries bypassed by -nostdlib and -nodefaultlibs is libgcc.a, a library of
internal subroutines which GCC uses to overcome shortcomings of particular machines, or special
needs for some languages. (See Interfacing to GCC Output, for more discussion of libgcc.a.) In most
cases, you need libgcc.a even when you want to avoid other standard libraries. In other words, when
you specify -nostdlib or -nodefaultlibs you should usually specify -lgcc as well. This ensures that
you have no unresolved references to internal GCC library subroutines. (An example of such an
internal subroutine is '__main', used to ensure C++ constructors are called; see collect2.) 


={============================================================================
*kt_dev_gcc_104*	gcc: C90 and C99

Preface

This is a reference manual for the C programming language as implemented by the GNU Compiler
Collection (GCC). Specifically, this manual aims to document:

The 1989 ANSI C standard, commonly known as C89/C90

The 1999 ISO C standard, commonly known as C99, ISO/IEC 9899:1999, to the extent that C99 is
implemented by GCC

The current state of GNU extensions to standard C 

This manual describes C89 as its baseline. C99 features and GNU extensions are explicitly labeled as
such.

By default, GCC will compile code as C89 plus GNU-specific extensions. Much of C99 is supported;
once full support is available, the default compilation dialect will be C99 plus GNU-specific
extensions. (Some of the GNU extensions to C89 ended up, sometimes slightly modified, as standard
language features in C99.)

The C language includes a set of preprocessor directives, which are used for things such as macro
text replacement, conditional compilation, and file inclusion. Although normally described in a C
language manual, the GNU C preprocessor has been thoroughly documented in The C Preprocessor, a
separate manual which covers preprocessing for C, C++, and Objective-C programs, so it is not
included here. 


{C90-C99}
After ANSI produced the official standard for the C programming language in 1989, which became an
international standard in 1990, the C language specification remained relatively static for some
time, while C++ continued to evolve, largely during its own standardization effort. Normative
Amendment 1 created a new standard for C in 1995, but only to correct some details of the 1989
standard and to add more extensive support for international character sets. The standard underwent
further revision in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in 1999, which
was adopted as an ANSI standard in May 2000. The language defined by that version of the standard is
commonly referred to as "C99". 

<for-example>
for(int i = 0; i < 0; i++)
   ;

sam01.c:153:3: error: ‘for’ loop initial declarations are only allowed in C99 mode
sam01.c:153:3: note: use option -std=c99 or -std=gnu99 to compile your code

<for-C99>
The following causes error:
usecomma.cpp:70:42: error: invalid conversion from 'Node* {aka node*}' to 'int' [-fpermissive]
usecomma.cpp:72:22: error: base operand of '->' is not a pointer

{
   // search the end using count
70:   for( int current = 1, pend = list->header; current < list->count; current++)
72:      pend = pend->pnext;
}

{
   // search the end using count
   pend = list->header;
   for( int current = 1; current < list->count; current++)
      pend = pend->pnext;

   or

   // search the end using count
   int current;
   for( current = 1, pend = list->header; current < list->count; current++) 
      pend = pend->pnext;
}

Why? Because cannot define different types in the init part of for. See declaration.

From ISO/IEC 9899-1999

6.8.5 Iteration statements
Syntax

for ( expression opt ; expression opt ; expression opt) statement
for ( declaration expression opt ; expression opt) statement

> [KT] This is why the var declared in a for has a scope
 5 An iteration statement is a block whose scope is a strict subset of the scope of its enclosing
 block. The loop body is also a block whose scope is a strict subset of the scope of the iteration
 statement. 
<

Now the 'block wrapped around the loop' comes into its own; it explains why the variable i cannot be
accessed outside the loop. You can declare more than one variable, but they must all be of [the-same
-type]:

for (int i = 0, j = sizeof(something); i < j; i++, j--) { ... }


={============================================================================
*kt_dev_gcc_105*	gcc likely and unlikely 

{likey-and-unlikely}
This is built-in function: long __builtin_expect (long exp, long c)

You may use __builtin_expect to provide the compiler with branch prediction information. In general,
you should prefer to use actual profile feedback for this (-fprofile-arcs), as programmers are
notoriously bad at predicting how their programs actually perform. However, there are applications
in which this data is hard to collect.


{reading-two}
http://blog.man7.org/2012/10/how-much-do-builtinexpect-likely-and.html
As the gcc documentation says, you can use this compiler built-in function to give the optimizer a
clue about the likely result of an integer (or Boolean) expression. In the context of an if
statement, this enables the optimizer to reorder the code in a way that gives best performance, by
ensuring that the code that is most likely to execute after the conditional immediately follows the
conditional when the instruction stream is fed to the CPU pipeline.

The __builtin_expect() function takes two arguments: a value to be tested, and the expected result.
Both of these are integral values. The interface is a little clumsy for most uses, since the common
case is that we want to test for "true" (non-zero) or "false" (zero). Thus, the Linux kernel defines
two simpler interfaces: likely() and unlikely() (in include/linux/compiler.h):

    #define likely(x)      __builtin_expect(!!(x), 1)
    #define unlikely(x)    __builtin_expect(!!(x), 0)

In other words, likely(x) means "I expect x is true", and and unlikely(x) means "I expect x is
false".

Here's my test program. The comments should be enough to help you understand some of the more
obscure pieces. Below, I'll just skip to looking at the test results.

The program essentially repeatedly scans a one-million-element integer array whose contents are zero
(in the default case). Using the program, we can time the results of the checks that are performed
either with or without using __builtin_expect().

For example, here we scan the array without  __builtin_expect():

    $ cc -DDONT_EXPECT -O3 builtin_expect_test.c -o bn
    $ time -f "%E real, %U user, %S sys" ./bn 1000
    0, 1000000000
    0:02.68 real,  2.67 user, 0.00 sys

In this case, the program looped one thousand times through the array, to perform a total of one
billion checks, and the real time for execution was 2.68 seconds. (The test machine is an Intel Core
Duo 2.53GHz, and the gcc version is 4.6.3.)

Here's what happens if we employ  __builtin_expect(), telling the compiler that the expected result
of the test is 0.

    [KT] expects 0 and best case
    $ cc -DEXPECT_RESULT=0 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    0, 1000000000
    0:02.28 real,  2.28 user, 0.00 sys

The execution time fell to 2.28 seconds. In other words (for this particular CPU, compiler version,
and program), __builtin_expect() improved the execution time of each check by 0.4 nanoseconds (0.4
seconds for one billion checks).

Well and good. What if we tell __builtin_expect() to expect the wrong value?

    [KT] expects 1 when all elements are 0 so worst case
    $ cc -DEXPECT_RESULT=1 -O3 builtin_expect_test.c -o b1
    $ time -f "%E real, %U user, %S sys" ./b1 1000
    0, 1000000000
    0:04.19 real,  4.18 user, 0.00 sys

In this case, unsurprisingly, we made each check run slower, by about 1.5 (i.e., 4.19 - 2.68)
nanoseconds. So, should you use __builtin_expect()?  

You should only use __builtin_expect()-or the Linux kernel's likely() and unlikely()-if it's "very
likely" that your code will follow the predicted branch. How much is "very likely"? If you're
looking for actual numbers, the answer will depend on your compiler version, CPU, and code. But to
illustrate that you should generally [avoid] these optimizations unless your code is very likely to
follow one branch, here's some further tests using the above code.

In this test, the program first injects some nonzero values into the array before doing tests for
zero using __builtin_expect(). Nonzero values are placed at every tenth element in the array:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000000, 900000000
    0:02.79 real,  2.76 user, 0.01 sys

Note what happened. Even though most array elements contained the expected zero value, execution
speed was actually worse (2.79 seconds versus 2.69 seconds) than not using __builtin_expect() at
all! In fact, even when only one in ten thousand values is nonzero, we're still at only roughly the
break-even point:

    $ cc -DEXPECT_RESULT=0 -DBREAK_STEP=10000 -O3 builtin_expect_test.c -o b0
    $ time -f "%E real, %U user, %S sys" ./b0 1000
    100000, 999900000
    0:02.66 real,  2.64 user, 0.00 sys

The point where using these optimizations becomes worthwhile will depend on the factors mention
above, but the point is that you should really only use them when your predicted path is very
likely, and if your predicted path is not very likely, then you're better off avoiding them, as
you'll actually slow your code down a little. Compiler-assisted run-time profiling The gcc
documentation contains the following advice regarding the use of __builtin_expect():

    In general, you should prefer to use actual profile feedback for this (-fprofile-arcs), as
    programmers are notoriously bad at predicting how their programs actually perform. However,
    there are applications in which this data is hard to collect. 

That's good concise advice. To put things another way, the only time you should use
__builtin_expect() is when you can't use compiler-assisted runtime optimization (perhaps because
your program has no easily repeatable pattern of execution-the Linux kernel is an obvious example)
and you are certain that your predicted code path is very (very) likely to be the one that will be
taken.


{reading-one}
This is about branch-prediction and optimisation in a compiler. 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "else" block is more probable by saying that x is more likely to be
  // false(0)
  if(__builtin_expect(x, 0)) 
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
 
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
 
abc.o:     file format elf32-i386
 
Disassembly of section .text:
 
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   75 07                   jne    11 < testfun+0x11 >
   The compiler branches the "if" block and keeps "else" sequential
   a:   b8 06 00 00 00          mov    $0x6,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 19 00 00 00          mov    $0x19,%eax
  16:   eb f7                   jmp    f < testfun+0xf > 

[kedar@ashwamedha ~]$ cat abc.c
int testfun(int x)
{
  // we instruct the compiler, "if" block is more probable by saying that x is more likely to be
  // true(1), non-zero.
  if(__builtin_expect(x, 1))
  {
    x = 5;
    x = x * x;
  }
  else
  {
    x = 6;
  }

  return x;
}
                                                                                                   
[kedar@ashwamedha ~]$ gcc -O2 -c abc.c
[kedar@ashwamedha ~]$ objdump  -d abc.o
                                                                                                   
abc.o:     file format elf32-i386
                                                                                                   
Disassembly of section .text:
                                                                                                   
00000000 :
   0:   55                      push   %ebp
   1:   89 e5                   mov    %esp,%ebp
   3:   8b 45 08                mov    0x8(%ebp),%eax
   6:   85 c0                   test   %eax,%eax
   8:   74 07                   je     11 < testfun+0x11 >
   The compiler branches the "else" block and keeps "if" sequential
   a:   b8 19 00 00 00          mov    $0x19,%eax
   f:   c9                      leave
  10:   c3                      ret
  11:   b8 06 00 00 00          mov    $0x6,%eax
  16:   eb f7                   jmp    f < testfun+0xf >
<

 [KT] As shown, the probable cases are placed in sequencial and menas in the pipe line. So most of
 case there is no jump.

{example-from-glibc}

#if __GNUC__ >= 3
# define __glibc_unlikely(cond)	__builtin_expect ((cond), 0)
# define __glibc_likely(cond)	__builtin_expect ((cond), 1)
#else
# define __glibc_unlikely(cond)	(cond)
# define __glibc_likely(cond)	(cond)
#endif

  if (__glibc_unlikely (*s == L_('\0')))
    goto noconv;


={============================================================================
*kt_dev_gcc_200*	gcc: cpp: preprocessor

http://gcc.gnu.org/onlinedocs/cpp/
/usr/bin/cpp

The C preprocessor, often known as cpp, is a "macro processor" that is used automatically by the C
compiler to transform your program before compilation. It is called a macro processor because it
allows you to define 'macros', which are brief abbreviations for longer constructs. 

{preprocessor-options}
http://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html

-E

If you use the -E option, nothing is done except preprocessing. Some of these options make sense
only together with -E because they cause the preprocessor output to be unsuitable for actual
compilation. 

g++ -std=c++0x -E useargs.cpp > out.txt

<save-temp-option>
To produce three extra files with .i, .s and .o extension. The temporary files produced by
-save-temps flag in one go can be produced one by one by using the gcc flags -E, -C and -S at each
of the preprocessing, compilation and assembly steps respectively.


-Wall

Turns on all optional warnings which are desirable for normal code. At present this is -Wcomment,
-Wtrigraphs, -Wmultichar and a warning about integer promotion causing a change of sign in #if
expressions. Note that many of the preprocessor's warnings are on by default and have no options to
control them. 

<to-get-header-lists>
-M
Instead of outputting the result of preprocessing, output a rule suitable for make describing the
dependencies of the main source file. The preprocessor outputs one make rule containing the object
file name for that source file, a colon, and the names of all the included files, including those
coming from -include or -imacros command line options. 


={============================================================================
*kt_dev_gcc_201*	gcc: cpp: define? 

Q: What's the difference between "define _LIMITS_H" and "define _LIMITS_H 1"?

# ifndef _LIMITS_H
#  define _LIMITS_H	1
...
# endif	/* limits.h  */

2.4 Once-Only Headers

If a header file happens to be included twice, the compiler will process its contents twice. This is
very likely to cause an error, e.g. when the compiler sees the same structure definition twice. Even
if it does not, it will certainly waste time.

The standard way to prevent this is to enclose the entire real contents of the file in a
conditional, like this:

     /* File foo.  */
     #ifndef FILE_FOO_SEEN
     #define FILE_FOO_SEEN
     
     the entire file
     
     #endif /* !FILE_FOO_SEEN */

This construct is commonly known as a "wrapper #ifndef". When the header is included again, the
conditional will be false, because FILE_FOO_SEEN is defined. The preprocessor will skip over the
entire contents of the file, and the compiler will not see it twice.

CPP optimizes even further. It remembers when a header file has a wrapper ‘#ifndef’. If a subsequent
‘#include’ specifies that header, and the macro in the ‘#ifndef’ is still defined, it does not
bother to rescan the file at all.

You can put comments outside the wrapper. They will not interfere with this optimization.

The macro FILE_FOO_SEEN is called the controlling macro or "guard macro". In a user header file, the
macro name should 'not' begin with '_'. In a system header file, it 'should' begin with '__' to
avoid conflicts with user programs. In any kind of header file, the macro name should contain the
name of the file and some additional text, to avoid conflicts with other header files.  

Q: Is it a problem to use '_' for user headers?

-D name 
Predefine name as a macro, with definition 1. 

-D name=definition
The contents of definition are tokenized and processed as if they appeared during translation phase
three in a '#define' directive. In particular, the definition will be truncated by embedded newline
characters.

If you are invoking the preprocessor from a shell or shell-like program you may need to use the
shell's quoting syntax to protect characters such as spaces that have a meaning in the shell syntax.

If you wish to define a function-like macro on the command line, write its argument list with
surrounding parentheses before the equals sign (if any). Parentheses are meaningful to most shells,
so you will need to quote the option. With sh and csh, -D'name(args...)=definition' works.

-D and -U options are processed in the order they are given on the command line. All -imacros file
and -include file options are processed after all -D and -U options. 

4.2.3 Defined

The special operator defined is used in '#if' and '#elif' expressions to test whether a certain name
is defined as a macro. "defined name" and "defined (name)" are both expressions whose value is <1>
if name is defined as a macro at the current point in the program, and 0 otherwise. Thus, #if
defined MACRO is precisely equivalent to #ifdef MACRO.

defined is useful when you wish to test more than one macro for existence at once. For example,

     #if defined (__vax__) || defined (__ns16000__)

would succeed if either of the names __vax__ or __ns16000__ is defined as a macro.

Conditionals written like this:

     #if defined BUFSIZE && BUFSIZE >= 1024

can generally be simplified to just #if BUFSIZE >= 1024, since if BUFSIZE is not defined, it will be
interpreted as having the value zero.

If the defined operator appears as a result of a macro expansion, the C standard says the behavior
is undefined. GNU cpp treats it as a genuine defined operator and evaluates it normally. It will
warn wherever your code uses this feature if you use the command-line option -pedantic, since other
compilers may handle it differently. 

<example>
#define SAMPLE
#define SAMPLE 1
#define SAMPLE 2

// This works for all three cases
#ifdef SAMPLE
  printf("sample is def\n");
#endif

// For 1, emit error like: 
// sam01.c:39:12: error: operator '>' has no left operand
// Only works for 2 case.
#if SAMPLE == 1
  printf("sample is =1\n");
#endif

// For 1, emit error like: 
// sam01.c:39:12: error: operator '>' has no left operand
// Only works for 3 case.
#if SAMPLE > 1
  printf("sample is >1 \n");
#endif

After all, "define MACRO x" is to use macro value and no real needs as a guard macro.


={============================================================================
*kt_dev_gcc_202*	gcc: cpp: how-to-get-filename-without-full-path

http://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros

The standard predefined macros are specified by the relevant language standards, so they are
available with all compilers that implement those standards. Older compilers may not provide all of
them. Their names all start with double underscores.

__cplusplus

This macro is defined when the C++ compiler is in use. You can use __cplusplus to test whether a
header is compiled by a C compiler or a C++ compiler. This macro is similar to __STDC_VERSION__, in
that it expands to a version number. Depending on the language standard selected, the value of the
macro is 199711L, as mandated by the 1998 C++ standard; 201103L, per the 2011 C++ standard; an
unspecified value strictly larger than 201103L for the experimental languages enabled by -std=c++1y
and -std=gnu++1y. 

__FILE__

This macro expands to the name of the current input file, in the form of a C string constant. This
is the path by which the preprocessor opened the file, not the short name specified in '#include' or
as the input file name argument. For example, "/usr/local/include/myheader.h" is a possible
expansion of this macro. [KT] For c files, this is a path from where run gcc to build.

<how-to-get-filename-without-full-path>

char *strrchr(const char *s, int c);
The strrchr() function returns a pointer to the last occurrence of the character c in the string s.

#include <string.h>
#define FILE (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

int main()
{
   printf("file is %s\n", __FILE__);
   printf("file is %s:%d:%s\n", FILE, __LINE__, __PRETTY_FUNCTION__ );
}

__LINE__

This macro expands to the current input line number, in the form of a decimal integer constant.
While we call it a predefined macro, it's a pretty strange macro, since its "definition" changes
with each new line of source code. 

__FILE__ and __LINE__ are useful in generating an error message to report an inconsistency detected
by the program; the message can state the source line at which the inconsistency was detected. For
example,

     fprintf (stderr, "Internal error: "
                      "negative string length "
                      "%d at %s, line %d.",
              length, __FILE__, __LINE__);

An '#include' directive changes the expansions of __FILE__ and __LINE__ to correspond to the
included file. At the end of that file, when processing resumes on the input file that contained the
'#include' directive, the expansions of __FILE__ and __LINE__ revert to the values they had before
the '#include' (but __LINE__ is then incremented by one as processing moves to the line after the
'#include').

A '#line' directive changes __LINE__, and may change __FILE__ as well. See Line Control.

__func__ and __FUNCTION__ 

C99 introduces __func__, and GCC has provided __FUNCTION__ for a long time. Both of these are
strings containing the name of the current function (there are slight semantic differences; see the
GCC manual). Neither of them is a macro; the preprocessor does not know the name of the current
function. They tend to be useful in conjunction with __FILE__ and __LINE__, though. 

__PRETTY_FUNCTION__

http://gcc.gnu.org/onlinedocs/gcc/Function-Names.html

GCC provides three magic variables that hold the name of the current function, as a string. The
first of these is __func__, which is part of the C99 standard:

The identifier __func__ is implicitly declared by the translator as if, immediately following the
opening brace of each function definition, the declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing function. This name is the
unadorned name of the function.

__FUNCTION__ is another name for __func__. Older versions of GCC recognize only this name. However,
it is not standardized. For maximum portability, we recommend you use __func__, but provide a
fallback definition with the preprocessor:

     #if __STDC_VERSION__ < 199901L
     # if __GNUC__ >= 2
     #  define __func__ __FUNCTION__
     # else
     #  define __func__ "<unknown>"
     # endif
     #endif

In C, __PRETTY_FUNCTION__ is yet another name for __func__. 

>
 However, in C++, __PRETTY_FUNCTION__ contains the type signature of the function as well as its bare
 name. For example, this program:
<
     extern "C" {
     extern int printf (char *, ...);
     }
     
     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };
     
     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)  // [KT] seems useful

These identifiers are not preprocessor macros. In GCC 3.3 and earlier, in C only, __FUNCTION__ and
__PRETTY_FUNCTION__ were treated as string literals; they could be used to initialize char arrays,
and they could be concatenated with other string literals. GCC 3.4 and later treat them as
variables, like __func__. In C++, __FUNCTION__ and __PRETTY_FUNCTION__ have always been variables. 


={============================================================================
*kt_dev_gcc_300*	gcc gprof

http://sourceware.org/binutils/docs/gprof/


# ============================================================================
#{ C AND C++
={============================================================================
*kt_dev_lang_001*	global, file and local static

{local-static} {global-static} 
Global vars has a program scope, global static has a file scope <file-static>, and local static has a
func scope <function-static>. file-static is from C and should use <unnamed-namespace> in C++. 

local-static == function-static. global-static == file-static.

void foo () {   
  static int x = 0;
  ++x;
  cout << x << endl;
}

int main (int argc, char const *argv[]) {
  foo();  // 1
  foo();  // 2
  foo();  // 3
  return 0;
}

The differences are:

The name is only accessible within the function, and has no linkage.(?) It is initialised the first
time execution reaches the definition, not necessarily during the program's initialisation phases.

<static-and-race-condition>
From C++ concurrency in action, p62, the initialization of function static is defined to occur the
first time control passes through its declaration; for multiple threads calling the function, this
means there's the potential for a race condition to define first. On many pre-C++11 compilers this
race condition is problematic in practice because multiple threads may believe they're first and try
to initialize the variable, or threads may try to use it after initialization has started on another
thread but before it's finished. In C++11 this problem is solved: the initialization is defined to
happen on exactly one thread.

<file-static-mean>
This applies to a function so if define static function, it has file-scope. 

// file one
#include < iostream>

static int gfs_count;
// extern static int gfs_count; 
// this causes an compile error: conflicting specifiers in declaration of 'gfs_count'

void print_gfs()
{
  std::cout << "{ "; 

  for(int idx = 0; idx < 5; idx++)
    gfs_count++;

  std::cout << gfs_count << std::endl;

  std::cout << "}" << std::endl; 
}

// file two
#include < iostream>

extern int gfs_count;
extern void print_gfs();

int main()
{
  std::cout << "{ "; 

  std::cout << gfs_count << std::endl;	// if remove this, no link error
  print_gfs();

  std::cout << "}" << std::endl; 
}

No error in building and in using a function in file one but failed to link in file two:

kit@kit-vb:~/work$ make
echo '>> build use-main.cpp'
>> build use-main.cpp
g++ -std=c++0x -o main.o -c use-main.cpp
echo '>> build file-static.cpp'
>> build file-static.cpp
g++ -std=c++0x -o file.o -c file-static.cpp
echo '>> bulid main'
>> bulid main
g++ -std=c++0x -o out main.o file.o
main.o: In function `main':
use-main.cpp:(.text+0x1e): undefined reference to `gfs_count'
collect2: ld returned 1 exit status
make: *** [main] Error 1


{init-order-problem}
The second difference can be useful to avoid the intialisation order fiasco, where global variables
can be accessed before they are initialised. Here, global varaiables means global and file static
but not local static. By replacing the global variable with a function that returns a reference to a
local static variable, you can guarantee that it is initialised before anything accesses it. This is
only true for single-threaded. This init-order-problem is the race-condition on global variables.

# file A
class FileSystem {
  public:
    ...
      std::size_t numDisk() const;
    ...
};

extern FileSystem tfs;

# file B
class Directory {
  Directory()
  {
    std::size_t = tfs.numDisk();
    ...
  }
  ..
};

Directory tempDir( params );

How can you be sure that tfs will be initialised before tempDir? Use <function-static>. See
*kt_dev_lang_001* for terms. EC++04 said it is common implementation of <singleton-pattern>

# file A
class FileSystem {
	 ...
};

# extern FileSystem tfs;
FileSystem& tfs()
{ >
  static FileSystem fs; return fs;
}

# file B
class Directory {
	 ... use tfs
};

# Directory tempDir( params );
Directory& tempDir()
{ >
  static Directory td(tempDir); return td;
}


{singleton-pattern}
<why-singleton>
From design pattern. Using global/static objects have two problems:

o Do not keep you from instantiating multiple objects of the same type(class). Not about the name.
class X one_instance; class X two_instance.  
o init-order-problem. 

Good things over global by making a class itself responsible for keeping track of its sole instance:

o instance control such as only one instance
o single point of controlled access. there is no such a thing for global objects.
o no creation if it is not called. See {limit-the-number-of-object}. In the following example, no
create unless a user call instance() but global do not.

<common-implementation>
class Singleton {
  public:
    'static' Singleton* Instance();    // single-point-of-access

  'protected':                         // to-make-sure-one-instance
      Singleton() {};                  // there should be an implementation. otherwise, undefined err

  private:
    'static' Singleton* _instance;     // can have different concrete classes
};

Singleton* Singleton::_Instance = 0;

<no-preventing-copies>
No preventing-copies for singleton. Why? Because there is no object creation. See
{preventing-copies} for more.

<lazy-initialisation> 
Means that do not create instance until its first access.

Singleton* Singleton::Instance() {
  if(_instance==0) {
    _instance = new Singleton;
  }
  return _instance;
}

<singleton-and-factory-func>
The singleton is similar to factory-func in that it has a single point to create hence static func.
However, the focus is different. The singleton is to create a single instance and the factory is to
choose what to create. 

Like to have singleton feature and flexibility to choose what to create? Here are ways:

// <first-way>

There are many ways to specify a derived class to create. See {interface-class}. The other way in
design pattern, use <registry> to find a class to create which is more flexible because it is open
to possible singleton class meaning no Instance() change when there are new sigleton class and to
set it at run-time.

class Singleton {
  public:
    'static' void Register( char* name, Singleton* );
    'static' Singleton* Instance();

  protected:
    'static' Singleton* Lookup( const char* name );

  private:
    'static' Singleton* _instance;
    'static' List< NameStingletonPair >* _registry;
};

Singleton* Singleton::Instance() 
{
  if(_instance==0) {

    const char* singletonName = getenv("SINGLETON");
    _instance = Lookup(singletonName);
  }
  return _instance;
}

// to register
MySingleton::MySingleton() 
{
  ...
    Singleton::Register( "MYSINGLETON", this );
}

// create and used file static since no protected ctor but how about parent class?
static MySingleton mySingleton;
static XXSingleton XXSingleton;

theSingleton.Instance(); 	// ? since it is staic function

The cons of this is that all possible singleton classes must be created before register since must
build a list to look up beforehand. Here single instance for a selcted class and can think a set of
single instance for each class. How about multiple instance of a class? 


// <second-way> from design pattern.

class MazeFactory {
  public:
    static MazeFactory* Instance();
    ... public interfaces ...

  protected:
      MazeFactory();

  private:
      static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    _instance = new MazeFactory;
  }

  return _instance;
}

To create different classes:

MazeFactory* MazeFactory::Instance () {
  if( _instance == 0 ) {
    const char* mazeStyle = getenv("MAZESTYLE");

    if( strcmp( mazeStyle, "bombed" ) == 0 ) {
      _instance = new BombedMazeFactory;
    }
    else if( strcmp( mazeStyle, "ehchanted" ) == 0 ) {
      _instance = new EnchantedMazeFactory;

      // other possible subclasses which means this should be modified whenever there are new
      // subclasses.

    } else { // default
      _instance = new MazeFactory;
    }
  }

  return _instance;
}

* [KT] How about this? NOT OK because there must be an instance to call Instance() but ctor is
protected. So MUST use <class-method>, staic-member-func, for singleton-pattern.

class MazeFactory {
	 public:
	 	'virtual' MazeFactory* Instance(); 
		... public interfaces ...

	 protected:
	 	MazeFactory();

	 private:
	 	static MazeFactory* _instance;
};

MazeFactory* MazeFactory::_instance = 0;

BombedMazeFactory* BombedMazeFactory::Instance () {
	 if( _instance == 0 ) {
		  _instance = new BombedMazeFactory;
	 }

	 return _instance;
}


{limit-the-number-of-object}
MEC++26. This is example of <function-static>

class PrintJob;

class Printer {
	public:
	 	void reset();
		...

		friend Printer& thePrinter(); # why need this? because need to call ctor.

	private:        # <ban-to-create-directly>
		Printer();
		Printer( const Printer& rhs );
		...
};

Printer& thePrinter()
{
	 static Printer p; 
	 return p;
}

Use:

thePrinter().reset();

The other approach is to make it static member and then it make use a bit wordier:

Printer::thePrinter().reset();

Recommend <funciton-static> over class-variable because:

o no creation if no func call. An object that is static in a class is, for all intents and purposes,
always constructed (and destructed), even if it is never used. KT: This has nothing to do with
static because class member object will be created regardless of static.

o prevent {init-order-problem} since this could happen anything but function-static.

KT. This method do lazy-initialisation automatically and seems to be a good alternative to
singletone?


{{control-the-number-of-object}}

class Printer {
	 public:
	 	class TooManyObjects { };

		Printer();
		~Printer();
		...

	private:
		static size_t numObjects;
		Printer(const Printer& rhs); # no-copy-ctor
};

size_t Printer::numObjects = 0;

Printer::Printer()
{
	 if( numObjects >= 1 ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}

Printer::~Printer()
{
	 ...
	 --numObjects;
}

The pros is that easy to understand and to support any number of objects.

The cons is that is not working in following cases; inheritance and <containment>. Both can be
prevented by having private ctor because cannot create object:

class ColorPrinter : public Printer {
	 ...
};

Printer p;
ColorPrinter cp;  # cause-an-exception


class X {
	 private:
	 	Printer p;
		...
};

X m1;
X m2;             # cause-an-exception

Both cases call ctor twice and these can be prevented by having ctor private. Here note that static
var, class-static, remains a single across objects of its class.


{{pseudo-ctor}}

class FSA {
	 public:
	 	static FSA* makeFSA();
	 	static FSA* makeFSA( const FSA& rhs );
		...

	private:
		FSA();
		FSA( const FSA& rhs );
		...
};

FSA* FSA::makeFSA()
{ return newFSA(); } # okay as it is member func

When make ctors private, cannot create object. Hence no derivation and containment. This pseudo-ctor
approcah means that client must delete and can use smart pointer for that.


{{multiple-time-instance-in-liecycle}}

<file-static> has only one instance for whole program life so not possible to do:

create Printer object p1;
use p1;
destroy p1;
create Printer object p2;
use p2;
destroy p2;

If use both control-the-number-of-object and prventing derivation, then have single instance in
multiple times for whole program life.

class Printer {
	 public:
	 	class TooManyObjects { ... };

		static Printer* makePrinter();
		~Printer();
		void reset();
		...

	private:
		static size_t numObjects;
		Printer();
		Printer( const Printer& rhs );
};

size_t Printer::numObjects = 0;

Printer::Printer()
{
	 if( numObjects >= 1 ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}

Printer* Printer::makePrinter()
{ return new Printer(); }

Can return null pointer instead of issuing an exception.

To supports more than one:

class Printer {
	 public:
	 	class TooManyObjects { ... };

		static Printer* makePrinter();
		~Printer();
		void reset();
		...

	private:
		static size_t numObjects;
		static const size_t maxObjects = 10;
		Printer();
		Printer( const Printer& rhs );
};

size_t Printer::numObjects = 0;
const size_t Printer::maxObjects;

Printer::Printer()
{
	 if( numObjects >= maxObjects ) {
		  throw TooManyObjects();
	 }
	 ...
	 ++numObjects;
}


{{to-support-different-instance}}

If there are many other types of instances to manage? Make it generalise and use template:

template< class T > # T is type being counted
class Counted {     # instance counting class
	 public:
	 	class TooManyObject { ... };
		static size_t objectCount() { return numObjects; }

	protected:       # <to-make-it-used-only-as-base-class>
		Counted();
		Counted( const Counted& rhs );
		~Counted() { --numObjects; };

	private:
		static size_t numObjects;
		static const size_t maxObjects;
		void int();
};

template< class T>
Counted< T >::Counted()
{ init(); }

template< class T>
Counted< T >::Counted( const Counted< T >& )
{ init(); }

template< class T>
void Counted< T>::init()
{
	 if( numObjects >= maxObjects )
		  throw TooManyObjects();
	
	++numObjects;
}


template< class T> size_t Counted< T>::numObjects;


Each derived class, Counted< T>, has independent counter and manage counting mechanism which is
<encapsulation>

Client use:

class Printer : private Counted< Printer> {
	 public:
	 	static Printer* makePrinter();
	 	static Printer* makePrinter( const Printer& rhs );
		 
		~Printer();
		void reset();
		...

		note: to make these public
		using Counted< Printer>::objectCount;
		using Counted< Printer>::TooManyObjects;

	private:
		Printer();
		Printer( const Printer& rhs );
};

note: Client should set static values which is a bit of loose end. If not, link error.

const size_t Counted< Printer>::maxObjects = 10;
const size_t Counted< FileDescripter>::maxObjects = 16;


{further-study}

(However, there is still no guarantee that it will not be destroyed before anything finishes
accessing it; you still need to take great care if you think you need a globally-accessible
variable. See the comments for a link to help in that situation.)

That is, init order fiaso means that there is no gurantee on the order of init when global and
global static init each other. e.g. if there are A and B object and B uses a method of A, then it is
a problem when B is created first.

The solution to this is to use local static:

http://www.parashift.com/c++-faq-lite/static-init-order-on-first-use.html
http://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746

note: KT. since it's best to avoid global object, do not study it further.


==============================================================================
*kt_dev_lang_002*	func pointer

In the past, void (*fptr)(); can define a func that has <any-args> but that is not the case any more
when tested with gcc and VC as of 2013.03.


{func-ptr-typedef}
This is wrong:

typedef int ENTRYTYPE;

typedef void(*)(int) TFUNC; // [KT] wrong

void stacktraverse( stack* stack, TFUNC func)
{
	func(val);
}

This is right:

typedef void(*TFUNC)(int);

void stacktraverse( stack* stack, TFUNC func)
{
	func(val);
}

Also, the following causes error:

queue-contig.cpp:60:35: error: expected identifier before '(' token
queue-contig.cpp:60:41: error: expected ',' or '...' before '*' token

void stacktraverse( stack* stack, (void)*func(int))
{
}


==============================================================================
*kt_dev_lang_003*	#error and #warning

// stops compilation
#error "unknwon cpu - you need to find out the stack grows downward or upward"

// get a mesg during compilation like:
// NDS_pthread.c:43:4: warning: #warning "xxx2" 
#warning "xxx2"


={============================================================================
*kt_dev_lang_004*	post and pre inc/dec

{when-different-pre-and-post-inc}
For example, there are situations when the 'value' of pre/post inc/dec is different from the
'effect'; means that where the use of post or pre makes differences: 

when n is 5, 
     
x = n++;    // x has 5 which is 'value'
x = ++n;    // x has 6

In both cases, n becomes 6 which is 'effect'. So where no value is used and just use effect, pre and
post are the same.

if( c == '\n' )
   nl++;

<example>
From C prog language, p47. All these are example where <post-inc> version is required.

// ansic version. squeeze: delete all c from string s
void squeeze(char s[], int c)
{
  int i, j;

  while( i = j = 0; s[i] != '\0'; i++ )
    if( s[i] != c )
      s[j++] = s[i];

  s[j] = '\0';
}

// mine
void squeeze( char s[], int c )
{
  char *run;

  for( run = s; *run; run++)
  {
    if( *run != c )
      *s++ = *run;
  }

  // this has a bug. why?
  // for( run = s; *run;)
  // {
  //   if( *run != c )
  //     *s++ = *run++;
  // }

  *s = '\0';
}

// strcat: concatenate t to end of s; s must be big enough 
// note lib version returns a pointer of resulting string
void strcat( char s[], char t[] )
{
  int i, j;

  i = j = 0;
  while( s[i] != '\0' )	/* find end of s */
    i++;

  while( (s[i++] = t[j++]) != '\0' )	/* copy t */
    ;
}

<exercise>
From ansic, exercise 2-4.
Write an alternate version of squeeze(s1,s2) that deletes each character in the string s1 that
matches any character in the string s2 .

// one http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_4
void squeeze2(char s[], char t[]) {
    int i, j, k;
    for (k = 0; t[k] != '\0'; k++) {
        for (i = j = 0; s[i] != '\0'; i++)
            if (s[i] != t[k])
                s[j++] = s[i];
        s[j] = '\0';
    }
}

// two
void squeeze( char s[], char c )
{
  char* run;

  for( run = s; *run; run++ )
  {
    // approach one: can use a function call to check if c is in the second string.
    // approach two: how can to it without using a function call? not possible to have a loop
    // replacing if block. use loop on the second rather than thinking about a loop inside a loop of
    // the first.
    if( *run != c )
      *s++ = *run;
  }

  *s = '\0';
}

void squeeze_mine( char s[], char t[] )
{
  char *run, *write;

  for(; *t; t++)
  {
    for( write = run = s; *run; run++ )
    {
      if( *run != *t )
        *write++ = *run;
    }

    *write = '\0';
  }
}

// three. attempt to loop from s. core dumped since write s[r] for the size of t[]
void squeeze_not_working(char s[], char t[]) {
    int r, w, k;

    for (r = w = 0; s[r] != '\0'; r++)  // r(run)
    {
      for (k = 0; t[k] != '\0'; k++)    // k(key)
      {
        if (s[r] != t[k])
          s[w++] = s[r];
      }
    }

    s[w] = '\0';
}

int main()
{
  char mesg[] = "hello world";
  char mesg2[] = "hello world";

  printf("mesg : %s\n", mesg );
  squeeze( mesg, 'l' );
  printf("mesg : %s\n", mesg );

  printf("mesg2 : %s\n", mesg2 );
  squeeze3( mesg2, "ol" );
  printf("mesg2 : %s\n", mesg2 );
}

note. whatever approach used, it has the worst case of O(nm).

<exercise> <strpbrk>
From ansic, exercise 2-5.
Write the function any(s1,s2), which returns the first location in the string s1 where any
character from the string s2 occurs, or -1 if s1 contains no characters from s2. (The standard
library function strpbrk does the same job but returns a pointer to the location.)

// one
// not good since based on the "squeeze" approach which means more work to find the first time since
// key chars can happen any order and did not stop on "first" match
int any_mine( char s[], char t[] )
{
  int ret = -1;
  int i;

  // run through t[]
  for(; *t; t++)
  {
    // run through s[]
    for( i = 0; s[i]; i++ )
    {
      // found a match
      if( s[i] == *t )
      {
        // update found index when either it's the first time or found the less than the previous
        if( ret < 0 || i < ret )
        {
          ret = i;
          break;
        }
      }
    }
  }

  return ret;
}


// two
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_5

// The pedestrian solution is Richard Heathfield's
// Here is my solution, which is very simple but quite naive and inefficient. It has a worst-case
// time complexity of O(nm) where n and m are the lengths of the two strings.

int any_online_one(char s1[], char s2[])
{
  int i;
  int j;
  int pos;

  pos = -1;

  // by having "pos == -1" checks, two for loops stops as soon as found a match and means the
  // "first" location as the problem states. But the worst still O(nm).
  //
  // <Q> is this check on pos really needed? 
  for(i = 0; pos == -1 && s1[i] != '\0'; i++)
  {
    for(j = 0; pos == -1 && s2[j] != '\0'; j++)
    {
      if(s2[j] == s1[i])
      {
        return pos = i;
      }
    }
  }

  return pos;
}

// three
// Could anything be simpler? Pilcrow 22:46, 24 August 2011 (UTC)
int any_online_two(char s1[], char s2[])
{
  int i;
  int j;

  // no need for further code when found a match
  for(i = 0; s1[i] != '\0'; i++)
  {
    for(j = 0; s2[j] != '\0'; j++)
    {
      if(s2[j] == s1[i])
      {
        return i;
      }
    }
  }

  return -1;
}

// four
http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_5

Here's a much better solution, by Partha Seetala. This solution has a worst- case time complexity of
only O(n + m) which is considerably better.

It works in a very interesting way. He first defines an array with one element for each possible
character in the character set, and then takes the second string and 'ticks' the array at each
position where the second string contains the character corresponding to that position. It's then a
simple matter to loop through the first string, quitting as soon as he hits a 'ticked' position in
the array.

#include <stdio.h> /* for NULL */

int any(char *s1, char *s2)
{
  char array[256]; /* rjh comments
                    * (a) by making this char array[256] = {0}; the first loop becomes unnecessary.
                    * (b) for full ANSIness, #include <limits.h>, make the array unsigned char,
                    *     cast as required, and specify an array size of UCHAR_MAX(255) + 1.
                    * (c) the return statements' (parentheses) are not required.
                    */
  int  i;
  if (s1 == NULL) {
    if (s2 == NULL) {
      return(0);
    } else {
      return(-1);
    }
  }

  for(i = 0; i < 256; i++) {
    array[i] = 0;
  }

  while(*s2 != '\0') {
    array[*s2] = 1;
    s2++;
  }

  i = 0;
  while(s1[i] != '\0') {
    if (array[s1[i]] == 1) {
      return(i);
    }
    i++;
  }
  return(-1);
}


{compounded-inc}
From C prog lang, p95, 105:

int *ip;

*ip++;		// inc ip itself
(*ip)++;		// inc *ip, not ip

NOTE: 
<post-inc> is higher than <pre-inc> and dereference. <pre-inc> and dereference has the same
precedence and right(right-to-left) assoc.  

/* strcpy: copy t to s; pointer version 
 * lib: The strcpy() and strncpy() functions return a pointer to the destination string dest
 */
void strcpy( char *s, char *t )
{
	 while( *s++ = *t++ ) 
		  ;
}

Here <right-to-left> for '=' op and <post-inc> are involved. "the value of *t++ is the char that t
pointed to 'before' t was incremented; the postfix does not change t until after this char has been
fetched." This is a bit confusing.

The before and after explanation says that ++n inc n 'before' its value is used and n++ inc n
'after'. Or some says that post-inc returns the previous copy. 

For *pbeg++, <post-inc> is high than dereference(*) so it's the same as *(pbeg++). but how this
behave as *(pbeg); pbeg++; ? because it returns the previous copy. This is how Primus explains. <THIS>
is answer and this matches to asm result.

Here there are three operations; fetch, increase and dereference. post-inc do fetch and increase but
return the value before increase and dereference it.


{post-inc-overload}
MEC++06. <post-inc> can be ineffective when used on user-type; overloads. 

 The prefix form of the increment operator is sometimes called - increment and fetch, while the
 postfix form is often known as fetch and increment.

class UPInt {                             // "unlimited precision int"
public:
	 UPInt& operator++();                  // prefix ++
	 'const' UPInt operator++(int);          // <postfix> ++
	 UPInt& operator--();                  // prefix --
	 const UPInt operator--(int);          // <postfix> --
	 UPInt& operator+=(int);               // a += operator for UPInts and ints
...
};

UPInt i;

++i; // calls i.operator++();
i++; // calls i.operator++(0);             // to distinguish with '++i'
--i; // calls i.operator--();
i--; // calls i.operator--(0);

// prefix form: increment and fetch
UPInt& UPInt::operator++()
{
	 *this += 1;                   // increment
	 return *this;                 // fetch
}

// postfix form: fetch and increment
const UPInt UPInt::operator++(int)
{
	 const UPInt oldValue = *this; // fetch
	 ++(*this);                    // increment
	 return oldValue;              // return what was fetched
}

The only purpose of the parameter is to distinguish prefix from postfix function invocation. Many
compilers issue warnings if you fail to use named parameters in the body of the function to which
they apply, and this can be annoying. To avoid such warnings, a common strategy is to omit names for
parameters you don't plan to use; that is what is been done above.

<why-const-in-post-inc> {const-return}
If you have ever wondered if it makes sense to have functions return const objects, now you know:
sometimes it does, and postfix increment and decrement are examples.

If not, it allows this:

i++++;

So to make it behave like premitive type, return const. In other words, ++++i; is valid? Yes, this
is valid code.

<should-prefer-post-inc-when-use-none-premitive>
The prefix increment function has no such temporaries. This leads to the possibly startling
conclusion that, for efficiency reasons alone, clients of UPInt should prefer prefix increment to
postfix increment unless they really need the behavior of postfix increment.

When dealing with user-defined types, prefix increment should be used whenever possible, because it
is inherently more efficient.

The principle is that postfix increment and decrement should be implemented in terms of their prefix
counterparts. You then need only maintain the prefix versions, because the postfix versions will
automatically behave in a consistent fashion.

<in-particular>
Primus(p148) recommends prefix version than postfix because post-inc increase first and
return(yield) the previous copy and it cost extra. it may have no effect for built-in types due to
optimization but may be expensive for <iterators>. See *kt_dev_stl_007* for iter++ example.

auto pbeg = v.begin();

while(...)
	 cout << *pbeg++ << endl;


{simple-post-asm}
Used gcc and de-asm for MIPS. when try simple post inc, it shows like that fetch and then inc. no
use of the previous copy. simply do j=i; and i+=i; in asm.

## post

#include <stdio.h>

int main()
{
	int i = 0, j = 0;
	
	j = i++;
	printf("j is %d\n", j );
	return 0;
}

# 
#
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       afbf0024        sw      ra,36(sp)
  400598:       afbe0020        sw      s8,32(sp)
  40059c:       03a0f021        move    s8,sp       # save sp to s8. s8 is sp.
  4005a0:       afc0001c        sw      zero,28(s8) # i = 0
  4005a4:       afc00018        sw      zero,24(s8) # j = 0
  4005a8:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005ac:       afc20018        sw      v0,24(s8)   # j = i
  4005b0:       8fc2001c        lw      v0,28(s8)   # v0 = i
  4005b4:       24420001        addiu   v0,v0,1     # v0(i) = i+1
  4005b8:       afc2001c        sw      v0,28(s8)   # i = v0
  4005bc:       3c020040        lui     v0,0x40
  4005c0:       24440690        addiu   a0,v0,1680
  4005c4:       8fc50018        lw      a1,24(s8)   # get j and call print
  4005c8:       0c100124        jal     400490 <printf@plt>
  4005cc:       00000000        nop
  4005d0:       00001021        move    v0,zero
  4005d4:       03c0e821        move    sp,s8
  4005d8:       8fbf0024        lw      ra,36(sp)
  4005dc:       8fbe0020        lw      s8,32(sp)
  4005e0:       27bd0028        addiu   sp,sp,40
  4005e4:       03e00008        jr      ra
  4005e8:       00000000        nop
  4005ec:       00000000        nop

## -Os. See how it's done. Just use zero to print and no increase.

00400590 <main>:
  400590:       3c040040        lui     a0,0x40
  400594:       27bdffe0        addiu   sp,sp,-32
  400598:       24840658        addiu   a0,a0,1624
  40059c:       afbf0018        sw      ra,24(sp)
  4005a0:       0c100124        jal     400490 <printf@plt>
  4005a4:       00002821        move    a1,zero
  4005a8:       8fbf0018        lw      ra,24(sp)
  4005ac:       00001021        move    v0,zero
  4005b0:       03e00008        jr      ra
  4005b4:       27bd0020        addiu   sp,sp,32  


<pointer-case>

#include <stdio.h>

void print_array(int arr[], int len)
{
	int *pend;
	
	pend = arr+len;

	while( arr != pend )
		printf("arr is : %d\n", *arr++ );
}

int main()
{
	int int_arr[] = { 1,2,3,4,5,6,7,8,9,10};
	
	print_array(int_arr, sizeof(int_arr)/sizeof(int));
	
	return 0;
}


004005c0 <print_array>:
  4005c0:       27bdffd8        addiu   sp,sp,-40
  4005c4:       afbf0024        sw      ra,36(sp)
  4005c8:       afbe0020        sw      s8,32(sp)
  4005cc:       03a0f021        move    s8,sp
  4005d0:       afc40028        sw      a0,40(s8)	# arr
  4005d4:       afc5002c        sw      a1,44(s8)	# len
  4005d8:       8fc2002c        lw      v0,44(s8)	# get len
  4005dc:       00021080        sll     v0,v0,0x2	# v0 = v0 << 2. 101000 (40) for 10 integers
  4005e0:       00401821        move    v1,v0		# v1 = len
  4005e4:       8fc20028        lw      v0,40(s8)	# get arr
  4005e8:       00621021        addu    v0,v1,v0	# v0 = len + arr {pend}
  4005ec:       afc20018        sw      v0,24(s8)	# save v0
  4005f0:       08100188        j       400620 <print_array+0x60>
  4005f4:       00000000        nop
{4005f8}:       8fc20028        lw      v0,40(s8)	#<2> get arr {inced-arr}
  4005fc:       8c430000        lw      v1,0(v0)	#    get *arr note. {deref} 0($x)
  400600:       8fc20028        lw      v0,40(s8)	#    get arr
  400604:       24420004        addiu   v0,v0,4		#    arr++
  400608:       afc20028        sw      v0,40(s8)	#    save arr++
  40060c:       3c020040        lui     v0,0x40		#    
  400610:       24440750        addiu   a0,v0,1872
  400614:       00602821        move    a1,v1		#    *arr
  400618:       0c10012c        jal     4004b0 <printf@plt>
  40061c:       00000000        nop
{400620}:       8fc30028        lw      v1,40(s8)	                     # <1> get arr {inced-arr}
  400624:       8fc20018        lw      v0,24(s8)	                     #   get pend {const}
  400628:       1462fff3        bne     v1,v0,4005f8 <print_array+0x38>	# !=
  40062c:       00000000        nop
  400630:       03c0e821        move    sp,s8
  400634:       8fbf0024        lw      ra,36(sp)
  400638:       8fbe0020        lw      s8,32(sp)
  40063c:       27bd0028        addiu   sp,sp,40
  400640:       03e00008        jr      ra
  400644:       00000000        nop

00400648 <main>:
  400648:       27bdffb8        addiu   sp,sp,-72
  40064c:       afbf0044        sw      ra,68(sp)
  400650:       afbe0040        sw      s8,64(sp)
  400654:       03a0f021        move    s8,sp
  400658:       3c020040        lui     v0,0x40
  40065c:       27c30018        addiu   v1,s8,24
  400660:       24420760        addiu   v0,v0,1888
  400664:       24060028        li      a2,40
  400668:       00602021        move    a0,v1
  40066c:       00402821        move    a1,v0
  400670:       0c100130        jal     4004c0 <memcpy@plt>	# may be copy array into stack (24)?
  400674:       00000000        nop
  400678:       27c20018        addiu   v0,s8,24
  40067c:       00402021        move    a0,v0
  400680:       2405000a        li      a1,10	# len
  400684:       0c100170        jal     4005c0 <print_array>
  400688:       00000000        nop
  40068c:       00001021        move    v0,zero
  400690:       03c0e821        move    sp,s8
  400694:       8fbf0044        lw      ra,68(sp)
  400698:       8fbe0040        lw      s8,64(sp)
  40069c:       27bd0048        addiu   sp,sp,72
  4006a0:       03e00008        jr      ra
  4006a4:       00000000        nop
        ...
		
004004c0 <memcpy@plt>:
  4004c0:       3c180040        lui     t8,0x40
  4004c4:       8f1917d8        lw      t9,6104(t8)
  4004c8:       03200008        jr      t9
  4004cc:       271817d8        addiu   t8,t8,6104

See <2> since dereference first and increase later.


==============================================================================
*kt_dev_lang_005*	chaining

int v1, v2;
cin >> v1 >> v2;

cout << "Enter numbers:" << endl;

Because operators returns reference of {left-hand-operand} which is cin and cout.


==============================================================================
*kt_dev_lang_006*	copile error types

syntax, type mismatch, and declaration error


==============================================================================
*kt_dev_lang_007*	bool type

Do not have a minimum size. In VC, is the same as int type. 

There is differece of meaning between return value from main and bool type. In return from main,

int main()
{
	 return 0; # for okay. true seems to be 0?
	 return ?; # any other value, error code, for not okay 
}

<gcc-case> on ubuntu linux
#include <iostream>
#include <bitset>

using std::cout;
using std::endl;

int main () {

  bool* parr = new bool(20);

  cout << "size: " << sizeof(parr) << endl;
  cout << "size: " << sizeof(*parr) << endl;
  cout << "valu: " << *parr << endl;

  return 0;
}

kt@kt-ub-vb:~/work$ ./a.out 
size: 4
size: 1
valu: 1


{non-bool-to-bool}
When assign non-bool to bool type, type conversion happens and got 0 or 1 depending on the value of
non-bool. That is false for 0 and true for [any-other-values] other than 0.

bool b = 42;    # b is true

When bool to non-bool, has 1 or 0.


{true-and-false} {bool-to-non-bool}
The 'true' and 'false' are [literals-of-type-bool]. true is any non-zero but not only 1. 

if( val == true ) { ... }

If val is non-bool type, conversion to non-bool which is bigger type happens and this becomes 

if( val == 1 ) { ... }

This may not be what intented if meant for cases of non-zero because it runs only when val is 1.
Therefore, want the case of when val is 1 then do it directly. The direct form is:

if(val) or if(!val) 

It is usually bad idea to use the boolean literals true and false as operands in a comparison. These
literals should be used only to compare to [an object of type bool].


{not-use-in-computation}
Do not use bool and char for computation since there is conversion. For example:

bool b1 = true;
bool b2 = -b1;

b2 is true since b1 promoted to 1, negates to -1, and convert back to bool but it is not a zero
hence true.


={============================================================================
*kt_dev_lang_008*	data type, char type

{data-type}
From ansic:

char
int      an integer, typically reflecting the natural size of integers on the host machine
float
double

short, long, signed and unsigned 'qualifiers'. short is 'at-least' 16 bits, long 'at-least' 32 bits
and int either 16 or 32 bits. Each compiler is free to choose appropriate sizes for its own
hardware.

The char is not singed char. there are char, signed, unsigned types because whether char is signed
or unsigned depends on compiler. From ansic, "whether plain chars are signed or unsigned is
machine-dependent". So recommendation is that use signed or unsigned.

The standard header <limits.h> and <float.h> contain symbolic constants for all of these sizes along
with other properties of the machine and compiler.


From C++: 2.1.1 Arithmetic Types

Type        Meaning           Minimum Size
------------------------------------------
bool        boolean           NA
short       short integer     16 bits
int         integer           16 bits
long        long integer      32 bits 
long long   long integer      64 bits

<exercise>
The ansic, page 36, exercise 2-1. Write a program to determine the range of char, short, int, and
long variables, both signed and unsigned, by printing appropriate values from standard headers and
by direct computation. Harder if you compute them: determine the range of the various floating-point
types.

// mine based on *kt_dev_prob_010* to get max value of type. 
//
#include <limits.h>

#define MY_ULONG_MAX (~(unsigned long)0) // see difference from glibc version

int main(int argc, char* argv[])
{
  printf("ulong max from limits: %luL\n", ULONG_MAX );
  printf("ulong max from calc: %luL\n", MY_ULONG_MAX );
}

From http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_1

#include <stdio.h>
#include <limits.h>


int main(void)
{
  printf("\nBits of type char: %d\n\n", CHAR_BIT);                     /* IV */

  printf("Maximum numeric value of type char: %d\n", CHAR_MAX);        /* IV */
  printf("Minimum numeric value of type char: %d\n\n", CHAR_MIN);      /* IV */

  printf("Maximum value of type signed char: %d\n", SCHAR_MAX);        /* IV */
  printf("Minimum value of type signed char: %d\n\n", SCHAR_MIN);      /* IV */

  printf("Maximum value of type unsigned char: %u\n\n", (unsigned) UCHAR_MAX);    /* SF */  /* IV */
  
  printf("Maximum value of type short: %d\n", SHRT_MAX);               /* IV */
  printf("Minimum value of type short: %d\n\n", SHRT_MIN);             /* IV */

  printf("Maximum value of type unsigned short: %u\n\n", (unsigned) USHRT_MAX);   /* SF */  /* IV */


  printf("Maximum value of type int: %d\n", INT_MAX);                  /* IV */
  printf("Minimum value of type int: %d\n\n", INT_MIN);                /* IV */

  printf("Maximum value of type unsigned int: %u\n\n", UINT_MAX);      /* RB */   /* IV */

  printf("Maximum value of type long: %ld\n", LONG_MAX);               /* RB */   /* IV */
  printf("Minimum value of type long: %ld\n\n", LONG_MIN);             /* RB */   /* IV */

  printf("Maximum value of type unsigned long: %lu\n\n", ULONG_MAX);   /* RB */   /* IV */


  return 0;
}

Integer solution. Floats to follow.
I know 'long long' is not in K&R. This is the 21st century.
Learned a bit doing this. Pilcrow 12:00, 31 July 2011 (UTC)

/* calculate the ranges of various types */
#include <stdio.h>
#include <limits.h>

int main(void)
{
  /* integer types */
  unsigned char c;
  unsigned short s;
  unsigned int i;
  unsigned long l;
  unsigned long long ll;

  putchar('\n');
  printf("VALUE RANGES FOR INTEGER TYPES\nUPPERCASE comes from <limits.h>\n"
      "lowercase is calculated.\n\n");

  /* char */
  c = ~0;     // note: this is Uxxx_MAX
  c >>= 1;    // note: this is xxx_MAX. why this work? since it's 'unsigned'
  printf("signed char:   %4d,           %4d\n",-c-1,c);
  printf("SCHAR_MIN:     %4d, SCHAR_MAX %4d\n",SCHAR_MIN,SCHAR_MAX);
  printf("unsigned char: %4u,           %4u\n",0,c*2+1);
  printf("UCHAR_MAX:                     %4u\n",UCHAR_MAX);
  putchar('\n');

  // kt@kt-ub-vb:~/work$ ./a.out 
  // 
  // VALUE RANGES FOR INTEGER TYPES
  // UPPERCASE comes from <limits.h>
  // lowercase is calculated.
  // 
  // signed char:   -128,            127
  // SCHAR_MIN:     -128, SCHAR_MAX  127
  // unsigned char:    0,            255
  // UCHAR_MAX:                      255

  /* short */
  s = ~0;
  s >>= 1;
  printf("signed short:   %6d,           %6d\n",-s-1,s);
  printf("SHRT_MIN:       %6d, SHRT_MAX: %6d\n",SHRT_MIN,SHRT_MAX);
  printf("unsigned short: %6u,           %6u\n",0,s*2+1);
  printf("USHRT_MAX:                        %6u\n",USHRT_MAX);
  putchar('\n');

  /* int */
  i = ~0;
  i >>= 1;
  printf("signed int:    %11d,          %11d\n",-i-1,i);
  printf("INT_MIN:       %11d, INT_MAX: %11d\n",INT_MIN, INT_MAX);
  printf("unsigned int:  %11u,          %11u\n",0,i*2+1);
  printf("UINT_MAX:                            %11u\n",UINT_MAX);
  putchar('\n');

  /* long */
  l = ~0;
  l >>= 1;
  printf("signed long:   %11ld,           %11ld\n",-l-1,l);
  printf("LONG_MIN:      %11ld, LONG_MAX: %11ld\n",LONG_MIN, LONG_MAX);
  printf("unsigned long: %11lu,           %11lu\n",0l,l*2+1);
  printf("ULONG_MAX:                            %11lu\n", ULONG_MAX);
  putchar('\n');


  /* long long */
  ll = ~0;
  ll >>= 1;
  printf("signed long long:   %20lld,            %20lld\n",-ll-1,ll);
  printf("LLONG_MIN:          %20lld, LLONG_MAX: %20lld\n",LLONG_MIN, LLONG_MAX);
  printf("unsigned long long: %20llu,            %20llu\n",0ll,ll*2+1);
  printf("ULLONG_MAX:                                          %20llu\n", ULLONG_MAX);
  return 0;

}


={============================================================================
*kt_dev_lang_009*	implicit conversion (built-in conversion)

When an operator has operands of different types, they are converted to a "common-type" according to
a small number of rules.
  
{implicit-conversion} See *kt_dev_cpp_005* for class-type conversion.

Primers p159. Happens when used in expression, func call and func matching

int ival = 3.541 + 3;

Causes promotion to double first and conversion to int next.

cases:

1. promote smaller types to int. when mixed, promote to a bigger type.
2. convert to bool in condition but not always possible. see below.
3. 'left = right' in init. promote right to left or can be truncated.
4. convert to signed to unsigned.


{bool-conversion} {equal-misspell}
<1>

The fact that we can use assignment in a condition can have surprising effects:

if (i = j)

<true-means>
The condition like this which assigns the value of j to i and then tests the result of the
assignment. If j is nonzero, the condition will be true. This is what "true" means in the 'test'
part of if, while, for, etc and 'true' means non-zero. 

The author of this code almost surely intended to test whether i and j have the same value:

if (i == j)

Bugs of this sort are notoriously difficult to find. Some, but not all, compilers are kind enough to
warn about code such as this example.

<2> 
auto loc = wordmap.find( sought );

if( loc = wordmap.end() )	// meant if( loc == wordmap.end() )

GCC error is:

tquery.cpp:63: error: could not convert '(loc <unknown operator> ((const
std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char, std::char_traits<char>,
std::allocator<char> >, std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>,
std::allocator<long unsigned int> > > > >&)((const std::_Rb_tree_const_iterator<std::pair<const
std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>, std::allocator<long
unsigned int> > > > >*)(&((const TextQuery*)this)->TextQuery::wordmap.std::map<_Key, _Tp, _Compare,
_Alloc>::end [with _Key = std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
_Tp = std::shared_ptr<std::set<long unsigned int, std::less<long unsigned int>, std::allocator<long
unsigned int> > >, _Compare = std::less<std::basic_string<char, std::char_traits<char>,
std::allocator<char> > >, _Alloc = std::allocator<std::pair<const std::basic_string<char,
std::char_traits<char>, std::allocator<char> >, std::shared_ptr<std::set<long unsigned int,
std::less<long unsigned int>, std::allocator<long unsigned int> > > > >]()))))' to 'bool'

This happens when tries to covert loc iterator to bool. If it were ==, then operator== would return
bool type.

<3>
Meant to be == and this if is always true.

bool QueueFull(Queue* queue)
{
   if( queue->count = MAXSIZE )
   {
      std::cout << "full(" << queue->count << ")" << std::endl;
      return true;
   }

   return false;
}


{signed-vs-unsigned}
unsigned char uc = -1;	// out-of-range. 255. {wrap-around}
signed char sc = 256;	// out-of-range. -128...127. undefined value
 
Recommends that don't mix between them:

<one> Same as wrap-around
unsigned ui = 10; int i = -42;
cout << ui + i << endl;

<two> 
unsigned int u1 = 42, u2 = 10;
cout << u2 - u1 << endl;

These two cases shows the same result. 4294967264. why? because converted to unsigned.

<three>
for( unsigned u = 10; u >= 0; --u )
	 cout << n << endl;

Causes <infinite-loop> because u = -1 and means big number.


{integer-division}
From ansic 1.2., this is a program to implement a formula "C = (5/9)(F-32)" to print a table of
Fahrenheit and Celsius.

<V1>
// print Fahrenheit-Celsius table
int main(int argc, char* argv[])
{
  int fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step = 20;

  fahr = lower;
  while( fahr <= upper ) 
  {
    celsius = 5 * (fahr-32) / 9;
    printf("%d\t%d\n", fahr, celsius );
    fahr = fahr + step;
  }
}

Why "celsius = 5 * (fahr-32) / 9;" but not "celsius = 5/9 * (fahr-32);"? Since integer division
truncates: any fractional part is discarded so 5/9 would be trancated to zero.

kt@kt-ub-vb:~/work$ ./a.out 
0	-17
20	-6
40	4
60	15
80	26
100	37
120	48
140	60
160	71
180	82
200	93
220	104
240	115
260	126
280	137
300	148
kt@kt-ub-vb:~/work$ gcc sam01.c
kt@kt-ub-vb:~/work$ ./a.out 
0	0
20	0
40	0
60	0
80	0
100	0
120	0
140	0
160	0
180	0
200	0
220	0
240	0
260	0
280	0
300	0

<V2>
// print Fahrenheit-Celsius table: floating-point version to be accurate
int main(int argc, char* argv[])
{
  float fahr, celsius;
  int lower, upper, step;

  lower = 0;
  upper = 300;
  step = 20;

  fahr = lower;
  while( fahr <= upper ) 
  {
    // celsius = 5/9 * (fahr-32);
    // celsius = 5/9 * (fahr-32.0);
    celsius = 5.0/9.0 * (fahr-32.0);
    printf("%3.0f %6.1f\n", fahr, celsius );
    fahr = fahr + step;
  }
}

1. "5/9" is still integer division.
kt@kt-ub-vb:~/work$ ./a.out 
  0   -0.0
 20   -0.0
 40    0.0
 60    0.0
 80    0.0
100    0.0
120    0.0

If an arithmetic operator has integer operands, an integer operation is performed. If an arithmetic
operator has on floating-point operand and one integer operand, howerver, the integer will be
converted to floating point before the operation is done. 

while(fhar <= upper) and fahr-32 would be converted to floating point. Nevertheless, writing
floating-point constants with explicit decimal point emphasizes their floating-point nature for
human readers.


{char-to-int} <ansic-example>
From ansic, p43.

int atoi(char s[])
{
  int n, i;

  for(n = 0, i = 0; s[i] >= '0' && s[i] <= '9'; i++)
    n = n*10 + (s[i]-'0'); // here s[i]-'0'

  return n;
}

// ASCII only and upper case comes first and lower case comes later in the table. Why ASCII only?
int lower(int c)
{
  if( c => 'A' && c <= 'Z' )
    return c + 'a' - 'A';     // c -'A' + 'a' or c + 'A' - 'a' ?
  else
    return c;
}


={============================================================================
*kt_dev_lang_010*	incomplete type

{text-query-example}
Primus p484. The output for query word 'element' is:

element occurs 112 times
	(line 36) A set element contains only a key;
	(line 158) operator creates a new element
	...

Requirements are that show line number, ascending order, no duplicates, and line text which contains
the word. Also support multi pass until user quit.

<more-abstract-solution>
Used class instead of using set, map, and vector directly. [DN] How to design what this query func
return without cost of copying? Yes, shared_ptr.

TextQuery:                         shared:dyn creted   QueryResult:
 shared_ptr<vector> : file           vector              shared_ptr<vector>
  line 0
  line 1
  line 2
  ...
 
 map : < word, ptr-to-set>
  word x, -> set : line nos         sets                shared_ptr
  word y, -> set : line nos


class QueryResult;	// forward declaration

class TextQuery {
  public:
    using line_no = std::vector<std::string>::size_type; // [type-member]

    TextQuery( std::ifstream& );
    QueryResult query( const std::string& ) const;

  private:
    std::shared_ptr<std::vector<std::string>> file; // input file
    std::map<std::string, std::shared_ptr< std::set< line_no >>> wm;
};

// TextQuery member definitions

TextQuery::TextQuery( ifstream& is ) : file( new vector<string>) // new vector
{
  string text;

  while( getline( is, text )) {     // for each line. std::getline
    file->push_back(text);          // save line
    int n = file->size() -1;        // get line num. -1 to make line num the same as vector index

    istringstream line(text);
    string word;

    while( line >> word ) {                  // for each word of a line
      // see that lines is reference
      auto& lines = wm[word];                // add new entry if word is not in wm
      // value-init and lines will be null
      if( !lines )                           // lines is shared_ptr
        lines.reset( new set< line_no > );   // new set

      lines->insert(n);                      // save line num which shown this word
      // word occurs more than once in the same line, do nothing since it is a set
    }
  }
}

Think what should return if the given string is not found because there is no set for this? Used
a empty set which is local static, function-static.

QueryResult TextQuery::query( const string& sought ) const
{
  static shared_ptr< set< line_no >> nodata( new set< line_no > );

  auto loc = wordmap.find( sought ); // [Quiz] why find instead of subscript?

  if( loc == wordmap.end() )
    return QueryResult( sought, nodata, file );
  else
    return QueryResult( sought, loc->second, file );		
}

class QueryResult {
  friend std::ostream& print( std::ostream&, const QueryResult& );

  public:
  // this is missed in the book.
  using line_no = std::vector<std::string>::size_type; // [type-member]

  QueryResult( std::string s,
      std::shared_ptr< std::set<line_no>> p,
      std::shared_ptr< std::vector< std::string >> f ): sought(s), lines(p), file(f) {}
  private:
  std::string sought;
  std::shared_ptr< std::set<line_no>> lines;
  std::shared_ptr< std::vector< std::string >> file;
};


{BP} When design a class, can be helpful to write programs using the class before implementing the
members. That way, can see whether the class has the operation we need. WHAT OPERATION WE NEED hels
us see WHAT DATA STRUCTURE we will need.

void runQueries(ifstream& infile)
{
  TextQuery tq(infile);

  while(true) {
    cout << "enter the word to look for, or q to quit: ";
    string s;

    // stop if hit eof or q
    if( !(cin >> s) || s == "q" ) break;

    print( cout, tq.query(s)) << endl;
  }
}

ostream &print( ostream& os, const QueryResult& qr)
{
  os << qr.sought << " occurs " << qr.lines->size() << " " << make_plural( qr.lines->size(),
      "time", "s") << endl;

  // when *qr.lines is empty, the loop will not be executed.
  for( auto num : *qr.lines )
    os << "\t(line " << num + 1 << ") " << *(qr.file->begin() + num) << endl;

  return os;
}

Got following errors:

tquery.cpp: In member function 'QueryResult TextQuery::query(const std::string&) const':
tquery.cpp:58: error: return type 'struct QueryResult' is incomplete ~
tquery.cpp:65: error: invalid use of incomplete type 'struct QueryResult' 
tquery.cpp:12: error: forward declaration of 'struct QueryResult'
tquery.cpp:67: error: invalid use of incomplete type 'struct QueryResult'
tquery.cpp:12: error: forward declaration of 'struct QueryResult'

When move query func after class QueryResult then these errors go away. Why?


{extented-text-query-example}
How to support these queries? ~(str), str, (str|str), (str&str), (str&str|str) which use normal C++
precedence rules.

<OOP-solution>
Can use TextQuery? No. To see why, consider a Not query and we would have to able to find the word
for which the Not query was searching. There is no such word. Instead a Not query has a query whose
value it negates. Similarly, And and Or query have two queries whose results it combines. This
suggests that we model our different kinds of queries as independent classes that share a common
base class. The solution is to have four classes which has the same interface and use ABC.

<DN-ABC>
o These four query types are not related to one another by inheritance; not related in vertically
and they are conceptually siblings and shares the same interface. This suggest that will need to
define ABC to represent that interface.

o The AndQuery and OrQuery share one property that the other classes do not. Each has two operands.
To model this, define another ABC to represent queries with two operands.

<DN-interface>
o We need to able to build queries. The simplest way is to write C++ expressions to create the
compounded queries:

   Query q = Query("fiery") & Query("bird") | Query("wind");

This suggests that user code won't use the inherited class directly. Instead, will define an
interface class named Query which hide the hierarchy and has the same operations as Query_base. It
will have three overloaded operators and ctor.

   - & operator will [create] a Query bound to a new AndQuery.
   - | operator will [create] a Query bound to a new OrQuery.
   - ~ operator will [create] a Query bound to a new NotQuery.
   - Query ctor that takes a string will create a Query bound to a new WordQuery.

<DN-SP>
o In each of these classes, the operand(s) can be an object of any of the concrete classes derived
from Query_base: NotQuery can be applied to an AndQuery. To allow this flexibility i.e., compound
query, the operands must be stored as pointers to Query_base so that can bind the pointer to
whichever concrete class we need. However, rather than storing a Query_base pointer, will themselves
use a Query object as [user] code is simplified by using the interface. [KT] This is why BinaryQuery
has Query members.

<DN-no-public-interface-in-implementation>
There is no public interface in Query_base hierarchy.

<creation>
So objects created by the expression are:

   Query q = Query("fiery") & Query("bird") | Query("wind");
             - new WQ         - new WQ                    // temp Queries
                       - new ANDQ             - new WQ    // temp Queries, copied Queries and copyed SPs
                                           - new ORQ
                                           
                                           Query q        // All temp Queries will be destoried

   q = Query      OrQuery        AndQuery          WordQuery
         [ ] ->   [ ]      ->    [ ]      ->       [fiery] 
                                                   WordQuery
                                 [ ]      ->       [bird]

                  [ ]      ->    WordQuery
                                 [wind]

Once the [tree-of-objects] is built up, evaluating(or generating the representation of) a query is
basically a process of following these links, asking each object to evaluate itself. Call eval on q
which is the root of the tree, that call asks the OrQuery to which q points to eval itself.
Evaluating this OrQuery calls eval on its two operands- on the AndQuery and the WordQuery that looks
for the word bind. Evaluating the AndQuery evaluates its two WordQuerys, generating the results for
the words fiery and bird.

<class-hierarchy>
Inheritance hierarchy is:                                    

User     Query class             Query Base
         - interface class       - ABC
         - hide QB from user        |           |           | 
                                 WordQuery   NotQuery    BinaryQuery
                                                         - ABC
                                                            |           |
                                                         AndQuery    ORQuery

Q        NOTQ     AND or ORQ
-sp<QB>  - Q      - Q lhs, rls

// private ctor which prevent a user from creating derived class directly and due to this, make
// operator overloads friend to use ctor.
//
class Query {
  friend Query operator~( const Query& );
  friend Query operator|( const Query&, const Query& );
  friend Query operator&( const Query&, const Query& );

  public:
    Query( const std::string& );

    // [interface] for Query_base
    QueryResult eval(const TextQuery &t) const { return q->eval(t); }
    std::string rep() const { return q->rep(); }

  private:
    Query( std::shared_ptr<Query_base> query ): q(query) {}

    std::shared_ptr<Query_base> q;
};

inline Query::Query( const std::string &s ): q(new WordQuery(s)) {}

// ABC and no public interface since do not intend users or the derived class to use it directly.
// Query friend since it use Query_base's virtual call. See protected dtor since it is used
// implicitly by the dtor in the derived class.
//
class Query_base {
  friend class Query;

  protected:
    using line_no = TextQuery::line_no;
    virtual ~Query_base() = default;

  private:  // [interface]
    virtual QueryResult eval( const TextQuery& ) const = 0;
    virtual std::string rep() const = 0;
};

class WordQuery: public Query_base {
  friend class Query;

  WordQuery( const std::string &s ): query_word(s) {}

  QueryResult eval( const TextQuery &t ) const { return t.query(query_word); }
  std::string rep() const { return query_word; }
  std::string query_word;
};

<not>
class NotQuery: public Query_base {
  // make a function friend
  friend Query operator~(const Query &);

  NotQuery( const Query &q ): query(q) {}

  // concrete class
  QueryResult eval( const TextQuery &t ) const;
  
  // [DN] This ultimately makes a virtual call to rep because query.rep() is nonvirtual call but
  // Query::rep in turn calls q->rep, which is virtual call through its Query_base pointer. However,
  // see that there is NO public interface in implementation class hierarchy and virtual funcs does
  // work for this case even if this is private.
  //
  // Query::rep()
  //  -> q->rep()
  //     ORQ::rep()
  //        -> lhs.rep(); Query::rep()
  //                       -> q->rep()
  //                          ANDQ::rep()
  //                             -> lhs.rep(); Query::rep()
  //                                            -> q->rep()
  //                                               WQ::rep()
  //
  std::string rep() const { return "~(" + query.rep() + ")"; }

  Query query; // [DN]
};

o [DN] The return Query type and [implicitly] uses Query ctor that takes the shared_ptr so this is
equivalent to:

o Here used Query( std::shared_ptr<Query_base> query )

shared_ptr<Query_base> tmp(new NotQuery(expr));
return Query(tmp);

inline Query operator~(const Query &operand)
{ return std::shared_ptr<Query_base>( new NotQuery(operand)); }

<binary-query>
// ABC and do not define eval().
//
class BinaryQuery : public Query_base {
  protected:
    BinaryQuery( const Query &l, const Query &r, std::string s ):
      lhs(l), rhs(r), opSym(s) {}

    // [DN] This ultimately makes a virtual call to rep.
    std::string rep() const 
      { return "(" + lhs.rep() + " " + opSym + " " + rhs.rep() + ")"; }

    Query lhs, rhs;  // [DN]
    std::string opSym;
};

<and>
class AndQuery : public BinaryQuery {
  friend Query operator&( const Query&, const Query& );     // to use ctor

  AndQuery( const Query &left, const Query &right ):
    BinaryQuery( left, right, "&") {}

  QueryResult eval(const TextQuery&) const;
};

inline Query operator&( const Query &lhs, const Query &rhs )
{ return std::shared_ptr<Query_base>( new AndQuery(lhs, rhs) ); }

<or>
class OrQuery : public BinaryQuery {
  friend Query operator|( const Query&, const Query& );     // to use ctor

  OrQuery( const Query &left, const Query &right ):
    BinaryQuery( left, right, "|") {}

  QueryResult eval(const TextQuery&) const;
};

inline Query operator|( const Query &lhs, const Query &rhs )
{ return std::shared_ptr<Query_base>( new OrQuery(lhs, rhs) ); }


{class-definition} {forward-declaration}
Primers p279.

struct Sales_data { /* ... */ };
Sales_data accum, trans, *salesptr;

The semicolon marks the end of the (usually empty) list of declarators. It is a common mistake among
new programmers to forget the semicolon at the end of a class definition.

This declaration, sometimes referred to as a <forward-declaration>, introduces the name Screen into
the program and indicates that Screen refers to a class type. After a declaration and 'before' a
definition is seen, the type Screen is an <incomplete-type>-it is known that Screen is a class type
but not known what members that type contains.

<limited-use>
We can use an incomplete type in only limited ways: We can define pointers or references to such
types, and we can declare (but not define) functions that use an incomplete type as a parameter or
return type.

A class must be defined-not just declared-before we can write code that creates objects of that
type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the
class must be defined before a reference or pointer is used to access a member of the type. After
all, if the class has not been defined, the compiler cannot know what members the class has.

In sum, two problems when use incomplete type, that is a compiler don't know the class(type) layout:

o cannot create object
o cannot defines funcs using return or params of incomplete type.

In this example, cannot create temp return object.


{missing-declaration}
For this cases, similar errors happens:

/src/main.c: In function '_terminate':
/src/main.c:91:8: error: dereferencing pointer to incomplete type
/src/main.c:92:21: error: dereferencing pointer to incomplete type


{typedef-errors}
<error-case>
struct List;         // 7

typedef struct node
{
  EntryType 	entry;
  node*			pnext;
  List*     plist;
} Node;

typedef struct {
   int   count;
	Node*	header;
} List;              // 19

gen-list-linked.cpp:19:3: error: conflicting declaration ‘typedef struct List List’
gen-list-linked.cpp:7:8: error: ‘struct List’ has a previous declaration as ‘struct List’

<okay-case>
struct list;

typedef struct node
{
	EntryType 	entry;
	node*			pnext;
  list*     plist;
} Node;

typedef struct list {
   int   count;
	Node*	header;
} List;


==============================================================================
*kt_dev_lang_011*	literal type

To specify the type of a literal. Primus p40.

{char-and-char-string-literals}

<prefix>    meaning          type
u           unicode 16 char  char16_t
U           unicode 32 char  char32_t
L           wide char        wchar_t
u8          utf-8            char

L'a'
u8"hi!"


{integer-literals}

<suffix>    minimum type
u/U         unsigned
l/L         long
ll/LL       long long

42ULL       // unsigned long long


{floating-literals}

<suffix>    type
f/F         unsigned
l/L         long double

3.14159L    // long double


={============================================================================
*kt_dev_lang_012*	pointer and array

{pointer}
A pointer is a 'variable' that contains the address of a variable. The unary operator * is the
indirection or dereferencing operator; when applied pointer, it accesses the object the pointer
points to. The declaration of the pointer ip is intended as a mnemonic:

int *ip;

It says that the expression *ip is an int. *ip is used as an 'ordinary' int variable. note the
implication that a pointer is constrained to point to a particular kind of object: every pointer
points to a specific data type. There is one exception: a pointer to void is used to hold any 'type'
of pointer but 'cannot' be dereferenced itself.

++*ip;
(*ip)++;

The parentheses are necessary in the second example. note that ANSI C explains "without them, the
expression would increase ip instead of what it points to, because unary operators like * and ++
associate right to left." However, in C++, postfix ++ has higher precedence. The both has the same
result. note that this effect used in strcpy example. 

*p++ = val;    // push val onto stack
val = *--p;    // pop top of stack into val

Here *--p decrements p before fetching the character that p points to.

whether variable is a object or what pointer points to, this is an write operation to a memory.
variable = xxx; 

whether variable is a object or what pointer points to, this is an read operation(fetch) from a
memory.  
xxx = variable;

{call-by-value-and-reference}
C passes arguments to function by value.

swap( a, b );

void swap(int x, int y)
{
  int temp;

  temp = x;
  x = y;
  y = temp;
}

swap( &a, &b );

void swap(int *x, int *y)
{
  int temp;

  temp = *x;
  *x = *y;
  *y = temp;
}

TODO: C++ reference example

{pointer-and-array}
An array is a data structure that is similar to the library vector type but offers different
trade-off. Like vector, is a container of unnamed object of a 'single' type. Unlike vector, has
'fixed' size. That run-time advantage comes at the cost of lost flexibility.

In C++ pointers and arrays are closely interwined. The elements in an array are objects. When
subscript an array, the result is the object at that location in the array. Array has special
property. the compiler automatically substitute array(name) with a pointer to the first element.
<ansic> said the name of array is a 'synonym' for the location of the initial element.

string name[] = {"one", "two", "three"};
string* p = &name[0];   // same
string* p = name;       // same

This means that operations on array are really operations on pointers.

<from-ansic>
In short, an array-and-index expression is equivalent to one written as a pointer and offset. The
pointer version will in general be faster. There is one difference between an array name and a
pointer that must be kept in mind. A pointer is variable but array name is 'not' a variable. However
when pass an array to a function call as a argument? This is a variable.
        
a[i] can also be written as *(a+i)

int a[10]; int *pa;

pa = a; pa++;     // okay
a = pa; a++;      // yako

<void-pointer>
Any pointer can be cast to void* and back again without loss of information.

<null-pointer>
C gurantees that zero is never a valid address for data. Pointer and integers are not
interchangeable but zero is the sole exception. NULL symbolic constant.

<off-the-end>
Pointer arithmetic or comparison is 'undefined' when use pointers that do not point to members of
the same array. There is one exception: the address of the first element past the end of an array
can be used in pointer arithmetic.

<string-constant>
char amessage[] = "now is the time";
char *pmessage = "now is the time";

The important difference is that amessage is an array that is 'initialised' with string constant.
Individual characters may be changed. On the other hand, pmessage is a pointer, initialised to point
to a string constant and can be modified but undefined if you try to modify the string contents.

<defining-array>
An array declarator has the form a[d], where a is the name and d is the dimension. Note that the
number of elements in an array is part of the array's type so must be known at compile time. That
means the dimension is constant expression.

<array-subscript>
For library types such as string and vector, subscript type is size_type which is unsigned. So if
use negative value, then will be converted to the unsigned. However, for built-in array, it is not
so can have negative subscript.

int *p = &ia[2];
int j = p[1];
int k = p[-2];

<array-init>
int a3[5] = { 0, 1, 2 }; 	// { 0, 1, 2, 0, 0 } since value-init the rest
int a4[11] = {};				// { 0,...0 } since value-init all

<complicated-array-declaration>
int arr[6];

arr     0        5
[ ] -> [ ][ ]...[ ]

Here arr, &arr[0], &arr have the same address and arr type is int(*arr)[6]. Note that this is
similar to function pointer definition. The size is part of type, that is, int(&)[10] in the
following case. The parentheses are needed and read from inside to outside. 

int (&arrRef) [ 10 ] = arr;	// refers to an array of ten ints

the reference param is bound to the corresponding arg

void print( int (&arr) [ 10 ])
{
	for( auto elem : arr )
		cout << elem << endl;
}

This could also means the first low of multidimensional array and the both are the same.

void print( int (*matrix)[10], int rowsize );
void print( int matrix[][10], int rowsize );

<complicated-array-type>
As seen above, array arr type is int(*)[6]. Likewise, state_list is **.

typedef struct fsm_instance {
   char*              name;
   fsm_state_t**      state_list;
   fsm_event_t*       event_list;
   fsm_state_t*       current_state;
   fsm_state_t*       previous_state;
} fsm_instance_t;

static Fsm::fsm_state_t* bootStateList[] = {
  &stateClosed,
  ...
  FSM_INVALID_STATE
};

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

fsm_instance fsm = { "...", &bootStateList, &bootEventList, ... };


{article}
Difference between char *a and char a[]

char * and char [] both are used to access character array, Though functionally both are same, they
are syntactically different. See how both works in order to access string.  

A. How char a[] works?

Consider following example for storing and accessing string using character array -

char a[] = "HELLO";

In the example string "Hello" is stored in character array 'a'. Character array is used to store
characters in 'contiguous' memory location. It will take following form after 'initialization'. We
have not specified array size in this example. Each array location will get following values -

a[0] = 'H'
a[1] = 'E'
a[2] = 'L'
a[3] = 'L'
a[4] = 'O'
a[5] = '\0'

It will Looks Like This
array a :  H    E    L    L    O '\0'
         a[0] a[1] a[2] a[3] a[4]


Accessing Individual Element :
Suppose we have to find out a[3] then firstly compiler will check whether ‘a’ is array or pointer.
If ‘a’ is array variable then it starts at the location 'a', goes three elements past it, and
returns the character there. In this method element is accessed sequentially

B. How char *a works?

String "Hello" will be stored at any Anonymous location in the form of array. We even don't know the
location where we have stored string, However string will have its starting address. Syntax of char
*a :

char *a = "HELLO";

the above syntax will take following form -

pointer a :  H    E    L    L    O '\0'
           a[0] a[1] a[2] a[3] a[4]
           anonymous array

We have declared pointer of type character i.e pointer variable is able to hold the address of
character variable. Now Base address of anonymous array is stored in character pointer variable. 'a'
Stores Base Address of the Anonymous Array [Unknown Array]

Address = [Base Address of Anonymous Array]  + [i]

Accessing Individual Element :

Consider we have to access a[3] then -
In short if 'a' is a pointer, it starts at the location “a”, gets the pointer value there, adds 3 to
the pointer value, and gets the character pointed to by that value. In both cases a[3] returns same
character but procedure is different.


{c-string}
int main(int argc, char* argv[])
{
  //char *str1 = "\n";
  //char *str2 = "";
  //char *str3 = "one";

  char str1[] = "\n"; 
  // note: '\n' is character constant(single character) and "\n" is s string constant 
  char str2[] = ""; 
  char str3[] = "one"; 

  printf("size is %d\n", sizeof(str2));
  printf("size is 0x%x\n", '\n');
}

(gdb) p str1
$1 = "\n"
(gdb) p str2
$2 = ""
(gdb) p str3
$3 = "one"

(gdb) p /x str1
$4 = {0xa, 0x0}
(gdb) p /x str2
$5 = {0x0}
(gdb) p /x str3
$6 = {0x6f, 0x6e, 0x65, 0x0}
(gdb) 


{pointers-are-iterator}
Like, off-the-end iterator, can use off-the-end pointer which is the address of the 'nonexistent'
element one past the last element of an array. note that just take address but not element(not
access it). So must not derefernce or increment an off-the-end pointer.

int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

int* e = &arr[10];

for( int* b = arr; b != e; ++b )
   cout << *b << endl;

<begin-and-end-function> <std::begin>
Said defined in iterator header but do not need to include to use and easy to write C++ loop.

int* pbeg = begin(arr), *pend = end(arr);

for( pbeg; pbeg != pend && *pbeg > = 0; ++pbeg )
  ...;

{difference-between-arr-and-parr}
int main () {

  int arr[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int* parr = new int[100];

  std::vector<int> ivec( std::begin(arr), std::end(arr) );     // 1
  std::vector<int> ivec( std::begin(parr), std::end(parr) );   // 2
  std::vector<int> ivec( std::begin(*parr), std::end(*parr) ); // 3
  
  return 0;
}

The "1" is okay but this "2" and 3 causes an error:

sam01.cpp:14:41: error: no matching function for call to ‘begin(int*&)’
sam01.cpp:14:41: note: candidates are:
/usr/include/c++/4.6/bits/range_access.h:48:5: note: template<class _Container> decltype (__cont.begin()) std::begin(_Container&)
/usr/include/c++/4.6/bits/range_access.h:58:5: note: template<class _Container> decltype (__cont.begin()) std::begin(const _Container&)
/usr/include/c++/4.6/bits/range_access.h:87:5: note: template<class _Tp, unsigned int _Nm> _Tp* std::begin(_Tp (&)[_Nm])
/usr/include/c++/4.6/initializer_list:86:5: note: template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)

Why? std::begin shall work with array? Array is different from block of memory. Here are the libary
implementation:

/usr/include/c++/4.6/bits/range_access.h:87:5:

/**
 *  @brief  Return an iterator pointing to the first element of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  begin(_Tp (&__arr)[_Nm])    // Note see the size
  { return __arr; }

/**
 *  @brief  Return an iterator pointing to one past the last element
 *          of the array.
 *  @param  arr  Array.
 */
template<class _Tp, size_t _Nm>
  inline _Tp*
  end(_Tp (&__arr)[_Nm])
  { return __arr + _Nm; }

<1> Array is 'sized' data structure and size is known at compile time and can be used implicitly.
<2> Array is different.

char parray[] = "this is sample string";
char *pnew = "this is sample string";

printf("0: %0x 1: %0x \n", &parray, &parray[0] );
printf("0: %0x 1: %0x \n", &pnew, &pnew[0] );

0: bfc09896 1: bfc09896
0: bfc09890 1: 80489c5 

<3> decltype seems return char * for both but typeid are different. Why?
decltype( parray ) x;
decltype( pnew ) x;

tid: A22_c  // parray
tid: Pc     // pnew

Since the special conversion in array do not happen when use decltype. Really? YES.

decltype(arr) x = 100;

$ ./comp.sh sam01.cpp 
sam01.cpp: In function ‘int main()’:
sam01.cpp:13:21: error: array must be initialised with a brace-enclosed initialiser

decltype(arr) x;
int y = x;

$ ./comp.sh sam01.cpp 
sam01.cpp: In function ‘int main()’:
sam01.cpp:14:11: error: invalid conversion from ‘int*’ to ‘int’ [-fpermissive]

<4> sizeof see {sizeof-operator} for more
cout << "size: " << sizeof(arr) << endl;
cout << "size: " << sizeof(parr) << endl;
cout << "size: " << sizeof(*parr) << endl;

size: 40
size: 4
size: 4


{pointer-array}
From ansic, given the definitions:

int a[10][20];
int *b[10];

then a[3][4] and b[3][4] are 'both' syntactically legal references to a single int. The a is a true
two dimensional array; 200 int-sized locations have been set aside. For b, however, only allocates
10 pointers.

The important advantage of the pointer array is that the rows of the array may be of different
length. So can be one int or array of int. In other words, int *b[10], int **b[10], int ***b[10] are
the same.

char *names[] = { "Illegal month", "Jan", "Feb", "Mar" };
char names[][15] = { "Illegal month", "Jan", "Feb", "Mar" };

<example-from-ansic>
p116 and example of option handling such as:

find -x -n pattern
find -xn pattern

int main(int argc, char* argv[])
{
  int c;

  // <1>
  while( --argc > 0 && ((*++argv)[0] == '-' ))
      while( c = *++argv[0] ) 
        printf("%c\n", c );

  // <2> not okay
  while( --argc > 0 && ((*++argv)[0] == '-' ))
    while( c = (*++argv)[1] ) 
      printf("%c\n", c );

  // <3>  not okay
  while( --argc > 0 && ((*++argv)[0] == '-' ))
    while( c = argv[1] ) 
      printf("%c\n", c );
}

In <1>, argv is a pointer variable to a array but not array name so can increase it. so (*++argv)[0]
is the first character of argv[1]. Alternative be **++argv.

while( --argc > 0 && ((*++argv)[0] == '-' ))    // -
    while( c = *++argv[0] )                     // x or n
      printf("%c\n", c );

The *++argv[0] increments the pointer argv[0] but not argv itself.

(gdb) p argv
$5 = (char **) 0xbffff358
(gdb) p *argv
$6 = 0xbffff4f1 "-nx"


{pointer-conversion}
Done by compiler and the followings are the same.

void print( const int* );
void print( const int[] );
void print( const int[10] );


{sizeof-operator}
Queries size of the 'object' or type. Used when actual size of the object must be known: 

sizeof( type ) 		
sizeof expression 		

Both versions return a constant of type std::size_t.

Explanation

1) returns size in bytes of the object representation of type.
2) returns size in bytes of the object representation of the type, that would be returned by
expression, if evaluated.  

1. Depending on the computer architecture, a byte may consist of 8 or more bits, the exact number being
recorded in CHAR_BIT.

2. sizeof(char), sizeof(signed char), and sizeof(unsigned char) always return 1.

3. Cannot be used with function types, incomplete types, or bit-field lvalues.

4. When applied to a reference type, the result is the size of the referenced type.

5. When applied to a class type, the result is the size of an object of that class [plus] any
additional padding required to place such object in an array.

6. When applied to an empty class type, always returns 1. 

<sizeof-operator-caveat>
int func()
{
  int arr[] = { ... };
  int length= sizeof(arr)/sizeof(int);
  ...
}

This works fine as expected; sizeof(array) returns a size of an array, but if you pass array in
func, it is converted to a pointer and the return of sizeof is the size of pointer but not the
array.

int func(int arr[])
{
  int length = sizeof(arr)/sizeof(int)-1; note: THIS DOESN'T WORK!
  ...
}

Why? {difference-between-arr-and-parr} explains.

<sizeof-to-get-string-length>
int main()
{
  std::cout << "length is " << sizeof("DSM:!") << std::endl;
  std::cout << "length is " << strlen("DSM:!") << std::endl;
  std::cout << "length is " << sizeof("") << std::endl;
  std::cout << "length is " << strlen("") << std::endl;
}

length is 6
length is 5
length is 1
length is 0

The strlen() function calculates the length of the string s, [excluding] the terminating null byte
('\0'). In other words, strlen knows about a c string but sizeof do not. Hence sizeof returns +1
more. KT. sizeof is better since it is not a func call and done in compile.


={============================================================================
*kt_dev_lang_013*	allman style

{allman-style}
The Allman style is named after Eric Allman. It has been incorrectly referred to as "ANSI style"
supposedly for its use in the documents describing the ANSI C standard; later adopted as the ISO C
international standard, though in fact those documents use K&R style. It is also sometimes known as
"BSD style" since Allman wrote many of the utilities for BSD Unix although this should not be
confused with the different "BSD KNF style"; see below.

This style puts the brace associated with a control statement on the next line, indented to the same
level as the control statement. Statements within the braces are indented to the next level.

while (x == y)
{
    something();
    somethingelse();
}
 
finalthing();

This style is similar to the standard indentation used by the Pascal programming language and
Transact-SQL, where the braces are equivalent to the begin and end keywords.

Suggested advantages of this style are that the indented code is clearly set apart from the
containing statement by lines that are almost completely whitespace and the closing brace lines up
in the same column as the opening brace. Some people feel this makes it easy to find matching
braces. Additionally, the blocking style delineates the actual block of code from the associated
control statement itself. Commenting out the control statement, removing the control statement
entirely, refactoring, or removing of the block of code is less likely to introduce syntax errors
because of dangling or missing braces. Furthermore, it's consistent with brace placement for the
outer/function block.

For example, the following is still syntactically correct:

//while (x == y)
{
    something();
    somethingelse();
}

As is this:

//for (int i=0; i < x; i++)
//while (x == y)
if (x == y)
{
    something();
    somethingelse();
}

Even like this, with conditional compilation:

char c;
#ifdef HAS_GETCH
while ((c = getch()) != EOF)
#else
while ((c = getchar()) != EOF)
#endif
{
    do_something(c);
}

{k-and-r-style}
The K&R style, so named because it was used in Kernighan and Ritchie's book The C Programming
Language, is commonly used in C. It is also used for C++, C#, and other curly brace programming
languages.

When adhering to K&R, each function has its opening brace at the next line on the same indentation
level as its header, the statements within the braces are indented, and the closing brace at the end
is on the same indentation level as the header of the function at a line of its own. The blocks
inside a function, however, have their opening braces at the same line as their respective control
statements; closing braces remain in a line of their own, unless followed by an else or while
keyword.

In this style a control statement with only a single statement in its scope may omit the braces. The
C Programming Language refers to this as fertile soil for bugs (programming logical errors) and
discourages it.

int main(int argc, char *argv[])
{
    ...
    while (x == y) {
        something();
        somethingelse();
 
        if (some_error) {
            /* the curly braces around this code block could be omitted */
            do_correct();
        } else
            continue_as_usual();
    }
 
    finalthing();
    ...
}


{type-declaration}

<1>
Foo *msg1, *msg2;

Foo& Foo::operator=( Foo &rhs )
{
  ...
}

<2>
Foo* msg1, *msg2;

Foo& Foo::operator=( Foo& rhs )
{
  ...
}


={============================================================================
*kt_dev_lang_014*	interesting codes

{1} The format argument of printf can be an expression too.
printf((argc>1) ? "%s " : "%s", *++argv );

{2} printf-format
int main()
{
  char *pmesg = "0123456789";

  printf("0: %.*s \n", 2, pmesg );
  printf("0: %.*s \n", 3, pmesg );
  printf("0: %.*s \n", 4, pmesg );
  printf("0: %.*s \n", 5, pmesg );
  printf("0: %.*s \n", 6, pmesg );
}

kit@kit-vb:~/work$ ./a.out
0: 01
0: 012
0: 0123
0: 01234
0: 012345

The precision
An optional precision, in the form of a period ('.') followed by an optional decimal digit string.
Instead of a decimal digit string one may write "*" or "*m$" (for some decimal integer m) to specify
that the precision is given in the next  arguâ€ ment,  or in the m-th argument, respectively, which
must be of type int.  If the precision is given as just '.', or the preciâ€ sion is negative, the
precision is taken to be zero.  This gives the minimum number of digits to appear for d, i, o, u, x,
and X conversions, the number of digits to appear after the radix character for a, A, e,
E, f, and F conversions, the maximum numâ€ ber of significant digits for g and G
conversions, or the maximum number of characters to be printed from a string for s and S
conversions.

MHEGDebugDebug(eMHEGengRuntime,"OS-OctetStringVariable Append %.*s, %.*s -> %.*s\n",
              (OctetStringVariableEntry(pEntry).m_osValue).size,
              (OctetStringVariableEntry(pEntry).m_osValue).buf,
              osValue.size, osValue.buf,
              osNewValue.size, osNewValue.buf);

{3} print unsigned long value

printf("ulong max from limits: %luL\n", ULONG_MAX );


={============================================================================
*kt_dev_lang_015*	statement, control flow {division-and-modulus}

{division-and-modulus}
The division truncate the remainder and modulus(%) operator.

// plus to grade ending in 8 0r 9 and minus to grade ending in 0, 1, or 2.
const vector< string > scores = { "F", "D", "C", "B", "A", "A++" };

string lettergrade;

if( grade < 60 )
	lettergrade = score[0];
else
{
	lettergrade = score[ (grade-50)/10 ];
	if( grade % 10 > 7 )
		lettergrade += '+';
	else if( grade%10 < 3 )
		lettergrade += '+';
}


{switch}
To emphasize that the cases represent a range of values:

switch(ch)
{
	case 'a': case 'e': case 'i': case 'o': case 'u':
		...
	break;
}

It can be useful to define a default label even if there is no work for the case to indicate that
the case was considered.

<switch-under-the-hood>
http://stackoverflow.com/questions/3012011/switch-case-assembly-level-code

Here is the C source:

switch(i)
{
    case 1:
    {
        printf("Case 1\n");
        break;
    }
    case 2:
    {           printf("Case 2\n");
        break;
    }
    case 3:
    {
        printf("Case 3\n");
        break;
    }
    case 4:
    {
        printf("Case 4\n");
        break;
    }
	 // omitted to 10:
    default:
    {
        printf("Nothing\n");
        break;
    }
}  

Now the resultant assembly for the same is:

movl    $5, -4(%ebp)
cmpl    $10, -4(%ebp)
ja  L13
movl    -4(%ebp), %eax
sall    $2, %eax
movl    L14(%eax), %eax
jmp *%eax
.section .rdata,"dr"
.align 4
L14:
.long   L13
.long   L3
.long   L4
.long   L5
.long   L6
.long   L7
.long   L8
.long   L9
.long   L10
.long   L11
.long   L12
.text
L3:
movl    $LC0, (%esp)
call    _printf
jmp L2
L4:
movl    $LC1, (%esp)
call    _printf
jmp L2
L5:
movl    $LC2, (%esp)
call    _printf
jmp L2
L6:
movl    $LC3, (%esp)
call    _printf
jmp L2
L7:
movl    $LC4, (%esp)
call    _printf
jmp L2
L8:
movl    $LC5, (%esp)
call    _printf
jmp L2
L9:
movl    $LC6, (%esp)
call    _printf
jmp L2
L10:
movl    $LC7, (%esp)
call    _printf
jmp L2
L11:
movl    $LC8, (%esp)
call    _printf
jmp L2
L12:
movl    $LC9, (%esp)
call    _printf
jmp L2
L13:
movl    $LC10, (%esp)
call    _printf
L2:  



First the code is comparing the i to 10 and jumping to the default case when the value is greater
then 10 (cmpl $10, -4(%ebp) followed by ja L13). The next bit of code is shifting the input to the
left by two (sall $2, %eax) which is the same as multiple by four (it multiplies by 4 because each
entry in the jump table is 4 bytes long). So what is had done here is generated an offset into
the jump table. It then loads an address from the jump table (movl L14(%eax), %eax) and jumps to it
(jmp *%eax).

The jump table is simply a list of addresses (represented in assembly code by labels):

L14:
.long   L13
.long   L3
.long   L4
...

One thing to notice is that L13 represents the default case. It is both the first entry in the jump
table (for when i is 0) and is handled specially at the beginning (when i > 10).

<01>
@puffadder: most modern compilers use heuristics to determine when it's more efficient to use
branches versus a jump table. E.g. if your case levels were say 1, 100 and 1000 you might expect
branches to be used. –  Paul R Jun 10 '10 at 7:07 

<02>
You have a switch statement with 5 case statements and the cases all have numbers that are spread
far apart so a jump table will not be used, 'if type' will. {Q} May choose not to use a jump table
because there will be entries which are not used? Up to a compiler?

<switch-grouping>

typedef enum {
  E_01,    //
  E_02,
  E_03,
  E_11,    //
  E_12,
  E_13,
  E_21,    //
  E_22,
  E_23,
  E_31,    //
  E_32,
  E_33
} EVENTS;

typedef enum {
  E_G00, E_G01, E_G02, E_G03, E_GNO
} GROUPS;

int getEventGroup( int events )
{
  switch( events )
  {
    case E_01: case E_02: case E_03:
      return E_G00;
      break;
      ...

    default:
        return E_GNO;
        break;
        std::cout << "IS IT EXECUTED?? " << events << std::endl;
  }
}

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( getEventGroup(events) )
    {
      case E_G00:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

OR

int main()
{
  int events = E_11;

  while( cin >> events )
  {
    switch( events )
    {
      case E_01: case E_02: case E_03:
        std::cout << "E_G00" << std::endl;
        break;

        ...

      case E_GNO:
          std::cout << "E_GNO" << std::endl;
          break;

      default:
          std::cout << "E_?? " << events << std::endl;
          break;
    }
  }
}

The both do the same. The second is a bit clearer at the expense of one function call?


<does-it-work>
Found it in the real code. Does the line after default get executed? NO.

switch( events )
{
  case E_01: case E_02: case E_03:
    ...
      break;
  default:
    return E_GNO;
    break;
    std::cout << "IS IT EXECUTED?? " << events << std::endl;
}


{for-vs-while}
<exercise> 
From ansic, exercise 3-2. Write a function escape(s,t) that converts characters like newline and tab
into visible escape sequences like \n and \t as it copies the string t to s . Use a switch . Write a
function for the other direction as well, converting escape sequences into the real characters.

// mine to show idea
void escape(char* s, char* t)
{
  // while( *t++ )
  while( *t )
  {
    switch(*t)
    {
      case '\t':
        *s++ = '\\';    // note
        *s++ = 't';
        break;

      default:
        *s++ = *t;
        break;
    }

    t++;
  }
  
  *s = '\0';
}

When use "while(*t++)", the result missed out the first char. Why? When think about strcpy:

void strcpy( char *s, char *t )
{
	 while( *s++ = *t++ ) 
		  ;
}

while(expression)
  statement

"If expression is non-zero, statement is executed and expression is re-evaluated." So in strcpy,
copied by evaluating and increased by the side effect. Not used in statement.

<ansic-example>
The for is preferable when there is a simple initialization and increment since it keeps the loop
control statement 'close''together' and visiable at the top of the loop.

// atoi second version p61
#include <ctype.h>

int atoi(char s[])
{
  int i, n, sign;

  // skip white spaces
  for(i = 0; isspace( s[i] ); i++)
    ;

  sign = (s[i] == '-') ? -1 : 1;

  // skip sign
  if( s[i] == '+' || s[i] == '-' )
    i++;

  for(n = 0; isdigit( s[i] ); i++)
    n = n+10 + (s[i]-'0');

  return sign*n;
}


{comma-operator}
The comma operator is a sequence point (as they are && and ||) so the order of evaluation of the
operands is {fixed}. It is a binary operator that evaluates its first operand, performs all side
effects and discards the result, and then evaluates the second operand and returns its value.

Any number of expressions separated by commas can form a single expression because the comma
operator is associative. The use of the comma operator guarantees that the subexpressions will be
evaluated in left-to-right order, and the value of the last becomes the value of the entire
expression. type so:

x = (y, z);

will do y and, after performing all side effects, will discard it, then do z and finally will set x
to z.

Because the comma operator discards its first operand, it is useful where the first operand has
<desirable-side-effects>, such as in the initializer or the counting expression of a for loop. Used
to produce side effects.

For example, this for statement:

for( p=0; p+=(a&1)*b,a!=1; a>>=1,b<<=1 )
   ...

can be re-written:

p=0;
p+=(a&1)*b;
while (a!=1) {
    ...
    a>>=1;
    b<<=1;
    p+=(a&1)*b;
}

The primary use of the comma operator is to 'produce' side effects in the following situations:

Calling a function
Entering or repeating an iteration loop
Testing a condition
Other situations where a side effect is required but the result of the expression is not immediately needed

for (i=0; i<2; ++i, f() ); 	

A for statement in which i is incremented and f() is called at each iteration.

if ( f(), ++i, i>1 ) { /* ... */ } 	

An if statement in which function f() is called, variable i is incremented, and variable i is tested
against a value. The first two expressions within this comma expression are evaluated before the
expression i>1. Regardless of the results of the first two expressions, the third is evaluated and
its result determines whether the if statement is processed.

func( ( ++a, f(a) ) ); 	

A function call to func() in which a is incremented, the resulting value is passed to a function
f(), and the return value of f() is passed to func(). The function func() is passed only a single
argument, because the comma expression is enclosed in parentheses within the function argument list.

<ansic-example> p62

#include <string.h>

void reverse(char s[])
{
  int c, i, j;

  for( i = 0, j = strlen(s)-1; i < j; i++, j-- )
  {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}

Suitable when strongly related to each other and the exchange can be 'thought' of as a single
operation.

void reverse(char s[])
{
  int c, i, j;

  for( i = 0, j = strlen(s)-1; i < j; i++, j-- )
    c = s[i], s[i] = s[j], s[j] = c;
  }
}

# ============================================================================
#{ CPP
={============================================================================
*kt_dev_cpp_000*	operator-precedence

http://en.cppreference.com/w/cpp/language/operator_precedence

The following table lists the precedence and associativity of C++ operators. Operators are listed
top to bottom, in descending precedence. Where no associativity follows the above one.

Precedence 	Operator 	Description 	Associativity

1 	:: 		Scope resolution 												Left-to-right
 ----------------------------------------------------------------------------
2 	++   -- 				[Postfix] increment and decrement					(same as)
   () 					Function call
   [] 					Array subscripting
   . 						Element selection by reference
   -> 					Element selection through pointer
 ----------------------------------------------------------------------------
3 	++   -- 				[Prefix] increment and decrement				Right-to-left
   + 	- 					Unary plus(+) and minus(-)
	!   ~ 				Logical NOT and bitwise NOT
	(type) 				Type cast
	* 						Indirection (dereference)
	& 						Address-of
	sizeof 				Size-of
	new, new[] 			Dynamic memory allocation
	delete, delete[] 	Dynamic memory deallocation
 ----------------------------------------------------------------------------
4 	.*   ->* 	Pointer to member 										Left-to-right
 ----------------------------------------------------------------------------
5 	*   /   % 	Multiplication, division, and remainder
 ----------------------------------------------------------------------------
6 	+ - 			Addition(+) and subtraction(-)
 ----------------------------------------------------------------------------
7 	<<   >> 		Bitwise left shift and right shift
 ----------------------------------------------------------------------------
8	< 	<= 		For relational operators < and <= respectively
	>   >= 		For relational operators > and >= respectively
 ----------------------------------------------------------------------------
9 	==   != 		For [relational] = and != respectively
 ----------------------------------------------------------------------------
10	& 				Bitwise AND
 ----------------------------------------------------------------------------
11	^ 				Bitwise XOR (exclusive or)
 ----------------------------------------------------------------------------
12	| 				Bitwise OR (inclusive or)
 ----------------------------------------------------------------------------
13	&& 			Logical AND
 ----------------------------------------------------------------------------
14	|| 			Logical OR
 ----------------------------------------------------------------------------
15	?: 				Ternary conditional 									Right-to-left
  	= 					Direct [assignment] (provided by default for C++ classes)
  	+= -= 			Assignment by sum and difference
  	*=   /=   %= 	Assignment by product, quotient, and remainder
  	<<=   >>= 		Assignment by bitwise left shift and right shift
  	&=   ^=   |= 	Assignment by bitwise AND, XOR, and OR
 ----------------------------------------------------------------------------
16 throw 			Throw operator (for exceptions)
 ----------------------------------------------------------------------------
17 , 					Comma 													Left-to-right 


{side-effect} <evaluation-order>
An expression, such as 'ival+5' becomes an expression statement when it is followed by a semicolon.
An expression statement contains an expression that has a side-effect-such as assigning a new value
or printing a result-when it is evaluated.

From ansic, p53. C do not specify the 'order' in which the operands of an operator are evaluated. 

x = f() + g();                         // f may be evaluated before g or vice versa

Function calls, nested assignment statements, and increment and decrement operators
cause "side effect" - some variable is changed as a by-product of the evaluation of an expression.
In any expression involving side effects, there can be subtle dependencies on the 'order' in which
variables taking part in the expression are updated.

printf("%d %d\n", ++n, power(2, n));   // WRONG

a[i] = i++;

When side effects take place is left to discretion of the compiler, since the best order depends
strongly on machine architecture.


{operator-unary}
The unary negation operator ! converts a non-zero operand into 0 and a zero operand into 1. A common
use of ! is in constructions like:

if(!valid) rather then if(valid==0)

<exercise>
From ansic, exercise 2-2. Write a loop equivalent to the for loop above without using && or ||.

for(i=0; i<lim-1 && (c=getchar()) != '\n' && c != EOF; ++i)
   s[i] = c;

##
# 01

while (i < (lim - 1))
{
  c = getchar();

  if (c == EOF)
    break;
  else if (c == '\n')
    break;

  s[i++] = c;
}

##
# 02

for(i=0; i<lim-1 ? (c=getchar()) != '\n' ? c != EOF : 0 : 0; ++i)
   s[i] = c;


{operator-assign}
The operator "+=" is called "assignment operator" and most binary operators have a corresponding
assignment operator "op=", where op is + - * / % << >> & ^ |.

Notice that "expr1 op= expr2" is equivalent to "expr1 = (expr1) op (expr2)" and notice that () around
expr since:

x *= y + 1; means x = x * ( y + 1 ); rather than x = x * y + 1;

Notice that "assignment statement" is: c = getchar(); and the 'type' of an assignement expression is
the type of its left operand in case of assignement operator. The point is that expresssion has a
'type'.


{operator-conditional}
The conditional expression often leads to succint code.

Prints newline after every 10th element and after n-th and blank for all other elements.

for( i = 0; i < n; i++ )
   printf("%6d%c", a[i], (i%10==9 || i==n-1) ? '\n' : ' ' );


printf("You have %d item%s.\n", n, n==1 ? "" : "s" );

<exercise>
The ansic, page 52, exercise 2-10. Rewrite the function lower, which converts upper case letters to
lower case, with a conditional expression instead of if-else.

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_2:Exercise_10

the natural solution for simply making this a conditional (ternary) return instead of an if end
else. Won't work on EBCDIC machines.

/* lower: convert c to lower case; ASCII only */
int lower(int c)
{
  return c >= 'A' && c <= 'Z' ? c + 'a' - 'A' : c;
}

the more portable solution, requiring string.h for strchr but keeping the idea of a 
conditional return.  

/* lower: convert c to lower case */
int lower(int c)
{
  char *Uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char *Lowercase = "abcdefghijklmnopqrstuvwxyz";
  char *p = NULL;

  return NULL == (p = strchr(Uppercase, c)) ? c : *(Lowercase + (p - Uppercase));
}


={============================================================================
*kt_dev_cpp_001*	virtual inheritance (interview)

MI and SI (single inheritance)

The problem is that a class inherit from the same base class more than once and this means there are
more than one subobject. Then what is the real problem or consequence out of having more than one
subobject?

From C++ Primer, p810, took this example from IO library:

basic_ios (ABC) <- istream <- iostream
                <- ostream <- iostream

basic_ios holds stream's buffer and state but iostream wants to use {the same buffer and condition
state for both reading and writing}. If an iostream object has two copies of its basic_ios, {this
sharing is not possible}.

That is, in iostream, cause ambiguity and can use both data using scope specifier like istream::x
and ostream::x. so real issue is <sharing>.

To solve this, use {virtual-inheritance} and this <shared> base class is called a
{virtual-base-class}. How? makes only <one> shared subobject for that virtual base class.


class istream : 'virtual' public basic_ios {};
class istream : virtual public basic_ios {};
class iostream : public istream, public ostream {}; 

From EC++40, p193,

This problem is called {deadly-MI-diamond}. Problems? ambiguity and replication in the derived. C++
takes no position on virtual inheritance problem. (checked with VC and no errors when there's a
deadly MI diamond) and its default is to perform the replication. 

However, VI costs in size, speed and initialization problem. So recommendation is {don't use VI
unless you need to}.
 
<syntax>
Which one is right to have public inheritance from Y and Z?

class X : public Y, Z {
  ...
};

class X : public Y, public Z {
  ...
};


==============================================================================
*kt_dev_cpp_002*	reference-vs-pointer (interview)

Refer to *kt_dev_cpp_013* for example uses.

EC++20. If you peek under the hood of a C++ compiler, will find that references are typically
implemented as pointers. <KT> To this question, reference may or may not be the same as pointer. In
user level, there are differences and in compiler level, implemented as pointers. reference is a sub
set of pointer which is limited in use?


{why-reference}

o no copy made so efficient code
o syntatic need such as operator[]

{differences}

<0-0>
No null reference hence must be initialised. From MEC++01. Always refer to an object. Unlike
pointer, no need to check its validity.

void printDouble( const double& rd )
{ cout << rd; }

vs.

void printDouble( const double* pd )
{
	 if(pd)
		  cout << *pd;
}

So <efficient-code> 

<0-1>
Used operator funcs such as operator[]. {Q}

vector< T> v; v[5] = 10;

<1>
All operations on that reference are actually operations on the object to which the reference is
bound. Reference is bound <once> but for pointer, can change pointer itself and can point other
objects.

<2> 
There is no reference to a reference. but there's a pointer to a pointer. 

<3>
Reference should <match-type> and cannot bind to a literal.

int &ref = 10;                        // error
double dval = 3.14; int &ref = dval;  // error

<4>
There is no const reference but there's a const pointer because a pointer is object. Like any other
const object const pointer must be inited. Why?

In {ref-CPR}, p50: Reference is not an object. object does not mean only object of class. Reference
defines an alternative name for an object. This is called <binding> hence <must-be-initialized>

int *const cpi = &i;

Q. An object is a memory area that has type and data. given a ref isn't a object, a ref
shouldn't have an address.

int* ip; int &ri = a;
ip = &ri; ???

in VC, ip has a's address.

Q. on the same token:

struct {
	 int x; int y;
} int_str;

struct {
	 int x; int &rx = x;
} ref_str;

sizeof(int_str) == sizeof(ref_str) ??

in VC, they are the same.

It seems that a ref is a complete alias to a actual object.

<5>
No array and vector of reference.

int* ptrs[10];
int& refs[10];		// error. no arrays of ref


={============================================================================
*kt_dev_cpp_003* ctor and copy controls

{syn-operations} <behind-the-scene-code>
The following operations are synthesized by compiler if they are not defined and only if ther are
needed. These are public and inline according to EC++05.

destructor and default constructor. four copy controls which are copy ctor, copy assign, move
ctor(C++11), move assign(C++11)

However, it is not always possible since there are cases when compiler refuse to create those such as:

1) when a class has reference or const member. why not const?
2) when base class have private on syn-operations. what private?


{default-ctor} {default-init}
Recommendation on initialization. Avoid syn version and do it explicitly: in-class init(C++11) or
ctor init list. Why? because to avoid:

1) Default-init for built-in types which means uninit/undefined.
2) Compile error when there's a class member that don't have def ctor. compiler cannot syn def ctor
for this case.
3) If a class requires control to init an object in one case, then the class is likely to require
control in all cases.

Note: The ctor cannot be a 'const' member func. why? When create a const object of a class type, the
object does not assume its 'constness' until after the ctor completes the object's initialisation.
Thus, ctor can write to const objects during their construction.

The syn ctor will:

o Use in-class init if there is. Otherwise default init its member and use default ctor for its
class member.

<default-keyword>
o If there are other ctor, then compiler will not make a syn ctor. so want to force it to create
then use 'default' keyword.

note: There are cases when syn-operations are useful. See {{make-base-class-for-reference-counting}} 


{in-class-init} <C++11>
<example-one>
For window_mgr calss to start up with a single, default-inited screen.

class window_mgr {
  private:

   vector<Screen> screens{ Screen(24, 80, ' ') }; or 
   vector<Screen> screens = { Screen(24, 80, ' ') };
};

<example-two>
class T {
  T() = default;
  T(const string &s) : bookNo(s) {}
  ...
  string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

The in-class-init do like 'default values' in func args because:

T(const string &s) : bookNo(s) {}

is equivalent to:

T(const string &s) : bookNo(s), units_sole(0), revenue(0) {}


{vexing-parse}
<example-one>
From C++ concurrency in action, 2.1.1., if you pass a temporary rather than a named variable the the
syntax can be the same as that of a fuction declaration.

class background_task;
std::thread my_thread( background_task() );     // T my_thread(...);

This declars the function my_thread that takes a single parameter which is type pointer to a
function taking no parameters and returning a background_task object. However, the intention was to
create std::thread instance with function object to run.

Solution?
std::thread my_thread( (background_task()) );   // extra ()
std::thread my_thread{ background_task() };     // brace-init

<example-two>
How to default init an object?

T object;		// OK
T object();		// NO. defines a func. Do not confuse with T()

<example-three>
In real work, meant to have null string.

std::string source();
source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);

/Session.cpp:257:70: error: assignment of function 'std::string source()'
/Session.cpp:257:70: error: cannot convert 'std::string' to 'std::string()' in assignment


{constructor-and-conversion}
The constructor is one of conversion methonds. For example:

void doSomething(B bObject);
doSomething(B(28));

From {temp-object-in-return} in *kt_dev_cpp_009*
return pair<string, int>();   // T()

From {default-and-value-init} in *kt_dev_stl_019*
int* pi = new int;				// def init
int* pi = new int();				// value init. new T()


{constructor-initializers} 
ABEntry::ABEntry(...)
{
  theName = name;
  theAddress = address;
  thePhones = phones;
  numTimesConsulted = 0;
}

This is initialization and assignment but not init. init happens before ctor runs. Why use
constructor-initializers? From Primers p289 and EC++04.  

1) Avoid default-init.
2) Efficient than initialization-and-assignment.
3) By the time the body of ctor begins excuting, init is completed so there are <three> cases that~
must use ctor-init: {QUIZ}

const, reference, and class member that do not have a def-ctor.

For the last case, that is because will try to use def-ctor for class memeber data when there is no
constructor initializer but there is no def-ctor and way to init. Hence this is error. This applies
to all other cases that need a def-ctor and that's why def ctor is almost nearly required.

For example, VC shows:
Error	1	error C2512: 'NoDefCtor' : no appropriate default constructor available

<use-constructor-initializer-always>
The examples are:

ABEntry::ABEntry(...)
: theName(name),
  theAddress(address),
  thePhones(phones),
  numTimesConsulted(0)
{
}

ABEntry::ABEntry(...)
: theName(),
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{
}

The constructor initializer is all about making sure that built-in type do not have undefined values
since user type has constructors so no undefined value. Is it overkill when use constructor
initializer for all members since default ctor will be used when omitted? Use constructor
initializer always since:

1> avoid to remember which memebers may go uninitialized if they are omitted.
2> cover data members which are const or reference.

<syntax> It seems that it must be done in class definition. NO since can be done in memeber
definition, that is cpp file.

class Derived: public Base {
	 public:
	 	Derived( parms ) : Base( parms ), m_xxx(param), ... { ... }
};


{default-arg}
The default argument in function. If a parameter has a default argument, all the parameters that
follow it must also have default arguments. The default arguments are used from right-most
arguments.

typedef string::size_type sz;
string screen( sz ht = 24, sz wid = 80, char background = ' ' );

string window = screen();				// == screen( 24, 80, ' ');
string window = screen(66);			// == screen( 66, 80, ' ');
string window = screen(66,256);		// == screen( 66, 256, ' ');

So consider ordering the parameters so that those lesat likely to use a default value appear first.

class T {
	 T() = default;
	 T(const string s) : bookNo(s) {}
	 ...
	 string bookNo;
};

is equi to:

class T {
	 T(const string s = "") : bookNo(s) {}
	 ...
	 string bookNo;
};


Two points:

o Use carefully as there are logical cases where need to have args from the same source. For
example, it's logical error when one arg is from def init and the other is from the user.

o See the org in {default-ctor}:

	 T(const string &s) : bookNo(s) {}

default arg costs a copy op then?


{copy-controls}
copy ctor, copy assign, move ctor(C++11), move assign(C++11)

If not defined, syn version will be created. Don't use syn version of copy controls when
use dyn allocated resource. *kt_dev_cpp_004* 


{copy-ctor} <copy-init> <pass-by-value>
When init object from the other of the same type. In other words, defines how pass-by-value is
implemented for a type.

The first arg is a reference to a class and the rest args can be defaults. Used in <four> context:~
copy init, <argument-pass>, <return>, and implicit coversion using temp object. For arg pass and
return they are <non-reference-type>, they are copy-inited; Hence called copy-ctor.

class Foo {
	Foo(const &Foo);	// wrong
	Foo(const Foo&);
};

Note: cannot be 'explicit' since used implicitly such as arg passing. 

<direct-and-copy-init>
// direct init. use func matching in searching string ctor.
string dots(10, '.');
string s(dots);	

// copy init. use <copy-ctor> but not assignment. see implicit conversion here and see more at
// *kt_dev_cpp_005*
string null_book = "9-999-99999-9";
string s1;
string s2 = s1;


{pass-by-reference-to-const}
EC++20.

class Person {
  ...
  private:
    string name;
    string address;
};

class Student: public Person {
  ...
  private:
    string schoolName;
    string schoolAddress;
};

When call this, it costs 6 ctor and dtor:

bool validateStudent(Student s);

Student plato;
validateStudent(plato);

To bypass these cost of copying:

bool validateStudent(const Student& s);

The points: 

1) Less expensive since no new object are being created. In other words, more <performance>.
Typically, references are implemented as pointers. So recommendation is that use pass-by-value for
built-in, STL iterator, and function objects types and use pass-by-reference for class types.

2) The const is necessary since in pass-by-value case, the caller know that they are shielded from
any changes the function might make. To have the same for pass-by-reference, need const. 

3) Avoid <sliced-off> problem. For example:

class Window {
  public:
    ...
    std::string name() const;
    virtual void display() const;
};

class WindowWithScrollBars: public Window {
  public:
    ...
    virtual void display() const;
};

void printNameAndDisplay(Window w)
{
  std::out << w.name();
  w.display();
}

WindowWithScrollBars wwsb; printNameAndDisplay(wwsb);

Which version of display will be called? It will [ALWAYS] be the Window::display since it is
pass-by-value using Window copy-ctor and is sliced-offed. Hence Window object. To fix this, should
use pass-by-reference.

void printNameAndDisplay(const Window& w)
{
  std::out << w.name();
  w.display();
}

EC++21. The pass-by-reference is great. Then always use reference? However, there are cases that
must return a copy not a reference such as operator*(). This is a operator* not dereferene operator.
See {smart-pointer-internal}. Q: How distinguish between two?

These are tries to save a construction cost by using pass-by-reference but not right:

<1> use stack but remember a refenrece is a name for some <existing> object. Here returns a
reference to object that no longer exist.

Rational c = a*b;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational retult( lhs.n*rhs.n, lhs.d*rhs.d );
    return result;
  }
};

<2> use heap? there is no way to delete in case: 
Rational w, x, y, z;
w = x*y*z;

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    Rational *retult = new Rational( lhs.n*rhs.n, lhs.d*rhs.d );
    return *result;
  }
};

<3> use function static? Not right for multi-threaded and even for single-threaded.

class Rational {
  friend const Rational& operator*( const Rational& lhs, const Rational& rhs )
  {
    static Rational retult;
    ...
    return result;
  }

  bool operator==( const Rational& lhs, const Rational& rhs);
};

Rational a, b, c, d;

if( (a*b) == (c*d) )
{
  ...
}

This will always true since it is evaluated as
if( operator==( operator*(a,b), operator*(c,d) ) )

Therefore, in summary, should return a copy and pay a small cost for correct behavior.

class Rational {
  friend const Rational operator*( const Rational& lhs, const Rational& rhs );
  ...
};


{copy-assign} {deleted-copy-controls}
Cannot use syn version when there are reference and const member data. Why? because syn copy assign
is defined as 'deleted' if the class has a const or reference member. (Primes p508). For
<delete-keyword>, see *kt_dev_cpp_004* 

It uses op overloading and must be a member because <lhs> is this pointer.

class Foo {
  Foo& operator=(const Foo&);
};

The copy-assign controls how objects of its class are assigned

Sales_data trans, accum;
trans = accum;

For assign with different types, need additional assign op and see *kt_dev_cpp_021*

<assignment-must-return-a-reference-to-this>
EC++10. All assign ops must follow this convention like built-in types because of chain of
assignment and should behave the same as built-in types.

x = y = z = 15;		// right associative

Widget wx, wy, wz;
wx = wy = wz = DefaultWidget;

class Widget {
  public:
    Widget& operator=( const Widget& rhs )
    {
      ...
        return *this; ~
    }
};


{avoid-unnecessary-default-ctor}
From MEC++04. There are two categories:

o For class that can be inited meaningfully without inputs from outside, do use default-ctor.
o For calss cannot be inited meaningfully without inputs from outside, recommend not to use
default-ctor.

TODO: more on problems and example

For example, think a class which has ID info and use default-ctor. This causes

o Limit a use of class as not able to use array of it.
o There should be checks in each member funcs to see if it is inited with a meaningful initial value
for ID. This means more error checking, handling and penalty of size and speed.

That means that a user provide a meaningful init value but once inited, can see efficient
implementation.


{example}
struct SomeLargeData {

  SomeLargeData(int id_)
    : id(id_)
  { cout << "Foo[" << this << "] ctor(" << id << ")" << endl; }
  ~SomeLargeData() { cout << "Foo[" << this << "] dtor(" << id << ")" << endl; }
  int id;
  int arr[100];
};

int main()
{
  uint64_t be, af;
  int n = 400;

  vector<SomeLargeData> vec_byval;
  vec_byval.push_back( SomeLargeData(100));     // note. this is copy-ctor
}

$ ./a.out 
Foo[0xbfc60f4c] ctor(100)
Foo[0xbfc60f4c] dtor(100)
Foo[0x9aba008] dtor(100)


={============================================================================
*kt_dev_cpp_004* copy-controls when use dyn resource.

{when-use-resource-has-dyn-lifetime}
o don't know how many object is needed
o don't know the exact type of object
o share data between objects


{the-rule-of-three-or-five}
The rule of three (the rule of five in C++11) is a rule of thumb in C++ that claims that
if a class defines one of the following it should probably explicitly define all three:[1]

dtor, copy-ctor, and copy-assign operator

<case-example> C++ Primer p505
The need of user dtor for a class allocating dynamic resources is obvious. Because if there's no
dtor defined, the syn dtor will not run delete on the pointer, ps, so must define own dtor. NOTE:
KT. how possibly the compiler can know what pointer member points to?) 

The need of user copy ctor and assign is less clear. See what will happen when use syn versions of
copy and assign. 

class HasPtr {
  public:
    HasPtr(const std::string& s = std::string() )	// def arg. 
      : ps( new std::string(s), i(0)) {}

    ~HasPtr() { delete ps; }

  private:
    std::string* ps;
};

<not-a-choice-of-style>
What are the problems? The syn versions does not operate well for a class using dyn resource.

HasPtr func(HasPtr hp)	// value and member-wise copy using a syn copy ctor.
{
	HasPtr ret = hp;		// a syn copy assign. ret and hp points the same.
	...
	return ret;				// <double-free> on ret and hp, when exit a call
}

Even if there is no return:

HasPrt p("...");
void func(p);		
// p and func's arg points the same. when func exits, func's arg is deleted and p has invalid
// pointer which was already deleted after func().

HasPrt q(p);		
// p and q have invalid pointer.

So, need to define copy-ctor and copy-assign as well. Two methods on what copying an object will
'mean': valuelike or pointerlike (what we do when copy pointer member)

For the same reason in {constructor-initializers} in *kt_dev_cpp_003* must define copy controls when
there are const and reference members because compiler will not create syn versions since cannot
'rebind' const and reference. But how to define user copy controls for these cases?


{construct-and-copy-all-parts-of-an-object}
EC++12. When having own copy functions(copy-ctor and copy-assign), then means that you shall have
full responsibility for copying. Two cases: 

1) when add member variables to a class.

Customer& Customer::operator=( const Customer& rhs )
{
  name = rhs.name;
  return *this;
}

If add new member data, then must update all copy functions and ctors too. Otherwise, have copy
functions to copy parts of object.

2) when defines copy functions for derived class. Be careful to handle base part 'as well' because
having own copy controls means to have full responsibilities of doing it.

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs )
  :priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  {
    priority = rhs.priority;
    return *this;
  }
};

These do nothing about base part and that means:
For construction, PriorityCustomer-ctor will use a default-ctor of Customer and Customer part will
be default-init. For copy, PriorityCustomer-copy-ctor will do nothing on Customer part and it will
remain unchanged. So shall be:

class PriorityCustomer: public Customer {
  ...
  PriorityCustomer::PriorityCustomer( const PriorityCustomer& rhs ) 
  :Customer(rhs),~
  priority( rhs.priority )
  {
  }

  PriorityCustomer& PriorityCustomer::operator=( const PriorityCustomer& rhs )
  { 
    Customer::operator=(rhs); ~
    priority = rhs.priority;
    return *this;
  }
};


{valuelike} # deep-copy, self-contained-object
See {own-resource-managing-class} in *kt_dev_stl_018* for full discussion.	

The copy and the original are independent since copy underlying object as well. note: library containers
and string use valuelike copy

class HasPtr {
	public:
		HasPtr(const std::string& s = std::string() )	// def arg. 
			: ps( new std::string(s), i(0)) {}
>
		HasPtr(const HasPtr& p):
			ps( new std::string( *p.ps ));

		HasPtr& operator=(const HasPtr& p);
<
		~HasPtr() { delete ps; }

	private:
		std::string* ps;
};

Think about self-assign and exception safe. The below covers handle self-assign and exception-safe.
See *kt_dev_cpp_019* for self-assign and exception

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}


{pointerlike} # shallow-copy, own-reference-counting
The copy and the original share underlying object like shared_ptr. *kt_dev_stl_018* for example.
Alternatively, use own reference counting as following:

class HasPtr {
  public:
    // see default arg and new size_t
    HasPtr(const std::string& s = std::string() ) : ps( new std::string(s), i(0), use( new std::size_t(1) ) {}

    HasPtr(const HasPtr& p): ps( p.ps ), use( p.use ) { ++*use; };

    HasPtr& operator=(const HasPtr& p);
    ~HasPtr();
      
  private:
    std::string* ps;
    std::size_t* use; 
};

HasPtr::~HasPtr()
{
   if( --*use == 0 )
   {
      delete ps; delete use;
   }
}

Combine dtor and copy ctor. handle self-assign

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use;

  // lhs
  if( --*use == 0 )
  {
    delete ps; delete use;
  }

  ps = rhs.ps;
  use = rhs.use;

  return *this;
}


{copy-control-for-bookkeeping}
p519. Although copy control is most often needed for classes that allocate resources, some class
have bookkeeping or other actions that copy control must perform.

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set

Folder (set of pointers to Message)  Message (set of pointers to Folder)
[ ][ ][ ][ ][ ]: set                 message text
                                     [ ][ ][ ][ ]: set
...                                  ...

<lits-of-operations-message-class> # how to sketch a class
To have the same message in multiple folders, each message has a set of pointers to folder and
requires to update Folders when necessary.

- Message class provide save and remove operations to add or remove a Message from a specified
folder. To create a new Message, specify the contents of the message but no folder. To put a message
call save. NOTE. Why? Can have ctor(Folder&) but needs remove() member anyway. So better to have
save and remove pair?

- To copy a message, the copy and the original will be distinct and be in the same 'set' of Folders.
Thus will copy the contents and the set of pointers. <copying-set>. To appear in the same Folders as
the original message, must traverse the set of Folders adding a pointer to the new to eash Folder
that points to the original. 'traverse' Folders.

- To destroy a message, remove pointers to that from the Folders. 'traverse' Folders.

- To assign a message, will replace the contents and also update the set of Folders by removing lhs
Message from lhs Folders and adding that Message to rhs Folders. 'traverse' Folders.

Looking at this list of operations, both the dtor and the copy assign have to 'remove' this Message
from the Folders. Both the copy ctor and the copy assign 'add' a Message to a given list of Folders.

<copy-assign-do-dtor-and-copy-ctor>
The copy assign often does the same work as is needed in the copy ctor and dtor. In such case the
'common' work should be put in private utility functions.

class Message {
  friend class Folder;

  public:
  // folders is implicitly initialized to the empty set
  explicit Message( const std::string &str = "" ): contents(str) {}

  // copy controls to manage pointers to this message
  Message( const Message& );
  Message& operator=( const Message& );
  ~Message();

  // add/remove this message from the specified Folder's set
  void save(Folder&);
  void remove(Folder&);

  private:
  std::string contents;
  std::set<Folder*> folders;

  void add_to_Folders( const Message& );
  void remove_from_Folders();
};

void Message::save( Folder& f )
{
  folders.insert( &f );    // add the given Folder to our list of Folders. Note: &f is pointer.
  f.addMsg(this);          // add this Message to Folder's set of Message.
}

void Message::remove( Folder& f )
{
  folders.erase( &f );    // remove the given Folder to our list of Folders. Note: &f is pointer.
  f.remMsg(this);         // remove this Message to f's set of Message.
}

void Message::add_to_Folders( const Message &m )   // m is the original
{
  for( auto f : m.folders )
    f->addMsg(this);
}

// copy ctor. <copying-set>
Message::Message( const Message &m ) : contents(m.contents), folders(m.folders)
{
  add_to_Folders(m);
}

void Message::remove_from_Folders()
{
  for( auto f : folders )
    f->remMsg(this);

  folders.clear();
}

// dtor
Message::~Message()
{
  remove_from_Folders();
}

// copy assign which do copy ctor and dtor. 
Message& Message::operator=(const Message& rhs)
{
  remove_from_Folders();   // for lhs

  contents = rhs.contents;
  folders = rhs.folders;   // <copying-set>

  add_to_Folders(rhs);

  return *this;
}

Handle self-assign by removing pointers to this message from lhs before inserting pointers to rhs.
Really? Isn't folders empty after removing pointers? Seems broken and needs a direct check as done
in move? 

If do inserting first, adding has no effect since adds the same address(message) to a set in a
folder. So would have removed this from 'all' of its corresponding Folders.

<swap-function>
Since the library string and set defines own swap, Message class will benefit from defining own
version of swap to avoid extraneous copies of 'folder' memder.

However, must manage Folder pointers since after a swap(m1, m2) call, the Folders that had pointed
to m1 must now point to m2.

void swap( Message &lhs, Message &rhs )
{
  // not necessary but good habit.
  using std::swap;

  // 1 pass. remove pointers to each message from Folders
  for( auto f: lhs.folders )
    f->remMsg(&lhs);
  for( auto f: rhs.folders )
    f->remMsg(&rhs);

  swap( lhs.folders, rhs.folders );       // swap(set&, set&)
  swap( lhs.contents, rhs.contents );     // swap(string&, string&)

  // 1 pass. add pointers to each message from Folders
  for( auto f: lhs.folders )
    f->addMsg(&lhs);
  for( auto f: rhs.folders )
    f->addMsg(&rhs);
}

<move-operations>
As with copy and swap, in addition to moving, must update each Folder and both move ctor and assign
need to update Folder pointers. So make common work as a function.

// move Folder pointers 'from' m 'to' this message
void Message::move_Folders(Message *m)
{
  folders = std::move(m->folders);  // use set move assign than copy, folders = m->folders

  for( auto f : folders )  // use 'folders' for both add and remove but not m.folders
  {
    f->remMsg(m);
    f->addMsg(this);
  }

  m->folders.clear();      // ensure that destroying m is harmless
}

NOTE that inserting an element to a set might throw since it requires memory to be allocated. As a
result, unlike HasPtr and StrVec case, will not mark move operations as noexcept. Q: what this
actually mean to me?

Message::Message( Message &&m ) : contents(std::move(m.contents))    // string move
{
  move_Folders(&m);
}

Message& Message::operator=( Message &&rhs )
{
  if( this != &rhs )    // direct check for self-assign
  {
    remove_from_Folders();    // destroy the old state of lhs
    contents = std::move( rhs.contents );
    move_Folders(&rhs);
  }

  return *this;
}


{preventing-copies} # delete-keywords
Primus p507 and EC++06. How can define a class to prevent copy or assign like iostream class? Do not
defining copy controls? This do not work as syn version will be made. Two ways: delete keyword and
private access control.

<delete-keyword> <C++11>
Signal to the compiler not to define these members and lead to <compile error> when try to use it. 

struct NoCopy {
  NoCopy() = default;
  NoCopy(const NoCopy&) = delete;                 # NO copy-ctor 
  NoCopy& operator=(const NoCopy&) = delete;      # NO copy-assign
  ~NoCopy() = default;
  ...
};

<private-copy-control> prior C++11
class PrivateCopy {
  private:
	 // declare but not define ~
	 PrivateCopy(const PrivateCopy&);
	 PrivateCopy &operator=(const PrivateCopy&);

  public:
	 ...
};

However, friends and members still can call these private members so declare copy controls but not
define. By doing this, can cause link errors when there are attempts to use. Because when needed,
compiler will try to link but no definition. The example is ios_base, basic_ios, and sentry of STL
implementation. 

This is an example when see errors when use private to prevent copies.

#include <iostream>

using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  private:
    int m_iDataABCAnimal;
    Base(const Base& base) { cout << "copy-ctor: base" << endl; }		// 11
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

class D : public Base
{
  public:
    void getShout() { cout << "derived get shout" << endl; };
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base b1, b2;

  Base b3(b1);       // <case-01> 21

  D d1, d2;

  d1.getShout();

  d2 = d1;           // <case-02>

  std::cout << "--} main " << std::endl;
}

<case-01>
kit@kit-vb:~/work$ ./comp.sh use-prevent-copy.cpp 
use-prevent-copy.cpp: In function ‘int main()’:
use-prevent-copy.cpp:11:4: error: ‘Base::Base(const Base&)’ is private
use-prevent-copy.cpp:21:12: error: within this context

<case-02>
base.cpp: In function ‘int main()’:
base.cpp:33:8: error: use of deleted function ‘D& D::operator=(const D&)’
base.cpp:15:7: error: ‘D& D::operator=(const D&)’ is implicitly deleted because the default definition would be ill-formed:
base.cpp:12:10: error: ‘Base& Base::operator=(const Base&)’ is private
base.cpp:15:7: error: within this context

<case-link-error>
using std::cout; using std::endl;

class Base {
  public:
    Base() = default;
    ~Base() = default;
  public:
    int m_iDataABCAnimal;
    Base(const Base& base);      // NO definition
    Base& operator=(const Base& base) { cout << "copy-assign: base" << endl; }
};

int main()
{
  Base b1, b2;

  Base b3(b1);
}

$ ./comp.sh use-prevent-copy.cpp 
/tmp/ccskAMRR.o: In function `main':
/home/kit/work/use-prevent-copy.cpp:22: undefined reference to `Base::Base(Base const&)'
collect2: ld returned 1 exit status

<boost-noncopyable>
EC++06. To move the link-time error up to the compile-time error. This still do not have definitions
but why compile error this time? By moving private up the inheritence, change link error to compile
error. [KT] This is not quite true since as shown the above, already get compile errors when use
private copy controls.

#include <iostream>

class Uncopyable {
  protected:
    Uncopyable() {}
    ~Uncopyable() {}

  private:
    Uncopyable(const Uncopyable&);
    Uncopyable& operator=(const Uncopyable&);
};

class Foo : private Uncopyable {		// line 13
	public:
		void WhoAmI() { std::cout << "foo" << std::endl; }
};

int main()
{
  Foo f;
  f.WhoAmI();

  // errors only when add followings
  Foo o;
  o = f;	// line 26
}

kit@kit-vb:~/work$ ./comp.sh use-noncopy.cpp 
use-noncopy.cpp: In function ‘int main()’:
use-noncopy.cpp:26:6: error: use of deleted function ‘Foo& Foo::operator=(const Foo&)’
use-noncopy.cpp:13:7: error: ‘Foo& Foo::operator=(const Foo&)’ is implicitly deleted 
								because the default definition would be ill-formed:
use-noncopy.cpp:10:17: error: ‘Uncopyable& Uncopyable::operator=(const Uncopyable&)’ is private
use-noncopy.cpp:13:7: error: within this context

syn copy and assign op for derived classes are supposed to handle base class parts but they can't
invoke member funcs since the derived class has no right to call. Again, the point is that derived
class part can't call the base class part as it's private. In boost, it's 'noncopyable'.


{self-assign}
EC++11. When implement copy-assign, must think about self-assign and exception-safe. See
{self-assign-exception-safe} in *kt_dev_cpp_019*

Why? because there are less-obvious-assignments to self cases and are the result of aliasing: having
more than one way to refer to an object.

<one> aliasing

a[i] = a[j];   // potential assign to self when i==j
*px = *py;     // potential assign to self when point to the same

<two> aliasing in same class hierarchy since base ptr can point to derived. Here, rb and *pd might
actually be the same.

void doSomething( const Base& rb, Derived* pd );


={============================================================================
*kt_dev_cpp_005* converting ctor

See *kt_dev_lang_009* for built-in conversion. converting-ctor and conversion-op are called
{class-type-conversion}. Two things.


In sum, converting-ctor is a coversion {to class; inwards} and conversion op is a conversion {from
others}

class T {       <- from other type to T. converting-ctor
	 ...         -> from T to other types. conversion-op
};


{converting-ctor}

Means ctor with single arg and enables 'implicit' converstion from arg type to class type. 

For example,

class Sale_data {
	...
	combine(const Sales_data&);
	Sales_data(const std::string &s);
	...
};

string str;
item.combine(str);

Here, combine() expect Sales_date type but it is given a string type. This equates to:

item.combine(Sales_data(str));

So implicit conversion happens and creates a temp Sales_data object. Because a temp-object is used,
this implicit conversion is not always useful.

class Sale_data {
	...
	combine(const Sales_data&);
	Sales_data(istream& in);
	...
};

item.combine(cin);

When combine finishes, temp-object is gone and lost input. To avoid this, can use
<explicit-keyword>:

class Sales_data {
	'explicit' Sales_data(const std::string &s);
	combine(const Sales_data&);
	...
};

Then this force user to speify it and means they know what they are doing:

string null_book;

// error: cannot use the copy form of initialization with an explicit constructor.
Sales_data item2 = null_book;

item.combine( Sales_data(str) );							// T()
item.combine( static_cast< Sales_data>(str) );

note: Whether or not use explicit-keyword, temp-object will be create so the point is about making
it explicit.


<stl-example-of-explicit>

The vector< T > v(number) is explicit so the following is in error.

// x.member(vector< string >& vec);
x.member(10);	// error


{conversion-op}

This is conversion from class type to other type. Use overloading and the form is:

operator T() const;

class SamallInt {
	 public:
	 'explicit' operator int() const { return val;}

	 private:
	 std::size_t val;
};


To avoid following problem, use explicit keyword:

int i = 42;
cin << 42;

There is no << operator in cin but there is conversion to bool. So works as if depending on the cin
state; 0 or 1.

0 or 1 << 42;


<bool-conversion-in-condition> {tip}

However, even if uses explicit, this explict has no effect when used in condition such as:

if, while, for and do statements. logical operators. conditional operators.
 
This make its use useful in condition like:

while( std::cin >> value )

It reads into value and return cin. cin converted to bool depending on cin state. This bool
conversion is the typical use of conversion-op.

<class-state>
note. Like cin, seems useful to have bool conversion when class has 'state'.~


{avoid-impicit-conversion}

From MEC++05. Recommend to use a member func to do the same.

<problem-case>

template< typename T>
class Array {
	 public:
	 	Array(int lowBound, int highBound);
		Array(int size);
		...
};

bool operator==(const Array< int> &lhs, const Array< int> &rhs );

Array< int > a(10); Array< int > b(10);

for( int i=0; i < 10; ++i )
	 if( a == b[i] ) {        # meant to be a[i] == b[i]
		  ...
	 }
	 else {
		  ...
	 }

There is no match candidate, ( operator==( Array< int>, int ), and compiler do convert the second
arg to Array because there is converting-ctor. This is the same as:

if( a == static_cast< Array< int>> (b[i]) )

This causes a creation and deletion of unknowm number of Array objects for each iteration.

How to prevent this?

o Use <explicit> keyword from GCC 4.5 and if a compiler do not support <explicit> see then for more.


==============================================================================
*kt_dev_cpp_006* swap 

{which-swap}
In this example, which swap will this call? std::swap()? NO. This is non-member func in vector. This
is not swap of a element but a swap of internal structure. Constant-time operation. 

Except string, iterator remains valid after swap. {really}? What if swapping containers that has
different size?

vector<string> svec1(10);
vector<string> svec2(24);

swap( svec1, svec2 );	

Primers p339. In C++, container provides member and non-member swap and previously supports member
only. Recommands non-member swap. {why}? for generic programming? 

If there's no type specific swap, use swap from the library, std::swap. This is function template
and does member-wise operation.


{why-swap}
The swap provides two characteritics: efficiency and strong exception-safety.
 
<efficiency>
It is for valuelike class and use swap when used by algorithm such as reorder elements. For
pointerlike class, no need as it naturally swaps pointers. stl containers are valuelike. see
{valuelike} in *kt_dev_cpp_004*

Since valuelike swap is expensive such as resource managing class which is value-like, need to have
better way and provide type specific swap which has efficient way to do it. So sounds like a topic
for container design?

<exception-safety>
Like STL containers, provide both memeber and non-member swap. To have the member version swap never
throw exception (because it use swap on built-in types that never throw exception.) This offers the
strong excepiton-safety gurantee.


{define-swap-use-specialisation}
EC++25. pimpl-idiom. See *kt_dev_ecpp_008* for pimpl-idiom.

class WidgetImpl {                          // class for Widget data;
public:                                     // details are unimportant
  ...

private:
  int a, b, c;                              
>
  std::vector< double > v;                  // possibly lots of data expensive to copy!
  ...
};

class Widget {                              // class using the pimpl idiom
public:
  Widget(const Widget& rhs);
>
  Widget& operator=(const Widget& rhs)      // to copy a Widget, copy its
  {                                         // WidgetImpl object. For
   ...                                      // details on implementing
   *pImpl = *(rhs.pImpl);                   // operator= in general,
   ...                                      // see Items 10, 11, and 12.
  }
  ...
<
private:
  WidgetImpl *pImpl;                        // ptr to object with this
};                                          // Widget's data


Imagine how expensive it may be when there's no swap for Widget and when use std::swap :

Widget A, B; swap(A,B);

All we really need to do is swap their pImpl pointers, but the default swap algorithm has no way to
know that. Instead, it would copy not only three Widgets, but also three WidgetImpl objects. Very
inefficient. In other words, cost three copies that use 'operator=' of valuelike class. For some
types such as pimpl-idiom, none of these copies are really necessary. How to avoid these cost? To
address this, should provide type specific swap version to be used by clients:

<attempt-one> use-template-specialization

namespace std {					  

  template<typename T>          // typical implementation of std::swap;
  void swap(T& a, T& b)         // swaps a's and b's values
  {
    T temp(a);
    a = b;
    b = temp;
  }
}

This is a way to say that to specialize std::swap for Widget. This is called 'total' template
specialization. Why? Since it specify T as Widget so it is from generic to speficic one. 

namespace std {                        // <DN> see in 'std'

  template<>                           // this is a specialized version
  void swap< Widget >(Widget& a,       // of std::swap for when T is
                    Widget& b)         // Widget; this won't compile
  {
    swap(a.pImpl, b.pImpl);            // to swap Widgets, just swap
  }                                    // their pImpl pointers
}

We are not permitted to alter the contents of the std namespace, but we are allowed to totally
specialize standard templates (like swap) for types of our own creation (such as Widget).

This function will not compile. That is because it is trying to access the pImpl pointers inside a
and b, and they are 'private' so other ways might be:

o could declare our specialization a friend, but the convention is different: so not
consider. 

o have a public swap member and specialized std::swap calls this member swap. 'okay' since do not
use friend here.

# this is the solution

class Widget {                     // same as above, except for the
public:                            // addition of the swap mem func
  ...
  void swap(Widget& other)
  {
    using std::swap;               // the need for this declaration
                                   // is explained later in this Item

    swap(pImpl, other.pImpl);      // to swap Widgets, swap their
  }                                // pImpl pointers
  ...
};

namespace std {

  template<>                       // revised specialization of
  void swap< Widget >(Widget& a,   // std::swap
                    Widget& b)
  {
    a.swap(b);                     // to swap Widgets, call their
  }                                // swap member function
}

<attempt-two> use-template-specialization and for class template
However, suppose that Widget and WidgetImpl were class templates instead of classes. Needs more
generic solution but cannot use the same as before since the specialization would look like:

namespace std {

  template<typename T>                       
  void swap<Widget<T>>(Widget<T>& a, Widget<T>& b)
  {
    a.swap(b);                     // to swap Widgets, call their
  }                                // swap member function
}

This is illegal code since C++ do not allow partial specialization for function template. If this is
possible, then it means to add a template into std namespace. Not allowed. Why? 

The overloading function-template is fine, but std is a special namespace, and the rules governing
it are special, too. It's okay to totally specialize templates in std, but it's not okay to add new
templates (or classes or functions or anything else) to std. Undefined behavior.

<attempt-three> use-namespace but not use specialization
This works as well for classes as for class templates. Just don't declare the non-member to be a
specialization or overloading of std::swap.

namespace WidgetStuff {
  ...                                     // templatized WidgetImpl, etc.

  template<typename T>                    // as before, including the swap
  class Widget { ... };                   // member function

  ...

  template<typename T>                    // non-member swap function;
  void swap(Widget< T >& a,               // not part of the std namespace
            Widget< T >& b)                                         
  {
    a.swap(b);
  }
}

This use swap(Widget< T >&, Widget< T >&) through {arg-dependent-lookup}

<why-use-using-std-in-the-member-function>
What you desire is to call a T-specific version if there is one, but to fall back on the general
version in std if there's not. Here's how you fulfill your desire:

template<typename T>
void doSomething(T& obj1, T& obj2)
{
  using std::swap;           // make std::swap available in this function
  ...
  swap(obj1, obj2);          // call the best swap for objects of type T
  ...
}

There are important subtleties:
1> use unqualified swap to search for class-specific swap version
2> use using std::swap to make it visiable in current scope so fall back on std::swap when there is
no class-specific version.

<attempt-four> attempt-treee and plus std::swap specialization when write class but not class templeate
Why? To cover misguided use like:

std::swap(obj1, obj2);

This force compiler to consider only the swap in std including any template specialization. In
addition to the type specific swap in a class, have specialized std::swap to call member swap. This
is to make type-specific swap implementations available to code written in this misguided fashion.

<stl-vector-code> taken from vector template in gcc

  template<typename _Tp, typename _Alloc = std::allocator< _Tp >>
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
	  ...
	  
      /**
       *  @brief  Swaps data with another %vector.
       *  @param  x  A %vector of the same element and allocator types.
       *
       *  This exchanges the elements between two vectors in constant time.
       *  (Three pointers, so it should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(v1,v2) will feed to this function.
       */
      void
      swap(vector& __x)
      {
		std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
		std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
		std::swap(this->_M_impl._M_end_of_storage,
			  __x._M_impl._M_end_of_storage);

		// _GLIBCXX_RESOLVE_LIB_DEFECTS
		// 431. Swapping containers with unequal allocators.
		std::__alloc_swap< _Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
								__x._M_get_Tp_allocator());
      }
	  ...
	} # end of class template
	
	/// See std::vector::swap().
	template<typename _Tp, typename _Alloc>
	inline void
	swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
	{ __x.swap(__y); }


{define-swap-use-friend}
Primer p516. This is an example which use non-member swap and friend approach and example from
{valuelike} in *kt_dev_cpp_004*

class HasPtr {
>
  friend void swap( HasPrt&, HasPtr& );
<
  public:
   HasPtr(const std::string& s = std::string() )	// def arg. 
    : ps( new std::string(s), i(0) {}
        
		...

   ~HasPtr() { delete ps; }

  private:
   std::string* ps;
};

inline void swap( HasPtr& lhs, HasPtr& rhs )
{
  using std::swap;
  swap( lhs.ps, rhs.ps );	// std::swap as no swap in string
  
  OR 

  std::swap( lhs.ps, rhs.ps );
}

The following will use swap(HasPtr&, HasPtr&) through {arg-dependent-lookup} in *kt_dev_cpp_007*

HasPtr A, B;
swap(A,B);		

In this example, the following is the same as used on built-in memeber data, pointer in this case
but this can be mistake for class member data because it will always use std::swap.

inline void swap( HasPtr& lhs, HasPtr& rhs )
{
  std::swap( lhs.ps, rhs.ps );	// std::swap as no swap in string
}


{copy-and-swap-idiom}
For valuelike, this is exception-safe code which automatically handle self-assign

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

To rewrite using copy-and-swap-idiom

HasPtr& HasPtr::operator=(const HasPtr rhs)  // note. not ref and it's copy so copy ctor used.
{
  swap(*this, rhs);
  return *this;      // rhs is destroyed, which deletes the old ps.
}

It this HasPrt has swap implementation, then this operator= will be efficient. SO, have
optimization, self and exception safe and neat implementation using swap. Also EC++11 says the
compiler can generate more efficient code by moving copying from the function body to parameter
construction. 

TODO: Primers p518. summarise after studying template.

{Q} why non-member swap in the first place? because to try type-specific first and if not fall back
to std one. member swap is the qualified one.


==============================================================================
*kt_dev_cpp_007* function matching and overload

{function-matching}

Also known as overload resolution. The name has 'scope' and object has 'lifetime'. Three possible
outcomes: best match, no match, and ambiguous call. For overload condition, see {const-on-overload} 

note: step 0 and 1 is called <normal-scope-or-name-lookup>?

step-0: <search>
For lookup of names inside a namespace, look in members in case class, and if not found, continue
looking in enclosing scope; which is a open scope having a name to look up. This can be block,
class, or namespace. So continue looking in classes up the chain of inheritance or
namespaces. This search goes upwards that means declared before use and before in reading
order. For example, int A::C1::f3() in qualified name. Plus use {arg-dependent-lookup} for
class type, reference, and pointer. For non-class, enclosing scope that is before the point
of use and is still open. See Primers p797. 'using' declaration or directive add names to
the candidate set. If found the name, the compiler looks no further.

step-1: <build-candidate>
Use name only hence called name-lookup. Build candidate functions which is the set of overloaded
functions and should be the same name and visible. Include any function-template instantiation for
which template arg deduction succeeds.

step-2: <build-viables>
Use the number of arguments to get viable functions and use conversion and type-match.

step-3: <best-match>
The exact match is better than a match that requires a conversion. non-template func is selected if
there's only one in the set. if not, more specialed func template is called. otherwise, the call is
ambiguous.

step-4: <check-access>
See accessibilty in case of inheritance. From EC++40

step-5: <virtual-or-not>
If it is virtual, generate a code for run-time binding. otherwise, generate a normal call.


{broader-candidate-set-op-overload}

a op b

is nothing to say about whether it calls member or non-member op overload. so the set is wider to
both member and non-member to be considered.  


{arg-dependent-lookup}
 
From {ref-CPR} p797.

std::string s;
std::cin >> s;

this is equi to:

operator>>(std::cin, s); 

This operator>>() func is defined in the 'string' libaray as a non-memeber and in 'std'. Why is it
okay without using either 'std::' or 'using'? When func has class type argument which is class
object, pointer or reference, the compiler searches <namespace-in-which-arg-defined> in addition to
the normal scope lookup.

In this case, searches the namespace, 'std', where cin and string is defined and found this func
from 'string'. note: it is namespace, not else.

Why this? This makes it easy to use non-member func which is conceptually part of class interface.
otherwise, should use

using std::operator>>; or std::operator>>(std::cin, s);


{scope-in-inheritance}

Primus p617. Hierarchical nesting of class scope; this means that the derived is nested in the base
scope and names in the derived can hide names declared in the base. See {override-keyword}
*kt_dev_cpp_023* The point is that the name-lookup happens at compile time and uses static-type. The
below shows that point.

class Disc_quote : public Quote {
	 public:
	 std::pair<a,b> discount_policy() const { ... }     # added in this class only
};

class Bulk_quote : public Disc_quote {
	 ...
};

Bulk_quote bulk;

Bulk_quote* bulkP = &bulk;
Quote* itemP = &bulk;        # static and dynamic type differ

bulkP->discount_policy();
itemP->discount_policy();    # error

What if discount_policy is virtual func? Doesn't matter in this case and it's still error because
this is not found in Quote class.

Tried with GCC and got an error:
.cpp:139:10: error: 'class Quote' has no member named 'discount_policy'

It is for non-virtual funcs. If the base has overloads and 'is-a' relationship then see EC++33 for more. 
note: seems need more clearer statement for the above.


={============================================================================
*kt_dev_cpp_008* const and conversion

{constant-expression}
A constant expression is an expression that involves only constants:

#define MAXLINE 100
char line[MAXLINE+1];


{global-const-scope}
The const object must be inited when defined and it's local to file by default. so want to use in
multiple files, must use <extern-keyword> on [both] definition and declaration. This is different
from <file-staic-mean>. The important principle is that shouldn't change const object.

// file one
extern const int gc_max = 100;

// file two
extern const int gc_max;


{top-and-low-level-const}
The top level const is for object itself. So there are <top-level-const> and <low-level-const> for a
reference and pointer. Top-level-const is for reference and pointer itself and low-level-const is
for underlying object. Top can be ignored but low level 'NOT' because top-level-const do not say
anything about underlying object. const-pointer can point either const or non-const. Hence can
be ignored. 

int i = 42;
const int ci = i;
int j = ci;					// top-level const ignored.

The initialisation do not change the value of an object. Constness of ci matters only for operations
that might change ci. Copying doesn't change ci. The new object has no further access to the
original object. 


{reference-to-const}
Unlike pointer, <reference-to-const> is different since there's no const-reference since reference
is not object. The reference-to-const restrics only what we can do [through] that reference and says
nothing about whether the underlying object itself. 

For pointer, there are <pointer-to-const> and <const-pointer>. The following initialsation is error
because should NOT be able to use a reference to change ci. Remember a reference is another name.

int &ri = i;
const int &r2 = i;
r1 = 0;
r2 = 0;						// error since r2 is reference-to-const

<const-to-nonconst-error>
int &ri = ci;				// error because NO 'const to non-const'. Not a copy.

int main()
{
  const int ci = 100;
  int &ri = ci;               // 6. 
  // int &ri = (int&) ci;     // no error.
}

:6:13: error: invalid initialisation of reference of type ‘int&’ from expression of type ‘const int’

For ordinary reference, must match type and must bind to a object.

int &ri = 10;				// error
int &ri = double_val; 	// error

For pointer examples, see and remember that read from right to left; that is from modifiers to base
type.

const double *cptr = &pi;
int *const curErr = &errNumb;


{type-match-exceptions}
Two exceptions to type match: <nonconst-to-const> and <derived-to-base-reference> conversion. Can
bind <reference-to-const> to non-const, a literal, a temp, or other expression that evaluate to an
type.

const int &ri = 42;		// ok

double dval = 3.14;
const int &ri = dval;	// ok becuase will bind to <temp-object> and cannot change it via ri

KT. This is [to-maintain-constness] by creating [temp-object]. See <case-one-in-conversion>

<convert-to-const>
Implicit nonconst-to-const conversion ONLY <for reference and pointer>.

const  -- NO --> non-const
const <-- OK --  non-const

const int &ri = const object		// cannot change as both are const
const int &ri = non-const object	// cannot change via ri but can change object itself. 

When copy an object, both object must have the same low-level const or be conversion.

const int ci = 42;	// top-level
int i = ci;				// ignored

const int& r = ci;	// is 'always' low-level

int i;
const int &j = i;		// conversion from non-const to const
const int *p = &i;
int &r = j, *q = p;	// error since conversion from const to non-const

If this is allowed, const object can be changed via non-const pointer and reference. So not allowed.


{const-param-args}
The const matters when copying vars and do func params. That is why copy-ctor is usded here.

void fcn( const int i );		
fcn(j);	// const int i = j;
fcn(cj);	// const int i = cj;

void fcn( int i );
fcn(j);	// int i = j;
fcn(cj);	// int i = cj;

This is error because it redefines the same. Why? See {const-on-overload} for more cases.
These are all explained by the fact that fcn(const init i) can be used both fcn( const-pararm ) and
fcn( non-const-param ) and in other words, top-level-const can be ignored.


{const-reference-param}
Two implications when use plain reference param in func:

o A func that don't change a ref param, mislead its user to think it is.
o More importantly, it limit its use only to non-const param.

example

find_char(const string& s, char c);
find_char("Hello", 'o');	// OK because const-to-ref can match to literal.

find_char(string& s, char c);
find_char("Hello", 'o');	// compile error because temp object is const

So recommend const-reference-param over reference-param for flexibility. 


{const-on-iterators}
In iterator, begin() has overloads: const and non-const version because if it has only const
version, *this is const and any data member is also const. begin() may return its member.

// like 'T* const' and iter itself is const
const std::vector<T>::iterator iter = vec.begin();

// like 'const T*' and *iter is const
std::vector<T>::const_iterator iter = vec.begin();


{const-return} {equal-misspell}
EC++03. When use return by value as a return, use const to raise error when mistake happens:

const Rational operator*( const Rational& lhs, const Rational& rhs );

// typo. was meant if( a*b == c )
//
if( a*b = c )

If these are built-in tyeps, this is flat-out error but don't for class type. It is never legal to
modify the return value of a function that returns a built-in type. Even if it were legal, the fact
that it returns object by value would mean that a copy would be modified and that's not the behavior
you want. 

So better to be prepared for this kind of mistakes. Also this is an example of returning a copy than
reference.


{why-const-member-func}
EC++03. Two points:

o Clearer interface to show which member func can change state
o Efficient code since make it possible to work with const objects. 
  

{const-and-this-pointer}
When call a member func, pseudo-code for actual call should looks:

total.isbn();

Sales_data::isbn(&total); where Sales_data::isbn(Sales_data *const this);

That is "this = &total" because this-pointer is a <const-pointer> by default; pointer itself is
const. This means that when calls non-const member of const object, cannot call it because when it
is called, this-pointer will be set but cannot. Why? since it meants 'this=&const object' but
there's no {const-to-non-const} conversion. *kt_dev_cpp_008*

this = &const_total; // ERROR

So if we make a member function const, will make this-pointer as a pointer-to-const then:

o Cannot change object via this member func(i.e. this-pointer)
o Can be used on both const and non-const class object.

<why-const-member-is-okay>
string isbn 'const' { return bookNo; }

it makes:

T *const this -> 'const' T *const this


{const-on-overload} {overload-condition}
Conditons for overloading

o Shall be the same name
o Shall have different param list in the number or the type
o Shall be in the same scope

So don't see return type. See {virtual-copy-constructor} for override case.

// int *const currErr : const pointer. read from right to left

Record lookup( account * );      // pointer
Record lookup( account *const );	// const pointer. re-define.

Record lookup( account & );		// non-const version
Record lookup( const account &);	// const version


{const-non-const-version}
May need to have overloads of non-const and const version.

If there is only a const version and display is const member func, then following is a compile error.
Assume display() is const member func and set_set is non-const member func.

screen myscreen;
myscreen.display().set_set(10);

Solution?

<approach-one> Use overloads for non const and const

class screen{
  public:
    screen& display( ostream& os ) 
    { do_display(os); return *this; }

    'const' screen& display( ostream& os ) const 
    { do_display(os); return *this; }

  private:
    // {tip} use a utility func for a common duplication
    void do_display( ostream& os ) const 
    { os << counts; }
};


// gcc-eample

class Screen {
  public:
    Screen& display()
      //{ cout << "dis: this is non-const member" << endl; }
    { cout << "dis: this is non-const member" << endl; return *this; }

    const Screen& display() const
      //const Screen& display() const
      //{ cout << "dis: this is const member" << endl; }
    { cout << "dis: this is const member" << endl; return *this; }

    void set()
    { cout << "set: this is non-const member" << endl; }
};


int main(int argc, char** argv)
{
  Screen screen;

  screen.display();
  screen.display().set();

  const Screen cscreen;

  cscreen.display();
  cscreen.display().set();	// error for note-02
}

<case-one>: when return *this from const member function. error on const to non-const conversion. 

Screen& display() const
{ cout << "dis: this is const member" << endl; return *this; }		// error line

test.cpp: In member function 'Screen& Screen::display() const':
test.cpp:14:58: error: invalid initialisation of reference of type 'Screen&' from expression of type
'const Screen'

<case-two>: expected as the problem to solve. 

const Screen& display() const
{ cout << "dis: this is const member" << endl; return *this; }

test.cpp: In function 'int main(int, char**)':
test.cpp:32:24: error: passing 'const Screen' as 'this' argument of 'void Screen::set()' discards
qualifiers [-fpermissive]

<case-three> const member function but do not return.
	
Screen& display() const
{ cout << "dis: this is const member" << endl; }

dis: this is non-const member
dis: this is non-const member
set: this is non-const member
dis: this is const member
dis: this is const member
set: this is non-const member

Seems that returns as defined in func because no comiple error and works but 'const Screen&
display() const', get the same error as the case-two even if there is no return.

The const member func has always this form when use return. why? see bitwise-const for more. This
matters only when returns reference but not a copy.

const T func( ... ) const // OK
T func( ... ) const       // NO 


<approach-two> Have one implementation for both const and non-const <const_cast>

From EC++03. Why need? If member function is big, code duplication. So implement once and use it
twice. Have non-const that calls const version and have only one implementation. Why this direction?
If you were to call a non-const from a const one, you'd run the risk that that object you'd promised
not to modify would be changed. 

Used static_cast to call const version and const_cast to cast away const and return.

class TextBlock {
  const char& operator[]( std::szie_t position ) const 
  {
    ...
    return text[position];
  }

  char& operator[]( std::size_t position )
  {
    return const_cast<char&> ( static_cast<const TextBlock&>(*this)[position] );
  }
};

From {ref-CPR} p233, const_cast is most useful in the conext of overloaded functions.

const string &shorterString( const string &s1, const string &s2 )
{
	return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString( string &s1, string &s2 )
{
	auto &r = shorterString( const_cast<const string&>(s1), const_cast<const string&>(s2) );

	return const_cast< string& >(r);
}

This is safe to cast that string back to a plain string& in the return because it is bound to one of
original nonconst arguments. See that const_cast is used to give it const and const away.


<approach-three> Change the order

myscreen.set_set(10).display();
const_screen.display();


{const-in-func-definition}
If miss out 'const' in the func definition then:

usedeskcalc.cpp:28:6: error: prototype for 'bool Stack::empty()' does not match any in class 'Stack'
usedeskcalc.cpp:13:7: error: candidate is: bool Stack::empty() const

class Stack {
	...
	bool empty() const;
	...
};

bool Stack::empty() const
{
	 ...
}


{bitwise-const}
From EC++03. Bitwise-const(physical const) is C++'s definition and compiler only catches assignment to
member data which is read-only. Issues errors like:

// example-one

Error_code Stack::top(Stack_entry &item) const
{
	...
	else
		//item = entry[count--];	# count is member
		item = entry[count-1];

	return outcome;
}

usedeskcalc.cpp:53:21: error: decrement of member 'Stack::count' in read-only object


// example-two

int cube(const int& num)
{
	num = num * num;   // [error]
	return num;
}

test.cpp:22:14: error: assignment of read-only reference 'num'

// example

#include < iostream>

using namespace std;

class Sample {
public:
	Sample(const char* str) : text(str) {}

	// cannot remove const return as return used
	const char& operator[] (std::size_t pos) const
	{ return text[pos]; }

private:
	std::string text;
};

int main(int argc, char** argv)
{

	Sample sam("CONSTMEMEBER");

	std::cout << sam[1] << endl;

	sam[1] = 'X';	// error
}

use-const-second.cpp: In function ‘int main(int, char**)’:
use-const-second.cpp:25:11: error: assignment of read-only location ‘sam.Sample::operator[](1u)’

if change to:

class Sample {
public:
	Sample(const char* str) : ptext(new std::string(str)) {}

	// [no-error] but see no const return and if so, get the same error as above.
	//
	// also the below works as well only this case meaning bit-wise.
	//
	// char& operator[] (std::size_t pos) const
	// { (*ptext)[pos] = 'k'; reurn (*ptext)[pos]; }
	//
	char& operator[] (std::size_t pos) const
	{ return (*ptext)[pos]; }

	~Sample() { delete ptext; }

private: >
	 std::string* ptext;
};

int _tmain(int argc, _TCHAR* argv[])
{
	Sample sam("CONSTMEMEBER"); or const Sample sam("CONSTMEMEBER"); 

	std::cout << sam[1] << endl;

	sam[1] = 'X'; 											// [no-error] and can chage value

	std::cout << sam[1] << endl;
 
	return 0;
}

No compile errors because 'indirect' use of an object (outside of an object) can avoid C++'s const
check called bitwise-const. Since do not make changes to *this, member, pointer in this case, so
compiler do not complain. This means const member func can change object state. Break encapsulation.

<fix-to-this-hole>
From EC++28. Can fix this problem as below,

const char& operator[] (std::size_t pos) const		// NO error

However, <dangling-handles> problem still remains since it returns reference to internal member.
Therefore, recommend to use const T(...) const form as a default.


{logical-const}
EC++03. Hence logical-const. This is an example to cache the length whenever it is requested. cache
textLength. Although it changes its member, it has logical constness as it updates length to cache
purpose. 

class CTextBlock {
  public:
    std::size_t length() const;

  private:
    char* pText;
    mutable std::size_t textLength;    // mutable
    mutable bool lengthIsValid;        // mutable
};

Last calculated length of textblock

std::size_t CTextBlock::length() const
{
  if( !lengthIsValid )
  {
    textLength = std::strlen( pText );
    lengthIsValid = true;
  }

  return textLength;
}


{mutable}
To make member data writable from a const member func. A mutable data member is never const even
when it is a member of a const object.

class T {
  public:
    void some_member() const;

  private:
    'mutable' size_t access_ctr;
};


<when-useful>
- in debug, to count the number of calls for a member func.
- to use logical constness
- to use lock as a mutable member. seems useful.
- see {lazy-fetching} in *kt_dev_mecpp_002* 

All these cases are about logical constness and the snippet from online:

A mutable variable could be used for example for tracking lifetime of an object and regularly prints
a log of its internal state. In this case, nothing changes for the object from the external point of
view, but some thing in its internal state changes. This does not contradict to promise to not
modify the object, because in this case, const can be seen as "I promise to my user that this
operation will not modify any visible state / information he could access". 


{case-example}
When use the mix of C and C++, face an build error when builds C++ source.

SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
...
  source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);
}

const char* _determineSource(const char*in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');
  ...
}

Session.cpp:876:23: error: invalid conversion from 'const char*' to 'char*'

Looked at the strchr man page and it says:

NAME
       strchr, strrchr, strchrnul - locate character in string

SYNOPSIS
       #include <string.h>

       char *strchr(const char *s, int c);
       
What? What's going on here?!

<answer>
Found that from glibc string.h

/* Find the first occurrence of C in S.  */
#ifdef __CORRECT_ISO_CPP_STRING_H_PROTO            // IF
extern "C++"
{
extern char *strchr (char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));
extern __const char *strchr (__const char *__s, int __c)
     __THROW __asm ("strchr") __attribute_pure__ __nonnull ((1));

# ifdef __OPTIMIZE__
__extern_always_inline char *
strchr (char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}

__extern_always_inline __const char *
strchr (__const char *__s, int __c) __THROW
{
  return __builtin_strchr (__s, __c);
}
# endif
}
#else                                              // ELSE
extern char *strchr (__const char *__s, int __c)
     __THROW __attribute_pure__ __nonnull ((1));
#endif

That says that will use non-const version for C++ build and const version for C.

<solution>
SessionResolveName(const char *in, char *out, int maxLen, int *calculated)
{
  ...
  source = _determineSource((char*)in, &sourcelen, &inIndex, &usePath);    <DN>
}

const char* _determineSource(const char*in, int* sourceLen, int *readPos, bool* usePath)
{
  idx = strchr(in, '/');
  ...
}


={============================================================================
*kt_dev_cpp_009* undefined result and a temp-object

{undefined-result-in-return}

// example-one

#include < iostream>
#include < string>

using namespace std;

bool str_subrange( const string& str1, const string& str2 )
{
	if( str1.size() == str2.size() )
		return str1 == str2;

	auto small_size = ( str1.size() < str2.size() ) ? str1.size() : str2.size();

	for( decltype(small_size) i = 0; i != small_size; ++i )
		if( str1[i] != str2[i] )
			;			// NO ERROR in this case
			return;	// [ERROR-01]
			return false;
	
	// [ERROR-02]
}

int main()
{
	string str1 = "KYOUNG";
	//string str2 = "YOU";
	string str2 = "KYO";

	bool ret = false;

	ret = str_subrange(str1, str2);
	if( ret )
		cout << "return true" << endl;
	else
		cout << "return false" << endl;

	return 0;
}

{ERROR-01}
VC and GCC picks up this error. This is GCC case:

samcpp.cpp: In function bool str_subrange(const std::string&, const std::string&)
samcpp.cpp:16: error: return-statement with no value, in function returning bool

{ERROR-02}
Primus says that some picks up this error and some do not. Both VC adn GCC do not picks up this.

{undefined-result}
Primus also says that its result at runtime is 'undefined'. When running for VC and GCC showed
different result: VC returns true and GCC do false. Hence 'undefined'. 

Note: KT. This is a kind of logic error that compiler cannot catch. 

// example-two

const string& foo()
{
	 string ret;

	 ...
	 if
	 	return ret;
	 else
	 	return "Empty";
}

Both return cause [undefined-result] at the call site(caller) because it returns reference to local
string in foo().


{temp-object-in-return}

// example-one

Return the plural version of the word if the counter is greater than 1.

string make_plural( size_t ctr, const string& word, const string& ending)
{
	 return (ctr>1) ? word + ending : word;
}

The word is copied to the call(ing) site or unnamed string [temp-object] is copied to the call site for
'word + ending' case.

// example-two

pair<string, int> process(vector< string> &v)
{
	 ...
	 return pair<string, int>();
	 or
	 return pair<string, int>( v.back(), v.back().size() );
}

Here explicitly constructed return pair [temp-object]. 'pair<string, int>' is T. That is T() and so is
default constructed and value-init.

See {return-reference-vs-copy} for interesting case. So whether or not there is a temp object
created in called site, there is a copy to call site when a func is defined to return a copy.


{temp-object-in-converison} {cost-of-temp-object}
From MEC++19. The cost of temp-object which is called unnamed or temp object. When is it used?

<in-conversion>
Used in implicit type conversion, nonconst-to-const, in func call and return. Can have an impact on
the performance in construction and destruction. 

size_t countChar( const string& str, char ch );

char buffer[MAX_STRING_LEN];

countChar( buffer, c ); // string str = string temp-object(buffer);

When it is called, there is a type mismatch so string [temp-object-or-unmaned-object] will be
created, buffer is copied, and binding to str arg happens. Destruction happens when return. If
buffer size is big, then it is costly. It is for compiler to make a func call succeed.

How to eliminate this?

<1> write code to make sure there is no <implicit-conversion> such as <explicit-keyword> or member
function.
<2> MEC++21

This happens only <pass-by-value> and <reference-to-const>. Why? There are exceptions
[to-maintain-constness]. See {reference-to-const}. For reference-to-non-const, get type mismatch
errors:

void uppercasify( string& str );
char subtlebookplug[] = "...";

uppercasify( subtlebookplug );          // type-error

<in-return>
This must be temp-object and [const-return]. Why const return and temp-object? See {const-return}.
If not, the following is legal: 

const Number operator+( const Number& lhs, const Number& rhs );
Number a, b, c;
a + b = c;

How to eliminate this cost?

Not always possible to shun this. Can use operator+= and see MEC++22 for more. Or can use compiler's
<return-value-optimisation> in MEC++20.

<in-casting>
From ansic, p45.
The cast produces the 'value' of n in the proper type; n itself is not altered. 

squrt( (double)n );


==============================================================================
*kt_dev_cpp_010* def args

If a parm has a def argument, all the parms that follow it must have def arg.

string screen(sz ht = 24, sz wid = 80, char background = ' ');
string screen(sz ht = 24, sz wid, char background = ' ');	// ERROR

string window;
window = screen();			// screen(24, 80, ' ');
window = screen(66);			// screen(66, 80, ' ');
window = screen(66, 256);	// screen(66, 256, ' ');

so consider ordering: those least likely to use a def value {appear-first} in {declaration}.

See {default-arg-in-virtual} for use inheritance.


==============================================================================
*kt_dev_cpp_011*	inline

o can avoid function call overhead
o a request to the compiler and the compiler may choose to ignore this request.
o EC++30 says that can have compiler optimisation on inlined code area.

Inline has cost:

o) bigger size and performance penalty due to additional paging and reduced instruction cache hit.
o) impossible to provide binary upgrades. Force client to compile than to relink
o) problem with debugger.
o) ctor and dtor may be worse candiate for inline. Why? There are codes written by compilers and
inserted into program during compilation for construction, destruction, exception handling during
those, new and delete, and so forth. These are up to compiler implementation. So empty ctor can have
followings:
o) A compiler refuse to inline funcs that has calls to virtual funcs because cannot know it at
compile time.


{empty-ctor-represenstaion}

class Derived: public Base {
	 public:
	 	Derived() {}
		...
	 private:
	 	std::string dm1, dm2, dm3;
};

Derived::Derived()
{
	 Base::Base();

	 try{ dm1.std::string::string(); }
	 catch(...) {
		  Base::~Base();
		  throw;
	 }

	 try{ dm2.std::string::string(); }
	 catch(...) {
		  dm1.std::string::~string();
		  Base::~Base();
		  throw;
	 }

	 try{ dm3.std::string::string(); }
	 catch(...) {
		  dm1.std::string::~string();
		  dm2.std::string::~string();
		  Base::~Base();
		  throw;
	 }
}

This is unrepresentative of what real compiler emit but do what ctor must offer. When think ctors of
base class, class members, not attractive for inlining. 

{BP} Think about 80-20 rule and may use profiler to find out 20% as a candidate for inlining.


={============================================================================
*kt_dev_cpp_012* initializer_list 

{gcc-support}
On 4.5.x:

const std::string hybrid_str{"hybrid:"};

/Session.cpp:56:21: warning: extended initializer lists only available with -std=c++0x or -std=gnu++0x
/Session.cpp:56:41: error: in C++98 '<unnamed>::hybrid_str' must be initialized by constructor, not by '{...}'


{initializer_list}
It is a library template type that repersents an array of values of the specified type. The element
in a list are always const.

#include "initializer_list"

initializer_list<T> lst;
initializer_list<T> lst{a,b,c};
lst.begin();
lst.end();

initializer_list<int> li; 
initializer_list<string> ls;

Since it supports begin and end, can process elements.

void error_msg( initializer_list<string> ls )
{
  for( auto beg = ls.begin(); beg != ls.end(); ++beg )
    cout << *beg << " ";
  cout << endl;
}

void error_msg( ErrorCode e, initializer_list<string> ls )
{
  cout << e.msg() << " ";
  for( const auto &elem : ls )
    cout << *elem << " ";
  cout << endl;
}


={============================================================================
*kt_dev_cpp_013*	when use reference {called-by-reference}

{no-address-when-use}

There is a difference between called-by-reference(passed-by-reference) and called-by-value. For
example:

void reset( int i )
{ i = 0; }

int j = 42;
void reset (j); 	

what's the value of j here?


void reset( int* pi )
{ *pi = 100; pi = 100; }

int j = 42;
void reset( &j );

what's the value of j here?

Here reference i will be bounded to whatever int object we pass and say "pass an object" directly.
So no need to pass its address.

void reset(int &i)
{ i = 0; }

int j = 42;
reset(j);		// [KT] no need to pass its address

what's the value of j here?

For called-by-reference, C uses pointers and C++ uses reference. Use C++ way of doing it.


<code-example>

From list and tree from kt_dev_01.txt. The list example using pointer is:

typedef struct {
   int   count;
	Node*	header;
} List;

void CreatList( List* list )
{ 
   list->count = 0;
   list->header = NULL; 
}	

bool ListAdd( List* list, EntryType entry )
{
	list->header = pnode;
	...
}

int main()
{
	List list;
	CreatList(&list);

	for(int i=0; i < 5; i++)
	{
		std::cin >> item;
		ListAdd(&list, item );
	}		
	...
}


This is tree example:

typedef struct treenode {
	TreeEntry entry; // application dependent
	treenode  *left;
	treenode  *right;
} TreeNode;

TreeNode* TreeInsert( TreeNode* root, TreeNode* newnode )
{
	if(!root)
	{
		root = newnode;
		root->left = root->right = NULL;
		std::cout << "inserted: " << root->entry.key << std::endl;
	}
	else if( LT(newnode->entry.key, root->entry.key) )
		root->left = TreeInsert( root->left, newnode);
	else
		root->right = TreeInsert( root->right, newnode);
	
	return root;
}

int main()
{
	TreeNode *proot, *pnode;
	CreateTree( &proot );

   for(int idx = 0; idx < size; idx++)
	{
		pnode = MakeTreeNode( arr[idx] );
		proot = TreeInsert( proot, pnode );
		// TreeInsert( proot, pnode );	// This is an error case
	}
	...
}

If not use return from TreeInsert then changes to proot remains null. Whether or not use
called-by-reference or value, uses a local copy but its content and how to use it makes difference.
This shows how easy and clear it is to use reference than one of pointers.


{to-change}

for( auto c : str )
	 cout << c << endl;

// want to change
for( auto &c : str )
	 c = toupper(c);


{return-reference}

// where back() returns a reference
auto &v = container.back();
auto v = container.back();


{return-reference-vs-copy}

Beware a func that returns copy or reference. {quiz} maybe a quiz?

class screen {

public:
	screen() : move(0), set(0) {}
	<case-01> screen& set_move(int val) { move = val; return *this; }
	<case-02> screen set_move(int val) { move = val; return *this; }
	void set_set(int val) { set = val; }
	void print() { cout << "screen: move " << move << ", set: " << set << endl; }

private:
	int move;
	int set;
};

screen myscreen;
myscreen.set_move(5).set_set(10);
myscreen.print();

<case-01>

5, 10

<case-02>

5, 0

Because in <case-02> set_move return is [temp-object] and myscreen is copied to a temp-object. Then
set_set is called on this temp. 


==============================================================================
*kt_dev_cpp_014*	decltype, typedef, and using

{deltype-and-auto}
The 'auto' can use from func() return

string s("...");
decltype( s.size() ) count = 0;


{typedef-and-using}
typedef double wages;
using wages = double;	// C++11


{typedef-of-class}
Effectively, make alias to classA. Useful when class name changes. Seen in Tizen code. typedef is
just a synonym for some type (from ESTL)

typedef classA classB;


{typedef-example}
typedef struct treenode TreeNode;
typedef struct treenode {
	TreeEntry entry; // application dependent
	TreeNode  *left;
	TreeNode  *right;
} TreeNode;

or

typedef struct treenode {
	TreeEntry entry; // application dependent
	treenode  *left;
	treenode  *right;
} TreeNode;


This is to create a pointer typedef.

typedef struct _fsm
{
  VRM_FSM_INIT  init;
  ...

} *FSM_T;

FSM_T			   new_fsm = 0;


{typedef-multiple}
Is it error to have multiple typedefs? See {string-is-typedef} in *kt_dev_stl_015*

{class-vs-struct}
The only difference between struct and class is the default access specifier for members and
derivation; struct is public and class is private. p616 in ref-CPR.

{typedef-vs-struct}
struct view_class {
	const char *title;
	const char *style;
	Evas_Object *(*create)(struct viewmgr *vmgr);
	void (*update)(Evas_Object *base, Elm_Object_Item *it);
	void (*show)(Evas_Object *base, Elm_Object_Item *it);
	void (*hide)(Evas_Object *base, Elm_Object_Item *it);
	void (*resume)(Evas_Object *base, Elm_Object_Item *it);
	void (*pause)(Evas_Object *base, Elm_Object_Item *it);
	void (*terminate)(Evas_Object *base);
	int show_bg;
};

This is struct declaration and not a typedef. So need to use struct keyword to create a object.

static struct view_class _vclass = {
	.title = NULL,
	.style = "homepanel/apps/1",
	.create = _create,
	.update = _update,
	.show = _show,
	.hide = _hide,
	.resume = _resume,
	.pause = _pause,
	.terminate = _terminate,
	.show_bg = 0,
};

If it was a typedef then would use like:

static view_class _vclass = {
	.title = NULL,
	.style = "homepanel/apps/1",
	.create = _create,
	.update = _update,
	.show = _show,
	.hide = _hide,
	.resume = _resume,
	.pause = _pause,
	.terminate = _terminate,
	.show_bg = 0,
};


==============================================================================
*kt_dev_cpp_015*	declaration and definition

A declaration tells compilers about the name and type of something and a
definition provides compilers with the details a a declartation omits. For an
object, the definition is where compilers set aside memory for the object. For
a function or function template, it provides the code body. For a class or
class template, it list the members of the class or template.

{compilation}
From p656. Ordinarily, when call a function, the compiler needs to see only a declaration.
Similarly, when use objects of class type, the class definition must be available but the definition
of the member functions need not be present. As a result, put class definition and function
declaration in header file and definition of ordinary and class member function is source files.

{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for that function. This
is true. The code below works fine with no errors.

#include <iostream>

class AA {
  public:
  void member_defined() { std::cout << "has definition" << std::endl; }
  void member_nodefined();
};

int main()
{
  AA aa;

  aa.member_defined();

  return 0;
}

However must define every virtual function regardless of whether it is used because do not know
which version of a function is called until run time.

extern int i;		// declare
int i;				// declare and define

void func(..);		// declare
void func(..)		// declare and define
{
	 ...
}

For class, see {class-definition} in *kt_dev_lang_010*


={============================================================================
*kt_dev_cpp_016*


={============================================================================
*kt_dev_cpp_017*	static-members and class const

The staic-members that are associated with the class rather than objects. So can call
static-member-func as <class-method> or <class-operation> as in smalltalk. Then <class-variable> or
<class-static> for static member var. See <function-static> for this term.


{static-member-func-and-this}
The static-member-func don not bound to any object; do not have a this pointer. Aa a result
static-member-func may not be declared as const. 


{init-class-variable}
The objects do not contain data associated with class-static. When initialized? The default
constructor 'implicitly' default initialize static-member-variable. The class-static
<must-be-defined-and-inited> outside of class because it's global objects.

<in-h>
class Foo {
  private:
    static double interest;					// declare
};

<in-cpp>
double Foo::interest = initRate();			// define and init


{class-const}
EC++02. If it's const, it limit the scope of a constant to a class and can use in-class-init. Hence
it's called class-variable and be static. Otherwise got error:

usecomma.cpp:8:13: error: invalid use of non-static data member ‘Foo::MAX’

<in-h>
class Foo {
  private:
    static const double interest = 30;		// declaration. in-class-init. 
    double table[ interest ];             // can be used.
};

<in-cpp>
This class-const of integral type can be used in class definition without definition. But used in
other context such as passing it to func arg, must define.

double Foo::interest;							// definition and 'must' not init


{what-class-method-can-access}
The static member func, class-method, do not have [this-pointer] because no need to distinguish
objects and this means static member func can only use static member data.


{summary}
After all, class-method and class-variable is to provide safer way to golbal objects.

o SCOPE. easy access as global, no need to create an object to use, but in the class scope.
o created only when it is used. It is true for <function-static> in {limit-the-number-of-object}.
o to solve {init-order-problem}

The bottom line is that static is global but we can limit its scope to file, class, or function.


==============================================================================
*kt_dev_cpp_018*	dtor			{non-virtual-destruction-problem}

{running-order}
It is opposite to ctor in destruction order; dtor body first and then implicit member destruction
under inheritence, 

------------> ctor
base 	derived
<------------ dtor

<example>
#include < iostream>

using std::cout; using std::endl;

class Base {
    private:
		 int m_iDataABCAnimal;
    public:
		 Base() { cout << "base ctor" << endl; }
		 ~Base() { cout << "base dtor" << endl; }
};

class Derived: public Base {
    private:
		int m_iDataAnimal;
    public:
		Derived() { cout << "derived ctor" << endl; }
		~Derived() { cout << "derived dtor" << endl; }
};

int main(int argc, char** argv)
{
    Derived dobj;

    cout << "end of main" << endl;
}

$ ./a.out 
base ctor
derived ctor
end of main
derived dtor
base dtor

KT: This is staic binding so compiler knows that this is derived object. Regardless of binding type
derived dtor has a call to base dtors. This {non-virtual-destruction-problem} only mean to fail to
pick up derived dtor since it goes through vtable.


{syn-version-is-non-virtual} {dtor-in-derived-classes}
The dtor is one of copy controls in *kt_dev_cpp_003* and means if not defined, the compiler will make
one which is non-virtual if it is not a class inheriting from a base which has a virtual dtor.  

The virtual is only used in class definition and for other functions, if it's virtual in base then
all overrides in derived classes are virtual. How about dtor? That's the same. 

Unlike the constructors and assignment operators, the destructor is reponsible only for destroying
the resources allocated by the derived class. From user or programmer POV.


{non-virtual-destruction-problem}
EC++07. Problem case: when dtor phase is run and derived-to-base(pointer) is used where the base
class don't have virtual dtor. 

In GCC spec, it will have 'undefined' result but in reality, destroy only the base part; partially
destroyed. In GCC, no runtime error in simple test. 

This is the same for other member functions. That is if miss out virtual keywords in a base, then
will have only base version even if expected derived version. Therefore, there are two cases when
override do not happen; one when argument is different and see {override-keyword} and one when miss
out virtual keyword in a base as shown here.

<example-code>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;
  public:
    Base() { cout << "ctor: base" << endl; }
    ~Base() { cout << "dtor: base" << endl; }				// [case-01]
    virtual ~Base() { cout << "dtor: base" << endl; }		// [case-02]
};

class Derived: public Base {
  private:
    int m_iDataAnimal;
  public:
    Derived() { cout << "ctor: derived" << endl; }
    ~Derived() { cout << "dtor: derived" << endl; }
};

class DDerived: public Derived {
  private:
    int m_iDataDAnimal;
  public:
    DDerived() { cout << "ctor: derived derived" << endl; }
    ~DDerived() { cout << "dtor: derived derived" << endl; }
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Base* pbase = new DDerived;

  delete pbase;

  std::cout << "--} main " << std::endl;
}

For case-01:

$ ./a.out 
--{ main 
ctor: base
ctor: derived
ctor: derived derived
dtor: base
--} main 

For case-02:

$ ./a.out 
--{ main 
ctor: base
ctor: derived
ctor: derived derived
dtor: derived derived
dtor: derived
dtor: base
--} main 


<explanation-one>
KT. Why only base part when no virtual dtor? Use [static-type]. The static-type is base class but no
virtual. So do not run down virtual to derived. Hence runs base dtor only. 

If base dtor was virtual, will run down virtual path and start from derived dtor which calls chains
up to base. This means that every base shall have virtual dtor. 

<explanation-two> {how-virtual-works}
KT. Why only base part when no virtual dtor? Simply derived class's vtable is not updated and still
have base one. Hence base dtor calls. 

Class1 (base)  <- Class2 (derived)

vtable            vtable
[1] -> C1::f2     [1] -> C2::f2  [virtual]
[2] -> C1::f1     [2] -> C1::f1  [non-virtual] dtor

If base dtor was virtual, will have code to follow vptr and to call derived dtor which calls chains
up to base. This means that every base shall have virtual dtor. 

From {summary-dynamic-binding}, {scope-in-inheritance}, {how-vtable-works}, {override-keyword} can
conclude: for non-virtuals use static and for virtuals use vtables.

class A vtable  class B vtable  class C vtable
[1] A::f        [1] { A sub     [1] { A sub
[2] A::f        [2] }           [2] }      
                [3] B::f        [3] { B sub
                [4] B::f        [4] }
                                [5] { C sub
                                [6] }

vptr            vptr            vptr
instances of A  instances of B  instances of C

For C's instances, if there are overrides, update its vtable and if not, sub objects remains the
same. That explains how override and virtual works.


{when-use-virtual-dtor}
Because there are costs of virtuals and virtual-destruction-problem, All BASE class must have
virtual-dtor and these are <1> and <2> as advised in EC++07.

<1> polymorphic base class
designed for inheritance and defined virtual funcs. 'must' use virtual dtor.

<2> base class to extend 
designed for inheritance but no virtual funcs. means no overrides and add more funcs. However, if no
virtual dtor, this causes virtual-destruction-problem. 

<3> a class not to be inherited
designed for no inheritance like STL. DO NOT use virtual-dtor sicne it will increate a size of
instance and make it not portable. See {preventing-inheritance} 


{pure-virtual-dtor}
EC++07. Why use this? Sometimes you have a class that you'd like to be abstract but you don't have
any pure virtual functions. Like <2> base class to extend. 

class AWOW {
  public:
    virtual ~AWOW() = 0;
};

AWOW::~AWOW() {}

The pure-virtual-dtor [must] have a definition(implementation) and [must] be implemeted outside
class definitions.

MEC++33. Pure virtual do not mean it has no implementation and means that the class is abstract and
the derived func must be nomal virtual. True, most pure virtual functions are never implemented, but
pure-virtual-dtor are a [special-case]. They must be implemented, because they are called whenever a
derived class destructor is invoked.  

<example-when-pure-virtual-has-implementation>
#include <iostream>

using std::cout; using std::endl;

class Base {
  private:
    int m_iDataABCAnimal;

  public:
    virtual ~Base() {};
    virtual void shout(void)=0;
};

void Base::shout(void)
{ cout << "base shout" << endl; }

class Derived: public Base {
  private:
    int m_iDataAnimal;

  public:
    void sample() { cout << "sample: derived" << endl; }
    void shout(void) { Base::shout(); cout << "derived shout" << endl; }
};

int main()
{
  std::cout << "--{ main " << std::endl;

  Derived d;
  d.shout();

  std::cout << "--} main " << std::endl;
}

<example-error>
class ABCAnimal {
  public:
    ...
      virtual ~ABCAnimal() = 0;     # pure-virtual-dtor
};

class Lizard: public ABCAnimal {
  public:
    ...                             # no dtor
};

int main(int argc, char** argv)
{
  ABCAnimal* pabc1;
  ABCAnimal* pabc2;

  cout << "end of main" << endl;
}

Upto here, NO comile error and works fine. However, the following emits errors:

int main(int argc, char** argv)
{
  ABCAnimal* pabc1;
  ABCAnimal* pabc2;

  Lizard liz1;

  cout << "end of main" << endl;
}

GCC error is:

/tmp/cciltEbG.o: In function `Lizard::~Lizard()':
abc.cpp:(.text._ZN6LizardD2Ev[_ZN6LizardD5Ev]+0x16): undefined reference to `ABCAnimal::~ABCAnimal()'
collect2: ld returned 1 exit status

To fix this, add implementation:

class ABCAnimal {
  public:
    ...
      virtual ~ABCAnimal() = 0;       # pure dtor
};

ABCAnimal::~ABCAnimal() {}


={============================================================================
*kt_dev_cpp_019*	exception

{intention}
The exception is intended for events that prevent the program from continuing normally. so when
found no matching catch and stop execution of the program; call the library 'terminate' function.

From MEC++09. What's different to the approach of returning error code? Exception cannot be ignored
and if do, it is terminated. From MEC++12. The execution return to call site for func call but never
for exception. Think that throw is a function call.


{standard-exception}
The stdexcept header defines several general purpose exception classes and the typeinfo header
defines the bad_cast exception type. 

The C++ Standard library provides a base class specifically designed to declare objects to be thrown
as exceptions. It is called std::exception and is defined in the <exception> header. This class has
a virtual member function called what that returns a null-terminated character sequence and that can
be overwritten in derived classes to contain some sort of description of the exception. KT. It seems
that exception header is older one and both works anyway.

// exceptions
#include <iostream>
// #include <stdexcept>
#include <exception>

using namespace std;

class myexception: public exception
{
  virtual const char* what() const throw()
  {
    return "My exception happened";
  }
} myex;

int main () {
  try
  {
    throw myex;      <DN> See myex but not myex()
  }
  catch (exception& e)
  {
    cout << e.what() << '\n';
  }
  return 0;
}

kt@kt-ub-vb:~/work$ ./a.out 
My exception happened

All exceptions thrown by components of the C++ Standard library throw exceptions derived from this
exception class. These are:

bad_alloc	      thrown by new on allocation failure
bad_cast	         thrown by dynamic_cast when it fails in a dynamic cast
bad_exception	   thrown by certain dynamic exception specifiers
bad_typeid	      thrown by typeid
bad_function_call	thrown by empty function objects
bad_weak_ptr	   thrown by shared_ptr when passed a bad weak_ptr

Also deriving from exception, header <exception> defines two generic exception types that can be
inherited by custom exceptions to report errors:

logic_error	      error related to the internal logic of the program
runtime_error	   error detected during runtime


{stack-unwinding}
A throw-keyword is like a return; statements following a throw are not executed. If no
<matching-catch> found, current/calling function is exted until found in the call tree.

o not found. call 'terminate'. 
o found. run catch and coutinue running from the the end of the try block catched but not from the
throw.

When no try-catch block in the chain, 1,2, and 3 runs only.  

func3()              func2()                func1()
{                    {                      {
	 (1)                   (2)                    (3)
	 func2();              func1();               throw...;
	 (6)                   (5)                    (4)
}                    }                      }


During stack-unwinding, func exits prematurely and means local objects are dstroyed and dtor is
called.


{exception-in-ctor}
Partially constructed. Even if it's partially constructed, guaranteed that the constructed members
will be properly destroyed. From EC++30 p137 and see {empty-ctor-represenstaion}

But from MEC++10, it shows many ways to handle exceptions in ctor so not sure that it is properly
destroyed. Seems EC++ is the latest.


{function-try-block}
Primus p773, 18.1.3 shows function-try to handle exception when do {constructor-initializers} This
is for ctor and dtor as well and to handle exceptions happens before ctor body get runs because
exception handling in ctor cannot catch it.

o The members are initialised in the order of defined in class.
o The parameters are copied using copy-ctor. covered in caller site.
o Runs constructor-initializers if there are. covered by function-try-block.
o Runs ctor-body. covered by function-try-block.

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) : data( std::make_shared< std::vector<T>> (il)) 
{}

template< typename T>
Blob<T>::Blob( std::initialzer_list<T>il) try : data( std::make_shared< std::vector<T>> (il)) 
{}
catch ( const std::bad_alloc& e) { handle_out_of_memory(e); }


{problem-of-exception-in-dtor}
Why exception in dtor is the problem? because as said, func call tree can exit prematurely during
stack-unwinding and this means local objects are destroyed. If dtor can raise an execption, ends up
having two exception which is not allowed so terminate will be called. EC++08 says that terminate is
called or undefined. Hence 

o The <permature-program-termination> which can means no chance to do useful things to handle
exception such as clean-up and to do what is useful before terminating or swallowing. For example,
make a log entry. This is a main problem since premature termination means that it can mean
undefined state of a system.

So usually no exception in dtor and if do, should handle in the same dtor. STL guarantee thar dtor
will not raise an execption.


{exception-and-resource-managing-class}
To handle exception, shall use resource-managing-class, ie., raii and see {resource-managing-class}
in *kt_dev_stl_018* for various solutions.


{how-to-handle-exeception-in-dtor}
See {raii-for-resource-using-own-interface} for other examples. From EC++08. General recommendation
is not to raise exception in dtor. If interface to use comes from external source then it could
raise an exception. What to do? These are how to handle when exception happens in dtor.

class DBConnection {
  public:
    ...
    static DBConnection create();    // fatctory-func
    void close();                    // can throw exception
};

// resource managing class
class DBConn {
  public:
    ~DBConn() { db.close(); }        

  private:
    DBConnection db;
};

// client use
//
{
  DBConn dbc( DBConnection::create() );
  ...
}

Two approach to address exception in dtor:

<1> terminate the program
By doing this, make a log entry to see and prevent undefined behavior.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
    std::abort();
  }
}

Can use {noexcept} at below? Seems not as it has the same effect when not handling exaction from a
dtor: no chance to do useful thing such as making a log entry.

<2> swallow the exception
Can be used when the program must be able to continue execution even after exception is happened and
ignored.

DBConn::~DBConn()
{
  try{ db.close() }
  catch(...) {
    // make log entry
  }
}

<3> However, said that the better way is:

class DBConn {
  public:
    void close()
    {
      db.close();							// can exception happen
      closed = true;
    }

    ~DBConn() 
    { 
      if(!closed)
      {
        try { db.close(); }			// resource managing class
        catch(...) {
          // make log enrtry
          // terminate or swallow
        }
      }
    }

  private:
      DBConnection db;
      bool closed;
};


The client have an opportunity to handle the exception and if the client choose not to handle it
then fall back to default action: terminating or swallowing. It appears that it make raii less
useful and pass the burden on to the client but it is not since it gives them opportunity to handle.
it. See {raii-and-exception-in-dtor} for the point to consider when use raii.

// client use
{
  DBConn dbc( DBConnection::create() );

  try{ DBConn dbc.close() }
  catch(...)
  {
    // try to address exception and if successful, set closed to true.
  }
}


{exception-object} {user-defined-exception-object}
Use throw-expression [to-copy-init-special-object], exception object. if it's a class type, must
have dtor and copy or move op. If it's array or func type, it's converted to its pointer type. {QQ}
If it is array, must be in heap since there is no connection between call and called site?

try {
  ...
  throw runtime_error("data must refer to the same");	# throw expression

} catch (runtime_error err) {		                     # exception declaration
  ...
  cout << err.what();
  ...
}

Because there's a stack-unwinding, must not to throw a pointer to a local object. Hence exception
object is copied that is manintained by compiler and remains vaild <until> catched.

Exception is like a functin call and exception declaration is like a function with one param. Like
function call, [catch] param can be non-refernce or reference. If it's class type from inheritance
and non-reference then {sliced-off} *kt_dev_cpp_022* can happen. How can use reference in catch?
Since there is separation between throw and catch site. That is the exception object is held in
global space by a compiler.

throw arg -> (copy init) -> exception object -> (copy init) -> catch (param)

// example
#include <iostream>
using namespace std;

class B 
{
  public:
  B() { cout << "B ctor" << endl; }
  ~B() { cout << "B dtor" << endl; }
  virtual string what() { return "i'm B"; }
};

class CD : public B
{
  public:
  CD() { cout << "CD ctor" << endl; }
  ~CD() { cout << "CD dtor" << endl; }
  string what() { return "i'm CD"; }
};

int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

$ ./a.out 
B ctor
going to throw
B dtor
An exception occurred. Exception Nr. i'm B
B dtor
B dtor
end

See that 2 B dtors after catch. Why? One for the exception object and the other for one in the
catch.

<exception-catch-by-reference>
The catch by referecne is recommendation.

1. catch by pointer, do not know if should call delete on it because do not know if it is created by
new or not.
2. catch by value, sliced-off can happen.
3. catch by reference, okay for both problems above.

// example
In the above example, if change catch param as catch (B& e) then have only one B dtor after catch.

B ctor
going to throw
B dtor
An exception occurred. Exception Nr. i'm B
B dtor
end

// example
int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
CD dtor
B dtor
An exception occurred. Exception Nr. i'm B
B dtor
CD dtor
B dtor      <DN>
end

// example
int main () {
  try
  {
    CD b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (B& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

B ctor
CD ctor
going to throw
CD dtor
B dtor
An exception occurred. Exception Nr. i'm CD
CD dtor
B dtor
end

See that it's CD and no B dtor after catch.

// example
int main () {
  try
  {
    B b;
    cout << "going to throw" << endl;
    throw b;
  }
  catch (CD& e)
  {
    cout << "An exception occurred. Exception Nr. " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

What will happen?

kt@kt-ub-vb:~/work$ ./a.out 
B ctor
going to throw
terminate called after throwing an instance of 'B'
Aborted (core dumped)
kt@kt-ub-vb:~/work$ 

<exception-type-conversion-and-order>
Limited type conversion for exception. Support <inheritance-based-conversion> that means catch using
base class type can catch exception object of derived class. Also catch uses the order of appearance
in code, called <first-fit> strategy compared to <best-fit> in function-matching.

In STL exception tree, logic_error is up than invalid_argument

try {
	 ...
	} catch ( logic_error& ex ) {
	 ...
	} catch ( invalid_argument& ex ) {
	 ...
}

Should be:

try {
	 ...
	} catch ( invalid_argument& ex ) {
	 ...
	} catch ( logic_error& ex ) {
	 ...
}

Because if first-match is found then look no further. Menas that the second catch never gets run
regardless of throw type, whether it is logic_error(base) or invalid_argument(derived) since the
first catch always matches to both cases.

<exception-object-always-copied>
The execution returns to call site for func call but never for exception. This means that whenever
throw happens, a copy is <always> made regardless of catch type whether it is value or reference
because throw leaves a call site.

// example-one
catch( Widget& w )
{
  ...
  throw;
}

Use 'current' exception and throw it again. 'rethrow'. So there is no addtional copy made and w can
be a derived class in Widget inheritance.

// example-two
catch( Widget& w )
{
  ...
  throw w;
}

This create a new Widget type exception and cost create and copy operation. Also, always throw
Widget type. Therefore, <example-one> is recommended.

// example
int main () {
  try{
    try
    {
      B b;
      cout << "going to throw" << endl;
      throw b;
    }
    catch (B& e)
    {
      cout << "An exception occurred. Exception Nr. " << e.what() << endl;
      throw;
    }
  }
  catch (B& e)
  {
    cout << "catch rethrow: " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

kt@kt-ub-vb:~/work$ ./a.out 
B ctor
going to throw
B dtor
An exception occurred. Exception Nr. i'm B
catch rethrow: i'm B
B dtor      <DN>
end

// example
int main () {
  try{
    try
    {
      B b;
      cout << "going to throw" << endl;
      throw b;
    }
    catch (B& e)
    {
      cout << "An exception occurred. Exception Nr. " << e.what() << endl;
      throw e;
    }
  }
  catch (B& e)
  {
    cout << "catch rethrow: " << e.what() << endl;
  }

  cout << "end" << endl;
  return 0;
}

kt@kt-ub-vb:~/work$ ./a.out 
B ctor
going to throw
B dtor
An exception occurred. Exception Nr. i'm B
B dtor      <DN>
catch rethrow: i'm B
B dtor      <DN>
end


{exception-spec}
Older code may contain dynamic exception specifications. They are now deprecated in C++, but still
supported. A dynamic exception specification follows the declaration of a function, appending a
throw specifier to it. For example:

double myfunction (char param) throw (int);

This declares a function called myfunction, which takes one argument of type char and returns a
value of type double. If this function throws an exception of some type other than int, the function
calls std::unexpected instead of looking for a handler or calling std::terminate.

If this throw specifier is left empty with no type, this means that std::unexpected is called for
any exception. Functions with no throw specifier (regular functions) never call std::unexpected, but
follow the normal path of looking for their exception handler.

int myfunction (int param) throw(); // all exceptions call unexpected
int myfunction (int param);         // normal exception handling 

<noexcept-keyword>
void recomp(int) noexcept;		// C++11 style
void recomp(int) throw();		// old style

The noexcept on both the declaration in the class header and on the definition if that appears outside
the class.

class Foo {
  public:
    Foo( Foo&& ) noexcept;
    ...
};

Foo::Foo( Foo && ) noexcept : /* member initializers */
{
  ...
}

Note: The nothrow-keyword is the same as noexcept but used in new-operator expression. See
{placement-new} in *kt_dev_stl_019*

It is to state that a func will not throw an exception and is checked at runtime. If an exception
happens even if it's declared it will not, 'terminate' is called. since it is mismatch as
<exception-spec-mismatch> So two use cases:

o when absolutly sure that there's no exception.
o when not possible to handle an exception. exit the program.

<exception-spec-mismatch>
MEC++14. If there is a mismatch of 'spec' between throw and catch <permature-program-termination>
happens: unexpected() -> terminated() -> abort(). This means no clean-up so should be avoided.

// example

extern void f1();       // may throw anything
void f2() throw (int);  // says it will throw only int type exception

void f2() throw (int)
{
	 ...
	 f1();
	 ...
}

By this, can wrap old code with new code that handles exception. But if f1() raise exception other
than int type, 'violate' f2's exception specification.

How to minimise these?

<1> do not mix template and exception spec because do not know T type so not able to write spec.
<2> change default handler, unexpected(), to handle those. For example, if we use a library that
raise unexpected exception:

<default-exception-handler>

class UnexpectedException { };

void convertUnexpected()
{ throw UnexpectedException(); }

set_unexpected( convertUnexpected );

This convert <all-unhandled-exception> to UnexpectedException and there should be catch for that
type. This means to set default exception handler.

OR

void convertUnexpected()
{ throw; }

set_unexpected( convertUnexpected );

This convert all to <bad_exception> but no detail about why. Q: why bad_exec?

<another-permature-program-termination>
This can block a exception handling of higher level. If logDestruction is declared that raise no
exception but raise it, then terminated and do not reach to ~Session().

Session::~Session()
{
  try {
    logDestruction(this);
  }
  catch(...) { }
}


{self-assign-exception-safe}
See {self-assign} for reasons why need to handle self-assign. Also if not, then it's not exception
safe as well. If this is exception safe, then lhs state shouldn't change when new raise exception,
but the below don't and the below isn't exception safe.

// NO self-assign and exception-safe in valuelike case
// 
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  delete ps;
  auto newp = new string(*rhs.ps);
  ps = newp;
  return *this;
}

// combine dtor and copy. handle self-assign and exception-safe by moving delete after new.
// <careful-statement-ordering>
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps);
  delete ps;
  ps = newp;
  return *this;
}

EC++11. Making operator= exception-safe typically renders it self-assign-safe too. So think about
exception-safe only. Alternatively, can use {copy-and-swap-idiom} in *kt_dev_cpp_006*


{exception-safe-gurantees}
EC++29. Two requirements for exception safety when exception happens:

NO resource leak and NO change of object state.

Therfore, a function can offer one of four gurantees:

1. None. not exception-safe.
2. basic. valid object state.
3. strong. unchaned object state.
4. noexcept. never.
 
The following offers 'almost' strong guarantee when param Image ctor can emit exception in ctor :

// from the bad exaple
//
void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
	 delete bgImage;
	 ++imageChanges;
	 bgImage = new Image(imgSrc);
};

// offer strong
//
class PrettyMenu {
	 ...
	 std::shared_ptr< Image > bgImage;
	 ...
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
	 bgImage.reset( new Image(imgSrc) );	// bad_alloc or ctor exception
	 ++imageChanges;
};

The deletion of old image takes place only if the new image is successfully created because reset
will be called only if the parameter is successfully created.

General design to lead to the strong guarantee: use {copy-and-swap-idiom} and {pimpl-idiom} in
*kt_dev_cpp_006* 

<copy-and-swap-idiom-case>

HasPtr& HasPtr::operator=(const HasPtr rhs)	// note. not ref and it's copy
{
	 ... operations to change the copy
	 swap(*this, rhs);
	 reutn *this;				// rhs is destroyed, which deletes the old ps.
}

Make all needed changes to the copy. If any of the modifying operation throws an exception, the
original remains 'unchanged'. After all changes have been successfully completed, swap the modified
with the original in non-throwing op. 


<pimpl-idiom-case>

The object has a pointer to the implementation that has all object data. This can be rewritten as
general design although offer no better gurarantee than the previous for this particular example.

struct PMImpl {
	 std::shared_ptr< Image > bgImage;
	 int imageChanges;
};

class PrettyMenu {
	 private:
	 std::shared_ptr< PMImpl > pImpl;
};

void PrettyMenu::changeBackGround( std::istream& imgSrc )
{
	 using std::swap;

	 std::shared_ptr< PMImpl > pNew( new PMImpl(*pImpl) );

	 pNew->bgImage.reset( new Image(imgSrc) );	// bad_alloc or ctor exception
	 ++pNew->imageChanges;

	 swap(pImpl, pNew);
};

Note: copy-and-swap-idiom is a good way for strong only when operates on local object or state than
golbals.


{rethrow}

Partially handle the exception and rethrow it up to the chain.

catch( myerror& eobj ) {
	 eobj.status = errCodes::severeErr;
	 throw;
}


{exception-cost}
MEC++15. Exception has cost:

<1> If not use exception, can save speed and space penalty. There is compiler option to disable it.

<2> the cost of try and exception spec in space varies from compiler to compiler. As a rough
estimate, expect your overall code size to increase by 5-10% and your runtime to go up by a similar
amount if you use try blocks. So try to minimise the use.

But think 80-20 rule and that exception is rare. The recommendation is that think if it is feasible
not to use exception, if can minimise, if can use other compiler showing better exception
implementation, and if use profiler to find out 20% to use exception.

<exception-to-disable>
From stackoverflow and said G++ specific.

Option #1: Simply never catch exceptions. {QQ} really?

Exceptions don't have much overhead when they're not thrown or caught; if you're throwing and not
prepared to catch, well, you're doing to die anyway, so the performance impact at that point is
trivial. Note also that stack unwinding will not be performed if an exception is not handled; the
program will simply terminate without performing stack unwinding.

It's important to note that, in G++, exceptions have almost no overhead when not actually thrown.
G++ generates extra information sufficient to trace back the execution of the program through the
stack, and some extra code to invoke destructors, etc - however none of this extra code or data is
ever used until an exception is actually thrown. So you should not see a performance difference
between code with exceptions enabled but not used and code with exceptions disabled (through
whatever mechanism).

Q: not sure it means never throw or never catch.

Option #2: Pass -fno-exceptions.

This flag instructs G++ to do two things:
http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_exceptions.html

	 All exception handling in STL libraries are removed; throws are replaced with abort() calls
	 Stack unwind data and code is removed. This saves some code space, and may make register
	 allocation marginally easier for the compiler (but I doubt it'll have much performance impact).
	 Notably, however, if an exception is thrown, and the library tries to unwind through
	 -fno-exceptions code, it will abort at that point, as there is no unwind data.

This will, effectively, turn all exceptions into abort()s, as you would like. Note, however, that
you will not be allowed to throw - any actual throws or catchs in your code will result in a
compile-time error.

Option #3: (Nonportable and not recommended!) Hook __cxa_allocate_exception.

C++ exceptions are implemented using (among others) the __cxa_allocate_exception and __cxa_throw
internal library functions. You can implement a LD_PRELOAD library that hooks these functions to
abort():

void __cxa_allocate_exception() { abort(); }
void __cxa_throw() { abort(); }

WARNING: This is a horrible hack. It should work on x86 and x86-64, but I strongly recommend against
this. Notably, it won't actually improve performance or save code space, as -fno-exceptions might.
However, it will allow the throw syntax, while turning throws into abort()s.


={============================================================================
*kt_dev_cpp_020* move semantics

{why}
In some of these circumstances, an object is immediately destroyed after it is copied. In those
cases, moving rather than copying the object can provide a significant performance boost. 

Or IO or unique_ptr classes which cannot be copied but can be moved.

Note: In previous library, class stored in a container had to be 'copyable'. Under new standard, can
use container on types that cannot be copied so long as they can be moved.

<problem-example>
StrVec example which is a simplification of the library vector class. Like vector, supports
reallocation. If there is not space left, then obtains new space, moves the existing elements into
that space, free the old space, and adds the new elements.

When copy a string, the new and the old are 'independent' from each other and there are two users.
However, when reallocates copies, there will be only 'one' user after the copy. As soon as copy is
done, will immediately destory the old.

Copying the old is 'unnecessary' in this case so StrVec's 'performance' will be much better if can avoid
the overhead of allocating and deallocating the 'strings' themselves each time we reallocate.

<how-to-avoid-copy>
Two facilities by C++11. 

First, several library classes, including string, define so called 'move constructor' but the detail
of implementation are not disclosed. Presumably the string move ctor copies the pointer rather than
allocating spaces.

Second, the library 'move' which is defined 'utility' header. Two things. must use move to signal it
want to use the string move ctor and use std::move() not move().

| 0 | 1 | 2 | 3 | 4 | unconstructed elements |

^                     ^                        ^
elements              first_free               cap

class StrVec {
  public:
    std::string* begin() const { return elements; }
    std::string* end() const { return first_free; }
    ...
  private:
    std::string *elements;
    std::string *first_free;
    std::string *cap;
    ...
};

void StrVec::reallocate()
{
  auto newcapacity = size() ? 2 * size() : 1;
  auto first = alloc.allocate(newcapacity);

  auto last = first;
  auto elem = elements;

  for( size_t i = 0; i != size(); ++i )
    alloc.construct( last++, std::move(*elem++) );    // note. move() which is string::move

  free();   // member which destroy and deallocate old container StrVec object. see below.

  elements = first;
  first_free = last;
  cap = elements + newcapacity;
}


{rvalue-reference} # important property
An rvalue reference is obtained by using '&&' rather than '&'. Has important property that be bound
ONLY to an object that is about to be 'destroyed'. As a result, free to 'move' resource from an
rvalue reference(moved-from) TO another object(moved-to).

<lvalue-and-rvalue>
In C, lvalue could stand on the left-hand side of an assignment whereas rvalues could 'not'. In C++
this distinction is less simple. Generally speaking, when use an object as an rvalue, use the
object's value(its contents) and when use lvalue, use the object's identity (its location in
memory).

From ansic: In c, any assignment, such as "c = getchar()" is an expression and has a value, which is
the value of the left hand side after the assignment. This means that an assignment can appear as
part of a larger expression, such as "while((c = getchar()) != EOF)"

These, lvalue/rvalue, are 'properties' of an expression. Expressions yield or require rvalue/lvalue.
Operators differ as to whether require lvalue or rvalue operands and as to whether return lvalue or
rvalues. Some yield or require lvalues and others yield or require rvalues:

Assignment requires a (nonconst) lvalue as its left hand operand and yields its left-hand operand as
an lvalue.

The address-of operator(&) requires an lvalue operand and returns a 'pointer' to its operand as an
'rvalue'.

<bindings> like const 
Binding properties for lvalue reference is that cannot bind regular(lvalue) reference to expression
that requires a conversion, to literals, or to expression that return an rvalue. Rvalue properties
have the opposite. The important point is that can use lvalue when an rvalue is required but cannot
use an rvalue when lvalue is required.

int i = 42;
int &r = 1;
int &&rr = i;           // error since cannot bind an rvalue reference to an lvalue
int &r2 = i*42;         // error since i*42 is rvalue.
const int &r3 = i*42;   // okay
int &&r2 = i*42;        // okay

<ravlue-is-temporary> implicit move sementics
Functions that 'return' a nonreference type, along with the arithmetic, relational, bitwise, and
postfix increment/decrement operators, all yield rvalues. So can bind rvalue to such expressions.

Looking at the list of rvalue and lvalue expressions, lvalue has 'persitent' state, whereas rvalue
are either literals or 'temporary' objects created in the course of evaluating expressions.

We know that: the referred-to object is about to be destroyed and there can be 'no' other users of
that object. So the code that uses an rvalue reference is free to take over resources from the
object to which the reference refers.


{std-move}
This is defined in <utility> header and to return rvalue reference to its given object.

int &&rr = std::move(rr1);
moved-to             moved-from

Essentially to tell compiler that we do 'not' intend to use rr1 again 'except' to assign to it or
destroy it. After move, cannot make any assumptions about the value of the moved-from object. Q: Why
assign?

<not-move>
To avoid name collisions, should use std::move, not move. p798.


{move-constructor}
See copy ctor and move ctor in comparison.

void StrVec::free()
{
  // may not pass deallocate a null pointer
  if(elements)
  {
    for( auto p = first_free; p != elements; /* empty */ )
      alloc.destroy(--p);

    alloc.deallocate( elements, cap - elements );
  }
}

StrVec::~StrVec() { free(); }

StrVec::StrVec( const StrVec& s)
{
  // to allocate exactly as many elements as in s
  auto newdata = alloc_n_copy( s.begin(), s.end());
  elements = newdata.first;
  first_free = cap = newdata.second;
}

See NO const in parameter. noexcept since do not allocate any new memory and take over the memory
from its argument. note on noexcept syntax and see <noexcept-keyword> for more.

After move, the moved-from object continues to exist and eventually will be destroyed, meaning that
the dtor will be run on that. That is 'why' set member ptrs null not to pass members to deallocate
memory in free(). 

StrVec::StrVec( StrVec&& s) noexcept
// member initializers take over the resources in s. note. this is move.
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  // leave s in a state in which it is safe to tun the dtor
  s.elements = s.first_free = s.cap = nullptr;
}

<why-noexcept-needed>
The library containers provide guarantees as to what they do if an exception happens. As an example,
vector guarantees that if an exception happens when call push_back, the vector itself will be left
unchanged.

Imagine that push_back in StrVec causes reallocation as vector, uses move ctor but exceptions
happens in the middle of moving. There would be a problem. However, if used copy ctor, not a problem
when exception happens since the original copy still remains. Like, exception safe condition in
using dynamic resources.

To avoid this potential problem, vector must use a copy ctor instead move during reallocation
'unless' it knows that 'element's type move ctor cannot throw an exception. How to do? Do so by
using noexcept keyword and explicity tell the library that move ctor is safe to use. 

Q: How actually does the library know what to use? 

note. KT. Whreas copy controls are more of necessary to work properly, move controls are more of
performace choice since if there are not, copy controls will be used.


{move-assign}
The move assign does the same work as the dtor and the move ctor. If move assign won't throw any
exceptions, should make it noexcept and must guard against self-assignment.

StrVec &StrVec::operator=( StrVec&& rhs) noexcept
{
  // direct test for self-assignment
  if( this != &rhs )    // note see &rhs
  {
    // free existing elements
    free();    

    // member initializers take over the resources from rhs. this is move as with move ctor.
    elements = rhs.elements;
    first_free = rhs.first_free;
    cap = rhs.cap;

    // leave rhs(moved-from) in a destructible state
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }

  return *this;
}

<destructible-state>
Moving from an object does not destroy that object. Therefore, must ensure that the moved-from
object is in a state in which the dtor can be run. In this example, memebers are 'pointers' and if
not set these as null, there shall be a problem when dtor runs and calls free().

In addition to that, move operations guarantee that the object remains 'valid' meaning that can runs
operations but no guarantees/assumptions about its value.


{synthesized-move-operations}
If class do not define copy ctor and assign then compiler 'always' make these operations; defined
either as memberwise or deleted.

Move operations are different. The compiler make move operations 'only' if a class does 'not' define
any copy ctor and assign and 'only' if all data members can be move ctored and assigned. So if class
has own copy ctor and assign then move will not be synthesized.

// the compiler will synthesize the move operations for X and hasX
struct X {
  int i;
  std::string s;
};

struct hasX {
  X mem;
};

X x, x2 = std::move(x);          // use the synthesized move ctor
hasX hx, hx2 = std::move(hx);

If class defines either move ctor and/or move assign, the synthesized copy ctor and copy assign will
de defined 'deleted' So class that define move operations 'must' also define own copy operations.
Otherwise, those members are deleted by default.


{copy-or-move}
Compiler use ordinary function matching to determine which to use. copy takes const StrVec& and move
takes StrVec&&.

StrVec v1, v2;
v1 = v2;                   // <1> copy assign
StrVec getVec(istream &);  // assume getVec returns an rvalue
v2 = getVec(cin);          // <2> move assign
   
<1> move not viable since cannot implicitly bind lvalue to rvalue.
<2> both are viable but copy assign requires conversion to const. Hence move is used.

<moved-by-copy>
Using the copy controls in place of move controls is safe and will meet the requirement of move
controls since objects is moved by copying operations. So copy will be used if no move operations.

If a class has no move operations, copy operations will be used 'even if' attempt to use move by
calling std::move().

// define copy but no move operations
class Foo {
  public:
    Foo() = default;
    Foo(const Foo&);
};

Foo x;
Foo y(x);                  // copy ctor
Foo z( std::move(x) );     // copy ctor

Here copy initialization happens but std::move returns Foo&& and can convert a Foo&& to const Foo&.
So copy ctor is viable and called.

<function-matching>
If add move ctor to HasPtr class then effectively add move assign as well. The assign operator is
both the move and copy assign. Note that this is from copy-and-swap-idiom which is for valuelike
case. Hence move is safe.

class HasPtr {
  public:
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i), { p.ps = 0; }

    // HasPtr& operator=(const HasPtr rhs)
    HasPtr& operator=(HasPtr rhs)
    { swap(*this, rhs); return *this; }
    ...
};

Depending on the type of argument, copy initialization for rhs uses either the copy ctor or the move
ctor.

HadPtr hp, hp2;

hp = hp2;
hp = std::move(hp2);

In the second assignment, std::move return rvalue and move ctor is the exact match so move ctor used
and the same assign code used.


{move-iterator-adoptor}
The StrVec::reallocate can be rewritten using move iterator which would be easier.

void StrVec::reallocate()
{
  auto newcapacity = size() ? 2 * size() : 1;
  auto first = alloc.allocate(newcapacity);

  // 'before'
  // for( size_t i = 0; i != size(); ++i )
  //  alloc.construct( last++, std::move(*elem++) );    // note. move()

  // 'after'
  auto last = uninitialized_copy( make_move_iterator( begin()), make_move_iterator( end()), first );

  free();   // member which destroy and deallocate

  elements = first;
  first_free = last;
  cap = elements + newcapacity;
}


{move-can-be-dangerous}
Since moved-from object has 'indeterminate' state, std::move is a dangerous operation. Judiciously
use class implementation such mover operations for significant performance benefit.

Use it in user code(outside of class implementation) ONLY when 'certain' that you need to do a move
and is guaranteeted to be safe.


{move-overload}
class StrVec {
  public:
    void push_back( const std::string& );
    void push_back( std::string&& );
    ...
};

void StrVec::push_back( const std::string& s )
{
  chk_n_alloc();
  alloc.construct( first_free++, s );
}

void StrVec::push_back( std::string&& s )    // 'must' not const
{
  chk_n_alloc();
  alloc.construct( first_free++, std::move(s) );   // use string move ctor
}

StrVec vec;
string s = "some string or another";

vec.push_back(s);          // calls push_back(const string&)
vec.push_back("done");     // calls push_back(string&&). temporary string.


={============================================================================
*kt_dev_cpp_021*	op overload

For class type because cannot overload operations for built-in types.

{member-or-non-member}

Whether to implement op overloads as either a member or non-member?

<assign-op> 
assign("=") should be member.

<symmetric-op>
arith, equality, relational or mixed-type arith that is commutative should be non-member.  

Why? think string u = "hi" + s; since a literal do not have member operations.

<io-op>
IO ops(<<, >>) should be non-member and usually a friend. If these are member op then can use like:

Sales_data data;
data << cout;

This is against to usual syntax. Why? Because when overloading op, lhs must be a class in which op
is defined.

class Sales_data {
	 ostream& operator<<( ostream& str ) const;
};

If want to use usual syntax like cout << data then means to change STL ostream class but cannot.
Therfore, these ops should be non-member. TODO: more explanation.

ostream& operator<<( ostream& os, const Sales_data& item )
{
	 os << item.isbn() << " " << item.revenue() << ...
	 return os;
}

note: no const for ostream& since it writes to stream and change its status and const and reference
for Sales_data


{member-op}

For member op, the first(left hand, lhs) operand is bound to the implict this pointer. This implies:

data1 += data2;

is 'always' equi to:

data1.operator+=(data2);

why not 'data2.operator+=(data1);' as these are the same type? because 'data2 = data1+data2' is
different.


{function-object}
p571 in {ref-CPR}. If overload function call operator() then can use a object as if it's a func call
and 'call' a object. Hence function object. Must be a member and can have 'state' so it's flexible
than usual func.

struct absInt {
  int operator() (int val) const {
    return val < 0 ? -val : val;
  }
};

int i = -42;
absInt absObj;
int ui = absObj(i);
  
<with-state>
class PrintString {
  public:
    PrintString( ostream& o = cout, char c = ' ') : os(o), sep(c) {}

    # const member func. works well. {QQ} wondered why const as os may change its state?
    void operator() (const string &s) const { os << s << sep; }

  private:
    ostream& os; char sep;
};

PrintString printer;
printer(s);

PrintString errors( cerr, '\n' );
errors(s);

<stl-functional> # stl function object
The stl functional header defines a set of function object classes that represent the arithmetic,
relational, and logical operations. 

plus<T>, minus<T>, multiplies<T>, ...
equal_to<T>, not_equal_to<T>, ...
logical_and<T>, logical_or<T>, ...

The main use of function-object is often used to override the default operator used by an algorithm:
To make sort() sort elements in descending order while it do ascending order by default.

sort( sv.begin(), sv.end(), greater<string>() );

<how-it-works>
How relates to the element? How algorithm use the function-object? Is it possible to have different
type for the element type of container and the element type of function-object? How function object
gets the argument?

These stl class generates a call operator that invokes the corresponding operator of the underlying
element type.

namespace std {
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
};

To print out elements in string vector, can use for_each as below:

# create a temp PrintString object
for_each( vs.begin(), vs.end(), PrintString( cerr, '\n' ));

namespace std {
  template<typename Iterator, typename Operation>
    Operation for_each( Iterator act, Iterator end, Operation op)    // create Operation 'type' op
    {
      while( act != end ) {
        op(*act);                                                    // call op object
        ++act;
      }
      return op;
    }
}

<work-for-pointers>
p575. Recall that comparing two unrelated pointers is undefined. However, these library function
objects will work for pointers. The associative containers use less<key_type> and that means we can
define a set of pointers or use a pointer as the key in a map.

vector<string *> nameTable;
sort(nameTable.begin(), nameTable.end(), less<string *>());

<how-useful>
Again, compare example.

template <typename T>		# '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

This is function template and is useful. However, only supports '<' on type.  How about others such
as '>'? If write a template supporting function object, then supports whatever operations user
selects. See <template-default-argument> for more.

template <typename T, typename F = less<T>>
int compare( const T &v1, const T &v2, F f = F())
{
  if( f(v1, v2) ) return -1;
  if( f(v2, v1) ) return 1;
  return 0;
}


{function-type}
Assume to build a simple desk calculator and to define a function table to store pointers to these
callables since all have the same call signature. 

// ordinary function
int add(int i, int j) { return i+j;}

// lambda
auto mod = [](int i, int j) { return i%j; };

// function object
struct divide {
  int operator () (int denominator, int divisor) {
    return denominator/divisor;
  }
};

map<string, int(*)(int, int)> binops;

binops.insert( {"+", add} );
binops.insert( {"%", mod} );

The second is in error since like any other object, a callable object has a type and lambda type
does not match the type of the values in the map.

Can solve this using library type named function defined in functional header. This represent any
callables that has this call signature.

function<int(int,int)>

function<int(int,int)> f1 = add;
function<int(int,int)> f2 = divide();
function<int(int,int)> f3 = [](int i, int j) { return i%j; };

cout << f1(4,2) << endl;
cout << f2(4,2) << endl;
cout << f3(4,2) << endl;

Can redefine a map to build a calculator.

map<string, function<int(int, int)>> binops = {
  {"+", add},
  {"-", std::minus<int>()},
  {"/", divide()},
  ...
};

And when index a map, get a reference to the associated value, use

binops["+"](10,5);   // adds(10,5)
binops["-"](10,5);   // minus<int>(10,5)
...

See predicate in *kt_dev_stl_010*


==============================================================================
*kt_dev_cpp_022*	oop: inheritance

{subobject-and-derived-to-base-conversion}
The <dynamic-binding> at run-time so called run-time binding because <static-type> is different from
<dynamic-type> and it is from inheritance. This is:

pointer or reference of base class = the one of derived class;
<static-type>                        <dynamic-type>

1> this is an exception to normal type-match as this is a conversion between different types. See
{type-match-exceptions}

2> do not know which object to bind until runtime. 

Subobject is key to how inheritance and dynamic-binding works. From MEC++. Inheritance give rise to
pointer and reference with two different types: static and dynamic type.


{conceptual-structure-of-deirved-object}

| ----------- |
|  base part  |
| ----------- |
| drived part |	# non-static members
| ----------- |

Quote item; Bulk_quote bulk;

# implicit derived-to-base-conversion for ref and pointer.

Quote* p = &item;
p = &bulk;

Quote& r = bulk;

If do followings with p or r:

1: calls non-virtual funcs of base then get base version. static
2: calls virtual funcs of base then get derived version. dynamic
3: calls any func of derived then compile error. static
4: deference and copy then sliced-off. static

{QQ} How compiler know whether it is normal function or virtual function call?

class Bulk_quote : public Quote {
	 public:
	 	double net_price( std::size_t ) const override;
};

double print_total( ostream& os, const Quote& item, size_t n ) // [Quote-reference]
{
	 double ret = item.net_price(n);                            // [virtual-call]
	 os << ... ;
	 return ret;
}

Quote item;
Bulk_quote bulk_item;

print_total( item );          // Quote version
print_total( bulk_item );     // Bulk version. dynamic-binding.


{sliced-off} {static-binding} {dynamic-binding}
The staic binding is done at compile time. <copy-ctor> and <copy-assign> are func calls and
derived-to-base-conversion happens when base's copy-int and copy-assign is called. But knows only
about base and derived part is ignored because do copying and hence only know about <static-type>. 

class Foo {
  Foo(const Foo&);
  Foo& operator=(const Foo&);
};


KT: The above explanation is a bit vague. In summary, compiler always use <static-type> but use ~
dynamic-type only if it is virtual function call. ~

This should be revised as: The compiler always use static-type and if it is a virtual call then will
generate a code for run-time binding and could calls derived version. However, this could be broken
if fails to override in the derived.

// example-one where item is base and bulk is derived

Quote item(bulk);         # sliced-off
item = bulk;              # sliced-off

// example-two

From MEC++33. When there are concrete classes like this:

base <- derived1
     <- derived2

The problem case is:

o obj = obj;               # the same class. fine
o baseobj = derivedobj;    # sliced-off
o derivedobj = baseobj;    # compile error

From GCC:
sam_slice.cpp:51:7: error: no match for 'operator=' in 'lo = bo'
sam_slice.cpp:51:7: note: candidate is:
sam_slice.cpp:30:8: note: Derived& Derived::operator=(const Left&)
sam_slice.cpp:30:8: note:   no known conversion for argument 1 from 'Base' to 'const Derived&'

Note: this is a syn coy-ctor that a compiler created.

o *baseptr = *baseptr;     # the same class. fine
o *baseptr = *baseptr;     # diff. base = derived. sliced-off. <1>
o *baseptr = *baseptr;     # diff. derived = base. sliced-off. <2> [no-compile-error] 

Why different in result? Because a compiler use <static-type> and only base part will be copied for
<1> and <2>.

So two problems here:

o sliced-off with no comiple error when use pointer
o real programmers write code like this.

How can we make it compile error to flag up two cases, <1> and <2>, in compile time? That is to make
it difficult to use incorrectly. <Q> TODO: So what's the solution? need to summarise the followings again.

<approach-one> 
Make operator= virtual. May thought it can use virtual mechanism. MEC++ said that derived's version
will be called and shall have the same params for virual funcs. But the return can be different.

class Base {
private:
	Animal& operator=(const Base& rhs); 
	...
};

class Derived: public Base {
public:
	Derived& operator=(const Base& rhs);
	...
};

However, in GCC 4.6.3, the params of virtual function can be different and derived's version is not
called. Note: Q: Changed in C++11?

Note: MEC++ seems to be wrong as a compiler use static-type and base version gets called. So don't
need to consider.

Note: see {override-keyword} and need to sum up if needed.

<approach-two-and-three>
Make operator= private and protected. Do not work when *pbase1 = *base2;

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is private
sam_slice.cpp:92:13: error: within this context

sam_slice.cpp:16:8: error: 'Base& Base::operator=(const Base&)' is protected
sam_slice.cpp:92:13: error: within this context

So not a solution.


<approach-to-make-abstract-class>
To remove sliced-off cases, make the base abstract and all derived on the same level. MEC++ says it
as make non-leaf classes abstract.

This only enables copys between objects in the same class whether it is via object or pointer.

But MEC++ says it is more about uncovering the design need to have abstract class out of derived
classes.

{virtual-and-definition}
Ordinarily if we do not use a function, do not need to supply a definition for that function.
However must define every virtual function regardless of whether it is used because do not know
which version of a function is called until run time.

{virtual-and-resolution}
The compiler generates code to decide at run time which function to call when a virtual function is
called through a reference or pointer. This is run time binding and polymorphism in C++.

{preventing-inheritance}

<1>
class Last 'final' : Base { ... };

<2>
Use private ctor. See {{control-the-number-of-object}}


{init-in-inheritance}
Unless we say otherwise, the base part of a derived is default-init.

The usual way is:

class Disc_quote : public Quote {
	 public:

	 Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
	 	Quote(book, price), quantity(qty), discount(disc) {}

};

If omit base ctor, then base part, Quote, is default-init.

class Disc_quote : public Quote {
	 public:

	 Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
	 	quantity(qty), discount(disc) {}

};

As for ctor, copy controls must explicitly call base part and otherwise has 'oddly configured'
object such as the derived part copied as expected but the base part default-init. In other words,
dtor is the only exception where do only for its part. ~


class Base {
	 public:
	 	Base(int val) { ... }
};

class Left: public Base {
	 public:
	 	Left(int val) {}
		...
};

sam_slice.cpp: In constructor 'Left::Left(int)':
sam_slice.cpp:27:32: error: no matching function for call to 'Base::Base()'

Because Base has another ctor so default-ctor will not be made and shows this error.


{call-base-in-virtual-of-derived}
Use scope operator. This is called circumventing the virtual mechanism; base version do work common
to all types and the derived version do whatever additional work.

class Window {
  public:
    virtual void onResize() { ... }
    ...
};

class SpecialWindow: public Window {
  public:
    virtual void onResize()
    {
      Window::onResize();
      ...
    }
};


{base-class-pointer-container} {RTTI}
<problem-one>
MEC++03: In inheritance, base pointer can point to derived class and when passes a array of derived
instead of base, <undefined-result> can happen.

class BalancedBST: public BST { };

void printBSTArray(ostream& s, const BST array[], int numElements)
{
  for (int i = 0; i < numElements; ++i) {
    s << array[i]; // this assumes an operator<< is defined
  } 
} // for BST objects

Because array[i] is *(array+i) and means can end up with wrong place. This warning applies to
deleting arrays like: delete [] array;

{Q} what is the real problem here? how does it relate to base class pointer? 

<problem-two>
EC++27: Problem:

Use smart-pointers to base to access <ANY> possible derived class. Only SpecialWindow support
blinking. Means that need to have to check its type at rumtime.

class Window { ... }
class SpecialWindow: public Window {
	 public:
	 void blink( ... );
	 ...
};

typedef std::vector< std::shared_ptr< Window >> VPW;
                                      ^^^^^^
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
	 if( SpecialWindow* psw = dynamic_cast< SepecialWindow* >( iter->get() ) )
	 {                        ^^^^^^^^^^^^
		  psw->blink();
	 }
}

Undesirable because dynamic_cast is slow and also need to know to which type the object should be
cast. Means already you know what it is.

<dynamic_cast-vs-virtual>
From Primus C++ 19.2 RTTI:

The dynamic_cast operator is the part of RTTI(run-time type identification). These operators are
useful when we have a derived operation that we want to perform through a pointer or reference to a
base-class object and it is not possible to make that operation a virtual function. Ordinarily, we
should use virtual functions if we can.

<problem-three>
From MEC++33: when showing virtual operator= to support mixed type assign in inheritance.

Derived& Derived::operator=(const Base& rhs)      # virtual member op
{
	 const Derived& rhs_derived = dynamic_cast<const Derived&>(rhs);

	 // proceed with a normal assignment of rhs_derived to left *this
}


<when-dynamic-cast-fails>
If a dynamic_cast to a pointer type fails, the result is 0. Error-reporting strategy for pointer.
For reference, bad_cast exception. 

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
	 
} else {  // bp points at a Base object

    // use the Base object to which bp points
}


<solution-one> type-safe container

typedef std::vector< std::shared_ptr< SpecialWindow >> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
	 (*iter)->blink();
}

Remove dynamic_cast BUT limited to SpecialWindow only. Not other possible derived class.


<solution-two> use virtual func in the hierarchy

class Window { 
	 public: >
	 virtual void blink {}		   // def-impl. do-nothing
<	 ... 
};

class SpecialWindow: public Window {
	 public: >
	 virtual void blink( ... );	// do real work
<   ...
};

//                                    ______
typedef std::vector< std::shared_ptr< Window >> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{ >
	 (*iter)->blink();
}


{derivation-access-specifier}
class X : publuc/private/protected B {
  ...
};

This has no effect on whether members of a derived class may access the members of its direct base
class. The purpose is to control the access that users of the derived class.


{typeid-operator}
typeid allows to check the type of an expression:

typeid (expression)

This operator returns a reference to a constant object of type type_info that is defined in the
standard header <typeinfo>. A value returned by typeid can be compared with another value returned
by typeid using operators == and != or can serve to obtain a null-terminated character sequence
representing the data type or class name by using its name() member.

<example>
#include <iostream>
#include <typeinfo>
using namespace std;

int main () {
  int * a,b;
  a=0; b=0;
  if (typeid(a) != typeid(b))
  {
    cout << "a and b are of different types:\n";
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
  }
  return 0;
}

<output> on GCC 4.6.3, VM.
kt@kt-ub-vb:~/work$ ./a.out 
a and b are of different types:
a is: Pi
b is: i

<output> on the text.
a and b are of different types:
a is: int *
b is: int  

Note: The string returned by member name of type_info depends on the specific implementation of your
compiler and library. It is not necessarily a simple string with its typical type name, like in the
compiler used to produce this output. 

When typeid is applied to classes, typeid uses the RTTI to keep track of the type of dynamic
objects. When typeid is applied to an expression whose type is a polymorphic class, the result is
the type of the most derived complete object:

<example>
// typeid, polymorphic class
#include <iostream>
#include <typeinfo>
#include <exception>
using namespace std;

class Base { virtual void f(){} };
class Derived : public Base {};

int main () {
  try {
    Base* a = new Base;
    Base* b = new Derived;
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
    cout << "*a is: " << typeid(*a).name() << '\n';
    cout << "*b is: " << typeid(*b).name() << '\n';
  } catch (exception& e) { cout << "Exception: " << e.what() << '\n'; }
  return 0;
}


<output> on GCC 4.6.3, VM.
a is: P4Base
b is: P4Base
*a is: 4Base
*b is: 7Derived

<output> on the text.
a is: class Base *
b is: class Base *
*a is: class Base
*b is: class Derived

Notice how the type that typeid considers for pointers is the pointer type itself (both a and b are
of type class Base *). However, when typeid is applied to objects (like *a and *b) typeid yields
their dynamic type (i.e. the type of their most derived complete object).

If the type typeid evaluates is a pointer preceded by the dereference operator (*), and this pointer
has a null value, typeid throws a bad_typeid exception.


==============================================================================
*kt_dev_cpp_023*	override

{dynamic-binding} {polymorphism}

Oppose to compile-time binding the compiler generates 'code' to decide at run time which function to
call. This dynamic binding or virtual mechanism is how C++ supports polymorphism. See
{static-binding}

Or some says static and dynamic polymorphism and expand it to type but not about function.
Polymorphism in general is when a piece of a program is designed to allow multiple different types
to be used in it.

Static polymorphism is a use of polymorphism that is determined when the program is constructed
(such as the Template system in C++). Once the program is constructed, the choice is made and the
type used is known.

Dynamic polymorphism is determined at run time. (Such as a pointer to a base class that allows for
descendant class pointers to be passed in. The base class provides the interface and the
descendants implement that interface in different ways that are suitable to the specifics of
the class.) Decisions are made during run time that choose which type to pass.

The important distinction is deciding at construction (compile) or run time. Generally, a well
designed static polymorphism performs better than dynamic, so it is to be preferred when the design
makes it possible. If the information to make a choice is not available until run time, dynamic is
the choice.


{override-keyword} {return-type-in-override}

To override, name and args should be the same but 'return' type is an exception to this. This is not
ture and see below. 


class CInterface 
{
	public:
		virtual void getName()
		{ std::cout << "this is CInterface" << std::endl; }
};

class CMyInterface : public CInterface
{
	public:
		//virtual bool getName()         // [case-three]
		//virtual void getName()         // [case-one]
		virtual void getName(int val)    // [case-two]
		{ std::cout << "this is CMyInterface" << std::endl; 
			//return true; 
		}
};

int main()
{
	std::cout << "-----{ main " << std::endl;

	CInterface* pinter = new CMyInterface();

	std::cout << "created CInterface" << std::endl;
	
	pinter->getName();

	delete pinter;

	std::cout << "-----} main " << std::endl;
}

This is [case-two] when arguments are different by mistake and there are two cases:

1> Like this example, the output is "this is CInterface" because starts from base class, and found
the name there but overriding does not happen. So got the base version.

2> This defines a new function in the derived and hide the name in the base. Like example in p619,
when uses example here, following error happens.

int main()
{
  ...
  CMyInterface cmy;
  cmy.getName();
}

override.cpp: In function ‘int main()’:
override.cpp:34:15: error: no matching function for call to ‘CMyInterface::getName()’
override.cpp:34:15: note: candidate is:
override.cpp:15:16: note: virtual void CMyInterface::getName(int)
override.cpp:15:16: note:   candidate expects 1 argument, 0 provided

This is [case-one] because was overrided.
this is CMyInterface

For [case-three], errors
error: conflicting return type specified for 'virtual bool CMyInterface::getName()'
error:   overriding 'virtual void CInterface::getName()'

However, tried pointer return type, no errors so return type in overrides can be different only
that is pointer. See p606 in ref-CPR.

As shown in {scope-in-inheritance} *kt_dev_cpp_007* this is to hide func in the derived and that is
derived version is not called as expected. It's surprisingly hard to find because there is no
compile error. To avoid this, use override keyword from C++11 and cause compile error when it's not
overrided:

class B {
	 void f1(int) const final;
	 virtual void f2();
	 void f3();
};

class D : public B {
	 void f1(int) const;		# error
	 void f2() override;
	 void f3() override;		# error
};

# VC error for f3 case:
Error	1	error C3668: 'Derived::sample' : method with override specifier 'override' did not override
any base class methods	

The final-keyword is used to end override. See final-keyword in inheritance.


{default-arg-in-virtual}

Default arg in virtual func will 'always' be used base's one even when the drived version is run
because default arg is statically bound and virtual is dynamic. See {default-arg} *kt_dev_cpp_003*

Problem case is:

class Shape {
	 public:
	 enum ShapeColor { Red, Green, Blue };
	 virtual void draw( ShapeColor color = Red ) const = 0;
	 ...
};

class Rectangle : public Shape {
	 public:
	 virtual void draw( ShapeColor color = Green ) const;
	 ...
};


==============================================================================
*kt_dev_cpp_024*	ABC

This is the previous approach to support several discounts:

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};

The abstract base class to represent the general concept and to prevent users creating a object of
this type.

Imagine that want to support several discount strategies by defining a new class named Disc_quote to
store the quantity and the discount amount. Each strategy is the same in that it requires a quantity
and a discount amount but implement its discount strategy by defining its own version of net_price.
Each discount class will inherit from Disc_quote. This raises a question: the Disc_quote do not
correspond to any particular discount strategy but user can create object of this type and can use
print_total. The result is the same when use Quote object since it inherits Quote version and no
discount even if user provided values. How can we prevent this nonsensical code?

This Disc_quote represent the general concept of a discounted book, not a concrete discount policy.~

To prevent users from creating Disc_quote objects, use pure-virtual and unlike usual virtuals,
pure-virtual do not have to be defined.

class Disc_quote : public Quote {
  public:
    Disc_quote() = default;
    Disc_quote(const std::string& book, double price, std::size_t qty, double disc):
      Quote(book, price), quantity(qty), discount(disc) {}

    # pure virtual function
    double net_price(std::size_t) const = 0;

  protected:
    std::size_t quantity = 0;
    double discount = 0.0;
};


class Bulk_quote : public Disc_quote {
  ...
};


{BP} Why define ctors although cannot define objects of this type directly? because of constuction
and destruction chain. See {non-virtual-destruction-problem} If user do not provide ctors, compiler
will provides so ther always is construction chain but not initialisation chain.

When deriving a class from the ABC, if don't override a pure virtual func then the derived also
becomes ABC. Also, ABC can have implementations and see interface-class and tizen case.


{refactoring}
This is refactoring-example. Refactoring involves redesigning a class hierarchy to move operations
and/or data from one class to another. It is that even though we changed the inheritance hierarchy
code that uses Bulk_quote or Quote would not need to change but need to recompile.


{error-when-create-abc}
This happens when tries to create an implementation class which is derived from ABC class; that is
interface class. Why? because implementation class did not override some of members.

/port/CPort.cpp: In static member function 'static CPort* CPort::getInstance()':
/port/CPort.cpp:36:27: error: cannot allocate an object of abstract type 'CPort'
/port/CPort.h:29:1: note:   because the following virtual functions are pure within 'CPort':
/interface/port/IPort.h:48:22: note: 	virtual IIframe* IPortingLayer::getIframe()
/interface/port/IPort.h:56:23: note: 	virtual ISession* IPortingLayer::getSession()
/port/CPort.cpp: In constructor 'CPort::CPort()':
/port/CPort.cpp:46:25: error: cannot allocate an object of abstract type 'CIframe'
/port/CIframe.h:27:1: note:   because the following virtual functions are pure within 'CIframe':
/interface/port/IIframe.h:73:18: note: 	virtual void IIframe::destory(uint32_t)
/interface/port/IIframe.h:80:18: note: 	virtual bool IIframe::isDisplayed()
/interface/port/IIframe.h:86:18: note: 	virtual bool IIframe::setDisplayFlag()
/interface/port/IIframe.h:94:18: note: 	virtual bool IIframe::isMHEG2(void*, uint32_t)
/interface/port/IIframe.h:102:18: note: 	virtual bool IIframe::isMHEG4(void*, uint32_t)

This may be a way to check whether it's overrieded or not? No this is only for ABC.


={============================================================================
*kt_dev_cpp_025*	template

The types become known during complilation in generic programming whereas OOP deals with types that
are not known until run times.

The STL library algorithms are function template and containers are class template.


{function-template}
For function template, the compiler uses the template argument to 'deduce' the template parameter
type.

compare( 1, 0 );
compare( vec1, vec2 );

template <typename T>		# '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

Here two important principles to write generic codes from this example:
1) the function parameters in the templeate are reference to const.
This makes the function runs faster and also it can be uses with types that cannot be copied such as
unique_ptr. why? do not need to copy.

2) used only < comparison. More genarally, reduce the requirement on underlying type. Type
independence and portability. Can write it as:

template <typename T>
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v1 > v2 ) return 1;
  return 0;
}

# error case as should be 'typename U'
template <typename T, U> inline T calc( const T&, const U& );

# can use typename or class but recommands typename
template <typename T, class U> inline T calc( const T&, const U& );

<overloading-and-templates>
function templetes can be overloaded by other templates or by ordinary nontemplate functions. The
things to remember is:

In the viable set, nontemplate function is called and then the more speciailized function is called. 


{instantiation}
Ordinarily, when call a function, the compiler needs to see only a declaration. Similarly, when use
objects of class type, the class definition must be available but the definition of the member
functions need not be present. As a result, put class definition and function declaration in header
file and definition of ordinary and class member function is source files. 

Templates are different and needs to have the code that defines a function and class template member
function. As a result, headers includes definitions as well as declarations.

Generic programming. 'instantiation' is a process that create a concrete 'independent' function or
class from a template when compiling. code generation. Must be defined in the same namespace that
contains the original template. See p675 for C++ feature to control this.


{class-template}
Unlike function-template, compiler 'cannot' deduce the type of parameter so user must provide
'additional' information to instantiate it. That is an element type.

Also it is up to the user to gurantee that the template argument support any operations that
template uses, and that those operations behave correctly in the context in which the template uses
them. Include headers for any type to instantiate that template.

<example> # template-version of StrBlob. No longer specific to string. See original-version in
shared_ptr. 

template<typename T>
class Blob {
  public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type; <using-class-members-that-are-types>

    Blob();
    Blob( std::initializer_list<T> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const T &t ) { data->push_back(t); }
    void pop_back();

    T& front();
    T& operator[](size_type i);

  private:
    std::shared_ptr< std::vector<T>> data;
    void check( size_type i, const std::string &msg ) const;
};

<instantiation>
Must provide the element type which is extra information. Each instantiation constitutes an
'independent' class. So 'specialization' is what compiler do.

Blob<int> ia;
Blob<int> ia2 = { 0, 1, 2, 3, 4 };
Blob<string> names;

These use the same 'type-specific' version of Blob. From these definitions,
      compiler will instantiate a class:

template <> class Blob<int> {
  typedef typename std::vector<int>::size_type size_type;
  Blob();
  Blob(std::initializer_list<int> il);
  ...
  private:
    std::shared_ptr<std::vector<int>> data;
    ...
};

<member-function>
For member functions of class template, it is instantiated <ONLY> if it is used and if not, it is
not instantiated.

To write a member function of class template in 'outside' of class definition, remember that the
instantiated class is a new type. As an example:

template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
  if( i >= data->size())
    throw std::out_of_range(msg);
}

<static-member-func>
As with a static in ordinary class, there must be exactly one definition of each static member. Only
one in the same instantiated class and other instance in the other instantiated class.

template <typename T> class Foo {
  public:
    static std::size_t count() { return ctr; }
    ...
  private:
      static std::size_t ctr;
};

template <typename T>
size_t Foo<T>::ctr = 0;

Foo<int> fi;

auto ct = Foo<int>::count();     // via an object
ct = fi.count();                 // via scope operator

<declaration>
As with members of template, template declaration must include the template parameters.

template <typename T> class Blob;

<use-class-type-members>
Often uses :: scope operator to access both static member and type members. e.g., string::size_type.
In nontemplate code, the compiler has access to the class definition and knows whether a name
accessed through the scope operator is a type or static member.

However, in template code, when it see code such as T::mem, won't know until instantiation whether
mem is a type or a static member. By default, the language assumes that a name accessed through the
scope operator is 'not' a type. So if want to use type member of template must explicitly tell.

template<typename T> 
typename T::value_type top( const T& c )
{
  if( !c.empty() )
    return c.book();
  else
    return typename T::value_type();
}

<template-default-argument>
Under new standard, supports default argument for both function and class template while the earlier
version support only for class.

# for function template

The rewritten example of the previous example and see that F represent the type of a callable
objects.

template <typename T>		# '<typename T>' is template param list
int compare( const T& v1, const T& v2 )
{
  if( v1 < v2 ) return -1;
  if( v2 < v1 ) return 1;
  return 0;
}

template <typename T, typename F = less<T>>
int compare( const T &v1, const T &v2, F f = F())
{
  if( f(v1, v2) ) return -1;
  if( f(v2, v1) ) return 1;
  return 0;
}

See what user can call.

bool i = compare(0,42);

Sales_data item1(cin), item2(cin);
bool j = compare( item1, item2, compareIsbn );

NOTE: KT: If type of item1 supports operator< then the previous works and if not, this version using
compareIsbn works. Matter of choice?

# for class

The empty braket says we want the default type to instantiate.

template <typename T = int> class Numbers {
  public:
    Numbers(T v = 0): val(v) {}
  private:
    T val;
};

Numbers<long double> lots_of_precision;
Numbers<> average_precision;


{member-template}
Either an ordinary class or class template may have a member-function-template. See this word
ordering since it summarise that it is member function and function template.

# for-ordinary-class-example

The member function of ordinary class is itself template from p672. This example is similar to the
default deleter and is a 'deleter' which prints out mesg when dtor runs.

Like shared_ptr, unique_ptr can set deleter. See *kt_dev_stl_018* for more.

unique_ptr< objT, delT > p ( new objT, fcn );

delT is the deleter type. fcn is callable object of delT. callable objects are func, func
ptr, lambda, object binded, and class overloaded the call op.

unique_ptr< connection, decltype(end_connection)*> p ( &c, end_connection );

class DebugDelete {
  public:
    DebugDelete( std::ostream& s = std::cerr) : os(s) {}

    # this make it work for 'all' types by using member template.
    template <typename T> void operator() (T* p) const
    { os << "deleting unique_ptr" << std::endl; delete p; }

  private:
    std::ostream& os;
};

double* p = new double; DebugDelete d;
d(p);    // now instantiated!

When use it with unique_ptr:

unique_ptr<int, DebugDelete> p( new int, DebugDelete() );
unique_ptr<string, DebugDelete> p( new string, DebugDelete() );

How will DebugDelete be instanticated for these cases? These are equivalent to:

void DebugDelete::operator() (int*) const { delete p; }
void DebugDelete::operator() (string*) const { delete p; }

Why? Whenever unique_ptr's dtor is instantiated, DebugDelete's call operator will also be
instantiated. See the following extract. 

template<typename _Tp1, typename _Deleter> __shared_ptr(_Tp1* __p, _Deleter __d)    // from ctor
  ...
__d(__p); // Call _Deleter on __p.  // from other function

After all, whether it is for ordinary class or class template, member template is function template
so compiler 'deduce' the type of func template when used(instantiated) so these will be instantiated
to correct type when deleter is called.

# for class template

Both the class and member have their own, independent, template parameters so must provide both.

template <typename T> class Blob {
  template <typename It> Bolb(It b, It e);
  ...
};

template <typename T>
template <typename It>
   Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b,e)) {}

Blob<int> a1( begin(iarray), end(iarray));
Blob<int> a1( ivec.begin(), ivec.end());
Blob<string> a1( svec.begin(), svec.end());


{variadic-templates}
A template function or class that can take varying number of parameters which is is called as a
parameter pack. Two kinds: template parameter pack and function parameter pack(list).

template <typename T, typename... Args>         // Args is template parameter pack
void foo( const T &t, const Args& ... rest);    // rest is function parameter pack.

int i = 0; double d = 3.14; string s = "how now brown cow";
foo( i, s, 42, d );  // three parameters in the pack
foo( s, 42, "hi" );  // two parameters in the pack
foo( d, s );         // one parameters in the pack
foo( "hi" );         // empty pack

the compiler deduces the template parameter types and instantiate four different foo:

void foo( const int&, const string&, const int&, const double&);
void foo( const string&, const int&, const char[3]&);
void foo( const double&, const string&);
void foo( const char[3]&);

<sizeof...-operator>
C++11. Use the sizeof... operator to know how many elements are in a pack.

template <typename ... Args> void g( Args ... args)
{
  cout << sizeof... (Args) << endl;    // number of type parameters
  cout << sizeof... (args) << endl;    // number of function parameters
}

Determine what sizeof... (Args) and sizeof... (rest) return for all foo instances?

Used GCC 4.6.3

#include <iostream>
#include <string>

template <typename T, typename... Args>
void foo(const T &t, const Args &... rest) 
{
  std::cout << "-------" << std::endl;
  std::cout << sizeof... (Args) << std::endl;
  std::cout << sizeof... (rest) << std::endl;
}

int main()
{
  int i = 0; double d = 3.14; std::string s = "how now brown cow";
  foo( i, s, 42, d );  // three parameters in the pack
  foo( s, 42, "hi" );  // two parameters in the pack
  foo( d, s );         // one parameters in the pack
  foo( "hi" );         // empty pack
}

kt@kt-ub-vb:~/work$ ./a.out 
-------
3
3
-------
2
2
-------
1
1
-------
0
0

<how-about-initializer-list>
Can use an initializer-list to define a function that can take a varying number of arguments.
However, the arguments must have the 'same' type.

Variadic functions are used when we know neither the number nor the types of the arguments to
process.

<variadic-recursive>
Variadic are often recursive on arguments in a pack. To stop the recustion, we also need nonvariadic
funtion.

template<typename T> 
ostream &print( ostream &os, const T &t)
{ return os << t; }

template<typename T, typename... Args>
ostream &print( ostream &os, const T &t, const Args& ... rest)
{
  os << t << ", ";            // print the first argument.
  return print(os, rest...);  // recursive call; print the other arguments.
}

The key part is that the first argument in rest gets bound to t. Pops up a argument in the pack
until there is the last since variadic one is viable. When the last remains, the variadic and the
nonvariadic are viable and the nonvariadic gets called since it is more speciailized. Stop
recursion.

Note: The declaration of the nonvariadic version of print 'must' be in the same scope when the
variadic version is defined. Otherwise, the variadic will recurse indefinitely.


{specialization}
A specialization is a separate defintion of the template in which one or more template parameters are
'speficied' to have particular 'type'.

Why? At other times, may be able to take advantage of some specific knowledge to write more
efficient code than the instantiated from the template. For example, compare function shown before.

// template using type parameters
template <typename T> int compare( const T&, const T& );

// template using nontype(value) parameters such as literal or array
template <size_t N, size_t M> int compare( const char (&)[N], const char (&)[M] );

The problem is when like compare() to compare character pointers, the first, template version will
be called which will compare the pointer values. However, would like to compare by calling strcmp().

<how-to-speficialze>
To indicate speficialization, use template followed by an empty angle brackets(<>). This indicate
that arguments will be supplied for 'all' the template parameters of the original template.

template <> int compare( const char* const &p1, const char* const &p2)
{ return strcmp(p1, p2); }
// int strcmp(const char *s1, const char *s2);

The hard to understand is the function parameter types. In specialization, the function parameter
type must match the corresponding type in the original template.

This example is to define a specialization with T as const char* and reference to a const pointer to
'const char'.

<best-practice-for-specialization>
To specialize, a declaration for the original template must be in scope and a declaration for a
specialization must be in scope before any code uses that speciailized instantiation.

Because the compiler can often instantiate the original template when a speficialization is missing,
errors in declaration order between a template and its speciailzation are easy to make but hard to
find. NOTE: the problem is that the specialised version will not get called when expected.

It is an error for a program to use a speciailization and an instantiation of the original template
with the same set of template arguments. However, it is an error that the compiler is unlikely to
detect.

So declare template and their speciailization in the same header file. Declare all the template
first, followed by any speciailization of those template. 

<class-specialization>
As an example, specialize the library 'hash' template and can use to store user type, Sales_data in
an unordered container. By default, unordered containers use hash<key_type> to organize their
elements.

p709. To use unordered map with our own data type, must define a specialization of the hash template
and it must define:

1. An overloaded call operator that return a size_t and takes an object of the container's key type.
2. Two type members, result_type and argument_type, which are the return and argument types,
  respectively, of the call operator.
3. The default constructor and copy-assign operator.

Template specialization must be defined in the same namespace that contains the original template.

# one way

namespace std {
  template <> struct hash<Sales_data>
  {
    typedef sizt_t result_type;
    typedef Sales_data argument_type;
    size_t operator()(const Sales_data& s) const;
  };

  size_t hash<Sales_data>::operator() const Sales_data& s) const
  {
    return hash<string>() (s.bookNo) ^ hash<unsigned>() (s.units_sold) ^ hash<double>() (s.revenue);
  }
}  // no semicolon after the close curly


Here, delegate the complexity of defining a good hash function to the library. Use unnamed
hash<string> object to generate a hash code for bookNo and others for other members. Do XOR these to
form an overall hash code for the given Sales_data object.

Assuming this speciailization is in scope, use it:

unordered_multiset<Sales_data> SDest;

Since hash<Sales_data> uses the private members of Sales_data, must make this calss, the specific
instantiation, a friend of Sales_data.

template <class T> class std::hash;
class Sales_data {
  friend class std::hash<Sales_data>;
  ...
};

# two way

namespace std {
	template <> struct hash< Sales_data >;
}

// Having added the declaration for the specialization to std namespce we can define the
// specialization outside the std.
template <> struct hash <Sales_data> 
{
	size_t operator() ( const Sales_data& s ) const
	{
		return hash<sring>()(s.bookNo);
	}
	// other members as before
}

<partial-specialization>
Differently from function template, can specify some, but not all, of the template parameters of
class template. Partial speciailization is itself a template.

<member-specialization>
Can speciailize specific member function(s). If Foo is a template with a member Bar.

template <typename T> struct Foo {
  Foo(const T &t = T()): mem(t) {}
  void Bar() { /* ... */ }
  T mem;
  ...
};

template <> void Foo<int>::Bar()
{
  ...
}

Here specializing one member of the Foo<int> class.

Foo<string> fs;   // instantiate Foo<string>::Foo(). Note
fs.Bar();         // instantiate Foo<string>::Bar()

Foo<int> fi;      // instantiate Foo<int>::Foo(). Note
fi.Bar();         // use specialization of Foo<int>::Bar()


={============================================================================
*kt_dev_cpp_026*	enum			{enum-hack}

The enumerations group together sets of integral 'constants' and defines 'new' type. From ansic,
there are two advantages over #define:

1. provide a convenient way to associate constant value with names.
2. a debugger may be able to print values of enumeration variables. confirmed on gcc.


{scoped-enum}
C++11. note that used class keyword. Defines an object of 'open_modes' type and follows scoping rule
means type-erorr can happen. Scope means to specify explicitly where it come from

// enumerators
enum 'class' open_modes { input, output, append };

open_modes readfile = open_modes::input;
open_modes readfile = 2;	// error


{unscoped-enum}
The enumerator is const and [need not be unique]. By default, start at 0 and inc by 1.

enum color { red, yellow, green };				// unscoped
enum stoplight { red, yellow, green };			// error: redefines enumerators
enum class peppers { red, yellow, green };	// okay: enumerators are hidden

color eyes = green;

// error: enumerators from peppers are not in scope. color::green is in scope but has the wrong
// type.
peppers p = green;		

color hair = color::red;
peppers pp = peppers::red;

enum { floatPrec = 6, doublePrec = 10, double_doublePrec = 10 };	// unnamed, unscoped


{conversion} {enum-hack}
The 'unscoped' enumerators are implicitly converted to 'int' but not vice versa. Can be used where
an integral value is required. Called <enum-hack>. By default scoped enums have int as the
underlying type. There is no default for unscoped enums; all we know is that the underlying type is
large enough to hold the enumerator values.

int i = color::red;
int j = peppers::red;	// error

class GamePlayer {
  private:
    enum { NumTurns = 5; }

    int scopes[NumTurns];
    ...
};


{func-with-enum-arg}
Cannot pass an integral value to an enum parameter but can pass an object or enumerator of unscoped
enumaration to a parameter of integral type; the enum promotes to int or to a larger integral type.

enum Tokens { INLINE = 128, VIRTUAL = 129 }

void ff(Tokens);
void ff(int);

Tokens curr = INLINE;

ff(128);			// ff(int)
ff(INLINE);		// ff(Tokens)
ff(curr);		// ff(Tokens)


={============================================================================
*kt_dev_cpp_027*	volatile

This is non-portable feature. For values that is controlled by processes outside the direct control
of the program and might be changed in ways outside the control of the program.

It's a directive to the compiler telling that is shoud not perform 'optimisations' on such objects.


={============================================================================
*kt_dev_cpp_028*	namespace

{real-problem}
03/07/2014. At samsung. 
When moves application which is a process and uses static link to shared library implementation
which will be used by the different process. The codes which works well before starts to fail. In
particular, crashes when try to create a thread. Problem of linking? Problem of pthread library when
used in shared library? Somehow, linker picks up the wrong pthred libaray since a debugger shows odd
address when thread creation call is made? Various directions and many days spent. Eventually, found
out that PCThread::Create() is a problem and works fine when changes parameter orders. The problem
was that the process loads a lot of shared library and one of those has the same PCThread class in
it but different signature. When our library make a call, it picks it up from the other shared
library in which has different signature so crashes. Sovled when wraps PCThread class with a
namespace.

The typical example is to use third party library and name conflict happens when other parties
develops a libaray separately. Howerver, in static link, conflict happens in link stage. In dynamic
loading, this happens at run time and called dynamic binding. So more difficult to find out.


{namespace}
To solve name pollution or collisions, namespace partitions the global namespace and a namespace is
a scope. It provides a much more controlled mechanism and any declaration can be put into a
namespace.


{global-namespace}
Names defined at global scope are in the global-namespace which is implicitly declared and exists in
every program. The scope operator can be used. {BP} use for global names.

::member_name


{named-namespace}
note: The namespce definition do not ends with a semi-colon.

namespace Foo {
	 ...
}

<namespace-is-a-scope>
Code outside the namespace must indicate the namspace in which the name is defined.

cplusplus_primer::Query q = cplusplus_primer::Query("Hello");

<can-be-discontiguous>
The namespace either defines a new namespace or adds to an existing one. Be sure only #include
appear before opening the namespace. If not, attempt to define all the names in that header as
members of the enclosing namespace. 

The declaration and definition should be in the same namespace and this means shall use namespace ~
block for header and source file.~

// Sales_data.h
#include <string>

namespace cplusplus_primer {
	class Sales_data { ... };
	Sales_data operator+( const Sales_data&, const Sales_data&);
	// declarations for the remaining functions in the Sales_data interface
}

// Sales_data.cpp
#include "Sales_data.h"

namespace cplusplus_primer {
	// definitions for the Sales_data members and overloaded operators
}

// user.cpp
#include "Sales_data.h"

int main()
{
	using c_plusplus_primer::Sales_data;
	Sales_data trans;
	...
}


{unnamed-namespace} {file-static}
Unnamed namespace. variables in unnamed namespace has staic lifetime so has file scope as with
file-static. If a header file has vars in unnamed namespace, it create different static vars which
are local to file that includes that header file. This replace file-static of C. *kt_dev_lang_001*
This also means that unnamed-namespace never spans multiple files and do not recommend to have it in
a header since the names in that namespace define different entities local to each file that
includes the header.

namespace {
	 ...
}

<example>
#include <iostream>

int i;			// 3

namespace {
	int i;		// 6
}

int main()
{
	i = 10;		// 11. ambiguous: defined globally and in an unnested, unnamed namespace.

	return 0;
}

sam01.cpp: In function ‘int main()’:
sam01.cpp:11:2: error: reference to ‘i’ is ambiguous
sam01.cpp:3:5: error: candidates are: int i
sam01.cpp:6:6: error:                 int {anonymous}::i

<same-as-static>
For static variable, try to use extern keyword and fails to link in the end. This is the same when
use unnamed namespace. If not use extern then have multiple definition error. 

<global-variables>
Can use namespace for global variables:

// file one
namespace NG {
  int gfs_count;
}

// file two
namespace NG {
  extern int gfs_count;
}


{using-declaration-and-directive}
The <using-declaration> which brings one namespace member into the scope that uses it.

using std::cin;

The <using-directive> which brings whole namespace into the the scope that have both a namespace and
a scope that uses directive. This is enclosing scope that is outter scope than the one uses
directive.

using namespce std;

<avoid-use-of-directive>
Why? Other than else, late-detection; means that ambiguity errors are detected only at the point of
use when use directive. This late detection means that conflicts can arise long after introducing a
particular library. If the program begins using a new part of the library, perviously undetected
collisions may arise.

// example. blip namespace is injected into the global namespce but no compile error. Emit error
// when strat to use j. At a point of use. 

#include <iostream>

namespace blip {
	int i=16, j=15;
}

int j = 0;

int main()
{
	using namespace blip;

	//++j;

	return 0;
}


// example. immediate compile error regardless of using j. At a point of declaration.
// sam01.cpp:9:13: error: ‘j’ is already declared in this scope

#include <iostream>

namespace blip {
	int i=16, j=15;
}

int j = 0;

using blip::j; 

int main()
{
	return 0;
}


<avoid-use-in-header-file>
Why? A header that has a using directive or declaration at its top-level injects names into every
file that includes the header. 

<when-directive-useful>
{BP} One place where using directive are useful is in the implementation files of the namespace
itself.


{nested-namespace}
namespace X { namespace App
{
	 class X : public XXX
	 {
		  ...
	 };
}}


==============================================================================
*kt_dev_cpp_029*	nested class

The type member is a local name and unlike ordinary members, type member must appear before they are
used. So usually appear at the beginning of the class.

class Screen {
	public:
		typedef std::string::size_type pos;

	private:
		pos cursor 	= 0;
};


Called nested-type and think it as nested-scope. Most used to define implementation class. This
defines <type-member> of enclosing class. Means:

o no connection between objects. do not have memebers of each other.
o nest class is only visible in its enclosing class.

When use? Tightly coupled to enclosing class so little sense to use nested class for any other
purpose.

class TextQuery {
	 public:
	 	class QueryResult; // to be defined later but seen before use.

		...
};

class TextQuery::QueryResult {
	 friend std::ostream& print(..);

	 public:
	 	QueryResult( ... );
		...
};

Unlike the previous {text-query-example}, no need to define QueryResult::line_no because nested
class can have direct access to enclosing class.

enclosing scope {

	 nested scope {
		  ...
	 }

}


==============================================================================
*kt_dev_cpp_030*	case study: framework {tizen-case}

From Tizen and points to see are:

o Used factory-func to create a self in the derived class but used static-factory-func. Have
separation and single point of acess to create whole instances.

o Not used singleton but used protected and private ctor or/and dtor in a tree. The protected is
used like singleton to allow derived to create base part.

o Used pimpl-idiom but do not have the same interface between them. not necessary to have the same
interface 

o the way to pass cpp func addresses to c

 
App: ABC                                  _AppImpl: public interface classes
															friend class App
 'protected': ctor(); new _AppImpl           	'private': ctor and dtor (only App can create AppImpl)
 'static' App* GetInstance(); calls -> 			static _AppImpl* GetInstance()
                                           	Construct()
                                           	Execute()
 |
 |
 |
ServiceApp:                               _ServiceAppImpl: public interface classes
 'protected': ctor(); new _ServiceAppImpl    	'private': ctor and dtor
 static ServiceApp* GetInstance(); ->      	static _ServiceAppImpl* GetInstance()
 static Execute(); 
 	: use user provided factory-func to create user class and creates all instances
	: register a event listener and run efl_main

 | 
 | Framework 
 |-----------------------------------------------------------------------------
 | User classes
 |----------------------------------
 |                                 | ...
AppService:                       XXXService:
 static CreateInstance();
 	: member-static-factory-func to create AppService. This is interesting because used subclassing
	to decide what to create but used static-factory-func.

OspMain():
   result r = Tizen::App::Service::Execute( AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute( AppService::CreateInstance, &args); )

//
// App
//
class App
{
// interfaces
public: 
	virtual OnXXX()=0;
	virtual void OnLowMemory(void);

	// very few use of forwarding to impl.
	virtual OnYYY()
	{ __pAppImpl->OnYYY(); }

	static App* GetInstance();
	{
		_AppImpl* pAppImpl = _AppImpl::GetInstance();

		if (pAppImpl != null)
		{  // [KT] why need this as it returns App* which is passed to Impl?
			return pAppImpl->GetAppInstance();
		}

		return null;
	}

	virtual ~App(void)			# see virtual
	{ delete __pAppImpl; }

protected:
	App(void);
	{ __pAppImpl = 'new' (std::nothrow) _AppImpl('this'); }

private:
	class _AppImpl* __pAppImpl;
};

//
// _AppImpl
//
class _AppImpl : public IEventListener
{
public:
	'static' _AppImpl* GetInstance()
	{ return __pAppImpl; }

	App* _AppImpl::GetAppInstance(void)
	{ return __pApp; }

	result Construct(const Tizen::Base::Collection::IList* pArgs);
	result Execute(_IAppImpl* pIAppImpl);
	{
		pAppImpl->__pIAppImpl = pIAppImpl;

		app_event_callback_s state_handler;

		state_handler.create = &OnCreate;
		state_handler.service = &OnService;
		state_handler.terminate = &OnTerminate;
		state_handler.pause = &OnPause;
		state_handler.resume = &OnResume;
		state_handler.device_orientation = NULL;

		state_handler.low_memory = &OnLowMemory;
		state_handler.low_battery = NULL;
		state_handler.language_changed = &OnLanguageChanged;
		state_handler.region_format_changed = &OnRegionFormatChanged;

		// see how to pass data from cpp to c and efl_main should copy since it is local
		// 
		eflResult = app_efl_main(&argc, &pArgv, &state_handler, this);
	}

	// same name but static. what will happen?
	'static' void OnLowMemory(void* user_data);

private:

	_AppImpl::_AppImpl(App* pApp)
		: ...
		, __pApp(pApp)
		, __pIAppImpl(null)
	{ __pAppImpl = this; }

	virtual ~_AppImpl(void)
	{ __pAppImpl = null; }

	'static' _AppImpl* __pAppImpl;

	App* __pApp;
	_IAppImpl* __pIAppImpl;

   // [KT] otherwise, compile errer when App creates Impl
	friend class App;
};

//
// ServiceApp(Service) since used typedef ServiceApp Service
//
class ServiceApp : public Tizen::App::App
{
public:
	virtual ~ServiceApp(void)
	{ delete __pServiceAppImpl; }

	'static' ServiceApp* GetInstance(void)
	{
		_ServiceAppImpl* pServiceAppImpl = _ServiceAppImpl::GetInstance();
		if (pServiceAppImpl == null)
		{
			return null;
		}

		return pServiceAppImpl->GetServiceAppInstance();
	}

	'static' result Execute(ServiceAppInstanceFactory pServiceAppFactory, 
		const Tizen::Base::Collection::IList* pArguments);
	{
		result r = E_SUCCESS;

		ServiceApp* pServiceApp = null;
		_AppImpl* pAppImpl = null;

		// call AppService::CreateInstance. create <AppService> instance
		// use pServiceApp only when exception happens to delete. Here done all creations of objects. 
		pServiceApp = pServiceAppFactory();

		// free to use all instances
		pAppImpl = _AppImpl::GetInstance();

		_ServiceAppImpl* 'pServiceAppImpl' = _ServiceAppImpl::GetInstance();

		// add it as event listner and set app state to initializing
		r = pAppImpl->Construct(pArguments);

		// derive-to-base conversion as _ServiceAppImpl to _IAppImpl
		// pass cpp Onxx funcs to c efl and run app_efl_main
		r = pAppImpl->Execute(pServiceAppImpl); 
	}

protected:
	ServiceApp(void)
	{ __pServiceAppImpl = 'new' (std::nothrow) _ServiceAppImpl('this'); }

private:
	ServiceApp(const ServiceApp& rhs);
	ServiceApp& operator =(const ServiceApp& rhs);

	class _ServiceAppImpl* __pServiceAppImpl;
}

//
// _ServiceAppImpl
//
class _ServiceAppImpl
	: public Tizen::Base::Object
	, public Tizen::App::_IAppImpl
	, public Tizen::Base::Runtime::ITimerEventListener
   , virtual public Tizen::Base::Runtime::IEventListener
{
public:
	static _ServiceAppImpl* GetInstance();
	{ return __pServiceAppImpl; }

private:
	_ServiceAppImpl(ServiceApp* pServiceApp)
	: __pAppImpl(_AppImpl::GetInstance())
	, __pServiceApp(pServiceApp)
	, __pAppTerminatingInternalEventListener(null)
	, __pLifeDurationTimer(null)
	, __lifeDuration(0)
	, __pauseLifeDurationTimer(false)
	{
		__pServiceAppImpl = this;
	}

	ServiceApp*
	_ServiceAppImpl::GetServiceAppInstance(void)
	{
		return __pServiceApp;
	}

	virtual ~_ServiceAppImpl(void);

	static _ServiceAppImpl* __pServiceAppImpl;
	_AppImpl* __pAppImpl;
	ServiceApp* __pServiceApp;
	_IAppEventListener* __pAppTerminatingInternalEventListener;

	friend class ServiceApp;
};

//
// AppService. client class which is out of framework and namespace.
//
class AppService
	: public Tizen::App::ServiceApp
	, public Tizen::App::Package::IPackageInstallationEventListener
	, public Tizen::App::_IAppManagerEventListener
	, public Tizen::System::IBootEventListener
	, virtual public Tizen::Base::Runtime::IEventListener
{

public:
	// create self
	'static' Tizen::App::ServiceApp* CreateInstance(void)
	{
      // [KT] why static?
		'static' AppService* pAppService = new (std::nothrow) AppService();
		__pAppService = pAppService;

		// convert to base
		return pAppService;
	}

	static AppService* GetAppServiceInstance(void);
	AppService();
	virtual ~AppService();

	// OnXXX interfaces
	virtual bool OnAppInitializing(Tizen::App::AppRegistry& appRegistry);
	...
	virtual void OnLowMemory(void);

	static AppService* __pAppService;
};

OspMain() {

   result r = Tizen::App::Service::Execute(AppService::CreateInstance, &args);
   (result r = Tizen::App::ServiceApp::Execute(AppService::CreateInstance, &args); )
}

int main(int argc, char* pArgv[])
{
	int r = OspMain(argc, pArgv);
}


==============================================================================
*kt_dev_cpp_031*	wrapper

{example-one} {wrapper}
This is taken from *kt_dev_mecpp_007* to discuss it again: This case is that main is in c and is to
use some features written cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typedefs               {
										  int wraaper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Here wrapper is used to bridge between cpp and c:

int wrapper_func()
{
	ClassX* pclass = new Class( params );

	pclass->func();
	...
}


{example-two} {{add-reference-counting-to-existing-classes}} {wrapper} {forwarding}
How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


==============================================================================
*kt_dev_cpp_032*	case study: porting layer

{case-one}
The case which use singleton to have a porting layer for different platforms.

├── Interfaces
│   ├── Core
│   │   ├── IPluginRegister.h
│   │   └── SectionDataDefines.h
│   └── PortingLayer (has interface classes)
│       ├── IAPLAppLaunch.h
│       ├── IAPLAVControl.h
│       ├── ...
│       ├── IAPLMutex.h
│       ├── IAPLOSAbstraction.h
│       └── IApplitePortingLayer.h
├
├── PortingLayer (for platform A)
│   ├── Inc (headers for each class which implements each interface
│   │   ├── APLAVController.h
│   │   ├── APLDebug.h
│   │   ├── ...
│   │   ├── APLMutex.h
│   │   ├── APLOSAbstraction.h
│   │   └── ApplitePortingLayer.h
│   └── Src (sources for each class which implements eash interface, functionality)
│       ├── APLAVController.cpp
│       ├── APLDebug.cpp
│       ├── ...
│       └── ApplitePortingLayer.cpp (this is the gate class)


User                 CApplitePortingLayer : publuc IApplitePortingLayer
getInstace()         - get functions to get each interface pointer
Ins->getInterface(); - pointer members for each interface

                     CInterfaceA : public IInterfaceA             CInterfaceB ...
                     - *.h, *.cpp
                     - actual platform specific implementation


class CApplitePortingLayer : public IApplitePortingLayer
{

private:
	///default constructor
	CApplitePortingLayer(){};

public:
	uses singleton
	has all getXXX funcs for each functionality which returns member pointer for each.
	ctor creates all interface classes and set member pointers.

	///This function creates the porting layer interfaces. factory-func
	static CApplitePortingLayer* Instance(CReceiverAppBase* receiver);
	{
		 if (m_singleton == NULL)
		 {
			  m_singleton = new CApplitePortingLayer(receiver);
		 }
		 return m_singleton;
	}

	///This function gets the porting layer interfaces if created.
	static CApplitePortingLayer* GetInstance();
	{
		return m_singleton;
	}
}

Creates all concrete classes which implments interfaces.

CApplitePortingLayer::CApplitePortingLayer(CReceiverAppBase* receiver)
:m_receiver(receiver)
{
	m_graphics =  new CAPLGraphics((IReceiverAppPorting*)receiver, receiver->GetViewIndex());
	m_debug = new CAPLDebug((PCTask*)receiver, receiver->GetTCTv());
	m_mediaManager = new CAPLMediaManager((IReceiverAppPorting*)receiver, receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);		m_OSAbstraction = new CAPLOSAbstraction((IReceiverAppPorting*)receiver, receiver->GetTCTv(), (PCTask*)receiver);
	m_persistentStorage = new CAPLPersistentStorage();
	m_sectionFilter = new CAPLSectionFilter(receiver->GetTCWindowByAutoSelect(), (PCTask*)receiver);
	m_serviceInformation = CAPLServiceInformation::Instance((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_systemProperties = new CAPLSystemProperties((IReceiverAppPorting*)receiver, 
			receiver->GetTCTv(), receiver->GetTCWindowByAutoSelect());
	m_security = new CAPLSecurity();
	m_serial = new CAPLSerial();
	m_typeface = CAPLTypeface::getInstance();
	m_appLaunch = new CAPLAppLaunch((IReceiverAppPorting*)receiver);

    //initialise curl here, needed for both network and X509 operations
    CAPLCurl::InitCurl();
}

The good thing is that make CApplitePortingLayer singleton and manage other interfaces via it rather
than making every interface a singleton class.

This approach means that each concrete implementation calss, Cxx, implements interfaces and users
will use it directly. If the client is CPP file, that's fine and each Cxx can have typedefs, enums
and so on but if C file then do not work. For C files, each Cxx class provide C function and there
should be a way to share typedefs between CPP and C files. So should be a single header which has
common typedefs for C and CPP land.

Also can use that make all interface concrete class to have private interfaces and make a friend
between CApplitePortingLayer and otheres. That makes only CApplitePortingLayer can create and use
those.

{case-two}
├── OAL (OS AL)
│   ├── Inc
│   │   ├── ...h
│   │   └── ...h
│   └── Src 
│       ├── LINUX (this is folder which has platform implementation)
│       ├── WINDOWS
│       ├── VXWORS
│       ├── ...


==============================================================================
*kt_dev_cpp_033*	case study: inheritance

In the porting layer design and implementation, have drawn the class hierarchy.

 ISession (ABC) and more...      IEvent 

 IDriver : public ISession, public IEvent

 CDsm : public IDriver and more...

When add more interface classes which are ABC and add more concrete derived classes, shall add the
same member functions in a header and source of a derived class. Otherwise, will have compile/link
error since ABC forces derived class to define functions. See {error-when-create-abc} for what
happens when not overrides pure virtual functions. Tedious. Any other better way?

1> How about having a pure-virtual-dtor to make a ABC and having normal virtual members?  If have a
class definition and the defintion of a pure-virtual-dtor in the header, get a multiple defintion
error since this is included in every file which use it. Can have source file which has a dtor
definition but still needs definitions for other members. If not, get errors as 3>.

2> How about having a virtual members for interface classes? Since it has implementation, that is
okay for a derived class not to override or implement it. So no tedious work. However, cannot force
derived to override and can forget to implement it. Here talking about 'interface' class.

3> What will happen when changes pure virtual functions to normal virtual functions but do not have
implementation? Simply changes a header since it has a header only as a interface class.

Linking CXX executable mhegproto
port/libmhport.a(CDsm.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `~IDriver':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/PortLayer.h:36: undefined reference to `vtable for IEvent'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x94): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x98): undefined reference to `IEvent::unsubscribeEvent(void*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTV7IDriver[vtable for IDriver]+0x9c): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CDsm.cpp.o):(.rodata._ZTI7IDriver[typeinfo for IDriver]+0x28): undefined reference to `typeinfo for IEvent'
port/libmhport.a(CDsm.cpp.o): In function `.LANCHOR0':
CDsm.cpp:(.rodata+0x5ac): undefined reference to `IEvent::subscribeEvent(void*, char const*, void (*)(void*, unsigned int), void*, void**, int, int)'
CDsm.cpp:(.rodata+0x5b0): undefined reference to `IEvent::unsubscribeEvent(void*)'
CDsm.cpp:(.rodata+0x5b4): undefined reference to `IEvent::getVersionEvent(void*, int*, int*)'
port/libmhport.a(CCi.cpp.o): In function `~ISession':
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'
/home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/interface/port/ISession.h:30: undefined reference to `vtable for IEvent'

This shows how GCC implements vtables for a class.


# ============================================================================
#{ STL
==============================================================================
*kt_dev_stl_000*	useful links

http://www.sgi.com/tech/stl/ 

{stl-design-rationale}

The idea behind the STL is to beat the combinatorial explosion of containers and functions that
implement the same data structures and algorithms without forcing all program structures to be
objects that are all in the same hierarchy. As long as a type has the needed properties, it works
with STL containers or algorithms, no matter what class hierarchies it is or isn't part of.

STL provides a collection of such things that are recognized as both useful and reasonable design.
The picky could point out std::string as a counter-example to good design, here. 


{gcc-stl-code}

For example, less<T> in functional header is 

</usr/include/c++/4.6/functional>
...
#include <bits/c++config.h>
#include <bits/stl_function.h>
...

</usr/include/c++/4.6/bits/stl_function.h>

/** @file bits/stl_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */

...
  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
...


={============================================================================
*kt_dev_stl_001* sequential containers

{trade-offs}
Think different performance trade-offs in {insert/delete} and {random-access}.

vector      : random-access, fast insert/delete at the back, contig. mem
string      : random-access, fast insert/delete at the back, contig. mem

ESTL09: string, vector and deque has {contiguous-memory} Hence, insert/delete in the middle can be
expensive since have to move elements.

list        : double llist, bi-directional, fast insert/delete at any point
forward list: single llist, forward, support push_front only. [KT] See push_front

But don't support random access and can also have memory overhead.

deque       : double-ended q, random-access, fast insert/delete at front/back	

moves elements other than front/back {QQ} what is it?

array       : C++11. fixed size. possible to copy and assign.

note:
The forward_list don't support size() but others do. The size() has fast and constant time op which
is different from ESTL so seems it's true for C++11? Primus says C++ library has improved
significantly in recent.

The list and forward_list don't support <iterator-arith> and means this is for containers that
supports random access; string, vector, deque and array.

The random-access is different from contig. mem since there are containers which supports
random-access but not contig. mem.


{delete-elements}
To delete all elements in a container.

slist.clear();
slist.erase( slist.begin(), slist.end() );


==============================================================================
*kt_dev_stl_005*	assoc containers

These are node-based containers and use balanced tree as ESTL said. GCC is implemented using
red-black tree see {map-uses-rbtree} Provides bidirectional iterator. Three dimensions: set or map,
unique or multiple keys, and ordered or not.

ordered by key	: map, set, multiset/map
unordered		: unordered_set/map/multiset/multimap	

The unordered uses hash function since it is not ordered.

{operator}
The associative containers do not support the sequential container position-specific operators such
as push_front and push_back.


{use-typedef}
To simplify the declaration of containers, define a type alias:

using SD_multiset = unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*>;
SD_multiset bookstore(42, hasher, eqOp);

This is not supported in GCC 4.6 and use typedef instead.

typedef unordered_multiset< Sales_data, decltype(hasher)*, decltype(eqOp)*> SD_multiset;
SD_multiset bookstore(42, hasher, eqOp);
SD_multiset::iterator it;


{key-value-pair} 
Thing to remember is the value_type is pair<const key_type, mapped_type> so implies key cannot be
changed. This affects the use with algorithms because key is const, only be used with algo that is
read-only and the use is limited to search but assoc is better in searching so little use of map
with algo. In practice, assoc can be used as a source or dest in algo.

map<string, int>::value_type v3;		// pair< const string, int>
map<string, int>::key_type v4;		// string
map<string, int>::mapped_type v5;	// int

See how return pair object explicitly and implicitly as a temp object. Here back() returns reference
to the last element.

pair<string, int>
process( vector< string > v )
{
	if( !v.empty())
		return {v.back(), v.back().size() };
	else
		return pair<string, int>();
}

The pair is defined in #include < utility > and the default pair ctor do value inits. see *kt_dev_cpp_009*

To make a new pair,
make_pair( v.back(), v.back().size() );

<key-type-requirement>
For ordered map, to compare the key, use '<' op of element so if use own type, must provide
comparison function and this is a part of type defintion. Rightly, map is ordered on key but not
mapped type. The example shows that use of key and comparison type which is func pointer type:

bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{ return lhs.isbn() < rhs.isbn(); }
 
// to initialise bookstore with func pointer as the ctor arg:
multiset< Sales_data, decltype( compareIsbn )* > bootstore(compareIsbn);

For unordered, use '==' op and hash func.


{subscript}

<in-map>
See {string-subscript}. When use [], index should be [in-range]. For fetching, only works for map
but not multimaps since there are multiple matches. Unlike other containers, [] op on map returns
mapped_type but dereferencing of iterator returns value_type. 

The [] <DOSE-ADD> element only for a map if there is no key already but can be costly since:

word_count[word] = 1; 

happens 3 setps but 3) could be extra

1) serch key and it is not found
2) insert element using temp pair{ word, 0 }. value-init
3) assign it with 1

See *kt_dev_stl_005* When index is out-of-range, <undefined-result> and to be safe, use c.at[index],
since can get a exception.

string word;
map<string, size_t> word_count;

while( cin >> word )
	++word_count[word];

for( const auto &w : word_count )
	cout << w.first << " occurs" << w.second << ((w.second>1) ? "times" : " time") << endl;

<in-set>
[] is only for containers such as sting, vector, deque, and array and map which suppors
<random-access>. NOT for set becuase set has only key. 


{multi-vs-single}
The ivec has two copies of 10 elements.

cout << ivec.size() << endl;	// 20
cout << iset.size() << endl;	// 10. no effects
cout << mset.size() << endl;	// 20

{Q} use case of multiset?


{insert-and-erase}
set.insert( ivec.begin(), ivec.end() );
set.insert( { 1, 2, 3, 4, 5} );

Should remember that the element type is pair when insert into a map.

map.insert( { word, 1} );								// C++11, brace-init
map.insert( make_pair(word, 1) );
map.insert( pair<string, size_t>(word, 1) );

map<string, size_t> word_count;
string word;

word_count.erase( removal_word );

// remove all with k(key) and returns size_t for the num of elements removed. For multiple, return
// number deleted and for single 1 or 0. 
c.erase(k)			
c.erase(iter)     // remove element by iter and return [after] iter
c.erase(b, e)     // remove range [b, e) and return e


{insert-return-pair}
insert() return pair{iter, bool} to indicate whether insertion happened so can use to count the
repeated key. This is for map and set. For multi containers, returns iterator to newly added element
since allows multiple keys and always inserts.

The previous:

map<string, size_t> word_count;
string word;

while( cin >> word )
	 ++word_count[word];

The way to use insert:

map<string, size_t> word_count;
string word;

while( cin >> word ) {
	 auto ret = word_count.insert( {word, 1} );

	 // word was already in word_count then second is false. ret.first is an value_type, {string,
	 // size_t}
	 if( !ret.second )
		  ++ret.first->second;
}


{find}

<in-set>

The set has only keys. key is const so iter is const. See that if not found, then return off-the-end
iterator.

set< string > exclude = { "The", "But", "And", "the" };

// count only word that are not in exclude
if( exclude.find(word) == exclude.end() )
	 ++word_count[word];

set< int> iset = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
iset.find(1);     // return iterator that refers to '1'
iset.count(1);		// return the number of elements. 1.

For containers with single key, find and count do the same but for containers with multiple key,
count has to do more work since still has to count how many elements have the same key. So if
don't need the count, it's best to use find.

<in-map>

For map, *iter is a reference of value_type, pair{key, ele} and it's the return from find().


<find-in-multi> {map-uses-rbtree}
There are three ways:

// <one>
// the way using count and the fact that. multiple elements of a given key will be 'adjacent' within
// the container. {ref-CPR} Primer p487.

// when misuse brace-init, got gcc crash, gcc 4.6 and errors: See _Rb_tree in errors

multimap< string, string > authors;
authors.inset( {"Barth, John"}, "Sot-Weed Factor"});
authors.inset( {"Barth, John"}, "Lost in the Funhouse"});
...

use-mmap.cpp:12:57: error: expected ')' before '}' token
use-mmap.cpp:12:57: error: expected ';' before '}' token
use-mmap.cpp: At global scope:
use-mmap.cpp:12:58: error: expected unqualified-id before ')' token
use-mmap.cpp:13:2: error: 'authors' does not name a type
use-mmap.cpp:13:33: error: expected unqualified-id before ',' token
use-mmap.cpp:13:35: error: expected unqualified-id before string constant
use-mmap.cpp:13:47: error: expected declaration before '}' token
In file included from /usr/include/c++/4.6/map:60:0,
                 from use-mmap.cpp:3:
/usr/include/c++/4.6/bits/stl_tree.h: In member function 'std::_Rb_tree<_Key, _Val, _KeyOfValue,
	_Compare, _Alloc>::iterator std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
	_Alloc>::_M_insert_equal_(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
			_Alloc>::const_iterator, _Arg&&) [with _Arg = const char&, _Key = std::basic_string<char>,
	_Val = std::pair<const std::basic_string<char>, std::basic_string<char> >, _KeyOfValue =
	std::_Select1st<std::pair<const std::basic_string<char>, std::basic_string<char> > >, _Compare =
	std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >, std::_Rb_tree<_Key, _Val, _KeyOfValue,
	_Compare, _Alloc>::iterator = std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,
	std::basic_string<char> > >, std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare,
	_Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,
	std::basic_string<char> > >]': /usr/include/c++/4.6/bits/stl_tree.h:1477:4:   instantiated from
	'void std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_insert_equal(_II, _II) [with
	_InputIterator = const char*, _Key = std::basic_string<char>, _Val = std::pair<const
	std::basic_string<char>, std::basic_string<char> >, _KeyOfValue = std::_Select1st<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >, _Compare =
	std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >]'
	/usr/include/c++/4.6/bits/stl_multimap.h:502:11:   instantiated from 'void std::multimap<_Key,
	_Tp, _Compare, _Alloc>::insert(_InputIterator, _InputIterator) [with _InputIterator = const
	char*, _Key = std::basic_string<char>, _Tp = std::basic_string<char>, _Compare =
	std::less<std::basic_string<char> >, _Alloc = std::allocator<std::pair<const
	std::basic_string<char>, std::basic_string<char> > >]' use-mmap.cpp:11:51:   instantiated from
	here /usr/include/c++/4.6/bits/stl_tree.h:1406:4: error: no match for call to
	'(std::_Select1st<std::pair<const std::basic_string<char>, std::basic_string<char> > >) (const
			char&)' /usr/include/c++/4.6/bits/stl_function.h:486:12: note: candidates are:
	/usr/include/c++/4.6/bits/stl_function.h:490:7: note: typename _Pair::first_type&
	std::_Select1st<_Pair>::operator()(_Pair&) const [with _Pair = std::pair<const
	std::basic_string<char>, std::basic_string<char> >, typename _Pair::first_type = const
	std::basic_string<char>] /usr/include/c++/4.6/bits/stl_function.h:490:7: note:   no known
	conversion for argument 1 from 'const char' to 'std::pair<const std::basic_string<char>,
	std::basic_string<char> >&' /usr/include/c++/4.6/bits/stl_function.h:494:7: note: const typename
	_Pair::first_type& std::_Select1st<_Pair>::operator()(const _Pair&) const [with _Pair =
	std::pair<const std::basic_string<char>, std::basic_string<char> >, typename _Pair::first_type =
	const std::basic_string<char>] /usr/include/c++/4.6/bits/stl_function.h:494:7: note:   no known
	conversion for argument 1 from 'const char' to 'const std::pair<const std::basic_string<char>,
	std::basic_string<char> >&'

/usr/include/c++/4.6/bits/stl_tree.h:1406: confused by earlier errors, bailing out
Preprocessed source stored into /tmp/cceMitsA.out file, please attach this to your bugreport.
kit@kit-vb:~/work$ 


// examples run under gcc 4.6
//
#include < iostream>
#include < string>
#include < map>

int main()
{
	std::string str = "total";

	std::multimap< std::string, std::string > authors;
	authors.insert( {"Kit, Park", "How to get through"} );
	authors.insert( {"Barth, John", "Sot-Weed Factor"} );
	authors.insert( {"Barth, John", "Lost in the Funhouse"});
	authors.insert( {"Andy, Steve", "Enterprise"});
	authors.insert( {"Barth, John", "A way to success"});

	std::string search_item("Barth, John"); 						// author to look for

	auto entries = authors.count( search_item ); // num of elements
	std::cout << "entries: " << entries << std::endl;

	auto iter = authors.find( search_item );		// first entry

	while( entries ) {
	// print each title
		std::cout << "count: " << entries << ", title: " << iter->second << std::endl;
		 ++iter;
		 --entries;
	}

	iter = authors.begin();
	for( iter; iter != authors.end(); ++iter )
		std::cout << "title: " << iter->second << std::endl;
}


kit@kit-vb:~/work$ ./a.out 
entries: 3
count: 3, title: Sot-Weed Factor
count: 2, title: Lost in the Funhouse
count: 1, title: A way to success

title: Enterprise
title: Sot-Weed Factor
title: Lost in the Funhouse
title: A way to success
title: How to get through


See that sorted by key but was ordered as inserted in the same key. So the first is the one inserted
first.

// <two> use lower and upper_bound which return each iter of begin and end. If it is not in the map
// then both will return the same iterator which refer to the point at which the key can be
// inserted.

for(auto beg = authors.lower_bound( search_item ),
	      end = authors.upper_bound( search_item );
			beg != end;
			++beg )
	 cout << beg->second << endl;

// <three> use equal_range which is most direct and return pair of iter in [range] {first,
// off-the-end}. Like above, if not found return the same.

for( auto pos = authors.equal_range( search_item ); pos.first != pos.second; ++pos.first)
	 cout << pos.first->second << endl;


{brace-init}

#include <iostream>
#include <string>
#include <map>

int main()
{
	std::map< std::string, std::string > authors = {{"brabo", "yanky"}, { "alpha", "zulu"}, {"charle", "xiera"}};

	std::cout << "===========================" << std::endl;

	auto iter = authors.begin();
	for( iter; iter != authors.end(); ++iter )
		std::cout << "key: " << iter->first << ", title: " << iter->second << std::endl;
}


{examples} {shared-ptr-as-a-key}

Multiset. mutiple same key from {ref-CPR} p631

One of the ironies of OOP in C++ is that we cannot use objects directly to support it. Instead must
use pointers and references. So often define auxiliary class to help manage complexity that pointer
use impose.

Here Quote class hierarchy represents book purchase or transaction which supports several discount
strategy and each book has isbn number. The same book has the same isbn. The basket is not in the
hierarchy and has multiset to manage multiple purchase for the same book or isbn number. The
multiset has shared_ptr key but equality is decided by compare function. Therefore, the key is the
isbn but not shared_ptr itself. 

class Quote {
  public:
    ...
    std::string isbn() const { return bookNo; }
    virtual double net_price( std::size_t n ) const
    { return n*price; }

  private:
    std::string bookNo;
  protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote() = default;
    double net_price( std::size_t ) const override;

  private:
    std::size_t min_qty = 0;
    double discount = 0.0;
};

double print_total( ostream &os, const Quote &item, size_t n )
{
  double ret = item.net_price(n);
  os << "ISBN: " << item.isbn()   // calls Quote::isbn
    << " # sold: " << n << " total due: " << ret << endl;
  return ret;
}

class Basket {
	public:
		  void add_item( const std::shared_ptr< Quote >& sale)	// see reference. 
			 { items.insert(sale); }

      double total_receipt( std::ostream& ) const;

	private:
		 static bool compare( const std::shared_ptr< Quote >& lhs,
									 const std::shared_ptr< Quote >& rhs )
			 { return lhs->isbn() < rhs->isbn(); }

		 // shared_ptr is a key
		 multiset< std::shared_ptr< Quote >, decltype(compare)*> items{ compare };
};

double Basket::total_receipt( ostream& os ) const 
{
  double sum = 0.0;

  // skip over all the elements that match the current key by calling upper_bound()
  //
  for( auto iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound( *iter ) ) 
  {
    // double print_total(ostream& os, const Quote& item, size_t n);
    // *iter is a key which is shared_ptr and **iter is a object that shared_ptr points
    sum += print_total( os, **iter, items.count( *iter ));
  }

  os << "Total sale: " << sum << endl;
  return sum;
}

User will:

Basket bsk;
bsk.add_item( make_shared< Quote >("123", 45) );
bsk.add_item( make_shared< Bulk_quote >("123", 45, 3, .15) );


{simulating-virtual-copy}
The basket class user still have to deal with dynamic memory and that means have to call
make_shared. So want to have add_item member like: 

<TODO> Here it is only about copy and in p633 in ref-CPR has move version as well.

void add_item( const Quote &sale );

Then this add_item member will use new in it but know only Quote type. If use this for derived
objects then sliced-down will happen. How to solve?

class Quote {
  public:
    // need to study further for reference qualifiers. p546.
    virtual Quote* clone() const & {return new Quote(*this); }
};

class Bulk_quote : public Quote {
  public:
    Bulk_quote* clone() const & { return new Bulk_quote(*this); }
};

class Basket {
  public:
    void add_item( const Quote& sale )
    { items.insert( std::shared_ptr<Quote>( sale.clone() )); }
};


={============================================================================
*kt_dev_stl_002*	vector

{how-a-vector-grows}
To support fast random access, vector elements are stored 'contiguously'. To maintain contiguous
memory and to avoid reallocating a container each time an element is added, the allocation strategy
is: when they have to get new memory, vector and string implementations typically allocate
'capacity' beyond what is immediately needed. Thus there is no need to 'reallocate' the container
for each new element. The vector has to move all of its elements each time it reallocates memory.

c.shrink_to_fit();   C++11. request to reduce capacity() to equal size()
c.capacity();        number of elements c can have before reallocation is necessary.
c.reserve(n);        allocate space for at least n elements

shrink_to_fit() valid only for vector, string, and deque. capacity and reserve valid only for vector
and string.

There is no gurantee that shrink_to_fit will return a memory and it's a only 'request'.
implementation specific. When reallocation is needed, how much memory it will allocate is
implementation specific.


{init-from-array} <std::begin>
int intarr[] = { 0, 1, ... };
vector< int > ivec( begin(intarr), end(intarr) );


{init-from-list} {brace-init}
List init. Not for VC as it's C++11 but g++ (GCC) 4.4.5 does.

vector< string > articles = { "a", "an", "the" };
vector< string > articles{ "a", "an", "the" };


{copy-assign}

<1>
vector< int > vi1(3, 5);	     # vi1(size, val)
vector< int > vi2(6, 2);

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:6

vi2 = vi1;                      # note:

cout << vi1.size() << ":" << vi2.size() << endl;
// 3:3

<2>

Applies to the whole container.

vector< int> ivec = { 1, 2, 3, 4, 5, 6 };
ivec.size();	// 7

ivec = { 1, 2, 5 };
ivec.size(); 	// 3


{assign}

vector< string > v;
v = {"a", "the", "an"};

{subscript}

Does it add an element? NO. The result is [seg-fault] [core-dumped]

int absdistinct_vec(int A[], int n)
{
	if(n==0)
		return -1;
	
	vector<int> ivec;
	int count = 0;

	for( int i = 0; i < n; ++i )
		ivec[i] = abs(*(A+i)); 
}


{vector-operator}

v1 == v2
v1 != v2

{use-example}

// 01

vector< string > words;

for(const auto &str : words)
	 cout << str << " ";
cout << endl;


// 02

auto it = words.begin();

while( it != words.end() )
{
  cout << *it << " ";                # no str update??
  it++;
}

// 03

vector< unsigned > scores(11, 0);

++scores[grade/10];
scores[grade/10]=ix;

{char-vector}
Q: Port from the code which uses memory copy of char array source to vector<char> source. How to use
vector<char> as char array? Should iterate through to get all elements?

This was discussed in Scott Meyers' Effective STL, that you can do &vec[0] to get the address of the
first element of an std::vector, and since the standard constrains vectors to having contiguous
memory, you can do stuff like this.

// some function
void doSomething(char *cptr, int n)
{

}

// in your code
std::vector<char> chars;

if (!chars.empty())
{
    doSomething(&chars[0], chars.size());
}

edit: From the comments (thanks casablanca)
be wary about holding pointers to this data, as the pointer can be invalidated if the vector is
modified.


={============================================================================
*kt_dev_stl_003*	list

{list-erase}
Thing to show here is that the header from begin() gets updated when use erase(start, end) to trim
unused entries.

<code-example>
#include <iostream>
#include <list>

typedef std::list<double> LIST;

int main()
{
  int n;
  double item;
  LIST dlist; 
  LIST::iterator iHead;

  std::cout << "type in an integer n(loop count) followed by n decimal numbers." << std::endl;

  std::cin >> n;

  for(int i=0; i<n; i++)
  {
    std::cin >> item;
    dlist.push_back(item);
  }

  std::cout << "input is done and you have entered " << dlist.size() << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }

  iHead = dlist.begin(); iHead++; iHead++;
  std::cout << "items: " << *iHead << std::endl; 
  dlist.erase( dlist.begin(), iHead );

  std::cout << "input is done and you have entered " << dlist.size() << " items" << std::endl;

  iHead = dlist.begin();

  for(; iHead != dlist.end(); iHead++) 
  {
    std::cout << "items: " << *iHead << std::endl; 
  }
}


$ ./a.out 
type in an integer n(loop count) followed by n decimal numbers.
5
10
20
30
40
50
input is done and you have entered 5 items
items: 10
items: 20
items: 30
items: 40
items: 50
items: 30
input is done and you have entered 3 items
items: 30
items: 40
items: 50
$ 


==============================================================================
*kt_dev_stl_004*	adaptors

stack, queue, priority_queue

{stack-stl}

The {ref-001} says that STL stack uses deque by default and can change by giving it second
paramenter.

template <class T, class Container = deque< T> > class stack;


#include < iostream>
#include < stack>

int main()
{
	int n;
	double item;
	std::stack< double> numbers;

	std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

	std::cin >> n;

	for(int i=0; i<n; i++)
	{
		std::cin >> item;
		numbers.push(item);
	}

	std::cout << "input is done and you have entered." << std::endl;

	while( !numbers.empty() )
	{
		// access next element. top() returns a reference to the top element in a stack. 
		std::cout << numbers.top() << " : ";
		numbers.pop(); // void pop()
	}

	std::cout << std::endl;
}

kit@kit-vb:~/work$ ./usestack
type in an integer n followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
10 : 9 : 8 : 7 : 6 : 5 : 4 : 3 : 2 : 1 : 


{queue-stl}

Like stack, STL queue uses deque by default and can change by giving it second paramenter. Also see
that it has similar interface as stack:

template <class T, class Container = deque< T> > class queue;

#include < iostream>
#include < queue>

int main()
{
	int n;
	double item;
	std::queue< double> numbers;

	// n to specify the number of items and type iterms after
	std::cout << "type in an integer n followed by n decimal numbers." << std::endl;

	std::cin >> n;

	for(int i=0; i<n; i++)
	{
		std::cin >> item;
		numbers.push(item);
	}

	std::cout << "input is done and you have entered." << std::endl;

	while( !numbers.empty() )
	{
		// access next element. front() returns a reference to the first element in a queue. 
		std::cout << numbers.front() << " : ";
		numbers.pop();
	}

	std::cout << std::endl;
}

kit@kit-vb:~/work$ ./usequeue
type in an integer n(loop count) followed by n decimal numbers.
10
1 2 3 4 5 6 7 8 9 10 11 12
input is done and you have entered.
1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : 


==============================================================================
*kt_dev_stl_006*	iterator

Iterator is a generalization of pointers. Pointers themselves are iterators. Each T has its own
iterator; each STL container defines its own iterators. so should use T's member func to get a
iterator.

{iterator-notation}

[begin, end) notation and <off-the-end> iterator which is one past the last. this notation applies
to subrange as well in use of algorithm.
 

{iterator-style}

This is iterator style compared to C style using for loop:

while(begin != end) {
	 *begin  = val;
	 ++begin;
}


template< class T>
T* find( T* begin, T* end, const T& value )
{
	 while( begin != end && *begin != value ) ++begin;
	 return begin;
}


{for-vs-while-style}

map< string, T > mapT::iterator iter = mapT.begin();

while( iter != mapT.end() )
{
	cout << *iter << ...; // use iter
	++iter;
}

for( ; iter != mapT.end(); ++iter )
{
	cout << *iter << ...; // use iter
}

For this simple iteration, for( ; itr != HighLows.end() ; ++itr) is useful. You would never need to
worry about not increasing the iterator with it.


{insert-method}

The insert() insert value at place denoted by iter and return the same. In other words, shift items
from iter position and add an item. 

insert(iter, val);

// example

#include <iostream>
#include <vector>
#include <algorithm>

int main()
{
	std::vector<int> veci = {1,2,3,4};
	std::vector<int>::iterator it;

	it = find(veci.begin(), veci.end(), 2);
	if( it != veci.end())
	{
		it = veci.insert( it, 7 );
		it = veci.insert( it, 6 );
		it = veci.insert( it, 5 );
	}

	it = veci.begin();
	while( it != veci.end() )
	{
		std::cout << *it << ":";
		it++;
	}
	std::cout << std::endl;
}

Output:
1:5:6:7:2:3:4:

// example

vec< int > veci;
veci.push_back(1); .. to (3); // [1,2,3,E)
veci.insert( veci.end(), 4 ); // is it [1,2,3,4] or [1,2,4] ?
it's [1,2,3,4]


// example

list< string > lst;
auto iter = lst.begin();

while( cin >> word )
	 iter = lst.insert( iter, word ); or lst.push_front(word);

[three, two, one]
be               end

while(...)
	 lst.insert(iter, word);

[one, two, three]                       # no iter update. see difference in order

Since iter remains the same(off-the-end) in list and works fine. However, this approach will creates
<core-dump> in case of vector because addition and deletion will invalidate iterator of vector.


{invalidated-iterators} {estl-009}

The following code creates <core-dump> for the same reason as above; invalidated iterators.

void removeOddNumbers( vector< int > numbers )
{
	 for( vector< int >::iterator it = numbers.begin(); it != numbers.end(); ++it )
	 {
		  if( isOdd( *it ))
				numbers.erase(it);
	 }
}

From ESTL09. See that here is about assoc-container but this applies only for containers which uses
contig. mem.

AssocContainer< int > ac;

for( AssocContainer< int >::iterator iter = ac.begin(); iter != ac.end(); ++iter ) {
	 if( badValue(*iter) )
		  ac.erase(iter);
}


// fix-one

for( AssocContainer< int >::iterator iter = ac.begin(); iter != ac.end(); /* [none] */ ) {
	 if( badValue(*iter) )
		  ac.erase(iter++);
}

Using post-inc, increase iter before being invalidated and use the previous.


// fix-two {recommanded}

for( SeqContainer< int >::iterator iter = ac.begin(); iter != ac.end(); /* <none> */ ) {
	 if( badValue(*iter) )
		  iter = ac.erase(iter);
}

For vector, string and deque. In ESTL, <fix-two> is only for seq-containers because erase() returns
void for assoc-containers. But from C++11, erase() returns after iterator for both container type
and can use it both type. Note: From C++11? Which gcc version?

From Primus p353.

o For list, forward-list, iterator remains valid after add/remove
o For vector, string, iterator becomes invalid after add/remove and realloc. (do not know when
realloc happens and think it always becomes invalid)

{Q} how about assoc-containers?

Therefore, two key things to do for each loop:

o call end() but not use the cached. this is the case for range-for
o update iterator


{range-for-caches-end}

for( auto &r : vec )
	 r *= 2;

becomes

for( auto beg = vec.begin(), end = vec.end(); beg != end; ++beg )
	 auto &r = *beg;
	 r *= 2;
}


==============================================================================
*kt_dev_stl_007*	iterator: inserter

These are additional iterators and actually iterator adaptors: insert, stream, reverse, and move iterators

{insert-iterator}

The insert iterator calls a container operation to add and it means that must use front_inserter
only if the container has push_front and use back_inserter only if it has push_back. These are
back_inserter, front_inserter, inserter which bind iterator to container operations.

Why are these useful? There is no need to increase or decrease iter but still need to think about
underlying container.

// example-one

*it = val;	// it from inserter

behave as the following and hence it still denotes the same element as before.

it = c.insert(it, val); ++it;

// example-two

#include < iterator>

vector< int > vec;
auto it = back_inserter(vec);
*it = 42;                                   // calls puch_back()
*it = 48;

[42, 48, E)

// example-three {algo-copy} 
// See the difference between inserter and front_inserter. 

list< int> lst = { 1, 2, 3, 4 }, lst2, lst3;

// OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result);
// 4,3,2,1
copy( lst.cbegin(), lst.cend(), front_inserter(lst2) );

// 1,2,3,4
copy( lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()) );


{stream-iterator}

Treat stream as a sequence of elements of a specified type that should have input/output op
defined(>>/<<) and bind iterator to a stream. In other words, see a stream as a sequence of {user
provided speficified type}. In summary, it makes us to use stream with algorithms.

// example which read the stdin into a vector

string word;
while( cin >> word )
	 // cout << word << endl;
	 vec.push_back(word);

or here postfix advances the stream by reading the next value but returns old value

istream_iterator< string > in_iter(cin), eof;
while( in_iter != eof )
	 vec.push_back(*in_iter++);

or

istream_iterator< string> in_iter(cin), eof;
vector< string> vec(in_iter, eof);                         // ctor use iter range


// for an algo use:

// template <class InputIterator, class T>
//   T accumulate (InputIterator first, InputIterator last, T init)

#include < numeric>

istream_iterator< int > in_iter(cin), eof;
cout << std::accumulate(in_iter, eof, 0) << endl;


// example for ostream. seems [useful] 

// template <class T, class charT=char, class traits=char_traits< charT>>
//  class ostream_iterator;
//
// ostream_iterator (ostream_type& s, const char_type* delimiter);

std::ostream_iterator< int> out_iter( std::cout, " " );
for( auto e : vec )
	 *out_iter++ = e;
cout << endl;

or

copy( vec.begin(), vec.end(), out_iter );
cout << endl;


// example for file

ifstream in("afile");
istream_iterator< string > str_it(in);


// how stream-iterator can make code neat

int main()
{
	Sales_item total;

	// read the first transaction
	if( std::cin >> total )
	{
		Sales_item trans;		// variable to hold the running sum

		while(std::cin >> trans )
		{
			// if we're still processing the same book, then update the running total
			if( total.isbn() == trans.isbn() )
				total += trans;
			// print results for the previous book
			else
			{
				std::cout << total << std::endl;
				total = trans;
			}
		}
		// print the last transaction
		std::cout << total << std::endl;
	} 
	// no input and return failure
	else
	{
		std::cerr << "No data?" << std::endl;
		return -1;
	}

	return 0;
}


This can be re-written as:

istream_iterator< Sales_item> item_iter(cin), eof;
ostream_iterator< Sales_item> out_iter(cout, "\n");

Sales_item sum = *item_iter++;

while( item_iter != eof )
{
	if( item_iter->isbn() == sum.isbn() )
		sum += *item_iter++;
	else
	{
		out_iter = sum;
		sum = *item_iter++;
	}
}

out_iter = sum;


{reverse-iterator}

For container except forward_list and stream iterator, supports reverse iterator; rbegin()/crbegin()
and rend() since reverse iterator use ++ and -- operator.

See *kt_dev_quiz_004* and *kt_dev_quiz_005* for more use cases

<difference-in-range>
The difference between reverse and normal iterator. When we initialize or assign a reverse iterator
from a plain iterator, the resulting iterator does not refer to the same element as the original.

rcomma.base()   cend()
	|       |
 , L A S T
 |       |
 rcomma  crbegin()

[crbegin(), rcomma ) which prints 'TSAL' and [rcomma.base(), cend() )

<example>

#include <iostream>
#include <string>

using std::cout;
using std::endl;
using std::string;

void reverse_cpp_two(char* str)
{
  if(!str) return;
  string istr(str);

  string::reverse_iterator it = istr.rbegin();
  while( it != istr.rend() )
  {
    cout << *it << endl;
    ++it;
  }
}

int main () {
  cout << "=====" << endl;
  reverse_cpp_two("KEITEE PARK");
  return 0;
}


==============================================================================
*kt_dev_stl_008*	algorithm

Do not work directly on a container. Instead, they operate by traversing a range of elements bounded
by two iterators; operates in terms of iterators. container independent but element type dependent.
means that do not use container's operations (don't add/remove items but write/move items) but use
operations on element such as '==', '<', or '+'. 

{iterator-category}

input iter			: read only		single-pass		inc only
output iter			: write only	single-pass		inc only
forward iter		: r/w				multiple-pass	inc only
bidirectional iter: r/w				multiple-pass	inc/dec
random access iter: r/w				multiple-pass	full

On parameter patterns:

alg( beg, end, other args );
alg( beg, end, dest, other args );	// assumes dest is big enough as with sequence one
alg( beg, end, beg2, other args );	// assumes beg2 is big enough as with sequence one
alg( beg, end, beg2, end2, other args );

{assumptions}

There is architecture or the unifying principles that categorise 100+ algorithms: according to what
do on container or required arguments. Be careful since algorithms have assumtions: 

use right iter for a algo according to iter category since compilers will not complain.

<read-only> use single sequence(input range)

The third argument determines which addition operator is used and the type of return. Seems clever.

int sum = accumulate( vec.cbegin(), vec.cend(), 0 );
string sum = accumulate( vec.cbegin(), vec.cend(), string(""));

<read-only> use two sequences

This assumes that the second sequence is at least as big as the first.

equal( one.cbegin(), one.cend(), two.cbegin() );	// assumes two >= one


<write>

The destination is large enough to hold itmes being written.

fill(vec.begin(), vec.end(), 0);

This is fill_n( dest, size, value ); and assumes that vec is 10 size at least.

fill_n( vec.begin(), 10, 0 );	

vector< int > vec;
fill_n( vec.begin(), 10, 0 );	

This is an error and to make sure it works:

vector< int > vec;
auto it = back_inserter(vec); // *kt_dev_stl_009*
fill_n( vec.begin(), 10, 0 );	


{independent-between-sequences}

The element types need not be the exactly same as long as can use element operators or compatible
between them. This is also an example of copying version in algorithm.

replace( ilst.begin(), ilst.end(), 0, 42 );
// replace any element with 0 with 42

replace_copy( ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42 );
// to leave the original sequence unchanged. in this case, move list to vector.

// copy version
reverse( beg, end );
reverse_copy( beg, end, dest );

{if-version}

Algorithm that takes an element value typically have a second named version that takes a predicate
in place of the value. Compared to overloaded version.

// if version
find( beg, end, val);
find_if( beg, end, pred);

// overloaded version
unique( beg, end );
uniqie( beg, end, comp );

{container-specific}

The list and forward_list define several algorithms as memebers because can use generic ones with
list but at a cost in performance. These container spscific ones are merge, sort, unique, remove and
reserse. The member version should be used in preference to the generic for list and forward_list.

Also, a important difference between the list-specific and the generic is that the list version
change the underlying containers.


={============================================================================
*kt_dev_stl_009*	algorithm: sort, unique

template< class RandomIt>
void sort( RandomIt first, RandomIt last );
		
template< class RandomIt, class Compare>
void sort( RandomIt first, RandomIt last, Compare comp );

void elimDups( vector< string >& words )
{
	// sort by alphabet order since string element
	sort( words.begin(), words.end() );

	// re-order by moving adjacent element and return iter that duplicats
	// starts. [unique set, not unique set, end)
	auto end_unique = unique( words.begin(), words.end() );

	// actually use container operation to delete
	words.erase( end_unique, words.end() );
}


From *kt_dev_quiz_008*

bool absLessThan(int a, int b)
{
	return abs(a) < abs(b);
}

bool absEqual(int a, int b)
{
	return abs(a) == abs(b);
}

int absDistinct(int A[], int N)
{
	if(N==0)
		return -1;

	vector<int> ivec;
	int count = 0;

	for(int i = 0; i < N; ++i)
		ivec.push_back( *(A+i) );

	// sort do not change a container
	// before : -5: -3: -1: 0:  3: 6
	// after  :  0: -1: -3: 3: -5: 6

	sort( ivec.begin(), ivec.end(), absLessThan );
	auto it_end_unique = unique( ivec.begin(), ivec.end(), absEqual );

	auto it_begin = ivec.begin();

	while( it_begin != it_end_unique )
	{
		++it_begin;
		++count;
	}

	return count;
}


{stl-find}
If there is a match, returns an iterator to the first element and if not, return end iterator.

auto result = find( vec.cbegin(), vec.cend(), val);

int ia[] = { 27, 210, 12, 47, 109, 83 };
int* result = find( begin(ia), end(ia), val);

{sort-reverse}
sort( vec.begin(), vec.end() );
sort( vec.rbegin(), vec.rend()); // sort in reverse; puts the smallest elements at the end


==============================================================================
*kt_dev_stl_010*	algorithm: predicate and lambda

This is {callables} to change a default operator of algorithms. For example,

1) sort() uses "<" on element to sort but if want to use different order
2) use user defined type that don't support "<"

Should use predicate to provide a way to compare. [ONLY] supports unary and binary predicate.

<01>

bool isShorter( const string& s1, const string& s2 )
{
	 return s1.size() < s2.size();
}

// sort by length
sort( words.begin(), words.end(), isShorter );


<02> stable_sort

sort by length and also want to keep the order among the 'equal' elements.

// sort by alphabet and remove dups
elimDups(words);

// sort by length but retain original order among equals that has the same size.
stable_sort( words.begin(), words.end(), isShorter );


{lambda}

The predicate only supports unary and binary which means must have one or two parameters. How to
support more arguments?


==============================================================================
*kt_dev_stl_011*	containers: restrictions on element type

There is nearly no restrictions on which type can be put in a container but some restrictions on
which operations can perform for element type. so there are some restriction on element type to use
in container.


==============================================================================
*kt_dev_stl_012*	containers: copy init

When copy init from other container, container and element type must be indentical. but use
iterators, it's okay if element is convertable. this is the same for other container operations.
e.g. c.assign( is, ie )


vector<const char*> articles = { "a", "an", "the" };
forward_list< string> words ( articles.begin(), articles.end() );


==============================================================================
*kt_dev_stl_013*	algorithm: copy

int a1[] = { 0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];

auto ret = copy( begin(a1), end(a1), a2 );
// ret points just past the last element copied into a2


==============================================================================
*kt_dev_stl_014*	bitset

The bitset is a class template and is defined in bitset header. Like array class, has a fixed size.

{why-bitset}
Mostly to reduce space complexity.

bitset<32> bitvec(1U);
bool bitbool[32];

cout << "size: " << sizeof(bitvec) << endl;
cout << "size: " << sizeof(bitbool) << endl;

size: 4
size: 32


{bitset-ctors}

bitset<n> b;   
b has n bits; each bit is 0.

bitset<n> b(u);   
b is a copy of the n low-order bits of unsigned long long(ULL) value u.

<init-from-unsigned>
If the size of bitset > the number of bits in ULL, the remaining high-order are set to 0.
If the size of bitset < the number of bits in ULL, the only low-order bits are used. 

<init-from-string>
bitset<n> b(s, pos, m);
'b' is a copy of the 'm' characters from the 'string' starting at position 'pos'. s may contain only
0 and 1 and if contains any other characters, throws invalid_argument.

The characters with the lowest indices in the string correspond to the high-order bits and vice
versa.

bitset<n> b(cp, pos, m);
same as the above but copies from the character array to which cp points.


{bitset-operations}
<about-the-state-of-the-entire-bitset>
b.any();       is any bit in b on?           <DN> Do not use is?? style although returns a bool.
b.all();       are all the bits on?
b.none();      are no bits on?
b.count();     number of bits that are on.
b.size();      return the number of bits in b.

<change-the-bitset>
b.test(pos);   return true if bit at position is on.
b.set(pos, v); set the bit at pos to the bool value v.
b.set();       set all bits.
b.reset(pos);  turn off the bit at pos.
b.reset();     turn off all bits.
b.flip(pos);   change the state of the bit at pos.
b.flip();      flip all bits.

<subsctipt>
when read, that is const version, return a bool true if it's on. when write, which is non-const
return special type that let us change bit at pos.

bool ret = b[pos];
b[31] = 0;
b[0].flip();

<retrive-the-value>
These return a value that holds the same bit pattern. Can use ONLY IF the size of the bitset is less
than or equal to the corresponding size; UL or ULL. Otherwise, throw overflow_error exception.

b.to_ulong();
b.to_ullong();

<io-operations>
This read into a temp string and read until it has read as many as the size of bitset.

os << b;
is >> b;


{code-example}
Tested with GCC 4.6.3.

#include <iostream>
#include <bitset>

using std::cout;
using std::endl;
using std::bitset;

int main()
{
  bitset<32> bitvec(1U);

  bool is_set = bitvec.any();
  bool is_not_set = bitvec.none();
  bool all_set = bitvec.all();
  size_t on_bits = bitvec.count();
  size_t size = bitvec.size();

  cout << "is_set: " << is_set << ", is_not_set: " << is_not_set 
    << ", all_set: " << all_set << ", on_bits: " << on_bits
    << ", size: " << size << endl;

  bitvec.flip();
  bitvec.reset();
  bitvec.set();

  bitset<16> bitvec2("01011001011");
  cout << bitvec2 << endl;             <DN>

  return 0;
}

{Q} How can use bitset with dynamic size since the size is constant expression? Options are:
0> vector<bool>
1> boost has a dynamic_bitset you can use.


={============================================================================
*kt_dev_stl_015*	string: stringstream and io stream

{string-is-typedef}
The string is:
typedef std::basic_string<char> string;

Interestingly, do not get an error of multiple tydedef when try this even though expects error since
it is already typedefed in string header.

#include < iostream>
#include < string>

typedef std::basic_string<char> string;

typedef int EntryType;
typedef int EntryType;

Turned out that there is no multiple typedef errors as shown as EntryType example.


{string-subscript} <do-not-include-null>
string s("string");

This s does not include NULL and size() returns 6 not 7.

s[n]	

returns a ref to the char at pos n in s. pos starts from 0 to size()-1.

For negavite subscript, see {array-subscript}

How to ensure that subscript is in range? A good way is to aviod subscripting altogether by using a
range for whenever possible. However not all compiler supports and see {range-for}


{std::string::npos}
The size_t is unsigned integral type It is a type able to represent the size of any object in bytes:
size_t is the type returned by the sizeof operator and is widely used in the standard library to
represent sizes and counts.

static const size_t npos = -1;

npos is a public static member constant value with the greatest possible value for an element of
type size_t.

This value, when used as the value for a len (or sublen) parameter in string's member functions,
means "until the end of the string".

As a return value, it is usually used to indicate no matches. This constant is defined with a value
of -1, which because size_t is an unsigned integral type, it is the largest possible representable
value for this type.


{std::string::find_first_of}
Searches the string for the first character that matches <any> of the characters specified in its
arguments. The position of the first character that matches. [KT] Starting from 0.

If no matches are found, the function returns string::npos. [KT] This means that when no match
driver will be the same as sResolved in the following example.

std::string sResolved(resolved_name); // "DSM:://xxxx"
std::string driver = sResolved.substr(0, sResolved.find_first_of(':'));    // DSM
std::string driver = sResolved.substr(0, sResolved.find_first_of(':')+1);  // DSM:


{std::string::substr}
string substr (size_t pos = 0, size_t len = npos) const;

The substring is the portion of the object that starts at character position pos and spans len
characters (or until the end of the string, whichever comes first). [KT] Here the second arg is the
length but not pos.


{string-and-c-str}
const CharT* c_str() const;

This means it returns a poiner to const object.

Returns a pointer to a null-terminated character array with data equivalent to those stored in the
string. The pointer is such that the range [c_str(); c_str() + size()] is valid and the values in it
correspond to the values stored in the string with an additional null character after the last
position. 


{string-and-algorithm}
string one;
sort(one.begin(), one.end());


{stringstream}
Supports in-memory IO and read from or write to a string as if the string were an IO stream. In
other words, read(>>) and write(<<) to a stream are string manipulations. 

#include <sstream> add memebers as:

sstream strm(s);  strm is an sstream that holds a copy of the string s.
strm.str();       return a copy of the string that strm holds.
strm.str(s);      copies the string s into strm.

#istringstream example. file parsing example

input file: lee 6095 20121212 800909094848

struct PersonInfo {
  string name;
  vector<string> phones;
};

ifstream input(argv[1]);
vector<PersonInfo> people;

string line;

// std::getline(std::basic_istream, std::basic_string); not include a new line
while( getline(input, line) ) 	
{
  PersonInfo info;
  istringstream record(line);

  record >> info.name;

  while( record >> word )
    info.phones.push_back(word);

  people.push_back(info);
}

# ostrringstream example

ostringstream is useful when need to 'build up' our output a little at a time but do not want to print
the output until later.

for( const auto &entry : people ) {
  ostringstream formatted, badNums;

  for( const auto &nums : entry.phones ) {
    if( !valid(nums))
    {
      badNums << " " << nums;             // string in badNums
    }
    else
    {
      formatted << " " << format(nums);   // writes to formatted's string
    }

    if( badNums.str().empty() )           // there are no bad numbers
      os << entry.name << " " << formatted.str() << endl;   // print the name and reformatted numbers
    else
      cerr << "input error: " << entry.name << " invalid numbers(s) " << badNums.str() << endl;
  }
}


{operator==}
tquery.cpp:128: error: no match for 'operator==' in 's == 'q''

shoule be:

string s;
if( !(cin >> s) || s == "q" ) break;


{inefficient-concatnation}
In JAVA, the following shows inefficient +. Assume that strings are all the same length, x and there
are n strings. Just think about +. For 1st iteration, x copies char by char. Next iteration, 2x and
so on. This reduces to O(xn^2).

String sentence = "";

for( String w : words )
{
	 sentence = sentence + w;
}

This add string to sentence and copy the temp result to sentence for each loop. Should be written

StringBuffer
sentence = "";

sentence.append(w);

{Q} How about C++ string? This should be the same for C++ string class.


={============================================================================
*kt_dev_stl_016*	io stream {getline}

{io-stream}
// ifstream, istream_iterator, and freopen

The ifstream class binds file to stream and then need a call to read data from stream such as
getline(). Further, istream_iterator {stream-iterator} add iterator features to a stream. However
freopen from iostream.h binds file to stdin and can use cin >> to read data.


// error
from above example, if omit header include, error from gcc is:

ifstream input(argv[1]);

while( getline(input, line) )

error: cannot convert 'std::basic_ifstream<char, std::char_traits<char> >' to 'char**' for
argument '1' to '__ssize_t getline(char**, size_t*, FILE*)'

must have #include <fstream>

this suggest that it calls getline from <stdio.h> and <cstdio> for C++ maybe?

<example>
#include <iostream>
#include <fstream>
#include <string>

int main()
{
  std::string line;
  int lnum = 0;
  std::ifstream ifs("sample.SWD", std::ifstream::in );

  // while( std::getline( ifs, line ))
  // {
  //   std::cout << lnum << ":" << line << std::endl;
  //   lnum++;
  // }

  std::getline( ifs, line );

  std::string hid = line.substr( 13, 6 );

  int hidi = std::stoi(hid);
  std:: cout << "hid :" << hid << "hid i: " << hidi << std::endl;

  ifs.close();
}

{example}
Example from C reference, section 1.9.

#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#define MAXLINE 1000 // maximum input line size

// <one>
// read a line into line, return length
int mygetline(char line[], int maxlen )
{
  int c, i;

  for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF) && c != '\n'; i++)
    line[i] = c;

  if( c == '\n')
  {
    line[i] = c;
    ++i;
  }

  line[i] = '\0';
  return i;
}

<two>
// int mygetline(char line[], int maxlen )
// {
//   int c, i;
// 
//   for(i = 0; i < maxlen-1 && ((c = getchar()) != EOF); i++)
//     line[i] = c;
// 
//   line[i] = '\0';
//   return i;
// }

// copy 'from' into 'to'; assume 'to' is big enough
void copy( char to[], char from[] )
{
  while( *to++ = *from++ )
    ;
}

int main()
{
  int curlen; // current line length
  int maxlen; // maximum length seen so far
  char line[MAXLINE];
  char longest[MAXLINE];

  maxlen = 0;
  while(( curlen = mygetline( line, MAXLINE )) > 0 )
  {
    if( curlen > maxlen )
    {
      maxlen = curlen;
      copy( longest, line );
    }
  }

  if( maxlen > 0 )
    printf("%s\n", longest);
}


Q: What's the difference between one and two?

one: h e l l o \n \0 w o r l d \n \0
two: h e l l o \n w o r l d \n \0


Q: Length and return size.

0  1  2  3  4  5  6  (return)
h  e  l  l  o  \n \0
1  2  3  4  5  6  7


{question} How can we use std::getline for stdin?

Obviously, cannot use cin for reading a line since:

#include <iostream>
#include <string>

using namespace std;

int main()
{
  string line;

  while( cin >> line )
    cout << "cout: " << line << endl;

  cout << "end: " << line << endl;
}

kt@kt-ub-vb:~/work$ ./a.out 
this
cout: this
that
cout: that
this is a long line
cout: this
cout: is
cout: a
cout: long
cout: line
end: line


={============================================================================
*kt_dev_stl_017*	emplace_* member

c.emplace_back( "978-3403", 25, 15.99 );

c.push_back( Sales_data("978-3403", 25, 15.99) );	// use temp object

Here c means container and the emplace_* construct a object directly in a container. no copy.


={============================================================================
*kt_dev_stl_018* smart pointer, RAII

{resource-acquisition-is-initialization} {resource-managing-class}
EC++13. Why raii? When use dynamic resource, client is fully resposible for releasing it after use
but it is very difficult to make sure there is no resource leak.

1> when passing dymamic resources between modules or components. 
2> when exception happens, the usual path is interrupted and may cannot release it as expected.

void f()
{
  // createInvestment() is factory-func that returns a pointer to dyn created resource or derived
  // class. client must delete it after use

  Investment* pInv = createInvestment();

  // [problem] code that throws an exception that is not caught inside f. may not reach to delete
  // statement

  delete pInv;
}

<try-block-approach>
void f()
{
  try {
    Investment* pInv = createInvestment();
  }
  catch( ... ) {
    delete pInv;
    throw;           // propagate exception to caller of f. rethrow.
  }

  delete pInv;
}

This has duplicated clean-up code. How to improve this? 

<raii-auto-ptr-approach> unique_ptr
Approaches to implement raii.

void f()
{
  // createInvestment() is factory-func that returns a pointer to dyn created resource
  // or derived class. client must delete it after use

  std::auto_ptr< Investment > pInv( createInvestment() );

  // code that throws an exception that is not caught inside f.

  // NO need to concern about free resource regardless of how control leaves a block
  // delete pInv;
}

To solve this, use resource-managing-class by putting resource inside object and use the fact that
dtor is called automatically when object is destroyed. lifetime. As soon as get resource, initialize
a object. How? In a <constructor> and hence called raii. 

Acquire and initialize a [resource-managing-class] in the same statement. In other words, resource
should be [encapsulated-in-a-object], resouce-managing-class, but raii do not exist to encapsulate
resource [but-to-prevent-leak]. 

However, auto_ptr is not the best way to manage all dyn resources since it's limitation on copying
to make sure there's only one ptr to object. So containers of auto_ptr aren't allowed since STL
requires normal copying, deep-copy.

<raii-shared-ptr-approach>
To return shared_ptr from a factory-func which is better way that supports normal copying. 

// use the fixed type, Foo that's the underlying object.
//
std::shared_ptr< Foo > factory(T arg)
{
	 return make_shared< Foo >(arg);
}

void use_factory(T arg)
{
	 shared_ptr< Foo > p = factory(arg);
	 // use p and deleted automatically.
}


{raii-for-resource-using-own-interface}
EC++14. There should be [own-raii-class] for resource that uses own interface to create and delete
it because cannot use delete operator on it as with generic case. 

<example-mutex-lock> {auto-lock}
void lock(Mutex* pm);		// int pthread_mutex_lock( pthread_mutex_t *mptr); 
void unlock(Mutex* pm);

class Lock {
  public:
    'explicit' Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};


// client use

Mutex m;		// pthread_mutex_t m;
...
{
  Lock ml(&m);
  ...
}

<example> # AUTOLOCK example
This is a case example seen in the code:

class CCAutoLock
{
  private:
    PCMutex* m_mutex;
  public:
    CCAutoLock(PCMutex* mutex) { m_mutex = mutex; m_mutex->Lock(); };
    ~CCAutoLock() { m_mutex->Unlock(); };
};

static PCMutex* g_mhdebug_mutex;
#define AUTOLOCK() CCAutoLock lock(&g_mhdebug_mutex)

void func()
{ 
  AUTOLOCK();
  ...
}


Q. When there is a nested call tree used AUTOLOCK, will the lock be maintained? That is will the
lock of func1 in the below example BE VALID/LOCKED when func3 gets run?

#include <iostream>

using std::cout; using std::endl;

class ALOCK {
  private:
    int m_num;
  public:
    ALOCK(int val):m_num(val) { cout << "ctor: ALOCK" << m_num << endl; }
    ~ALOCK() { cout << "dtor: ALOCK: " << m_num << endl; }
};

int func3()
{
  ALOCK LOCK(3);

  std::cout << "func 3" << std::endl;

  return 1;
}

int func2()
{
  ALOCK LOCK(2);

  std::cout << "func 2" << std::endl;

  return func3();
}

int func1()
{
  ALOCK LOCK(1);

  std::cout << "func 1" << std::endl;

  return func2();
}

int main()
{
  std::cout << "--{ main " << std::endl;

  func1();

  std::cout << "--} main " << std::endl;
}

Expected output?

--{ main
ctor: ALOCK1
func 1
ctor: ALOCK2
func 2
ctor: ALOCK3
func 3
dtor: ALOCK: 3
dtor: ALOCK: 2
dtor: ALOCK: 1
--} main 

<example-window-handle>
MEC++09.

void displayInfo(const Information& info)
{
  WINDOW_HANDLE w ( createWindow() );

  ... display info in window w and exception can happen.

  destoryWindow(w);
}


class WindowHandle {
	 public:
	 	WindowHandle( WINDOW_HANDLE handle ) : w(handle) {}
		~WindowHandle() { destoryWindow(w); }

      // [conversion-op]
		operator WINDOW_HANDLE() { return w; }

	 private:
	 	WINDOW_HANDLE w;

      // [preventing-copies]
		WindowHandle( const WindowHandle& );
		WindowHandle& operator=( const WindowHandle& );
};


void displayInfo(const Information& info)
{
	 WindowHandle w ( createWindow() );

	 ... display info in window w and exception can happen.
	 ... displayWindow(w); coversion-op runs to convert WindowHandle to WINDOW_HANDLE

	 // destoryWindow(w);
}


{raii-and-two-cautions}
The raii is great but there are two cautions when use raii.

<1> When use resources which has own interface such as mutex and db connection, it can raise
exception in destructor. Since raii uses destructor, it can cause the problem is described in
{problem-of-exception-in-dtor}. 

<2> Acquire and initialize a raii in the same statement. In other words, use constructor. If not,
can be a problem as described in EC++17.

processWidget( std::shared_ptr<Widget>( new Widget ), priority() );

The problem is that there is no order in evaluating the arguments between new, shared_ptr
constructor, and priority() call. So if complier reorder calls as new, priority, and shared_ptr and
priority raise exception then raii is broken. Means newed pointer will be lost. The better way is:

std::shared_ptr<Widget> pw( new Widget );
processWidget( pw, priority() );


{raii-and-copy-support}
EC++14. What should happen when a Lock object, more generally raii object, is copied? There are four
approaches depending on the type of resource.

<1> prohibit copying
Likely to be true for Lock. See {preventing-copies} in *kt_dev_cpp_004* So,

class Lock: private Uncopyable {
	 ...
};


<2> reference counting underlying resources
This is shared_ptr; {pointerlike} in *kt_dev_cpp_004* For this example, use 'deleter' to use unlock
instead of default delete.

class Lock {
  public:
    explicit Lock( Mutex* pm ) : mutexPtr(pm) 
      { lock( mutexPtr ); }

    ~Lock() { unlock( mutexPtr ); }

  private:
    Mutex* mutexPtr;
};

To:

class Lock {
  public:
    explicit Lock( Mutex* pm ) >
      :mutexPtr( pm, unlock ) 
      {
        lock( mutexPtr.get() );  // to get law pointer assuming this is C interface
      }

  private:
    std::shared_ptr< Mutex > mutexPtr;
};

Set deleter using shared_ptr ctor in ctor init list. No longer declares a destructor.

<3> copy the underlying resource
This is {valuelike} in *kt_dev_cpp_004* Such as string class which uses heap for characters.
Copying the resource managing object should also copy the resource it wraps. deep-copy.

<4> transfer ownership of underlying resource
This is unique_ptr. Only one raii refers to a raw resource and when raii is copied ownership of the
resource is transfered. 


{shared-ptr}
#include <memory> and def init has a nullptr:

shared_ptr< T > plist;
shared_ptr<list<int >> plist;

{make-shared}
This will alloc and init T and return a shared_ptr< T>

shard_prt< string > p4 = make_shared< string>(10, '9');
auto p6 = make_shared<vector< sting>>();	// create empty vector< string>

This is recommeneded because do alloc and bind at the same time. By the way, it's possible to do
'alloc' and 'bind shared_ptr with ptr' later.

{when-use-reset-to-assign-new-pointer} {unique-and-reset}
Why not assignment instead of using reset? [KT] Think that = operator is to decrease a reference
counter of right and to do the opposite for left and cannot do it on new objects. To assign a new
pointer to a shared_ptr. Like assignment, reset updates reference count of left. If sp is the only
shared_ptr pointing at its object, reset frees sp's existing object. If q is passed, makes sp points
to q, otherwise makes sp null.

sp.reset(); or sp.reset(q);

shared_ptr< int> p (new int(42));
p = new int(1024);						// [error]
p.reset( new int(1024));


To check how many users are. Return bool on whether there is the only user of this sp.

sp.unique();

Often to check whether we are the only user before changing the underlying object:

if( !p.unique() )
	 p.reset( new string(*p) );		// we are not alone. allocate a new copy
*p += newValue;							// we are the only pointer, okay to change


{copy-shared-ptr}

auto p = make_shared< int>(42);

// p.use++
auto q(p);

// all prints 2
cout << "q: " << q.use_count() << ", p: " << p.use_count() << endl;

auto r = make_shared< int>(52);

// q.use++ and r.use--. destroies a object which r pointed. 
r = q;

// all prints 3
cout << "q: " << q.use_count() << ", p: " << p.use_count() << ", r: " << r.use_count() << endl;


{example} # StrBlob from p455.
<1> When shared_ptr is useful? 
This case don't define 'copy-controls' and use syn versions but not a problem as it uses shared_ptr.
That's why shared_ptr is useful. 

class StrBlob {
  friend class StrBlobPtr;

  public:
    typedef std::vector<std::string>::size_type size_type;

    StrBlob();
    StrBlob( std::initializer_list<std::string> il );

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const std::string &t ) { data->push_back(t); }
    void pop_back();

    std::string& front();
    std::string& back();

    // return a copy object like iterator. NOTE: Why is this? Since for the begin(), use dtor with
    // curr(0) and for end(), use dtor curr(size). vector[0] and vector[size].
    StrBlobPtr begin() { return StrBlobPtr(*this); }
    StrBlobPtr end() { reutn StrBlobPtr(*this, data->size(); }

  private:
    std::shared_ptr<std::vector<std::string>> data;
    void check( size_type i, const std::string &msg ) const;
};

# ctors

StrBlob::StrBlob: data( make_shared<vector<string>> ()) {}
StrBlob::StrBlob(initializer_list<string> il): data( make_shared<vector<string>> (il)) {}

# see return type is void when raise an exception.

void StrBlob::check( size_type i, const string &msg ) const
{
  if( i >= data->size() )
    throw out_of_range(msg);
}

string& StrBlob::front()
{
  check( 0, "front on empty StrBlob" );
  return data->front();
};

string& StrBlob::back()
{
  check( 0, "back on empty StrBlob" );
  return data->back();
};

string& StrBlob::pop_back()
{
  check( 0, "pop_back on empty StrBlob" );
  return data->pop_back();
};

{Q} are these all operation on vector? what will happen when calls on empty vector?

<2> When weak_ptr is useful?
<- new container class ->  <- companion class like iterator ->
   StrBlob                    StrBlobPtr
   - shared_ptr               - weak_ptr
                     vector[]
                     - underlying container

What it provides:

1) The weak_ptr do not participate in the reference count of shared_ptr and won't affect the
lifetime of the vector. 

2) However, can prevent the user from attempting to access a vector that no longer exist.

class StrBlobPtr {
  public:
    StrBlobPtr(): curr(0) {}
    StrBlobPtr( StrBlob &a, size_t sz=0 ): wptr( a.data ), curr(sz) {}

    StrBlobPtr& incr();
    StrBlobPtr& deref() const;

  private:
    std::shared_ptr< std::vector<std::string>> check( std::size_t, const std::string& ) const;
    std::weak_ptr<std::vector<std::string>> wptr;
    std::size_t curr;
};

# returns a shared_ptr to the vector if the check succeeds. Because a weak ptr does not participate
# in the reference count of its corresponding shared ptr, the vector might have been deleted. If the
# vector is gone, lock() will return a null pointer. 

std::shared_ptr< std::vector<std::string>> 
StrBlobPtr::check( std::size_t, const std::string& ) const
{
  // ret is shared_ptr and is the vector still around? If it's gone, lock() returns null.
  auto ret = wptr.lock();
  if(!ret)
    throw std::runtime_error("unbounded StrBlobPtr");

  if( i >= ret->size() )
    throw std::out_of_range(msg);

  // otherwise, return a shared ptr to the vector
  return ret;
}

std::string& StrBlobPtr::deref() const
{
  auto p = check( curr, "dereference past end");
  return (*p)[curr];    // must since [] is higher than *
}

StrBlobPtr& StrBlobPtr::incr() const
{
  auto p = check( curr, "increment past end");
  curr++;
  return *this;
}

<3> Quiz? Expected output?
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <exception>
#include <stdexcept>

class StrBlob {
  public:
    typedef std::vector<std::string>::size_type size_type;

    StrBlob(std::string n);
    StrBlob(std::string n, std::initializer_list<std::string> il);
    ~StrBlob();

    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }

    void push_back( const std::string &t) { data->push_back(t); }
    // void pop_back();
    // std::string front();
    // std::string back();

  private:
    std::string name;
    std::shared_ptr<std::vector<std::string>> data;
    void checks( size_type i, const std::string &msg) const;
};

StrBlob::StrBlob(std::string n): name(n), data( std::make_shared<std::vector<std::string>>() )
{
  std::cout << "ctor for " << name << std::endl;
}

StrBlob::StrBlob(std::string n, std::initializer_list<std::string> il): name(n), data( std::make_shared<std::vector<std::string>>(il))
{
  std::cout << "ctor for " << name << std::endl;
}

StrBlob::~StrBlob()
{
  std::cout << "dtor for " << name << std::endl;
}

void StrBlob::checks( size_type i, const std::string &msg) const
{
  if( i >= data->size() )
    throw std::out_of_range(msg);
}

int main()
{
  std::cout << "-{ main ---" << std::endl;

  StrBlob b1("b1");
  {
    std::cout << "-b1 size: " << b1.size() << "-" << std::endl;

    StrBlob b2("b2", { "this", "is", "second blob" });
    b1 = b2;
    b2.push_back(". really?");

    std::cout << "-b2 size: " << b2.size() << "-" << std::endl;
  }

  std::cout << "-b1 size: " << b1.size() << "-" << std::endl;

  std::cout << "-} main ---" << std::endl;
}

$ ./a.out
-{ main ---
ctor for b1
-b1 size: 0-
ctor for b2
-b2 size: 4-  // pointing to the same underlying vector.
dtor for b2
-b1 size: 4-
-} main ---
dtor for b2  // why? since it's copied using the syn copy assign in b1=b2.


{use-example}
shared_ptr<vector< T >> pvec;

T var = (*pvec)[index];


{set-deleter}
This is exception safe. However, how can we make it sense when using resources which have own
interfacces since default deleter is delete.

void f()
{
  shared_ptr< int > sp (new int(42) );
  // use sp
  // exception occur and no catch
}

void f()
{
  connection c = connect(&d);
  // use connection
  // if exception occur, no way to close conn
}

User can set deleter of shared_ptr rather than the default deleter, delete.

void end_connection( connection &p ) { disconnect(*p); }

void f()
{
  connection c = connect(&d);
  shared_ptr<connection> p (&c, end_connection);
  // use connection
  // if exception occur
}


{unique-ptr} # no copy support
This was auto_ptr before C++11 and it has only one user because 'no' ordinary copy and assign are
supported. Only 'one' unique_ptr at a time can point to a given object. So limit the use and it
transfer ownerships.

u.release()    relinquishes control of the pointer u has held; returns the pointer u has held and
makes u null.

u.reset()      delete the object to which u points.

<ownership>
How to copy? Instead, transfer ownership. The release() return the pointer it held and make it null
so using reset/release pair transfer ownerships.

// p1 becomes null. transfer ownership. Like copy ctor
unique_ptr<string> p2( p1.release() );

// reset delete a mem that p2 points and set it with pointer p3 points. transfer ownership. Like
// copy assign.
unique_ptr<string> p3( new string("Fred") );
p2.reset( p3.release() );

<lost-pointer>
// WRONG. p2 won't free the memory and have lost the pointer.
p2.release();

// OK. but must remember to delete(p).
auto p = p2.release();

<pass-return-unique-ptr> # move-operation
One exception to the rule that cannot copy a unique_ptr; can copy or assign a unique_ptr that is
about to destroyed since compiler knows it and use 'move'. The most common example is when return it
from a function.

unique_ptr<int> clone(int p) {
  ...
  // explicitly create a pointer
  return unique_ptr<int>( new int(p) );
}

unique_ptr<int> clone(int p) {
  unique_ptr<int> ret( new int(p) );
  ...
  // can return a copy of local object
  return ret;
}

<vs-auto-ptr>
In auto_ptr, it is not possible to store an auto_ptr in a container, nor could we return one from a
function.

#include <iostream>
#include <memory>
using namespace std;

class Foo 
{
  private:
    int id;
  public:
    Foo(int val):id(val) { cout << "Foo ctor(" << id << ")" << endl; }
    ~Foo() { cout << "Foo dtor(" << id << ")" << endl; }
};

int main()
{
  unique_ptr<Foo> p1(new Foo(1));
  unique_ptr<Foo> p2(new Foo(2));
  unique_ptr<Foo> p3(new Foo(3));

  p2.reset( p3.release());
}

$ ./a.out 
Foo ctor(1)
Foo ctor(2)
Foo ctor(3)
Foo dtor(2)
Foo dtor(3)
Foo dtor(1)


{deleter-form}
As with shared_ptr, can set 'deleter' but use different form. p678 said that:

By binding the deleter at compile time, unique_ptr avoids the run-time cost of an indirect call to
its deleter. In contrast, by binding at run time, shared_ptr makes it easier for users to override
the deleter. (significant cost?)

shared_ptr<connection> p (&c, end_connection);
unique_ptr<connection, decltype(end_connection)*> p ( &c, end_connection );


{get-func}
EC++15. Have to provide access to raw underlying resource? There are two ways: implicit and explicit
conversion. Explicit conversion is safer. Said it converts an RAII object into the raw resource.
Explicit conversion.

<explicit-conversion>
Provide get() funtion.

std::shared_ptr<Investment> pInv( createInvestment());

int daysHeld( const Investment *pi );

int days = daysHeld( pInv.get() );

<implicit-conversion>
Provide conversion operator. FontHandle is raw resource. This makes calling into C API easy and
natural but increase the chance of errors.

class Font {
  public:
    explicit Font( FontHandle fh) : f(fh) {}

    ~Font() { releaseFont(f); }

    operator FontHandle() const
    { return f; }

  private:
    FontHandle f;
};

Font f( getFont() );
changeFontSize( f, newFontSize );

Font f1(getFont());
FontHandle f2 = f1;     // oops. meant Font f2=f1;

<encapsulation>
Is this contrary to encapsulation? true but raii donesn't exist to encapsulate something. It exist
to ensure that a particular action - release resource - takes place. Encapsulation is not for every
classes.


{smart-pointer-internal}
MEC++28. The typical implementation is:

template< class T>
class SmartPtr {
	 public:
	 	SmartPtr( T* realPtr = 0 );
		SmartPtr( const SmartPtr& rhs );
		~SmartPtr();

		// const. though it may lead to modification of what the pointer points to
		T* operator->() const;
		T& operator*() const;

	private:
		T* pointee;
};


{{encapsulation}}

SP is testimony of encapsulation:

o Allow us to treat them as dumb, built-in, pointer. SP is object acts like a pointer.
o Other example. Handle local and remote DB access as if it is in the same place. Hide.

void editTuple(DBPtr<Tuple>& pt)
{
	 do {
		  pt->displayEditDialog();
	 } while (pt->isValid() == false);
}

The tuple to be edited inside editTuple may be physically located on a remote machine, but the
programmer writing editTuple need not be concerned with such matters;


{{ownership}}

Passing auto_ptr by value is often a bad idea. Why?

void printNode( ostream& s, auto_ptr< TreeNode> p ) { s << *p; }

int main()
{
	 auto_ptr< TreeNode> ptr( new TreeNode );
	 ...
	 printNode( cout, ptr );
	 ...
}

In printNode call, call copy-ctor and means transfer ownership. When returns, dtor runs and delete
pointee. When main ends, dtor runs again. <double-free> So use reference:

void printNode( ostream& s, auto_ptr< TreeNode>& p ) { s << *p; }

See {the-rule-of-three} for <double-free> example.


{{dereferencing-and-member-selection-operator}}

template< class T>
T& SmartPtr< T>::operator*() const
{
	 ...
	 return *pointee;
}

See return as reference because:

o *pointee can be derived class in inheritance. Avoid sliced-off.
o More efficient. No temp object.


pt->displayEditDialog(); -> (pt.operator->())->DisplayEditDialog();

So operator-> return either pointer or another smart pointer because can use -> on it.

template< class T>
T* SmartPtr< T>::operator->() const
{
	 ...
	 return pointee;
}

Both returns pointer and reference, virtual call through it works as supposed to.


{{nullness-of-smart-pointer}}

SmartPtr< T> ptr;
...
if( ptr == 0 ) ...
if( ptr ) ...
if(!ptr) ...

All issues compile error. NOTE: How about STL?

How to solve? Typical approach is to use conversion operators.

<approach-one> <conversion-to-void>

This is the way iostream uses so it is possible:

ifstream inputFile("datafile.dat");
if(ifstream) ...

template< class T>
class SmartPtr {
	 public:
	 	operator void*(); // return 0 if smart pointer is null, non-zero otherwise.
		...
};

<approach-two> <conversion-to-bool>

Both approaches are not complete. Why? Cases where implicit conversion is a problem:

SmartPtr< Apple> pa; SmartPtr< Orange> po;

if( pa == po ) ...

Even if there is no operator== taking a SmartPtr<Apple> and a SmartPtr<Orange>, this compiles,
because both smart pointers can be implicitly converted into void* pointers, and there is a built-in
comparison function for built-in pointers.

<approach-three>

Use operator!() but still not complete.


{{smart-pointer-in-inheritance}}

If use smart pointer thinking it do derived-to-base conversion in inheritance, causes compile error.
Why? Template make a new class so inheritance no longer exist. Is it useful to maintain inheritance
when use template? If so, do further study.


{{smart-pointer-and-const}}

For built-in:

const T* const ptr = ...;

For smart pointer:

const SmartPtr< T> ptr = &goodCD;  // const pointer
SmartPtr< const CD> ptr = &goodCD;

Unlike built-in, there is no conversion from non-const to ptr-to-const.

const CD* pConstCD = pCD;

Because template create new classes. If need more, see further.


={============================================================================
*kt_dev_stl_019*	new and delete

{default-and-value-init}
#include <new>

string* ps = new string;		// default-init
string* ps = new string();		// value-init

int* pi = new int;				// default-init
int* pi = new int();				// value-init

Only for built-in types, value-init makes difference and this means that default-init for built-in
types has uninitialized values. For class types, both will use default ctors and so no difference.
<new-operator> combines allocation and construction. it creates 'unnamed' and then 'default-init'
objects e.g. calls ctor for class object.


{new-operator}
MEC++08: This operator is built into the language and, like sizeof, you can't change its meaning: it
always does the same thing. What it does is twofold: allocation and construction.

For new operator, use operator new (or operator new[]) to allocate raw memory, runs ctor to
construct, and returns pointer to constructed memory. Raise 'bad_alloc' exception when there no
memory.

For deletion, runs dtor and operator delete( or delete[]) to free memory.
	 
<new-operator-and-delete-operator>
EC++16. Use the same form in corresponding uses of new and delete since these do two things but
think what will happen when call destructor(s) less or more than needed. Undefined in both ways. 

std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100]; 

delete stringPtr1;
delete[] stringPtr2;

<warning-when-use-typedef>
typedef std::string AddressLines[4];
std::string *pal = new AddressLines;

delete pal;    // undefined
delete[] pal;

If do not know that there is a typedef, for example, it is in a file somewhere in huge source tree
then may be a problem.


{operator-new-and-delete}
This is the C++ equivalent of calling malloc and free. What you can change is how the memory for an
object is allocated. The name of the function that the new operator calls to allocate memory is
operator-new. you can rewrite or overload that function to change its behavior.

The operator new function is usually declared like this:

void * operator new(size_t size);

The return type is void*, because this function returns a pointer to raw, uninitialized memory.

void *rawMemory = operator new(sizeof(string));

Like malloc, operator new's only responsibility is to allocate memory.

NOTE: Can define own operator new and delete but careful because it takes over responsibility for
<ALL> dynamic memory allocation. <BECAUSE> write your own version of operator new and then use the
new operator; it will automatically invoke your custom version of operator new.


{placement-new} <interview>
A [special] version of operator new called placement new which gives it more options. The placement
new is part of the standard C++ library. To use placement new, all you have to do is #include <new>
(or, if your compilers don't yet support the new-style header names, <new.h>).
However, do not need to include new header for a use of operator new.

<example-one>
One example is to tell not to raise exception. No exception and return nullptr instead.

int* pi = new (nothrow) int;

<example-two>
new (place_address) type 
new (place_address) type (initializers)

Widget * constructWidgetInBuffer(void *buffer, int widgetSize)
{
	return new (buffer) Widget(widgetSize);
}

This function returns a pointer to a Widget object that's constructed within the buffer passed to
the function.

<useful-case>
Such a function might be useful for applications using shared memory or memory-mapped I/O, because
objects in such applications must be placed at specific addresses or in memory allocated by special
routines.


{must-match-between-operator-new-and-delete}
// allocate enough memory to hold 50 chars; call no ctors
void *buffer = operator new(50*sizeof(char)); 
...

// deallocate the memory; call no dtors
operator delete(buffer); 

NOTE: Should undo the effect of the constructor by explicitly calling the object's destructor:

// functions for allocating and deallocating memory in shared memory
void * mallocShared(size_t size);
void freeShared(void *memory);
void *sharedMemory = mallocShared(sizeof(Widget));

// placement new is used
Widget *pw = constructWidgetInBuffer( sharedMemory, 10);           

...

// undefined! sharedMemory came from mallocShared, not operator new
delete pw; 

// fine, destructs the Widget pointed to by pw, but doesn't deallocate the memory containing the
// Widget
pw->~Widget(); 

// fine, deallocates the memory pointed to by pw, but calls no destructor
freeShared(pw); 

(From Primus?)
This is analogous to allocator.construct() but one important difference: allocator.construct()
must use memory allocated by the 'same' allocator but need not point to memory by operator
new and refer to dynamic memory.


{overloading-new-and-delete-as-a-member-func}
note: useful case? can implement memory allocation specific to class?

When see new/delete expr, looks for corresponding operator function to call. For class type
arg-dependent lookup applies. If class has a member new or delete operator, this will be used while
can use library version via ::new or ::delete.


{allocator}
Some needs to allocate a varying amount of storage at run time and use a library container.
However, some needs to do their 'own' allocation. Such classes must define own copy controls. As an
example, see StrVec in Primers p524.

#include <memory>

template<class T>
struct allocator;
		
template<>
struct allocator<void>;

Provides a way to decouple alloc/dealloc and construction/destruction and allows finer control. For
example, allocate big memory and pay the overhead of construction 'only' when needed.

The allocator provides 'type-aware' allocation and returns 'unconstructed' memory while operator-new
uses only size. Be careful since using unconstructed memory is 'undefined'.

allocator<string> alloc;
auto const p = alloc.allocator(n);

// calls ctor. From C++11, supports many ctors of the 'type' The first argument to construct() must
// be a pointer to unconstructed space allocated by allocate(). The second and subsequent argument
// determine ctor to use.
alloc.construct(p++);
alloc.construct(p++, 10, 'c');
alloc.construct(p++, "hi");

// calls dtor
alloc.destory(p);

// size must match
alloc.deallocate(p, n);

<companion-algorithms>
The library defines two that calls 'construct' on each element in uninitialsed memory.

uninitialized_copy(b, e, b2);
copies elements from the input range by iterator b and e into unconstructed memory by iterator b2.
Like copy, return its incremented destination iterator.

uninitialized_copy_n(b, n, b2);
copies n elements from b to b2.

uninitialized_fill(b, e, t);
construct objects in raw memory denoted by b and e as a copy of t.

uninitialized_fill_n(b, n, t);

auto p = alloc.allocate( vi.size()*2 );
auto q = uninitialized_copy( vi.begin(), vi.end(), p );
uninitialized_fill_n( q, vi.size(), 42 );


{delete-caution}
It's okay delete nullptr but it's undefined when:

1) delete twice
2) delete ptr that was not from new operator.


={============================================================================
*kt_dev_stl_020*	gcc stl impl files

/usr/include/c++/4.4.4

algorithm        cinttypes           cstddef          exception            iostream  queue         thread
array            ciso646             cstdint          exception_defines.h  istream   random        tr1
backward         climits             cstdio           exception_ptr.h      iterator  ratio         tr1_impl
bits             clocale             cstdlib          ext                  limits    regex         tuple
bitset           cmath               cstring          fenv.h               list      set           typeinfo
c++0x_warning.h  complex             ctgmath          forward_list         locale    sstream       type_traits
cassert          complex.h           ctime            fstream              map       stack         unordered_map
ccomplex         condition_variable  cwchar           functional           memory    stdatomic.h   unordered_set
cctype           csetjmp             cwctype          i686-redhat-linux    mutex     stdexcept     utility
cerrno           csignal             cxxabi-forced.h  initializer_list     new       streambuf     valarray
cfenv            cstdarg             cxxabi.h         iomanip              numeric   string        vector
cfloat           cstdatomic          debug            ios                  ostream   system_error  x86_64-redhat-linux
chrono           cstdbool            deque            iosfwd               parallel  tgmath.h

bits dir has actual STL files.


==============================================================================
*kt_dev_stl_021*	algorithm: remove-erase idiom

If want to delete all elements with specific value from container, use remove-erase idiom.

When runs remove(), it will reorder like:

<elemenets not matched> <elements matched>
                       |
							  += return the past of the last element

c.erase( remove( c.begin(), c.end(), 1963 ), c.end() );

For list and assoc containers, use member func as c.remove(1963)


={============================================================================
*kt_dev_stl_022* iterator: external and internal

Was asked in phone screening. 

http://gafter.blogspot.co.uk/2007/07/internal-versus-external-iterators.html

In the "Gang Of Four" Patterns book's discussion of the Iterator pattern, we read (page 260):

Who controls the iteration? A fundamental issue is deciding which party controls the iteration, the
iterator or the client that uses the iterator. When the client controls the iteration, the iterator
is called an external iterator (C++ and Java), and when the iterator controls it, the iterator is an
internal iterator (Lisp and functional languages). Clients that use an external iterator must
advance the traversal and request the next element explicitly from the iterator. In contrast, the
client hands an internal iterator an operation to perform, and the iterator applies that operation
to every element in the aggregate.

External iterators are more flexible than internal iterators. It's easy to compare two collections
for equality with an external iterator, for example, but it's practically impossible with internal
iterators. Internal iterators are especially weak in a language like C++ that does not provide
anonymous functions, closures, or continuations like Smalltalk and CLOS. But on the other hand,
internal iterators are easier to use, because they define the iteration logic for you.


={============================================================================
*kt_dev_stl_100* ref: can store unique_ptr in a container?

From unique-ptr # no copy support:
This was auto_ptr before C++11 and it has only one user because 'no' ordinary copy and assign are
supported. Only 'one' unique_ptr at a time can point to a given object. So limit the use and it
transfer ownerships.

From "moving objects": 
Note: In previous library, class stored in a container had to be 'copyable'. Under new standard, can
use container on types that cannot be copied so long as they can be moved.

So cannot store? No can since not copyable but moveable.

http://eli.thegreenplace.net/2012/06/20/c11-using-unique_ptr-with-standard-library-containers/

C++11: using unique_ptr with standard library containers
June 20th, 2012 at 8:46 pm

Before C++11, the only "smart" pointer available in the standard C++ library was auto_ptr. Alas,
auto_ptr isn’t very smart. It has very problematic copy semantics that make it difficult to use in
several important scenarios. In particular, auto_ptr can not be used with standard containers and
algorithms!

To quote from Herb Sutter:

auto_ptr is most charitably characterized as a valiant attempt to create a unique_ptr before C++ had
move semantics. auto_ptr is now deprecated, and should not be used in new code. When you get a
chance, try doing a global search-and-replace of auto_ptr to unique_ptr in your code base

So what is this unique_ptr thing, and what can it be used for?

Basic capabilities

To put it simply, unique_ptr 'should' be the 'default' smart pointer used by new C++ code, replacing
"raw" pointers as much as possible. unique_ptr cleanly represents the single ownership idiom - it
cannot be copied and assigned, and it cleans up the pointed object when it’s destructed.

Here’s some code to demonstrate this [1]:

#include <iostream>
#include <cstdlib>
#include <memory>          // note header

using namespace std;

struct Foo {
    Foo() {cerr << "Foo [" << this << "] constructed\n";}  // note use of this to get a pointer
    virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

int main(int argc, char** argv) 
{
  // .. some code
  {
    unique_ptr<Foo> fp(new Foo());     // note not unique_ptr<Foo*>

    unique_ptr<Foo> fp2(fp);    // ERROR! can't copy unique_ptr
    unique_ptr<Foo> fp3;
    fp3 = fp;                   // ERROR! can't assign unique_ptr

    cerr << "Exiting scope\n";
  } // fp will be destroyed, and will destruct the pointed object

  return 0;
}

The lines marked with the ERROR! comment won’t actually compile. The compiler will complain saying
something like:

error: use of deleted function
 'std::unique_ptr<_Tp, _Dp>::unique_ptr(const std::unique_ptr<_Tp, _Dp>&)

If these two lines are commented out, the code will print:

Foo [0x845010] constructed
Exiting scope
Foo [0x845010] destructed

In addition to managing the pointed object’s lifetime, unique_ptr provides the other expected
capabilities of a smart pointer: it overloads operator* and operator->, provides a means to obtain
the raw pointer (get), to relinquish control of the pointed object (release), and to replace the
object it manages (reset). It also lets you customize the way the pointed object is deleted (if you
don't want it to be the default delete operator), and has some other niceties - just consult
your favorite C++ reference.

<Q> How does the library make it not copyable?


What about sources and sinks?

In this article I want to focus not on the grocery list of unique_ptr‘s features, but its
interesting move semantics. Specifically, given that unique_ptr forbids copying and assignment, one
may wonder how it can fit in the source and sink idiom which is so useful for smart pointers.

In other words, we'd like this to work:

// source creates a Foo object, wraps it in a smart pointer for safety and provides the result to
// the caller, giving it the ownership of the object in the process.
unique_ptr<Foo> source();

// sink gets a Foo object wrapped in a smart pointer for safety. It also assumes ownership of the
// provided object.
void sink(unique_ptr<Foo> p);

And in C++11, it does! Even though unique_ptr can't be copied, it can be moved. Move semantics are a
perfect match for unique_ptr - the two concepts reinforce each other. With move semantics,
unique_ptr is both safe and efficient. Here's some code to demonstrate this:

#include <iostream>
#include <cstdlib>
#include <memory>

using namespace std;

struct Foo {
  Foo() {cerr << "Foo [" << this << "] constructed\n";}
  virtual ~Foo() {cerr << "Foo [" << this << "] destructed\n";}
};

void sink(unique_ptr<Foo> p) {
  cerr << "Sink owns Foo [" << p.get() << "]\n";
}

unique_ptr<Foo> source() {
  cerr << "Creating Foo in source\n";
  return unique_ptr<Foo>(new Foo);
}

int main(int argc, char** argv) {
  cerr << "Calling source\n";
  unique_ptr<Foo> pmain = source();  // Can also be written as
  // auto pmain = source();

  cerr << "Now pmain owns Foo [" << pmain.get() << "]\n";
  cerr << "Passing it to sink\n";
  sink(pmain);                    // ERROR! can't copy unique_ptr
  sink(move(pmain));              // OK: can move it!    // meant std::move

  cerr << "Main done\n";
  return 0;
}

Again, there's a line marked with ERROR! here - it demonstrates once again that a unique_ptr can't
be copied. However, it can be explicitly moved, as the next line shows [2]. When the erroneous line
is commented out, this code prints:

[2] It can also be taken from an rvalue: sink(unique_ptr<Foo>(new Foo)) would work, because rvalue
references can be moved directly. note. here again temp object hence rvalue

Calling source
Creating Foo in source
Foo [0x1767010] constructed
Now pmain owns Foo [0x1767010]
Passing it to sink
Sink owns Foo [0x1767010]
Foo [0x1767010] destructed
Main done

Note how cleanly the ownership is being passed between the functions in this code. At each point in
time, only a single unique_ptr owns the pointed Foo object. Moreover, this is efficient - the actual
pointed object only gets constructed once and destructed once.

Containers - motivation

So unique_ptr is a useful single-ownership smart pointer. But what makes it really shine (especially
when compared to auto_ptr) is that it can be used in standard containers.

Why is it so important to be able to place smart pointers into containers? Because holding objects
by value is sometimes very expensive. Containers, especially when coupled with algorithms, tend to
move objects around. Large objects are expensive to copy, hence we'd like to keep pointers to
objects inside containers instead.

What follows is a very simplistic example that demonstrates this. It shows how much more expensive
it is to sort a vector of large objects that are stored by value, than it is when they're stored by
pointer [3].

Also, I explicitly said to take the container example with a grain of salt as it was synthetically
built to demonstrate the point. Yes, it is best to avoid huge objects, but that's not always
possible.

First, let's create a synthetic "large" object that has well defined ordering properties by some
numeric ID:

struct SomeLargeData {
    SomeLargeData(int id_)
        : id(id_)
    {}
    int id;
    int arr[100];
};

We also need a function to compare two such objects. Actually, we need two - one for a container
that holds object by value, and another for the by-pointer version:

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
    return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
    return a->id < b->id;
}

Let's now create two vectors and populate them with random objects:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));
}

Finally, we'll sort the two vectors with the standard sort algorithm, and measure the runtime for
some large n:

sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

The timing results I get are quite consistent - the by-pointer sorting is 2-3x faster than the
by-value sorting [4]. That's a very significant difference, and it's all due to the copying sort has
to do for moving the objects around inside the container.

[4] The speedup grows as the size of the object grows. Increasing the arr member to hold 1000
integers makes the speedup 10x.

So holding objects of non-trivial size inside standard containers is not a good idea in terms of
performance. But holding raw pointers to them is also not so great, because of all the safety issues
that come with raw pointers. The container can't own the pointed objects because its destructor will
just "destruct" the pointer(note not pointed object), which does nothing. So the calling code(note
client) has to own the actual objects which are being shuffled around by the container. Add
exceptions and/or early returns to the mix, and this is a recipe for memory leaks or even worse
problems.

What we'd really like to do is let our objects be managed by a smart pointer and put that into a
container. This would guarantee a clean ownership strategy - the container destroys its contents
when it gets destroyed itself - just the way it should be. This is why unique_ptr is so exciting.

Containers of unique_ptr

Adapting the by-pointer version of the code above to hold unique_ptr is very simple. First, we need
another comparison function:

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a,
                        const unique_ptr<SomeLargeData>& b) {
    return a->id < b->id;
}

And then we just need to create the vector, populate it and then sort it, similarly to the way we've
done for the other vectors:

vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    // ...
    vec_byuniqptr.push_back(
        unique_ptr<SomeLargeData>(new SomeLargeData(id)));  
    // note temp object. shall be this form since no copy supported or use std::move
}

sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);

That's it! And the performance? Almost identical to the by-pointer version (I measured differences
of 1-5%, depending on the data).

What about shared pointers?

Another smart pointer C++11 brings with it is the shared_ptr/weak_ptr pair, implementing a
reference-counted approach to shared ownership. While much more flexible than unique_ptr, shared_ptr
is slower and consumes more memory; managing the reference count is not free [5].

[5] For the sorting benchmark demonstrated in this article shared_ptr is about 10% slower than
unique_ptr. As for size, while the size of unique_ptr is exactly the size of a raw pointer,
shared_ptr is about twice as large.

Which one to use depends on your exact needs, but I agree with Herb Sutter's proposal of using
unique_ptr by default and switching to shared_ptr if the need arises.

In addition, it is my personal opinion that preferring unique_ptr imposes a certain memory
management discipline on the code, since you know at each point exactly who owns what. Shared
pointers give you a sense of security you can over-use and end up with reference leaks, which are
tricky to debug (just like when writing Python C extension code). 

Moreover, shared pointers signal the intention of APIs less clearly than owning pointers. When some
factory returns a shared pointer, does it mean it keeps a reference to the object too? With an
owning pointer, the API is self documenting (source returns a unique_ptr? then source is for sure
giving away ownership). With a shared pointer, it does not, and need external documentation to
clarify.

Conclusion

I have mentioned how rvalue references and move semantics can make code more efficient with C++11.
unique_ptr is another great example that makes me want to use a C++11-capable compiler as soon as
possible.

unique_ptr provides an excellent mix of efficiency and safe memory management. IMHO it's a great
example of how several ideas in language design interact to create a whole that is larger than its
parts.

Replies:

<1>
fanNo Gravatar Says:
June 25th, 2012 at 14:48

Can’t we get the best of all worlds, by doing this:

vector<SomeLargeData> vec_byval;
vector<SomeLargeData*> vec_byptr;

for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(&vec_byval.back());
}

sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);

This gives us 'fast' by-pointer sorting AND 'ownership' of the pointed objects. So I don’t get the
excitement about unique_ptr.

<2>
westforkNo Gravatar Says:
November 5th, 2012 at 12:22

Hi

Nice article. But my results are different from what you wrote.  I implemented your code using gcc
4.7 (g++ (Ubuntu/Linaro 4.7.2-4precise1) 4.7.2) on my desktop (OS xubuntu 12.04, Intel(R) Core(TM)2
Duo CPU, E8400 @ 3.00GHz).  I build a vector of 2010000 containing SomeLargeData objects, raw
pointers to SomeLargeData objects and unique-pointers to SomeLargeData objects. The results are that
raw pointer container is the faster to sort (as expected) but the container with the unique pointers
is the slower!!!  Here a dump of my tests

By value test
TIMESTAMP-START 11:18:23:127277 (ms ~ 40703127)
TIMESTAMP-END 11:18:27:378556 (ms ~ 40707378)
ELAPSED TIME (ms) 4251

By pointer test
TIMESTAMP-START 11:18:27:378658 (ms ~ 40707378)
TIMESTAMP-END 11:18:29:841735 (ms ~ 40709841)
ELAPSED TIME (ms) 2463

By unique_pointer test
TIMESTAMP-START 11:18:29:841816 (ms ~ 40709841)
TIMESTAMP-END 11:18:35:674064 (ms ~ 40715674)
ELAPSED TIME (ms) 5833

What do you think? The overhead of the unique-ptr over the raw pointer is so heavy?

Regards
westfork

<3>
SqeakyNo Gravatar Says:
March 19th, 2013 at 11:58

@Fan The first time the value vector grows it will invalidate all the pointers in the pointer
vector. Since it never tells you when this happens, but can happen on any insertion, you have to
assume that the pointer is invalid after the next insertion.

@Westfork I would guess that the implementation just hasn’t had enough time to mature yet. There
must be at least as much over with the unique_ptr as raw pointers, but double does seem excessive.
Did you remember to delete in the raw pointer example?


<4>
This is my result on the VM in a laptop.

#include <iostream>
#include <memory>
#include <vector>
#include <sys/time.h>
#include <algorithm>

using namespace std;

typedef uint64_t u64;

static u64 nsec() {
  struct timeval tv;
  if(gettimeofday(&tv, 0) < 0)
    return -1;
  return (u64)tv.tv_sec*1000*1000*1000 + tv.tv_usec*1000;
}

struct SomeLargeData {
  SomeLargeData(int id_)
    : id(id_)
  {}

  // SomeLargeData(int id_)
  //   : id(id_)
  // { cout << "Foo[" << this << "] ctor(" << id << ")" << endl; }
  // ~SomeLargeData() { cout << "Foo[" << this << "] dtor(" << id << ")" << endl; }

  int id;
  int arr[100];
};

bool compare_by_value(const SomeLargeData& a, const SomeLargeData& b) {
  return a.id < b.id;
}

bool compare_by_ptr(const SomeLargeData* a, const SomeLargeData* b) {
  return a->id < b->id;
}

bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a, const unique_ptr<SomeLargeData>& b) {
  return a->id < b->id;
}

int main()
{
  uint64_t be, af;
  int n = 400;

  vector<SomeLargeData> vec_byval;
  vector<SomeLargeData*> vec_byptr;
  vector<unique_ptr<SomeLargeData>> vec_byuniqptr;

  for (int i = 0; i < n; ++i) {
    int id = rand() % 500000;
    vec_byval.push_back(SomeLargeData(id));
    vec_byptr.push_back(new SomeLargeData(id));    // note. shall be deleted later
    vec_byuniqptr.push_back(unique_ptr<SomeLargeData>(new SomeLargeData(id)));
  }  

  be = nsec();
  sort(vec_byval.begin(), vec_byval.end(), compare_by_value);
  af = nsec();
  cout << "by value: diff(ns): " << af-be << endl;
  cout << "by value: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byptr.begin(), vec_byptr.end(), compare_by_ptr);
  af = nsec();
  cout << "by ptr: diff(ns): " << af-be << endl;
  cout << "by ptr: diff(ms): " << (af-be)/(1000) << endl;

  be = nsec();
  sort(vec_byuniqptr.begin(), vec_byuniqptr.end(), compare_by_uniqptr);
  af = nsec();
  cout << "by uptr: diff(ns): " << af-be << endl;
  cout << "by uptr: diff(ms): " << (af-be)/(1000) << endl;
}

$ ./a.out 
by value: diff(ns): 302000
by value: diff(ms): 302
by ptr: diff(ns): 127000
by ptr: diff(ms): 127
by uptr: diff(ns): 585000
by uptr: diff(ms): 585


# ============================================================================
#{ SYSTEM
={============================================================================
*kt_dev_sys_001*	<empty>

={============================================================================
*kt_dev_sys_002*	endianess

representation

this is how {.byte 11} in MIPS is stores in memory:

0000 0000 0000 0000 0000 0000 0000 1011

big endian(e.g. intel)	little(e.g. spacc)
0000 0000					0000 1011
0000 0000					0000 0000
0000 0000					0000 0000
0000 1011					0000 0000


==============================================================================
*kt_dev_sys_003*	to check endianess at runtime

uint8_t ebuf[4];
uint32_t *ebuf32 = (uint32_t *)ebuf;

ebuf32[0] = 0x01000000;
if(ebuf[0] == 0x01) system_endian = TBIG_ENDIAN;
else system_endian = TLITTLE_ENDIAN;


={============================================================================
*kt_dev_sys_004*	to check address alignment

#define SYSTEM_ALIGNMENT (8)

/* check if an address is aligned to the given alignment boundry,
   NOTE: alignment boundry must be a power of two */
#define IS_ALIGNED(addr,alignb) (((((uint32_t)(addr))) & (((unsigned)alignb)-1)) == 0)

// ALIGNED
if (IS_ALIGNED(size, SYSTEM_ALIGNMENT)) 
{
	*p_aligned_size = size;
}
// NOT ALIGNED
else 
{
	*p_aligned_size = ((size / SYSTEM_ALIGNMENT) + 1) * SYSTEM_ALIGNMENT;
}

Why 'alignment byte -1'? 7(111) in this case.

dec : bin
0     0000        ==0 <- ALIGNED for 4/8 bytes
1     0001        !=0
2     0010        !=0
3     0011  [11]  !=0
----------
4     0100        <- ALIGNED for 8
5     0101
6     0110
7     0111  [11] or [111] 
----------
8     1000        <- ALIGNED
9   0 1001
10  0 1010
11  0 1011 [11]
----------
12  0 1100
13  0 1101
14  0 1110
15  0 1111 [11] or [111] 
----------
16  1 0000
32 10 0000

For 4 bytes align, 4-1=3 [11] and get the start or boundary by & [11].
For 8 bytes align, 7-1=3 [111] and get the start or boundary by & [111].


={============================================================================
*kt_dev_sys_005*	two's complement

type int on MIPS. size int: 4
s int  : -219874992
us int : 4075092304

show the complement of a binary number by flipping all digits:

    23:    1 0111
NOT 23: 1110 1000
-----------------
        1111 1111

X + NOT X = -1  ->  "1 + NOT X = -X"

NOT 23: 1110 1000
+    1: 0000 0001
-----------------
   -23: 1110 1001

this method is called "the 2's complement".

Since the addition operation in the CPU is agnostic to whether the integer is signed or unsigned,
the same goes for signed integers. For 32-bit signed integers, the minimum value is 0x80000000
(-2147483648, 31th MSB is on) and the maximum value is 0x7fffffff (2147483647). note that there is
no value than can hold 2147483648, so 1. if you 'negate' (int)0x80000000, you get (int)0x80000000 again.
That is something to look out for, because 2. it means abs() returns a negative value when fed
-2147483648.

// under gcc and ubuntu, vc and windows
signed char sc = -128;
signed char min, ret;
printf("signed char : %4d, %4d, %4d\n", sc, ~sc, ~sc+1);
printf("signed char : %x, %x, %x\n", sc, ~sc, ~sc+1);
printf("abs: %d, %d, %d, %d \n", abs(sc), abs(~sc), abs(~sc+1), abs(-sc));
printf("minus: %d, %d, %d \n", -sc, (-sc)/10, -1);

min = -sc;
ret = min/10;

printf("minus: %04d, %04d, \n", min, ret);

kit@kit-vb:~/work$ ./a.out
signed char : -128,  127,  128
signed char : ffffff80, 7f, 80
abs: 128, 127, 128, 128
minus: 128, 12, -1
minus: -128, -012, 

So 2 statement is not true? Seems not when see printf result. Really? DO NOT BELIEVE printf result
since bit representation is 'agnostic' to whether it's signed or unsigned.

unsigned int x = ~0;    // 11....1 UINT_MAX
             x >>= 1;   // 01....1 INT_MAX

signed   -INT_MAX-1 ... INT_MAX
unsigned 0          ... UNIT_MAX  

-INT_MAX-2? -INT_MAX-2 becomes INT_MAX since plus and minus moves up/down in bit representation.

So in the above, "1" and "2" means the same since abs uses 'negate'. negate on largest negative
number has no effect in bit representaiton and cause confusion or problems in arithmetic but not
printf.

8bit two's complement

0000 0000    : 0
0000 0001 {{ : 1
0000 0010    : 2
0000 0011    : 3
0000 0100    : 4
...
0111 1111 }} : 127                                       //         -(127)-2

1000 0000    : -128                                      // not -0. -(127)-1

1000 0001 {{ : -127 (0111 1110 + 1 = 0111 1111 (127))    // not -1. -(127)
1000 0010    : -126 (0111 1101 + 1 = 0111 1110 (126))    // not -2
...
1111 1110    : -2
1111 1111 }} : -1

Get two's complement in programmatic way

uint32_t ins = 0x27BDFFE0 
0010.0111.1011.1101.1111.1111.1110.0000

two's complement
1101.1000.0100.0010.0000.0000.0001.1111      // ~X
+1                                           // +1
--------------------------------------------------
1101.1000.0100.0010.0000.0000.0010.0000      // -X

(-ins) = 0xD8420020
1101.1000.0100.0010.0000.0000.0010.0000

<exercise>
The ansic, page 64, exercise 3-4. In a two's complement number representation, our version of itoa
does 'not' handle the largest negative number, that is, the value of n equal to -(2 to the power
(wordsize - 1)). Explain why not. Modify it to print that value correctly regardless of the
machine on which it runs. 

http://clc-wiki.net/wiki/K%26R2_solutions:Chapter_3:Exercise_4
In other words, to find the two's complement representation of a negative number, find the one's
complement of it, and add one. The important thing to notice is that the range of an 8 bit variable
using a two's complement representation is -128 to 127, as opposed to -127 to 127 using one's
complement. Thus, the absolute value of the largest negative number cannot be represented (i.e. we
cannot represent +128). Since the itoa() function in Chapter 3 handles negative numbers by
reversing the sign of the number before processing, then adding a '-' to the string, passing the
largest negative number will result it in being translated to 'itself':

void itoa( int n, char s[] )
{
  int i, sign;

  if( (sign = n) < 0 )     // record sign
    n = -n;                // make n positive. 

  // note that when given largest negative, has no effect and means 'n' is largest negative In
  // ansic, p41, arithmetic operators, "The direction of truncation for / and the sign of result for
  // % are machine dependent for negative operands, as is the action taken on overflow or
  // underflow". this causes (n /= 10) has negative value. From n=-2147483648 to
  // n=-214748364(0xf3333334)

  i = 0;

  do {                        // generate digits in reverse order
    s[i++] = '0' + n % 10;    // get next digit
  } while( (n /= 10) > 0 );   // delete it

  if(sign < 0)
    s[i++] = '-';

  s[i] = '\0';

  reverse(s);
}


Therefore, because (n /= 10) will be negative, the do-while loop will run once only, and will place
in the string a '-', followed by a single character, (INT_MIN % 10 + '0'). We can remedy these two
bugs in the following way:

1 - change 'while ((n /= 10) > 0)' to 'while (n /= 10)'. Since any fractional part is truncated with
integer division, n will eventually equal zero after successive divides by 10, and 'n /= 10' will
evaluate to false sooner or later.

2 - change 'n % 10 + '0 to 'abs(n % 10) + '0, to get the correct character. EX3_4.C shows the
revised function, which will run correctly regardless of the number representation


{wrap-around}
unsigned = out-of-range signed value   # wrap-around. by compiler from Primus p35?
signed   = out-of-range unsigned value # undefined.


==============================================================================
*kt_dev_sys_007*	stack (MIPS)

http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html

To think about what's required, let's think about what happens in a function call. 

1.	When a function call is executed, the arguments need to be evaluated to values at least, for
C-like programming languages.  

2.	Then, control flow jumps to the body of the function, and code begins executing there.  

3.	Once a return statement has been encountered, we're done with the function, and return back to
the function call. 

Programming languages make functions easy to maintain and write by giving each function its own
section of memory to operate in. For example, suppose you have the following function. 

int pickMin( int x, int y, int z ) {
  int min = x ;
  if ( y < min )
    min = y ;
  if ( z < min )
    min = z ;
  return min ;
}

You declare parameters x, y, and z. You also declare local variables, min. You know that these
variables won't interfere with other variables in other functions, even if those functions use the
same variable names. In fact, you also know that these variables won't interfere with separate
invocations of itself. 

For example, consider this recursive function, 

    int fact( int n ) {
      if ( n == 0 )
        return 1 ;
      else
        return fact( n - 1 ) * n ;
    }

Each call to fact produces a new memory location for n. Thus, each separate call (or invocation) to
fact has its own copy of n. How does this get implemented? In order to understand function calls,
you need to understand the stack, and you need to understand how assembly languages like MIPS
deal with the stack. 


{stack-pointer}

When a program starts executing, a certain contiguous section of memory is set aside for the program
called the stack. Let's look at a stack. 

low addr  +---------+ stack limit (overflow)
          |         |
			 |         |
			 |=========| sp (grows up towards low addr)
			 |         |
high addr +---------+ stack bottom

The stack-pointer is usually a register that contains the top of the stack. The stack pointer
contains the smallest address x such that any address smaller than x is considered garbage, and any
address greater than or equal to x is considered valid. The shaded region of the diagram represents
valid parts of the stack. 


<push-and-pop>

Push: You can push one or more registers, by setting the stack pointer to a smaller value. Usually
by subtracting 4 times the number of registers to be pushed on the stack and copying the registers
to the stack.  

Pop: You can pop one or more registers, by copying the data from the stack to the registers, then to
add a value to the stack pointer. Usually adding 4 times the number of registers to be popped on the
stack

Thus, pushing is a way of saving the contents of the register to stack, and popping is a way of
restoring the contents of the register from stack. 

Some ISAs have an explicit push and pop instruction. However, {MIPS-does-not} However, you can get
the same behavior as push and pop by manipulating the stack pointer directly. 

The stack pointer, by convention, is r29(sp). That is, it's register 29. Here's how to implement the
equivalent of push $r2 in MIPS, which is to push register $r2 onto the stack. 

push:  addi $sp, $sp, -4  # Decrement stack pointer by 4
       sw   $r3, 0($sp)   # Save $r3 to stack

Here's a diagram of a push operation. 


<stack-pointer-convention>

You might wonder why it's necessary to update the stack pointer. Couldn't you just do the following? 

push:  sw $r3, -4($sp)   # Copy $r3 to stack

Certainly, this is equivalent in behavior as far as register 3 being saved to the stack. However
we'd like to maintain the invariant (condition) that all addresses greater than or equal to the
stack pointer hold valid data, and all the addresses less than the stack pointer hold invalid data.
It just makes bookkeeping that much easier if we follow these conventions.  

Popping off the stack is the opposite of pushing on the stack. First, you copy the data from the
stack to the register, then you adjust the stack pointer. 

pop:  lw   $r3, 0($sp)   # Copy from stack to $r3
      addi $sp, $sp, 4   # Increment stack pointer by 4


<call-by-value>
If you've ever made the error of returning a pointer to a local variable or to a parameter that was
passed by value and wondered why the value stayed valid initially, but later on got corrupted, you
should now know the reason. The data still stays on the garbage part of the stack until the next
push operation overwrites it. That's when the data gets corrupted.

push and pop for 3 regs

push:  addi $sp, $sp, -12  # Decrement stack pointer by 12
       sw   $r2, 0($sp)   # Save $r2 to stack
       sw   $r3, 4($sp)   # Save $r3 to stack
       sw   $r4, 8($sp)   # Save $r4 to stack

pop:  sw   $r2, 0($sp)   # Copy from stack to $r2
      sw   $r3, 4($sp)   # Copy from stack to $r3
      sw   $r4, 8($sp)   # Copy from stack to $r4
      addi $sp, $sp, 12  # Increment stack pointer by 12


{stack-frame}
The following is more of general when there is a frame pointer so not the same as MIPS. {KT} The
stack frame is a function call and scope. Arg is copied into a stack and hence need copy-ctor.


Let's now see how the stack is used to implement functions. For each function call, there's a
section of the stack reserved for the function. This is usually called a stack frame. Let's imagine
we're starting in main() in a C program. The stack looks something like this: 

We'll call this the stack frame for main(). A stack frame exists whenever a (called) function has
started, but yet to complete.

Suppose, inside of body of main() there's a call to foo(). Suppose foo() takes two arguments. One
way to pass the arguments to foo() is through the stack. Thus, there needs to be assembly language
code in main() to "push" arguments for foo() onto the the stack. The result looks like: 

As you can see, by placing the arguments on the stack, the stack frame for main() has increased in
size. We also reserved some space for the return value. The return value is computed by foo(), so it
will be filled out once foo() is done. 

Once we get into code for foo(), the function foo() may need local variables, so foo() needs to push
some space on the stack, which looks like: 
 
   |          |
SP +----------+
   | foo      |	foo() stack frame
   |          |
   +----------+   ++++
FP | ret val  |   main() stack frame
   +----------+
   | args     |
   +----------+
   | args     |
   +----------+
   | main     |
   |          |
   |          |
   +----------+   ++++

foo() can access the arguments passed to it from main() because the code in main() places the
arguments just as foo() expects it. 

We've added a new pointer called FP which stands for frame pointer. The frame pointer points to the
location where the stack pointer was, just before foo() moved the stack pointer for foo()'s own
local variables. 

<stack-pointer>
Almost all architectures have one register dedicated to point to the end of the stack; the stack
pointer. 

<frame-pointer> <not-for-mips>
Many have a second register which points to the start of the currently active stack frame; the frame
pointer. 

That's SP means the current level and FP means the start of current stack frame.

When your program is started, the stack has only one frame, that of the function main.  This is
called the initial frame or the outermost frame.  ==

Having a frame pointer is convenient when a function is likely to move the stack pointer several
times throughout the course of running the function. The idea is to keep the frame pointer fixed for
the duration of foo()'s stack frame. The stack pointer, in the meanwhile, can change values.  Thus,
    we can use the frame pointer to compute the locations in memory for both arguments as well as
    local variables. Since it doesn't move, the computations for those locations should be some
    fixed offset from the frame pointer. 

And, once it's time to exit foo(), you just have to set the stack pointer to where the frame pointer
is, which effectively pops off foo()'s stack frame. It's quite handy to have a frame pointer.  We
can imagine the stack growing if foo() calls another function, say, bar(). foo() would push
arguments on the stack just as main() pushed arguments on the stack for foo().  So when we exit
foo() the stack looks just as it did before we pushed on foo()'s stack frame, except this time the
return value has been filled in. Once main() has the return value, it can pop that and the arguments
to foo() off the stack. 


<MIPS-stack-frame>

Each called function in a program allocates a stack frame on the run-time stack, if necessary. A
frame is allocated for each non-leaf function and for each leaf function that requires stack
storage. A non-leaf function is one that calls other function(s); a leaf function is one that does
not itself make any function calls. Stack frames are allocated on the run-time stack; the stack
grows downward from high addresses to low addresses. 

A function allocates a stack frame by subtracting the size of the stack frame from $sp on entry to
the function. This $sp adjustment must occur before $sp is used within the function and prior to any
jump or branch instructions. 


base offset | contents       | frame
+-----------+----------------+--------------
$sp       +0| arg build      |   low	
            | area           |   
            +----------------+   current
            | f/point regs   |
				| save area      |	
            +----------------+
            | generl regs    |
				| save area      |	
            +----------------+   
            | local and temp |	
+-----------+----------------+--------------
old $sp   +0| space for      |	
            | incoming args  |
            | args 1-4       |	
            +----------------+
         +16| (if present)   |
            | incoming args  |	
            | passed in sp   |	previous
            +----------------+
            | unspecified    |	high
            | ...            |	
            | variable size  |	
            +----------------+


{standard-called-function-rules}

By convention, there is a set of rules that must be followed by every function that allocates a
stack frame. Following this set of rules ensures that, given an arbitrary program counter, return
address register $31, and stack pointer, there is a deterministic way of performing
{stack-backtracing}. These rules also make possible programs that translate already compiled
absolute code into position-independent

There is only one exit from a function that contains a stack adjustment: a jump register instruction
that transfers control to the location in the return address register $31. This instruction,
including the contents of its branch delay slot, mark the end of function.

MIPS stack frame alignment. Although the architecture requires only word alignment, software
convention and the operating system require every stack frame to be doubleword (8 byte) aligned.

In the previous discussion of function calls, we said that arguments are pushed on the stack and
space for the return value is also pushed. This is how CPUs used to do it. With the RISC revolution
(admittedly, nearly 20 years old now) and large numbers of registers used in typical RISC machines,
{the-goal-is-to-try-and-avoid-using-the-stack}. 

Why? The stack is in physical memory, which is RAM. Compared to accessing registers, accessing
memory is much slower---probably on the order of 100 to 500 times as slow to access RAM than to
access a register. 


http://msdn.microsoft.com/en-us/library/aa448706.aspx
(The MIPS microprocessor has 32 general-purpose registers.) 

(gdb) info registers

          zero       at       v0       v1       a0       a1       a2       a3
 R0   00000000 10008401 2aadf310 00d40b70 2aadc000 00000000 00000001 00000001 
            t0       t1       t2       t3       t4       t5       t6       t7
 R8   00000000 00008400 10008400 831a8000 00000002 00000000 831a9e7a 00000000 
            s0       s1       s2       s3       s4       s5       s6       s7
 R16  00a12870 009cc130 0098c4bc 00000001 00000004 00000008 009cd2fc 009cc23c 
            t8       t9       k0       k1       gp      {sp}      s8      {ra}
 R24  831a9d9a 2aada010 00000000 00000000 2aae5010 009cc078 00860000 2aad2590 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 00d40b74 0080000c 2aad0cac 
           fsr      fir
      00000000 00000000 


args $a0, $a1, $a2, $a3 ~

There are four registers used to pass arguments: $a0, $a1, $a2, $a3.  If a function has
more than four arguments, or if any of the arguments is a {large-structure} that's passed by
value, then the stack is used.  There must be a set procedure for passing arguments that's
known to everyone based on the types of the functions. That way, the caller of the
function knows how to pass the arguments, and the function being called knows how to
access them. Clearly, if this protocol is not established and followed, the function being
called would not get its arguments properly, and would likely compute bogus values or,
worse, crash. 


return $v0, $v1 ~

The return value is placed in registers $v0, and if necessary, in $v1. In general, this
makes calling functions a little easier. In particular, the calling function usually does
not need to place anything on the stack for the function being called. 

However, this is clearly not a panacea. In particular, imagine main() calls foo().
Arguments are passed using $a0 and $a1, say. What happens when foo() calls bar()? If foo()
has to pass arguments too, then by convention, it's supposed to pass them using $a0 and
$a1, etc. What if foo() needs the argument values from main() afterwards? To prevent its
own arguments from getting overwritten, foo() needs to save the arguments to the stack.
Thus, we don't entirely avoid using the stack. 


Example to show reg changes between SF.

(gdb) bt
#0  0x2aaf02d4 in ?? () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
#1  0x00b100c8 in SYSTEMITC_API_PendEvent (qhandle=<value optimized out>, timeout=-1) at systemitc.c:375
#2  0x00520fd0 in SrmLowPriorityMain (data=<value optimized out>) at srm_main.c:1597
#3  0x00b328d0 in SYSTEMUTIL_THR_P_ThreadPrologue (arg=<value optimized out>) at systemutil_thread.c:869
#4  0x2aad2f9c in pthread_join () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
Backtrace stopped: previous frame inner to this frame (corrupt stack?)

(gdb) bt
#0  0x2aaf02d4 in ?? () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbb0 00d40000 00b100c8 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 2aaf02d4 
      
#1  0x00b100c8 in SYSTEMITC_API_PendEvent (qhandle=<value optimized out>, timeout=-1) at systemitc.c:375
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbb0 00d40000 00b100c8 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00b100c8 
            
#2  0x00520fd0 in SrmLowPriorityMain (data=<value optimized out>) at srm_main.c:1597
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fbe8 00d40000 00520fd0 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00520fd0 

(SP diff: 0139fe38 - 0139fbe8 = 0x250, 592)      

#3  0x00b328d0 in SYSTEMUTIL_THR_P_ThreadPrologue (arg=<value optimized out>) at systemutil_thread.c:869
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139fe38 00f0eacc 00b328d0 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 00b328d0 

(0139feb0 - 0139fe38 = 0x78, 128)
       
#4  0x2aad2f9c in pthread_join () from /data/home/NDS-UK/parkkt/fob/gdb/lib/libpthread.so.0
            t8       t9       k0       k1       gp       sp       s8       ra
 R24  00f28b4c 2aaf02c0 00000000 00000000 2ab88540 0139feb0 00f0eacc 2aad2f9c 
            sr       lo       hi      bad    cause       pc
      00008413 00000000 00000000 2b4bae74 00800020 2aad2f9c 

40 registers in total and 40*4 = 160 bytes


==============================================================================
*kt_dev_sys_008*	stack asm example (MIPS)

# C
#

typedef struct {
	int struct_one;
	int struct_two;
	int struct_three;
} ENTRY;

int func_second(int arg1, int arg2)
{
	int local_val = 0;
	
	return local_val = arg1*2 + arg2;	
}

int func_first(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ENTRY entry)
{
	int local_val = 0;
	int one = 0, two = 0;
	
	one = arg5+arg1+entry.struct_one;
	two = arg6+arg2+entry.struct_two;
	
	local_val = arg1+arg2+arg3+arg4+func_second(one, two);
	
	return local_val;
}

int main(int argc, char* argv[])
{
	int ret = 0;
	ENTRY node = {0};
	
	node.struct_one = 10;
	node.struct_two = 20;
	node.struct_three = 30;
	
	ret = func_first( 1, 2, 3, 4, 5, 6, node );
	printf("ret = %d\n",  ret);	
	return 0;
}


# asm
#

int func_second(int arg1, int arg2)
{
  400590:	27bdffe8 	addiu	sp,sp,-24
  400594:	afbe0010 	sw	s8,16(sp)	# {no-need-to-save-ra}
  400598:	03a0f021 	move	s8,sp
  40059c:	afc40018 	sw	a0,24(s8)
  4005a0:	afc5001c 	sw	a1,28(s8)
	int local_val = 0;
  4005a4:	afc00008 	sw	zero,8(s8)
	
	return local_val = arg1*2 + arg2;	
  4005a8:	8fc20018 	lw	v0,24(s8)
  4005ac:	00021840 	sll	v1,v0,0x1
  4005b0:	8fc2001c 	lw	v0,28(s8)
  4005b4:	00621021 	addu	v0,v1,v0
  4005b8:	afc20008 	sw	v0,8(s8)
  4005bc:	8fc20008 	lw	v0,8(s8)
}
  4005c0:	03c0e821 	move	sp,s8
  4005c4:	8fbe0010 	lw	s8,16(sp)
  4005c8:	27bd0018 	addiu	sp,sp,24	# pop
  4005cc:	03e00008 	jr	ra				# {return-to-caller} 
  4005d0:	00000000 	nop

004005d4 <func_first>:

note no pass by value happend for struct arg. how about passing this struct to second
func? this struct will be copied again in stack?

int func_first(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ENTRY entry)
{
  4005d4:	27bdffc8 	addiu	sp,sp,-56
  4005d8:	afbf0030 	sw	ra,48(sp)	# {save-ra}
  4005dc:	afbe002c 	sw	s8,44(sp)
  4005e0:	afb00028 	sw	s0,40(sp)
  4005e4:	03a0f021 	move	s8,sp
  4005e8:	afc40038 	sw	a0,56(s8)	// save args in stack
  4005ec:	afc5003c 	sw	a1,60(s8)
  4005f0:	afc60040 	sw	a2,64(s8)
  4005f4:	afc70044 	sw	a3,68(s8)
	int local_val = 0;
  4005f8:	afc00020 	sw	zero,32(s8)
	int one = 0, two = 0;
  4005fc:	afc0001c 	sw	zero,28(s8)
  400600:	afc00018 	sw	zero,24(s8)
	
	one = arg5+arg1+entry.struct_one;
  400604:	8fc30048 	lw	v1,72(s8)	// arg5
  400608:	8fc20038 	lw	v0,56(s8)	// arg1
  40060c:	00621821 	addu	v1,v1,v0
  400610:	8fc20050 	lw	v0,80(s8)	// struct.one
  400614:	00621021 	addu	v0,v1,v0
  400618:	afc2001c 	sw	v0,28(s8)
	two = arg6+arg2+entry.struct_two;
  40061c:	8fc3004c 	lw	v1,76(s8)	// arg6
  400620:	8fc2003c 	lw	v0,60(s8)	// arg2
  400624:	00621821 	addu	v1,v1,v0
  400628:	8fc20054 	lw	v0,84(s8)
  40062c:	00621021 	addu	v0,v1,v0
  400630:	afc20018 	sw	v0,24(s8)
	
	local_val = arg1+arg2+arg3+arg4+func_second(one, two);
  400634:	8fc30038 	lw	v1,56(s8)
  400638:	8fc2003c 	lw	v0,60(s8)
  40063c:	00621821 	addu	v1,v1,v0
  400640:	8fc20040 	lw	v0,64(s8)
  400644:	00621821 	addu	v1,v1,v0
  400648:	8fc20044 	lw	v0,68(s8)
  40064c:	00628021 	addu	s0,v1,v0
  400650:	8fc4001c 	lw	a0,28(s8)
  400654:	8fc50018 	lw	a1,24(s8)
  400658:	0c100164 	jal	400590 <func_second>
  40065c:	00000000 	nop
  400660:	02021021 	addu	v0,s0,v0	// local_val = ... + return;
  400664:	afc20020 	sw	v0,32(s8)		 
	
	return local_val;
  400668:	8fc20020 	lw	v0,32(s8)
}
  40066c:	03c0e821 	move	sp,s8
  400670:	8fbf0030 	lw	ra,48(sp)
  400674:	8fbe002c 	lw	s8,44(sp)
  400678:	8fb00028 	lw	s0,40(sp)
  40067c:	27bd0038 	addiu	sp,sp,56
  400680:	03e00008 	jr	ra
  400684:	00000000 	nop

00400688 <main>:

int main(int argc, char* argv[])
{
  400688:	27bdffb8 	addiu	sp,sp,-72
  40068c:	afbf0044 	sw	ra,68(sp)	// save return
  400690:	afbe0040 	sw	s8,64(sp)
  400694:	03a0f021 	move	s8,sp
  400698:	afc40048 	sw	a0,72(s8)
  40069c:	afc5004c 	sw	a1,76(s8)
	int ret = 0;
  4006a0:	afc00030 	sw	zero,48(s8)
	ENTRY node = {0};
  4006a4:	afc00034 	sw	zero,52(s8)	// struct in stack
  4006a8:	afc00038 	sw	zero,56(s8)
  4006ac:	afc0003c 	sw	zero,60(s8)
	
	node.struct_one = 10;
  4006b0:	2402000a 	li	v0,10
  4006b4:	afc20034 	sw	v0,52(s8)
	node.struct_two = 20;
  4006b8:	24020014 	li	v0,20
  4006bc:	afc20038 	sw	v0,56(s8)
	node.struct_three = 30;
  4006c0:	2402001e 	li	v0,30
  4006c4:	afc2003c 	sw	v0,60(s8)
	
	ret = func_first( 1, 2, 3, 4, 5, 6, node );
  4006c8:	24020005 	li	v0,5		// arg in stack and move struct in stack
  4006cc:	afa20010 	sw	v0,16(sp)	// essentially, arg and strcut in stack
  4006d0:	24020006 	li	v0,6
  4006d4:	afa20014 	sw	v0,20(sp)
  4006d8:	8fc20034 	lw	v0,52(s8)
  4006dc:	8fc30038 	lw	v1,56(s8)
  4006e0:	8fc4003c 	lw	a0,60(s8)
  4006e4:	afa20018 	sw	v0,24(sp)
  4006e8:	afa3001c 	sw	v1,28(sp)
  4006ec:	afa40020 	sw	a0,32(sp)
  4006f0:	24040001 	li	a0,1
  4006f4:	24050002 	li	a1,2
  4006f8:	24060003 	li	a2,3
  4006fc:	24070004 	li	a3,4
  400700:	0c100175 	jal	4005d4 <func_first>	// func call
  400704:	00000000 	nop
  400708:	afc20030 	sw	v0,48(s8)
	printf("ret = %d\n",  ret);	
  40070c:	3c020040 	lui	v0,0x40
  400710:	244407e0 	addiu	a0,v0,2016
  400714:	8fc50030 	lw	a1,48(s8)
  400718:	0c100124 	jal	400490 <printf@plt>
  40071c:	00000000 	nop
	return 0;
  400720:	00001021 	move	v0,zero
}
  400724:	03c0e821 	move	sp,s8
  400728:	8fbf0044 	lw	ra,68(sp)
  40072c:	8fbe0040 	lw	s8,64(sp)
  400730:	27bd0048 	addiu	sp,sp,72
  400734:	03e00008 	jr	ra
  400738:	00000000 	nop
  40073c:	00000000 	nop


# SP and SF
#

 ----------------------------------- first
 56(00) : sp



   (16) : arg5
   (20) : arg6
   (24) : struct_one
   (28) : struct_one
   (32) : struct_one


 04(48) : ra
 00(56) : 
 ----------------------------------- main
 72(00) : sp



   (16) : arg5           (72)
   (20) : arg6           (76)
   (24) : struct_one     (80)
   (28) : struct_two     (84)
   (32) : struct_three


 04(68) : ra use 4(word) from here
 00(72) : 


# ra
# (caller update ra before jump)

 main
+------------+
| save ra    |
|            |
| update ra  |       first
| call first |  -> +------------+ 
|            |     | save ra    |
| get ra     |     |            |
| jump ra    |     | update ra  |      second
+------------+     | call secon | -> +------------+
                   |            |    | jump ra    |
                   | get ra     |    +------------+
                   | jump ra    |    
                   +------------+    


==============================================================================
*kt_dev_sys_009*	for and while asm (MIPS)

<asm-while-loop> in C
int main()
{
  int i = 0;

  while( i < 10 )
  {
    printf("w iter %d\n", i );
    ++i;
  }

  return 0;
}

#	when use -g (debug)
#
int main()
{
  400590:       27bdffd8        addiu   sp,sp,-40	     # push	:
  400594:       afbf0024        sw      ra,36(sp)	     # {copy-return-addr-into-a-stack}
  400598:       afbe0020        sw      s8,32(sp)	     # save s8(saved reg) into a stack. 
                                                        # s8 has one of s0-s7 that has values are preserved across function calls.
  40059c:       03a0f021        move    s8,sp	        # save sp to s8.
        int i = 0;
  4005a0:       afc00018        sw      zero,24(s8)     # int i = 0. save into a stack.			

        while( i < 10 )
  4005a4:       08100173        j       4005cc <main+0x3c> # { jump
  4005a8:       00000000        nop
        {
                printf("w iter %d\n", i );

{4005ac}:       3c020040        lui     v0,0x40		          # -> v0 = v0 << 16.
  4005b0:       244406a0        addiu   a0,v0,1696	          # a0 = v0 + 1696. a0-a3 used for passing args to functions.
  4005b4:       8fc50018        lw      a1,24(s8)			    # a1 = int i. 
  4005b8:       0c100124        jal     400490 <printf@plt>  # }} jump and link.
  4005bc:       00000000        nop
                ++i;

  4005c0:       8fc20018        lw      v0,24(s8)	    # v0 = int i.
  4005c4:       24420001        addiu   v0,v0,1		    # v0 = int i +1. inc i.
  4005c8:       afc20018        sw      v0,24(s8)	    # int i = v0.

{4005cc}:       8fc20018        lw      v0,24(s8)	    # -> v0 = int i 
  4005d0:       2842000a        slti    v0,v0,10	    # i < 10. 
  # slti(set on less than immediate. tests if one register is less than a constant.)
  4005d4:       1440fff5        bnez    v0,4005ac <main+0x1c>	
  # if( v0 != 0 ) then jump. bne(branch on not equal). v0 is 1(true).
  4005d8:       00000000        nop                    # }
        }

        return 0;
  4005dc:       00001021        move    v0,zero		# {copy-return-value}
}
  4005e0:       03c0e821        move    sp,s8
  4005e4:       8fbf0024        lw      ra,36(sp)
  4005e8:       8fbe0020        lw      s8,32(sp)
  4005ec:       27bd0028        addiu   sp,sp,40
  4005f0:       03e00008        jr      ra
  4005f4:       00000000        nop
  
#	when use -Os
#  
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40						# push. dec sp -40.
  400594:       3c020040        lui     v0,0x40							# v0 = v0 << 16.
  400598:       afb1001c        sw      s1,28(sp)						# save arg
  40059c:       afb00018        sw      s0,24(sp)						# save arg
  4005a0:       afbf0020        sw      ra,32(sp)						# save ra
  4005a4:       24510678        addiu   s1,v0,1656						# a1 = v0 + 1656.
  4005a8:       00008021        move    s0,zero							# s0 = 0. s0(int i) is free to use.
  4005ac:       02002821        move    a1,s0							# a1 = s0.
  																						# {
  4005b0:       0c100124        jal     400490 <printf@plt>			# call printf. as int i is 0 to start
  4005b4:       02202021        move    a0,s1							# a0 = s1
  4005b8:       26100001        addiu   s0,s0,1							# s0 = s0+1. 
  4005bc:       2402000a        li      v0,10							# v0 = 10. 
  4005c0:       1602fffb        bne     s0,v0,4005b0 <main+0x20>	# if( s0 != v0 )then jump.
                                                                  # }
  4005c4:       02002821        move    a1,s0							# a1 = s0(int i). exit while
  4005c8:       8fbf0020        lw      ra,32(sp)						# pop. recover ra.
  4005cc:       8fb1001c        lw      s1,28(sp)
  4005d0:       8fb00018        lw      s0,24(sp)
  4005d4:       00001021        move    v0,zero							# return 0.
  4005d8:       03e00008        jr      ra
  4005dc:       27bd0028        addiu   sp,sp,40


<asm-for-loop>
#include <stdio.h>

int main()
{
  int i = 0;

  for(i; i < 10; i++)
    printf("w iter %d\n", i );

  return 0;
}

# when use -Os. same as while case
#
00400590 <main>:
  400590:       27bdffd8        addiu   sp,sp,-40
  400594:       3c020040        lui     v0,0x40
  400598:       afb1001c        sw      s1,28(sp)
  40059c:       afb00018        sw      s0,24(sp)
  4005a0:       afbf0020        sw      ra,32(sp)
  4005a4:       24510678        addiu   s1,v0,1656
  4005a8:       00008021        move    s0,zero
  4005ac:       02002821        move    a1,s0
                                                             # {
  4005b0:       0c100124        jal     400490 <printf@plt>
  4005b4:       02202021        move    a0,s1
  4005b8:       26100001        addiu   s0,s0,1
  4005bc:       2402000a        li      v0,10
  4005c0:       1602fffb        bne     s0,v0,4005b0 <main+0x20>
                                                             # }
  4005c4:       02002821        move    a1,s0
  4005c8:       8fbf0020        lw      ra,32(sp)
  4005cc:       8fb1001c        lw      s1,28(sp)
  4005d0:       8fb00018        lw      s0,24(sp)
  4005d4:       00001021        move    v0,zero
  4005d8:       03e00008        jr      ra
  4005dc:       27bd0028        addiu   sp,sp,40


==============================================================================
*kt_dev_sys_010*	POR(power on reset) (MIPS)

when POR, the start address by reset vector is 0xBFC0 0000

exception vector locations.

the reset, soft reset, and NMI exceptions are always vectored to location 0xBFC0_0000.
debug exceptions are vectored to location 0xBFC0_0480 or to location 0xFF20_0200 if the
ProbEn bit is 0 or 1, respectively, itn eht EJTAG control register(ECR).


==============================================================================
*kt_dev_sys_011*	instruction and addressing (MIPS)

I-Type(immediate)

|31      26|25    21|20     16|15              0|
|    op    |   rs   |    rt   |    immediate    |

when a word(4 bytes) is loaded and stored the memory address must be a multiple of four.
this is called an {alignment-restriction}. addresses that are a multiple of four are
called {word-aligned}. this resctiction makes the hardware simpler and faster.


The MIPS instruction that loads a word into a register is the lw instruction. The store
word instruction is sw. Each must specify a register and a memory address. A MIPS
instruction is 32 bits (always). A MIPS memory address is 32 bits (always). How can a load
or store instruction specify an address that is the same size as itself?

note. kt. means that instruction and args should fit into a word(32 bits)


An instruction that refers to memory uses a base register and an offset. The base register
is a general purpose register that contains a 32-bit address. The offset is a 16-bit
signed integer contained in the instruction. The sum of the address in the base register
with the (sign-extended) offset forms the memory address. 

For example:

if you want to load a byte by using the 'lb' instruction.

lb t1, 0x180003fb

it's not working and it simply stores the hexadecimal value into the register. in this
case 0x18000000. Because addresses are always signed 16-bit displacements relative to a
register 

# LUI -- The immediate value is shifted left 16 bits and stored in the register. The lower
# 16 bits are zeroes. lui $t, imm  # $t = (imm << 16)

so you'd wite to work

lui t1, 0x1800		
lbu t1, 0x3fb(t1)

Similarly, to store t1 into address 0x8009f000, you'd write:

# SW -- Store word. The contents of $t is stored at the specified address. 	
# sw $t, offset($s). MEM[$s + offset] = $t

lui at, 0x800a
sw t1, 0xf000(at) 

# Notice that in this case, the upper part of the address has to be incremented by one,
# since the lower part is negative.  0xf000(at) is negative and equates to -0x1000. so
# 0x800a0000 - 0x1000 = 0x8009f000

If you just want to load or store into an address between 0xffff8000 and 0x7fff, you can
skip the lui and use the register which various assemblers call zr, zero or 0 as the base
address. (??)

As you may already know, to load an arbitrary 32-bit value into a register, you use lui and addiu. 
Let's say you want to load 0xfedcba98 into v0. This becomes:

lui v0, 0xfedd
addiu v0, v0, 0xba98 # Add immediate unsigned (no overflow). addiu $t, $s, imm ($t = $s + imm)

Although addiu stands for "add immediate unsigned", the operand is nevertheless sign extended.

Example 02)
sw $12 , 0xFFF8($13)    or    sw $12 , -8($13)

Both are the same.


==============================================================================
*kt_dev_sys_012*	dump_stack

This function can be amended to print any failed capabilities checks using printk, and a
call to the kernel function dump_stack() should give you a pretty good idea of what the
middleware was attempting at the time of the failure. A little guesswork is still required
though, as this will only show you the stack in kernel space, not in the middleware
itself.

only for glibc?


==============================================================================
*kt_dev_sys_013*	clock_gettime and mktime



==============================================================================
*kt_dev_sys_014*	newlines between dos and linux

Q: what is it about?

Systems based on ASCII or a compatible character set use either LF (Line feed, '\n', 0x0A, 10 in
decimal) or CR (Carriage return, '\r', 0x0D, 13 in decimal) individually, or CR followed by LF
(CR+LF, '\r\n', 0x0D0A).  These characters are based on printer commands: The line feed indicated
that one line of paper should feed out of the printer, and a carriage return indicated that the
printer carriage should return to the beginning of the current line. 

CR+LF: Microsoft Windows, DEC TOPS-10, RT-11 and most other early non-Unix and non-IBM OSes, CP/M,
MP/M, DOS (MS-DOS, PC-DOS, etc.) 

LF   : Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS,
Amiga, RISC OS, and others.

fgets() reads in at most one less than size characters from stream and stores them into the buffer
pointed to by s.  Reading stops after an EOF or a newline. If a newline is read, it is stored into
the buffer.  A '\0' is stored after the last character in the buffer. 

can check as below

[ktpark@cdilinux build_mlu]$ file platform.mk (for dos)
platform.mk: ASCII English text, with CRLF line terminators

[ktpark@cdilinux build_mlu]$ file platform.mk.kt (for unix)
platform.mk.kt: ASCII English text


# ============================================================================
#{

==============================================================================
*kt_dev_ecpp_001*	01: federation of language

C++ is:

Multiparadigm programming language. view it not as a single language but as a federation of related
sublanguages, each with its own rules and conventions.

C, object-oriendted (class), template, and STL


==============================================================================
*kt_dev_ecpp_002*	02: no to preprocessor

Prefer the compiler to the preprocessor because:

<0> type-checking

<1> better to decode compile error and to use symbolic debugger. 

#define ASPECT_RATIO 1.653

const double AspectRatio = 1.653

<2> smaller code (?) since blind substitution could result in multiple copies in your object code.

<3> class-const

class specific const and better encapsulation. see *kt_dev_cpp_017*

<4> avoid problem when use macro with an expression

#define CALL_WITH_MAX(a,b) func((a) > (b) ? (a) : (b) )

int a= 5, b = 0;

CALL_WITH_MAX(++a, b);				// a is increased twice
CALL_WITH_MAX(++a, b+10);			// a is increased once

If want to avoid function call cost, use 'inline' instead.


==============================================================================
*kt_dev_ecpp_003*	09: no virtual call in ctor or dtor 

Problem:
Assume that each time a transaction object is created, an appropriate log entry needs to be created
in a log. If it is a derived object, then need to have a log entry for that.

Solution?:

class Transaction {
  public:
    Transaction();

    virtual void logTransaction() const = 0;		// to make <type-dependent-log-entry>
    ...
};

Transaction::Transaction()
{
  ... >
    logTransaction();
}

class BuyTransaction: public Transaction {
  public:
    virtual void logTransaction() const;
    ...
};

class SellTransaction: public Transaction {
  public:
    virtual void logTransaction() const;
    ...
};

// use
{
	 BuyTransaction buy;
}

Will it have a log entry of BuyTransaction as expected? NO. Will have the base class version if
there is one. 

C++ don't allow this because when base ctor runs, only base part is created. hence base version. If
it was allowed, then derived call would access derived part which is not created or initialized.
This is undefined so not allowed. KT. Also this can be explained as this is becuase it is static
bining at compile time.

1) For the example above, some compilers issue a warning. Even if there is no warnings, there will
be a link error unless there is a definition of pure virtual function. Remember pure virtual can
have definition. 

2) Can use normal virtual function (not pure) but still get base version.


{one-solution}
Make it non-virtual, move up the implementation to log in the tree and pass up the type-dependent
info to the base class in the tree.

class Transaction {
  public:
    explicit Transaction( const std::string& logInfo );

    void logTransaction( const std::string& logInfo) const;		// <non-virtual-func>
    ...
};

Transaction::Transaction( const std::string& logInfo )
{
  ...
    logTransaction( logInfo );
}

class BuyTransaction: public Transaction {
  public:
    BuyTransaction( parameters ) 
      : Transaction( createLogString(parameters) )                // <pass-log-to-base-class>
    { ... }
    ...
  private:
      'static' std::string createLogString( parameters );         // <static-member-func>
};

See the use of func, createLogString, helper func, instead of member init list and it is more
convenient than member init. Consider this  when there are many parameters.

<why-static> {static-member-func-example} {reason-one}
Why static? By doing this, there is no danger of accidentally referring to the BuyTransaction
object's as-yet-uninitialized data members when base ctor and part runs.

Why logging call in the base class in the first place? that's becauase it's common to all type of
transactions. So move up as it's abstraction.


==============================================================================
*kt_dev_ecpp_004*	18: hard to use incorrectly 

1) Make compile error for incorrect uses (interface usage errors):

class Date {
  public:
    Date(int month, int day, int year);
    ...
};

// client use
//
Date d(30, 3, 1995);		// wrong order
Date d(3, 40, 1995);		// invalid

How to make compile errros? Use <type-system>:

struct Day {
  explicit Day(int day) : val(day) {}
  int val;
};

struct Month {
  explicit Month(int month) : val(month) {}
  int val;
};

struct Year {
  explicit Year(int year) : val(year) {}
  int val;
};

class Date {
  public:
    Date( const Month& month, const Day& day, const Year& year);
    ...
};

// client use
//
Date d(30, 3, 1995);                      // wrong type. wrong order
Date d( Day(3), Month(40), Year(1995) );  // wrong type. invalid
Date d( Month(40), Day(3), Year(1995) );  // correct type. invalid value but easy to see!


2) Make compile error for invalid values: 

Consider enum? NO since not type-safe. Safer solution is to predefine all vaild months.

class Month {
  public:
    static Month Jan() { return Month(1); }
    ...
    static Month Dec() { return Month(12); }

  private:
    explicit Month(int m); // 'prevent' creation of new values
};

Date d( Month::Mar(), Day(30), Year(1995) );

Used functions to represent months. How about {class-const} in *kt_dev_cpp_017* instead of using
function?


3) Force client to follow interface rule

Investment* createInvestment();

This means that client remember to use raii to prevent resource leaks. The better interface decision
is:

std::shated_ptr< Investment > createInvestment();

The same is {factory-func} in *kt_dev_stl_018* This force client to use smart_ptr.


==============================================================================
*kt_dev_ecpp_005*	23: prefer non-member non-friend func

EC++23. About considering encapsulation in design:

The greater something is encapsulated, then the greater our ability to change it. Roughly, when
there are more funcs to access data, it's less encapsulated. Assumes that it follows the rule in
EC++22 that member data must be private and therefore provide only funtional interfaces to access
data.

If use private member data, then only member function and friend can use it. If member function and
non-member non-friend function provides the same functionality, which is better? non-member
non-friend function since it doesn't increase the number of functions that can access the private
part of the class. Hence it's between member and non-member non-friend.

For example:

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    ...
};

<1> approach one. add more interface?

class WebBrowser
{
  public:
    ...
    void clearCache();
    void clearHistory();
    void removeCookies();
    void clearEverything();
    ...
};

<2> approach two. add non-member non-friend function?

void clearBrowser( Webbrowser& wb )
{
  wb.clearCache();
  wb.clearHistory();
  wb.removeCookies();
}

How to use the approach two? Use namespace in C++.

namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}


{partitioning-or-packaging-functionality}
The namespace can be spread across multiple sources.

<1> partitioning on convenience functions
The convenience function can't offer any functionality a WebBrowser client couldn't already get in
some other way. However, can make client to be compliation dependent on only what they uses.

// <webbrowser.h> for class WebBrowser and 'core' WebBrowser-related functionality.
namespace WebBrowserStuff {
  class WebBrowser { ... };
  void clearBrowser(WebBrowser& wb);
  ...
}

// <webbrowserbookmarks.h> for bookmark related convenience functions.
namespace WebBrowserStuff {
  ...
}

// <webbrowsercookies.h> for cookies related convenience functions.
namespace WebBrowserStuff {
  ...
}

<2> partitioning on functionality
Use the same approach but on separated functionality. Like STL, vector, list and etc are in each
header but in the same namespce. Cannot do the same with class member since a class cannot be split
into pieces.


{functional-extensibility}
When necessary, can extend functionality in the existing namespace by adding more. This is
horizental extension compared with vertical, i.e., class inheritence. 

KT. After all, it's all about encapsulation and seperation. The class is closed or tightly coupled
approach since if it changes, the client will be broken. By having non-member non-friend in the
middle, can have seperation between classes and client. This is like indirect access or interface
class approach.


==============================================================================
*kt_dev_ecpp_006*	26: postpone variable definitions

{costwise}
Avoid unused varaibles but see that there are variables which aren't completely unused so to
postpone variable definitions as long as possible until is needed and have init value. Increases
clarity and efficiency.

std::string encryptPassword( const std::string& password )
{
  using namespace std;

  string encrypted;

  if( password.length() < MinimumPasswordLength )
  {
    throw logic_error("Password is too short");
  }

  ...

  return encrypted;
}

The real meaning of 'as long as possible': postpone a variable's definition until right before you
have to use the variable, also try to postpone the definition until you have initialsation arguments
for it. Avoid cost of construction, destruction and default construction.

{what-about-loop}

# approach A                           # approach B
Widget w;
for( int i=0; i < n; i++ )             for( int i = 0; i < n; i++ )
{                                      {
  w = some value;                         Widget w(some value);
  ...                                     ...
}                                      }

1 ctor, 1 dtor, n assign.              n ctor and dtor.

Choose depending on whether ctor/dtor is expensive than assign.

<make-variable-available-only-for-some>
The approach B makes that the name w is only visible in the loop. This is good for comprehensibility
and maintainability. So approach B is recommended unless performance analysis shows approach A is
better.

By defining the variable in a condition, the pointer <dp> is not accessible outside the if. If the
cast fails, then the unbound pointer is not available for use in subsequent code where we might
forget to check whether the cast succeeded.

if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    // use the Derived object to which dp points
   
} else {  // bp points at a Base object

    // use the Base object to which bp points
}


==============================================================================
*kt_dev_ecpp_007*	28: avoid returning handles to object internals

EC++28. Here internals means everything except public interface and includes private and protected
member func. If returns handles (iterator, pointer and reference) to internals, causes three
problems: breaks encapsulatation, constness, and dangling-handles.

{compromising-encapsulation-and-constness}
Passing by ref is more efficient than passing by value and offer client a way to learn
what rectangle's points are, not to let clients modify. This is read-only. So:

class Rectangle {
  public:
    Point& upperLeft() const { return pData->ulhc; }

  private:
    std::shared_ptr< RectData > pData;
};

Is it okay? NO because client can change its value:

// use
const Rectangle rec( ... );
rec.upperLeft().setX(50);

Two problems:

1) it makes memeber data effectively public as returns reference to it from a public member function.
2) the problem of bitwise-const. See {bitwise-const} in *kt_dev_cpp_008*

The solution is that it offers read-only access:

class Rectangle {
  public: >
   const Point& upperLeft() const { return pData->ulhc; }

  private:
   std::shared_ptr< RectData > pData;
};

Similar to the example of {const-member-func} in *kt_dev_cpp_008*

To see 1) only, see following example:

using namespace std;

class Sample {
  private:
    int val;

  public:
    Sample() : val(10) {}
    int& getx() { return val;}
    void printx() { cout << val << endl; }
};

int _tmain(int argc, _TCHAR* argv[])
{
	Sample sam;
	cout << "------" << endl;
	sam.printx();
	sam.getx() = 20;
	cout << "------" << endl;
	sam.printx();

	return 0;
}

This changes private member val to 20.


{dangling-handles}

class GUIObject { ... }
const Rectangle boundingBox( const GUIObject& obj );

// use
GUIObject* pgo;
...
const Point* pUpperLeft = &( boundingBox(*pgo).upperLeft() );

This creates a temp Rectangle and returns its upper member. The problem is this temp is destroyed
when end this statement and pUpperLeft will dangle.

vector and string's [] operator returns reference but these are exceptions to this rule, but not a
general rule. Better not use [] operator.


==============================================================================
*kt_dev_ecpp_008*	31: minimize compilation dependencies

Two cases can cause complilation dependency problem:

o class interface changes. means header file changes.
o no separation between interface and implementation in class definition. means header file changes.

 [KT] The implementation separation can be achieved when use func tables which has a set of fixed
 interfaces and this is often done via registration. Such as OS abstraction or driver abstraction
 which happens when porting.
 
 But, how to handle when interface changes? For example, when replace graphic library which has
 different interfaces. Usually talk about how to design interfaces for user but if user uses it
 everywhere and replace library, need to find every place using it. If there is a single point or
 file to use interfaces then better to cope with changes? More about C. 

This item is about separating interface from implementation and this happens because C++ isn't very
good at separating interface from implementation.

// person.h
//
class Person {
	 public:
		  Preson( const Date& birthDay, const Address& addr );
		  std::string name() const;
		  ...

	 private:
		  std::string theName;
		  Date theBirthDate;
		  Address theAddress;
};

This member data is implementaion details and need class definition such as Date to compile. Hence
headers of these class are needed:

// person.cpp
//
#include < string>
#include "date.h"
#include "address.h"

This cause <cascading-compilation-dependencies>. Think if this person, date, or address class
changes then classes using one of these should be compiled.

date.h    -- persoh.h -- xxx.cpp that use person class. 
address.h --          -- xxx.cpp
                      -- ...

If change person class like adding or removing memeber data even if the interface remains the same,
will cause to compile every cpp files that includes person.h. Can use forward declaration to avoid
this? NO because cannot create an object. {forward-declaration} in *kt_dev_lang_010*	

If use foward declaration, the compiler cannot know the size of p and how big a Person object is. 

class Date;
class Address;

class Person {
	 public:
		  Preson( const Date& birthDay, const Address& addr );
		  std::string name() const;
		  ...

	 private:
		  std::string theName;
		  Date theBirthDate;
		  Address theAddress;
};

Person p(params);		// define a person object

To solve this, decouple interface from implementation and use dependencies on declaration than
definition. This move from <dependencies-on-definition> to <dependencies-on-declaration>. Two
approaches:


{pimpl-idiom} 

aka handle class. See {exception-safe} in *kt_dev_cpp_019*	

Have two classes. One is what client use and has a pointer to implementation. 
>
	 Use the fact that compiler has no problem to get size of built-in types like pointer. no
	 definition needed.


o Use built-in types such as reference and pointer.
o Need only declaration when func uses a class as pass or return by value because the definition is
needed only when call a func or define a func. {forward-declaration} in *kt_dev_lang_010*	

Date today(); void func(Date d);

No Date definition is needed. This removes dependency on unnecessary but not move the onus to
clients.


// person.h, interface class
//
class PersonImpl;											// forward-declaration
class Date;
class Address;

class Person {
	 ...
	 private:
		  std::shared_ptr< PersonImpl > pImpl;		// <set-pimpl>
};


// personimpl.h, implementation class
//

Both class must have the <same-interface>. If add or remove member data; changes implementation, no
need to compile clients.


// person.cpp, implementation class
//
#include "person.h"
#include "personimpl.h"												// for Impl class

Person::Person(...) : pImpl( new PersonImpl (...) ) {}   // <create-and-set-impl>

std::string Person::name() const                         // <forwarding>
{ return pImpl->name(); }

<summary>

(client)  (interface class)               (impl. class)
(client)		interface: no virtuals          interface
... 			set impl in ctor.               has real impl. and use other classes such as
				ptr to impl                     Date and Address in this example.

														(subclassing)

note:
o If impl class changes, need to change only cpp file of interface class but not clients.
o How about <subclassing> impl. class to have other impls? Seems okay.


<stl-case-example>

STL uses this approach: Two header files.

< iosfwd > has declaration only
< sstream > < streambuf > < fstream > < iostream > are all implementation files

note:
o Further study to look into STL?
o What is the relation between person and personimpl? implemented-in-terms-of?


{interface-class} 

Similar to JAVA's interface but C++ one can have data or func implementation. Use ABC and interface
class can have only interfaces or interface and default implementation.

class Person {                     	# class IPerson
	public:
	 virtual ~Person();					# see 'virtual'
	 virtual std::string name() const = 0; 
	 virtual std::string birthDate() const = 0; 
	 virtual std::string address() const = 0; 
	 ...
	 // factory-func *kt_dev_stl_018*
	 'static' std::shared_ptr< Person > create(
	 	const std::string& name, const Date& birthday, const Address& address);
};


std::shared_ptr< Person > Person::create(...)
{
	 return std::shared_ptr< Person > ( new RealPerson (...) );    # <create-and-set-impl>
}


// implementation
//
class RealPerson: public Person {  # public IPerson
	 private:
	 std::string theName;                            # <has-implementation-details>
	 Date theBirthDate;

	 public:
	 RealPerson(...): ... {}
	 virtual ~RealPerson() {}
	 virtual std::string name() const;
	 ... same interface
};


Then client use pointer or reference because ABC cannot create an object.

std::shared_ptr< Person > pp ( Person::create(...) );

<summary>

(client)  (interface class)   
(client)		interface: virtuals
... 			factory-function 
				ptr to impl      

			(subclassing) 
				real implementation : use other classes

o Like pimpl idiom, no interface change and can force class interface to derived class.
o Used subclassing.
o Like pimpl idiom, separated implementation. When implementation, derived class, changes, no need
to compile clients. But re-link.

IPerson::create( RealPersonX )
 |
 |-return new RealPersonX or
 |-return new RealPersonY
 |-...
 |-return new RealPersonZ


{factory-func-pattern} {creational-pattern}

The factory-function plays the role of the ctor for the derived classes that are actually created.
Hence called [virtual-constructor]

<why-factory>

This is about a method but not a class. 

Pros:
o Separation. No code to create in the client and move it into factory-func. 
o Defer decision on what to create: create in the base such as parameterized factory-func or to
defer creation to subclass, so any product class in the tree. This subclassing often used in
framework since no need to make changes in framework.

Cons:
o Client should subclass to use specific product class.


<static-vs-virtual-factory-func>

The static-factory-func has efficient code because no virtual cost and has single point to access
but hard-wired to choose classes to create. Have to change it when the choice to create changes. As
shown in *kt_dev_cpp_030* static-factory-func is in the user class in a tree.

The virtual-factory-func has bigger code but subclassing can change class to create. So useful for
framework that cannot be changed. When factory-func is on the creator tree and uses virtual func:
pure virtual or virtual which as default implementation. Let client decide which class to create
using subclassing, application specific document, to create(manufacture) and defer instantiation to
subclass which is out of framework.


(client)                 (creator class, Application)           (product class, Document)       
-----------------------  ------------------------------------   ------------------------- 
Creator.NewDoc();        // factory-func.
                         // set impl in factory func.
								 //
                         'virtual' CreateDoc() = 0;
                         'virtual' CreateDoc();

								 NewDoc()                                Open();
								 { pDoc = CreateDoc(); pDoc->Open(); }

                         (subclass)                              (subclass)
								 -------------------------------------   -------------------------
								 WordApplication, DrawApplicaion, ...    WordDoc, DrawDoc, ...
								 'virtual' CreateDoc()
								 { return new WordDoc; }
								 { return new DrawDoc; }

note: This can be used in parallel class implementation. See design pattern book for more.

<virtual-factory-func> sample-code-from-design-pattern

The previous has hard-codes for classes to create:

Maze* MazeGame::CreateMaze() {
	 Maze* aMaze = new Maze;
	 Room* r1 = new Room(1);
	 Room* r2 = new Room(2);
	 Door* theDoor = new Door(r1, r2);

	 aMaze->AddRoom(r1);
	 ...
	 return aMaze;
}

This is revised to use factory which shows how framework works. The frameworks has all logics and
user implements interfaces as flatfrom defines and creats instance.

class MazeGame {
	 public:
	 Maze* CreateMaze();

	 // factory-funcs
	 virtual Maze* MakeMaze() const { return new Maze; }
	 virtual Room* MakeRoom( int n ) const { return new Room(n); }
	 virtual Wall* MakeWall(...);
	 virtual Door* MakeDoor(...);
};

Maze* MazeGame::CreateMaze() {
	 Maze* aMaze = MakeMaze();

	 Room* r1 = MakeRoom(1); Room* r2 = MakeRoom(2);
	 Door* theDoor = MakeDoor( r1, r2 );

	 aMaze->AddRoom(r1); aMaze->AddRoom(r2);
	 ...
	 return aMaze;
};

class BombedMazeGame : public MazeGame {
	 public:
	 virtual Wall* MakeWall() const { return new BombedWall; }
	 virtual Room* MakeRoom(int n) const { return new RoomWithABomb(n); }
};

class EnchantedMazeGame : public MazeGame {
	 public:
	 virtual Wall* MakeDoor() const { return new DoorNeedingSpell; }
	 virtual Room* MakeRoom(int n) const { return new EnchantedRoom(n); }
};

BombedMazeGame bombMaze;             	// BombedMazeGame
Maze* pMaze = bombMaze.CreateMaze();	// [KT] client know what to create
pMaze->func();

When CreateMaze is called, will use redefined factory-funcs to create application specific class.
See {template-pattern} for this way to use virtual.


<non-member-factory-func> <parameterized-factory-func>

Realistic examples may support different derived class to create using additional params, file, DB
or env var. See factory-pattern in design pattern book for an example of env. use. 

// example-one

From EC++40. Use id to select different concrete class and non-member factory-func and conditional
switch in it.

std::shared_ptr< IPerson > makePerson( DatabaseID personID );

DatabaseID id(askUserForDatabaseID());
std::shared_ptr< IPerson > pp ( makePerson(id) );

pp->name();
pp->birthDate();


// example-two. From design pattern 

class Creator {
	 public:
	 virtual Product* Create( ProductId );
};

Product* Creator::Create( ProductId id )
{
	 if( id == MINE ) return new MyProduct;
	 if( id == YOURS ) return new YourProduct;

	 return 0;
};

Product* MyCreator::Create( ProductId id )
{
	 if( id == YOURS ) return new MyProduct;       # note: changed ids
	 if( id == MINE ) return new YourProduct;

	 if( id == THEIRS ) return new TheirProduct;   # extented

	 return Creator::Create(id);                   # fall back on base class for otheres.
};


{on-disk-representation-factory-func}

From MEC++25. Creating objects from reading disk and there should be type to create in disk.

class NLComponents {
	 public:
	 ...
};

class TextBook : public NLComponents {
	 public:
	 ...
};

class Graphic : public NLComponents {
	 public:
	 ...
};

class NewsLetter {
	 public:
	 ...
	 private:
	 list< NLComponents* > components;
	 static NLComponents* readComponent( istream& str );      // <static-factory-func>
};

NewsLetter::NewsLetter( istream& str )
{
	 while( str ) {
		  components.push_back( readComponent( str ) );
	 }
}


{virtual-copy-constructor}

Two things to note here:

o return type can be different in virtual funcs. See {return-type-in-overrides}

o clone simply use real copy ctor and means it follows the same whether it is deep or shallow copy.

class NLComponent {
	 public:
	 	virtual NLComponent* clone() const = 0;
		...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual TextBlock* clone() const
		{ return new TextBlock(*this); }
		...
};

class Graphic : public NLComponent {
	 public:
	 	virtual Graphic* clone() const
		{ return new Graphic(*this); }
		...
};

class NewsLetter {
	 public:
	 	NewsLetter( const NewsLetter& rhs );
		...

	 private:
	 	list< NLComponents* > components;
};

NewsLetter::NewsLetter( const NewsLetter& rhs )
{
	 for( list< NLComponent* >::const_iterator it = rhs.components.begin();
	 	it != rhs.components.end(); ++it )
	 {
		  components.push_back( (*it)->clone() );
	 }
}

Why virtual copy ctor? This copies whatever the pointer really points to, that is calls type
dependent clone. If copying list is allowed this means copying pointers, not real objects. So this
is useful to implement deep copying.

Q: Can copy list?


{virtual-acting-non-member-func}

To have different output for different object? Can use virtual? That means member func.

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& operator<<( ostream& str ) const;
		...
};

TextBlock t; Graphic g;

t << cout; g << cout;

For usual syntax, must use non-member but then cannot use virtual. See kt_dev_cpp_021 for why it
must be non-member. How to solve?

class NLComponent {
	 public:
	 virtual ostream& print( ostream& os ) const = 0;
	 ...
};

class TextBlock : public NLComponent {
	 public:
	 	virtual ostream& print( ostream& os ) const;
};

inline ostream& operator<<( ostream& os, const NLComponent& c )
{ return c.print(os); }

Used virtual mecanism on the second arg since it is reference.


{more-things-from-design-pattern}

o In C++, always use virtual. [KT] How about static func?
o Not to call factory-func which is virtual in the creator's ctor. see *kt_dev_ecpp_003* 

Create the product on demand and use <lazy-initialization>. 

class Creator {
	 public:
	 Product* GetProduct();            # accessor

	 protected:
	 virtual Product* CreateProduct(); # factory-func

	 private:
	 Product* _product;
};

Product* Creator::GetProduct() {
	 if(_product == 0) {
		  _product = CreateProduct();
	 }
	 return _product;
}

o Can use template instead of subclassing. For example,

class Creator {
	 public:
	 virtual Product* CreateProcut() = 0;
};

template <class T>
class StandardCreator : public Creator {
	 public:
	 virtual Product* CreateProduct();
};

template <class T>
Product* StandardCreator< T >::CreateProduct() {
	 return new T;
};

o Use naming convention for factory-funcs.
For MacApp framework example, class* DoMakeClass() where Class is the product class. 


==============================================================================
*kt_dev_ecpp_009*	: 32: public inheritance. is-a model

Public inheritance means is-a. 

Derived is Base. Base represent a more general concept than Derived, that Derived represent a more
specialised concept. Can use Derived where Base can be used. Anything that is true of Base is also
true of Derived.

"Base represent a more general concept than Derived, that Derived represent a more specialised
concept."

Usually general means bigger set but not in C++ which is smaller: The derived is bigger. Here
'general' means the common part, is-a. Think a model which is wrong:

Rectangle <- Square

But the score is opposite: the derived is nested in the base.

CodeComplete(p144): LSP (Liskov Substitution Principle)
All the routines defined in the base class should mean the same thing when they are used in each of
derived classes. semantic meaning. reduce complexity. 


==============================================================================
*kt_dev_ecpp_010*	34: interface and implementation inheritance

(EC++34)
When design classes, should think <three> separately.

1) Pure virtual (abstract). To have 'only' interface inherited. interface inheritence. 

2) (Simple) virtual (overridable). To have interface and 'default' implementation.

To be careful about that 'default' impl is inherited without request from the derived.  can be a
problem when the derived forgot to redefine it.

class Airplane {
	 public:
	 virtual void fly( const Airport& destination );
	 ...
};

void Airplane::fly( ... )
{
	 code for usual plane type. default.
}

class ModelA : public Airplane { ... };
class ModelB : public Airplane { ... };

class ModelC : public Airplane { ... };

Here it's okay for model A and B but not C because C is different type of plane that has different
way to fly and should have defined own fly(). If it's missed to redefine own, it will use the
default. Error. For early error detection, can use following approaches which force the derived
explicitly request implementation:


{approach-one}

class Airplane {
	 public: >
	 virtual void fly( const Airport& destination ) = 0; // make a pure
	 ...
	 protected:
	 void defaultFly( ... );
<
};

void Airplane::defaultFly( ... )
{
	 code for usual plane type. default.
}

class ModelA : public Airplane {
	 public:
	 virtual void fly( ... )  
 	 	{ defaultFly( ... ); }		// explicit
};

class ModelC : public Airplane {
	 public:
	 virtual void fly( ... )
	 { specific code for model C type }
};

If forget to redefine ModelC::fly then will get errors in compile time because cannot create ModelC
objects. it's ABC.


{approach-two}: use the fact that pure virtual can have its impl.

class Airplane {
	 public: >
	 virtual void fly( const Airport& destination ) = 0; // make a pure
	 ...
<
};

void Airplane::fly( ... )
{
	 code for usual plane type. default.
}

class ModelA : public Airplane {
	 public:
	 virtual void fly( ... )  
 	 	{ Airplance::fly( ... ); }		// explicit
};


3) Non-virtual (non-overridable). invariant over specialization. To have interface and 'mandatory'
implementation that is default implementation but not overridable. 

KT. This suggests the less use of simple virtual?


==============================================================================
*kt_dev_ecpp_011*	35: alternatives to virtual func

{template-pattern} 
From {ref-003}, it is called [template-method] and define skeleton of an algorithm in an operation,

o deferring [some] steps to subclass ( without default implementation of some steps ). must be
overridden.

o letting subclass redefine certain steps ( with default implementation ). may be overridden.
{hook-operation}

Without chaning the algorithm's structure. The template-method defines steps in terms of abstract
operations that subclass override to provide concrete behavior. Or it is to define {invariant-parts}
once and leave {variant-part} to subclass.

What is different from when common behavior among subclasses should be factored and localized in a
common class to avoid code duplication? This is also about code resuse but difference is steps, that
is template.

void Application::OpenDocument( const char* name ) {
	 if( !CanOpenDocument(name)) {
		  // cannot handle this document
		  return;
	 }

	 Document* doc = DoCreateDocument(); // {factory-func}

	 if(doc) {
		  _docs->AddDocument(doc);
		  AboutToOpenDocument(doc);
		  doc->Open();
		  doc->DoRead();
	 }
}


AbstractClass: (Don't call us, we'll call you)
 TemplateMethod
 { PrimitiveOperation1(); PrimitiveOperation2(); }

 PrimitiveOperation1(); 
 PrimitiveOperation2();

ConcreteClass:
 PrimitiveOperation1(); 
 PrimitiveOperation2();


EC++35. In the following example, different character may calculate their health in different ways.
Using virtual is obivious? This is alternatives to usual virtual design. Called as NVI(non-virtual
interface) idiom as a public non-virtual in the base call a private virtual func that can be
redefined but it's little more than window dressing as still use virtuals.

There are how and when: how is to redefine virtual funcs and when is the time to call this. This
template-method means that base controls when and derived control how.

class GameCharacter {
  public:
    int healthValue() const
    {
      // do 'before' stuff 
      int retVal = doHealthValue();
      // do 'after' stuff
    }

  private:     // [DN] See this is private and {text-query-example}
    virtual int doHealthValue() const
    {
      // default calc code
    }
};

In the base, set before and after stuff and when to call the derived part that is the derived
dependent. Before and after can be lock/unlock, logging, pre/post condition.


{name-and-related}
For a naming convention of primitive operation which should be overridden, prefix names with Do:
DoRead. Often used with {factory-func} as DoCreateDocument shown above. KT: Do prefix seems to
mean a func to be overridden.


{access-specifier}
#include < iostream>

using std::cout;
using std::endl;

class Base {
	public:
		Base()
		{ cout << "bas: this is ctor" << endl; }

		void doCalc()
		{
			cout << "bas: doCalc" << endl;
			doMorePub();
			doMorePri();
			doMorePro();
			cout << "bas: called doMore" << endl;
		}

		virtual void doMorePub()
		{
			cout << "bas: doMorePub" << endl;
		}

	private:
		virtual void doMorePri()
		{
			cout << "bas: doMorePri" << endl;
		}

	protected:
		virtual void doMorePro()
		{
			cout << "bas: doMorePro" << endl;
		}
};

class Derived : public Base {
	public:
		Derived() 
		{ cout << "der: this is ctor" << endl; }

		virtual void doMorePub()
		{
			cout << "der: doMorePub" << endl;
		}

	private:
		virtual void doMorePri()
		{
			// [error] Base::doMorePri();
			cout << "der: doMorePri" << endl;
		}

	protected:
		virtual void doMorePro()
		{
			cout << "der: doMorePro" << endl;
		}
		
};

 
int main(int argc, char** argv)
{
	Derived drv;

	drv.doCalc();

	cout << "end of main" << endl;
}

kit@kit-vb:~/work$ ./a.out 
bas: this is ctor
der: this is ctor
bas: doCalc
der: doMorePub
der: doMorePri
der: doMorePro
bas: called doMore
kit@kit-vb:~/work$ 

As {text-query-example}, the Do operation which to be overrided, should be protected or private?
Here, access-specifier do not work in derived class since virtuals get called even if these are
private in derived calss but when speified like [error], will get

usetemppattern.cpp: In member function 'virtual void Derived::doMorePri()':
usetemppattern.cpp:26:16: error: 'virtual void Base::doMorePri()' is private
usetemppattern.cpp:51:20: error: within this context

This is why it matters for hook-operation. This access-specifier is for user client and
hook-operation. This means that it is like {bitwise-const} as compiler picks up physical things.
Also can think it as indirection involved because uses vptr because: See {how-vtable-works} and
because it is in Derived class context.

vtable
[1] Derived.doCalc : Base.doCalc
[2] Drrived.doMore : Derived.doMore


{hook-operation}
The template-method can be used to extend parent class operation but not a class. 

class Window {
	 public:
	 virtual void onResize() { ... }
	 ...
};

class SpecialWindow : public Window {
	 public:
	 virtual void onResize() {
		  Window::onResize();
		  // additional to the derived
	 }
	 ...
};

But it is esay to forget to call the inherited function and can use template-method to give the
parent class a control over how subclasses extend it. {Q}

void ParentClass::Operation() {
	 // parent class behavior
	 HookOperation();
}

void ParentClass::HookOperation() { }

void DerivedClass::HookOperation() {
	 // derived class extension
}


{strategy-pattern}
Use no virtual. take the real calc func out of the class.

# 01 : use func pointer

class GameCharacter;

int defaultHealthCalc( const GameCharacter& gc );

class GameCharacter {
	 public:

	 typedef int(*HealthCalcFunc)(const GameCharacter&);

	 explicit GameCharacter( HealthCalcFunc hcf = defaultHealthCalc )
	 : healthFunc(hcf) {}

	 int healthValue() const
	 { return healthFunc(*this); }
	 ...

	 private:
	 HealthCalcFunc healthFunc;
};

Provide flexibilities than virual:

1) Each instance(object) of the same type can have different calc func. 
2) Can change the calc func at runtime.

One downside is that should weaken encapsulation when need access to non-public part of
class to calc. Like make it a friend or offer more public funcs that are private
otherwise.


# 02 : use tr1::function

class GameCharacter {
	 public:

	 typedef std::tr1::function<int(const GameCharacter&)>HealthCalcFunc;
	 ...
};

tr1::function is <generalized-pointer-to-a-function> and allow us to use any compatible
callable entities such as function object, member funcs, and funcs with different return
type. see {function-object} *kt_dev_cpp_021*


# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...

hierarchy 02:

class HealthCalcFunc {
	 public:
	 virtual int calc( const GameCharacter& gc ) const { ... }
	 ...
};

HealthCalcFunc defaultHealthCalc;

class GameCharacter {
	 public:
	 explicit GameCharacter( HealthCalcFunc* phcf = &defaultHealthCalc )
	 : pHealthCalc( phcf ) {}

	 int healthValue() const
	 { return pHealthCalc->calc(*this); }
	 ...

	 private:
	 HealthCalcFunc* pHealthCalc;
};

Can add/change calc func later because can have the drived classes in separate hierarchy.


==============================================================================
*kt_dev_ecpp_012*	: composition. has-a model 

Two types of composition(aggregation): has-a and is-implemented-in-terms-of model.

{has-a-model}

This kind of objects are in application domain.

class Person {
	 public:
	 ...
	 private: >
	 std::string name;
	 Address address;
	 PhoneNumber voiceNumber;
	 PhoneNumber faxNumber;
};


{is-implemented-in-terms-of}

Assume need to implement template class that is like set but should use less space so can we use
std::set? it is fast but has space overhead. Then can we use std::list instead? But cannot use
public inheritance as it is is-a model. So can be implemented by using it:

This kind of objects are in implementation domain.

template<class T>
class Set {
	 public:
	 bool member( ... ) const;
	 void insert( ... );
	 void remove( ... );
	 std::size_t size() const;

	 private: >
	 std::list< T > rep;
};

template<typename T>
void Set<T >::insert( ... )
{
	 if( !member(item) ) rep.push_back(item);
}


{private-inheritance}

class Student: private Person { ... };

void eat( const Person& p );

Person p; Student s;

eat(p);
eat(s);	// error which is different to the public inheritance case

So private inheritance is implementation inheritance; impelementation only but not interface. Then when
use either private inheritance or is-implemented? EC recommends is-implemented over private
inheritance.

Assume Widget class needs to keep track of how many times each member func is called and
periodically examine the information.

class Timer {
	 public:
	 explicit Timer( int tickFrequency );
	 virtual void onTick() const;
};

class Widget : public Timer { ... };

No as Wideet is not a timer. So

class Widget : private Timer {
	 private:
	 virtual void onTick() const;
	 ...
};

<OR>

Can use private nested class.

class Widget {
	 private:

	 class WidgetTimer: public Timer {
		  public:
		  virtual void onTick() const;
		  ...
	 };

	 WidgetTimer timer;
	 ...
};


Three resons why prefer other compositions over private:

1) when derive class from Widget but want the derived do not redefine onTick. Not possible private
inheritance. (KT can use final keyword as of now)

2) to minimize compilation dependency as Timer's definition must be available if use inheritance.
But if Widget use a pointer to WidgetTimer, no need to include.
 
3) eaiser to understand.

KT. Use private when need to access protected area of the base and to redefine virtual functions.
Know that other composition comes with greater design complexity.

CodeComplete(p143) PI violates encapsulation and tends to point to design errors that should be resolved.


==============================================================================
*kt_dev_ecpp_013*	22: data member must be private

EC++22. How about using public or protected member data in class?

If class interface has only member funcs then the good things are:

1) syntactically uniform access(consistency) since do not need to remember which one is function or
member data. Always use function interface.

2) fine-grained access control. read-only. write-only. etc.

3) Encapsulation. Hiding data members behind <functional-interface> can offer all kinds of
implementation flexibility as with benefits from separation between interfacea and implementation.
For example, change implementation later.

The encapsulation is inversely proportional to the amount of code that might be broken if that
something changes. 

The point is that do not use public and protected members since this means un-encapsulated and
un-changeable.


==============================================================================
*kt_dev_ecpp_014*	27: minimize casting

{type-casting-and-type-conversion}
http://www.cplusplus.com/doc/tutorial/typecasting/

<implicit-conversions>
Implicit conversions are automatically performed when a value is copied to a compatible type. For
example:

short a=2000;
int b;
b=a;

Here, the value of a is promoted from short to int without the need of any explicit operator. This
is known as a standard conversion. Standard conversions affect fundamental data types, and allow the
conversions between numerical types (short to int, int to float, double to int...), to or from bool,
and some pointer conversions.

Converting to int from some smaller integer type, or to double from float is known as promotion, and
is guaranteed to produce the exact same value in the destination type. Other conversions between
arithmetic types may not always be able to represent the same value exactly:

o If a negative integer value is converted to an unsigned type, the resulting value corresponds to
its 2's complement bitwise representation (i.e., -1 becomes the largest value representable by the
type, -2 the second largest, ...).

o The conversions from/to bool consider false equivalent to zero (for numeric types) and to null
pointer (for pointer types); true is equivalent to all other values and is converted to the
equivalent of 1.

o If the conversion is from a floating-point type to an integer type, the value is truncated; the
decimal part is removed. <Q> decimal part? If the result lies outside the range of representable
values by the type, the conversion causes undefined behavior. <Q> undefined?

o Otherwise, if the conversion is between numeric types of the same kind; integer-to-integer or
floating-to-floating, the conversion is valid, but the value is implementation-specific (and may not
be portable).

Some of these conversions may imply a loss of precision, which the compiler can signal with a
warning. This warning can be avoided with an explicit conversion.

For non-fundamental types, arrays and functions implicitly convert to pointers, and pointers in
general allow the following conversions:

o Null pointers can be converted to pointers of any type
o Pointers to any type can be converted to void pointers.
o Pointer upcast: pointers to a derived class can be converted to a pointer of an accessible and
unambiguous base class, without modifying its const or volatile qualification.
 
<implicit-conversions-with-classes>
In the world of classes, implicit conversions can be controlled by means of three member functions:

o Single-argument constructors: allow implicit conversion from a particular type to initialize an
object.  
o Assignment operator: allow implicit conversion from a particular type on assignments.  
o Type-cast operator: allow implicit conversion to a particular type.

// implicit conversion of classes:
#include <iostream>
using namespace std;

class A {};

class B {
  public:
    // conversion from A (constructor):
    B (const A& x) {}

    // conversion from A (assignment):
    B& operator= (const A& x) {return *this;}

    // conversion to A (type-cast operator)
    operator A() {return A();}
};

int main ()
{
  A foo;
  B bar = foo;    // calls constructor
  bar = foo;      // calls assignment
  foo = bar;      // calls type-cast operator
  return 0;
}

The type-cast operator uses a particular syntax: it uses the operator keyword followed by the
destination type and an empty set of parentheses. Notice that the return type is the destination
type and thus is not specified before the operator keyword.

<type-casting>
C++ is a strong-typed language. Many conversions, specially those that imply a different
interpretation of the value, require an explicit conversion, known in C++ as type-casting. There
exist two main syntaxes for generic type-casting: functional and c-like:

double x = 10.3;
int y;
y = int (x);    // functional notation
y = (int) x;    // c-like cast notation

The functionality of these generic forms of type-casting is enough for most needs with fundamental
data types. However, these operators can be applied indiscriminately on classes and pointers to
classes, which can lead to code that -while being syntactically correct- can cause runtime errors.
For example, the following code compiles without errors: 

// class type-casting
#include <iostream>
using namespace std;

class Dummy {
  double i,j;
};

class Addition {
    int x,y;

  public:
    Addition (int a, int b) { x=a; y=b; }
    int result() { return x+y;}
};

int main () {
  Dummy d;
  Addition * padd;
  padd = (Addition*) &d;
  cout << padd->result();
  return 0;
}

The program declares a pointer to Addition, but then it assigns to it a reference to an object of
another <unrelated> type using explicit type-casting:

Unrestricted explicit type-casting allows to convert any pointer into any other pointer type,
independently of the types they point to. The subsequent call to member result will
produce either a run-time error or some other unexpected results.

In order to control these types of conversions between classes, we have four specific casting
operators: dynamic_cast, reinterpret_cast, static_cast and const_cast. Their format is to follow the
new type enclosed between angle-brackets (<>) and immediately after, the expression to be converted
between parentheses.

dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)

The traditional type-casting equivalents to these expressions would be:

(new_type) expression
new_type (expression)

but each one with its own special characteristics:

<dynamic_cast> 
dynamic_cast can only be used with <pointers and references> to classes (or with void*). Its purpose
is to ensure that the result of the type conversion points to a valid complete object of the
destination pointer type.

This naturally includes pointer <upcast> (converting from pointer-to-derived to pointer-to-base), in
the same way as allowed as an implicit conversion. DONE BY COMPILER.

But dynamic_cast can also <downcast> (convert from pointer-to-base to pointer-to-derived)
polymorphic classes (those with virtual members) if-and only if-the pointed object is a valid
<complete> object of the target type. For example:

// dynamic_cast
#include <iostream>
#include <exception>
using namespace std;

class Base { virtual void dummy() {} };
class Derived: public Base { int a; };

int main () {
  try {
    Base * pba = new Derived;
    Base * pbb = new Base;
    Derived * pd;

    pd = dynamic_cast<Derived*>(pba);
    if (pd==0) cout << "Null pointer on first type-cast.\n";

    pd = dynamic_cast<Derived*>(pbb);
    if (pd==0) cout << "Null pointer on second type-cast.\n";

  } catch (exception& e) {cout << "Exception: " << e.what();}
  return 0;
}

The result: Null pointer on second type-cast.

Compatibility note: This type of dynamic_cast requires Run-Time Type Information (RTTI) to keep
track of dynamic types. Some compilers support this feature as an option which is disabled by
default. This needs to be enabled for runtime type checking using dynamic_cast to work properly with
these types.

The code above tries to perform two dynamic casts from pointer objects of type Base* (pba and pbb)
to a pointer object of type Derived*, but only the first one is successful. Notice their
respective initializations:

Even though both are pointers of type Base*, pba actually points to an object of type Derived, while
pbb points to an object of type Base. Therefore, when their respective type-casts are performed
using dynamic_cast, pba is pointing to a full object of class Derived, whereas pbb is pointing to an
object of class Base, which is an incomplete object of class Derived.

<when-pointer>
When dynamic_cast cannot cast a pointer because it is not a complete object of the required class
-as in the second conversion in the previous example- it <returns> a null pointer to indicate the
failure. 

<when-reference>
If dynamic_cast is used to convert to a reference type and the conversion is not possible, an
exception of type bad_cast is thrown instead.

dynamic_cast can also perform the other implicit casts allowed on pointers: casting null pointers
between pointers types (even between unrelated classes), and casting any pointer of any type to a
void* pointer.

<static_cast>
static_cast can perform conversions between pointers to <related> classes, not only upcasts but also
downcasts. <NO CHECKS> are performed during runtime to guarantee that the object being converted is in
fact a full object of the destination type. Therefore, it is up to the programmer to ensure that the
conversion is safe. On the other side, it does not incur the overhead of the type-safety checks of
dynamic_cast.

class Base {};
class Derived: public Base {};
Base * a = new Base;
Derived * b = static_cast<Derived*>(a);

This would be valid code, although b would point to an incomplete object of the class and could lead
to runtime errors if dereferenced.

static_cast is also able to perform all conversions allowed implicitly; not only those with pointers
to classes, and is also able to perform the opposite of these. It can:

o Convert from void* to any pointer type. In this case, it guarantees that if the void* value was
obtained by converting from that same pointer type, the resulting pointer value is the same.

o Convert integers, floating-point values and enum types to enum types.

Additionally, static_cast can also perform the following:

o Explicitly call a single-argument constructor or a conversion operator.
o Convert to rvalue references.
o Convert enum class values into integers or floating-point values.
o Convert any type to void, evaluating and discarding the value.

<reinterpret_cast>
reinterpret_cast converts any pointer type to any other pointer type, even of <unrelated> classes.
The operation result is a simple binary copy of the value from one pointer to the other. All pointer
conversions are allowed: neither the content pointed nor the pointer type itself is checked.

It can also cast pointers to or from integer types. The format in which this integer value
represents a pointer is platform-specific. The only guarantee is that a pointer cast to an integer
type large enough to fully contain it (such as intptr_t), is guaranteed to be able to be cast back
to a valid pointer.

The conversions that can be performed by reinterpret_cast but not by static_cast are low-level
operations based on reinterpreting the binary representations of the types, which on most cases
results in code which is system-specific, and thus non-portable. For example:

class A { /* ... */ };
class B { /* ... */ };
A * a = new A;
B * b = reinterpret_cast<B*>(a);

This code compiles, although it does not make much sense, since now b points to an object of a
totally unrelated and likely incompatible class. Dereferencing b is unsafe.

The other example is that it peforms a low-level reinterpretation of the bit pattern of its
operands.

int *p;
char *pc = reinterpret_cast<char*>(ip);

<const_cast>
This type of casting manipulates the constness of the object pointed by a pointer, either to be set
or to be removed. For example, in order to pass a const pointer to a function that expects a
non-const argument:

// const_cast
#include <iostream>
using namespace std;

void print (char * str)
{
  cout << str << '\n';
}

int main () {
  const char * c = "sample text";
  print ( const_cast<char *> (c) );
  return 0;
}

The example above is guaranteed to work because function print does not write to the pointed object.
Note though, that removing the constness of a pointed object to actually write to it causes
undefined behavior.

This is not just about const away and see {const-non-const-version} to add const.


{named-cast}
From MEC++02. These casts are called named cast and these provides:

o Easier-to-recognise style in code both for humans and for tools.

o The more narrowly specified purpose and precision of meaning. Better for a comipler to diagnose
usuage errors.

{why-careful-about-cast}
<function-style-cast>

doSomething(Widget(15);
doSomething(static_cast<Widget>(15));

The both do exactly the same although doesn't feel like a cast.

<do-not-assume-how-things-are-laid-out>
C++ can have an object that might have more than one address; that is when pointed by a Base*
pointer and when pointed by Derived*. This cannot happen in C and other lanauages.

Derived d;
Base *pb = &d;

Sometimes, a base class pointer and derived class pointer values will not be the same. When that's
the case, an offset is applied at runtime to the Derived* pointer to get the correct Base* pointer
value. DO not use "I know how things are laid out" casts.

<cast-means-more-code>
The cast do nothing but tell compilers to treat one type as another? Mistaken since type conversion
often lead to additional code that is executed at runtime. 

int x, y;
...
double d = static_cast<double>(x)/y;

Use division but use floating point division.

<cast-create-a-temp>
Assume that a virtual function in derived class call their base class counterparts first.

class Window 
{
  virtual void onResize() {...}
};

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      static_cast<Window>(*this).onResize();
      ...
    }
    ...
};

It does call onResize but on the temp object. WHY? The solution is:

class SpecialWindow : public Window 
{
  public:
    virtual void onResize()
    {
      Window.onResize();
      ...
    }
    ...
};

<cast-is-expensive>
The dymamic cast is expensive and slow since often is implemented using string comparison in the
hierarchy. The compier supports up-cast that is implicit derived-to-base conversion so a base
pointer can point either base object and derived object. How to know which? The need for dynamic
cast arises when want to use derived class ops on what you believe to be a derived class objects via
base pointer or reference. This is down-cast. 

class Window { ... };
class SpecialWindow: public Window {
  public:
    void blink();
};

typedef std::vector< std::shared_ptr<Window>> VPW;
VPW winPtrs;

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow *psw = dynamic_cast<SpecialWindow*> (iter->get()))
    psw->blink();
}

Here used dymamic_cast to meet the condition which only derived class supports blink(). To avoid
this dymamic_cast, two approaches:


<solution-one>
typedef std::vector< std::shared_ptr<SpecialWindow>> VPW;

But, do not support all possible window derivatives.

<solution-two>
Use virtual mechanism. 

class Window {
  public:
    virtual void blink() {}     
    # default impl is no-op. See *kt_dev_ecpp_010* for why it can be a bad idea
};

class SpecialWindow : public Window {
  public:
    virtual void blink() { ... }
};

<other-things-to-remember>
Avoid cascading dynamic cast and try to hide cast inside a function.

for( VPW::iterator iter = winPtrs.begin(); iter != winPtrs.end(); ++iter )
{
  if( SpecialWindow1 *psw = dynamic_cast<SpecialWindow1*> (iter->get()))
    psw->blink();
  else if( SpecialWindow2 *psw = dynamic_cast<SpecialWindow2*> (iter->get()))
    psw->blink();
  ...
}


==============================================================================
*kt_dev_ecpp_015*	30: ins and outs of inlining 

Minimize the use of inline and this provides:

1) debugging
2) binary upgradability ( think when changes ininline func. all clients should be recompiled. )

Do not inline ctor and dtor. why?

If an exception is thrown druing ctor, any parts of the object that have already been fully
constructed are destroyed. C++ spec says but do not say how. It is down to compiler implementation.
So some code written and inserted into during compilation. These can be big enough not to use
inline. So do not use inline for ctor and dtor.

class Derived: public Base {
	 public:
	 Derived() {}       # is empty - or is it?
	 ...
};


# ============================================================================
#{

==============================================================================
*kt_dev_mecpp_001* 16: 80-20 rule and profiler

Think about characteristics of your app such as IO-bound or CPU-bound. If a profiler tells you about
only the number of statments and func calls, then these can give you some insight but not enough.
The important thing is the time to wait. The input to profiler should represent 20%, called
<representative>, and use as many data set as possible. 


==============================================================================
*kt_dev_mecpp_002* 17: lazy evaluation

When you employ lazy evaluation, you write your classes in such a way that they defer computations
until the results of those computations are required. If the results are never required, the
computations are never performed.

Nevertheless, it's not always a good idea.  Lazy evaluation is only useful when there's a reasonable
chance your software will be asked to perform computations that can be avoided.

Yet C++ is particularly suitable as a vehicle for user-implemented lazy evaluation, because its
support for <encapsulation> makes it possible to add lazy evaluation to a class without clients of
that class knowing it's been done. 

That means it's possible to implement a class using a straightforward eager evaluation strategy, but
then, if your profiling investigations (see Item 16) show that class's implementation is a
performance bottleneck, you can replace its implementation with one based on lazy evaluation.


Four examples and one in *kt_dev_ecpp_006*	

{reference-counting}

class String { ... };

String s1 = "Hello";
String s2 = s1;

Such a copy constructor would incur a relatively large expense, because it would have to make a copy
of s1's value to give to s2, and that would typically entail allocating heap memory via the new
operator and calling strcpy to copy the data in s1 into the memory allocated by s2. This is eager
evaluation.

But s2 hasn't been used yet.

The lazy approach is a lot less work. Instead of giving s2 a copy of s1's value, we have s2 share
s1's value. Need some book-keeping and is transparent to clients: do not know difference.

Because they only read values, not write them. 

cout << s1;            // read s1's value
cout << s1 + s2;       // read s1's and s2's values

In fact, the only time the sharing of values makes a difference is when one or the other string is
modified;

s2.convertToUpperCase();

Inside convertToUpperCase, we can be lazy no longer: we have to make a copy of s2's (shared) value
for s2's private use.


{distinguish-read-and-write}

By using lazy evaluation and proxy classes as described in Item 30, however, we can defer the
decision on whether to take read actions or write actions until we can determine which is correct.


{lazy-fetching}

Imagine large objects containing many constituent fields which can be expensive to get from
database, even worse remote database. To restore a LargeObject is quite expensive.

class LargeObject {                   // large persistent objects
public:
	 LargeObject(ObjectID id);         // restore object from disk
	 const string& field1() const;     // value of field 1
	 int field2() const;               // value of field 2
	 double field3() const;            // ...
	 const string& field4() const;
	 const string& field5() const;
...
};

If need few fields like below,

void restoreAndProcessObject(ObjectID id)
{
	LargeObject object(id);

	if (object.field2() == 0) 
	{
	 	cout << "Object " << id << ": null field2.\n";
	}
}

Data is retrieved from the database only when that particular data is needed inside the object.
Here's one way to implement this kind of <demand-paged-object-initialization>

class LargeObject {
public:
	 LargeObject(ObjectID id);
	 const string& field1() const;
	 int field2() const;
	 double field3() const;
	 const string& field4() const;
	 ...
	 private:
	 ObjectID oid;
	 mutable string *field1Value;  // see below for a
	 mutable int *field2Value;     // discussion of "mutable"
	 mutable double *field3Value;
	 mutable string *field4Value;
	 ...
};

LargeObject::LargeObject(ObjectID id)
: oid(id), field1Value(0), field2Value(0), field3Value(0), ...
{}

const string& LargeObject::field1() const
{
	 if (field1Value == 0) {
		  read the data for field 1 from the database and make
		  field1Value point to it;
	 }
	 return *field1Value;
}

Null pointers signify fields that have not yet been read from the database. Each LargeObject member
function must check the state of a field's pointer before accessing the data it points to.


The problem that null pointers may need to be initialized to point to real data from inside any
member function. So need mutable keyword. <mutable-example>

NOTE: can use smart-pointer in item28

Refer to <lazy-initialisation>.



{lazy-expression-evaluation}

For numerical application.

template<class T>
class Matrix { ... }; // for homogeneous matrices

Matrix< int> m1(1000, 1000); // a 1000 by 1000 matrix
Matrix< int> m2(1000, 1000); // ditto
...

Matrix< int> m3 = m1 + m2; // add m1 and m2

Lazy evaluation strategy: Instead, it sets up a data structure inside m3 that indicates that m3's
value is the sum of m1 and m2. Such a data structure might consist of nothing more than a pointer to
each of m1 and m2, plus an enum indicating that the operation on them is addition.

Matrix< int> m4(1000, 1000);
... // give m4 some values
m3 = m4 * m1;

We can forget all about m3 being the sum of m1 and m2 (and thereby save the cost of the
computation),

A more common scenario is that we need only part of a computation. For example, suppose we use m3 as
follows after initializing it to the sum of m1 and m2:

cout << m3[4]; // print the 4th row of m3

Clearly we can be completely lazy no longer. But there's no reason we have to compute any more than
the fourth row of m3; the remainder of m3 can remain uncomputed until it's actually needed.

To be fair, laziness sometimes fails to pay off.

m3 = m1 + m2;  // remember that m3 is the sum of m1 and m2
m1 = m4;       // now m3 is the sum of m2 and the OLD value of m1!


Because of the need to store dependencies between values; to maintain data structures that can store
values, dependencies, or a combination of the two; and to overload operators like assignment,
copying, and addition, lazy evaluation in a numerical domain is a lot of work. 

KT. Need to understand expression like a compiler and need to see if it pays off.


==============================================================================
*kt_dev_mecpp_003* 18: over-eager evaluation

The idea behind over-eager evaluation is that if you expect a computation to be requested
frequently, you can lower the average cost per request by designing your data structures to handle
the requests especially efficiently.

<caching> and <prefetching> are examples. 

{space-and-time-trade-off}

that's that greater speed can often be purchased at a cost of increased memory usage.


{lazy-or-eager}

Lazy and eager are not contradictory to each other.

Lazy evaluation is a technique for improving the efficiency of programs when you must support
operations whose results are not always needed. Over-eager evaluation is a technique for improving
the efficiency of programs when you must support operations whose results are almost always needed
or whose results are often needed more than once.

both can yield significant performance improvements in programs whose behavioral characteristics
justify the extra programming effort.


==============================================================================
*kt_dev_mecpp_004* 24: virtual cost

{vtable-internal}

Every class which has virtual func has [vtable] which is a table of func ptr. So vtable for a class
and vptr for a instance. If one is overridden in derived, derived's vtable gets updated to point to
derived version.

Class1 (base)  <- Class2 (derived)

vtable            vtable
[1] -> C1::f2     [1] -> C2::f2  [virtual]
[2] -> C1::f1     [2] -> C1::f1  [non-virtual]


{first-cost}

Size cost of vtable per class and the number of entry as many as the number of virtual funcs.

{second-cost}

Size cost of vptr which links between objects which are of the same class and 'single' vtable.

| ------ |
| object |
| ------ |
| vptr   |	-> vtable
| ------ |

{third-cost}

Virtual func must not be inline because inline is done at compile time but virtual is dynamic. See
*kt_dev_ecpp_015* for more.


{how-vtable-works}

makeCall(C1* pC1)
{
	 pC1->f1();
}

Which one? C1::f1() or C2::f1()? pC1 can be really either C1, base or C2, derived.

<0> KT. some code to get dynamic type by compiler? dynamic-binding.
<1> get vptr of this object
<2> get vtable via vptr
<3> call a func from vtable entry

When the index of a func is i, effecitve code is:

pC1->f1(); -> (*pC1->vptr[i])(pC1);       // (pC1) becomes this pointer


{performance-cost}

Therefore there is a little performance impact due to virtual func calls but in size. In
inheritance, vtable mechanism gets more complicated. lots of vptrs for objects, vtables for classes.
There is a special vtable for base classes. Hence more cost.


{RTTI-and-vtable}

RTTI can discover info about object and class at run-time. How? That information is stored in an
object of type type_info, and you can access the type_info object for a class by using the typeid
operator. There is a single copy for a class. Typical implementation is:

vtable       
[0] -> type_info
[1] -> C1::f2  
[2] -> C1::f1 

{Q} does it mean each object has a type_infor and vptr as well.


==============================================================================
*kt_dev_mecpp_005* 29: reference-counting

See {own-reference-counting} for simple example. This chapter is about how to implement sharing
underlying object like stl string class.

Two motivations:

o To simplify the bookkeeping 'who is allowed to delete what'. simple form of garbage collection.
smart pointer is an example. This is what most uses.

o To share underlying objects. efficiency since use same memory and runs fast on assumption that
object will share values.


{summary}

This is optimization technique. When useful because reference-counting costs more moeny, code,
complex and work.

o For cases when objects are big and there are many sharings. More memory to save.
o For cases when there are many copy and assign between objects. More time to save.

Need profiling. However, there is a case which cannot use this technique: data structures using
self-reference which causes isolated collection of objects and reference count never drops to zero.
Therfore, industrial garbage collectors use special technique to find these.


{what-problem-to-solve}

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		char* data;
};

// handles self-assign but not exception safe
String& String::operator=( const String& rhs )
{
	 if( this == &rhs ) return *this;

	 delete[] data;
	 data = new char[ strlen(rhs.dat) +1 ];
	 strcpy( data, rhs.data );
	 return *this;
}

Use:

Sring a, b, c, d;
a = b = c = d = "Hello";

This means:

a -> "Hello"
b -> "Hello"
c -> "Hello"
d -> "Hello"

How can we make those share one copy of Hello?


{approach-one}

Have a reference count out of object. Why out of object? Because count per value but not per object.

a -> 4 -> "Hello"
b 
c
d 

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1) # <default-1>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

String::StringValue::~StringValue()
{
	 delete [] data;
}

Why private nested class? Because to make only String has a full access of it.


{{ctor-one}}

String::String( const char* initValue ) : value( new StringValue( initValue )) {}

Use:

String s("Hello");

s -> 1 -> "Hello"

But cannot avoid duplication:

String s1("Hello");
String s2("Hello");

s1 -> 1 -> "Hello"
s2 -> 1 -> "Hello"

Solution is to create new one only when it is unique string and leave it for further study.


{{ctor-two}}

// String S1(S2);
//
String::String( const String& rhs ) : value( rhs.value )
{
	 ++value->refCount;
}

String::~String()
{
	 if( --value->refCount == 0 ) delete value;
}

// S1 = S2; reference count of S1 is decresed by one and S2 is increased by one
//
String& String::operator=( const String& rhs )
{
	 if( value == rhs.value ) return *this;

	 if( --value->refCount == 0 ) delete value;

	 value = rhs.value;
	 ++value->refCount;

	 return *this;
}


See efficiency here since there is no alloc, free, and copy.


{{copy-on-write}}

class String {
	 const char& operator[] (int index) const;
	 char& operator[] (int index);
	 ...
};

const version is read-only so that is okay. If want to separate read and write for non-const, that
is to create new object only when writing. How?

cout << s[3];     // read 
s[5] = 'x';       // write

Not possible to separate. This separation could be done using proxy class, MEC++ 30, so now assume
all non-const as write.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}

	return value->data[index];
}

This if-block works only when there is sharing before and create new one only when writing happens.
So this is copy-on-write and the example of {lazy-evaluation}


{{sharable}}

However, there are cases not covered:

String s1 = "Hello";
char* p = &s1[1];

String s2 = s1;
*p = 'x';                // change s1 and s2 as well


s1 -> 2 -> "Hello"
s2 -> 

note: how about stl string class? possible?


The problem is to change underlying object not through String interface. See *kt_dev_ecpp_007* for
returning handles to internal objects.

How to solve?

o Ignore this problem
o Hava a shareable flag in which to create new object when tries to change from outside. This is
waht stl string uses. This is ON by default, operator[] turn it OFF, and cannot change it once it is
OFF. Kind of dirty flag.

class String {
	 public:
	 	String& operator=( const String& rhs );
		...
	private:
		struct StringValue {
			 >
			 bool sharable;
<
			 size_t refCount;
			 char* data;
			 StringValue( const char* initValue );
			 ~StringValue();
		};

		StringValue* value;
};

String::StringValue::StringValue( const char* initValue ) : refCount(1), sharable(true) # <default>
{
	 data = new char[ strlen(initValue) +1 ];
	 strcpy( data, initValue );
}

There should be a check in member funcs.

String::String( const String& rhs )
{ >
	 if( rhs.value->sharable ) {
<		  value = rhs.value;
		  ++value->refCount;
	 }
	 else {
		  value = new StringValue( rhs.value->data );
	 }
}

Assume that returning from this call means someone outside will have a reference to internal so make
it non-sharable always.

char* String::operator[] (int index)
{
	if( value->refCount > 1 ) {
		  --value->refCount;
		  value = new StringValue( value->data );
	}
>
	value->sharable = false;
<
	return value->data[index];
}

For example:

String s1 = s2 = s3 = "Hello";

s1 -> 3 -> "Hello"
s2 -> 
s3 ->

s3[3] = 'x';

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"

String s4(s3);

s1 -> 2 -> "Hello"
s2 -> 
s3 -> 1 -> "Hello"
s4 -> 1 -> "Hello"


{{make-base-class-for-reference-counting}}

To make this reference counting available to any other class, so make it base class. note there is
no data in this class.

class RCObject {
	 public:
	 	RCObject();
		RCObject( const RCObject& rhs );
		virtual ~RCObject() = 0;

		RCObject& operator= ( const RCObject& rhs );

		... public interface
		addReference();

	private:
		size_t refCount;
		bool sharable;
};


The pure virtual means it must be used as a base class.

See ctor and copy ctor in setting refCount as 0 because it simplfies thing for the client to set
refCount to 1. copy ctor always set refCount to 0 because creating a new value and new value are
always unshared and referenced only by their creator.

RCObject::RCObject(): refCount(0), sharable(true) {}
RCObject::RCObject(const RCObject&): refCount(0), sharable(true) {}

RCObject::~RCObject() {}     # see {pure-virtual-dtor}

Copy assign do nothing and will not be used in reality because it is a base class for a shared value
object(StringValue) which are not assigned to one another. Only String do. {{why-need}} It said it
is for future use but seems not useful to consider since do nothing about refCount.

RCObject& RCObject::operator=( const RCObject& )
{ return *this;}

note: Really need copy ctor and copy assign?

<delete-this> is safe only if *this is a heap object.

void RCObject::removeReference()
{
	 if(--refCount == 0 ) delete this;   # <delete-this>
}

void RCObject::addReference() { ++refCount; }


class String {
	 private:
	 	struct StringValue : public RCObject {    # <public-inheritance>
			 char* data;                           # <data>
			 StringValue( const char* initValue );
			 ~StringValue();
		};
		...
};

String::StringValue::StringValue(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}

String::StringValue::~StringValue()
{
	 delete [] data;
}


          RCObject: has reference-counting feature
			 |
String -> StringValue -> data

StringValue is almost the same but now StringValue do not manipulate refCount and RCObject has. But
String should call explicitly interfaces to manage refCount. It is clumsy because String must call
these to manage reference counting. can we make it done automatically? move it out of user class?

If can detect access to StringValue through pointer, it could. This is objcet which acts like a
pointer such as smart pointer and which support member selection(->) and dereferencing(*). 


This template gives smart pointer objects control over what happens during their construction,
assignment, and destruction. When such <events> occur, this object can automatically perform the
appropriate manipulations of the refCount field in the objects to which they point.


template<class T>
class RCPtr {
public:
	RCPtr(T* realPtr = 0);
	RCPtr(const RCPtr& rhs);
	~RCPtr();
	RCPtr& operator=(const RCPtr& rhs);
	T* operator->() const; // see Item 28
	T& operator*() const;  // see Item 28
private:
	T *pointee;  // dumb pointer this object is emulating
	void init(); // common initialization code
}; 

template<class T>
RCPtr< T>::RCPtr(T* realPtr): pointee(realPtr)
{
	init();
}

template<class T>
RCPtr< T>::RCPtr(const RCPtr& rhs): pointee(rhs.pointee)
{
	init();
}

template<class T>
void RCPtr< T>::init()
{
	// if the dumb pointer is null, so is the smart one
	if (pointee == 0) { 
		return;         
	}
	// if the value is not shareable, copy it
	if (pointee->isShareable() == false) { 
		pointee = new T(*pointee); 
	} 
	// note that there is now a new reference to the value
	pointee->addReference(); 
} 

The problem is when T is StringValue and the following happens:

pointee = new T(*pointee);

There is no copy ctor of StringValue and syn version will be used. So memberwise copy but not a deep
copy. Therefore, needs String::StringValue::StringValue( const StringValue& rhs ) 


{{putting-it-all-together}}

Sting is reference counted string class.

                        RCObject
			               |
String               -> StringValue -> data
+RCPtr
+nested StringValue


/*
** RCObject : base class for reference counted objects
*/
class RCObject { 
public:
	 RCObject();
	 RCObject(const RCObject& rhs);
	 RCObject& operator=(const RCObject& rhs);
	 virtual ~RCObject() = 0;
	 void addReference();
	 void removeReference();
	 void markUnshareable();
	 bool isShareable() const;
	 bool isShared() const;
private:
	 size_t refCount;
	 bool shareable;
};

RCObject::RCObject() : refCount(0), shareable(true) {}
RCObject::RCObject(const RCObject&) : refCount(0), shareable(true) {}
RCObject& RCObject::operator=(const RCObject&) { return *this; }
RCObject::~RCObject() {}
void RCObject::addReference() { ++refCount; }

void RCObject::removeReference()
{ if (--refCount == 0) delete this; }

void RCObject::markUnshareable()
{ shareable = false; }
bool RCObject::isShareable() const
{ return shareable; }
bool RCObject::isShared() const
{ return refCount > 1; }


/*
 * RCPtr
 */
template<class T> 
class RCPtr { 
public: 
	 RCPtr(T* realPtr = 0);
	 RCPtr(const RCPtr& rhs);
	 ~RCPtr();
	 RCPtr& operator=(const RCPtr& rhs);
	 T* operator->() const;
	 T& operator*() const;
private:
	 T *pointee;
	 void init();
};

template<class T>
void RCPtr<T>::init()
{
	// if the dump pointer is null, so is the smart one
	if (pointee == 0) return;

	// if is not sharable, create new one
	if (pointee->isShareable() == false) {
		pointee = new T(*pointee);
	}
	
	// new reference
	pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr(T* realPtr) : pointee(realPtr)
{ init(); }

template<class T>
RCPtr<T>::RCPtr(const RCPtr& rhs) : pointee(rhs.pointee)
{ init(); }

template<class T>
RCPtr<T>::~RCPtr()
{ if (pointee) pointee->removeReference(); }    # <delete-this-in-removeReference>

template<class T>
RCPtr<T>& RCPtr<T>::operator=(const RCPtr& rhs)
{
	 // skip when the value does not change
	 if (pointee != rhs.pointee) {

		  T *oldPointee = pointee;
		  pointee = rhs.pointee;

		  // if possible share it, else make own copy
		  init();

		  // decrease reference
		  if (oldPointee) oldPointee->removeReference();
	 }

	 return *this;
}

template<class T>
T* RCPtr<T>::operator->() const { return pointee; }

template<class T>
T& RCPtr<T>::operator*() const { return *pointee; }


/*
 * String : class to be used by users
 */
class String { 
public: 
	 String(const char *value = "");
	 const char& operator[](int index) const;
	 char& operator[](int index);

private:
	 // class representing string values
	 struct StringValue: public RCObject {
		  char *data;
		  StringValue(const char *initValue);
		  StringValue(const StringValue& rhs);
		  void init(const char *initValue);
		  ~StringValue();
	};

	RCPtr<StringValue> value;
};


void String::StringValue::init(const char *initValue)
{
	 data = new char[strlen(initValue) + 1];
	 strcpy(data, initValue);
}
String::StringValue::StringValue(const char *initValue)
{ init(initValue); }
String::StringValue::StringValue(const StringValue& rhs)
{ init(rhs.data); }
String::StringValue::~StringValue()
{ delete [] data; }


String::String(const char *initValue)
: value( new StringValue(initValue) ) {}        # <set-rcptr>

const char& String::operator[](int index) const
{ return value->data[index]; }

char& String::operator[](int index)
{
	if (value->isShared()) {
		value = new StringValue(value->data);
	}
	value->markUnshareable();
	return value->data[index];
}

<assumption>

RCPtr< T> has:

o deep-copying copy constructor
o T inherit from RCObject, or at least that T provide all the functionality that RCObject does. T
must support the RCObject interface and it menas RCPtr and RCObject is tightly coupled.


<note-one> <difference-in-interface-of-sting>
Now there is no need to have String copy ctor, assign, and dtor because syn version doing memberwise
will call matching one of RCPtr which doing work of managing refCount. That is smart.

note: This is an example of using syn version compiler made.

Our original goal was to move the unreusable reference-counting code out of our hand-written String
class and into context-independent classes where it would be available for use with any class. Now
we've done it (in the form of the RCObject and RCPtr classes),

note: Also there is nearly no changes to String interface. encapsulation.


{{add-reference-counting-to-existing-classes}} {wrapper}

How to add this reference-counting feature, RCObject, to a class which is in libary and do not
have source? Here Widget is library class:

            RCObject
			    |
RCWidget -> Widget
+RCPtr

>
 Use that most problems in Computer Science can be solved with an additional level of indirection.
 See how to forward and how to get around the problem.
<

                  RCObject
			          |
RCWidget       -> CounterHolder    -> Widget
+RCIPtr
  (counter)->      (pointee)->

Here Widget or CounterHolder is <reference-counted-object>


template<class T>
class RCIPtr {
	 public:
		  RCIPtr(T* realPtr = 0);
		  ...
		  RCObject& getRCObject() // give clients access to
		  { return *counter; } // isShared, etc.

	 private:
		  struct CountHolder: public RCObject {
				~CountHolder() { delete pointee; }
				T *pointee;
		  };

		  CountHolder *counter;
		  void init();
};

template<class T>
void RCIPtr<T>::init()
{
	 if (counter->isShareable() == false) {
		  T *oldValue = counter->pointee;
		  counter = new CountHolder;
		  counter->pointee = oldValue ? new T(*oldValue) : 0;
	 }
	 counter->addReference();
}

template<class T>
RCIPtr<T>::RCIPtr(T* realPtr) : counter( 'new' CountHolder)
{
	 counter->pointee = realPtr;
	 init();
}

class RCWidget {
	 public:
		  # <see-how-to-pass-widget> 
		  RCWidget(int size): value( 'new' Widget(size)) {} 

        # <forwarding> [see-how-to-forward]
		  void doThis()
		  {
				if (value.getRCObject().isShared()) { 
					 value = new Widget(*value); 
				}
				value->doThis();
		  }

		  int showThat() const { return value->showThat(); }

	 private:
		  RCIPtr<Widget> value;
};


==============================================================================
*kt_dev_mecpp_006* 28: log entry

Class template for making log entries whenever a T object is modified; see below for details

template<class T>
class LogEntry {
public:
	 LogEntry(const T& objectToBeModified);
	 ~LogEntry();
};

void editTuple(DBPtr< Tuple>& pt)
{
	 LogEntry< Tuple> entry(*pt); // make log entry for this operation

	 do {
	 	pt->displayEditDialog();
	 } while (pt->isValid() == false);
}


The LogEntry's constructor begins the log entry and its destructor ends the log entry. Two pros:

o handles exception case
o easier to create a single LogEntry object than to add separate calls to start and stop an entry 


==============================================================================
*kt_dev_mecpp_007* 34: combine C and C++

There are things to know when use both together in a program.

{name-mangling}
This is the process which C++ compiler give each function a unique name because supports
overloading. There is a directive to tell compiler not to mangle func name. This is called linkage
directive.


{extern-keyword}
The GCC compiles files based on extension. When compiles cpp files meaning cpp mane mangling you can
make sure that functions are c functions:

extern "C" void drawLine(int x1, int y1, int x2, int y2);

extern "C" {
	 ...
}

extern "C" {
	 #include <string.h>
}

If you want to build a function as a c function, then can do: 

extern "C" double calc( double dparam )
{
	 ...
}

To allow source or header to be compiled under either C or C++.

#ifdef __cplusplus
extern "C"
{
#endif

int strcmp( const char*, const char* );
...

#ifdef __cplusplus
}
#endif


<case-example> <wrapper-from-cpp-to-c>
This case is that main is in c and is to use some features written in cpp.

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)

#include "wrapper.h"                                  #include "wrapper.h" 
                            extern "C"                extern "C"
                            {   typdefs               {
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									 }                                ....
                                                          }
																			 ...
																		}

Note This is a problem when use the same header in both c and cpp compile. Why extern C is needed in
the wrapper.h? If this is only used for C files then not needed but must for C and CPP source files.

Also because cpp file uses typedefs from it. So when compile cpp compiler thinks func defs are C++
linkage from wrapper header when there is no extern guard and then see wrapper_func in C linkage
from cpp file. So conflict and emits errors:

[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmosa.h:170:1: error: previous
declaration of 'pfmerr_t pfmThreadCreate(SPfmThreadParams*, void (*)(void*), void*)' with 'C++'
linkage 
[   15s] /home/abuild/rpmbuild/BUILD/org.tizen.mhegproto-0.1/pfm/pfmthread.cpp:80:80: error:
conflicts with new declaration with 'C' linkage

C source(.c and gcc)        wrapper header(.h)        wrapper class(.cpp and g++)
#include "wrapper.h"                                 	extern "C"
                               typdefs                {
                                                          #include "wrapper.h" 
										  int wrapper_func();       int wrapper_func()
										  ...                       {
									                                 ....
                                                          }
																			 ...
																		}

This can be avoided if design header and source files carefully. For example, if need some c
functions that can be used in c file and this function creates cpp objects and use it then simply
create a header which has normal declarations and no externs and only have externs in cpp. The point
is that the same header is used for both C and CPP.

// ususal c
#include "wrapper.h"
{
	wrapper_func();
}

// usual.h or wrapper.h
int wrapper_func();

// usual cpp or wrapper.cpp
extern "C"
{
  int wrapper_func()
  {
     ClassX* pclass = new Class( params );

     pclass->func();
     ...
  }
}

If usual cpp header or wrapper.h have other cpp headers, will work cpp compiles such as usual cpp
and others but when used in c compile, emits loads of errors since these cpp files have cpp things.
So better to have single header file which have all c functions from cpp land. Otherwise, will get
errors shown in *kt_dev_gcc_007* 

<extern-linkage>
Using extern to Specify Linkage
http://msdn.microsoft.com/en-us/library/0603949d.aspx

extern string-literal { declaration-list }
extern string-literal declaration

The extern keyword declares a variable or function and specifies that it has external linkage (its
    name is visible from files other than the one in which it's defined). When modifying a variable,
    extern specifies that the variable has static duration (it is allocated when the program begins
        and deallocated when the program ends). The variable or function may be defined in another
    source file, or later in the same file. Declarations of variables and functions at file scope
    are external by default.

In C++, when used with a string, extern specifies that the linkage conventions of another language
are being used for the declarator(s). C functions and data can be accessed only if they are
previously declared as having C linkage. However, they must be defined in a separately compiled
translation unit.

Microsoft C++ supports the strings "C" and "C++" in the string-literal field. All of the standard
include files use the extern "C" syntax to allow the run-time library functions to be used in C++
programs.

The following example shows alternative ways to declare names that have C linkage:

// specifying_linkage2.cpp
// compile with: /c
// Declare printf with C linkage.
extern "C" int printf( const char *fmt, ... );

//  Cause everything in the specified header files
//   to have C linkage.
extern "C" {
   // add your #include statements here
   #include <stdio.h>
}

//  Declare the two functions ShowChar and GetChar
//   with C linkage.
extern "C" {
   char ShowChar( char ch );
   char GetChar( void );
}

//  Define the two functions ShowChar and GetChar
//   with C linkage.
extern "C" char ShowChar( char ch ) {
   putchar( ch );
   return ch;
}

extern "C" char GetChar( void ) {
   char ch;

   ch = getchar();
   return ch;
}

// Declare a global variable, errno, with C linkage.
extern "C" int errno;


{example-from-code}
/* Define C declaration macros for C++ compatibility. */                                
#if !defined(BEGIN_C_DECLS) && !defined(END_C_DECLS)
#if defined(__cplusplus) || defined(c_plusplus)
# define BEGIN_C_DECLS extern "C" {
# define END_C_DECLS   }
#else /* !__cplusplus */
# define BEGIN_C_DECLS
# define END_C_DECLS
#endif /* __cplusplus */
#endif /* BEGIN_C_DECLS && END_C_DECLS */


{function-pointer-between}
If use function-pointer or function-pointer as arg between them, see Primus p859 for more.


{cpp-main}
The cpp-main has three stages: static-initialisation, main, and static-destruction. So if not use
cpp-main when use both, will not work as expected and shall use cpp-main.

extern "C" int realMain(...);

int main( ... )
{
	 return realMain( ... );
}

This is dependent on compiler and shall check with it.

KT: is it still ture? ture for gcc?


{new-delete-and-malloc-free}
Do not mix between new/delete and malloc/free. For example, char* strdup(char *ps), which is not
standard in C/C++. Need to free or delete? It depends on system and compiler so recommends that do
not use funcs which is not standard.


{data-structure-in-between}
The objects that have virtual and inheritance are not compatible with C. This affects when calling
funcs with return or args between them.


==============================================================================
*kt_dev_mecpp_008*	32: program in the future tense

To be prepared for the change. How?

{one}

Express design decision in code instead of comments or documents. For example,
preventing-derivation.


{two}

Design code so that when changes are necessary, the impact is localized. Asks how the class is
designed to be used. See future thense and this is a example of virtual dtor. Encapsulation.


# ============================================================================
#{
={============================================================================
*kt_dev_estl_001*	02: illusion of container-independent code

STL is based on generalizaiton: container is array generalization, iterator is pointer, and
algorithm is function. but do not mean that can write container-independent code because each
container has different interface and characteristics. To minimize impcats of changing containers,
use <encapsulation> using typedef and class.

{no-encapsulation}

class Widget { ... };
vector< Widget > vw;
Widget bestWidget;
...
vector< Widget >::iterator i = find( vw.begin(), vw.end(), bestWidget );


{first-improvement}

class Widget { ... };
>
 typedef vector< Widget > WidgetContainer;
 WidgetContainer vw;
<
Widget bestWidget;
...
>
 WidgetContainer::iterator i = find( vw.begin(), vw.end(), bestWidget );

Also, save you some typing as think about:

map< sting, vector< Widget >::iterator, CIStingCompare>;

Want to sell out the below?

map< sting, vector< Widget >::iterator, CIStingCompare>::const_iterator;


{second-improvement}
Using typdef is not enough to separate client so use class:

class CustomerList {
	 private:
	 >
	 typedef list< Customer > CustomerContainer;
	 typedef CustomerContainer::iterator CCIterator;
	 CustomerContainer customers;
<
	 public:
	 // limit the list-specific detail visible through this interface
	 ...
};

# ============================================================================
#{
={============================================================================
*kt_dev_blush_001*	accessing neighbors in array

2013.10. when had a problem solving which is to find a path in a maze, wrote a func like:

bool checkWhite( const Pos& pos)
{
	// upper-left
	if( A[pos.xpos-1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper
	else if ( A[pos.xpos][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// upper-right
	else if ( A[pos.xpos+1][pos.ypos-1] == WHITE )
	{
		return true;
	}
	// same-left
	else if ( A[pos.xpos-1][pos.ypos] == WHITE )
	{
		return true;
	}
	// same-right
	else if ( A[pos.xpos+1][pos.ypos] == WHITE )
	{
		return true;
	}
	// lower-left
	else if ( A[pos.xpos-1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower
	else if ( A[pos.xpos][pos.ypos+1] == WHITE )
	{
		return true;
	}
	// lower-right
	else if ( A[pos.xpos+1][pos.ypos+1] == WHITE )
	{
		return true;
	}
	else
		return false;
}

Although the above tried to give it some priority, this should be something like used in
*kt_dev_algo_006* :

int NeighborCount( Grid map, int row, int col)
{
	 int i, j, count = 0;

	 for( i = row-1; i <= row+1; i++ )
		  for( j = col-1; j <= col+1; j++ )
				if( map[i][j] == ALIVE )
					 count++;

	 // exclude one for itself
	 if( map[row][col] == ALIVE )
		  count--;

	 return count;
}


={{===========================================================================
*kt_dev_blush_001* default return values

Have spent a day to find out why a program crashes. Two lessons:

1) It is better to have a core dump rather then narrowing down where a crash happens. Since looked
like there are other places to be suspicious while doing gdb session until reachs to the real cause
such as constructors, map insertions, and so on.

2) From the '89 standard as quoted in the new testament: Flowing off the end of a function is
equivalent to a return with no expression. In either case, the return value is undefined.

This is a debug trace routines and defines enums, strings for enums. It is easy to make a mismatch
between enum and strings when add more enums. So better to have strings from enums using macro
stringfication. However, in that case, enum should be sequential.

typedef enum MHEGComponent_
{
    eMHEGNull       = 0x00000001,
    eMHEGeng        = 0x00000002,
    eMHEGengRuntime = 0x00000004,
    ...
} MHEGComponent;

const char* s_names[] =
{
    "Null",
    "MHEGEng",
    "MHEGEngRun",
    ...
};

const uint32_t getIndex(MHEGComponent comp)
{
  switch (comp)
  {
    case 0x00000001: return 0; break;
    case 0x00000002: return 1; break;
    case 0x00000004: return 2; break;
    case 0x00000008: return 3; break;
    case 0x00000010: return 4; break;
    ...
    case 0x00000040: return 6; break;
    case 0x00000080: return 7; break;
    case 0x00000100: return 8; break;
    case 0x00000200: return 9; break;
    case 0x00000400: return 10; break;
  }
}

This didn't have default case and when there is a enum which don't have a matching case, no return
statement but this function returns int. Which value will you get? Quick test shows undefined return
value.

case: 3000
val: 134520896


# ============================================================================
#{
={{===========================================================================
*kt_dev_uml_001*	aggragation

Two aggregations: weak and strong.

1) weak. white diamond-shaped arrowhead pointing towards the target or parent class.

2) strong. a black diamond-shaped arrowhead. composite aggragation.

# example

AddressBook <*>----------- ContactGroup
            1         0..*

(copied from *kt_dev_ecpp_011* )

# 03 : classic strategy pattern

hierarchy 01:

GameCharacter <--- CharacterX
                |- CharacterY
					 |- ...
    <*>
	  |
	  | composition aggregation
	 1|
HealCalcFunc  <--- SlowHealthLoser
                |- FastHealthLoser
					 |- ...


# ============================================================================
#{
={============================================================================
*kt_dev_ref_001* references

{ref-001} data structure and program design in C/C++, 2nd Ed, Robert Kruse, Prentice Hall.
ftp://ftp.prenhall.com/pub/esm/computer_science.s-041/kruse/cpp/

{ref-002} thinking in C++. 
http://www.mindviewinc.com/Books/

{ref-003} design patterns, Erich Gamma and et el. Addison Wesley

{ref-004} cracking the coding interview, 5th Ed.

{ref-CPR} C++ primer, 5th Ed.


={============================================================================
*kt_dev_ref_002* sites

http://eli.thegreenplace.net/


==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
