*kt_dev_08*                                                                tw=100

kt.dev.py

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_py_0001| py-check-version
|kt_dev_py_0001| py-main-scope
|kt_dev_py_0001| py-read-bash

|kt_dev_py_0001| py-lib-sys
|kt_dev_py_0001| py-lib-subprocess

|kt_dev_py_0001| py-data-tuple
|kt_dev_py_0001| py-data-list
|kt_dev_py_0001| py-data-slice
|kt_dev_py_0001| py-data-seq-function
|kt_dev_py_0001| py-data-dict


# ============================================================================
#{
={============================================================================
|kt_dev_py_0001| py-check-version

10:27:35 ~$ python -V
Python 2.7.3

10:27:40 ~$ python --version
Python 2.7.3

>>> import sys
>>> print (sys.version)
2.7.3 (default, Mar 14 2014, 11:57:14) 
[GCC 4.7.2]

>>> sys.version_info
sys.version_info(major=2, minor=7, micro=3, releaselevel='final', serial=0)
>>> sys.hexversion
34014192

# `tuple` and `tuple` comparison?
>>> sys.version_info >= (2,5)
True


={============================================================================
|kt_dev_py_0001| py-main-scope

29.4. __main__ — Top-level script environment

'__main__' is the name of the `scope` in which top-level code executes. A
module's __name__ is set equal to '__main__' when read from standard input, a
script, or from an interactive prompt.

A module can discover whether or not it is running in the `main-scope` by
checking its own __name__, which allows a common idiom for conditionally
executing code in a module when it is run `as-a-script` or with python -m but
not when it is imported:

if __name__ == "__main__":
    # execute only if run as a script
    main()

For a package, the same effect can be achieved by including a __main__.py
module, the contents of which will be executed when the module is run with -m.


={============================================================================
|kt_dev_py_0001| py-read-bash

Python Scripts as a Replacement for Bash Utility Scripts

http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts?page=0,0

Pros:

Python is a fully featured programming language. Code reuse is simple, because
Python modules easily can be imported and used in any Python script. Scripts
easily can be extended or built upon.

Python has access to an excellent standard library and thousands of third-party
libraries for all sorts of advanced utilities, such as parsers and request
libraries. For instance, Python's standard library includes datetime libraries
that allow you to parse dates into any format that you specify and compare it to
other dates easily. 

<ex>
#!/usr/bin/env python
import sys

if __name__ == "__main__":

    # initialize a names dictionary as empty to start with.
    # each key in this dictionary will be a name and the value will be
    # the number of times that names appears. name-value-pair
    names = {}

    # sys.stdin is a file object. all the same functions that can be
    # applied to a file object can be applied to sys.stdin. 
    for name in sys.stdin.readlines():

        # each line will have a newline on the end that should be
        # removed.
        name = name.strip()

        if name in names:
            names[name] += 1
        else:
            names[name] = 1

    # iterating over the dictionary. print name followed by a space and 
    # the number of times it appeared.
    for name, count in names.iteritems():
        sys.stdout.write("%d\t%s\n" % (count, name))


$ cat names.log | python namescount.py


The standard library of Python provides a CSV reader. The Python script below
completes this goal:


*py-cvs-reader*

#!/usr/bin/env python
# CSV module that comes with the Python standard library
import csv
import sys

if __name__ == "__main__":
    # The CSV module exposes a reader object that takes
    # a file object to read. In this example, sys.stdin.
    csvfile = csv.reader(sys.stdin)

    # The script should take one argument that is a column number.
    # Command-line arguments are accessed via sys.argv list.
    column_number = 0
    if len(sys.argv) > 1:
            column_number = int(sys.argv[1])

    # Each row in the CSV file is a list with each 
    # comma-separated value for that line.
    for row in csvfile:
            print row[column_number]


*py-stmplib*

#!/usr/bin/env python
import smtplib
import sys


GMAIL_SMTP_SERVER = "smtp.gmail.com"
GMAIL_SMTP_PORT = 587

GMAIL_EMAIL = "Your Gmail Email Goes Here"
GMAIL_PASSWORD = "Your Gmail Password Goes Here"


def initialize_smtp_server():
    '''
    This function initializes and greets the smtp server.
    It logs in using the provided credentials and returns 
    the smtp server object as a result.
    '''
    smtpserver = smtplib.SMTP(GMAIL_SMTP_SERVER, GMAIL_SMTP_PORT)
    smtpserver.ehlo()
    smtpserver.starttls()
    smtpserver.ehlo()
    smtpserver.login(GMAIL_EMAIL, GMAIL_PASSWORD)
    return smtpserver


def send_thank_you_mail(email):
    to_email = email
    from_email = GMAIL_EMAIL
    subj = "Thanks for being an active commenter"
    # The header consists of the To and From and Subject lines
    # separated using a newline character
    header = "To:%s\nFrom:%s\nSubject:%s \n" % (to_email,
            from_email, subj)
    # Hard-coded templates are not best practice.
    msg_body = """
    Hi %s,

    Thank you very much for your repeated comments on our service.
    The interaction is much appreciated.

    Thank You.""" % email
    content = header + "\n" + msg_body
    smtpserver = initialize_smtp_server()
    smtpserver.sendmail(from_email, to_email, content)
    smtpserver.close()


if __name__ == "__main__":
    # for every line of input.
    for email in sys.stdin.readlines():
            send_thank_you_mail(email)


*py-optionparser*

Thankfully, Python has a number of modules to deal with command-line arguments.
My personal favorite is OptionParser. OptionParser is part of the optparse
module that is provided by the standard library.

if __name__ == "__main__":
    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("--email", dest="email",
            help="email to login to smtp server")
    parser.add_option("--pwd", dest="pwd",
            help="password to login to smtp server")
    parser.add_option("--smtp-server", dest="smtpserver",
            help="smtp server url", default="smtp.gmail.com")
    parser.add_option("--smtp-port", dest="smtpserverport",
            help="smtp server port", default=587)
    options, args = parser.parse_args()

    if not (options.email or options.pwd):
            parser.error("Must provide both an email and a password")

    smtpserver = initialize_smtp_server(options.stmpserver,
            options.smtpserverport, options.email, options.pwd)

    # for every line of input.
    for email in sys.stdin.readlines():
            send_thank_you_mail(email, smtpserver)
    smtpserver.close()


There are a lot of aspects to Python in the shell that go beyond the scope of
  this article, such as the os module and the subprocess module. The os module
  is a standard library function that holds a lot of key operating system-level
  operations, such as listing directories and stating files, along with an
  excellent submodule os.path that deals with normalizing directories paths. The
  subprocess module allows Python programs to run system commands and other
  advanced operations, such as handling piping as described above within Python
  code between spawned processes. Both of these libraries are worth checking out
  if you intend to do any Python shell scripting. 


={============================================================================
|kt_dev_py_0001| py-lib-sys

sys.exit([arg])

    Exit from Python. This is implemented by raising the SystemExit exception,
so cleanup actions specified by finally clauses of try statements are honored,
and it is possible to intercept the exit attempt at an outer level.

    The optional argument arg can be an integer giving the exit status
    (defaulting to zero), or another type of object. If it is an integer, zero
    is considered “successful termination” and any nonzero value is considered
    “abnormal termination” by shells and the like. Most systems require it to
    be in the range 0-127, and produce undefined results otherwise. Some
    systems have a convention for assigning specific meanings to specific exit
    codes, but these are generally underdeveloped; Unix programs generally use
    2 for command line syntax errors and 1 for all other kind of errors. If
    another type of object is passed, None is equivalent to passing zero, and
    any other object is printed to stderr and results in an exit code of 1. In
    particular, sys.exit("some error message") is a quick way to exit a
    program when an error occurs.

    Since exit() ultimately “only” raises an exception, it will only exit the
    process when called from the main thread, and the exception is not
    intercepted.


sys.argv

    The list of command line arguments passed to a Python script. argv[0] is
    the script name (it is operating system dependent whether this is a full
        pathname or not). If the command was executed using the -c command
    line option to the interpreter, argv[0] is set to the string '-c'. If no
    script name was passed to the Python interpreter, argv[0] is the empty
    string.

    To loop over the standard input, or the list of files given on the command
    line, see the fileinput module.

    note:
    argv[0] - len(argv[0]) is 1


={============================================================================
|kt_dev_py_0001| py-lib-subprocess

subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)

    Run the command described by args. Wait for command to complete, then
    return the returncode attribute.

    The arguments shown above are merely the most common ones, described below
    in Frequently Used Arguments (hence the slightly odd notation in the
        abbreviated signature). The full function signature is the same as
    that of the Popen constructor - this functions passes all supplied
    arguments directly through to that interface.

    Examples:

    >>> subprocess.call(["ls", "-l"])
    0

    >>> subprocess.call("exit 1", shell=True)
    1

    Warning
    Using shell=True can be a security hazard. See the warning under
    Frequently Used Arguments for details.

    Note
    Do not use stdout=PIPE or stderr=PIPE with this function as that can
    deadlock based on the child process output volume. Use Popen with the
    communicate() method when you need pipes.


={============================================================================
|kt_dev_py_0001| py-lib-built-in

2. Built-in Functions
The Python interpreter has a number of functions and types built into it that
are always available. They are listed here in alphabetical order.

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

    Print objects to the text stream file, separated by sep and followed by
    end. sep, end and file, if present, must be given as keyword arguments.
    All non-keyword arguments are converted to strings like str() does and
    written to the stream, separated by sep and followed by end. Both sep and
    end must be strings; they can also be None, which means to use the default
    values. If no objects are given, print() will just write end.  The file
    argument must be an object with a write(string) method; if it is not
    present or None, sys.stdout will be used. Since printed arguments are
    converted to text strings, print() cannot be used with binary mode file
    objects. For these, use file.write(...) instead.  Whether output is
    buffered is usually determined by file, but if the flush keyword argument
    is true, the stream is forcibly flushed.  Changed in version 3.3: Added
    the flush keyword argument.

<ex>
print "item in the list: %s" % item


={============================================================================
|kt_dev_py_0001| py-data-tuple

A tuple is a one-dimensional, `fixed-length`, `immutable` sequence of Python
objects. 


# The easiest way to create one is with a comma-separated sequence of values

>>> tup = 4,5,6
>>> tup
(4, 5, 6)


# necessary to enclose the values in parentheses to create a tuple of tuples:

>>> nested_tup=(4,5,6),(7,8)
>>> nested_tup
((4, 5, 6), (7, 8))


# Any sequence or iterator can be converted to a tuple by invoking tuple:

>>> tuple([4,5,6])
(4, 5, 6)

>>> string_tup=tuple('string')
>>> string_tup
('s', 't', 'r', 'i', 'n', 'g')


# Accessed with square brackets [] as with most other sequence types.
# Sequences are 0-indexed in Python:

>>> string_tup[0]
's'


# Once created it's not possible to modify which object is stored in each slot:

>>> tup
(4, 5, 6)
>>> tup[1]=7
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

note: WHY??

>>> tup=('foo', 'bar', 'baz')
>>> tup
('foo', 'bar', 'baz')
>>> tup=1,2,3
>>> tup
(1, 2, 3)
>>> tup=4,5,6,7
>>> tup
(4, 5, 6, 7)


# Can be concatenated using the + operator to produce longer tuples:

>>> long_tup = tup + nested_tup + string_tup
>>> long_tup
(4, 5, 6, (4, 5, 6), (7, 8), 's', 't', 'r', 'i', 'n', 'g')

note:
`tuple of tuple` so sequence can have different types.


# `unpacking` If you try to assign to a tuple-like expression of variables,
# Python will attempt to unpack the value on the right-hand side of the equals
# sign:

>>> a,b,c = tup
>>> a
4
>>> b
5
>>> c
6


# Using this functionality it's easy to swap `variable names`, a task which in
# many languages might look like:
#
#   tmp = a
#   a = b
#   b = tmp

>>> a,b = b,a
>>> a
5
>>> b
4
>>> c
6


# One of the most common uses of variable unpacking when `iterating` over
# sequences of tuples or lists:

seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
for a, b, c in seq:
  pass


<method>
# Since the size and contents of a tuple cannot be modified, it is very light
# on instance methods. `count`, which counts the number of `occurrences` of a
# value:

>>> a=1,2,2,2,3,4,2
>>> a
(1, 2, 2, 2, 3, 4, 2)
>>> a.count(2)
4


<check>

>>> tup
('foo', 'bar', 'baz')
>>> 'bar' in tup
True


={============================================================================
|kt_dev_py_0001| py-data-list

In contrast with tuples, lists are `variable-length` and their contents can be
`modified`. They can be defined using `square brackets []` or using the `list`
type function:

Lists and tuples are semantically similar as one-dimensional sequences of
objects and thus can be used interchangeably in many functions.

>>> b_list=list(tup)
>>> b_list
['foo', 'bar', 'baz']


<adding-removing>

# Append to the end of the list with the `append` method and `insert` an
# element at a specific location in the list:

>>> b_list.append('dwarf')
>>> b_list
['foo', 'bar', 'baz', 'dwarf']
>>> b_list.insert(1,'red')
>>> b_list
['foo', 'red', 'bar', 'baz', 'dwarf']

note: 
insert is computationally `expensive` compared with append as references to
subsequent elements have to be shifted internally to make room for the new
element.


# `pop` removes and returns an element at a particular index:

>>> b_list.pop(2)
'bar'
>>> b_list
['foo', 'red', 'baz', 'dwarf']


# `remove` locates the first such value and removes it from the last:

>>> b_list
['foo', 'red', 'red', 'red', 'baz', 'dwarf']
>>> b_list.remove('red')
>>> b_list
['foo', 'red', 'red', 'baz', 'dwarf']


<check>
As with tuple.

note:
checking whether a list contains a value is a lot `slower` than dicts and sets
as Python makes a linear scan across the values of the list, whereas the
others (based on hash tables) can make the check in constant time.


<concatenation>
# Append multiple elements to it using the `extend` method:

>>> [4, None, 'foo'] + [7,8,(2,3)]
[4, None, 'foo', 7, 8, (2, 3)]

>>> x=[4, None, 'foo']
>>> x.extend([7,8,(2,3)])
>>> x
[4, None, 'foo', 7, 8, (2, 3)]

# list concatenation is a compartively `expensive` operation since a `new
# list` must be created and the objects copied over. Using extend is usually
# preferable.

everything = []
for chunk in list_of_lists:
  everything.extend(chunk)

is faster than than the concatenative alternative

everything = []
for chunk in list_of_lists:
  everything = everything + chunk


<sorting> 
A list can be sorted in-place (without creating a new object) by calling its
`sort` function:

>>> tup = 2,4,3,5,7,6
>>> tup
(2, 4, 3, 5, 7, 6)

>>> lst = [2,4,3,5,7,8]
>>> lst
[2, 4, 3, 5, 7, 8]

>>> tup.sort()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'sort'

>>> lst.sort()
>>> lst
[2, 3, 4, 5, 7, 8]


sort has a few options that will occasionally come in handy. One is the
  ability to pass a secondary `sort key`, i.e. a `function` that produces a
  value to use to sort the objects.

>>> lst = ['saw', 'small', 'He', 'foxes', 'six']
>>> lst
['saw', 'small', 'He', 'foxes', 'six']
>>> lst.sort(key=len)
>>> lst
['He', 'saw', 'six', 'small', 'foxes']


note: *py-module-bisect*

The built-in bisect module implements binary-search and insertion into a
sorted list. bisect.bisect finds the `location` where an element should be
inserted to keep it sorted, while bisect.insort actually `inserts` the element
into that location:

>>> import bisect

>>> c = [1,2,2,2,3,4,7]
>>> bisect.bisect(c,2)
4

>>> bisect.insort(c,6)
>>> c
[1, 2, 2, 2, 3, 4, 6, 7]

The bisect module functions do not check whether the list is sorted. Thus,
using them with an unsorted list will succeed without error but may lead to
incorrect results.


={============================================================================
|kt_dev_py_0001| py-data-slice

You can select sections of list-like types (arrays, tuples, NumPy arrays) by
using slice notation, which in its basic form consists of `start:stop` passed
to the `indexing operator []`:

>>> seq=[7,2,3,7,5,6,0,1]
>>> seq
[7, 2, 3, 7, 5, 6, 0, 1]

# (start, end] in C++ iterator notation.

>>> seq[1:1]
[]

>>> seq[1:2]
[2]

>>> seq[1:5]
[2, 3, 7, 5]

# inserted actually

>>> seq[3:4] = [6,3]
>>> seq
[7, 2, 3, 6, 3, 5, 6, 0, 1]

Either the start or stop can be omitted in which case they default to the
start of the sequence and the end of the sequence, respectively:


A `step` can also be used after a second colon

[7, 2, 3, 6, 3, 5, 6, 0, 1]
>>> seq[::2]
[7, 3, 3, 6, 1]

Negative indices slice the sequence relative to the end:

   H  E  L  L  O  !
   0  1  2  3  4  5  6
  -6 -5 -4 -3 -2 -1

A clever use of this is to pass -1 which has the useful effect of reversing a
list or tuple:

[7, 2, 3, 6, 3, 5, 6, 0, 1]
>>> seq[::-1]
[1, 0, 6, 5, 3, 6, 3, 2, 7]


={============================================================================
|kt_dev_py_0001| py-data-seq-function

Python has a handful of useful built-in sequence functions.

<enumerate>
When iterating over a sequence to want to keep track of the index of the
current item. Since this is so common, Python has a built-in function
`enumerate` which returns a sequence of (i, value) tuples:

for i, value in enumerate(collection):
  # do something with value


Useful `pattern` that uses enumerate is computing a dict mapping the values of
a sequence (which are assumed to be unique) to their locations in the
sequence:

>>> l
['one', 'two', 'three']
>>> mapping = dict((v,i) for i,v in enumerate(l))
>>> mapping
{'three': 2, 'two': 1, 'one': 0}


<sorted>
The sorted function returns a new sorted list from the elements of any
sequence. A common `pattern` for getting a sorted list of the `unique
elements` in a sequence is to combine sorted with set.

>>> [7,1,2,6,0,3,2,3,2]
[7, 1, 2, 6, 0, 3, 2, 3, 2]
>>> sorted([7,1,2,6,0,3,2,3,2])
[0, 1, 2, 2, 2, 3, 3, 6, 7]
>>> sorted(set([7,1,2,6,0,3,2,3,2]))
[0, 1, 2, 3, 6, 7]


<zip>
zip `pairs up` the elements of a number of lists, tuples, or other sequences,
    to create a list of tuples:

>>> seq1=['foo','bar','baz']
>>> seq2=['one','two','three']
>>> zip(seq1,seq2)
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]


A very common use of zip is for simultaneously `iterating over multiple`
sequences, possibly also combined with enumerate:

>>> for i, (a,b) in enumerate(zip(seq1,seq2)):
...     print('%d: %s, %s' % (i,a,b))
... 
0: foo, one
1: bar, two
2: baz, three


Given a zipped sequence, zip can be applied in a clever way to `unzip` the
sequence.  Another way to think about this is converting a list of rows into a
list of columns. The syntax, which looks a bit magical, is:

>>> zipped=zip(seq1, seq2)
>>> zipped
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
>>> names, numbers = zip(*zipped)
>>> names
('foo', 'bar', 'baz')
>>> numbers
('one', 'two', 'three')


<reversed>
`reversed` iterates over the elements of a sequence in reverse order:

>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> reversed(range(10))
<listreverseiterator object at 0xb753a8ec>
>>> list(reversed(range(10)))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]


={============================================================================
|kt_dev_py_0001| py-data-dict

A more common name for it is hash map or associative array. It is a
flexibly-sized collection of key-value pairs, where key and value are Python
objects. One way to create one is by using curly `braces` {} and using
`colons` to separate keys and values:

>>> d1={'a':'some value', 'b':[1,2,3,4]}
>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4]}


Elements can be accessed and inserted using the same syntax as accessing
elements of a list or tuple:

>>> d1[7]='an integer'
>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
>>> d1['b']
[1, 2, 3, 4]
>>> d1[b]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'three'
>>> 


Can check if a dict contains a key using the same syntax as with checking
whether a list or tuple contains a value:

>>> 'b' in d1
True


Values can be deleted either using the `del` keyword or the `pop` method
(which simultaneously returns the value and deletes the key):

>>> d1
{'a': 'some value', 'dummy': 'another value', 'b': [1, 2, 3, 4], 5: 'some value', 7: 'an integer'}
>>> del d1[5]
>>> d1
{'a': 'some value', 'dummy': 'another value', 'b': [1, 2, 3, 4], 7: 'an integer'}
>>> d1.pop('dummy')
'another value'
>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}


The `keys and values method` give you lists of the keys and values,
    respectively. While the key-value pairs are not in any particular order,
    these functions output the keys and values in the same order:

>>> d1.keys()
['a', 'b', 7]
>>> d1.values()
['some value', [1, 2, 3, 4], 'an integer']


One dict can be merged into another using the `update` method:

>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
>>> d1.update({'b':'foo','c':12})
>>> d1
{'a': 'some value', 'c': 12, 'b': 'foo', 7: 'an integer'}

note: 'b' is overwritten.


<dict-from-sequence>
Common to occasionally end up with two sequences that you want to pair up
element-wise in a dict.

mapping = {}
for key, value in zip(key_list, value_list):
  mapping[key] = value

Since a dict is essentially a collection of 2-tuples, the dict type function
accepts a list of 2-tuples:

mapping = dict(zip(range(5), reversed(range(5))))
mapping
Out[454]: {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}


>>> l
['one', 'two', 'three']
>>> mapping = dict((v,i) for i,v in enumerate(l))
>>> mapping
{'three': 2, 'two': 1, 'one': 0}


<default-values>
Very common to have logic like:

if key in some_dict:
  value = some_dict[key]
else:
  value = default_value

Thus, the dict methods get and pop can take a default value to be returned, so
that the above if-else block can be written simply as:

value = some_dict.get(key, default_value)

`get` by default will return `None` if the key is not present, while `pop`
will raise an exception.


<other-collection-as-value>

>>> di={}
>>> di['b'] = ['apple', 'atom']
>>> di
{'b': ['apple', 'atom']}

With setting values, a common case is for the values in a dict to be other
collections, like lists. For example, you could imagine categorizing a list of
words by their first letters as a dict of lists:

>>> words=['apple', 'bat', 'bar', 'atom', 'book']
>>> by_letter={}
>>> for word in words:
...     letter = word[0]
...     if letter not in by_letter:
...             by_letter[letter] = [word]
...     else:
...             by_letter[letter].append(word)
... 
>>> by_letter
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}


The `setdefault` dict method is for precisely this purpose.

note: HOW does all work?

>>> by_letter={}
>>> words=['apple', 'bat', 'bar', 'atom', 'book']
>>> for word in words:
...     letter = word[0]
...     by_letter.setdefault(letter,[]).append(word)
... 
>>> by_letter
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}


The built-in `collections` module has a useful class, `defaultdict`, which makes
  this even easier. One is created by passing a type or function for
  generating the default value for each slot in the dict: 
  
from collections import defaultdict 
by_letter = defaultdict(list) 
for word in words:
  by_letter[word[0]].append(word) 
  

The initializer to defaultdict only needs to be a callable object (e.g. any
    function), not necessarily a type. Thus, if you wanted the default value
to be 4 you could pass a function returning 4

counts = defaultdict(lambda: 4)


<key-types>
While the values of a dict can be `any` Python object, the keys have to be
`immutable` objects like scalar types (int, float, string) or tuples (all the
    objects in the tuple need to be immutable, too). The technical term here
is `hashability`. You can check whether an object is hashable (can be used as
    a key in a dict) with the hash function:

>>> hash('string')
-1542666171
>>> hash((1,2,(2,3)))
1387206534
>>> hash((1,2,[2,3]))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'


To use a list as a key, an easy fix is to convert it to a tuple:

>>> d = {}
>>> d[tuple([1,2,3])]=5
>>> d
{(1, 2, 3): 5}


==============================================================================
Copyrightobjdump see |ktkb|                              vim:tw=100:ts=3:ft=help:norl:
