*kt_dev_08*                                                                tw=100

kt.dev.py

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_py_0001| py-check-version
|kt_dev_py_0001| py-base-basic
|kt_dev_py_0001| py-main-scope
|kt_dev_py_0001| py-read-bash

|kt_dev_py_0001| py-lib-sys
|kt_dev_py_0001| py-lib-subprocess
|kt_dev_py_0001| py-lib-built-in

|kt_dev_py_0001| py-data-tuple
|kt_dev_py_0001| py-data-list
|kt_dev_py_0001| py-data-slice
|kt_dev_py_0001| py-data-seq-function
|kt_dev_py_0001| py-data-dict
|kt_dev_py_0001| py-data-comprehension
|kt_dev_py_0001| py-function


# ============================================================================
#{
={============================================================================
|kt_dev_py_0001| py-check-version

10:27:35 ~$ python -V
Python 2.7.3

10:27:40 ~$ python --version
Python 2.7.3

>>> import sys
>>> print (sys.version)
2.7.3 (default, Mar 14 2014, 11:57:14) 
[GCC 4.7.2]

>>> sys.version_info
sys.version_info(major=2, minor=7, micro=3, releaselevel='final', serial=0)
>>> sys.hexversion
34014192

# `tuple` and `tuple` comparison?
>>> sys.version_info >= (2,5)
True


={============================================================================
|kt_dev_py_0001| py-base-basic

<indentation-not-brace>
Python uses whitespace (tabs or spaces) to structure code

for x in array:
  if x < pivot:
    less.append(x)
  else:
    greater.append(x)

A `colon` denotes the start of an `indented code block` after which all of the
code must be indented by the same amount until the end of the block.


<everything-is-object>
An important characteristic of the Python language is the consistency of its
object model. 

Every number, string, data structure, function, class, module, and so on
exists in the Python interpreter in its own "box" which is referred to as a
Python object. Each object has an associated type (for example, string or
    function) and internal data. In practice this makes the language very
flexible, as even functions can be treated just like any other object.


<comment>
Any text preceded by the hash mark (pound sign) # is ignored by the Python
interpreter.


<function>
Functions are called using parentheses and passing zero or more arguments,
          optionally assigning the returned value to a variable:

result = f(x, y, z)
g()

Almost every object in Python has attached functions, known as methods, that
have access to the object's internal contents. They can be called using the
syntax:

obj.some_method(x, y, z)


<pass-by-reference>
When assigning a variable (or name) in Python, you are creating a `reference` to
the object on the right hand side of the equals sign.

In some languages, this assignment would cause the data [1, 2, 3] to be
copied. In Python, a and b actually now refer to the same object, the original
list

a = [1,2,3]
b = a
a.append(4)
b
[1,2,3,4]

note:
Assignment is also referred to as `binding`, as we are binding a name to an
object. Variables names that have been assigned may occasionally be referred
to as bound variables.

When you pass objects as arguments to a function, you are only passing
references; no copying occurs.

Understanding the semantics of references in Python and when, how, and why
  data is copied is especially critical when working with larger data sets in
  Python.


<typed-language>
In contrast with many compiled languages, such as Java and C++, 
`object references` in Python `have no type` associated with them. There is no
  problem with the following:

>>> a = 5
>>> type(a)
<type 'int'>

>>> a = 'foo'
>>> type(a)
<type 'str'>

>>> a = "foo"
>>> type(a)
<type 'str'>


Variables are names for objects within a particular namespace; the type
information is stored in the `object itself` Some observers might hastily
conclude that Python `is not a typed language` This is `not true`; consider
this example:

>>> '5'+5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
`TypeError`: cannot concatenate 'str' and 'int' objects

In some languages, such as Visual Basic, the string '5' might get implicitly
  converted (or casted) to an integer, thus yielding 10. Yet in other
  languages, such as JavaScript, the integer 5 might be casted to a string,
  yielding the concatenated string '55'. 

In this regard Python is considered a strongly-typed language, which means
that every object has a specific type (or class), and implicit conversions
will occur only in `certain obvious circumstances`, such as the following:

>>> a = 4.5
>>> b = 2
>>> print "a is %s, b is %s" % (type(a), type(b))
a is <type 'float'>, b is <type 'int'>
>>> a/b
2.25


Knowing the type of an object is important and can check that an object is an
instance of a particular type using the `isinstance` function:

>>> a = 5
>>> isinstance(a,int)
True
>>> b = 4.5
>>> isinstance(b,int)
False
>>> isinstance(b,float)
True

isinstance can accept a tuple of types if you want to check that an object's
type is among those present in the tuple:

>>> isinstance(b,(int,float))
True


<attribute-and-method>
Objects in Python typically have both `attributes`, other Python objects
stored "inside" the object, and `methods`, functions associated with an object
which can have access to the object's internal data.

Both of them are accessed via the syntax `obj.attribute_name` Attributes and
methods can also be accessed by name using the `getattr` function:

>>> a='foo'
>>> type(a)
<type 'str'>
>>> getattr(a, 'split')
<built-in method split of str object at 0xb744dc38>

While we will not extensively use the functions getattr and related functions
`hasattr` and setattr in this book, they can be used very effectively to write
generic, reusable code.


<iterable>
Can verify that an object is iterable if it implemented the iterator protocol.

>>> def isiterable(obj):
...     try:
...             iter(obj)
...             return True
...     except TypeError:
...             return False
... 
>>> isiterable('a string')
True
>>> isiterable([1,2,3])
True
>>> isiterable(4)
False

note:
iter(object[, sentinel])

Return an iterator object. Without a second argument, object must be a
collection object which supports the `iteration protocol` (the __iter__()
    method), or it must support the sequence protocol (the __getitem__()
      method with integer arguments starting at 0). If it does not support
    either of those protocols, TypeError is raised.

A common case is writing a function that can accept any kind of sequence
(list, tuple, ndarray) or even an iterator. If it is not, convert it to be
one:

if not isinstance(x, list) and isiterable(x):
  x = list(x)


<module>
In Python a module is simply a .py file.

# some_module.py
PI = 3.14159

def f(x):
  return x + 2

def g(a, b):
  return a + b

To access the variables and functions defined in some_module.py, from another
  file in the `same directory` we could do:

import some_module
result = some_module.f(5)
pi = some_module.PI

Or equivalently:

from some_module import f, g, PI
result = g(5, PI)


By using the `as` keyword you can give imports different variable names:

import some_module as sm
from some_module import PI as pi, g as gf
r1 = sm.f(pi)
r2 = gf(6, pi)


<comparison>
To check if two `references` refer to the same object, use the `is` and `is not`
keyword. Not the object itself. 

>>> a=[1,2,3]
>>> b=a
>>> c=list(a)
>>> a is b
True
>>> a is not c
True
>>> a is c
False
>>> a == c
True
>>> b == c
True

A very common use of is and is not is to check if a variable is None

>>> a = None
>>> a is None
True


={============================================================================
|kt_dev_py_0001| py-base-builtin-type

Table A-2. Standard Python Scalar Types

`None` 
The Python "null" value (only one instance of the None object exists)

`str` 
String type. ASCII-valued only in Python 2.x and Unicode in Python 3

unicode 
Unicode string type

float 
Double-precision (64-bit) floating point number. Note there is no separate
double type.

bool 
A `True` or `False` value

`int` 
Signed integer with maximum value determined by the platform.

long 
Arbitrary precision signed integer. Large int values are automatically
converted to long.


<numeric-types>
The primary Python types for numbers are `int` and `float`. The size of the
integer which can be stored as an int is dependent on your platform (whether
    32 or 64-bit), but Python will transparently convert a very large integer
to `long`, which can store arbitrarily large integers.

Floating point numbers are represented with the Python float type. Under the
hood each one is a double-precision (64 bits) value.

In Python 3, integer division not resulting in a whole number will always
yield a floating point number:

In [284]: 3 / 2
Out[284]: 1.5

In Python 2.7 and below (which some readers will likely be using), you can
enable this behavior by default by putting the following cryptic-looking
statement at the top of your module:

from __future__ import division

Without this in place, you can always explicitly convert the denominator into
a floating point number:

In [285]: 3 / float(2)
Out[285]: 1.5

To get C-style integer division (which drops the fractional part if the result
is not a whole number), use the floor division operator //:

In [286]: 3 // 2
Out[286]: 1


={============================================================================
|kt_dev_py_0001| py-base-string-type

Can write string literal using either single quotes ' or double quotes ":

For multiline strings with line breaks, you can use triple quotes, either '''
or """:

c = """
This is a longer string that
spans multiple lines
"""


={============================================================================
|kt_dev_py_0001| py-base-control

{pass}
`pass` is the "no-op" statement in Python. It can be used in blocks where no
action is to be taken; it is only required because Python uses whitespace to
delimit blocks:

if x < 0:
  print 'negative!'
elif x == 0:
  # TODO: put something smart here
  pass
else:
  print 'positive!'

It's common to use pass as a place-holder in code while working on a new piece
of functionality:

def f(x, y, z):
  # TODO: implement this function!
  pass


{exception}
Suppose we wanted a version of float that fails gracefully, returning the
input argument.

# catchs all

def attempt_float(x):
  try:
    return float(x)
  except:
    return x

Want to only `suppress` ValueError, since a TypeError (the input was not a
    string or numeric value) might indicate a legitimate bug in your program.
To do that, write the `exception type` after except:

def attempt_float(x):
  try:
    return float(x)
  except ValueError:
    return x

>>> float((1,2))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: float() argument must be a string or a number
>>> def attempt_float(x):
...     try:
...             return float(x)
...     except ValueError:
...             return x
... 
>>> attempt_float((1,2))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in attempt_float
TypeError: float() argument must be a string or a number
>>> 


Can catch `multiple exception types` by writing a `tuple` of exception types
instead (the parentheses are required):

def attempt_float(x):
  try:
    return float(x)
  except (TypeError, ValueError):
    return x


note:
As with C++, if exception gets raised and not catched, then returns
immediately.

In some cases, you may not want to suppress an exception, but you want some
code to be executed `regardless of` whether the code in the try block
`succeeds or not` To do this, use finally:

f = open(path, 'w')

try:
  write_to_file(f)
finally:
  f.close()

Here, the file handle f will always get closed. 

Similarly, you can have code that executes `only if` the try: block `succeeds`
using else:

f = open(path, 'w')

try:
  write_to_file(f)
except:
  print 'Failed'
else:
  print 'Succeeded'
finally:
  f.close()


{range}
`range` produces integers up to but not including the endpoint. 

>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

A common use of range is for iterating through sequences `by index`:

seq = [1, 2, 3, 4]
for i in range(len(seq)):
  val = seq[i]

For very long ranges, it's recommended to use `xrange`, which takes the same
arguments as range but returns an iterator that generates integers one by one
rather than generating all of them up-front and storing them in a (potentially
    very large) list. This snippet sums all numbers from 0 to 9999 that are
multiples of 3 or 5:

sum = 0
for i in xrange(10000):
  # % is the modulo operator
  if x % 3 == 0 or x % 5 == 0:
    sum += i


{ternary-expression}

>>> x=5
>>> 'non-negative' if x >= 0 else 'negative'
'non-negative'
>>> 


={============================================================================
|kt_dev_py_0001| py-main-scope

29.4. __main__ — Top-level script environment

'__main__' is the name of the `scope` in which top-level code executes. A
module's __name__ is set equal to '__main__' when read from standard input, a
script, or from an interactive prompt.

A module can discover whether or not it is running in the `main-scope` by
checking its own __name__, which allows a common idiom for conditionally
executing code in a module when it is run `as-a-script` or with python -m but
not when it is imported:

if __name__ == "__main__":
    # execute only if run as a script
    main()

For a package, the same effect can be achieved by including a __main__.py
module, the contents of which will be executed when the module is run with -m.


={============================================================================
|kt_dev_py_0001| py-read-bash

Python Scripts as a Replacement for Bash Utility Scripts

http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts?page=0,0

Pros:

Python is a fully featured programming language. Code reuse is simple, because
Python modules easily can be imported and used in any Python script. Scripts
easily can be extended or built upon.

Python has access to an excellent standard library and thousands of third-party
libraries for all sorts of advanced utilities, such as parsers and request
libraries. For instance, Python's standard library includes datetime libraries
that allow you to parse dates into any format that you specify and compare it to
other dates easily. 

<ex>
#!/usr/bin/env python
import sys

if __name__ == "__main__":

    # initialize a names dictionary as empty to start with.
    # each key in this dictionary will be a name and the value will be
    # the number of times that names appears. name-value-pair
    names = {}

    # sys.stdin is a file object. all the same functions that can be
    # applied to a file object can be applied to sys.stdin. 
    for name in sys.stdin.readlines():

        # each line will have a newline on the end that should be
        # removed.
        name = name.strip()

        if name in names:
            names[name] += 1
        else:
            names[name] = 1

    # iterating over the dictionary. print name followed by a space and 
    # the number of times it appeared.
    for name, count in names.iteritems():
        sys.stdout.write("%d\t%s\n" % (count, name))


$ cat names.log | python namescount.py


The standard library of Python provides a CSV reader. The Python script below
completes this goal:


*py-cvs-reader*

#!/usr/bin/env python
# CSV module that comes with the Python standard library
import csv
import sys

if __name__ == "__main__":
    # The CSV module exposes a reader object that takes
    # a file object to read. In this example, sys.stdin.
    csvfile = csv.reader(sys.stdin)

    # The script should take one argument that is a column number.
    # Command-line arguments are accessed via sys.argv list.
    column_number = 0
    if len(sys.argv) > 1:
            column_number = int(sys.argv[1])

    # Each row in the CSV file is a list with each 
    # comma-separated value for that line.
    for row in csvfile:
            print row[column_number]


*py-stmplib*

#!/usr/bin/env python
import smtplib
import sys


GMAIL_SMTP_SERVER = "smtp.gmail.com"
GMAIL_SMTP_PORT = 587

GMAIL_EMAIL = "Your Gmail Email Goes Here"
GMAIL_PASSWORD = "Your Gmail Password Goes Here"


def initialize_smtp_server():
    '''
    This function initializes and greets the smtp server.
    It logs in using the provided credentials and returns 
    the smtp server object as a result.
    '''
    smtpserver = smtplib.SMTP(GMAIL_SMTP_SERVER, GMAIL_SMTP_PORT)
    smtpserver.ehlo()
    smtpserver.starttls()
    smtpserver.ehlo()
    smtpserver.login(GMAIL_EMAIL, GMAIL_PASSWORD)
    return smtpserver


def send_thank_you_mail(email):
    to_email = email
    from_email = GMAIL_EMAIL
    subj = "Thanks for being an active commenter"
    # The header consists of the To and From and Subject lines
    # separated using a newline character
    header = "To:%s\nFrom:%s\nSubject:%s \n" % (to_email,
            from_email, subj)
    # Hard-coded templates are not best practice.
    msg_body = """
    Hi %s,

    Thank you very much for your repeated comments on our service.
    The interaction is much appreciated.

    Thank You.""" % email
    content = header + "\n" + msg_body
    smtpserver = initialize_smtp_server()
    smtpserver.sendmail(from_email, to_email, content)
    smtpserver.close()


if __name__ == "__main__":
    # for every line of input.
    for email in sys.stdin.readlines():
            send_thank_you_mail(email)


*py-optionparser*

Thankfully, Python has a number of modules to deal with command-line arguments.
My personal favorite is OptionParser. OptionParser is part of the optparse
module that is provided by the standard library.

if __name__ == "__main__":
    usage = "usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("--email", dest="email",
            help="email to login to smtp server")
    parser.add_option("--pwd", dest="pwd",
            help="password to login to smtp server")
    parser.add_option("--smtp-server", dest="smtpserver",
            help="smtp server url", default="smtp.gmail.com")
    parser.add_option("--smtp-port", dest="smtpserverport",
            help="smtp server port", default=587)
    options, args = parser.parse_args()

    if not (options.email or options.pwd):
            parser.error("Must provide both an email and a password")

    smtpserver = initialize_smtp_server(options.stmpserver,
            options.smtpserverport, options.email, options.pwd)

    # for every line of input.
    for email in sys.stdin.readlines():
            send_thank_you_mail(email, smtpserver)
    smtpserver.close()


There are a lot of aspects to Python in the shell that go beyond the scope of
  this article, such as the os module and the subprocess module. The os module
  is a standard library function that holds a lot of key operating system-level
  operations, such as listing directories and stating files, along with an
  excellent submodule os.path that deals with normalizing directories paths. The
  subprocess module allows Python programs to run system commands and other
  advanced operations, such as handling piping as described above within Python
  code between spawned processes. Both of these libraries are worth checking out
  if you intend to do any Python shell scripting. 


={============================================================================
|kt_dev_py_0001| py-lib-sys

sys.exit([arg])

    Exit from Python. This is implemented by raising the SystemExit exception,
so cleanup actions specified by finally clauses of try statements are honored,
and it is possible to intercept the exit attempt at an outer level.

    The optional argument arg can be an integer giving the exit status
    (defaulting to zero), or another type of object. If it is an integer, zero
    is considered “successful termination” and any nonzero value is considered
    “abnormal termination” by shells and the like. Most systems require it to
    be in the range 0-127, and produce undefined results otherwise. Some
    systems have a convention for assigning specific meanings to specific exit
    codes, but these are generally underdeveloped; Unix programs generally use
    2 for command line syntax errors and 1 for all other kind of errors. If
    another type of object is passed, None is equivalent to passing zero, and
    any other object is printed to stderr and results in an exit code of 1. In
    particular, sys.exit("some error message") is a quick way to exit a
    program when an error occurs.

    Since exit() ultimately “only” raises an exception, it will only exit the
    process when called from the main thread, and the exception is not
    intercepted.


sys.argv

    The list of command line arguments passed to a Python script. argv[0] is
    the script name (it is operating system dependent whether this is a full
        pathname or not). If the command was executed using the -c command
    line option to the interpreter, argv[0] is set to the string '-c'. If no
    script name was passed to the Python interpreter, argv[0] is the empty
    string.

    To loop over the standard input, or the list of files given on the command
    line, see the fileinput module.

    note:
    argv[0] - len(argv[0]) is 1


={============================================================================
|kt_dev_py_0001| py-lib-subprocess

subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)

    Run the command described by args. Wait for command to complete, then
    return the returncode attribute.

    The arguments shown above are merely the most common ones, described below
    in Frequently Used Arguments (hence the slightly odd notation in the
        abbreviated signature). The full function signature is the same as
    that of the Popen constructor - this functions passes all supplied
    arguments directly through to that interface.

    Examples:

    >>> subprocess.call(["ls", "-l"])
    0

    >>> subprocess.call("exit 1", shell=True)
    1

    Warning
    Using shell=True can be a security hazard. See the warning under
    Frequently Used Arguments for details.

    Note
    Do not use stdout=PIPE or stderr=PIPE with this function as that can
    deadlock based on the child process output volume. Use Popen with the
    communicate() method when you need pipes.


={============================================================================
|kt_dev_py_0001| py-lib-built-in

2. Built-in Functions
The Python interpreter has a number of functions and types built into it that
are always available. They are listed here in alphabetical order.

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

    Print objects to the text stream file, separated by sep and followed by
    end. sep, end and file, if present, must be given as keyword arguments.
    All non-keyword arguments are converted to strings like str() does and
    written to the stream, separated by sep and followed by end. Both sep and
    end must be strings; they can also be None, which means to use the default
    values. If no objects are given, print() will just write end.  The file
    argument must be an object with a write(string) method; if it is not
    present or None, sys.stdout will be used. Since printed arguments are
    converted to text strings, print() cannot be used with binary mode file
    objects. For these, use file.write(...) instead.  Whether output is
    buffered is usually determined by file, but if the flush keyword argument
    is true, the stream is forcibly flushed.  Changed in version 3.3: Added
    the flush keyword argument.

<ex>
print "item in the list: %s" % item


={============================================================================
|kt_dev_py_0001| py-data-tuple

A tuple is a one-dimensional, `fixed-length`, `immutable` sequence of Python
objects. 


# The easiest way to create one is with a comma-separated sequence of values

>>> tup = 4,5,6
>>> tup
(4, 5, 6)


# necessary to enclose the values in `parentheses` to create a tuple of tuples:

>>> nested_tup=(4,5,6),(7,8)
>>> nested_tup
((4, 5, 6), (7, 8))


# Any sequence or iterator can be converted to a tuple by invoking tuple:

>>> tuple([4,5,6])
(4, 5, 6)

>>> string_tup=tuple('string')
>>> string_tup
('s', 't', 'r', 'i', 'n', 'g')


# Accessed with square brackets [] as with most other sequence types.
# Sequences are 0-indexed in Python:

>>> string_tup[0]
's'


# Once created it's not possible to modify which object is stored in each slot:

>>> tup
(4, 5, 6)
>>> tup[1]=7
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

note: WHY??

>>> tup=('foo', 'bar', 'baz')
>>> tup
('foo', 'bar', 'baz')
>>> tup=1,2,3
>>> tup
(1, 2, 3)
>>> tup=4,5,6,7
>>> tup
(4, 5, 6, 7)


# Can be concatenated using the + operator to produce longer tuples:

>>> long_tup = tup + nested_tup + string_tup
>>> long_tup
(4, 5, 6, (4, 5, 6), (7, 8), 's', 't', 'r', 'i', 'n', 'g')

note:
`tuple of tuple` so sequence can have different types.


{unpacking}
# If you try to assign to a tuple-like expression of variables, Python will
# attempt to unpack the value on the right-hand side of the equals sign:

>>> a,b,c = tup
>>> a
4
>>> b
5
>>> c
6


# Using this functionality it's easy to swap `variable names`, a task which in
# many languages might look like:
#
#   tmp = a
#   a = b
#   b = tmp

>>> a,b = b,a
>>> a
5
>>> b
4
>>> c
6


# One of the most common uses of variable unpacking when `iterating` over
# sequences of tuples or lists:

seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
for a, b, c in seq:
  pass


<method>
# Since the size and contents of a tuple cannot be modified, it is very light
# on instance methods. `count`, which counts the number of `occurrences` of a
# value:

>>> a=1,2,2,2,3,4,2
>>> a
(1, 2, 2, 2, 3, 4, 2)
>>> a.count(2)
4


<check>

>>> tup
('foo', 'bar', 'baz')
>>> 'bar' in tup
True


={============================================================================
|kt_dev_py_0001| py-data-list

In contrast with tuples, lists are `variable-length` and their contents can be
`modified`. They can be defined using `square brackets []` or using the `list`
type function:

Lists and tuples are semantically similar as one-dimensional sequences of
objects and thus can be used interchangeably in many functions.

>>> b_list=list(tup)
>>> b_list
['foo', 'bar', 'baz']


<adding-removing>

# Append to the end of the list with the `append` method and `insert` an
# element at a specific location in the list:

>>> b_list.append('dwarf')
>>> b_list
['foo', 'bar', 'baz', 'dwarf']
>>> b_list.insert(1,'red')
>>> b_list
['foo', 'red', 'bar', 'baz', 'dwarf']

note: 
insert is computationally `expensive` compared with append as references to
subsequent elements have to be shifted internally to make room for the new
element.


# `pop` removes and returns an element at a particular index:

>>> b_list.pop(2)
'bar'
>>> b_list
['foo', 'red', 'baz', 'dwarf']


# `remove` locates the first such value and removes it from the last:

>>> b_list
['foo', 'red', 'red', 'red', 'baz', 'dwarf']
>>> b_list.remove('red')
>>> b_list
['foo', 'red', 'red', 'baz', 'dwarf']


<check>
As with tuple.

note:
checking whether a list contains a value is a lot `slower` than dicts and sets
as Python makes a linear scan across the values of the list, whereas the
others (based on hash tables) can make the check in constant time.


<concatenation>
# Append multiple elements to it using the `extend` method:

>>> [4, None, 'foo'] + [7,8,(2,3)]
[4, None, 'foo', 7, 8, (2, 3)]

>>> x=[4, None, 'foo']
>>> x.extend([7,8,(2,3)])
>>> x
[4, None, 'foo', 7, 8, (2, 3)]

# list concatenation is a compartively `expensive` operation since a `new
# list` must be created and the objects copied over. Using extend is usually
# preferable.

everything = []
for chunk in list_of_lists:
  everything.extend(chunk)

is faster than than the concatenative alternative

everything = []
for chunk in list_of_lists:
  everything = everything + chunk


<sorting> 
A list can be sorted in-place (without creating a new object) by calling its
`sort` function:

>>> tup = 2,4,3,5,7,6
>>> tup
(2, 4, 3, 5, 7, 6)

>>> lst = [2,4,3,5,7,8]
>>> lst
[2, 4, 3, 5, 7, 8]

>>> tup.sort()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'tuple' object has no attribute 'sort'

>>> lst.sort()
>>> lst
[2, 3, 4, 5, 7, 8]


sort has a few options that will occasionally come in handy. One is the
  ability to pass a secondary `sort key`, i.e. a `function` that produces a
  value to use to sort the objects.

>>> lst = ['saw', 'small', 'He', 'foxes', 'six']
>>> lst
['saw', 'small', 'He', 'foxes', 'six']
>>> lst.sort(key=len)
>>> lst
['He', 'saw', 'six', 'small', 'foxes']


note: *py-module-bisect*

The built-in bisect module implements binary-search and insertion into a
sorted list. bisect.bisect finds the `location` where an element should be
inserted to keep it sorted, while bisect.insort actually `inserts` the element
into that location:

>>> import bisect

>>> c = [1,2,2,2,3,4,7]
>>> bisect.bisect(c,2)
4

>>> bisect.insort(c,6)
>>> c
[1, 2, 2, 2, 3, 4, 6, 7]

The bisect module functions do not check whether the list is sorted. Thus,
using them with an unsorted list will succeed without error but may lead to
incorrect results.


={============================================================================
|kt_dev_py_0001| py-data-slice

You can select sections of list-like types (arrays, tuples, NumPy arrays) by
using slice notation, which in its basic form consists of `start:stop` passed
to the `indexing operator []`:

>>> seq=[7,2,3,7,5,6,0,1]
>>> seq
[7, 2, 3, 7, 5, 6, 0, 1]

# (start, end] in C++ iterator notation.

>>> seq[1:1]
[]

>>> seq[1:2]
[2]

>>> seq[1:5]
[2, 3, 7, 5]

# inserted actually

>>> seq[3:4] = [6,3]
>>> seq
[7, 2, 3, 6, 3, 5, 6, 0, 1]

Either the start or stop can be omitted in which case they default to the
start of the sequence and the end of the sequence, respectively:


A `step` can also be used after a second colon

[7, 2, 3, 6, 3, 5, 6, 0, 1]
>>> seq[::2]
[7, 3, 3, 6, 1]

Negative indices slice the sequence relative to the end:

   H  E  L  L  O  !
   0  1  2  3  4  5  6
  -6 -5 -4 -3 -2 -1

A clever use of this is to pass -1 which has the useful effect of reversing a
list or tuple:

[7, 2, 3, 6, 3, 5, 6, 0, 1]
>>> seq[::-1]
[1, 0, 6, 5, 3, 6, 3, 2, 7]


={============================================================================
|kt_dev_py_0001| py-data-seq-function

Python has a handful of useful built-in sequence functions.

<enumerate>
When iterating over a sequence to want to keep track of the index of the
current item. Since this is so common, Python has a built-in function
`enumerate` which returns a sequence of (i, value) tuples:

for i, value in enumerate(collection):
  # do something with value


Useful `pattern` that uses enumerate is computing a dict mapping the values of
a sequence (which are assumed to be unique) to their locations in the
sequence:

>>> l
['one', 'two', 'three']
>>> mapping = dict((v,i) for i,v in enumerate(l))
>>> mapping
{'three': 2, 'two': 1, 'one': 0}


<sorted>
The sorted function returns a new sorted list from the elements of any
sequence. A common `pattern` for getting a sorted list of the `unique
elements` in a sequence is to combine sorted with set.

>>> [7,1,2,6,0,3,2,3,2]
[7, 1, 2, 6, 0, 3, 2, 3, 2]
>>> sorted([7,1,2,6,0,3,2,3,2])
[0, 1, 2, 2, 2, 3, 3, 6, 7]
>>> sorted(set([7,1,2,6,0,3,2,3,2]))
[0, 1, 2, 3, 6, 7]


<zip>
zip `pairs up` the elements of a number of lists, tuples, or other sequences,
    to create a list of tuples:

>>> seq1=['foo','bar','baz']
>>> seq2=['one','two','three']
>>> zip(seq1,seq2)
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]


A very common use of zip is for simultaneously `iterating over multiple`
sequences, possibly also combined with enumerate:

>>> for i, (a,b) in enumerate(zip(seq1,seq2)):
...     print('%d: %s, %s' % (i,a,b))
... 
0: foo, one
1: bar, two
2: baz, three


Given a zipped sequence, zip can be applied in a clever way to `unzip` the
sequence.  Another way to think about this is converting a list of rows into a
list of columns. The syntax, which looks a bit magical, is:

>>> zipped=zip(seq1, seq2)
>>> zipped
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
>>> names, numbers = zip(*zipped)
>>> names
('foo', 'bar', 'baz')
>>> numbers
('one', 'two', 'three')


<reversed>
`reversed` iterates over the elements of a sequence in reverse order:

>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> reversed(range(10))
<listreverseiterator object at 0xb753a8ec>
>>> list(reversed(range(10)))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]


={============================================================================
|kt_dev_py_0001| py-data-dict

A more common name for it is hash map or associative array. It is a
flexibly-sized collection of key-value pairs, where key and value are Python
objects. One way to create one is by using curly `braces` {} and using
`colons` to separate keys and values:

>>> d1={'a':'some value', 'b':[1,2,3,4]}
>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4]}


Elements can be accessed and inserted using the same syntax as accessing
elements of a list or tuple:

>>> d1[7]='an integer'
>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
>>> d1['b']
[1, 2, 3, 4]
>>> d1[b]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'three'
>>> 


Can check if a dict contains a key using the same syntax as with checking
whether a list or tuple contains a value:

>>> 'b' in d1
True


Values can be deleted either using the `del` keyword or the `pop` method
(which simultaneously returns the value and deletes the key):

>>> d1
{'a': 'some value', 'dummy': 'another value', 'b': [1, 2, 3, 4], 5: 'some value', 7: 'an integer'}
>>> del d1[5]
>>> d1
{'a': 'some value', 'dummy': 'another value', 'b': [1, 2, 3, 4], 7: 'an integer'}
>>> d1.pop('dummy')
'another value'
>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}


The `keys and values method` give you lists of the keys and values,
    respectively. While the key-value pairs are not in any particular order,
    these functions output the keys and values in the same order:

>>> d1.keys()
['a', 'b', 7]
>>> d1.values()
['some value', [1, 2, 3, 4], 'an integer']


One dict can be merged into another using the `update` method:

>>> d1
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
>>> d1.update({'b':'foo','c':12})
>>> d1
{'a': 'some value', 'c': 12, 'b': 'foo', 7: 'an integer'}

note: 'b' is overwritten.


<dict-from-sequence>
Common to occasionally end up with two sequences that you want to pair up
element-wise in a dict.

mapping = {}
for key, value in zip(key_list, value_list):
  mapping[key] = value

Since a dict is essentially a collection of 2-tuples, the dict type function
accepts a list of 2-tuples:

mapping = dict(zip(range(5), reversed(range(5))))
mapping
Out[454]: {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}


>>> l
['one', 'two', 'three']
>>> mapping = dict((v,i) for i,v in enumerate(l))
>>> mapping
{'three': 2, 'two': 1, 'one': 0}


<default-values>
Very common to have logic like:

if key in some_dict:
  value = some_dict[key]
else:
  value = default_value

Thus, the dict methods get and pop can take a default value to be returned, so
that the above if-else block can be written simply as:

value = some_dict.get(key, default_value)

`get` by default will return `None` if the key is not present, while `pop`
will raise an exception.


<other-collection-as-value>

>>> di={}
>>> di['b'] = ['apple', 'atom']
>>> di
{'b': ['apple', 'atom']}

With setting values, a common case is for the values in a dict to be other
collections, like lists. For example, you could imagine categorizing a list of
words by their first letters as a dict of lists:

>>> words=['apple', 'bat', 'bar', 'atom', 'book']
>>> by_letter={}
>>> for word in words:
...     letter = word[0]
...     if letter not in by_letter:
...             by_letter[letter] = [word]
...     else:
...             by_letter[letter].append(word)
... 
>>> by_letter
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}


The `setdefault` dict method is for precisely this purpose.

note: HOW does all work?

>>> by_letter={}
>>> words=['apple', 'bat', 'bar', 'atom', 'book']
>>> for word in words:
...     letter = word[0]
...     by_letter.setdefault(letter,[]).append(word)
... 
>>> by_letter
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}


The built-in `collections` module has a useful class, `defaultdict`, which makes
  this even easier. One is created by passing a type or function for
  generating the default value for each slot in the dict: 
  
from collections import defaultdict 
by_letter = defaultdict(list) 
for word in words:
  by_letter[word[0]].append(word) 
  

The initializer to defaultdict only needs to be a callable object (e.g. any
    function), not necessarily a type. Thus, if you wanted the default value
to be 4 you could pass a function returning 4

counts = defaultdict(lambda: 4)


<key-types>
While the values of a dict can be `any` Python object, the keys have to be
`immutable` objects like scalar types (int, float, string) or tuples (all the
    objects in the tuple need to be immutable, too). The technical term here
is `hashability`. You can check whether an object is hashable (can be used as
    a key in a dict) with the hash function:

>>> hash('string')
-1542666171
>>> hash((1,2,(2,3)))
1387206534
>>> hash((1,2,[2,3]))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'


To use a list as a key, an easy fix is to convert it to a tuple:

>>> d = {}
>>> d[tuple([1,2,3])]=5
>>> d
{(1, 2, 3): 5}


={============================================================================
|kt_dev_py_0001| py-data-set

A set is an `unordered` collection of unique elements. You can think of them
like dicts, but keys only, no values.

A set can be created in two ways:

>>> set([2,2,2,1,3,3])
set([1, 2, 3])

>>> {2,2,2,1,3,3}
set([1, 2, 3])


Sets support mathematical set operations like union, intersection, difference,
and symmetric difference.

>>> a = {1,2,3,4,5}
>>> b = {3,4,5,6,7,8}

# union(or)
>>> a | b
set([1, 2, 3, 4, 5, 6, 7, 8])

# intersection(and)
>>> a & b
set([3, 4, 5])

# difference
>>> a - b
set([1, 2])

# symmetric difference
>>> a ^ b
set([1, 2, 6, 7, 8])


>>> {1,2,3}.issubset(a)
True
>>> a.issuperset({1,2,3})
True
>>> {1,2,3} == {3,2,1}
True


={============================================================================
|kt_dev_py_0001| py-data-comprehension

`List comprehensions` are one of the most-loved Python language features. They
allow you to concisely form a new list `by filtering` the elements of a
collection and transforming the elements passing the filter in one conscise
expression. They take the basic form:

[`expr` for val in collection if `condition`]

This is equivalent to the following for loop:

result = []
for val in collection:
  if condition:
    result.append(expr)

The `filter condition` can be `omitted`, leaving only the expression. For
example, we could filter out strings with length 2 or less and also convert
them to uppercase like this:

>>> strings=['a', 'as', 'bat', 'car', 'dove', 'python']
>>> [x.upper() for x in strings if len(x) > 2]
['BAT', 'CAR', 'DOVE', 'PYTHON']


A `dict comprehension` looks like this:

dict_comp = { `key-expr:value-expr` for value in collection if `condition`}


A `set comprehension` looks like list comprehension except with curly braces
  instead of square brackets:

set_comp = {expr for value in collection if condition}


Comprehensions are just syntactic sugar, but they similarly can make code both
  easier to write and read.


Suppose we wanted a set containing just the lengths of the strings contained
in the collection; this could be easily computed using a set comprehension:

>>> unique_lengths = {len(x) for x in strings}
>>> unique_lengths
set([1, 2, 3, 4, 6])

Could create a lookup map of these strings to their locations in the list:

>>> loc_mapping = {val:index for index, val in enumerate(strings)}
>>> loc_mapping
{'a': 0, 'bat': 2, 'python': 5, 'car': 3, 'as': 1, 'dove': 4}

Note that this dict could be equivalently constructed by:

>>> loc_mapping2 = dict((val,index) for index, val in enumerate(strings))
>>> loc_mapping2
{'a': 0, 'bat': 2, 'python': 5, 'car': 3, 'as': 1, 'dove': 4}


={============================================================================
|kt_dev_py_0001| py-function

Functions are declared using the `def` keyword and returned from using the
`return` keyword:

def my_function(x, y, z=1.5):
  if z > 1:
    return z * (x + y)
  else:
    return z / (x + y)

If the end of a function is reached without encountering a return statement,
    `None` is returned.


Each function can have some number of `positional` arguments and some number
of `keyword` arguments. Keyword arguments are most commonly used to specify
default values or optional arguments. In the above function, x and y are
positional arguments while z is a keyword argument. This means that it can be
called in either of these equivalent ways:

my_function(5, 6, z=0.7)
my_function(3.14, 7, 3.5)

The main restriction on function arguments it that the keyword arguments must
follow the positional arguments (if any).


{namespace}
Functions can access variables in two different scopes: global and local. An
alternate and more descriptive name describing a variable scope in Python is a
namespace.


{return-multiple-values}
If you think about tuple packing and unpacking from earlier in this chapter,
   you may realize that what's happening here is that the function is actually
   just returning `one` object, namely a tuple, which is then being unpacked
   into the result variables.

>>> def f():
...     a=5
...     b=6
...     c=7
...     return a,b,c
... 
>>> a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined

>>> a,b,c = f()
>>> a
5
>>> b
6
>>> c
7


{functions-are-objects}
Since Python functions are objects, many constructs can be easily expressed
that are difficult to do in other languages.

Suppose we were doing some data cleaning and needed to apply a bunch of
transformations to the following list of strings:

>>> states = [' Alabama ', 'Georgia!', 'Georgia', 'georgia', 'FlOrIda', \
  'south carolina##', 'West virginia?']
>>> states
[' Alabama ', 'Georgia!', 'Georgia', 'georgia', 'FlOrIda', 'south carolina##',\
    'West virginia?']

>>> import re
>>> def clean_strings(strings):
...     result=[]
...     for value in strings:
                # these are `str` methods
...             value = value.strip()
...             value = re.sub('[!#?]', '', value)
...             value = value.title()
...             result.append(value)
...     return result
... 

# see address
>>> clean_strings
<function clean_strings at 0xb7509b1c>
>>> clean_strings(states)
['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South Carolina', 'West Virginia']


An alternate approach that you may find useful is to make a list of the
operations you want to apply to a particular set of strings:

>>> def remove_punctuation(value):
...     return re.sub('!?#', '', value)
... 
>>> clean_ops=[str.strip, remove_punctuation, str.title]

# see addresses
>>> clean_ops
[<method 'strip' of 'str' objects>, <function remove_punctuation at 0xb750979c>, 
  <method 'title' of 'str' objects>]

>>> def clean_strings_ops(strings, ops):
...     result=[]
...     for value in strings:
...             for function in ops:
...                     value = function(value)
...             result.append(value)
...     return result
... 

>>> states
[' Alabama ', 'Georgia!', 'Georgia', 'georgia', 'FlOrIda', 'south carolina##', 
  'West virginia?']

# WTF? oops since have error in remove_punctuation function.
>>> clean_strings_ops(states, clean_ops)
['Alabama', 'Georgia!', 'Georgia', 'Georgia', 'Florida', 'South Carolina', 'West Virginia?']

# going to work if define it again?
>>> def remove_punctuation(value):
...     return re.sub('[!?#]', '', value)
... 

# still not working?
>>> clean_strings_ops(states, clean_ops)
['Alabama', 'Georgia!', 'Georgia', 'Georgia', 'Florida', 'South Carolina', 'West Virginia?']

# define clean_ops again and see different address for remove_punctuation
>>> clean_ops
[<method 'strip' of 'str' objects>, <function remove_punctuation at 0xb750979c>, 
  <method 'title' of 'str' objects>]

>>> clean_ops=[str.strip, remove_punctuation, str.title]
>>> clean_ops
[<method 'strip' of 'str' objects>, <function remove_punctuation at 0xb7509e9c>, 
  <method 'title' of 'str' objects>]

>>> clean_strings_ops(states, clean_ops)
['Alabama', 'Georgia', 'Georgia', 'Georgia', 'Florida', 'South Carolina', 'West Virginia']


A more `functional pattern` like this enables you to easily modify how the
strings are transformed at a very high level. The clean_strings function is
also now more reusable!

Use functions as arguments to other functions like the built-in `map
function`, which applies a function to a collection of some kind:

>>> map(remove_punctuation, states)
[' Alabama ', 'Georgia', 'Georgia', 'georgia', 'FlOrIda', 
  'south carolina', 'West virginia']


{lambda}
Anonymous or lambda functions, which are really just simple functions
consisting of a single statement, the result of which is the return value.
They are defined using the `lambda keyword`

They are especially convenient in data analysis because, as you'll see, there
are many cases where data transformation functions will take functions as
arguments. It's often less typing (and clearer) to pass a lambda function as
opposed to writing a full-out function declaration or even assigning the
lambda function to a local variable. For example, consider this silly example:

>>> def apply_to_list(some_list, f):
...     return [f(x) for x in some_list]
... 

>>> ints = [4,0,1,5,6]
>>> apply_to_list(ints, lambda x: x*2)
[8, 0, 2, 10, 12]

You could also have written [x * 2 for x in ints], but here we were able to
succintly pass a custom operator to the apply_to_list function.


{closures}
In a nutshell, a closure is any `dynamically-generated function` returned by
another function. The key property is that the returned function has access to
the variables in the local namespace where it was created. Here is a very
simple example:

>>> def make_closure(a):
...     def closure():
...             print('I know the secret: %d' % a)
...     return closure
... 

>>> closure = make_closure(5)
>>> closure
<function closure at 0xb75125dc>
>>> closure()
I know the secret: 5
>>> closure()
I know the secret: 5


The difference between a closure and a regular Python function is that the
closure continues to have access to the namespace (the function) where it was
created, even though that function is done executing. So in the above case,
  the returned closure will always print "I know the secret: 5" whenever you
  call it. 

While it's common to create closures whose internal state (in this example,
    only the `value` of a) is `static`, you can just as easily have a
`mutable` object like a dict, set, or list that can be modified. For example,
  here's a function that returns a function that keeps track of arguments it
  has been called with:

def make_watcher():
  have_seen = {}

  def has_been_seen(x):
    if x in have_seen:
      return True
    else:
      have_seen[x] = True
      return False
  return has_been_seen

Using this on a sequence of integers I obtain:

In [496]: watcher = make_watcher()
In [497]: vals = [5, 6, 1, 5, 1, 6, 3, 5]
In [498]: [watcher(x) for x in vals]
Out[498]: [False, False, False, True, True, True, False, True]

one technical limitation to keep in mind is that while you can mutate any
internal state objects (like adding key-value pairs to a dict), you cannot
bind variables in the enclosing function scope. One way to work around this is
to modify a dict or list rather than binding variables:

>>> def make_counter():
...     count = [0]
...     def counter():
...             count[0] +=1
...             return count[0]
...     return counter
... 
>>> cnt = make_counter()
>>> cnt
<function counter at 0xb7512684>
>>> cnt()
1
>>> cnt()
2

>>> def make_counter_two():
...     count = 0
...     def counter():
...             count +=1
...             return count
...     return counter
... 
>>> cnt_two = make_counter_two()
>>> cnt_two
<function counter at 0xb75126f4>
>>> cnt_two()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 4, in counter
UnboundLocalError: local variable 'count' referenced before assignment


Why this is useful? In practice, you can write very `general functions` with
lots of options, then fabricate simpler, more specialized functions. Here's an
example of creating a string formatting function:


Here's an example of creating a string formatting function:

def format_and_pad(template, space):
  def formatter(x):
    return (template % x).rjust(space)
  return formatter

You could then create a floating point formatter that always returns a
length-15 string like so:

In [500]: fmt = format_and_pad('%.4f', 15)
In [501]: fmt(1.756)
Out[501]: ' 1.7560'

If you learn more about object-oriented programming in Python, you might
observe that these patterns also could be implemented (albeit more verbosely)
  using classes.


==============================================================================
Copyrightobjdump see |ktkb|                        vim:tw=100:ts=3:ft=help:norl:
