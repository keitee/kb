*kt_dev_sky_mw*                                                     tw=100, utf-8

/^[#=]{
Use #{ for a group and ={ for a item

Write what you know and konw what you write. - EXC++, Herb Sutter

An expert is a man who has made all the mistakes that can be made, in a very
narrow field. -Nils Bohr

TODO:
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. SKYMW

*kt_dev_skymw_0000* skymw-setup
*kt_dev_skymw_0000* skymw-pages
*kt_dev_skymw_0000* skymw-commands
*kt_dev_skymw_0000* skymw-git
*kt_dev_skymw_0000* skymw-q-hardware
*kt_dev_skymw_0000* skymw-q-package
*kt_dev_skymw_0000* skymw-build
*kt_dev_skymw_0000* skymw-as
*kt_dev_skymw_0000* skymw-as-airplay
*kt_dev_skymw_0000* skymw-bluez
*kt_dev_skymw_0000* skymw-bluez-ai
*kt_dev_skymw_0000* skymw-android
*kt_dev_skymw_0000* skymw-android-doc
*kt_dev_skymw_0000* skymw-android-studio
*kt_dev_skymw_0000* skymw-android-bluetoothrcu
*kt_dev_skymw_0000* skymw-android-ip150
*kt_dev_skymw_0000* skymw-luna
*kt_dev_skymw_0000* skymw-jira
*kt_dev_skymw_0000* skymw-todo


={============================================================================
*kt_dev_skymw_0000* skymw-setup

<tftp>
sudo apt-get install tftpd-hpa

cat /etc/default/tftpd-hpa 

# /etc/default/tftpd-hpa

TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/opt/tftpboot"
TFTP_ADDRESS=":69"
TFTP_OPTIONS="--secure"

<nfs>
sudo apt-get install nfs-kernel-server


<boot>
mount -o rw -t nfs 192.168.0.101:/home/keitee/mw/exports/titan/flash0 /mnt/x

// should be careful not to include the end of line when pasting it into bolt
// command line

setenv -p STARTUP "ifconfig eth0 -auto;boot 192.168.1.5:falcon_d1/zImage 'console=ttyS0,115200 ip=udhcp mesh=off vmalloc=334M brcm_cma_kern_rsv=416M remotedir=192.168.1.5:/export/flash0_falcon_d1'"

// shall have quote ""
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage"
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.101:/titan/zImage ‘remotedir=192.168.0.101:/home/keitee/mw/exports/titan/flash0'"
// setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage console=ttyS0,115200 ip=udhcp vmalloc=300M brcm_cma_kern_rsv=450M remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0"

// error since copied from word document and found that dash(-) causes the
// issue when used on bolt bootloader
setenv -p STARTUP "ifconfig eth0 –auto; boot 192.168.0.100:/titan/zImage ‘remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0'"

<ai-build-for-pc>
sudo apt-get install automake
sudo apt-get install libxslt-dev


={============================================================================
*kt_dev_skymw_0000* skymw-pages

https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=2016&title=Application+Infrastructure+Architecture


={============================================================================
*kt_dev_skymw_0000* skymw-commands

ls -al /opt/airplay/audio.out.pcm
touch /opt/airplay/audio.out.pcm; chmod 777 /opt/airplay/audio.out.pcm
rm /mnt/nds/dev_13/part_0/FSN_DATA/LOG

cp /mnt/nds/dev_13/part_0/FSN_DATA/LOG /flash0/LOG_07; chmod 777 /flash0/LOG_07
cp /opt/airplay/audio.out.pcm /flash0/PCM_31; chmod 777 /flash0/PCM_31

tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KT|AudioConverterDispose|AudioConverterNew"
tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KEY_P|Progress|rtpSkew"

curl -v -X POST http://127.0.0.1:8008/pm/downloads/ --data http://192.168.0.105/spotify.wgt

curl -v -X DELETE http://192.168.0.102:8008/pm/packages/com.spotify.Spotify.TVv2
curl -v -X GET http://192.168.0.102:8008/pm/packages
 
// to see ip
cat /proc/net/fib_trie


={============================================================================
*kt_dev_skymw_0000* skymw-git

<ssh>
to register ssh keys
https://www.stb.bskyb.com/gosa/

<git-repos>
git clone dwngit@git.stb.bskyb.com:ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-as-source ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-mw-wrt
git clone dwngit@git.stb.bskyb.com:appinfrastructure
git clone ssh://kyoupark@mgt-ip100-gerrit.skyqstbbuild.com:29418/sky/platform/packages/apps/SkyBluetoothRcu


<ethan-as-source>
// needs to run git pull since no default branch?
// "develop" branch

git pull origin develop

keitee@keitee-mint:~/mw/ethan-as-source$ git checkout develop
Checking out files: 100% (25967/25967), done.

// update submodule

keitee@keitee-mint:~/mw/ethan-as-source$ git submodule update --init --force

git push -n --set-upstream origin kit-NGDEV-141186

<git>
tag: NGDEV-141186_Delivered_Develop_07062019_1057
branch NGDEV-143556_IP100_Support_RCU_pairing_without_infrared

git checkout -b NGDEV-143556_review_03 develop
git push -n origin NGDEV-143556_IP100_Support_RCU_pairing_without_infrared
git push -f origin NGDEV-143556_review:NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_2
git push origin NGDEV-143556_review_03:NGDEV-143556_IP100_Support_RCU_pairing_without_infrared
NGDEV-143556_IP100_Support_RCU_pairing_without_infrared

// no permission to do
// git push origin --delete NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_2

// check the pushed branch
git diff origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_3 HEAD

// check update
git pull --rebase origin develop

// check difference
git log develop..HEAD

git rebase develop
git rebase --onto develop <topic>

git push -n origin HEAD:refs/for/release/2.2.0


<ex>
NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

Quote from
https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Bluetooth+RCU+Pairing+Without+Infrared:

In the v2.1.0 release of the SkyBluetoothRcu code for Android an experimental
feature was added in the debug builds to put the bluetooth code in 'searching'
mode for 30 seconds.  In search mode the code will look for any nearby BT RCU
devices that are in pairing mode, when / if found it will automatically start
pairing to it.   Only the first RCU found in pairing mode will trigger the STB
pairing code, subsequent found devices will be ignored (until 'searching' mode
is enalbed once again).

It works by looking for the special advertising packets sent by the BT RCU
when you hold the 1 and 3 buttons.  The BT RCU will send these special packets
for 10 seconds after entering pairing mode.


NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

Applies clang style, Mozilla, to files before a commit which has actual
changes so that can have clean base to show only differences to review. 



<git-message>
NGDEV-141186: TITAN SPECIFIC - AIRPLAY 2 - CODH:  Airplay Cerfication Assistant
- STB firmware version is not updated correctly on Get/info Automated Test
    
The AirPlay Certification Assistant reports wrong information which are reported
from a box and Product team clarify requirement about them. The keys in question
are:

firmwareRevision – This should be the current MW version eg Q100.XXX.XXX.XXX
keepAliveLowPower – Should this be 0 as we don't support WoL
keepAliveSendStatsAsBody - Should this be 0 as we don't support WoL
kAirPlayProperty_NameIsFactoryDefault

This commit fixes these values to report correct values and add support for
kAirPlayProperty_NameIsFactoryDefault to report correctly based on names of
AirPlay network. 

keitee@keitee-mint:~/mw/ethan-as-source/Components$ git diff --ignore-space-at-eol --stat origin/develop..HEAD
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayDelegate.c | 112 ++--------------------------------------------------------------------------------------
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.cpp   |  12 ++++++++++
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.h     |   4 +---
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c |   5 ++--
 // Components/AudioStreamer/AirplaySdk2/include/AirPlayPlayer.h                      |   5 +++-
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/daemon_cl                   | Bin 3284680 -> 3282536 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libAirPlay.a                | Bin 1390526 -> 1388298 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libAirPlayPlatform.a        | Bin 467130 -> 466692 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libCoreUtils.a              | Bin 4036690 -> 4025966 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libdns_sd.a                 | Bin 27338 -> 27338 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/mdnsd                       | Bin 326396 -> 326396 bytes
 // Components/AudioStreamer/source/AirPlayProtocol.cpp                               |  12 ++++++++++
 // Components/AudioStreamer/source/AirPlayProtocol.h                                 |   2 +-
 // Components/AudioStreamer/source/AudioStreamerPlayer.cpp                           |   6 ++---
 // Components/AudioStreamer/source/AudioStreamerPlayer.h                             |  11 +++++----
 Components/AudioStreamer/source/AudioStreamerProxy.cpp                            |   0
 Components/AudioStreamer/source/MwServices.cpp                                    |   8 +++----
 18 files changed, 53 insertions(+), 129 deletions(-)


={============================================================================
*kt_dev_skymw_0000* skymw-q-hardware

// q hardware
https://www.stb.bskyb.com/confluence/display/2016/Q+Platform+Hardware+Specifications


={============================================================================
*kt_dev_skymw_0000* skymw-q-package

// fusion mw
// Check the SI_TARBALL.tgz at the bottom of the page.
http://hudkinsartifactory.cisco.com:8081/artifactory/formal_builds/Q/formal/Q000/Q000.021.41.00/


={============================================================================
*kt_dev_skymw_0000* skymw-build

<to-fix-titan-build-error>
export LC_ALL=C

as: loadlocale.c:129: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))' failed.
arm-linux-gcc: internal compiler error: Aborted (program as)
Please submit a full bug report,
with preprocessed source if appropriate.
See <http://gcc.gnu.org/bugs.html> for instructions.


<skymw-build-as>

export LC_ALL=C

cd /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK

// download sdk from zork

./getSdk.sh eu-q-titan-uk HQ000

// type username/password for darwin intranet

./compile_sdkv2.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/ clean
./compile_sdkv3.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/

Creating object 
/home/keitee/mw/`ethan-as-source`/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/bskybgen2/SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/release_dbg/
/components/bskybgen2/appinfrastructure/XmlDSigVerifier/standalone/lib/source/VerificationRequest.o

// all points the same single file

ll eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
-rwxr-xr-x 1 keitee keitee 25M May 14 10:41 eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

// `to use ai-repo`
keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/THIRD_PARTY_LIBS_2/BSKYB_GEN2_APP_INFRASTRUCTURE$ ll
-rw-r--r--  1 keitee keitee   63 May 14 10:41 BSKYB_GEN2_APP_INFRASTRUCTURE_tag.txt
drwxr-xr-x 66 keitee keitee 4.0K May 14 10:41 AppInfrastructure_org/
lrwxrwxrwx  1 keitee keitee   51 Jul  9 15:41 AppInfrastructure -> /home/keitee/mw/appinfrastructure/AppInfrastructure/

// do not use submodule
// keitee@keitee-mint:~/mw/ethan-as-source$ git submodule
// 76d9c62d463b35364aa7b9bd5b18b18b0f5acc04 xSubmoduleAppInfrastructure (9.38.0-10-g76d9c62d4)


<build-tool> *builc-gcc*
~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gcc

lrwxrwxrwx 1 keitee keitee 31 May 14 10:41 arm-linux-gcc -> arm-unknown-linux-gnueabihf-gcc*

/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01

<gcc>
export LC_ALL=C
cp /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/unstripped_bin/APP_Process .
/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gdb


<fsi-build>
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/
svn checkout svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/

http://10.184.136.138:8081/view/SI%20build%20Jobs/job/FULL_STACK_SI_BUILD/69/consoleFull

+ cd FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials --baseline Q000.021.42.00

+ create_version_string_from_baseline
+ local VERSION_CFG=projects/bskybgen2/fs/NDS/config/overrides/version.cfg
+ local VERSION_H=projects/bskybgen2/inc/version.h
+ local 'VERSION_SECTION=[VERSION]'
+ local VERSION_TAG=NDS_SW_VERSION
+ local PLATFORM_TAG=PLATFORM
+ echo 'Checking & calculating Version string - '\''sky_trials'\'' '\'''\'''
Checking & calculating Version string - 'sky_trials' ''
python tools/nds/si/python/version_string_calculation.py ${PROFILE} ${BASELINE}
++ python tools/nds/si/python/version_string_calculation.py sky_trials
+ VERSION_STRING='~*~dev version~*~'
+ '[' 0 -ne 0 ']'
+ echo 'VERSION = ~*~dev version~*~'
VERSION = ~*~dev version~*~
+ echo '[VERSION]'
+ echo 'NDS_SW_VERSION="~*~dev version~*~"'
+ echo 'PLATFORM="eu-q-titan-uk"'


./build_mw_epg.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --nomake
./make_image.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --project bskybgen2


<skymw-build-ai>
// build full under AS but use ai from ai-repo

keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK$ pwd
/home/keitee/mw/appinfrastructure/xSubmoduleDarwinSDK

// see that use as
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK$ ll
lrwxrwxrwx  1 keitee keitee   66 Jul  1 15:53 eu-q-titan-uk -> /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk//

// build command
cd /home/keitee/mw/appinfrastructure/Tools/Jenkins
~/mw/appinfrastructure/Tools/Jenkins$ build-AI-fromSDKv2.sh eu-q-titan-uk /home/keitee/mw/appinfrastructure NO | tee build.log

// where can see compile outputs ??

Creating object /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/bskybgen2/SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/release_dbg/
/components/bskybgen2/appinfrastructure/BluetoothRcu/client/lib/source/BleRcuVoiceStreamSimDelegate.o

/home/keitee/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/bskybgen2/SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/release_dbg/
components/bskybgen2/appinfrastructure

keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk$ ls SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage
SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage


keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk$ pwd
/home/keitee/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk$ ll
total 24K
lrwxrwxrwx  1 keitee keitee   73 May 14 10:41 BSKYB_INTEGRATION_BLD.txt -> SDK/ReleaseNotes/BSKYB_INTEGRATION_BLD_21.35.00_BSKYB_HQ000_ETHAN_Int.txt
lrwxrwxrwx  1 keitee keitee   24 May 14 10:41 baseline_reasons.txt -> SDK/baseline_reasons.txt
drwxr-xr-x  5 keitee keitee 4.0K May 20 15:57 flash0/
drwxr-xr-x  2 keitee keitee 4.0K May 20 15:58 unstripped_bin/
drwxr-xr-x  5 keitee keitee 4.0K Jul  1 14:57 ./
drwxr-xr-x  3 keitee keitee 4.0K Jul  1 15:35 ../
drwxr-xr-x 35 keitee keitee 4.0K Jul  2 09:38 SDK/

// same
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK$
lrwxrwxrwx  1 keitee keitee   66 Jul  1 15:53 
eu-q-titan-uk -> /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk//

// to use `as-repo`
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/THIRD_PARTY_LIBRARIES/BSKYB_GEN2_AMS$ ll
-rw-r--r--  1 keitee keitee   47 May 14 10:41 BSKYB_GEN2_AMS_tag.txt
lrwxrwxrwx  1 keitee keitee   42 Jul  1 15:35 Components_org -> /home/keitee/mw/ethan-as-source/Components/
lrwxrwxrwx  1 keitee keitee   42 Jul 17 11:54 Components -> /home/keitee/mw/ethan-as-source/Components/

keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK$ ls -al flash0
flash0/                  flash0_sky_TITAN.tar.gz  flash0.tar.gz

cp -r flash0/ ~/mw/exports/titan/
cp -r /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/flash0 /home/keitee/mw/exports/titan


={============================================================================
*kt_dev_skymw_0000* skymw-as

https://www.stb.bskyb.com/confluence/pages/viewpage.action?pageId=9538192

<as-rest> <comp-asda>
http://build01.mw.ethan.bskyb.com/asda/#

192.168.0.104:9005

curl -v -X GET http://192.168.0.102:9005/as/system/information

curl -v -X GET http://192.168.0.102:8008/pm/packages

curl -v -X GET http://192.168.0.102:9005/peripherals/btremotes/edidinfo

curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Host: 192.168.0.102:9005" -H "Origin:" http://192.168.0.102:9005/as/peripherals/btremotes/status

// from curl
curl -v -X POST http://192.168.0.102:9005/as/peripherals/btremotes/action/startsearching?timeout=30

// from asda
peripherals/btremotes/action/startsearching?timeout=30

curl 192.168.0.102:9005/as/test/preferences -X POST --data '{"enableirinput":"false"}'

// 
{
   "remotes" : [
      {
         "batterylevel" : 90,
         "bdaddr" : "70:91:F3:22:6E:22",
         "btlswver" : "BL 195",
         "connected" : true,
         "deviceid" : 2387,
         "hwrev" : "102.0.0.1",
         "make" : "Universal Electronics, Inc.",
         "model" : "Sky EC102",
         "name" : "P047 SkyQ EC102",
         "rcuswver" : "7007.02.09",
         "serialno" : "226E22F39170"
      }
   ],
   "status" : "COMPLETE"
}

// 
{
   "remotes" : [
      {
         "batterylevel" : 73,
         "bdaddr" : "D4:B8:FF:12:E1:A8",
         "btlswver" : "2.0",
         "connected" : false,
         "deviceid" : 2615,
         "hwrev" : "101.2.0.0",
         "make" : "Omni Remotes",
         "model" : "EC101",
         "name" : "P236 SkyQ EC101",
         "rcuswver" : "1.0.5",
         "serialno" : "D4B8FF12E1A8"
      }
   ],
   "status" : "PAIRING"
}


={============================================================================
*kt_dev_skymw_0000* skymw-as-airplay

<as-airplay>
/ethan-as-source/Components/AudioStreamer

<airplay-setting>
http://192.168.0.102:13579/index.html

<airplay-sdk-build>
/ethan-as-source/Components/AudioStreamer/AirplaySdk2

export LC_ALL=C
make libraries platform=Titan

<airplay-logging>

// from apple and prints two lines

acs_ulog(kLogLevelNotice, "KT: AudioConverterReset: ALAC: DO NOTHING \n");

NDS: ^0000000694.438133 !MIL   -AS           < p:00000e12 t:6e754dc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 
  > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:34.438098 AM [AirPlayACS] 
  KT: AudioConverterReset: ALAC: DO NOTHING 

// works by default and on MIL

at_app_ulog(kLogLevelNotice, "KT: kAirPlayProperty_NameIsFactoryDefault = %d\n", value);
  #define at_app_ulog(LEVEL, ...) ulog(at_app_ucat(), (LEVEL), __VA_ARGS__)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/AccessorySDK/Support/LogUtils.c
int LogPrintF(LogCategory* inCategory, const char* inFunction, LogLevel inLevel, const char* inFormat, ...)
{
    int n;
    va_list args;

    va_start(args, inFormat);
    n = LogPrintV(inCategory, inFunction, inLevel, inFormat, args);
    va_end(args);
    return (n);
}


// print single line

TRACE("KT: integration::checkNameIsFactoryDefault:\n");
  #define TRACE(...) { LogInterfaceInToDiag(0,__VA_ARGS__);}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp
void LogInterfaceInToDiag(int level,const char*format,...)
{
  char buffer[256];
  va_list args;
  va_start (args, format);
  vsnprintf (buffer,256,format, args);
  va_end (args);
  if (interfaceLoggingFunction != NULL)
    interfaceLoggingFunction(level,buffer);
}

AudioStreamer::AirPlayProtocol::AirPlayProtocol(uint8_t macAddress[6])
    : m_audioAvailable(true)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
  ::memcpy (m_macAddress, macAddress, 6);
  AirPlay::Player::createInstance(this);
  AirPlay::Player::instance().registerAirplaySDKDiagLogFunction(AirplaySDKDiagLog);
  AirPlay::Player::instance().registerInterfaceDiagLogFunction(AirplayinterfaceDiagLog);
#ifdef ENABLE_AIRPLAY_2
  dobbyPTPLxc = std::make_shared<ptpdobbyfactory::PtpDobbyFactory>("PTPAirplay");
#endif

  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
}

void AirplayinterfaceDiagLog(int level ,const char* msg)
{
  (void) level;
  printf("2---%s \n ",msg);
}


// fusion diag
// home/keitee/mw/ethan-as-source/Components/AS/Diag/include/AS_DIAG_Macros.h

#define AS_LOG_FATAL(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_FATAL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Fatal,writeFatal,handleFatal,msg);} while (0)
#define AS_LOG_MIL(msg...)      do {do {AS_DECLARE_FUNCTION;DIAG_LOG_MIL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Mil,writeMil,handleMil,msg);} while (0)
#define AS_LOG_ERROR(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_ERROR(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Error,writeError,handleError,msg);} while (0)
#define AS_LOG_WARNING(msg...)  do {do {AS_DECLARE_FUNCTION;DIAG_LOG_WARN(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Warning,writeWarning,handleWarning,msg);} while (0)
#define AS_LOG_INFO(msg...)     do {do {AS_DECLARE_FUNCTION;DIAG_LOG_INFO(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Info,writeInfo,handleInfo,msg);} while (0)
#define AS_LOG_ENTRY(msg...)    AS_LOG_INFO(msg)
#define AS_LOG_EXIT(msg...)     AS_LOG_INFO(msg)

However, there seems to be an issue:
m_total shows 0. WHY?

    AUD_LOG_MIL("KT: get Data from buffer, sampleCount(%d), m_total(%d), dataToCopy(%d)", sampleCount, m_total, dataToCopy);
    AUD_LOG_MIL("KT: get Data from buffer, sampleCount(%d)", sampleCount);
    AUD_LOG_MIL("KT: get Data from buffer, m_total(%d)", m_total);

NDS: ^0000000222.561686 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(762) KT: get Data from buffer, sampleCount(0), m_total(0), dataToCopy(8820)
NDS: ^0000000222.561700 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(763) KT: get Data from buffer, sampleCount(0)
NDS: ^0000000222.561714 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(764) KT: get Data from buffer, m_total(8820)


<airplay-sdk>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayMain.c

int AirPlayMain( int argc, const char **argv )
{
  AirPlayReceiverServerCreate( &sgReceiverServer );

  AirPlayReceiverServerDelegateInit(&delegate);

  // register delegate to APRS
  delegate.copyProperty_f = _AirPlayHandleServerCopyProperty;
  delegate.setProperty_f = _AirPlayHandleServerSetProperty;
  delegate.sessionCreated_f = _AirPlayHandleSessionCreated;
  AirPlayReceiverServerSetDelegate(sgReceiverServer, &delegate);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c

AirPlayReceiverServerCreateWithConfigFilePath(CFStringRef inConfigFilePath, AirPlayReceiverServerRef* outServer)
{
}


// setup path

static OSStatus _HandleHTTPConnectionMessage(HTTPConnectionRef inCnx, HTTPMessageRef inRequest, void* inContext)
{
  aprs_ulog(kLogLevelTrace, "method:'%.*s' path:'%.*s'\n", (int)methodLen, methodPtr, (int)pathLen, pathPtr);

  else if (strnicmpx(methodPtr, methodLen, "SETUP") == 0)
    status = _requestProcessSetup(cnx, inRequest);
}

static HTTPStatus _requestProcessSetup(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
  status = _requestProcessSetupPlist(inCnx, inRequest);
}

static HTTPStatus _requestProcessSetupPlist(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
    aprs_ulog(kAirPlayPhaseLogLevel, "Setup (%##a)\n", &inCnx->httpCnx->peerAddr);
}

_requestCreateSession()
{
  AirPlayReceiverSessionCreate();
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c
AirPlayReceiverSessionCreate()
{
  err = AirPlayReceiverSessionPlatformInitialize(me);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c

OSStatus AirPlayReceiverServerPlatformInitialize(AirPlayReceiverServerRef inServer)
{}


// set audio stream

static OSStatus _UpdateStreams(AirPlayReceiverSessionRef inSession)
{
  atrp_ulog(kLogLevelNotice, "Main audio setting up %s for %@, input %s, loopback %s, volume:%f\n",
      AirPlayAudioFormatToString(streamCtx->format),
      streamCtx->audioType ? streamCtx->audioType : CFSTR(kAirPlayAudioType_Default),
      streamCtx->input ? "yes" : "no",
      streamCtx->loopback ? "yes" : "no",
      inSession->server->volume);

  // > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:37.199742 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-8.374125

  AudioStreamSetOutputCallback(streamCtx->stream, _AudioOutputCallBack, streamCtx);

  void AudioStreamSetOutputCallback(AudioStreamRef inStream, AudioStreamOutputCallback_f inFunc, void* inContext)
  {
    AudioStreamImpRef const me = _AudioStreamGetImp(inStream);
    TRACE("AudioStreamSetAudioCallback\n");

    me->callback = inFunc;
    me->callbackContext = inContext;
  }

  err = AudioStreamStart(streamCtx->stream);
}

// Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioUtilsStub.c
OSStatus AudioStreamPrepare(AudioStreamRef inStream)
{
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  _IMPL Trace.cpp(41) AudioStreamCreate
  _IMPL Trace.cpp(41) New AudioStreamPrivate=(nil)
  _IMPL Trace.cpp(41) AudioStreamSetAudioCallback
  _IMPL Trace.cpp(41) AudioStreamPrepare:
  _IMPL Trace.cpp(41) channels:      2
  _IMPL Trace.cpp(41) bits/channel:  16
  _IMPL Trace.cpp(41) sample rate:   44100
  _IMPL Trace.cpp(41) bytes/frame:   4
  _IMPL Trace.cpp(41) bytes/packet:  4
  _IMPL Trace.cpp(41) frames/packet: 1
  _IMPL Trace.cpp(41) format id:     6c70636d
  _IMPL Trace.cpp(41) format flags:  c
  _IMPL Trace.cpp(41) Signed
  _IMPL Trace.cpp(41) Little endian
  _IMPL Trace.cpp(41) audioSetFormat returning 1
}

OSStatus AudioStreamStart(AudioStreamRef inStream)
{
  // calls to intergration.cpp
  if( !sessionInitialize(inStream));
}


<airplay-config>

// AudioStreamer/config/audiostreamer.xml

 151   │    <!--NGDEV-140292:Update audiostreamer.xml to support Titan UK-->
 152   │    <profile name="EE_GW_UK_TITAN">
 153   │    <file name="audiostreamer.cfg">
 154   │    <section name="SYSTEM_DELAY_CONFIG">
 155   │     <key name="SYSTEM_DELAY" type="INTEGER" value="137">
 156   │         <comment date="2019/05/16 10:13:45" text="NGDEV-141515 The time in mS to provide system delay. This will be used in the calculation of inHostTime" />
 157   │     </key>
 158   │    </section>
 159   │    <section name="PCM_CONFIGURATION">
 160   │     <key name="PCM_BUFFERSIZE" type="INTEGER" value="100">
 161   │     <comment date="2017/01/19 01:23:45" text="The time in ms" />
 162   │     </key>
 163   │     <key name="PCM_THRESHOLD" type="INTEGER" value="50">
 164   │     <comment date="2017/01/19 01:23:45" text="The time in ms" />
 

<airplay-get-audio-data>

// AudioStreamer/source/AudioThread.cpp

case EVENT_SESSION_START:
{
  PLAYER_API_SessionHandle* sessionId = (PLAYER_API_SessionHandle*)t.data;

  string sourceUri = AsStringTool::stringf("audio/cisco.com_pcm;rate=%d;channels=%d;samplesize=%d;byteorder=%s;sign=%s", 
      m_format.sampleRate, m_format.channels, m_format.sampleSizeBytes*8, m_format.bigEndian?"be":"le", m_format.isSigned?"signed":"unsigned");
  AUD_LOG_MIL("AudioThread::EVENT_SESSION_START id=0x%08X, adding source='%s'", *sessionId, sourceUri.c_str());
  ret = PLAYER_API_AVControl_AddSourceBuffer(playerAvControl, sourceUri.c_str(), &m_avControlBufferHandle);
}

// CMS_MEDIA_SERVICES/MPM/inc/mpm_pres.h

/** @brief Structure that contains properties of a NEED_DATA callback for use in MPM_PRES_ES_EVENT_PROPERTIES */
typedef struct
{
    uint32_t    data_length;        /*!< @brief The amount of data that can be written to the device */
    uint32_t    current_level;      /*!< @brief The current buffer level on the output device */
    uint32_t    cumulative_bytes;   /*!< @brief The total amount of bytes written to this handle */
} MPM_PRES_ES_EVENT_NEED_DATA_PROPERTIES;

// DARWIN_PLATFORM/DARWIN_PLAYER/inc/player_api_events.h

#define PLAYER_EVENT_AUDIO_NEED_DATA                (0x22000000U)   
/**< Notification sent when the buffer created with PLAYER_API_AVControl_AddSourceBuffer needs more
 * data. Application should provide more data through PLAYER_API_AVControl_AppendToBuffer */

typedef struct
{
  uint32_t length;
  uint32_t buffer_level;
  uint32_t bytes_received;
} PLAYER_PRIV_EVENT_NEED_DATA;

ret = PLAYER_API_Session_RegisterEventListener(playerSession,PLAYER_EVENT_AUDIO_NEED_DATA,playerEventListener,PLAYER_API_TAG(this),&dataEventListenerHandle);

struct event_data_type
{
  uint32_t                 eventType;

  /* PLAYER_EVENT_AUDIO_NEED_DATA */
  uint32_t                 audioLength;
  uint32_t                 bufferLevel;
  uint32_t                 bytesReceived;

  /* PLAYER_EVENT_SESSION_START */
  PLAYER_API_SessionHandle sessionId;
};

handlePlayerEventNeedData(event_data, audioThread, event);

static void handlePlayerEventNeedData(event_data_type &event_data , AudioStreamer::AudioThread* audioThread,PLAYER_API_Event_Handle event)

audioThread->onPlayerNeedData(event_data.audioLength, event_data.bufferLevel, event_data.bytesReceived);

void AudioStreamer::AudioThread::onPlayerNeedData(uint32_t dataNeeded, uint32_t bufferLevel, uint32_t totalPlayed);

case EVENT_NEED_DATA:
  handlePlayerNeedData(arg->dataNeeded, arg->bufferLevel, arg->totalPlayed);

case EVENT_PUSH_DATA:
  pushDataToPlayer(arg->dataNeeded, arg->bufferLevel, arg->totalPlayed);

void AudioStreamer::AudioThread::pushDataToPlayer(uint32_t dataNeeded, uint32_t bufferLevel, uint32_t totalPlayed)
{
  currentInstance->audioBufferGet(sampleCount, UpTicks()+inHostTime, m_buffer, dataToCopy);
}

/*
 *AirPlayProtocol getAudioData
 *
 * inParam :
 *      sampleTime :- uint32_t , Time in terms of samples , mostly how many samples consumed till now indicate
 *                              how much time has elapsed. 4410 samples indicate 100ms
 *      hostTime      :- uint64_t , Approximate time when first sample will be played . Needs to as accurate as possible
 *                              and any variation of more than 5 ms will lead audio sync delay b/w apple devices
 *      buffer           :- void * , buffer memory allocated and managed by client
 *      bufferLen     :- size_t , length of buffer which also indicate the amount of data needs to be copied in bytes
 *
 * Function Breif :
 *       Get audio data from airplay SDK
 */
void AudioStreamer::AirPlayProtocol::getAudioData(uint32_t sampleTime, uint64_t hostTime, void *buffer, size_t bufferLen)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.cpp

void audioGetData(uint32_t sampleTime, uint64_t	hostTime, void *buffer, size_t bufferLen)
{
  TRACE("audioGetData(%d %llu %p %u)\n",  sampleTime, hostTime, buffer, bufferLen);

  s_audioStream->callback(sampleTime, hostTime, buffer, bufferLen, s_audioStream->callbackContext);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c
// callback is

static void
_AudioOutputCallBack(
    uint32_t inSampleTime,          // sample time
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    void* inContext)
{
  AirPlayAudioStreamPlatformContext* const streamCtx = (AirPlayAudioStreamPlatformContext*)inContext;
  OSStatus err;

  atrp_ulog(kLogLevelNotice, "KT: _AudioOutputCallBack: inLen(%d)\n", inLen);
  //  AM [AirPlay] KT: _AudioOutputCallBack: inLen(8820)

  err = AirPlayReceiverSessionReadAudio(streamCtx->session, streamCtx->activeType, 
      inSampleTime,                 // 3. sample time 
      inHostTime,
      inBuffer, 
      inLen);
  require_noerr(err, exit);

  if (streamCtx->input && streamCtx->loopback) {
    // not called in the log. use case?
    err = AirPlayReceiverSessionWriteAudio(streamCtx->session, streamCtx->activeType, inSampleTime, inHostTime,
        inBuffer, inLen);
    require_noerr(err, exit);
  }

exit:
  return;
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c

OSStatus
AirPlayReceiverSessionReadAudio(
    AirPlayReceiverSessionRef inSession,
    AirPlayStreamType inType,
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen)
{
  return AirPlayReceiverSessionReadAudio2(
      inSession, 
      inType, 
      inSampleTime, 
      inHostTime, 
      inBuffer, 
      inLen, 
      inLen,                  // 7
      NULL);
}

AirPlayReceiverSessionReadAudio2(
    AirPlayReceiverSessionRef inSession,
    AirPlayStreamType inType,
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    size_t inMinLen,          // 7
    size_t* outSuppliedLen)
{
  suppliedLen = _GeneralAudioRender(inSession, inSampleTime, inBuffer, inLen, inMinLen);
}

static size_t _GeneralAudioRender(
    AirPlayReceiverSessionRef inSession, 
    uint32_t inRTPTime,             // sample time
    void* inBuffer, 
    size_t inSize, 
    size_t inMinFillSize)
{
  // o inMinLen is date bytes for 50ms 
  //
  // o ctx->sampleTimeOffset is 0 so has no effect
  //
  // o srcTS = pktTS. what's unit?
  //
  // o minTS == limTS

  nowTS = inRTPTime - ctx->sampleTimeOffset;
  limTS = nowTS + (uint32_t)(inSize / bytesPerUnit);
  minTS = nowTS + (uint32_t)(inMinFillSize / bytesPerUnit);
  maxTS = limTS + kAirTunesRTPOffsetApplyThreshold;
  pktSeq = 0;

  // sample time
  //
  // #define kAirTunesPlayoutDelay 11025 // 250 ms delay to sync with AirPort Express'es 250 ms buffer.
  // inCnx->minLatency = kAirTunesPlayoutDelay; // Default value for old clients.
  //
  // AirPlayReceiverSessionSetProperty()
  //  gAirTunesRelativeTimeOffset = offset;

  inSession->audioLatencyOffset = inSession->minLatency + gAirTunesRelativeTimeOffset;

  // uint32_t rtpOffsetActive; // RTP offset actively in use (different when deferring).
  //
  // static void AirPlayReceiverFlushPackets(AirPlayReceiverSessionRef inSession, AirPlayFlushPoint const* flushFrom, AirPlayFlushPoint flushUntil)
  //  uint32_t offsetActive = inSession->source.rtpOffsetActive;
}


// start path

// AudioStreamer/source/AirPlayProtocol.cpp

void AudioStreamer::AirPlayProtocol::enable(uint16_t port)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::enable");
  if( !AirPlay::Player::instance().supported() )
  {
    AUD_LOG_WARNING("Airplay not supported on this box, cannot enable");
    return;
  }
  AUD_LOG_INFO("Airplay supported, enabling");
  AirPlay::Player::instance().startAirPlay();
  AirPlay::Player::instance().registerHttpService("/index.html", port);
  AUD_LOG_MIL("Enable airplay done");
  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::enable");
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp

void AirPlay::PlayerImpl::startAirPlay()
{
  if( !m_airplayRunning )
  {
    TRACE("ASDK0218. AirPlayStartMain()\n");
    AirPlayStartMain();
    m_airplayRunning=true;
  }
}


<airplay-progress>
NDS: ^0000000452.250604 !MIL   -AS           < p:00000de7 t:7a3fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplayinterfaceDiagLog L:00258 > 
  @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(41) Progress, duration 39 elapsed 9


={============================================================================
*kt_dev_skymw_0000* skymw-bluez

TODO:

1. Q version do not supports filtering byte on:
bool startPairing(quint8 pairingCode) override;

2. Q version calls BleRcuManager and Android version calls BleRcuAdapter.

<compare-both>
meld /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/blercu /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/blercu


={============================================================================
*kt_dev_skymw_0000* skymw-bluez-ai

<bluez-factory>

// Singletons/lib/source/FactoryContainer.cpp

std::shared_ptr<AI_BLERCU::IBleRcuContoller> FactoryContainer::getRcuControllerProxy() const
{
    return blercuFactory->createBleRcuControllerProxy();
}

FactoryContainer::FactoryContainer()
    : aiDmsFactory(AIDms::Factory::getSharedInstance())
    , aiConfig(std::make_shared<AppInfrastructureConfig>(aiDmsFactory))
    , sysInfo(new SystemInfo())
    , wsMediatorFactory(new WebSocketMediator::WebSocketMediatorFactory(SkyDefinitions::getWebsocketMediatorPorts()))
    , rmFactory(new RuntimeManagerFactory(aiConfig, sysInfo))
    , pmFactory(new PackageManagerFactory(aiConfig))
    , ampFactory(new ApplicationManagerProxy::Factory(aiConfig))
    , verifierFactory( new xmldsigverifier::Factory(aiConfig))
    , webServerFactory(new AppWebServerFactory())
    , softCatFactory(new SoftCatFactory(aiConfig))
    , applicationLaunchPolicyFactory(new ApplicationLaunchPolicyFactory(aiConfig))
    , jumperFactory(new jumper::JumperFactory())
    , dbusServerFactory(new AI_DBUS::DbusServerFactory())
    , aiDiagnosticsFactory(new AIDiagnostics::DiagnosticsFactory(aiConfig))
    , credentialsManagerFactory(new CredentialsManagerFactory())
    , upnpDiscoveryFactory(new UPnPDiscoveryFactory())

    , `blercuFactory(std::make_shared<AI_BLERCU::BleRcuFactory>())`

    , irrcuFactory(std::make_shared<AI_IRRCU::IrRcuFactory>())
    , netflixProxyFactory(std::make_shared<Netflix::Factory>())
    , terminalProxy(std::make_shared<AIDms::TerminalProxy>())
    {

      // setup the dbus daemon for apps to use
      std::shared_ptr<AI_DBUS::IDbusServer> dbusServerPublic =
        initAndStartDbusServer(AI_DBUS::DbusServerId::AI_PUBLIC);

      dbusServers[AI_DBUS::DbusServerId::AI_PRIVATE] = dbusServerPrivate;
      std::shared_ptr<AI_IPC::IIpcService> ipcServicePrivate =
        AI_IPC::createIpcService(dbusServerPrivate, IPC_SERVICE_APP_PROCESS);
      ipcServices[AI_DBUS::DbusServerId::AI_PRIVATE] = ipcServicePrivate;

      // create the BleRcu factory, which just launches the daemon (requires the system IPC service)
      blercuFactory->setLocale(aiDmsFactory->createLocale());

      `blercuFactory->setIpcService(ipcServicePrivate);`

      blercuFactory->setInputHandler(inputHandler);
      blercuFactory->startDaemon(dobbyProxy);

      // creates BleRcuContollerProxy
      blercuFactory->`createBleRcuControllerProxy`();
    }


// -----------------------------------------------------------------------------
/**
 * @brief Create RCU controller proxy object
 *
 *
 * @return the RCU controller proxy object, or null pointer in case of failure
 */
std::shared_ptr<IBleRcuContoller> BleRcuFactory::createBleRcuControllerProxy()
{
  // return the controller if we've already created it
  if (mController)
  {
    AI_LOG_FN_EXIT();
    return mController;
  }
}

// AppInfrastructure/Singletons/lib/source/Singletons.cpp

std::shared_ptr<AI_BLERCU::IBleRcuContoller> getBleRcuControllerProxyInstance()
{
    return FactoryContainer::getInstance().`getRcuControllerProxy`();
}


<bluez-as-observer>

// ethan-as-source/Components/AS/Services/Controllers/RcuController/source/AS_RCU_RcuControllerImplementation.h
// Components/AS/Services/Controllers/RcuController/source/AS_RCU_RcuControllerImplementation.cpp

class BluetoothRcuDeviceEventObserver : public AICommon::Observer<AI_BLERCU::IBleRcuDeviceEvent>
{
  public:
    /**
     * @brief Constructor
     *
     * @param[in] queue      : Pointer to queue
     */
    BluetoothRcuDeviceEventObserver( AS_WORKER::Queue *queue );

    /**
     * @brief Listener to be invoked when pairing state has changed
     *
     * @param[in] pairingInProgress      : Pairing state
     */
    void pairingStatusChanged( bool pairingInProgress );

    /**
     * @brief Listener to be invoked when rcu device properties has changed
     */
    void deviceListChanged();

  private:
    AS_WORKER::Queue *m_queue;                                ///< Pointer to queue
};


m_bluetoothRcuDeviceObserver = std::make_shared < BluetoothRcuDeviceEventObserver > (m_queue);

m_bluetoothRcuController = `getBleRcuControllerProxyInstance`();

m_bluetoothRcuController->addObserver( m_bluetoothRcuDeviceObserver );

std::pair<bool, std::vector<std::string>> manufacturers = 
`m_bluetoothRcuController->getDeviceManufacturers`( macaddress, manufacturer, searchFlags, (int64_t) 0, (int64_t) RCU_TOTAL_MANUFACTURER_TO_RETRIEVE, totalEntries );


void BleRcuContollerProxy::signalHandlerPropertiesChanged(const AI_IPC::VariantList& args)
{
  mDispatcher->post(std::bind(&BleRcuContollerProxy::notifyPairingStatusChanged, this, mPairing.load()));
}

void BleRcuContollerProxy::notifyPairingStatusChanged(bool pairing)
{
  notify( std::bind(&IBleRcuDeviceEvent::pairingStatusChanged, std::placeholders::_1, pairing) );
}

// ethan-as-source/Components/AS/Services/Controllers/RcuController/source/AS_RCU_RcuControllerImplementation.cpp
void BluetoothRcuDeviceEventObserver::pairingStatusChanged( bool pairingInProgress )
{ 
}


<bluez-controller-proxy> <ai-bluetooth-client-side>

COMPONENT_NAME := BleRcuClientLib

// BluetoothRcu/client/lib/include/BleRcuFactory.h

    std::map<std::string, std::shared_ptr<BleRcuDevice>> mRcuDevices;


// AppInfrastructure/Public/Common/Notifier.h

template<typename T>
class Notifier : virtual public Polymorphic
{
  /**
   * @brief Register interest in receiving updates.
   */
  void addObserver(const std::shared_ptr<T>& observer)
  {
    std::lock_guard<std::mutex> lock(m);
    observers.push_back(observer);
  }
}

// AppInfrastructure/Public/BluetoothRcu/IBluetoothRcu.h

class IBleRcuDeviceEvent : Interface
{
public:

    /**
     * @brief Pairing status changed notification
     *
     * @param pairingInProgress Pairing in progress or not.
     */
    virtual void pairingStatusChanged(bool pairingInProgress) = 0;

    /**
     * @brief Device list changed notification
     */
    virtual void deviceListChanged() = 0;
};

class IBleRcuContoller : public AICommon::`Notifier`<IBleRcuDeviceEvent>
{
public:

    /**
    * @brief Get JSON as defined in the AS spec
    */
    virtual Json::Value GetJsonRcuDeviceList() const = 0;

    /**
     * @brief Get information about the RCU devices
     */
    virtual std::vector<BleRcuDeviceProperties> getRcuDevices() const = 0;

    /**
     * @brief Start audio steaming
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     * @param type          [in]    Streaming type such as ADPCM or PCM
     *
     * @return If successful then the fd to read the audio data, otherwise a negative value to indicate error
     */
    virtual int startAudioStreaming(const std::string& rcuAddress, StreamAudioRequestType type) = 0;

    /**
     * @brief Stop audio steaming
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     *
     * @return If successful then true otherwise false
     */
    virtual bool stopAudioStreaming(const std::string& rcuAddress) = 0;


    /**
     * @brief Get audio streaming status
     *
     * @param rcuAddress     [in]     The address of the RCU to use for audio streaming
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the audio streaming if the method call is successful.
     */
    virtual std::pair<bool, BleRcuAudioStatus> getAudioStreamingStatus(const std::string& rcuAddress) = 0;

    /**
     * @brief Set IR codes
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     * @param deviceType    [in]    Device type such as TV or AMP
     * @param irCode        [in]    IR code to set
     *
     * @return If successful then true otherwise false
     */
    virtual bool setIRCode(const std::string& rcuAddress, IrSignalProfile deviceType, int32_t irCode ) = 0;

    /**
     * @brief Clear IR codes
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     *
     * @return If successful then true otherwise false
     */
    virtual bool clearIRCode(const std::string& rcuAddress) = 0;

    /**
     * @brief Set RCU mode
     *
     * @param rcuAddress    The address of the RCU to use for audio streaming
     * @param modesBitMask  Flags representing different RCU modes, see RcuMode
     *
     * @return If successful then true otherwise false
     */
    virtual bool setRcuMode(const std::string& rcuAddress, uint32_t modesBitMask) = 0;

    /**
     * @brief Get device models
     *
     * @param rcuAddress            [in]     The address of the RCU to use for audio streaming
     * @param deviceManufacturer    [in]     Name of the device manufacturer
     * @param deviceModelSearchText [in]     Search text indicating the hints about the model
     * @param searchFlagsBitMask    [in]     Search flags - see RcuDeviceSearchFlags
     * @param offset                [in]     Offset value in the search result
     * @param count                 [in]     Maximum number of entries requested
     * @param totalEntries          [out]    Maximum number of entries available
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (models) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<std::string>> getDeviceModels(
            const std::string& rcuAddress,
            const std::string &deviceManufacturer,
            const std::string &deviceModelSearchText,
            uint32_t searchFlagsBitMask,
            int64_t offset,
            int64_t count,
            uint64_t& totalEntries) = 0;

    /**
     * @brief Get device manufacturers
     *
     * @param rcuAddress                    [in]     The address of the RCU to use for audio streaming
     * @param deviceManufacturerSearchText  [in]     Search text indicating the hints about the model
     * @param searchFlagsBitMask            [in]     Search flags - see RcuDeviceSearchFlags
     * @param offset                        [in]     Offset value in the search result
     * @param count                         [in]     Maximum number of entries requested
     * @param totalEntries                  [out]    Maximum number of entries available
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (manufacturers) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<std::string>> getDeviceManufacturers(
            const std::string& rcuAddress,
            const std::string &deviceManufacturerSearchText,
            uint32_t searchFlagsBitMask,
            int64_t offset,
            int64_t count,
            uint64_t& totalEntries) = 0;

    /**
     * @brief Get manual input based IR codes
     *
     * @param rcuAddress          [in]     The address of the RCU to use for audio streaming
     * @param deviceManufacturer  [in]     Name of the device manufacturer
     * @param deviceModel         [in]     Name of the device model
     * @param searchFlagsBitMask  [in]     Search flags - see RcuDeviceSearchFlags
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (IR codes) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<int32_t>> getManualInputBasedIRCodes(
            const std::string& rcuAddress,
            const std::string &deviceManufacturer,
            const std::string &deviceModel,
            uint32_t searchFlagsBitMask ) = 0;

    /**
     * @brief Get manual input based IR codes
     *
     * @param rcuAddress     [in]     The address of the RCU to use for audio streaming
     * @param Edit           [in]     EDID data
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (IR codes) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<int32_t>> getEdidBasedIRCodes(
            const std::string& rcuAddress,
            const std::vector<uint8_t>& edit ) = 0;

    /**
     * @brief This method triggers the 'find me' beeping on the RCU.
     *
     * @param rcuAddress     [in]     The address of the RCU to use for audio streaming
     * @param beepLevel      [in]     Beep level
     * @param duration       [in]     Beep duration
     *
     * @return if successful then true else false. We need to check the validity of the future object prior to invoke its get method.
     **/
    virtual std::future<bool> findMe(const std::string& rcuAddress, FindMeBeepLevel beepLevel, int32_t duration) = 0;
};



// client/lib/source/BleRcuFactory.cpp
std::shared_ptr<IBleRcuContoller> BleRcuFactory::createBleRcuControllerProxy()
{
  try
  {
    mController = std::make_shared<BleRcuContollerProxy>(mIpcService, mInputHandler);
  }
}


// client/lib/source/BleRcuController.h

class `BleRcuContollerProxy` : public IBleRcuContoller
{
  /**
   * @brief Get information about the RCU devices
   */
  virtual std::vector<BleRcuDeviceProperties> getRcuDevices() const final;
};


// AppInfrastructure/BluetoothRcu/`client/lib/source/BleRcuController.cpp`

BleRcuContollerProxy::BleRcuContollerProxy(
    const std::shared_ptr<AI_IPC::IIpcService>& ipcService, const std::shared_ptr<IInputHandler>& inputHandler)

    : `mDispatcher(std::make_shared<AICommon::ThreadedDispatcher>("AI_BLERCU_PROXY"))`

  , mIpcService(ipcService)

{
  `setDispatcher(mDispatcher);`

  // #define BLE_RCU_CONTROLLER_OBJECT               "/com/sky/blercu/controller"
  // #define BLE_RCU_CONTROLLER_INTERFACE            "com.sky.blercu.Controller1"

  // for signals
  std::string handle = mIpcService->registerSignalHandler(
      AI_IPC::Signal(BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, "DeviceAdded"),
      std::bind(`&BleRcuContollerProxy::signalHandlerDeviceAdded`, this, std::placeholders::_1));

  // for properties
  handle = mIpcService->registerSignalHandler(
      AI_IPC::Signal(BLE_RCU_CONTROLLER_OBJECT, ORG_FREEDESKTOP_DBUS_PROPERTIES, "PropertiesChanged"),
      std::bind(`&BleRcuContollerProxy::signalHandlerPropertiesChanged`, this, std::placeholders::_1));
 
  //
  IInputHandler::KeyListenerV2 irListener = std::bind(
      `&BleRcuContollerProxy::onIrPairingCode`, this,
      std::placeholders::_1,  // event source
      std::placeholders::_2,  // filter byte
      std::placeholders::_3,  // key code
      std::placeholders::_4); // up/down state

  mIrListenerId = inputHandler->registerKeyListener
    (unsigned(IInputHandler::EventSource::Infrared), irListener, irPredicate);
}


BleRcuContollerProxy::~BleRcuContollerProxy()
{
  // can now safely stop the dispatcher
  mDispatcher->stop();
}


void BleRcuContollerProxy::signalHandlerDeviceAdded(const AI_IPC::VariantList& args)
{
  {
    std::string objectPath = boost::get<std::string>(args[0]);
    std::string address = boost::get<std::string>(args[1]);

    AI_LOG_INFO("Device added [object path: %s] [address: %s]", objectPath.c_str(), address.c_str());

    `mDispatcher->post`(std::bind(`&BleRcuContollerProxy::updateDeviceList`, this));
  }
}

void BleRcuContollerProxy::updateDeviceList()
{
  const AI_IPC::Method method(BLE_RCU_SERVICE, BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, 
      "GetDevices");

  AI_IPC::VariantList methodParams;
  AI_IPC::VariantList methodReturnValue;

  AI_LOG_INFO("Updating device list");

  if (mIpcService->invokeMethod(method, methodParams, methodReturnValue))
}

void BleRcuContollerProxy::addDevicesToDeviceList(const std::set<std::string>& objectPaths)
{
  for (const auto& objectPath : objectPaths)
  {
    AI_LOG_INFO("Add new device [object path: %s]", objectPath.c_str());

    try
    {
      mRcuDevices[objectPath] = std::make_shared<AI_BLERCU::BleRcuDevice>(
          mIpcService,
          mInputHandler,
          std::bind(`&BleRcuContollerProxy::notifyDevicePropertyChanged`, this),
          objectPath);
    }
    catch(const std::exception& e)
    {
      AI_LOG_ERROR("Failed to create device object [object path: %s]", objectPath.c_str());
    }
  }
}


*start-pairing*
// get input key and kicks off pairing request

void `BleRcuContollerProxy::onIrPairingCode`(
    IInputHandler::EventSource eventSource,
    uint8_t filterByte, 
    uint16_t keyCode, bool keyState)
{
  // unused - filter byte is used in the predicate before we get here
  (void)filterByte;

  // sanity check
  if ((keyCode & 0xff00) != (USER_INPUT_KEY_PAIRING_000 & 0xff00))
  {
    AI_LOG_ERROR_EXIT("odd, received non-pairing key code in callback");
    return;
  }

  const uint8_t pairingCode = (keyCode & 0x00ff);

  AI_LOG_MILESTONE("received IR pairing code %03hhu", pairingCode);

  mDispatcher->post(std::bind(
        &`BleRcuContollerProxy::triggerPairing`, this, pairingCode));
}

void `BleRcuContollerProxy::triggerPairing`(uint8_t pairingCode)
{
  // if the daemon is already signalling that pairing is running don't bother
  // trying to start it again
  if (mPairing)
  {
    AI_LOG_INFO("ignoring pairing request as already in pairing state");
    AI_LOG_FN_EXIT();
    return;
  }

  // #define BLE_RCU_SERVICE                         "com.sky.blercu"
  // #define BLE_RCU_CONTROLLER_OBJECT               "/com/sky/blercu/controller"
  // #define BLE_RCU_CONTROLLER_INTERFACE            "com.sky.blercu.Controller1"
  // #define ORG_FREEDESKTOP_DBUS_PROPERTIES         "org.freedesktop.DBus.Properties"
  // #define BLE_RCU_DEVICE_INTERFACE_DEVICE1        "com.sky.blercu.Device1"
  // #define BLE_RCU_DEVICE_INTERFACE_INFRARED1      "com.sky.blercu.Infrared1"

  const AI_IPC::Method method(
      BLE_RCU_SERVICE, 
      BLE_RCU_CONTROLLER_OBJECT, 
      BLE_RCU_CONTROLLER_INTERFACE, 
      `"StartPairing"`);

  AI_IPC::VariantList methodParams = {pairingCode};
  AI_IPC::VariantList methodReturnValue;

  `if (!mIpcService->invokeMethod(method, methodParams, methodReturnValue))`
  {
    AI_LOG_ERROR("Failed to invoke '%s.%s'", method.interface.c_str(), method.name.c_str());
  }
}


// BluetoothRcu/client/lib/source/BleRcuDevice.cpp
// each device also registers functions to dbus

BleRcuDevice::BleRcuDevice(const std::shared_ptr<AI_IPC::IIpcService>& ipcService,
                 const std::shared_ptr<IInputHandler>& inputHandler,
                 const std::function<void(void)>& notifyPropertyChanged,
                 const std::string& objectPath)
    : mIpcService(ipcService), 
    `mNotifyPropertyChanged(notifyPropertyChanged)`, 
    mObjectPath(objectPath)
{
  // #define ORG_FREEDESKTOP_DBUS_PROPERTIES         "org.freedesktop.DBus.Properties"

  mPropertyChangedSignalHandler = mIpcService->registerSignalHandler(
      AI_IPC::Signal(
        objectPath, 
        ORG_FREEDESKTOP_DBUS_PROPERTIES, 
        "PropertiesChanged"),
      std::bind(`&BleRcuDevice::signalHandlerPropertyChanged`, this, std::placeholders::_1));

  // and more
}

void BleRcuDevice::signalHandlerPropertyChanged(const AI_IPC::VariantList& args)
{
  /*org.freedesktop.DBus.Properties.PropertiesChanged (STRING interface_name,
    DICT<STRING,VARIANT> changed_properties,
    ARRAY<STRING> invalidated_properties)*/

  if (args.size() >= 2)
  {
    try
    {
      std::string interface = boost::get<std::string>(args[0]); //STRING interface_name
      if (interface == BLE_RCU_DEVICE_INTERFACE_DEVICE1)
      {
        std::map<std::string, AI_IPC::DictDataType> changedProperties = boost::get<std::map<std::string, AI_IPC::DictDataType>>(args[1]); //DICT<STRING,VARIANT> changed_properties,

        if ((!changedProperties.empty()) || (!invalidatedProperties.empty()))
        {
          updateDeviceProperties(changedProperties, invalidatedProperties);
          mNotifyPropertyChanged();
        }
      }
    }
  }
}

void BleRcuContollerProxy::notifyDevicePropertyChanged()
{
  `mDispatcher->post`(std::bind(&BleRcuContollerProxy::notifyDeviceListChanged, this));
}

void BleRcuContollerProxy::notifyDeviceListChanged()
{
  `notify`( std::bind(&IBleRcuDeviceEvent::deviceListChanged, std::placeholders::_1) );
}


<ai-bluetooth-console-side>

qWarning() << "KT: Console: dbusName: " << dbusName << ", serviceName: " << serviceName;

-sh-3.2# BleRcuConsole
KT: Console: 
  dbusName:  "com.sky.blercuconsole.pid6932" , 
  serviceName:  "com.sky.blercu"

[blercu]#


// console/source/main.cpp

int main(int argc, char *argv[])
{
  cmdHandler = QSharedPointer<BleRcuCmdHandler>::create(dbus, serviceName);
}

BleRcuCmdHandler::BleRcuCmdHandler(const QDBusConnection &bus,
                                   const QString &service,
                                   QObject *parent)
	: BaseCmdHandler(parent)
	, m_bus(bus)
	, m_serviceName(service)
{
  // initalise the dbus interfaces
  initBleRcuInterfaces(m_bus, m_serviceName,
      QStringLiteral("/com/sky/blercu/controller"));
}

void BleRcuCmdHandler::initBleRcuInterfaces(const QDBusConnection &bus,
                                            const QString &service,
                                            const QString &path)
{
  // get the controller interface which do the same as *bluez-controller-proxy*
  m_blercuController1 = 
    QSharedPointer<ComSkyBleRcuController1Interface>::create(service, path, bus);
}

void BleRcuCmdHandler::startPairing(quint8 pairingCode)
{
  if (!m_blercuController1 || !m_blercuController1->isValid()) {
    qWarning("Missing one or more required dbus interfaces");
    return;
  }

  // send the request to the daemon
  QDBusPendingReply<> reply = m_blercuController1->StartPairing(pairingCode);
  reply.waitForFinished();
  if (reply.isError())
    showDBusError(reply.error());
}


[blercu]# help
Available commands:
  connected-devices                                  List connected devices
  devices                                            List available devices
  exit                                               Quit program (same as quit)
  help                                               Display this text
  info <dev>                                         Device information
  ir-erase <dev>                                     Erases IR code(s) programmed into the rcu
  ir-get-codes <dev> <any/amp/tv> <manuf> <model>    Retreives a list of IR codes
  ir-get-manuf <dev> <any/amp/tv> <search> [sort]    Retreives a list of manufacturers
  ir-get-model <dev> <any/amp/tv> <manuf> <search>   Retreives a list of models
  ir-parse-edid <dev> [async] [edid]                 Parses the EDID sending back code list. If [edid] is supplied it should be hex string of 128 bytes
  ir-program <dev> <code> [signals...]               Programs the IR code(s) into the rcu
  ir-send <dev> <signal>                             Asks the RCU to send a given IR signal
  log-ethanlog [<on/off>]                            Gets / sets logging to ethan DIAG log
  log-level [fatal/error/warning/milestone/info/debug] Gets / sets the daemon log level
  log-syslog [<on/off>]                              Gets / sets logging to syslog
  pair <on/off> <code>                               Start/stop pairing using pairing byte code
  quit                                               Quit program


[blercu]# devices
Device 70:91:F3:22:BC:75 P039 SkyQ EC102
[blercu]# connected-devices
Device 70:91:F3:22:BC:75 P039 SkyQ EC102

[blercu]# connected-devices
Device D4:B8:FF:12:E1:A8 P066 SkyQ EC101

*dbus-monitor*
dbus-monitor "interface=com.sky.BleRcuDevice1"


void Console::initReadLine()
{
  m_readLine.setPrompt(m_cmdHandler->prompt());

  m_readLine.addCommand("devices", { }, "List available devices",
      this, &Console::onListDevicesCommand);

  // void BleRcuCmdHandler::listDevices()

  m_readLine.addCommand("connected-devices", { }, "List connected devices",
      this, &Console::onListConnectedDevicesCommand);
  // m_cmdHandler->listConnectedDevices();

  m_readLine.addCommand("pair", { "<on/off>", "<code>" }, "Start/stop pairing using pairing byte code",
      this, &Console::onStartPairingCommand);

  *start-pairing*
  // if (on)
  // 	m_cmdHandler->startPairing(pairingCode);
  //  { 
  //    QDBusPendingReply<> reply = m_blercuController1->StartPairing(pairingCode);
  //  }
  // else
  // 	m_cmdHandler->cancelPairing();

  // m_readLine.addCommand("unpair", { "<dev>" }, "Unpair device",
  //     this, &Console::onUnpairCommand);
  //
  // // m_cmdHandler->unPairDevice(address);
  // // qWarning("Not implemented on BLERCU interface");

  m_readLine.addCommand("info", { "<dev>" }, "Device information",
      this, &Console::onInfoCommand);

  // m_cmdHandler->deviceInfo(address);

  m_readLine.addCommand("log-level", { "[fatal/error/warning/milestone/info/debug]" }, "Gets / sets the daemon log level",
      this, &Console::onLogLevelCommand);

  // m_cmdHandler->setLogLevel(level);

  m_readLine.addCommand("log-syslog", { "[<on/off>]" }, "Gets / sets logging to syslog",
      this, &Console::onLogSyslogCommand);
  m_readLine.addCommand("log-ethanlog", { "[<on/off>]" }, "Gets / sets logging to ethan DIAG log",
      this, &Console::onLogEthanlogCommand);

  m_readLine.addCommand("hci-capture", { "[<on/off/clear/dump>] [file]" }, "Enables / disables / clear or dumps the HCI packet capture",
      this, &Console::onHciCaptureCommand);
}


<ai-bluetooth-daemon>

RCU_USR   5022  0.0  0.0   3224   548 ?        Ss   06:31   0:00 /opt/libexec/DobbyInit /opt/sbin/BleRcuDaemon --noconsole --session --netns=3 --audio-fifo-dir=/tmp/blercu/
RCU_USR   5056  0.0  0.2  48860  7036 ?        Sl   06:31   0:00 BleRcuDaemon --noconsole --session --netns=3 --audio-fifo-dir=/tmp/blercu/

// BleRcuDaemon started. address: , servicename: com.sky.blercu

// BluetoothRcu/daemon/source/main.cpp

int main(int argc, char *argv[])
{
  QCoreApplication app(argc, argv);
  QCoreApplication::setApplicationName("BleRcuDaemon");
  QCoreApplication::setApplicationVersion("2.0");

  // connect dbus
  QSharedPointer<QDBusConnection> dbusConn = 
    setupDBus(options->dbusType(),
      options->dbusAddress(),
      options->dbusServiceName());

  // setup and start the blercu controller object
  QSharedPointer<BleRcuController> controller =
    setupBleRcuController(options, config, irDatabase, dbusConn, debugDBusConn);
}

static QSharedPointer<QDBusConnection> setupDBus(CmdLineOptions::DBusType dbusType,
                                                 const QString &dbusAddress,
                                                 const QString &dbusServiceName)
{}

static QSharedPointer<BleRcuController> setupBleRcuController(const QSharedPointer<CmdLineOptions> &options,
                                                              const QSharedPointer<ConfigSettings> &config,
                                                              const QSharedPointer<IrDatabase> &irDatabase,
                                                              const QSharedPointer<QDBusConnection> &dbusConn,
                                                              const QSharedPointer<QDBusConnection> &debugDBusConn)
{
  *ai-bluetooth-ipc-service*
  // create the factory for generating BleRcuServices using the vendor
  // supplied IPC service
  QSharedPointer<IpcServicesFactory> ipcServicesFactory =
    QSharedPointer<IpcServicesFactory>::create(config,
        hidrawDevManager,
        QDBusConnection::systemBus(),
        options->audioFifoDirectory());

  *ai-bluetooth-device*
  // create the factory for generating BleRcuDevices
  QSharedPointer<BleRcuDeviceFactory> deviceFactory =
    QSharedPointer<BleRcuDeviceFactory>::create(*dbusConn, config,
        ipcServicesFactory,
        gattServicesFactory);

  *ai-bluetooth-manager*
  // create the manager object
  QSharedPointer<BleRcuManager> manager =
    QSharedPointer<BleRcuManagerImpl>::create(config,
        deviceFactory,
        QDBusConnection::systemBus());

  *ai-bluetooth-controller*
  // create the controller object
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(config, `manager`,
        options->networkNamespace());
  if (!controller || !controller->isValid()) {
    controller.reset();
    qFatal("failed to setup the BLE RCU controller");
  }

  // register on the controller on dbus
  controller->registerOnBus(*dbusConn);

  return controller;
}


<bluez-controller>
// BluetoothRcu/daemon/source/blercu/blercucontroller.cpp

class BleRcuControllerImpl : public BleRcuController
                           , public QDBusContext
{}

// BluetoothRcu/daemon/source/blercu/blercucontroller_p.h

	BleRcuPairingStateMachine m_pairingStateMachine;

BleRcuControllerImpl::BleRcuControllerImpl(const QSharedPointer<const ConfigSettings> &config,
                                           const QSharedPointer<BleRcuManager> &manager,
                                           int networkNamespaceFd,
                                           QObject *parent)

  , m_dbusObjectPath(QStringLiteral("`/com/sky/blercu/controller`"))
{
  // create and attach the dbus adaptor for the controller interface to
  // ourselves.
  m_dbusAdaptors.append(new `BleRcuController1Adaptor`(
        this // *pass-bluez-controller*
        , `m_dbusObjectPath`));
}

bool BleRcuControllerImpl::registerOnBus(const QDBusConnection &dbusConn)
{
  // strip the const'ness off the connection (bit of a hack)
  QDBusConnection dbusConn_(dbusConn);

  if (!dbusConn_.`registerObject`(`m_dbusObjectPath`.path(), this)) {
    qError("failed to register blercudevice adaptor object(s)");
    return false;
  }

  // tell all the adaptors that they're now registered on the bus, this is
  // used for property change notifications
  for (DBusAbstractAdaptor *adaptor : m_dbusAdaptors)
    adaptor->registerConnection(dbusConn);

  // we are now ready so emit a 'Ready' signal over dbus letting everyone know
  BleRcuController1Adaptor *adaptor = findChild<BleRcuController1Adaptor*>();
  if (!adaptor)
    qWarning("failed to find BleRcuController1Adaptor child");
  else
    emit adaptor->Ready();

  return true;
}


<bluez-controller-adaptor>

dbusxml/com.sky.blercu.Controller1.xml

{
  <interface name="com.sky.blercu.Controller1">

    <method name="StartPairing">
    <arg name="pairing_code" type="y" direction="in"/>
    </method>

    <method name="CancelPairing">
    </method>

    <method name="GetDevices">
    <arg name="devices" type="ao" direction="out"/>
    </method>

    <method name="IsReady">
    <annotation name="org.freedesktop.DBus.Method.NoReply" value="true"/>
    </method>

    <signal name="DeviceAdded">
    <arg name="path" type="o"/>
    <arg name="address" type="s"/>
    </signal>

    <signal name="DeviceRemoved">
    <arg name="path" type="o"/>
    <arg name="address" type="s"/>
    </signal>

    <signal name="Ready">
    </signal>

    <property name="Pairing" type="b" access="read"/>
    <property name="PairingCode" type="y" access="read"/>

    </interface>
}

// BluetoothRcu/daemon/source/blercu/adaptors/blercucontroller1_adaptor.h

class BleRcuController1Adaptor : public DBusAbstractAdaptor
{
  Q_OBJECT
    Q_CLASSINFO("D-Bus Interface", "com.sky.blercu.Controller1")
    Q_CLASSINFO("D-Bus Introspection", ""
        "  <interface name=\"com.sky.blercu.Controller1\">\n"
        "    <method name=\"Shutdown\"/>\n"
        "    <method name=\"StartPairing\">\n"
        "      <arg direction=\"in\" type=\"y\" name=\"pairing_code\"/>\n"
        "    </method>\n"
        "    <method name=\"CancelPairing\"/>\n"
        "    <method name=\"GetDevices\">\n"
        "      <arg direction=\"out\" type=\"ao\" name=\"devices\"/>\n"
        "    </method>\n"
        "    <method name=\"IsReady\">\n"
        "      <annotation value=\"true\" name=\"org.freedesktop.DBus.Method.NoReply\"/>\n"
        "    </method>\n"
        "    <signal name=\"DeviceAdded\">\n"
        "      <arg type=\"o\" name=\"path\"/>\n"
        "      <arg type=\"s\" name=\"address\"/>\n"
        "    </signal>\n"
        "    <signal name=\"DeviceRemoved\">\n"
        "      <arg type=\"o\" name=\"path\"/>\n"
        "      <arg type=\"s\" name=\"address\"/>\n"
        "    </signal>\n"
        "    <signal name=\"Ready\"/>\n"
        "    <property access=\"read\" type=\"b\" name=\"Pairing\"/>\n"
        "    <property access=\"read\" type=\"y\" name=\"PairingCode\"/>\n"
        "  </interface>\n"
        "")
  public:
        Q_PROPERTY(bool Pairing READ pairing)
          Q_PROPERTY(quint8 PairingCode READ pairingCode)

          ...
};


// BluetoothRcu/daemon/source/blercu/adaptors/blercucontroller1_adaptor.cpp

BleRcuController1Adaptor::BleRcuController1Adaptor(BleRcuController *parent,
                                                   const QDBusObjectPath &objPath)
  : DBusAbstractAdaptor(parent)
  , `m_controller(parent)` // *pass-bluez-controller* 
  , m_dbusObjPath(objPath)
{
  // don't auto relay signals, we do this manually
  setAutoRelaySignals(false);

  // connect to the device added and removed signals
  QObject::connect(m_controller, &BleRcuController::managedDeviceAdded,
      this, &BleRcuController1Adaptor::onDeviceAdded);
  QObject::connect(m_controller, &BleRcuController::managedDeviceRemoved,
      this, &BleRcuController1Adaptor::onDeviceRemoved);

  // connect to the pairing state change signals
  QObject::connect(m_controller, &BleRcuController::pairingStateChanged,
      this, &BleRcuController1Adaptor::onPairingStateChanged);
}

void BleRcuController1Adaptor::`StartPairing`(quint8 pairingCode,
                                            const QDBusMessage &message)
{
  // sanity check we're not already in the pairing state
  if (m_controller->isPairing()) {
    sendErrorReply(message, BleRcuError::errorString(BleRcuError::Busy),
        QStringLiteral("Already in pairing state"));
    return;
  }

  *start-pairing*
  // attempt to start pairing using the supplied code
  if (!`m_controller->startPairing`(pairingCode)) {

    const BleRcuError error = m_controller->lastError();
    sendErrorReply(message, error.name(), error.message());

  }
}


<ai-bluetooth-controller-property-change>

path : "`/com/sky/blercu/controller`"
iface: "com.sky.blercu.Controller1"

void BleRcuPairingStateMachine::onEnteredFinishedState()
{
  // finally just emit a finished signal to the BleRcuManagerImpl object
  emit finished();
}

BleRcuControllerImpl::BleRcuControllerImpl()
{
  QObject::connect(&m_pairingStateMachine, &BleRcuPairingStateMachine::finished,
      this, &BleRcuControllerImpl::onFinishedPairing,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onFinishedPairing()
{
  // tell clients that the pairing state is changed
  emit pairingStateChanged(pairing);
}

BleRcuController1Adaptor::BleRcuController1Adaptor(BleRcuController *parent)
{
	// connect to the pairing state change signals
	QObject::connect(m_controller, &BleRcuController::pairingStateChanged,
	                 this, &BleRcuController1Adaptor::onPairingStateChanged);
}

// daemon/source/blercu/adaptors/blercucontroller1_adaptor.cpp

void BleRcuController1Adaptor::onPairingStateChanged(bool pairing)
{
  `emitPropertyChanged(QStringLiteral("Pairing"), pairing);`
}

template <typename T>
void BleRcuController1Adaptor::emitPropertyChanged(const QString &propName,
    const T &propValue) const
{
  sendPropertyChangeNotification<T>(m_dbusObjPath.path(), propName, propValue);
}

// daemon/source/dbus/dbusabstractadaptor.h

bool sendPropertyChangeNotification(const QString &objectPath,
    const QString &propertyName,
    const T1 &propertyValue) const
{
  // send the signal on all dbus connections
  for (const QDBusConnection &dbusConn : `m_dbusConnections`) {
    if (!dbusConn.send(propChangeSignal))
      qWarning("failed to send property change notification signal");
  }
}

/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -p blercucontroller1_interface.h: ../dbusxml/com.sky.BleRcuController1.xml
 *
 * Proxy class for interface com.sky.BleRcuController1
 */
class ComSkyBleRcuController1Interface: public DBusAbstractInterface
{
  Q_PROPERTY(bool Pairing READ pairing NOTIFY pairingChanged)
    inline bool pairing() const
    { return qvariant_cast< bool >(property("Pairing")); }
};

void BleRcuCmdHandler::initBleRcuInterfaces()
{
  QObject::connect(m_blercuController1.data(), &ComSkyBleRcuController1Interface::pairingChanged,
      this, &BleRcuCmdHandler::onPairingStateChanged);
}


<ai-bluetooth-manager>

// BluetoothRcu/daemon/source/blercu/blercumanager.cpp

class BleRcuManager : public QObject
{}

bool BleRcuManagerImpl::attachAdapter(const QDBusObjectPath &adapterPath)
{
  // create a proxy to the 'org.bluez.Adapter1' interface on the adapter object
  m_adapterProxy = QSharedPointer<BluezAdapterInterface>::create(m_bluezService,
      adapterPath.path(),
      m_bluezDBusConn);

  // connect proxy to manager
  QObject::connect(m_adapterProxy.data(), &BluezAdapterInterface::discoveringChanged,
      this, &BleRcuManagerImpl::onAdapterDiscoveringChanged);
}


// BluetoothRcu/daemon/source/blercu/blercumanager_p.h

	StateMachine m_stateMachine;

BleRcuManagerImpl::BleRcuManagerImpl(const QSharedPointer<const ConfigSettings> &config,
                                     const QSharedPointer<IBleRcuDeviceFactory> &deviceFactory,
                                     const QDBusConnection &bluezBusConn,
                                     QObject *parent)

// BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.cpp

void BleRcuPairingStateMachine::setupStateMachine()
{
}


void BleRcuManagerImpl::onDeviceAdded(const QDBusObjectPath &path,
                                      const QVariantMap &properties)
{
  // so we now have all the params we need, create a device object to manage
  // the (RCU) device
  QSharedPointer<BleRcuDevice> device = `m_deviceFactory->create`(bdaddr, name,
      m_bluezDBusConn,
      path);

  // connect device to manager
  QObject::connect(device.data(), &BleRcuDevice::nameChanged,
      this, nameChangedFunctor);
  ...
}

QSharedPointer<BleRcuDevice> BleRcuDeviceFactory::create(const BleAddress &address,
  const QString &name,
  const QDBusConnection &bluezBusConn,
  const QDBusObjectPath &bluezObjPath,
  QObject *parent) const
{
  *ai-bluetooth-device*
  QSharedPointer<BleRcuDevice> device =

    serviceFactory is *ai-bluetooth-ipc-service*
    QSharedPointer<BleRcuDeviceImpl>::create(serviceFactory,
        bluezBusConn,
        bluezObjPath,
        address,
        name,
        parent);

  // FIXME: the registration of the device on dbus should really be handled
  // in the BleRcuController object as that handles the master list of
  // managed devices we expose to clients.
  if (!device || !device->isValid() || !device->registerOnBus(m_dbusConn))
    device.reset();

  return device;
}


<ai-bluetooth-device>

// daemon/source/blercu/blercudevice.cpp

QSharedPointer<BluezDeviceInterface> m_deviceProxy;

QSharedPointer<BleRcuServices> m_services;

QList<DBusAbstractAdaptor*> m_blercuAdaptors;

BleRcuDeviceImpl::BleRcuDeviceImpl(const QSharedPointer<IBleRcuServicesFactory> &servicesFactory)
{
  // initialise the dbus interface to bluez
  (!init(bluezDBusConn, bluezDBusPath))
  {
    // create a proxy to the 'org.bluez.Device1' interface on the device object
    m_deviceProxy =
      QSharedPointer<BluezDeviceInterface>::create(QStringLiteral("org.bluez"),
          bluezDBusPath.path(),
          bluezDBusConn);

    // connect to the property change notifications from the daemon
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::connectedChanged,
        this, &BleRcuDeviceImpl::onDeviceConnectedChanged);
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::pairedChanged,
        this, &BleRcuDeviceImpl::onDevicePairedChanged);
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::servicesResolvedChanged,
        this, &BleRcuDeviceImpl::onDeviceServicesResolvedChanged);
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::nameChanged,
        this, &BleRcuDeviceImpl::onDeviceNameChanged);
  }

  *ai-bluetooth-device*
  // create ourselves a dbus object path
  const QString objPath = 
    QString::asprintf("/com/sky/blercu/device_%02hhX_%02hhX_%02hhX_%02hhX_%02hhX_%02hhX",
        m_address[0], m_address[1], m_address[2],
        m_address[3], m_address[4], m_address[5]);

  // register this on dbus
  `m_blercuObjectPath.setPath(objPath);`

  m_blercuAdaptors.append( new BleRcuDevice1Adaptor(this, m_blercuObjectPath) );
}

bool BleRcuDeviceImpl::registerOnBus(const QDBusConnection &dbusConn)
{
  if (!dbusConn_.`registerObject`(m_blercuObjectPath.path(), this)) {
    qError("failed to register blercudevice adaptor object(s)");
    return false;
  }

  // tell all the adaptors that they're now registered on the bus, this is
  // used for property change notifications
  for (DBusAbstractAdaptor *adaptor : m_blercuAdaptors)
    adaptor->registerConnection(dbusConn);
}

// daemon/source/blercu/adaptors/blercudevice1_adaptor.h

/*
 * Adaptor class for interface com.sky.BleRcuDevice1
 */
class BleRcuDevice1Adaptor : public DBusAbstractAdaptor
{
	Q_OBJECT
	Q_CLASSINFO("D-Bus Interface", "com.sky.blercu.Device1")
	Q_CLASSINFO("D-Bus Introspection", "")
};


// daemon/source/dbus/dbusabstractadaptor.cpp

class DBusAbstractAdaptor : public QDBusAbstractAdaptor

void DBusAbstractAdaptor::registerConnection(const QDBusConnection &connection)
{
  `m_dbusConnections`.append(connection);
}


<call-from-client-such-as-startpairing>

keitee@keitee-mint:~/mw/appinfrastructure/AppInfrastructure/BluetoothRcu$ ag StartPairing


console/source/blercu/blercucontroller1_interface.h
67:     inline QDBusPendingReply<> StartPairing(quint8 pairing_code)
71:             return asyncCallWithArgumentList(QStringLiteral("StartPairing"), argumentList);

  console/source/console.h
  44:     void onStartPairingCommand(const QStringList &args);
  
  console/source/console.cpp
  46:                           this, &Console::onStartPairingCommand);
  164:void Console::onStartPairingCommand(const QStringList &args)
  
  console/source/blercu_cmdhandler.cpp
  304:    QDBusPendingReply<> reply = m_blercuController1->StartPairing(pairingCode);


client/test/source/BlueRcuProxyTest.cpp
410:            Method method6(BLE_RCU_SERVICE, BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, "StartPairing");
411:            regId = mIpcRcuDaemonService->registerMethodHandler(method6, std::bind(&BleRcuContollerProxyTest::methodHandlerStartPairing, this, std::placeholders::_1));
659:    void methodHandlerStartPairing(std::shared_ptr<IAsyncReplySender> replySender)

client/lib/source/BleRcuController.cpp
755:    const AI_IPC::Method method(BLE_RCU_SERVICE, BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, "StartPairing");


  daemon/test/source/tst_blercucontrolleradaptor.cpp
  226:TEST_F(BleRcuControllerAdaptorTest, testStartPairing)
  233:            QDBusMessage request = QDBusMessage::createMethodCall("", m_deviceObjPath, m_interfaceName, "StartPairing");
  252:            QDBusMessage request = QDBusMessage::createMethodCall("", m_deviceObjPath, m_interfaceName, "StartPairing");
  271:            QDBusMessage request = QDBusMessage::createMethodCall("", m_deviceObjPath, m_interfaceName, "StartPairing");

daemon/source/blercu/adaptors/blercucontroller1_adaptor.cpp
135:    DBus method call handler for com.sky.BleRcuController1.StartPairing
138:void BleRcuController1Adaptor::StartPairing(quint8 pairingCode,

daemon/source/blercu/adaptors/blercucontroller1_adaptor.h
27:                 "    <method name=\"StartPairing\">\n"
64:     void StartPairing(quint8 pairingCode, const QDBusMessage &message);
keitee@keitee-mint:~/mw/appinfrastructure/AppInfrastructure/BluetoothRcu$


<ai-bluetooth-log>
18685:NDS: ^0000000141.602695 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercumanager.cpp F:onAdapterPowerChanged L:00856 > BT adapter powered on
18687:NDS: ^0000000141.617348 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving to state Idle(0)"
18688:NDS: ^0000000141.618547 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercumanager.cpp F:onDeviceAdded L:01459 > added device 70:91:F3:22:BC:75 named "P039 SkyQ EC102" (connected: false paired: true)
18689:NDS: ^0000000141.618594 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:name L:00878 > KT: BleRcuDeviceImpl: name  P039 SkyQ EC102
18690:NDS: ^0000000141.620675 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:onDevicePairedChanged L:00482 > 70:91:F3:22:BC:75 paired
18691:NDS: ^0000000141.620833 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state Idle(0) to Paired(1)"
21866:NDS: ^0000000157.009252 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:onDeviceConnectedChanged L:00456 > 70:91:F3:22:BC:75 connected
21867:NDS: ^0000000157.009296 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state Paired(1) to ResolvingServices(3)"
21886:NDS: ^0000000157.854269 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:hidrawdevicemanager.cpp F:syncHidRawDeviceMap L:00293 > hidraw device @ "/hostdev/hidraw0" with physical address "70:91:f3:22:bc:75" has been added
22356:NDS: ^0000000158.154419 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:onDeviceServicesResolvedChanged L:00511 > 70:91:F3:22:BC:75 services resolved
22357:NDS: ^0000000158.154459 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state ResolvingServices(3) to StartingServices(8)"
22359:NDS: ^0000000158.590546 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:.  L:00000 > bluetooth rcu device info [ Universal Electronics, Inc. / Sky EC102 / hw:102.0.0.1 / fw:BL 195 / sw:7007.02.09 ]
22360:NDS: ^0000000158.791891 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state StartingServices(8) to ReadyState(9)"
22361:NDS: ^0000000158.792324 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercumanager.cpp F:onDeviceReadyChanged L:01685 > device with address 70:91:F3:22:BC:75 is  ready


={============================================================================
*kt_dev_skymw_0000* skymw-android

1. android studio
https://developer.android.com/studio/install

2. adb, Android Debug Bridge

3. ninja-build, to build from android studio
Ninja is a small build system with a focus on speed. It differs from other
build systems in two major respects: it is designed to have its input files
generated by a higher-level build system, and it is designed to run builds as
fast as possible.

4. qt.


={============================================================================
*kt_dev_skymw_0000* skymw-android-doc

https://developer.android.com/reference
https://developer.android.com/reference/android/app/Activity.html


={============================================================================
*kt_dev_skymw_0000* skymw-android-service

https://developer.android.com/guide/components/services.html

A Service is an application component that can perform long-running operations
in the background, and it doesn't provide a user interface. Another application
component can start a service, and it continues to run in the background even if
the user switches to another application. Additionally, a component can bind to
a service to interact with it and even perform interprocess communication (IPC).
For example, a service can handle network transactions, play music, perform file
I/O, or interact with a content provider, all from the background.

Bound

A service is bound when an application component binds to it by calling
bindService(). A bound service offers a client-server interface that allows
components to interact with the service, send requests, receive results, and
even do so across processes with interprocess communication (IPC). A bound
service runs only as long as another application component is bound to it.
Multiple components can bind to the service at once, but when all of them
unbind, the service is destroyed.


https://developer.android.com/guide/components/bound-services.html#Binder

Creating a bound service

When creating a service that provides binding, you must provide an IBinder that
provides the programming interface that clients can use to interact with the
service. There are three ways you can define the interface:

Using AIDL

Android Interface Definition Language (AIDL) decomposes objects into primitives
that the operating system can understand and marshals them across processes to
perform IPC. The previous technique, using a Messenger, is actually based on
AIDL as its underlying structure. As mentioned above, the Messenger creates a
queue of all the client requests in a single thread, so the service receives
requests one at a time. If, however, you want your service to handle multiple
requests simultaneously, then you can use AIDL directly. In this case, your
service must be thread-safe and capable of multi-threading.  To use AIDL
directly, you must create an .aidl file that defines the programming interface.
The Android SDK tools use this file to generate an abstract class that
implements the interface and handles IPC, which you can then extend within your
service.

Note: Most applications shouldn't use AIDL to create a bound service, because it
may require multithreading capabilities and can result in a more complicated
implementation. As such, AIDL is not suitable for most applications and this
document does not discuss how to use it for your service. If you're certain that
you need to use AIDL directly, see the AIDL document.


https://developer.android.com/guide/components/aidl#java

Defining an AIDL interface

You must define your AIDL interface in an .aidl file using the Java programming
language syntax, then save it in the source code (in the src/ directory) of both
the application hosting the service and any other application that binds to the
service.

When you build each application that contains the .aidl file, the Android SDK
tools generate an IBinder interface based on the .aidl file and save it in the
project's gen/ directory. The service must implement the IBinder interface as
appropriate. The client applications can then bind to the service and call
methods from the IBinder to perform IPC.

Implement the interface

The Android SDK tools generate an interface in the Java programming language,
based on your .aidl file. This interface has an inner abstract class named Stub
  that extends Binder and implements methods from your AIDL interface. You must
  extend the `Stub class and implement the methods`

Expose the interface to clients

Implement a Service and override onBind() to return your implementation of the
Stub class.

public class BleRcuService extends Service {

	public boolean registerService() {

		final String serviceName = "com.sky.blercuservice";

		Method method = null;
		try {
			method = Class.forName("android.os.ServiceManager").getMethod("addService", String.class, IBinder.class);

			method.invoke(null, serviceName, new BleRcuServiceBinder(this));
      }
   }

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {
  }
}

When you build your application, the Android SDK tools generate a .java
interface file named after your .aidl file. The generated interface includes a
subclass named Stub that is an abstract implementation of its parent interface
(for example, YourInterface.Stub) and declares all the methods from the .aidl
file.

Note: Stub also defines a few helper methods, most notably asInterface(), which
takes an IBinder (usually the one passed to a client's onServiceConnected()
    callback method) and returns an instance of the stub interface. See the
section Calling an IPC Method for more details on how to make this cast.

To implement the interface generated from the .aidl, extend the generated Binder
interface (for example, YourInterface.Stub) and implement the methods inherited
from the .aidl file.

Here is an example implementation of an interface called IRemoteService (defined
    by the IRemoteService.aidl example, above) using an anonymous instance:


<android-surface>
https://developer.android.com/reference/android/view/SurfaceView.html


={============================================================================
*kt_dev_skymw_0000* skymw-android-studio

https://developer.android.com/training/basics/firstapp/creating-project

{navigation}

Here are some tips to help you move around Android Studio.

Recent Files

Switch between your recently accessed files using the Recent Files action. Press
`Control+E` (Command+E on a Mac) to bring up the Recent Files action. By
default, the last accessed file is selected. You can also access any tool window
through the left column in this action.


File Structure

View the structure of the current file using the File Structure action. Bring up
the File Structure action by pressing `Control+F12` (Command+F12 on a Mac).
Using this action, you can quickly navigate to any part of your current file.

Find all the pieces of code referencing the class, method, field, parameter, or
statement at the current cursor position by pressing Alt+F7 (Option+F7 on a
Mac).


Find in path

`Control + Shift + F`

<global-search>
Global Search

you can search across your source code, databases, actions, elements of the user
interface, and so on, by `double-pressing the Shift`, or clicking the magnifying
glass in the upper right-hand corner of the Android Studio window.

// (can select from global search)
//
// Search for and navigate to a specific class in your project using the
// Navigate to Class action. Bring up the action by pressing Control+N
// (Command+O on a Mac).  Navigate to Class supports sophisticated expressions,
// including camel humps, paths, line navigate to, middle name matching, and
// many more. If you call it twice in a row, it shows you the results out of the
// project classes.
//
// Navigate to a file or folder using the Navigate to File action. Bring up the
// Navigate to File action by pressing Control+Shift+N (Command+Shift+O on a
// Mac).  To search for folders rather than files, add a / at the end of your
// expression.
// 
// Navigate to a method or field by name using the Navigate to Symbol action.
// Bring up the Navigate to Symbol action by pressing Control+Shift+Alt+N
// (Command+Option+O on a Mac).


<build>
By employing the flexibility of Gradle, you can achieve all of this without
modifying your app's core source files. Android Studio build files are named
build.gradle. They are plain text files that use Groovy syntax to configure
the build with elements provided by the Android plugin for Gradle. Each
project has one top-level build file for the entire project and separate
module-level build files for each module. When you import an existing project,
Android Studio automatically generates the necessary build files.

To learn more about the build system and how to configure, see Configure your
build.

<adb>
https://developer.android.com/studio/command-line/adb.html
https://www.stb.bskyb.com/confluence/display/~grayb/Android+Bluez+Stack

// run command from host

adb disable-verity
adb reboot

root	Restart adbd with root permissions.
adb root

adb remount
adb connect 192.168.0.104

You can verify that your device is connected by executing adb devices

$ adb devices
List of devices attached
192.168.0.104:5555      device


<adb-logcat> <android-log>

https://developer.android.com/studio/debug/am-logcat.html

keitee@keitee-mint:~/ip$ adb logcat --help
Usage: logcat [options] [filterspecs]
options include:
  -s              Set default filter to silent. Equivalent to filterspec '*:S'
  -f <file>, --file=<file>               Log to file. Default is stdout

   -e <expr>, --regex=<expr>
                  Only print lines where the log message matches <expr>
                  where <expr> is a regular expression
 

// capture all
adb logcat | tee log.log

adb logcat --pid=2208 | tee log.log

06-14 09:36:56.292  2208  2226 I BleRcuQt: < M:blercuadapter.cpp F:onDeviceAdded L:1494 > added device D4:B8:FF:12:E1:A8 named "P215 SkyQ EC101" (connected: false paired: false)
06-14 09:53:21.869  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 18:46:44:xx:xx:xx is 'U104 SkyQ EC201'
06-14 09:53:21.869  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 70:91:F3:xx:xx:xx is 'U104 SkyQ EC102'
06-14 09:53:21.870  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for D4:B8:FF:xx:xx:xx is 'U104 SkyQ EC[12]01'
06-14 09:53:21.871  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for E8:0F:C8:xx:xx:xx is 'U104 SkyQ EC202'

<run>
/home/keitee/Downloads/android/android-studio/bin
./studio.sh &


={============================================================================
*kt_dev_skymw_0000* skymw-android-bluetoothrcu

<things-to-check-to-build>

1. set QT setting

app/CMakeLists.txt

# Sets the path to the Qt5 libraries and headers.
# You'll need to modify the QT5_SDK path below to point to your Qt5 SDK install

set( QT5_SDK "/home/keitee/Qt/5.12.3" )


<build-release>
pass for key:
android
platform

https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Android+-+HowTo+Release+Components

Hi all,

A new release of the SkyBluetoothRcu service - version 2.1.1 - has been tagged
and pushed to git master.

Gerrit merge requests have been created for sky/QIP100 branch.

Release notes attached, highlights are:
- Added feature to put the bluetooth code in 'searching' mode for 30 seconds. 


<bt-remote-pairing>
https://docs.ubuntu.com/core/en/stacks/bluetooth/bluez/docs/reference/pairing/introduction

What is Pairing

In Bluetooth terminology pairing is the process of making two devices know about
each other. The key concept is about exchanging so called link-keys that are
used to secure the communication. The pairing process involves authentication
however due to the nature and variety of Bluetooth devices there will be
different ways of confirming the pairing attempt:

Devices such as keyboards or car-kits will require authentication by PIN/passkey
code

Other devices will provide a yes/no choice to the pairing attempt

Devices without an input interface such as headsets or speakers will not require
the user to confirm the pairing attempt at all

https://www.stb.bskyb.com/confluence/display/2016/RCU%3A+Pairing+steps+by+steps
https://www.stb.bskyb.com/confluence/display/~grayb/BLERCU+%3A+State+Diagrams+for+EC10x+Bluetooth+RCUS
https://www.stb.bskyb.com/confluence/display/2016/Remote+Control+Architecture

The BT Manager component will act as a connector to the underlying Bluez stack,
and expose the interfaces in a specified API, for use with the main network
control and pairing system.

 5.3.3.2 Certificate Store

Pairing will generate CA certificate information, which must be placed in
persistent storage. An API to the wider system, or some knowledge of the final
persistent storage system is necessary to co-ordinate this.


<bluetoothctl>
Pairing from Ubuntu Core
https://docs.ubuntu.com/core/en/stacks/bluetooth/bluez/docs/reference/pairing/outbound.html

SKY BLUEZ DEBUG CONSOLE
http://192.168.0.104:8180/index.html

telnet <stb-ip-address> 8123

   Select one of the following tools:
      1 - bluetoothctl
      2 - btmgmt
      3 - btmon
#>

#> 1
[NEW] Controller 38:A6:CE:7E:63:1A "sky-ip100" [default]
[NEW] Device D4:B8:FF:12:E1:A8 U122 SkyQ EC101
Agent registered
[bluetooth]# ?
Invalid command
[bluetooth]# help
Menu main:
Available commands:
-------------------
advertise                                         Advertise Options Submenu
scan                                              Scan Options Submenu
gatt                                              Generic Attribute Submenu
list                                              List available controllers
show [ctrl]                                       Controller information
select <ctrl>                                     Select default controller
devices                                           List available devices
paired-devices                                    List paired devices
system-alias <name>                               Set controller alias
reset-alias                                       Reset controller alias
power <on/off>                                    Set controller power
pairable <on/off>                                 Set controller pairable mode
discoverable <on/off>                             Set controller discoverable mode
agent <on/off/capability>                         Enable/disable agent with given capability
default-agent                                     Set agent as the default one
advertise <on/off/type>                           Enable/disable advertising with given type
set-alias <alias>                                 Set device alias
scan <on/off>                                     Scan for devices
info [dev]                                        Device information
pair [dev]                                        Pair with device
trust [dev]                                       Trust device
untrust [dev]                                     Untrust device
block [dev]                                       Block device
unblock [dev]                                     Unblock device
remove <dev>                                      Remove device
connect <dev>                                     Connect device
disconnect [dev]                                  Disconnect device
menu <name>                                       Select submenu
version                                           Display version
quit                                              Quit program
exit                                              Quit program
help                                              Display help about this program
[bluetooth]#

// check if "controller" is on and if not, run "power on"

[bluetooth]# show
Controller 38:A6:CE:7E:63:1A (public)
        Name: "sky-ip100"
        Alias: "sky-ip100"
        Class: 0x00000414
        Powered: yes
        Discoverable: no
        Pairable: no
        UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)
        UUID: A/V Remote Control        (0000110e-0000-1000-8000-00805f9b34fb)
        UUID: PnP Information           (00001200-0000-1000-8000-00805f9b34fb)
        UUID: A/V Remote Control Target (0000110c-0000-1000-8000-00805f9b34fb)
        UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)
        Modalias: usb:v1D6Bp0246d0530
        Discovering: no
[bluetooth]#


// check on "paired" and "connected"

[bluetooth]# info D4:B8:FF:12:E1:A8
Device D4:B8:FF:12:E1:A8 (public)
        Name: P199 SkyQ EC101
        Alias: P199 SkyQ EC101
        Appearance: 0x0180
        Paired: yes
        Trusted: no
        Blocked: no
        Connected: no
        LegacyPairing: no
        UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)
        UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)
        UUID: Immediate Alert           (00001802-0000-1000-8000-00805f9b34fb)
        UUID: Device Information        (0000180a-0000-1000-8000-00805f9b34fb)
        UUID: Battery Service           (0000180f-0000-1000-8000-00805f9b34fb)
        UUID: Human Interface Device    (00001812-0000-1000-8000-00805f9b34fb)
        UUID: Scan Parameters           (00001813-0000-1000-8000-00805f9b34fb)
        UUID: Vendor specific           (0000f800-bdf0-407c-aaff-d09967f31acd)
        UUID: Vendor specific           (0000f801-bdf0-407c-aaff-d09967f31acd)
        UUID: Vendor specific           (0000f802-bdf0-407c-aaff-d09967f31acd)
        Modalias: bluetooth:v057Ap0004d0100
[bluetooth]#

// remove

[bluetooth]# remove D4:B8:FF:12:E1:A8
[DEL] Primary Service
...
Device has been removed
[bluetooth]#

//

[bluetooth]# scan on

... press "1+3"

[bluetooth]# pair D4:B8:FF:12:E1:A8

[bluetooth]# info D4:B8:FF:12:E1:A8

[U162 SkyQ EC101]# devices
Device D4:B8:FF:12:E1:A8 P215 SkyQ EC101


<bluez-sky>
1+3 key triggers two things:

o do advertisement from rcu
o do paring process from a box


// app/src/main/cpp/main.cpp

/*
Called from the java MainApplication class when it's created.  This is the
entry point that kicks of the Qt main loop thread.

 */
extern "C"
JNIEXPORT jboolean JNICALL 
Java_com_sky_skybluetoothrcu_MainApplication_startQApplication(JNIEnv *env, 
    jobject /* this */)
{
  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, "launching QApplication");

  pthread_t qtThread;

  int rc = pthread_create(&qtThread, nullptr, mainThread, nullptr);
}

static int doMain()
{
  QCoreApplication a(argc, argv);

  // log the start-up
  qMilestone("====================");
  qMilestone("KT:");
  qMilestone("====================");

  // first thing we do is start the Android AIDL service, it has no controller
  // so won't be useful, but means other clients can connect to it (the controller
  // is added later)
  QSharedPointer<BleRcuService> service =
    QSharedPointer<BleRcuService>::create();

  // create the config options, read from the config.json file
  QSharedPointer<const ConfigSettings> config = ConfigSettings::defaults();

  // create the factory for creating the BleRcu services for each device
  QSharedPointer<BleRcuServicesFactory> servicesFactory =
    QSharedPointer<BleRcuServicesFactory>::create(config);

  // store the backend type
  g_backend.store(Backend::Bluez);

  // attempt to connect to the android dbus-broker
  QDBusConnection dbusConn = connectToDBus();
  if (!dbusConn.isConnected()) {
    qError() << "failed to connect to dbus due to" << dbusConn.lastError();
  }

  *when-use-bluez*
  // and then create the adapter talking to bluez over dbus
  adapter = QSharedPointer<BleRcuAdapterBluez>::create(config,
      servicesFactory,
      dbusConn);

  // create the controller that manages the adapter and paired devices
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(config, adapter);

  // give the controller to the Android service, the service is now useful
  service->setController(controller);
}


<bluez-config>

daemon/resources/resources.default.qrc
3:      <file alias="defaultconfig.json">config.default.json</file>
keitee@keitee-mint:~/mw/appinfrastructure/AppInfrastructure/BluetoothRcu$

gvimdiff /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json
cdiff /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json
cp /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json
mv /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json.kt
cdiff /home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json
meld /home/keitee/ip/SkyBluetoothRcu/app/src/ /home/keitee/ip/repo/SkyBluetoothRcu/app/src/

// right config file used?
// SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json

	"models": [
		{
			"name": "ECx01",
			"manufacturer": "Omni",
			"oui": "D4:B8:FF",
			"pairingNameFormat": "U%03hhu SkyQ EC[12]01",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC[12]01",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC201",
			"manufacturer": "Omni",
			"oui": "18:46:44",
			"pairingNameFormat": "U%03hhu SkyQ EC201",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC201",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC102",
			"manufacturer": "UEI",
			"oui": "70:91:F3",
			"pairingNameFormat": "U%03hhu SkyQ EC102",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC102",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC202",
			"manufacturer": "UEI",
			"oui": "E8:0F:C8",
			"pairingNameFormat": "U%03hhu SkyQ EC202",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC202",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC05x",
			"manufacturer": "Ruwido",
			"disabled": true,
			"oui": "1C:A2:B1",
			"pairingNameFormat": "U%03hhuruwido Sky Remote",
			"scanNameFormat": "U[0-9][0-9][0-9]ruwido Sky Remote",
			"filterByte": 27,
			"connectionParams": {
				"maxInterval": 15.0,
				"minInterval": 15.0,
				"latency": 332,
				"supervisionTimeout": 15000
			},
			"services": {
				"type": "rci",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"touch"
				]
			}
		}

	]
	"models": [
		{
			"name": "ECx01",
			"manufacturer": "Omni",
			"oui": "D4:B8:FF",
			"pairingNameFormat": "U%03hhu SkyQ EC[12]01",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC[12]01",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC201",
			"manufacturer": "Omni",
			"oui": "18:46:44",
			"pairingNameFormat": "U%03hhu SkyQ EC201",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC201",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC102",
			"manufacturer": "UEI",
			"oui": "70:91:F3",
			"pairingNameFormat": "U%03hhu SkyQ EC102",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC102",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC202",
			"manufacturer": "UEI",
			"oui": "E8:0F:C8",
			"pairingNameFormat": "U%03hhu SkyQ EC202",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC202",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC05x",
			"manufacturer": "Ruwido",
			"disabled": true,
			"oui": "1C:A2:B1",
			"pairingNameFormat": "U%03hhuruwido Sky Remote",
			"scanNameFormat": "U[0-9][0-9][0-9]ruwido Sky Remote",
			"filterByte": 27,
			"connectionParams": {
				"maxInterval": 15.0,
				"minInterval": 15.0,
				"latency": 332,
				"supervisionTimeout": 15000
			},
			"services": {
				"type": "rci",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"touch"
				]
			}
		}
	]


// app/src/main/cpp/utils/linuxinputdevice.cpp

signals:
	void keyPress(quint16 keyCode, qint32 scanCode);
	void keyRelease(quint16 keyCode, qint32 scanCode);

void LinuxInputDevice::processEvents(const struct input_event *events, size_t nevents)
{
  switch (event->type) {
    case EV_SYN:
      m_scanCode = 0;
      break;
    case EV_KEY:
      if (event->value)
        `emit keyPress(event->code, m_scanCode);`
      else
        emit keyRelease(event->code, m_scanCode);
      m_scanCode = 0;
      break;
    case EV_MSC:
      if (event->code == MSC_SCAN)
        m_scanCode = event->value;
      break;

    default:
      break;
  }
}


// note that "service/android"
// app/src/main/cpp/service/android/blercuservice.cpp
// app/src/main/cpp/service/android/blercuservice.h

class BleRcuService : public QObject
                    , public QEnableSharedFromThis<BleRcuService>
{
  const QSharedPointer<InputDeviceManager> m_inputDeviceManager;

  QSharedPointer<BleRcuController> m_controller;

  QSharedPointer<QAndroidJniObject> m_javaBleRcuService;

  QSharedPointer<LinuxInputDevice> m_irInputDevice;

  QMap<BleAddress, int> m_deviceIdMap;
}

{
  // create the SkyBluetoothLE java object
  m_javaBleRcuService = QSharedPointer<QAndroidJniObject>::create(
      "com/sky/blercu/BleRcuService",
      "(J)V");
}

BleRcuService::BleRcuService(QObject *parent)
	: QObject(parent)
	, m_inputDeviceManager(InputDeviceManager::create())
  {
    QObject::connect(m_irInputDevice.data(), `&LinuxInputDevice::keyPress`,
        this, &BleRcuService::onIrKeyPress);
  }

void BleRcuService::onIrKeyPress(quint16 keyCode, qint32 scanCode)
{
  // check for the pairing keyCode F13 which is the new format
  if (keyCode == KEY_F13) {

    // 03th byte
    const quint8 filterByte = quint8((scanCode >> 16) & 0xff);

    // 01st byte
    const quint8 pairingCode = quint8((scanCode >> 0) & 0xff);

    // kick off pairing using supplied pairing code
    `m_controller->startPairing`(filterByte, pairingCode);
  }
}


// app/src/main/cpp/blercu/blercucontroller.cpp
*start-pairing-android*
bool BleRcuControllerImpl::startPairing(quint8 filterByte, quint8 pairingCode)
{
  // start the pairing process
  m_pairingStateMachine.start(filterByte, pairingCode);
}


// app/src/main/cpp/blercu/blercupairingstatemachine.cpp

class BleRcuControllerImpl : public BleRcuController
{
	const QSharedPointer<BleRcuAdapter> m_adapter;

	BleRcuPairingStateMachine m_pairingStateMachine;
	BleRcuScannerStateMachine m_scannerStateMachine;
}

//   QObject::connect(m_adapter.data(), &BleRcuAdapter::deviceNameChanged,
//     this, &BleRcuPairingStateMachine::onDeviceNameChanged);
// 
// void BleRcuPairingStateMachine::onDeviceNameChanged(const BleAddress &address,
//                                                     const QString &name)
// {
//   qDebug() << "device name changed" << address << name
//     << "(target" << m_targetAddress << ")";
// 
//   `processDevice`(address, name);
// }
// 
// /*!
// 	\internal
// 
// 	Called when entering the 'discovering' state.  At this point we query the
// 	manager for `the current list of devices and their names`  We use this to
// 	determine if any existing devices match the pairing prefix.
// 
//  */
// void BleRcuPairingStateMachine::onEnteredDiscoveringState()
// {
//    *get-devices-from-adapter*
// 	// get the current list of devices
// 	const QMap<BleAddress, QString> deviceNames = m_adapter->deviceNames();
// 
// 	// process each existing device
// 	QMap<BleAddress, QString>::const_iterator it = deviceNames.begin();
// 	for (; it != deviceNames.end(); ++it)
// 		`processDevice`(it.key(), it.value());
// }
//
// 
// // -----------------------------------------------------------------------------
// /*!
// 	\internal
// 
// 	Called when the an outside object has called either deviceAdded() or
// 	deviceNameChanged(), it then checks if the \a name matches our expected
// 	pairing prefix.  If it does then we check if we already have a pairing
// 	target, if not we use this new device.
// 
//  */
// void BleRcuPairingStateMachine::processDevice(const BleAddress &address,
//                                               const QString &name)
// {
//    *match-devices-from-rcu-to-scanned-devices*
//    QMap<quint32, QRegExp>::const_iterator it = m_pairingPrefixes.find(address.oui());
//
//    I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8
// }
// 
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8


// *pairing-fsm-regex*
//
// m_pairingPrefixFormats is built from *config* when fsm starts and is used to
// check if current devices does match up with expected pattern in
// `processDevice()` which gets called when device found and added
//
// "pairingNameFormat": "U%03hhu SkyQ EC202",
//
// BleRcuPairingStateMachine::BleRcuPairingStateMachine(const QSharedPointer<const ConfigSettings> &config)
// {
//   // constructs a map of name printf style formats for searching for device
//   // names that match
//   const QList<ConfigModelSettings> models = config->modelSettings();
//   for (const ConfigModelSettings &model : models) {
//     `m_pairingPrefixFormats`[model.oui()] = model.pairingNameFormat();
//   }
// }
//

// "130" is *paringcode*
// 
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 18:46:44:xx:xx:xx is 'U130 SkyQ EC201'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 70:91:F3:xx:xx:xx is 'U130 SkyQ EC102'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for D4:B8:FF:xx:xx:xx is 'U130 SkyQ EC[12]01'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for E8:0F:C8:xx:xx:xx is 'U130 SkyQ EC202'
// I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
//
// I BleRcuQt: < M:blercudevice.cpp F:onEnteredResolvingServicesState L:547 > D4:B8:FF:12:E1:A8 entered RESOLVING_SERVICES state
// I BleRcuQt: < M:blercudevice.cpp F:onDeviceNameChanged L:352 > D4:B8:FF:12:E1:A8 device name changed from "P138 SkyQ EC101" to "U130 SkyQ EC101"
// I BleRcuQt: < M:blercuadapter.cpp F:onDeviceNameChanged L:1692 > renamed device D4:B8:FF:12:E1:A8 to "U130 SkyQ EC101"
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:773 > found target device D4:B8:FF:12:E1:A8 but it's currently paired, will unpair and wait till it shows up in a scan again
//

void BleRcuPairingStateMachine::start(quint8 filterByte, quint8 pairingCode)
{
  // FIXME: use the filterByte to narrow the search to a certain RCU model
  Q_UNUSED(filterByte);

  // create a map of OUI (first 3 bytes of mac address) to a regex to match to
  // the name of the device
  m_pairingPrefixes.clear();
  QMap<quint32, QByteArray>::const_iterator it = m_pairingPrefixFormats.begin();
  for (; it != m_pairingPrefixFormats.end(); ++it) {

    // construct the wildcard match
    QRegExp regEx(QString::asprintf(it.value().constData(), `pairingCode`));
    regEx.setPatternSyntax(QRegExp::WildcardUnix);

    qInfo("pairing regex for %02hhX:%02hhX:%02hhX:xx:xx:xx is '%s'",
        quint8(it.key() >> 16), quint8(it.key() >> 8), quint8(it.key() >> 0),
        regEx.pattern().toLatin1().constData());

    // add to the map to use for compare when a device is found
    `m_pairingPrefixes`.insert(it.key(), std::move(regEx));
  }

  // start the state machine
  m_stateMachine.start();
}

bool StateMachine::start()
{
  m_currentState = m_initialState;
  m_running = true;

  logTransition(-1, m_currentState);

  emit entered(m_currentState);
  return true;
}

void BleRcuPairingStateMachine::setupStateMachine()
{
  // connect to the state entry and exit signals
  QObject::connect(&m_stateMachine, &StateMachine::`entered`,
      this, &BleRcuPairingStateMachine::`onStateEntry`);

  QObject::connect(&m_stateMachine, &StateMachine::`exited`,
      this, &BleRcuPairingStateMachine::`onStateExit`);
}

void BleRcuPairingStateMachine::onStateEntry(int state)
{
  switch (state) {

    case StartingDiscoveryState:
      onEnteredStartDiscoveryState()
      {
        // *emit-started*
        // tell anyone who cares that pairing has started
        `emit started();`
      }

      break;

    case FinishedState:
      onEnteredFinishedState()
      {
        // finally just emit a finished signal to the BleRcuManagerImpl object
        `emit finished();`
      }
      break;
  }
}

void BleRcuPairingStateMachine::onStateExit(int state)
{
  switch (state) {}
}


< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
< M:blercupairingstatemachine.cpp F:onStateEntry L:306 > KT: state: 2
< M:blercupairingstatemachine.cpp F:onEnteredStartDiscoveryState L:379 > KT: BleRcuPairingStateMachine::onEnteredStartDiscoveryState


*start-pairing-device-pair*

void BleRcuPairingStateMachine::onEnteredPairingState()
{
	// request the manager to pair with the device
	m_manager->pairDevice(m_targetAddress);
}

bool BleRcuManagerImpl::pairDevice(const BleAddress &address)
{
	qInfo() << "requesting bluez pair" << device->address();
	device->pair(0);
	return true;
}

void BleRcuDeviceImpl::pair(int timeout)
{
	QDBusPendingReply<> reply = m_deviceProxy->Pair();
	QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(reply, this);

	QObject::connect(watcher, &QDBusPendingCallWatcher::finished,
	                 this, &BleRcuDeviceImpl::onPairRequestReply);

	// set the flag, it may be cleared if the call fails
	m_isPairing = true;
}

void BleRcuDeviceImpl::onPairRequestReply(QDBusPendingCallWatcher *call)
{
	QDBusPendingReply<> reply = *call;

	if (Q_UNLIKELY(reply.isError())) {

		m_isPairing = false;

		// an error occurred so log it, however from bluez 5.47 the bluez daemon
		// doesn't seem to send a reply on success, so ignore that error
		QDBusError error = reply.error();
		if (error.type() != QDBusError::NoReply)
			qError() << m_address << "pairing request failed with error" << error;

		// emit pairingError(m_address, error.message());

	} else {

		qDebug() << m_address << "pairing request successful";

		// TODO: start the timer to cancel the pairing after a certain amount of time

	}
	// free the pending reply object
	call->deleteLater();
}


// from adaptor signal

< M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter started discovering
bool BleRcuControllerImpl::startScanning(int timeoutMs)
{
	// check we're not currently pairing
	if (m_pairingStateMachine.isRunning()) {
		qWarning("currently performing pairing, cannot start new scan");
		return false;
	}

	// check we're not already scanning
	if (m_scannerStateMachine.isRunning()) {
		qWarning("already scanning, new scan request aborted");
		return false;
	}

	// check that the manager has powered on the adapter, without this we
	// obviously can't scan. The only time the adaptor should (legitimately) be
	// unavailable is right at start-up
	if (!m_adapter->isAvailable() || !m_adapter->isPowered()) {
		m_lastError = BleRcuError(BleRcuError::General,
		                          QStringLiteral("Adaptor not available or not powered"));
		return false;
	}

	// start the pairing process
	emit stateChanged(PairingState::Searching);
	m_scannerStateMachine.start(timeoutMs);
	return true;
}
< M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:422 > KT: postEvent(DiscoveryStartedEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1001)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (3)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state StartingDiscoveryState(2) to DiscoveringState(3)"

< M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8
< M:blercupairingstatemachine.cpp F:processDevice L:799 > KT: postEvent(DeviceFoundEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1009)
< M:statemachine.cpp F:shouldMoveState L:310 > KT: really happen?? state (1)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (5)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state DiscoveringState(3) to StoppingDiscoveryState(5)"

< M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter stopped discovering
< M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:427 > KT: postEvent(DiscoveryStoppedEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1002)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (6)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state StoppingDiscoveryState(5) to EnablePairableState(6)"


//
// app/src/main/cpp/blercu/bluez/interfaces/bluezadapterinterface.h

#include <QtDBus>

class BluezAdapterInterface : public DBusAbstractInterface
{
  // ??
  Q_PROPERTY(bool Discovering READ discovering NOTIFY `discoveringChanged`)
    inline bool discovering() const
    { return qvariant_cast< bool >(property("Discovering")); }

signals:
  void aliasChanged(const QString& newAlias);
  void deviceClassChanged(quint32 deviceClass);
  void discoverableChanged(bool discoverable);
  void discoverableTimeoutChanged(uint newDiscoverableTimeout);
  void `discoveringChanged`(bool discovering);
  ...
};

// dbus -> adapter
// app/src/main/cpp/blercu/blercuadapter.h

class BleRcuAdapter : public QObject
{
signals:
  void poweredChanged(bool powered, QPrivateSignal);

  void `discoveryChanged`(bool discovering, QPrivateSignal);
  void pairableChanged(bool pairable, QPrivateSignal);

  void deviceFound(const BleAddress &address, const QString &name, QPrivateSignal);
  void deviceRemoved(const BleAddress &address, QPrivateSignal);

  void deviceNameChanged(const BleAddress &address, const QString &name, QPrivateSignal);
  void devicePairingChanged(const BleAddress &address, bool paired, QPrivateSignal);
  void deviceReadyChanged(const BleAddress &address, bool ready, QPrivateSignal);
};

// app/src/main/cpp/blercu/bluez/blercuadapter_p.h

class BleRcuAdapterBluez : public BleRcuAdapter
{
  private slots:
    void onAdapterDiscoveringChanged(bool discovering);
};

// app/src/main/cpp/blercu/bluez/blercuadapter.cpp

bool BleRcuAdapterBluez::attachAdapter(const QDBusObjectPath &adapterPath)
{
  // install handlers for the interesting adapter notifications
  QObject::connect(m_adapterProxy.data(), &BluezAdapterInterface::`discoveringChanged`,
      this, &BleRcuAdapterBluez::`onAdapterDiscoveringChanged`);
}

void BleRcuAdapterBluez::`onAdapterDiscoveringChanged`(bool discovering)
{
  emit `discoveryChanged`(m_discovering, BleRcuAdapter::privateSignal());
}

// adapter -> state machine
// app/src/main/cpp/blercu/blercupairingstatemachine.cpp

class BleRcuPairingStateMachine : public QObject {}

BleRcuPairingStateMachine::BleRcuPairingStateMachine()
{
  QObject::connect(m_adapter.data(), `&BleRcuAdapter::discoveryChanged`,
      this, &BleRcuPairingStateMachine::`onDiscoveryChanged`);
}

void BleRcuPairingStateMachine::`onDiscoveryChanged`(bool discovering)
{
  if (discovering)
    m_stateMachine.postEvent(DiscoveryStartedEvent);
  else
    m_stateMachine.postEvent(DiscoveryStoppedEvent);
}

app/src/main/java/com/sky/bluetooth/SkyBroadcastReceiver.java
124:            filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
1


/home/keitee/ip/SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
/home/keitee/ip/SkyBluetoothRcu/app/src/main/java/com/sky/blercu/BleRcuService.java
/home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/blercu/blercuadapter.h
/home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/blercu/android/blercuadapter_p.h


<bluez-sky-aidl>
https://developer.android.com/guide/components/aidl#java

Defining an AIDL interface

You must define your AIDL interface in an .aidl file using the Java programming
language syntax, then save it in the source code (in the src/ directory) of 
`both the application` hosting the service and any other application that binds
to the service.

When you build each application that contains the .aidl file, the Android SDK
tools `generate` an IBinder interface based on the .aidl file and save it in the
project's gen/ directory. The service must implement the IBinder interface as
appropriate. The client applications can then bind to the service and call
methods from the IBinder to perform IPC.

Implement the interface

The Android SDK tools generate an interface in the Java programming language,
based on your .aidl file. This interface has an inner abstract class named Stub
that extends Binder and implements methods from your AIDL interface.  You must
extend the Stub class and implement the methods.


as api to support

/peripherals/btremotes/status
/peripherals/btremotes/action/startsearching


as/iWedia_AS_service/QtRESTService/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl

// are the same files

keitee@keitee-mint:~/ip$ find . -name IBleRcuService.aidl
./SkyBluetoothRcu/example/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./SkyBluetoothRcu/tests/IrDatabaseTest/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./iwedia/as/iWedia_AS_service/QtRESTService/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl


// app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl

interface IBleRcuService {
	void registerClient(in ParcelUuid appId, in IBleRcuServiceCallback callback);
	void unregisterClient(in int clientIf);

	boolean isPairing();

	String[] getDevices();

	++++ boolean isDevicePaired(in String address);
	++++ boolean isDeviceConnected(in String address);
	++++ int getDeviceId(in String address);
	++++ int getDeviceBatteryLevel(in String address);
	++++ String getDeviceName(in String address);
	++++ String getDeviceMake(in String address);
	++++ String getDeviceModel(in String address);
	++++ String getDeviceSerialNumber(in String address);
	++++ String getDeviceHardwareVersion(in String address);
	++++ String getDeviceSoftwareVersion(in String address);
	++++ String getDeviceBootloaderVersion(in String address);
	++ boolean setDeviceFindMe(in String address, in boolean enable);

	++ boolean setDeviceTouchMode(in String address, in int mode);
	++ int getDeviceTouchMode(in String address);

	++ boolean programDeviceIrCode(in String address, in int type, in int code);
	++ boolean eraseDeviceIrCodes(in String address);

	++ ParcelFileDescriptor startDeviceVoiceRecording(in String address);
	++ VoiceRecordingStats getDeviceVoiceRecordingStats(in String address);

	String[] getManufacturers(in String search, in int flags, in int offset, in int limit);
	String[] getModels(in String manufacturer, in String search, in int flags, in int offset, in int limit);
	int[] getCodes(in String manufacturer, in String model, in int flags);
	int[] getCodesFromEDID(in byte[] edid);

	++ boolean startDeviceUpgrade(in String address, in byte[] firmware);
	++ void cancelDeviceUpgrade(in String address);
}


Expose the interface to clients

Implement a Service and override onBind() to return your implementation of the
Stub class.

// app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {

  private static class BleRcuServiceBinder extends IBleRcuService.Stub {
    // ...

    @Override
      public String getDeviceMake(String address) {
        if (!checkAddress(address))
          return null;

        BleRcuService service = getService();

        if (service == null) return null;

        // use of JNI ifs
        return service.jniGetDeviceMake(service.mQtObject, address);
      }

  } // IBleRcuService

  // JNI ifs
  private native String jniGetDeviceMake(long qtObject, String address);
  // ...

} // end of service


// app/src/main/cpp/service/android/blercuservice.cpp

bool `BleRcuService::registerNatives`()
{
  JNI_ENTRY(jniGetDeviceMake,               "(JLjava/lang/String;)Ljava/lang/String;"),
	private static class BleRcuServiceBinder extends IBleRcuService.Stub {
		private BleRcuService mService;

		private BleRcuServiceBinder(BleRcuService svc) {
			mService = svc;
		}
		public boolean cleanup() {
			mService = null;
			return true;
		}

		public BleRcuService getService() {
			if (mService != null && mService.isAvailable()) {
				return mService;
			}
			return null;
		}

		@Override
		public void dump(FileDescriptor fd, String[] args) {
			// TODO: check if we should be doing this
			BleRcuService service = getService();
			if (service == null) return;

			service.jniDump(service.mQtObject, fd, args);
		}

		@Override
		public void registerClient(ParcelUuid appId, IBleRcuServiceCallback callback) {
			if (callback == null)
				return;

			int callerId = getCallingPid();

			BleRcuService service = getService();
			if (service == null) return;
			service.registerClient(callerId, appId, callback);
		}

		@Override
		public void unregisterClient(int clientIf) {
			if (clientIf <= 0)
				return;

			int callerId = getCallingPid();

			BleRcuService service = getService();
			if (service == null) return;
			service.unregisterClient(callerId, clientIf);
		}

		@Override
		public boolean isPairing() {
			BleRcuService service = getService();
			if (service == null) return false;
			return service.isPairing();
		}

		@Override
		public String[] getDevices() {
			BleRcuService service = getService();
			if (service == null) return new String[0];
			return service.getPairedDevices();
		}

		@Override
		public boolean isDevicePaired(String address) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.isDevicePaired(address);
		}

		@Override
		public boolean isDeviceConnected(String address) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;

			return service.jniIsDeviceConnected(service.mQtObject, address);
		}

		@Override
		public int getDeviceId(String address)  {
			if (!checkAddress(address))
				return -1;

			BleRcuService service = getService();
			if (service == null) return -1;
			return service.jniGetDeviceId(service.mQtObject, address);
		}

		@Override
		public int getDeviceBatteryLevel(String address) {
			if (!checkAddress(address))
				return 255;

			BleRcuService service = getService();
			if (service == null) return -1;
			return service.jniGetDeviceBatteryLevel(service.mQtObject, address);
		}

		@Override
		public String getDeviceName(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceName(service.mQtObject, address);
		}

		@Override
		public String getDeviceMake(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceMake(service.mQtObject, address);
		}

		@Override
		public String getDeviceModel(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceModel(service.mQtObject, address);
		}

		@Override
		public String getDeviceSerialNumber(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceSerialNumber(service.mQtObject, address);
		}

		@Override
		public String getDeviceHardwareVersion(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceHardwareVersion(service.mQtObject, address);
		}

		@Override
		public String getDeviceSoftwareVersion(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceSoftwareVersion(service.mQtObject, address);
		}

		@Override
		public String getDeviceBootloaderVersion(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceBootloaderVersion(service.mQtObject, address);
		}

		@Override
		public boolean setDeviceFindMe(String address, boolean enable) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.jniSetDeviceFindMe(service.mQtObject, address, enable);
		}

		@Override
		public boolean setDeviceTouchMode(String address, int mode) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.jniSetDeviceTouchMode(service.mQtObject, address, mode);
		}

		@Override
		public int getDeviceTouchMode(String address) {
			if (!checkAddress(address))
				return -1;

			BleRcuService service = getService();
			if (service == null) return 0;
			return service.jniGetDeviceTouchMode(service.mQtObject, address);
		}

		@Override
		public boolean programDeviceIrCode(String address, int type, int code) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.jniProgramDeviceIrCode(service.mQtObject, address, type, code);
		}

		@Override
		public boolean eraseDeviceIrCodes(String address) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.jniEraseDeviceIrCodes(service.mQtObject, address);
		}

		@Override
		public ParcelFileDescriptor startDeviceVoiceRecording(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;

			try {
				// create a pipe for sending voice data (nb: a 'reliable' pipe
				// object also contains a AF_SEQPACKET socket that is used as a
				// side channel to send back error messages)
				ParcelFileDescriptor[] fds = ParcelFileDescriptor.createReliablePipe();

				// request the start of voice search, if this fails an exception is
				// thrown, in which case we mark the pipe as errored
				try {
					service.jniStartDeviceVoiceRecording(service.mQtObject, address,
					                                     fds[1].getFd());
				} catch (Exception e) {
					fds[1].closeWithError(e.getMessage());
					return fds[0];
				}

				// close the pipe write end (is dup'ed within the native c++ code)
				// and return the read end of the pipe
				fds[1].close();
				return fds[0];

			} catch (IOException e) {
				Log.e(TAG, "", e);
				return null;
			}
		}

		@Override
		public VoiceRecordingStats getDeviceVoiceRecordingStats(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;

			// get the current details from native code
			int[] details = service.jniGetDeviceVoiceRecordingStats(service.mQtObject, address);

			// return the voice recording stats
			VoiceRecordingStats stats = new VoiceRecordingStats();
			stats.errorCode = details[0];
			stats.receivedPackets = details[1];
			stats.expectedPackets = details[2];
			return stats;
		}

		@Override
		public String[] getManufacturers(String search, int flags, int offset, int limit) {
			BleRcuService service = getService();
			if (service == null) return new String[0];
			return service.jniGetManufacturers(service.mQtObject, search, flags, offset, limit);
		}

		@Override
		public String[] getModels(String manufacturer, String search, int flags, int offset, int limit) {
			BleRcuService service = getService();
			if (service == null) return new String[0];
			return service.jniGetModels(service.mQtObject, manufacturer, search, flags, offset, limit);
		}

		@Override
		public int[] getCodes(String manufacturer, String model, int flags) {
			BleRcuService service = getService();
			if (service == null) return new int[0];
			return service.jniGetCodes(service.mQtObject, manufacturer, model, flags);
		}

		@Override
		public int[] getCodesFromEDID(byte[] edid) {
			BleRcuService service = getService();
			if (service == null) return new int[0];
			return service.jniGetCodesFromEDID(service.mQtObject, edid);
		}


		@Override
		public boolean startDeviceUpgrade(String address, byte[] firmware) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null)
				return false;

			boolean result = false;
			try {
				result = service.jniStartDeviceUpgrade(service.mQtObject, address, firmware);
			} catch (Exception e) {
				// safe to call this as it just bounces the message through the
				// notification thread and is non-blocking
				service.onDeviceFirmwareUpgradeProgressChanged(address, -1, e.getMessage());
				result = false;
			}

			return result;
		}

		@Override
		public void cancelDeviceUpgrade(String address) {
			if (!checkAddress(address))
				return;

			BleRcuService service = getService();
			if (service != null)
				service.jniCancelDeviceUpgrade(service.mQtObject, address);
		}

		@Override
		public void startScanning(int timeout) {
			BleRcuService service = getService();
			if (service != null)
				service.jniStartScanning(service.mQtObject, timeout);
		}

		@Override
		public int getState() {
			BleRcuService service = getService();
			return service != null ? service.getState() : PAIRING_STATE_IDLE;
		}
	}
}


// app/src/main/cpp/blercu/bluez/blercuadapter.cpp

bool BleRcuAdapterBluez::isDevicePaired(const BleAddress &address) const
{
	const QSharedPointer<BleRcuDeviceBluez> device = m_devices.value(address);
	if (!device || !device->isValid()) {
		qInfo() << "failed to find device with address" << address
		        << "to query paired status";
		return false;
	}

	return device->isPaired();
}

// app/src/main/java/com/sky/blercu/BleRcuService.java
	/**
	 * Returns true if the device with the given address is in the list of paired
	 * device.
	 *
	 */
	public boolean isDevicePaired(String address) {
		mServiceLock.readLock().lock();
		boolean isPaired = mPairedDevices.contains(address);
		mServiceLock.readLock().unlock();

		return isPaired;
	}

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {

		@Override
		public boolean isDevicePaired(String address) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.isDevicePaired(address);
		}


<bluez-scanning>
https://www.stb.bskyb.com/confluence/display/~grayb/Bluetooth+RCU+Pairing+Without+Infrared

Bluetooth RCU Pairing(scan)
http://192.168.0.100:8280/index.html

app/src/main/cpp/debug/www/main.dart.js
1796:i5:function(){W.eS("http://"+H.e($.b9)+":"+$.bY+"/bs/peripherals/btremotes/action/scanstart?timeoutms=30000","POST").aa(new F.e1(),null)},
3652:P.eA("post scanstart request finished")},


// app/src/main/cpp/debug/3rdparty/qhttpengine/src/qhttpserver.cpp

  d->process(socket);

// app/src/main/cpp/debug/httphandler.cpp

void HttpHandler::process(QHttpSocket *socket, const QString &path)
{}

void HttpHandler::handlePostRequest(QHttpSocket *socket, const QString &path)
{
  // ask the controller to start the scan
  m_controller->startScanning(timeoutMs);
}


see *bluez-config* for m_deviceNameMatchers

*start-pairing-start-scanning*
bool BleRcuControllerImpl::startScanning(int timeoutMs)
{
  // start the pairing process
  m_scannerStateMachine.start(timeoutMs);
  return true;
}


// app/src/main/cpp/blercu/blercuscannerstatemachine.cpp

void BleRcuScannerStateMachine::`onEnteredFinishedState`()
{
  // if we found a device then tell any clients
  if (!m_foundDevice.address.isNull()) {
    `emit foundPairableDevice(m_foundDevice.address, m_foundDevice.name);`
    m_foundDevice.clear();
  }

  // and we're done
  emit finished();
}

// BleRcuControllerImpl::BleRcuControllerImpl()
//
// // connect to the scanner signals
// QObject::connect(&m_scannerStateMachine,
//                  &BleRcuScannerStateMachine::started,
//                  this,
//                  &BleRcuControllerImpl::onStartedScanning,
//                  Qt::QueuedConnection);
// QObject::connect(&m_scannerStateMachine,
//                  &BleRcuScannerStateMachine::finished,
//                  this,
//                  &BleRcuControllerImpl::onFinishedScanning,
//                  Qt::QueuedConnection);
//
// void
// BleRcuControllerImpl::onStartedScanning()
// {
// 	emit scanningStateChanged(true);
// }
// 
// void
// BleRcuControllerImpl::onFinishedScanning()
// {
// 	emit scanningStateChanged(false);
// }
//
// WsHandler::WsHandler(const QSharedPointer<BleRcuController>& controller,
//                      QObject* parent)
//   : QHttpHandler(parent)
//   , m_controller(controller)
// {
// 	// connect to changes in the controller scanning or pairing status
// 	QObject::connect(controller.data(),
// 	                 &BleRcuController::scanningStateChanged,
// 	                 this,
// 	                 &WsHandler::onBleScanningStateChanged,
// 	                 Qt::QueuedConnection);
// }


BleRcuControllerImpl::BleRcuControllerImpl()
{
  // connect to the signal emitted when the scanner found an RCU device in
  // pairing mode
  QObject::connect(&m_scannerStateMachine, 
      `&BleRcuScannerStateMachine::foundPairableDevice`,
      this, &BleRcuControllerImpl::onFoundPairableDevice,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onFoundPairableDevice(const BleAddress &address,
                                                 const QString &name)
{
  qInfo() << "found" << address << "RCU device in pairing mode,"
    << "kicking off the pairing state machine";

  // sanity check (needed?)
  if (m_pairingStateMachine.isRunning()) {
    qWarning("found target device in scan but pairing state machine "
        "already running?");
    return;
  }

*start-pairing-android-from-scan*
  // start pairing the device
  m_pairingStateMachine.start(address, name);

}

// note: this is different start() from pairing mode
// void BleRcuPairingStateMachine::start(const BleAddress &target, const QString &name)
// add "single entry"

void BleRcuPairingStateMachine::start(const BleAddress &target, const QString &name)
{
  m_pairingPrefixes.insert(target.oui(),
      QRegExp(name, Qt::CaseInsensitive, QRegExp::FixedString));
}

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[ScannerStateMachine] moving from state StoppingDiscoveryState(3) 
  to FinishedState(4)"
W BleRcuQt: < M:statemachine.cpp F:moveToState L:206 > new states:  (4)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:207 > old states:  (3, 0)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:214 > KT: fire exit only for old state which is not in new states from child to parent state (3)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:214 > KT: fire exit only for old state which is not in new states from child to parent state (0)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:227 > KT: fire enter only for new state which is not in old states from parent to child state (4)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:248 > KT: cleanup events?
W BleRcuQt: < M:statemachine.cpp F:moveToState L:253 > KT: emit finished?

I BleRcuQt: < M:blercucontroller.cpp F:onFoundPairableDevice L:617 
  > found D4:B8:FF:12:E1:A8 RCU device in pairing mode, kicking off the pairing state machine

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onStateEntry L:306 > KT: state: 2
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onEnteredStartDiscoveryState L:379 > KT: BleRcuPairingStateMachine::onEnteredStartDiscoveryState
I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:280 > started pairing targeting D4:B8:FF:12:E1:A8
I BleRcuQt: < M:? F:? L:0 > started bluetooth RCU pairing procedure
I BleRcuQt: < M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter started discovering
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:422 > KT: postEvent(DiscoveryStartedEvent)

	bool startPairing(quint8 pairingCode) override;


<bluez-sky-client-example>
/home/keitee/ip/BleRcuExample

// copy-aidl
cp SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
cp SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl

// app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/blercu/IBleRcuService.java

@Override public boolean isDevicePaired(java.lang.String address) throws android.os.RemoteException
{
  android.os.Parcel _data = android.os.Parcel.obtain();
  android.os.Parcel _reply = android.os.Parcel.obtain();
  boolean _result;
  try {
    _data.writeInterfaceToken(DESCRIPTOR);
    _data.writeString(address);
    mRemote.transact(Stub.TRANSACTION_isDevicePaired, _data, _reply, 0);
    _reply.readException();
    _result = (0!=_reply.readInt());
  }
  finally {
    _reply.recycle();
    _data.recycle();
  }
  return _result;
}


// BleRcuExample/app/src/main/java/com/sky/blercuexample/MainActivity.java

public class MainActivity extends Activity {

  protected void onCreate(Bundle savedInstanceState) {

    // get the blercu service
    mManager = new BleRcuManager(mBleRcuCallback);

    // get the sidebar that displays the device details
    mSideBar = new SideBar(this,
        mManager,
        (TextView)findViewById(R.id.sidebar_heading),
        (ListView)findViewById(R.id.sidebar_list), mLogView);
  }

  private final BleRcuManagerCallback mBleRcuCallback = new BleRcuManagerCallback() {

    @Override
      public void onPairingChanged(BleRcuManager manager, final boolean isPairing) {
        runOnUiThread(new Runnable() {
            public void run() {
            mLogView.i("KT: MainActivity.java, pairing state changed to " + isPairing);
            }
            });
      }
  }

  /**
   * Callbacks from the BleRcu service.
   */
  private final BleRcuManagerCallback mBleRcuCallback = new BleRcuManagerCallback() {

    @Override
      public void onPairingChanged(BleRcuManager manager, final boolean isPairing) {
        runOnUiThread(new Runnable() {
            public void run() {
            mLogView.i("KT: MainActivity.java, pairing state changed to " + isPairing);
            }
            });
      }
  }
} 


// to provice client access to service via IBinder if
// BleRcuExample/app/src/main/java/com/sky/blercu/BleRcuManager.java

public final class BleRcuManager {

  private static synchronized IBleRcuService getService() {
    if(binder != null) {
      sService = IBleRcuService.Stub.asInterface(binder);
    }
  }
}

// BleRcuExample/app/src/main/java/com/sky/blercuexample/SideBar.java

    private void onClicked(int position) {

        if ((mCurrentAddress == null) || mCurrentAddress.isEmpty())
            return;

        if (position == TRIGGER_FINDME_LIST_IDX) {
            if (mFindMeListener != null)
                mFindMeListener.onTriggered(mCurrentAddress);
        }
        if (position == UPGRADE_FIRMWARE_LIST_IDX) {
            if (mFwUpgradeListener != null)
                mFwUpgradeListener.onTriggered(mCurrentAddress);
        }
        if (position == SCANNING_RCU_LIST_IDX) {
            try {
                mLogView.e("KT: startScanning(30000)..");
                mLogView.e("KT: startScanning(30000)..");
                mLogView.e("KT: startScanning(30000)..");
                mDevice.startScanning(30000);
            } catch (RemoteException e) {
                Log.e(TAG, "", e);
            }
        }
        if (position == GET_STATE_LIST_IDX) {
            try {
                mLogView.e("KT: getState() retuns " + mDevice.getState());
                mLogView.e("KT: getState() retuns " + mDevice.getState());
                mLogView.e("KT: getState() retuns " + mDevice.getState());
            } catch (RemoteException e) {
                Log.e(TAG, "", e);
            }
        }
    }


// /BleRcuExample/app/src/main/java/com/sky/blercu/BleRcuDevice.java

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();

        try {
            // isDeviceConnected
            final boolean connected = isConnected();

            // getDeviceId, getDeviceName
            description.append("BleRcu Device ").append(getDeviceId()).append(": ").append(getName()).append("\n");

            description.append("  bdaddr: ").append(getAddress()).append("\n");
            description.append("  connected: ").append(connected);
            if (connected) {
                description.append("\n");
                description.append("  name: ").append(getName()).append("\n");
                description.append("  deviceid: ").append(getDeviceId()).append("\n");

                // getDeviceMake, 
                description.append("  make: ").append(getMake()).append("\n");

                // getDeviceModel
                description.append("  model: ").append(getModel()).append("\n");

                // getDeviceHardwareVersion
                description.append("  hwrev: ").append(getHardwareVersion()).append("\n");

                // getDeviceSerialNumber
                description.append("  serialno: ").append(getSerialNumber()).append("\n");

                // getDeviceSoftwareVersion
                description.append("  rcuswver: ").append(getSoftwareVersion()).append("\n");

                // getDeviceBootloaderVersion
                description.append("  btlswver: ").append(getBootloaderVersion()).append("\n");

                // getDeviceBatteryLevel
                description.append("  batterylevel: ").append(getBatteryLevel());
            }

        } catch (RemoteException e) {
            description.append("Error: ...");
        }
  }


={============================================================================
*kt_dev_skymw_0000* skymw-android-ip150

https://www.stb.bskyb.com/confluence/display/2016/IP150+Releases

https://www.stb.bskyb.com/confluence/pages/viewpage.action?pageId=54062914
Programming IP100/IP150 via adb

Note: The box and the laptop must be on the same network before you can try to
program with this image from the laptop.
 
adb connect 192.168.1.10:5555 
adb root 
adb connect 192.168.1.10:5555
 
# Push the OTA package
adb push IP150-ota.zip /cache/update.zip

<comp-drivers>
IP150:/vendor/lib/modules # pwd
/vendor/lib/modules


={============================================================================
*kt_dev_skymw_0000* skymw-luna

https://www.stb.bskyb.com/confluence/display/~grayb/Android+Luna+-+Runtime+Service

<git-repo>
git clone ssh://kyoupark@mgt-ip100-gerrit.skyqstbbuild.com:29418/sky/platform/packages/apps/SkyLunaRuntime


<upgrade-apk>

https://www.stb.bskyb.com/confluence/display/~grayb/Updating+SkyLunaRuntime+Package

IP150:/system/app # readlink -f SkyLunaRuntime/
/system/app/SkyLunaRuntime


Step 1 - Disable Verity

adb root
adb connect 192.168.0.104
adb disable-verity

If verity is not already disabled you'll need then be prompted to reboot you box
for the change to take effect ... do that.

keitee@keitee-mint:~/Downloads$ adb disable-verity
Verity disabled on /vendor
Verity disabled on /system
Now reboot your device for settings to take effect

adb reboot

adb root
adb connect 192.168.0.104
adb remount
adb shell rm -rf /system/app/SkyLunaRuntime
adb reboot

keitee@keitee-mint:~/ip/repo/SkyLunaRuntime/apk$ adb install SkyLunaRuntime.apk
adb: failed to install SkyLunaRuntime.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.sky.lunaruntime signatures do not match the previously installed version; ignoring!]


<output-so>
~/ip/repo/SkyLunaRuntime$ ls -al app/src/main/libs/armeabi-v7a/libluna.so
-rwxr-xr-x 1 keitee keitee 20257680 Jul 15 14:31 app/src/main/libs/armeabi-v7a/libluna.so


// example/app/src/main/java/com/sky/lunaexample/MainActivity.java

public class MainActivity extends Activity {

  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // create the runtime object
    mLuna = new Runtime(this, mCallback);
  }
}


<clientlib>
clientlib/src/main/aidl/com/sky/luna/ILunaRuntime.aidl

interface ILunaRuntime
{
  /**
   * Check/download required libs to run the application
   *
   * param callback  - interface used by Minsitro service to notify the client when the loader is ready
   * param parameters
   *            parameters fields:
   *                 * Key Name                   Key type         Explanations
   *                   "sources"                  StringArray      Sources list from where Ministro will download the libs. Make sure you are using ONLY secure locations.
   *                   "repository"               String           Overwrites the default Ministro repository. Possible values: default, stable, testing and unstable
   *                   "required.modules"         StringArray      Required modules by your application
   *                   "application.title"        String           Application name, used to show more informations to user
   *                   "qt.provider"              String           Qt libs provider, currently only "necessitas" is supported.
   *                   "minimum.ministro.api"     Integer          Minimum Ministro API level, used to check if Ministro service compatible with your application. Current API Level is 3 !
   *                   "minimum.qt.version"       Integer          Minimim Qt version (e.g. 0x040800, which means Qt 4.8.0, check http://qt-project.org/doc/qt-4.8/qtglobal.html#QT_VERSION)!
   */
  void requestLoader(in ILunaRuntimeCallback callback, in Bundle parameters);
}


clientlib/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/luna/ILunaRuntime.java


// SkyLunaRuntime/clientlib/src/main/java/com/sky/luna/Runtime.java

public class Runtime {

    /**
     * Async callback object that receives the service updates.
     * <p>
     * The com.sky.lunaruntime service works by requesting the loader providing a
     * callback.  That callback is called with details on the service and triggers
     * the start of the actual runtime.  At the same time we disconnect from the
     * remote service because we no longer need it, all the require details were
     * supplied in the callback.
     *
     */
    private ServiceConnection mRuntimeConnection = new ServiceConnection() {

        private ILunaRuntime mService = null;

        @Override
        public void onServiceConnected(ComponentName name, IBinder service)
        {
            mService = ILunaRuntime.Stub.asInterface(service);
            try {
                if (mService != null) {
                    Bundle parameters = new Bundle();

                    // TODO: add any parameters to the engine request

                    mService.requestLoader(mServiceCallback, parameters);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mService = null;
        }

        private ILunaRuntimeCallback mServiceCallback = new ILunaRuntimeCallback.Stub() {

            // this function is called back by LunaRuntime service.
            @Override
            public void loaderReady(final Bundle loaderParams) throws RemoteException {
                mActivity.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mActivity.unbindService(mRuntimeConnection);
                        launchLuna(loaderParams);
                    }
                });
            }
        };

    };
}


<runtime>

app/src/main/aidl/com/sky/luna/ILunaRuntime.aidl

app/src/main/java/com/sky/lunaruntime/LunaRuntimeService.java

public class LunaRuntimeService extends Service {

    public void onCreate() {

        mRuntimeInterface = new ILunaRuntime.Stub() {

            @Override
            public void requestLoader(ILunaRuntimeCallback callback, Bundle params) throws RemoteException {
            }
    }
}


<so>

// Main Activity of the application, we need to implement SufraceHolder callback
// from which we obtain the actual SufraceView

public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback {

  @Override
    public void surfaceCreated(SurfaceHolder surfaceHolder) { //Callback which is called when surface is created
      A4TVStatus status;
      mLog.d("SurfaceHolder.Callback surfaceCreated");
      if (IDTVManager != null) {
        if (mSurfaceHolder != null) {
          Surface surface = mSurfaceHolder.getSurface(); //The actual surface object that we want to pass to the AS Service
          try {
            //The following line sets the actual surface to the AS service
            status = IDTVManager.getDisplayControl().setVideoLayerSurface(DISP_PRIMARY_VIDEO_LAYER, new SurfaceBundle(surface));
            if (status != ASStatus.SUCCESS) {
              mLog.e("Error on passing surface to AS service");
            }
            mLog.d("setVideoLayerSurface[" + surface + "]");
          } catch (RemoteException re) {
            re.printStackTrace();
          }
        }
      }
    }
}


// app/src/main/java/com/sky/lunaruntime/Runtime.java

public class Runtime extends BroadcastReceiver implements IRuntime {

  /**
   * Attempts to launch the luna runtime executing the contents of the supplied asset.
   * <p>
   * The asset must be a zip file containing all the 'stuff' for running the app in Luna.
   * It will be extracted to the data area of the app and then luna will be launched
   * from that.
   *
   * @param activity the activity to display and run luna in.
   * @param params the parameters to use for launching the luna runtime.
   *
   * @return true if successful otherwise false.
   */
  @Override
    public boolean launch(Activity activity, Bundle params) {

      // load the native luna library(s) .so
      loadNativeLibraries(params);

      // /app/libs/com.iwedia.comedia.service.comm-release.jar!/com/iwedia/dtv/IDTVManager.class
      //
      // connect to the DTV service early, even before extracting the app
      
      mDtvManager = new IWediaDTVManager(activity);
      mDtvManager.connect();

      // latest version already installed, go and run it
      return launchLuna(AppInstaller.installedDirectory(activity), params);

    }

  /**
   * This creates all the surfaces and sets the content view for the activity.
   * All the work to actually kick off Luna is done in the surface creation
   * callbacks, so this is just the view setup code.
   *
   * @param appInstallDir the directory that the app was expanded to.
   * @param params the parameters that were passed to the app to launch.
   *
   * @return true on success or false on failure.
   */
  private boolean launchLuna(final File appInstallDir, final Bundle params) {

    // Create the VideoSurface
    mVideoSurface = `new VideoSurface`(mActivity, mDtvManager);
  }
}

app/src/main/java/com/sky/lunaruntime/VideoSurface.java

class `VideoSurface` extends `IWediaDTVSurface` implements `Native.ILunaVideoSurface` {

  public VideoSurface(Activity activity, IWediaDTVManager dtvManager) {
    super(activity, dtvManager, IWediaDTVManager.DISP_LAYER_PRIMARY_VIDEO_ID);

    mActivity = activity;
    mDtvManager = dtvManager;

    // get the current screen dims for clamping the video window to the
    // on screen region
    // get the screen display size
    DisplayMetrics displayMetrics = new DisplayMetrics();
    activity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);

    // hardcode subtitles surface size based on display metrics
    mScreenWidth = displayMetrics.widthPixels;
    mScreenHeight = displayMetrics.heightPixels;
  }
}

app/src/main/java/com/sky/lunaruntime/IWediaDTVSurface.java

class IWediaDTVSurface extends SurfaceView {

  IWediaDTVSurface(Context context, IWediaDTVManager dtvManager, int layerId) {
    super(context);
  }

  private SurfaceHolder.Callback mCallback = `new SurfaceHolder.Callback`() {

    @Override
      public void `surfaceCreated`(SurfaceHolder surfaceHolder) {
        if (DBG) Log.d(TAG, "Surface for layer " + mLayerId + " created");

        // get the underlying surface
        Surface surface = surfaceHolder.getSurface();
        if (surface == null) {
          Log.e(TAG, "Failed to get the underlying surface");
          return;
        }

        // and attach to the DTV manager
        `mDtvManager.attachSurface`(`mLayerId`, surface);
      }
  }
}

Android/Sdk/platforms/android-27/android.jar!/android/view/SurfaceView.class
import android.view.SurfaceView;


class IWediaDTVManager {

  /**
   * The possible layer ids to assign a surface to.
   */
  public static final int DISP_LAYER_PRIMARY_VIDEO_ID = 0;
  public static final int DISP_LAYER_GFX_ID_0 = 16;

  public void `attachSurface`(int layerId, Surface surface) {

    // add the surface to our internal map
    mSurfaceMapping.put(layerId, surface);

    // if we have a DTV manager (ie. the service is connected) then add the binding
    if (mDtvManager != null) {
      `bindSurface`(layerId, surface);
    }
  }

  /**
   * Binds the supplied surface to the DTV layer in the service.
   * <p>
   * The lock must be held before calling this method.
   *
   * @param id the id of the layer to bind the surface to.
   * @param surface the surface to be bound.
   * @return true on success, false on failure.
   */
  private boolean bindSurface(int id, Surface surface) {

    // sanity check the lock is held before this call
    if (DBG && !mDtvManagerLock.isLocked())
      Log.e(TAG, "The mDtvManagerLock must be held before calling this method");

    // sanity check we have a DTV manager
    if (mDtvManager == null) {
      Log.e(TAG, "Invalid DtvManager");
      return false;
    }

    // SkyLunaRuntime/app/libs/com.iwedia.comedia.service.comm-release.jar!/com/iwedia/dtv/display/SurfaceBundle.class

    try {
     
      // *plumbing-to-as-iwedia*
      // The following line sets the actual subtitles surface to the AS service

      // SkyLunaRuntime/app/libs/com.iwedia.comedia.service.comm-release.jar!/com/iwedia/dtv/display/IDisplayControl.class

      A4TVStatus status = mDtvManager.getDisplayControl()
        .`setVideoLayerSurface`(id, `new SurfaceBundle(surface)`);
      if (status == A4TVStatus.SUCCESS) {
        Log.i(TAG, "Surface for layer " + id + " bound to DTV display controller");
      } else {
        Log.e(TAG, "Error on passing surface to AS service (" + status.getValue() + ")");
        return false;
      }

    } catch (RemoteException e) {
      Log.e(TAG, "Remote exception occurred talking to AS", e);
      return false;
    }

    return true;
  }
}

app/src/main/java/com/sky/lunaruntime/Renderer.java

public class Renderer implements ModdedGLSurfaceView.Renderer {

  @Override
    public void onSurfaceCreated(GL10 gl, EGLConfig config, int width, int height) {

      if (mInited.compareAndSet(false, true)) {

        // get the context, this should never fail, if it does it means the Activity has finished ?
        Context context = mContext.get();
        if (context == null)
          Log.wtf(TAG, "failed to get main android context");

        // initialise the luna engine (even if context is null)
        `com.sky.lunaruntime.Native.initLuna`(context,
            getClass().getClassLoader(),
            width, height,
            mMetrics.xdpi, mMetrics.ydpi);

        // register video window(s)
        for(int i = 0; i < mVideoWindows.size(); i++) {
          com.sky.lunaruntime.Native.registerVideoWindow(
              mVideoWindows.keyAt(i), mVideoWindows.get(i));
        }

        // finally start Luna
        com.sky.lunaruntime.Native.startLuna(mPath, mCallback);
        return;
      }

      Native.surfaceRestored();
    }
}


{
  //  Register a callback to be invoked when a hardware key is pressed in this view.
  mGlView.setOnKeyListener(new KeyListener(mActivity, params));
}


={============================================================================
*kt_dev_skymw_0000* skymw-jira

<skymw-jira-airplay>

<NGDEV-141186>

// delegate if
else if (CFEqual(inProperty, CFSTR(kAirPlayKey_FirmwareRevision))) {

// [String] Firmware revision of the accessory.
#define kAirPlayKey_FirmwareRevision	"firmwareRevision"

have to use SPM_API_SYSINFO_PROPID_STB_SW_VER

// from http if
// [Boolean] Support sending UDP beacon as keep alive.
#define kAirPlayKey_KeepAliveLowPower "keepAliveLowPower"
need to change it to false

kAirPlayKey_KeepAliveSendStatsAsBody  387 AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c     CFDictionarySetValue(info, CFSTR(kAirPlayKey_KeepAliveSendStatsAsBody), kCFBooleanFalse); // Supports statistics as part of the keep alive body.

// from http if
// [Boolean] Whether the receiver supports statistics as part of the keep alive body.
#define kAirPlayKey_KeepAliveSendStatsAsBody "keepAliveSendStatsAsBody"
need to change it to false

// [Boolean] Returns true if the AirPlay name is the factory default name
#define kAirPlayProperty_NameIsFactoryDefault "nameIsFactoryDefault"

    else if (CFEqual(inProperty, CFSTR(kAirPlayKey_Name))) {

.654538 !MIL   -AS           < p:00000dec t:7a1fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 2019-05-16 10:40:41.629209 AM [AirtuneDelegate] <- Name being set is Sky4027  


<NGDEV-141186>

<decode>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c


typedef struct
{
	UInt32		mNumberChannels;
	UInt32		mDataByteSize;
	void *		mData;
	
}	AudioBuffer;

typedef struct
{
	UInt32			mNumberBuffers;
	AudioBuffer		mBuffers[ 1 ];
	
}	AudioBufferList;

_AudioDecoderDecodeFrame()
{
  // note that it is local
  AudioBufferList							bufferList;

  packetCount									= inSession->samplesPerFrame;

  bufferList.mNumberBuffers					= 1;
  bufferList.mBuffers[ 0 ].mNumberChannels	= ctx->channels;
  bufferList.mBuffers[ 0 ].mDataByteSize		= (uint32_t) inDstMaxLen;
  bufferList.mBuffers[ 0 ].mData				= inDstPtr;

  AudioConverterFillComplexBuffer(
      inSession->audioConverter, 
      _AudioDecoderDecodeCallback,  // pass function pointer
      inSession,
      &packetCount,                 // samples per frame 
      &bufferList,                  // buffer list
      NULL );
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioConverterStub.c
// called as many as needed to decode chunk of audio

AudioConverterFillComplexBuffer()
OSStatus AudioConverterFillComplexBuffer(
    AudioConverterRef inConverter, 
    AudioConverterComplexInputDataProc inInputDataProc,
    void* inInputDataProcUserData,
    uint32_t* ioOutputDataPacketSize,   // samples per frame
    AudioBufferList* outOutputData,     // buffer list
    AudioStreamPacketDescription* outPacketDescription)
{
  switch (me->sourceFormatID) {

    // ALAC
    case kAudioFormatAppleLossless:
      return _AudioConverterFillComplexBufferALACDecode(
          inConverter, 
          inInputDataProc, 
          inInputDataProcUserData, 
          ioOutputDataPacketSize,   // in/out, size to decode and size that decoded
          outOutputData, 
          outPacketDescription);

    case kAudioFormatMPEG4AAC:
      // AAC LC to PCM
      return _AudioConverterFillComplexBufferAACDecode(inConverter, inInputDataProc, inInputDataProcUserData, ioOutputDataPacketSize, outOutputData, outPacketDescription);

    default:
      return kUnsupportedErr;
  }
}

<flush>

static HTTPStatus _requestProcessFlushBuffered()
{
  err = AirPlayReceiverSessionFlushAudio(inCnx->session, flushFromP, flushUntil, &lastPlayedTS);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.h
// @abstract 
// Flush any queued audio until the specified timestamp or sequence number.

AirPlayReceiverSessionFlushAudio()
{
  err = AudioConverterReset(inSession->audioConverter);
}

// AP2 SDK

OSStatus AudioConverterReset(AudioConverterRef inConverter)
{
  (void)inConverter;

  // $$$ TODO: Discard any data buffered by the codec

  AudioConverterPrivateRef const me = (AudioConverterPrivateRef)inConverter;

  switch (me->sourceFormatID) {

    case kAudioFormatMPEG4AAC:
      _FlushAACDecoder(inConverter);
  }

  return (kNoErr);
}


// AP1 SDK

// AudioStreamer/AirplaySdk/AirPlayAudioPOSIXReceiver211.1.p8/Support/AudioConverterLite.c

OSStatus	AudioConverterReset_compat( AudioConverterRef me )
{
  (void) me;

  // Nothing to do here.

  return( kNoErr );
}

// from LOG

KT: audioGetData(0 230596533307 0x78f3597c 8820)
KT: audioGetData(2205 230646111351 0x78f3597c 8820)
KT: audioGetData(4410 230696437499 0x78f3597c 8820)
KT: audioGetData(6615 230746918462 0x78f3597c 8820)
KT: audioGetData(8820 230796348590 0x78f3597c 8820)
KT: audioGetData(11025 230846362117 0x78f3597c 8820)
KT: audioGetData(13230 230896336344 0x78f3597c 8820)
KT: audioGetData(15435 230946897891 0x78f3597c 8820)
KT: audioGetData(17640 230996312937 0x78f3597c 8820)
KT: audioGetData(19845 231046380775 0x78f3597c 8820)
KT: audioGetData(22050 231096312862 0x78f3597c 8820)

>>> 985635-983430
2205
>>> 2205-1595
610
>>> 610/44.1
13.83219954648526 ~~ 14ms but 26ms in PCM output?

985635, 22.350
18051:NDS: ^0000000252.850650 !MIL   -AS           < 1970-01-01 12:04:12.850632 AM [AirPlay] Concealed 1595 unit gap (985635 vs 987230), curr seq 26233
18052:NDS: ^0000000252.850667 !MIL   -AS           < 1970-01-01 12:04:12.850632 AM [AirPlay] Concealed 1595 unit gap (985635 vs 987230), curr seq 26233

25016:NDS: ^0000000264.298628 !MIL   -AS           < 1970-01-01 12:04:24.298610 AM [AirPlay] Concealed 2042 unit gap (1490580 vs 1492622), curr seq 27667
25017:NDS: ^0000000264.298645 !MIL   -AS           < 1970-01-01 12:04:24.298610 AM [AirPlay] Concealed 2042 unit gap (1490580 vs 1492622), curr seq 27667

31732:NDS: ^0000000275.496637 !MIL   -AS          < 1970-01-01 12:04:35.496619 AM [AirPlay] Concealed 1612 unit gap (1984500 vs 1986112), curr seq 29063
31733:NDS: ^0000000275.496655 !MIL   -AS          < 1970-01-01 12:04:35.496619 AM [AirPlay] Concealed 1612 unit gap (1984500 vs 1986112), curr seq 29063

37098:NDS: ^0000000284.702606 !MIL   -AS          < 1970-01-01 12:04:44.702588 AM [AirPlay] Concealed 727 unit gap (2390220 vs 2390947), curr seq 30209
37099:NDS: ^0000000284.702624 !MIL   -AS          < 1970-01-01 12:04:44.702588 AM [AirPlay] Concealed 727 unit gap (2390220 vs 2390947), curr seq 30209

43855:NDS: ^0000000295.902600 !MIL   -AS          < 1970-01-01 12:04:55.902582 AM [AirPlay] Concealed 302 unit gap (2884140 vs 2884442), curr seq 31608
43856:NDS: ^0000000295.902618 !MIL   -AS          < 1970-01-01 12:04:55.902582 AM [AirPlay] Concealed 302 unit gap (2884140 vs 2884442), curr seq 31608

3168585, 71.850
47357:NDS: ^0000000302.348641 !MIL   -AS          < 1970-01-01 12:05:02.348619 AM [AirPlay] Concealed 286 unit gap (3168585 vs 3168871), curr seq 32410
47358:NDS: ^0000000302.348659 !MIL   -AS          < 1970-01-01 12:05:02.348619 AM [AirPlay] Concealed 286 unit gap (3168585 vs 3168871), curr seq 32410

3318525, 75.250
48777:NDS: ^0000000305.746622 !MIL   -AS          < 1970-01-01 12:05:05.746564 AM [AirPlay] Concealed 1170 unit gap (3318525 vs 3319695), curr seq 32834
48778:NDS: ^0000000305.746644 !MIL   -AS          < 1970-01-01 12:05:05.746564 AM [AirPlay] Concealed 1170 unit gap (3318525 vs 3319695), curr seq 32834


>>> 985635/44100
22
>>> (985635%44100)/44.1
350.0


KT: nowTs=806326, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552521935, srcTS=806326
KT: nowTs=806326, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552521935, srcTS=806326
KT: pktTS=3552522287 src->rtpOffsetActive=743240662 inSession->audioLatencyOffset=11025
KT: pktTS=3552522287 src->rtpOffsetActive=743240662 inSession->audioLatencyOffset=11025
KT: nowTs=806678, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552522287, srcTS=806678
KT: nowTs=806678, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552522287, srcTS=806678


<skymw-jira-android>

keitee@keitee-mint:~/ip/repo/SkyBluetoothRcu$ git show --stat

commit c472491d870088f3afaffd7863bc5c4ce4697078 (HEAD -> NGDEV-143556_IP100_Support_RCU_pairing_without_infrared, origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared)
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jun 25 14:48:07 2019 +0100

    NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

    Quote from
    https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Bluetooth+RCU+Pairing+Without+Infrared:

    In the v2.1.0 release of the SkyBluetoothRcu code for Android an experimental
    feature was added in the debug builds to put the bluetooth code in 'searching'
    mode for 30 seconds. In search mode the code will look for any nearby BT RCU
    devices that are in pairing mode, when / if found it will automatically start
    pairing to it. Only the first RCU found in pairing mode will trigger the STB
    pairing code, subsequent found devices will be ignored (until 'searching' mode
    is enalbed once again).

    It works by looking for the special advertising packets sent by the BT RCU
    when you hold the 1 and 3 buttons. The BT RCU will send these special packets
    for 10 seconds after entering pairing mode.

 app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl         |  2 ++
 app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl |  2 +-
 app/src/main/cpp/blercu/blercucontroller.cpp                 | 37 +++++++++++++++++++++++++++++++++----
 app/src/main/cpp/blercu/blercucontroller.h                   | 11 ++++++++++-
 app/src/main/cpp/blercu/blercucontroller_p.h                 |  2 ++
 app/src/main/cpp/blercu/blercupairingstatemachine.h          |  1 +
 app/src/main/cpp/debug/wshandler.cpp                         |  2 +-
 app/src/main/cpp/service/android/blercuservice.cpp           | 57 +++++++++++++++++++++++++++++++++++++++++++++++++--------
 app/src/main/cpp/service/android/blercuservice.h             |  9 ++++++++-
 app/src/main/java/com/sky/blercu/BleRcuService.java          | 24 +++++++++++++-----------
 10 files changed, 120 insertions(+), 27 deletions(-)

* c472491 : (HEAD -> NGDEV-143556_IP100_Support_RCU_pairing_without_infrared, origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared) NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared (23 hours ago) <Kit Park>
* d9f1809 : NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared (24 hours ago) <Kit Park>

keitee@keitee-mint:~/ip/repo/SkyBluetoothRcu$ git show --stat d9f1809
commit d9f1809e6ab0bb5bf4d500dfa82f5207ea3ef605
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jun 25 14:24:20 2019 +0100

    NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

    As a part of delivery, applies clang style, Mozilla, to files before a commit
    which has actual changes so that can have clean base to show only differences to
    review.

 app/src/main/cpp/blercu/blercucontroller.cpp        |  906 ++++++++++++++++++++++++++------------------------
 app/src/main/cpp/blercu/blercucontroller.h          |   52 ++-
 app/src/main/cpp/blercu/blercupairingstatemachine.h |  192 +++++------
 app/src/main/cpp/debug/wshandler.cpp                |  188 ++++++-----
 app/src/main/cpp/service/android/blercuservice.cpp  | 3192 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------
 app/src/main/cpp/service/android/blercuservice.h    |  447 ++++++++++++++-----------
 6 files changed, 2637 insertions(+), 2340 deletions(-)


<add-start-scan-call>

add startScanning(int timeout); to client if

app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
app/src/main/java/com/sky/blercu/BleRcuService.java

	public BleRcuService(long qtObject) {
		//
		mQtObject = qtObject;
   }

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {

		`private BleRcuService mService;`

		private BleRcuServiceBinder(BleRcuService svc) {
			mService = svc;
		}
		public boolean cleanup() {
			mService = null;
			return true;
		}

		public BleRcuService getService() {
			if (mService != null && mService.isAvailable()) {
				return mService;
			}
			return null;
		}

		public String getDeviceName(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceName(`service.mQtObject`, address);
		}

	private native String jniGetDeviceName(long qtObject, String address);


app/src/main/cpp/service/android/blercuservice.cpp

bool BleRcuService::registerNatives()
{
		JNI_ENTRY(jniGetDeviceName,               "(JLjava/lang/String;)Ljava/lang/String;"),
}

jstring BleRcuService::jniGetDeviceName(JNIEnv *env, jobject, `jlong qtObject`,
                                        jstring address)
{
	return jniGetDeviceInfo(env, qtObject, address, DeviceName);
}

app/src/main/cpp/service/android/blercuservice.h

keitee@keitee-mint:~/ip/BleRcuExample$ cp ../SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl


<ble-example-client>

app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/blercu/IBleRcuService.java
 * This file is auto-generated.  DO NOT MODIFY.


<ble-callback>

// app/src/main/cpp/blercu/blercucontroller.cpp

BleRcuControllerImpl::BleRcuControllerImpl()
{
  *emit-started*
  // connect to the finished signal of the pairing statemachine, use to update
  // our list of managed devices
  QObject::connect(&m_pairingStateMachine, `&BleRcuPairingStateMachine::finished`,
      this, &BleRcuControllerImpl::onFinishedPairing,
      Qt::QueuedConnection);

  // connect to the started signal so we can send pairing state notifications
  QObject::connect(&m_pairingStateMachine, `&BleRcuPairingStateMachine::started`,
      this, &`BleRcuControllerImpl::onStartedPairing`,
      Qt::QueuedConnection);

  QObject::connect(this, &`BleRcuController::pairingStateChanged`,
      m_analytics.data(), &BleRcuAnalytics::logPairingStateChange,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onStartedPairing()
{
  // a queued event so check the state
  const bool pairing = m_pairingStateMachine.isRunning();

  qMilestone() << "KT: tell clients that the pairing state has changed";

  // tell clients that the pairing state has changed
  emit pairingStateChanged(pairing);
}

void BleRcuControllerImpl::onFinishedPairing()
{
  // a queued event so check the state
  const bool pairing = m_pairingStateMachine.isRunning();

  // (re)sync our list of managed devices now pairing has finished
  if (!pairing)
    syncManagedDevices();

  qMilestone() << "KT: tell clients that the pairing state has changed";

  // tell clients that the pairing state is changed
  emit pairingStateChanged(pairing);
}

// app/src/main/cpp/service/android/blercuservice.cpp

void BleRcuService::setController(const QSharedPointer<BleRcuController> &controller)
{
  QObject::connect(controller.data(), &`BleRcuController::pairingStateChanged`,
      this, `&BleRcuService::onPairingStateChanged`);
}

void BleRcuService::onPairingStateChanged(bool pairing)
{
  m_javaBleRcuService->callMethod<void>("onPairingStateChanged",
      "(Z)V",
      static_cast<jboolean>(pairing ? JNI_TRUE : JNI_FALSE));
}

void BleRcuAnalytics::logPairingStateChange(bool pairing)
{
  if (pairing)
    qProdLog("KT: logPairingStateChange: started bluetooth RCU pairing procedure");
  else
    qProdLog("KT: logPairingStateChange: finished bluetooth RCU pairing procedure");
}

app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {

	final RemoteCallbackList<IBleRcuServiceCallback> mCallbacks =
		new RemoteCallbackList<IBleRcuServiceCallback>();

	/**
	 * Expected to be called by the native C++ code when the pairing process
	 * has started or stopped.
	 *
	 */
	public void onPairingStateChanged(final boolean pairing) {

		mServiceLock.writeLock().lock();
		boolean triggerCallback = (mIsPairing != pairing);
		mIsPairing = pairing;
		mServiceLock.writeLock().unlock();

		if (triggerCallback && mNotifyThread.isAlive()) {

			// broadcast back to clients from the notify thread
			mNotifyThread.mHandler.post(() -> {

				final int n = mCallbacks.beginBroadcast();
				for (int i = 0; i < n; i++) {
					try {
						mCallbacks.getBroadcastItem(i).onPairingChanged(pairing);
					} catch (RemoteException e) {
						// RemoteCallbackList will take care of removing dead objects
					}
				}

				`mCallbacks`.finishBroadcast();
			});
		}
	}
}

<port-to->

/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
main.cpp

setupBleRcuController()
{
  // create the manager object
  QSharedPointer<BleRcuManager> manager =
    QSharedPointer<BleRcuManagerImpl>::create(config,
        deviceFactory,
        QDBusConnection::systemBus());

  // create the controller object
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(
        config, 
        `manager`,
        options->networkNamespace());
}


/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
blercu/blercumanager.cpp

class BleRcuManagerImpl : public BleRcuManager

	StateMachine m_stateMachine;


/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
blercu/blercucontroller.cpp

	BleRcuPairingStateMachine m_pairingStateMachine;


xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/console/source/
dbus/dbusabstractinterface.cpp


<xx>
this is when a device is ready when pairing fsm is not running.

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[DeviceStateMachine] moving from state StartingServices(5) to ReadyState(6)"
I BleRcuQt: < M:blercuadapter.cpp F:onDeviceReadyChanged L:1733 > device with address D4:B8:FF:12:E1:A8 is  ready
D ServicePeripherals: @BTREMOTE: onDeviceConnectionStateChanged | address: D4:B8:FF:12:E1:A8 connected: true
D BleRcuManager: onDeviceConnectionStateChanged() - D4:B8:FF:12:E1:A8 : true


<git-flow-bluez>
git checkout -b NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared_backward

meld /home/keitee/ip/SkyBluetoothRcu-clean/app/src/main/cpp/blercu /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/blercu &

gvim /home/keitee/ip/SkyBluetoothRcu-clean/app/src/main/cpp/blercu/blercupairingstatemachine.cpp /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.cpp

git flow feature start NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

$ git branch -vv
* feature/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared d27b0d10e Increment Telemetria App version to 2.0.2

// for a review
// *skymw-repo-ai* To git.stb.bskyb.com:appinfrastructure

git push --set-upstream origin feature/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

git push -n origin feature/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

// Someone else might have changed something
git pull --rebase

*git-two-dot*
git log origin/develop..HEAD


keitee@keitee-mint:~/mw/appinfrastructure$ git flow feature finish --help
usage: git flow feature finish [-h] [-F] [-r] [-p] [-k] [-D] [-S] [--no-ff] <name|nameprefix>

    Finish feature <name>

    -h, --help            Show this help
    --showcommands        Show git commands while executing them
    -F, --[no]fetch       Fetch from origin before performing finish
    -r, --[no]rebase      Rebase before merging
    -p, --[no]preserve-merges
                          Preserve merges while rebasing
    --[no]push            Push to origin after performing finish
    -k, --[no]keep        Keep branch after performing finish
    --keepremote          Keep the remote branch
    --keeplocal           Keep the local branch
    -D, --[no]force_delete
                          Force delete feature branch after finish
    -S, --[no]squash      Squash feature during merge
    --no-ff               Never fast-forward during the merge


<skymw-jira-bluez>

NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

This is clone of NGDEV-143556[1] to bring the same feature onto DTH Q. Before
doing that, Bluetooth code in DTH Q may be updated and be synced with IP100
codebase since DTH Q is left behind and IP100 is moved away which makes many
differences between two base. 

Therefore, the efforts is made to have as common base as possible between them
and have a new feature on top of that. Refer to [1] for more details of the new
feature. 

This also has corresponding test caes in support of features and changes.

[1] NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared


git flow feature start NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared_compatibility_fix

git push -n origin feature/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

While delivering NGDEV-143989[1], we have found that it is better to maintain
compatibility in terms of paring state which application counts on until
application moves to new state change and old pairing state becomes obsolete. 

This commit includes changes to update pairing state when pairing attempts fails.

[1] NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

<skymw-jira-luna>

git checkout -b NGDEV-144531_Luna_-_update_to_support_DTT_video_on_IP150_/_IP051


={============================================================================
*kt_dev_skymw_0000* skymw-todo

NDS: ^0000027250.001939 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onStartDiscoveryReply L:00959 > discovery start request failed with error QDBusError("org.bluez.Error.InProgress", "Operation already in progress")
NDS: ^0000027252.282777 !MIL   -SYSTEMTIME   < p:00000dda t:b5a10440 T:SYSTEMTIME_NOTIFICATION_THREAD M:systemtime_monotonic.c F:SYSTEMTIME_TimeStampCallback L:02242 > Time is (Year:Month:Day:Hour:Min:Sec) 2019:07:12:01:38:14
NDS: ^0000027255.001136 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onDiscoveryWatchdog L:01064 > detected discovery in the wrong state (expected:on actual:off)
NDS: ^0000027255.003794 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onStartDiscoveryReply L:00959 > discovery start request failed with error QDBusError("org.bluez.Error.InProgress", "Operation already in progress")
NDS: ^0000027257.282896 !MIL   -SYSTEMTIME   < p:00000dda t:b5a10440 T:SYSTEMTIME_NOTIFICATION_THREAD M:systemtime_monotonic.c F:SYSTEMTIME_TimeStampCallback L:02242 > Time is (Year:Month:Day:Hour:Min:Sec) 2019:07:12:01:38:19
NDS: ^0000027260.000971 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onDiscoveryWatchdog L:01064 > detected discovery in the wrong state (expected:on actual:off)
NDS: ^0000027260.001910 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onStartDiscoveryReply L:00959 > discovery start request failed with error QDBusError("org.bluez.Error.InProgress", "Operation already in progress")


#{============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
