*kt_dev_sky_mw*                                                     tw=100, utf-8

/^[#=]{
Use #{ for a group and ={ for a item

Write what you know and konw what you write. - EXC++, Herb Sutter

An expert is a man who has made all the mistakes that can be made, in a very
narrow field. -Nils Bohr

TODO:
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. SKYMW

*kt_dev_skymw_0000* skymw-setup
*kt_dev_skymw_0000* skymw-pages
*kt_dev_skymw_0000* skymw-commands
*kt_dev_skymw_0000* skymw-git
*kt_dev_skymw_0000* skymw-q-hardware
*kt_dev_skymw_0000* skymw-q-package
*kt_dev_skymw_0000* skymw-build
*kt_dev_skymw_0000* skymw-epg
*kt_dev_skymw_0000* skymw-as
*kt_dev_skymw_0000* skymw-as-airplay
*kt_dev_skymw_0000* skymw-ai-input-handler
*kt_dev_skymw_0000* skymw-bluez
*kt_dev_skymw_0000* skymw-bluez-as
*kt_dev_skymw_0000* skymw-bluez-dbus
*kt_dev_skymw_0000* skymw-bluez-q
*kt_dev_skymw_0000* skymw-bluez-audio-stream
*kt_dev_skymw_0000* skymw-android
*kt_dev_skymw_0000* skymw-android-service
*kt_dev_skymw_0000* skymw-android-studio
*kt_dev_skymw_0000* skymw-android-skybluez
*kt_dev_skymw_0000* skymw-android-bluetoothrcu
*kt_dev_skymw_0000* skymw-android-ip150
*kt_dev_skymw_0000* skymw-luna
*kt_dev_skymw_0000* skymw-rdk
*kt_dev_skymw_0000* skymw-jira-airplay
*kt_dev_skymw_0000* skymw-jira-android
*kt_dev_skymw_0000* skymw-jira-q
*kt_dev_skymw_0000* skymw-jira-luna
*kt_dev_skymw_0000* skymw-todo


={============================================================================
*kt_dev_skymw_0000* skymw-setup

<skymw-setup-amidala>
/home/keitee/mw/tftproot/amidala

192.168.0.100:titan/zImage"

setenv serverip 192.168.0.101
setenv tftp_dir amidala
setenv autoload no
setenv tftp_path "$serverip:$user_name/$tftp_dir"
setenv kernel "$tftp_path/zImage"
setenv dtb "$tftp_path/sdk2_stih418-amidala.dtb"
setenv load_addr "0x82008000"
setenv fdt_addr "0x94000000"
setenv bootm "dhcp;tftp $load_addr $kernel;tftp $fdt_addr $dtb;dcache off;bootz $load_addr - $fdt_addr"
setenv bootcmd "run bootm"
setenv bootargs "remotedir=192.168.0.101:/home/keitee/mw/exports/amidala/flash0"
setenv bootdelay 2
saveenv
reset

bootm=dhcp;tftp 0x82008001 192.168.0.101:/amidala/zImage;tftp 0x94000000 192.168.0.101:/amidala/sdk2_stih418-amidala.dtb;dcache off;bootz 0x82008000 - 0x94000000

<tftp>
sudo apt-get install tftpd-hpa

cat /etc/default/tftpd-hpa 

# /etc/default/tftpd-hpa

TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/opt/tftpboot"
TFTP_ADDRESS=":69"
TFTP_OPTIONS="--secure"

<nfs>
sudo apt-get install nfs-kernel-server


<skymw-setup-titan-boot>

/home/keitee/mw/tftproot/titan

mount -o rw -t nfs 192.168.0.101:/home/keitee/mw/exports/titan/flash0 /mnt/x

// should be careful not to include the end of line when pasting it into bolt
// command line

setenv -p STARTUP "ifconfig eth0 -auto;boot 192.168.1.5:falcon_d1/zImage 'console=ttyS0,115200 ip=udhcp mesh=off vmalloc=334M brcm_cma_kern_rsv=416M remotedir=192.168.1.5:/export/flash0_falcon_d1'"

// shall have quote ""
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage"
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.101:/titan/zImage ‘remotedir=192.168.0.101:/home/keitee/mw/exports/titan/flash0'"
// setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage console=ttyS0,115200 ip=udhcp vmalloc=300M brcm_cma_kern_rsv=450M remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0"

// error since copied from word document and found that dash(-) causes the
// issue when used on bolt bootloader
setenv -p STARTUP "ifconfig eth0 –auto; boot 192.168.0.100:/titan/zImage ‘remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0'"

<ai-build-for-pc>
sudo apt-get install automake
sudo apt-get install libxslt-dev


={============================================================================
*kt_dev_skymw_0000* skymw-mw

https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=2016&title=Application+Infrastructure+Architecture


={============================================================================
*kt_dev_skymw_0000* skymw-commands

ls -al /opt/airplay/audio.out.pcm
touch /opt/airplay/audio.out.pcm; chmod 777 /opt/airplay/audio.out.pcm
rm /mnt/nds/dev_13/part_0/FSN_DATA/LOG

cp /mnt/nds/dev_13/part_0/FSN_DATA/LOG /flash0/LOG_07; chmod 777 /flash0/LOG_07
cp /opt/airplay/audio.out.pcm /flash0/PCM_31; chmod 777 /flash0/PCM_31

tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KT|AudioConverterDispose|AudioConverterNew"
tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KEY_P|Progress|rtpSkew"

curl -v -X POST http://127.0.0.1:8008/pm/downloads/ --data http://192.168.0.105/spotify.wgt

curl -v -X DELETE http://192.168.0.102:8008/pm/packages/com.spotify.Spotify.TVv2
curl -v -X GET http://192.168.0.102:8008/pm/packages
 
// to see ip
cat /proc/net/fib_trie


={============================================================================
*kt_dev_skymw_0000* skymw-git

<ssh>
to register ssh keys
https://www.stb.bskyb.com/gosa/

<git-repos>
git clone dwngit@git.stb.bskyb.com:ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-as-source ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-mw-wrt
git clone dwngit@git.stb.bskyb.com:appinfrastructure

*skymw-ip100*
git clone ssh://kyoupark@mgt-ip100-gerrit.skyqstbbuild.com:29418/sky/platform/packages/apps/SkyBluetoothRcu


<ethan-as-source>
// needs to run git pull since no default branch?
// "develop" branch

git pull origin develop

keitee@keitee-mint:~/mw/ethan-as-source$ git checkout develop
Checking out files: 100% (25967/25967), done.

// update submodule

keitee@keitee-mint:~/mw/ethan-as-source$ git submodule update --init --force

git push -n --set-upstream origin kit-NGDEV-141186

<git>
tag: NGDEV-141186_Delivered_Develop_07062019_1057
branch NGDEV-143556_IP100_Support_RCU_pairing_without_infrared

git checkout -b NGDEV-143556_review_03 develop
git push -n origin NGDEV-143556_IP100_Support_RCU_pairing_without_infrared
git push -f origin NGDEV-143556_review:NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_2
git push origin NGDEV-143556_review_03:NGDEV-143556_IP100_Support_RCU_pairing_without_infrared
NGDEV-143556_IP100_Support_RCU_pairing_without_infrared

// no permission to do
// git push origin --delete NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_2

// check the pushed branch
git diff origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_3 HEAD

// check update
git pull --rebase origin develop

// check difference
git log develop..HEAD

git rebase develop
git rebase --onto develop <topic>

git push -n origin HEAD:refs/for/release/2.2.0

git diff --ignore-space-at-eol --stat origin/develop..HEAD


<git-flow-bluez-android> *git-flow*

git checkout -b NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

meld /home/keitee/ip/SkyBluetoothRcu-clean/app/src/main/cpp/blercu /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/blercu &
gvim /home/keitee/ip/SkyBluetoothRcu-clean/app/src/main/cpp/blercu/blercupairingstatemachine.cpp /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.cpp

// this will create a branch
git flow feature start NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

git branch --set-upstream-to=origin/develop

git branch -vv
* feature/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared d27b0d10e Increment Telemetria App version to 2.0.2

// change codes

// for a review (web)
// https://pv-jbt001.uk2.scp.bskyb.com:8443/ethan-as-source
// 
// origin:
// *git-repo-ai* To git.stb.bskyb.com:appinfrastructure

git diff origin/develop..HEAD

git push --set-upstream origin feature/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

// since uses diffrent branch name 
git push -n origin `feature`/NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

// Someone else might have changed something
git pull --rebase

// see what to push *git-two-dot*
git log origin/develop..HEAD


keitee@keitee-mint:~/mw/appinfrastructure$ git flow feature finish --help
usage: git flow feature finish [-h] [-F] [-r] [-p] [-k] [-D] [-S] [--no-ff] <name|nameprefix>

    Finish feature <name>

    -h, --help            Show this help
    --showcommands        Show git commands while executing them
    -F, --[no]fetch       Fetch from origin before performing finish
    -r, --[no]rebase      Rebase before merging
    -p, --[no]preserve-merges
                          Preserve merges while rebasing
    --[no]push            Push to origin after performing finish
    -k, --[no]keep        Keep branch after performing finish
    --keepremote          Keep the remote branch
    `--keeplocal`           Keep the local branch
    -D, --[no]force_delete
                          Force delete feature branch after finish
    -S, --[no]squash      Squash feature during merge
    --no-ff               Never fast-forward during the merge

// see no `feature` in the name
git flow feature finish -S NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared_compatibility_fix
git flow feature finish NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared_compatibility_fix


<git-flow-release>

git flow release start 1.0.7
git flow release publish 1.0.7

git flow release finish 1.0.7
git push
 
git checkout master
git push
 
git push origin --tags
git checkout develop


={============================================================================
*kt_dev_skymw_0000* skymw-q-hardware

// q hardware
https://www.stb.bskyb.com/confluence/display/2016/Q+Platform+Hardware+Specifications


={============================================================================
*kt_dev_skymw_0000* skymw-q-package

// fusion mw
// Check the SI_TARBALL.tgz at the bottom of the page.
http://hudkinsartifactory.cisco.com:8081/artifactory/formal_builds/Q/formal/Q000/Q000.021.41.00/


={============================================================================
*kt_dev_skymw_0000* skymw-build

<to-fix-titan-build-error>
export LC_ALL=C

as: loadlocale.c:129: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))' failed.
arm-linux-gcc: internal compiler error: Aborted (program as)
Please submit a full bug report,
with preprocessed source if appropriate.
See <http://gcc.gnu.org/bugs.html> for instructions.


<skymw-build-amidala>

cd /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-amidala-de

get sdk from zork
https://zork.ethan.bskyb.com/de/sdk/Q000.022.76.00/
https://zork.ethan.bskyb.com/de/sdk/Q000.022.76.00/Q__formal__Q000__Q000.022.76.00__SDK__eu-q-amidala-de__release_dbg__S__unsigned.tgz

// copy boot image
cp ~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-amidala-de/SDK/SKYEU_SKYH418_AMIDALA_LNUX_01/KERN_SKYEU_SKYH418_AMIDALA_LNUX_01/LittleEndian/debug/debug/BootImage/zImage .

./compile_sdkv2.0.sh eu-q-amidala-de /home/keitee/mw/ethan-as-source/ clean

or

cd ~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-amidala-de/SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build
./make.sh --platform bskyb-falcon-d1-uhd --project bskybgen2 --profile nds_si_devel
./utils/bskybgen2_flash_H1.sh -b bskyb-falcon-d1-uhd


sudo cp -r /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-amidala-de/SDK/flash0 /home/keitee/mw/exports/amidala



<skymw-build-as> *build-from-as-pov*

export LC_ALL=C

cd /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK

// download sdk from zork

./getSdk.sh eu-q-titan-uk HQ000

// type username/password for darwin intranet. kyoupark/

keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/bskybgen$ ll
total 2.2G
drwxr-xr-x 3 keitee keitee 4.0K Sep 17 10:31 ../
drwxr-xr-x 2 keitee keitee 4.0K Sep 17 10:32 ./
-rw-r--r-- 1 keitee keitee 2.2G Sep 17 10:35 Q__formal__Q000__Q000.022.04.00__SDK__eu-q-titan-uk__release_dbg__S__unsigned.tgz

// + cd /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/
// ++ pwd
// + dir=/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk
// + echo 'copy new SDK'
//
// keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK$ cat SDK_TAG
// 22.62.00 HQ000
// 00.04.00 X063
//
// tar -xzf ${SDK_FILE_NAME}

// copy boot image
cp ~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage /home/keitee/mw/tftproot/titan


// 2.0??
./compile_sdkv2.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/ clean

// 3.0??
./compile_sdkv3.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/

*skymw-build-output* Creating object 
/home/keitee/mw/`ethan-as-source`/xSubmoduleDarwinSDK/eu-q-titan-uk/
  SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/bskybgen2/SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/release_dbg/
  /components/bskybgen2/appinfrastructure/


// all points the same single file

ll eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
-rwxr-xr-x 1 keitee keitee 25M May 14 10:41 eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

// SDK has AI and overwrites it when updates but when want to use own/differnt 
// AI from repo
//
// `to use git-repo-ai` *git-repo-ai*
keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/
  SDK/THIRD_PARTY_LIBS_2/BSKYB_GEN2_APP_INFRASTRUCTURE$ ll


ln -s /home/keitee/mw/appinfrastructure/AppInfrastructure/ AppInfrastructure

-rw-r--r--  1 keitee keitee   63 May 14 10:41 BSKYB_GEN2_APP_INFRASTRUCTURE_tag.txt
drwxr-xr-x 66 keitee keitee 4.0K May 14 10:41 AppInfrastructure_org/
lrwxrwxrwx  1 keitee keitee   51 Jul  9 15:41 AppInfrastructure -> /home/keitee/mw/appinfrastructure/AppInfrastructure/

// do not use submodule
// keitee@keitee-mint:~/mw/ethan-as-source$ git submodule
// 76d9c62d463b35364aa7b9bd5b18b18b0f5acc04 xSubmoduleAppInfrastructure (9.38.0-10-g76d9c62d4)

// *to-use-git-repo-as*
keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/THIRD_PARTY_LIBRARIES/BSKYB_GEN2_AMS$ ll
total 12K
-rw-r--r--  1 keitee keitee   48 Sep 17 10:37 BSKYB_GEN2_AMS_tag.txt
drwxr-xr-x 10 keitee keitee 4.0K Sep 17 10:37 ../
lrwxrwxrwx  1 keitee keitee   42 Sep 17 10:40 Components -> /home/keitee/mw/ethan-as-source/Components/
drwxr-xr-x  2 keitee keitee 4.0K Sep 17 10:40 ./

// to-use-as-from-sdk
ln -s /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK_Q000.022.04.00_bskybgen2_SKY7278/THIRD_PARTY_LIBRARIES/BSKYB_GEN2_AMS /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/THIRD_PARTY_LIBRARIES/BSKYB_GEN2_AMS/Components
`

<skymw-build-ai> *build-from-ai-pov*
// build full under AS but use ai from ai-repo

keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK$ pwd
/home/keitee/mw/appinfrastructure/xSubmoduleDarwinSDK

// see that use as
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK$ ll
lrwxrwxrwx  1 keitee keitee   66 Jul  1 15:53 eu-q-titan-uk -> 
  /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk//

// build command
cd /home/keitee/mw/appinfrastructure/Tools/Jenkins
~/mw/appinfrastructure/Tools/Jenkins$ build-AI-fromSDKv2.sh eu-q-titan-uk /home/keitee/mw/appinfrastructure NO | tee build.log

// where can see compile outputs ??

Creating object /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/bskybgen2/SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/release_dbg/
/components/bskybgen2/appinfrastructure/BluetoothRcu/client/lib/source/BleRcuVoiceStreamSimDelegate.o

/home/keitee/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/bskybgen2/SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/release_dbg/
components/bskybgen2/appinfrastructure

keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk$ ls SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage
SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage


keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk$ pwd
/home/keitee/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk$ ll
total 24K
lrwxrwxrwx  1 keitee keitee   73 May 14 10:41 BSKYB_INTEGRATION_BLD.txt -> SDK/ReleaseNotes/BSKYB_INTEGRATION_BLD_21.35.00_BSKYB_HQ000_ETHAN_Int.txt
lrwxrwxrwx  1 keitee keitee   24 May 14 10:41 baseline_reasons.txt -> SDK/baseline_reasons.txt
drwxr-xr-x  5 keitee keitee 4.0K May 20 15:57 flash0/
drwxr-xr-x  2 keitee keitee 4.0K May 20 15:58 unstripped_bin/
drwxr-xr-x  5 keitee keitee 4.0K Jul  1 14:57 ./
drwxr-xr-x  3 keitee keitee 4.0K Jul  1 15:35 ../
drwxr-xr-x 35 keitee keitee 4.0K Jul  2 09:38 SDK/

// same
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK$
lrwxrwxrwx  1 keitee keitee   66 Jul  1 15:53 
eu-q-titan-uk -> /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk//

// to use `git-repo-as`
keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk/
  SDK/THIRD_PARTY_LIBRARIES/BSKYB_GEN2_AMS$ ll
-rw-r--r--  1 keitee keitee   47 May 14 10:41 BSKYB_GEN2_AMS_tag.txt
lrwxrwxrwx  1 keitee keitee   42 Jul  1 15:35 Components_org -> /home/keitee/mw/ethan-as-source/Components/
lrwxrwxrwx  1 keitee keitee   42 Jul 17 11:54 Components -> /home/keitee/mw/ethan-as-source/Components/

keitee@keitee-mint:~/mw/appinfrastructure/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK$ ls -al flash0
flash0/                  flash0_sky_TITAN.tar.gz  flash0.tar.gz

cp -r flash0/ ~/mw/exports/titan/
cp -r /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/flash0 /home/keitee/mw/exports/titan


<build-tool> *builc-gcc*
~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gcc

lrwxrwxrwx 1 keitee keitee 31 May 14 10:41 arm-linux-gcc -> arm-unknown-linux-gnueabihf-gcc*

/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01

<gcc>
export LC_ALL=C
cp /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/unstripped_bin/APP_Process .
/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gdb


<fsi-build>
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/
svn checkout svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/

http://10.184.136.138:8081/view/SI%20build%20Jobs/job/FULL_STACK_SI_BUILD/69/consoleFull

+ cd FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials --baseline Q000.021.42.00

+ create_version_string_from_baseline
+ local VERSION_CFG=projects/bskybgen2/fs/NDS/config/overrides/version.cfg
+ local VERSION_H=projects/bskybgen2/inc/version.h
+ local 'VERSION_SECTION=[VERSION]'
+ local VERSION_TAG=NDS_SW_VERSION
+ local PLATFORM_TAG=PLATFORM
+ echo 'Checking & calculating Version string - '\''sky_trials'\'' '\'''\'''
Checking & calculating Version string - 'sky_trials' ''
python tools/nds/si/python/version_string_calculation.py ${PROFILE} ${BASELINE}
++ python tools/nds/si/python/version_string_calculation.py sky_trials
+ VERSION_STRING='~*~dev version~*~'
+ '[' 0 -ne 0 ']'
+ echo 'VERSION = ~*~dev version~*~'
VERSION = ~*~dev version~*~
+ echo '[VERSION]'
+ echo 'NDS_SW_VERSION="~*~dev version~*~"'
+ echo 'PLATFORM="eu-q-titan-uk"'


./build_mw_epg.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --nomake
./make_image.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --project bskybgen2


={============================================================================
*kt_dev_skymw_0000* skymw-epg

git clone -b master ssh://dwngit@git.stb.bskyb.com/ethan-qt-epg-app epg

epg/source/prod_epg/epg_ui/src/ui_models/BTRemoteModel.cpp


={============================================================================
*kt_dev_skymw_0000* skymw-as

// as-spec
https://www.stb.bskyb.com/confluence/pages/viewpage.action?pageId=9538192

<as-rest> <comp-asda>
http://build01.mw.ethan.bskyb.com/asda/#

192.168.0.104:9005

curl -v -X GET http://192.168.0.102:9005/as/system/information

curl -v -X GET http://192.168.0.102:8008/pm/packages

curl -v -X GET http://192.168.0.102:9005/peripherals/btremotes/edidinfo

curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Host: 192.168.0.102:9005" -H "Origin:" http://192.168.0.102:9005/as/peripherals/btremotes/status

// from curl
curl -v -X POST http://192.168.0.102:9005/as/peripherals/btremotes/action/startsearching?timeout=30

// from asda
peripherals/btremotes/action/startsearching?timeout=30

curl 192.168.0.102:9005/as/test/preferences -X POST --data '{"enableirinput":"false"}'

// 
{
   "remotes" : [
      {
         "batterylevel" : 90,
         "bdaddr" : "70:91:F3:22:6E:22",
         "btlswver" : "BL 195",
         "connected" : true,
         "deviceid" : 2387,
         "hwrev" : "102.0.0.1",
         "make" : "Universal Electronics, Inc.",
         "model" : "Sky EC102",
         "name" : "P047 SkyQ EC102",
         "rcuswver" : "7007.02.09",
         "serialno" : "226E22F39170"
      }
   ],
   "status" : "COMPLETE"
}

// 
{
   "remotes" : [
      {
         "batterylevel" : 73,
         "bdaddr" : "D4:B8:FF:12:E1:A8",
         "btlswver" : "2.0",
         "connected" : false,
         "deviceid" : 2615,
         "hwrev" : "101.2.0.0",
         "make" : "Omni Remotes",
         "model" : "EC101",
         "name" : "P236 SkyQ EC101",
         "rcuswver" : "1.0.5",
         "serialno" : "D4B8FF12E1A8"
      }
   ],
   "status" : "PAIRING"
}


={============================================================================
*kt_dev_skymw_0000* skymw-as-airplay

<as-airplay>
/ethan-as-source/Components/AudioStreamer

<airplay-setting>
http://192.168.0.102:13579/index.html

<airplay-sdk-build>
/ethan-as-source/Components/AudioStreamer/AirplaySdk2

export LC_ALL=C
make libraries platform=Titan

<airplay-logging>

// from apple and prints two lines

acs_ulog(kLogLevelNotice, "KT: AudioConverterReset: ALAC: DO NOTHING \n");

NDS: ^0000000694.438133 !MIL   -AS           < p:00000e12 t:6e754dc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 
  > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:34.438098 AM [AirPlayACS] 
  KT: AudioConverterReset: ALAC: DO NOTHING 

// works by default and on MIL

at_app_ulog(kLogLevelNotice, "KT: kAirPlayProperty_NameIsFactoryDefault = %d\n", value);
  #define at_app_ulog(LEVEL, ...) ulog(at_app_ucat(), (LEVEL), __VA_ARGS__)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/AccessorySDK/Support/LogUtils.c
int LogPrintF(LogCategory* inCategory, const char* inFunction, LogLevel inLevel, const char* inFormat, ...)
{
    int n;
    va_list args;

    va_start(args, inFormat);
    n = LogPrintV(inCategory, inFunction, inLevel, inFormat, args);
    va_end(args);
    return (n);
}


// print single line

TRACE("KT: integration::checkNameIsFactoryDefault:\n");
  #define TRACE(...) { LogInterfaceInToDiag(0,__VA_ARGS__);}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp
void LogInterfaceInToDiag(int level,const char*format,...)
{
  char buffer[256];
  va_list args;
  va_start (args, format);
  vsnprintf (buffer,256,format, args);
  va_end (args);
  if (interfaceLoggingFunction != NULL)
    interfaceLoggingFunction(level,buffer);
}

AudioStreamer::AirPlayProtocol::AirPlayProtocol(uint8_t macAddress[6])
    : m_audioAvailable(true)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
  ::memcpy (m_macAddress, macAddress, 6);
  AirPlay::Player::createInstance(this);
  AirPlay::Player::instance().registerAirplaySDKDiagLogFunction(AirplaySDKDiagLog);
  AirPlay::Player::instance().registerInterfaceDiagLogFunction(AirplayinterfaceDiagLog);
#ifdef ENABLE_AIRPLAY_2
  dobbyPTPLxc = std::make_shared<ptpdobbyfactory::PtpDobbyFactory>("PTPAirplay");
#endif

  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
}

void AirplayinterfaceDiagLog(int level ,const char* msg)
{
  (void) level;
  printf("2---%s \n ",msg);
}


// fusion diag
// home/keitee/mw/ethan-as-source/Components/AS/Diag/include/AS_DIAG_Macros.h

#define AS_LOG_FATAL(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_FATAL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Fatal,writeFatal,handleFatal,msg);} while (0)
#define AS_LOG_MIL(msg...)      do {do {AS_DECLARE_FUNCTION;DIAG_LOG_MIL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Mil,writeMil,handleMil,msg);} while (0)
#define AS_LOG_ERROR(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_ERROR(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Error,writeError,handleError,msg);} while (0)
#define AS_LOG_WARNING(msg...)  do {do {AS_DECLARE_FUNCTION;DIAG_LOG_WARN(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Warning,writeWarning,handleWarning,msg);} while (0)
#define AS_LOG_INFO(msg...)     do {do {AS_DECLARE_FUNCTION;DIAG_LOG_INFO(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Info,writeInfo,handleInfo,msg);} while (0)
#define AS_LOG_ENTRY(msg...)    AS_LOG_INFO(msg)
#define AS_LOG_EXIT(msg...)     AS_LOG_INFO(msg)

However, there seems to be an issue:
m_total shows 0. WHY?

    AUD_LOG_MIL("KT: get Data from buffer, sampleCount(%d), m_total(%d), dataToCopy(%d)", sampleCount, m_total, dataToCopy);
    AUD_LOG_MIL("KT: get Data from buffer, sampleCount(%d)", sampleCount);
    AUD_LOG_MIL("KT: get Data from buffer, m_total(%d)", m_total);

NDS: ^0000000222.561686 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(762) KT: get Data from buffer, sampleCount(0), m_total(0), dataToCopy(8820)
NDS: ^0000000222.561700 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(763) KT: get Data from buffer, sampleCount(0)
NDS: ^0000000222.561714 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(764) KT: get Data from buffer, m_total(8820)


<airplay-sdk>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayMain.c

int AirPlayMain( int argc, const char **argv )
{
  AirPlayReceiverServerCreate( &sgReceiverServer );

  AirPlayReceiverServerDelegateInit(&delegate);

  // register delegate to APRS
  delegate.copyProperty_f = _AirPlayHandleServerCopyProperty;
  delegate.setProperty_f = _AirPlayHandleServerSetProperty;
  delegate.sessionCreated_f = _AirPlayHandleSessionCreated;
  AirPlayReceiverServerSetDelegate(sgReceiverServer, &delegate);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c

AirPlayReceiverServerCreateWithConfigFilePath(CFStringRef inConfigFilePath, AirPlayReceiverServerRef* outServer)
{
}


// setup path

static OSStatus _HandleHTTPConnectionMessage(HTTPConnectionRef inCnx, HTTPMessageRef inRequest, void* inContext)
{
  aprs_ulog(kLogLevelTrace, "method:'%.*s' path:'%.*s'\n", (int)methodLen, methodPtr, (int)pathLen, pathPtr);

  else if (strnicmpx(methodPtr, methodLen, "SETUP") == 0)
    status = _requestProcessSetup(cnx, inRequest);
}

static HTTPStatus _requestProcessSetup(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
  status = _requestProcessSetupPlist(inCnx, inRequest);
}

static HTTPStatus _requestProcessSetupPlist(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
    aprs_ulog(kAirPlayPhaseLogLevel, "Setup (%##a)\n", &inCnx->httpCnx->peerAddr);
}

_requestCreateSession()
{
  AirPlayReceiverSessionCreate();
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c
AirPlayReceiverSessionCreate()
{
  err = AirPlayReceiverSessionPlatformInitialize(me);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c

OSStatus AirPlayReceiverServerPlatformInitialize(AirPlayReceiverServerRef inServer)
{}


// set audio stream

static OSStatus _UpdateStreams(AirPlayReceiverSessionRef inSession)
{
  atrp_ulog(kLogLevelNotice, "Main audio setting up %s for %@, input %s, loopback %s, volume:%f\n",
      AirPlayAudioFormatToString(streamCtx->format),
      streamCtx->audioType ? streamCtx->audioType : CFSTR(kAirPlayAudioType_Default),
      streamCtx->input ? "yes" : "no",
      streamCtx->loopback ? "yes" : "no",
      inSession->server->volume);

  // > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:37.199742 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-8.374125

  AudioStreamSetOutputCallback(streamCtx->stream, _AudioOutputCallBack, streamCtx);

  void AudioStreamSetOutputCallback(AudioStreamRef inStream, AudioStreamOutputCallback_f inFunc, void* inContext)
  {
    AudioStreamImpRef const me = _AudioStreamGetImp(inStream);
    TRACE("AudioStreamSetAudioCallback\n");

    me->callback = inFunc;
    me->callbackContext = inContext;
  }

  err = AudioStreamStart(streamCtx->stream);
}

// Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioUtilsStub.c
OSStatus AudioStreamPrepare(AudioStreamRef inStream)
{
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  _IMPL Trace.cpp(41) AudioStreamCreate
  _IMPL Trace.cpp(41) New AudioStreamPrivate=(nil)
  _IMPL Trace.cpp(41) AudioStreamSetAudioCallback
  _IMPL Trace.cpp(41) AudioStreamPrepare:
  _IMPL Trace.cpp(41) channels:      2
  _IMPL Trace.cpp(41) bits/channel:  16
  _IMPL Trace.cpp(41) sample rate:   44100
  _IMPL Trace.cpp(41) bytes/frame:   4
  _IMPL Trace.cpp(41) bytes/packet:  4
  _IMPL Trace.cpp(41) frames/packet: 1
  _IMPL Trace.cpp(41) format id:     6c70636d
  _IMPL Trace.cpp(41) format flags:  c
  _IMPL Trace.cpp(41) Signed
  _IMPL Trace.cpp(41) Little endian
  _IMPL Trace.cpp(41) audioSetFormat returning 1
}

OSStatus AudioStreamStart(AudioStreamRef inStream)
{
  // calls to intergration.cpp
  if( !sessionInitialize(inStream));
}


<airplay-config>

// AudioStreamer/config/audiostreamer.xml

 151   │    <!--NGDEV-140292:Update audiostreamer.xml to support Titan UK-->
 152   │    <profile name="EE_GW_UK_TITAN">
 153   │    <file name="audiostreamer.cfg">
 154   │    <section name="SYSTEM_DELAY_CONFIG">
 155   │     <key name="SYSTEM_DELAY" type="INTEGER" value="137">
 156   │         <comment date="2019/05/16 10:13:45" text="NGDEV-141515 The time in mS to provide system delay. This will be used in the calculation of inHostTime" />
 157   │     </key>
 158   │    </section>
 159   │    <section name="PCM_CONFIGURATION">
 160   │     <key name="PCM_BUFFERSIZE" type="INTEGER" value="100">
 161   │     <comment date="2017/01/19 01:23:45" text="The time in ms" />
 162   │     </key>
 163   │     <key name="PCM_THRESHOLD" type="INTEGER" value="50">
 164   │     <comment date="2017/01/19 01:23:45" text="The time in ms" />
 

<airplay-get-audio-data>

// AudioStreamer/source/AudioThread.cpp

case EVENT_SESSION_START:
{
  PLAYER_API_SessionHandle* sessionId = (PLAYER_API_SessionHandle*)t.data;

  string sourceUri = AsStringTool::stringf("audio/cisco.com_pcm;rate=%d;channels=%d;samplesize=%d;byteorder=%s;sign=%s", 
      m_format.sampleRate, m_format.channels, m_format.sampleSizeBytes*8, m_format.bigEndian?"be":"le", m_format.isSigned?"signed":"unsigned");
  AUD_LOG_MIL("AudioThread::EVENT_SESSION_START id=0x%08X, adding source='%s'", *sessionId, sourceUri.c_str());
  ret = PLAYER_API_AVControl_AddSourceBuffer(playerAvControl, sourceUri.c_str(), &m_avControlBufferHandle);
}

// CMS_MEDIA_SERVICES/MPM/inc/mpm_pres.h

/** @brief Structure that contains properties of a NEED_DATA callback for use in MPM_PRES_ES_EVENT_PROPERTIES */
typedef struct
{
    uint32_t    data_length;        /*!< @brief The amount of data that can be written to the device */
    uint32_t    current_level;      /*!< @brief The current buffer level on the output device */
    uint32_t    cumulative_bytes;   /*!< @brief The total amount of bytes written to this handle */
} MPM_PRES_ES_EVENT_NEED_DATA_PROPERTIES;

// DARWIN_PLATFORM/DARWIN_PLAYER/inc/player_api_events.h

#define PLAYER_EVENT_AUDIO_NEED_DATA                (0x22000000U)   
/**< Notification sent when the buffer created with PLAYER_API_AVControl_AddSourceBuffer needs more
 * data. Application should provide more data through PLAYER_API_AVControl_AppendToBuffer */

typedef struct
{
  uint32_t length;
  uint32_t buffer_level;
  uint32_t bytes_received;
} PLAYER_PRIV_EVENT_NEED_DATA;

ret = PLAYER_API_Session_RegisterEventListener(playerSession,PLAYER_EVENT_AUDIO_NEED_DATA,playerEventListener,PLAYER_API_TAG(this),&dataEventListenerHandle);

struct event_data_type
{
  uint32_t                 eventType;

  /* PLAYER_EVENT_AUDIO_NEED_DATA */
  uint32_t                 audioLength;
  uint32_t                 bufferLevel;
  uint32_t                 bytesReceived;

  /* PLAYER_EVENT_SESSION_START */
  PLAYER_API_SessionHandle sessionId;
};

handlePlayerEventNeedData(event_data, audioThread, event);

static void handlePlayerEventNeedData(event_data_type &event_data , AudioStreamer::AudioThread* audioThread,PLAYER_API_Event_Handle event)

audioThread->onPlayerNeedData(event_data.audioLength, event_data.bufferLevel, event_data.bytesReceived);

void AudioStreamer::AudioThread::onPlayerNeedData(uint32_t dataNeeded, uint32_t bufferLevel, uint32_t totalPlayed);

case EVENT_NEED_DATA:
  handlePlayerNeedData(arg->dataNeeded, arg->bufferLevel, arg->totalPlayed);

case EVENT_PUSH_DATA:
  pushDataToPlayer(arg->dataNeeded, arg->bufferLevel, arg->totalPlayed);

void AudioStreamer::AudioThread::pushDataToPlayer(uint32_t dataNeeded, uint32_t bufferLevel, uint32_t totalPlayed)
{
  currentInstance->audioBufferGet(sampleCount, UpTicks()+inHostTime, m_buffer, dataToCopy);
}

/*
 *AirPlayProtocol getAudioData
 *
 * inParam :
 *      sampleTime :- uint32_t , Time in terms of samples , mostly how many samples consumed till now indicate
 *                              how much time has elapsed. 4410 samples indicate 100ms
 *      hostTime      :- uint64_t , Approximate time when first sample will be played . Needs to as accurate as possible
 *                              and any variation of more than 5 ms will lead audio sync delay b/w apple devices
 *      buffer           :- void * , buffer memory allocated and managed by client
 *      bufferLen     :- size_t , length of buffer which also indicate the amount of data needs to be copied in bytes
 *
 * Function Breif :
 *       Get audio data from airplay SDK
 */
void AudioStreamer::AirPlayProtocol::getAudioData(uint32_t sampleTime, uint64_t hostTime, void *buffer, size_t bufferLen)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.cpp

void audioGetData(uint32_t sampleTime, uint64_t	hostTime, void *buffer, size_t bufferLen)
{
  TRACE("audioGetData(%d %llu %p %u)\n",  sampleTime, hostTime, buffer, bufferLen);

  s_audioStream->callback(sampleTime, hostTime, buffer, bufferLen, s_audioStream->callbackContext);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c
// callback is

static void
_AudioOutputCallBack(
    uint32_t inSampleTime,          // sample time
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    void* inContext)
{
  AirPlayAudioStreamPlatformContext* const streamCtx = (AirPlayAudioStreamPlatformContext*)inContext;
  OSStatus err;

  atrp_ulog(kLogLevelNotice, "KT: _AudioOutputCallBack: inLen(%d)\n", inLen);
  //  AM [AirPlay] KT: _AudioOutputCallBack: inLen(8820)

  err = AirPlayReceiverSessionReadAudio(streamCtx->session, streamCtx->activeType, 
      inSampleTime,                 // 3. sample time 
      inHostTime,
      inBuffer, 
      inLen);
  require_noerr(err, exit);

  if (streamCtx->input && streamCtx->loopback) {
    // not called in the log. use case?
    err = AirPlayReceiverSessionWriteAudio(streamCtx->session, streamCtx->activeType, inSampleTime, inHostTime,
        inBuffer, inLen);
    require_noerr(err, exit);
  }

exit:
  return;
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c

OSStatus
AirPlayReceiverSessionReadAudio(
    AirPlayReceiverSessionRef inSession,
    AirPlayStreamType inType,
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen)
{
  return AirPlayReceiverSessionReadAudio2(
      inSession, 
      inType, 
      inSampleTime, 
      inHostTime, 
      inBuffer, 
      inLen, 
      inLen,                  // 7
      NULL);
}

AirPlayReceiverSessionReadAudio2(
    AirPlayReceiverSessionRef inSession,
    AirPlayStreamType inType,
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    size_t inMinLen,          // 7
    size_t* outSuppliedLen)
{
  suppliedLen = _GeneralAudioRender(inSession, inSampleTime, inBuffer, inLen, inMinLen);
}

static size_t _GeneralAudioRender(
    AirPlayReceiverSessionRef inSession, 
    uint32_t inRTPTime,             // sample time
    void* inBuffer, 
    size_t inSize, 
    size_t inMinFillSize)
{
  // o inMinLen is date bytes for 50ms 
  //
  // o ctx->sampleTimeOffset is 0 so has no effect
  //
  // o srcTS = pktTS. what's unit?
  //
  // o minTS == limTS

  nowTS = inRTPTime - ctx->sampleTimeOffset;
  limTS = nowTS + (uint32_t)(inSize / bytesPerUnit);
  minTS = nowTS + (uint32_t)(inMinFillSize / bytesPerUnit);
  maxTS = limTS + kAirTunesRTPOffsetApplyThreshold;
  pktSeq = 0;

  // sample time
  //
  // #define kAirTunesPlayoutDelay 11025 // 250 ms delay to sync with AirPort Express'es 250 ms buffer.
  // inCnx->minLatency = kAirTunesPlayoutDelay; // Default value for old clients.
  //
  // AirPlayReceiverSessionSetProperty()
  //  gAirTunesRelativeTimeOffset = offset;

  inSession->audioLatencyOffset = inSession->minLatency + gAirTunesRelativeTimeOffset;

  // uint32_t rtpOffsetActive; // RTP offset actively in use (different when deferring).
  //
  // static void AirPlayReceiverFlushPackets(AirPlayReceiverSessionRef inSession, AirPlayFlushPoint const* flushFrom, AirPlayFlushPoint flushUntil)
  //  uint32_t offsetActive = inSession->source.rtpOffsetActive;
}


// start path

// AudioStreamer/source/AirPlayProtocol.cpp

void AudioStreamer::AirPlayProtocol::enable(uint16_t port)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::enable");
  if( !AirPlay::Player::instance().supported() )
  {
    AUD_LOG_WARNING("Airplay not supported on this box, cannot enable");
    return;
  }
  AUD_LOG_INFO("Airplay supported, enabling");
  AirPlay::Player::instance().startAirPlay();
  AirPlay::Player::instance().registerHttpService("/index.html", port);
  AUD_LOG_MIL("Enable airplay done");
  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::enable");
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp

void AirPlay::PlayerImpl::startAirPlay()
{
  if( !m_airplayRunning )
  {
    TRACE("ASDK0218. AirPlayStartMain()\n");
    AirPlayStartMain();
    m_airplayRunning=true;
  }
}


<airplay-progress>
NDS: ^0000000452.250604 !MIL   -AS           < p:00000de7 t:7a3fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplayinterfaceDiagLog L:00258 > 
  @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(41) Progress, duration 39 elapsed 9


={============================================================================
*kt_dev_skymw_0000* skymw-ai-input-handler

https://www.stb.bskyb.com/confluence/display/~grayb/Input+Handling+In+AI

FactoryContainer::FactoryContainer()
{
  // input handler creation
  inputHandler = std::make_shared<InputHandler>();
}

InputHandler::InputHandler()
    *create-queue*
    : mInputQueue(std::make_shared<InputQueue>())
    , mFusionHandler(std::make_shared<FusionInputHandler>(mInputQueue))
    *create-linux-input-handler*
    , mLinuxHandler(std::make_shared<LinuxInputHandler>(mInputQueue))
    , mCdiHandler(std::make_shared<CdiInputHandler>(mInputQueue))
{
  mFusionHandler->start();
  mLinuxHandler->start();
  mCdiHandler->start();
}

int InputHandler::registerKeyListener(unsigned eventSources,
                                      const IInputHandler::KeyListener& listener,
                                      const IInputHandler::KeyListenerPredicate& predicate)
{
  return mInputQueue->registerKeyListener(eventSources, listener, predicate);
}


// observers

ethan-as-source/Components/AS/Services/Controllers/KeyEventController/source/
  AS_KEYEVENT_KeyEventControllerImplementation.cpp

void KeyEventControllerImplementation::KeyControllerMainListener
  (IInputHandler::EventSource eventSource, uint17_t keyCode, bool keyState);


// source (observee)

    typedef std::function<void (EventSource, uint16_t, bool)> KeyListener;

    struct Listener
    {
        unsigned eventSources;
        IInputHandler::KeyListener handler;
        IInputHandler::KeyListenerPredicate predicate;
        IInputHandler::KeyListenerV2 handlerV2;
        IInputHandler::KeyListenerPredicateV2 predicateV2;
    };

class InputQueue
{
  std::queue<KeyEvent> mKeyQueue;

  int registerKeyListener(unsigned eventSources,
      const IInputHandler::KeyListener& listener,
      const IInputHandler::KeyListenerPredicate& predicate);
};


    const std::shared_ptr<InputQueue> mInputQueue;

void LinuxInputHandler::addNewInputDevice(dev_t devNumber, const std::string &devPath)
{
  // try and create the new device based
  std::shared_ptr<LinuxInputDevice> device =
    LinuxInputDevice::create(devNumber, m_modeSetting, devPath, `mInputQueue`, mDeviceIDManager);

  // add the device to the poll loop
  EPollLoop::Handler handler = std::bind(`&LinuxInputDevice::process`, device,
      std::placeholders::_1, std::placeholders::_2);

  int64_t id = mPollLoop->addFileDescriptor(device->fd(), EPollLoop::Readable, handler);

  mInputDevices[devNumber] = std::make_pair(id, device);

  AI_LOG_MILESTONE("added device node %u:%u (%s) with fd %d and id %hu to input loop ",
      major(devNumber), minor(devNumber), device->toString().c_str(),
      device->fd(), device->deviceId());
}


59351:NDS: ^0000000247.989785 !MIL   -APPINFRA     < p:00000e1e t:46910dc0 T:no name 
M:LinuxInputHandler.cpp F:addNewInputDevice L:00497 > 
added device node 13:64 (bluetooth vendor:0x057a product:0x0004 'D4:B8:FF:12:E1:A8') with fd 549 and id 4039 to input loop


// appinfrastructure/AppInfrastructure/InputHandler/lib/include/InputHandler.h

class InputSource
{
  void sendKey(uint16_t keyCode, bool down);
  const std::shared_ptr<InputQueue> mQueue;
};


class LinuxInputDevice : public InputSource
{
    LinuxInputEventProcessor *mEventProcessor;
};


std::shared_ptr<LinuxInputDevice> LinuxInputDevice::create(dev_t devNumber,
                                                           uint8_t devMode,
                                                           const std::string &devPath,
                                                           const std::shared_ptr<InputQueue> &queue,
                                                           const std::shared_ptr<InputDeviceIDManager> &idManager)
{
  // gift the device fd with all the other data to an LinuxInputDevice object
  std::shared_ptr<LinuxInputDevice> device =
    std::shared_ptr<LinuxInputDevice>
    (new LinuxInputDevice(devFd, devNumber, devMode, devType,
                          busType, id.vendor, id.product,
                          id.version, physAddress, idToken, queue));
}


LinuxInputDevice::LinuxInputDevice(int deviceFd, dev_t devNumber,
  const std::shared_ptr<InputQueue> &queue)
    : InputSource(devType, devMode, idToken->value(), queue,
                  std::chrono::milliseconds(RCU_LONG_STANDBY_MS),
                  RCU_SHORT_STANDBY_KEYCODE, RCU_LONG_STANDBY_KEYCODE)

{
  // create either a default event processor or one specific for the BT RCU
  // depending on the product id
  if (devType != IInputHandler::DeviceType::GenericLinuxInputDev)
  {
    // BLE RCU
    mEventProcessor = new BleRcuInputEventProcessor(this);
  }
}

void LinuxInputDevice::process(int devFd, unsigned events)
{
  ssize_t amount = TEMP_FAILURE_RETRY(readv(devFd, iov, maxInputEvents));

  // process the events based on input type
  mEventProcessor->processEvents(inputEvents, nEvents);
}

protected:
    InputSource * const mOutput;

LinuxInputEventProcessor::LinuxInputEventProcessor(InputSource *output)
    : mOutput(output)

class BleRcuInputEventProcessor : public LinuxInputEventProcessor

BleRcuInputEventProcessor::BleRcuInputEventProcessor(InputSource *output)
    : LinuxInputEventProcessor(output)


// appinfrastructure/AppInfrastructure/InputHandler/lib/source/BleRcuInputEventProcessor.cpp
void BleRcuInputEventProcessor::processEvents(const struct input_event *events);

void BleRcuInputEventProcessor::processKeyEvents(uint16_t keyCode, int32_t state)
{
  // send the up / down state of the key
  mOutput->sendKey(hidKeyCode, (state == LNX_KEY_UP) ? false : true);
}

// ir keys

-APPINFRA     < M:InputQueue.cpp F:sendKey L:00110 > KT: InputQueue::sendKey(filterByte(20), keyCode(61022), down(0)
-APPINFRA     < M:InputQueue.cpp F:listenerThread L:00288 > KT: InputQueue::listner.handler(event{source(2), keyCode(61022), down(0)}
-AS           < M:AS_DMS_Writer.cpp F:KeyControllerMainListener L:00258 > @ctx:AS_KEYEVENT AS_KEYEVENT_KeyEventControllerImplementation.cpp(223) KT: KeyControllerMainListener acquired deviceType: 2, keyCode: 0xee5e, keyState: 0
-APPINFRA     < M:BleRcuController.cpp F:isIrPairingCode L:00801 > KT: isIrPairingCode filterByte(0x14), keyCode(0xee5e)
-APPINFRA     < M:InputQueue.cpp F:listenerThread L:00288 > KT: InputQueue::listner.handler(event{source(2), keyCode(61022), down(0)}
-APPINFRA     < M:BleRcuController.cpp F:onIrPairingCode L:00850 > KT: received IR pairing code 094

-APPINFRA     < M:LinuxInputDevice.cpp F:create L:00169 > KT LinuxInputDevice(devPath(/dev/input/event0) busType(2) devType(3)
-APPINFRA     < M:LinuxInputDevice.cpp F:LinuxInputDevice L:00210 > KT LinuxInputDevice creates BleRcuInputEventProcessor
-APPINFRA     < M:LinuxInputHandler.cpp F:addNewInputDevice L:00497 > KT: added device node 13:64 (bluetooth vendor:0x057a product:0x0004 'D4:B8:FF:12:E1:A8') with fd 508 and id 1418 to input loop 

// bluetooth keys
-APPINFRA     < M:LinuxInputDevice.cpp F:process L:00419 > KT: read 48 bytes (3 events) from device node
-APPINFRA     < M:BleRcuInputEventProcessor.cpp F:processEvents L:00188 > KT: ble rcu input { type=EV_MSC, code=4, value=458810 }
-APPINFRA     < M:BleRcuInputEventProcessor.cpp F:processEvents L:00188 > KT: ble rcu input { type=EV_KEY, code=59, value=1 }
-APPINFRA     < M:BleRcuInputEventProcessor.cpp F:processKeyEvents L:00124 > KT: sendKey(58, 1)
-APPINFRA     < M:InputQueue.cpp F:sendKey L:00110 > KT: InputQueue::sendKey(filterByte(0), keyCode(57344), down(1)
-APPINFRA     < M:BleRcuInputEventProcessor.cpp F:processEvents L:00188 > KT: ble rcu input { type=EV_SYN, code=0, value=0 }
-APPINFRA     < M:InputQueue.cpp F:listenerThread L:00288 > KT: InputQueue::listner.handler(event{source(4), keyCode(57344), down(1)}
-AS           < M:AS_DMS_Writer.cpp F:KeyControllerMainListener L:00258 > @ctx:AS_KEYEVENT AS_KEYEVENT_KeyEventControllerImplementation.cpp(223) KT: KeyControllerMainListener acquired deviceType: 4, keyCode: 0xe000, keyState: 1


={============================================================================
*kt_dev_skymw_0000* skymw-bluez

TODO:

1. Q version do not supports filtering byte on:
bool startPairing(quint8 pairingCode) override;

2. Q version calls BleRcuManager and Android version calls BleRcuAdapter.

<compare-both> between bluez ip and bluez DTH(Q)
meld /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/blercu /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/blercu


<bluez-usb>
do everytime when bluetooth usb is plugged or reboot machine

keitee@keitee-mint:~/mw/ethan-as-source-repo$ sudo dmesg | tail

[393789.742167] IPv6: ADDRCONF(NETDEV_UP): eno1: link is not ready
[393789.931065] IPv6: ADDRCONF(NETDEV_UP): eno1: link is not ready
[393791.433703] e1000e: eno1 NIC Link is Up 100 Mbps Full Duplex, Flow Control: Rx/Tx
[393791.433705] e1000e 0000:00:1f.6 eno1: 10/100 speed: disabling TSO
[393791.433753] IPv6: ADDRCONF(NETDEV_CHANGE): eno1: link becomes ready
[421360.738270] usb 1-10: new full-speed USB device number 18 using xhci_hcd
[421361.311131] usb 1-10: New USB device found, idVendor=1d5a, idProduct=c080
[421361.311137] usb 1-10: New USB device strings: Mfr=0, Product=0, SerialNumber=0
[421361.337102] input: HID 1d5a:c080 as /devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0/0003:1D5A:C080.000E/input/input53
[421361.395548] hid-generic 0003:1D5A:C080.000E: input,hiddev2,hidraw4: USB HID v1.11 Keyboard [HID 1d5a:c080] on usb-0000:00:14.0-10/input0
keitee@keitee-mint:~/mw/ethan-as-source-repo$ /lib/udev/hid2hci --mode=hci --method=csr2 --devpath=
error: could not find usb_device for ''
keitee@keitee-mint:~/mw/ethan-as-source-repo$
keitee@keitee-mint:~/mw/ethan-as-source-repo$
keitee@keitee-mint:~/mw/ethan-as-source-repo$
keitee@keitee-mint:~/mw/ethan-as-source-repo$ /lib/udev/hid2hci --mode=hci --method=csr2 --devpath=/devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0
Can't open device: Permission denied (13)
error: unable to handle '/sys//devices/pci0000:00/0000:00:14.0/usb1/1-10'
keitee@keitee-mint:~/mw/ethan-as-source-repo$ sudo /lib/udev/hid2hci --mode=hci --method=csr2 --devpath=/devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0
keitee@keitee-mint:~/mw/ethan-as-source-repo$ sudo dmesg | tail
[421535.138520] Bluetooth: HCI socket layer initialized
[421535.138521] Bluetooth: L2CAP socket layer initialized
[421535.138523] Bluetooth: SCO socket layer initialized
[421535.142951] usbcore: registered new interface driver btusb
[421535.271614] Bluetooth: BNEP (Ethernet Emulation) ver 1.3
[421535.271616] Bluetooth: BNEP filters: protocol multicast
[421535.271622] Bluetooth: BNEP socket layer initialized
[421535.324115] Bluetooth: RFCOMM TTY layer initialized
[421535.324124] Bluetooth: RFCOMM socket layer initialized
[421535.324132] Bluetooth: RFCOMM ver 1.11

keitee@keitee-mint:~/mw/ethan-as-source-repo$ sudo /lib/udev/hid2hci --mode=hci --method=csr2 --devpath=/devices/pci0000:00/0000:00:14.0/usb1/1-10/1-10:1.0


={============================================================================
*kt_dev_skymw_0000* skymw-bluez-as

/peripherals/btremotes/status

curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Host: 192.168.0.102:9005" -H "Origin:" http://192.168.0.102:9005/as/peripherals/btremotes/status

// works on Q box
keitee@keitee-mint:~$ curl -i -N -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Host: 192.168.0.102:9005" -H "Origin:" http://192.168.0.102:9005/as/peripherals/btremotes/status
~{
   "remotes" : [
      {
         "batterylevel" : 255,
         "bdaddr" : "D4:B8:FF:66:D6:25",
         "btlswver" : "Unknown",
         "connected" : false,
         "deviceid" : 3164,
         "hwrev" : "Unknown",
         "make" : "Unknown",
         "model" : "Unknown",
         "name" : "P235 SkyQ EC201",
         "rcuswver" : "Unknown",
         "serialno" : "Unknown"
      }
   ],
   "status" : "IDLE"
}

^C
keitee@keitee-mint:~$


={============================================================================
*kt_dev_skymw_0000* skymw-bluez-dbus

-sh-3.2# 
dbus-send  --system --type=method_call --print-reply --dest='org.freedesktop.DBus' / org.freedesktop.DBus.ListNames
method return time=1567148533.424057 sender=org.freedesktop.DBus -> destination=:1.18 serial=3 reply_serial=2
   array [
      string "org.freedesktop.DBus"
      string ":1.7"
      string ":1.8"
      string ":1.9"
      string "com.sky.rhad"
      string "com.ruwido.rcu"
      string "com.sky.dobby"
      string "com.sky.ai.app_process"
      string ":1.10"
      string "org.bluez"
      string "com.uei.userver"
      string ":1.11"
      string ":1.12"
      string ":1.13"
      string ":1.0"
      string "com.sky.maid"
      string "com.sky.as2bluez"
      string ":1.1"
      string ":1.2"
      string ":1.3"
      string "com.ubuntu.Upstart"
      string ":1.4"
      string ":1.18"
      string ":1.5"
      string ":1.6"
   ]


-sh-3.2# dbus-send  --system --type=method_call --print-reply --dest='org.bluez' / org.freedesktop.DBus.Introspectable.Introspect
method return time=1567148503.833966 sender=:1.4 -> destination=:1.17 serial=43 reply_serial=2
   string "<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
<node><interface name="org.freedesktop.DBus.Introspectable"><method name="Introspect"><arg name="xml" type="s" direction="out"/>
</method></interface><interface name="org.freedesktop.DBus.ObjectManager"><method name="GetManagedObjects"><arg name="objects" type="a{oa{sa{sv}}}" direction="out"/>
</method><signal name="InterfacesAdded"><arg name="object" type="o"/>
<arg name="interfaces" type="a{sa{sv}}"/>
</signal>
<signal name="InterfacesRemoved"><arg name="object" type="o"/>
<arg name="interfaces" type="as"/>
</signal>
</interface><node name="org"/></node>"


// type="a{oa{sa{sv}}}"
// dict<path, <dict<string, variant>>>

dbus-send --system --type=method_call --print-reply --dest='org.bluez' / org.freedesktop.DBus.ObjectManager.GetManagedObjects

method return time=1567161890.415580 sender=:1.4 -> destination=:1.20 serial=45 reply_serial=2
   array [
      dict entry(
         object path "/org/bluez"
         array [
            dict entry(
               string "org.freedesktop.DBus.Introspectable"
               array [
               ]
            )
            dict entry(
               string "org.bluez.AgentManager1"
               array [
               ]
            )
            dict entry(
               string "org.bluez.ProfileManager1"
               array [
               ]
            )
         ]
      )
      dict entry(
         object path "/org/bluez/hci0"
         array [
            dict entry(
               string "org.freedesktop.DBus.Introspectable"
               array [
               ]
            )
            dict entry(
               string "org.bluez.Adapter1"
               array [
                  dict entry(
                     string "Address"
                     variant                         string "FF:FF:FF:FF:FF:FF"
                  )
                  dict entry(
                     string "AddressType"
                     variant                         string "public"
                  )
                  dict entry(
                     string "Name"
                     variant                         string ""sky-one-box""
                  )
                  dict entry(
                     string "Alias"
                     variant                         string "Sky Q 1TB Box4027"
                  )
                  dict entry(
                     string "Class"
                     variant                         uint32 263188
                  )
                  dict entry(
                     string "Powered"
                     variant                         boolean true
                  )
                  dict entry(
                     string "Discoverable"
                     variant                         boolean false
                  )
                  dict entry(
                     string "DiscoverableTimeout"
                     variant                         uint32 0
                  )
                  dict entry(
                     string "Pairable"
                     variant                         boolean false
                  )
                  dict entry(
                     string "PairableTimeout"
                     variant                         uint32 0
                  )
                  dict entry(
                     string "Discovering"
                     variant                         boolean false
                  )
                  dict entry(
                     string "UUIDs"
                     variant                         array [
                           string "0000110b-0000-1000-8000-00805f9b34fb"
                           string "00001801-0000-1000-8000-00805f9b34fb"
                           string "0000110e-0000-1000-8000-00805f9b34fb"
                           string "00001200-0000-1000-8000-00805f9b34fb"
                           string "0000110c-0000-1000-8000-00805f9b34fb"
                           string "00001800-0000-1000-8000-00805f9b34fb"
                        ]
                  )
                  dict entry(
                     string "Modalias"
                     variant                         string "usb:v1D6Bp0246d0530"
                  )
               ]
            )
            dict entry(
               string "org.freedesktop.DBus.Properties"
               array [
               ]
            )
            dict entry(
               string "org.bluez.GattManager1"
               array [
               ]
            )
            dict entry(
               string "org.bluez.Media1"
               array [
               ]
            )
            dict entry(
               string "org.bluez.LEAdvertisingManager1"
               array [
                  dict entry(
                     string "ActiveInstances"
                     variant                         byte 0
                  )
                  dict entry(
                     string "SupportedInstances"
                     variant                         byte 5
                  )
                  dict entry(
                     string "SupportedIncludes"
                     variant                         array [
                           string "tx-power"
                           string "appearance"
                           string "local-name"
                        ]
                  )
               ]
            )
         ]
      )
      dict entry(
         object path "/org/bluez/hci0/dev_D4_B8_FF_12_E1_A8"
         array [
            dict entry(
               string "org.freedesktop.DBus.Introspectable"
               array [
               ]
            )
            dict entry(
               string "org.bluez.Device1"
               array [
                  dict entry(
                     string "Address"
                     variant                         string "D4:B8:FF:12:E1:A8"
                  )
                  dict entry(
                     string "AddressType"
                     variant                         string "public"
                  )
                  dict entry(
                     string "Name"
                     variant                         string "P210 SkyQ EC101"
                  )
                  dict entry(
                     string "Alias"
                     variant                         string "P210 SkyQ EC101"
                  )
                  dict entry(
                     string "Appearance"
                     variant                         uint16 384
                  )
                  dict entry(
                     string "Paired"
                     variant                         boolean true
                  )
                  dict entry(
                     string "Trusted"
                     variant                         boolean false
                  )
                  dict entry(
                     string "Blocked"
                     variant                         boolean false
                  )
                  dict entry(
                     string "LegacyPairing"
                     variant                         boolean false
                  )
                  dict entry(
                     string "Connected"
                     variant                         boolean false
                  )
                  dict entry(
                     string "UUIDs"
                     variant                         array [
                           string "00001800-0000-1000-8000-00805f9b34fb"
                           string "00001801-0000-1000-8000-00805f9b34fb"
                           string "00001802-0000-1000-8000-00805f9b34fb"
                           string "0000180a-0000-1000-8000-00805f9b34fb"
                           string "0000180f-0000-1000-8000-00805f9b34fb"
                           string "00001812-0000-1000-8000-00805f9b34fb"
                           string "00001813-0000-1000-8000-00805f9b34fb"
                           string "0000f800-bdf0-407c-aaff-d09967f31acd"
                           string "0000f801-bdf0-407c-aaff-d09967f31acd"
                           string "0000f802-bdf0-407c-aaff-d09967f31acd"
                        ]
                  )
                  dict entry(
                     string "Modalias"
                     variant                         string "bluetooth:v057Ap0004d0100"
                  )
                  dict entry(
                     string "Adapter"
                     variant                         object path "/org/bluez/hci0"
                  )
                  dict entry(
                     string "ServicesResolved"
                     variant                         boolean false
                  )
               ]
            )
            dict entry(
               string "org.freedesktop.DBus.Properties"
               array [
               ]
            )
         ]
      )
      dict entry(
         object path "/org/bluez/hci0/dev_88_9F_6F_88_6A_7B"
         array [
            dict entry(
               string "org.freedesktop.DBus.Introspectable"
               array [
               ]
            )
            dict entry(
               string "org.bluez.Device1"
               array [
                  dict entry(
                     string "Address"
                     variant                         string "88:9F:6F:88:6A:7B"
                  )
                  dict entry(
                     string "AddressType"
                     variant                         string "public"
                  )
                  dict entry(
                     string "Name"
                     variant                         string "Galaxy J6"
                  )
                  dict entry(
                     string "Alias"
                     variant                         string "Galaxy J6"
                  )
                  dict entry(
                     string "Class"
                     variant                         uint32 5898764
                  )
                  dict entry(
                     string "Icon"
                     variant                         string "phone"
                  )
                  dict entry(
                     string "Paired"
                     variant                         boolean true
                  )
                  dict entry(
                     string "Trusted"
                     variant                         boolean false
                  )
                  dict entry(
                     string "Blocked"
                     variant                         boolean false
                  )
                  dict entry(
                     string "LegacyPairing"
                     variant                         boolean false
                  )
                  dict entry(
                     string "Connected"
                     variant                         boolean false
                  )
                  dict entry(
                     string "UUIDs"
                     variant                         array [
                           string "00001105-0000-1000-8000-00805f9b34fb"
                           string "0000110a-0000-1000-8000-00805f9b34fb"
                           string "0000110c-0000-1000-8000-00805f9b34fb"
                           string "0000110d-0000-1000-8000-00805f9b34fb"
                           string "0000110e-0000-1000-8000-00805f9b34fb"
                           string "00001112-0000-1000-8000-00805f9b34fb"
                           string "00001115-0000-1000-8000-00805f9b34fb"
                           string "00001116-0000-1000-8000-00805f9b34fb"
                           string "0000111f-0000-1000-8000-00805f9b34fb"
                           string "0000112f-0000-1000-8000-00805f9b34fb"
                           string "00001132-0000-1000-8000-00805f9b34fb"
                           string "00001200-0000-1000-8000-00805f9b34fb"
                           string "00001800-0000-1000-8000-00805f9b34fb"
                           string "00001801-0000-1000-8000-00805f9b34fb"
                        ]
                  )
                  dict entry(
                     string "Modalias"
                     variant                         string "bluetooth:v0075p0100d0201"
                  )
                  dict entry(
                     string "Adapter"
                     variant                         object path "/org/bluez/hci0"
                  )
                  dict entry(
                     string "ServicesResolved"
                     variant                         boolean false
                  )
               ]
            )
            dict entry(
               string "org.freedesktop.DBus.Properties"
               array [
               ]
            )
            dict entry(
               string "org.bluez.MediaControl1"
               array [
                  dict entry(
                     string "Connected"
                     variant                         boolean false
                  )
               ]
            )
         ]
      )
   ]


={============================================================================
*kt_dev_skymw_0000* skymw-bluez-q

<bluez-factory>

// Singletons/lib/source/FactoryContainer.cpp

std::shared_ptr<AI_BLERCU::IBleRcuContoller> FactoryContainer::getRcuControllerProxy() const
{
    return blercuFactory->createBleRcuControllerProxy();
}

FactoryContainer::FactoryContainer()
    : aiDmsFactory(AIDms::Factory::getSharedInstance())
    , aiConfig(std::make_shared<AppInfrastructureConfig>(aiDmsFactory))
    , sysInfo(new SystemInfo())
    , wsMediatorFactory(new WebSocketMediator::WebSocketMediatorFactory(SkyDefinitions::getWebsocketMediatorPorts()))
    , rmFactory(new RuntimeManagerFactory(aiConfig, sysInfo))
    , pmFactory(new PackageManagerFactory(aiConfig))
    , ampFactory(new ApplicationManagerProxy::Factory(aiConfig))
    , verifierFactory( new xmldsigverifier::Factory(aiConfig))
    , webServerFactory(new AppWebServerFactory())
    , softCatFactory(new SoftCatFactory(aiConfig))
    , applicationLaunchPolicyFactory(new ApplicationLaunchPolicyFactory(aiConfig))
    , jumperFactory(new jumper::JumperFactory())
    , dbusServerFactory(new AI_DBUS::DbusServerFactory())
    , aiDiagnosticsFactory(new AIDiagnostics::DiagnosticsFactory(aiConfig))
    , credentialsManagerFactory(new CredentialsManagerFactory())
    , upnpDiscoveryFactory(new UPnPDiscoveryFactory())

    , `blercuFactory(std::make_shared<AI_BLERCU::BleRcuFactory>())`

    , irrcuFactory(std::make_shared<AI_IRRCU::IrRcuFactory>())
    , netflixProxyFactory(std::make_shared<Netflix::Factory>())
    , terminalProxy(std::make_shared<AIDms::TerminalProxy>())
    {

      // setup the dbus daemon for apps to use
      std::shared_ptr<AI_DBUS::IDbusServer> dbusServerPublic =
        initAndStartDbusServer(AI_DBUS::DbusServerId::AI_PUBLIC);

      dbusServers[AI_DBUS::DbusServerId::AI_PRIVATE] = dbusServerPrivate;
      std::shared_ptr<AI_IPC::IIpcService> ipcServicePrivate =
        AI_IPC::createIpcService(dbusServerPrivate, IPC_SERVICE_APP_PROCESS);
      ipcServices[AI_DBUS::DbusServerId::AI_PRIVATE] = ipcServicePrivate;

      // create the BleRcu factory, which just launches the daemon (requires the system IPC service)
      blercuFactory->setLocale(aiDmsFactory->createLocale());

      `blercuFactory->setIpcService(ipcServicePrivate);`

      blercuFactory->setInputHandler(inputHandler);
      blercuFactory->startDaemon(dobbyProxy);

      // creates BleRcuContollerProxy
      blercuFactory->`createBleRcuControllerProxy`();
    }


// -----------------------------------------------------------------------------
/**
 * @brief Create RCU controller proxy object
 *
 *
 * @return the RCU controller proxy object, or null pointer in case of failure
 */
std::shared_ptr<IBleRcuContoller> BleRcuFactory::createBleRcuControllerProxy()
{
  // return the controller if we've already created it
  if (mController)
  {
    AI_LOG_FN_EXIT();
    return mController;
  }
}

// AppInfrastructure/Singletons/lib/source/Singletons.cpp

std::shared_ptr<AI_BLERCU::IBleRcuContoller> getBleRcuControllerProxyInstance()
{
    return FactoryContainer::getInstance().`getRcuControllerProxy`();
}


<bluetooth-as-observer> *state-change*

// Components/AS/Services/Controllers/RcuController/source/AS_RCU_RcuControllerImplementation.h
// Components/AS/Services/Controllers/RcuController/source/AS_RCU_RcuControllerImplementation.cpp

void BluetoothRcuDeviceEventObserver::stateChanged( AI_BLERCU::PairingState state )
{
    AS_LOG_ENTRY( "%s state: %u", __func__, state );

    RcuControllerEventData eventData;

    AS_LOG_INFO( "Received pairing state changed event, state: %u", state );

    eventData.pairingState = state;

    size_t bytesSend = m_queue->Send( AS_RCU_CONTROLLER_EVENT_PAIRING_STATE_CHANGED, &eventData, sizeof(eventData) );
    if ( bytesSend != sizeof(eventData) )
    {
        AS_LOG_ERROR( "Not enough bytes sent in queue send: %d expected: %u", bytesSend, sizeof(eventData) );
    }

    AS_LOG_EXIT( "%s", __func__ );
}

// handle signal/notificaiton from AS

class BluetoothRcuDeviceEventObserver : 
  public AICommon::Observer<AI_BLERCU::IBleRcuDeviceEvent>
{
  public:
    /**
     * @brief Constructor
     *
     * @param[in] queue      : Pointer to queue
     */
    BluetoothRcuDeviceEventObserver( AS_WORKER::Queue *queue );

    /**
     * @brief Listener to be invoked when pairing state has changed
     *
     * @param[in] pairingInProgress      : Pairing state
     */
    void pairingStatusChanged( bool pairingInProgress );

    /**
     * @brief Listener to be invoked when rcu device properties has changed
     */
    void deviceListChanged();

  private:
    AS_WORKER::Queue *m_queue;                                ///< Pointer to queue
};


m_bluetoothRcuDeviceObserver = std::make_shared < BluetoothRcuDeviceEventObserver > (m_queue);

m_bluetoothRcuController = `getBleRcuControllerProxyInstance`();

m_bluetoothRcuController->addObserver( m_bluetoothRcuDeviceObserver );

std::pair<bool, std::vector<std::string>> manufacturers = 
`m_bluetoothRcuController->getDeviceManufacturers`( macaddress, manufacturer, searchFlags, (int64_t) 0, (int64_t) RCU_TOTAL_MANUFACTURER_TO_RETRIEVE, totalEntries );

// ethan-as-source/Components/AS/Services/Controllers/RcuController/source/AS_RCU_RcuControllerImplementation.cpp
void BluetoothRcuDeviceEventObserver::pairingStatusChanged( bool pairingInProgress )
{ 
}


// appinfrastructure/AppInfrastructure/BluetoothRcu/client/lib/source/BleRcuController.cpp
void BleRcuContollerProxy::signalHandlerPropertiesChanged(const AI_IPC::VariantList& args)
{
  mDispatcher->post(std::bind(&BleRcuContollerProxy::notifyPairingStatusChanged, this, mPairing.load()));
}

void BleRcuContollerProxy::notifyPairingStatusChanged(bool pairing)
{
  `notify`( std::bind(&IBleRcuDeviceEvent::pairingStatusChanged, std::placeholders::_1, pairing) );
}


<bluez-q-client-proxy>

COMPONENT_NAME := BleRcuClientLib

// BluetoothRcu/client/lib/include/BleRcuFactory.h

    std::map<std::string, std::shared_ptr<BleRcuDevice>> mRcuDevices;


// AppInfrastructure/Public/Common/Notifier.h

template<typename T>
class Notifier : virtual public Polymorphic
{
  /**
   * @brief Register interest in receiving updates.
   */
  void addObserver(const std::shared_ptr<T>& observer)
  {
    std::lock_guard<std::mutex> lock(m);
    observers.push_back(observer);
  }
}

// AppInfrastructure/Public/BluetoothRcu/IBluetoothRcu.h

class `IBleRcuDeviceEvent` : Interface
{
public:

    /**
     * @brief Pairing status changed notification
     *
     * @param pairingInProgress Pairing in progress or not.
     */
    virtual void pairingStatusChanged(bool pairingInProgress) = 0;

    /**
     * @brief Device list changed notification
     */
    virtual void deviceListChanged() = 0;
};

class IBleRcuContoller : public AICommon::`Notifier`<IBleRcuDeviceEvent>
{
public:

    /**
    * @brief Get JSON as defined in the AS spec
    */
    virtual Json::Value GetJsonRcuDeviceList() const = 0;

    /**
     * @brief Get information about the RCU devices
     */
    virtual std::vector<BleRcuDeviceProperties> getRcuDevices() const = 0;

    /**
     * @brief Start audio steaming
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     * @param type          [in]    Streaming type such as ADPCM or PCM
     *
     * @return If successful then the fd to read the audio data, otherwise a negative value to indicate error
     */
    virtual int startAudioStreaming(const std::string& rcuAddress, StreamAudioRequestType type) = 0;

    /**
     * @brief Stop audio steaming
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     *
     * @return If successful then true otherwise false
     */
    virtual bool stopAudioStreaming(const std::string& rcuAddress) = 0;


    /**
     * @brief Get audio streaming status
     *
     * @param rcuAddress     [in]     The address of the RCU to use for audio streaming
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the audio streaming if the method call is successful.
     */
    virtual std::pair<bool, BleRcuAudioStatus> getAudioStreamingStatus(const std::string& rcuAddress) = 0;

    /**
     * @brief Set IR codes
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     * @param deviceType    [in]    Device type such as TV or AMP
     * @param irCode        [in]    IR code to set
     *
     * @return If successful then true otherwise false
     */
    virtual bool setIRCode(const std::string& rcuAddress, IrSignalProfile deviceType, int32_t irCode ) = 0;

    /**
     * @brief Clear IR codes
     *
     * @param rcuAddress    [in]    The address of the RCU to use for audio streaming
     *
     * @return If successful then true otherwise false
     */
    virtual bool clearIRCode(const std::string& rcuAddress) = 0;

    /**
     * @brief Set RCU mode
     *
     * @param rcuAddress    The address of the RCU to use for audio streaming
     * @param modesBitMask  Flags representing different RCU modes, see RcuMode
     *
     * @return If successful then true otherwise false
     */
    virtual bool setRcuMode(const std::string& rcuAddress, uint32_t modesBitMask) = 0;

    /**
     * @brief Get device models
     *
     * @param rcuAddress            [in]     The address of the RCU to use for audio streaming
     * @param deviceManufacturer    [in]     Name of the device manufacturer
     * @param deviceModelSearchText [in]     Search text indicating the hints about the model
     * @param searchFlagsBitMask    [in]     Search flags - see RcuDeviceSearchFlags
     * @param offset                [in]     Offset value in the search result
     * @param count                 [in]     Maximum number of entries requested
     * @param totalEntries          [out]    Maximum number of entries available
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (models) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<std::string>> getDeviceModels(
            const std::string& rcuAddress,
            const std::string &deviceManufacturer,
            const std::string &deviceModelSearchText,
            uint32_t searchFlagsBitMask,
            int64_t offset,
            int64_t count,
            uint64_t& totalEntries) = 0;

    /**
     * @brief Get device manufacturers
     *
     * @param rcuAddress                    [in]     The address of the RCU to use for audio streaming
     * @param deviceManufacturerSearchText  [in]     Search text indicating the hints about the model
     * @param searchFlagsBitMask            [in]     Search flags - see RcuDeviceSearchFlags
     * @param offset                        [in]     Offset value in the search result
     * @param count                         [in]     Maximum number of entries requested
     * @param totalEntries                  [out]    Maximum number of entries available
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (manufacturers) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<std::string>> getDeviceManufacturers(
            const std::string& rcuAddress,
            const std::string &deviceManufacturerSearchText,
            uint32_t searchFlagsBitMask,
            int64_t offset,
            int64_t count,
            uint64_t& totalEntries) = 0;

    /**
     * @brief Get manual input based IR codes
     *
     * @param rcuAddress          [in]     The address of the RCU to use for audio streaming
     * @param deviceManufacturer  [in]     Name of the device manufacturer
     * @param deviceModel         [in]     Name of the device model
     * @param searchFlagsBitMask  [in]     Search flags - see RcuDeviceSearchFlags
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (IR codes) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<int32_t>> getManualInputBasedIRCodes(
            const std::string& rcuAddress,
            const std::string &deviceManufacturer,
            const std::string &deviceModel,
            uint32_t searchFlagsBitMask ) = 0;

    /**
     * @brief Get manual input based IR codes
     *
     * @param rcuAddress     [in]     The address of the RCU to use for audio streaming
     * @param Edit           [in]     EDID data
     *
     * @return It returns a pair. pair.first indicates whether the method can is successful or not
     *         and pair.second gives us the result set (IR codes) if the method call is successful.
     */
    virtual std::pair<bool, std::vector<int32_t>> getEdidBasedIRCodes(
            const std::string& rcuAddress,
            const std::vector<uint8_t>& edit ) = 0;

    /**
     * @brief This method triggers the 'find me' beeping on the RCU.
     *
     * @param rcuAddress     [in]     The address of the RCU to use for audio streaming
     * @param beepLevel      [in]     Beep level
     * @param duration       [in]     Beep duration
     *
     * @return if successful then true else false. We need to check the validity of the future object prior to invoke its get method.
     **/
    virtual std::future<bool> findMe(const std::string& rcuAddress, FindMeBeepLevel beepLevel, int32_t duration) = 0;

    // *start-scanning* added
    /**
     * @brief Start scanning
     *
     * @param timeout       [in]    scanning timeout in ms
     *
     * @return void
     */
    virtual void startScanning(const uint32_t timeout) = 0;
};


// client/lib/source/BleRcuFactory.cpp
std::shared_ptr<IBleRcuContoller> BleRcuFactory::createBleRcuControllerProxy()
{
  try
  {
    mController = std::make_shared<BleRcuContollerProxy>(mIpcService, mInputHandler);
  }
}


// client/lib/source/BleRcuController.h

class `BleRcuContollerProxy` : public IBleRcuContoller
{
  /**
   * @brief Get information about the RCU devices
   */
  virtual std::vector<BleRcuDeviceProperties> getRcuDevices() const final;
};


// AppInfrastructure/BluetoothRcu/`client/lib/source/BleRcuController.cpp`

BleRcuContollerProxy::BleRcuContollerProxy(
    const std::shared_ptr<AI_IPC::IIpcService>& ipcService, const std::shared_ptr<IInputHandler>& inputHandler)

    : `mDispatcher(std::make_shared<AICommon::ThreadedDispatcher>("AI_BLERCU_PROXY"))`

  , mIpcService(ipcService)

{
  `setDispatcher(mDispatcher);`

  // #define BLE_RCU_CONTROLLER_OBJECT               "/com/sky/blercu/controller"
  // #define BLE_RCU_CONTROLLER_INTERFACE            "com.sky.blercu.Controller1"

  // for signals
  std::string handle = mIpcService->registerSignalHandler(
      AI_IPC::Signal(BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, "DeviceAdded"),
      std::bind(`&BleRcuContollerProxy::signalHandlerDeviceAdded`, this, std::placeholders::_1));

  // for properties
  handle = mIpcService->registerSignalHandler(
      AI_IPC::Signal(BLE_RCU_CONTROLLER_OBJECT, ORG_FREEDESKTOP_DBUS_PROPERTIES, "PropertiesChanged"),
      std::bind(`&BleRcuContollerProxy::signalHandlerPropertiesChanged`, this, std::placeholders::_1));
 
  //
  IInputHandler::KeyListenerV2 irListener = std::bind(
      `&BleRcuContollerProxy::onIrPairingCode`, this,
      std::placeholders::_1,  // event source
      std::placeholders::_2,  // filter byte
      std::placeholders::_3,  // key code
      std::placeholders::_4); // up/down state

  mIrListenerId = inputHandler->registerKeyListener
    (unsigned(IInputHandler::EventSource::Infrared), irListener, irPredicate);
}


BleRcuContollerProxy::~BleRcuContollerProxy()
{
  // can now safely stop the dispatcher
  mDispatcher->stop();
}


void BleRcuContollerProxy::signalHandlerDeviceAdded(const AI_IPC::VariantList& args)
{
  {
    std::string objectPath = boost::get<std::string>(args[0]);
    std::string address = boost::get<std::string>(args[1]);

    AI_LOG_INFO("Device added [object path: %s] [address: %s]", objectPath.c_str(), address.c_str());

    `mDispatcher->post`(std::bind(`&BleRcuContollerProxy::updateDeviceList`, this));
  }
}

void BleRcuContollerProxy::updateDeviceList()
{
  const AI_IPC::Method method(BLE_RCU_SERVICE, BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, 
      "GetDevices");

  AI_IPC::VariantList methodParams;
  AI_IPC::VariantList methodReturnValue;

  AI_LOG_INFO("Updating device list");

  if (mIpcService->invokeMethod(method, methodParams, methodReturnValue))
}

void BleRcuContollerProxy::addDevicesToDeviceList(const std::set<std::string>& objectPaths)
{
  for (const auto& objectPath : objectPaths)
  {
    AI_LOG_INFO("Add new device [object path: %s]", objectPath.c_str());

    try
    {
      mRcuDevices[objectPath] = std::make_shared<AI_BLERCU::BleRcuDevice>(
          mIpcService,
          mInputHandler,
          std::bind(`&BleRcuContollerProxy::notifyDevicePropertyChanged`, this),
          objectPath);
    }
    catch(const std::exception& e)
    {
      AI_LOG_ERROR("Failed to create device object [object path: %s]", objectPath.c_str());
    }
  }
}


*start-pairing*
// get input key and kicks off pairing request

void `BleRcuContollerProxy::onIrPairingCode`(
    IInputHandler::EventSource eventSource,
    uint8_t filterByte, 
    uint16_t keyCode, bool keyState)
{
  // unused - filter byte is used in the predicate before we get here
  (void)filterByte;

  // sanity check
  if ((keyCode & 0xff00) != (USER_INPUT_KEY_PAIRING_000 & 0xff00))
  {
    AI_LOG_ERROR_EXIT("odd, received non-pairing key code in callback");
    return;
  }

  *pairing-code*
  const uint8_t pairingCode = (keyCode & 0x00ff);

  AI_LOG_MILESTONE("received IR pairing code %03hhu", pairingCode);

  mDispatcher->post(std::bind(
        &`BleRcuContollerProxy::triggerPairing`, this, pairingCode));
}

void `BleRcuContollerProxy::triggerPairing`(uint8_t pairingCode)
{
  // if the daemon is already signalling that pairing is running don't bother
  // trying to start it again
  if (mPairing)
  {
    AI_LOG_INFO("ignoring pairing request as already in pairing state");
    AI_LOG_FN_EXIT();
    return;
  }

  // #define BLE_RCU_SERVICE                         "com.sky.blercu"
  // #define BLE_RCU_CONTROLLER_OBJECT               "/com/sky/blercu/controller"
  // #define BLE_RCU_CONTROLLER_INTERFACE            "com.sky.blercu.Controller1"
  // #define ORG_FREEDESKTOP_DBUS_PROPERTIES         "org.freedesktop.DBus.Properties"
  // #define BLE_RCU_DEVICE_INTERFACE_DEVICE1        "com.sky.blercu.Device1"
  // #define BLE_RCU_DEVICE_INTERFACE_INFRARED1      "com.sky.blercu.Infrared1"

  const AI_IPC::Method method(
      BLE_RCU_SERVICE, 
      BLE_RCU_CONTROLLER_OBJECT, 
      BLE_RCU_CONTROLLER_INTERFACE, 
      `"StartPairing"`);

  AI_IPC::VariantList methodParams = {pairingCode};
  AI_IPC::VariantList methodReturnValue;

  `if (!mIpcService->invokeMethod(method, methodParams, methodReturnValue))`
  {
    AI_LOG_ERROR("Failed to invoke '%s.%s'", method.interface.c_str(), method.name.c_str());
  }
}


// BluetoothRcu/client/lib/source/BleRcuDevice.cpp
// each device also registers functions to dbus

  std::function<void(void)> mNotifyPropertyChanged;

BleRcuDevice::BleRcuDevice(const std::shared_ptr<AI_IPC::IIpcService>& ipcService,
                 const std::shared_ptr<IInputHandler>& inputHandler,
                 const std::function<void(void)>& notifyPropertyChanged,
                 const std::string& objectPath)
    : mIpcService(ipcService), 
    `mNotifyPropertyChanged(notifyPropertyChanged)`, 
    mObjectPath(objectPath)
{
  // #define ORG_FREEDESKTOP_DBUS_PROPERTIES         "org.freedesktop.DBus.Properties"

  mPropertyChangedSignalHandler = mIpcService->registerSignalHandler(
      AI_IPC::Signal(
        objectPath, 
        ORG_FREEDESKTOP_DBUS_PROPERTIES, 
        "PropertiesChanged"),
      std::bind(`&BleRcuDevice::signalHandlerPropertyChanged`, this, std::placeholders::_1));

  // and more
}

void BleRcuDevice::signalHandlerPropertyChanged(const AI_IPC::VariantList& args)
{
  /*org.freedesktop.DBus.Properties.PropertiesChanged (STRING interface_name,
    DICT<STRING,VARIANT> changed_properties,
    ARRAY<STRING> invalidated_properties)*/

  if (args.size() >= 2)
  {
    try
    {
      std::string interface = boost::get<std::string>(args[0]); //STRING interface_name
      if (interface == BLE_RCU_DEVICE_INTERFACE_DEVICE1)
      {
        std::map<std::string, AI_IPC::DictDataType> changedProperties = boost::get<std::map<std::string, AI_IPC::DictDataType>>(args[1]); //DICT<STRING,VARIANT> changed_properties,

        if ((!changedProperties.empty()) || (!invalidatedProperties.empty()))
        {
          updateDeviceProperties(changedProperties, invalidatedProperties);
          `mNotifyPropertyChanged();`
        }
      }
    }
  }
}

void BleRcuContollerProxy::notifyDevicePropertyChanged()
{
  `mDispatcher->post`(std::bind(&BleRcuContollerProxy::notifyDeviceListChanged, this));
}

void BleRcuContollerProxy::notifyDeviceListChanged()
{
  `notify`( std::bind(&IBleRcuDeviceEvent::deviceListChanged, std::placeholders::_1) );
}


<bluez-q-console-side> *bluez-tool*

qWarning() << "KT: Console: dbusName: " << dbusName << ", serviceName: " << serviceName;

-sh-3.2# BleRcuConsole
KT: Console: 
  dbusName:  "com.sky.blercuconsole.pid6932" , 
  serviceName:  "com.sky.blercu"

[blercu]#


// console/source/main.cpp

int main(int argc, char *argv[])
{
  cmdHandler = QSharedPointer<BleRcuCmdHandler>::create(dbus, serviceName);
}

BleRcuCmdHandler::BleRcuCmdHandler(const QDBusConnection &bus,
                                   const QString &service,
                                   QObject *parent)
	: BaseCmdHandler(parent)
	, m_bus(bus)
	, m_serviceName(service)
{
  // initalise the dbus interfaces
  initBleRcuInterfaces(m_bus, m_serviceName,
      QStringLiteral("/com/sky/blercu/controller"));
}

void BleRcuCmdHandler::initBleRcuInterfaces(const QDBusConnection &bus,
                                            const QString &service,
                                            const QString &path)
{
  // get the controller interface which do the same as *bluez-controller-proxy*
  m_blercuController1 = 
    QSharedPointer<ComSkyBleRcuController1Interface>::create(service, path, bus);
}

void BleRcuCmdHandler::startPairing(quint8 pairingCode)
{
  if (!m_blercuController1 || !m_blercuController1->isValid()) {
    qWarning("Missing one or more required dbus interfaces");
    return;
  }

  // send the request to the daemon
  QDBusPendingReply<> reply = m_blercuController1->StartPairing(pairingCode);
  reply.waitForFinished();
  if (reply.isError())
    showDBusError(reply.error());
}


[blercu]# help
Available commands:
  connected-devices                                  List connected devices
  devices                                            List available devices
  exit                                               Quit program (same as quit)
  help                                               Display this text
  info <dev>                                         Device information
  ir-erase <dev>                                     Erases IR code(s) programmed into the rcu
  ir-get-codes <dev> <any/amp/tv> <manuf> <model>    Retreives a list of IR codes
  ir-get-manuf <dev> <any/amp/tv> <search> [sort]    Retreives a list of manufacturers
  ir-get-model <dev> <any/amp/tv> <manuf> <search>   Retreives a list of models
  ir-parse-edid <dev> [async] [edid]                 Parses the EDID sending back code list. If [edid] is supplied it should be hex string of 128 bytes
  ir-program <dev> <code> [signals...]               Programs the IR code(s) into the rcu
  ir-send <dev> <signal>                             Asks the RCU to send a given IR signal
  log-ethanlog [<on/off>]                            Gets / sets logging to ethan DIAG log
  log-level [fatal/error/warning/milestone/info/debug] Gets / sets the daemon log level
  log-syslog [<on/off>]                              Gets / sets logging to syslog
  pair <on/off> <code>                               Start/stop pairing using pairing byte code
  quit                                               Quit program


[blercu]# devices
Device 70:91:F3:22:BC:75 P039 SkyQ EC102
[blercu]# connected-devices
Device 70:91:F3:22:BC:75 P039 SkyQ EC102

[blercu]# connected-devices
Device D4:B8:FF:12:E1:A8 P066 SkyQ EC101

*dbus-monitor*
dbus-monitor "interface=com.sky.BleRcuDevice1"


void Console::initReadLine()
{
  m_readLine.setPrompt(m_cmdHandler->prompt());

  m_readLine.addCommand("devices", { }, "List available devices",
      this, &Console::onListDevicesCommand);

  // void BleRcuCmdHandler::listDevices()

  m_readLine.addCommand("connected-devices", { }, "List connected devices",
      this, &Console::onListConnectedDevicesCommand);
  // m_cmdHandler->listConnectedDevices();

  m_readLine.addCommand("pair", { "<on/off>", "<code>" }, "Start/stop pairing using pairing byte code",
      this, &Console::onStartPairingCommand);

  *start-pairing*
  // if (on)
  // 	m_cmdHandler->startPairing(pairingCode);
  //  { 
  //    QDBusPendingReply<> reply = m_blercuController1->StartPairing(pairingCode);
  //  }
  // else
  // 	m_cmdHandler->cancelPairing();

  // m_readLine.addCommand("unpair", { "<dev>" }, "Unpair device",
  //     this, &Console::onUnpairCommand);
  //
  // // m_cmdHandler->unPairDevice(address);
  // // qWarning("Not implemented on BLERCU interface");

  m_readLine.addCommand("info", { "<dev>" }, "Device information",
      this, &Console::onInfoCommand);

  // m_cmdHandler->deviceInfo(address);

  m_readLine.addCommand("log-level", { "[fatal/error/warning/milestone/info/debug]" }, "Gets / sets the daemon log level",
      this, &Console::onLogLevelCommand);

  // m_cmdHandler->setLogLevel(level);

  m_readLine.addCommand("log-syslog", { "[<on/off>]" }, "Gets / sets logging to syslog",
      this, &Console::onLogSyslogCommand);
  m_readLine.addCommand("log-ethanlog", { "[<on/off>]" }, "Gets / sets logging to ethan DIAG log",
      this, &Console::onLogEthanlogCommand);

  m_readLine.addCommand("hci-capture", { "[<on/off/clear/dump>] [file]" }, "Enables / disables / clear or dumps the HCI packet capture",
      this, &Console::onHciCaptureCommand);
}


void BleRcuCmdHandler::startPairing(quint8 pairingCode)
{
	if (!m_blercuController1 || !m_blercuController1->isValid()) {
		qWarning("Missing one or more required dbus interfaces");
		return;
	}

	// send the request to the daemon
	QDBusPendingReply<> reply = m_blercuController1->StartPairing(pairingCode);
	reply.waitForFinished();
	if (reply.isError())
		showDBusError(reply.error());
}


<bluez-q-daemon>

RCU_USR   5022  0.0  0.0   3224   548 ?        Ss   06:31   0:00 \
  /opt/libexec/DobbyInit /opt/sbin/BleRcuDaemon --noconsole --session --netns=3 --audio-fifo-dir=/tmp/blercu/
RCU_USR   5056  0.0  0.2  48860  7036 ?        Sl   06:31   0:00 \
  BleRcuDaemon --noconsole --session --netns=3 --audio-fifo-dir=/tmp/blercu/

// BleRcuDaemon started. address: , servicename: com.sky.blercu

// BluetoothRcu/daemon/source/main.cpp

int main(int argc, char *argv[])
{
  QCoreApplication app(argc, argv);
  QCoreApplication::setApplicationName("BleRcuDaemon");
  QCoreApplication::setApplicationVersion("2.0");

  // connect dbus
  QSharedPointer<QDBusConnection> dbusConn = 
    setupDBus(options->dbusType(),
      options->dbusAddress(),
      options->dbusServiceName());

  // setup and start the blercu controller object
  QSharedPointer<BleRcuController> controller =
    setupBleRcuController(options, config, irDatabase, dbusConn, debugDBusConn);
}

static QSharedPointer<QDBusConnection> setupDBus(CmdLineOptions::DBusType dbusType,
                                                 const QString &dbusAddress,
                                                 const QString &dbusServiceName)
{}

static QSharedPointer<BleRcuController> setupBleRcuController(const QSharedPointer<CmdLineOptions> &options,
                                                              const QSharedPointer<ConfigSettings> &config,
                                                              const QSharedPointer<IrDatabase> &irDatabase,
                                                              const QSharedPointer<QDBusConnection> &dbusConn,
                                                              const QSharedPointer<QDBusConnection> &debugDBusConn)
{
  *ai-bluetooth-ipc-service*
  // create the factory for generating BleRcuServices using the vendor
  // supplied IPC service
  QSharedPointer<IpcServicesFactory> ipcServicesFactory =
    QSharedPointer<IpcServicesFactory>::create(config,
        hidrawDevManager,
        QDBusConnection::systemBus(),
        options->audioFifoDirectory());

  *ai-bluetooth-device*
  // create the factory for generating BleRcuDevices
  QSharedPointer<BleRcuDeviceFactory> deviceFactory =
    QSharedPointer<BleRcuDeviceFactory>::create(*dbusConn, config,
        ipcServicesFactory,
        gattServicesFactory);

  *ai-bluetooth-manager*
  // create the manager object
  QSharedPointer<BleRcuManager> manager =
    QSharedPointer<BleRcuManagerImpl>::create(config,
        deviceFactory,
        QDBusConnection::systemBus());

  *ai-bluetooth-controller*
  // create the controller object
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(config, `manager`,
        options->networkNamespace());
  if (!controller || !controller->isValid()) {
    controller.reset();
    qFatal("failed to setup the BLE RCU controller");
  }

  // register on the controller on dbus
  controller->registerOnBus(*dbusConn);

  return controller;
}


<ai-bluetooth-daemon-controller>
// BluetoothRcu/daemon/source/blercu/blercucontroller.cpp

class BleRcuControllerImpl : public BleRcuController
                           , public QDBusContext
{}

// BluetoothRcu/daemon/source/blercu/blercucontroller_p.h

BleRcuPairingStateMachine m_pairingStateMachine;

BleRcuControllerImpl::BleRcuControllerImpl(const QSharedPointer<const ConfigSettings> &config,
                                           const QSharedPointer<BleRcuManager> &manager,
                                           int networkNamespaceFd,
                                           QObject *parent)

  , m_dbusObjectPath(QStringLiteral("`/com/sky/blercu/controller`"))
{
  *create-bluez-daemon-controller-adaptor*
  // create and attach the dbus adaptor for the controller interface to
  // ourselves.

  m_dbusAdaptors.append(new `BleRcuController1Adaptor`(
        this // *pass-bluez-controller*
        , `m_dbusObjectPath`));
}

bool BleRcuControllerImpl::registerOnBus(const QDBusConnection &dbusConn)
{
  // strip the const'ness off the connection (bit of a hack)
  QDBusConnection dbusConn_(dbusConn);

  if (!dbusConn_.`registerObject`(`m_dbusObjectPath`.path(), this)) {
    qError("failed to register blercudevice adaptor object(s)");
    return false;
  }

  // tell all the adaptors that they're now registered on the bus, this is
  // used for property change notifications
  for (DBusAbstractAdaptor *adaptor : m_dbusAdaptors)
    adaptor->registerConnection(dbusConn);

  // we are now ready so emit a 'Ready' signal over dbus letting everyone know
  BleRcuController1Adaptor *adaptor = findChild<BleRcuController1Adaptor*>();
  if (!adaptor)
    qWarning("failed to find BleRcuController1Adaptor child");
  else
    emit adaptor->Ready();

  return true;
}


<ai-bluetooth-daemon-controller-adaptor>

dbusxml/com.sky.blercu.Controller1.xml

{
  <interface name="com.sky.blercu.Controller1">

    <method name="StartPairing">
    <arg name="pairing_code" type="y" direction="in"/>
    </method>

    <method name="CancelPairing">
    </method>

    <method name="GetDevices">
    <arg name="devices" type="ao" direction="out"/>
    </method>

    <method name="IsReady">
    <annotation name="org.freedesktop.DBus.Method.NoReply" value="true"/>
    </method>

    <signal name="DeviceAdded">
    <arg name="path" type="o"/>
    <arg name="address" type="s"/>
    </signal>

    <signal name="DeviceRemoved">
    <arg name="path" type="o"/>
    <arg name="address" type="s"/>
    </signal>

    <signal name="Ready">
    </signal>

    <property name="Pairing" type="b" access="read"/>
    <property name="PairingCode" type="y" access="read"/>

    </interface>
}

// BluetoothRcu/daemon/source/blercu/adaptors/blercucontroller1_adaptor.h

class BleRcuController1Adaptor : public DBusAbstractAdaptor
{
  Q_OBJECT
    Q_CLASSINFO("D-Bus Interface", "com.sky.blercu.Controller1")
    Q_CLASSINFO("D-Bus Introspection", ""
        "  <interface name=\"com.sky.blercu.Controller1\">\n"
        "    <method name=\"Shutdown\"/>\n"
        "    <method name=\"StartPairing\">\n"
        "      <arg direction=\"in\" type=\"y\" name=\"pairing_code\"/>\n"
        "    </method>\n"
        "    <method name=\"CancelPairing\"/>\n"
        "    <method name=\"GetDevices\">\n"
        "      <arg direction=\"out\" type=\"ao\" name=\"devices\"/>\n"
        "    </method>\n"
        "    <method name=\"IsReady\">\n"
        "      <annotation value=\"true\" name=\"org.freedesktop.DBus.Method.NoReply\"/>\n"
        "    </method>\n"
        "    <signal name=\"DeviceAdded\">\n"
        "      <arg type=\"o\" name=\"path\"/>\n"
        "      <arg type=\"s\" name=\"address\"/>\n"
        "    </signal>\n"
        "    <signal name=\"DeviceRemoved\">\n"
        "      <arg type=\"o\" name=\"path\"/>\n"
        "      <arg type=\"s\" name=\"address\"/>\n"
        "    </signal>\n"
        "    <signal name=\"Ready\"/>\n"
        "    <property access=\"read\" type=\"b\" name=\"Pairing\"/>\n"
        "    <property access=\"read\" type=\"y\" name=\"PairingCode\"/>\n"
        "  </interface>\n"
        "")
  public:
        Q_PROPERTY(bool Pairing READ pairing)
          Q_PROPERTY(quint8 PairingCode READ pairingCode)

          ...
};


// BluetoothRcu/daemon/source/blercu/adaptors/blercucontroller1_adaptor.cpp

BleRcuController1Adaptor::BleRcuController1Adaptor(BleRcuController *parent,
                                                   const QDBusObjectPath &objPath)
  : DBusAbstractAdaptor(parent)
  , `m_controller(parent)` // *pass-bluez-controller* 
  , m_dbusObjPath(objPath)
{
  // don't auto relay signals, we do this manually
  setAutoRelaySignals(false);

  // connect to the device added and removed signals
  QObject::connect(m_controller, &BleRcuController::managedDeviceAdded,
      this, &BleRcuController1Adaptor::onDeviceAdded);
  QObject::connect(m_controller, &BleRcuController::managedDeviceRemoved,
      this, &BleRcuController1Adaptor::onDeviceRemoved);

  // connect to the pairing state change signals
  QObject::connect(m_controller, &BleRcuController::pairingStateChanged,
      this, &BleRcuController1Adaptor::onPairingStateChanged);
}

*start-pairing* *pairing-code*

Attempts to start the pairing procedure looking for devices that identify
with the given \a filterByte and \a pairingCode.  Both these byte values
are sent in the IR pairing signal and are used `to help identify` the RCU
model and unique name.

void BleRcuController1Adaptor::`StartPairing`(quint8 pairingCode,
                                            const QDBusMessage &message)
{
  // sanity check we're not already in the pairing state
  if (m_controller->isPairing()) {
    sendErrorReply(message, BleRcuError::errorString(BleRcuError::Busy),
        QStringLiteral("Already in pairing state"));
    return;
  }

  // attempt to start pairing using the supplied code
  if (!`m_controller->startPairing`(pairingCode)) {

    const BleRcuError error = m_controller->lastError();
    sendErrorReply(message, error.name(), error.message());

  }
}

bool BleRcuControllerImpl::startPairing(quint8 pairingCode)
{
  // start the pairing process
  m_pairingStateMachine.start(pairingCode);
  return true;
}


<bluez-q-controller-property-change> *state-change*

path : "`/com/sky/blercu/controller`"
iface: "com.sky.blercu.Controller1"

void BleRcuPairingStateMachine::onEnteredFinishedState()
{
  // finally just emit a finished signal to the BleRcuManagerImpl object
  emit finished();
}

BleRcuControllerImpl::BleRcuControllerImpl()
{
  QObject::connect(&m_pairingStateMachine, &BleRcuPairingStateMachine::finished,
      this, &BleRcuControllerImpl::onFinishedPairing,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onFinishedPairing()
{
  // tell clients that the pairing state is changed
  emit pairingStateChanged(pairing);
}

BleRcuController1Adaptor::BleRcuController1Adaptor(BleRcuController *parent)
{
	// connect to the pairing state change signals
	QObject::connect(m_controller, &BleRcuController::pairingStateChanged,
	                 this, &BleRcuController1Adaptor::onPairingStateChanged);
}

// daemon/source/blercu/adaptors/blercucontroller1_adaptor.cpp

void BleRcuController1Adaptor::onPairingStateChanged(bool pairing)
{
  `emitPropertyChanged(QStringLiteral("Pairing"), pairing);`
}

template <typename T>
void BleRcuController1Adaptor::emitPropertyChanged(const QString &propName,
    const T &propValue) const
{
  sendPropertyChangeNotification<T>(m_dbusObjPath.path(), propName, propValue);
}

// daemon/source/dbus/dbusabstractadaptor.h

class DBusAbstractAdaptor : public QDBusAbstractAdaptor
{
  bool sendPropertyChangeNotification(const QString &objectPath,
      const QString &propertyName,
      const T1 &propertyValue) const
  {
    // send the signal on all dbus connections
    for (const QDBusConnection &dbusConn : `m_dbusConnections`) {
      if (!dbusConn.send(propChangeSignal))
        qWarning("failed to send property change notification signal");
    }
  }
}

/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -p blercucontroller1_interface.h: ../dbusxml/com.sky.BleRcuController1.xml
 *
 * Proxy class for interface com.sky.BleRcuController1
 */
class ComSkyBleRcuController1Interface: public DBusAbstractInterface
{
  Q_PROPERTY(bool Pairing READ pairing NOTIFY pairingChanged)
    inline bool pairing() const
    { return qvariant_cast< bool >(property("Pairing")); }
};

void BleRcuCmdHandler::initBleRcuInterfaces()
{
  QObject::connect(m_blercuController1.data(), &ComSkyBleRcuController1Interface::pairingChanged,
      this, &BleRcuCmdHandler::onPairingStateChanged);
}


$ ag "emit stateChanged\("

daemon/source/blercu/blercucontroller.cpp
369:    emit stateChanged(PairingState::Searching);
550:    emit stateChanged(PairingState::Pairing);
572:    emit stateChanged(PairingState::Complete);
594:    emit stateChanged(PairingState::Failed);

606:    emit stateChanged(PairingState::Idle);

	m_stateMachine.addTransition(AdapterPoweredOffState,
       AdapterPoweredOnEvent, 
       AdapterPoweredOnState);

	// connect to the manager's initialised signal
	QObject::connect(manager.data(), &BleRcuManager::poweredInitialised,
	                 this, &BleRcuControllerImpl::onInitialised,
	                 Qt::QueuedConnection);

694:    emit stateChanged(PairingState::Failed);

*state-change-to-idle*

	enum PairingState
	{
		Initialsing,
		Idle,
		Searching,
		Pairing,
		Complete,
		Failed
	};
} // namespace

-sh-3.2# grep -an "BLERCU" /mnt/nds/dev_13/part_0/FSN_DATA/LOG
436:NDS: ^0000000114.579030 !MIL   -APPINFRA     < p:00000dfb t:42f52dc0 T:no name M:DiagService.cpp F:createLogPipe L:00137 > CreateLogPipe created pipe for app BLERCU with inode 24614
437:NDS: ^0000000114.580355 !MIL   -DOBBY        < p:00000dfb t:49afcdc0 T:no name M:EthanLogPlugin.cpp F:postConstruction L:00255 > Received pipe to BLERCU with inode 24614
443:NDS: ^0000000114.667217 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:.  L:00000 > Logging pipe inode is 24614
444:NDS: ^0000000114.693299 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:hcisocket.cpp F:create L:00311 > creating new socket for HciSocket object
445:NDS: ^0000000114.693485 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:hcisocket.cpp F:setSocketFilter L:00435 > setting hci filter to [ type=0x0010 events={0x00000020, 0x40000000} ]
446:NDS: ^0000000114.693867 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:qtvfs.cpp F:qtvfsRegister L:00704 > registered sqlite VFS for QT
447:NDS: ^0000000114.694251 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:irdatabase.cpp F:init L:00253 > opened ir database @ ':irdb.sqlite'
448:NDS: ^0000000114.700529 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:ipc_servicesfactory.cpp F:init L:00153 > created 'com.sky.rcu.Manager1' proxy to "/com/ruwido/rcu" on service "com.ruwido.rcu"
449:NDS: ^0000000114.701628 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:ipc_servicesfactory.cpp F:init L:00153 > created 'com.sky.rcu.Manager1' proxy to "/com/uei/userver" on service "com.uei.userver"
450:NDS: ^0000000114.701728 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercudevicefactory.cpp F:BleRcuDeviceFactory L:00047 > models with OUI 0x48d0cf are disabled
451:NDS: ^0000000114.705605 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercumanager.cpp F:findAdapter L:00703 > found bluez adapter at "/org/bluez/hci0" with address FF:FF:FF:FF:FF:FF
452:NDS: ^0000000114.706830 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercumanager.cpp F:onEnteredAdapterPoweredOffState L:00456 > adapter is not powered, attempting to power on now
453:NDS: ^0000000114.707987 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:hcimonitor.cpp F:run L:00645 > entering hci monitor thread
456:NDS: ^0000000114.715370 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:main.cpp F:main L:00478 > BleRcuDaemon started
457:NDS: ^0000000114.715420 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:main.cpp F:main L:00479 > ========================
458:NDS: ^0000000114.715449 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:main.cpp F:main L:00480 > KT: BleRcuDaemon started
626:NDS: ^0000000114.923988 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercumanager.cpp F:onAdapterPowerChanged L:00864 > BT adapter powered on
675:NDS: ^0000000114.936800 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercumanager.cpp F:disablePairable L:01142 > disabling pairable mode
676:NDS: ^0000000114.941246 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercumanager.cpp F:onEnteredAdapterPoweredOnState L:00552 > KT: onEnteredAdapterPoweredOnState: emit poweredInitialised
677:NDS: ^0000000114.941297 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercucontroller.cpp F:onInitialised L:00605 > KT: onInitialised: emit stateChanged(idle)
678:NDS: ^0000000114.941318 !MIL   -BLERCU       < p:00000dfb t:49afcdc0 T:no name M:blercucontroller1_adaptor.cpp F:onStateChanged L:00128 > onStateChanged( 1 )
-

<bluez-q-manager>

// BluetoothRcu/daemon/source/blercu/blercumanager.cpp

class BleRcuManager : public QObject
{}

bool BleRcuManagerImpl::attachAdapter(const QDBusObjectPath &adapterPath)
{
  // create a proxy to the 'org.bluez.Adapter1' interface on the adapter object
  m_adapterProxy = QSharedPointer<BluezAdapterInterface>::create(m_bluezService,
      adapterPath.path(),
      m_bluezDBusConn);

  // connect proxy to manager
  QObject::connect(m_adapterProxy.data(), &BluezAdapterInterface::discoveringChanged,
      this, &BleRcuManagerImpl::onAdapterDiscoveringChanged);
}


// BluetoothRcu/daemon/source/blercu/blercumanager_p.h

	StateMachine m_stateMachine;

BleRcuManagerImpl::BleRcuManagerImpl(const QSharedPointer<const ConfigSettings> &config,
                                     const QSharedPointer<IBleRcuDeviceFactory> &deviceFactory,
                                     const QDBusConnection &bluezBusConn,
                                     QObject *parent)


<bluez-q-controller>
// BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.cpp

void BleRcuPairingStateMachine::setupStateMachine()
{
}


void BleRcuManagerImpl::onDeviceAdded(const QDBusObjectPath &path,
                                      const QVariantMap &properties)
{
  // so we now have all the params we need, create a device object to manage
  // the (RCU) device
  QSharedPointer<BleRcuDevice> device = `m_deviceFactory->create`(bdaddr, name,
      m_bluezDBusConn,
      path);

  // connect device to manager
  QObject::connect(device.data(), &BleRcuDevice::nameChanged,
      this, nameChangedFunctor);
  ...
}

QSharedPointer<BleRcuDevice> BleRcuDeviceFactory::create(const BleAddress &address,
  const QString &name,
  const QDBusConnection &bluezBusConn,
  const QDBusObjectPath &bluezObjPath,
  QObject *parent) const
{
  *ai-bluetooth-device*
  QSharedPointer<BleRcuDevice> device =

    serviceFactory is *ai-bluetooth-ipc-service*
    QSharedPointer<BleRcuDeviceImpl>::create(serviceFactory,
        bluezBusConn,
        bluezObjPath,
        address,
        name,
        parent);

  // FIXME: the registration of the device on dbus should really be handled
  // in the BleRcuController object as that handles the master list of
  // managed devices we expose to clients.
  if (!device || !device->isValid() || !device->registerOnBus(m_dbusConn))
    device.reset();

  return device;
}


<bluez-q-device>

// appinfrastructure/AppInfrastructure/BluetoothRcu/
// daemon/source/blercu/blercudevice_p.h
// daemon/source/blercu/blercudevice.cpp

QSharedPointer<BluezDeviceInterface> m_deviceProxy;

QSharedPointer<BleRcuServices> m_services;

QList<DBusAbstractAdaptor*> m_blercuAdaptors;

BleRcuDeviceImpl::BleRcuDeviceImpl(const QSharedPointer<IBleRcuServicesFactory> &servicesFactory)
{
  // initialise the dbus interface to bluez
  (!init(bluezDBusConn, bluezDBusPath))
  {
    *ai-bluez-device-proxy*
    // create a proxy to the 'org.bluez.Device1' interface on the device object
    m_deviceProxy =
      QSharedPointer<BluezDeviceInterface>::create(QStringLiteral("org.bluez"),
          bluezDBusPath.path(),
          bluezDBusConn);

    // connect to the property change notifications from the daemon
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::connectedChanged,
        this, &BleRcuDeviceImpl::onDeviceConnectedChanged);
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::pairedChanged,
        this, &BleRcuDeviceImpl::onDevicePairedChanged);
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::servicesResolvedChanged,
        this, &BleRcuDeviceImpl::onDeviceServicesResolvedChanged);
    QObject::connect(m_deviceProxy.data(), &BluezDeviceInterface::nameChanged,
        this, &BleRcuDeviceImpl::onDeviceNameChanged);
  }

  *ai-bluez-device*
  // create ourselves a dbus object path
  const QString objPath = 
    QString::asprintf("/com/sky/blercu/device_%02hhX_%02hhX_%02hhX_%02hhX_%02hhX_%02hhX",
        m_address[0], m_address[1], m_address[2],
        m_address[3], m_address[4], m_address[5]);

  // register this on dbus
  `m_blercuObjectPath.setPath(objPath);`

  m_blercuAdaptors.append( new BleRcuDevice1Adaptor(this, m_blercuObjectPath) );
}

bool BleRcuDeviceImpl::registerOnBus(const QDBusConnection &dbusConn)
{
  if (!dbusConn_.`registerObject`(m_blercuObjectPath.path(), this)) {
    qError("failed to register blercudevice adaptor object(s)");
    return false;
  }

  // tell all the adaptors that they're now registered on the bus, this is
  // used for property change notifications
  for (DBusAbstractAdaptor *adaptor : m_blercuAdaptors)
    adaptor->registerConnection(dbusConn);
}

// daemon/source/blercu/adaptors/blercudevice1_adaptor.h

/*
 * Adaptor class for interface com.sky.BleRcuDevice1
 */
class BleRcuDevice1Adaptor : public DBusAbstractAdaptor
{
	Q_OBJECT
	Q_CLASSINFO("D-Bus Interface", "com.sky.blercu.Device1")
	Q_CLASSINFO("D-Bus Introspection", "")
};


// daemon/source/dbus/dbusabstractadaptor.cpp

class DBusAbstractAdaptor : public QDBusAbstractAdaptor

void DBusAbstractAdaptor::registerConnection(const QDBusConnection &connection)
{
  `m_dbusConnections`.append(connection);
}


<bluez-test-client>

// AppInfrastructure/BluetoothRcu/client/test/source/BlueRcuProxyTest.cpp


<bluez-test-daemon>
BleRcuController(Mock)  | BleRcuController1Adaptor      | DBus | Proxy
                        | "com.sky.blercu.Controller1"
                        | OUT(Object Under Test)

// AppInfrastructure/BluetoothRcu/daemon/test/source/mck_blercucontroller.h

class MockBleRcuController : public BleRcuController
                           , public QDBusContext
{
  MOCK_METHOD1(startPairing, bool(quint8));
};


// AppInfrastructure/BluetoothRcu/daemon/test/source/tst_blercucontrolleradaptor.cpp

class BleRcuControllerAdaptorTest : public ::testing::Test
{
  public:
    void SetUp()
    {
      m_mockController = QSharedPointer<MockBleRcuController>::create();
    }
};


// Therefore, it is to test dbus interface exposed by daemon

TEST_F(BleRcuControllerAdaptorTest, testStartPairing)
{
  // check happy case
  const QList<quint8> values = { 0, 123, 255 };
  for (const quint8 &value : values) {

    // construct the request
    QDBusMessage request = QDBusMessage::createMethodCall("", m_deviceObjPath, m_interfaceName, "StartPairing");
    request << QVariant::fromValue(value);

    // expect the the controller will be called to start pairing
    // return success
    EXPECT_CALL(*m_mockController, isPairing())
      .WillOnce(::testing::Return(false));
    EXPECT_CALL(*m_mockController, startPairing(value))
      .WillOnce(::testing::Return(true));

    // check for a positive reply
    QDBusMessage reply = m_dbusConn->call(request, QDBus::BlockWithGui);
    EXPECT_EQ(reply.type(), QDBusMessage::ReplyMessage);
  }
}


<bluz-q-bluez-logging> *bluez-log-milestone*
appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/utils/logging.cpp

// to have info logging

static void messageOutput(QtMsgType type, const QMessageLogContext &context,
                          const QString &msg)
{
	if (context.category == milestone().categoryName()) {
		level = LoggingLevel::Milestone;

	} else {
		// not in the milestone category so use the qt message type
		switch (type) {
			case QtFatalMsg:    level = LoggingLevel::Fatal;    break;
			case QtCriticalMsg: level = LoggingLevel::Error;    break;
			case QtWarningMsg:  level = LoggingLevel::Warning;  break;
			case QtInfoMsg:     level = LoggingLevel::Milestone;     break;
			// case QtInfoMsg:     level = LoggingLevel::Info;     break;
			case QtDebugMsg:    level = LoggingLevel::Debug;    break;
			default:            level = LoggingLevel::Debug;    break;
		}
	}
}

18685:NDS: ^0000000141.602695 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercumanager.cpp F:onAdapterPowerChanged L:00856 > BT adapter powered on
18687:NDS: ^0000000141.617348 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving to state Idle(0)"
18688:NDS: ^0000000141.618547 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercumanager.cpp F:onDeviceAdded L:01459 > added device 70:91:F3:22:BC:75 named "P039 SkyQ EC102" (connected: false paired: true)
18689:NDS: ^0000000141.618594 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:name L:00878 > KT: BleRcuDeviceImpl: name  P039 SkyQ EC102
18690:NDS: ^0000000141.620675 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:onDevicePairedChanged L:00482 > 70:91:F3:22:BC:75 paired
18691:NDS: ^0000000141.620833 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state Idle(0) to Paired(1)"
21866:NDS: ^0000000157.009252 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:onDeviceConnectedChanged L:00456 > 70:91:F3:22:BC:75 connected
21867:NDS: ^0000000157.009296 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state Paired(1) to ResolvingServices(3)"
21886:NDS: ^0000000157.854269 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:hidrawdevicemanager.cpp F:syncHidRawDeviceMap L:00293 > hidraw device @ "/hostdev/hidraw0" with physical address "70:91:f3:22:bc:75" has been added
22356:NDS: ^0000000158.154419 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercudevice.cpp F:onDeviceServicesResolvedChanged L:00511 > 70:91:F3:22:BC:75 services resolved
22357:NDS: ^0000000158.154459 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state ResolvingServices(3) to StartingServices(8)"
22359:NDS: ^0000000158.590546 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:.  L:00000 > bluetooth rcu device info [ Universal Electronics, Inc. / Sky EC102 / hw:102.0.0.1 / fw:BL 195 / sw:7007.02.09 ]
22360:NDS: ^0000000158.791891 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state StartingServices(8) to ReadyState(9)"
22361:NDS: ^0000000158.792324 !MIL   -BLERCU       < p:00000de4 t:89cbadc0 T:no name M:blercumanager.cpp F:onDeviceReadyChanged L:01685 > device with address 70:91:F3:22:BC:75 is  ready


={============================================================================
*kt_dev_skymw_0000* skymw-bluez-audio-stream

*refs*
https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=2016&title=Qt+WebRuntime+Documentation
Bluetooth Audio: ETHAN Bluetooth AUdio Streaming Theory Of Ops.pdf

*refs*
dbusitf usage in AS
https://www.stb.bskyb.com/confluence/display/~partom1/dbusitf+usage+in+AS

BluetoothAudio

BluetoothAudio provides a pairing mechanism for devices which may stream audio
to the STB.  It exports http APIs for enabling and disabling STB visibility, and
managing incoming pairing requests.  It also provides a status websocket with
information about paired devices as well as information about a pairing request
when pairing is in progress.

The pairing process for audio devices consists of the following steps:

1. BluetoothAudio's startvisibility API is used to make the STB visible
(discoverable) and pairable

2. The user initiates a scan on their device, and when the STB is discovered
makes a pairing request "from the device to the STB"

3. When the pairing request is received by the STB, BluetoothAudio generates a
status update with details of the device MAC and name, and pairing code (if any)

4. If the pairing request should be accepted, BluetoothAudio's acceptpairing API
is used to accept the request

5. Once pairing is completed, BluetoothAudio updates its websocket status to
reflect the pairing status of the device

Device updates
BluetoothAudio encapsulates all dbusitf interactions within a "platform
interface" class PlatformItf.  This provides listener interfaces for device
updates, as well as listener interfaces for the bluez pairing agent (see below).
When device updates are received, PlatformItf calls methods on the
BluetoothAudio Controller object.

Initial bringup
Similar to RcuController, on initialisation BluetoothAudio populates its own
internal list of devices based on the dbusitf device object population.  This
process is handled by PlatformItf::PopulateStatusDb(), called early on by
Controller::exec().  Again similar to RcuController, PlatformItf registers
itself as a dbusitf device listener during construction, so by the time
PopulateStatusDb() is called it is already listening for device updates.

The pairing agent
While RcuController drives pairing requests from the STB, in the BluetoothAudio
case pairing requests originate with the user's device. Handling of this is
significantly different.

Bluez has the concept of a "pairing agent", which is essentially a DBus endpoint
that client code can register in order to take responsibility for accepting or
rejecting incoming pairing requests.  dbusitf provides this functionality as
BluetoothPairingAgent, which has its own listener interface and methods for
accepting and rejecting pairing requests.

BluetoothAudio registers a listener with BluetoothPairingAgent, and uses the
callbacks on this interface to populate its websocket with pairing request
information.


The architecture of the dbusitf code
*refs*
https://www.stb.bskyb.com/confluence/display/~partom1/The+architecture+of+the+dbusitf+code

Bluetooth media streaming
*refs*
https://www.stb.bskyb.com/confluence/display/~partom1/Bluetooth+media+streaming


<diag-logging>
NDS: ^0000000336.330585 !MIL   -AS           < p:00000df9 t:6e8c4dc0 T:no name M:AS_DMS_Writer.cpp 
  F:BluetoothA2DPTransport L:00258 > @ctx:dbusitf bluetooth_a2dp_transport.cpp(32) new a2dp transport /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0


<player-switch-protocols>

// 1. m_ptrBluetoothProtocol is enabled as long as Player runs
// 2. set m_nextProtocol and use `startStreamingFromProtocol(m_nextProtocol);`

// Components/AudioStreamer/source/AudioStreamerPlayer.cpp
void AudioStreamer::Player::run()
{
  m_ptrBluetoothProtocol = new BluetoothProtocol();

  while()
  {
    case TASK_TYPE_SET_OPERATING_MODE:
      {
        case PREFS_API_TERMINAL_OPERATING_MODE_ON:

          if( m_nextProtocol!=NULL )
          {
            AUD_LOG_INFO("PREFS_API_TERMINAL_OPERATING_MODE_ON: Starting next protocol %p", m_nextProtocol);
            `startStreamingFromProtocol(m_nextProtocol);`
            m_nextProtocol=NULL;
          }
          break;
      }

    case TASK_TYPE_STREAMING_STATE_UPDATE:
      {
        bool streamingBlocked = s_applicationLaunchPolicy->canLaunchApplication(s_appId);
        AUD_LOG_MIL("Can Launch app returned %x",streamingBlocked);
        if (streamingBlocked != m_streamingAllowed)
        {
          m_streamingAllowed = streamingBlocked;
          if( m_streamingAllowed )
          {
            `handleEnableStreaming();`
          }
        }
      }
  }

  if( m_ptrBluetoothProtocol!=NULL )
  {
    m_ptrBluetoothProtocol->disable();
    delete m_ptrBluetoothProtocol;
    m_ptrBluetoothProtocol=NULL;
  }

  if( m_ptrAirplayProtocol!=NULL )
  {
    m_ptrAirplayProtocol->disable();
    delete m_ptrAirplayProtocol;
    m_ptrAirplayProtocol=NULL;
  }
}

void AudioStreamer::Player::handleEnableStreaming()
{
  /*
   * Start MDNSD before enabling Airplay
   */
  if (m_networkAvailable )
  {

    if (configureAndStartMdnsd())
    {
      m_ptrAirplayProtocol->enable(m_webServer->getPort());
    }
    else
    {
      AUD_LOG_FATAL("Airplay is not enabled as Audiostreamer failed to start MDNSD in a container");
    }
    m_airplayEnabled = true;
  }
  else
  {
    AUD_LOG_WARNING("Airplay is Not enabled due to Network UnAvailability");
  }

  *bluetooth-audio-enable*
  m_ptrBluetoothProtocol->enable();
}

// Components/AudioStreamer/source/BluetoothProtocol.cpp

namespace AudioStreamer
{
  class BluetoothProtocol : public Protocol, public Base
  {
    BluetoothApi::Streamer*                 m_btInstance;
  };
}

*bluetooth-audio-enable*
void AudioStreamer::BluetoothProtocol::enable()
{
    AUD_LOG_MIL("Starting bluetooth");

    BluetoothApi::Streamer::createInstance();
    m_btInstance = BluetoothApi::Streamer::instance();
    m_btInstance->setMessageHandler(&s_bluetoothEventListener,this);    
    uint32_t timeout = MwServices::instance().getDevDisconnectionTimeout();
    m_btInstance->setBluetoothTimeout(timeout);
}

void AudioStreamer::BluetoothProtocol::disable()
{
  if( m_btInstance==NULL )
  {
    AUD_LOG_WARNING("Bluetooth already stopped, nothing to stop");
    return;
  }
  AUD_LOG_MIL("Stopping bluetooth");
  m_btInstance->stop();
  m_wa_stopSent=true;
  BluetoothApi::Streamer::destroyInstance();
  m_btInstance=NULL;
}

void AudioStreamer::BluetoothProtocol::getAudioData(uint32_t sampleTime, uint64_t hostTime, void *buffer, size_t bufferLen)
{
}


int AudioStreamer::Player::startUp()
{
  //start check launch policy
  Task t;
  t.type=TASK_TYPE_STREAMING_STATE_UPDATE;
}

int AUDIO_STREAMER::Proxy::StartUp()
{
  return AudioStreamer::Player::instance().startUp();
}


// switch between protocols

void AudioStreamer::Player::handleProtocolMessage(Task &task)
{
  switch(msg->type)
  {
    case Protocol::MESSAGE_TYPE_SESSION_INITIALIZE:
      {
        // stop current protocol first that session has and then save it for next

        AUD_LOG_INFO("Stop protocol %p first",m_session.getProtocol());
        m_nextProtocol=msg->protocol;
        handleStopStreaming(); // calls m_protocol->stop();
      }

    case Protocol::MESSAGE_TYPE_SESSION_FINALIZE_BEGIN:

  }
}

// Components/AudioStreamer/source/AirPlayProtocol.cpp

bool AudioStreamer::AirPlayProtocol::sessionInitialize()
{
  Message msg;
  postProtocolMessage(MESSAGE_TYPE_SESSION_INITIALIZE, msg);
  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::sessionInitialize");
  return msg.success;
}

// Components/AudioStreamer/source/BluetoothProtocol.cpp

void AudioStreamer::BluetoothProtocol::bluetoothEventListener(const BluetoothApi::Streamer::Message& message)
{
  case BluetoothApi::Streamer::MESSAGE_TYPE_SESSION_START:
    {
      AudioThread::Format atf = s_convertBtFormat(message.audioFormat);            
      if( !AudioThread::validateFormat(atf) )
      {
        AUD_LOG_WARNING("Cannot validate audio format");
        break;
      }

      m_audioFormat=atf;
      AUD_LOG_INFO("AudioFormat: sampleSize %d channels %d sampleRate %d", m_audioFormat.sampleSizeBytes, m_audioFormat.channels, m_audioFormat.sampleRate);

      Message msg;
      postProtocolMessage(MESSAGE_TYPE_SESSION_INITIALIZE, msg);

      break;
    }
}

void AudioStreamer::Player::startStreamingFromProtocol(Protocol *protocol)
{
  if( !m_audioThread.threadStart() ) { AUD_LOG_FATAL("Failed to start audio thread"); }
  m_session.start(protocol);
}

void AudioStreamer::Player::Session::`start`(Protocol *protocol)
{
  m_protocol=protocol;
  AUD_LOG_MIL("Session::start protocol %p type %d", m_protocol, m_protocol->getProtocolType());
  m_playerStatus.protocol=protocol->getProtocolType();
  setState(AUDIO_STREAMER::STREAMING);
}


<bluetooth-streamer> *bluetooth-audio-enable*

// ethan-as-source/Components/AudioStreamer/source/BluetoothProtocol.cpp

BluetoothApi::Streamer*                 m_btInstance;

void AudioStreamer::BluetoothProtocol::s_bluetoothEventListener
  (const BluetoothApi::Streamer::Message& message, void *user);

void AudioStreamer::BluetoothProtocol::enable()
{
  AUD_LOG_MIL("Starting bluetooth");
  `BluetoothApi::Streamer::createInstance();`
  m_btInstance = BluetoothApi::Streamer::instance();

  // it is actually BluetoothMediaStreamer
  // register callback to `BluetoothMediaStreamer`
  `m_btInstance->setMessageHandler(&s_bluetoothEventListener,this);`
}

// Components/Bluetooth/reader/include/BluetoothStreamer.h
namespace BluetoothApi
{
  class Streamer
  {
  };
}


// Components/Bluetooth/reader/source/bluetooth_media.h
// Components/Bluetooth/reader/source/bluetooth_media.cpp

class BluetoothMediaStreamer : 
  public BluetoothApi::Streamer, 
  public BluetoothA2DPTransportListener, public TimerListener
{
};


/** @brief Creates the object which manages the bluetooth streamer
 *
 * Creates internal state for managing the bluetooth streamer. If already
 * created, this function does nothing. Thread safe.
 */
void BluetoothApi::Streamer::createInstance()
{
  pthread_rwlock_wrlock(&singleton_lock);
  if (!singleton) singleton = `new BluetoothMediaStreamer();`
  pthread_rwlock_unlock(&singleton_lock);
}


*dbus-device-added*

F:onPropertyChange L:00258 > @ctx:dbusitf bluetooth_media.cpp(78) BluetoothDeviceListener::onPropertyChange received connection status Connected
F:onDeviceState L:00258 > @ctx:dbusitf bluetooth_media.cpp(366) KT: BluetoothMediaStreamer::onDeviceState received for 
  path /org/bluez/hci0/dev_D4_B8_FF_66_D6_25 connection status 1

*dbus-transport-added* which fire up listener chain

// Components/Bluetooth/dbusitf/source/bluez_parser.cpp
// Handle interface addition, either from signals or from GetManagedObjects responses

class BluezInterfaceAdditionAdapter : public BluezParserAdapter
{
  case BluezParserEvent::PROPERTYBAG_END:
    if (m_listener && m_object) m_listener->onBluezObjectAdded(m_interface, *m_object);
}

// Components/Bluetooth/dbusitf/source/bluetooth.cpp

std::vector<BluezProxy*> m_bluez_proxies;

/**
 * @brief BluezParser callback.
 * Not for external use.
 */
void Bluetooth::onBluezObjectAdded(const std::string &interface, const BluezObject &obj)
{
  Locker lock(&m_bus_lock);
  BluezProxy *proxy = NULL;
  if (lookupProxy(interface, &proxy)) `proxy->add(obj);`
  else AS_LOG_ERROR("no proxy for %s %s", interface.c_str(), obj.getPath().c_str());
}

*dbus-property-update*
void Bluetooth::onBluezProperty(const std::string &object_path, const std::string &interface, const DBusProperty &property)
{
  Locker lock(&m_bus_lock);
  BluezProxy *proxy = NULL;
  if (lookupProxy(interface, &proxy)) {
    if (!`proxy->update`(object_path, property))
  }
}

void BluetoothMediaTransport::add(const BluezObject &object)
{
  BluezObject o = object;
  o += m_prototype_object;
  BluezProxy::add(o);
}

/**
 * @brief Add a new BluezObject to the proxy
 * @param object reference to the BluezObject to add
 */

#define notify(_what) do { \
    std::vector<BluezProxyListener*> listeners; \
    { \
        Locker lock(&m_listener_lock); \
        listeners = m_listeners; \
    } \
    for (std::vector<BluezProxyListener*>::iterator it = listeners.begin(); it != listeners.end(); ++it) if (*it) (*it)->_what; \
} while(0)

void BluezProxy::add(const BluezObject &object)
{
  /* Adding a duplicated object is probably a sign that bluetoothd restarted
   * without cleanly shutting down first.
   * Since we'd like to keep our cached information up-to-date, we need to replace
   * our BluezObject with the new one.
   * And since we'd like any client code to be able to do required magic on object
   * re-registration, generate a fake "removed" event before re-adding.
   */
  if (lookup(object.getPath())) {
    drop(object.getPath());
  }

  *notify*
  `if (addObject(object)) notify(onObjectAdded(object.getPath()));`
}

class MediaTransportListener : public BluezProxyListener
{
  public:
    MediaTransportListener(BluetoothMediaStreamer *streamer) : m_streamer(streamer) {};

  private:
    void onObjectAdded(const std::string &path) {
      if (m_streamer) `m_streamer->onTransportAdded(path);`
    };

    void onPropertyChange(const std::string &path, const DBusProperty &property) {
      if (property.getName() == BLUEZ_MEDIATRANSPORT_PROP_STATE) {
        if (m_streamer) m_streamer->`onTransportState`(path, property.getValue().asString());
      }
    };

    BluetoothMediaStreamer *m_streamer;
};


class BluetoothMediaStreamer : 
  public BluetoothApi::Streamer, 
  `public BluetoothA2DPTransportListener`, 
  public TimerListener
{
  BluetoothMediaTransport *m_transport;
};

/** @brief Constructs the BluetoothMediaStreamer object.
 *
 * Creates locks used for thread safety. Registers for Bluez MediaPlayer events
 * and starts a thread to handle Bluez events. Blocks until the media thread is
 * running.
 */
BluetoothMediaStreamer::BluetoothMediaStreamer()
{
  // `register to dbus`

  std::vector<std::string> endpoints = media_endpoint->getObjectPaths();

  // BluetoothMediaTransport *m_transport;

  m_transport = Bluetooth::getInstance()->getMediaTransports();
  if (m_transport) {
    `m_transport_listener = new MediaTransportListener(this);`
    if (m_transport_listener) m_transport->addListener(m_transport_listener);
    else AS_LOG_ERROR("failed to create MediaTransportListener");
  } else {
    AS_LOG_ERROR("failed to obtain BluetoothMediaTransport");
  }
}


*dbus-transport-added*
/** @brief Handles Bluez MediaTransport1 addition
 */
void BluetoothMediaStreamer::onTransportAdded(const std::string &path)
{
  m_evq.push(BTStreamerMessage
      (BTStreamerMessage::MSG_TYPE_TRANSPORT_ADDED, path));
}


F:onTransportAdded L:00258 > @ctx:dbusitf bluetooth_media.cpp(293) 
  KT: BluetoothMediaStreamer::onTransportAdded: path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0

// thread

void BluetoothMediaStreamer::eventHandler(void)
{
  case BTStreamerMessage::MSG_TYPE_TRANSPORT_ADDED:
    // Create a new session for this transport
    if (`createSession(m.object_path)`) 
      current_transport = m.object_path;
    break;
}


// Components/Bluetooth/reader/source/bluetooth_media.h

class PlaybackSession {
  public:
    PlaybackSession(
        const std::string &bluez_xport_path, 
        BluetoothA2DPTransportListener *listener)

      : xport(NULL)
        , xport_listener(listener)
        , halt_timer(TIMER_ID_UNSET) 
        {
          xport = `new BluetoothA2DPTransport(bluez_xport_path);`
          if (xport) xport->addListener(xport_listener);
        };
};

bool BluetoothMediaStreamer::createSession(const std::string &xport_path)
{
  PlaybackSession *session = findSessionByXport(xport_path);
  if (!session) {
    `session = new PlaybackSession(xport_path, this);`
  }
  return false;
}


*dbus-property-update*

/** @brief Handles Bluez MediaTransport1 state change
 */
void BluetoothMediaStreamer::onTransportState(const std::string &path, const std::string &state)
{
  m_evq.push(BTStreamerMessage(BTStreamerMessage::MSG_TYPE_TRANSPORT_STATE, path));
}

void BluetoothMediaStreamer::eventHandler(void)
{
  case BTStreamerMessage::MSG_TYPE_TRANSPORT_STATE:
    {
      PlaybackSession *session = findSessionByXport(m.object_path);
      if (session) {
        std::string state;

        // get state from bluez dbuf
        // #define BLUEZ_MEDIATRANSPORT_STATE_ACTIVE           "active"
        // bool BluetoothMediaTransport::getState(const std::string &object_path, std::string &state) const
        
        if (m_transport->getState(session->xport->m_transport_path, state))
          session->xport->`update`(state);
      }
    }
    break;
}


// Components/Bluetooth/reader/source/bluetooth_a2dp_transport.cpp

BluetoothA2DPTransport::BluetoothA2DPTransport(const std::string &transport_path)
    : m_transport_path(transport_path)
    , m_fsm(NULL)
    , m_reader(NULL)
    , m_got_media_format(false)
{
  pthread_mutex_init(&m_listener_lock, NULL);
  *create-media-fsm*
  `m_fsm = new BluetoothMediaFsm(transport_path);`
  if (m_fsm) {
    `m_fsm->addListener(this);`
    AS_LOG_MIL("new a2dp transport %s", transport_path.c_str());
  } else AS_LOG_ERROR("failed to create fsm instance");
}


*dbus-property-update* drive fsm

void BluetoothA2DPTransport::update(const std::string &u)
{
  if (m_fsm) {
    BluetoothMediaFsm::FsmEvent ev;
    if (u == BLUEZ_MEDIATRANSPORT_STATE_IDLE)          ev = BluetoothMediaFsm::FSM_EVENT_TRANSPORT_IDLE;
    else if (u == BLUEZ_MEDIATRANSPORT_STATE_PENDING)  ev = BluetoothMediaFsm::FSM_EVENT_TRANSPORT_PENDING;
    `else if (u == BLUEZ_MEDIATRANSPORT_STATE_ACTIVE)   ev = BluetoothMediaFsm::FSM_EVENT_TRANSPORT_ACTIVE;`
    else {
      AS_LOG_ERROR("unhandled state string %s", u.c_str());
      return; // early, we don't want to inject the event if we don't map it
    }
    m_fsm->injectEvent(ev);
  }
}


// Components/Bluetooth/reader/source/bluetooth_media_fsm.h
*use-thread*
ret = pthread_create(&m_thread, NULL, threadFn, (void*)this);

class BluetoothMediaFsm
{
public:
    enum FsmEvent {
        FSM_EVENT_TRANSPORT_IDLE,
        FSM_EVENT_TRANSPORT_PENDING,
        FSM_EVENT_TRANSPORT_ACTIVE,
        FSM_EVENT_TRANSPORT_DEAD,
        FSM_EVENT_QUIT,
    };

    BluetoothMediaFsm(std::string transport_path);
    ~BluetoothMediaFsm();

    bool addListener(BluetoothMediaFsmListener *listener);
    bool removeListener(BluetoothMediaFsmListener *listener);

    bool getFd(int &fd, uint16_t &wmtu, uint16_t &rmtu) {
        if (m_fd < 0) return false;
        fd = m_fd;
        wmtu = m_wmtu;
        rmtu = m_rmtu;
        return true;
    };

    BluetoothMediaTransport *m_transport;
};

void BluetoothMediaFsm::run()
{
  bool running = true;

  // obtain BT proxy handles
  if (!m_transport && !m_endpoint) {
    *get-bluetooth-singleton*
    Bluetooth *bt = Bluetooth::getInstance();
    DBusProperty property("");
    if (bt) {
      m_endpoint = bt->getMediaEndpoints();
      m_transport = bt->getMediaTransports();
    }
  }

  *dbus-transport-aquire-fd*
  case FSM_EVENT_TRANSPORT_PENDING:
    if (!acquireTransport()) {
    }

  *dbus-property-update* *calls-transport-up*
  case FSM_EVENT_TRANSPORT_ACTIVE:
    setState(Connected);
}

bool BluetoothMediaFsm::acquireTransport()
{
  m_transport->tryAcquire(m_transport_path, m_fd, m_rmtu, m_wmtu);
}


/**
 * @brief Attempt to acquire a file descriptor for a media transport.
 * This relies on the transport being in the pending state, the call will fail
 * if the transport is idle.
 *
 * @param object_path the bluez entity path of the transport
 *
 * @param fd reference to an integer to be assigned with the tranport file
 * descriptor on success 
 *
 * @param readMTU reference to an integer to be assigned with the transport
 * read MTU on success 
 *
 * @param writeMTU reference to an integer to be assigned with the transport
 * write MTU on success 
 *
 * @return true on success, false otherwise
 */

bool BluetoothMediaTransport::tryAcquire
  (const std::string &object_path, int &fd, uint16_t &readMTU, uint16_t &writeMTU)
{
  if (!lookup(object_path)) {
    AS_LOG_ERROR("no such path %s", object_path.c_str());
    return false;
  }

  bool ret = false;
  DBusMessage *response = NULL;
  DBusMessage *msg = 
    dbus_message_new_method_call("org.bluez", object_path.c_str(), 
        "org.bluez.MediaTransport1", "TryAcquire");

  if (msg) {
    if (blockingSend(msg, &response)) {
      int fdesc;
      uint16_t rmtu, wmtu;
      DBusError error;
      dbus_error_init(&error);
      if (!dbus_message_get_args(response, &error, DBUS_TYPE_UNIX_FD, &fdesc, DBUS_TYPE_UINT16, &rmtu, DBUS_TYPE_UINT16, &wmtu, DBUS_TYPE_INVALID)) {
        AS_LOG_ERROR("failed to parse TryAcquire response: %s", error.message);
        dbus_error_free(&error);
      } else {

        `fd = fdesc;`

        readMTU = rmtu;
        writeMTU = wmtu;
        ret = true;
      }
    } else {
      AS_LOG_ERROR("dbus send failed");
      ret = false;
    }
    dbus_message_unref(msg);
    if (response) dbus_message_unref(response);
  } else AS_LOG_ERROR("failed to create dbus message");
  return ret;
}


*dbus-property-update* *dbus-transport-aquire-read-fd*

void BluetoothMediaFsm::setState(BluetoothMediaFsmState s)
{
  AS_LOG_MIL("%s -> %s", fsmStateString(m_state), fsmStateString(s));
  if (s != m_state) {
    if (s == Connected) notify(onTransportUp(true));
    else if (s == Disconnected) notify(onTransportUp(false));
  }
  m_state = s;
}

void BluetoothA2DPTransport::transportUp()
{
  if (!m_reader) {
    int fd;
    uint16_t wmtu, rmtu;
    a2dp_sbc_t config;
    if (`m_fsm->getFd`(fd, wmtu, rmtu) && m_fsm->getConfig(config)) {
      `m_reader = new BluetoothMediaReader(fd, config);`
      if (m_reader) {
        `m_reader->addListener(this);`
      } else AS_LOG_ERROR("failed to instantiate media reader");
    } else AS_LOG_ERROR("failed to obtain transport fd and config");
  } else {
    if (m_got_media_format) notify(onMediaTransportUp(this, m_format, m_samplerate, m_channels));
    else {
      /* stale reader, create a new one */
      delete m_reader;
      m_reader = NULL;
      transportUp();
    }
  }
}


// Components/Bluetooth/reader/source/bluetooth_media_reader.cpp

BluetoothMediaReader::BluetoothMediaReader(int fd, a2dp_sbc_t &config)
{
  *use-thread*
  ret = pthread_create(&m_thread, &attr, readerThreadFn, this);
}


*dbus-transport-aquire-read-ready*
ssize_t BluetoothMediaReader::decode(const uint8_t *data, int sz)
{
  if (decoded_len > 0) {
    `notify(onBufferReady((char*)m_buf, decoded_len, m_sample));`
    return offset + sizeof(struct rtp_header) + sizeof(*payload);
  }
}

void BluetoothA2DPTransport::onBufferReady(char *buffer, size_t nbytes, size_t sampleno)
{
  notify(onBufferReady(this, buffer, nbytes, sampleno));
}

void BluetoothMediaStreamer::onBufferReady(BluetoothA2DPTransport *xport, void *buffer, size_t nbytes, size_t samplenum)
{
  // Copy buffer data; we'll release it later when the player app has finished with it

  `char *copy = new char[nbytes];`
  if (copy) {

    *use-memcpy*
    memcpy(copy, buffer, nbytes);

    m_evq.push(
        BTStreamerMessage(BTStreamerMessage::MSG_TYPE_MEDIA_BUFFER_READY, 
          xport, 
          AudioBuffer(copy, nbytes, samplenum))
        );
  }
}


*use-thread*
void BluetoothMediaStreamer::eventHandler(void)
{
  case BTStreamerMessage::MSG_TYPE_MEDIA_BUFFER_READY:
    if (sessionIsCurrent(session) && sessionIsActive(session)) 
      sendBufferFilled(m.audio_buffer);
}

void BluetoothMediaStreamer::sendBufferFilled(AudioBuffer &buf)
{
  if (buf.isValid()) {
    Message msg;
    msg.type = MESSAGE_TYPE_BUFFER_FILLED;
    msg.buffer = buf.buffer;
    msg.bufferLevel = buf.nbytes;
    msg.sampleNumber = buf.samplenum;
    sendMessage(msg);
  }
}


*send-message-back*
// actually a call
void BluetoothMediaStreamer::sendMessage(Message &m)
{
    Locker lock(&m_handler_lock);
    m_handler(m, m_handler_arg);
}


// Components/Bluetooth/reader/include/BluetoothStreamer.h

namespace BluetoothApi
{
  class Streamer;

  typedef enum _MessageType {} MessageType;
};

// registered to BluetoothMediaStreamer
// BluetoothMediaStreamer
// `m_btInstance->setMessageHandler(&s_bluetoothEventListener,this);`

// Components/AudioStreamer/source/BluetoothProtocol.cpp

void AudioStreamer::BluetoothProtocol::
  `bluetoothEventListener`(const BluetoothApi::Streamer::Message& message)


// Components/AudioStreamer/source/AudioBuffer.h

*use-pointers-and-no-copy*

`AudioBuffer                             m_audioBuffer;`

void AudioStreamer::BluetoothProtocol::`bluetoothEventListener`
  (const BluetoothApi::Streamer::Message& message)
{
  switch(message.type)
  {
    case BluetoothApi::Streamer::MESSAGE_TYPE_BUFFER_FILLED:
      {
        Guard lock(m_audBufferSync);

        //accept data
        size_t bufferLevelBytes = 
          m_audioBuffer.add(message.buffer, message.bufferLevel, message.sampleNumber);
      }
  }
}

class AudioBuffer
{
public:
    struct Packet
    {
        Packet(void *buffer, size_t bufferSize, size_t sampleNumber) 
          : start(buffer), startSample(sampleNumber), size(bufferSize), used(0) {}

        void *start;
        size_t startSample;
        size_t size;
        size_t used;
    };
public:
    AudioBuffer();
    ~AudioBuffer();
    
    // add and popFront returns the total buffersize in bytes held by the audio buffer after the operation
    size_t  add(void *buffer, size_t bufferSize, size_t sampleNumber);

private:
    list<Packet>    m_packets;
    volatile size_t m_bufferLevel;
};

size_t AudioStreamer::AudioBuffer::add(void *buffer, size_t bufferSize, size_t sampleNumber)
{
  AUD_LOG_ENTRY("AudioStreamer::AudioBuffer::add");
  Guard lock(m_mutex);
  AUD_LOG_INFO("Adding buffer %p size %u", buffer, bufferSize);
  m_bufferLevel += bufferSize;
  m_packets.push_back(Packet(buffer, bufferSize, sampleNumber));
  //It's only expected the first packet will have used up any data
  AUD_LOG_EXIT("AudioStreamer::AudioBuffer::add");
  return m_bufferLevel-m_packets.front().used;
}


*dbus-flows*
F:onPlayerAdded L:00258 > @ctx:dbusitf bluetooth_media.cpp(318) 
  KT: BluetoothMediaStreamer::onPlayerAdded: 
  path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/player0

F:findSessionByPlayer L:00258 > @ctx:dbusitf bluetooth_media.cpp(1195) 
  KT: BluetoothMediaStreamer::findSessionByPlayer: 
  player_path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/player0, xport_path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0

F:onPlayerPropertyChange L:00258 > @ctx:dbusitf bluetooth_media.cpp(337) 
  KT: BluetoothMediaStreamer::onPlayerChanged: 
  path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/player0, property Status

F:onPlayerPropertyChange L:00258 > @ctx:dbusitf bluetooth_media.cpp(337) 
  KT: BluetoothMediaStreamer::onPlayerChanged: 
  path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/player0, property Track

F:onPlayerPropertyChange L:00258 > @ctx:dbusitf bluetooth_media.cpp(337) 
  KT: BluetoothMediaStreamer::onPlayerChanged: 
  path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/player0, property Position

F:onTransportState L:00258 > @ctx:dbusitf bluetooth_media.cpp(302) 
  KT: BluetoothMediaStreamer::onTransportState: path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0, state pending

F:onTransportState L:00258 > @ctx:dbusitf bluetooth_media.cpp(302) 
  KT: BluetoothMediaStreamer::onTransportState: path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0, state active


F:decode L:00258 > @ctx:dbusitf bluetooth_media_reader.cpp(400) KT: onBufferReady(decoded_len 2560, samples 10240
F:readMediaFd L:00258 > @ctx:dbusitf bluetooth_media_reader.cpp(156) KT: decoded 608 bytes
F:findSessionByXport L:00258 > @ctx:dbusitf bluetooth_media.cpp(1174) KT: BluetoothMediaStreamer::findSessionByXport: found path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0, size 1
F:add L:00258 > @ctx:fallback AudioBuffer.cpp(52) Adding buffer 0x7a122788 size 2560

== NDS: ^0000000556.186505 !MIL   -AS           < p:00000dd6 t:724f2dc0 T:no name M:AS_DMS_Writer.cpp F:onTransportState L:00258 > @ctx:dbusitf bluetooth_media.cpp(302) KT: BluetoothMediaStreamer::onTransportState: path /org/bluez/hci0/dev_88_9F_6F_88_6A_7B/fd0, state idle


// timeout that comes from config
F:MwServices L:00258 > @ctx:AS_AUDIOSTREAMER_IMPL MwServices.cpp(203) 
  AudioStreamer Bluetooth device inactivity timeout is 300 sec


*dbus-proxies*

// Components/Bluetooth/dbusitf/include/bluetooth.h
// 
// The Bluetooth singleton class is the toplevel object for accessing the
// bluetooth stack. It provides a set of proxy classes mirroring objects held by
// Bluez's bluetoothd.

class Bluetooth
    : public IDBusTransportListener
    , public BluezParserListener
{
  public:
    static Bluetooth *getInstance();

    // returns a heap-allocated pointer with the same lifetime 
    // as the Bluetooth object itself
    BluetoothMediaTransport *getMediaTransports();
};

Bluetooth::Bluetooth()
    : m_bus_connection(NULL)
    , m_bus_transport(NULL)
{
  pthread_mutex_init(&m_bus_lock, NULL);
  pthread_mutex_init(&m_msghdlr_lock, NULL);

  // use system bus and "com.sky.as2bluez"

  if (connectToBus()) {

    // DBusTransport handles dbus bindings
    m_bus_transport = new DBusTransport(m_bus_connection, this);

    if (m_bus_transport) {

      // add a proxy to m_bluez_proxies and register interest to dbus
      
      // #define BLUEZ_ADAPTER_INTERFACE                     "org.bluez.Adapter1"
      if (!initProxy("BluetoothHCI", new BluetoothHCI(m_bus_transport)))

      // #define BLUEZ_DEVICE_INTERFACE                      "org.bluez.Device1"
      if (!initProxy("BluetoothDevice", new BluetoothDevice(m_bus_transport)))

      // #define BLUEZ_MEDIA_INTERFACE                       "org.bluez.Media1"
      if (!initProxy("MediaEndpoint", new BluetoothMediaEndpoint(m_bus_transport)))

      // #define `BLUEZ_MEDIATRANSPORT_INTERFACE`             "org.bluez.MediaTransport1"
      if (!initProxy("BluetoothMediaTransport",
            `new BluetoothMediaTransport`(m_bus_transport)))

      // #define BLUEZ_MEDIAPLAYER_INTERFACE                 "org.bluez.MediaPlayer1"
      if (!initProxy("BluetoothMediaPlayer", new BluetoothMediaPlayer(m_bus_transport)))

      // #define BLUEZ_AGENT_MANAGER_INTERFACE               "org.bluez.AgentManager1"
      if (!initProxy("BluetoothPairingAgent", new BluetoothPairingAgent(m_bus_transport)))

      if (!addBusMatch(BUS_MATCH_NAME_OWNER_CHANGED)) AS_LOG_ERROR("failed to add NameOwnerChanged bus match");
      if (!addBusMatch(BUS_MATCH_INTERFACES_ADDED)) AS_LOG_ERROR("failed to add InterfacesAdded bus match");
      if (!addBusMatch(BUS_MATCH_INTERFACES_REMOVED)) AS_LOG_ERROR("failed to add InterfacesRemoved bus match");

    } else AS_LOG_ERROR("failed to allocate dbus transport");
  } else AS_LOG_ERROR("failed to initialise dbus connection");
}

/**
 * @brief Obtain a pointer to the media transport proxy
 *
 * This method will always return a valid pointer with the same lifetime
   as the Bluetooth singleton.
 */
BluetoothMediaTransport *Bluetooth::getMediaTransports()
{
  if (lookupProxy(`BLUEZ_MEDIATRANSPORT_INTERFACE`, &proxy)) {
    return static_cast<BluetoothMediaTransport*>(proxy);
}


/**
 * @class BluetoothMediaTransport
 *
 * The BluetoothMediaTransport class is a proxy for bluez entities exposing
 * the org.bluez.MediaTransport1 interface.
 */

class BluetoothMediaTransport : public BluezProxy {
};


// Components/Bluetooth/dbusitf/include/bluez_proxy.h

class BluezProxy
{
  public:
    bool addListener(BluezProxyListener *listener);
};


<as-access>

// ethan-as-source/Components/AS/Services/Controllers/BTAudioController/include/AS_BTAUDIO_ControllerImplementation.h

ControllerImplementation(AS_WORKER::Environment *env, const char *deviceName = nullptr,
    uint32_t           maxPaired = 12 // Default max 12 paired, 0 = no limit
    )
{
  pthread_mutexattr_init   (&(m_dataLockAttr));
  pthread_mutexattr_settype(&(m_dataLockAttr),PTHREAD_MUTEX_RECURSIVE);

  pthread_mutex_init       (&(m_dataLock),&(m_dataLockAttr));

  // Create event queue
  m_queue        = env->CreateQueue();

  // TODO: There is no further use for the environment after queue is created. There is little point in storing the pointer in the object and delete later.
  // Hence delete the environment. Revisit for a better implementation later. Not deleting here will cause a leak on STB, there is no impact on utests and hence will not be caught using valgrind.
  delete env;

  `m_platformItf  = new AS_BTAUDIO::PlatformItf( deviceName );`

  `m_platformItf->BindController(this);`

  m_btaudioControllerThread = new AS_DMS::Thread( this, "AS_BTAUDIO_CTL" );
}

// Components/AS/Services/Controllers/BTAudioController/source/AS_BTAUDIO_PlatformItf.cpp

class AS_BTAUDIO::PlatformItfListener :
    public BluetoothPairingAgentListener ,
    public BluezProxyListener;

PlatformItf::PlatformItf(const char *platformDeviceName,
                         const char *bluezRoot,
                         bool active) : m_currentHci("")
{
  m_bluezPathRoot = bluezRoot;
  m_active        = active;
  m_platformDeviceName = platformDeviceName;

  `m_bluetooth = Bluetooth::getInstance();`
  m_pairingAgent = m_bluetooth->getPairingAgent();
  std::vector<std::string> hciNames = m_bluetooth->getHostInterfaces()->getObjectPaths();
}

m_bluetooth->getMediaEndpoints()->enableEndpoints();

// adapter
m_bluetooth->getHostInterfaces()->getAlias( m_currentHci, bluetoothIdStd ) );

m_bluetooth->getDevices()->getPaired(path, isPaired);

m_pairingAgent = m_bluetooth->getPairingAgent();
m_pairingAgent->setListener(m_listener);
m_pairingAgent->pairingResponse(addr, accepted);

// add listener to BTDevice
m_bluetooth->getDevices()->addListener(m_listener);


// device connect / disconnet comes from AS

void PlatformItf::onPropertyChange(const std::string &path, const DBusProperty &property)
{
  AS_LOG_ENTRY("%s() entry: path=%s property = %s",
      __func__,path.c_str(),property.getName().c_str());

  // Note code assumes a direct mapping between device path and device address
  if (m_controller && property.getName() == BLUEZ_DEVICE_PROP_CONNECTED)
  {
    AS::string bdaddr,asPath;
    bool    connected = property.getValue().asBool();

    asPath.assign(path.c_str());
    bdaddr = Util::PathToBdaddr(asPath);

    AS_LOG_INFO("Controller bound, passing on connection state %d",(int)connected);
    m_controller->ProcessConnectionState(bdaddr,connected);
  }

  AS_LOG_EXIT("%s() exit",__func__);
}

ethan-as-source/Components/AS/Services/Controllers/BTAudioController/source/AS_BTAUDIO_ControllerImplementation.cpp

void ControllerImplementation::ProcessConnectionState(AS::string bdaddr,
                                        bool       connected)
{
  AS_LOG_ENTRY("%s() bdaddr=%s,connected=%d",
      __func__,bdaddr.c_str(),(int)connected);

  ControllerMessage *msg = new ControllerMessage(ControllerMessage::ConnectionState);

  msg->m_bdaddr    = bdaddr;
  msg->m_connected = connected;

  // Send ptr, delete upon reception
  m_queue->SendPayload(&(msg),sizeof(msg));

  AS_LOG_EXIT("%s() exit",__func__);
}


={============================================================================
*kt_dev_skymw_0000* skymw-android

1. android studio
*refs*
https://developer.android.com/studio/install

2. adb, Android Debug Bridge

3. ninja-build, to build from android studio
Ninja is a small build system with a focus on speed. It differs from other
build systems in two major respects: it is designed to have its input files
generated by a higher-level build system, and it is designed to run builds as
fast as possible.

4. qt.


<skymw-android-doc>

https://developer.android.com/reference
https://developer.android.com/reference/android/app/Activity.html


={============================================================================
*kt_dev_skymw_0000* skymw-android-service

https://developer.android.com/guide/components/services.html

A Service is an application component that can perform long-running operations
in the background, and it doesn't provide a user interface. Another application
component can start a service, and it continues to run in the background even if
the user switches to another application. Additionally, a component can bind to
a service to interact with it and even perform interprocess communication (IPC).
For example, a service can handle network transactions, play music, perform file
I/O, or interact with a content provider, all from the background.

Bound

A service is bound when an application component binds to it by calling
bindService(). A bound service offers a client-server interface that allows
components to interact with the service, send requests, receive results, and
even do so across processes with interprocess communication (IPC). A bound
service runs only as long as another application component is bound to it.
Multiple components can bind to the service at once, but when all of them
unbind, the service is destroyed.


https://developer.android.com/guide/components/bound-services.html#Binder

Creating a bound service

When creating a service that provides binding, you must provide an IBinder that
provides the programming interface that clients can use to interact with the
service. There are three ways you can define the interface:

Using AIDL

Android Interface Definition Language (AIDL) decomposes objects into primitives
that the operating system can understand and marshals them across processes to
perform IPC. The previous technique, using a Messenger, is actually based on
AIDL as its underlying structure. As mentioned above, the Messenger creates a
queue of all the client requests in a single thread, so the service receives
requests one at a time. If, however, you want your service to handle multiple
requests simultaneously, then you can use AIDL directly. In this case, your
service must be thread-safe and capable of multi-threading.  To use AIDL
directly, you must create an .aidl file that defines the programming interface.
The Android SDK tools use this file to generate an abstract class that
implements the interface and handles IPC, which you can then extend within your
service.

Note: Most applications shouldn't use AIDL to create a bound service, because it
may require multithreading capabilities and can result in a more complicated
implementation. As such, AIDL is not suitable for most applications and this
document does not discuss how to use it for your service. If you're certain that
you need to use AIDL directly, see the AIDL document.


https://developer.android.com/guide/components/aidl#java

Defining an AIDL interface

You must define your AIDL interface in an .aidl file using the Java programming
language syntax, then save it in the source code (in the src/ directory) of both
the application hosting the service and any other application that binds to the
service.

When you build each application that contains the .aidl file, the Android SDK
tools generate an IBinder interface based on the .aidl file and save it in the
project's gen/ directory. The service must implement the IBinder interface as
appropriate. The client applications can then bind to the service and call
methods from the IBinder to perform IPC.

Implement the interface

The Android SDK tools generate an interface in the Java programming language,
based on your .aidl file. This interface has an inner abstract class named Stub
  that extends Binder and implements methods from your AIDL interface. You must
  extend the `Stub class and implement the methods`

Expose the interface to clients

Implement a Service and override onBind() to return your implementation of the
Stub class.

public class BleRcuService extends Service {

	public boolean registerService() {

		final String serviceName = "com.sky.blercuservice";

		Method method = null;
		try {
			method = Class.forName("android.os.ServiceManager").getMethod("addService", String.class, IBinder.class);

			method.invoke(null, serviceName, new BleRcuServiceBinder(this));
      }
   }

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {
  }
}

When you build your application, the Android SDK tools generate a .java
interface file named after your .aidl file. The generated interface includes a
subclass named Stub that is an abstract implementation of its parent interface
(for example, YourInterface.Stub) and declares all the methods from the .aidl
file.

Note: Stub also defines a few helper methods, most notably asInterface(), which
takes an IBinder (usually the one passed to a client's onServiceConnected()
    callback method) and returns an instance of the stub interface. See the
section Calling an IPC Method for more details on how to make this cast.

To implement the interface generated from the .aidl, extend the generated Binder
interface (for example, YourInterface.Stub) and implement the methods inherited
from the .aidl file.

Here is an example implementation of an interface called IRemoteService (defined
    by the IRemoteService.aidl example, above) using an anonymous instance:


<android-surface>
https://developer.android.com/reference/android/view/SurfaceView.html


={============================================================================
*kt_dev_skymw_0000* skymw-android-studio

https://developer.android.com/training/basics/firstapp/creating-project

{navigation}

Here are some tips to help you move around Android Studio.

Recent Files

Switch between your recently accessed files using the Recent Files action. Press
`Control+E` (Command+E on a Mac) to bring up the Recent Files action. By
default, the last accessed file is selected. You can also access any tool window
through the left column in this action.


File Structure

View the structure of the current file using the File Structure action. Bring up
the File Structure action by pressing `Control+F12` (Command+F12 on a Mac).
Using this action, you can quickly navigate to any part of your current file.

Find all the pieces of code referencing the class, method, field, parameter, or
statement at the current cursor position by pressing Alt+F7 (Option+F7 on a
Mac).


Find in path

`Control + Shift + F`

<global-search>
Global Search

you can search across your source code, databases, actions, elements of the user
interface, and so on, by `double-pressing the Shift`, or clicking the magnifying
glass in the upper right-hand corner of the Android Studio window.

// (can select from global search)
//
// Search for and navigate to a specific class in your project using the
// Navigate to Class action. Bring up the action by pressing Control+N
// (Command+O on a Mac).  Navigate to Class supports sophisticated expressions,
// including camel humps, paths, line navigate to, middle name matching, and
// many more. If you call it twice in a row, it shows you the results out of the
// project classes.
//
// Navigate to a file or folder using the Navigate to File action. Bring up the
// Navigate to File action by pressing Control+Shift+N (Command+Shift+O on a
// Mac).  To search for folders rather than files, add a / at the end of your
// expression.
// 
// Navigate to a method or field by name using the Navigate to Symbol action.
// Bring up the Navigate to Symbol action by pressing Control+Shift+Alt+N
// (Command+Option+O on a Mac).


<build>
By employing the flexibility of Gradle, you can achieve all of this without
modifying your app's core source files. Android Studio build files are named
build.gradle. They are plain text files that use Groovy syntax to configure
the build with elements provided by the Android plugin for Gradle. Each
project has one top-level build file for the entire project and separate
module-level build files for each module. When you import an existing project,
Android Studio automatically generates the necessary build files.

To learn more about the build system and how to configure, see Configure your
build.

<run>
/home/keitee/Downloads/android/android-studio/bin
./studio.sh &


={============================================================================
*kt_dev_skymw_0000* skymw-android-skybluez

<things-to-check-to-build>

1. set QT setting

app/CMakeLists.txt

# Sets the path to the Qt5 libraries and headers.
# You'll need to modify the QT5_SDK path below to point to your Qt5 SDK install

set( QT5_SDK "/home/keitee/Qt/5.12.3" )


<output>
keitee@keitee-mint:~/ip/SkyBluez$ find . -name *.apk | xargs ls -al
-rw-rw-r-- 1 keitee keitee 5844787 Sep 26 11:15 ./app/debug/SkyBluez-armeabi-v7a-debug.apk
-rw-rw-r-- 1 keitee keitee 4109972 Sep 26 11:20 ./app/release/SkyBluez-armeabi-v7a-release.apk


<signing>
keitee@keitee-mint:~/ip/SkyBluez$ find . -name *.keystore
./app/platform.keystore

android
platform
android


={============================================================================
*kt_dev_skymw_0000* skymw-android-bluetoothrcu skymw-ip100

<skymw-ip100>
*refs*
https://www.stb.bskyb.com/confluence/display/~grayb/Android+Bluez+Stack

<ip100-adb>
https://developer.android.com/studio/command-line/adb.html
https://www.stb.bskyb.com/confluence/display/~grayb/Android+Bluez+Stack

// run command from host

adb disable-verity
adb reboot

root	Restart adbd with root permissions.
adb root

adb remount
adb connect 192.168.0.104

You can verify that your device is connected by executing adb devices

$ adb devices
List of devices attached
192.168.0.104:5555      device


<comp-adb-logcat> <logging>

https://developer.android.com/studio/debug/am-logcat.html

keitee@keitee-mint:~/ip$ adb logcat --help
Usage: logcat [options] [filterspecs]
options include:
  -s              Set default filter to silent. Equivalent to filterspec '*:S'
  -f <file>, --file=<file>               Log to file. Default is stdout

   -e <expr>, --regex=<expr>
                  Only print lines where the log message matches <expr>
                  where <expr> is a regular expression
 
https://www.stb.bskyb.com/confluence/display/2016/Useful+code+snippets

// capture all
adb logcat | tee log.log

adb logcat --pid=2208 | tee log.log

06-14 09:36:56.292  2208  2226 I BleRcuQt: < M:blercuadapter.cpp F:onDeviceAdded L:1494 > added device D4:B8:FF:12:E1:A8 named "P215 SkyQ EC101" (connected: false paired: false)
06-14 09:53:21.869  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 18:46:44:xx:xx:xx is 'U104 SkyQ EC201'
06-14 09:53:21.869  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 70:91:F3:xx:xx:xx is 'U104 SkyQ EC102'
06-14 09:53:21.870  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for D4:B8:FF:xx:xx:xx is 'U104 SkyQ EC[12]01'
06-14 09:53:21.871  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for E8:0F:C8:xx:xx:xx is 'U104 SkyQ EC202'


<things-to-check-to-build>

1. set QT setting

app/CMakeLists.txt

# Sets the path to the Qt5 libraries and headers.
# You'll need to modify the QT5_SDK path below to point to your Qt5 SDK install

set( QT5_SDK "/home/keitee/Qt/5.12.3" )

// copy qt bins
drwxr-xr-x 11 keitee keitee     4096 Jun 10 16:52 android_bens_armv7


<skymw-bluez-release> signing *release-process*

/home/keitee/ip/repo/SkyBluetoothRcu/app/platform.keystore
pass for key:
android
platform
android

https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Android+-+HowTo+Release+Components

Hi all,

A new release of the SkyBluetoothRcu service - version 2.1.1 - has been tagged
and pushed to git master.

Gerrit merge requests have been created for sky/QIP100 branch.

Release notes attached, highlights are:
- Added feature to put the bluetooth code in 'searching' mode for 30 seconds. 


<bt-remote-pairing> *bluez-pairing*
https://docs.ubuntu.com/core/en/stacks/bluetooth/bluez/docs/reference/pairing/introduction

What is Pairing

In Bluetooth terminology pairing is the process of making two devices know about
each other. The key concept is about exchanging so called link-keys that are
used to secure the communication. The pairing process involves authentication
however due to the nature and variety of Bluetooth devices there will be
different ways of confirming the pairing attempt:

Devices such as keyboards or car-kits will require authentication by PIN/passkey
code

Other devices will provide a yes/no choice to the pairing attempt

Devices without an input interface such as headsets or speakers will not require
the user to confirm the pairing attempt at all

https://www.stb.bskyb.com/confluence/display/~grayb/BLERCU+%3A+State+Diagrams+for+EC10x+Bluetooth+RCUS
https://www.stb.bskyb.com/confluence/display/2016/Remote+Control+Architecture

The BT Manager component will act as a connector to the underlying Bluez stack,
and expose the interfaces in a specified API, for use with the main network
control and pairing system.

 5.3.3.2 Certificate Store

Pairing will generate CA certificate information, which must be placed in
persistent storage. An API to the wider system, or some knowledge of the final
persistent storage system is necessary to co-ordinate this.


<bluez-tool-bluetoothctl> *only-for-android* bluez-tool
https://www.stb.bskyb.com/confluence/display/2016/RCU%3A+Pairing+steps+by+steps

Pairing from Ubuntu Core
https://docs.ubuntu.com/core/en/stacks/bluetooth/bluez/docs/reference/pairing/outbound.html

(web)
SKY BLUEZ DEBUG CONSOLE
http://192.168.0.102:8180/index.html

(cli)
telnet 192.168.0.102 8123
telnet <stb-ip-address> 8123

   Select one of the following tools:
      1 - bluetoothctl
      2 - btmgmt
      3 - btmon
#>

#> 1
[NEW] Controller 38:A6:CE:7E:63:1A "sky-ip100" [default]
[NEW] Device D4:B8:FF:12:E1:A8 U122 SkyQ EC101
Agent registered

[bluetooth]# ?
Invalid command
[bluetooth]# help
Menu main:
Available commands:
-------------------
advertise                                         Advertise Options Submenu
scan                                              Scan Options Submenu
gatt                                              Generic Attribute Submenu
list                                              List available controllers
show [ctrl]                                       Controller information
select <ctrl>                                     Select default controller
devices                                           List available devices
paired-devices                                    List paired devices
system-alias <name>                               Set controller alias
reset-alias                                       Reset controller alias
power <on/off>                                    Set controller power
pairable <on/off>                                 Set controller pairable mode
discoverable <on/off>                             Set controller discoverable mode
agent <on/off/capability>                         Enable/disable agent with given capability
default-agent                                     Set agent as the default one
advertise <on/off/type>                           Enable/disable advertising with given type
set-alias <alias>                                 Set device alias
scan <on/off>                                     Scan for devices
info [dev]                                        Device information
pair [dev]                                        Pair with device
trust [dev]                                       Trust device
untrust [dev]                                     Untrust device
block [dev]                                       Block device
unblock [dev]                                     Unblock device
remove <dev>                                      Remove device
connect <dev>                                     Connect device
disconnect [dev]                                  Disconnect device
menu <name>                                       Select submenu
version                                           Display version
quit                                              Quit program
exit                                              Quit program
help                                              Display help about this program
[bluetooth]#

// check if "controller" is on and if not, run "power on"

[bluetooth]# show
Controller 38:A6:CE:7E:63:1A (public)
        Name: "sky-ip100"
        Alias: "sky-ip100"
        Class: 0x00000414
        Powered: yes
        Discoverable: no
        Pairable: no
        UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)
        UUID: A/V Remote Control        (0000110e-0000-1000-8000-00805f9b34fb)
        UUID: PnP Information           (00001200-0000-1000-8000-00805f9b34fb)
        UUID: A/V Remote Control Target (0000110c-0000-1000-8000-00805f9b34fb)
        UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)
        Modalias: usb:v1D6Bp0246d0530
        Discovering: no
[bluetooth]#


// check on "paired" and "connected"

[bluetooth]# info D4:B8:FF:12:E1:A8
Device D4:B8:FF:12:E1:A8 (public)
        Name: P199 SkyQ EC101
        Alias: P199 SkyQ EC101
        Appearance: 0x0180
        Paired: yes
        Trusted: no
        Blocked: no
        Connected: no
        LegacyPairing: no
        UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)
        UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)
        UUID: Immediate Alert           (00001802-0000-1000-8000-00805f9b34fb)
        UUID: Device Information        (0000180a-0000-1000-8000-00805f9b34fb)
        UUID: Battery Service           (0000180f-0000-1000-8000-00805f9b34fb)
        UUID: Human Interface Device    (00001812-0000-1000-8000-00805f9b34fb)
        UUID: Scan Parameters           (00001813-0000-1000-8000-00805f9b34fb)
        UUID: Vendor specific           (0000f800-bdf0-407c-aaff-d09967f31acd)
        UUID: Vendor specific           (0000f801-bdf0-407c-aaff-d09967f31acd)
        UUID: Vendor specific           (0000f802-bdf0-407c-aaff-d09967f31acd)
        Modalias: bluetooth:v057Ap0004d0100
[bluetooth]#

// remove

[bluetooth]# remove D4:B8:FF:12:E1:A8
[DEL] Primary Service
...
Device has been removed
[bluetooth]#


// *start-pairing*
[bluetooth]# scan on

// while scan is going
[bluetooth]# pair D4:B8:FF:12:E1:A8
Attempting to pair with D4:B8:FF:12:E1:A8

... press "1+3"

[CHG] Device D4:B8:FF:12:E1:A8 Connected: yes
[CHG] Device D4:B8:FF:12:E1:A8 Name: U032 SkyQ EC101
[CHG] Device D4:B8:FF:12:E1:A8 Alias: U032 SkyQ EC101
[U187 SkyQ EC101]#

// see the change on [name] and no need to scan off if paired?
// [bluetooth]# scan off
// [bluetooth]# info D4:B8:FF:12:E1:A8

*bluez-rcu*
[U162 SkyQ EC101]# devices
Device D4:B8:FF:12:E1:A8 P215 SkyQ EC101


<bluez-android-logging>

// the log levels we support
typedef enum {
  Fatal = 0x01,
  Error = 0x02,
  Warning = 0x04,
  Milestone = 0x08,
  Info = 0x10,
  Debug = 0x20
} LoggingLevel;

note: use bit flag but not <, >

// check this level should be logged
const LoggingLevels::Int allowedLevels = g_logLevels.load();
if (!(allowedLevels & level))
  return;

static int doMain()
{
#if (AI_BUILD_TYPE == AI_DEBUG)
  setupLogging(LoggingTarget::AndroidLog,
      LoggingLevel::Fatal    | LoggingLevel::Error |
      LoggingLevel::Warning  | LoggingLevel::Milestone);

  // TODO: remove
  setLogLevels(getLogLevels() | LoggingLevel::Info);
  // setLogLevels(getLogLevels() | LoggingLevel::Debug);

#elif (AI_BUILD_TYPE == AI_RELEASE)
  setupLogging(LoggingTarget::AndroidLog,
      LoggingLevel::Fatal | LoggingLevel::Error);

#else
#	error "Unknown AI_BUILD_TYPE, expected AI_DEBUG or AI_RELEASE"
#endif
}


<java-logging>
// SkyBluetoothRcu/app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {

  private static boolean DBG = true;

  if (DBG) Log.d(TAG, "created BleRcuService object with qtObject " + mQtObject);
}


<bluez-sky> *start-pairing*
1+3 key triggers two things:

o do advertisement from rcu
o do paring process from a box


// app/src/main/cpp/main.cpp

/*
Called from the java MainApplication class when it's created.  This is the
entry point that kicks of the Qt main loop thread.

 */
extern "C"
JNIEXPORT jboolean JNICALL 
Java_com_sky_skybluetoothrcu_MainApplication_startQApplication(JNIEnv *env, 
    jobject /* this */)
{
  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, "launching QApplication");

  pthread_t qtThread;

  int rc = pthread_create(&qtThread, nullptr, mainThread, nullptr);
}

static int doMain()
{
  QCoreApplication a(argc, argv);

  // log the start-up
  qMilestone("====================");
  qMilestone("KT:");
  qMilestone("====================");

  // first thing we do is start the Android AIDL service, it has no controller
  // so won't be useful, but means other clients can connect to it (the controller
  // is added later)
  QSharedPointer<BleRcuService> service =
    QSharedPointer<BleRcuService>::create();

  // create the config options, read from the config.json file
  QSharedPointer<const ConfigSettings> config = ConfigSettings::defaults();

  // create the factory for creating the BleRcu services for each device
  QSharedPointer<BleRcuServicesFactory> servicesFactory =
    QSharedPointer<BleRcuServicesFactory>::create(config);

  // store the backend type
  g_backend.store(Backend::Bluez);

  // attempt to connect to the android dbus-broker
  QDBusConnection dbusConn = connectToDBus();
  if (!dbusConn.isConnected()) {
    qError() << "failed to connect to dbus due to" << dbusConn.lastError();
  }

  *when-use-bluez*
  // and then create the adapter talking to bluez over dbus
  adapter = QSharedPointer<BleRcuAdapterBluez>::create(config,
      servicesFactory,
      dbusConn);

  // create the controller that manages the adapter and paired devices
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(config, adapter);

  // give the controller to the Android service, the service is now useful
  service->setController(controller);
}


<bluez-config>

daemon/resources/resources.default.qrc
3:      <file alias="defaultconfig.json">config.default.json</file>
keitee@keitee-mint:~/mw/appinfrastructure/AppInfrastructure/BluetoothRcu$

gvimdiff /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json
cdiff /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json
cp /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json
mv /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json /home/keitee/mw/appinfrastructure/AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json.kt
cdiff /home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json /home/keitee/ip/repo/SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json
meld /home/keitee/ip/SkyBluetoothRcu/app/src/ /home/keitee/ip/repo/SkyBluetoothRcu/app/src/

// right config file used?
// SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json

	"models": [
		{
			"name": "ECx01",
			"manufacturer": "Omni",
			"oui": "D4:B8:FF",
			"pairingNameFormat": "U%03hhu SkyQ EC[12]01",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC[12]01",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC201",
			"manufacturer": "Omni",
			"oui": "18:46:44",
			"pairingNameFormat": "U%03hhu SkyQ EC201",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC201",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC102",
			"manufacturer": "UEI",
			"oui": "70:91:F3",
			"pairingNameFormat": "U%03hhu SkyQ EC102",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC102",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC202",
			"manufacturer": "UEI",
			"oui": "E8:0F:C8",
			"pairingNameFormat": "U%03hhu SkyQ EC202",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC202",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC05x",
			"manufacturer": "Ruwido",
			"disabled": true,
			"oui": "1C:A2:B1",
			"pairingNameFormat": "U%03hhuruwido Sky Remote",
			"scanNameFormat": "U[0-9][0-9][0-9]ruwido Sky Remote",
			"filterByte": 27,
			"connectionParams": {
				"maxInterval": 15.0,
				"minInterval": 15.0,
				"latency": 332,
				"supervisionTimeout": 15000
			},
			"services": {
				"type": "rci",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"touch"
				]
			}
		}

	]
	"models": [
		{
			"name": "ECx01",
			"manufacturer": "Omni",
			"oui": "D4:B8:FF",
			"pairingNameFormat": "U%03hhu SkyQ EC[12]01",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC[12]01",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC201",
			"manufacturer": "Omni",
			"oui": "18:46:44",
			"pairingNameFormat": "U%03hhu SkyQ EC201",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC201",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC102",
			"manufacturer": "UEI",
			"oui": "70:91:F3",
			"pairingNameFormat": "U%03hhu SkyQ EC102",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC102",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC202",
			"manufacturer": "UEI",
			"oui": "E8:0F:C8",
			"pairingNameFormat": "U%03hhu SkyQ EC202",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC202",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC05x",
			"manufacturer": "Ruwido",
			"disabled": true,
			"oui": "1C:A2:B1",
			"pairingNameFormat": "U%03hhuruwido Sky Remote",
			"scanNameFormat": "U[0-9][0-9][0-9]ruwido Sky Remote",
			"filterByte": 27,
			"connectionParams": {
				"maxInterval": 15.0,
				"minInterval": 15.0,
				"latency": 332,
				"supervisionTimeout": 15000
			},
			"services": {
				"type": "rci",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"touch"
				]
			}
		}
	]


// app/src/main/cpp/utils/linuxinputdevice.cpp

signals:
	void keyPress(quint16 keyCode, qint32 scanCode);
	void keyRelease(quint16 keyCode, qint32 scanCode);

void LinuxInputDevice::processEvents(const struct input_event *events, size_t nevents)
{
  switch (event->type) {
    case EV_SYN:
      m_scanCode = 0;
      break;
    case EV_KEY:
      if (event->value)
        `emit keyPress(event->code, m_scanCode);`
      else
        emit keyRelease(event->code, m_scanCode);
      m_scanCode = 0;
      break;
    case EV_MSC:
      if (event->code == MSC_SCAN)
        m_scanCode = event->value;
      break;

    default:
      break;
  }
}


// note that "service/android"
// app/src/main/cpp/service/android/blercuservice.cpp
// app/src/main/cpp/service/android/blercuservice.h

class BleRcuService : public QObject
                    , public QEnableSharedFromThis<BleRcuService>
{
  const QSharedPointer<InputDeviceManager> m_inputDeviceManager;

  QSharedPointer<BleRcuController> m_controller;

  *call-from-c-to-java*
  QSharedPointer<QAndroidJniObject> m_javaBleRcuService;

  QSharedPointer<LinuxInputDevice> m_irInputDevice;

  QMap<BleAddress, int> m_deviceIdMap;
}

{
  // create the SkyBluetoothLE java object
  m_javaBleRcuService = QSharedPointer<QAndroidJniObject>::create(
      "com/sky/blercu/BleRcuService",
      "(J)V");
}

BleRcuService::BleRcuService(QObject *parent)
	: QObject(parent)
	, m_inputDeviceManager(InputDeviceManager::create())
  {
    QObject::connect(m_irInputDevice.data(), `&LinuxInputDevice::keyPress`,
        this, &BleRcuService::onIrKeyPress);
  }

*pairing-code*
void BleRcuService::onIrKeyPress(quint16 keyCode, qint32 scanCode)
{
  // check for the pairing keyCode F13 which is the new format
  if (keyCode == KEY_F13) {

    // 03th byte
    const quint8 filterByte = quint8((scanCode >> 16) & 0xff);

    // 01st byte
    const quint8 pairingCode = quint8((scanCode >> 0) & 0xff);

    // kick off pairing using supplied pairing code
    `m_controller->startPairing`(filterByte, pairingCode);
  }
}


// app/src/main/cpp/blercu/blercucontroller.cpp
*start-pairing-android*
bool BleRcuControllerImpl::startPairing(quint8 filterByte, quint8 pairingCode)
{
  // start the pairing process
  m_pairingStateMachine.start(filterByte, pairingCode);
}


// app/src/main/cpp/blercu/blercupairingstatemachine.cpp

class BleRcuControllerImpl : public BleRcuController
{
	const QSharedPointer<BleRcuAdapter> m_adapter;

	BleRcuPairingStateMachine m_pairingStateMachine;
	BleRcuScannerStateMachine m_scannerStateMachine;
}

//   QObject::connect(m_adapter.data(), &BleRcuAdapter::deviceNameChanged,
//     this, &BleRcuPairingStateMachine::onDeviceNameChanged);
// 
// void BleRcuPairingStateMachine::onDeviceNameChanged(const BleAddress &address,
//                                                     const QString &name)
// {
//   qDebug() << "device name changed" << address << name
//     << "(target" << m_targetAddress << ")";
// 
//   `processDevice`(address, name);
// }
// 
// /*!
// 	\internal
// 
// 	Called when entering the 'discovering' state.  At this point we query the
// 	manager for `the current list of devices and their names`  We use this to
// 	determine if any existing devices match the pairing prefix.
// 
//  */
// void BleRcuPairingStateMachine::onEnteredDiscoveringState()
// {
//    *start-pairing-get-devices-from-adapter*
// 	// get the current list of devices
// 	const QMap<BleAddress, QString> deviceNames = m_adapter->deviceNames();
// 
// 	// process each existing device
// 	QMap<BleAddress, QString>::const_iterator it = deviceNames.begin();
// 	for (; it != deviceNames.end(); ++it)
// 		`processDevice`(it.key(), it.value());
// }
//
// 
// // -----------------------------------------------------------------------------
// /*!
// 	\internal
// 
// 	Called when the an outside object has called either deviceAdded() or
// 	deviceNameChanged(), it then checks if the \a name matches our expected
// 	pairing prefix.  If it does then we check if we already have a pairing
// 	target, if not we use this new device.
// 
//  */
// void BleRcuPairingStateMachine::processDevice(const BleAddress &address,
//                                               const QString &name)
// {
//    *pairing-code-match-devices-from-rcu-to-scanned-devices*
//    QMap<quint32, QRegExp>::const_iterator it = 
//      m_pairingPrefixes.find(address.oui());
// }
// 
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:781 > 
//  found target device D4:B8:FF:12:E1:A8


// *pairing-code-regex*
//
// m_pairingPrefixFormats is built from *config* when fsm starts and is used to
// check if current devices does match up with expected pattern in
// `processDevice()` which gets called when device found and added
//
// "pairingNameFormat": "U%03hhu SkyQ EC202",
//
// BleRcuPairingStateMachine::BleRcuPairingStateMachine(const QSharedPointer<const ConfigSettings> &config)
// {
//   // constructs a map of name printf style formats for searching for device
//   // names that match
//   const QList<ConfigModelSettings> models = config->modelSettings();
//   for (const ConfigModelSettings &model : models) {
//     `m_pairingPrefixFormats`[model.oui()] = model.pairingNameFormat();
//   }
// }
//

!MIL   -APPINFRA     < M:InputQueue.cpp F:sendKey L:00110 > KT: InputQueue::sendKey(filterByte(20), keyCode(61022), down(1)
!MIL   -APPINFRA     < M:InputQueue.cpp F:listenerThread L:00288 > KT: InputQueue::listner.handler(event{source(2), keyCode(61022), down(1)}
!MIL   -AS           < M:AS_DMS_Writer.cpp F:KeyControllerMainListener L:00258 > @ctx:AS_KEYEVENT AS_KEYEVENT_KeyEventControllerImplementation.cpp(223) KT: KeyControllerMainListener acquired deviceType: 2, keyCode: 0xee5e, keyState: 1
!MIL   -APPINFRA     < M:BleRcuController.cpp F:isIrPairingCode L:00801 > KT: isIrPairingCode filterByte(0x14), keyCode(0xee5e)
!MIL   -APPINFRA     < M:InputQueue.cpp F:listenerThread L:00288 > KT: InputQueue::listner.handler(event{source(2), keyCode(61022), down(1)}
!MIL   -APPINFRA     < M:BleRcuController.cpp F:onIrPairingCode L:00850 > KT: received IR pairing code 094
!INFO  -BLERCU       < M:blercupairingstatemachine.cpp F:start L:00209 > pairing regex for 18:46:44:xx:xx:xx is 'U094 SkyQ EC201'
!INFO  -BLERCU       < M:blercupairingstatemachine.cpp F:start L:00209 > pairing regex for 1C:A2:B1:xx:xx:xx is 'U094ruwido Sky Remote'
!INFO  -BLERCU       < M:blercupairingstatemachine.cpp F:start L:00209 > pairing regex for 70:91:F3:xx:xx:xx is 'U094 SkyQ EC102'
!INFO  -BLERCU       < M:blercupairingstatemachine.cpp F:start L:00209 > pairing regex for D4:B8:FF:xx:xx:xx is 'U094 SkyQ EC[12]01'
!INFO  -BLERCU       < M:blercupairingstatemachine.cpp F:start L:00209 > pairing regex for E8:0F:C8:xx:xx:xx is 'U094 SkyQ EC202'

// "130" is *paring-code*
// 
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 18:46:44:xx:xx:xx is 'U130 SkyQ EC201'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 70:91:F3:xx:xx:xx is 'U130 SkyQ EC102'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for D4:B8:FF:xx:xx:xx is 'U130 SkyQ EC[12]01'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for E8:0F:C8:xx:xx:xx is 'U130 SkyQ EC202'
// I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
//
// I BleRcuQt: < M:blercudevice.cpp F:onEnteredResolvingServicesState L:547 > D4:B8:FF:12:E1:A8 entered RESOLVING_SERVICES state
// I BleRcuQt: < M:blercudevice.cpp F:onDeviceNameChanged L:352 > D4:B8:FF:12:E1:A8 device name changed from "P138 SkyQ EC101" to "U130 SkyQ EC101"
// I BleRcuQt: < M:blercuadapter.cpp F:onDeviceNameChanged L:1692 > renamed device D4:B8:FF:12:E1:A8 to "U130 SkyQ EC101"
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:773 > found target device D4:B8:FF:12:E1:A8 but it's currently paired, will unpair and wait till it shows up in a scan again
//

void BleRcuPairingStateMachine::start(quint8 filterByte, quint8 pairingCode)
{
  // FIXME: use the filterByte to narrow the search to a certain RCU model
  Q_UNUSED(filterByte);

  // create a map of OUI (first 3 bytes of mac address) to a regex to match to
  // the name of the device
  m_pairingPrefixes.clear();
  QMap<quint32, QByteArray>::const_iterator it = m_pairingPrefixFormats.begin();
  for (; it != m_pairingPrefixFormats.end(); ++it) {

    // construct the wildcard match
    QRegExp regEx(QString::asprintf(it.value().constData(), `pairingCode`));

    regEx.setPatternSyntax(QRegExp::WildcardUnix);

    qInfo("pairing regex for %02hhX:%02hhX:%02hhX:xx:xx:xx is '%s'",
        quint8(it.key() >> 16), quint8(it.key() >> 8), quint8(it.key() >> 0),
        regEx.pattern().toLatin1().constData());

    // add to the map to use for compare when a device is found
    `m_pairingPrefixes`.insert(it.key(), std::move(regEx));
  }

  // start the state machine
  m_stateMachine.start();
}

bool StateMachine::start()
{
  m_currentState = m_initialState;
  m_running = true;

  logTransition(-1, m_currentState);

  emit entered(m_currentState);
  return true;
}

void BleRcuPairingStateMachine::setupStateMachine()
{
  // connect to the state entry and exit signals
  QObject::connect(&m_stateMachine, &StateMachine::`entered`,
      this, &BleRcuPairingStateMachine::`onStateEntry`);

  QObject::connect(&m_stateMachine, &StateMachine::`exited`,
      this, &BleRcuPairingStateMachine::`onStateExit`);
}

void BleRcuPairingStateMachine::onStateEntry(int state)
{
  switch (state) {

    case StartingDiscoveryState:
      onEnteredStartDiscoveryState()
      {
        // *emit-started*
        // tell anyone who cares that pairing has started
        `emit started();`
      }

      break;

    case FinishedState:
      onEnteredFinishedState()
      {
        // finally just emit a finished signal to the BleRcuManagerImpl object
        `emit finished();`
      }
      break;
  }
}

void BleRcuPairingStateMachine::onStateExit(int state)
{
  switch (state) {}
}


< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
< M:blercupairingstatemachine.cpp F:onStateEntry L:306 > KT: state: 2
< M:blercupairingstatemachine.cpp F:onEnteredStartDiscoveryState L:379 > KT: BleRcuPairingStateMachine::onEnteredStartDiscoveryState


*start-pairing-device-pair*

void BleRcuPairingStateMachine::onEnteredPairingState()
{
  // note:
  // m_targetAddress comes when device is found in processDevice()
  //
  // request the manager to pair with the device
  m_manager->pairDevice(m_targetAddress);
}

bool BleRcuManagerImpl::pairDevice(const BleAddress &address)
{
	qInfo() << "requesting bluez pair" << device->address();
	device->pair(0);
	return true;
}

void BleRcuDeviceImpl::pair(int timeout)
{
  QDBusPendingReply<> reply = `m_deviceProxy->Pair();`
  QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(reply, this);

  QObject::connect(watcher, &QDBusPendingCallWatcher::finished,
      this, &BleRcuDeviceImpl::onPairRequestReply);

  // set the flag, it may be cleared if the call fails
  m_isPairing = true;
}

void BleRcuDeviceImpl::onPairRequestReply(QDBusPendingCallWatcher *call)
{
	QDBusPendingReply<> reply = *call;

	if (Q_UNLIKELY(reply.isError())) {

		m_isPairing = false;

		// an error occurred so log it, however from bluez 5.47 the bluez daemon
		// doesn't seem to send a reply on success, so ignore that error
		QDBusError error = reply.error();
		if (error.type() != QDBusError::NoReply)
			qError() << m_address << "pairing request failed with error" << error;

		// emit pairingError(m_address, error.message());

	} else {

		qDebug() << m_address << "pairing request successful";

		// TODO: start the timer to cancel the pairing after a certain amount of time

	}
	// free the pending reply object
	call->deleteLater();
}


// from adaptor signal

< M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter started discovering
bool BleRcuControllerImpl::startScanning(int timeoutMs)
{
	// check we're not currently pairing
	if (m_pairingStateMachine.isRunning()) {
		qWarning("currently performing pairing, cannot start new scan");
		return false;
	}

	// check we're not already scanning
	if (m_scannerStateMachine.isRunning()) {
		qWarning("already scanning, new scan request aborted");
		return false;
	}

	// check that the manager has powered on the adapter, without this we
	// obviously can't scan. The only time the adaptor should (legitimately) be
	// unavailable is right at start-up
	if (!m_adapter->isAvailable() || !m_adapter->isPowered()) {
		m_lastError = BleRcuError(BleRcuError::General,
		                          QStringLiteral("Adaptor not available or not powered"));
		return false;
	}

	// start the pairing process
	emit stateChanged(PairingState::Searching);
	m_scannerStateMachine.start(timeoutMs);
	return true;
}
< M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:422 > KT: postEvent(DiscoveryStartedEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1001)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (3)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state StartingDiscoveryState(2) to DiscoveringState(3)"

< M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8
< M:blercupairingstatemachine.cpp F:processDevice L:799 > KT: postEvent(DeviceFoundEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1009)
< M:statemachine.cpp F:shouldMoveState L:310 > KT: really happen?? state (1)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (5)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state DiscoveringState(3) to StoppingDiscoveryState(5)"

< M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter stopped discovering
< M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:427 > KT: postEvent(DiscoveryStoppedEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1002)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (6)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state StoppingDiscoveryState(5) to EnablePairableState(6)"


//
// app/src/main/cpp/blercu/bluez/interfaces/bluezadapterinterface.h

#include <QtDBus>

class BluezAdapterInterface : public DBusAbstractInterface
{
  // ??
  Q_PROPERTY(bool Discovering READ discovering NOTIFY `discoveringChanged`)
    inline bool discovering() const
    { return qvariant_cast< bool >(property("Discovering")); }

signals:
  void aliasChanged(const QString& newAlias);
  void deviceClassChanged(quint32 deviceClass);
  void discoverableChanged(bool discoverable);
  void discoverableTimeoutChanged(uint newDiscoverableTimeout);
  void `discoveringChanged`(bool discovering);
  ...
};

// dbus -> adapter
// app/src/main/cpp/blercu/blercuadapter.h

class BleRcuAdapter : public QObject
{
signals:
  void poweredChanged(bool powered, QPrivateSignal);

  void `discoveryChanged`(bool discovering, QPrivateSignal);
  void pairableChanged(bool pairable, QPrivateSignal);

  void deviceFound(const BleAddress &address, const QString &name, QPrivateSignal);
  void deviceRemoved(const BleAddress &address, QPrivateSignal);

  void deviceNameChanged(const BleAddress &address, const QString &name, QPrivateSignal);
  void devicePairingChanged(const BleAddress &address, bool paired, QPrivateSignal);
  void deviceReadyChanged(const BleAddress &address, bool ready, QPrivateSignal);
};

// app/src/main/cpp/blercu/bluez/blercuadapter_p.h

class BleRcuAdapterBluez : public BleRcuAdapter
{
  private slots:
    void onAdapterDiscoveringChanged(bool discovering);
};

// app/src/main/cpp/blercu/bluez/blercuadapter.cpp

bool BleRcuAdapterBluez::attachAdapter(const QDBusObjectPath &adapterPath)
{
  // install handlers for the interesting adapter notifications
  QObject::connect(m_adapterProxy.data(), &BluezAdapterInterface::`discoveringChanged`,
      this, &BleRcuAdapterBluez::`onAdapterDiscoveringChanged`);
}

void BleRcuAdapterBluez::`onAdapterDiscoveringChanged`(bool discovering)
{
  emit `discoveryChanged`(m_discovering, BleRcuAdapter::privateSignal());
}

// adapter -> state machine
// app/src/main/cpp/blercu/blercupairingstatemachine.cpp

class BleRcuPairingStateMachine : public QObject {}

BleRcuPairingStateMachine::BleRcuPairingStateMachine()
{
  QObject::connect(m_adapter.data(), `&BleRcuAdapter::discoveryChanged`,
      this, &BleRcuPairingStateMachine::`onDiscoveryChanged`);
}

void BleRcuPairingStateMachine::`onDiscoveryChanged`(bool discovering)
{
  if (discovering)
    m_stateMachine.postEvent(DiscoveryStartedEvent);
  else
    m_stateMachine.postEvent(DiscoveryStoppedEvent);
}

app/src/main/java/com/sky/bluetooth/SkyBroadcastReceiver.java
124:            filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
1


/home/keitee/ip/SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
/home/keitee/ip/SkyBluetoothRcu/app/src/main/java/com/sky/blercu/BleRcuService.java
/home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/blercu/blercuadapter.h
/home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/blercu/android/blercuadapter_p.h


<bluez-sky-aidl>
https://developer.android.com/guide/components/aidl#java

Defining an AIDL interface

You must define your AIDL interface in an .aidl file using the Java programming
language syntax, then save it in the source code (in the src/ directory) of 
`both the application` hosting the service and any other application that binds
to the service.

When you build each application that contains the .aidl file, the Android SDK
tools `generate` an IBinder interface based on the .aidl file and save it in the
project's gen/ directory. The service must implement the IBinder interface as
appropriate. The client applications can then bind to the service and call
methods from the IBinder to perform IPC.

Implement the interface

The Android SDK tools generate an interface in the Java programming language,
based on your .aidl file. This interface has an inner abstract class named Stub
that extends Binder and implements methods from your AIDL interface.  You must
extend the Stub class and implement the methods.


as api to support

/peripherals/btremotes/status
/peripherals/btremotes/action/startsearching


as/iWedia_AS_service/QtRESTService/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl

// are the same files

keitee@keitee-mint:~/ip$ find . -name IBleRcuService.aidl
./SkyBluetoothRcu/example/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./SkyBluetoothRcu/tests/IrDatabaseTest/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./iwedia/as/iWedia_AS_service/QtRESTService/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl


// app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl

interface IBleRcuService {
	void registerClient(in ParcelUuid appId, in IBleRcuServiceCallback callback);
	void unregisterClient(in int clientIf);

	boolean isPairing();

	String[] getDevices();

	++++ boolean isDevicePaired(in String address);
	++++ boolean isDeviceConnected(in String address);
	++++ int getDeviceId(in String address);
	++++ int getDeviceBatteryLevel(in String address);
	++++ String getDeviceName(in String address);
	++++ String getDeviceMake(in String address);
	++++ String getDeviceModel(in String address);
	++++ String getDeviceSerialNumber(in String address);
	++++ String getDeviceHardwareVersion(in String address);
	++++ String getDeviceSoftwareVersion(in String address);
	++++ String getDeviceBootloaderVersion(in String address);
	++ boolean setDeviceFindMe(in String address, in boolean enable);

	++ boolean setDeviceTouchMode(in String address, in int mode);
	++ int getDeviceTouchMode(in String address);

	++ boolean programDeviceIrCode(in String address, in int type, in int code);
	++ boolean eraseDeviceIrCodes(in String address);

	++ ParcelFileDescriptor startDeviceVoiceRecording(in String address);
	++ VoiceRecordingStats getDeviceVoiceRecordingStats(in String address);

	String[] getManufacturers(in String search, in int flags, in int offset, in int limit);
	String[] getModels(in String manufacturer, in String search, in int flags, in int offset, in int limit);
	int[] getCodes(in String manufacturer, in String model, in int flags);
	int[] getCodesFromEDID(in byte[] edid);

	++ boolean startDeviceUpgrade(in String address, in byte[] firmware);
	++ void cancelDeviceUpgrade(in String address);
}


*from-java-to-bluez-c*

Expose the interface to clients

Implement a Service and override onBind() to return your implementation of the
Stub class.

// app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {

  private static class BleRcuServiceBinder extends IBleRcuService.Stub {
    // ...

    @Override
      public String getDeviceMake(String address) {
        if (!checkAddress(address))
          return null;

        BleRcuService service = getService();

        if (service == null) return null;

        // use of JNI ifs
        return `service.jniGetDeviceMake`(service.mQtObject, address);
      }

  } // IBleRcuService

  // JNI ifs
  private native String jniGetDeviceMake(long qtObject, String address);
  // ...

} // end of service


// app/src/main/cpp/service/android/blercuservice.cpp

bool `BleRcuService::registerNatives`()
{
  JNI_ENTRY(`jniGetDeviceMake`,               "(JLjava/lang/String;)Ljava/lang/String;"),
  JNI_ENTRY(jniGetDeviceModel,              "(JLjava/lang/String;)Ljava/lang/String;"),
  ...
}

jstring BleRcuService::jniGetDeviceMake(JNIEnv *env, jobject, jlong qtObject,
                                        jstring address)
{
  return jniGetDeviceInfo(env, qtObject, address, DeviceMake);
}

// -----------------------------------------------------------------------------
/*!
	Returns the given info string for the device with \a address.

	Called from the java / android BleRcuService object in response to a remote
	client request.

 */
jstring BleRcuService::jniGetDeviceInfo(JNIEnv *env, jlong qtObject, jstring address,
                                        DeviceInfoType type)
{
  // convert the address string
  const BleAddress bdaddr(env, address);
  if (Q_UNLIKELY(bdaddr.isNull()))
    return env->NewStringUTF("");

  // get a pointer back to ourselves (set in the constructor when the Java
  // class is created)
  QSharedPointer<BleRcuService> self = fromJniQtObject(qtObject);
  if (Q_UNLIKELY(!self))
    return env->NewStringUTF("");

  QString result;
  self->invokeInMainThread(`&BleRcuService::getDeviceInfoString`, self, bdaddr, type, &result);
  return env->NewString(reinterpret_cast<const jchar*>(result.constData()),
      static_cast<jsize>(result.size()));
}

void BleRcuService::`getDeviceInfoString`(const BleAddress &address,
                                        DeviceInfoType type, QString *value) const
{
}


void BleRcuService::onPairingStateChanged(bool pairing)
{
  *call-from-c-to-java*
  m_javaBleRcuService->callMethod<void>("onPairingStateChanged",
      "(Z)V",
      static_cast<jboolean>(pairing ? JNI_TRUE : JNI_FALSE));
}


<bluez-android-state-change>
After implemented new way of pairing and status report:

// from AS spec
INITIALISING: starting up, no paired remotes
IDLE: no activity
SEARCHING: device is searching for RCUs
PAIRING: device is pairing to an RCU
COMPLETE: device successfully paired to an RCU
FAILED: device failed to find or pair to an RCU

app/src/main/cpp/blercu/blercucontroller.cpp
338:    emit stateChanged(PairingState::Searching);
519:    emit stateChanged(PairingState::Pairing);
541:    emit stateChanged(PairingState::Complete);
562:    emit stateChanged(PairingState::Failed);
574:    emit stateChanged(PairingState::Idle);

	// connect to the manager's initialised signal
	QObject::connect(adapter.data(), &BleRcuAdapter::poweredInitialised,
	                 this, &BleRcuControllerImpl::onInitialised,
	                 Qt::QueuedConnection);

void BleRcuControllerImpl::onInitialised()
{
	// tell clients that the pairing state is changed
	emit stateChanged(PairingState::Idle);
}

662:    emit stateChanged(PairingState::Failed);

app/src/main/cpp/blercu/blercucontroller.h
71:     void stateChanged(int status);

app/src/main/cpp/service/android/blercuservice.h
62:     void onStateChanged(int status);

app/src/main/cpp/service/android/blercuservice.cpp
339:    QObject::connect(controller.data(), &BleRcuController::stateChanged,
340:                     this, &BleRcuService::onStateChanged);
413:void BleRcuService::onStateChanged(int status)
420:    m_javaBleRcuService->callMethod<void>("onStateChanged",
544:            m_javaBleRcuService->callMethod<void>("onDeviceConnectionStateChanged",

app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl
12:     void onDeviceConnectionStateChanged(in String address, in boolean connected);
21:     void onStateChanged(in int status);

app/src/main/java/com/sky/blercu/BleRcuService.java
406:    public void onStateChanged(final int status) {
420:                                            mCallbacks.getBroadcastItem(i).onStateChanged(status);

app/src/main/java/com/sky/bluetooth/SkyBroadcastReceiver.java
177:                                    onStateChanged(intent);
237:    private void onStateChanged(final Intent intent) {


<bluez-http-server-start-scanning> *bluez-web-scan* *start-scanning*
Bluetooth RCU Pairing(scan)

https://www.stb.bskyb.com/confluence/display/~grayb/Bluetooth+RCU+Pairing+Without+Infrared
http://192.168.0.100:8280/index.html

app/src/main/cpp/debug/www/index.html

app/src/main/cpp/debug/www/main.dart.js
1796:i5:function(){W.eS("http://"+H.e($.b9)+":"+$.bY+"/bs/peripherals/btremotes/action/scanstart?timeoutms=30000","POST").aa(new F.e1(),null)},
3652:P.eA("post scanstart request finished")},

// SkyBluetoothRcu/app/src/main/cpp/debug/httpserver.cpp

HttpServer::HttpServer(const QSharedPointer<BleRcuController> &controller,
      QObject *parent)
 : QObject(parent)
 , m_httpHandler(new HttpHandler(controller, this))
 , m_wsHandler(new WsHandler(controller, m_httpHandler))
 , m_server(new QHttpServer(m_httpHandler, this))
{}

// app/src/main/cpp/debug/3rdparty/qhttpengine/src/qhttpserver.cpp

  d->process(socket);

// app/src/main/cpp/debug/httphandler.cpp

void HttpHandler::process(QHttpSocket *socket, const QString &path)
{}

void HttpHandler::handlePostRequest(QHttpSocket *socket, const QString &path)
{
  // ask the controller to start the scan
  m_controller->startScanning(timeoutMs);
}


see *bluez-config* for m_deviceNameMatchers

*start-pairing-start-scanning*
bool BleRcuControllerImpl::startScanning(int timeoutMs)
{
  // start the pairing process
  m_scannerStateMachine.start(timeoutMs);
  return true;
}


// app/src/main/cpp/blercu/blercuscannerstatemachine.cpp

void BleRcuScannerStateMachine::`onEnteredFinishedState`()
{
  // if we found a device then tell any clients
  if (!m_foundDevice.address.isNull()) {
    `emit foundPairableDevice(m_foundDevice.address, m_foundDevice.name);`
    m_foundDevice.clear();
  }

  // and we're done
  emit finished();
}

// BleRcuControllerImpl::BleRcuControllerImpl()
//
// // connect to the scanner signals
// QObject::connect(&m_scannerStateMachine,
//                  &BleRcuScannerStateMachine::started,
//                  this,
//                  &BleRcuControllerImpl::onStartedScanning,
//                  Qt::QueuedConnection);
// QObject::connect(&m_scannerStateMachine,
//                  &BleRcuScannerStateMachine::finished,
//                  this,
//                  &BleRcuControllerImpl::onFinishedScanning,
//                  Qt::QueuedConnection);
//
// void
// BleRcuControllerImpl::onStartedScanning()
// {
// 	emit scanningStateChanged(true);
// }
// 
// void
// BleRcuControllerImpl::onFinishedScanning()
// {
// 	emit scanningStateChanged(false);
// }
//
// WsHandler::WsHandler(const QSharedPointer<BleRcuController>& controller,
//                      QObject* parent)
//   : QHttpHandler(parent)
//   , m_controller(controller)
// {
// 	// connect to changes in the controller scanning or pairing status
// 	QObject::connect(controller.data(),
// 	                 &BleRcuController::scanningStateChanged,
// 	                 this,
// 	                 &WsHandler::onBleScanningStateChanged,
// 	                 Qt::QueuedConnection);
// }


BleRcuControllerImpl::BleRcuControllerImpl()
{
  // connect to the signal emitted when the scanner found an RCU device in
  // pairing mode
  QObject::connect(&m_scannerStateMachine, 
      `&BleRcuScannerStateMachine::foundPairableDevice`,
      this, &BleRcuControllerImpl::onFoundPairableDevice,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onFoundPairableDevice(const BleAddress &address,
                                                 const QString &name)
{
  qInfo() << "found" << address << "RCU device in pairing mode,"
    << "kicking off the pairing state machine";

  // sanity check (needed?)
  if (m_pairingStateMachine.isRunning()) {
    qWarning("found target device in scan but pairing state machine "
        "already running?");
    return;
  }

*start-pairing-android-from-scan*
  // start pairing the device
  m_pairingStateMachine.start(address, name);

}

// note: this is different start() from pairing mode
// void BleRcuPairingStateMachine::start(const BleAddress &target, const QString &name)
// add "single entry"

void BleRcuPairingStateMachine::start(const BleAddress &target, const QString &name)
{
  m_pairingPrefixes.insert(target.oui(),
      QRegExp(name, Qt::CaseInsensitive, QRegExp::FixedString));
}

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[ScannerStateMachine] moving from state StoppingDiscoveryState(3) 
  to FinishedState(4)"
W BleRcuQt: < M:statemachine.cpp F:moveToState L:206 > new states:  (4)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:207 > old states:  (3, 0)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:214 > KT: fire exit only for old state which is not in new states from child to parent state (3)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:214 > KT: fire exit only for old state which is not in new states from child to parent state (0)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:227 > KT: fire enter only for new state which is not in old states from parent to child state (4)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:248 > KT: cleanup events?
W BleRcuQt: < M:statemachine.cpp F:moveToState L:253 > KT: emit finished?

I BleRcuQt: < M:blercucontroller.cpp F:onFoundPairableDevice L:617 
  > found D4:B8:FF:12:E1:A8 RCU device in pairing mode, kicking off the pairing state machine

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onStateEntry L:306 > KT: state: 2
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onEnteredStartDiscoveryState L:379 > KT: BleRcuPairingStateMachine::onEnteredStartDiscoveryState
I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:280 > started pairing targeting D4:B8:FF:12:E1:A8
I BleRcuQt: < M:? F:? L:0 > started bluetooth RCU pairing procedure
I BleRcuQt: < M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter started discovering
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:422 > KT: postEvent(DiscoveryStartedEvent)

	bool startPairing(quint8 pairingCode) override;


<bluez-android-client-example>
/home/keitee/ip/BleRcuExample

// copy-aidl
cp SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
cp SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl

// app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/blercu/IBleRcuService.java

@Override public boolean isDevicePaired(java.lang.String address) throws android.os.RemoteException
{
  android.os.Parcel _data = android.os.Parcel.obtain();
  android.os.Parcel _reply = android.os.Parcel.obtain();
  boolean _result;
  try {
    _data.writeInterfaceToken(DESCRIPTOR);
    _data.writeString(address);
    mRemote.transact(Stub.TRANSACTION_isDevicePaired, _data, _reply, 0);
    _reply.readException();
    _result = (0!=_reply.readInt());
  }
  finally {
    _reply.recycle();
    _data.recycle();
  }
  return _result;
}


// BleRcuExample/app/src/main/java/com/sky/blercuexample/MainActivity.java

public class MainActivity extends Activity {

  protected void onCreate(Bundle savedInstanceState) {

    // get the blercu service
    mManager = new BleRcuManager(mBleRcuCallback);

    // get the sidebar that displays the device details
    mSideBar = new SideBar(this,
        mManager,
        (TextView)findViewById(R.id.sidebar_heading),
        (ListView)findViewById(R.id.sidebar_list), mLogView);

    *pass-device*
    if (!devices.isEmpty())
      mSideBar.setDeviceDetails(devices.iterator().next());
  }

  private final BleRcuManagerCallback mBleRcuCallback = new BleRcuManagerCallback() {

    @Override
      public void onPairingChanged(BleRcuManager manager, final boolean isPairing) {
        runOnUiThread(new Runnable() {
            public void run() {
            mLogView.i("KT: MainActivity.java, pairing state changed to " + isPairing);
            }
            });
      }
  }

  /**
   * Callbacks from the BleRcu service.
   */
  private final BleRcuManagerCallback mBleRcuCallback = new BleRcuManagerCallback() {

    @Override
      public void onPairingChanged(BleRcuManager manager, final boolean isPairing) {
        runOnUiThread(new Runnable() {
            public void run() {
            mLogView.i("KT: MainActivity.java, pairing state changed to " + isPairing);
            }
            });
      }
  }
} 


// to provice client access to service via IBinder if
// BleRcuExample/app/src/main/java/com/sky/blercu/BleRcuManager.java

public final class BleRcuManager {

  private static synchronized IBleRcuService getService() {
    if(binder != null) {
      sService = IBleRcuService.Stub.asInterface(binder);
    }
  }
}

// BleRcuExample/app/src/main/java/com/sky/blercuexample/SideBar.java

    private void onClicked(int position) {

        if ((mCurrentAddress == null) || mCurrentAddress.isEmpty())
            return;

        if (position == TRIGGER_FINDME_LIST_IDX) {
            if (mFindMeListener != null)
                mFindMeListener.onTriggered(mCurrentAddress);
        }
        if (position == UPGRADE_FIRMWARE_LIST_IDX) {
            if (mFwUpgradeListener != null)
                mFwUpgradeListener.onTriggered(mCurrentAddress);
        }
        if (position == SCANNING_RCU_LIST_IDX) {
            try {
                mLogView.e("KT: startScanning(30000)..");
                mLogView.e("KT: startScanning(30000)..");
                mLogView.e("KT: startScanning(30000)..");
                mDevice.startScanning(30000);
            } catch (RemoteException e) {
                Log.e(TAG, "", e);
            }
        }
        if (position == GET_STATE_LIST_IDX) {
            try {
                *use-device*
                mLogView.e("KT: getState() retuns " + mDevice.getState());
                mLogView.e("KT: getState() retuns " + mDevice.getState());
                mLogView.e("KT: getState() retuns " + mDevice.getState());
            } catch (RemoteException e) {
                Log.e(TAG, "", e);
            }
        }
    }


// /BleRcuExample/app/src/main/java/com/sky/blercu/BleRcuDevice.java

    *use-device*
    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();

        try {
            // isDeviceConnected
            final boolean connected = isConnected();

            // getDeviceId, getDeviceName
            description.append("BleRcu Device ").append(getDeviceId()).append(": ").append(getName()).append("\n");

            description.append("  bdaddr: ").append(getAddress()).append("\n");
            description.append("  connected: ").append(connected);
            if (connected) {
                description.append("\n");
                description.append("  name: ").append(getName()).append("\n");
                description.append("  deviceid: ").append(getDeviceId()).append("\n");

                // getDeviceMake, 
                description.append("  make: ").append(getMake()).append("\n");

                // getDeviceModel
                description.append("  model: ").append(getModel()).append("\n");

                // getDeviceHardwareVersion
                description.append("  hwrev: ").append(getHardwareVersion()).append("\n");

                // getDeviceSerialNumber
                description.append("  serialno: ").append(getSerialNumber()).append("\n");

                // getDeviceSoftwareVersion
                description.append("  rcuswver: ").append(getSoftwareVersion()).append("\n");

                // getDeviceBootloaderVersion
                description.append("  btlswver: ").append(getBootloaderVersion()).append("\n");

                // getDeviceBatteryLevel
                description.append("  batterylevel: ").append(getBatteryLevel());
            }

        } catch (RemoteException e) {
            description.append("Error: ...");
        }
  }


={============================================================================
*kt_dev_skymw_0000* skymw-android-ip150

<ip150>
https://www.stb.bskyb.com/confluence/display/2016/IP150+Releases

<ip100> <ip150>
https://www.stb.bskyb.com/confluence/pages/viewpage.action?pageId=54062914
Programming IP100/IP150 via adb

Note: The box and the laptop must be on the same network before you can try to
program with this image from the laptop.
 
adb connect 192.168.1.10:5555 
adb root 
adb connect 192.168.1.10:5555
 
# Push the OTA package
adb push IP150-ota.zip /cache/update.zip
 
#(If it already exists you might see the following- mkdir: '/cache/recovery/':
File exists. Everything is fine and you can proceed to the next step)

adb shell 'mkdir /cache/recovery/'
adb shell 'echo "--update_package=/cache/update.zip" > /cache/recovery/command'
 
# Reboot in recovery mode
adb reboot recovery


<ip100-check-version>
IP100:/ $ getprop | grep version
[ro.build.sky.drivers.version]: [M4.2.10]
[ro.build.version.all_codenames]: [REL]
[ro.build.version.base_os]: []
[ro.build.version.baseline]: [Q08]
[ro.build.version.codename]: [REL]
[ro.build.version.incremental]: [QIPQ00.000.39.00D]


<comp-drivers>
IP150:/vendor/lib/modules # pwd
/vendor/lib/modules


={============================================================================
*kt_dev_skymw_0000* skymw-luna

https://www.stb.bskyb.com/confluence/display/~grayb/Android+Luna+-+Runtime+Service

<git-repo-skymw-luna>
git clone ssh://kyoupark@mgt-ip100-gerrit.skyqstbbuild.com:29418/sky/platform/packages/apps/SkyLunaRuntime
git clone ssh://kyoupark@mgt-ip100-gerrit.skyqstbbuild.com:29418/sky/platform/packages/apps/SkyLunaRuntime SkyLunaRuntime-100

<signing>
android
testkey
android

<upgrade-apk>

https://www.stb.bskyb.com/confluence/display/~grayb/Updating+SkyLunaRuntime+Package

IP150:/system/app # readlink -f SkyLunaRuntime/
/system/app/SkyLunaRuntime


Step 1 - Disable Verity

adb root
adb connect 192.168.0.104
adb disable-verity

If verity is not already disabled you'll need then be prompted to reboot you box
for the change to take effect ... do that.

keitee@keitee-mint:~/Downloads$ adb disable-verity
Verity disabled on /vendor
Verity disabled on /system
Now reboot your device for settings to take effect

adb reboot

adb root
adb connect 192.168.0.104
adb remount
adb shell rm -rf /system/app/SkyLunaRuntime
adb reboot

cd ~/ip/repo/SkyLunaRuntime/apk
adb install SkyLunaRuntime.apk
adb: failed to install SkyLunaRuntime.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.sky.lunaruntime signatures do not match the previously installed version; ignoring!]

adb install -r -t SkyLunaRuntime.apk

app installation:
 install [-lrtsdg] PACKAGE
 install-multiple [-lrtsdpg] PACKAGE...
     push package(s) to the device and install them
     -l: forward lock application
     -r: replace existing application
     -t: allow test packages
     -s: install application on sdcard
     -d: allow version code downgrade (debuggable packages only)
     -p: partial application install (install-multiple only)
     -g: grant all runtime permissions
 
adb: failed to install SkyLunaRuntime.apk: Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.sky.lunaruntime signatures do not match the previously installed version; ignoring!]

keitee@keitee-mint:~/ip/repo/SkyLunaRuntime/apk$ adb uninstall com.sky.lunaruntime
Success
keitee@keitee-mint:~/ip/repo/SkyLunaRuntime/apk$ adb install SkyLunaRuntime.apk
Success


<android-instant-run>
https://developer.android.com/studio/run#instant-run
https://stackoverflow.com/questions/42672157/how-to-stop-installation-of-multiple-slice-apk-in-android-studio-2-3

Vevo app : http://static.de.skyq.sky.com/softcat-published-content/QIPQ00DE/com.bskyb.vevo/12712444/1.7.5/package.wgt
unzip that
adb install app.apk
Success

adb shell am start -n com.bskyb.vevo/com.bskyb.vevo.MainActivity


<output-so>
~/ip/repo/SkyLunaRuntime$ ls -al app/src/main/libs/armeabi-v7a/libluna.so
-rwxr-xr-x 1 keitee keitee 20257680 Jul 15 14:31 app/src/main/libs/armeabi-v7a/libluna.so


// example/app/src/main/java/com/sky/lunaexample/MainActivity.java

public class MainActivity extends Activity {

  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // create the runtime object
    mLuna = new Runtime(this, mCallback);
  }
}


<clientlib>
clientlib/src/main/aidl/com/sky/luna/ILunaRuntime.aidl

interface ILunaRuntime
{
  /**
   * Check/download required libs to run the application
   *
   * param callback  - interface used by Minsitro service to notify the client when the loader is ready
   * param parameters
   *            parameters fields:
   *                 * Key Name                   Key type         Explanations
   *                   "sources"                  StringArray      Sources list from where Ministro will download the libs. Make sure you are using ONLY secure locations.
   *                   "repository"               String           Overwrites the default Ministro repository. Possible values: default, stable, testing and unstable
   *                   "required.modules"         StringArray      Required modules by your application
   *                   "application.title"        String           Application name, used to show more informations to user
   *                   "qt.provider"              String           Qt libs provider, currently only "necessitas" is supported.
   *                   "minimum.ministro.api"     Integer          Minimum Ministro API level, used to check if Ministro service compatible with your application. Current API Level is 3 !
   *                   "minimum.qt.version"       Integer          Minimim Qt version (e.g. 0x040800, which means Qt 4.8.0, check http://qt-project.org/doc/qt-4.8/qtglobal.html#QT_VERSION)!
   */
  void requestLoader(in ILunaRuntimeCallback callback, in Bundle parameters);
}


clientlib/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/luna/ILunaRuntime.java


// SkyLunaRuntime/clientlib/src/main/java/com/sky/luna/Runtime.java

public class Runtime {

    /**
     * Async callback object that receives the service updates.
     * <p>
     * The com.sky.lunaruntime service works by requesting the loader providing a
     * callback.  That callback is called with details on the service and triggers
     * the start of the actual runtime.  At the same time we disconnect from the
     * remote service because we no longer need it, all the require details were
     * supplied in the callback.
     *
     */
    private ServiceConnection mRuntimeConnection = new ServiceConnection() {

        private ILunaRuntime mService = null;

        @Override
        public void onServiceConnected(ComponentName name, IBinder service)
        {
            mService = ILunaRuntime.Stub.asInterface(service);
            try {
                if (mService != null) {
                    Bundle parameters = new Bundle();

                    // TODO: add any parameters to the engine request

                    mService.requestLoader(mServiceCallback, parameters);
                }
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            mService = null;
        }

        private ILunaRuntimeCallback mServiceCallback = new ILunaRuntimeCallback.Stub() {

            // this function is called back by LunaRuntime service.
            @Override
            public void loaderReady(final Bundle loaderParams) throws RemoteException {
                mActivity.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mActivity.unbindService(mRuntimeConnection);
                        launchLuna(loaderParams);
                    }
                });
            }
        };

    };
}


<runtime>

app/src/main/aidl/com/sky/luna/ILunaRuntime.aidl

app/src/main/java/com/sky/lunaruntime/LunaRuntimeService.java

public class LunaRuntimeService extends Service {

    public void onCreate() {

        mRuntimeInterface = new ILunaRuntime.Stub() {

            @Override
            public void requestLoader(ILunaRuntimeCallback callback, Bundle params) throws RemoteException {
            }
    }
}


<so>

// Main Activity of the application, we need to implement SufraceHolder callback
// from which we obtain the actual SufraceView

public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback {

  @Override
    public void surfaceCreated(SurfaceHolder surfaceHolder) { //Callback which is called when surface is created
      A4TVStatus status;
      mLog.d("SurfaceHolder.Callback surfaceCreated");
      if (IDTVManager != null) {
        if (mSurfaceHolder != null) {
          Surface surface = mSurfaceHolder.getSurface(); //The actual surface object that we want to pass to the AS Service
          try {
            //The following line sets the actual surface to the AS service
            status = IDTVManager.getDisplayControl().setVideoLayerSurface(DISP_PRIMARY_VIDEO_LAYER, new SurfaceBundle(surface));
            if (status != ASStatus.SUCCESS) {
              mLog.e("Error on passing surface to AS service");
            }
            mLog.d("setVideoLayerSurface[" + surface + "]");
          } catch (RemoteException re) {
            re.printStackTrace();
          }
        }
      }
    }
}


// app/src/main/java/com/sky/lunaruntime/Runtime.java

public class Runtime extends BroadcastReceiver implements IRuntime {

  /**
   * Attempts to launch the luna runtime executing the contents of the supplied asset.
   * <p>
   * The asset must be a zip file containing all the 'stuff' for running the app in Luna.
   * It will be extracted to the data area of the app and then luna will be launched
   * from that.
   *
   * @param activity the activity to display and run luna in.
   * @param params the parameters to use for launching the luna runtime.
   *
   * @return true if successful otherwise false.
   */
  @Override
    public boolean launch(Activity activity, Bundle params) {

      // load the native luna library(s) .so
      loadNativeLibraries(params);

      // /app/libs/com.iwedia.comedia.service.comm-release.jar!/com/iwedia/dtv/IDTVManager.class
      //
      // connect to the DTV service early, even before extracting the app
      
      `mDtvManager = new IWediaDTVManager(activity);`
      mDtvManager.connect();

      // latest version already installed, go and run it
      return launchLuna(AppInstaller.installedDirectory(activity), params);

    }

  /**
   * This creates all the surfaces and sets the content view for the activity.
   * All the work to actually kick off Luna is done in the surface creation
   * callbacks, so this is just the view setup code.
   *
   * @param appInstallDir the directory that the app was expanded to.
   * @param params the parameters that were passed to the app to launch.
   *
   * @return true on success or false on failure.
   */
  private boolean launchLuna(final File appInstallDir, final Bundle params) {

    mRenderer = new Renderer(appInstallDir.getAbsolutePath(), mActivity);

    // Create the VideoSurface
    mVideoSurface = `new VideoSurface`(mActivity, `mDtvManager`);

    // Attach the video surface to Luna so it can adjust it
    `mRenderer.addVideoWindow(0, mVideoSurface);`

    // Setup and attach the video surface
    relativeLayout.addView(mVideoSurface, 0,
          new ViewGroup.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT));

    // Create the subtitle surface and add to the layout
    mSubtitleSurface = new SubtitleSurface(mActivity, mDtvManager);

    // Setup and attach the subtitle surface

    /*
    https://developer.android.com/reference/android/view/SurfaceView
    setZOrderMediaOverlay
    Added in API level 5
    public void setZOrderMediaOverlay (boolean isMediaOverlay)
    Control whether the surface view's surface is placed on top of another regular surface view in the window (but still behind the window itself). This is typically used to place overlays on top of an underlying media surface view.
    
    Note that this must be set before the surface view's containing window is attached to the window manager.
    mSubtitleSurface.setZOrderMediaOverlay(true);

    https://developer.android.com/reference/android/view/View#layout
    and is a top-down traversal of the view tree. 
     */

    relativeLayout.addView(mSubtitleSurface, 1,
        new RelativeLayout.LayoutParams(
          ViewGroup.LayoutParams.MATCH_PARENT,
          ViewGroup.LayoutParams.MATCH_PARENT));
  }
}


app/src/main/java/com/sky/lunaruntime/VideoSurface.java

class `VideoSurface` extends `IWediaDTVSurface` implements `Native.ILunaVideoSurface` {

  public VideoSurface(Activity activity, IWediaDTVManager dtvManager) {
    super(activity, dtvManager, IWediaDTVManager.`DISP_LAYER_PRIMARY_VIDEO_ID`);

    mActivity = activity;
    mDtvManager = dtvManager;

    // get the current screen dims for clamping the video window to the
    // on screen region
    // get the screen display size
    DisplayMetrics displayMetrics = new DisplayMetrics();
    activity.getWindowManager().getDefaultDisplay().getMetrics(displayMetrics);

    // hardcode subtitles surface size based on display metrics
    mScreenWidth = displayMetrics.widthPixels;
    mScreenHeight = displayMetrics.heightPixels;
  }
}

app/src/main/java/com/sky/lunaruntime/IWediaDTVSurface.java

class IWediaDTVSurface extends `SurfaceView` {

  IWediaDTVSurface(Context context, IWediaDTVManager dtvManager, `int layerId`) {
    super(context);

    `getHolder().addCallback(mCallback);`
  }

  private SurfaceHolder.Callback mCallback = `new SurfaceHolder.Callback`() {

    @Override
      public void `surfaceCreated`(SurfaceHolder surfaceHolder) {
        if (DBG) Log.d(TAG, "Surface for layer " + mLayerId + " created");

        // get the underlying surface
        `Surface` surface = surfaceHolder.getSurface();
        if (surface == null) {
          Log.e(TAG, "Failed to get the underlying surface");
          return;
        }

        // and attach to the DTV manager
        `mDtvManager.attachSurface`(`mLayerId`, surface);
      }
  }
}

Android/Sdk/platforms/android-27/android.jar!/android/view/SurfaceView.class
import android.view.SurfaceView;


class IWediaDTVManager {

  /**
   * The possible layer ids to assign a surface to.
   */
  public static final int DISP_LAYER_PRIMARY_VIDEO_ID = 0;
  public static final int DISP_LAYER_GFX_ID_0 = 16;

  public void `attachSurface`(int layerId, Surface surface) {

    // add the surface to our internal map
    mSurfaceMapping.put(layerId, surface);

    // if we have a DTV manager (ie. the service is connected) then add the binding
    if (mDtvManager != null) {
      `bindSurface`(layerId, surface);
    }
  }

  /**
   * Binds the supplied surface to the DTV layer in the service.
   * <p>
   * The lock must be held before calling this method.
   *
   * @param id the id of the layer to bind the surface to.
   * @param surface the surface to be bound.
   * @return true on success, false on failure.
   */
  private boolean bindSurface(int id, Surface surface) {

    // sanity check the lock is held before this call
    if (DBG && !mDtvManagerLock.isLocked())
      Log.e(TAG, "The mDtvManagerLock must be held before calling this method");

    // sanity check we have a DTV manager
    if (mDtvManager == null) {
      Log.e(TAG, "Invalid DtvManager");
      return false;
    }

    // SkyLunaRuntime/app/libs/com.iwedia.comedia.service.comm-release.jar!/com/iwedia/dtv/display/SurfaceBundle.class

    try {
     
      // *plumbing-to-as-iwedia*
      // SkyLunaRuntime/app/libs/com.iwedia.comedia.service.comm-release.jar!/com/iwedia/dtv/display/IDisplayControl.class

      A4TVStatus status = mDtvManager.getDisplayControl()
        .`setVideoLayerSurface`(id, `new SurfaceBundle(surface)`);
      if (status == A4TVStatus.SUCCESS) {
        Log.i(TAG, "Surface for layer " + id + " bound to DTV display controller");
      } else {
        Log.e(TAG, "Error on passing surface to AS service (" + status.getValue() + ")");
        return false;
      }

    } catch (RemoteException e) {
      Log.e(TAG, "Remote exception occurred talking to AS", e);
      return false;
    }

    return true;
  }
}

app/src/main/java/com/sky/lunaruntime/Renderer.java

public class Renderer implements ModdedGLSurfaceView.Renderer {

  @Override
    public void onSurfaceCreated(GL10 gl, EGLConfig config, int width, int height) {

      if (mInited.compareAndSet(false, true)) {

        // get the context, this should never fail, if it does it means the Activity has finished ?
        Context context = mContext.get();
        if (context == null)
          Log.wtf(TAG, "failed to get main android context");

        // initialise the luna engine (even if context is null)
        `com.sky.lunaruntime.Native.initLuna`(context,
            getClass().getClassLoader(),
            width, height,
            mMetrics.xdpi, mMetrics.ydpi);

        // *pass-video-window*
        // register video window(s)
        // public static native void 
        // registerVideoWindow(int id, ILunaVideoSurface videoSurface);

        for(int i = 0; i < mVideoWindows.size(); i++) {
          `com.sky.lunaruntime.Native.registerVideoWindow`(
              `mVideoWindows`.keyAt(i), mVideoWindows.get(i));
        }

        // finally start Luna
        com.sky.lunaruntime.Native.startLuna(mPath, mCallback);
        return;
      }

      Native.surfaceRestored();
    }
}


// app/src/main/java/com/sky/lunaruntime/VideoSurface.java

    /**
     * Called by the luna runtime code when we want to adjust the video window parameters.
     *
     * @param flags 
     * Flags that control the visibility, z-ordering and subtitles for the video
     * surface.
     *
     * @param sourceRect 
     * The cropping rectangle that controls the portion of the video to
     * display on the surface.
     *
     * @param destinationRect 
     * The position on the display to put the video surface.
     *
     * note: (see) only use destination
     */
    @Override
    public void setWindowProperties(int flags, 
        RectF sourceRect, 
        Rect destinationRect) {

      if (DBG) {
        if ((flags & Native.ILunaVideoSurface.VISIBLE) == 0)
          Log.d(TAG, "Luna app requested video to hidden");
        else
          Log.d(TAG, "Luna app requested video size to " + destinationRect);
      }

      if (destinationRect.right > mScreenWidth)
        destinationRect.right = mScreenWidth;
      if (destinationRect.left < 0)
        destinationRect.left = 0;

      if (destinationRect.bottom > mScreenHeight)
        destinationRect.bottom = mScreenHeight;
      if (destinationRect.top < 0)
        destinationRect.top = 0;

      final int x = destinationRect.left;
      final int y = destinationRect.top;
      final int width = destinationRect.width();
      final int height = destinationRect.height();
      final boolean visible = ((flags & Native.ILunaVideoSurface.VISIBLE) != 0);

      mActivity.runOnUiThread(new Runnable() {
          @Override
          public void run() {

          if (!visible) {

          if (DBG)
          Log.d(TAG, "Hiding video window");

          setVisibility(View.INVISIBLE);
          mDtvManager.blankVideo(true);

          } else {

          if (DBG)
          Log.d(TAG, "Setting video window dims to " +
              x + "x" + y + " " + width + "x" + height);

          final RelativeLayout.LayoutParams params =
          new RelativeLayout.LayoutParams(width, height);

          params.setMargins(x, y,
              mScreenWidth - x - width,
              mScreenHeight - y - height);
          setLayoutParams(params);

          setVisibility(View.VISIBLE);
          mDtvManager.blankVideo(false);
          }
          }
      });
    }


={============================================================================
*kt_dev_skymw_0000* skymw-rdk

<skymw-rdk-wiki>
https://wiki.rdkcentral.com/display/RDK/Overview

https://www.stb.bskyb.com/confluence/display/~grayb/RDK+-+Building+BleRcuDaemon
Checkout Code

git clone dwngit@git.stb.bskyb.com:appinfrastructure appinfrastructure-ai
git checkout feature/NOJIRA_rdk_appinfra

git clone dwngit@git.stb.bskyb.com:appinfrastructure appinfrastructure-rcu
git checkout feature/NOJIRA_rdk_ble_rcu_daemon

The top level CMake file is in the 

appinfrastructure/RDK/BluetoothRcu 


// toolchain?
https://www.stb.bskyb.com/confluence/display/~grayb/RDK+-+Setting+up+new+Xi6+Units


// sdk root where sdk is installed

`keitee@keitee-mint:~/rdk/2.0`$ 
drwxr-xr-x 4 keitee keitee 4.0K Aug 28 00:01 sysroots/
drwxr-xr-x 5 keitee keitee 4.0K Sep 20 11:07 ../
-rw-r--r-- 1 keitee keitee 3.4K Sep 20 11:07 environment-setup-cortexa15t2hf-neon-rdk-linux-gnueabi
-rw-r--r-- 1 keitee keitee  118 Sep 20 11:07 version-cortexa15t2hf-neon-rdk-linux-gnueabi
-rw-r--r-- 1 keitee keitee  54K Sep 20 11:07 site-config-cortexa15t2hf-neon-rdk-linux-gnueabi


<rdk-cmake>
keitee@keitee-mint:~/rdk/appinfrastructure/RDK/BluetoothRcu/cmake$ more toolchain.cmake
# this one is important
SET(CMAKE_SYSTEM_NAME Linux)
#this one not so much
SET(CMAKE_SYSTEM_VERSION 1)

set(RDK_SDK /home/keitee/rdk/2.0)

set( RDK_TOOLCHAIN_BASE ${RDK_SDK}/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-gnueabi )
set( RDK_TOOLCHAIN_PREFIX ${RDK_TOOLCHAIN_BASE}/arm-rdk-linux-gnueabi- )

# compiler flags as set by the RDK SDK
set( RDK_DEFAULT_CFLAGS "-march=armv7-a -mfloat-abi=hard -mfpu=neon-vfpv4 -mtune=cortex-a7 -fno-omit-frame-pointer -fno-optimize-sibling-calls -ggdb --sysroot=${RDK_SDK}/sysroots/cortexa15t2hf-neon-rdk-linux-gnueabi" )


# specify the cross compiler
SET(CMAKE_C_COMPILER   ${RDK_TOOLCHAIN_PREFIX}gcc )
SET(CMAKE_CXX_COMPILER ${RDK_TOOLCHAIN_PREFIX}g++ )

# the following is needed as the OSX toolchain uses the "/lib/ld-linux.so.3"
# linker path, whereas in the RDK rootfs they haven't added the symlink so
# instead we force it to be the original file
# (nb if you run 'file' on the built binary you can see the difference)
set( CMAKE_EXE_LINKER_FLAGS "-Wl,--dynamic-linker,/lib/ld-2.24.so" )

set( CMAKE_C_FLAGS "${RDK_DEFAULT_CFLAGS}" CACHE STRING "" FORCE )
set( CMAKE_CXX_FLAGS "${RDK_DEFAULT_CFLAGS}" CACHE STRING "" FORCE )

# where is the target environment
#SET( CMAKE_FIND_ROOT_PATH "${RDK_TOOLCHAIN_BASE}" )
SET( CMAKE_FIND_ROOT_PATH "${RDK_SDK}/sysroots/cortexa15t2hf-neon-rdk-linux-gnueabi/" )
SET( CMAKE_SYSROOT "${RDK_SDK}/sysroots/cortexa15t2hf-neon-rdk-linux-gnueabi/" )


# search for programs in the build host directories
SET( CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER )

# for libraries and headers in the target directories
set( CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY )
set( CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY )

# set the path to the Qt SDK
set( QT5_SDK, ${RDK_SDK}/sysroots/cortexa15t2hf-neon-rdk-linux-gnueabi/usr )
set( QT5_ABI_SDK "${QT5_SDK}" )
# set( OE_QMAKE_PATH_EXTERNAL_HOST_BINS "/Volumes/Katalix/RDK/firebolt/Qt-build/rdk_armv7/bin" )
set( OE_QMAKE_PATH_EXTERNAL_HOST_BINS "/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin" )


// set env

Assuming that the SDK is installed in sdk_root directory, issue the following command
source  <sdk_root>/environment-setup-<chipset>-rdk-linux-gnueabi

...
export SDKTARGETSYSROOT=/home/keitee/rdk/2.0/sysroots/cortexa15t2hf-neon-rdk-linux-gnueabi

export PATH=
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/sbin:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/bin:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/sbin:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/../x86_64-rdksdk-linux/bin:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-gnueabi:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-uclibc:
  /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-musl:$PATH

export CCACHE_PATH=/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin:/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/../x86_64-rdksdk-linux/bin:/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-gnueabi:/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-uclibc:/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-musl:$CCACHE_PATH
export PKG_CONFIG_SYSROOT_DIR=$SDKTARGETSYSROOT
export PKG_CONFIG_PATH=$SDKTARGETSYSROOT/usr/lib/pkgconfig:$SDKTARGETSYSROOT/usr/share/pkgconfig
export CONFIG_SITE=/home/keitee/rdk/2.0/site-config-cortexa15t2hf-neon-rdk-linux-gnueabi
export OECORE_NATIVE_SYSROOT="/home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux"
export OECORE_TARGET_SYSROOT="$SDKTARGETSYSROOT"
export OECORE_ACLOCAL_OPTS="-I /home/keitee/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/share/aclocal"
unset command_not_found_handle
export CC="arm-rdk-linux-gnueabi-gcc  -march=armv7ve -mthumb -mfpu=neon  -mfloat-abi=hard -mcpu=cortex-a15 -fno-omit-frame-pointer -fno-optimize-sibling-calls --sysroot=$SDKTARGETSYSROOT"
export CXX="arm-rdk-linux-gnueabi-g++  -march=armv7ve -mthumb -mfpu=neon  -mfloat-abi=hard -mcpu=cortex-a15 -fno-omit-frame-pointer -fno-optimize-sibling-calls --sysroot=$SDKTARGETSYSROOT"
export AR=arm-rdk-linux-gnueabi-ar
export NM=arm-rdk-linux-gnueabi-nm
export M4=m4
export TARGET_PREFIX=arm-rdk-linux-gnueabi-
...

keitee@keitee-mint:~/rdk/2.0/sysroots/x86_64-rdksdk-linux/usr/bin/arm-rdk-linux-gnueabi$ ls -al
total 35428
drwxr-xr-x 2 keitee keitee    4096 Aug 28 01:02 .
drwxr-xr-x 8 keitee keitee    4096 Sep 20 11:07 ..
-rwxr-xr-x 1 keitee keitee  836736 Sep 20 11:07 arm-rdk-linux-gnueabi-addr2line
...


// build sample

keitee@keitee-mint:~/rdk/arrisxi6-morty-RNE-SDK-2.0/samples$ ./build_samples.sh

<rdk-ssh>
// Enable SSH Access (every time when boots)

By default the image provides an ssh service (dropbear) that is locked down.
The following can be used to spin up a new instance of dropbear that allow
root login.

dropbearkey -t rsa -f /tmp/sky-ssh-hostkey
dropbear -p :10022 -P /var/run/dropbear2.pid -r /tmp/sky-ssh-hostkey -B

You then need to open the 10022 port:

iptables -I INPUT 2 -p tcp --dport 10022 -m conntrack --ctstate NEW,ESTABLISHED -j ACCEPT
iptables -I OUTPUT 1 -p tcp --sport 10022 -m conntrack --ctstate ESTABLISHED -j ACCEPT


ssh -p 10022 root@<STBIP>

// copy binary to
/tmp/data


={============================================================================
*kt_dev_skymw_0000* skymw-jira-airplay

<skymw-jira-airplay>

<NGDEV-141186>

// delegate if
else if (CFEqual(inProperty, CFSTR(kAirPlayKey_FirmwareRevision))) {

// [String] Firmware revision of the accessory.
#define kAirPlayKey_FirmwareRevision	"firmwareRevision"

have to use SPM_API_SYSINFO_PROPID_STB_SW_VER

// from http if
// [Boolean] Support sending UDP beacon as keep alive.
#define kAirPlayKey_KeepAliveLowPower "keepAliveLowPower"
need to change it to false

kAirPlayKey_KeepAliveSendStatsAsBody  387 AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c     CFDictionarySetValue(info, CFSTR(kAirPlayKey_KeepAliveSendStatsAsBody), kCFBooleanFalse); // Supports statistics as part of the keep alive body.

// from http if
// [Boolean] Whether the receiver supports statistics as part of the keep alive body.
#define kAirPlayKey_KeepAliveSendStatsAsBody "keepAliveSendStatsAsBody"
need to change it to false

// [Boolean] Returns true if the AirPlay name is the factory default name
#define kAirPlayProperty_NameIsFactoryDefault "nameIsFactoryDefault"

    else if (CFEqual(inProperty, CFSTR(kAirPlayKey_Name))) {

.654538 !MIL   -AS           < p:00000dec t:7a1fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 2019-05-16 10:40:41.629209 AM [AirtuneDelegate] <- Name being set is Sky4027  


<NGDEV-141186>

<decode>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c


typedef struct
{
	UInt32		mNumberChannels;
	UInt32		mDataByteSize;
	void *		mData;
	
}	AudioBuffer;

typedef struct
{
	UInt32			mNumberBuffers;
	AudioBuffer		mBuffers[ 1 ];
	
}	AudioBufferList;

_AudioDecoderDecodeFrame()
{
  // note that it is local
  AudioBufferList							bufferList;

  packetCount									= inSession->samplesPerFrame;

  bufferList.mNumberBuffers					= 1;
  bufferList.mBuffers[ 0 ].mNumberChannels	= ctx->channels;
  bufferList.mBuffers[ 0 ].mDataByteSize		= (uint32_t) inDstMaxLen;
  bufferList.mBuffers[ 0 ].mData				= inDstPtr;

  AudioConverterFillComplexBuffer(
      inSession->audioConverter, 
      _AudioDecoderDecodeCallback,  // pass function pointer
      inSession,
      &packetCount,                 // samples per frame 
      &bufferList,                  // buffer list
      NULL );
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioConverterStub.c
// called as many as needed to decode chunk of audio

AudioConverterFillComplexBuffer()
OSStatus AudioConverterFillComplexBuffer(
    AudioConverterRef inConverter, 
    AudioConverterComplexInputDataProc inInputDataProc,
    void* inInputDataProcUserData,
    uint32_t* ioOutputDataPacketSize,   // samples per frame
    AudioBufferList* outOutputData,     // buffer list
    AudioStreamPacketDescription* outPacketDescription)
{
  switch (me->sourceFormatID) {

    // ALAC
    case kAudioFormatAppleLossless:
      return _AudioConverterFillComplexBufferALACDecode(
          inConverter, 
          inInputDataProc, 
          inInputDataProcUserData, 
          ioOutputDataPacketSize,   // in/out, size to decode and size that decoded
          outOutputData, 
          outPacketDescription);

    case kAudioFormatMPEG4AAC:
      // AAC LC to PCM
      return _AudioConverterFillComplexBufferAACDecode(inConverter, inInputDataProc, inInputDataProcUserData, ioOutputDataPacketSize, outOutputData, outPacketDescription);

    default:
      return kUnsupportedErr;
  }
}

<flush>

static HTTPStatus _requestProcessFlushBuffered()
{
  err = AirPlayReceiverSessionFlushAudio(inCnx->session, flushFromP, flushUntil, &lastPlayedTS);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.h
// @abstract 
// Flush any queued audio until the specified timestamp or sequence number.

AirPlayReceiverSessionFlushAudio()
{
  err = AudioConverterReset(inSession->audioConverter);
}

// AP2 SDK

OSStatus AudioConverterReset(AudioConverterRef inConverter)
{
  (void)inConverter;

  // $$$ TODO: Discard any data buffered by the codec

  AudioConverterPrivateRef const me = (AudioConverterPrivateRef)inConverter;

  switch (me->sourceFormatID) {

    case kAudioFormatMPEG4AAC:
      _FlushAACDecoder(inConverter);
  }

  return (kNoErr);
}


// AP1 SDK

// AudioStreamer/AirplaySdk/AirPlayAudioPOSIXReceiver211.1.p8/Support/AudioConverterLite.c

OSStatus	AudioConverterReset_compat( AudioConverterRef me )
{
  (void) me;

  // Nothing to do here.

  return( kNoErr );
}

// from LOG

KT: audioGetData(0 230596533307 0x78f3597c 8820)
KT: audioGetData(2205 230646111351 0x78f3597c 8820)
KT: audioGetData(4410 230696437499 0x78f3597c 8820)
KT: audioGetData(6615 230746918462 0x78f3597c 8820)
KT: audioGetData(8820 230796348590 0x78f3597c 8820)
KT: audioGetData(11025 230846362117 0x78f3597c 8820)
KT: audioGetData(13230 230896336344 0x78f3597c 8820)
KT: audioGetData(15435 230946897891 0x78f3597c 8820)
KT: audioGetData(17640 230996312937 0x78f3597c 8820)
KT: audioGetData(19845 231046380775 0x78f3597c 8820)
KT: audioGetData(22050 231096312862 0x78f3597c 8820)

>>> 985635-983430
2205
>>> 2205-1595
610
>>> 610/44.1
13.83219954648526 ~~ 14ms but 26ms in PCM output?

985635, 22.350
18051:NDS: ^0000000252.850650 !MIL   -AS           < 1970-01-01 12:04:12.850632 AM [AirPlay] Concealed 1595 unit gap (985635 vs 987230), curr seq 26233
18052:NDS: ^0000000252.850667 !MIL   -AS           < 1970-01-01 12:04:12.850632 AM [AirPlay] Concealed 1595 unit gap (985635 vs 987230), curr seq 26233

25016:NDS: ^0000000264.298628 !MIL   -AS           < 1970-01-01 12:04:24.298610 AM [AirPlay] Concealed 2042 unit gap (1490580 vs 1492622), curr seq 27667
25017:NDS: ^0000000264.298645 !MIL   -AS           < 1970-01-01 12:04:24.298610 AM [AirPlay] Concealed 2042 unit gap (1490580 vs 1492622), curr seq 27667

31732:NDS: ^0000000275.496637 !MIL   -AS          < 1970-01-01 12:04:35.496619 AM [AirPlay] Concealed 1612 unit gap (1984500 vs 1986112), curr seq 29063
31733:NDS: ^0000000275.496655 !MIL   -AS          < 1970-01-01 12:04:35.496619 AM [AirPlay] Concealed 1612 unit gap (1984500 vs 1986112), curr seq 29063

37098:NDS: ^0000000284.702606 !MIL   -AS          < 1970-01-01 12:04:44.702588 AM [AirPlay] Concealed 727 unit gap (2390220 vs 2390947), curr seq 30209
37099:NDS: ^0000000284.702624 !MIL   -AS          < 1970-01-01 12:04:44.702588 AM [AirPlay] Concealed 727 unit gap (2390220 vs 2390947), curr seq 30209

43855:NDS: ^0000000295.902600 !MIL   -AS          < 1970-01-01 12:04:55.902582 AM [AirPlay] Concealed 302 unit gap (2884140 vs 2884442), curr seq 31608
43856:NDS: ^0000000295.902618 !MIL   -AS          < 1970-01-01 12:04:55.902582 AM [AirPlay] Concealed 302 unit gap (2884140 vs 2884442), curr seq 31608

3168585, 71.850
47357:NDS: ^0000000302.348641 !MIL   -AS          < 1970-01-01 12:05:02.348619 AM [AirPlay] Concealed 286 unit gap (3168585 vs 3168871), curr seq 32410
47358:NDS: ^0000000302.348659 !MIL   -AS          < 1970-01-01 12:05:02.348619 AM [AirPlay] Concealed 286 unit gap (3168585 vs 3168871), curr seq 32410

3318525, 75.250
48777:NDS: ^0000000305.746622 !MIL   -AS          < 1970-01-01 12:05:05.746564 AM [AirPlay] Concealed 1170 unit gap (3318525 vs 3319695), curr seq 32834
48778:NDS: ^0000000305.746644 !MIL   -AS          < 1970-01-01 12:05:05.746564 AM [AirPlay] Concealed 1170 unit gap (3318525 vs 3319695), curr seq 32834


>>> 985635/44100
22
>>> (985635%44100)/44.1
350.0


KT: nowTs=806326, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552521935, srcTS=806326
KT: nowTs=806326, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552521935, srcTS=806326
KT: pktTS=3552522287 src->rtpOffsetActive=743240662 inSession->audioLatencyOffset=11025
KT: pktTS=3552522287 src->rtpOffsetActive=743240662 inSession->audioLatencyOffset=11025
KT: nowTs=806678, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552522287, srcTS=806678
KT: nowTs=806678, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552522287, srcTS=806678


={============================================================================
*kt_dev_skymw_0000* skymw-jira-android

<skymw-jira-NGDEV-143556> <git-log>

keitee@keitee-mint:~/ip/repo/SkyBluetoothRcu$ git show --stat

commit c472491d870088f3afaffd7863bc5c4ce4697078 (HEAD -> NGDEV-143556_IP100_Support_RCU_pairing_without_infrared, origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared)
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jun 25 14:48:07 2019 +0100

    NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

    Quote from
    https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Bluetooth+RCU+Pairing+Without+Infrared

    In the v2.1.0 release of the SkyBluetoothRcu code for Android an experimental
    feature was added in the debug builds to put the bluetooth code in 'searching'
    mode for 30 seconds. In search mode the code will look for any nearby BT RCU
    devices that are in pairing mode, when / if found it will automatically start
    pairing to it. Only the first RCU found in pairing mode will trigger the STB
    pairing code, subsequent found devices will be ignored (until 'searching' mode
    is enalbed once again).

    It works by looking for the special advertising packets sent by the BT RCU
    when you hold the 1 and 3 buttons. The BT RCU will send these special packets
    for 10 seconds after entering pairing mode.

 app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl         |  2 ++
 app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl |  2 +-
 app/src/main/cpp/blercu/blercucontroller.cpp                 | 37 +++++++++++++++++++++++++++++++++----
 app/src/main/cpp/blercu/blercucontroller.h                   | 11 ++++++++++-
 app/src/main/cpp/blercu/blercucontroller_p.h                 |  2 ++
 app/src/main/cpp/blercu/blercupairingstatemachine.h          |  1 +
 app/src/main/cpp/debug/wshandler.cpp                         |  2 +-
 app/src/main/cpp/service/android/blercuservice.cpp           | 57 +++++++++++++++++++++++++++++++++++++++++++++++++--------
 app/src/main/cpp/service/android/blercuservice.h             |  9 ++++++++-
 app/src/main/java/com/sky/blercu/BleRcuService.java          | 24 +++++++++++++-----------
 10 files changed, 120 insertions(+), 27 deletions(-)

* c472491 : (HEAD -> NGDEV-143556_IP100_Support_RCU_pairing_without_infrared, origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared) NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared (23 hours ago) <Kit Park>
* d9f1809 : NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared (24 hours ago) <Kit Park>

keitee@keitee-mint:~/ip/repo/SkyBluetoothRcu$ git show --stat d9f1809
commit d9f1809e6ab0bb5bf4d500dfa82f5207ea3ef605
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jun 25 14:24:20 2019 +0100

    NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

    As a part of delivery, applies clang style, Mozilla, to files before a commit
    which has actual changes so that can have clean base to show only differences to
    review.

 app/src/main/cpp/blercu/blercucontroller.cpp        |  906 ++++++++++++++++++++++++++------------------------
 app/src/main/cpp/blercu/blercucontroller.h          |   52 ++-
 app/src/main/cpp/blercu/blercupairingstatemachine.h |  192 +++++------
 app/src/main/cpp/debug/wshandler.cpp                |  188 ++++++-----
 app/src/main/cpp/service/android/blercuservice.cpp  | 3192 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------
 app/src/main/cpp/service/android/blercuservice.h    |  447 ++++++++++++++-----------
 6 files changed, 2637 insertions(+), 2340 deletions(-)


<add-start-scan-call>

add startScanning(int timeout); to client if

app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
app/src/main/java/com/sky/blercu/BleRcuService.java

	public BleRcuService(long qtObject) {
		//
		mQtObject = qtObject;
   }

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {

		`private BleRcuService mService;`

		private BleRcuServiceBinder(BleRcuService svc) {
			mService = svc;
		}
		public boolean cleanup() {
			mService = null;
			return true;
		}

		public BleRcuService getService() {
			if (mService != null && mService.isAvailable()) {
				return mService;
			}
			return null;
		}

		public String getDeviceName(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceName(`service.mQtObject`, address);
		}

	private native String jniGetDeviceName(long qtObject, String address);


app/src/main/cpp/service/android/blercuservice.cpp

bool BleRcuService::registerNatives()
{
		JNI_ENTRY(jniGetDeviceName,               "(JLjava/lang/String;)Ljava/lang/String;"),
}

jstring BleRcuService::jniGetDeviceName(JNIEnv *env, jobject, `jlong qtObject`,
                                        jstring address)
{
	return jniGetDeviceInfo(env, qtObject, address, DeviceName);
}

app/src/main/cpp/service/android/blercuservice.h

keitee@keitee-mint:~/ip/BleRcuExample$ cp ../SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl


<ble-example-client>

app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/blercu/IBleRcuService.java
 * This file is auto-generated.  DO NOT MODIFY.


<ble-callback>

// app/src/main/cpp/blercu/blercucontroller.cpp

BleRcuControllerImpl::BleRcuControllerImpl()
{
  *emit-started*
  // connect to the finished signal of the pairing statemachine, use to update
  // our list of managed devices
  QObject::connect(&m_pairingStateMachine, `&BleRcuPairingStateMachine::finished`,
      this, &BleRcuControllerImpl::onFinishedPairing,
      Qt::QueuedConnection);

  // connect to the started signal so we can send pairing state notifications
  QObject::connect(&m_pairingStateMachine, `&BleRcuPairingStateMachine::started`,
      this, &`BleRcuControllerImpl::onStartedPairing`,
      Qt::QueuedConnection);

  QObject::connect(this, &`BleRcuController::pairingStateChanged`,
      m_analytics.data(), &BleRcuAnalytics::logPairingStateChange,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onStartedPairing()
{
  // a queued event so check the state
  const bool pairing = m_pairingStateMachine.isRunning();

  qMilestone() << "KT: tell clients that the pairing state has changed";

  // tell clients that the pairing state has changed
  emit pairingStateChanged(pairing);
}

void BleRcuControllerImpl::onFinishedPairing()
{
  // a queued event so check the state
  const bool pairing = m_pairingStateMachine.isRunning();

  // (re)sync our list of managed devices now pairing has finished
  if (!pairing)
    syncManagedDevices();

  qMilestone() << "KT: tell clients that the pairing state has changed";

  // tell clients that the pairing state is changed
  emit pairingStateChanged(pairing);
}

// app/src/main/cpp/service/android/blercuservice.cpp

void BleRcuService::setController(const QSharedPointer<BleRcuController> &controller)
{
  QObject::connect(controller.data(), &`BleRcuController::pairingStateChanged`,
      this, `&BleRcuService::onPairingStateChanged`);
}

void BleRcuService::onPairingStateChanged(bool pairing)
{
  *call-from-c-to-java*
  m_javaBleRcuService->callMethod<void>("onPairingStateChanged",
      "(Z)V",
      static_cast<jboolean>(pairing ? JNI_TRUE : JNI_FALSE));
}

void BleRcuAnalytics::logPairingStateChange(bool pairing)
{
  if (pairing)
    qProdLog("KT: logPairingStateChange: started bluetooth RCU pairing procedure");
  else
    qProdLog("KT: logPairingStateChange: finished bluetooth RCU pairing procedure");
}

app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {

	final RemoteCallbackList<IBleRcuServiceCallback> mCallbacks =
		new RemoteCallbackList<IBleRcuServiceCallback>();

	/**
	 * Expected to be called by the native C++ code when the pairing process
	 * has started or stopped.
	 *
	 */
	public void onPairingStateChanged(final boolean pairing) {

		mServiceLock.writeLock().lock();
		boolean triggerCallback = (mIsPairing != pairing);
		mIsPairing = pairing;
		mServiceLock.writeLock().unlock();

		if (triggerCallback && mNotifyThread.isAlive()) {

			// broadcast back to clients from the notify thread
			mNotifyThread.mHandler.post(() -> {

				final int n = mCallbacks.beginBroadcast();
				for (int i = 0; i < n; i++) {
					try {
						mCallbacks.getBroadcastItem(i).onPairingChanged(pairing);
					} catch (RemoteException e) {
						// RemoteCallbackList will take care of removing dead objects
					}
				}

				`mCallbacks`.finishBroadcast();
			});
		}
	}
}

<port-to->

/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
main.cpp

setupBleRcuController()
{
  // create the manager object
  QSharedPointer<BleRcuManager> manager =
    QSharedPointer<BleRcuManagerImpl>::create(config,
        deviceFactory,
        QDBusConnection::systemBus());

  // create the controller object
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(
        config, 
        `manager`,
        options->networkNamespace());
}


/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
blercu/blercumanager.cpp

class BleRcuManagerImpl : public BleRcuManager

	StateMachine m_stateMachine;


/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
blercu/blercucontroller.cpp

	BleRcuPairingStateMachine m_pairingStateMachine;


xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/console/source/
dbus/dbusabstractinterface.cpp


<xx>
this is when a device is ready when pairing fsm is not running.

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[DeviceStateMachine] moving from state StartingServices(5) to ReadyState(6)"
I BleRcuQt: < M:blercuadapter.cpp F:onDeviceReadyChanged L:1733 > device with address D4:B8:FF:12:E1:A8 is  ready
D ServicePeripherals: @BTREMOTE: onDeviceConnectionStateChanged | address: D4:B8:FF:12:E1:A8 connected: true
D BleRcuManager: onDeviceConnectionStateChanged() - D4:B8:FF:12:E1:A8 : true


<skymw-jira-NGDEV-147137>
NGDEV-147137
IP - peripherals/btremotes/status is not persistent after reboot

Have used IP100, QIPQ00.000.39.00D which is older AS version than the reported,
QIP100.000.16.00D and see the same issue when connected from reboot.

However, can get these properties from test application. So AS don't seem to
update its property set when connected. 

<skymw-jira-NGDEV-147573> *state-change*
PUCK ITA very long INITIALISING BT remote state during startup

From log_dump.log

09-11 15:16:13.348760  1376  1376 I bluetoothd: Bluetooth daemon 5.48
09-11 15:16:13.349182  1376  1376 D bluetoothd: src/main.c:parse_config() parsing /data/user/0/com.sky.bluez/etc/main.conf
09-11 15:16:13.349249  1376  1376 D bluetoothd: src/main.c:parse_config() discovto=180
09-11 15:16:13.349304  1376  1376 D bluetoothd: src/main.c:parse_config() pairto=180
09-11 15:16:13.349357  1376  1376 D bluetoothd: src/main.c:parse_config() privacy=off
09-11 15:16:13.349408  1376  1376 D bluetoothd: src/main.c:parse_config() name="sky-ip100"
09-11 15:16:13.349475  1376  1376 D bluetoothd: src/main.c:parse_config() class=0x040414
09-11 15:16:13.349566  1376  1376 D bluetoothd: src/main.c:parse_config() Key file does not have key “DeviceID” in group “General”
09-11 15:16:13.349688  1376  1376 D bluetoothd: src/main.c:parse_sky_config() SecureConnections=false
09-11 15:16:13.349754  1376  1376 D bluetoothd: src/main.c:parse_sky_config() att_le_mtu=23
09-11 15:16:13.349807  1376  1376 D bluetoothd: src/main.c:parse_sky_config() DelayGATTUntilBonded=true

	/** This is a list of possible pairing state values */
	private static final int PAIRING_STATE_INITIALSING  = 0;
	private static final int PAIRING_STATE_IDLE         = 1;
	private static final int PAIRING_STATE_SEARCHING    = 2;
	private static final int PAIRING_STATE_PAIRING      = 3;
	private static final int PAIRING_STATE_COMPLETE     = 4;
	private static final int PAIRING_STATE_FAILED       = 5;

6418 :09-11 15:16:13.749913  1280  1360 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
10260:09-11 15:16:19.868501  1280  1360 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  2
17053:09-11 15:16:43.620617  1280  1360 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  3
17722:09-11 15:16:48.144087  1280  1360 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  4
28657:09-11 15:21:18.921847  1139  1252 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
38031:09-11 15:23:00.713862  1142  1244 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
47503:09-11 15:24:07.713163  1141  1295 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
55904:09-11 15:25:13.668425  1142  1293 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
67590:09-11 16:05:27.576975  1146  1232 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
79753:09-11 16:08:42.353928  1141  1268 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1
95029:09-11 16:16:05.782230  1141  1237 I BleRcuQt: < M:blercuservice.cpp F:onStateChanged L:417 > on pairing state changes to  1


={============================================================================
*kt_dev_skymw_0000* skymw-jira-q

<skymw-jira-q>
NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

This is clone of NGDEV-143556[1] to bring the same feature onto DTH Q. Before
doing that, Bluetooth code in DTH Q may be updated and be synced with IP100
codebase since DTH Q is left behind and IP100 is moved away which makes many
differences between two base. 

Therefore, the efforts is made to have as common base as possible between them
and have a new feature on top of that. Refer to [1] for more details of the new
feature. 

This also has corresponding test caes in support of features and changes.

[1] NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared


git flow feature start NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared_compatibility_fix

NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

While delivering NGDEV-143989[1], we have found that it is better to maintain
compatibility in terms of paring state which application counts on until
application moves to new state change and old pairing state becomes obsolete. 

This commit includes changes to update pairing state when pairing attempts fails.

[1] NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared


commit ff1b11c895b656ec2a85eea10af00c797cea84e2
Author: Kit Park <kit.park@sky.uk>
Date:   Fri Jul 19 08:59:12 2019 +0100

    NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

    While delivering NGDEV-143989[1], we have found that it is better to maintain
    compatibility in terms of paring state which application counts on until
    application moves to new state change and old pairing state becomes obsolete.

    This commit includes changes to update pairing state when pairing attempts
    fails.

    [1] NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

commit d72ba3afca41490034901be9ecaa25c21450a18d
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jul 16 15:38:30 2019 +0100

    NGDEV-143989: CLONE - DTH - BLERCU Support RCU pairing without Infrared

    This is clone of NGDEV-143556[1] to bring the same feature onto DTH Q. Before
    doing that, Bluetooth code in DTH Q may be updated and be synced with IP100
    codebase since DTH Q is left behind and IP100 is moved away which makes many
    differences between two base.

    Therefore, the efforts is made to have as common base as possible between them
    and have a new feature on top of that. Refer to [1] for more details of the new
    feature.

    This also has corresponding test caes in support of features and changes.

    [1] NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

git show --stat d72ba3afca41490034901be9ecaa25c21450a18d

 AppInfrastructure/BluetoothRcu/client/lib/source/BleRcuController.cpp                      |  54 ++++++++++++++++
 AppInfrastructure/BluetoothRcu/client/lib/source/BleRcuController.h                        |  20 ++++++
 AppInfrastructure/BluetoothRcu/client/test/source/BlueRcuProxyTest.cpp                     | 121 ++++++++++++++++++++++++++++++++++
 AppInfrastructure/BluetoothRcu/console/source/base_cmdhandler.h                            |   1 +
 AppInfrastructure/BluetoothRcu/console/source/blercu/blercucontroller1_interface.h         |  12 ++++
 AppInfrastructure/BluetoothRcu/console/source/blercu_cmdhandler.cpp                        |  68 +++++++++++++++++++-
 AppInfrastructure/BluetoothRcu/console/source/blercu_cmdhandler.h                          |   3 +
 AppInfrastructure/BluetoothRcu/console/source/console.cpp                                  |  28 ++++++++
 AppInfrastructure/BluetoothRcu/console/source/console.h                                    |   1 +
 AppInfrastructure/BluetoothRcu/console/source/rhad_cmdhandler.cpp                          |   6 ++
 AppInfrastructure/BluetoothRcu/console/source/rhad_cmdhandler.h                            |   1 +
 AppInfrastructure/BluetoothRcu/daemon/resources/config.default.json                        |  25 ++++++--
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/adaptors/blercucontroller1_adaptor.cpp |  51 +++++++++++++++
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/adaptors/blercucontroller1_adaptor.h   |   9 +++
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercu.pri                             |   2 +
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercucontroller.cpp                   | 310 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-----------
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercucontroller.h                     |  22 +++++--
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercucontroller_p.h                   |  22 +++++--
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercudevice.cpp                       |  13 +++-
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercumanager.cpp                      | 114 ++++++++++++++++++++------------
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercumanager.h                        |  26 ++++----
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercumanager_p.h                      |  19 +++---
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.cpp          | 192 ++++++++++++++++++++++++++++++++++++------------------
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.h            |  46 +++++++------
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercuscannerstatemachine.cpp          | 492 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 AppInfrastructure/BluetoothRcu/daemon/source/blercu/blercuscannerstatemachine.h            | 129 +++++++++++++++++++++++++++++++++++++
 AppInfrastructure/BluetoothRcu/daemon/source/configsettings/configmodelsettings.cpp        |  85 +++++++++++++++++++++---
 AppInfrastructure/BluetoothRcu/daemon/source/configsettings/configmodelsettings.h          |  10 ++-
 AppInfrastructure/BluetoothRcu/daemon/source/configsettings/configmodelsettings_p.h        |   4 +-
 AppInfrastructure/Public/BluetoothRcu/IBluetoothRcu.h                                      |  35 ++++++++++
 30 files changed, 1708 insertions(+), 213 deletions(-)


<skymw-jira-q>
git checkout -b NGDEV-146407_AS_INT_peripherals_btremotes_status_is_stuck_in_INITIALISING_state_after_reboot

NGDEV-146407: AS_INT: peripherals/btremotes/status is stuck in INITIALISING state after reboot

From investigation, the edge case is identified:

* 055 RCU and some platforms gets an adapter powered earlier than the usual
  such as 101 RCU which causes the IDLE state change fired before the signal
  connection is made. So the signal is lost and no state update to AS.

This commit sends out IDLE state change once all objects are up and running to
be sure it's get delivered to AS when early powered event arrives and manager
skips out to powered on state. 


git flow feature start NGDEV-146407_AS_INT_peripherals_btremotes_status_is_stuck_in_INITIALISING_state_after_reboot

NGDEV-143989_CLONE_-_DTH_-_BLERCU_Support_RCU_pairing_without_infrared

This issue can not be reproduced with EC 101.

Steps:

RCU E055 is paired
reboot the box

Actual: peripherals/btremotes/status is stuck in "INITIALISING" state.
Expected : peripherals/btremotes/status in "IDLE" state


// 101, OK

42331:NDS: ^0000000113.395098 !MIL   -APPINFRA     < p:00000e14 t:43110dc0 T:no name M:DiagService.cpp F:createLogPipe L:00137 > CreateLogPipe created pipe for app BLERCU with inode 123931
42332:NDS: ^0000000113.396437 !MIL   -DOBBY        < p:00000e14 t:49cbadc0 T:no name M:EthanLogPlugin.cpp F:postConstruction L:00255 > Received pipe to BLERCU with inode 123931
42335:NDS: ^0000000113.476438 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:.  L:00000 > Logging pipe inode is 123931
42336:NDS: ^0000000113.502220 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:hcisocket.cpp F:create L:00311 > creating new socket for HciSocket object
42337:NDS: ^0000000113.502419 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:hcisocket.cpp F:setSocketFilter L:00435 > setting hci filter to [ type=0x0010 events={0x00000020, 0x40000000} ]
42338:NDS: ^0000000113.502755 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:qtvfs.cpp F:qtvfsRegister L:00704 > registered sqlite VFS for QT
42339:NDS: ^0000000113.503158 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:irdatabase.cpp F:init L:00253 > opened ir database @ ':irdb.sqlite'
42340:NDS: ^0000000113.507607 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:ipc_servicesfactory.cpp F:init L:00153 > created 'com.sky.rcu.Manager1' proxy to "/com/ruwido/rcu" on service "com.ruwido.rcu"
42341:NDS: ^0000000113.508173 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:ipc_servicesfactory.cpp F:init L:00153 > created 'com.sky.rcu.Manager1' proxy to "/com/uei/userver" on service "com.uei.userver"
42342:NDS: ^0000000113.508262 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercudevicefactory.cpp F:BleRcuDeviceFactory L:00047 > models with OUI 0x48d0cf are disabled
42343:NDS: ^0000000113.511511 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercumanager.cpp F:findAdapter L:00703 > found bluez adapter at "/org/bluez/hci0" with address FF:FF:FF:FF:FF:FF
42344:NDS: ^0000000113.512581 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercumanager.cpp F:onEnteredAdapterPoweredOffState L:00456 > adapter is not powered, attempting to power on now
42345:NDS: ^0000000113.513691 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:hcimonitor.cpp F:run L:00645 > entering hci monitor thread
42348:NDS: ^0000000113.517156 !MIL   -APPINFRA     < p:00000e14 t:4b282dc0 T:no name M:BleRcuFactory.cpp F:createBleRcuControllerProxy L:00447 > KT: BleRcuContollerProxy: {
42349:NDS: ^0000000113.518418 !MIL   -APPINFRA     < p:00000e14 t:4b282dc0 T:no name M:BleRcuFactory.cpp F:createBleRcuControllerProxy L:00449 > KT: BleRcuContollerProxy: }
42352:NDS: ^0000000113.519752 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:main.cpp F:main L:00478 > BleRcuDaemon started
42353:NDS: ^0000000113.519793 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:main.cpp F:main L:00479 > ========================
42354:NDS: ^0000000113.519808 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:main.cpp F:main L:00480 > KT: BleRcuDaemon started
42507:NDS: ^0000000113.733030 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercumanager.cpp F:onAdapterPowerChanged L:00864 > BT adapter powered on
42569:NDS: ^0000000113.745203 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercumanager.cpp F:disablePairable L:01142 > disabling pairable mode
42570:NDS: ^0000000113.747187 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving to state Idle(0)"
42583:NDS: ^0000000113.748514 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercumanager.cpp F:onDeviceAdded L:01480 > added device D4:B8:FF:12:E1:A8 named "P037 SkyQ EC101" (connected: false paired: true)
42587:NDS: ^0000000113.748813 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercumanager.cpp F:onEnteredAdapterPoweredOnState L:00552 > KT: onEnteredAdapterPoweredOnState: emit poweredInitialised
42588:NDS: ^0000000113.748844 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercucontroller.cpp F:onInitialised L:00605 > KT: onInitialised: emit stateChanged(idle)
42589:NDS: ^0000000113.748858 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercucontroller1_adaptor.cpp F:onStateChanged L:00128 > onStateChanged( 1 )
42596:NDS: ^0000000113.749657 !MIL   -APPINFRA     < p:00000e14 t:44110dc0 T:no name M:BleRcuController.cpp F:signalHandlerPropertiesChanged L:00770 > KT: Status change: 1
42610:NDS: ^0000000113.753153 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:blercudevice.cpp F:onDevicePairedChanged L:00484 > D4:B8:FF:12:E1:A8 paired
42611:NDS: ^0000000113.753222 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state Idle(0) to Paired(1)"
42612:NDS: ^0000000113.753405 !MIL   -BLERCU       < p:00000e14 t:49cbadc0 T:no name M:.  L:00000 > ECx01 bluetooth RCU added
43848:NDS: ^0000000114.060701 !MIL   -DRM_Manager  < p:00000e15 t:76a70c70 T:no name M:time_server.c F:HandleFirstValidDeviceTime L:01023 > !DRM_MIL_TIME! device time calculated from LKT is 0xB6415B:5 [15:23:05 17/09/2019], Current device time is 0xB6415E:6 [15:26:06 17/09/2019] - secure time was adjusted to 0xB6415E:5 [15:26:05 17/09/2019], compensating for power-down time, time_qualit=1
44351:NDS: ^0000000114.346088 !MIL   -AS           < p:00000e14 t:3b4dedc0 T:AUS_Player M:AS_DMS_Writer.cpp F:BluetoothMediaStreamer L:00258 > @ctx:dbusitf bluetooth_media.cpp(239) KT::BluetoothMediaStreamer
52798:NDS: ^0000000117.936613 !MIL   -AS           < p:00000e14 t:4a185dc0 T:AS_SVC_CTL M:AS_DMS_Writer.cpp F:SetName L:00258 > @ctx:AS_SERVICELIST_CONTROLLER AS_SERVICELIST_Service.cpp(934) AS_DMSUTILS::getSystemString succeeded, m_name: KTV
52801:NDS: ^0000000117.936735 !MIL   -AS           < p:00000e14 t:4a185dc0 T:AS_SVC_CTL M:AS_DMS_Writer.cpp F:AddServiceObject L:00258 > @ctx:AS_SERVICELIST_CONTROLLER AS_SERVICELIST_ServiceListContainer.cpp(412) Adding service that is relevant, service.GetSid: 1056, service.GetLcn: 771, service.GetName: KTV


// 055, NOK

392876:NDS: ^0000000111.689749 !MIL   -APPINFRA     < p:00000e12 t:430a7dc0 T:no name M:DiagService.cpp F:createLogPipe L:00137 > CreateLogPipe created pipe for app BLERCU with inode 83962
392877:NDS: ^0000000111.691023 !MIL   -DOBBY        < p:00000e12 t:49c51dc0 T:no name M:EthanLogPlugin.cpp F:postConstruction L:00255 > Received pipe to BLERCU with inode 83962
392880:NDS: ^0000000111.777662 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:.  L:00000 > Logging pipe inode is 83962
392881:NDS: ^0000000111.803370 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:hcisocket.cpp F:create L:00311 > creating new socket for HciSocket object
392882:NDS: ^0000000111.803554 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:hcisocket.cpp F:setSocketFilter L:00435 > setting hci filter to [ type=0x0010 events={0x00000020, 0x40000000} ]
392883:NDS: ^0000000111.803901 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:qtvfs.cpp F:qtvfsRegister L:00704 > registered sqlite VFS for QT
392884:NDS: ^0000000111.804319 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:irdatabase.cpp F:init L:00253 > opened ir database @ ':irdb.sqlite'
392885:NDS: ^0000000111.814339 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:ipc_servicesfactory.cpp F:init L:00153 > created 'com.sky.rcu.Manager1' proxy to "/com/ruwido/rcu" on service "com.ruwido.rcu"
392886:NDS: ^0000000111.815319 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:ipc_servicesfactory.cpp F:init L:00153 > created 'com.sky.rcu.Manager1' proxy to "/com/uei/userver" on service "com.uei.userver"
392887:NDS: ^0000000111.815435 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:blercudevicefactory.cpp F:BleRcuDeviceFactory L:00047 > models with OUI 0x48d0cf are disabled
392888:NDS: ^0000000111.824693 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:blercumanager.cpp F:findAdapter L:00703 > found bluez adapter at "/org/bluez/hci0" with address FF:FF:FF:FF:FF:FF
392889:NDS: ^0000000111.830725 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:blercumanager.cpp F:disablePairable L:01142 > disabling pairable mode
392890:NDS: ^0000000111.832958 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving to state Idle(0)"
392891:NDS: ^0000000111.834093 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:blercumanager.cpp F:onDeviceAdded L:01480 > added device 1C:A2:B1:BA:C0:AD named "U192ruwido Sky Remote" (connected: false paired: true)
392892:NDS: ^0000000111.834168 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:blercumanager.cpp F:onEnteredAdapterPoweredOnState L:00552 > KT: onEnteredAdapterPoweredOnState: emit poweredInitialised
392893:NDS: ^0000000111.834915 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:hcimonitor.cpp F:run L:00645 > entering hci monitor thread
392896:NDS: ^0000000111.837928 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:main.cpp F:main L:00478 > BleRcuDaemon started
392897:NDS: ^0000000111.837978 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:main.cpp F:main L:00479 > ========================
392898:NDS: ^0000000111.837993 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:main.cpp F:main L:00480 > KT: BleRcuDaemon started
392899:NDS: ^0000000111.838498 !MIL   -APPINFRA     < p:00000e12 t:4b1b4dc0 T:no name M:BleRcuFactory.cpp F:createBleRcuControllerProxy L:00447 > KT: BleRcuContollerProxy: {
392900:NDS: ^0000000111.839903 !MIL   -APPINFRA     < p:00000e12 t:4b1b4dc0 T:no name M:BleRcuFactory.cpp F:createBleRcuControllerProxy L:00449 > KT: BleRcuContollerProxy: }
392903:NDS: ^0000000111.840755 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:blercudevice.cpp F:onDevicePairedChanged L:00484 > 1C:A2:B1:BA:C0:AD paired
392904:NDS: ^0000000111.840841 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:statemachine.cpp F:logTransition L:00082 > "[DeviceStateMachine] moving from state Idle(0) to Paired(1)"
392905:NDS: ^0000000111.841514 !MIL   -BLERCU       < p:00000e12 t:49c51dc0 T:no name M:.  L:00000 > EC05x bluetooth RCU added
394378:NDS: ^0000000112.353534 !MIL   -DRM_Manager  < p:00000e13 t:76a70c70 T:no name M:time_server.c F:HandleFirstValidDeviceTime L:01023 > !DRM_MIL_TIME! device time calculated from LKT is 0xB64140:53 [14:56:53 17/09/2019], Current device time is 0xB64150:42 [15:12:42 17/09/2019] - secure time was adjusted to 0xB64150:41 [15:12:41 17/09/2019], compensating for power-down time, time_qualit=1
394847:NDS: ^0000000112.645504 !MIL   -AS           < p:00000e12 t:3b3dddc0 T:AUS_Player M:AS_DMS_Writer.cpp F:BluetoothMediaStreamer L:00258 > @ctx:dbusitf bluetooth_media.cpp(239) KT::BluetoothMediaStreamer
405166:NDS: ^0000000119.839658 !MIL   -AS           < p:00000e12 t:4a085dc0 T:AS_SVC_CTL M:AS_DMS_Writer.cpp F:SetName L:00258 > @ctx:AS_SERVICELIST_CONTROLLER AS_SERVICELIST_Service.cpp(934) AS_DMSUTILS::getSystemString succeeded, m_name: KTV
405169:NDS: ^0000000119.839708 !MIL   -AS           < p:00000e12 t:4a085dc0 T:AS_SVC_CTL M:AS_DMS_Writer.cpp F:AddServiceObject L:00258 > @ctx:AS_SERVICELIST_CONTROLLER AS_SERVICELIST_ServiceListContainer.cpp(412) Adding service that is relevant, service.GetSid: 1056, service.GetLcn: 771, service.GetName: KTV


={============================================================================
*kt_dev_skymw_0000* skymw-jira-luna

git flow feature start NGDEV-144531_Luna_-_update_to_support_DTT_video_on_IP150_/_IP051

NGDEV-144531: Luna - update to support DTT video on IP150 / IP051

For the new IP150 and IP051 Android boxes the way the iWedia player exposes
video surfaces has changed. See [1] for more details. Therefore, The Luna
runtime needs to be updated to reflect this.

This is a temporary commit only to have new jar library and a change to see
video via Vevo.

[1] https://www.stb.bskyb.com/confluence/display/2016/Creating+and+passing+of+Android+video+surface+to+iWedia+AS+Service+for+IP150

git flow feature finish -S NGDEV-144531_Luna_-_update_to_support_DTT_video_on_IP150_/_IP051


={============================================================================
*kt_dev_skymw_0000* skymw-todo

NDS: ^0000027250.001939 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onStartDiscoveryReply L:00959 > discovery start request failed with error QDBusError("org.bluez.Error.InProgress", "Operation already in progress")
NDS: ^0000027252.282777 !MIL   -SYSTEMTIME   < p:00000dda t:b5a10440 T:SYSTEMTIME_NOTIFICATION_THREAD M:systemtime_monotonic.c F:SYSTEMTIME_TimeStampCallback L:02242 > Time is (Year:Month:Day:Hour:Min:Sec) 2019:07:12:01:38:14
NDS: ^0000027255.001136 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onDiscoveryWatchdog L:01064 > detected discovery in the wrong state (expected:on actual:off)
NDS: ^0000027255.003794 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onStartDiscoveryReply L:00959 > discovery start request failed with error QDBusError("org.bluez.Error.InProgress", "Operation already in progress")
NDS: ^0000027257.282896 !MIL   -SYSTEMTIME   < p:00000dda t:b5a10440 T:SYSTEMTIME_NOTIFICATION_THREAD M:systemtime_monotonic.c F:SYSTEMTIME_TimeStampCallback L:02242 > Time is (Year:Month:Day:Hour:Min:Sec) 2019:07:12:01:38:19
NDS: ^0000027260.000971 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onDiscoveryWatchdog L:01064 > detected discovery in the wrong state (expected:on actual:off)
NDS: ^0000027260.001910 !ERROR -BLERCU       < p:00000ddb t:89cbadc0 T:no name M:blercumanager.cpp F:onStartDiscoveryReply L:00959 > discovery start request failed with error QDBusError("org.bluez.Error.InProgress", "Operation already in progress")


#{============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
