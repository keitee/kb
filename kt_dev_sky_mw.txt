*kt_dev_sky_mw*                                                     tw=100, utf-8

/^[#=]{
Use #{ for a group and ={ for a item

Write what you know and konw what you write. - EXC++, Herb Sutter

An expert is a man who has made all the mistakes that can be made, in a very
narrow field. -Nils Bohr

TODO:
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. SKYMW

*kt_dev_skymw_0000* skymw-setup
*kt_dev_skymw_0000* skymw-q-hardware


={============================================================================
*kt_dev_skymw_0000* skymw-setup

<ssh>
to register ssh keys
https://www.stb.bskyb.com/gosa/


<repos>
git clone dwngit@git.stb.bskyb.com:ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-as-source ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-mw-wrt
git clone dwngit@git.stb.bskyb.com:appinfrastructure


<ethan-as-source>
// needs to run git pull since no default branch?
// "develop" branch

git pull origin develop

keitee@keitee-mint:~/mw/ethan-as-source$ git checkout develop
Checking out files: 100% (25967/25967), done.

// update submodule

keitee@keitee-mint:~/mw/ethan-as-source$ git submodule update --init --force


<sdk>
keitee@keitee-mint:~/mw/ethan-as-source$ cd xSubmoduleDarwinSDK/
keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK$ ./getSdk.sh eu-q-titan-uk HQ000


<tftp>
sudo apt-get install tftpd-hpa

cat /etc/default/tftpd-hpa 

# /etc/default/tftpd-hpa

TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/opt/tftpboot"
TFTP_ADDRESS=":69"
TFTP_OPTIONS="--secure"

<nfs>
sudo apt-get install nfs-kernel-server

<boot>

mount -o rw -t nfs 192.168.0.101:/home/keitee/mw/exports/titan/flash0 /mnt/x

// should be careful not to include the end of line when pasting it into bolt
// command line

setenv -p STARTUP "ifconfig eth0 -auto;boot 192.168.1.5:falcon_d1/zImage 'console=ttyS0,115200 ip=udhcp mesh=off vmalloc=334M brcm_cma_kern_rsv=416M remotedir=192.168.1.5:/export/flash0_falcon_d1'"

// shall have quote ""
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage"
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.101:/titan/zImage ‘remotedir=192.168.0.101:/home/keitee/mw/exports/titan/flash0'"
// setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage console=ttyS0,115200 ip=udhcp vmalloc=300M brcm_cma_kern_rsv=450M remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0"

// error since copied from word document and found that dash(-) causes the
// issue when used on bolt bootloader
setenv -p STARTUP "ifconfig eth0 –auto; boot 192.168.0.100:/titan/zImage ‘remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0'"


={============================================================================
*kt_dev_skymw_0000* skymw-q-hardware

// q hardware
https://www.stb.bskyb.com/confluence/display/2016/Q+Platform+Hardware+Specifications


={============================================================================
*kt_dev_skymw_0000* skymw-q-package

// fusion mw
// Check the SI_TARBALL.tgz at the bottom of the page.
http://hudkinsartifactory.cisco.com:8081/artifactory/formal_builds/Q/formal/Q000/Q000.021.41.00/


={============================================================================
*kt_dev_skymw_0000* skymw-q-build

<to-fix-titan-build-error>
export LC_ALL=C

as: loadlocale.c:129: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))' failed.
arm-linux-gcc: internal compiler error: Aborted (program as)
Please submit a full bug report,
with preprocessed source if appropriate.
See <http://gcc.gnu.org/bugs.html> for instructions.


<build-sdk>
cd /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK
./compile_sdkv2.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/ clean
./compile_sdkv2.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/

keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK$ 

ll eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

// all points the same single file

ll eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
-rwxr-xr-x 1 keitee keitee 25M May 14 10:41 eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*


<build-tool>
~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gcc

lrwxrwxrwx 1 keitee keitee 31 May 14 10:41 arm-linux-gcc -> arm-unknown-linux-gnueabihf-gcc*

/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01

<gcc>
export LC_ALL=C
cp /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/unstripped_bin/APP_Process .
/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gdb


<fsi-build>
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/
svn checkout svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/

http://10.184.136.138:8081/view/SI%20build%20Jobs/job/FULL_STACK_SI_BUILD/69/consoleFull

+ cd FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials --baseline Q000.021.42.00

+ create_version_string_from_baseline
+ local VERSION_CFG=projects/bskybgen2/fs/NDS/config/overrides/version.cfg
+ local VERSION_H=projects/bskybgen2/inc/version.h
+ local 'VERSION_SECTION=[VERSION]'
+ local VERSION_TAG=NDS_SW_VERSION
+ local PLATFORM_TAG=PLATFORM
+ echo 'Checking & calculating Version string - '\''sky_trials'\'' '\'''\'''
Checking & calculating Version string - 'sky_trials' ''
python tools/nds/si/python/version_string_calculation.py ${PROFILE} ${BASELINE}
++ python tools/nds/si/python/version_string_calculation.py sky_trials
+ VERSION_STRING='~*~dev version~*~'
+ '[' 0 -ne 0 ']'
+ echo 'VERSION = ~*~dev version~*~'
VERSION = ~*~dev version~*~
+ echo '[VERSION]'
+ echo 'NDS_SW_VERSION="~*~dev version~*~"'
+ echo 'PLATFORM="eu-q-titan-uk"'


./build_mw_epg.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --nomake
./make_image.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --project bskybgen2


={============================================================================
*kt_dev_skymw_0000* skymw-as-ap

<as-airplay>
/ethan-as-source/Components/AudioStreamer

<airplay-setting>
http://192.168.0.102:13579/index.html

<airplay-sdk-build>
/ethan-as-source/Components/AudioStreamer/AirplaySdk2

export LC_ALL=C
make libraries platform=Titan

<airplay-logging>

// from apple and prints two lines

acs_ulog(kLogLevelNotice, "KT: AudioConverterReset: ALAC: DO NOTHING \n");

NDS: ^0000000694.438133 !MIL   -AS           < p:00000e12 t:6e754dc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 
  > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:34.438098 AM [AirPlayACS] 
  KT: AudioConverterReset: ALAC: DO NOTHING 

// works by default and on MIL

at_app_ulog(kLogLevelNotice, "KT: kAirPlayProperty_NameIsFactoryDefault = %d\n", value);
  #define at_app_ulog(LEVEL, ...) ulog(at_app_ucat(), (LEVEL), __VA_ARGS__)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/AccessorySDK/Support/LogUtils.c
int LogPrintF(LogCategory* inCategory, const char* inFunction, LogLevel inLevel, const char* inFormat, ...)
{
    int n;
    va_list args;

    va_start(args, inFormat);
    n = LogPrintV(inCategory, inFunction, inLevel, inFormat, args);
    va_end(args);
    return (n);
}


// print single line

TRACE("KT: integration::checkNameIsFactoryDefault:\n");
  #define TRACE(...) { LogInterfaceInToDiag(0,__VA_ARGS__);}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp
void LogInterfaceInToDiag(int level,const char*format,...)
{
  char buffer[256];
  va_list args;
  va_start (args, format);
  vsnprintf (buffer,256,format, args);
  va_end (args);
  if (interfaceLoggingFunction != NULL)
    interfaceLoggingFunction(level,buffer);
}

AudioStreamer::AirPlayProtocol::AirPlayProtocol(uint8_t macAddress[6])
    : m_audioAvailable(true)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
  ::memcpy (m_macAddress, macAddress, 6);
  AirPlay::Player::createInstance(this);
  AirPlay::Player::instance().registerAirplaySDKDiagLogFunction(AirplaySDKDiagLog);
  AirPlay::Player::instance().registerInterfaceDiagLogFunction(AirplayinterfaceDiagLog);
#ifdef ENABLE_AIRPLAY_2
  dobbyPTPLxc = std::make_shared<ptpdobbyfactory::PtpDobbyFactory>("PTPAirplay");
#endif

  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
}

void AirplayinterfaceDiagLog(int level ,const char* msg)
{
  (void) level;
  printf("2---%s \n ",msg);
}


// fusion diag
// home/keitee/mw/ethan-as-source/Components/AS/Diag/include/AS_DIAG_Macros.h

#define AS_LOG_FATAL(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_FATAL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Fatal,writeFatal,handleFatal,msg);} while (0)
#define AS_LOG_MIL(msg...)      do {do {AS_DECLARE_FUNCTION;DIAG_LOG_MIL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Mil,writeMil,handleMil,msg);} while (0)
#define AS_LOG_ERROR(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_ERROR(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Error,writeError,handleError,msg);} while (0)
#define AS_LOG_WARNING(msg...)  do {do {AS_DECLARE_FUNCTION;DIAG_LOG_WARN(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Warning,writeWarning,handleWarning,msg);} while (0)
#define AS_LOG_INFO(msg...)     do {do {AS_DECLARE_FUNCTION;DIAG_LOG_INFO(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Info,writeInfo,handleInfo,msg);} while (0)
#define AS_LOG_ENTRY(msg...)    AS_LOG_INFO(msg)
#define AS_LOG_EXIT(msg...)     AS_LOG_INFO(msg)


<airplay-sdk>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayMain.c

int AirPlayMain( int argc, const char **argv )
{
  AirPlayReceiverServerCreate( &sgReceiverServer );

  AirPlayReceiverServerDelegateInit(&delegate);

  // register delegate to APRS
  delegate.copyProperty_f = _AirPlayHandleServerCopyProperty;
  delegate.setProperty_f = _AirPlayHandleServerSetProperty;
  delegate.sessionCreated_f = _AirPlayHandleSessionCreated;
  AirPlayReceiverServerSetDelegate(sgReceiverServer, &delegate);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c

AirPlayReceiverServerCreateWithConfigFilePath(CFStringRef inConfigFilePath, AirPlayReceiverServerRef* outServer)
{
}


// setup path

static OSStatus _HandleHTTPConnectionMessage(HTTPConnectionRef inCnx, HTTPMessageRef inRequest, void* inContext)
{
  aprs_ulog(kLogLevelTrace, "method:'%.*s' path:'%.*s'\n", (int)methodLen, methodPtr, (int)pathLen, pathPtr);

  else if (strnicmpx(methodPtr, methodLen, "SETUP") == 0)
    status = _requestProcessSetup(cnx, inRequest);
}

static HTTPStatus _requestProcessSetup(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
  status = _requestProcessSetupPlist(inCnx, inRequest);
}

static HTTPStatus _requestProcessSetupPlist(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
    aprs_ulog(kAirPlayPhaseLogLevel, "Setup (%##a)\n", &inCnx->httpCnx->peerAddr);
}

_requestCreateSession()
{
  AirPlayReceiverSessionCreate();
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c
AirPlayReceiverSessionCreate()
{
  err = AirPlayReceiverSessionPlatformInitialize(me);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c

OSStatus AirPlayReceiverServerPlatformInitialize(AirPlayReceiverServerRef inServer)
{}


// set audio stream

static OSStatus _UpdateStreams(AirPlayReceiverSessionRef inSession)
{
  atrp_ulog(kLogLevelNotice, "Main audio setting up %s for %@, input %s, loopback %s, volume:%f\n",
      AirPlayAudioFormatToString(streamCtx->format),
      streamCtx->audioType ? streamCtx->audioType : CFSTR(kAirPlayAudioType_Default),
      streamCtx->input ? "yes" : "no",
      streamCtx->loopback ? "yes" : "no",
      inSession->server->volume);

  // > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:37.199742 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-8.374125

  AudioStreamSetOutputCallback(streamCtx->stream, _AudioOutputCallBack, streamCtx);

  void AudioStreamSetOutputCallback(AudioStreamRef inStream, AudioStreamOutputCallback_f inFunc, void* inContext)
  {
    AudioStreamImpRef const me = _AudioStreamGetImp(inStream);
    TRACE("AudioStreamSetAudioCallback\n");

    me->callback = inFunc;
    me->callbackContext = inContext;
  }

  err = AudioStreamStart(streamCtx->stream);
}

// Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioUtilsStub.c
OSStatus AudioStreamPrepare(AudioStreamRef inStream)
{
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  _IMPL Trace.cpp(41) AudioStreamCreate
  _IMPL Trace.cpp(41) New AudioStreamPrivate=(nil)
  _IMPL Trace.cpp(41) AudioStreamSetAudioCallback
  _IMPL Trace.cpp(41) AudioStreamPrepare:
  _IMPL Trace.cpp(41) channels:      2
  _IMPL Trace.cpp(41) bits/channel:  16
  _IMPL Trace.cpp(41) sample rate:   44100
  _IMPL Trace.cpp(41) bytes/frame:   4
  _IMPL Trace.cpp(41) bytes/packet:  4
  _IMPL Trace.cpp(41) frames/packet: 1
  _IMPL Trace.cpp(41) format id:     6c70636d
  _IMPL Trace.cpp(41) format flags:  c
  _IMPL Trace.cpp(41) Signed
  _IMPL Trace.cpp(41) Little endian
  _IMPL Trace.cpp(41) audioSetFormat returning 1
}

OSStatus AudioStreamStart(AudioStreamRef inStream)
{
  // calls to intergration.cpp
  if( !sessionInitialize(inStream));
}


// get audio data
// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.cpp

void audioGetData(uint32_t sampleTime, uint64_t	hostTime, void *buffer, size_t bufferLen)
{
  TRACE("audioGetData(%d %llu %p %u)\n",  sampleTime, hostTime, buffer, bufferLen);

  s_audioStream->callback(sampleTime, hostTime, buffer, bufferLen, s_audioStream->callbackContext);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c
// callback is

static void
_AudioOutputCallBack(
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    void* inContext)
{
  AirPlayAudioStreamPlatformContext* const streamCtx = (AirPlayAudioStreamPlatformContext*)inContext;
  OSStatus err;

  atrp_ulog(kLogLevelNotice, "KT: _AudioOutputCallBack: inLen(%d)\n", inLen);

  err = AirPlayReceiverSessionReadAudio(streamCtx->session, streamCtx->activeType, inSampleTime, inHostTime,
      inBuffer, inLen);
  require_noerr(err, exit);

  if (streamCtx->input && streamCtx->loopback) {
    // not called in the log. use case?
    err = AirPlayReceiverSessionWriteAudio(streamCtx->session, streamCtx->activeType, inSampleTime, inHostTime,
        inBuffer, inLen);
    require_noerr(err, exit);
  }

exit:
  return;
}


// start path

// AudioStreamer/source/AirPlayProtocol.cpp

void AudioStreamer::AirPlayProtocol::enable(uint16_t port)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::enable");
  if( !AirPlay::Player::instance().supported() )
  {
    AUD_LOG_WARNING("Airplay not supported on this box, cannot enable");
    return;
  }
  AUD_LOG_INFO("Airplay supported, enabling");
  AirPlay::Player::instance().startAirPlay();
  AirPlay::Player::instance().registerHttpService("/index.html", port);
  AUD_LOG_MIL("Enable airplay done");
  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::enable");
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp

void AirPlay::PlayerImpl::startAirPlay()
{
  if( !m_airplayRunning )
  {
    TRACE("ASDK0218. AirPlayStartMain()\n");
    AirPlayStartMain();
    m_airplayRunning=true;
  }
}


={============================================================================
*kt_dev_skymw_0000* skymw-as-ap-jira

<NGDEV-141186>

// delegate if
else if (CFEqual(inProperty, CFSTR(kAirPlayKey_FirmwareRevision))) {

// [String] Firmware revision of the accessory.
#define kAirPlayKey_FirmwareRevision	"firmwareRevision"

have to use SPM_API_SYSINFO_PROPID_STB_SW_VER

// from http if
// [Boolean] Support sending UDP beacon as keep alive.
#define kAirPlayKey_KeepAliveLowPower "keepAliveLowPower"
need to change it to false

kAirPlayKey_KeepAliveSendStatsAsBody  387 AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c     CFDictionarySetValue(info, CFSTR(kAirPlayKey_KeepAliveSendStatsAsBody), kCFBooleanFalse); // Supports statistics as part of the keep alive body.

// from http if
// [Boolean] Whether the receiver supports statistics as part of the keep alive body.
#define kAirPlayKey_KeepAliveSendStatsAsBody "keepAliveSendStatsAsBody"
need to change it to false

// [Boolean] Returns true if the AirPlay name is the factory default name
#define kAirPlayProperty_NameIsFactoryDefault "nameIsFactoryDefault"

    else if (CFEqual(inProperty, CFSTR(kAirPlayKey_Name))) {

.654538 !MIL   -AS           < p:00000dec t:7a1fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 2019-05-16 10:40:41.629209 AM [AirtuneDelegate] <- Name being set is Sky4027  

<git-message>
NGDEV-141186: TITAN SPECIFIC - AIRPLAY 2 - CODH:  Airplay Cerfication Assistant
- STB firmware version is not updated correctly on Get/info Automated Test
    
The AirPlay Certification Assistant reports wrong information which are reported
from a box and Product team clarify requirement about them. The keys in question
are:

firmwareRevision – This should be the current MW version eg Q100.XXX.XXX.XXX
keepAliveLowPower – Should this be 0 as we don't support WoL
keepAliveSendStatsAsBody - Should this be 0 as we don't support WoL
kAirPlayProperty_NameIsFactoryDefault

This commit fixes these values to report correct values and add support for
kAirPlayProperty_NameIsFactoryDefault to report correctly based on names of
AirPlay network. 


<NGDEV-141186>

<decode>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c


typedef struct
{
	UInt32		mNumberChannels;
	UInt32		mDataByteSize;
	void *		mData;
	
}	AudioBuffer;

typedef struct
{
	UInt32			mNumberBuffers;
	AudioBuffer		mBuffers[ 1 ];
	
}	AudioBufferList;

_AudioDecoderDecodeFrame()
{
  // note that it is local
  AudioBufferList							bufferList;

  packetCount									= inSession->samplesPerFrame;

  bufferList.mNumberBuffers					= 1;
  bufferList.mBuffers[ 0 ].mNumberChannels	= ctx->channels;
  bufferList.mBuffers[ 0 ].mDataByteSize		= (uint32_t) inDstMaxLen;
  bufferList.mBuffers[ 0 ].mData				= inDstPtr;

  AudioConverterFillComplexBuffer(
      inSession->audioConverter, 
      _AudioDecoderDecodeCallback,  // pass function pointer
      inSession,
      &packetCount,                 // samples per frame 
      &bufferList,                  // buffer list
      NULL );
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioConverterStub.c
// called as many as needed to decode chunk of audio

AudioConverterFillComplexBuffer()
OSStatus AudioConverterFillComplexBuffer(
    AudioConverterRef inConverter, 
    AudioConverterComplexInputDataProc inInputDataProc,
    void* inInputDataProcUserData,
    uint32_t* ioOutputDataPacketSize,   // samples per frame
    AudioBufferList* outOutputData,     // buffer list
    AudioStreamPacketDescription* outPacketDescription)
{
  switch (me->sourceFormatID) {

    // ALAC
    case kAudioFormatAppleLossless:
      return _AudioConverterFillComplexBufferALACDecode(
          inConverter, 
          inInputDataProc, 
          inInputDataProcUserData, 
          ioOutputDataPacketSize,   // in/out, size to decode and size that decoded
          outOutputData, 
          outPacketDescription);

    case kAudioFormatMPEG4AAC:
      // AAC LC to PCM
      return _AudioConverterFillComplexBufferAACDecode(inConverter, inInputDataProc, inInputDataProcUserData, ioOutputDataPacketSize, outOutputData, outPacketDescription);

    default:
      return kUnsupportedErr;
  }
}

<flush>

static HTTPStatus _requestProcessFlushBuffered()
{
  err = AirPlayReceiverSessionFlushAudio(inCnx->session, flushFromP, flushUntil, &lastPlayedTS);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.h
// @abstract 
// Flush any queued audio until the specified timestamp or sequence number.

AirPlayReceiverSessionFlushAudio()
{
  err = AudioConverterReset(inSession->audioConverter);
}

// AP2 SDK

OSStatus AudioConverterReset(AudioConverterRef inConverter)
{
  (void)inConverter;

  // $$$ TODO: Discard any data buffered by the codec

  AudioConverterPrivateRef const me = (AudioConverterPrivateRef)inConverter;

  switch (me->sourceFormatID) {

    case kAudioFormatMPEG4AAC:
      _FlushAACDecoder(inConverter);
  }

  return (kNoErr);
}


// AP1 SDK

// AudioStreamer/AirplaySdk/AirPlayAudioPOSIXReceiver211.1.p8/Support/AudioConverterLite.c

OSStatus	AudioConverterReset_compat( AudioConverterRef me )
{
  (void) me;

  // Nothing to do here.

  return( kNoErr );
}

touch /opt/airplay/audio.out.pcm; chmod 777 /opt/airplay/audio.out.pcm
tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KT|AudioConverterDispose|AudioConverterNew"
tail -f LOG | egrep "AudioConverterDispose|AudioConverterNew"


#{============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
