*kt_dev_sky_mw*                                                     tw=100, utf-8

/^[#=]{
Use #{ for a group and ={ for a item

Write what you know and konw what you write. - EXC++, Herb Sutter

An expert is a man who has made all the mistakes that can be made, in a very
narrow field. -Nils Bohr

TODO:
2. how to implement shared_ptr for multi-threaded without using locks?
3. how to solve when there are same symbols in different objects in the same namespace?

KT KB. SKYMW

*kt_dev_skymw_0000* skymw-setup
*kt_dev_skymw_0000* skymw-pages
*kt_dev_skymw_0000* skymw-commands
*kt_dev_skymw_0000* skymw-q-hardware
*kt_dev_skymw_0000* skymw-q-package
*kt_dev_skymw_0000* skymw-q-build
*kt_dev_skymw_0000* skymw-as
*kt_dev_skymw_0000* skymw-as-ap
*kt_dev_skymw_0000* skymw-as-ap-jira
*kt_dev_skymw_0000* skymw-ai
*kt_dev_skymw_0000* skymw-android
*kt_dev_skymw_0000* skymw-android-doc
*kt_dev_skymw_0000* skymw-android-studio
*kt_dev_skymw_0000* skymw-android-bluetoothrcu
*kt_dev_skymw_0000* skymw-android-jira

={============================================================================
*kt_dev_skymw_0000* skymw-setup

<ssh>
to register ssh keys
https://www.stb.bskyb.com/gosa/


<repos>
git clone dwngit@git.stb.bskyb.com:ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-as-source ethan-as-source-repo
git clone dwngit@git.stb.bskyb.com:ethan-mw-wrt
git clone dwngit@git.stb.bskyb.com:appinfrastructure


<ethan-as-source>
// needs to run git pull since no default branch?
// "develop" branch

git pull origin develop

keitee@keitee-mint:~/mw/ethan-as-source$ git checkout develop
Checking out files: 100% (25967/25967), done.

// update submodule

keitee@keitee-mint:~/mw/ethan-as-source$ git submodule update --init --force

git push -n --set-upstream origin kit-NGDEV-141186

<sdk>
keitee@keitee-mint:~/mw/ethan-as-source$ cd xSubmoduleDarwinSDK/
keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK$ ./getSdk.sh eu-q-titan-uk HQ000


<tftp>
sudo apt-get install tftpd-hpa

cat /etc/default/tftpd-hpa 

# /etc/default/tftpd-hpa

TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/opt/tftpboot"
TFTP_ADDRESS=":69"
TFTP_OPTIONS="--secure"

<nfs>
sudo apt-get install nfs-kernel-server

<boot>

mount -o rw -t nfs 192.168.0.101:/home/keitee/mw/exports/titan/flash0 /mnt/x

// should be careful not to include the end of line when pasting it into bolt
// command line

setenv -p STARTUP "ifconfig eth0 -auto;boot 192.168.1.5:falcon_d1/zImage 'console=ttyS0,115200 ip=udhcp mesh=off vmalloc=334M brcm_cma_kern_rsv=416M remotedir=192.168.1.5:/export/flash0_falcon_d1'"

// shall have quote ""
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage"
// ok
setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.101:/titan/zImage ‘remotedir=192.168.0.101:/home/keitee/mw/exports/titan/flash0'"
// setenv -p STARTUP "ifconfig eth0 -auto; boot 192.168.0.100:titan/zImage console=ttyS0,115200 ip=udhcp vmalloc=300M brcm_cma_kern_rsv=450M remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0"

// error since copied from word document and found that dash(-) causes the
// issue when used on bolt bootloader
setenv -p STARTUP "ifconfig eth0 –auto; boot 192.168.0.100:/titan/zImage ‘remotedir=192.168.0.100:/home/keitee/mw/exports/titan/flash0'"


={============================================================================
*kt_dev_skymw_0000* skymw-pages

https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=2016&title=Application+Infrastructure+Architecture


={============================================================================
*kt_dev_skymw_0000* skymw-commands

ls -al /opt/airplay/audio.out.pcm
touch /opt/airplay/audio.out.pcm; chmod 777 /opt/airplay/audio.out.pcm
rm /mnt/nds/dev_13/part_0/FSN_DATA/LOG

cp /mnt/nds/dev_13/part_0/FSN_DATA/LOG /flash0/LOG_07; chmod 777 /flash0/LOG_07
cp /opt/airplay/audio.out.pcm /flash0/PCM_31; chmod 777 /flash0/PCM_31

tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KT|AudioConverterDispose|AudioConverterNew"
tail -f /mnt/nds/dev_13/part_0/FSN_DATA/LOG | egrep "KEY_P|Progress|rtpSkew"

curl -v -X POST http://127.0.0.1:8008/pm/downloads/ --data http://192.168.0.105/spotify.wgt

curl -v -X DELETE http://192.168.0.102:8008/pm/packages/com.spotify.Spotify.TVv2
curl -v -X GET http://192.168.0.102:8008/pm/packages
 
// to see ip
cat /proc/net/fib_trie


={============================================================================
*kt_dev_skymw_0000* skymw-git

<repo>
git clone ssh://kyoupark@mgt-ip100-gerrit.skyqstbbuild.com:29418/sky/platform/packages/apps/SkyBluetoothRcu


<git>
tag: NGDEV-141186_Delivered_Develop_07062019_1057
branch NGDEV-143556_IP100_Support_RCU_pairing_without_infrared

git checkout -b NGDEV-143556_review_03 develop
git push -n origin NGDEV-143556_IP100_Support_RCU_pairing_without_infrared
git push -f origin NGDEV-143556_review:NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_2
git push -f origin NGDEV-143556_review_03:NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_3

// no permission to do
// git push origin --delete NGDEV-143556_IP100_Support_RCU_pairing_without_infrared_2


<ex>
NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

Quote from
https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Bluetooth+RCU+Pairing+Without+Infrared:

In the v2.1.0 release of the SkyBluetoothRcu code for Android an experimental
feature was added in the debug builds to put the bluetooth code in 'searching'
mode for 30 seconds.  In search mode the code will look for any nearby BT RCU
devices that are in pairing mode, when / if found it will automatically start
pairing to it.   Only the first RCU found in pairing mode will trigger the STB
pairing code, subsequent found devices will be ignored (until 'searching' mode
is enalbed once again).

It works by looking for the special advertising packets sent by the BT RCU
when you hold the 1 and 3 buttons.  The BT RCU will send these special packets
for 10 seconds after entering pairing mode.


NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

Applies clang style, Mozilla, to files before a commit which has actual
changes so that can have clean base to show only differences to review. 



<git-message>
NGDEV-141186: TITAN SPECIFIC - AIRPLAY 2 - CODH:  Airplay Cerfication Assistant
- STB firmware version is not updated correctly on Get/info Automated Test
    
The AirPlay Certification Assistant reports wrong information which are reported
from a box and Product team clarify requirement about them. The keys in question
are:

firmwareRevision – This should be the current MW version eg Q100.XXX.XXX.XXX
keepAliveLowPower – Should this be 0 as we don't support WoL
keepAliveSendStatsAsBody - Should this be 0 as we don't support WoL
kAirPlayProperty_NameIsFactoryDefault

This commit fixes these values to report correct values and add support for
kAirPlayProperty_NameIsFactoryDefault to report correctly based on names of
AirPlay network. 

keitee@keitee-mint:~/mw/ethan-as-source/Components$ git diff --ignore-space-at-eol --stat origin/develop..HEAD
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayDelegate.c | 112 ++--------------------------------------------------------------------------------------
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.cpp   |  12 ++++++++++
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.h     |   4 +---
 // Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c |   5 ++--
 // Components/AudioStreamer/AirplaySdk2/include/AirPlayPlayer.h                      |   5 +++-
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/daemon_cl                   | Bin 3284680 -> 3282536 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libAirPlay.a                | Bin 1390526 -> 1388298 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libAirPlayPlatform.a        | Bin 467130 -> 466692 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libCoreUtils.a              | Bin 4036690 -> 4025966 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/libdns_sd.a                 | Bin 27338 -> 27338 bytes
 Components/AudioStreamer/AirplaySdk2/libs/bskyb-titan/mdnsd                       | Bin 326396 -> 326396 bytes
 // Components/AudioStreamer/source/AirPlayProtocol.cpp                               |  12 ++++++++++
 // Components/AudioStreamer/source/AirPlayProtocol.h                                 |   2 +-
 // Components/AudioStreamer/source/AudioStreamerPlayer.cpp                           |   6 ++---
 // Components/AudioStreamer/source/AudioStreamerPlayer.h                             |  11 +++++----
 Components/AudioStreamer/source/AudioStreamerProxy.cpp                            |   0
 Components/AudioStreamer/source/MwServices.cpp                                    |   8 +++----
 18 files changed, 53 insertions(+), 129 deletions(-)


={============================================================================
*kt_dev_skymw_0000* skymw-q-hardware

// q hardware
https://www.stb.bskyb.com/confluence/display/2016/Q+Platform+Hardware+Specifications


={============================================================================
*kt_dev_skymw_0000* skymw-q-package

// fusion mw
// Check the SI_TARBALL.tgz at the bottom of the page.
http://hudkinsartifactory.cisco.com:8081/artifactory/formal_builds/Q/formal/Q000/Q000.021.41.00/


={============================================================================
*kt_dev_skymw_0000* skymw-q-build

<to-fix-titan-build-error>
export LC_ALL=C

as: loadlocale.c:129: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))' failed.
arm-linux-gcc: internal compiler error: Aborted (program as)
Please submit a full bug report,
with preprocessed source if appropriate.
See <http://gcc.gnu.org/bugs.html> for instructions.


<build-sdk>
cd /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK
./compile_sdkv2.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/ clean
./compile_sdkv2.0.sh eu-q-titan-uk /home/keitee/mw/ethan-as-source/

keitee@keitee-mint:~/mw/ethan-as-source/xSubmoduleDarwinSDK$ 

ll eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_OUTPUT_DEL_BSKYB_2/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/FUSIONOS_BSKYB_2/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

// all points the same single file

ll eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage 
-rwxr-xr-x 1 keitee keitee 25M May 14 10:41 eu-q-titan-uk/SDK/deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*

ll eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage 
lrwxrwxrwx 1 keitee keitee 129 May 14 10:41 eu-q-titan-uk/SDK/SKYOB_SKY7278_BCM7278_LNUX_01/BLD_SKYOB_SKY7278_BCM7278_LNUX_01/platform_cfg/linux/LittleEndian/debug/BootImage/zImage -> ../../../../../../deps/SKYOB_SKY7278_BCM7278_LNUX_01/KERN_SKYOB_SKY7278_BCM7278_LNUX_01/LittleEndian/debug/debug/BootImage/zImage*


<build-tool> *builc-gcc*
~/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gcc

lrwxrwxrwx 1 keitee keitee 31 May 14 10:41 arm-linux-gcc -> arm-unknown-linux-gnueabihf-gcc*

/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01

<gcc>
export LC_ALL=C
cp /home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/unstripped_bin/APP_Process .
/home/keitee/mw/ethan-as-source/xSubmoduleDarwinSDK/eu-q-titan-uk/SDK/deps/SYSTEM_BIN_4/brcm_gcc_arm_x86_linux_01/bin/arm-linux-gdb


<fsi-build>
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/
svn ls svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/
svn checkout svn+ssh://dwnsvn@git.stb.bskyb.com/2016_middleware/tags/Q000/Q000.021.45.00/

http://10.184.136.138:8081/view/SI%20build%20Jobs/job/FULL_STACK_SI_BUILD/69/consoleFull

+ cd FUSION_SYSTEM_INTEGRATION/BSKYB_ETHAN/build/
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials
+ ./make.sh --platform eu-q-titan-uk --profile sky_trials --baseline Q000.021.42.00

+ create_version_string_from_baseline
+ local VERSION_CFG=projects/bskybgen2/fs/NDS/config/overrides/version.cfg
+ local VERSION_H=projects/bskybgen2/inc/version.h
+ local 'VERSION_SECTION=[VERSION]'
+ local VERSION_TAG=NDS_SW_VERSION
+ local PLATFORM_TAG=PLATFORM
+ echo 'Checking & calculating Version string - '\''sky_trials'\'' '\'''\'''
Checking & calculating Version string - 'sky_trials' ''
python tools/nds/si/python/version_string_calculation.py ${PROFILE} ${BASELINE}
++ python tools/nds/si/python/version_string_calculation.py sky_trials
+ VERSION_STRING='~*~dev version~*~'
+ '[' 0 -ne 0 ']'
+ echo 'VERSION = ~*~dev version~*~'
VERSION = ~*~dev version~*~
+ echo '[VERSION]'
+ echo 'NDS_SW_VERSION="~*~dev version~*~"'
+ echo 'PLATFORM="eu-q-titan-uk"'


./build_mw_epg.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --nomake
./make_image.sh --platform eu-q-titan-uk --variant debug --profile sky_trials --project bskybgen2


={============================================================================
*kt_dev_skymw_0000* skymw-as

https://www.stb.bskyb.com/confluence/pages/viewpage.action?pageId=9538192

<as-rest> <as-asda>
http://build01.mw.ethan.bskyb.com/asda/#

192.168.0.104:9005

curl -v -X GET http://192.168.0.102:9005/as/system/information

curl -v -X GET http://192.168.0.102:8008/pm/packages


={============================================================================
*kt_dev_skymw_0000* skymw-as-ap

<as-airplay>
/ethan-as-source/Components/AudioStreamer

<airplay-setting>
http://192.168.0.102:13579/index.html

<airplay-sdk-build>
/ethan-as-source/Components/AudioStreamer/AirplaySdk2

export LC_ALL=C
make libraries platform=Titan

<airplay-logging>

// from apple and prints two lines

acs_ulog(kLogLevelNotice, "KT: AudioConverterReset: ALAC: DO NOTHING \n");

NDS: ^0000000694.438133 !MIL   -AS           < p:00000e12 t:6e754dc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 
  > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:34.438098 AM [AirPlayACS] 
  KT: AudioConverterReset: ALAC: DO NOTHING 

// works by default and on MIL

at_app_ulog(kLogLevelNotice, "KT: kAirPlayProperty_NameIsFactoryDefault = %d\n", value);
  #define at_app_ulog(LEVEL, ...) ulog(at_app_ucat(), (LEVEL), __VA_ARGS__)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/AccessorySDK/Support/LogUtils.c
int LogPrintF(LogCategory* inCategory, const char* inFunction, LogLevel inLevel, const char* inFormat, ...)
{
    int n;
    va_list args;

    va_start(args, inFormat);
    n = LogPrintV(inCategory, inFunction, inLevel, inFormat, args);
    va_end(args);
    return (n);
}


// print single line

TRACE("KT: integration::checkNameIsFactoryDefault:\n");
  #define TRACE(...) { LogInterfaceInToDiag(0,__VA_ARGS__);}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp
void LogInterfaceInToDiag(int level,const char*format,...)
{
  char buffer[256];
  va_list args;
  va_start (args, format);
  vsnprintf (buffer,256,format, args);
  va_end (args);
  if (interfaceLoggingFunction != NULL)
    interfaceLoggingFunction(level,buffer);
}

AudioStreamer::AirPlayProtocol::AirPlayProtocol(uint8_t macAddress[6])
    : m_audioAvailable(true)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
  ::memcpy (m_macAddress, macAddress, 6);
  AirPlay::Player::createInstance(this);
  AirPlay::Player::instance().registerAirplaySDKDiagLogFunction(AirplaySDKDiagLog);
  AirPlay::Player::instance().registerInterfaceDiagLogFunction(AirplayinterfaceDiagLog);
#ifdef ENABLE_AIRPLAY_2
  dobbyPTPLxc = std::make_shared<ptpdobbyfactory::PtpDobbyFactory>("PTPAirplay");
#endif

  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::AirPlayProtocol");
}

void AirplayinterfaceDiagLog(int level ,const char* msg)
{
  (void) level;
  printf("2---%s \n ",msg);
}


// fusion diag
// home/keitee/mw/ethan-as-source/Components/AS/Diag/include/AS_DIAG_Macros.h

#define AS_LOG_FATAL(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_FATAL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Fatal,writeFatal,handleFatal,msg);} while (0)
#define AS_LOG_MIL(msg...)      do {do {AS_DECLARE_FUNCTION;DIAG_LOG_MIL(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Mil,writeMil,handleMil,msg);} while (0)
#define AS_LOG_ERROR(msg...)    do {do {AS_DECLARE_FUNCTION;DIAG_LOG_ERROR(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Error,writeError,handleError,msg);} while (0)
#define AS_LOG_WARNING(msg...)  do {do {AS_DECLARE_FUNCTION;DIAG_LOG_WARN(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Warning,writeWarning,handleWarning,msg);} while (0)
#define AS_LOG_INFO(msg...)     do {do {AS_DECLARE_FUNCTION;DIAG_LOG_INFO(AS_DIAG_SEG_ID,(msg));} while (0); AS_DIAG_CONTEXT_TEST(AS_DIAG_CONTEXT_DEFAULT,AS_DIAG::Info,writeInfo,handleInfo,msg);} while (0)
#define AS_LOG_ENTRY(msg...)    AS_LOG_INFO(msg)
#define AS_LOG_EXIT(msg...)     AS_LOG_INFO(msg)

However, there seems to be an issue:
m_total shows 0. WHY?

    AUD_LOG_MIL("KT: get Data from buffer, sampleCount(%d), m_total(%d), dataToCopy(%d)", sampleCount, m_total, dataToCopy);
    AUD_LOG_MIL("KT: get Data from buffer, sampleCount(%d)", sampleCount);
    AUD_LOG_MIL("KT: get Data from buffer, m_total(%d)", m_total);

NDS: ^0000000222.561686 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(762) KT: get Data from buffer, sampleCount(0), m_total(0), dataToCopy(8820)
NDS: ^0000000222.561700 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(763) KT: get Data from buffer, sampleCount(0)
NDS: ^0000000222.561714 !MIL   -AS           < p:00000f6f t:7ae99dc0 T:AUS_AudioThread M:AS_DMS_Writer.cpp F:pushDataToPlayer L:00258 > @ctx:fallback AudioThread.cpp(764) KT: get Data from buffer, m_total(8820)


<airplay-sdk>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayMain.c

int AirPlayMain( int argc, const char **argv )
{
  AirPlayReceiverServerCreate( &sgReceiverServer );

  AirPlayReceiverServerDelegateInit(&delegate);

  // register delegate to APRS
  delegate.copyProperty_f = _AirPlayHandleServerCopyProperty;
  delegate.setProperty_f = _AirPlayHandleServerSetProperty;
  delegate.sessionCreated_f = _AirPlayHandleSessionCreated;
  AirPlayReceiverServerSetDelegate(sgReceiverServer, &delegate);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c

AirPlayReceiverServerCreateWithConfigFilePath(CFStringRef inConfigFilePath, AirPlayReceiverServerRef* outServer)
{
}


// setup path

static OSStatus _HandleHTTPConnectionMessage(HTTPConnectionRef inCnx, HTTPMessageRef inRequest, void* inContext)
{
  aprs_ulog(kLogLevelTrace, "method:'%.*s' path:'%.*s'\n", (int)methodLen, methodPtr, (int)pathLen, pathPtr);

  else if (strnicmpx(methodPtr, methodLen, "SETUP") == 0)
    status = _requestProcessSetup(cnx, inRequest);
}

static HTTPStatus _requestProcessSetup(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
  status = _requestProcessSetupPlist(inCnx, inRequest);
}

static HTTPStatus _requestProcessSetupPlist(AirPlayReceiverConnectionRef inCnx, HTTPMessageRef inRequest)
{
    aprs_ulog(kAirPlayPhaseLogLevel, "Setup (%##a)\n", &inCnx->httpCnx->peerAddr);
}

_requestCreateSession()
{
  AirPlayReceiverSessionCreate();
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c
AirPlayReceiverSessionCreate()
{
  err = AirPlayReceiverSessionPlatformInitialize(me);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c

OSStatus AirPlayReceiverServerPlatformInitialize(AirPlayReceiverServerRef inServer)
{}


// set audio stream

static OSStatus _UpdateStreams(AirPlayReceiverSessionRef inSession)
{
  atrp_ulog(kLogLevelNotice, "Main audio setting up %s for %@, input %s, loopback %s, volume:%f\n",
      AirPlayAudioFormatToString(streamCtx->format),
      streamCtx->audioType ? streamCtx->audioType : CFSTR(kAirPlayAudioType_Default),
      streamCtx->input ? "yes" : "no",
      streamCtx->loopback ? "yes" : "no",
      inSession->server->volume);

  // > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 1970-01-01 12:11:37.199742 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-8.374125

  AudioStreamSetOutputCallback(streamCtx->stream, _AudioOutputCallBack, streamCtx);

  void AudioStreamSetOutputCallback(AudioStreamRef inStream, AudioStreamOutputCallback_f inFunc, void* inContext)
  {
    AudioStreamImpRef const me = _AudioStreamGetImp(inStream);
    TRACE("AudioStreamSetAudioCallback\n");

    me->callback = inFunc;
    me->callbackContext = inContext;
  }

  err = AudioStreamStart(streamCtx->stream);
}

// Components/AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioUtilsStub.c
OSStatus AudioStreamPrepare(AudioStreamRef inStream)
{
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  Trace.cpp(25) 1970-01-01 12:06:46.573261 AM [AirPlay] Main audio setting up ALAC/44100/16/2 for default, input no, loopback no, volume:-21.002514
  _IMPL Trace.cpp(41) AudioStreamCreate
  _IMPL Trace.cpp(41) New AudioStreamPrivate=(nil)
  _IMPL Trace.cpp(41) AudioStreamSetAudioCallback
  _IMPL Trace.cpp(41) AudioStreamPrepare:
  _IMPL Trace.cpp(41) channels:      2
  _IMPL Trace.cpp(41) bits/channel:  16
  _IMPL Trace.cpp(41) sample rate:   44100
  _IMPL Trace.cpp(41) bytes/frame:   4
  _IMPL Trace.cpp(41) bytes/packet:  4
  _IMPL Trace.cpp(41) frames/packet: 1
  _IMPL Trace.cpp(41) format id:     6c70636d
  _IMPL Trace.cpp(41) format flags:  c
  _IMPL Trace.cpp(41) Signed
  _IMPL Trace.cpp(41) Little endian
  _IMPL Trace.cpp(41) audioSetFormat returning 1
}

OSStatus AudioStreamStart(AudioStreamRef inStream)
{
  // calls to intergration.cpp
  if( !sessionInitialize(inStream));
}


<airplay-config>

// AudioStreamer/config/audiostreamer.xml

 151   │    <!--NGDEV-140292:Update audiostreamer.xml to support Titan UK-->
 152   │    <profile name="EE_GW_UK_TITAN">
 153   │    <file name="audiostreamer.cfg">
 154   │    <section name="SYSTEM_DELAY_CONFIG">
 155   │     <key name="SYSTEM_DELAY" type="INTEGER" value="137">
 156   │         <comment date="2019/05/16 10:13:45" text="NGDEV-141515 The time in mS to provide system delay. This will be used in the calculation of inHostTime" />
 157   │     </key>
 158   │    </section>
 159   │    <section name="PCM_CONFIGURATION">
 160   │     <key name="PCM_BUFFERSIZE" type="INTEGER" value="100">
 161   │     <comment date="2017/01/19 01:23:45" text="The time in ms" />
 162   │     </key>
 163   │     <key name="PCM_THRESHOLD" type="INTEGER" value="50">
 164   │     <comment date="2017/01/19 01:23:45" text="The time in ms" />
 

<airplay-get-audio-data>

// AudioStreamer/source/AudioThread.cpp

case EVENT_SESSION_START:
{
  PLAYER_API_SessionHandle* sessionId = (PLAYER_API_SessionHandle*)t.data;

  string sourceUri = AsStringTool::stringf("audio/cisco.com_pcm;rate=%d;channels=%d;samplesize=%d;byteorder=%s;sign=%s", 
      m_format.sampleRate, m_format.channels, m_format.sampleSizeBytes*8, m_format.bigEndian?"be":"le", m_format.isSigned?"signed":"unsigned");
  AUD_LOG_MIL("AudioThread::EVENT_SESSION_START id=0x%08X, adding source='%s'", *sessionId, sourceUri.c_str());
  ret = PLAYER_API_AVControl_AddSourceBuffer(playerAvControl, sourceUri.c_str(), &m_avControlBufferHandle);
}

// CMS_MEDIA_SERVICES/MPM/inc/mpm_pres.h

/** @brief Structure that contains properties of a NEED_DATA callback for use in MPM_PRES_ES_EVENT_PROPERTIES */
typedef struct
{
    uint32_t    data_length;        /*!< @brief The amount of data that can be written to the device */
    uint32_t    current_level;      /*!< @brief The current buffer level on the output device */
    uint32_t    cumulative_bytes;   /*!< @brief The total amount of bytes written to this handle */
} MPM_PRES_ES_EVENT_NEED_DATA_PROPERTIES;

// DARWIN_PLATFORM/DARWIN_PLAYER/inc/player_api_events.h

#define PLAYER_EVENT_AUDIO_NEED_DATA                (0x22000000U)   
/**< Notification sent when the buffer created with PLAYER_API_AVControl_AddSourceBuffer needs more
 * data. Application should provide more data through PLAYER_API_AVControl_AppendToBuffer */

typedef struct
{
  uint32_t length;
  uint32_t buffer_level;
  uint32_t bytes_received;
} PLAYER_PRIV_EVENT_NEED_DATA;

ret = PLAYER_API_Session_RegisterEventListener(playerSession,PLAYER_EVENT_AUDIO_NEED_DATA,playerEventListener,PLAYER_API_TAG(this),&dataEventListenerHandle);

struct event_data_type
{
  uint32_t                 eventType;

  /* PLAYER_EVENT_AUDIO_NEED_DATA */
  uint32_t                 audioLength;
  uint32_t                 bufferLevel;
  uint32_t                 bytesReceived;

  /* PLAYER_EVENT_SESSION_START */
  PLAYER_API_SessionHandle sessionId;
};

handlePlayerEventNeedData(event_data, audioThread, event);

static void handlePlayerEventNeedData(event_data_type &event_data , AudioStreamer::AudioThread* audioThread,PLAYER_API_Event_Handle event)

audioThread->onPlayerNeedData(event_data.audioLength, event_data.bufferLevel, event_data.bytesReceived);

void AudioStreamer::AudioThread::onPlayerNeedData(uint32_t dataNeeded, uint32_t bufferLevel, uint32_t totalPlayed);

case EVENT_NEED_DATA:
  handlePlayerNeedData(arg->dataNeeded, arg->bufferLevel, arg->totalPlayed);

case EVENT_PUSH_DATA:
  pushDataToPlayer(arg->dataNeeded, arg->bufferLevel, arg->totalPlayed);

void AudioStreamer::AudioThread::pushDataToPlayer(uint32_t dataNeeded, uint32_t bufferLevel, uint32_t totalPlayed)
{
  currentInstance->audioBufferGet(sampleCount, UpTicks()+inHostTime, m_buffer, dataToCopy);
}

/*
 *AirPlayProtocol getAudioData
 *
 * inParam :
 *      sampleTime :- uint32_t , Time in terms of samples , mostly how many samples consumed till now indicate
 *                              how much time has elapsed. 4410 samples indicate 100ms
 *      hostTime      :- uint64_t , Approximate time when first sample will be played . Needs to as accurate as possible
 *                              and any variation of more than 5 ms will lead audio sync delay b/w apple devices
 *      buffer           :- void * , buffer memory allocated and managed by client
 *      bufferLen     :- size_t , length of buffer which also indicate the amount of data needs to be copied in bytes
 *
 * Function Breif :
 *       Get audio data from airplay SDK
 */
void AudioStreamer::AirPlayProtocol::getAudioData(uint32_t sampleTime, uint64_t hostTime, void *buffer, size_t bufferLen)

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/integration.cpp

void audioGetData(uint32_t sampleTime, uint64_t	hostTime, void *buffer, size_t bufferLen)
{
  TRACE("audioGetData(%d %llu %p %u)\n",  sampleTime, hostTime, buffer, bufferLen);

  s_audioStream->callback(sampleTime, hostTime, buffer, bufferLen, s_audioStream->callbackContext);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverPOSIX.c
// callback is

static void
_AudioOutputCallBack(
    uint32_t inSampleTime,          // sample time
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    void* inContext)
{
  AirPlayAudioStreamPlatformContext* const streamCtx = (AirPlayAudioStreamPlatformContext*)inContext;
  OSStatus err;

  atrp_ulog(kLogLevelNotice, "KT: _AudioOutputCallBack: inLen(%d)\n", inLen);
  //  AM [AirPlay] KT: _AudioOutputCallBack: inLen(8820)

  err = AirPlayReceiverSessionReadAudio(streamCtx->session, streamCtx->activeType, 
      inSampleTime,                 // 3. sample time 
      inHostTime,
      inBuffer, 
      inLen);
  require_noerr(err, exit);

  if (streamCtx->input && streamCtx->loopback) {
    // not called in the log. use case?
    err = AirPlayReceiverSessionWriteAudio(streamCtx->session, streamCtx->activeType, inSampleTime, inHostTime,
        inBuffer, inLen);
    require_noerr(err, exit);
  }

exit:
  return;
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c

OSStatus
AirPlayReceiverSessionReadAudio(
    AirPlayReceiverSessionRef inSession,
    AirPlayStreamType inType,
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen)
{
  return AirPlayReceiverSessionReadAudio2(
      inSession, 
      inType, 
      inSampleTime, 
      inHostTime, 
      inBuffer, 
      inLen, 
      inLen,                  // 7
      NULL);
}

AirPlayReceiverSessionReadAudio2(
    AirPlayReceiverSessionRef inSession,
    AirPlayStreamType inType,
    uint32_t inSampleTime,
    uint64_t inHostTime,
    void* inBuffer,
    size_t inLen,
    size_t inMinLen,          // 7
    size_t* outSuppliedLen)
{
  suppliedLen = _GeneralAudioRender(inSession, inSampleTime, inBuffer, inLen, inMinLen);
}

static size_t _GeneralAudioRender(
    AirPlayReceiverSessionRef inSession, 
    uint32_t inRTPTime,             // sample time
    void* inBuffer, 
    size_t inSize, 
    size_t inMinFillSize)
{
  // o inMinLen is date bytes for 50ms 
  //
  // o ctx->sampleTimeOffset is 0 so has no effect
  //
  // o srcTS = pktTS. what's unit?
  //
  // o minTS == limTS

  nowTS = inRTPTime - ctx->sampleTimeOffset;
  limTS = nowTS + (uint32_t)(inSize / bytesPerUnit);
  minTS = nowTS + (uint32_t)(inMinFillSize / bytesPerUnit);
  maxTS = limTS + kAirTunesRTPOffsetApplyThreshold;
  pktSeq = 0;

  // sample time
  //
  // #define kAirTunesPlayoutDelay 11025 // 250 ms delay to sync with AirPort Express'es 250 ms buffer.
  // inCnx->minLatency = kAirTunesPlayoutDelay; // Default value for old clients.
  //
  // AirPlayReceiverSessionSetProperty()
  //  gAirTunesRelativeTimeOffset = offset;

  inSession->audioLatencyOffset = inSession->minLatency + gAirTunesRelativeTimeOffset;

  // uint32_t rtpOffsetActive; // RTP offset actively in use (different when deferring).
  //
  // static void AirPlayReceiverFlushPackets(AirPlayReceiverSessionRef inSession, AirPlayFlushPoint const* flushFrom, AirPlayFlushPoint flushUntil)
  //  uint32_t offsetActive = inSession->source.rtpOffsetActive;
}


// start path

// AudioStreamer/source/AirPlayProtocol.cpp

void AudioStreamer::AirPlayProtocol::enable(uint16_t port)
{
  AUD_LOG_ENTRY("AudioStreamer::AirPlayProtocol::enable");
  if( !AirPlay::Player::instance().supported() )
  {
    AUD_LOG_WARNING("Airplay not supported on this box, cannot enable");
    return;
  }
  AUD_LOG_INFO("Airplay supported, enabling");
  AirPlay::Player::instance().startAirPlay();
  AirPlay::Player::instance().registerHttpService("/index.html", port);
  AUD_LOG_MIL("Enable airplay done");
  AUD_LOG_EXIT("AudioStreamer::AirPlayProtocol::enable");
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AirPlayPlayerImpl.cpp

void AirPlay::PlayerImpl::startAirPlay()
{
  if( !m_airplayRunning )
  {
    TRACE("ASDK0218. AirPlayStartMain()\n");
    AirPlayStartMain();
    m_airplayRunning=true;
  }
}


<airplay-progress>
NDS: ^0000000452.250604 !MIL   -AS           < p:00000de7 t:7a3fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplayinterfaceDiagLog L:00258 > 
  @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(41) Progress, duration 39 elapsed 9


={============================================================================
*kt_dev_skymw_0000* skymw-as-ap-jira

<NGDEV-141186>

// delegate if
else if (CFEqual(inProperty, CFSTR(kAirPlayKey_FirmwareRevision))) {

// [String] Firmware revision of the accessory.
#define kAirPlayKey_FirmwareRevision	"firmwareRevision"

have to use SPM_API_SYSINFO_PROPID_STB_SW_VER

// from http if
// [Boolean] Support sending UDP beacon as keep alive.
#define kAirPlayKey_KeepAliveLowPower "keepAliveLowPower"
need to change it to false

kAirPlayKey_KeepAliveSendStatsAsBody  387 AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverServer.c     CFDictionarySetValue(info, CFSTR(kAirPlayKey_KeepAliveSendStatsAsBody), kCFBooleanFalse); // Supports statistics as part of the keep alive body.

// from http if
// [Boolean] Whether the receiver supports statistics as part of the keep alive body.
#define kAirPlayKey_KeepAliveSendStatsAsBody "keepAliveSendStatsAsBody"
need to change it to false

// [Boolean] Returns true if the AirPlay name is the factory default name
#define kAirPlayProperty_NameIsFactoryDefault "nameIsFactoryDefault"

    else if (CFEqual(inProperty, CFSTR(kAirPlayKey_Name))) {

.654538 !MIL   -AS           < p:00000dec t:7a1fedc0 T:no name M:AS_DMS_Writer.cpp F:AirplaySDKDiagLog L:00258 > @ctx:AS_AUDIOSTREAMER_IMPL Trace.cpp(25) 2019-05-16 10:40:41.629209 AM [AirtuneDelegate] <- Name being set is Sky4027  


<NGDEV-141186>

<decode>

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.c


typedef struct
{
	UInt32		mNumberChannels;
	UInt32		mDataByteSize;
	void *		mData;
	
}	AudioBuffer;

typedef struct
{
	UInt32			mNumberBuffers;
	AudioBuffer		mBuffers[ 1 ];
	
}	AudioBufferList;

_AudioDecoderDecodeFrame()
{
  // note that it is local
  AudioBufferList							bufferList;

  packetCount									= inSession->samplesPerFrame;

  bufferList.mNumberBuffers					= 1;
  bufferList.mBuffers[ 0 ].mNumberChannels	= ctx->channels;
  bufferList.mBuffers[ 0 ].mDataByteSize		= (uint32_t) inDstMaxLen;
  bufferList.mBuffers[ 0 ].mData				= inDstPtr;

  AudioConverterFillComplexBuffer(
      inSession->audioConverter, 
      _AudioDecoderDecodeCallback,  // pass function pointer
      inSession,
      &packetCount,                 // samples per frame 
      &bufferList,                  // buffer list
      NULL );
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/PlatformEthan/AudioConverterStub.c
// called as many as needed to decode chunk of audio

AudioConverterFillComplexBuffer()
OSStatus AudioConverterFillComplexBuffer(
    AudioConverterRef inConverter, 
    AudioConverterComplexInputDataProc inInputDataProc,
    void* inInputDataProcUserData,
    uint32_t* ioOutputDataPacketSize,   // samples per frame
    AudioBufferList* outOutputData,     // buffer list
    AudioStreamPacketDescription* outPacketDescription)
{
  switch (me->sourceFormatID) {

    // ALAC
    case kAudioFormatAppleLossless:
      return _AudioConverterFillComplexBufferALACDecode(
          inConverter, 
          inInputDataProc, 
          inInputDataProcUserData, 
          ioOutputDataPacketSize,   // in/out, size to decode and size that decoded
          outOutputData, 
          outPacketDescription);

    case kAudioFormatMPEG4AAC:
      // AAC LC to PCM
      return _AudioConverterFillComplexBufferAACDecode(inConverter, inInputDataProc, inInputDataProcUserData, ioOutputDataPacketSize, outOutputData, outPacketDescription);

    default:
      return kUnsupportedErr;
  }
}

<flush>

static HTTPStatus _requestProcessFlushBuffered()
{
  err = AirPlayReceiverSessionFlushAudio(inCnx->session, flushFromP, flushUntil, &lastPlayedTS);
}

// AudioStreamer/AirplaySdk2/AirPlaySDK_2/Sources/AirPlayReceiverSession.h
// @abstract 
// Flush any queued audio until the specified timestamp or sequence number.

AirPlayReceiverSessionFlushAudio()
{
  err = AudioConverterReset(inSession->audioConverter);
}

// AP2 SDK

OSStatus AudioConverterReset(AudioConverterRef inConverter)
{
  (void)inConverter;

  // $$$ TODO: Discard any data buffered by the codec

  AudioConverterPrivateRef const me = (AudioConverterPrivateRef)inConverter;

  switch (me->sourceFormatID) {

    case kAudioFormatMPEG4AAC:
      _FlushAACDecoder(inConverter);
  }

  return (kNoErr);
}


// AP1 SDK

// AudioStreamer/AirplaySdk/AirPlayAudioPOSIXReceiver211.1.p8/Support/AudioConverterLite.c

OSStatus	AudioConverterReset_compat( AudioConverterRef me )
{
  (void) me;

  // Nothing to do here.

  return( kNoErr );
}

// from LOG

KT: audioGetData(0 230596533307 0x78f3597c 8820)
KT: audioGetData(2205 230646111351 0x78f3597c 8820)
KT: audioGetData(4410 230696437499 0x78f3597c 8820)
KT: audioGetData(6615 230746918462 0x78f3597c 8820)
KT: audioGetData(8820 230796348590 0x78f3597c 8820)
KT: audioGetData(11025 230846362117 0x78f3597c 8820)
KT: audioGetData(13230 230896336344 0x78f3597c 8820)
KT: audioGetData(15435 230946897891 0x78f3597c 8820)
KT: audioGetData(17640 230996312937 0x78f3597c 8820)
KT: audioGetData(19845 231046380775 0x78f3597c 8820)
KT: audioGetData(22050 231096312862 0x78f3597c 8820)

>>> 985635-983430
2205
>>> 2205-1595
610
>>> 610/44.1
13.83219954648526 ~~ 14ms but 26ms in PCM output?

985635, 22.350
18051:NDS: ^0000000252.850650 !MIL   -AS           < 1970-01-01 12:04:12.850632 AM [AirPlay] Concealed 1595 unit gap (985635 vs 987230), curr seq 26233
18052:NDS: ^0000000252.850667 !MIL   -AS           < 1970-01-01 12:04:12.850632 AM [AirPlay] Concealed 1595 unit gap (985635 vs 987230), curr seq 26233

25016:NDS: ^0000000264.298628 !MIL   -AS           < 1970-01-01 12:04:24.298610 AM [AirPlay] Concealed 2042 unit gap (1490580 vs 1492622), curr seq 27667
25017:NDS: ^0000000264.298645 !MIL   -AS           < 1970-01-01 12:04:24.298610 AM [AirPlay] Concealed 2042 unit gap (1490580 vs 1492622), curr seq 27667

31732:NDS: ^0000000275.496637 !MIL   -AS          < 1970-01-01 12:04:35.496619 AM [AirPlay] Concealed 1612 unit gap (1984500 vs 1986112), curr seq 29063
31733:NDS: ^0000000275.496655 !MIL   -AS          < 1970-01-01 12:04:35.496619 AM [AirPlay] Concealed 1612 unit gap (1984500 vs 1986112), curr seq 29063

37098:NDS: ^0000000284.702606 !MIL   -AS          < 1970-01-01 12:04:44.702588 AM [AirPlay] Concealed 727 unit gap (2390220 vs 2390947), curr seq 30209
37099:NDS: ^0000000284.702624 !MIL   -AS          < 1970-01-01 12:04:44.702588 AM [AirPlay] Concealed 727 unit gap (2390220 vs 2390947), curr seq 30209

43855:NDS: ^0000000295.902600 !MIL   -AS          < 1970-01-01 12:04:55.902582 AM [AirPlay] Concealed 302 unit gap (2884140 vs 2884442), curr seq 31608
43856:NDS: ^0000000295.902618 !MIL   -AS          < 1970-01-01 12:04:55.902582 AM [AirPlay] Concealed 302 unit gap (2884140 vs 2884442), curr seq 31608

3168585, 71.850
47357:NDS: ^0000000302.348641 !MIL   -AS          < 1970-01-01 12:05:02.348619 AM [AirPlay] Concealed 286 unit gap (3168585 vs 3168871), curr seq 32410
47358:NDS: ^0000000302.348659 !MIL   -AS          < 1970-01-01 12:05:02.348619 AM [AirPlay] Concealed 286 unit gap (3168585 vs 3168871), curr seq 32410

3318525, 75.250
48777:NDS: ^0000000305.746622 !MIL   -AS          < 1970-01-01 12:05:05.746564 AM [AirPlay] Concealed 1170 unit gap (3318525 vs 3319695), curr seq 32834
48778:NDS: ^0000000305.746644 !MIL   -AS          < 1970-01-01 12:05:05.746564 AM [AirPlay] Concealed 1170 unit gap (3318525 vs 3319695), curr seq 32834


>>> 985635/44100
22
>>> (985635%44100)/44.1
350.0


KT: nowTs=806326, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552521935, srcTS=806326
KT: nowTs=806326, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552521935, srcTS=806326
KT: pktTS=3552522287 src->rtpOffsetActive=743240662 inSession->audioLatencyOffset=11025
KT: pktTS=3552522287 src->rtpOffsetActive=743240662 inSession->audioLatencyOffset=11025
KT: nowTs=806678, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552522287, srcTS=806678
KT: nowTs=806678, limTs=807030, minTs=807030, maxTs=1248030, pktTS=3552522287, srcTS=806678


={============================================================================
*kt_dev_skymw_0000* skymw-ai

// Singletons/lib/source/FactoryContainer.cpp

FactoryContainer::FactoryContainer()
    : aiDmsFactory(AIDms::Factory::getSharedInstance())
    , aiConfig(std::make_shared<AppInfrastructureConfig>(aiDmsFactory))
    , sysInfo(new SystemInfo())
    , wsMediatorFactory(new WebSocketMediator::WebSocketMediatorFactory(SkyDefinitions::getWebsocketMediatorPorts()))
    , rmFactory(new RuntimeManagerFactory(aiConfig, sysInfo))
    , pmFactory(new PackageManagerFactory(aiConfig))
    , ampFactory(new ApplicationManagerProxy::Factory(aiConfig))
    , verifierFactory( new xmldsigverifier::Factory(aiConfig))
    , webServerFactory(new AppWebServerFactory())
    , softCatFactory(new SoftCatFactory(aiConfig))
    , applicationLaunchPolicyFactory(new ApplicationLaunchPolicyFactory(aiConfig))
    , jumperFactory(new jumper::JumperFactory())
    , dbusServerFactory(new AI_DBUS::DbusServerFactory())
    , aiDiagnosticsFactory(new AIDiagnostics::DiagnosticsFactory(aiConfig))
    , credentialsManagerFactory(new CredentialsManagerFactory())
    , upnpDiscoveryFactory(new UPnPDiscoveryFactory())

    , `blercuFactory(std::make_shared<AI_BLERCU::BleRcuFactory>())`

    , irrcuFactory(std::make_shared<AI_IRRCU::IrRcuFactory>())
    , netflixProxyFactory(std::make_shared<Netflix::Factory>())
    , terminalProxy(std::make_shared<AIDms::TerminalProxy>())
    {
      dbusServers[AI_DBUS::DbusServerId::AI_PRIVATE] = dbusServerPrivate;
      std::shared_ptr<AI_IPC::IIpcService> ipcServicePrivate = AI_IPC::createIpcService(dbusServerPrivate, IPC_SERVICE_APP_PROCESS);
      ipcServices[AI_DBUS::DbusServerId::AI_PRIVATE] = ipcServicePrivate;

      // create the BleRcu factory, which just launches the daemon (requires the system IPC service)
      blercuFactory->setLocale(aiDmsFactory->createLocale());

      blercuFactory->setIpcService(ipcServicePrivate);

      blercuFactory->setInputHandler(inputHandler);
      blercuFactory->startDaemon(dobbyProxy);

      // creates BleRcuContollerProxy
      blercuFactory->createBleRcuControllerProxy();
    }


COMPONENT_NAME := BleRcuClientLib

// BluetoothRcu/client/lib/include/BleRcuFactory.h

    std::map<std::string, std::shared_ptr<BleRcuDevice>> mRcuDevices;

BleRcuContollerProxy::BleRcuContollerProxy(
    const std::shared_ptr<AI_IPC::IIpcService>& ipcService, const std::shared_ptr<IInputHandler>& inputHandler)
{
  // #define BLE_RCU_CONTROLLER_OBJECT               "/com/sky/blercu/controller"
  // #define BLE_RCU_CONTROLLER_INTERFACE            "com.sky.blercu.Controller1"

  std::string handle = mIpcService->registerSignalHandler(
      AI_IPC::Signal(BLE_RCU_CONTROLLER_OBJECT, BLE_RCU_CONTROLLER_INTERFACE, "DeviceAdded"),
      std::bind(`&BleRcuContollerProxy::signalHandlerDeviceAdded`, this, std::placeholders::_1));

  // and more
}

void BleRcuContollerProxy::signalHandlerDeviceAdded(const AI_IPC::VariantList& args)
{
  {
    std::string objectPath = boost::get<std::string>(args[0]);
    std::string address = boost::get<std::string>(args[1]);

    AI_LOG_INFO("Device added [object path: %s] [address: %s]", objectPath.c_str(), address.c_str());

    mDispatcher->post(std::bind(`&BleRcuContollerProxy::updateDeviceList`, this));
  }
}

// BleRcuContollerProxy::updateDeviceList calls addDevicesToDeviceList

void BleRcuContollerProxy::addDevicesToDeviceList(const std::set<std::string>& objectPaths)
{
  for (const auto& objectPath : objectPaths)
  {
    AI_LOG_INFO("Add new device [object path: %s]", objectPath.c_str());

    try
    {
      mRcuDevices[objectPath] = std::make_shared<AI_BLERCU::BleRcuDevice>(
          mIpcService,
          mInputHandler,
          std::bind(`&BleRcuContollerProxy::notifyDevicePropertyChanged`, this),
          objectPath);
    }
    catch(const std::exception& e)
    {
      AI_LOG_ERROR("Failed to create device object [object path: %s]", objectPath.c_str());
    }
  }
}


// BluetoothRcu/client/lib/source/BleRcuDevice.cpp
// each device also registers functions to dbus

BleRcuDevice::BleRcuDevice(const std::shared_ptr<AI_IPC::IIpcService>& ipcService,
                 const std::shared_ptr<IInputHandler>& inputHandler,
                 const std::function<void(void)>& notifyPropertyChanged,
                 const std::string& objectPath)
    : mIpcService(ipcService), 
    `mNotifyPropertyChanged(notifyPropertyChanged)`, 
    mObjectPath(objectPath)
{
  // #define ORG_FREEDESKTOP_DBUS_PROPERTIES         "org.freedesktop.DBus.Properties"

  mPropertyChangedSignalHandler = mIpcService->registerSignalHandler(
      AI_IPC::Signal(objectPath, ORG_FREEDESKTOP_DBUS_PROPERTIES, "PropertiesChanged"),
      std::bind(`&BleRcuDevice::signalHandlerPropertyChanged`, this, std::placeholders::_1));

  // and more
}

void BleRcuDevice::signalHandlerPropertyChanged(const AI_IPC::VariantList& args)
{
  /*org.freedesktop.DBus.Properties.PropertiesChanged (STRING interface_name,
    DICT<STRING,VARIANT> changed_properties,
    ARRAY<STRING> invalidated_properties)*/

  if (args.size() >= 2)
  {
    try
    {
      std::string interface = boost::get<std::string>(args[0]); //STRING interface_name
      if (interface == BLE_RCU_DEVICE_INTERFACE_DEVICE1)
      {
        std::map<std::string, AI_IPC::DictDataType> changedProperties = boost::get<std::map<std::string, AI_IPC::DictDataType>>(args[1]); //DICT<STRING,VARIANT> changed_properties,

        if ((!changedProperties.empty()) || (!invalidatedProperties.empty()))
        {
          updateDeviceProperties(changedProperties, invalidatedProperties);
          mNotifyPropertyChanged();
        }
      }
    }
  }
}

void BleRcuContollerProxy::notifyDevicePropertyChanged()
{
  mDispatcher->post(std::bind(&BleRcuContollerProxy::notifyDeviceListChanged, this));
}

void BleRcuContollerProxy::notifyDeviceListChanged()
{
  notify( std::bind(&IBleRcuDeviceEvent::deviceListChanged, std::placeholders::_1) );
}

// Public/Common/Notifier.h
// class Notifier : virtual public Polymorphic


*to-daemon*

// BluetoothRcu/daemon/source/main.cpp

int main(int argc, char *argv[])
{
  QCoreApplication app(argc, argv);
  QCoreApplication::setApplicationName("BleRcuDaemon");
  QCoreApplication::setApplicationVersion("2.0");
}

	\internal

	Creates the main \l{BleRcuController} object and returns a shared pointer
	to it.  This is just a wrapper around the boilerplate needed to create
	the various class objects needed by the controller.
 */

static QSharedPointer<BleRcuController> setupBleRcuController(const QSharedPointer<CmdLineOptions> &options,
                                                              const QSharedPointer<ConfigSettings> &config,
                                                              const QSharedPointer<IrDatabase> &irDatabase,
                                                              const QSharedPointer<QDBusConnection> &dbusConn,
                                                              const QSharedPointer<QDBusConnection> &debugDBusConn)
{
  // connect dbus
  QSharedPointer<QDBusConnection> dbusConn = setupDBus(options->dbusType(),
      options->dbusAddress(),
      options->dbusServiceName());

  // create the manager object
  QSharedPointer<BleRcuManager> manager =
    QSharedPointer<BleRcuManagerImpl>::create(config,
        deviceFactory,
        QDBusConnection::systemBus());

  // create the controller object
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(config, manager,
        options->networkNamespace());
  if (!controller || !controller->isValid()) {
    controller.reset();
    qFatal("failed to setup the BLE RCU controller");
  }
}

// BluetoothRcu/daemon/source/blercu/blercucontroller.cpp

class BleRcuControllerImpl : public BleRcuController
                           , public QDBusContext
{}

// BluetoothRcu/daemon/source/blercu/blercucontroller_p.h

	BleRcuPairingStateMachine m_pairingStateMachine;

BleRcuControllerImpl::BleRcuControllerImpl(const QSharedPointer<const ConfigSettings> &config,
                                           const QSharedPointer<BleRcuManager> &manager,
                                           int networkNamespaceFd,
                                           QObject *parent)


// BluetoothRcu/daemon/source/blercu/blercumanager.cpp

class BleRcuManager : public QObject
{}

// BluetoothRcu/daemon/source/blercu/blercumanager_p.h

	StateMachine m_stateMachine;

BleRcuManagerImpl::BleRcuManagerImpl(const QSharedPointer<const ConfigSettings> &config,
                                     const QSharedPointer<IBleRcuDeviceFactory> &deviceFactory,
                                     const QDBusConnection &bluezBusConn,
                                     QObject *parent)

// BluetoothRcu/daemon/source/blercu/blercupairingstatemachine.cpp

void BleRcuPairingStateMachine::setupStateMachine()
{
}


={============================================================================
*kt_dev_skymw_0000* skymw-android

1. android studio
https://developer.android.com/studio/install

2. adb, Android Debug Bridge

3. ninja-build, to build from android studio
Ninja is a small build system with a focus on speed. It differs from other
build systems in two major respects: it is designed to have its input files
generated by a higher-level build system, and it is designed to run builds as
fast as possible.

4. qt.


={============================================================================
*kt_dev_skymw_0000* skymw-android-doc

https://developer.android.com/reference
https://developer.android.com/reference/android/app/Activity.html


={============================================================================
*kt_dev_skymw_0000* skymw-android-service

https://developer.android.com/guide/components/services.html

A Service is an application component that can perform long-running operations
in the background, and it doesn't provide a user interface. Another application
component can start a service, and it continues to run in the background even if
the user switches to another application. Additionally, a component can bind to
a service to interact with it and even perform interprocess communication (IPC).
For example, a service can handle network transactions, play music, perform file
I/O, or interact with a content provider, all from the background.

Bound

A service is bound when an application component binds to it by calling
bindService(). A bound service offers a client-server interface that allows
components to interact with the service, send requests, receive results, and
even do so across processes with interprocess communication (IPC). A bound
service runs only as long as another application component is bound to it.
Multiple components can bind to the service at once, but when all of them
unbind, the service is destroyed.


https://developer.android.com/guide/components/bound-services.html#Binder

Creating a bound service

When creating a service that provides binding, you must provide an IBinder that
provides the programming interface that clients can use to interact with the
service. There are three ways you can define the interface:

Using AIDL

Android Interface Definition Language (AIDL) decomposes objects into primitives
that the operating system can understand and marshals them across processes to
perform IPC. The previous technique, using a Messenger, is actually based on
AIDL as its underlying structure. As mentioned above, the Messenger creates a
queue of all the client requests in a single thread, so the service receives
requests one at a time. If, however, you want your service to handle multiple
requests simultaneously, then you can use AIDL directly. In this case, your
service must be thread-safe and capable of multi-threading.  To use AIDL
directly, you must create an .aidl file that defines the programming interface.
The Android SDK tools use this file to generate an abstract class that
implements the interface and handles IPC, which you can then extend within your
service.

Note: Most applications shouldn't use AIDL to create a bound service, because it
may require multithreading capabilities and can result in a more complicated
implementation. As such, AIDL is not suitable for most applications and this
document does not discuss how to use it for your service. If you're certain that
you need to use AIDL directly, see the AIDL document.


https://developer.android.com/guide/components/aidl#java

Defining an AIDL interface

You must define your AIDL interface in an .aidl file using the Java programming
language syntax, then save it in the source code (in the src/ directory) of both
the application hosting the service and any other application that binds to the
service.

When you build each application that contains the .aidl file, the Android SDK
tools generate an IBinder interface based on the .aidl file and save it in the
project's gen/ directory. The service must implement the IBinder interface as
appropriate. The client applications can then bind to the service and call
methods from the IBinder to perform IPC.

Implement the interface

The Android SDK tools generate an interface in the Java programming language,
based on your .aidl file. This interface has an inner abstract class named Stub
  that extends Binder and implements methods from your AIDL interface. You must
  extend the `Stub class and implement the methods`

Expose the interface to clients

Implement a Service and override onBind() to return your implementation of the
Stub class.

public class BleRcuService extends Service {

	public boolean registerService() {

		final String serviceName = "com.sky.blercuservice";

		Method method = null;
		try {
			method = Class.forName("android.os.ServiceManager").getMethod("addService", String.class, IBinder.class);

			method.invoke(null, serviceName, new BleRcuServiceBinder(this));
      }
   }

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {
  }
}

When you build your application, the Android SDK tools generate a .java
interface file named after your .aidl file. The generated interface includes a
subclass named Stub that is an abstract implementation of its parent interface
(for example, YourInterface.Stub) and declares all the methods from the .aidl
file.

Note: Stub also defines a few helper methods, most notably asInterface(), which
takes an IBinder (usually the one passed to a client's onServiceConnected()
    callback method) and returns an instance of the stub interface. See the
section Calling an IPC Method for more details on how to make this cast.

To implement the interface generated from the .aidl, extend the generated Binder
interface (for example, YourInterface.Stub) and implement the methods inherited
from the .aidl file.

Here is an example implementation of an interface called IRemoteService (defined
    by the IRemoteService.aidl example, above) using an anonymous instance:


={============================================================================
*kt_dev_skymw_0000* skymw-android-studio

https://developer.android.com/training/basics/firstapp/creating-project

{navigation}

Here are some tips to help you move around Android Studio.

Recent Files

Switch between your recently accessed files using the Recent Files action. Press
`Control+E` (Command+E on a Mac) to bring up the Recent Files action. By
default, the last accessed file is selected. You can also access any tool window
through the left column in this action.


File Structure

View the structure of the current file using the File Structure action. Bring up
the File Structure action by pressing `Control+F12` (Command+F12 on a Mac).
Using this action, you can quickly navigate to any part of your current file.

Find all the pieces of code referencing the class, method, field, parameter, or
statement at the current cursor position by pressing Alt+F7 (Option+F7 on a
Mac).


Find in path

`Control + Shift + F`

<global-search>
Global Search

you can search across your source code, databases, actions, elements of the user
interface, and so on, by `double-pressing the Shift`, or clicking the magnifying
glass in the upper right-hand corner of the Android Studio window.

// (can select from global search)
//
// Search for and navigate to a specific class in your project using the
// Navigate to Class action. Bring up the action by pressing Control+N
// (Command+O on a Mac).  Navigate to Class supports sophisticated expressions,
// including camel humps, paths, line navigate to, middle name matching, and
// many more. If you call it twice in a row, it shows you the results out of the
// project classes.
//
// Navigate to a file or folder using the Navigate to File action. Bring up the
// Navigate to File action by pressing Control+Shift+N (Command+Shift+O on a
// Mac).  To search for folders rather than files, add a / at the end of your
// expression.
// 
// Navigate to a method or field by name using the Navigate to Symbol action.
// Bring up the Navigate to Symbol action by pressing Control+Shift+Alt+N
// (Command+Option+O on a Mac).


<build>
By employing the flexibility of Gradle, you can achieve all of this without
modifying your app's core source files. Android Studio build files are named
build.gradle. They are plain text files that use Groovy syntax to configure
the build with elements provided by the Android plugin for Gradle. Each
project has one top-level build file for the entire project and separate
module-level build files for each module. When you import an existing project,
Android Studio automatically generates the necessary build files.

To learn more about the build system and how to configure, see Configure your
build.

<adb>
https://developer.android.com/studio/command-line/adb.html
https://www.stb.bskyb.com/confluence/display/~grayb/Android+Bluez+Stack

// run command from host

adb disable-verity
adb reboot

root	Restart adbd with root permissions.
adb root

adb remount
adb connect 192.168.0.104

You can verify that your device is connected by executing adb devices

$ adb devices
List of devices attached
192.168.0.104:5555      device


<adb-logcat> <android-log>

https://developer.android.com/studio/debug/am-logcat.html

keitee@keitee-mint:~/ip$ adb logcat --help
Usage: logcat [options] [filterspecs]
options include:
  -s              Set default filter to silent. Equivalent to filterspec '*:S'
  -f <file>, --file=<file>               Log to file. Default is stdout

   -e <expr>, --regex=<expr>
                  Only print lines where the log message matches <expr>
                  where <expr> is a regular expression
 

// capture all
adb logcat | tee log.log

adb logcat --pid=2208 | tee log.log

06-14 09:36:56.292  2208  2226 I BleRcuQt: < M:blercuadapter.cpp F:onDeviceAdded L:1494 > added device D4:B8:FF:12:E1:A8 named "P215 SkyQ EC101" (connected: false paired: false)
06-14 09:53:21.869  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 18:46:44:xx:xx:xx is 'U104 SkyQ EC201'
06-14 09:53:21.869  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 70:91:F3:xx:xx:xx is 'U104 SkyQ EC102'
06-14 09:53:21.870  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for D4:B8:FF:xx:xx:xx is 'U104 SkyQ EC[12]01'
06-14 09:53:21.871  2208  2226 I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for E8:0F:C8:xx:xx:xx is 'U104 SkyQ EC202'

<run>
/home/keitee/Downloads/android/android-studio/bin
./studio.sh &


={============================================================================
*kt_dev_skymw_0000* skymw-android-bluetoothrcu

<things-to-check-to-build>

1. set QT setting

app/CMakeLists.txt

# Sets the path to the Qt5 libraries and headers.
# You'll need to modify the QT5_SDK path below to point to your Qt5 SDK install

set( QT5_SDK "/home/keitee/Qt/5.12.3" )


<bt-remote-pairing>
https://docs.ubuntu.com/core/en/stacks/bluetooth/bluez/docs/reference/pairing/introduction

What is Pairing

In Bluetooth terminology pairing is the process of making two devices know about
each other. The key concept is about exchanging so called link-keys that are
used to secure the communication. The pairing process involves authentication
however due to the nature and variety of Bluetooth devices there will be
different ways of confirming the pairing attempt:

Devices such as keyboards or car-kits will require authentication by PIN/passkey
code

Other devices will provide a yes/no choice to the pairing attempt

Devices without an input interface such as headsets or speakers will not require
the user to confirm the pairing attempt at all

https://www.stb.bskyb.com/confluence/display/2016/RCU%3A+Pairing+steps+by+steps
https://www.stb.bskyb.com/confluence/display/~grayb/BLERCU+%3A+State+Diagrams+for+EC10x+Bluetooth+RCUS
https://www.stb.bskyb.com/confluence/display/2016/Remote+Control+Architecture

The BT Manager component will act as a connector to the underlying Bluez stack,
and expose the interfaces in a specified API, for use with the main network
control and pairing system.

 5.3.3.2 Certificate Store

Pairing will generate CA certificate information, which must be placed in
persistent storage. An API to the wider system, or some knowledge of the final
persistent storage system is necessary to co-ordinate this.


<bluetoothctl>
Pairing from Ubuntu Core
https://docs.ubuntu.com/core/en/stacks/bluetooth/bluez/docs/reference/pairing/outbound.html

SKY BLUEZ DEBUG CONSOLE
http://192.168.0.104:8180/index.html

telnet <stb-ip-address> 8123

   Select one of the following tools:
      1 - bluetoothctl
      2 - btmgmt
      3 - btmon
#>

#> 1
[NEW] Controller 38:A6:CE:7E:63:1A "sky-ip100" [default]
[NEW] Device D4:B8:FF:12:E1:A8 U122 SkyQ EC101
Agent registered
[bluetooth]# ?
Invalid command
[bluetooth]# help
Menu main:
Available commands:
-------------------
advertise                                         Advertise Options Submenu
scan                                              Scan Options Submenu
gatt                                              Generic Attribute Submenu
list                                              List available controllers
show [ctrl]                                       Controller information
select <ctrl>                                     Select default controller
devices                                           List available devices
paired-devices                                    List paired devices
system-alias <name>                               Set controller alias
reset-alias                                       Reset controller alias
power <on/off>                                    Set controller power
pairable <on/off>                                 Set controller pairable mode
discoverable <on/off>                             Set controller discoverable mode
agent <on/off/capability>                         Enable/disable agent with given capability
default-agent                                     Set agent as the default one
advertise <on/off/type>                           Enable/disable advertising with given type
set-alias <alias>                                 Set device alias
scan <on/off>                                     Scan for devices
info [dev]                                        Device information
pair [dev]                                        Pair with device
trust [dev]                                       Trust device
untrust [dev]                                     Untrust device
block [dev]                                       Block device
unblock [dev]                                     Unblock device
remove <dev>                                      Remove device
connect <dev>                                     Connect device
disconnect [dev]                                  Disconnect device
menu <name>                                       Select submenu
version                                           Display version
quit                                              Quit program
exit                                              Quit program
help                                              Display help about this program
[bluetooth]#

// check if "controller" is on and if not, run "power on"

[bluetooth]# show
Controller 38:A6:CE:7E:63:1A (public)
        Name: "sky-ip100"
        Alias: "sky-ip100"
        Class: 0x00000414
        Powered: yes
        Discoverable: no
        Pairable: no
        UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)
        UUID: A/V Remote Control        (0000110e-0000-1000-8000-00805f9b34fb)
        UUID: PnP Information           (00001200-0000-1000-8000-00805f9b34fb)
        UUID: A/V Remote Control Target (0000110c-0000-1000-8000-00805f9b34fb)
        UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)
        Modalias: usb:v1D6Bp0246d0530
        Discovering: no
[bluetooth]#


// check on "paired" and "connected"

[bluetooth]# info D4:B8:FF:12:E1:A8
Device D4:B8:FF:12:E1:A8 (public)
        Name: P199 SkyQ EC101
        Alias: P199 SkyQ EC101
        Appearance: 0x0180
        Paired: yes
        Trusted: no
        Blocked: no
        Connected: no
        LegacyPairing: no
        UUID: Generic Access Profile    (00001800-0000-1000-8000-00805f9b34fb)
        UUID: Generic Attribute Profile (00001801-0000-1000-8000-00805f9b34fb)
        UUID: Immediate Alert           (00001802-0000-1000-8000-00805f9b34fb)
        UUID: Device Information        (0000180a-0000-1000-8000-00805f9b34fb)
        UUID: Battery Service           (0000180f-0000-1000-8000-00805f9b34fb)
        UUID: Human Interface Device    (00001812-0000-1000-8000-00805f9b34fb)
        UUID: Scan Parameters           (00001813-0000-1000-8000-00805f9b34fb)
        UUID: Vendor specific           (0000f800-bdf0-407c-aaff-d09967f31acd)
        UUID: Vendor specific           (0000f801-bdf0-407c-aaff-d09967f31acd)
        UUID: Vendor specific           (0000f802-bdf0-407c-aaff-d09967f31acd)
        Modalias: bluetooth:v057Ap0004d0100
[bluetooth]#

// remove

[bluetooth]# remove D4:B8:FF:12:E1:A8
[DEL] Primary Service
...
Device has been removed
[bluetooth]#

//

[bluetooth]# scan on

... press "1+3"

[bluetooth]# pair D4:B8:FF:12:E1:A8

[bluetooth]# info D4:B8:FF:12:E1:A8

[U162 SkyQ EC101]# devices
Device D4:B8:FF:12:E1:A8 P215 SkyQ EC101


<skyblercu>
1+3 key triggers two things:

o do advertisement from rcu
o do paring process from a box


// app/src/main/cpp/main.cpp

/*
Called from the java MainApplication class when it's created.  This is the
entry point that kicks of the Qt main loop thread.

 */
extern "C"
JNIEXPORT jboolean JNICALL 
Java_com_sky_skybluetoothrcu_MainApplication_startQApplication(JNIEnv *env, 
    jobject /* this */)
{
  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, "launching QApplication");

  pthread_t qtThread;

  int rc = pthread_create(&qtThread, nullptr, mainThread, nullptr);
}

static int doMain()
{
  QCoreApplication a(argc, argv);

  // log the start-up
  qMilestone("====================");
  qMilestone("KT:");
  qMilestone("====================");

  // first thing we do is start the Android AIDL service, it has no controller
  // so won't be useful, but means other clients can connect to it (the controller
  // is added later)
  QSharedPointer<BleRcuService> service =
    QSharedPointer<BleRcuService>::create();

  // create the config options, read from the config.json file
  QSharedPointer<const ConfigSettings> config = ConfigSettings::defaults();

  // create the factory for creating the BleRcu services for each device
  QSharedPointer<BleRcuServicesFactory> servicesFactory =
    QSharedPointer<BleRcuServicesFactory>::create(config);

  // store the backend type
  g_backend.store(Backend::Bluez);

  // attempt to connect to the android dbus-broker
  QDBusConnection dbusConn = connectToDBus();
  if (!dbusConn.isConnected()) {
    qError() << "failed to connect to dbus due to" << dbusConn.lastError();
  }

  *when-use-bluez*
  // and then create the adapter talking to bluez over dbus
  adapter = QSharedPointer<BleRcuAdapterBluez>::create(config,
      servicesFactory,
      dbusConn);

  // create the controller that manages the adapter and paired devices
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(config, adapter);

  // give the controller to the Android service, the service is now useful
  service->setController(controller);
}


<config>

// right config file used?
// SkyBluetoothRcu/app/src/main/cpp/resources/config.android.json

	"models": [
		{
			"name": "ECx01",
			"manufacturer": "Omni",
			"oui": "D4:B8:FF",
			"pairingNameFormat": "U%03hhu SkyQ EC[12]01",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC[12]01",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC201",
			"manufacturer": "Omni",
			"oui": "18:46:44",
			"pairingNameFormat": "U%03hhu SkyQ EC201",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC201",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC102",
			"manufacturer": "UEI",
			"oui": "70:91:F3",
			"pairingNameFormat": "U%03hhu SkyQ EC102",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC102",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC202",
			"manufacturer": "UEI",
			"oui": "E8:0F:C8",
			"pairingNameFormat": "U%03hhu SkyQ EC202",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC202",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC05x",
			"manufacturer": "Ruwido",
			"disabled": true,
			"oui": "1C:A2:B1",
			"pairingNameFormat": "U%03hhuruwido Sky Remote",
			"scanNameFormat": "U[0-9][0-9][0-9]ruwido Sky Remote",
			"filterByte": 27,
			"connectionParams": {
				"maxInterval": 15.0,
				"minInterval": 15.0,
				"latency": 332,
				"supervisionTimeout": 15000
			},
			"services": {
				"type": "rci",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"touch"
				]
			}
		}

	]
	"models": [
		{
			"name": "ECx01",
			"manufacturer": "Omni",
			"oui": "D4:B8:FF",
			"pairingNameFormat": "U%03hhu SkyQ EC[12]01",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC[12]01",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC201",
			"manufacturer": "Omni",
			"oui": "18:46:44",
			"pairingNameFormat": "U%03hhu SkyQ EC201",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC201",
			"filterByte": 20,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC102",
			"manufacturer": "UEI",
			"oui": "70:91:F3",
			"pairingNameFormat": "U%03hhu SkyQ EC102",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC102",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC202",
			"manufacturer": "UEI",
			"oui": "E8:0F:C8",
			"pairingNameFormat": "U%03hhu SkyQ EC202",
			"scanNameFormat": "U[0-9][0-9][0-9] SkyQ EC202",
			"filterByte": 19,
			"services": {
				"type": "gatt",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"upgrade"
				]
			}
		},
		{
			"name": "EC05x",
			"manufacturer": "Ruwido",
			"disabled": true,
			"oui": "1C:A2:B1",
			"pairingNameFormat": "U%03hhuruwido Sky Remote",
			"scanNameFormat": "U[0-9][0-9][0-9]ruwido Sky Remote",
			"filterByte": 27,
			"connectionParams": {
				"maxInterval": 15.0,
				"minInterval": 15.0,
				"latency": 332,
				"supervisionTimeout": 15000
			},
			"services": {
				"type": "rci",
				"supported": [
					"audio",
					"battery",
					"deviceInfo",
					"findMe",
					"infrared",
					"touch"
				]
			}
		}
	]


// app/src/main/cpp/utils/linuxinputdevice.cpp

signals:
	void keyPress(quint16 keyCode, qint32 scanCode);
	void keyRelease(quint16 keyCode, qint32 scanCode);

void LinuxInputDevice::processEvents(const struct input_event *events, size_t nevents)
{
  switch (event->type) {
    case EV_SYN:
      m_scanCode = 0;
      break;
    case EV_KEY:
      if (event->value)
        `emit keyPress(event->code, m_scanCode);`
      else
        emit keyRelease(event->code, m_scanCode);
      m_scanCode = 0;
      break;
    case EV_MSC:
      if (event->code == MSC_SCAN)
        m_scanCode = event->value;
      break;

    default:
      break;
  }
}


// note that "service/android"
// app/src/main/cpp/service/android/blercuservice.cpp
// app/src/main/cpp/service/android/blercuservice.h

class BleRcuService : public QObject
                    , public QEnableSharedFromThis<BleRcuService>
{
  const QSharedPointer<InputDeviceManager> m_inputDeviceManager;

  QSharedPointer<BleRcuController> m_controller;

  QSharedPointer<QAndroidJniObject> m_javaBleRcuService;

  QSharedPointer<LinuxInputDevice> m_irInputDevice;

  QMap<BleAddress, int> m_deviceIdMap;
}

{
  // create the SkyBluetoothLE java object
  m_javaBleRcuService = QSharedPointer<QAndroidJniObject>::create(
      "com/sky/blercu/BleRcuService",
      "(J)V");
}

BleRcuService::BleRcuService(QObject *parent)
	: QObject(parent)
	, m_inputDeviceManager(InputDeviceManager::create())
  {
    QObject::connect(m_irInputDevice.data(), `&LinuxInputDevice::keyPress`,
        this, &BleRcuService::onIrKeyPress);
  }

void BleRcuService::onIrKeyPress(quint16 keyCode, qint32 scanCode)
{
  // check for the pairing keyCode F13 which is the new format
  if (keyCode == KEY_F13) {
    const quint8 filterByte = quint8((scanCode >> 16) & 0xff);
    const quint8 pairingCode = quint8((scanCode >> 0) & 0xff);

    // kick off pairing using supplied pairing code
    `m_controller->startPairing`(filterByte, pairingCode);
  }
}


// app/src/main/cpp/blercu/blercucontroller.cpp

bool BleRcuControllerImpl::startPairing(quint8 filterByte, quint8 pairingCode)
{
  // start the pairing process
  m_pairingStateMachine.start(filterByte, pairingCode);
}


// app/src/main/cpp/blercu/blercupairingstatemachine.cpp

class BleRcuControllerImpl : public BleRcuController
{
	const QSharedPointer<BleRcuAdapter> m_adapter;

	BleRcuPairingStateMachine m_pairingStateMachine;
	BleRcuScannerStateMachine m_scannerStateMachine;
}

//   QObject::connect(m_adapter.data(), &BleRcuAdapter::deviceNameChanged,
//     this, &BleRcuPairingStateMachine::onDeviceNameChanged);
// 
// void BleRcuPairingStateMachine::onDeviceNameChanged(const BleAddress &address,
//                                                     const QString &name)
// {
//   qDebug() << "device name changed" << address << name
//     << "(target" << m_targetAddress << ")";
// 
//   `processDevice`(address, name);
// }
// 
// /*!
// 	\internal
// 
// 	Called when entering the 'discovering' state.  At this point we query the
// 	manager for `the current list of devices and their names`  We use this to
// 	determine if any existing devices match the pairing prefix.
// 
//  */
// void BleRcuPairingStateMachine::onEnteredDiscoveringState()
// {
//    *get-devices-from-adapter*
// 	// get the current list of devices
// 	const QMap<BleAddress, QString> deviceNames = m_adapter->deviceNames();
// 
// 	// process each existing device
// 	QMap<BleAddress, QString>::const_iterator it = deviceNames.begin();
// 	for (; it != deviceNames.end(); ++it)
// 		`processDevice`(it.key(), it.value());
// }
//
// 
// // -----------------------------------------------------------------------------
// /*!
// 	\internal
// 
// 	Called when the an outside object has called either deviceAdded() or
// 	deviceNameChanged(), it then checks if the \a name matches our expected
// 	pairing prefix.  If it does then we check if we already have a pairing
// 	target, if not we use this new device.
// 
//  */
// void BleRcuPairingStateMachine::processDevice(const BleAddress &address,
//                                               const QString &name)
// {
//    *match-devices-from-rcu-to-scanned-devices*
//    QMap<quint32, QRegExp>::const_iterator it = m_pairingPrefixes.find(address.oui());
//
//    I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8
// }
// 
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8


// m_pairingPrefixFormats is built from *config* when fsm starts and is used to
// check if current devices does match up with expected pattern when
// processDevice gets called by handling events

// "130" is paringcode
// 
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 18:46:44:xx:xx:xx is 'U130 SkyQ EC201'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for 70:91:F3:xx:xx:xx is 'U130 SkyQ EC102'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for D4:B8:FF:xx:xx:xx is 'U130 SkyQ EC[12]01'
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:236 > pairing regex for E8:0F:C8:xx:xx:xx is 'U130 SkyQ EC202'
// I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
//
// I BleRcuQt: < M:blercudevice.cpp F:onEnteredResolvingServicesState L:547 > D4:B8:FF:12:E1:A8 entered RESOLVING_SERVICES state
// I BleRcuQt: < M:blercudevice.cpp F:onDeviceNameChanged L:352 > D4:B8:FF:12:E1:A8 device name changed from "P138 SkyQ EC101" to "U130 SkyQ EC101"
// I BleRcuQt: < M:blercuadapter.cpp F:onDeviceNameChanged L:1692 > renamed device D4:B8:FF:12:E1:A8 to "U130 SkyQ EC101"
// I BleRcuQt: < M:blercupairingstatemachine.cpp F:processDevice L:773 > found target device D4:B8:FF:12:E1:A8 but it's currently paired, will unpair and wait till it shows up in a scan again
//

void BleRcuPairingStateMachine::start(quint8 filterByte, quint8 pairingCode)
{
  // FIXME: use the filterByte to narrow the search to a certain RCU model
  Q_UNUSED(filterByte);

  // create a map of OUI (first 3 bytes of mac address) to a regex to match to
  // the name of the device
  m_pairingPrefixes.clear();
  QMap<quint32, QByteArray>::const_iterator it = m_pairingPrefixFormats.begin();
  for (; it != m_pairingPrefixFormats.end(); ++it) {

    // construct the wildcard match
    QRegExp regEx(QString::asprintf(it.value().constData(), `pairingCode`));
    regEx.setPatternSyntax(QRegExp::WildcardUnix);

    qInfo("pairing regex for %02hhX:%02hhX:%02hhX:xx:xx:xx is '%s'",
        quint8(it.key() >> 16), quint8(it.key() >> 8), quint8(it.key() >> 0),
        regEx.pattern().toLatin1().constData());

    // add to the map to use for compare when a device is found
    m_pairingPrefixes.insert(it.key(), std::move(regEx));
  }

  // start the state machine
  m_stateMachine.start();
}

bool StateMachine::start()
{
  m_currentState = m_initialState;
  m_running = true;

  logTransition(-1, m_currentState);

  emit entered(m_currentState);
  return true;
}

void BleRcuPairingStateMachine::setupStateMachine()
{
  // connect to the state entry and exit signals
  QObject::connect(&m_stateMachine, &StateMachine::`entered`,
      this, &BleRcuPairingStateMachine::`onStateEntry`);

  QObject::connect(&m_stateMachine, &StateMachine::`exited`,
      this, &BleRcuPairingStateMachine::`onStateExit`);
}

void BleRcuPairingStateMachine::onStateEntry(int state)
{
  switch (state) {

    case StartingDiscoveryState:
      onEnteredStartDiscoveryState()
      {
        // *emit-started*
        // tell anyone who cares that pairing has started
        `emit started();`
      }

      break;

    case FinishedState:
      onEnteredFinishedState()
      {
        // finally just emit a finished signal to the BleRcuManagerImpl object
        `emit finished();`
      }
      break;
  }
}

void BleRcuPairingStateMachine::onStateExit(int state)
{
  switch (state) {}
}


< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
< M:blercupairingstatemachine.cpp F:onStateEntry L:306 > KT: state: 2
< M:blercupairingstatemachine.cpp F:onEnteredStartDiscoveryState L:379 > KT: BleRcuPairingStateMachine::onEnteredStartDiscoveryState


// from adaptor signal

< M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter started discovering
< M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:422 > KT: postEvent(DiscoveryStartedEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1001)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (3)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state StartingDiscoveryState(2) to DiscoveringState(3)"

< M:blercupairingstatemachine.cpp F:processDevice L:781 > found target device D4:B8:FF:12:E1:A8
< M:blercupairingstatemachine.cpp F:processDevice L:799 > KT: postEvent(DeviceFoundEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1009)
< M:statemachine.cpp F:shouldMoveState L:310 > KT: really happen?? state (1)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (5)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state DiscoveringState(3) to StoppingDiscoveryState(5)"

< M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter stopped discovering
< M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:427 > KT: postEvent(DiscoveryStoppedEvent)
< M:statemachine.cpp F:postEvent L:766 > KT: event type (1002)
< M:statemachine.cpp F:moveToState L:193 > KT: set current state (6)
< M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving from state StoppingDiscoveryState(5) to EnablePairableState(6)"


//
// app/src/main/cpp/blercu/bluez/interfaces/bluezadapterinterface.h

#include <QtDBus>

class BluezAdapterInterface : public DBusAbstractInterface
{
  // ??
  Q_PROPERTY(bool Discovering READ discovering NOTIFY `discoveringChanged`)
    inline bool discovering() const
    { return qvariant_cast< bool >(property("Discovering")); }

signals:
  void aliasChanged(const QString& newAlias);
  void deviceClassChanged(quint32 deviceClass);
  void discoverableChanged(bool discoverable);
  void discoverableTimeoutChanged(uint newDiscoverableTimeout);
  void `discoveringChanged`(bool discovering);
  ...
};

// dbus -> adapter
// app/src/main/cpp/blercu/blercuadapter.h

class BleRcuAdapter : public QObject
{
signals:
  void poweredChanged(bool powered, QPrivateSignal);

  void `discoveryChanged`(bool discovering, QPrivateSignal);
  void pairableChanged(bool pairable, QPrivateSignal);

  void deviceFound(const BleAddress &address, const QString &name, QPrivateSignal);
  void deviceRemoved(const BleAddress &address, QPrivateSignal);

  void deviceNameChanged(const BleAddress &address, const QString &name, QPrivateSignal);
  void devicePairingChanged(const BleAddress &address, bool paired, QPrivateSignal);
  void deviceReadyChanged(const BleAddress &address, bool ready, QPrivateSignal);
};

// app/src/main/cpp/blercu/bluez/blercuadapter_p.h

class BleRcuAdapterBluez : public BleRcuAdapter
{
  private slots:
    void onAdapterDiscoveringChanged(bool discovering);
};

// app/src/main/cpp/blercu/bluez/blercuadapter.cpp

bool BleRcuAdapterBluez::attachAdapter(const QDBusObjectPath &adapterPath)
{
  // install handlers for the interesting adapter notifications
  QObject::connect(m_adapterProxy.data(), &BluezAdapterInterface::`discoveringChanged`,
      this, &BleRcuAdapterBluez::`onAdapterDiscoveringChanged`);
}

void BleRcuAdapterBluez::`onAdapterDiscoveringChanged`(bool discovering)
{
  emit `discoveryChanged`(m_discovering, BleRcuAdapter::privateSignal());
}

// adapter -> state machine
// app/src/main/cpp/blercu/blercupairingstatemachine.cpp

class BleRcuPairingStateMachine : public QObject {}

BleRcuPairingStateMachine::BleRcuPairingStateMachine()
{
  QObject::connect(m_adapter.data(), `&BleRcuAdapter::discoveryChanged`,
      this, &BleRcuPairingStateMachine::`onDiscoveryChanged`);
}

void BleRcuPairingStateMachine::`onDiscoveryChanged`(bool discovering)
{
  if (discovering)
    m_stateMachine.postEvent(DiscoveryStartedEvent);
  else
    m_stateMachine.postEvent(DiscoveryStoppedEvent);
}

app/src/main/java/com/sky/bluetooth/SkyBroadcastReceiver.java
124:            filter.addAction(BluetoothDevice.ACTION_PAIRING_REQUEST);
1


/home/keitee/ip/SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
/home/keitee/ip/SkyBluetoothRcu/app/src/main/java/com/sky/blercu/BleRcuService.java
/home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/blercu/blercuadapter.h
/home/keitee/ip/SkyBluetoothRcu/app/src/main/cpp/blercu/android/blercuadapter_p.h


<bt-remote-as-api> <aidl>
https://developer.android.com/guide/components/aidl#java

Defining an AIDL interface

You must define your AIDL interface in an .aidl file using the Java programming
language syntax, then save it in the source code (in the src/ directory) of 
`both the application` hosting the service and any other application that binds
to the service.

When you build each application that contains the .aidl file, the Android SDK
tools `generate` an IBinder interface based on the .aidl file and save it in the
project's gen/ directory. The service must implement the IBinder interface as
appropriate. The client applications can then bind to the service and call
methods from the IBinder to perform IPC.

Implement the interface

The Android SDK tools generate an interface in the Java programming language,
based on your .aidl file. This interface has an inner abstract class named Stub
that extends Binder and implements methods from your AIDL interface.  You must
extend the Stub class and implement the methods.


as api to support

/peripherals/btremotes/status
/peripherals/btremotes/action/startsearching


as/iWedia_AS_service/QtRESTService/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl

// app/src/main/java/com/sky/blercu/BleRcuService.java

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {
    ...

      @Override
      public String getDeviceMake(String address) {
        if (!checkAddress(address))
          return null;

        BleRcuService service = getService();

        if (service == null) return null;

        return service.jniGetDeviceMake(service.mQtObject, address);
      }
   }

	private native String jniGetDeviceMake(long qtObject, String address);


// app/src/main/cpp/service/android/blercuservice.cpp

bool BleRcuService::registerNatives()
{
  JNI_ENTRY(jniGetDeviceMake,               "(JLjava/lang/String;)Ljava/lang/String;"),
}


Expose the interface to clients

Implement a Service and override onBind() to return your implementation of the
Stub class.

// app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {
  ...
}


// are the same files

keitee@keitee-mint:~/ip$ find . -name IBleRcuService.aidl
./SkyBluetoothRcu/example/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./SkyBluetoothRcu/tests/IrDatabaseTest/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./iwedia/as/iWedia_AS_service/QtRESTService/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
./BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl


// app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl

interface IBleRcuService {
	void registerClient(in ParcelUuid appId, in IBleRcuServiceCallback callback);
	void unregisterClient(in int clientIf);

	boolean isPairing();

	String[] getDevices();

	++++ boolean isDevicePaired(in String address);
	++++ boolean isDeviceConnected(in String address);
	++++ int getDeviceId(in String address);
	++++ int getDeviceBatteryLevel(in String address);
	++++ String getDeviceName(in String address);
	++++ String getDeviceMake(in String address);
	++++ String getDeviceModel(in String address);
	++++ String getDeviceSerialNumber(in String address);
	++++ String getDeviceHardwareVersion(in String address);
	++++ String getDeviceSoftwareVersion(in String address);
	++++ String getDeviceBootloaderVersion(in String address);
	++ boolean setDeviceFindMe(in String address, in boolean enable);

	++ boolean setDeviceTouchMode(in String address, in int mode);
	++ int getDeviceTouchMode(in String address);

	++ boolean programDeviceIrCode(in String address, in int type, in int code);
	++ boolean eraseDeviceIrCodes(in String address);

	++ ParcelFileDescriptor startDeviceVoiceRecording(in String address);
	++ VoiceRecordingStats getDeviceVoiceRecordingStats(in String address);

	String[] getManufacturers(in String search, in int flags, in int offset, in int limit);
	String[] getModels(in String manufacturer, in String search, in int flags, in int offset, in int limit);
	int[] getCodes(in String manufacturer, in String model, in int flags);
	int[] getCodesFromEDID(in byte[] edid);

	++ boolean startDeviceUpgrade(in String address, in byte[] firmware);
	++ void cancelDeviceUpgrade(in String address);
}

    @Override
    public String toString() {
        StringBuilder description = new StringBuilder();

        try {
            // isDeviceConnected
            final boolean connected = isConnected();

            // getDeviceId, getDeviceName
            description.append("BleRcu Device ").append(getDeviceId()).append(": ").append(getName()).append("\n");

            description.append("  bdaddr: ").append(getAddress()).append("\n");
            description.append("  connected: ").append(connected);
            if (connected) {
                description.append("\n");
                description.append("  name: ").append(getName()).append("\n");
                description.append("  deviceid: ").append(getDeviceId()).append("\n");

                // getDeviceMake, 
                description.append("  make: ").append(getMake()).append("\n");

                // getDeviceModel
                description.append("  model: ").append(getModel()).append("\n");

                // getDeviceHardwareVersion
                description.append("  hwrev: ").append(getHardwareVersion()).append("\n");

                // getDeviceSerialNumber
                description.append("  serialno: ").append(getSerialNumber()).append("\n");

                // getDeviceSoftwareVersion
                description.append("  rcuswver: ").append(getSoftwareVersion()).append("\n");

                // getDeviceBootloaderVersion
                description.append("  btlswver: ").append(getBootloaderVersion()).append("\n");

                // getDeviceBatteryLevel
                description.append("  batterylevel: ").append(getBatteryLevel());
            }

        } catch (RemoteException e) {
            description.append("Error: ...");
        }
  }


// app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/blercu/IBleRcuService.java

@Override public boolean isDevicePaired(java.lang.String address) throws android.os.RemoteException
{
  android.os.Parcel _data = android.os.Parcel.obtain();
  android.os.Parcel _reply = android.os.Parcel.obtain();
  boolean _result;
  try {
    _data.writeInterfaceToken(DESCRIPTOR);
    _data.writeString(address);
    mRemote.transact(Stub.TRANSACTION_isDevicePaired, _data, _reply, 0);
    _reply.readException();
    _result = (0!=_reply.readInt());
  }
  finally {
    _reply.recycle();
    _data.recycle();
  }
  return _result;
}


// app/src/main/cpp/blercu/bluez/blercuadapter.cpp

bool BleRcuAdapterBluez::isDevicePaired(const BleAddress &address) const
{
	const QSharedPointer<BleRcuDeviceBluez> device = m_devices.value(address);
	if (!device || !device->isValid()) {
		qInfo() << "failed to find device with address" << address
		        << "to query paired status";
		return false;
	}

	return device->isPaired();
}

// app/src/main/java/com/sky/blercu/BleRcuService.java
	/**
	 * Returns true if the device with the given address is in the list of paired
	 * device.
	 *
	 */
	public boolean isDevicePaired(String address) {
		mServiceLock.readLock().lock();
		boolean isPaired = mPairedDevices.contains(address);
		mServiceLock.readLock().unlock();

		return isPaired;
	}

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {

		@Override
		public boolean isDevicePaired(String address) {
			if (!checkAddress(address))
				return false;

			BleRcuService service = getService();
			if (service == null) return false;
			return service.isDevicePaired(address);
		}


<bt-remote-scanning>
https://www.stb.bskyb.com/confluence/display/~grayb/Bluetooth+RCU+Pairing+Without+Infrared

Bluetooth RCU Pairing(scan)
http://192.168.0.100:8280/index.html

app/src/main/cpp/debug/www/main.dart.js
1796:i5:function(){W.eS("http://"+H.e($.b9)+":"+$.bY+"/bs/peripherals/btremotes/action/scanstart?timeoutms=30000","POST").aa(new F.e1(),null)},
3652:P.eA("post scanstart request finished")},


// app/src/main/cpp/debug/3rdparty/qhttpengine/src/qhttpserver.cpp

  d->process(socket);

// app/src/main/cpp/debug/httphandler.cpp

void HttpHandler::process(QHttpSocket *socket, const QString &path)
{}

void HttpHandler::handlePostRequest(QHttpSocket *socket, const QString &path)
{
  // ask the controller to start the scan
  m_controller->startScanning(timeoutMs);
}

bool BleRcuControllerImpl::startScanning(int timeoutMs)
{
  // start the pairing process
  m_scannerStateMachine.start(timeoutMs);
  return true;
}


// app/src/main/cpp/blercu/blercuscannerstatemachine.cpp

void BleRcuScannerStateMachine::onEnteredFinishedState()
{
  // if we found a device then tell any clients
  if (!m_foundDevice.address.isNull()) {
    `emit foundPairableDevice(m_foundDevice.address, m_foundDevice.name);`
    m_foundDevice.clear();
  }

  // and we're done
  emit finished();
}

// BleRcuControllerImpl::BleRcuControllerImpl()
//
// // connect to the scanner signals
// QObject::connect(&m_scannerStateMachine,
//                  &BleRcuScannerStateMachine::started,
//                  this,
//                  &BleRcuControllerImpl::onStartedScanning,
//                  Qt::QueuedConnection);
// QObject::connect(&m_scannerStateMachine,
//                  &BleRcuScannerStateMachine::finished,
//                  this,
//                  &BleRcuControllerImpl::onFinishedScanning,
//                  Qt::QueuedConnection);
//
// void
// BleRcuControllerImpl::onStartedScanning()
// {
// 	emit scanningStateChanged(true);
// }
// 
// void
// BleRcuControllerImpl::onFinishedScanning()
// {
// 	emit scanningStateChanged(false);
// }
//
// WsHandler::WsHandler(const QSharedPointer<BleRcuController>& controller,
//                      QObject* parent)
//   : QHttpHandler(parent)
//   , m_controller(controller)
// {
// 	// connect to changes in the controller scanning or pairing status
// 	QObject::connect(controller.data(),
// 	                 &BleRcuController::scanningStateChanged,
// 	                 this,
// 	                 &WsHandler::onBleScanningStateChanged,
// 	                 Qt::QueuedConnection);
// }


BleRcuControllerImpl::BleRcuControllerImpl()
{
  // connect to the signal emitted when the scanner found an RCU device in
  // pairing mode
  QObject::connect(&m_scannerStateMachine, 
      `&BleRcuScannerStateMachine::foundPairableDevice`,
      this, &BleRcuControllerImpl::onFoundPairableDevice,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onFoundPairableDevice(const BleAddress &address,
                                                 const QString &name)
{
  qInfo() << "found" << address << "RCU device in pairing mode,"
    << "kicking off the pairing state machine";

  // sanity check (needed?)
  if (m_pairingStateMachine.isRunning()) {
    qWarning("found target device in scan but pairing state machine "
        "already running?");
    return;
  }

  // start pairing the device
  m_pairingStateMachine.start(address, name);
}

// note: this is different start() from pairing mode
// void BleRcuPairingStateMachine::start(const BleAddress &target, const QString &name)
// add "single entry"

void BleRcuPairingStateMachine::start(const BleAddress &target, const QString &name)
{
  m_pairingPrefixes.insert(target.oui(),
      QRegExp(name, Qt::CaseInsensitive, QRegExp::FixedString));
}

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[ScannerStateMachine] moving from state StoppingDiscoveryState(3) 
  to FinishedState(4)"
W BleRcuQt: < M:statemachine.cpp F:moveToState L:206 > new states:  (4)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:207 > old states:  (3, 0)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:214 > KT: fire exit only for old state which is not in new states from child to parent state (3)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:214 > KT: fire exit only for old state which is not in new states from child to parent state (0)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:227 > KT: fire enter only for new state which is not in old states from parent to child state (4)
W BleRcuQt: < M:statemachine.cpp F:moveToState L:248 > KT: cleanup events?
W BleRcuQt: < M:statemachine.cpp F:moveToState L:253 > KT: emit finished?

I BleRcuQt: < M:blercucontroller.cpp F:onFoundPairableDevice L:617 
  > found D4:B8:FF:12:E1:A8 RCU device in pairing mode, kicking off the pairing state machine

I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[PairingStateMachine] moving to state StartingDiscoveryState(2)"
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onStateEntry L:306 > KT: state: 2
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onEnteredStartDiscoveryState L:379 > KT: BleRcuPairingStateMachine::onEnteredStartDiscoveryState
I BleRcuQt: < M:blercupairingstatemachine.cpp F:start L:280 > started pairing targeting D4:B8:FF:12:E1:A8
I BleRcuQt: < M:? F:? L:0 > started bluetooth RCU pairing procedure
I BleRcuQt: < M:blercuadapter.cpp F:onAdapterDiscoveringChanged L:1297 > adapter started discovering
I BleRcuQt: < M:blercupairingstatemachine.cpp F:onDiscoveryChanged L:422 > KT: postEvent(DiscoveryStartedEvent)


={============================================================================
*kt_dev_skymw_0000* skymw-android-jira

keitee@keitee-mint:~/ip/repo/SkyBluetoothRcu$ git show --stat

commit c472491d870088f3afaffd7863bc5c4ce4697078 (HEAD -> NGDEV-143556_IP100_Support_RCU_pairing_without_infrared, origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared)
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jun 25 14:48:07 2019 +0100

    NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

    Quote from
    https://www.stb.bskyb.com/confluence/pages/viewpage.action?spaceKey=~grayb&title=Bluetooth+RCU+Pairing+Without+Infrared:

    In the v2.1.0 release of the SkyBluetoothRcu code for Android an experimental
    feature was added in the debug builds to put the bluetooth code in 'searching'
    mode for 30 seconds. In search mode the code will look for any nearby BT RCU
    devices that are in pairing mode, when / if found it will automatically start
    pairing to it. Only the first RCU found in pairing mode will trigger the STB
    pairing code, subsequent found devices will be ignored (until 'searching' mode
    is enalbed once again).

    It works by looking for the special advertising packets sent by the BT RCU
    when you hold the 1 and 3 buttons. The BT RCU will send these special packets
    for 10 seconds after entering pairing mode.

 app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl         |  2 ++
 app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl |  2 +-
 app/src/main/cpp/blercu/blercucontroller.cpp                 | 37 +++++++++++++++++++++++++++++++++----
 app/src/main/cpp/blercu/blercucontroller.h                   | 11 ++++++++++-
 app/src/main/cpp/blercu/blercucontroller_p.h                 |  2 ++
 app/src/main/cpp/blercu/blercupairingstatemachine.h          |  1 +
 app/src/main/cpp/debug/wshandler.cpp                         |  2 +-
 app/src/main/cpp/service/android/blercuservice.cpp           | 57 +++++++++++++++++++++++++++++++++++++++++++++++++--------
 app/src/main/cpp/service/android/blercuservice.h             |  9 ++++++++-
 app/src/main/java/com/sky/blercu/BleRcuService.java          | 24 +++++++++++++-----------
 10 files changed, 120 insertions(+), 27 deletions(-)

* c472491 : (HEAD -> NGDEV-143556_IP100_Support_RCU_pairing_without_infrared, origin/NGDEV-143556_IP100_Support_RCU_pairing_without_infrared) NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared (23 hours ago) <Kit Park>
* d9f1809 : NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared (24 hours ago) <Kit Park>

keitee@keitee-mint:~/ip/repo/SkyBluetoothRcu$ git show --stat d9f1809
commit d9f1809e6ab0bb5bf4d500dfa82f5207ea3ef605
Author: Kit Park <kit.park@sky.uk>
Date:   Tue Jun 25 14:24:20 2019 +0100

    NGDEV-143556: IP100 - BLERCU Support RCU Pairing without Infrared

    As a part of delivery, applies clang style, Mozilla, to files before a commit
    which has actual changes so that can have clean base to show only differences to
    review.

 app/src/main/cpp/blercu/blercucontroller.cpp        |  906 ++++++++++++++++++++++++++------------------------
 app/src/main/cpp/blercu/blercucontroller.h          |   52 ++-
 app/src/main/cpp/blercu/blercupairingstatemachine.h |  192 +++++------
 app/src/main/cpp/debug/wshandler.cpp                |  188 ++++++-----
 app/src/main/cpp/service/android/blercuservice.cpp  | 3192 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------------------------------------------------------
 app/src/main/cpp/service/android/blercuservice.h    |  447 ++++++++++++++-----------
 6 files changed, 2637 insertions(+), 2340 deletions(-)


<copy-iadl>
cp SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
cp SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl BleRcuExample/app/src/main/aidl/com/sky/blercu/IBleRcuServiceCallback.aidl


<add-start-scan-call>

add startScanning(int timeout); to client if

app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl
app/src/main/java/com/sky/blercu/BleRcuService.java

	public BleRcuService(long qtObject) {
		//
		mQtObject = qtObject;
   }

	private static class BleRcuServiceBinder extends IBleRcuService.Stub {

		`private BleRcuService mService;`

		private BleRcuServiceBinder(BleRcuService svc) {
			mService = svc;
		}
		public boolean cleanup() {
			mService = null;
			return true;
		}

		public BleRcuService getService() {
			if (mService != null && mService.isAvailable()) {
				return mService;
			}
			return null;
		}

		public String getDeviceName(String address) {
			if (!checkAddress(address))
				return null;

			BleRcuService service = getService();
			if (service == null) return null;
			return service.jniGetDeviceName(`service.mQtObject`, address);
		}

	private native String jniGetDeviceName(long qtObject, String address);


app/src/main/cpp/service/android/blercuservice.cpp

bool BleRcuService::registerNatives()
{
		JNI_ENTRY(jniGetDeviceName,               "(JLjava/lang/String;)Ljava/lang/String;"),
}

jstring BleRcuService::jniGetDeviceName(JNIEnv *env, jobject, `jlong qtObject`,
                                        jstring address)
{
	return jniGetDeviceInfo(env, qtObject, address, DeviceName);
}

app/src/main/cpp/service/android/blercuservice.h

keitee@keitee-mint:~/ip/BleRcuExample$ cp ../SkyBluetoothRcu/app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl app/src/main/aidl/com/sky/blercu/IBleRcuService.aidl


<ble-example-client>

app/build/generated/aidl_source_output_dir/debug/compileDebugAidl/out/com/sky/blercu/IBleRcuService.java
 * This file is auto-generated.  DO NOT MODIFY.


<ble-callback>

// app/src/main/cpp/blercu/blercucontroller.cpp

BleRcuControllerImpl::BleRcuControllerImpl()
{
  *emit-started*
  // connect to the finished signal of the pairing statemachine, use to update
  // our list of managed devices
  QObject::connect(&m_pairingStateMachine, `&BleRcuPairingStateMachine::finished`,
      this, &BleRcuControllerImpl::onFinishedPairing,
      Qt::QueuedConnection);

  // connect to the started signal so we can send pairing state notifications
  QObject::connect(&m_pairingStateMachine, `&BleRcuPairingStateMachine::started`,
      this, &`BleRcuControllerImpl::onStartedPairing`,
      Qt::QueuedConnection);

  QObject::connect(this, &`BleRcuController::pairingStateChanged`,
      m_analytics.data(), &BleRcuAnalytics::logPairingStateChange,
      Qt::QueuedConnection);
}

void BleRcuControllerImpl::onStartedPairing()
{
  // a queued event so check the state
  const bool pairing = m_pairingStateMachine.isRunning();

  qMilestone() << "KT: tell clients that the pairing state has changed";

  // tell clients that the pairing state has changed
  emit pairingStateChanged(pairing);
}

void BleRcuControllerImpl::onFinishedPairing()
{
  // a queued event so check the state
  const bool pairing = m_pairingStateMachine.isRunning();

  // (re)sync our list of managed devices now pairing has finished
  if (!pairing)
    syncManagedDevices();

  qMilestone() << "KT: tell clients that the pairing state has changed";

  // tell clients that the pairing state is changed
  emit pairingStateChanged(pairing);
}

// app/src/main/cpp/service/android/blercuservice.cpp

void BleRcuService::setController(const QSharedPointer<BleRcuController> &controller)
{
  QObject::connect(controller.data(), &`BleRcuController::pairingStateChanged`,
      this, `&BleRcuService::onPairingStateChanged`);
}

void BleRcuService::onPairingStateChanged(bool pairing)
{
  m_javaBleRcuService->callMethod<void>("onPairingStateChanged",
      "(Z)V",
      static_cast<jboolean>(pairing ? JNI_TRUE : JNI_FALSE));
}

void BleRcuAnalytics::logPairingStateChange(bool pairing)
{
  if (pairing)
    qProdLog("KT: logPairingStateChange: started bluetooth RCU pairing procedure");
  else
    qProdLog("KT: logPairingStateChange: finished bluetooth RCU pairing procedure");
}

app/src/main/java/com/sky/blercu/BleRcuService.java

public class BleRcuService extends Service {

	final RemoteCallbackList<IBleRcuServiceCallback> mCallbacks =
		new RemoteCallbackList<IBleRcuServiceCallback>();

	/**
	 * Expected to be called by the native C++ code when the pairing process
	 * has started or stopped.
	 *
	 */
	public void onPairingStateChanged(final boolean pairing) {

		mServiceLock.writeLock().lock();
		boolean triggerCallback = (mIsPairing != pairing);
		mIsPairing = pairing;
		mServiceLock.writeLock().unlock();

		if (triggerCallback && mNotifyThread.isAlive()) {

			// broadcast back to clients from the notify thread
			mNotifyThread.mHandler.post(() -> {

				final int n = mCallbacks.beginBroadcast();
				for (int i = 0; i < n; i++) {
					try {
						mCallbacks.getBroadcastItem(i).onPairingChanged(pairing);
					} catch (RemoteException e) {
						// RemoteCallbackList will take care of removing dead objects
					}
				}

				`mCallbacks`.finishBroadcast();
			});
		}
	}
}



<port-to->

/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
main.cpp

setupBleRcuController()
{
  // create the manager object
  QSharedPointer<BleRcuManager> manager =
    QSharedPointer<BleRcuManagerImpl>::create(config,
        deviceFactory,
        QDBusConnection::systemBus());

  // create the controller object
  QSharedPointer<BleRcuController> controller =
    QSharedPointer<BleRcuControllerImpl>::create(
        config, 
        `manager`,
        options->networkNamespace());
}


/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
blercu/blercumanager.cpp

class BleRcuManagerImpl : public BleRcuManager

	StateMachine m_stateMachine;


/xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/daemon/source/
blercu/blercucontroller.cpp

	BleRcuPairingStateMachine m_pairingStateMachine;


xSubmoduleAppInfrastructure/AppInfrastructure/BluetoothRcu/console/source/
dbus/dbusabstractinterface.cpp


<xx>
I BleRcuQt: < M:statemachine.cpp F:logTransition L:82 > "[DeviceStateMachine] moving from state StartingServices(5) to ReadyState(6)"
I BleRcuQt: < M:blercuadapter.cpp F:onDeviceReadyChanged L:1733 > device with address D4:B8:FF:12:E1:A8 is  ready
D ServicePeripherals: @BTREMOTE: onDeviceConnectionStateChanged | address: D4:B8:FF:12:E1:A8 connected: true
D BleRcuManager: onDeviceConnectionStateChanged() - D4:B8:FF:12:E1:A8 : true


#{============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
