*kt_dev_07*                                                                tw=100

kt.dev.sql

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_sql_001| sql-validator
|kt_dev_sql_001| sql-intro
|kt_dev_sql_002| sql-select
|kt_dev_sql_003| sql-order-by
*kt_dev_sql_003* sql-join
*kt_dev_sql_003* sql-insert sql-update sql-delete


# ============================================================================
#{
={============================================================================
*kt_dev_sql_001* sql-validator

http://developer.mimer.com/validator/parser200x/index.tml


={============================================================================
*kt_dev_sql_001* sql-intro

* SQL, Structured Query Language

* special-purpose programming language
  to manipulate relational database
  contains both a data definition syntax and data manipulation syntax

* Primary key
  if more than on table uses the same primary key, you can then `merge` those
  two tables together.

* Foreign kay
  `links` that table to another table's primary key

* SQL is `not case-sensitive`


={============================================================================
*kt_dev_sql_002* sql-select

<alias>
p is alias for a table name.

SELECT p.person_first_name FROM person p;

<where-clause>
The body of the WHERE clause will be a set of expression that can evaluate to
TRUE or FALSE. boolean expression. Uses to `filter` down the result set.

Who are all the people in my contact list that have the first name Jon?

SELECT p.person_first_name FROM person p WHERE p.person_first_name = 'Jon';

<simple-operators>
=     equal to
<>    not equal to
>     greater than
>=
<=


<more-operators>

BETWEEN is `inclusive`

Who are all the people in my contact list that I have contacted at least once
but no more than 20 times?

SELECT p.person_first_name FROM person p WHERE p.contacted_number 
BETWEEN 1 AND 20;

<LIKE>
LIKE is a special operator just for strings, give LIKE a pattern that will
match strings. % is the wild-card character.

Who are all the people in my contact list that have a first name that begins
with the letter J?

SELECT p.person_first_name FROM person p WHERE p.person_first_name 
LIKE 'J%';


<IN>
IN requires a list of potential values and if row matches `any` of the
  potential values, then is added to the result set.

Who are all the people in my contact list that are named Jon, Shannon, or
Flitz?

SELECT p.person_first_name FROM person p WHERE p.person_first_name 
IN ('Jon','Shannon','Flitz');


IS is used to check NULL which is special in SQL and don't work with equality(=)
operator.

Who are all the people in my contact list that don't have a last name?

SELECT p.person_first_name FROM person p WHERE p.person_last_name 
IS NULL;

Who are all the people in my contact list that have a last name?

SELECT p.person_first_name FROM person p WHERE p.person_last_name 
IS NOT NULL;


<ex>
returns all columns

SELECT * FROM person p;


={============================================================================
*kt_dev_sql_003* sql-order-by

ORDER BY

* ascending order is the default.
* after WHERE clause but WHERE isn't required.

Who are all the people in my contact list, ordered by last name?

SELECT p.person_first_name, p.person_last_name FROM person p 
ORDER BY p.person_last_name;

* descending order

SELECT p.person_first_name, p.person_last_name FROM person p 
ORDER BY p.person_last_name DESC;


<set-function>
built-in functions to provide additional functionality and use these function
instead of columns in the slect list.

Q: How many contacts do I have?
Q: Who is the contact that I've interacted with the least?

CONUT
* include NULL when use *
* use alias to change column name as result set

SELECT COUNT(*) FROM person p;

SELECT COUNT(*) as NumberOfPople FROM person p;
SELECT COUNT(p.person_first_name) as NumberOfPople FROM person p;

MAX

SELECT MAX(p.person_contacted_number) FROM person p;

MIN
AVG
SUM


<qualifiers-and-set-function>
How to limit rows from a query?

Use result set qualifier. ALL implied by default.

SELECT DISTINCT p.person_first_name FROM person p;

shows all the unique first names since DISTINCT removes duplicates.

Q: What is the count of unique first names among my contacts?

SELECT COUNT(DISTINCT p.person_first_name) FROM person p;


GROUP BY
* can `subset` of the set which set function can run on and get `subresult`

Q: What is the count of every unique first names among my contacts?

SELECT COUNT(DISTINCT p.person_first_name), p.person_first_name FROM person p
GROUP BY p.person_first_name;

<ex>
> SELECT a.address_street FROM address a;
+----------------+
| address_street |
+----------------+
| Pluralsight    |
| Trainsignal    |
| Pluralsight    |
| Pluralsight    |
+----------------+

> SELECT COUNT(a.address_street) FROM address a;
4

> SELECT COUNT(DISTINCT a.address_street) FROM address a;
2

> SELECT COUNT(DISTINCT a.address_street), a.address_street FROM address a;
| COUNT(DISTINCT a.address_street)  | a.address_street |
|                                 2 | Pluralsight      |

this do not make sense.

> SELECT COUNT(DISTINCT a.address_street), a.address_street FROM address a
GROUP BY a.address_street;
| COUNT(DISTINCT a.address_street)  | a.address_street |
|                                 1 | Pluralsight      |
|                                 1 | Trainsignal      |

> SELECT COUNT(a.address_street), a.address_street FROM address a
GROUP BY a.address_street;
| COUNT(a.address_street)           | a.address_street |
|                                 3 | Pluralsight      |
|                                 1 | Trainsignal      |


<HAVING>
HVING clause works as WHERE clause works to SELECT.

Q: What is the count of every unique first names among my contacts that
appears at least 5 times?

SELECT COUNT(p.person_first_name) as NameCount, p.person_first_name FROM person p
GROUP BY p.person_first_name HAVING NameCount >= 5;


={============================================================================
*kt_dev_sql_003* sql-join

create result set from two or more tables.


<CROSS-JOIN>
The simplest type of JOIN. least useful and inefficient.
Takes all the rows from both tables without relation between tables.
CROSS keyword is optional.

Q: What are all the first names and email addresses I have?

SELECT p.person_first_name, e.email_address FROM person p, email_address e;


<INNER-JOIN>
The typical JOIN.
Take all the rows from table A, find all rows in table B where a key in table
A is equal to a key in table B.
ON boolean expression to match the key columns.

Q: What are my contacts' email addresses?

SELECT p.person_first_name, p.person_last_name, e.email_address 
FROM person p INNER JOIN email_address e
ON p.person_id = e.email_address_person_id;


<OUTER-JOIN>
The difference between INNER JOIN and OUTER JOIN is NULL since INNER JOIN only
joins against rows where there is a match in the joined table and OUTER JOIN
works even when there is no match.

Q: What are all my contacts and their email addresses, including the ones
missing an email address and the one with an email address but missing a
contact name?

SELECT p.person_first_name, p.person_last_name, e.email_address 
FROM person p FULL OUTER JOIN email_address e
ON p.person_id = e.email_address_person_id;

| person_first_name | person_last_name  | email_address | 
| Jon               | Flanders          | jon@..        |
| Fritz             | Onion             | fritz@..      |
| Shannon           | Ahern             | NULL          |
| NULL              | NULL              | aaron@..      |


<LEFT-OUTER-JOIN>
Only the rows from the table on the left of the LEFT OUTER JOIN will be
returned.

Q: What are all my contacts and their email addresses, including the ones
missing an email address?

SELECT p.person_first_name, p.person_last_name, e.email_address 
FROM person p LEFT OUTER JOIN email_address e
ON p.person_id = e.email_address_person_id;

| Jon               | Flanders          | jon@..        |
| Fritz             | Onion             | fritz@..      |
| Shannon           | Ahern             | NULL          |


<RIGHT-OUTER-JOIN>

Q: What are the email addresses I have, including those emails I don't have a
person for?

SELECT p.person_first_name, p.person_last_name, e.email_address 
FROM person p RIGHT OUTER JOIN email_address e
ON p.person_id = e.email_address_person_id;

| Jon               | Flanders          | jon@..        |
| Fritz             | Onion             | fritz@..      |
| NULL              | NULL              | aaron@..      |

<ex>
CROSS JOIN
SELECT p.person_first_name, e.email_address FROM person p, email_address e;

| person_first_name | person_last_name  | email_address     | 
+-----------------------------------------------------------+
| Jon               | Flanders          | jon.flanders@..   |
| Shannon           | Ahern             | jon.flanders@..   |
| Fritz             | Onion             | jon.flanders@..   |
| Jon               | Flanders          | jon@..            |
| Shannon           | Ahern             | jon@..            |
| Fritz             | Onion             | jon@..            |
| Jon               | Flanders          | fritz@..          |
| Shannon           | Ahern             | fritz@..          |
| Fritz             | Onion             | fritz@..          |
| Jon               | Flanders          | aaron@..          |
| Shannon           | Ahern             | aaron@..          |
| Fritz             | Onion             | aaron@..          |


INNER JOIN

| person_first_name | person_last_name  | email_address     | 
+-----------------------------------------------------------+
| Jon               | Flanders          | jon.flanders@..   |
| Jon               | Flanders          | jon@..            |
| Fritz             | Onion             | fritz@..          |


SELECT p.person_first_name FROM person p;

| person_first_name |
+--------------------
| Jon               |
| Jon               |
| Fritz             |


SLECT e.email_address FROM email_address e;

| email_address     | 
--------------------+
| jon.flanders@..   |
| jon@..            |
| fritz@..          |
| aaron@..          |

This means that there are rows which has NULL.

note: WHY do not show rows which has NULL?


RIGHT OUTER JOIN

| person_first_name | person_last_name  | email_address     | 
+-----------------------------------------------------------+
| Jon               | Flanders          | jon.flanders@..   |
| Jon               | Flanders          | jon@..            |
| Fritz             | Onion             | fritz@..          |
| NULL              | NULL              | aaron@..          |


LEFT OUTER JOIN

| person_first_name | person_last_name  | email_address     | 
+-----------------------------------------------------------+
| Jon               | Flanders          | jon.flanders@..   |
| Jon               | Flanders          | jon@..            |
| Shannon           | Ahern             | NULL              |
| Fritz             | Onion             | fritz@..          |


={============================================================================
*kt_dev_sql_003* sql-insert sql-update sql-delete

<INSERT-INTO>
* one table at a time.

INSERT INTO persopn (person_id, person_first_name, person_last_name, 
    person_contacted_number, person_date_last_contacted, person_date_added )
VALUES 
(1, 'jon', 'Flanders', 5, '2013-09-14 11:43:31', '2013-01-14 11:43:31')


* can insert multiple rows.

INSERT INTO persopn (person_id, person_first_name, person_last_name, 
    person_contacted_number, person_date_last_contacted, person_date_added )
VALUES 
(1, 'jon', 'Flanders', 5, '2013-09-14 11:43:31', '2013-01-14 11:43:31')
(2, 'Shannon', 'Ahern', 0, '2013-08-14 11:43:31', '2013-02-14 11:43:31')


<UPDATE>
* without WHERE clause, UPDATE(like DELETE) affects all the rows in the table.
* SET follows table name.

UPDATE email_address e SET e.email_address_person_id = 5
WHERE e.email_address = 'aaron@mail.com';


<DELETE>
* one table at a time and without WHERE, affects all rows.

# deletes all
DELETE FROM person;


<sql-transaction>
Transaction should be ACID (atomic, Consistent, Isolated, Durable)

Isolated(serialed)

-- ANSI syntax
START TRANSACTION;
DELETE FROM person;
COMMIT;
-- or ROLLBACK;


DELETE FROM person p
WHERE p.person_first_name LIKE 'J%';

DELETE FROM person p
WHERE p.person_id IN (1,2,3,4,5,6);


=}============================================================================
Copyright: see |ktkb|                              vim:tw=100:ts=3:ft=help:norl:
