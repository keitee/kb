*kt_dev_04*                                                                tw=100

KT KB. DEVELOPMENT. WEB.

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_web_001| NPAPI
|kt_dev_web_002| URL encode
*kt_dev_web_003* qunit


# ============================================================================
#{
={============================================================================
*kt_dev_web_001* NPAPI

{js-to-native}
You can bundle an NPAPI plugin with your extension, allowing you to call into native binary code
from JavaScript. 

NPAPI is being phased out. Consider using alternatives. NPAPI is a really big hammer that should
only be used when no other approach will work. 

Code running in an NPAPI plugin has the full permissions of the current user and is not sandboxed or
shielded from malicious input by Google Chrome in any way. You should be especially cautious when
processing input from untrusted sources, such as when working with content scripts or
XMLHttpRequest. 

How to develop an NPAPI plugin is outside the scope of this document. See Mozilla's NPAPI plugin
reference for information on how to do that. 

https://developer.mozilla.org/en-US/Add-ons/Plugins

<what-plugin-is>
Plugins are shared libraries that users can install to display content that the application itself
can't display natively. For example, the Adobe Reader plugin lets the user open PDF files directly
inside the browser, and the QuickTime and RealPlayer plugins are used to play special format videos
in a web page.

Plugins are now a legacy technology. They are not available on most mobile devices. Mozilla
encourages website developers to avoid using plugins wherever possible. If there are plugin features
which are not available in the web platform, we encourage developers to post their use cases to
mozilla.dev.platform project list, so that Mozilla can prioritize web platform work to make those
use cases possible.

Plugins are written using NPAPI, the cross-browser API for plugins. The main source of documentation
for NPAPI is the Gecko Plugin API Reference. To make your plugin scriptable from web pages, use
npruntime.

Plugins can be written completely from scratch using C APIs (usually in C or C++) or they may be
built on a plugin framework such as Firebreath, JUCE, or QtBrowserPlugin. There are also some code
generation tools that may be helpful. More information about these tools can be found on the
External Resources page.

Plugins are different from extensions, which modify or enhance the functionality of the browser
itself. Plugins are also different from search plugins, which plug additional search engines in the
search bar.


={============================================================================
*kt_dev_web_002* URL encode

http://www.url-encode-decode.com/

What is URL encoding?

URL encoding stands for encoding 'certain' characters in a URL by replacing them with one or more
character triplets that consist of the percent character "%" followed by two hexadecimal digits. The
two hexadecimal digits of the triplet(s) represent the numeric value of the replaced character.

For example, the string: François ,would be encoded as: Fran%C3%A7ois

The "ç" is encoded in UTF-8 as two bytes C3 (hex) and A7 (hex), which are then written as the three
characters "%c3" and "%a7" respectively. This can make a URI rather long (up to 9 ASCII characters
        for a single Unicode character), but the intention is that browsers only need to display the
decoded form, and many protocols can send UTF-8 without the %HH 'escaping'. 

The term URL encoding is a bit inexact because the encoding procedure is not limited to URLs
(Uniform Resource Locators), but can also be applied to any other URIs (Uniform Resource
        Identifiers) such as URNs (Uniform Resource Names). Therefore, the term percent-encoding
should be preferred. 


When and why would you use URL encoding?

When data that has been entered into HTML forms is submitted, the form field names and values are
encoded and sent to the server in an HTTP request message using method GET or POST, or,
historically, via email. The encoding used by default is based on a very early version of the
    general URI percent-encoding rules, with a number of modifications such as newline normalization
    and replacing spaces with "+" instead of "%20". The MIME type of data encoded this way is
    application/x-www-form-urlencoded, and it is currently defined (still in a very outdated manner)
    in the HTML and XForms specifications. In addition, the CGI specification contains rules for how
    web servers decode data of this type and make it available to applications.

When sent in an HTTP GET request, application/x-www-form-urlencoded data is included in the query
component of the request URI. When sent in an HTTP POST request or via email, the data is placed in
the body of the message, and the name of the media type is included in the message's Content-Type
header. 


={============================================================================
*kt_dev_web_003* qunit

https://qunitjs.com/intro/

You probably know that testing is good, but the first hurdle to overcome when
trying to write unit tests for client-side code is the lack of any actual units;
JavaScript code is written for each page of a website or each module of an
  application and is closely intermixed with back-end logic and related HTML. In
  the worst case, the code is completely mixed with HTML, as inline events
  handlers.

This is likely the case when no JavaScript library for some DOM abstraction is
being used; writing inline event handlers is much easier than using the DOM APIs
to bind those events. More and more developers are picking up a library such as
jQuery to handle the DOM abstraction, allowing them to move those inline events
to distinct scripts, either on the same page or even in a separate JavaScript
file. However, putting the code into separate files doesn’t mean that it is
ready to be tested as a unit.

What is a unit anyway? In the best case, it is a pure function that you can deal
with in some way — a function that always gives you the same result for a given
input. This makes unit testing pretty easy, but most of the time you need to
deal with side effects, which here means DOM manipulations. It’s still useful to
figure out which units we can structure our code into and to build unit tests
accordingly.


={============================================================================
*kt_dev_web_004* html standard

https://html.spec.whatwg.org/multipage/index.html

https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement


==============================================================================
Copyright: see |ktkb|                              vim:tw=100:ts=3:ft=help:norl:
