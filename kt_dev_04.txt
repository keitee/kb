*kt_dev_04*                                                                tw=100

KT KB. DEVELOPMENT. WEB.

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_web_001| NPAPI
|kt_dev_web_002| URL encode
*kt_dev_web_003* qunit
*kt_dev_web_003* java scripts to check on video element
*kt_dev_web_004* html standard
*kt_dev_web_005* crome dev tool
*kt_dev_web_005* user agent

# ============================================================================
#{
={============================================================================
*kt_dev_web_001* NPAPI

{js-to-native}
You can bundle an NPAPI plugin with your extension, allowing you to call into native binary code
from JavaScript. 

NPAPI is being phased out. Consider using alternatives. NPAPI is a really big hammer that should
only be used when no other approach will work. 

Code running in an NPAPI plugin has the full permissions of the current user and is not sandboxed or
shielded from malicious input by Google Chrome in any way. You should be especially cautious when
processing input from untrusted sources, such as when working with content scripts or
XMLHttpRequest. 

How to develop an NPAPI plugin is outside the scope of this document. See Mozilla's NPAPI plugin
reference for information on how to do that. 

https://developer.mozilla.org/en-US/Add-ons/Plugins

<what-plugin-is>
Plugins are shared libraries that users can install to display content that the application itself
can't display natively. For example, the Adobe Reader plugin lets the user open PDF files directly
inside the browser, and the QuickTime and RealPlayer plugins are used to play special format videos
in a web page.

Plugins are now a legacy technology. They are not available on most mobile devices. Mozilla
encourages website developers to avoid using plugins wherever possible. If there are plugin features
which are not available in the web platform, we encourage developers to post their use cases to
mozilla.dev.platform project list, so that Mozilla can prioritize web platform work to make those
use cases possible.

Plugins are written using NPAPI, the cross-browser API for plugins. The main source of documentation
for NPAPI is the Gecko Plugin API Reference. To make your plugin scriptable from web pages, use
npruntime.

Plugins can be written completely from scratch using C APIs (usually in C or C++) or they may be
built on a plugin framework such as Firebreath, JUCE, or QtBrowserPlugin. There are also some code
generation tools that may be helpful. More information about these tools can be found on the
External Resources page.

Plugins are different from extensions, which modify or enhance the functionality of the browser
itself. Plugins are also different from search plugins, which plug additional search engines in the
search bar.


={============================================================================
*kt_dev_web_002* URL encode

http://www.url-encode-decode.com/

What is URL encoding?

URL encoding stands for encoding 'certain' characters in a URL by replacing them with one or more
character triplets that consist of the percent character "%" followed by two hexadecimal digits. The
two hexadecimal digits of the triplet(s) represent the numeric value of the replaced character.

For example, the string: François ,would be encoded as: Fran%C3%A7ois

The "ç" is encoded in UTF-8 as two bytes C3 (hex) and A7 (hex), which are then written as the three
characters "%c3" and "%a7" respectively. This can make a URI rather long (up to 9 ASCII characters
        for a single Unicode character), but the intention is that browsers only need to display the
decoded form, and many protocols can send UTF-8 without the %HH 'escaping'. 

The term URL encoding is a bit inexact because the encoding procedure is not limited to URLs
(Uniform Resource Locators), but can also be applied to any other URIs (Uniform Resource
        Identifiers) such as URNs (Uniform Resource Names). Therefore, the term percent-encoding
should be preferred. 


When and why would you use URL encoding?

When data that has been entered into HTML forms is submitted, the form field names and values are
encoded and sent to the server in an HTTP request message using method GET or POST, or,
historically, via email. The encoding used by default is based on a very early version of the
    general URI percent-encoding rules, with a number of modifications such as newline normalization
    and replacing spaces with "+" instead of "%20". The MIME type of data encoded this way is
    application/x-www-form-urlencoded, and it is currently defined (still in a very outdated manner)
    in the HTML and XForms specifications. In addition, the CGI specification contains rules for how
    web servers decode data of this type and make it available to applications.

When sent in an HTTP GET request, application/x-www-form-urlencoded data is included in the query
component of the request URI. When sent in an HTTP POST request or via email, the data is placed in
the body of the message, and the name of the media type is included in the message's Content-Type
header. 


={============================================================================
*kt_dev_web_003* qunit

https://qunitjs.com/intro/

You probably know that testing is good, but the first hurdle to overcome when
trying to write unit tests for client-side code is the lack of any actual units;
JavaScript code is written for each page of a website or each module of an
  application and is closely intermixed with back-end logic and related HTML. In
  the worst case, the code is completely mixed with HTML, as inline events
  handlers.

This is likely the case when no JavaScript library for some DOM abstraction is
being used; writing inline event handlers is much easier than using the DOM APIs
to bind those events. More and more developers are picking up a library such as
jQuery to handle the DOM abstraction, allowing them to move those inline events
to distinct scripts, either on the same page or even in a separate JavaScript
file. However, putting the code into separate files doesn’t mean that it is
ready to be tested as a unit.

What is a unit anyway? In the best case, it is a pure function that you can deal
with in some way - a function that always gives you the same result for a given
input. This makes unit testing pretty easy, but most of the time you need to
deal with side effects, which here means DOM manipulations. It's still useful to
figure out which units we can structure our code into and to build unit tests
accordingly.

<equal>
http://api.qunitjs.com/equal/

equal( actual, expected [, message ] )


={============================================================================
*kt_dev_web_003* java scripts to check on video element

video.addEventListener("timeupdate", function() {
    equal(video.currentTime, 6, "Unexpected currentTime");
    equal(video.played.length, 1, "Unexpected played range");
    equal(video.played.start(0), 0, "Unexpected start of played range");
    equal(video.played.end(0), 6, "Unexpected end of played range");
    equal(video.seekable.length, 1, "Unexpected seekable range");
    equal(video.seekable.start(0), 0, "Unexpected start of seekable range");
    equal(video.seekable.end(0), 1200, "Unexpected end of seekable range");
    equal(video.buffered.length, 1, "Unexpected buffered range");
    equal(video.buffered.start(0), 0, "Unexpected start of buffered range");
    equal(video.buffered.end(0), 256, "Unexpected end of buffered range");
    start();
});

note: BBC iplayer uses 'mediaPlayerVideo' ALWAYS

(function() {
    video = document.getElementById('mediaPlayerVideo');
    video.addEventListener("ended", function() {
    console.log("ended");
    });
})()

(function() {
    video = document.getElementById('mediaPlayerVideo');
    video.addEventListener("timeupdate", function() {
    console.log("currentTime:", video.currentTime);
    });
})()


<addeventlistener>
http://www.w3schools.com/jsref/met_document_addeventlistener.asp
https://www.w3.org/2003/01/dom2-javadoc/org/w3c/dom/events/EventTarget.html

The document.addEventListener() method attaches an event handler to the
document.

document.addEventListener(event, function, useCapture)

event 	Required. 

A String that specifies the name of the event. Note: Do not use the "on" prefix.
For example, use "click" instead of "onclick".

For a list of all HTML DOM events, look at our complete HTML DOM Event Object
Reference.

function 	Required. 

Specifies the function to run when the event occurs.

When the event occurs, an event object is passed to the function as the first
parameter. The type of the event object depends on the specified event. For
example, the "click" event belongs to the MouseEvent object.


<settimeout>
http://www.w3schools.com/jsref/met_win_settimeout.asp

The setTimeout() method calls a function or evaluates an expression after a
specified number of milliseconds.

Syntax
setTimeout(function,milliseconds,param1,param2,...)

function            Required. 
The function that will be executed

milliseconds        Required. 
The number of milliseconds to wait 'before' executing the code

param1,param2,...   Optional. 
Additional parameters to pass to the function (Not supported in IE9 and earlier)

Return Value: 
A Number, representing the ID value of the timer that is set. Use this value
with the clearTimeout() method to cancel the timer

setTimeout(function(){ x.value="2 seconds" }, 2000);


={============================================================================
*kt_dev_web_004* html standard

https://html.spec.whatwg.org/multipage/index.html

https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement


={============================================================================
*kt_dev_web_005* crome dev tool

https://developers.google.com/web/tools/chrome-devtools/


={============================================================================
*kt_dev_web_005* user agent

YouView devices have a number of software components that use HTTP/1.1 to
communicate over the Internet. HTTP allows a User-Agent header field to be
included in the request. The purpose of the User-Agent header field is to
identify the application that made the request.

In order to allow servers to differentiate between requests from YouView devices
and requests from other HTTP clients, and to provide additional details about
device capabilities and versions, it is necessary to have a standard template
for User-Agent headers on YouView devices.

IETF, RFC 2616 – Hypertext Transfer Protocol -- HTTP/1.1, June 1999.

The design and construction of a User-Agent string for YouView must follow the
requirements of RFC 2616, which defines the form of the User-Agent string. In
addition, the UK DTG D-Book defines tokens which must be included in the
User-Agent string for requests relating to D-Book functionality.

HTTP/1.1 is defined in RFC 2616. The specification states that a User-Agent
header field should be included in the header of requests made. The header field
is formed of one or more product tokens, by convention listed in order of their
significance. The format is defined by the BNF grammar specified in RFC 2616 (in
        sections 14.43, 3.8 and 2.2), part of which is reproduced below.

User-Agent = “User-Agent” “:” 1*( product | comment )
product = token [ “/” product-version ]
product-version = token

That part of the header field following the initial “User-Agent: ” is referred
to here as the User-Agent string.


==============================================================================
Copyright: see |ktkb|                              vim:tw=100:ts=3:ft=help:norl:
