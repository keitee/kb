*kt_dev_03*		tw=100

aThu 13 Feb 2014 13:38:09 GMT

Keywords:
{Q} for questions to find out more
{design-note} for design considerations
{LL} for lessons learned

KT KB. DEVELOPMENT. CODE.

|kt_dev_code_001| fsm	

|kt_dev_design_001| use state and if checks	

# ============================================================================
#{

==============================================================================
*kt_dev_code_001* fsm	

From nds vrm, view record manager, component. The summary is:

0> This fsm uses sesseion base which means that it creates a fsm instance for each session and
manage its state. That is why this fsm module creates its data structure at runtime.

1> This function can send a messages which is async and or call a function. The route to this
function can come from thread or from action function in fsm. This implies that the user who design
a state machine must know whether to end function call in fsm action chain or to send a message.

2> This defines a fsm definition for each scenario type such as basic record and play, review
buffer play and record, and remider. Creates instance for each type when request comes. 

3> This uses state and input(event) to define a fsm. Be better to use enuerator a bit clearer.


//
// FSM structures
//

/* fsm definition handle */
typedef void* VRM_FSM_DEFINITION_HANDLE; 

/* handle to FSM instance */
typedef void* VRM_FSM_INSTANCE_HANDLE;


<eaf-source>

0> This can be a server thread running fsm
1> This can be an another eaf.
2> This can be an notification callback from other threads. For example, play creates a play and do
preparation and waits notification from MC. This fsm call chains end there. When MC notification
arrives starts to run fsm again.

//
// Thead Main
// 
stat = VRM_OS_THR_Create( &VrmSrvThread, VRM_SRV_THREAD_NAME, VrmSrvMain, NULL );

static void * VrmSrvMain(void* data)
{
  while( isRunVrmSrv )
  {
    /* Get a message from the queue */
    stat = SYSTEMITC_API_PendEvent(&VrmSrvItcQueueHandle, SYSTEMITC_API_PEND_FOREVER);
    if (!SYSTEM_STATUS_IS_OK(stat)) {
      VRM_DIAG_ASSERT_ZERO ("error in SYSTEMITC_API_PendEvent, VRM terminate");
      break;
    }
    payloadsize = SYSTEMITC_API_MAX_PAYLOAD_SIZE;
    stat = SYSTEMITC_API_ReadEvent(&VrmSrvItcQueueHandle, &event, (void*)payload , &payloadsize);
    if (!SYSTEM_STATUS_IS_OK(stat)) {
      VRM_DIAG_ASSERT_ZERO ("error in SYSTEMITC_API_ReadEvent, VRM terminate");
      break;
    }

    /* Dispatch the message */
    stat = VrmSrvReceiveMessage(event,payload,payloadsize);
  }
}

static SYSTEM_STATUS VrmSrvReceiveMessage (uint32_t event, void *payload, uint32_t payloadsize)
{
  // partition a event into sub range
  moduleId = VRM_GET_MSG_SUBCOMP_ID(event);

  if (SYSTEM_STATUS_IS_OK(stat))
  {
    switch (moduleId){
      ...
      case E_VRM_SUBCOMP_ID_ENGINE_LIVE:
        stat = LIVE_ReceiveMessage (event, payload, payloadsize);
        break;
      case E_VRM_SUBCOMP_ID_ENGINE_PLAY:
        stat = PLAY_ReceiveMessage (event, payload, payloadsize);
        break;
        ...
      default:
          VRM_DIAG_ASSERT_ZERO ("Unexpected message type");
          stat = VRM_STATUS_FAILURE;
          break;
    }
  }

  DIAG_LOG_INFO( VRM_diag_segment_id, ("finished. %s", VRM_TYPE2STR_SystemStatus(stat)) );

  return stat;
}

SYSTEM_STATUS PLAY_ReceiveMessage(uint32_t event, void *payload, uint32_t payloadsize)
{
	/* dispatch message to the appropriate message according to the private play module msg type */
	if (SYSTEM_STATUS_IS_OK (stat)) {
		switch ((E_PLAY_MSG_TYPE)event) 
		{
			case E_PLAY_MSG_TYPE_FSM:
				if ((payload != NULL) && (payloadsize == sizeof(PLAY_FSM_MSG_PAYLOAD)))
				{
					p_fsm_payload = (PLAY_FSM_MSG_PAYLOAD *)payload;
				}
				else 
				{
					VRM_DIAG_ASSERT_ZERO ("msg type mismatch");
					stat = PLAY_STATUS_FAILURE;
				}
				if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_payload != NULL))
				{
					stat = PlayGetFromPlayHandle (p_fsm_payload -> play_handle, &pThis);
				}
				if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_payload != NULL)) {
					stat = PlaySendFSMInput (pThis, p_fsm_payload->play_input, SYNCHRONOUS); ~
				}
				break;

			case E_PLAY_MSG_TYPE_FSM_DESTROY:
				if ((payload != NULL) && (payloadsize == sizeof(PLAY_FSM_DESTROY_MSG_PAYLOAD)))
				{
					p_fsm_destroy_payload = (PLAY_FSM_DESTROY_MSG_PAYLOAD	*)payload;
				}
				else 
				{
					VRM_DIAG_ASSERT_ZERO("msg type mismatch");
					stat = PLAY_STATUS_FAILURE;
				}
				if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_destroy_payload != NULL))	{
					stat = VRM_FSM_DestroyInstance (p_fsm_destroy_payload->hFsm);
					VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
				}
				break;

			default:
					VRM_DIAG_ASSERT_ZERO  ("Unknown message type");
					break;

		}
	}
}


// [KT] This function can send a messages which is async and or call a function.  The route to this
// function can come from thread or from action function in fsm.
static SYSTEM_STATUS PlaySendFSMInput(const BASIC_PLAY * pThis, E_PLAY_INPUT fsm_input, bool is_async)
/* WARNING: if is_asynch is set to XFALSE this function will change the state of the FSM, so no actions which
 			are state dependant may be done by the calling function after this function has been called. */
{
	SYSTEM_STATUS stat = PLAY_STATUS_OK;
	PLAY_FSM_MSG_PAYLOAD fsm_msg;

	DIAG_DECLARE_FUNCTION ("PlaySendFSMInput");

	if (pThis != NULL )
	{
		DIAG_LOG_PARAMS (VRM_diag_segment_id, ("Start. hPlay = 0x%x, input = %s, mode = %s",	
			pThis -> hPlay, PlayGetInputStr (fsm_input), is_async == true ? "Async" : "Sync"));

		if (is_async == true) {
			/* send message to handle state transitions */
			fsm_msg.play_input  = fsm_input;
			fsm_msg.play_handle = pThis->hPlay;
			stat = PlaySendMessage (E_PLAY_MSG_TYPE_FSM, &fsm_msg, sizeof (PLAY_FSM_MSG_PAYLOAD));
		} else {
			/* process the input by the FSM immediately */
			stat = VRM_FSM_Input (pThis -> fsm, (uint16_t)fsm_input);
		}
	}
	else {
		stat = PLAY_STATUS_FAILURE;
	}

   VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
	return stat;
}


//
// Instance creation. VRM_FSM_CreateInstance
//

<basic_play_c>

/* structure stored per playing program */
typedef struct BASIC_PLAY_ {
  ...
  /* state machine data */
  VRM_FSM_INSTANCE_HANDLE fsm;         	/* handle of finite state machine				*/
  ...
} BASIC_PLAY;


/* Stores the currently playing sessions */
static BASIC_PLAY BasicPlay[BASIC_PLAY_MAX_HANDLES_NUM];

// one handle for one definition. In this case basic_play.c
static VRM_FSM_DEFINITION_HANDLE fsm_definition_handle;

This defines a state machine ~

typedef enum E_PLAY_INP_ {
  E_PLAY_INPUT_NULL,
  E_PLAY_INPUT_START,				/* request to start play job					*/
  E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE,	/* acquire RMF resources					*/
  ...
  E_PLAY_INPUT_LAST
} E_PLAY_INPUT;

/* Possible Play state machine states */
typedef enum E_PLAY_INTERNAL_STATE_
{
	E_PLAY_INT_STATE_NONE = 0,
	E_PLAY_INT_STATE_STARTING,				/*	play is starting process					*/
	E_PLAY_INT_STATE_ALLOCATING_RESOURCES,  /*	play is allocating RMF resources			*/
  ...
	E_PLAY_INT_STATE_LAST
} E_PLAY_INTERNAL_STATE;

static VRM_FSM_ENTRY PlayEntries[] = {

  VRM_FSM_E(  VRM_FSM_ALL_STATES,			/* (current) state */ 
      E_PLAY_INPUT_STOP, 					/* input */
      E_PLAY_INT_STATE_RELEASED_MEDIACONN,/* new state */
      (VRM_FSM_ACTION)PlayActionGeneralTrap ),/* action */

  <1> STATE_NONE & INPUT_START -> E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE
  VRM_FSM_E(  E_PLAY_INT_STATE_NONE,        	/* state */
      E_PLAY_INPUT_START,   				/* input */
      E_PLAY_INT_STATE_STARTING,        	/* new state */
      (VRM_FSM_ACTION) PlayActionStartingState ),	/* action */

  <2>
  VRM_FSM_E(  E_PLAY_INT_STATE_STARTING,        	/* state */
      E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE,  /* input */
      E_PLAY_INT_STATE_ALLOCATING_RESOURCES,/* new state */
      (VRM_FSM_ACTION) PlayActionRmfAllocatingResourcesState ), /* action */

  ...
};


<eaf>

0> if want to eaf chain then just have a eaf which do nothing.

static void PlayActionStartingState(BASIC_PLAY *pThis) \Description: Handles entering starting state. 
{
  ...
  /* input the fsm sync to acquire rmf resources */
  if (SYSTEM_STATUS_IS_OK (pThis->last_status)) {
    pThis->vfile_start_position = vfile_start_position.offset;
    pThis->last_status = VRM_FSM_SetNextInput (pThis -> fsm, (uint16_t)E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE);
  }

  return;
}

SYSTEM_STATUS VRM_FSM_SetNextInput(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t input) {
  ...
  /* in release mode, we recover by: */
  return VRM_FSM_Input(fsm_h,input); excute a state machine ~
}

SYSTEM_STATUS VRM_FSM_Input(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t input)
{
  FSM_DEFINITION* def = NULL;
  FSM_T fsm = (FSM_T)fsm_h; 
  SYSTEM_STATUS stat = VRM_FSM_OK;

  if (fsm == NULL) { 
    _fsm_error(par_err);
    stat = VRM_FSM_FAILURE;
  }

  /* check user is not calling this function from within an action function */ 
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if (fsm->in_action) {
     
    // in debug mode, _fsm_error() call VRM_DIAG_Abort and can call DIAG_About depending on vrm configuration ~
    // value. in release mode, do nothing. so there is no harm to let it run. ~

      _fsm_error(act_err); 
      /* stat = VRM_FSM_FAILURE; */
      /* in release mode, we will recover by: */
      return VRM_FSM_SetNextInput(fsm_h,input);
    }
  }
	  
  if (SYSTEM_STATUS_IS_OK(stat)) {
    def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle);
  }
	
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if ((input > def->max_input) || (input < def->min_input)) { 
      _fsm_error(par_err);  
      stat = VRM_FSM_FAILURE; 
    }
  } 

  if  (SYSTEM_STATUS_IS_OK(stat)) { 
    if (!fsm->input_available) {
      fsm->input_available = true;
      fsm->input_offset = input - def->min_input;		  
    }
    else { 
      stat = VRM_FSM_FAILURE; /* this sould not happen */  		 
      VRM_DIAG_ASSERT_ZERO("Internal FSM error");
    }
  }
	 
  /* run FSM while there is input available */
  while (SYSTEM_STATUS_IS_OK(stat) && (true == fsm->input_available)) { 
    stat = FSMRun(fsm_h); 
  } 

  return stat;
}

static SYSTEM_STATUS FSMRun(VRM_FSM_INSTANCE_HANDLE fsm_h) {

  SYSTEM_STATUS stat = VRM_FSM_OK;
  FSM_TRANS   *pTrans;
  uint16_t     offset;
  FSM_T       fsm = (FSM_T)fsm_h;
  VRM_FSM_ENTRY   cb_entry;
  FSM_DEFINITION* def = NULL;

#if 0 /*ifdef VRM_DEBUG*/
  SYSTEMTIME_TIMEDATE currentTime;                            /* The current time */
  char timeStrCurrent[SYSTEMTIME_MIN_STRING_BUFFER_SIZE] = "";/* String to print the date */
  int32_t timeSize = SYSTEMTIME_MIN_STRING_BUFFER_SIZE;           /* String size to print the date */
#endif

  DIAG_DECLARE_FUNCTION("FSMRun");	 

  /* in any case reset input available flag */ 	
  fsm->input_available = false;

  def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle);
    	
  /* calculate offset in states table -> from old state (state_offset) & input */
  offset = (fsm->state_offset * def->num_inputs) + fsm->input_offset; 

  /* set a pointer to the table's entry */
  pTrans = def->table + offset;

#ifdef VRM_DEBUG
  DIAG_LOG_INFO( VRM_diag_segment_id,
      ("--------- [%s] ---------",fsm->name));

  DIAG_LOG_INFO(VRM_diag_segment_id,
      ("state:     %s",TraceState(fsm, fsm->state_offset)));

  DIAG_LOG_INFO(VRM_diag_segment_id,
      ("input:     %s",TraceInput(fsm, (uint16_t)(fsm->input_offset + def->min_input))));

  DIAG_LOG_INFO(VRM_diag_segment_id,
      ("new state: %s",TraceState(fsm, pTrans->new_state)));

#if 0 /* getting current time is a very heavy operation */
  /* Get the current time */
  stat = SYSTEMTIME_GetTime(&currentTime);

  if (SYSTEM_STATUS_IS_OK(stat)) {
    stat = SYSTEMTIME_DebugString(currentTime, timeStrCurrent, &timeSize);
  }

  DIAG_LOG_INFO(VRM_diag_segment_id,("current time: %s (%d)\n", timeStrCurrent, currentTime));
#endif /* 0 */

#endif

  /* L.R. */
  if ( VRM_FSM_ILLEGAL_STATE == pTrans->new_state ) {	    
    DIAG_LOG_INFO( VRM_diag_segment_id,
        ("^__ Attention: Undefined fsm_entry !!!")); 					 
  }
 
  /* Setup the callback if any */
  if (fsm->init.callback != NULL) {
    cb_entry.state	= fsm->state_offset + def->min_state;
    cb_entry.input = fsm->input_offset + def->min_input;
    cb_entry.new_state = pTrans->new_state + def->min_state;
  }

  /* If there is a real new state, set it */
  if (pTrans->new_state != VRM_FSM_ILLEGAL_STATE) {

    /* set the state_offset + initialize timeout if needed */
    stat = FSMSetState((VRM_FSM_INSTANCE_HANDLE)fsm, pTrans->new_state);

    if (SYSTEM_STATUS_IS_OK(stat)) { 
      fsm->in_action = true;     eaf guard start ~

      /* Carry out action */
      if (pTrans->action) {
        (*pTrans->action)(fsm->init.data);
      }

      /* Call the callback if any */
      if (fsm->init.callback) {
        fsm->init.callback (fsm->init.data, &cb_entry);
      }

      fsm->in_action = false;	   eaf guard end ~
    }	
  }
	
  return stat; 
}


<play-start>

SYSTEM_STATUS PLAY_Start( const PLAY_PARAMS	*p_play_params,
						  PLAY_HANDLE		*p_hPlay)
{
  /* allocate a new playback - if playback already exists -  will return its play object */
  if (SYSTEM_STATUS_IS_OK (stat)) {
      stat = PlayAllocateNew (p_play_params, &pPlaySession);
  }

  /* send fsm input to start */
  if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
    stat = PlaySendFSMInput (pPlaySession, E_PLAY_INPUT_START, ASYNCHRONOUS);
  }
}

static SYSTEM_STATUS PlayAllocateNew (	const PLAY_PARAMS	*p_play_params, BASIC_PLAY **ppNew_play_session)
{
  if (SYSTEM_STATUS_IS_OK (stat)) {
    defines max number of plays ~
    stat = PlayInitializeEntry (&(BasicPlay[new_index]), p_play_params); 
    if (!SYSTEM_STATUS_IS_OK (stat)) {
      DummyStatus = PlayFree(&(BasicPlay[new_index]));
    }
  }
}

static SYSTEM_STATUS PlayInitializeEntry (BASIC_PLAY *pThis, const PLAY_PARAMS	*p_play_params)
{
  VRM_FSM_INIT	init; /* FSM initialization structure */

  pThis -> fsm = NULL;

  /* initialize fsm init data */ ~
  memset( &init, 0, sizeof(VRM_FSM_INIT));
  init.fsm_definition_handle	= fsm_definition_handle;
  init.callback				= (VRM_FSM_TRANS_CB)PlayActionFsmOnExit;
  init.init_state				= (uint16_t)E_PLAY_INT_STATE_NONE;
  init.timeout_callback		 = NULL; 
  init.data = (void *)(pThis);

  if (SYSTEM_STATUS_IS_OK (stat)) {
    stat = VRM_FSM_CreateInstance (&init, &(pThis->fsm)); ! set fsm instance ~
    VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
  }

  if (SYSTEM_STATUS_IS_OK (stat)) {
    sprintf ((char *)name_str, "play:0x%x", pThis -> hPlay);
    stat = VRM_FSM_SetName (pThis -> fsm, name_str);
    VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
  }

}


<FSM_T> /* FSM internal control structure - per instance. */

typedef struct _fsm
{
  VRM_FSM_INIT  init;									/* initialization data */

#ifdef VRM_DEBUG
  int8_t		  name[VRM_VSM_MAX_INSTANCE_NAME_LEN];  /* name of instance */
#endif

  uint16_t	  state_offset;							/* current state of the FSM */
  uint16_t    input_offset;							/* input value that will be processed */
  bool		  input_available;						/* true if input is available, false otherwise */

  uint16_t    timeout_input;						/* input to be sent as callback paramter when timeout */
  SYSTEMALARM_ALARM_HANDLE   alarm_handle;			/* alarm used for timeout */

  bool		   alarm_expected;	  /* true after alarm is set, false if alarm is not set, cancled or timed out */	
  bool         in_action;           /* when action is preformed this flag is true */

} *FSM_T;

SYSTEM_STATUS VRM_FSM_CreateInstance(const VRM_FSM_INIT *pInit, VRM_FSM_INSTANCE_HANDLE *pHandle) 						   
{	 
  FSM_DEFINITION* def;
  SYSTEM_STATUS	stat = VRM_FSM_OK;
  SYSTEM_STATUS   stat_memman = MEMMAN_API_STATUS_OK;
  FSM_T			   new_fsm = 0;
	
  DIAG_DECLARE_FUNCTION("VRM_FSM_CreateInstance");

  /* sanity checking */ 	
  if ((pInit == NULL) || (pInit->fsm_definition_handle == VRM_FSM_ILLEGAL_DEFINITION)) {
    _fsm_error(par_err);  
    stat = VRM_FSM_FAILURE; 
  }	 

  /* Allocate FSM instance */
  if (SYSTEM_STATUS_IS_OK(stat)) { 

    new_fsm = (FSM_T)MEMMAN_API_AllocElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
        p_instances_allocator);

    /* check for allocation error */
    if (NULL == new_fsm) { 		
      _fsm_error(mem_err);
      stat = VRM_FSM_FAILURE; 
    } 
  }

  /* initialize the allocated structure */
  if (SYSTEM_STATUS_IS_OK(stat)) { 

    /* copy the initialization data */ ~
    memcpy(&(new_fsm->init), pInit, sizeof(VRM_FSM_INIT));

    /* set the name to null string */
#ifdef VRM_DEBUG
    *(new_fsm->name) = 0;    
#endif

    new_fsm->input_available = false;

    /* get the FSM definition */ ~
    def = (FSM_DEFINITION*)(new_fsm->init.fsm_definition_handle);
    
    /* increase instance count for the used definition */
    new_fsm->in_action = false;

    /* alarm is not valid */ 
    new_fsm->alarm_expected = false;

    /* set the initial state */ ~
    stat = FSMSetState((VRM_FSM_INSTANCE_HANDLE)new_fsm, (uint16_t)(new_fsm->init.init_state - def->min_state));

    /* consider error case */
    if (!SYSTEM_STATUS_IS_OK(stat)) {   

      /* free the instance */ 
      stat_memman = MEMMAN_API_FreeElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
          p_instances_allocator,(void*)new_fsm); 

      *pHandle = NULL;		  

      VRM_DIAG_ASSERT_ZERO("Error encountered while trying to set initial state to new FSM instance");
    } 
    else {
      def->instances_count++; increase instance counter ~
    }
  } // if end

  if (SYSTEM_STATUS_IS_OK(stat)) { 
    /* set the handle */ return fsm instance ~
    *pHandle = (VRM_FSM_INSTANCE_HANDLE)new_fsm; 
  }

  return stat;  
}

//
// Set State
//
static SYSTEM_STATUS FSMSetState(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t state)
{
  SYSTEM_STATUS stat = VRM_FSM_OK;
  FSM_DEFINITION* def = NULL; 
  FSM_T fsm = (FSM_T)fsm_h;
  uint16_t state_offset = 0u;

  /* check FSM is not performing an action */ 
  if (fsm->in_action) {
    stat = VRM_FSM_FAILURE; 
  }
 	
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    /* get the FSM definition */
    def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle); 

    /* calculate the state offset */
    state_offset = state - def->min_state; 

    /* check validity */
    if (state_offset >= def->num_states) {  
      _fsm_error(par_err); 
      stat = VRM_FSM_FAILURE;
    }
  }

  if (SYSTEM_STATUS_IS_OK(stat)) { 
    /* set the new state */ ~
    fsm->state_offset = state_offset;

    /* set the input that is injected when timeout from this state */
    fsm->timeout_input = def->timeouts[state].input;

    /* cancel previous alarm if needed */
    if (true == fsm->alarm_expected) { 
      alarm_stat = SYSTEMALARM_Cancel(fsm->alarm_handle);  

#ifdef VRM_DEBUG 
      if (!SYSTEM_STATUS_IS_OK(alarm_stat)) {
        DIAG_LOG_INFO(VRM_diag_segment_id,("Previous alarm could not be canceled. fsm->name: %s",fsm->name));
      } 
#endif

      fsm->alarm_expected = false;
    } 
	  	  
    /* do we need to set a new alarm? */ 
    ...
	} 	 

	return stat; 
}


//
// Init
//

/* FSM definition info structure */
typedef struct _fsm_definition_info {
  VRM_FSM_ENTRY* entries;                    /* must be static during definition's life time */ 											  
  uint16_t num_entries;				   
  VRM_FSM_TIMEOUT* timeouts;				   /* must be static during definition's life time */ 
  uint16_t num_timeouts;
} VRM_FSM_DEFINITION_INFO; 

SYSTEM_STATUS PLAY_Init(void)
{
  VRM_FSM_DEFINITION_INFO fsm_info;

  /* initialize FSM definition info structure */
  fsm_info.entries = PlayEntries;
  fsm_info.num_entries = (uint16_t)NELEMENTS(PlayEntries);
  fsm_info.timeouts = NULL;
  fsm_info.num_timeouts = 0u;

  // set fsm_definition_handle which is static global
  stat = VRM_FSM_CreateDefinition (&fsm_info, &fsm_definition_handle);
  VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));

  /* initialize fields to null values */
  memset(BasicPlay, 0, (size_t)(sizeof(BASIC_PLAY) * BASIC_PLAY_MAX_HANDLES_NUM));

  for (i=0u; i < BASIC_PLAY_MAX_HANDLES_NUM; i++) {
    /* set session id to illegal -  indicates that entry is not in use */
    BasicPlay[i].hPlay = PLAY_HANDLE_ILLEGAL;
  }
  ...
}

/* State transition. Contains the new state and the action to be taken. */
typedef struct fsm_trans {
    uint16_t new_state;             /* new state */    
	VRM_FSM_ACTION action;			/* action on this transition */	
} FSM_TRANS;

/* fsm definition structure */
typedef struct _fsm_definition { 
  VRM_FSM_DEFINITION_INFO def_info;

  uint16_t     min_state, max_state, num_states;
  uint16_t     min_input, max_input, num_inputs;

  FSM_TRANS   *table;        /* transitions table in size of states_num*inputs_num */
  FSM_TIMER   *timeouts;     /* timeouts array in size of states_num */

  uint16_t instances_count;   /* number of live instances of this FSM definition */
} FSM_DEFINITION;

// The states and inputs starts from 0 in state machine definition.
#define VRM_FSM_ILLEGAL_STATE	((uint16_t)0xFFFFu)   // seems not used
#define VRM_FSM_ALL_STATES		(uint16_t)0xFFFE


SYSTEM_STATUS VRM_FSM_CreateDefinition(const VRM_FSM_DEFINITION_INFO* pFSM_definition_info,
									   VRM_FSM_DEFINITION_HANDLE* pHandle)
{

  uint16_t     i = 0u;
  uint16_t     count = 0u;
  uint16_t     offset;
  uint16_t     state;
  uint16_t     first_state;
  uint16_t     last_state;
  VRM_FSM_ENTRY   *pEntry;
  FSM_TRANS   *pTrans;
	SYSTEM_STATUS stat = VRM_FSM_OK;
	SYSTEM_STATUS stat_memman = MEMMAN_API_STATUS_OK; 
	FSM_DEFINITION* fsm_definition = NULL;

	/* Check for parameter errors */
	if (pFSM_definition_info->entries == 0) { 
      _fsm_error(par_err); 
      stat = VRM_FSM_FAILURE;
	}

	/* allocate space for definition structure */ 
	if (SYSTEM_STATUS_IS_OK(stat)) {
	  fsm_definition = (FSM_DEFINITION*)MEMMAN_API_AllocElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
		  p_definitions_allocator);
	}

  /* check for allocation error */
	if (SYSTEM_STATUS_IS_OK(stat) && (fsm_definition == NULL)) { 
      _fsm_error(mem_err); 
      stat = VRM_FSM_FAILURE;
	}

	/* set definition info */ 
	if (SYSTEM_STATUS_IS_OK(stat)) { 
	  
	  /* copy info */
	  fsm_definition->def_info.entries = pFSM_definition_info->entries;
	  fsm_definition->def_info.num_entries = pFSM_definition_info->num_entries; 
	  fsm_definition->def_info.timeouts = pFSM_definition_info->timeouts; 
	  fsm_definition->def_info.num_timeouts = pFSM_definition_info->num_timeouts;

	  /* no instances at this time */ 
	  fsm_definition->instances_count = 0u;
	
    /* Scan for the range of states and inputs */
    fsm_definition->min_state = (uint16_t) -1;
    fsm_definition->min_input = (uint16_t) -1;
    fsm_definition->max_state = 0u;
    fsm_definition->max_input = 0u;

    // For fsm entry array which is a state machine, calculate min and max value for state, next
    // state, and input. For all states entry, do only for input. Seems that no use of doing for all
    // state case.

    for (i = 0u; i < pFSM_definition_info->num_entries; i++) 
    {
        if ((pFSM_definition_info->entries[i].state != VRM_FSM_ILLEGAL_STATE) &&
            (pFSM_definition_info->entries[i].state != VRM_FSM_ALL_STATES )   ) 
        {
          if (pFSM_definition_info->entries[i].state < fsm_definition->min_state) {
                    fsm_definition->min_state = pFSM_definition_info->entries[i].state;
          }
          if (pFSM_definition_info->entries[i].state > fsm_definition->max_state) { 
                    fsm_definition->max_state = pFSM_definition_info->entries[i].state;
          }
          if (pFSM_definition_info->entries[i].new_state < fsm_definition->min_state) {
                    fsm_definition->min_state = pFSM_definition_info->entries[i].new_state;
          }
          if (pFSM_definition_info->entries[i].new_state > fsm_definition->max_state) {
                    fsm_definition->max_state = pFSM_definition_info->entries[i].new_state;
          }
        }

        if (pFSM_definition_info->entries[i].input < fsm_definition->min_input) { 
                fsm_definition->min_input = pFSM_definition_info->entries[i].input;
        }
        if (pFSM_definition_info->entries[i].input > fsm_definition->max_input) {
                fsm_definition->max_input = pFSM_definition_info->entries[i].input;
        }
      } // for end

      // get the number of state and inputs; for example, 0-3 means 4 entries and plus 1.
      fsm_definition->num_states = (fsm_definition->max_state - fsm_definition->min_state) + 1u;
      fsm_definition->num_inputs = (fsm_definition->max_input - fsm_definition->min_input) + 1u;

      why state * input? ~
      count = fsm_definition->num_states * fsm_definition->num_inputs;
	}

	if (SYSTEM_STATUS_IS_OK(stat)) { 
  
    /* Allocate the states table */    
    fsm_definition->table = 
      (FSM_TRANS *)MEMMAN_API_CallocStaticP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
          (uint32_t)count, (uint32_t)sizeof(FSM_TRANS));

    /* check for allocation error */
    if (fsm_definition->table == 0) {

      /* assert */ 
      _fsm_error(mem_err);

      stat_memman = MEMMAN_API_FreeElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
          p_definitions_allocator, fsm_definition);

      fsm_definition = NULL;

      stat = VRM_FSM_FAILURE;
    } 
  } 

  ...

	if (SYSTEM_STATUS_IS_OK(stat)) { 

    /* initialize the entries in the table */
    for (i = 0u; i < count; i++) {
      fsm_definition->table[i].new_state = VRM_FSM_ILLEGAL_STATE;
    }
   
    /* Fill the table */
    for (i = 0u; i < pFSM_definition_info->num_entries; i++) {

      pEntry = pFSM_definition_info->entries + i;

      if (pEntry->state == VRM_FSM_ALL_STATES) {
        first_state = fsm_definition->min_state;
        last_state = fsm_definition->max_state;
      }
      else {
        first_state = pEntry->state;
        last_state = pEntry->state;
      }

      // table[state*input]
      //
      // for state 0 {
      //               input 0
      //               ...
      //               input max
      //             }
      // for state 1 {
      //               input 0
      //               ...
      //               input max
      //             }
      // ...
      // for state max {
      //               input 0
      //               ...
      //               input max
      //             }
      //
      // For ALL_STATES case, set entries for all state set. For other cases, set entry for that
      // state. Seems waste of memory?
      
      for (state = first_state; state <= last_state; state++) {
        offset = (fsm_definition->num_inputs * (state - fsm_definition->min_state)) + (pEntry->input - fsm_definition->min_input);
        pTrans = fsm_definition->table + offset;

        /* we keep the states offsets, rather than the states themself */
        pTrans->new_state = pEntry->new_state - fsm_definition->min_state;
        pTrans->action = pEntry->action;
      }
    }
    ...

	  /* set the returned handle */ 
	  *pHandle = (VRM_FSM_DEFINITION_HANDLE)fsm_definition;
	} 
	
	if (!SYSTEM_STATUS_IS_OK(stat)) {
	 *pHandle = VRM_FSM_ILLEGAL_DEFINITION;
	}

  return stat;		
}


# ============================================================================
#{

==============================================================================
*kt_dev_design_001* use state and if checks	

{example-one}

This uses checks on stat to continue running next step and if it is not okay, stop and return at the
end. If fails in the first, then will run if for every remaining check? Guess not because compiler
will generate a code to jump to the end. Check in assembly code?

SYSTEM_STATUS PLAY_Start( const PLAY_PARAMS	*p_play_params, PLAY_HANDLE		*p_hPlay)
{
	SYSTEM_STATUS stat = PLAY_STATUS_OK;

  /* allocate a new playback - if playback already exists -  will return its play object */
	if (SYSTEM_STATUS_IS_OK (stat)) {
        stat = PlayAllocateNew (p_play_params, &pPlaySession);
	}

	/* send fsm input to start */
	if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
		stat = PlaySendFSMInput (pPlaySession, E_PLAY_INPUT_START, ASYNCHRONOUS);
	}

	if (!SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
		DummyStatus = PlayFree (pPlaySession);
	}

	/*  returned play handle */
	if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
        *p_hPlay = pPlaySession -> hPlay;
	}
	else {
		stat = PLAY_STATUS_FAILURE;
	}

	/* unlock the play module data */
	if (SYSTEM_STATUS_IS_OK(lock_stat)) {
        lock_stat = PlayUnlock ();
	}

	if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
		DIAG_LOG_RETURN (VRM_diag_segment_id, ("ended record_item_ID:0x%x, play handle:0x%x, stat:%s \n",
			pPlaySession->record_item_ID, *p_hPlay, VRM_TYPE2STR_SystemStatus( stat )));
	}
	else {
		DIAG_LOG_ERROR (VRM_diag_segment_id, ("ended record_item_ID:0x%x, play handle:0x%x, stat:%s \n",
			0, *p_hPlay, VRM_TYPE2STR_SystemStatus( stat )));
	}

	return stat;
}


{example-two}

Use return for each step.

bool X::t_Create(void)
{
    // Create options read/write mutex
    m_option_access_mtx = new PCMutex;
    if( m_option_access_mtx == NULL )
    {
        MHEGDebugFatal(eMHEGapp,
                       "Digital Text ReadWrite Mutex could not be instantiated!");
        return false;
    }

    m_option_access_mtx->Create();
    if( !m_option_access_mtx->FlagCreate() )
    {
        MHEGDebugFatal(eMHEGapp,
                       "Digital Text ReadWrite Mutex could not be created!");
        return false;
    }

    m_mheg_stop_mtx = new PCMutex();
    if( m_mheg_stop_mtx == NULL )
    {
        MHEGDebugFatal(eMHEGapp,
                       "MHEG Stop Mutex could not be instantiated!");
        return false;
    }

    m_mheg_stop_mtx->Create();
    if( !m_mheg_stop_mtx->FlagCreate() )
    {
        MHEGDebugFatal(eMHEGapp,
                       "MHEG Stop Mutex could not be created!");
        return false;
    }
}


==============================================================================
*kt_dev_code_ref*	references

{ref-005} C++ primer, 5th Ed.

==============================================================================
Copyright: see |ktkb|  vim:tw=100:ts=3:ft=help:norl:
