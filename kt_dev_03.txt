*kt_dev_03*                                                             tw=100

Keywords:
{source} use this mark to go to each source file

KT KB. DEVELOPMENT. CODE.

|kt_dev_code_000| fsm
|kt_dev_code_001| dynamic fsm
|kt_dev_code_002| static fsm
|kt_dev_code_003| static fsm demo in cpp
*kt_dev_code_004* macro: wait on expression or timed out 

|kt_dev_code_010| asyc: continuation
|kt_dev_code_011| asyc: flow between future, promise, and io_service
|kt_dev_code_012| asyc: future and futuer-then
|kt_dev_code_013| asyc: future helper
|kt_dev_code_013| asyc: promise
|kt_dev_code_014| asyc: future barrier
|kt_dev_code_015| asyc: dispatcher
|kt_dev_code_016| asyc: listener
|kt_dev_code_017| asyc: dispatcher use

|kt_dev_design_001| use state and if checks


# ============================================================================
#{
={============================================================================
*kt_dev_code_000* fsm(finite state machine)

From "designing concurrent distributed and real-time applications with uml". FSM is:

1> to model dynamic aspect of a system.
2> to provide a conceptual model to understand a complexity of a system.
3> to decide what to do which is 'action' depending on input which is 'event' and what has happened
before in a syatem which are history and 'current-state'.
4> is a cause and effect relationship.


{notation}
Based on Harel's notation, UML uses statechart or statechart diagram.

<condition>
Called 'state-variable' and use it to describe when event happens and has boolean value.

// example

Initial
   <- Acel[brake off]   // when 'brake' condition is off.
Accelerating

// example

Down <- After(Elapsed time) [Closedown Was Requested]	// it can be descriptive.
Idel <- After(Elapsed time) [Closedown Was Not Requested]

<action>
This is a operation which is run as a result of state transition. Depict it as:

event[condition]/action

The entry-and-exit-action is action which runs due to transition and which is common action to all
transition.

<activity>
This is a operation which is run during staying a state. Enabled when entering a state and disabled
when out. Depect it as: Do/activity

Accelerating        BrakePressed/Select Desired Speed       Cruising Off
------------       ---------------------------------------->                   
Do/IncreaseSpeed

<related-statechart>
This is concurrent statechart and a output or action from one statechart becomes an input to the
other statechart.

<hierarchical-statechart>
Compared to flat statechart which becomes difficult to depict and read when there are too many state
and transition, has super and substate and provides visual advantage which allows user to focus on
basic concept. 

<guideline>

1> use unique name as a state such as 'Initial', 'Elevator Idle', or 'Elavator moving'
2> state name can be often different from EAF. State action or evant action? 


={============================================================================
*kt_dev_code_001* dynamic fsm

From nds vrm, view record manager, component. The summary is:

0> This fsm uses sesseion base which means that it creates a fsm instance for each session and
manage its state. That is why this fsm module creates its data structure at runtime.

1> This function can send a messages which is async and or call a function. The route to this
function can come from thread or from action function in fsm. This implies that the user who design
a state machine 'must' know whether to end function call in fsm action chain or to send a message.

2> This defines a fsm definition for each scenario type such as basic record and play, review
buffer play and record, and remider. Creates instance for each type when request comes. So
definition is like a class and instance is like a object. 

This build definition in dynamic memory from static fsm state machine entries and build transition
tables in dynamic memory as well. This table array has N state x M inputs. Each state has M entries
for all inputs and one of them will be set based on static definition. For FSM_ALL_STATE which
should apply to all states, so set a specified event for all states. Which is done in
FSM_CreateDefintion.

For eaf, like static, this is state action for each state and there is no check on return since eaf
is void. 

3> This uses state and input(event) to define a fsm. Be better to use enuerator a bit clearer.

4> Like static fsm, there should no gaps in state enumerators.

5> Supports timeout for each fsm instance.

//
// FSM structures
//

/* fsm definition handle */
typedef void* VRM_FSM_DEFINITION_HANDLE; 

/* handle to FSM instance */
typedef void* VRM_FSM_INSTANCE_HANDLE;


<eaf-source>

0> This can be a server thread running fsm
1> This can be an another eaf.
2> This can be an notification callback from other threads. For example, play creates a play and do
preparation and waits notification from MC. This fsm call chains end there. When MC notification
arrives starts to run fsm again.

//
// Thead Main
// 
stat = VRM_OS_THR_Create( &VrmSrvThread, VRM_SRV_THREAD_NAME, VrmSrvMain, NULL );

static void * VrmSrvMain(void* data)
{
  while( isRunVrmSrv )
  {
    /* Get a message from the queue */
    stat = SYSTEMITC_API_PendEvent(&VrmSrvItcQueueHandle, SYSTEMITC_API_PEND_FOREVER);
    if (!SYSTEM_STATUS_IS_OK(stat)) {
      VRM_DIAG_ASSERT_ZERO ("error in SYSTEMITC_API_PendEvent, VRM terminate");
      break;
    }
    payloadsize = SYSTEMITC_API_MAX_PAYLOAD_SIZE;
    stat = SYSTEMITC_API_ReadEvent(&VrmSrvItcQueueHandle, &event, (void*)payload , &payloadsize);
    if (!SYSTEM_STATUS_IS_OK(stat)) {
      VRM_DIAG_ASSERT_ZERO ("error in SYSTEMITC_API_ReadEvent, VRM terminate");
      break;
    }

    /* Dispatch the message */
    stat = VrmSrvReceiveMessage(event,payload,payloadsize);
  }
}

static SYSTEM_STATUS VrmSrvReceiveMessage (uint32_t event, void *payload, uint32_t payloadsize)
{
  // partition a event into sub range
  moduleId = VRM_GET_MSG_SUBCOMP_ID(event);

  if (SYSTEM_STATUS_IS_OK(stat))
  {
    switch (moduleId){
      ...
      case E_VRM_SUBCOMP_ID_ENGINE_LIVE:
        stat = LIVE_ReceiveMessage (event, payload, payloadsize);
        break;
      case E_VRM_SUBCOMP_ID_ENGINE_PLAY:
        stat = PLAY_ReceiveMessage (event, payload, payloadsize);
        break;
        ...
      default:
          VRM_DIAG_ASSERT_ZERO ("Unexpected message type");
          stat = VRM_STATUS_FAILURE;
          break;
    }
  }

  DIAG_LOG_INFO( VRM_diag_segment_id, ("finished. %s", VRM_TYPE2STR_SystemStatus(stat)) );

  return stat;
}

SYSTEM_STATUS PLAY_ReceiveMessage(uint32_t event, void *payload, uint32_t payloadsize)
{
	/* dispatch message to the appropriate message according to the private play module msg type */
	if (SYSTEM_STATUS_IS_OK (stat)) {
		switch ((E_PLAY_MSG_TYPE)event) 
		{
			case E_PLAY_MSG_TYPE_FSM:
				if ((payload != NULL) && (payloadsize == sizeof(PLAY_FSM_MSG_PAYLOAD)))
				{
					p_fsm_payload = (PLAY_FSM_MSG_PAYLOAD *)payload;
				}
				else 
				{
					VRM_DIAG_ASSERT_ZERO ("msg type mismatch");
					stat = PLAY_STATUS_FAILURE;
				}
				if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_payload != NULL))
				{
					stat = PlayGetFromPlayHandle (p_fsm_payload -> play_handle, &pThis);
				}
				if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_payload != NULL)) {
					stat = PlaySendFSMInput (pThis, p_fsm_payload->play_input, SYNCHRONOUS); ~
				}
				break;

			case E_PLAY_MSG_TYPE_FSM_DESTROY:
				if ((payload != NULL) && (payloadsize == sizeof(PLAY_FSM_DESTROY_MSG_PAYLOAD)))
				{
					p_fsm_destroy_payload = (PLAY_FSM_DESTROY_MSG_PAYLOAD	*)payload;
				}
				else 
				{
					VRM_DIAG_ASSERT_ZERO("msg type mismatch");
					stat = PLAY_STATUS_FAILURE;
				}
				if (SYSTEM_STATUS_IS_OK (stat) && (p_fsm_destroy_payload != NULL))	{
					stat = VRM_FSM_DestroyInstance (p_fsm_destroy_payload->hFsm);
					VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
				}
				break;

			default:
					VRM_DIAG_ASSERT_ZERO  ("Unknown message type");
					break;

		}
	}
}


// [KT] This function can send a messages which is async and or call a function.  The route to this
// function can come from thread or from action function in fsm.
static SYSTEM_STATUS PlaySendFSMInput(const BASIC_PLAY * pThis, E_PLAY_INPUT fsm_input, bool is_async)
/* WARNING: if is_asynch is set to XFALSE this function will change the state of the FSM, so no actions which
 			are state dependant may be done by the calling function after this function has been called. */
{
	SYSTEM_STATUS stat = PLAY_STATUS_OK;
	PLAY_FSM_MSG_PAYLOAD fsm_msg;

	DIAG_DECLARE_FUNCTION ("PlaySendFSMInput");

	if (pThis != NULL )
	{
		DIAG_LOG_PARAMS (VRM_diag_segment_id, ("Start. hPlay = 0x%x, input = %s, mode = %s",	
			pThis -> hPlay, PlayGetInputStr (fsm_input), is_async == true ? "Async" : "Sync"));

		if (is_async == true) {
			/* send message to handle state transitions */
			fsm_msg.play_input  = fsm_input;
			fsm_msg.play_handle = pThis->hPlay;
			stat = PlaySendMessage (E_PLAY_MSG_TYPE_FSM, &fsm_msg, sizeof (PLAY_FSM_MSG_PAYLOAD));
		} else {
			/* process the input by the FSM immediately */
			stat = VRM_FSM_Input (pThis -> fsm, (uint16_t)fsm_input);
		}
	}
	else {
		stat = PLAY_STATUS_FAILURE;
	}

   VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
	return stat;
}


//
// Instance creation. VRM_FSM_CreateInstance
//

<basic_play_c>

/* structure stored per playing program */
typedef struct BASIC_PLAY_ {
  ...
  /* state machine data */
  VRM_FSM_INSTANCE_HANDLE fsm;         	/* handle of finite state machine				*/
  ...
} BASIC_PLAY;


/* Stores the currently playing sessions */
static BASIC_PLAY BasicPlay[BASIC_PLAY_MAX_HANDLES_NUM];

// one handle for one definition. In this case basic_play.c
static VRM_FSM_DEFINITION_HANDLE fsm_definition_handle;

This defines a state machine ~

typedef enum E_PLAY_INP_ {
  E_PLAY_INPUT_NULL,
  E_PLAY_INPUT_START,				/* request to start play job					*/
  E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE,	/* acquire RMF resources					*/
  ...
  E_PLAY_INPUT_LAST
} E_PLAY_INPUT;

/* Possible Play state machine states */
typedef enum E_PLAY_INTERNAL_STATE_
{
	E_PLAY_INT_STATE_NONE = 0,
	E_PLAY_INT_STATE_STARTING,				/*	play is starting process					*/
	E_PLAY_INT_STATE_ALLOCATING_RESOURCES,  /*	play is allocating RMF resources			*/
  ...
	E_PLAY_INT_STATE_LAST
} E_PLAY_INTERNAL_STATE;


/* Use this macro for make array of VRM_FSM_ENTRY. */
#define	VRM_FSM_E(w,x,y,z) {(uint16_t)w,(uint16_t)x,(uint16_t)y,z,#w,#x}

typedef struct _fsm_entry {
	uint16_t state;				/* state to which this transition belongs or VRM_FSM_ALL_STATES */
	uint16_t input;				/* input on which the transition works */
	uint16_t new_state;			/* new state */
    VRM_FSM_ACTION action;      /* action on this transition */
	char	*state_str;			/* to support trace */
	char	*input_str;			/* to support trace */
} VRM_FSM_ENTRY;


static VRM_FSM_ENTRY PlayEntries[] = {

  VRM_FSM_E(  VRM_FSM_ALL_STATES,			/* (current) state */ 
      E_PLAY_INPUT_STOP, 					/* input */
      E_PLAY_INT_STATE_RELEASED_MEDIACONN,/* new state */
      (VRM_FSM_ACTION)PlayActionGeneralTrap ),/* action */

  <1> STATE_NONE & INPUT_START -> E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE
  VRM_FSM_E(  E_PLAY_INT_STATE_NONE,        	/* state */
      E_PLAY_INPUT_START,   				/* input */
      E_PLAY_INT_STATE_STARTING,        	/* new state */
      (VRM_FSM_ACTION) PlayActionStartingState ),	/* action */

  <2>
  VRM_FSM_E(  E_PLAY_INT_STATE_STARTING,        	/* state */
      E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE,  /* input */
      E_PLAY_INT_STATE_ALLOCATING_RESOURCES,/* new state */
      (VRM_FSM_ACTION) PlayActionRmfAllocatingResourcesState ), /* action */

  ...
};


<eaf>

0> if want to eaf chain then just have a eaf which do nothing.

static void PlayActionStartingState(BASIC_PLAY *pThis) \Description: Handles entering starting state. 
{
  ...
  /* input the fsm sync to acquire rmf resources */
  if (SYSTEM_STATUS_IS_OK (pThis->last_status)) {
    pThis->vfile_start_position = vfile_start_position.offset;
    pThis->last_status = VRM_FSM_SetNextInput (pThis -> fsm, (uint16_t)E_PLAY_INPUT_RMF_ACQUIRE_RESOURCE); ~
  }

  return;
}

SYSTEM_STATUS VRM_FSM_SetNextInput(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t input) {
  ...
  /* check if not executing action function */
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if (fsm->in_action == false) { ~
      _fsm_error(act2_err);
      /*stat = VRM_FSM_FAILURE;*/

      /* in release mode, we recover by: */
      return VRM_FSM_Input(fsm_h,input);     // excute a state machine ~
    } 
    else { 	     
      /* set the input */ 
      fsm->input_available = true;
      fsm->input_offset = input - def->min_input;     ~
    } 
  }	
}

SYSTEM_STATUS VRM_FSM_Input(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t input)
{
  FSM_DEFINITION* def = NULL;
  FSM_T fsm = (FSM_T)fsm_h; 
  SYSTEM_STATUS stat = VRM_FSM_OK;

  if (fsm == NULL) { 
    _fsm_error(par_err);
    stat = VRM_FSM_FAILURE;
  }

  /* check user is not calling this function from within an action function */ 
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if (fsm->in_action) {
     
    // in debug mode, _fsm_error() call VRM_DIAG_Abort and can call DIAG_About depending on vrm configuration ~
    // value. in release mode, do nothing. so there is no harm to let it run. ~

      _fsm_error(act_err); 
      /* stat = VRM_FSM_FAILURE; */
      /* in release mode, we will recover by: */
      return VRM_FSM_SetNextInput(fsm_h,input);
    }
  }
	  
  if (SYSTEM_STATUS_IS_OK(stat)) {
    def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle);
  }
	
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    if ((input > def->max_input) || (input < def->min_input)) { 
      _fsm_error(par_err);  
      stat = VRM_FSM_FAILURE; 
    }
  } 

  if  (SYSTEM_STATUS_IS_OK(stat)) { 
    if (!fsm->input_available) {
      fsm->input_available = true;
      fsm->input_offset = input - def->min_input;		  ~
    }
    else { 
      stat = VRM_FSM_FAILURE; /* this sould not happen */  		 
      VRM_DIAG_ASSERT_ZERO("Internal FSM error");
    }
  }
	 
  /* run FSM while there is input available */
  while (SYSTEM_STATUS_IS_OK(stat) && (true == fsm->input_available)) { 
    stat = FSMRun(fsm_h); 
  } 

  return stat;
}

static SYSTEM_STATUS FSMRun(VRM_FSM_INSTANCE_HANDLE fsm_h) {

  SYSTEM_STATUS stat = VRM_FSM_OK;
  FSM_TRANS   *pTrans;
  uint16_t     offset;
  FSM_T       fsm = (FSM_T)fsm_h;
  VRM_FSM_ENTRY   cb_entry;
  FSM_DEFINITION* def = NULL;

#if 0 /*ifdef VRM_DEBUG*/
  SYSTEMTIME_TIMEDATE currentTime;                            /* The current time */
  char timeStrCurrent[SYSTEMTIME_MIN_STRING_BUFFER_SIZE] = "";/* String to print the date */
  int32_t timeSize = SYSTEMTIME_MIN_STRING_BUFFER_SIZE;           /* String size to print the date */
#endif

  DIAG_DECLARE_FUNCTION("FSMRun");	 

  /* in any case reset input available flag */ 	
  fsm->input_available = false;

  def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle);
    	
  /* calculate offset in states table -> from old state (state_offset) & input */
  offset = (fsm->state_offset * def->num_inputs) + fsm->input_offset; 

  /* set a pointer to the table's entry */
  pTrans = def->table + offset;

#ifdef VRM_DEBUG
  DIAG_LOG_INFO( VRM_diag_segment_id,
      ("--------- [%s] ---------",fsm->name));

  DIAG_LOG_INFO(VRM_diag_segment_id,
      ("state:     %s",TraceState(fsm, fsm->state_offset)));

  DIAG_LOG_INFO(VRM_diag_segment_id,
      ("input:     %s",TraceInput(fsm, (uint16_t)(fsm->input_offset + def->min_input))));

  DIAG_LOG_INFO(VRM_diag_segment_id,
      ("new state: %s",TraceState(fsm, pTrans->new_state)));

#if 0 /* getting current time is a very heavy operation */
  /* Get the current time */
  stat = SYSTEMTIME_GetTime(&currentTime);

  if (SYSTEM_STATUS_IS_OK(stat)) {
    stat = SYSTEMTIME_DebugString(currentTime, timeStrCurrent, &timeSize);
  }

  DIAG_LOG_INFO(VRM_diag_segment_id,("current time: %s (%d)\n", timeStrCurrent, currentTime));
#endif /* 0 */

#endif

  /* L.R. */
  if ( VRM_FSM_ILLEGAL_STATE == pTrans->new_state ) {	    
    DIAG_LOG_INFO( VRM_diag_segment_id,
        ("^__ Attention: Undefined fsm_entry !!!")); 					 
  }
 
  /* Setup the callback if any */
  if (fsm->init.callback != NULL) {
    cb_entry.state	= fsm->state_offset + def->min_state;
    cb_entry.input = fsm->input_offset + def->min_input;
    cb_entry.new_state = pTrans->new_state + def->min_state;
  }

  /* If there is a real new state, set it */
  if (pTrans->new_state != VRM_FSM_ILLEGAL_STATE) {

    /* set the state_offset + initialize timeout if needed */
    stat = FSMSetState((VRM_FSM_INSTANCE_HANDLE)fsm, pTrans->new_state);

    if (SYSTEM_STATUS_IS_OK(stat)) { 
      fsm->in_action = true;     eaf guard start ~

      /* Carry out action */
      if (pTrans->action) {
        (*pTrans->action)(fsm->init.data);
      }

      /* Call the callback if any */
      if (fsm->init.callback) {
        fsm->init.callback (fsm->init.data, &cb_entry);
      }

      fsm->in_action = false;	   eaf guard end ~
    }	
  }
	
  return stat; 
}


<play-start> <fsm-create-instance>

SYSTEM_STATUS PLAY_Start( const PLAY_PARAMS	*p_play_params,
						  PLAY_HANDLE		*p_hPlay)
{
  /* allocate a new playback - if playback already exists -  will return its play object */
  if (SYSTEM_STATUS_IS_OK (stat)) {
      stat = PlayAllocateNew (p_play_params, &pPlaySession); ~
  }

  /* send fsm input to start */
  if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
    stat = PlaySendFSMInput (pPlaySession, E_PLAY_INPUT_START, ASYNCHRONOUS);
  }
}

static SYSTEM_STATUS PlayAllocateNew (	const PLAY_PARAMS	*p_play_params, BASIC_PLAY **ppNew_play_session)
{
  if (SYSTEM_STATUS_IS_OK (stat)) {
    defines max number of plays ~
    stat = PlayInitializeEntry (&(BasicPlay[new_index]), p_play_params); 
    if (!SYSTEM_STATUS_IS_OK (stat)) {
      DummyStatus = PlayFree(&(BasicPlay[new_index]));
    }
  }
}

static SYSTEM_STATUS PlayInitializeEntry (BASIC_PLAY *pThis, const PLAY_PARAMS	*p_play_params)
{
  VRM_FSM_INIT	init; /* FSM initialization structure */

  pThis -> fsm = NULL;

  /* initialize fsm init data */ ~
  memset( &init, 0, sizeof(VRM_FSM_INIT));
  init.fsm_definition_handle	= fsm_definition_handle;
  init.callback				= (VRM_FSM_TRANS_CB)PlayActionFsmOnExit;
  init.init_state				= (uint16_t)E_PLAY_INT_STATE_NONE;
  init.timeout_callback		 = NULL; 
  init.data = (void *)(pThis);

  if (SYSTEM_STATUS_IS_OK (stat)) {
    stat = VRM_FSM_CreateInstance (&init, &(pThis->fsm)); ! set fsm instance ~
    VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
  }

  if (SYSTEM_STATUS_IS_OK (stat)) {
    sprintf ((char *)name_str, "play:0x%x", pThis -> hPlay);
    stat = VRM_FSM_SetName (pThis -> fsm, name_str);
    VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));
  }

}


<FSM_T> /* FSM internal control structure - per instance. */

typedef struct _fsm
{
  VRM_FSM_INIT  init;									/* initialization data */

#ifdef VRM_DEBUG
  int8_t		  name[VRM_VSM_MAX_INSTANCE_NAME_LEN];  /* name of instance */
#endif

  uint16_t	  state_offset;							/* current state of the FSM */
  uint16_t    input_offset;							/* input value that will be processed */
  bool		  input_available;						/* true if input is available, false otherwise */

  uint16_t    timeout_input;						/* input to be sent as callback paramter when timeout */
  SYSTEMALARM_ALARM_HANDLE   alarm_handle;			/* alarm used for timeout */

  bool		   alarm_expected;	  /* true after alarm is set, false if alarm is not set, cancled or timed out */	
  bool         in_action;           /* when action is preformed this flag is true */

} *FSM_T;

SYSTEM_STATUS VRM_FSM_CreateInstance(const VRM_FSM_INIT *pInit, VRM_FSM_INSTANCE_HANDLE *pHandle) 						   
{	 
  FSM_DEFINITION* def;
  SYSTEM_STATUS	stat = VRM_FSM_OK;
  SYSTEM_STATUS   stat_memman = MEMMAN_API_STATUS_OK;
  FSM_T			   new_fsm = 0;
	
  DIAG_DECLARE_FUNCTION("VRM_FSM_CreateInstance");

  /* sanity checking */ 	
  if ((pInit == NULL) || (pInit->fsm_definition_handle == VRM_FSM_ILLEGAL_DEFINITION)) {
    _fsm_error(par_err);  
    stat = VRM_FSM_FAILURE; 
  }	 

  /* Allocate FSM instance */
  if (SYSTEM_STATUS_IS_OK(stat)) { 

    new_fsm = (FSM_T)MEMMAN_API_AllocElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
        p_instances_allocator);

    /* check for allocation error */
    if (NULL == new_fsm) { 		
      _fsm_error(mem_err);
      stat = VRM_FSM_FAILURE; 
    } 
  }

  /* initialize the allocated structure */
  if (SYSTEM_STATUS_IS_OK(stat)) { 

    /* copy the initialization data */ ~
    memcpy(&(new_fsm->init), pInit, sizeof(VRM_FSM_INIT));

    /* set the name to null string */
#ifdef VRM_DEBUG
    *(new_fsm->name) = 0;    
#endif

    new_fsm->input_available = false;

    /* get the FSM definition */ ~
    def = (FSM_DEFINITION*)(new_fsm->init.fsm_definition_handle);
    
    /* increase instance count for the used definition */
    new_fsm->in_action = false;

    /* alarm is not valid */ 
    new_fsm->alarm_expected = false;

    /* set the initial state */ ~
    stat = FSMSetState((VRM_FSM_INSTANCE_HANDLE)new_fsm, (uint16_t)(new_fsm->init.init_state - def->min_state));

    /* consider error case */
    if (!SYSTEM_STATUS_IS_OK(stat)) {   

      /* free the instance */ 
      stat_memman = MEMMAN_API_FreeElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
          p_instances_allocator,(void*)new_fsm); 

      *pHandle = NULL;		  

      VRM_DIAG_ASSERT_ZERO("Error encountered while trying to set initial state to new FSM instance");
    } 
    else {
      def->instances_count++; increase instance counter ~
    }
  } // if end

  if (SYSTEM_STATUS_IS_OK(stat)) { 
    /* set the handle */ return fsm instance ~
    *pHandle = (VRM_FSM_INSTANCE_HANDLE)new_fsm; 
  }

  return stat;  
}

//
// Set State
//
static SYSTEM_STATUS FSMSetState(VRM_FSM_INSTANCE_HANDLE fsm_h, uint16_t state)
{
  SYSTEM_STATUS stat = VRM_FSM_OK;
  FSM_DEFINITION* def = NULL; 
  FSM_T fsm = (FSM_T)fsm_h;
  uint16_t state_offset = 0u;

  /* check FSM is not performing an action */ 
  if (fsm->in_action) {
    stat = VRM_FSM_FAILURE; 
  }
 	
  if (SYSTEM_STATUS_IS_OK(stat)) { 
    /* get the FSM definition */
    def = (FSM_DEFINITION*)(fsm->init.fsm_definition_handle); 

    /* calculate the state offset */
    state_offset = state - def->min_state; 

    /* check validity */
    if (state_offset >= def->num_states) {  
      _fsm_error(par_err); 
      stat = VRM_FSM_FAILURE;
    }
  }

  if (SYSTEM_STATUS_IS_OK(stat)) { 
    /* set the new state */ ~
    fsm->state_offset = state_offset;

    /* set the input that is injected when timeout from this state */
    fsm->timeout_input = def->timeouts[state].input;

    /* cancel previous alarm if needed */
    if (true == fsm->alarm_expected) { 
      alarm_stat = SYSTEMALARM_Cancel(fsm->alarm_handle);  

#ifdef VRM_DEBUG 
      if (!SYSTEM_STATUS_IS_OK(alarm_stat)) {
        DIAG_LOG_INFO(VRM_diag_segment_id,("Previous alarm could not be canceled. fsm->name: %s",fsm->name));
      } 
#endif

      fsm->alarm_expected = false;
    } 
	  	  
    /* do we need to set a new alarm? */ 
    ...
	} 	 

	return stat; 
}


<fsm-init>

/* FSM definition info structure */
typedef struct _fsm_definition_info {
  VRM_FSM_ENTRY* entries;                    /* must be static during definition's life time */ 											  
  uint16_t num_entries;				   
  VRM_FSM_TIMEOUT* timeouts;				   /* must be static during definition's life time */ 
  uint16_t num_timeouts;
} VRM_FSM_DEFINITION_INFO; 

SYSTEM_STATUS PLAY_Init(void)
{
  VRM_FSM_DEFINITION_INFO fsm_info;

  /* initialize FSM definition info structure */
  fsm_info.entries = PlayEntries; ~
  fsm_info.num_entries = (uint16_t)NELEMENTS(PlayEntries);
  fsm_info.timeouts = NULL;
  fsm_info.num_timeouts = 0u;

  // set fsm_definition_handle which is static global
  stat = VRM_FSM_CreateDefinition (&fsm_info, &fsm_definition_handle);
  VRM_DIAG_ASSERT (SYSTEM_STATUS_IS_OK (stat));

  /* initialize fields to null values */
  memset(BasicPlay, 0, (size_t)(sizeof(BASIC_PLAY) * BASIC_PLAY_MAX_HANDLES_NUM));

  for (i=0u; i < BASIC_PLAY_MAX_HANDLES_NUM; i++) {
    /* set session id to illegal -  indicates that entry is not in use */
    BasicPlay[i].hPlay = PLAY_HANDLE_ILLEGAL;
  }
  ...
}

/* State transition. Contains the new state and the action to be taken. */
typedef struct fsm_trans {
    uint16_t new_state;             /* new state */    
	VRM_FSM_ACTION action;			/* action on this transition */	
} FSM_TRANS;

/* fsm definition structure */
typedef struct _fsm_definition { 
  VRM_FSM_DEFINITION_INFO def_info;

  uint16_t     min_state, max_state, num_states;
  uint16_t     min_input, max_input, num_inputs;

  FSM_TRANS   *table;        /* transitions table in size of states_num*inputs_num */
  FSM_TIMER   *timeouts;     /* timeouts array in size of states_num */

  uint16_t instances_count;   /* number of live instances of this FSM definition */
} FSM_DEFINITION;

// The states and inputs starts from 0 in state machine definition.
#define VRM_FSM_ILLEGAL_STATE	((uint16_t)0xFFFFu)   // seems not used
#define VRM_FSM_ALL_STATES		(uint16_t)0xFFFE


SYSTEM_STATUS VRM_FSM_CreateDefinition(const VRM_FSM_DEFINITION_INFO* pFSM_definition_info,
									   VRM_FSM_DEFINITION_HANDLE* pHandle)
{

  uint16_t     i = 0u;
  uint16_t     count = 0u;
  uint16_t     offset;
  uint16_t     state;
  uint16_t     first_state;
  uint16_t     last_state;
  VRM_FSM_ENTRY   *pEntry;
  FSM_TRANS   *pTrans;
	SYSTEM_STATUS stat = VRM_FSM_OK;
	SYSTEM_STATUS stat_memman = MEMMAN_API_STATUS_OK; 
	FSM_DEFINITION* fsm_definition = NULL;

	/* Check for parameter errors */
	if (pFSM_definition_info->entries == 0) { 
      _fsm_error(par_err); 
      stat = VRM_FSM_FAILURE;
	}

	/* allocate space for definition structure */ 
	if (SYSTEM_STATUS_IS_OK(stat)) {
	  fsm_definition = (FSM_DEFINITION*)MEMMAN_API_AllocElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
		  p_definitions_allocator);
	}

  /* check for allocation error */
	if (SYSTEM_STATUS_IS_OK(stat) && (fsm_definition == NULL)) { 
      _fsm_error(mem_err); 
      stat = VRM_FSM_FAILURE;
	}

	/* set definition info */ 
	if (SYSTEM_STATUS_IS_OK(stat)) { 
	  
	  /* copy info */
	  fsm_definition->def_info.entries = pFSM_definition_info->entries;
	  fsm_definition->def_info.num_entries = pFSM_definition_info->num_entries; 
	  fsm_definition->def_info.timeouts = pFSM_definition_info->timeouts; 
	  fsm_definition->def_info.num_timeouts = pFSM_definition_info->num_timeouts;

	  /* no instances at this time */ 
	  fsm_definition->instances_count = 0u;
	
    /* Scan for the range of states and inputs */
    fsm_definition->min_state = (uint16_t) -1;
    fsm_definition->min_input = (uint16_t) -1;
    fsm_definition->max_state = 0u;
    fsm_definition->max_input = 0u;

    // For fsm entry array which is a state machine, calculate min and max value for state, next
    // state, and input. For all states entry, do only for input. Seems that no use of doing for all
    // state case.

    for (i = 0u; i < pFSM_definition_info->num_entries; i++) 
    {
        if ((pFSM_definition_info->entries[i].state != VRM_FSM_ILLEGAL_STATE) &&
            (pFSM_definition_info->entries[i].state != VRM_FSM_ALL_STATES )   ) 
        {
          if (pFSM_definition_info->entries[i].state < fsm_definition->min_state) {
                    fsm_definition->min_state = pFSM_definition_info->entries[i].state;
          }
          if (pFSM_definition_info->entries[i].state > fsm_definition->max_state) { 
                    fsm_definition->max_state = pFSM_definition_info->entries[i].state;
          }
          if (pFSM_definition_info->entries[i].new_state < fsm_definition->min_state) {
                    fsm_definition->min_state = pFSM_definition_info->entries[i].new_state;
          }
          if (pFSM_definition_info->entries[i].new_state > fsm_definition->max_state) {
                    fsm_definition->max_state = pFSM_definition_info->entries[i].new_state;
          }
        }

        if (pFSM_definition_info->entries[i].input < fsm_definition->min_input) { 
                fsm_definition->min_input = pFSM_definition_info->entries[i].input;
        }
        if (pFSM_definition_info->entries[i].input > fsm_definition->max_input) {
                fsm_definition->max_input = pFSM_definition_info->entries[i].input;
        }
      } // for end

      // get the number of state and inputs; for example, 0-3 means 4 entries and plus 1.
      fsm_definition->num_states = (fsm_definition->max_state - fsm_definition->min_state) + 1u;
      fsm_definition->num_inputs = (fsm_definition->max_input - fsm_definition->min_input) + 1u;

      why state * input? ~
      count = fsm_definition->num_states * fsm_definition->num_inputs;
	}

	if (SYSTEM_STATUS_IS_OK(stat)) { 
  
    /* Allocate the states table */    
    fsm_definition->table = 
      (FSM_TRANS *)MEMMAN_API_CallocStaticP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
          (uint32_t)count, (uint32_t)sizeof(FSM_TRANS));

    /* check for allocation error */
    if (fsm_definition->table == 0) {

      /* assert */ 
      _fsm_error(mem_err);

      stat_memman = MEMMAN_API_FreeElementP(VRM_MEMMAN_GetVrmMemoryPoolHandle(),
          p_definitions_allocator, fsm_definition);

      fsm_definition = NULL;

      stat = VRM_FSM_FAILURE;
    } 
  } 

  ...

	if (SYSTEM_STATUS_IS_OK(stat)) { 

    /* initialize the entries in the table */
    for (i = 0u; i < count; i++) {
      fsm_definition->table[i].new_state = VRM_FSM_ILLEGAL_STATE;
    }
   
    /* Fill the table */
    for (i = 0u; i < pFSM_definition_info->num_entries; i++) {

      pEntry = pFSM_definition_info->entries + i;

      if (pEntry->state == VRM_FSM_ALL_STATES) {
        first_state = fsm_definition->min_state;
        last_state = fsm_definition->max_state;
      }
      else {
        first_state = pEntry->state;
        last_state = pEntry->state;
      }

      // trans table[state*input]
      //
      // table for state 0. max number of trans table. set one of them for defined input(event).
      // {
      //    input 0     // state0::inpt0
      //    ...
      //    input max   // state0::input max
      // }
      // table for state 1 {
      // {
      //    input 0
      //    ...
      //    input max
      // }
      // ...
      // table for state max {
      // {
      //    input 0
      //    ...
      //    input max
      // }
      //
      // For ALL_STATES case, set entries for all state set. For other cases, set entry for that
      // state. Seems waste of memory?
      
      for (state = first_state; state <= last_state; state++) {
        offset = (fsm_definition->num_inputs * (state - fsm_definition->min_state)) + (pEntry->input - fsm_definition->min_input);
        pTrans = fsm_definition->table + offset;

        /* we keep the states offsets, rather than the states themself */
        pTrans->new_state = pEntry->new_state - fsm_definition->min_state;
        pTrans->action = pEntry->action;
      }
    }
    ...

	  /* set the returned handle */ 
	  *pHandle = (VRM_FSM_DEFINITION_HANDLE)fsm_definition;
	} 
	
	if (!SYSTEM_STATUS_IS_OK(stat)) {
	 *pHandle = VRM_FSM_ILLEGAL_DEFINITION;
	}

  return stat;		
}


={============================================================================
*kt_dev_code_002* static fsm

This is cut-down version from FSM manager of realtime performance inc., and from work at jusung.
This static fsm was used in oob dmx, opentv and sms implementaion at humax. 

{things-to-be-useful}
1> 32bit swap macro
2> ip header and section dump calls
3> data dump calls
4> trace debug message calls
5> color debug outputs


{analysis}
1) Uses all global static structures.

2) Uses state and event enum and loop through state and event list to find. There should be 'no' gap
in event and state list. If used state or event enum as an index of state and event list then can
remove loop overhead.

However, the index is used and should match to print out event name in eaf and others.

Such as fsm->event_list[post_event].name in:
fsm->name, fsm->event_list[post_event].name, fsm->current_state->name, next_state->name );

#define FSM_E(x) {x,#x}

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  FSM_E(BOOT_EVENT_READY),
  ...
}

enum Events
{
  // BOOT EVENTS
  BOOT_EVENT_CLOSED = 0x00,
  BOOT_EVENT_READY,
  BOOT_EVENT_START,
  ...
}

This also means that events cannot start from user defined value? Why need this? Since fsm events
can be used with other system events(enums) in the same process routine such as thread main
processing events. Solution? This fsm event names is debugging purpose and can use like this to make
a index starting from 0. 

fsm->name, fsm->event_list[post_event-start].name, fsm->current_state->name, next_state->name );

The event index used to select event but not just for debugging purpose.

static fsm_status_t call_state_actions( fsm_instance_t* fsm, fsm_event_hdl event, void* event_data )
{
  ...

  /* in case there is enter function */
  if( fsm->current_state->enter_action )
  {
    // note see use of data
    fsm->event_list[event].data = (void*) event_data;

    // note see selection of event using simple index in many places in fsm code for debugging and
    // seleting event.
    fsm->current_state->enter_action( fsm, &(fsm->event_list[event]) );
    return FSM_OK;
  }

  return FSM_ERR;
}

3) For common evnets for all state, then need to write transition table for each state to have that
event. Also can have transition to self state. All depends on how defines transition table.

4) There is a one-two-one mapping between state and transition table.

5) There is no lock in fsm factility itself.

6) Fsm structure:
instance
  - state list(array) -> state #01
                          - eaf
                          - transition table  -> table #01
                                                  - event and state pair
                      -> state #02
                      -> state #03
                      -> ...

  - event list(array) -> event #01
                      -> event #02 

static Fsm::fsm_instance_t bootFsm = { (char*)"boot", bootStateList, bootEventList, NULL };

// typedef struct fsm_instance {
//    char*              name;
//    fsm_state_t**      state_list;
//    fsm_event_t*       event_list;
//    fsm_state_t*       current_state;
//    fsm_state_t*       previous_state;
// } fsm_instance_t;

static Fsm::fsm_state_t* bootStateList[] = {
  &stateClosed,
  ...
  FSM_INVALID_STATE
};

static Fsm::fsm_event_t bootEventList[] = {
  FSM_E(BOOT_EVENT_CLOSED),
  ...
  FSM_E(BOOT_EVENT_STOP)
};

static Fsm::fsm_state_t stateClosed = { BOOT_STATE_CLOSED, (char*)"Closed", eafClosed, tableClosed };

// typedef struct fsm_state { 
//   fsm_state_hdl         hdl;
//   char*                 name;
//   fsm_action_func_t     enter_action;
//   fsm_transition_tbl_t* transition_tbl;
// } fsm_state_t;

Questions from the previous note: In this fsm, it runs its eaf when enters a state and this is
actually state action compared to event action. How to handle when error occurs in eaf? Do we need
not to make state transition depending on a return value of eaf? Currently runs eaf blindly.

2014.02. This is up to eaf design but not to fsm and that means that a user of fsm do all necessary
work and call state transition only when there is no error to change state.


7) Careful when state initial event.

// note that fsm_create will eaf without checking if it is a valid event in that state.

// 1) stat = fsm_create( &bootFsm, BOOT_STATE_CLOSED, BOOT_EVENT_CLOSED, (void*) NULL );
// 2) stat = fsm_create( &bootFsm, BOOT_STATE_CLOSED, BOOT_EVENT_RUN, (void*) NULL );
//
// static Fsm::fsm_transition_tbl_t tableClosed[] =
// {
//   {BOOT_EVENT_CLOSED, BOOT_STATE_CLOSED},
//   {BOOT_EVENT_READY, BOOT_STATE_READY},
//   {Fsm::INVALID_EVENT_HDL}
// };
//
// 1) is expected but 2) still works because transition_tbl is only used make transition.
//
fsm_status_t fsm_create( fsm_instance_t* fsm, fsm_state_hdl init_state, fsm_event_hdl init_event, void* init_data )
{
  fsm_status_t stat = FSM_OK;
  fsm_state_t* pstate = NULL;

  if( fsm == NULL )
  {
    FSM_LOG( stderr, "FSM: fsm is null.\n" );
    stat = FSM_ERR;
  }

  if( stat && (pstate = get_valid_state(fsm, init_state)) )
  {
    fsm->previous_state = fsm->current_state = pstate;
    if( pstate == NULL )
    {
      FSM_LOG( stderr, "FSM: fail to create(%s).\n", fsm->name);
      stat = FSM_ERR;
    }
  }

  // change state of fsm
  if(stat)
    stat = call_state_actions( fsm, init_event, init_data );

  return stat;
}

8) Fix in fsm_post_event to handle null return from get_valid_state.


{oob-dmx-analysis}
oob_dmx_api
  - defines eafs
  - defines interfaces to upper layer
  - register callbacks to lower layer and this callback is a source to fun fsms.
  - two threads and two message queues.

oob_dmx_fsm
  - defines fsms
  - defines interface to fsm layer
  - creates two semaphores; one for data and the other for run fsm.

{source-list}
 kit  14784 Feb 14 10:30 fsm.c*
 kit   8336 May 20  2003 fsm.h*
 kit 125803 May 28  2003 oob_dmx_api.c*
 kit   9283 May 28  2003 oob_dmx_api.h*
 kit  10480 May 28  2003 oob_dmx_def.h*
 kit  34211 May 28  2003 oob_dmx_fsm.c*
 kit  10892 May 28  2003 oob_dmx_fsm.h*
 kit  15232 May 20  2003 oob_dmx_util.c*
 kit   3363 May 20  2003 oob_dmx_util.h*


{source-fsm}

{souce} <fsm.h>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN, PRIMA
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * FSM.H
 *
 * $Id: fsm.h,v 1.1.1.2 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains the finite state machine (FSM) manager header file, 
 * including constant and data type definitions. The FSM manager offers an 
 * effective control mechanism that can be re-used and shared among many 
 * applications.  
 *
 * !NOTE
 * ------
 * Naming convention is modified and some code is revised. (2003.03, ktpark)
 *
 * This FSM version was minimized and modified to meet OpenTV environment and
 * non threaded model. (2001.08, ktpark)
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * Thanks to their initial work and efforts by...
 *
 * 1. COPYRIGHT 1988/96 BY REALTIME PERFORMANCE, INC.
 *                            158 COMMERCIAL STREET,        
 *                            SUNNYVALE, CA 94086           
 *                            (408) 245-6537
 * 2. C. D. Kang
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: fsm.h,v $
 * Revision 1.1.1.2  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * Revision 1.1.1.1  2001/08/30 17:52:30  Administrator
 * - (2001.08.30 ktpark) initial release for OTV Paris application at Paris
 * 
 *================================================================================
 */

#ifndef __FSM_H__
#define __FSM_H__


/* =================================================================================
 * C O N S T A N T S - M A C R O S
 * =================================================================================
 */  
 
#ifndef NULL
#define NULL 0
#endif

// this is to mark end state in the state list so null. not for state handle of a state.
#define FSM_INVALID_STATE     NULL
// 2014.02. {KT} these two are not used
// #define FSM_INVALID_STATE_HDL NULL
// #define FSM_INVALID_EVENT     NULL
// this is to mark invalid event and is for event handle since 0 is used already in enum.
#define FSM_INVALID_EVENT_HDL -1


/* =================================================================================
 * D A T A T Y P E S
 * =================================================================================
 * enums and typdefs
 */  


/* ----------------------------------------------------------------------------------
 * uint16, sint16
 * ----------------------------------------------------------------------------------
 */
#ifndef uint16
typedef unsigned short uint16;
#endif

#ifndef sint16
typedef signed short sint16;
#endif


/* ----------------------------------------------------------------------------------
 * fsm_status_t
 * ----------------------------------------------------------------------------------
 * return codes from fsm routines

typedef enum 
   FSM_OK,
   FSM_ERR,
   FSM_ERR_CREATE,
   FSM_ERR_NO_ENTER_ACTION,
   FSM_ERR_UNSUPPORTED_EVENT
} fsm_status_t;
*/  

typedef bool fsm_status_t;

/* ----------------------------------------------------------------------------------
 * fsm_state_hdl
 * ----------------------------------------------------------------------------------
 */
typedef uint16 fsm_state_hdl;


/* ----------------------------------------------------------------------------------
 * fsm_event_hdl
 * ----------------------------------------------------------------------------------
 * because of FSM_INVALID_EVENT_HDL
 */
typedef sint16 fsm_event_hdl;


/* ----------------------------------------------------------------------------------
 * forward reference 
 * ----------------------------------------------------------------------------------
 */
struct fsm_instance_t;
struct fsm_event_t;


/* ----------------------------------------------------------------------------------
 * fsm_action_func_t
 * ----------------------------------------------------------------------------------
 */
typedef void (*fsm_action_func_t)(struct fsm_instance_t*, struct fsm_event_t*);


/* ----------------------------------------------------------------------------------
 * fsm_event_t
 * ----------------------------------------------------------------------------------
 * hdl			 : handle
 * name		     : name
 */
typedef struct {
  fsm_event_hdl   hdl;
  char*           name;
  void*           data;
} fsm_event_t;


/* ----------------------------------------------------------------------------------
 * fsm_transition_tbl_t
 * ----------------------------------------------------------------------------------
 * event_hdl      : event handle
 * state_hdl      : state handle
 */
typedef struct {
  fsm_event_hdl   event_hdl;
  fsm_state_hdl   state_hdl;
} fsm_transition_tbl_t;


/* ----------------------------------------------------------------------------------
 * fsm_state_t
 * ----------------------------------------------------------------------------------
 * hdl            : state own handle
 * name           : state own name
 * action_func    : enter function of the state
 * transiton_tbl  : transition table of the state
 */
typedef struct {  
  fsm_state_hdl         hdl;
  char*                 name;
  fsm_action_func_t     enter_action;
  fsm_transition_tbl_t* transition_tbl;
} fsm_state_t;


/* ----------------------------------------------------------------------------------
 * fsm_instatnce_t
 * ----------------------------------------------------------------------------------
 * name           : the fsm name
 * state_list     : list of all the states
 * event_list     : list of all the events
 * current_state  : fsm's current state
 */  
typedef struct {
   char*              name;
   fsm_state_t**      state_list;
   fsm_event_t*       event_list;
   fsm_state_t*       current_state;
   fsm_state_t*       previous_state;
} fsm_instance_t;


/* =================================================================================
 * I N T E R F A C E S
 * =================================================================================
 */  
extern fsm_status_t  fsm_create( fsm_instance_t* fsm, fsm_state_hdl init_state, fsm_event_hdl init_event, void* data );
extern fsm_status_t  fsm_post_event( fsm_instance_t* fsm, fsm_event_hdl post_event, void* data );
extern fsm_state_hdl fsm_get_current_state_hdl( fsm_instance_t* fsm );
extern fsm_state_hdl fsm_get_previous_state_hdl( fsm_instance_t* fsm );
extern char*         fsm_get_current_state_name( fsm_instance_t* fsm );
extern char*         fsm_get_event_name( fsm_instance_t* fsm, fsm_event_hdl event );
extern bool          fsm_is_valid_incoming_event( fsm_instance_t* fsm, fsm_event_hdl event );

#endif /* __FSM_H__ */


{source} <fsm.c>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN, PRIMA
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * FSM.C
 *
 * $Id: fsm.c,v 1.1.1.2 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains the finite state machine (FSM) manager header file, 
 * including constant and data type definitions. The FSM manager offers an 
 * effective control mechanism that can be re-used and shared among many 
 * applications.  
 *
 * !NOTE
 * ------
 * Naming convention is modified and some code is revised. (2003.03, ktpark)
 *
 * This FSM version was minimized and modified to meet OpenTV environment and
 * non threaded model. (2001.08, ktpark)
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * Thanks to their initial work and efforts by...
 *
 * 1. COPYRIGHT 1988/96 BY REALTIME PERFORMANCE, INC.
 *                            158 COMMERCIAL STREET,        
 *                            SUNNYVALE, CA 94086           
 *                            (408) 245-6537
 * 2. C. D. Kang
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: fsm.c,v $
 * Revision 1.1.1.2  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * Revision 1.1.1.1  2001/08/30 17:52:30  Administrator
 * - (2001.08.30 ktpark) initial release for OTV Paris application at Paris
 * 
 *================================================================================
 */

/* 
 * F O R N O N P C E N V 
 * =================================================================================
 */  
#include <stdio.h>
#include <kal.h>
#include <string.h>
#include <stdlib.h>
#include <basetype.h>
#include <cm_oob_types.h>
#include "oob_dmx_def.h"
#include "fsm.h"


// {KT} 2014.02. This seems to check if input state is within the number of states but seems not
// useful since:
//
// 1> can be replace with get_vaild_state() 2> this assumes that state enum shoud not have gaps and
// should match the order between state list and state enum.


bool is_valid_state( fsm_instance_t* fsm, fsm_state_hdl state )
{
  uint16         state_cnt = 0;

  /* look for match state until it reaches end of state list table */
  while ( fsm->state_list[state_cnt] != FSM_INVALID_STATE ) 
  {
    /* found match state */
    if( state_cnt == state ) 
      return TRUE;

    state_cnt++;
  }

  trace_new(FSM_ERR, ERR "FSM: %s: is_valid_state: unsupported state handle(%d) in this fsm.\n" NOR,
      fsm->name, state );

  return FALSE;
}

      
/* ----------------------------------------------------------------------------------
 ** FUNCTION = get_vaild_state
 *
 ** OVERVIEW
 *    find given state in the state list of the fsm object
 *   
 ** SYNTAX
 *	  fsm_state_t* 
 *     get_vaild_state( fsm_instance_t* fsm, fsm_state_hdl state_hdl )
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 *  @ {state_hdl} is an handle of the finding state.
 * 
 ** DESCRIPTION 
 *    The function get_vaild_state is used to search a valid state in the
 *    state list.
 * 
 ** RETURN VALUE
 *    fsm_state_t* that is valid and found is returned
 *    FSM_INVALID_STATE
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
fsm_state_t* get_vaild_state( fsm_instance_t* fsm, fsm_state_hdl state_hdl )
{
	uint16 idx=0;

	while( fsm->state_list[idx] != FSM_INVALID_STATE ) 
	{
		if( fsm->state_list[idx]->hdl == state_hdl )
			return fsm->state_list[idx];

		idx++;
	}
	
	/* error: can not find a valid state */
	trace_new(FSM_ERR, ERR "FSM: %s: get state: unsupported state handle(%d).\n" NOR, 
		fsm->name, state_hdl );

	return FSM_INVALID_STATE;
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION = call_state_actions
 *
 ** OVERVIEW
 *    execute an enter action of the state of the fsm object
 *   
 ** SYNTAX
 *	  fsm_status_t 
 *     call_state_actions( fsm_instance_t* fsm, fsm_event_hdl event )
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 *  @ {event} is an event causing state change.
 * 
 ** DESCRIPTION 
 *    The function call_state_actions is used to call enter action of the state.
 * 
 ** RETURN VALUE
 *    FSM_OK
 *    FSM_ERR_NO_ENTER_ACTION
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
fsm_status_t call_state_actions( fsm_instance_t* fsm, fsm_event_hdl event, void* event_data )
{
  /* in case there is enter function */
  if( fsm->current_state->enter_action ) 
  {
    trace_new(FSM_TL2, WAR "FSM: %s: call eaf: state(%s), event(%s).\n" NOR, 
        fsm->name, fsm->current_state->name, fsm->event_list[event].name );

    fsm->event_list[event].data = (void*) event_data;

    fsm->current_state->enter_action( (struct fsm_instance_t*)fsm, 
        (struct fsm_event_t*)&(fsm->event_list[event]) );
    return TRUE; // FSM_OK;
  }

  /* error: there is no actions */
  trace_new(FSM_ERR, ERR "FSM: %s: call eaf: no action.\n" NOR, fsm->name );

  return FALSE; // FSM_ERR_NO_ENTER_ACTION;
}

/* ----------------------------------------------------------------------------------
 ** FUNCTION = fsm_create
 *
 ** OVERVIEW
 *    create and init fsm with related structures
 *   
 ** SYNTAX
 *	  fsm_status_t 
 *     fsm_create( fsm_instance_t* fsm, fsm_state_hdl init_state, fsm_event_hdl init_event )
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 *  @ {init_state} is start state of the given fsm object.
 * 
 *  @ {init_event} is init event of the start state.
 * 
 ** DESCRIPTION 
 *    The function fsm_create is called by a client in order to create fsm object
 *    and should be called before calling any fsm interfaces. 
 * 
 ** RETURN VALUE
 *    FSM_OK
 *    FSM_ERR_CREATE
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
fsm_status_t fsm_create( fsm_instance_t* fsm, fsm_state_hdl init_state, fsm_event_hdl init_event, void* init_data )
{
  fsm_status_t stat = FSM_ERR;

  // {KT} 2014.02. Why not use get_vaild_state() than inventing is_valid_state() here since this is
  // the only place using it and as stated above, this seems redundant.

  if(is_valid_state(fsm, init_state))
  {  
    // set init state
    // M0001 (2003.03)
    // correction for fsm_is_valid_incoming event(). So, after this correction,
    // fsm's init state should have SELF event in its transition table.
    fsm->previous_state = fsm->current_state = fsm->state_list[init_state];

    // change state of fsm 
    stat = call_state_actions( fsm, init_event, init_data );
    // stat = call_state_actions( fsm, init_event );
    if( stat != TRUE )
      //if( stat != FSM_OK )
      return FALSE; //FSM_ERR_CREATE;

    trace_new( FSM_TL2, WAR "FSM: %s: create: init state(%s), init event(%s).\n" NOR, 
        fsm->name, fsm->state_list[init_state]->name, fsm->event_list[init_event].name );

    return TRUE; //FSM_OK;
  }

  return FALSE; //FSM_ERR;
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION = fsm_post_event
 *
 ** OVERVIEW
 *    post an event to fsm object
 *   
 ** SYNTAX
 *	  fsm_status_t 
 *     fsm_post_event( fsm_instance_t* fsm, fsm_event_hdl post_event ) 
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 *  @ {post_event} is an event to post to the given fsm object.
 * 
 ** DESCRIPTION 
 *    The function fsm_post_event is used to post an event to specified fsm object.
 * 
 ** RETURN VALUE
 *    FSM_OK
 *    FSM_ERR_UNSUPPORTED_EVENT
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
fsm_status_t fsm_post_event( fsm_instance_t* fsm, fsm_event_hdl post_event, void* event_data )
{
  uint16			idx=0;
  fsm_state_t*	next_state = NULL;

  // look for match event until it reaches end of transition table
  while ( fsm->current_state->transition_tbl[idx].event_hdl != FSM_INVALID_EVENT_HDL ) 
  {
    // found match event
    if( fsm->current_state->transition_tbl[idx].event_hdl == post_event ) 
    {
      // find valid state
      // 2014.02. check if state is in the state list but not handle when if not. that is no
      // not handle when it retuns null.
      //
      // 2014.08. Why? crash happens when miss out state in the state list. Fix as below.
      // next_state = get_valid_state( fsm, fsm->current_state->transition_tbl[idx].state_hdl );
      // if(!next_state)
      //  return FSM_ERR;
      //
      next_state = get_vaild_state( fsm, fsm->current_state->transition_tbl[idx].state_hdl );

      // save state
      fsm->previous_state = fsm->current_state;

      trace_new(FSM_TL2, WAR "FSM: %s: post: state(%s)->state(%s) w event(%s).\n" NOR,
          fsm->name, fsm->current_state->name, next_state->name, fsm->event_list[post_event].name );

      // state transition
      fsm->current_state = next_state;

      // call action function of next state
      call_state_actions( fsm, post_event, event_data );
      // call_state_actions( fsm, post_event);
      return TRUE; // FSM_OK;
    }

    idx++;
  }

  trace_new(FSM_ERR, ERR "FSM: %s: post: unsupported event(%s) in state(%s).\n" NOR,
      fsm->name, fsm->event_list[post_event].name, fsm->current_state->name );

  // error: can not find a valid event
  return FALSE; //FSM_ERR_UNSUPPORTED_EVENT;
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION = fsm_get_current_state_hdl
 *
 ** OVERVIEW
 *    get a handle of current state of fsm object
 *   
 ** SYNTAX
 *	  fsm_state_hdl 
 *     fsm_get_current_state_hdl( fsm_instance_t* fsm )
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 ** DESCRIPTION 
 *    The utility function is used to get a handle of current state.
 * 
 ** RETURN VALUE
 *    a handle of current state
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
fsm_state_hdl fsm_get_current_state_hdl( fsm_instance_t* fsm )
{
   return fsm->current_state->hdl;
}

/* ----------------------------------------------------------------------------------
 ** FUNCTION = fsm_get_current_state_hdl
 *
 ** OVERVIEW
 *    get a handle of current state of fsm object
 *   
 ** SYNTAX
 *	  fsm_state_hdl 
 *     fsm_get_current_state_hdl( fsm_instance_t* fsm )
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 ** DESCRIPTION 
 *    The utility function is used to get a handle of current state.
 * 
 ** RETURN VALUE
 *    a handle of current state
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
fsm_state_hdl fsm_get_previous_state_hdl( fsm_instance_t* fsm )
{
   return fsm->previous_state->hdl;
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION = fsm_get_current_state_name
 *
 ** OVERVIEW
 *    get state name of fsm object
 *   
 ** SYNTAX
 *	  char* 
 *     fsm_get_current_state_name( fsm_instance_t* fsm )
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 * 	 
 ** DESCRIPTION 
 *    The utility function is used to get a name of current state.
 * 
 ** RETURN VALUE
 *    a name of current state
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
char*         fsm_get_current_state_name( fsm_instance_t* fsm )
{
   return fsm->current_state->name;
}

char*         fsm_get_event_name( fsm_instance_t* fsm, fsm_event_hdl event )
{
   return fsm->event_list[event].name;
}

bool fsm_is_valid_incoming_event( fsm_instance_t* fsm, fsm_event_hdl event )
{
  uint16			idx=0;

  /* look for match event until it reaches end of transition table */
  while ( fsm->previous_state->transition_tbl[idx].event_hdl != FSM_INVALID_EVENT_HDL ) 
  {
    /* found match event */
    if( fsm->previous_state->transition_tbl[idx].event_hdl == event ) 
      return TRUE;

    idx++;
  }

  trace_new(FSM_ERR, ERR "FSM: %s: post: unsupported event(%s) from prev state(%s).\n" NOR,
      fsm->name, fsm->event_list[event].name, fsm->previous_state->name );

  // error: can not find a valid event
  return FALSE;
}


{source-dmx-fsm}

{source} <oob_dmx_fsm.h>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_FSM.H
 *
 * $Id: oob_dmx_fsm.h,v 1.1.1.2 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains definitions of the oob dmx fsm. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_fsm.h,v $
 * Revision 1.1.1.2  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */
 
#ifndef __OOB_DMX_FSM_H__
#define __OOB_DMX_FSM_H__

#ifndef __FSM_H__
#include "fsm.h"
#endif

#ifndef __OOB_DMX_API_H__
#include "oob_dmx_api.h"
#endif
               
/* =================================================================================
 * D A T A T Y P E S
 * =================================================================================
 * enums and typdefs
 */  
  
/* ----------------------------------------------------------------------------------
 * oob_dmx_filter_t
 * ----------------------------------------------------------------------------------
 */
typedef struct {
   uint32      chid;
   uint32      fid;
   uint32      filter_size;
   uint32      match[OOB_DMX_FILTER_SIZE/4];
   uint32      mask[OOB_DMX_FILTER_SIZE/4];
   uint32      not_match[OOB_DMX_FILTER_SIZE/4];      
} oob_dmx_filter_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_channel_type_t
 * ----------------------------------------------------------------------------------
 * enum for channel type of oob

typedef emum {
   OOB_DMX_CHAN_NULL,
   OOB_DMX_CHAN_EMM,
   OOB_DMX_CHAN_PSI
} oob_dmx_channel_type_t;
 */


/* ----------------------------------------------------------------------------------
 * oob_dmx_channel_t
 * ----------------------------------------------------------------------------------
 */
typedef struct {
   uint16                  pid;
   uint32                  cnxt_chid;
   uint32                  chid;
   uint32                  allocated_filters;
   uint32                  enabled_filters;
   uint32                  crc_status;
   oob_dmx_callback_t      data_notify;
} oob_dmx_channel_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_instance_t
 * ----------------------------------------------------------------------------------
 */
typedef struct {
   bool                    is_reset_raised;
   uint8                   avail_channels;
   uint8                   avail_filters;
   oob_dmx_connection_t    connection_notify;
} oob_dmx_instance_t;
              

/* =================================================================================
 * S T A T E - E V E N T - D E F N I T I O N S
 * =================================================================================
 */  


/* =================================================================================
 * OOB_DMX_DEMOD
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * OOB_DMX_DEMOD STATES
 * ----------------------------------------------------------------------------------
 * state definitions of the oob dmx demod
 */
typedef enum {
   ST_CM_NOT_ALIVE,
   ST_CM_ALIVE,
   ST_CH_UNLOCK,
   ST_CH_LOCK
} oob_dmx_demod_states_t;


/* ----------------------------------------------------------------------------------
 * OOB_DMX_DEMOD EVENTS
 * ----------------------------------------------------------------------------------
 * state definitions of the oob dmx demod
 *
 * M030526
 * - EV_CM_NOT_ALIVE has a same meaning with CM_REST
 */
typedef enum {
   EV_CM_NOT_ALIVE,
   EV_CM_ALIVE,
   EV_CH_UNLOCK,
   EV_CH_LOCK
} oob_dmx_demod_events_t;



/* =================================================================================
 * OOB_DMX_CHANNEL
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * OOB_DMX_CHANNEL STATES
 * ----------------------------------------------------------------------------------
 * state definitions of the oob dmx channels
 */
typedef enum {
   ST_CH_OPEN,
   ST_CH_CLOSE,
   ST_CH_ENABLE,
   ST_CH_DISABLE
} oob_dmx_channel_states_t;


/* ----------------------------------------------------------------------------------
 * OOB_DMX_CHANNEL EVENTS
 * ----------------------------------------------------------------------------------
 * events definitions of the oob dmx channels
 */
typedef enum {
   EV_CH_OPEN,
   EV_CH_CLOSE,
   EV_CH_ENABLE,
   EV_CH_DISABLE
} oob_dmx_channel_events_t;


/* =================================================================================
 * OOB_DMX_FILTER
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * OOB_DMX_FILTER STATES
 * ----------------------------------------------------------------------------------
 * state definitions of the oob dmx filters
 */
typedef enum {
   ST_FI_OPEN,
   ST_FI_CLOSE,
   ST_FI_ENABLE,
   ST_FI_DISABLE
} oob_dmx_filter_states_t;


/* ----------------------------------------------------------------------------------
 * OOB_DMX_FILTER EVENTS
 * ----------------------------------------------------------------------------------
 * events definitions of the oob dmx filters
 */
typedef enum {
   EV_FI_OPEN,
   EV_FI_CLOSE,
   EV_FI_ENABLE,
   EV_FI_DISABLE
} oob_dmx_filter_events_t;


/* ----------------------------------------------------------------------------------
 * EAF TABLES
 * ----------------------------------------------------------------------------------
 */
typedef struct 
{
   // demod eafs
   fsm_action_func_t* cm_not_alive_eaf;
   fsm_action_func_t* cm_alive_eaf;
   fsm_action_func_t* ch_unlock_eaf;
   fsm_action_func_t* ch_lock_eaf;
   // channel eafs
   fsm_action_func_t* ch_open_eaf;
   fsm_action_func_t* ch_close_eaf;
   fsm_action_func_t* ch_enable_eaf;
   fsm_action_func_t* ch_disable_eaf;
   // filter eafs
   fsm_action_func_t* fi_open_eaf;
   fsm_action_func_t* fi_close_eaf;
   fsm_action_func_t* fi_enable_eaf;
   fsm_action_func_t* fi_disable_eaf;
} eaf_ftabls_t;


/* =================================================================================
 * I N T E R F A C E S
 * =================================================================================
 */  
 
extern bool                      oob_fsm_init( eaf_ftabls_t* ftable );
extern void                      oob_fsm_initialize_channel(uint32 chid);
extern void                      oob_fsm_initialize_filter(uint32 fid);

extern bool                      oob_fsm_dmd_post_event(int connections, oob_dmx_demod_events_t event);
extern oob_dmx_demod_states_t    oob_fsm_dmd_get_current_state( void );
extern bool                      oob_fsm_dmd_is_valid_event( oob_dmx_demod_events_t event );
extern bool                      oob_fsm_dmx_get( oob_dmx_instance_t* p_dmx );
extern bool                      oob_fsm_dmx_set( oob_dmx_instance_t* p_dmx );
   
extern bool                      oob_fsm_chn_post_event( uint32 chid, oob_dmx_channel_events_t event);
extern oob_dmx_channel_states_t  oob_fsm_chn_get_current_state( uint32 chid );
extern char*                     oob_fsm_chn_get_current_state_name( uint32 chid );
extern oob_dmx_channel_states_t  oob_fsm_chn_get_previous_state( uint32 chid );
extern bool                      oob_fsm_chn_is_valid_event( uint32 chid, oob_dmx_channel_events_t event );
extern bool                      oob_fsm_chn_get( uint32 chid, oob_dmx_channel_t* p_channel );
extern bool                      oob_fsm_chn_set( uint32 chid, oob_dmx_channel_t* p_channel );
extern bool                      oob_fsm_chn_get_back( uint32 chid );
extern char*                     oob_fsm_chn_get_name( uint32 chid );

extern bool                      oob_fsm_fil_post_event( uint32 fid, oob_dmx_channel_events_t event );
extern oob_dmx_filter_states_t   oob_fsm_fil_get_current_state( uint32 fid );
extern char*                     oob_fsm_fil_get_current_state_name( uint32 fid );
extern oob_dmx_filter_states_t   oob_fsm_fil_get_previous_state( uint32 fid );
extern bool                      oob_fsm_fil_is_valid_event( uint32 fid, oob_dmx_channel_events_t event );
extern bool                      oob_fsm_fil_get( uint32 fid, oob_dmx_filter_t* p_filter );
extern bool                      oob_fsm_fil_set( uint32 fid, oob_dmx_filter_t* p_filter );
extern bool                      oob_fsm_fil_get_back( uint32 fid );
extern char*                     oob_fsm_fil_get_name( uint32 fid );

#endif /* __OOB_DMX_FSM_H__ */
 

{source} <oob_dmx_fsm.c>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_FSM.C
 *
 * $Id: oob_dmx_fsm.c,v 1.1.1.2 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains implementations of the oob dmx fsm. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_fsm.c,v $
 * Revision 1.1.1.2  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */

     
/* =================================================================================
 * I N C L U D E S
 * =================================================================================
 */  
#include <stdio.h>
#include <kal.h>
#include <vxworks.h>
#include <semLib.h>
#include <cm_oob_types.h>

#include "oob_dmx_def.h"
#include "fsm.h"
#include "oob_dmx_fsm.h"
#include "oob_dmx_util.h"

#define CS_DATA_BEGIN()   oob_msem_take(oob_fsm_data_sem_id)
#define CS_DATA_END()     oob_msem_give(oob_fsm_data_sem_id)

#define CS_EXEC_BEGIN()   oob_msem_take(oob_fsm_exec_sem_id)
#define CS_EXEC_END()     oob_msem_give(oob_fsm_exec_sem_id)

/* =================================================================================
 * F O R W A R D S
 * =================================================================================
 */  
static bool is_oob_fsm_initialized();
static void initialize_dmx();


/* =================================================================================
 * T R A N S I T I O N - T A B L E - D E F N I T I O N S
 * =================================================================================
 */  

/* =================================================================================
 * OOB_DMX_DEMOD
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * [CM_NOT_ALIVE] state 
 * ----------------------------------------------------------------------------------
 * { event, state }
 * NB: INIT STATE
 */
static fsm_transition_tbl_t cm_not_alive_state_trans_tbl[] = {
   { EV_CM_NOT_ALIVE, ST_CM_NOT_ALIVE },
   { EV_CM_ALIVE, ST_CM_ALIVE },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [CM_ALIVE] state 
 * ----------------------------------------------------------------------------------
 * { event, state }
 */
static fsm_transition_tbl_t cm_alive_state_trans_tbl[] = {
   { EV_CM_NOT_ALIVE, ST_CM_NOT_ALIVE },
   { EV_CH_UNLOCK, ST_CH_UNLOCK },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [CH_UNLOCK] state 
 * ----------------------------------------------------------------------------------
 * { event, state }
 */
static fsm_transition_tbl_t ch_unlock_state_trans_tbl[] = {
   { EV_CM_NOT_ALIVE, ST_CM_NOT_ALIVE },
   { EV_CM_ALIVE, ST_CM_ALIVE }, /* M030526, add a new transition */
   { EV_CH_LOCK, ST_CH_LOCK },
   { EV_CH_UNLOCK, ST_CH_UNLOCK },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [CH_LOCK] state 
 * ----------------------------------------------------------------------------------
 * { event, state }
 */
static fsm_transition_tbl_t ch_lock_state_trans_tbl[] = {
   { EV_CH_UNLOCK, ST_CH_UNLOCK },
   { EV_CM_NOT_ALIVE, ST_CH_UNLOCK }, /* M030526, change from ST_CM_NOT_ALIVE */
   { FSM_INVALID_EVENT_HDL }
};


/* =================================================================================
 * OOB_DMX_CHANNEL
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * [CH_CLOSE] state 
 * ----------------------------------------------------------------------------------
 * INIT STATE
 */
static fsm_transition_tbl_t ch_close_state_trans_tbl[] = {
   /* { event, state } */ 
   { EV_CH_CLOSE, ST_CH_CLOSE },
   { EV_CH_OPEN, ST_CH_OPEN },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [CH_OPEN] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_transition_tbl_t ch_open_state_trans_tbl[] = {
   /* { event, state } */ 
   { EV_CH_CLOSE, ST_CH_CLOSE },
   { EV_CH_ENABLE, ST_CH_ENABLE },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [CH_ENABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_transition_tbl_t ch_enable_state_trans_tbl[] = {
   /* { event, state } */ 
   { EV_CH_CLOSE, ST_CH_CLOSE },
   { EV_CH_DISABLE, ST_CH_DISABLE },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [CH_DISABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_transition_tbl_t ch_disable_state_trans_tbl[] = {
   // { event, state }
   { EV_CH_CLOSE, ST_CH_CLOSE },
   { EV_CH_ENABLE, ST_CH_ENABLE },
   { FSM_INVALID_EVENT_HDL }
};


/* =================================================================================
 * OOB_DMX_FILTER
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * [FI_CLOSE] state 
 * ----------------------------------------------------------------------------------
 * INIT STATE
 */
static fsm_transition_tbl_t fi_close_state_trans_tbl[] = {
   /* { event, state } */ 
   { EV_FI_CLOSE, ST_FI_CLOSE },
   { EV_FI_OPEN, ST_FI_OPEN },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [FI_OPEN] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_transition_tbl_t fi_open_state_trans_tbl[] = {
   /* { event, state } */ 
   { EV_FI_CLOSE, ST_FI_CLOSE },
   { EV_FI_ENABLE, ST_FI_ENABLE },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [FI_ENABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_transition_tbl_t fi_enable_state_trans_tbl[] = {
   /* { event, state } */ 
   { EV_FI_CLOSE, ST_FI_CLOSE },
   { EV_FI_DISABLE, ST_FI_DISABLE },
   { FSM_INVALID_EVENT_HDL }
};


/* ----------------------------------------------------------------------------------
 * [FI_DISABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_transition_tbl_t fi_disable_state_trans_tbl[] = {
   // { event, state }
   { EV_FI_CLOSE, ST_FI_CLOSE },
   { EV_FI_ENABLE, ST_FI_ENABLE },
   { FSM_INVALID_EVENT_HDL }
};


/* =================================================================================
 * S T A T E - D E F N I T I O N S
 * =================================================================================
 */  
 
/* =================================================================================
 * OOB_DMX_DEMOD
 * =================================================================================
 */  
 
/* ----------------------------------------------------------------------------------
 * [CM_NOT_ALIVE] state 
 * ----------------------------------------------------------------------------------
 * init state
 */
static fsm_state_t cm_not_alive_state = {
   ST_CM_NOT_ALIVE,
   "cm not alive st",
   (fsm_action_func_t)NULL,
   cm_not_alive_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [CM_ALIVE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t cm_alive_state = {
   ST_CM_ALIVE,
   "cm alive st",
   (fsm_action_func_t)NULL,
   cm_alive_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [CH_UNLOCK] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t ch_unlock_state = {
   ST_CH_UNLOCK,
   "ch unlock st",
   (fsm_action_func_t)NULL,
   ch_unlock_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [CH_LOCK] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t ch_lock_state = {
   ST_CH_LOCK,
   "ch lock st",
   (fsm_action_func_t)NULL,
   ch_lock_state_trans_tbl
};


/* =================================================================================
 * OOB_DMX_CHANNEL
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * [CH_OPEN] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t ch_open_state = {
   ST_CH_OPEN,
   "ch open st",
   (fsm_action_func_t)NULL,
   ch_open_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [CH_CLOSE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t ch_close_state = {
   ST_CH_CLOSE,
   "ch close st",
   (fsm_action_func_t)NULL,
   ch_close_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [CH_ENABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t ch_enable_state = {
   ST_CH_ENABLE,
   "ch enable st",
   (fsm_action_func_t)NULL,
   ch_enable_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [CH_DISABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t ch_disable_state = {
   ST_CH_DISABLE,
   "ch disable st",
   (fsm_action_func_t)NULL,
   ch_disable_state_trans_tbl
};


/* =================================================================================
 * OOB_DMX_FILTER
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 * [FI_OPEN] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t fi_open_state = {
   ST_FI_OPEN,
   "fi open st",
   (fsm_action_func_t)NULL,
   fi_open_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [FI_CLOSE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t fi_close_state = {
   ST_FI_CLOSE,
   "fi close st",
   (fsm_action_func_t)NULL,
   fi_close_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [FI_ENABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t fi_enable_state = {
   ST_FI_ENABLE,
   "fi enable st",
   (fsm_action_func_t)NULL,
   fi_enable_state_trans_tbl
};


/* ----------------------------------------------------------------------------------
 * [FI_DISABLE] state 
 * ----------------------------------------------------------------------------------
 */
static fsm_state_t fi_disable_state = {
   ST_FI_DISABLE,
   "fi disable st",
   (fsm_action_func_t)NULL,
   fi_disable_state_trans_tbl
};


/* =================================================================================
 * S T A T E - L I S T S
 * =================================================================================
 */  

/* =================================================================================
 * OOB_DMX_DEMOD
 * =================================================================================
 */  
static fsm_state_t* oob_dmx_demod_state_list[] = {
   &cm_not_alive_state,
   &cm_alive_state,
   &ch_unlock_state,
   &ch_lock_state,
   FSM_INVALID_STATE
};

/* =================================================================================
 * OOB_DMX_CHANNEL
 * =================================================================================
 */  
static fsm_state_t* oob_dmx_channel_state_list[] = {
   &ch_open_state,
   &ch_close_state,
   &ch_enable_state,
   &ch_disable_state,
   FSM_INVALID_STATE
};

/* =================================================================================
 * OOB_DMX_FILTER
 * =================================================================================
 */  
static fsm_state_t* oob_dmx_filter_state_list[] = {
   &fi_open_state,
   &fi_close_state,
   &fi_enable_state,
   &fi_disable_state,
   FSM_INVALID_STATE
};

/* =================================================================================
 * E V E N T - L I S T S
 * =================================================================================
 */  

/* =================================================================================
 * OOB_DMX_DEMOD : oob_dmx_demod_event_list
 * =================================================================================
 */  
static fsm_event_t oob_dmx_demod_event_list[] = {
   { EV_CM_NOT_ALIVE, "ev_cm_not_alive" }, 
   { EV_CM_ALIVE, "ev_cm_alive" },
   { EV_CH_UNLOCK, "ev_ch_unlock" },
   { EV_CH_LOCK, "ev_ch_lock" }
};


/* =================================================================================
 * OOB_DMX_CHANNEL : oob_dmx_channel_event_list
 * =================================================================================
 */  
static fsm_event_t oob_dmx_channel_event_list[] = {
   { EV_CH_OPEN, "ev_ch_open" },
   { EV_CH_CLOSE, "ev_ch_close" },
   { EV_CH_ENABLE, "ev_ch_enable" },
   { EV_CH_DISABLE, "ev_ch_disable" }
};


/* =================================================================================
 * OOB_DMX_FILTER : oob_dmx_filter_event_list
 * =================================================================================
 */  
static fsm_event_t oob_dmx_filter_event_list[] = {
   { EV_FI_OPEN, "ev_fi_open" },
   { EV_FI_CLOSE, "ev_fi_close" },
   { EV_FI_ENABLE, "ev_fi_enable" },
   { EV_FI_DISABLE, "ev_fi_disable" }
};


/* =================================================================================
 * G L O B A L S
 * =================================================================================
 */  

static bool g_is_oob_fsm_initialized = FALSE;

/* ----------------------------------------------------------------------------------
 * F S M - I N S T A N C E
 * ----------------------------------------------------------------------------------
 */  

/* ----------------------------------------------------------------------------------
 * oob_dmx_demod_fsm
 * ----------------------------------------------------------------------------------
 */
static fsm_instance_t oob_dmx_demod_fsm = {
   "OOB_DMX_DMD", oob_dmx_demod_state_list, oob_dmx_demod_event_list, NULL
};

/* ----------------------------------------------------------------------------------
 * oob_dmx_channel_fsms
 * ----------------------------------------------------------------------------------
 * it is designed for static allocation model.
 */
typedef char fsm_names_t[20];

static fsm_instance_t oob_dmx_channel_fsms[OOB_DMX_MAX_CHANNELS];
static fsm_names_t oob_dmx_channel_fsms_names[OOB_DMX_MAX_CHANNELS];

static fsm_instance_t oob_dmx_filter_fsms[OOB_DMX_MAX_FILTERS];
static fsm_names_t oob_dmx_filter_fsms_names[OOB_DMX_MAX_FILTERS];


/* ----------------------------------------------------------------------------------
 * oob_dmx
 * ----------------------------------------------------------------------------------
 */
static oob_dmx_instance_t  oob_dmx = {0};
static oob_dmx_channel_t   channel_list[OOB_DMX_MAX_CHANNELS];
static oob_dmx_filter_t    filter_list[OOB_DMX_MAX_FILTERS];


/* ----------------------------------------------------------------------------------
 * F S M - S E M
 * ----------------------------------------------------------------------------------
 */  
static SEM_ID oob_fsm_data_sem_id   = 0;
static SEM_ID oob_fsm_exec_sem_id   = 0;

/* =================================================================================
 * I N T E R F A C E S
 * =================================================================================
 */  
bool oob_fsm_init(eaf_ftabls_t* ftable)
{
   fsm_status_t      stat     = FSM_ERR;
   int               idx      = 0;

   if(is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_init: oob_fsm is already initialized.\n" NOR );
      return FALSE;
   }

   cm_not_alive_state.enter_action  = (fsm_action_func_t)ftable->cm_not_alive_eaf;
   cm_alive_state.enter_action      = (fsm_action_func_t)ftable->cm_alive_eaf;
   ch_unlock_state.enter_action     = (fsm_action_func_t)ftable->ch_unlock_eaf;
   ch_lock_state.enter_action       = (fsm_action_func_t)ftable->ch_lock_eaf;

   ch_open_state.enter_action       = (fsm_action_func_t)ftable->ch_open_eaf;
   ch_close_state.enter_action      = (fsm_action_func_t)ftable->ch_close_eaf;
   ch_enable_state.enter_action     = (fsm_action_func_t)ftable->ch_enable_eaf;
   ch_disable_state.enter_action    = (fsm_action_func_t)ftable->ch_disable_eaf;

   fi_open_state.enter_action       = (fsm_action_func_t)ftable->fi_open_eaf;
   fi_close_state.enter_action      = (fsm_action_func_t)ftable->fi_close_eaf;
   fi_enable_state.enter_action     = (fsm_action_func_t)ftable->fi_enable_eaf;
   fi_disable_state.enter_action    = (fsm_action_func_t)ftable->fi_disable_eaf;

   // crate semaphore
   oob_fsm_data_sem_id = semMCreate(OOB_DMX_SEM_OPTIONS);
   if(!oob_fsm_data_sem_id)
   {
      trace_new( FSM_ERR, ERR "oob_dmx_init_fsm: sem create(oob_fsm_data_sem_id) fail.\n" NOR );
      return FALSE;
   }

   oob_fsm_exec_sem_id = semMCreate(OOB_DMX_SEM_OPTIONS);
   if(!oob_fsm_exec_sem_id)
   {
      trace_new( FSM_ERR, ERR "oob_dmx_init_fsm: sem create(oob_fsm_exec_sem_id) fail.\n" NOR );
      return FALSE;
   }

   initialize_dmx();

   for( idx=0; idx < OOB_DMX_MAX_CHANNELS; idx++)
   {
      sprintf( oob_dmx_channel_fsms_names[idx], "OOB_DMX_CHN_%02d", idx);

      oob_dmx_channel_fsms[idx].name          = (char*) oob_dmx_channel_fsms_names[idx];
      oob_dmx_channel_fsms[idx].state_list    = oob_dmx_channel_state_list; 
      oob_dmx_channel_fsms[idx].event_list    = oob_dmx_channel_event_list;
      oob_dmx_channel_fsms[idx].current_state = (fsm_state_t*) NULL;

      stat = fsm_create( &(oob_dmx_channel_fsms[idx]), ST_CH_CLOSE, EV_CH_CLOSE, (void*) &idx );
      if(stat)
      {
         trace_new(FSM_TL3, WAR "oob_dmx_init_fsm: chn fsm(%s) is created.\n" NOR, 
                   oob_dmx_channel_fsms_names[idx] );
      }
      else
      {
         trace_new(FSM_ERR, ERR "oob_dmx_init_fsm: chn fsm(%s) is not created.\n" NOR,
                   oob_dmx_channel_fsms_names[idx] );
         return FALSE;
      }
   } // for end

   for( idx=0; idx < OOB_DMX_MAX_FILTERS; idx++)
   {
      sprintf( oob_dmx_filter_fsms_names[idx], "OOB_DMX_FIL_%02d", idx);

      oob_dmx_filter_fsms[idx].name          = (char*) oob_dmx_filter_fsms_names[idx];
      oob_dmx_filter_fsms[idx].state_list    = oob_dmx_filter_state_list; 
      oob_dmx_filter_fsms[idx].event_list    = oob_dmx_filter_event_list;
      oob_dmx_filter_fsms[idx].current_state = (fsm_state_t*) NULL;

      stat = fsm_create( &(oob_dmx_filter_fsms[idx]), ST_FI_CLOSE, EV_FI_CLOSE, (void*) &idx );
      if(stat)
      {
         trace_new(FSM_TL3, WAR "oob_dmx_init_fsm: fil fsm(%s) is created.\n" NOR, 
                   oob_dmx_filter_fsms_names[idx] );
      }
      else
      {
         trace_new(FSM_ERR, ERR "oob_dmx_init_fsm: fil fsm(%s) is not created.\n" NOR,
                   oob_dmx_filter_fsms_names[idx] );
         return FALSE;
      }
   } // for end

   // it is moved here because of init checking routine in oob_fsm_dmx_xxx
   g_is_oob_fsm_initialized = TRUE;

   // stat = fsm_create( &oob_dmx_demod_fsm, ST_CM_NOT_ALIVE, EV_CM_NOT_ALIVE);
   stat = fsm_create( &oob_dmx_demod_fsm, ST_CM_NOT_ALIVE, EV_CM_NOT_ALIVE, (void*) NULL );
   if(stat)
   {
      trace_new(FSM_TL3, WAR "oob_dmx_init_fsm: oob_dmx_demod_fsm created.\n" NOR );
   }      
   else
   {
      trace_new(FSM_ERR, ERR "oob_dmx_init_fsm: oob_dmx_demod_fsm is not created.\n" NOR );
      return FALSE;
   }

   return TRUE;
} // oob_fsm_init


/* =================================================================================
 * OOB_DMX_DEMOD
 * =================================================================================
 */  
bool oob_fsm_dmd_post_event(int connections, oob_dmx_demod_events_t event)
{
   fsm_status_t stat = FSM_ERR;

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmd_post_event: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   CS_EXEC_BEGIN();

   stat = fsm_post_event(&oob_dmx_demod_fsm, event, (void*) connections );

   CS_EXEC_END();

   return TRUE;
}


oob_dmx_demod_states_t oob_fsm_dmd_get_current_state(void)
{
   return fsm_get_current_state_hdl( &oob_dmx_demod_fsm );
}

bool oob_fsm_dmd_is_valid_event( oob_dmx_demod_events_t event )
{
   // return bool type
   return fsm_is_valid_incoming_event( &oob_dmx_demod_fsm, event );
}

bool oob_fsm_dmx_get( oob_dmx_instance_t* p_dmx )
{
   CS_DATA_BEGIN();

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmx_get: oob_fsm is not initialized.\n" NOR );
      CS_DATA_END();
      return FALSE;
   }

   if(!p_dmx)
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmx_get: invalid arg: p_dmx(0x%x).\n" NOR, p_dmx );
      CS_DATA_END();
      return FALSE;
   }

   trace_new(FSM_TL2, POP "oob_fsm_dmx_get: oob_dmx.avail_filters(%d)\n" NOR, oob_dmx.avail_filters );

   p_dmx->is_reset_raised     = oob_dmx.is_reset_raised;
   p_dmx->avail_channels      = oob_dmx.avail_channels;
   p_dmx->avail_filters       = oob_dmx.avail_filters;
   p_dmx->connection_notify   = oob_dmx.connection_notify;

   CS_DATA_END();

   return TRUE;
}


bool oob_fsm_dmx_set( oob_dmx_instance_t* p_dmx )
{
   CS_DATA_BEGIN();

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmx_set: oob_fsm is not initialized.\n" NOR );
      CS_DATA_END();
      return FALSE;
   }

   if(!p_dmx)
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmx_set: invalid arg, p_dmx(0x%x).\n" NOR, p_dmx );
      CS_DATA_END();
      return FALSE;
   }

   trace_new(FSM_TL2, POP "oob_fsm_dmx_set: oob_dmx.avail_filters(%d)\n" NOR, p_dmx->avail_filters );

   oob_dmx.is_reset_raised    = p_dmx->is_reset_raised;
   oob_dmx.connection_notify  = p_dmx->connection_notify;
   oob_dmx.avail_channels     = p_dmx->avail_channels;
   oob_dmx.avail_filters      = p_dmx->avail_filters;

   CS_DATA_END();

   return TRUE;
}


/* =================================================================================
 * OOB_DMX_CHANNEL
 * =================================================================================
 */  
bool oob_fsm_chn_post_event( uint32 chid, oob_dmx_channel_events_t event )
{
   fsm_status_t   stat = FSM_ERR;

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_post_event: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   CS_EXEC_BEGIN();

   stat = fsm_post_event(&(oob_dmx_channel_fsms[chid]), event, (void*) &chid );

   CS_EXEC_END();

   return TRUE;
}

oob_dmx_channel_states_t oob_fsm_chn_get_current_state(uint32 chid)
{
   return fsm_get_current_state_hdl( &(oob_dmx_channel_fsms[chid]) );
}

char* oob_fsm_chn_get_current_state_name( uint32 chid )
{
   return fsm_get_current_state_name( &(oob_dmx_channel_fsms[chid]) );
}

char* oob_fsm_chn_get_name( uint32 chid )
{
   return (oob_dmx_channel_fsms[chid].name);
}

oob_dmx_channel_states_t oob_fsm_chn_get_previous_state(uint32 chid)
{
   return fsm_get_previous_state_hdl( &(oob_dmx_channel_fsms[chid]) );
}

bool oob_fsm_chn_is_valid_event( uint32 chid, oob_dmx_channel_events_t event )
{
   return fsm_is_valid_incoming_event( &(oob_dmx_channel_fsms[chid]), event );
}

bool oob_fsm_chn_get( uint32 chid, oob_dmx_channel_t* p_channel )
{
   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_get: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   if((chid >= OOB_DMX_MAX_CHANNELS) && (!p_channel))
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_get: invalid arg: chid(%d) p_channel(0x%x).\n" NOR,
                chid, p_channel );
      return FALSE;
   }

   CS_DATA_BEGIN();

   p_channel->pid                = channel_list[chid].pid;
   p_channel->cnxt_chid          = channel_list[chid].cnxt_chid;
   p_channel->chid               = channel_list[chid].chid;
   p_channel->allocated_filters  = channel_list[chid].allocated_filters;
   p_channel->enabled_filters    = channel_list[chid].enabled_filters;
   p_channel->crc_status         = channel_list[chid].crc_status;
   p_channel->data_notify        = channel_list[chid].data_notify;

   CS_DATA_END();

   return TRUE;
}


bool oob_fsm_chn_set( uint32 chid, oob_dmx_channel_t* p_channel )
{
   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_set: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   if((chid >= OOB_DMX_MAX_CHANNELS) && (!p_channel))
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_set: invalid arg: chid(%d) p_channel(0x%x).\n" NOR,
                chid, p_channel );
      return FALSE;
   }

   CS_DATA_BEGIN();

   channel_list[chid].pid              = p_channel->pid;
   channel_list[chid].cnxt_chid        = p_channel->cnxt_chid;
   channel_list[chid].chid             = p_channel->chid;
   channel_list[chid].allocated_filters= p_channel->allocated_filters;
   channel_list[chid].enabled_filters  = p_channel->enabled_filters;
   channel_list[chid].crc_status       = p_channel->crc_status;
   channel_list[chid].data_notify      = p_channel->data_notify;

   CS_DATA_END();

   return TRUE;
}

bool oob_fsm_chn_get_back( uint32 chid )
{
   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_get_back: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   if((chid >= OOB_DMX_MAX_CHANNELS))
   {
      trace_new(FSM_ERR, ERR "oob_fsm_chn_get_back: invalid arg: chid(%d).\n" NOR,
                chid );
      return FALSE;
   }

   CS_DATA_BEGIN();
   oob_dmx_channel_fsms[chid].current_state = oob_dmx_channel_fsms[chid].previous_state;
   CS_DATA_END();

   return TRUE;
}


/* =================================================================================
 * OOB_DMX_FILTER
 * =================================================================================
 */  
bool oob_fsm_fil_post_event( uint32 fid, oob_dmx_channel_events_t event )
{
   fsm_status_t   stat = FSM_ERR;

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_fil_post_event: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   CS_EXEC_BEGIN();

   stat = fsm_post_event(&(oob_dmx_filter_fsms[fid]), event, (void*) &fid );

   CS_EXEC_END();

   return TRUE;
}

oob_dmx_filter_states_t oob_fsm_fil_get_current_state( uint32 fid )
{
   return fsm_get_current_state_hdl( &(oob_dmx_filter_fsms[fid]) );
}

char* oob_fsm_fil_get_current_state_name( uint32 fid )
{
   return fsm_get_current_state_name( &(oob_dmx_filter_fsms[fid]) );
}

char* oob_fsm_fil_get_name( uint32 fid )
{
   return ( oob_dmx_filter_fsms[fid].name );
}


oob_dmx_filter_states_t oob_fsm_fil_get_previous_state( uint32 fid )
{
   return fsm_get_previous_state_hdl( &(oob_dmx_filter_fsms[fid]) );
}

bool oob_fsm_fil_is_valid_event( uint32 fid, oob_dmx_channel_events_t event )
{
   return fsm_is_valid_incoming_event( &(oob_dmx_filter_fsms[fid]), event );
}

bool oob_fsm_fil_get( uint32 fid, oob_dmx_filter_t* p_filter )
{               
   uint32    idx = 0;

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_fil_get: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   if((fid >= OOB_DMX_MAX_FILTERS) && (!p_filter))
   {
      trace_new(FSM_ERR, ERR "oob_fsm_fil_get: invalid arg: fid(%d) p_filter(0x%x).\n" NOR,
                fid, p_filter );
      return FALSE;
   }

   CS_DATA_BEGIN();

   p_filter->chid = filter_list[fid].chid;
   p_filter->fid  = filter_list[fid].fid;
   p_filter->filter_size   = filter_list[fid].filter_size;

   for(idx=0; idx < OOB_DMX_FILTER_SIZE/4; idx++)
   {
      p_filter->match[idx]      = filter_list[fid].match[idx];
      p_filter->mask[idx]       = filter_list[fid].mask[idx];
      p_filter->not_match[idx]  = filter_list[fid].not_match[idx];
   }

   CS_DATA_END();

   return TRUE;
}


bool oob_fsm_fil_set( uint32 fid, oob_dmx_filter_t* p_filter )
{
   uint32    idx = 0;

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_fil_set: oob_fsm is not initialized.\n" NOR );
      return FALSE;
   }

   if((fid >= OOB_DMX_MAX_FILTERS) && (!p_filter))
   {
      trace_new(FSM_ERR, ERR "oob_fsm_fil_set: invalid arg: fid(%d) p_filter(0x%x).\n" NOR,
                fid, p_filter );
      return FALSE;
   }

   CS_DATA_BEGIN();

   filter_list[fid].chid         = p_filter->chid;
   filter_list[fid].fid          = p_filter->fid;
   filter_list[fid].filter_size  = p_filter->filter_size;

   for(idx=0; idx < OOB_DMX_FILTER_SIZE/4; idx++)
   {
      filter_list[fid].match[idx]      = p_filter->match[idx];
      filter_list[fid].mask[idx]       = p_filter->mask[idx];
      filter_list[fid].not_match[idx]  = p_filter->not_match[idx];
   }

   CS_DATA_END();

   return TRUE;
}


void oob_fsm_initialize_channel(uint32 chid)
{
   CS_DATA_BEGIN();

   channel_list[chid].allocated_filters = 0x0;
   channel_list[chid].cnxt_chid        = 0;
   channel_list[chid].chid             = 0;
   channel_list[chid].crc_status       = 0;
   channel_list[chid].enabled_filters   = 0x0;
   channel_list[chid].data_notify      = (oob_dmx_callback_t) NULL;
   channel_list[chid].pid              = 0;

   CS_DATA_END();
}

void oob_fsm_initialize_filter(uint32 fid)
{
   uint32 idx = 0;

   CS_DATA_BEGIN();

   filter_list[fid].chid         = 0;
   filter_list[fid].fid          = 0;
   filter_list[fid].filter_size  = 0;

   for(idx=0; idx < OOB_DMX_FILTER_SIZE/4; idx++)
   {
      filter_list[fid].mask[idx]       = (uint32)0;
      filter_list[fid].match[idx]      = (uint32)0;
      filter_list[fid].not_match[idx]   = (uint32)0;
   }

   CS_DATA_END();
}


static void initialize_dmx()
{
   CS_DATA_BEGIN();

   oob_dmx.is_reset_raised    = FALSE;
   oob_dmx.avail_channels     = (uint32) OOB_DMX_MAX_CHANNELS;
   oob_dmx.avail_filters      = (uint32) OOB_DMX_MAX_FILTERS;
   oob_dmx.connection_notify  = (oob_dmx_connection_t) NULL;

   CS_DATA_END();
} // initialize_oob_dmx_data()



static bool is_oob_fsm_initialized()
{
   return g_is_oob_fsm_initialized;
} // is_initialized_oob_dmx 


{source-dmx-api}

{source} <oob_dmx_api.h>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_API.H
 *
 * $Id: oob_dmx_api.h,v 1.1.1.3 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains interfaces of the oob dmx api. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_api.h,v $
 * Revision 1.1.1.3  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.2  2003/05/17 01:10:53  ktpark
 * correct status_get() args to meet oobfe release
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */
#ifndef __OOB_DMX_API_H__
#define __OOB_DMX_API_H__

#ifndef _OOB_API_H_
#include "oob_api.h"
#endif

#ifndef __OOB_DMX_DEF_H__
#include "oob_dmx_def.h" 
#endif
 

/* =================================================================================
 * D A T A T Y P E S
 * =================================================================================
 * enums and typdefs
 */  

/* ----------------------------------------------------------------------------------
 * oob_dmx_mode_t
 * ----------------------------------------------------------------------------------
 */
typedef enum {
   OOB_DMX_MODE_DVS,
   OOB_DMX_MODE_POD
} oob_dmx_mode_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_status_t
 * ----------------------------------------------------------------------------------
 typedef enum
 {
   OOB_RET_OK,
   OOB_RET_ERROR,
   OOB_RET_BAD_DOWN_PARAMS,
   OOB_RET_BAD_CHID,
   OOB_RET_BAD_VCI_VPI,
   OOB_RET_MAX_VCI_VPI,
   OOB_RET_BAD_ARGS
 } OOB_RESULTS;
 
 */

#define  OOB_DMX_ERR_BASE   10

typedef enum {
   OOB_DMX_OK              = CNXT_DAVIC_OOBFE_OK,
   OOB_DMX_ERR             = CNXT_DAVIC_OOBFE_ERROR,
   OOB_DMX_ERR_BAD_CHID    = CNXT_DAVIC_OOBFE_BAD_HANDLE,
   OOB_DMX_ERR_BAD_PID     = CNXT_DAVIC_OOBFE_BAD_VCI_VPI,
   OOB_DMX_ERR_NO_CHANNEL  = CNXT_DAVIC_OOBFE_MAX_VCI_VPI,
   OOB_DMX_ERR_BAD_FID     = OOB_DMX_ERR_BASE+1,
   OOB_DMX_ERR_NO_FILTER   = OOB_DMX_ERR_BASE+2,
   OOB_DMX_ERR_LOCK        = OOB_DMX_ERR_BASE+3,
   OOB_DMX_ERR_NOT_INIT    = OOB_DMX_ERR_BASE+4,
   OOB_DMX_ERR_BAD_PARAM   = OOB_DMX_ERR_BASE+5
} oob_dmx_status_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_callback_data_t
 * ----------------------------------------------------------------------------------
 */
typedef struct {
   uint8*   pdata;
   uint8*   mBlkPtr;
   uint32   chid;
   uint32   fid;
   uint32   length;
} oob_dmx_callback_data_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_callback_t
 * ----------------------------------------------------------------------------------
 */
typedef void (*oob_dmx_callback_t)( oob_dmx_callback_data_t* pdata );


/* ----------------------------------------------------------------------------------
 * oob_dmx_connection_status_t
 * ----------------------------------------------------------------------------------

typedef enum {
#define _CONNECTION_STATE(code, str) code,
} oob_dmx_connection_status_t;
 */

typedef enum {
   OOB_CON_CONNECTED,
   OOB_CON_DISCONNECTED,
   OOB_CON_IN_PROGRESS,
   OOB_CON_RESET
} oob_dmx_connection_status_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_commands_t
 * ----------------------------------------------------------------------------------
 */
typedef CNXT_DAVIC_OOBFE_COMMANDS oob_dmx_commands_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_connection_t
 * ----------------------------------------------------------------------------------
 */
typedef void (*oob_dmx_connection_t)( oob_dmx_connection_status_t stat );


/* ----------------------------------------------------------------------------------
 * oob_dmx_channel_ftabls_t
 * ----------------------------------------------------------------------------------
 */
typedef struct 
{
   CNXT_DAVIC_OOBFE_STATUS (*init) ( void );
   CNXT_DAVIC_OOBFE_STATUS (*param_set) ( CNXT_DAVIC_OOBFE_HANDLE handle, CNXT_DAVIC_OOBFE_DOWNSTREAM_PARAMS *downstream_params);
   CNXT_DAVIC_OOBFE_STATUS (*control_set) ( PCALLBACKFUNC_CONTROL pfunc );
   CNXT_DAVIC_OOBFE_STATUS (*channel_open) ( CNXT_DAVIC_OOBFE_HANDLE handle, u_int16 vci, u_int8 vpi, u_int32* chid); 
   CNXT_DAVIC_OOBFE_STATUS (*channel_control)( CNXT_DAVIC_OOBFE_HANDLE handle, u_int32 chid, CNXT_DAVIC_OOBFE_COMMANDS command );
   CNXT_DAVIC_OOBFE_STATUS (*channel_close)( CNXT_DAVIC_OOBFE_HANDLE handle, u_int32 chid );
   CNXT_DAVIC_OOBFE_STATUS (*channel_all_close)( CNXT_DAVIC_OOBFE_HANDLE handle );
   CNXT_DAVIC_OOBFE_CHANNEL_STATUS (*status_get) ( CNXT_DAVIC_OOBFE_HANDLE handle, u_int32 chid, CNXT_DAVIC_OOBFE_CHANNEL_STATUS *pStatus );   
} oob_dmx_channel_ftabls_t;


/* ----------------------------------------------------------------------------------
 * oob_dmx_ip_fragment_type_t
 * ----------------------------------------------------------------------------------
 */
typedef enum {
   OOB_DMX_IP_UNKNOWN_FRAG,
   OOB_DMX_IP_DONT_FRAG,
   OOB_DMX_IP_MORE_FRAG,
   OOB_DMX_IP_LAST_FRAG
} oob_dmx_ip_fragment_type_t;


/* =================================================================================
 * I N T E R F A C E S
 * =================================================================================
 */  
extern oob_dmx_status_t oob_dmx_init( oob_dmx_mode_t mode );
extern oob_dmx_status_t oob_dmx_set_control_callback( oob_dmx_connection_t notify );
extern oob_dmx_status_t oob_dmx_open_channel( uint32* chid, uint16 pid );
extern oob_dmx_status_t oob_dmx_set_channel_attributes( uint32 chid, oob_dmx_callback_t header_notify,
                                                 oob_dmx_callback_t data_notify, 
                                                 uint16 timeout, uint16 header_size );
extern oob_dmx_status_t oob_dmx_control_channel( uint32 chid, oob_dmx_commands_t command );
extern oob_dmx_status_t oob_dmx_close_channel( uint32 chid );
extern void oob_dmx_close_all_channel();

extern oob_dmx_status_t oob_dmx_open_filter( uint32 chid, uint16 size, uint32* fid);
extern oob_dmx_status_t oob_dmx_set_filter( uint32 chid, uint32 fid, uint8* match, uint8* mask );
extern oob_dmx_status_t oob_dmx_control_filter( uint32 chid, uint32 fid, oob_dmx_commands_t command );
extern oob_dmx_status_t oob_dmx_close_filter( uint32 chid, uint32 fid);

extern oob_dmx_status_t oob_dmx_free_buf( uint8* buf );

extern oob_dmx_status_t oob_dmx_info_control(CNXT_DAVIC_OOBFE_INFO_DATA_CODE info_code, oob_dmx_commands_t command);
extern oob_dmx_status_t oob_dmx_info_read(CNXT_DAVIC_OOBFE_INFO_DATA_CODE info_code);


#ifdef DEBUG
extern void debug_dmx_info();
extern void debug_channel_info(uint32 chid);
extern void debug_filter_info(uint32 fid);
extern void debug_netpool_info();
extern void debug_task_info();
extern void debug_queue_info();
extern void debug_channel_fsm_info();
extern void debug_filter_fsm_info();

extern void debug_cnxt_show_all();
extern void debug_cnxt_stats_show();
extern void debug_cnxt_channel_list_show(unsigned int channel);
#endif

#endif /* __OOB_DMX_API_H__ */
       

{source} <oob_dmx_api.c>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_API.C
 *
 * $Id: oob_dmx_api.c,v 1.1.1.5 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains implementations of the oob dmx api. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_api.c,v $
 * Revision 1.1.1.5  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.4  2003/05/17 05:37:59  ktpark
 * fix the bug on fragment count, id and modify do not pump when setion length mismatch.
 *
 * Revision 1.1.1.3  2003/05/17 02:14:32  ktpark
 * modify alive timeout
 *
 * Revision 1.1.1.2  2003/05/17 01:34:03  ktpark
 * modify oob_dmx_init() info messages
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */

   
/* =================================================================================
 * I N C L U D E S
 * =================================================================================
 */    
 
#include <stdio.h>
#include <string.h>
#include <vxworks.h>
#include <basetype.h>
#include <taskLib.h>
#include <msgQLib.h>
#include <retcodes.h>
#include <netBufLib.h>

#include <trace.h>
#include <cm_oob_types.h>
#include "oob_dmx_def.h"
#include "oob_dmx_fsm.h" 
#include "oob_dmx_api.h"
#include "oob_dmx_util.h"


/* =================================================================================
 * C O N S T A N T S 
 * =================================================================================
 */  
#define CS_DMX_BEGIN()   oob_msem_take(oob_dmx_exec_sid)
#define CS_DMX_END()     oob_msem_give(oob_dmx_exec_sid)


/* =================================================================================
 * F O R W A R D S
 * =================================================================================
 */  
static void cm_not_alive_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void cm_alive_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void ch_unlock_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void ch_lock_eaf( fsm_instance_t* fsm, fsm_event_t* event);

static void ch_open_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void ch_close_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void ch_enable_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void ch_disable_eaf( fsm_instance_t* fsm, fsm_event_t* event);

static void fi_open_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void fi_close_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void fi_enable_eaf( fsm_instance_t* fsm, fsm_event_t* event);
static void fi_disable_eaf( fsm_instance_t* fsm, fsm_event_t* event);

static void add_off_match_job(uint32 chid, uint32 length, uint32* p_data, uint8* mBlkPtr, uint16 ip_id );
static void add_off_pump_job(uint32 chid, uint32 fid, uint32 length, uint32* p_data, uint8* mBlkPtr );

static void oob_dmx_match_task(void);
static void oob_dmx_pump_task(void);

static bool is_oob_dmx_initialized();
static bool find_chid_from_cnxt_chid(uint32* chid, uint32 cnxt_chid);
static int control_callback_params_check(PCNXT_DAVIC_OOBFE_CALLBACKCONTROL p_control_info);
static int data_callback_params_check(PCNXT_DAVIC_OOBFE_CALLBACKDATA pDataInfo);

static oob_dmx_ip_fragment_type_t get_ip_fragment_type(uint32* p_ip_header, uint16* ip_id, uint16* ip_flag, uint16* ip_offset);
static bool is_section_length_matched(uint32 section_length, uint8* p_section );
static void reset_internal_data();

static void oob_control_callback( PCNXT_DAVIC_OOBFE_CALLBACKCONTROL p_control );
static void oob_data_callback( PCNXT_DAVIC_OOBFE_CALLBACKDATA p_data );
static CNXT_DAVIC_OOBFE_STATUS oob_callback(CNXT_DAVIC_OOBFE_HANDLE  handle,
                                                    void                    *pUserData,
                                                    CNXT_DAVIC_OOBFE_EVENT  event,
                                                    void                    *pData,
                                                    void                    *Tag );

static uint16 map_pid_to_vci(uint16 pid);
void trace_now(char *string, ...);


/* =================================================================================
 * G L O B A L S
 * =================================================================================
 */  

extern NET_POOL_ID pci_memPoolId;
extern unsigned int      uiNumAvailableBuffers;       /* number of free bds */

extern void netPoolShow(NET_POOL_ID pNetPool);
extern void i(int taskNameOrId /* task name or task ID, 0 = summarize all */);
extern void trace_message(bool bNoTsFlag, char *string, va_list arg);

/* ----------------------------------------------------------------------------------
 * g_is_oob_dmx_initialized
 * ----------------------------------------------------------------------------------
 */
static bool g_is_oob_dmx_initialized = FALSE;

static oob_dmx_status_t g_ret = OOB_DMX_ERR;


/* ----------------------------------------------------------------------------------
 * oob_ftables
 * ----------------------------------------------------------------------------------
 */
static oob_dmx_channel_ftabls_t oob_ftables = {0};
                                     

/* ----------------------------------------------------------------------------------
 * oob_ftables
 * ----------------------------------------------------------------------------------
 */
static eaf_ftabls_t eafs = {
   (fsm_action_func_t*)&cm_not_alive_eaf,
   (fsm_action_func_t*)&cm_alive_eaf,
   (fsm_action_func_t*)&ch_unlock_eaf,
   (fsm_action_func_t*)&ch_lock_eaf,
   // channels
   (fsm_action_func_t*)&ch_open_eaf,
   (fsm_action_func_t*)&ch_close_eaf,
   (fsm_action_func_t*)&ch_enable_eaf,
   (fsm_action_func_t*)&ch_disable_eaf,
   // filters
   (fsm_action_func_t*)&fi_open_eaf,
   (fsm_action_func_t*)&fi_close_eaf,
   (fsm_action_func_t*)&fi_enable_eaf,
   (fsm_action_func_t*)&fi_disable_eaf,
};


/* ----------------------------------------------------------------------------------
 * IDs
 * ----------------------------------------------------------------------------------
 */
static int        oob_dmx_pump_tid        = 0;
static int        oob_dmx_match_tid       = 0;

static MSG_Q_ID   oob_dmx_off_pump_qid    = 0;   
static MSG_Q_ID   oob_dmx_off_match_qid   = 0;   

static SEM_ID     oob_dmx_exec_sid        = 0;

static NET_POOL_ID   oob_dmx_section_pool  = 0;
static M_BLK_ID      g_ptr_first_mblk     = 0;
uint16        g_ip_id              = 0;
uint16        g_fragment_cnt       = 0;
uint32        g_total_length       = 0;

uint32               g_pump_cnt              = 0;
uint32               g_data_callback_cnt     = 0;

static CNXT_DAVIC_OOBFE_HANDLE          g_oobfe_handle =NULL;
static CNXT_DAVIC_OOBFE_CAPS            g_oobfe_caps;

/* =================================================================================
 * ALIVE TIMER
 * =================================================================================
 */  
#ifdef ALIVE_TIMER_ON

// ms period
#define OOB_DMX_ALIVE_TIMEOUT 5000
#define OOB_DMX_ALIVE_MESG    100

static timer_id_t oob_dmx_alive_timer     = 0;
static uint32     oob_dmx_alive_cnt       = 0;

static void oob_dmx_alive_timer_handler(timer_id_t timer, void *arg)
{
   uint32 msg[OOB_DMX_MATCH_Q_LEN_MESG/4]   = {0};

   oob_dmx_alive_cnt++;

   msg[0] = (u_int32)OOB_DMX_ALIVE_MESG;
   msg[1] = msg[2] = msg[3] = msg[4] = (u_int32)0;

   msgQSend(oob_dmx_off_match_qid, (char*)msg, OOB_DMX_MATCH_Q_LEN_MESG, NO_WAIT, MSG_PRI_NORMAL);
}

#endif // ALIVE_TIMER_ON


/* =================================================================================
 * CONTROL INFO TEST
 * =================================================================================
 */  
#ifdef CONTROL_INFO_TEST_ON

#define OOB_INFO_TEST_TIMEOUT    1000
#define OOB_INFO_TEST_MESG       200

static timer_id_t    oob_info_test_timer     = 0;
static uint32        oob_info_test_cnt       = 0;

static void oob_dmx_info_test_timer_handler(timer_id_t timer, void *arg)
{
   uint32 msg[OOB_DMX_MATCH_Q_LEN_MESG/4]   = {0};

   oob_info_test_cnt++;

   msg[0] = (u_int32)OOB_INFO_TEST_MESG;
   msg[1] = msg[2] = msg[3] = msg[4] = (u_int32)0;

   msgQSend(oob_dmx_off_match_qid, (char*)msg, OOB_DMX_MATCH_Q_LEN_MESG, NO_WAIT, MSG_PRI_NORMAL);
}

#endif // CONTROL_INFO_TEST_ON



/* =================================================================================
 * E A F S
 * =================================================================================
 */

/* =================================================================================
 * OOB_DMX_DEMOD
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CM_NOT_ALIVE_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    cm not alive eaf
 *   
 ** SYNTAX
 *	  void 
 *     cm_not_alive_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - initialize sub layer and register control callback
 *    - create sem, q and tasks
 *    - set downstream params to sub layer
 *    - TEMPORARILY post a cm alive message on purpose
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a demod fsm
 * ----------------------------------------------------------------------------------
 */      
static void cm_not_alive_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{  
   oob_dmx_instance_t   dmx      = {0};

#ifndef ALIVE_MSG_DEBUG_ON
   CNXT_DAVIC_OOBFE_DOWNSTREAM_PARAMS   oob_downstream_params   = {0};
#endif

   // state check
   if( !oob_fsm_dmd_is_valid_event(event->hdl) )
   {
      trace_new( OOB_ERR, ERR "cm_not_alive_eaf: invalid state change.\n" NOR );
      return;
   }

   trace_new(OOB_TL4, WAR "cm_not_alive_eaf: event(%s).\n" NOR, event->name ); 
   
   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_TL4, WAR "cm_not_alive_eaf: initialize oob_dmx.\n" NOR );

      g_ret = oob_ftables.init();
      if( g_ret != CNXT_DAVIC_OOBFE_OK )
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: oob_ftables.init is fail.\n" NOR );
         return;
      }
      
      g_oobfe_caps.bExclusive = TRUE;
      g_oobfe_caps.uLength = sizeof(CNXT_DAVIC_OOBFE_CAPS);
      g_oobfe_caps.uSlotNum = 0;

      g_ret = cnxt_davic_oobfe_get_unit_caps(0, &g_oobfe_caps);
      if( g_ret != CNXT_DAVIC_OOBFE_OK)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: cnxt_davic_oobfe_get_unit_caps() is fail.\n" NOR );
         return;   
      }
      
      g_ret = cnxt_davic_oobfe_open(&g_oobfe_handle, &g_oobfe_caps, oob_callback, NULL);
      if( g_ret != CNXT_DAVIC_OOBFE_OK)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: cnxt_davic_oobfe_open() is fail.\n" NOR );
         return;
      }

      // crate semaphore
      oob_dmx_exec_sid = semMCreate(OOB_DMX_SEM_OPTIONS);
      if(!oob_dmx_exec_sid)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: sem create(dmx) is fail.\n" NOR );
         return;
      }

      oob_dmx_off_pump_qid = msgQCreate( OOB_DMX_PUMP_Q_MAX_MESG, OOB_DMX_PUMP_Q_LEN_MESG, MSG_Q_PRIORITY);
      if(!oob_dmx_off_pump_qid)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: oob_dmx_off_pump_qid is fail.\n" NOR );
         return;
      }

      oob_dmx_off_match_qid = msgQCreate( OOB_DMX_MATCH_Q_MAX_MESG, OOB_DMX_MATCH_Q_LEN_MESG, MSG_Q_PRIORITY);
      if(!oob_dmx_off_match_qid)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: oob_dmx_off_match_qid is fail.\n" NOR );
         return;
      }

      // create task taskSpawn
      oob_dmx_pump_tid = taskSpawn( OOB_DMX_PUMP_NAME, OOB_DMX_PUMP_PRIORITY, OOB_DMX_PUMP_OPTIONS, 
                                  OOB_DMX_PUMP_STACK_SIZE, (FUNCPTR) oob_dmx_pump_task, 
                                  0,0,0,0,0,0,0,0,0,0);
      if(!oob_dmx_pump_tid)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: oob_dmx_pump_tid is fail.\n" NOR );
         return;
      }

      // create task taskSpawn
      oob_dmx_match_tid = taskSpawn( OOB_DMX_MATCH_NAME, OOB_DMX_MATCH_PRIORITY, OOB_DMX_MATCH_OPTIONS, 
                                  OOB_DMX_MATCH_STACK_SIZE, (FUNCPTR) oob_dmx_match_task, 
                                  0,0,0,0,0,0,0,0,0,0);
      if(!oob_dmx_match_tid)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: oob_dmx_match_tid is fail.\n" NOR );
         return;
      }

      oob_dmx_section_pool = oob_npool_init( OOB_DMX_NUM_OF_CLUSTERS+1, 
                                         OOB_DMX_NUM_OF_CLUSTERS+1,
                                         OOB_DMX_NUM_OF_CLUSTERS,
                                         OOB_DMX_SIZE_OF_CLUSTER );
      if(!oob_dmx_section_pool)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf_d: oob_dmx_section_pool is fail.\n" NOR );
         return;
      }
      else
         trace_new( OOB_TL4, WAR "cm_not_alive_eaf_d: oob_dmx_section_pool is success.\n" NOR );

#ifdef ALIVE_TIMER_ON

      if (!(oob_dmx_alive_timer = tick_create(oob_dmx_alive_timer_handler, NULL, NULL)))
         return;

      if(tick_set(oob_dmx_alive_timer, OOB_DMX_ALIVE_TIMEOUT, TRUE) != RC_OK)
         return;

      tick_start(oob_dmx_alive_timer);

#endif //ALIVE_TIMER_ON 

#ifndef ALIVE_MSG_DEBUG_ON

#ifdef CONTROL_INFO_TEST_ON
      if( cnxt_davic_oobfe_info_control(g_oobfe_handle, 0, 1) != CNXT_DAVIC_OOBFE_OK)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: cnxt_oob_info_control(0,1) is fail.\n" NOR);
      }

      if( cnxt_davic_oobfe_info_control(g_oobfe_handle, 2, 1) != CNXT_DAVIC_OOBFE_OK)
      {
         trace_new( OOB_ERR, ERR "cm_not_alive_eaf: cnxt_oob_info_control(2,1) is fail.\n" NOR);
      }
      
      if (!(oob_info_test_timer = tick_create(oob_dmx_info_test_timer_handler, NULL, NULL)))
         return;
      
      if(tick_set(oob_info_test_timer, OOB_INFO_TEST_TIMEOUT, TRUE) != RC_OK)
         return;
      
      tick_start(oob_info_test_timer);
      
#endif //CONTROL_INFO_TEST_ON 

      // set dn stream params
      oob_downstream_params.downstream_modulation_type = 2;//qpsk
      oob_downstream_params.scan_symbol_rate = 0;//no_scan
      oob_downstream_params.scan_spectral_inversion = 0;//no_scan
      oob_downstream_params.scan_modulation_type = 0;//no_scan
      oob_downstream_params.scan_frequency = 0;//no_scan
      oob_downstream_params.downstream_frequency = 75000000;
      oob_downstream_params.ds_frequency_scan_start = 70000000;
      oob_downstream_params.ds_frequency_scan_stop = 130000000;
      oob_downstream_params.ds_frequency_step_size = 1000000;
      oob_downstream_params.ds_symbol_rate0 = 772000;//1.544 Mbps
      oob_downstream_params.ds_symbol_rate1 = 1544000;//3.088 Mbps
      oob_downstream_params.ds_symbol_rate2 = 0;
      oob_downstream_params.ds_symbol_rate3 = 0;
      oob_downstream_params.cSdpVhfL = 0;
      oob_downstream_params.cSdpVhfH = 0;
      oob_downstream_params.cSdpUhf = 0;
      oob_downstream_params.spectral_inversion = 0;//???

      g_ret = oob_ftables.param_set(g_oobfe_handle, &oob_downstream_params);
      if( g_ret == CNXT_DAVIC_OOBFE_OK )
      {
         trace_new(OOB_TL3, WAR "cm_not_alive_eaf: cnxt_oob_downstream_params_set is success.\n" NOR );
      }
      else
      {
         trace_new(OOB_ERR, ERR "cm_not_alive_eaf: cnxt_oob_downstream_params_set is fail. oob_ret(0x%x).\n" NOR, g_ret );
         return;
      }

      trace_new( OOB_TL3, WAR "cm_not_alive_eaf: ** oob_fsm_dmd_post_event(EV_CM_ALIVE) **.\n" NOR );
      oob_fsm_dmd_post_event((int) OOB_CON_DISCONNECTED, EV_CM_ALIVE );

#endif // ALIVE_MSG_DEBUG_ON

      // M030526
      g_is_oob_dmx_initialized = TRUE;
   } // end if g_is_oob_dmx_initialized is false
   else
   {
      trace_new( OOB_TL4, WAR "cm_not_alive_eaf: reset oob_dmx internals. event data(%d).\n" NOR
                 , (oob_dmx_connection_status_t) event->data );

      // in case of reset from lock state
      if(((oob_dmx_connection_status_t) event->data)==OOB_CON_RESET)
      {
         oob_fsm_dmx_get(&dmx);
         dmx.is_reset_raised = TRUE;
         oob_fsm_dmx_set(&dmx);
      }

      reset_internal_data();
   }

} // cm_not_alive_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CM_ALIVE_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    cm alive eaf
 *   
 ** SYNTAX
 *	  void 
 *     cm_alive_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - turn on initialization flag of oob dmx
 *    - go to unlock state
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a demod fsm
 * ----------------------------------------------------------------------------------
 */      
static void cm_alive_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
#ifdef ALIVE_MSG_DEBUG_ON
   CNXT_DAVIC_OOBFE_DOWNSTREAM_PARAMS   oob_downstream_params   = {0};
#endif

   // state check
   if( !oob_fsm_dmd_is_valid_event(event->hdl) )
   {
      trace_new( OOB_ERR, ERR "cm_alive_eaf: invalid state change.\n" NOR );
      return;
   }

   trace_new(OOB_TL4, "cm_alive_eaf: event(%s).\n", event->name ); 

   // is oob_dmx not initialized?
   // M030526, mod for only if oob_dmx was initialized.
   if( is_oob_dmx_initialized() )
   {

#ifdef ALIVE_MSG_DEBUG_ON
      // set dn stream params
      oob_downstream_params.downstream_modulation_type = 2;//qpsk
      oob_downstream_params.scan_symbol_rate = 0;//no_scan
      oob_downstream_params.scan_spectral_inversion = 0;//no_scan
      oob_downstream_params.scan_modulation_type = 0;//no_scan
      oob_downstream_params.scan_frequency = 0;//no_scan
      oob_downstream_params.downstream_frequency = 75000000;
      oob_downstream_params.ds_frequency_scan_start = 70000000;
      oob_downstream_params.ds_frequency_scan_stop = 130000000;
      oob_downstream_params.ds_frequency_step_size = 1000000;
      oob_downstream_params.ds_symbol_rate0 = 772000;//1.544 Mbps
      oob_downstream_params.ds_symbol_rate1 = 1544000;//3.088 Mbps
      oob_downstream_params.ds_symbol_rate2 = 0;
      oob_downstream_params.ds_symbol_rate3 = 0;
      oob_downstream_params.cSdpVhfL = 0;
      oob_downstream_params.cSdpVhfH = 0;
      oob_downstream_params.cSdpUhf = 0;
      oob_downstream_params.spectral_inversion = 0;//???

      g_ret = oob_ftables.param_set(g_oobfe_handle, &oob_downstream_params);
      if( g_ret == CNXT_DAVIC_OOBFE_OK )
      {
         trace_new(OOB_TL3, WAR "cm_alive_eaf: cnxt_oob_downstream_params_set is success.\n" NOR );
      }
      else
      {
         trace_new(OOB_ERR, ERR "cm_alive_eaf: cnxt_oob_downstream_params_set is fail. oob_ret(0x%x).\n" NOR, g_ret );
         return;
      }
#endif // ALIVE_MSG_DEBUG_ON

      trace_new( OOB_TL3, WAR "cm_alive_eaf: ** oob_fsm_dmd_post_event(EV_CH_UNLOCK) **.\n" NOR );
      oob_fsm_dmd_post_event((int) OOB_CON_DISCONNECTED, EV_CH_UNLOCK );
   } // if end

} // cm_alive_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CH_UNLOCK_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    channel unlock eaf
 *   
 ** SYNTAX
 *	  void 
 *     ch_unlock_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - wait until cm is locked
 *    - go to lock state
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a demod fsm
 * ----------------------------------------------------------------------------------
 */      
static void ch_unlock_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   oob_dmx_instance_t   dmx      = {0};

   // state check
   if( !oob_fsm_dmd_is_valid_event(event->hdl) )
   {
      trace_new( OOB_ERR, ERR "ch_unlock_eaf: invalid state change.\n" NOR );
      return;
   }

   trace_new(OOB_TL4, WAR "ch_unlock_eaf: event(%s).\n" NOR, event->name );

   oob_fsm_dmx_get(&dmx);

   // in case of reset from lock state
   if(((oob_dmx_connection_status_t) event->data)==OOB_CON_RESET)
   {
      dmx.is_reset_raised = TRUE;
      oob_fsm_dmx_set(&dmx);
   }
   else
   {
      dmx.is_reset_raised = FALSE;
      oob_fsm_dmx_set(&dmx);
   }

   //if(oob_fsm_dmd_get_previous_state() == ST_CH_LOCK)
   if(((oob_dmx_connection_status_t) event->data)==OOB_CON_RESET)
   {
      trace_new(OOB_TL4, WAR "ch_unlock_eaf: reset_internal_data.\n" NOR );
      reset_internal_data();
   }                        

   // in case that client provides a notify
   if(dmx.connection_notify)
      dmx.connection_notify( (oob_dmx_connection_status_t) event->data );

} // ch_unlock_eaf 
   

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CH_LOCK_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    channel lock eaf
 *   
 ** SYNTAX
 *	  void 
 *     ch_lock_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - wait until cm is locked
 *    - go to lock state
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a demod fsm
 * ----------------------------------------------------------------------------------
 */      
static void ch_lock_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   oob_dmx_instance_t   dmx      = {0};

   // state check
   if( !oob_fsm_dmd_is_valid_event(event->hdl) )
   {
      trace_new( OOB_ERR, ERR "ch_lock_eaf: invalid state change.\n" NOR );
      return;
   }

   trace_new(OOB_TL4, WAR "ch_lock_eaf: event(%s).\n" NOR, event->name );

#ifdef ALIVE_MSG_DEBUG_ON

#ifdef CONTROL_INFO_TEST_ON
   if( cnxt_davic_oobfe_info_control(g_oobfe_handle, 0, 1) != CNXT_DAVIC_OOBFE_OK)
   {
      trace_new( OOB_ERR, ERR "cm_not_alive_eaf: cnxt_oob_info_control(0,1) is fail.\n" NOR);
   }

   if( cnxt_davic_oobfe_info_control(g_oobfe_handle, 2, 1) != CNXT_DAVIC_OOBFE_OK)
   {
      trace_new( OOB_ERR, ERR "cm_not_alive_eaf: cnxt_oob_info_control(2,1) is fail.\n" NOR);
   }
   
   if (!(oob_info_test_timer = tick_create(oob_dmx_info_test_timer_handler, NULL, NULL)))
      return;
   
   if(tick_set(oob_info_test_timer, OOB_INFO_TEST_TIMEOUT, TRUE) != RC_OK)
      return;
   
   tick_start(oob_info_test_timer);  
#endif //CONTROL_INFO_TEST_ON 
#endif // ALIVE_MSG_DEBUG_ON

   oob_fsm_dmx_get(&dmx);

   // in case that client provides a notify
   if(dmx.connection_notify)
      dmx.connection_notify( (oob_dmx_connection_status_t) event->data );

} // ch_lock_eaf



/* =================================================================================
 * OOB_DMX_CHANNEL
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CH_CLOSE_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    channel close eaf
 *   
 ** SYNTAX
 *	  void 
 *     ch_close_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    This eaf close a channel of sub layer and increase available channels
 *    only when state comes from other states except init state(close) state.
 *    Always, it initialize channel data.
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a channel fsm
 * ----------------------------------------------------------------------------------
 */      
static void ch_close_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint32               chid     = 0;
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_instance_t   dmx      = {0};
   uint8                idx      = 0;

#ifdef OOB_DMX_DEBUG
   char buf_alloc[MAX_TRACEMSG_CHARS]={0};
   char buf_enable[MAX_TRACEMSG_CHARS]={0};
#endif

   chid = *((uint32*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_chn_is_valid_event(chid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "ch_close_eaf: chid(%d), invalid state change.\n" NOR,
                 chid );
      return;
   }

   trace_new(OOB_TL4, WAR "ch_close_eaf: chid(%d), event(%s).\n" NOR, chid, event->name); 

   // does this state not come from init state?
   if( oob_fsm_chn_get_previous_state(chid) != ST_CH_CLOSE)
   {
      if(oob_fsm_chn_get(chid, &channel)
         && oob_fsm_dmx_get(&dmx))
      {
         // in case that reset is not raised
         if(!dmx.is_reset_raised)
         {
            trace_new(OOB_TL4, WAR "ch_close_eaf: reset not raised, so close chid(%d).\n" NOR, chid ); 

            g_ret = oob_ftables.channel_close( g_oobfe_handle, channel.cnxt_chid );         
            if( g_ret != CNXT_DAVIC_OOBFE_OK )
            {
               trace_new(OOB_ERR, ERR "ch_close_eaf: chid(%d), cnxt_oob_channel_close is fail. g_ret(0x%x).\n" NOR, 
                         chid, g_ret );
               return;
            }
         }

#ifdef OOB_DMX_DEBUG
         bsprintf( buf_alloc, channel.allocated_filters  );
         bsprintf( buf_enable, channel.enabled_filters );

         trace_new(OOB_TL3, WAR 
                   "ch_close_eaf:\n"
                   "------------------------------\n"
                   "chid                      : %d.\n"
                   "cnxt_chid                 : %d.\n"
                   "pid                       : %d.\n"
                   "channel.allocated_filters : %s.\n"
                   "channel.enabled_filters   : %s.\n"
                   "dmx.avail_channels        : %d.\n" NOR, 
                   channel.chid, channel.cnxt_chid, channel.pid,
                   buf_alloc, buf_enable, dmx.avail_channels );
#endif

         dmx.avail_channels++;

         oob_fsm_dmx_set(&dmx);

         // close all filters which is binded to a channel
         for(idx=0; idx < OOB_DMX_MAX_FILTERS; idx++)
         {
            // a allocated filter is founded
            if((channel.allocated_filters>>idx) &1)
            {
               trace_new(OOB_TL3, WAR "ch_close_eaf: chid(%d), fid(%d), ** oob_fsm_fil_post_event(EV_FI_CLOSE) **.\n" NOR, 
                         chid, idx );
               oob_fsm_fil_post_event(idx, EV_FI_CLOSE);
            }
         }
      }
   }

   oob_fsm_initialize_channel(chid);
} // ch_close_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CH_OPEN_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    channel open eaf
 *   
 ** SYNTAX
 *	  void 
 *     ch_open_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - open a channel of sub layer
 *    - if fail to open a channel, put a channel state back to close state.
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a channel fsm
 * ----------------------------------------------------------------------------------
 */      
static void ch_open_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint32               chid = 0;
   oob_dmx_channel_t    channel  = {0};

   chid = *((uint32*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_chn_is_valid_event(chid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "ch_open_eaf: chid(%d), invalid state change.\n" NOR,
                 chid );
      return;
   }

   trace_new(OOB_TL4, WAR "ch_open_eaf: chid(%d), event(%s).\n" NOR, chid, event->name); 
   
   // get valid channel instance
   if( oob_fsm_chn_get(chid, &channel) )
   {
      g_ret = oob_ftables.channel_open( g_oobfe_handle, channel.pid, 0, &channel.cnxt_chid );
      if( g_ret == CNXT_DAVIC_OOBFE_OK )
      {
         oob_fsm_chn_set( chid, &channel );

         trace_new(OOB_TL3, WAR "ch_open_eaf: chid(%d), cnxt_chid(%d), pid(%d).\n" NOR, 
                   channel.chid, channel.cnxt_chid, channel.pid );
      }
      else
      {
         trace_new(OOB_ERR, ERR "ch_open_eaf: chid(%d), cnxt_oob_channel_open is fail. g_ret(0x%x).\n" NOR,
                   chid, g_ret );
         trace_new(OOB_TL3, WAR "ch_open_eaf: ** oob_fsm_chn_post_event(EV_CH_CLOSE) **.\n" NOR );
         oob_fsm_chn_post_event( chid, EV_CH_CLOSE );
      }
   }
} // ch_open_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CH_ENABLE_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    enables an channel
 *   
 ** SYNTAX
 *	  void 
 *     ch_enable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - enables an channel and data pumping will be started
 *    - if fail to enable a channel, put a channel state back to prev. state.
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a channel fsm
 * ----------------------------------------------------------------------------------
 */      
static void ch_enable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint8                chid     = 0;
   oob_dmx_channel_t    channel  = {0};

   chid = *((uint8*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_chn_is_valid_event(chid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "ch_enable_eaf: chid(%d), invalid state change.\n" NOR,
                 chid );
      return;
   }

   trace_new(OOB_TL4, WAR "ch_enable_eaf: chid(%d), event(%s).\n" NOR,
             chid, event->name);

   if( oob_fsm_chn_get(chid,&channel) )
   {
      g_ret = oob_ftables.channel_control( g_oobfe_handle, channel.cnxt_chid, OOB_CMD_ENABLE );      
      if( g_ret == CNXT_DAVIC_OOBFE_OK )
      {
         trace_new(OOB_TL3, WAR "ch_enable_eaf: chid(%d), cnxt_oob_channel_control is success.\n" NOR,
                   chid );
      }
      else
      {
         trace_new(OOB_ERR, ERR "ch_enable_eaf: chid(%d), cnxt_oob_channel_control is fail. g_ret(0x%x).\n" NOR, 
                   chid, g_ret );

         oob_fsm_chn_get_back(chid);
         trace_new(OOB_ERR, ERR "ch_enable_eaf: chid(%d), put back and cur state(%s).\n" NOR, 
                   chid, oob_fsm_chn_get_current_state_name(chid) );
         return;
      }
   }
} // ch_enable_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: CH_DISABLE_EAF
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    disables an channel
 *   
 ** SYNTAX
 *	  void 
 *     ch_disable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    - disables an channel and data pumping will be stopped
 *    - if fail to disable a channel, put a channel state back to prev. state.
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a channel fsm
 * ----------------------------------------------------------------------------------
 */      
static void ch_disable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint8                chid     = 0;
   oob_dmx_channel_t    channel  = {0};

   chid = *((uint8*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_chn_is_valid_event(chid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "ch_disable_eaf: chid(%d), invalid state change.\n" NOR,
                 chid );
      return;
   }

   trace_new(OOB_TL4, WAR "ch_disable_eaf: chid(%d), event(%s).\n" NOR, chid, event->name); 

   if( oob_fsm_chn_get(chid,&channel) )
   {
      g_ret = oob_ftables.channel_control( g_oobfe_handle, channel.cnxt_chid, OOB_CMD_DISABLE );      
      if( g_ret == CNXT_DAVIC_OOBFE_OK )
      {
         trace_new(OOB_TL3, WAR "ch_disable_eaf: chid(%d), cnxt_oob_channel_control is success.\n" NOR,
                   chid );
      }
      else
      {
         trace_new(OOB_ERR, ERR "ch_disable_eaf: chid(%d), cnxt_oob_channel_control is fail. g_ret(0x%x).\n" NOR, 
                   chid, g_ret );

         oob_fsm_chn_get_back(chid);
         trace_new(OOB_ERR, ERR "ch_disable_eaf: chid(%d), put back and cur state(%s).\n" NOR, 
                   chid, oob_fsm_chn_get_current_state_name(chid) );
         return;
      }
   }
} // ch_disable_eaf


/* =================================================================================
 * OOB_DMX_FILTER
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: fi_close_eaf 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    filter close eaf
 *   
 ** SYNTAX
 *	  void 
 *     fi_close_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    This eaf close a filter of oob_dmx and initialize a filter data
 *    only when state comes from other states except init state(close) state.
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a filter fsm
 * ----------------------------------------------------------------------------------
 */      
static void fi_close_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint32               fid = 0;
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_filter_t     filter   = {0};
   oob_dmx_instance_t   dmx      = {0};

#ifdef OOB_DMX_DEBUG
   char buf_alloc[MAX_TRACEMSG_CHARS]={0};
   char buf_enable[MAX_TRACEMSG_CHARS]={0};
#endif

   fid = *((uint32*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_fil_is_valid_event(fid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "fi_close_eaf: fid(%d), invalid state change.\n" NOR,
                 fid );
      return;
   }

   trace_new(OOB_TL3, WAR "fi_close_eaf: fid(%d), event(%s).\n" NOR, fid, event->name); 

   // does this state not come from init state?
   if( oob_fsm_fil_get_previous_state(fid) != ST_FI_CLOSE)
   {
      if(oob_fsm_fil_get(fid, &filter) 
         && oob_fsm_chn_get(filter.chid, &channel)
         && oob_fsm_dmx_get(&dmx) )
      {
         // free filter in a channel instance
         channel.allocated_filters &= ~(1<<fid);
         channel.enabled_filters &= ~(1<<fid);

         dmx.avail_filters++;

         oob_fsm_chn_set(filter.chid, &channel );
         oob_fsm_dmx_set(&dmx);

#ifdef OOB_DMX_DEBUG
         bsprintf(buf_alloc, channel.allocated_filters  );
         bsprintf(buf_enable, channel.enabled_filters );

         trace_new(OOB_TL3, WAR 
                      "fi_close_eaf:\n" NOR
                      "------------------------------\n"
                      "fid                       : %d.\n"
                      "chid                      : %d.\n"
                      "channel.allocated_filters : %s.\n"
                      "channel.enabled_filters   : %s.\n"
                      "dmx.avail_filters         : %d.\n", 
                      fid, filter.chid, 
                      buf_alloc, buf_enable,
                      dmx.avail_filters);
#endif
                               
      }
   }

   oob_fsm_initialize_filter(fid);
} // fi_close_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: fi_open_eaf 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    filter open eaf
 *   
 ** SYNTAX
 *	  void 
 *     fi_open_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    This eaf opens a filter of oob_dmx 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a filter fsm
 * ----------------------------------------------------------------------------------
 */      
static void fi_open_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint32               fid = 0;
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_filter_t     filter   = {0};
   oob_dmx_instance_t   dmx      = {0};

#ifdef OOB_DMX_DEBUG
   char buf_alloc[MAX_TRACEMSG_CHARS]={0};
   char buf_enable[MAX_TRACEMSG_CHARS]={0};
#endif

   fid = *((uint32*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_fil_is_valid_event(fid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "fi_open_eaf: fid(%d), invalid state change.\n" NOR, fid );
      return;
   }

   trace_new(OOB_TL3, WAR "fi_open_eaf: fid(%d), event(%s).\n" NOR, fid, event->name ); 

   if(oob_fsm_fil_get(fid, &filter) 
      && oob_fsm_chn_get(filter.chid, &channel)
      && oob_fsm_dmx_get(&dmx) )
   {

      // allocate a filter in a channel instance
      channel.allocated_filters |= (1<<fid);

      dmx.avail_filters--;

      oob_fsm_chn_set(filter.chid, &channel );
      oob_fsm_dmx_set(&dmx);

#ifdef OOB_DMX_DEBUG
      bsprintf(buf_alloc, channel.allocated_filters  );
      bsprintf(buf_enable, channel.enabled_filters );

      trace_new(OOB_TL3, WAR 
                "\nfi_open_eaf:\n" NOR
                "------------------------------\n"
                "fid                       : %ld.\n"
                "chid                      : %ld.\n"
                "channel.allocated_filters : %s.\n"
                "channel.enabled_filters   : %s.\n"
                "dmx.avail_filters         : %d.\n", 
                fid, filter.chid, 
                buf_alloc, buf_enable,
                dmx.avail_filters);
#endif

   }
} // fi_open_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: fi_enable_eaf 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    filter enable eaf
 *   
 ** SYNTAX
 *	  void 
 *     fi_enable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    This eaf enables a filter of oob_dmx 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a filter fsm
 * ----------------------------------------------------------------------------------
 */      
static void fi_enable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint32               fid      = 0;
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_filter_t     filter   = {0};

#ifdef OOB_DMX_DEBUG
   char buf_alloc[MAX_TRACEMSG_CHARS]={0};
   char buf_enable[MAX_TRACEMSG_CHARS]={0};
#endif

   fid = *((uint32*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_fil_is_valid_event(fid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "fi_enable_eaf: fid(%d), invalid state change.\n" NOR,
                 fid );
      return;
   }

   trace_new(OOB_TL3, WAR "fi_enable_eaf: fid(%d), event(%s).\n" NOR, fid, event->name); 

   if( oob_fsm_fil_get(fid, &filter))
   {
      if( oob_fsm_chn_get(filter.chid, &channel))
      {
         channel.enabled_filters |= (1<<fid);

         oob_fsm_chn_set(filter.chid, &channel);

#ifdef OOB_DMX_DEBUG
         bsprintf(buf_alloc, channel.allocated_filters  );
         bsprintf(buf_enable, channel.enabled_filters );

         trace_new(OOB_TL3, WAR 
                   "\nfi_enable_eaf:\n" NOR
                   "------------------------------\n"
                   "fid                       : %ld.\n"
                   "chid                      : %ld.\n"
                   "channel.allocated_filters : %s.\n"
                   "channel.enabled_filters   : %s.\n",
                   fid, filter.chid, 
                   buf_alloc, buf_enable);
#endif

      }
   }
} // ch_enable_eaf


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: fi_disable_eaf 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    filter disable eaf
 *   
 ** SYNTAX
 *	  void 
 *     fi_disable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
 * 
 ** PROTOTYPE IN
 *    fsm.h
 *                                                                    
 ** PARAMETERS
 *  @ {fsm} is a pointer to given fsm object.
 *  @ {event} is a pointer to given event object.
 * 	 
 ** DESCRIPTION 
 *    This eaf disables a filter of oob_dmx 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *    the definitions of a filter fsm
 * ----------------------------------------------------------------------------------
 */      
static void fi_disable_eaf( fsm_instance_t* fsm, fsm_event_t* event)
{
   uint32               fid      = 0;
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_filter_t     filter   = {0};

#ifdef OOB_DMX_DEBUG
   char buf_alloc[MAX_TRACEMSG_CHARS]={0};
   char buf_enable[MAX_TRACEMSG_CHARS]={0};
#endif

   fid = *((uint32*)event->data);

   // is valid event in this state ?
   if( !oob_fsm_fil_is_valid_event(fid, event->hdl) )
   {
      trace_new( OOB_ERR, ERR "fi_disable_eaf: fid(%d), invalid state change.\n" NOR,
                 fid );
      return;
   }

   trace_new(OOB_TL3, WAR "fi_disable_eaf: fid(%d), event(%s).\n" NOR, 
             fid, event->name ); 

   if( oob_fsm_fil_get(fid, &filter))
   {
      if( oob_fsm_chn_get(filter.chid, &channel))
      {
         channel.enabled_filters &= ~(1<<fid);

         oob_fsm_chn_set(filter.chid, &channel);

#ifdef OOB_DMX_DEBUG
         bsprintf(buf_alloc, channel.allocated_filters  );
         bsprintf(buf_enable, channel.enabled_filters );

         trace_new(OOB_TL3, WAR 
                   "fi_disable_eaf:\n" NOR
                   "------------------------------\n"
                   "fid                       : %d.\n"
                   "chid                      : %d.\n"
                   "channel.allocated_filters : %s.\n"
                   "channel.enabled_filters   : %s.\n",
                   fid, filter.chid, 
                   buf_alloc, buf_enable);
#endif

      }
   }
} // ch_disable_eaf


/* =================================================================================
 * C A L L B A C K S
 * =================================================================================
 */  
 
static CNXT_DAVIC_OOBFE_STATUS oob_callback(CNXT_DAVIC_OOBFE_HANDLE  handle,
                                                    void                    *pUserData,
                                                    CNXT_DAVIC_OOBFE_EVENT  event,
                                                    void                    *pData,
                                                    void                    *Tag )
{
   if(handle == NULL)
   {
      trace_new( OOB_ERR, ERR "oob_callback: handle is null (%s:%d).\n" NOR, __FILE__,__LINE__ );
   }
   
   switch(event)
   {
      case CNXT_DAVIC_OOBFE_EVENT_DATA:
         oob_data_callback((PCNXT_DAVIC_OOBFE_CALLBACKDATA)pData);
      break;
      
      case CNXT_DAVIC_OOBFE_EVENT_CONTROL:
         oob_control_callback((PCNXT_DAVIC_OOBFE_CALLBACKCONTROL)pData);
      break;
      
      case CNXT_DAVIC_OOBFE_EVENT_RESET:
         trace_new( OOB_TL2, WAR "oob_callback: event(CNXT_DAVIC_OOBFE_EVENT_RESET).\n" NOR); 
      break;
      
      case CNXT_DAVIC_OOBFE_EVENT_TERMINATED:
         trace_new( OOB_TL2, WAR "oob_callback: event(CNXT_DAVIC_OOBFE_EVENT_TERMINATED).\n" NOR);          
      break;
      
      default:
         trace_new( OOB_TL2, WAR "oob_callback: UNKNOWN EVENT.\n" NOR);          
      break;
         
   }
   
   return CNXT_DAVIC_OOBFE_OK;
}


static void oob_control_callback( PCNXT_DAVIC_OOBFE_CALLBACKCONTROL p_control )
{
   uint16   control_type   = 0;
   uint32   oob_dn_freq    = 0;
   uint8    oob_dn_acq     = 0;
   uint32   channel_id     = 0;
   uint32   info_code      = 0;
   uint32   if_signal_strength   = 0;
   uint32   rf_signal_strength   = 0;
   uint32   total_bits = 0, error_bits = 0;
   
   /* prevent a call before init
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_control_callback: oob dmx is not initialized.\n" NOR );
      return;
   }
   */

   if(control_callback_params_check(p_control) != 0)
   {
      // get control type
      control_type = *((uint16*)p_control->pControl);

      trace_new( OOB_TL2, WAR "oob_control_callback: length(%d), type(0x%x).\n" NOR, 
                 p_control->length, control_type );

      switch( control_type )
      {
      case OOB_CLIENT_CM_RESET_MSG_TYPE:
         trace_new( OOB_TL4, WAR "oob_control_callback: OOB_CLIENT_CM_RESET_MSG_TYPE.\n" NOR );

#ifdef ALIVE_MSG_DEBUG_ON
         trace_new( OOB_TL3, WAR "oob_control_callback: ** oob_fsm_dmd_post_event(EV_CM_NOT_ALIVE) **.\n" NOR );
         oob_fsm_dmd_post_event((int) OOB_CON_RESET, EV_CM_NOT_ALIVE );
#endif // ALIVE_MSG_DEBUG_ON
         break;

      case OOB_CLIENT_CM_ALIVE_MSG_TYPE:
         trace_new( OOB_TL4, WAR "oob_control_callback: OOB_CLIENT_CM_ALIVE_MSG_TYPE.\n" NOR );

#ifdef ALIVE_MSG_DEBUG_ON
         trace_new( OOB_TL3, WAR "oob_control_callback: ** oob_fsm_dmd_post_event(EV_CM_ALIVE) **.\n" NOR );
         oob_fsm_dmd_post_event((int) OOB_CON_DISCONNECTED, EV_CM_ALIVE );
#endif // ALIVE_MSG_DEBUG_ON

         break;

      case OOB_CLIENT_CM_ACQUISITION_STATUS_MSG_TYPE:
         trace_new( OOB_TL3, WAR "oob_control_callback: OOB_CLIENT_CM_ACQUISITION_STATUS_MSG_TYPE.\n" NOR );

         oob_dn_freq = *((uint32*) (p_control->pControl+4));
         oob_dn_acq = *((uint8*) p_control->pControl+8);
         trace_new( OOB_TL2, WAR "oob_control_callback: dn_freq(%ld), dn_acq(%d).\n" NOR,
                    oob_dn_freq, oob_dn_acq );

         switch(oob_dn_acq)
         {
         case OOB_CLIENT_CM_ACQ_STATUS_IDLE:
            trace_new( OOB_TL4, WAR "oob_control_callback: OOB_CLIENT_CM_ACQ_STATUS_IDLE.\n" NOR );

            trace_new( OOB_TL3, WAR "oob_control_callback: ** oob_fsm_dmd_post_event(EV_CH_UNLOCK) **.\n" NOR );
            oob_fsm_dmd_post_event((int) OOB_CON_DISCONNECTED, EV_CH_UNLOCK );
            break;

         case OOB_CLIENT_CM_ACQ_STATUS_IN_PROGRESS:
            trace_new( OOB_TL4, WAR "oob_control_callback: OOB_CLIENT_CM_ACQ_STATUS_IN_PROGRESS.\n" NOR );

            trace_new( OOB_TL3, WAR "oob_control_callback: ** oob_fsm_dmd_post_event(EV_CH_UNLOCK) **.\n" NOR );
            oob_fsm_dmd_post_event((int) OOB_CON_IN_PROGRESS, EV_CH_UNLOCK );
            break;

         case OOB_CLIENT_CM_ACQ_STATUS_LOCK:
            trace_new( OOB_TL4, WAR "oob_control_callback: OOB_CLIENT_CM_ACQ_STATUS_LOCK.\n" NOR );
            
            trace_new( OOB_TL3, WAR "oob_control_callback: ** oob_fsm_dmd_post_event(EV_CH_LOCK) **.\n" NOR );
            oob_fsm_dmd_post_event((int) OOB_CON_CONNECTED, EV_CH_LOCK );
            break;

         default:
            trace_new( OOB_TL6, WAR "oob_control_callback: UNDEFINED DN ACQ STAT.\n" NOR );
            break;
         } // switch end

         break;

      case OOB_CLIENT_CHANNEL_CLOSED_MSG_TYPE:
         trace_new( OOB_TL4, TRACE_FG_LIGHT_CYAN "oob_control_callback: OOB_CLIENT_CHANNEL_CLOSED_MSG_TYPE.\n" NOR );

         channel_id = *((uint32*) (p_control->pControl+4));

         trace_new( OOB_TL4, TRACE_FG_LIGHT_CYAN "oob_control_callback: closed chan id (0x%x).\n" NOR, channel_id );

         // post fsm msg
         // trace_new( OOB_TL6, WAR "oob_control_callback: enable: ** oob_fsm_chn_post_event(EV_CH_CLOSE) **.\n" NOR );
         // oob_fsm_chn_post_event( EV_CH_CLOSE, (void*)&channel_id );
         break;
         
      case OOB_CLIENT_INFO_RSP_MSG_TYPE:
         info_code = *((uint32*) (p_control->pControl+4));         
         trace_new( OOB_TL3, WAR "oob_control_callback: OOB_CLIENT_INFO_RSP_MSG_TYPE.\n" NOR );
         trace_new( OOB_TL3, WAR "oob_control_callback: info code(%d).\n" NOR, 
            (info_code & 0x0ff));
         
         switch((info_code & 0x0ff))
         {
            case 0: 
               total_bits = *((uint32*) (p_control->pControl+8)); 
               error_bits = *((uint32*) (p_control->pControl+12));
               trace_new( OOB_ERR, WAR "\n\noob_control_callback: bit error rate.\n" NOR
                  "-----------------------------------------\n"
                  " total bits(%d), error bits(%d).\n\n"
                  , total_bits, error_bits );
               break;
               
            case 1:
               trace_new( OOB_ERR, WAR "\n\noob_control_callback: reed solomon.\n" NOR
                  "-----------------------------------------\n"
                  " status(%d).\n\n" 
                  , (info_code>>8)&0x0ff);                              
               break;
               
            case 2:
               if_signal_strength = *((uint32*) (p_control->pControl+8));
               rf_signal_strength = *((uint32*) (p_control->pControl+12));
               trace_new( OOB_ERR, WAR "\n\noob_control_callback: signal strength.\n" NOR
                  "-----------------------------------------\n"
                  " if signal strength. (0x%08lX). rf signal_strength(0x%08lX).\n\n"
                  , if_signal_strength, rf_signal_strength );
               break;
               
            default:
               trace_new( OOB_ERR, ERR "oob_control_callback: UNDEFINED INFO CODE.(%d)\n" NOR,
                  (info_code & 0x0ff) );
               break;                  
         }
         
         break;
         
      default:
         trace_new( OOB_ERR, ERR "oob_control_callback: UNDEFINED MSG_TYPE.\n" NOR );
         break;
      } // switch end
   } // if end

   // free netbuf
   netMblkClChainFree((M_BLK_ID)(p_control->mBlkPtr)) ;   

} // cnxt_oob_control_callback


#if (DATA_CALLBACK_DEBUG_ON==0)

static void oob_data_callback( PCNXT_DAVIC_OOBFE_CALLBACKDATA p_data )
{
   uint32   chid = 0, ip_len = 0;
   uint32*  p_ip_header   = (uint32*) NULL;
   uint8    tid = 0, snum = 0, lsnum = 0;

   if(data_callback_params_check(p_data) != 0)
   {
      // is known chid and enabled ?
      if( find_chid_from_cnxt_chid( &chid, p_data->chid ) 
          && (oob_fsm_chn_get_current_state(chid) == ST_CH_ENABLE))
      {       
         trace_now( POP "\n***\n***\n{{{ oob_data_callback. dump. chid(%ld).\n" NOR, p_data->chid );
         
         ip_len = p_data->length;
         p_ip_header = p_data->pData;

         print_ip_header(TRUE, "oob_data_callback:dump", "cnt", g_data_callback_cnt, p_ip_header);

         // first frag
         if(get_ip_fragment_offset(p_ip_header) == 0 )
         {         
            dump_data_as_byte_align(TRUE, "first frag", p_data->length-28, p_data->pData+28 );
            print_section_header(TRUE, p_data->pData+28, &tid, &snum, &lsnum);

            //trace_new(OOB_TL4, WAR "oob_data_callback: first frag: free p_data.\n");
            netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));         
         }
         else
         {
            dump_data_as_byte_align(TRUE, "not first frag", p_data->length-20, p_data->pData+20 );
            print_section_header(TRUE, p_data->pData+20, &tid, &snum, &lsnum);
            
            //trace_new(OOB_TL4, WAR "oob_data_callback: not first frag: free p_data.\n");
            netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));         
         }
         
         trace_now(POP "\n}}} dump. oob_data_callback.\n\n" NOR);            
         
      } // if end, only for valid chid
      else
      {
         trace_new( OOB_ERR, ERR "oob_data_callback: discard, invalid chid(%d).\n" NOR, 
                    p_data->chid );
         netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
      }
   } // if end, param check
} // oob_data_callback


#elif(DATA_CALLBACK_DEBUG_ON==1)

#define DO_NOT_PUMP_DATA

static void oob_data_callback( PCNXT_DAVIC_OOBFE_CALLBACKDATA p_data )
{
   uint32   chid = 0, ip_len = 0;
   uint32*  p_ip_header   = (uint32*) NULL;
   uint16   offset = 0, id = 0;
   
   if(data_callback_params_check(p_data) != 0)
   {
      // is known chid and enabled ?
      if( find_chid_from_cnxt_chid( &chid, p_data->chid ) 
          && (oob_fsm_chn_get_current_state(chid) == ST_CH_ENABLE))
      {       
         //trace_now( POP "\n***\n***\n{{{ start of oob_data_callback. chid(%ld).\n" NOR, p_data->chid );
         
         ip_len = p_data->length;
         p_ip_header = (uint32*)p_data->pData;

         print_ip_header(TRUE, "oob_data_callback_ip", "callback cnt", g_data_callback_cnt, p_ip_header);
         g_data_callback_cnt++;
         
         id = get_ip_id(p_ip_header);
         
         switch(get_ip_fragment_type(p_ip_header))
         {
            case OOB_DMX_IP_DONT_FRAG:
               
               #ifdef DATA_FLOW_DEBUG_ON
               dump_data_as_byte_align(TRUE, "no frag section", p_data->length-28, p_data->pData+28 );
               #endif

               #ifdef DO_NOT_PUMP_DATA
               trace_now( WAR "\noob_data_callback: no frag: free p_data. ip_id(0x%X)\n", id );
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               #else
               trace_now( WAR "\noob_data_callback: no frag: add match. ip_id(0x%X).\n", id );               
               add_off_match_job(p_data->chid
                  , (uint32)(p_data->length-OOB_DMX_IP_UDP_OFFSET)
                  , (uint32*)(p_data->pData+OOB_DMX_IP_UDP_OFFSET)
                  , p_data->mBlkPtr, id );               
               #endif
               
               break;

            case OOB_DMX_IP_MORE_FRAG:

               offset = get_ip_fragment_offset(p_ip_header);
               
               // is it first fragment?
               if(!offset)
               {
                  // free the previous fragment
                  netMblkClChainFree(g_ptr_first_mblk);               
                  g_fragment_cnt = 0;
                  g_total_length = 0;  
                  g_ip_id = 0;
                  
                  // get cluster
                  oob_npool_get(oob_dmx_section_pool, (uint8**)&g_ptr_first_mblk, OOB_DMX_SIZE_OF_CLUSTER );
                  if(!g_ptr_first_mblk)
                  {
                     trace_new( OOB_ERR, ERR "oob_data_callback: more frag: error in oob_npool_get. free p_data.\n" NOR );
                     netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
                     break;
                  }
                  
                  trace_new(OOB_ERR, POP "oob_data_callback: more frag: first frag. ip_id(0x%X).\n" NOR, id );
                  g_ip_id = id;
               }

               if(!g_ptr_first_mblk)
               {
                  trace_new(OOB_ERR, ERR "oob_data_callback: more frag: g_ptr_first_mblk(0x%p) is null. free p_data.\n" NOR
                     , g_ptr_first_mblk);
                  netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
                  break;
               }       
               
               if(g_ip_id != id)
               {
                  trace_new(OOB_ERR, POP "oob_data_callback: more frag: g_ip_id(0x%X) mismatch id(0x%X). free p_data.\n" NOR
                     , g_ip_id, id);
                  netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
                  break;
               }       

               memcpy(((char*)(g_ptr_first_mblk->mBlkHdr.mData))+(offset*8) 
                  ,((M_BLK_ID)(p_data->mBlkPtr))->mBlkHdr.mData+OOB_DMX_IP_OFFSET
                  ,(p_data->length)-OOB_DMX_IP_OFFSET);

               g_fragment_cnt++;
               g_total_length += (p_data->length)-OOB_DMX_IP_OFFSET;
               
               #ifdef DATA_FLOW_DEBUG_ON
               if(!offset)
                  dump_data_as_byte_align(TRUE, "first frag section", p_data->length-28, p_data->pData+28 );
               else
                  dump_data_as_byte_align(TRUE, "more frag section", p_data->length-20, p_data->pData+20 );
               #endif
               
               trace_now( WAR "oob_data_callback: more frag: g_fragment_cnt(%d). g_total_length(%ld). free p_data. ip(0x%X).\n" NOR
                  ,g_fragment_cnt, g_total_length, id );
               
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               break;
                  
            case OOB_DMX_IP_LAST_FRAG:
               offset = get_ip_fragment_offset(p_ip_header);

               if(!g_ptr_first_mblk)
               {
                  trace_new(OOB_ERR, ERR "oob_data_callback: last frag: g_ptr_first_mblk(0x%p) is null. free p_data.\n" NOR
                     , g_ptr_first_mblk);            
                  netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
                  break;
               }       
               
               if(g_ip_id != id)
               {
                  trace_new(OOB_ERR, POP "oob_data_callback: last frag: g_ip_id(0x%X) mismatch id(0x%X). free p_data.\n" NOR
                     , g_ip_id, id);
                  netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
                  break;
               }       

               memcpy(((char*)(g_ptr_first_mblk->mBlkHdr.mData))+(offset*8) 
                  ,((M_BLK_ID)(p_data->mBlkPtr))->mBlkHdr.mData+OOB_DMX_IP_OFFSET
                  ,(p_data->length)-OOB_DMX_IP_OFFSET);
               
               g_fragment_cnt++;
               g_total_length += (p_data->length)-OOB_DMX_IP_OFFSET;

               #ifdef DATA_FLOW_DEBUG_ON
               dump_data_as_byte_align(TRUE, "last frag section", p_data->length-20, p_data->pData+20 );
               #endif
               
               trace_now( POP "\noob_data_callback: last frag: g_fragment_cnt(%d). g_total_length(%ld). free p_data. id(0x%X)\n" NOR
                  ,g_fragment_cnt, g_total_length, id );               
               
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               
               ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData  += OOB_DMX_UDP_OFFSET;
               ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen   = g_total_length-OOB_DMX_UDP_OFFSET;
               ((M_BLK_ID)g_ptr_first_mblk)->mBlkPktHdr.len  = g_total_length-OOB_DMX_UDP_OFFSET;
               ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mFlags  |= M_PKTHDR;

               #ifdef DATA_FLOW_DEBUG_ON
               dump_data_as_byte_align(TRUE, "assembled frag section", ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen, ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData );                  
               #endif

               #ifdef DO_NOT_PUMP_DATA
               netMblkClChainFree((M_BLK_ID)g_ptr_first_mblk);
               #else
               if(!is_section_length_matched( ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen, ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData))
               {
                  trace_new( OOB_ERR, WAR "oob_data_callback: sec length(%ld) mismatch error. g_fragment_cnt(%d). free data\n" NOR
                             , ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen , g_fragment_cnt );
                  netMblkClChainFree((M_BLK_ID)g_ptr_first_mblk);
               }
               else
               {
                  add_off_match_job(p_data->chid
                     , (uint32)(((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen)
                     , (uint32*)(((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData)
                     , (uint8*)g_ptr_first_mblk, id );
               }               
               #endif
               
               g_fragment_cnt = 0;
               g_total_length = 0;  
               g_ip_id = 0;

               break;
               
            case OOB_DMX_IP_UNKNOWN_FRAG:
               trace_new(OOB_ERR, ERR "oob_data_callback: OOB_DMX_IP_UNKNOWN_FRAG.\n" NOR );               
               break;
         }       
         
         //trace_now(POP "\n}}} end of oob_data_callback.\n\n" NOR);            
         
      } // if end, only for valid chid
      else
      {
         trace_new( OOB_ERR, ERR "oob_data_callback: discard, invalid chid(%d).\n" NOR, 
                    p_data->chid );
         netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
      }
   } // if end, param check
} // oob_data_callback

#else

#define SURPRESS_DEBUG_MSG

static void oob_data_callback( PCNXT_DAVIC_OOBFE_CALLBACKDATA p_data )
{
   uint32   chid = 0;
   uint16   id = 0, flag = 0, offset = 0;
   
   if(data_callback_params_check(p_data) != 0)
   {
      // is known chid and enabled ?
      if( find_chid_from_cnxt_chid( &chid, p_data->chid ) 
          && (oob_fsm_chn_get_current_state(chid) == ST_CH_ENABLE))
      {              
         switch(get_ip_fragment_type((uint32*)p_data->pData, &id, &flag, &offset))
         {
         case OOB_DMX_IP_DONT_FRAG:
            
            #ifdef DATA_FLOW_DEBUG_ON
            dump_data_as_byte_align( TRUE, "no frag sec"
               , p_data->length-OOB_DMX_IP_UDP_OFFSET
               , p_data->pData+OOB_DMX_IP_UDP_OFFSET );
            #endif
            
            add_off_match_job(p_data->chid
               , (uint32)(p_data->length-OOB_DMX_IP_UDP_OFFSET)
               , (uint32*)(p_data->pData+OOB_DMX_IP_UDP_OFFSET)
               , p_data->mBlkPtr, id);
            
            break;

         case OOB_DMX_IP_MORE_FRAG:
            
            // is it first fragment?
            if(!offset)
            {
               // free the previous fragment
               netMblkClChainFree(g_ptr_first_mblk);               
               g_fragment_cnt = 0;
               g_total_length = 0;  
               g_ip_id = 0;
               
               // get cluster
               oob_npool_get(oob_dmx_section_pool, (uint8**)&g_ptr_first_mblk, OOB_DMX_SIZE_OF_CLUSTER );
               if(!g_ptr_first_mblk)
               {
                  trace_new( OOB_ERR, ERR "oob_data_callback_r: first frag: error in oob_npool_get. free p_data.\n" NOR );
                  netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
                  break;
               }
               
               g_ip_id = id;
            }
            
            if(g_ip_id != id)
            {
               #ifndef SURPRESS_DEBUG_MSG
               trace_new(OOB_ERR, WAR "oob_data_callback_r: more frag: g_ip_id(0x%X) mismatch id(0x%X). free p_data.\n" NOR
                  , g_ip_id, id);
               #endif
               
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               break;
            }       

            if(!g_ptr_first_mblk)
            {
               trace_new(OOB_ERR, ERR "oob_data_callback_r: more frag: g_ptr_first_mblk(%p) is null. free p_data.\n" NOR
                  , g_ptr_first_mblk);
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               break;
            }        

            memcpy(((char*)(g_ptr_first_mblk->mBlkHdr.mData))+(offset*8) 
               ,((M_BLK_ID)(p_data->mBlkPtr))->mBlkHdr.mData+OOB_DMX_IP_OFFSET
               ,(p_data->length)-OOB_DMX_IP_OFFSET);

            g_fragment_cnt++;
            g_total_length += (p_data->length)-OOB_DMX_IP_OFFSET;

            netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
            break;
                  
         case OOB_DMX_IP_LAST_FRAG:

            if(g_ip_id != id)
            {
               #ifndef SURPRESS_DEBUG_MSG
               trace_new(OOB_ERR, WAR "oob_data_callback_r: last frag: g_ip_id(0x%X) mismatch id(0x%X). free p_data.\n" NOR
                  , g_ip_id, id);
               #endif
               
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               break;
            }       
           
            if(!g_ptr_first_mblk)
            {
               trace_new(OOB_ERR, ERR "oob_data_callback_r: last frag: g_ptr_first_mblk(0x%p) is null. free p_data.\n" NOR
                  ,g_ptr_first_mblk);
               netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
               break;
            }     
            
            memcpy(((char*)(g_ptr_first_mblk->mBlkHdr.mData))+(offset*8) 
               ,((M_BLK_ID)(p_data->mBlkPtr))->mBlkHdr.mData+OOB_DMX_IP_OFFSET
               ,(p_data->length)-OOB_DMX_IP_OFFSET);
            
            g_fragment_cnt++;
            g_total_length += (p_data->length)-OOB_DMX_IP_OFFSET;
            
            #ifdef DATA_FLOW_DEBUG_ON               
            dump_data_as_byte_align(TRUE, "last frag section", p_data->length-20, p_data->pData+20 );
            #endif
            
            netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
            
            ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData  += OOB_DMX_UDP_OFFSET;
            ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen   = g_total_length-OOB_DMX_UDP_OFFSET;
            ((M_BLK_ID)g_ptr_first_mblk)->mBlkPktHdr.len  = g_total_length-OOB_DMX_UDP_OFFSET;
            ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mFlags  |= M_PKTHDR;

            #ifdef DATA_FLOW_DEBUG_ON               
            dump_data_as_byte_align(TRUE, "assembled frag section", ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen, ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData );                                 
            #endif               
            
            if(!is_section_length_matched( ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen, ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData))
            {
               #ifndef SURPRESS_DEBUG_MSG
               trace_new( OOB_ERR, WAR "oob_data_callback_r: sec length(%ld) mismatch error. g_fragment_cnt(%d). free data\n" NOR
                          , ((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen , g_fragment_cnt );
               #endif
               
               netMblkClChainFree((M_BLK_ID)g_ptr_first_mblk);
            }
            else
            {
               add_off_match_job(p_data->chid
                  , (uint32)(((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mLen)
                  , (uint32*)(((M_BLK_ID)g_ptr_first_mblk)->mBlkHdr.mData)
                  , (uint8*)g_ptr_first_mblk, id );
            }               
            
            g_fragment_cnt = 0;
            g_total_length = 0;               
            g_ip_id = 0;

            break;
               
         case OOB_DMX_IP_UNKNOWN_FRAG:
            trace_new(OOB_ERR, ERR "oob_data_callback: OOB_DMX_IP_UNKNOWN_FRAG.\n" NOR );               
            break;
         }       
        
      } // if end, only for valid chid
      else
      {
         trace_new( OOB_ERR, ERR "oob_data_callback: discard, invalid chid(%d).\n" NOR, 
                    p_data->chid );
         netMblkClChainFree((M_BLK_ID)(p_data->mBlkPtr));
      }
   } // if end, param check
} // oob_data_callback

#endif // DATA_CALLBACK_DEBUG_ON



/* =================================================================================
 * I N T E R N A L - F U N C T I O N S
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: control_callback_params_check 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Check a sanity of PCALLBACKCONTROL argument
 *   
 ** SYNTAX
 *	  int control_callback_params_check(PCALLBACKCONTROL p_control_info)
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {p_control_info} is a data through cnxt oob driver
 * 	 
 ** DESCRIPTION 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 * ----------------------------------------------------------------------------------
 */      
static int control_callback_params_check(PCNXT_DAVIC_OOBFE_CALLBACKCONTROL p_control_info)
{
   int retval = 1;

   // check parameters
   if(p_control_info == NULL)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   if(p_control_info->pControl == NULL)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   if(p_control_info->length == 0)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   if(p_control_info->mBlkPtr == NULL)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   if( ( (u_int8 *)((M_BLK_ID)p_control_info->mBlkPtr)->mBlkHdr.mData) != p_control_info->pControl)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   if(((M_BLK_ID)p_control_info->mBlkPtr)->mBlkHdr.mLen != p_control_info->length)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   if(((M_BLK_ID)p_control_info->mBlkPtr)->mBlkPktHdr.len != p_control_info->length)
   {
      trace_new( OOB_ERR, ERR "control_callback_params_check: error in file(%s),line(%d).\n" NOR, 
                 __FILE__, __LINE__ );
      retval = 0;
   }
   
   return retval;
} // control_callback_params_check


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: data_callback_params_check 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Check a sanity of PCALLBACKDATA argument
 *   
 ** SYNTAX
 *	  int data_callback_params_check(PCALLBACKDATA p_data_info)
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {p_data_info} is a data through cnxt oob driver
 * 	 
 ** DESCRIPTION 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 * ----------------------------------------------------------------------------------
 */      
static int data_callback_params_check(PCNXT_DAVIC_OOBFE_CALLBACKDATA p_data_info)
{
   int retval = 1;
   /* check parameters */
   if(p_data_info == NULL)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);
      retval = 0;
   }
   if(p_data_info->pData == NULL)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);
      retval = 0;
   }
   if(p_data_info->length == 0)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);
      retval = 0;
   }
   if(p_data_info->mBlkPtr == NULL)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);
      retval = 0;
   }
   if( ( (u_int8 *)((M_BLK_ID)p_data_info->mBlkPtr)->mBlkHdr.mData ) != p_data_info->pData)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);   
      retval = 0;
   }
   if(((M_BLK_ID)p_data_info->mBlkPtr)->mBlkHdr.mLen != p_data_info->length)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);   
      retval = 0;
   }
   if(((M_BLK_ID)p_data_info->mBlkPtr)->mBlkPktHdr.len != p_data_info->length)
   {
      trace_new(OOB_ERR, ERR "data_callback_params_check: error(line %d)\n" NOR, __LINE__);   
      retval = 0;
   }

   return retval;
}


uint16 map_pid_to_vci(uint16 pid)
{
   uint16 vci = 0x0;

   /* temp */
   if( pid >= 0x1dd2 && pid <= 0x1e4f)
      return 124;

   switch(pid)
   {
   /* dvs 234 base pid */
   case 0x1ffc: vci = 121; break;
   /* dvs 234 aeit/aett0-1 */
   case 0x1dd0: vci = 122; break;
   /* dvs 234 aeit/aett2-3 */
   case 0x1dd1: vci = 123; break;
   /* dvs 234 aeit/aett4-255 */
   case 0x1dd2: vci = 124; break;
   /* emm */
   case 0xb4: vci = 180; break;
   default:
      trace_new(OOB_ERR, ERR "map_pid_to_vci: UNKNOWN PID(%d).\n" NOR, pid );
      break;
   }

   trace_new(OOB_TL3, WAR "map_pid_to_vci: pid(0x%x) vci(%d).\n" NOR, 
             pid, vci );

   return vci;
}


void trace_now(char *string, ...)
{
#ifdef DEBUG
   va_list arg;
   
   /* Only do anything if we are not at interrupt time */
   not_interrupt_safe();

   va_start(arg,string);
   trace_message(TRUE, string, arg);
   va_end(arg);
#endif
   
   return;
} /* trace_now */


static bool is_oob_dmx_initialized()
{
   return g_is_oob_dmx_initialized;
} // is_oob_dmx_initialized 


static bool find_chid_from_cnxt_chid(uint32* chid, uint32 cnxt_chid)
{
   uint32            idx = 0;
   oob_dmx_channel_t channel = {0};

   while( idx < OOB_DMX_MAX_CHANNELS )
   {
      oob_fsm_chn_get(idx,&channel);

      if( channel.cnxt_chid == cnxt_chid )
      {
         *chid = channel.chid;
         return TRUE;
      }

      idx++;
   }

   trace_new( OOB_ERR, ERR "find_chid_from_cnxt_chid:  cannot find cnxt_chid(%d).\n" NOR,
              cnxt_chid );
   return FALSE;
}


static oob_dmx_ip_fragment_type_t get_ip_fragment_type(uint32* p_ip_header, uint16* ip_id, uint16* ip_flag, uint16* ip_offset)
{
   uint32   header = 0;
   uint16   id = 0, flag = 0, offset = 0;

   header   = BSWAP((u_int32) *(p_ip_header+1));

   id       = ((header >> 16) & 0xffff);
   offset   = ((header) & 0x01fff);
   flag     = ((header>>13) &0x07);

   trace_new(OOB_TL3, NOR "get_ip_fragment_type: id(0x%x), flag(%d), offset(%d).\n" NOR
      , id, flag, offset );   

   *ip_id       = id;
   *ip_offset   = offset;
   *ip_flag     = flag;

   if( flag )
   {
      trace_new(OOB_TL3, WAR "get_ip_fragment_type: return OOB_DMX_IP_MORE_FRAG.\n" NOR);
      return OOB_DMX_IP_MORE_FRAG;
   }
   else if((!flag) && (!offset))
   {
      trace_new(OOB_TL3, WAR "get_ip_fragment_type: return OOB_DMX_IP_DONT_FRAG.\n" NOR);
      return OOB_DMX_IP_DONT_FRAG;
   }
   else if((!flag) && offset)
   {
      trace_new(OOB_TL3, WAR "get_ip_fragment_type: return OOB_DMX_IP_LAST_FRAG.\n" NOR);   
      return OOB_DMX_IP_LAST_FRAG;
   }      
   else
   {
      trace_new(OOB_TL3, WAR "get_ip_fragment_type: return OOB_DMX_IP_UNKNOWN_FRAG.\n" NOR);   
      return OOB_DMX_IP_UNKNOWN_FRAG;
   }      
}


static bool is_section_length_matched(uint32 section_length, uint8* p_section )
{
   uint32   tid=0, first_word = 0, real_section_length=0;
   
   // section data in the user datagram
   first_word = *((uint32*) p_section);
   first_word = BSWAP(first_word);
   
   // extract table id and section length
   tid = ((first_word>>24)&0x0ff);
   real_section_length = ((first_word>>8)&0x0fff);

   trace_new(OOB_TL3, NOR "is_section_length_matched: length(%ld), tid(0x%lX), real sec len(%ld). first word(0x%08lX).\n" NOR
      , section_length, tid, real_section_length, first_word);

   if(section_length != (real_section_length+3))
      return FALSE;
   else
      return TRUE;
}

void reset_internal_data()
{
   uint32   idx;

   // close all channels
   for( idx=0; idx < OOB_DMX_MAX_CHANNELS; idx++)
      oob_fsm_chn_post_event( idx, EV_CH_CLOSE );

   // reset global vars
   g_ret = OOB_DMX_ERR;

   g_ip_id = g_fragment_cnt = 0;
   g_total_length = g_pump_cnt = g_data_callback_cnt = 0;

   if(!g_ptr_first_mblk)
      netMblkClChainFree(g_ptr_first_mblk);

   g_ptr_first_mblk = 0;

#ifdef ALIVE_TIMER_ON
   oob_dmx_alive_cnt = 0;
#endif // ALIVE_TIMER_ON 

#ifdef CONTROL_INFO_TEST_ON
   oob_info_test_cnt = 0;
#endif // CONTROL_INFO_TEST_ON 

   trace_new( OOB_TL4, POP "reset_internal_data: cnxt buf(%d), oob buf(%d)\n" NOR NOR
              , uiNumAvailableBuffers, oob_npool_get_num_free_bufs(oob_dmx_section_pool) );           
}


/* =================================================================================
 * T A S K - R O U T I N E S
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: add_off_pump_job 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *   
 ** SYNTAX
 * 
 ** PROTOTYPE IN
 *                                                                    
 ** PARAMETERS
 *    void
 *     
 ** DESCRIPTION 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
static void add_off_pump_job(uint32 chid, uint32 fid, uint32 length, uint32* p_data, uint8* mBlkPtr )
{
   STATUS                     ret;
   uint32                     msg[OOB_DMX_PUMP_Q_LEN_MESG/4] = {0};

   msg[0] = (uint32) chid;
   msg[1] = (uint32) fid;
   msg[2] = (uint32) length;
   msg[3] = (uint32) p_data;
   msg[4] = (uint32) mBlkPtr;

   ret = msgQSend(oob_dmx_off_pump_qid, (char*)msg, OOB_DMX_PUMP_Q_LEN_MESG, WAIT_FOREVER, MSG_PRI_NORMAL);
   // ERROR(-1)
   if(ret==ERROR)
   {
      trace_new( OOB_ERR, ERR "add_off_job: fail to send msg.\n" NOR);      
   }

} // add_off_pump_job()


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: add_off_match_job 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *   
 ** SYNTAX
 * 
 ** PROTOTYPE IN
 *                                                                    
 ** PARAMETERS
 *    void
 *     
 ** DESCRIPTION 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
static void add_off_match_job(uint32 chid, uint32 length, uint32* p_data, uint8* mBlkPtr, uint16 ip_id )
{
   STATUS                     ret;
   uint32                     msg[OOB_DMX_MATCH_Q_LEN_MESG/4] = {0};

   msg[0] = (uint32) chid;
   msg[1] = (uint32) length;
   msg[2] = (uint32) p_data;
   msg[3] = (uint32) mBlkPtr;
   msg[4] = (uint32) ip_id;

   ret = msgQSend(oob_dmx_off_match_qid, (char*)msg, OOB_DMX_MATCH_Q_LEN_MESG, WAIT_FOREVER, MSG_PRI_NORMAL);
   // ERROR(-1)
   if(ret==ERROR)
   {
      trace_new( OOB_ERR, ERR "add_off_match_job: fail to send msg.\n" NOR);      
   }       
} // add_off_match_job()


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_match_task 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    data match task main
 *   
 ** SYNTAX
 * 
 ** PROTOTYPE IN
 *                                                                    
 ** PARAMETERS
 *    void
 *     
 ** DESCRIPTION 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
static void oob_dmx_match_task(void)
{
   uint32                  match=0, mask=0, data=0;
   uint32                  fidx = 0, idx = 0;
   uint32*                 section_data   = (uint32*) NULL;
   uint32                  valid_filters  = 0x0;
   uint8                   match_result   = 0x0;

   oob_dmx_channel_t       channel  = {0};
   oob_dmx_filter_t        filter   = {0};
   uint32                  msg[OOB_DMX_MATCH_Q_LEN_MESG/4]   = {0};

   while(1)
   {
      trace_new( OOB_TL3, NOR "oob_dmx_m_task: wait...\n" NOR NOR);

      if(msgQReceive(oob_dmx_off_match_qid, (char*) msg, OOB_DMX_MATCH_Q_LEN_MESG, WAIT_FOREVER) == ERROR) 
      {
         trace_new( OOB_ERR, ERR "oob_dmx_m_task: msgQrecv error.\n" NOR );    
         continue;
      }

#ifdef ALIVE_TIMER_ON
      if(msg[0] == OOB_DMX_ALIVE_MESG)
      {
         trace_new( OOB_ERR, POP "** oob_dmx_m_task: %ld: cnxt buf(%d), oob buf(%d) **\n" NOR NOR,
                    oob_dmx_alive_cnt, uiNumAvailableBuffers, oob_npool_get_num_free_bufs(oob_dmx_section_pool) );           

         // restart timer
         tick_start(oob_dmx_alive_timer);
         continue;
      }
#endif // ALIVE_TIMER_ON

#ifdef CONTROL_INFO_TEST_ON
      if(msg[0] == OOB_INFO_TEST_MESG)
      {
         oob_dmx_info_read(0);
         oob_dmx_info_read(2);
         
         trace_new( OOB_ERR, WAR "oob_dmx_m_task: info test timer cnt(%d)..\n" NOR,
                          oob_info_test_cnt);   
         // restart timer 
         tick_start(oob_info_test_timer);
         continue;
      }
#endif // CONTROL_INFO_TEST_ON

      match_result   = 0x0;
      section_data   = (uint32*)msg[2];

#ifdef DATA_FLOW_DEBUG_ON                     
      dump_data_as_byte_align(TRUE, "oob_dmx_m_task", msg[1], (uint8*) msg[2] );
#endif

      oob_fsm_chn_get(msg[0],&channel);

      // get filters that is allocated and enabled
      valid_filters = channel.allocated_filters & channel.enabled_filters;

      // search all filters for a channel
      for( fidx = 0; fidx < OOB_DMX_MAX_FILTERS; fidx++ ) 
      {
         // is a valid filter ?
         if( valid_filters & (1<<fidx) )
         {
            oob_fsm_fil_get(fidx,&filter);

            // perform filtering
            for( idx = 0; idx < OOB_DMX_FILTER_SIZE/4; idx++ )
            {
               match = filter.match[idx];
               mask  = filter.mask[idx];

               // make sure BE
               data = (u_int32)*(section_data+idx);
               data = BSWAP(data);

               // does not matched
               if((match & mask) != (data & mask)) 
               {
                  match_result &= ~(1<<idx);
               }
               // is matched
               else
               {
                  match_result |= (1<<idx);
               }
            } // for end, filtering

            if(match_result==0x03)
            {
               // pump it
               trace_new( OOB_TL3, WAR "oob_dmx_m_task: pump: chid(%d), fid(%d). ip_id(0x%X), g_pump_cnt(%ld).\n" NOR
                          ,msg[0], fidx, (uint16)msg[4], g_pump_cnt );    
               
               g_pump_cnt++;

               add_off_pump_job(msg[0], fidx, msg[1], section_data, (uint8*)msg[3] );

               // exit a loop of searching filter
               break;
            }
        } // if end, only for a valid filter
      } // for end, search a valid filter in all filters

      if(match_result!=0x03)
      {
         // discard it
         trace_new( OOB_TL4, WAR "oob_dmx_m_task: discard: chid(%d).\n" NOR,
                    msg[0]);    

         netMblkClChainFree((M_BLK_ID)msg[3]);
      }
   } // while
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_pump_task 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    data pump task main
 *   
 ** SYNTAX
 * 
 ** PROTOTYPE IN
 *                                                                    
 ** PARAMETERS
 *    void
 *     
 ** DESCRIPTION 
 * 
 ** RETURN VALUE
 *  
 ** SEE ALSO
 *
 * ----------------------------------------------------------------------------------
 */      
static void oob_dmx_pump_task(void)
{
   uint32                  msg[OOB_DMX_PUMP_Q_LEN_MESG/4] = {0};
   int                     ret;
   oob_dmx_callback_data_t callback_data = {0}; 
   oob_dmx_channel_t       channel = {0};

   while(1)
   {
      if ((ret = msgQReceive(oob_dmx_off_pump_qid, (char*) msg, OOB_DMX_PUMP_Q_LEN_MESG, WAIT_FOREVER)) == ERROR) 
      {
         trace_new( OOB_ERR, ERR "oob_dmx_p_task: msgQrcv error.\n" NOR );    
         continue;
      }
 
      callback_data.chid      = (uint32) msg[0];
      callback_data.fid       = (uint32) msg[1];
      callback_data.length    = (uint32) msg[2];
      callback_data.pdata     = (uint8*) msg[3];
      callback_data.mBlkPtr   = (uint8*) msg[4];

#ifdef PUMP_TASK_DEBUG_ON      
      dump_data_as_byte_align(TRUE, "oob_dmx_p_task", msg[2], (uint8*) msg[3] );

      if(!is_section_length_matched( msg[2], (uint8*) msg[3] ))
         trace_new( OOB_ERR, ERR "oob_dmx_p_task: sec length(%ld) mismatch error. g_fragment_cnt(%d).\n" NOR
                    , callback_data.length, g_fragment_cnt );
#endif

      oob_fsm_chn_get(msg[0],&channel);

      if(channel.data_notify)
         channel.data_notify(&callback_data);

   } // while end
}


/*=================================================================================
 * E X T E R N A L - I N T E R F A C E S
 * =================================================================================
 */  

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_init 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Initialization of oob_dmx driver
 *   
 ** SYNTAX
 *   oob_dmx_status_t oob_dmx_init( oob_dmx_mode_t mode ) 
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {mode} is a operation mode of oob_dmx driver.
 *     
 ** DESCRIPTION 
 *    Now, it does not support mode beacuse there are different oob_dmx drivers
 *    according to POD and OOB.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *  
 ** SEE ALSO
 *    oob_dmx for POD
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_init( oob_dmx_mode_t mode )
{
   uint32   trace_level;

   // is oob_dmx already initialized?
   if( is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_init: oob dmx already initialized.\n" NOR );
      return OOB_DMX_ERR_NOT_INIT;
   }

   if(mode == OOB_DMX_MODE_DVS)
   {
      oob_ftables.init = &cnxt_davic_oobfe_init;
      oob_ftables.param_set = &cnxt_davic_oobfe_downstream_params_set;
      oob_ftables.channel_open = &cnxt_davic_oobfe_channel_open;
      oob_ftables.channel_control = &cnxt_davic_oobfe_channel_control;
      oob_ftables.channel_close = &cnxt_davic_oobfe_channel_close;
      oob_ftables.channel_all_close = &cnxt_davic_oobfe_all_channels_close;
      oob_ftables.status_get = &cnxt_davic_oobfe_channel_status_get;         
   }
   else
   {
      trace_new( OOB_ERR, ERR "oob_dmx_init: Unsupported oob dmx mode.\n" NOR );
      return OOB_DMX_ERR_BAD_PARAM;
   }

   // initialize all fsms for oob_dmx 
   oob_fsm_init(&eafs);

   // clear previous trace level setting
   trace_get_level(&trace_level);
   trace_level &= TRACE_LEVEL_NEVER;

#ifndef OOB_DMX_TRACE_ON
   trace_set_level( trace_level | TRACE_GEN | TRACE_CM_MUX | TRACE_LEVEL_6 );
   trace_get_level(&trace_level);

   trace_new( TRACE_CM_MUX|TRACE_LEVEL_ALWAYS, WAR "\n\n\a"
              "oob_dmx_init: no message.\n"
              "===================================================================\n"
              "OOB DMX FE with cnxt oobfe release\n"
              "2003.05 ktpark@humaxdigital.com\n"
              "-------------------------------------------------------------------\n"
              "trace level is (0x%X)\n"
              "-------------------------------------------------------------------\n\n"
              NOR, trace_level );

#else
   trace_set_level( trace_level | TRACE_GEN | TRACE_CM_MUX | TRACE_OOB_DMX | TRACE_OOB_CNXT | TRACE_LEVEL_4 );
   trace_get_level(&trace_level);

   trace_new( OOB_TL6, WAR "\n\n\a"
              "oob_dmx_init: with message.\n"
              "===================================================================\n"
              "OOB DMX FE with cnxt oobfe release\n"
              "2003.05 ktpark@humaxdigital.com\n"
              "-------------------------------------------------------------------\n"
              "trace level is (0x%X)\n"
              "-------------------------------------------------------------------\n\n"
              NOR, trace_level );
#endif // OOB_DMX_TRACE_ON

   return g_ret;
} // oob_dmx_init
          

/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_open_channel
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Allocate one channel.
 *   
 ** SYNTAX
 *   oob_dmx_status_t oob_dmx_open_channel( uint32* chid, uint16 pid )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is channel id which is returned and this is a managed id by oob_dmx driver
 *    not sub driver, such as OOB or POD.
 *
 *  @ {pid}  is a pid which is given by clients of oob_dmx driver.
 *     
 ** DESCRIPTION 
 *    This tries to allocate one channel in the free channels and then, if success,
 *    it post a open event to channel fsm.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx including errors of sub driver. it uses a global return
 *    value mechanism due to eafs of fsms.
 *  
 ** SEE ALSO
 *    related channel routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_open_channel( uint32* chid, uint16 pid )
{
   uint8                idx      = 0;
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_instance_t   dmx      = {0};

   trace_new( OOB_TL3, "\n***\n***\n***\n"
          "{{=============================================================\n");
   
   CS_DMX_BEGIN();

   g_ret = OOB_DMX_ERR;

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_open_channel: chid(%d), oob dmx is not initialized.\n" NOR,
                 chid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   // is there no free channel in oob_dmx?
   if(oob_fsm_dmx_get(&dmx))
   {
      if(!dmx.avail_channels)
      {
         CS_DMX_END();
         return OOB_DMX_ERR_NO_CHANNEL;
      }
   }

   // search one free channel
   for(idx=0; idx < OOB_DMX_MAX_CHANNELS; idx++)
   {
      if(oob_fsm_chn_get( idx, &channel ))
      {
         // a free channel is founded
         if(oob_fsm_chn_get_current_state(idx)==ST_CH_CLOSE)
         {
            channel.chid   = idx;
            channel.pid    = map_pid_to_vci(pid);
            *chid          = idx;
            dmx.avail_channels--;

            oob_fsm_chn_set(idx, &channel);
            oob_fsm_dmx_set(&dmx);

            trace_new( OOB_TL3, WAR "oob_dmx_open_channel: chid(%d) is allocated.\n" NOR, idx );
            trace_new( OOB_TL2, WAR "oob_dmx_open_channel: ** oob_fsm_chn_post_event(EV_CH_OPEN) **.\n" NOR );

            oob_fsm_chn_post_event(idx, EV_CH_OPEN );

            CS_DMX_END();
            return g_ret;
         }
      }
   }

   trace_new( OOB_ERR, ERR "oob_dmx_open_channel: chid(%d), no free channel" NOR, chid );

   CS_DMX_END();

   return g_ret;
} // oob_dmx_open_channel


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_set_control_callback 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Install control path to oob_dmx
 *   
 ** SYNTAX
 *   oob_dmx_status_t oob_dmx_set_control_callback( oob_dmx_connection_t notify )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {notify} is a callback pointer of client which want to install control path.
 *     
 ** DESCRIPTION 
 *    This install client's callback to oob_dmx for control path.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *  
 ** SEE ALSO
 *    related channel routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_set_control_callback( oob_dmx_connection_t notify )
{
   oob_dmx_instance_t dmx      = {0};

   CS_DMX_BEGIN();

   /* is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_set_control_callback: oob dmx not initialized.\n" NOR );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }
   */

   if( oob_fsm_dmx_get(&dmx) )
   {
      dmx.connection_notify = notify;

      oob_fsm_dmx_set(&dmx);

      trace_new( OOB_TL4, WAR "oob_dmx_set_control_callback: control callback(0x%x).\n" NOR, notify );
      CS_DMX_END();
      return OOB_DMX_OK;
   }

   CS_DMX_END();
   trace_new( OOB_ERR, ERR "oob_dmx_set_control_callback: can't set control path.\n" NOR );

   return OOB_DMX_ERR;
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_set_channel_attributes 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Install data path to oob_dmx
 *   
 ** SYNTAX
 *    oob_dmx_status_t oob_dmx_set_channel_attributes( uint32 chid, 
 *                                              oob_dmx_callback_t header_notify,
 *                                              oob_dmx_callback_t data_notify, 
 *                                              uint16 timeout, uint16 header_size )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is a channel id.
 *  @ {data_notify} is a callback pointer of client which want to install data path.
 *     
 ** DESCRIPTION 
 *    This install client's callback to oob_dmx for data path but it is channel based
 *    interface with a given chid. Now, this supports data_notify only and rests are
 *    reserved for future reference.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *  
 ** SEE ALSO
 *    related channel routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_set_channel_attributes( uint32 chid, oob_dmx_callback_t header_notify,
                                                 oob_dmx_callback_t data_notify, 
                                                 uint16 timeout, uint16 header_size )
{
   oob_dmx_channel_t channel = {0};

   CS_DMX_BEGIN();

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_set_channel_attributes: chid(%d), oob dmx is not initialized.\n" NOR,
                 chid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }
      
   if( oob_fsm_chn_get(chid,&channel))
   {
      channel.data_notify = data_notify;

      oob_fsm_chn_set(chid, &channel);

      trace_new( OOB_TL4, WAR "oob_dmx_set_channel_attributes: chid(%d), data callback(0x%x).\n" NOR,
                 chid, data_notify );
      CS_DMX_END();
      return OOB_DMX_OK;
   }

   trace_new( OOB_ERR, ERR "oob_dmx_set_channel_attributes: can't not set data path for chid(%d).\n" NOR, chid );
   CS_DMX_END();
   
   return OOB_DMX_ERR;
} // oob_dmx_set_channel_attributes


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_control_channel 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Control one channel operation
 *   
 ** SYNTAX
 *    oob_dmx_status_t oob_dmx_control_channel( uint32 chid, oob_dmx_commands_t command )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is a channel id.
 *  @ {command} is a enable/disable command to control a channel operation.
 *     
 ** DESCRIPTION 
 *    This controls a channel operation according to command and post a relavant
 *    event to channel fsm. Data pumping starts only when a channel is enabled.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *  
 ** SEE ALSO
 *    related channel routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_control_channel( uint32 chid, oob_dmx_commands_t command )
{
   oob_dmx_channel_t channel = {0};

   CS_DMX_BEGIN();

   g_ret = OOB_DMX_ERR;

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_control_channel: chid(%d), oob dmx is not initialized.\n" NOR,
                 chid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   // is it a valid chid?
   if(!oob_fsm_chn_get(chid,&channel))
   {
      CS_DMX_END();
      return OOB_DMX_ERR_BAD_CHID;
   }

   switch(command)
   {
   case OOB_CMD_ENABLE:
      trace_new( OOB_TL3, WAR "oob_dmx_control_channel: enable: chid(%d), ** oob_fsm_chn_post_event(EV_CH_ENABLE) **.\n" NOR,
                 chid );
      oob_fsm_chn_post_event( chid, EV_CH_ENABLE );
      break;

   case OOB_CMD_DISABLE:
      trace_new( OOB_TL3, WAR "oob_dmx_control_channel: disable: chid(%d), ** oob_fsm_chn_post_event(EV_CH_DISABLE) **.\n" NOR,
                 chid );
      oob_fsm_chn_post_event( chid, EV_CH_DISABLE );
      break;

   default:
      trace_new( OOB_ERR, ERR "oob_dmx_control_channel: UNSUPPORTED COMMAND.\n" NOR );
      break;
   }

   CS_DMX_END();
   
   return g_ret;
} // oob_dmx_control_channel


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_close_channel
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Deallocate one channel.
 *   
 ** SYNTAX
 *   oob_dmx_status_t oob_dmx_close_channel( uint32 chid )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is channel id.
 *     
 ** DESCRIPTION 
 *    This tries to deallocate one channel and return to pool of free channels. Then,
 *    it post a open event to channel fsm and closes all fiters which was tided this
 *    channel.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx including errors of sub driver. it uses a global return
 *    value mechanism due to eafs of fsms.
 *  
 ** SEE ALSO
 *    related channel routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_close_channel( uint32 chid )
{
   oob_dmx_channel_t    channel  = {0};

   CS_DMX_BEGIN();

   g_ret = OOB_DMX_ERR;

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_close_channel: chid(%d), oob dmx is not initialized.\n" NOR,
                 chid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   // is it valid chid?
   if(!oob_fsm_chn_get(chid,&channel))
   {
      CS_DMX_END(); 
      return OOB_DMX_ERR_BAD_CHID;
   }
      
   trace_new( OOB_TL2, WAR "oob_dmx_close_channel: chid(%d). ** oob_fsm_chn_post_event(EV_CH_CLOSE) **.\n" NOR,
              chid );
   oob_fsm_chn_post_event( chid, EV_CH_CLOSE );

   CS_DMX_END();

   trace_new( OOB_TL3, "\n"
          "}}=============================================================\n");

   return g_ret;
} // oob_dmx_close_channel 


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_close_all_channel
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Deallocate all channel.
 *   
 ** SYNTAX
 *   oob_dmx_status_t oob_dmx_close_all_channel( )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {void}
 *     
 ** DESCRIPTION 
 *    This tries to deallocate all channel and return to pool of free channels. Then,
 *    it post a open event to channel fsm and closes all fiters which was tided this
 *    channel.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx including errors of sub driver. it uses a global return
 *    value mechanism due to eafs of fsms.
 *  
 ** SEE ALSO
 *    related channel routines
 * ----------------------------------------------------------------------------------
 */      
void oob_dmx_close_all_channel()
{
   uint32   idx;

   CS_DMX_BEGIN();

   for( idx=0; idx < OOB_DMX_MAX_CHANNELS; idx++)
      oob_fsm_chn_post_event( idx, EV_CH_CLOSE );

   oob_ftables.channel_all_close(g_oobfe_handle);

   CS_DMX_END();

   return;   
} // oob_dmx_close_all_channel


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_open_filter 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Allocate one filter to a given channel
 *   
 ** SYNTAX
 *    oob_dmx_status_t oob_dmx_open_filter( uint32 chid, uint16 size, uint32* fid)
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is a channel id.
 *  @ {size} is a size of this filter. Now it has no meaning because oob_dmx only
 *    supports 8 bytes filter.
 *  @ {fid} is a filter id which is returned to after this call.
 *     
 ** DESCRIPTION 
 *    This tries to allocate one filter in the free filter and then, if success,
 *    assocate this filter to a given channel. It post a open event to filter fsm.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx including errors of sub driver. it uses a global return
 *    value mechanism due to eafs of fsms.
 *  
 ** SEE ALSO
 *    related filter routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_open_filter( uint32 chid, uint16 size, uint32* fid)
{
   uint8                idx      = 0;
   oob_dmx_filter_t     filter   = {0};
   oob_dmx_channel_t    channel  = {0};
   oob_dmx_instance_t   dmx      = {0};

   CS_DMX_BEGIN();

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_open_filter: chid(%d), oob dmx is not initialized.\n" NOR,
                 chid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   // is there no free filter in oob_dmx?
   if(oob_fsm_dmx_get(&dmx))
   {
      if(!dmx.avail_filters)
      {
         CS_DMX_END();
         return OOB_DMX_ERR_NO_FILTER;
      }
   }

   // search free channel
   for(idx=0; idx < OOB_DMX_MAX_FILTERS; idx++)
   {
      if(oob_fsm_fil_get( idx, &filter )
         && oob_fsm_chn_get(chid, &channel) )
      {
         // a free channel is founded
         if(oob_fsm_fil_get_current_state(idx)==ST_FI_CLOSE)
         {
            filter.chid                   = chid;
            filter.fid                    = idx;
            filter.filter_size            = size;
            *fid                          = idx;

            oob_fsm_fil_set(idx,&filter);

            trace_new( OOB_TL3, WAR "oob_dmx_open_filter: fid(%d), chid(%d) is allocated.\n" NOR, 
                          idx, channel.chid );

            trace_new( OOB_TL2, WAR "oob_dmx_open_filter: ** oob_fsm_fil_post_event(EV_FI_OPEN) **.\n" NOR );
            oob_fsm_fil_post_event( idx, EV_FI_OPEN );
            CS_DMX_END();
            return OOB_DMX_OK;
         }
      }
   }

   trace_new( OOB_ERR, ERR "oob_dmx_open_filter: chid(%d), no free filter" NOR, chid);

   CS_DMX_END();
   
   return OOB_DMX_ERR_NO_FILTER;
} // oob_dmx_open_filter


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_set_filter 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Install a match and mask pattern to a filter
 *   
 ** SYNTAX
 *    oob_dmx_status_t 
 *     oob_dmx_set_filter( uint32 chid, uint32 fid, uint8* match, uint8* mask )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is a channel id.
 *  @ {fid} is a filter id. 
 *  @ {match} is a pointer to match pattern array.
 *  @ {mask} is a pointer to mask pattern array.
 *     
 ** DESCRIPTION 
 *    This install match and mask pattern to a given filter. Now only supports 8
 *    byters long.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *  
 ** SEE ALSO
 *    related filter routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_set_filter( uint32 chid, uint32 fid, uint8* match, uint8* mask )
{
   uint8                idx      = 0;
   oob_dmx_filter_t     filter   = {0};
   oob_dmx_channel_t    channel  = {0};

   CS_DMX_BEGIN();

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_set_filter: fid(%d), oob dmx is not initialized.\n" NOR,
                 fid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   if( oob_fsm_fil_get( fid, &filter )
       && oob_fsm_chn_get( chid, &channel))
   {
      // install filter maks/match as BE
      for(idx=0; idx < filter.filter_size/4; idx++)
      {
         filter.mask[idx]  = *((uint32*)mask)++;
         filter.mask[idx]  = BSWAP(filter.mask[idx]);
         filter.match[idx] = *((uint32*)match)++;
         filter.match[idx] = BSWAP(filter.match[idx]);
      }

      // clear unused mask/match
      for(;idx < OOB_DMX_FILTER_SIZE/4; idx++)
      {
         filter.mask[idx]  = (uint32) 0;
         filter.match[idx] = (uint32) 0;
      }

      trace_new( OOB_TL3, WAR "oob_dmx_set_filter: fid(%d), mask : %08X-%08X.\n" NOR,
                 fid, filter.mask[0], filter.mask[1] );

      trace_new( OOB_TL3, WAR "oob_dmx_set_filter: fid(%d), match: %08X-%08X.\n" NOR,
                 fid, filter.match[0], filter.match[1] );

      oob_fsm_fil_set(fid, &filter);

      CS_DMX_END();
      return OOB_DMX_OK;
   }

   CS_DMX_END();
   trace_new( OOB_ERR, ERR "oob_dmx_set_filter: can't install match/mask for fid(%d).\n" NOR, fid );
   
   return OOB_DMX_ERR;
} // oob_dmx_set_filter


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_control_filter 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Control one filter operation
 *   
 ** SYNTAX
 *    oob_dmx_status_t 
 *     oob_dmx_control_filter( uint32 chid, uint32 fid, oob_dmx_commands_t command )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is a channel id.
 *  @ {fid} is a filter id.
 *  @ {command} is a enable/disable command to control a filter operation.
 *     
 ** DESCRIPTION 
 *    This controls a filter operation according to command and post a relavant
 *    event to filter fsm. Data pumping starts only when a filter is enabled.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *  
 ** SEE ALSO
 *    related filter routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_control_filter( uint32 chid, uint32 fid, oob_dmx_commands_t command )
{
   oob_dmx_filter_t     filter   = {0};
   oob_dmx_channel_t    channel  = {0};

   CS_DMX_BEGIN();

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_control_filter: fid(%d), oob dmx is not initialized.\n" NOR,
                 fid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   if(!oob_fsm_chn_get(chid,&channel))
   {
      CS_DMX_END(); return OOB_DMX_ERR_BAD_CHID;
   }
      

   if(!oob_fsm_fil_get(fid,&filter))
   {
      CS_DMX_END(); return OOB_DMX_ERR_BAD_FID;
   }
      
   switch(command)
   {
   case OOB_CMD_ENABLE:
      trace_new( OOB_TL3, WAR "oob_dmx_control_filter: enable: fid(%d), ** oob_fsm_fil_post_event(EV_FI_ENABLE) **.\n" NOR,
                 fid );
      oob_fsm_fil_post_event( fid, EV_FI_ENABLE );
      break;

   case OOB_CMD_DISABLE:
      trace_new( OOB_TL3, WAR "oob_dmx_control_filter: disable: fid(%d), ** oob_fsm_fil_post_event(EV_FI_DISABLE) **.\n" NOR,
                 fid );
      oob_fsm_fil_post_event( fid, EV_FI_DISABLE );
      break;

   default:
      trace_new( OOB_ERR, WAR "oob_dmx_control_filter: UNSUPPORTED COMMAND.\n" NOR );
      break;
   }

   CS_DMX_END();
   
   return OOB_DMX_OK;
} // oob_dmx_control_filter


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_close_filter
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Deallocate one filter.
 *   
 ** SYNTAX
 *    oob_dmx_status_t oob_dmx_close_filter( uint32 chid, uint32 fid)
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {chid} is channel id.
 *  @ {fid} is filter id. 
 *     
 ** DESCRIPTION 
 *    This tries to deallocate one filter and return to pool of free filters. Then,
 *    it post a open event to filter fsm.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx including errors of sub driver. it uses a global return
 *    value mechanism due to eafs of fsms.
 *  
 ** SEE ALSO
 *    related filter routines
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_close_filter( uint32 chid, uint32 fid )
{
   oob_dmx_filter_t     filter   = {0};
   oob_dmx_channel_t    channel  = {0};

   CS_DMX_BEGIN();

   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_close_filter: fid(%d), oob dmx is not initialized.\n" NOR,
                 fid );
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }

   // is it valid chid?
   if(!oob_fsm_chn_get(chid,&channel))
   {
      CS_DMX_END(); 
      return OOB_DMX_ERR_BAD_CHID;
   }

   // is it valid fid?
   if(!oob_fsm_fil_get(fid,&filter))
   {
      CS_DMX_END(); 
      return OOB_DMX_ERR_BAD_FID;
   }

   trace_new( OOB_TL2, WAR "oob_dmx_close_filter: chid(%d), fid(%d). ** oob_fsm_fil_post_event(EV_FI_CLOSE) **.\n" NOR,
              chid, fid );
   oob_fsm_fil_post_event( fid, EV_FI_CLOSE );

   CS_DMX_END();
   
   return OOB_DMX_OK;
} // oob_dmx_close_filter


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_dmx_free_buf
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Free one section buffer which holds section data.
 *   
 ** SYNTAX
 * oob_dmx_status_t oob_dmx_free_buf( uint8* buf )
 * 
 ** PROTOTYPE IN
 *    oob_dmx_api.h
 *                                                                    
 ** PARAMETERS
 *  @ {buf} is a M_BLK_ID of netbuf element.
 *     
 ** DESCRIPTION 
 *    This frees a netbuf element and return to netbuf pool.
 * 
 ** RETURN VALUE
 *    status value of oob_dmx
 *
 ** SEE ALSO
 *    netbuf lib
 * ----------------------------------------------------------------------------------
 */      
oob_dmx_status_t oob_dmx_free_buf( uint8* buf )
{
   if((M_BLK_ID)buf)
      netMblkClChainFree((M_BLK_ID)buf);
   
   return OOB_DMX_OK;
} // oob_dmx_free_buf


oob_dmx_status_t oob_dmx_info_control(CNXT_DAVIC_OOBFE_INFO_DATA_CODE info_code, oob_dmx_commands_t command)
{
   CS_DMX_BEGIN();
   
   g_ret = OOB_DMX_ERR;
   
   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_info_control: oob dmx is not initialized.\n" NOR);
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }
   
   trace_new( OOB_TL3, WAR "oob_dmx_info_control: arg info_code(%d), command(%d).\n" NOR,
      info_code, command );   

   g_ret = cnxt_davic_oobfe_info_control( g_oobfe_handle, info_code, command );
   if( g_ret == CNXT_DAVIC_OOBFE_OK )
   {
      trace_new( OOB_TL3, WAR "oob_dmx_info_control: cnxt_oob_info_control is ok.\n" NOR);   
   }
   else
   {
      trace_new( OOB_ERR, ERR "oob_dmx_info_control: cnxt_oob_info_control is fail. g_ret(0x%x)\n" NOR
         , g_ret );   
   }
   
   CS_DMX_END();
   
   return g_ret;
}


oob_dmx_status_t oob_dmx_info_read(CNXT_DAVIC_OOBFE_INFO_DATA_CODE info_code)
{
   CS_DMX_BEGIN();
   
   g_ret = OOB_DMX_ERR;
   
   // is oob_dmx not initialized?
   if( !is_oob_dmx_initialized() )
   {
      trace_new( OOB_ERR, ERR "oob_dmx_info_read: oob dmx is not initialized.\n" NOR);
      CS_DMX_END();
      return OOB_DMX_ERR_NOT_INIT;
   }
   
   trace_new( OOB_TL3, NOR "oob_dmx_info_read: arg info_code(%d).\n" NOR,
      info_code );   
   
   g_ret = cnxt_davic_oobfe_info_read( g_oobfe_handle, info_code );
   if( g_ret == CNXT_DAVIC_OOBFE_OK )
   {
      trace_new( OOB_TL3, NOR "oob_dmx_info_read: cnxt_oob_info_read is ok.\n" NOR);   
   }
   else
   {
      trace_new( OOB_ERR, ERR "oob_dmx_info_read: cnxt_oob_info_read is fail. g_ret(0x%x).\n" NOR
         , g_ret );   
   }
   
   CS_DMX_END();
   
   return g_ret;
}


/* =================================================================================
 * D E B U G - I N T E R F A C E S
 * =================================================================================
 */  

#ifdef DEBUG

extern void oob_show_all(void);
extern void oob_stats_show(void);
extern void oob_channel_list_show(unsigned int channel);
extern void oob_internal_objects_show(void);

void debug_netpool_info()
{
   netPoolShow(pci_memPoolId);
}

void debug_task_info()
{
   if( oob_dmx_pump_tid && oob_dmx_match_tid )
   {
      printf(WAR "\n"
             "===================================================================\n"
             "oob_dmx_task_information.\n" NOR
             "-------------------------------------------------------------------\n"
             );

      i(oob_dmx_pump_tid);
      i(oob_dmx_match_tid);
   }
}

void debug_queue_info()
{
   if( oob_dmx_off_pump_qid && oob_dmx_off_match_qid )
   {
      printf(WAR "\n"
             "===================================================================\n"
             "oob_dmx_queue_information.\n" NOR
             "-------------------------------------------------------------------\n"
             );

      msgQShow(oob_dmx_off_pump_qid,1);
      msgQShow(oob_dmx_off_match_qid,1);
   }
}

void debug_channel_fsm_info()
{
   uint32               idx      = 0;

   printf(WAR "\n"
          "===================================================================\n"
          "channel fsm status.\n" NOR
          "-------------------------------------------------------------------\n");

   for(idx=0; idx < OOB_DMX_MAX_CHANNELS; idx++)
   {
      printf("name: %15s, \tcurrent state: %15s\n",
             oob_fsm_chn_get_name(idx),
             oob_fsm_chn_get_current_state_name(idx));
   }
}

void debug_filter_fsm_info()
{
   uint32               idx      = 0;

   printf(WAR "\n"
          "===================================================================\n"
          "filter fsm status.\n" NOR
          "-------------------------------------------------------------------\n");

   for(idx=0; idx < OOB_DMX_MAX_FILTERS; idx++)
   {
      printf("name: %15s, \tcurrent state: %15s\n",
             oob_fsm_fil_get_name(idx),
             oob_fsm_fil_get_current_state_name(idx));
   }
}


void debug_dmx_info()
{
   oob_dmx_instance_t    dmx  = {0};

   if(oob_fsm_dmx_get(&dmx))
   {
      printf(WAR "\n"
             "===================================================================\n"
             "oob_dmx_instance.\n" NOR
             "-------------------------------------------------------------------\n"
             "avail_channels(num)          : %d of %d.\n"
             "avail_filters(num)           : %d of %d.\n"
             "connection_notify(fptr)      : %p.\n"
             "===================================================================\n\n",
             dmx.avail_channels,
             OOB_DMX_MAX_CHANNELS,
             dmx.avail_filters,
             OOB_DMX_MAX_FILTERS,
             (oob_dmx_connection_t)dmx.connection_notify);
   }
}

void debug_channel_info(uint32 chid)
{
   oob_dmx_channel_t    channel  = {0};
   uint32               fidx = 0;

   char buf_alloc[MAX_TRACEMSG_CHARS]={0};
   char buf_enable[MAX_TRACEMSG_CHARS]={0};

   if( oob_fsm_chn_get(chid,&channel))
   {
      bsprintf(buf_alloc, channel.allocated_filters  );
      bsprintf(buf_enable, channel.enabled_filters );

      printf(WAR "\n"
             "===================================================================\n"
             "channel(%ld).\n" NOR
             "-------------------------------------------------------------------\n"
             "pid(uint16)       : %d.\n"
             "cnxt_chid(uint32) : %ld.\n"
             "chid(uint8)       : %ld.\n"
             "allocated_filters : %s\n"
             "enabled_filters   : %s\n"
             "crc_status        : %ld.\n"
             "data_notify(fptr) : %p.\n"
             "-------------------------------------------------------------------\n",
             chid,
             channel.pid,
             channel.cnxt_chid,
             channel.chid,
             buf_alloc,
             buf_enable,
             channel.crc_status,
             (oob_dmx_callback_t)channel.data_notify);

      // search all filters for a channel
      for( fidx = 0; fidx < OOB_DMX_MAX_FILTERS; fidx++ ) 
      {
         // is an allocated filter ?
         if( channel.allocated_filters & (1<<fidx) )
            debug_filter_info(fidx);
      }

   }
}

void debug_filter_info(uint32 fid)
{
   oob_dmx_filter_t    filter  = {0};
   int idx = 0;

   if( oob_fsm_fil_get(fid,&filter))
   {
      printf(WAR "\n"
             "===================================================================\n"
             "oob_dmx_filter(%ld).\n" NOR
             "-------------------------------------------------------------------\n"
             "chid(uint32)           : %ld.\n"
             "fid(uint32)            : %ld.\n"
             "filter_size(uint32)    : %ld.\n",
             fid,
             filter.chid,
             filter.fid,
             filter.filter_size );

      printf("match(uint32*%d)        : ", OOB_DMX_FILTER_SIZE/4 );

      for(idx = 0; idx <OOB_DMX_FILTER_SIZE/4; idx++ )
         printf("%08lX-", (uint32)filter.match[idx]);

      printf("\nmask(uint32*%d)       : ", OOB_DMX_FILTER_SIZE/4 );

      for(idx = 0; idx <OOB_DMX_FILTER_SIZE/4; idx++ )
         printf("%08lX-", (uint32)filter.mask[idx]);

      printf("\n"
             "-------------------------------------------------------------------\n");
   }
}


void debug_cnxt_show_all()
{
   oob_show_all();
}

void debug_cnxt_stats_show()
{
   oob_stats_show();
}

void debug_cnxt_channel_list_show(unsigned int channel)
{
   /* 1 = working channels list. 0 - delted channels list */
   oob_channel_list_show(channel);
}

#endif // DEBUG

{source-uitl}

{source-} <oob_dmx_util.h>

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_UTIL.H
 *
 * $Id: oob_dmx_util.h,v 1.1.1.2 2003/05/20 07:22:24 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains definitions of the oob dmx fsm. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_util.h,v $
 * Revision 1.1.1.2  2003/05/20 07:22:24  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */
 
#ifndef __OOB_DMX_UTIL_H__
#define __OOB_DMX_UTIL_H__

#ifndef __INCnetBufLibh
#include <netBufLib.h>
#endif

extern void oob_msem_take(SEM_ID sem_id);
extern void oob_msem_give(SEM_ID sem_id);
extern void bsprintf(char* buf, unsigned int val);

extern NET_POOL_ID oob_npool_init(uint32 num_mblks, uint32 num_clblks, uint32 num_clusters, uint32 cluster_size);
extern uint8* oob_npool_get(NET_POOL_ID pool_id, uint8** pp_data, uint32 num_bytes);
extern void oob_npool_free(NET_POOL_ID pool_id, uint8 *p_data);
extern int oob_npool_get_num_free_bufs(NET_POOL_ID memPoolId);

extern void print_section_header(bool skip, uint32 num, uint8* p_section_header, uint8* tid, uint8* section_number, uint8* last_section_number);
extern void print_ip_header(bool skip, const char* caller_name, const char* num_desc, uint32 num, uint32* p_ip_header);
extern void dump_data_as_byte_align(bool skip, const char* name, uint32 length, uint8* p_start );

#endif //__OOB_DMX_UTIL_H__ 


{source-} <oob_dmx_util.c>


/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_UTIL.C
 *
 * $Id: oob_dmx_util.c,v 1.1.1.3 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains implementations of the oob dmx fsm. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_util.c,v $
 * Revision 1.1.1.3  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.2  2003/05/17 02:15:04  ktpark
 * modify print_section message format
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */

     
/* =================================================================================
 * I N C L U D E S
 * =================================================================================
 */  
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vxworks.h>
#include <kal.h>
#include <semLib.h>

#include "trace.h"
#include "cm_oob_types.h"
#include "oob_dmx_def.h"
#include "oob_dmx_util.h"


extern void trace_now(char *string, ...);


/* =================================================================================
 * U T I L - F U N C T I O N S
 * =================================================================================
 */  

void oob_msem_take(SEM_ID sem_id)
{
   if(sem_id)
      semTake(sem_id, WAIT_FOREVER);
}


void oob_msem_give(SEM_ID sem_id)
{
   if(sem_id)
      semGive(sem_id);   
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: bsprintf 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Initialization of oob_dmx driver
 *   
 ** SYNTAX
 *   void bsprintf(char* buf, unsigned int val) 
 * 
 ** PROTOTYPE IN
 *    oob_dmx_util.h
 *                                                                    
 ** PARAMETERS
 *  @ {buf} is 
 *  @ {val} is 
 *     
 ** DESCRIPTION 
 *    Now this only supports unsigned int(4bytes) arg.
 *    buf output is 
 *     "1.1.0.0|1.0.0.0|1.1.1.1|0.0.0.0|1.0.0.1|1.1.0.1|0.0.0.0|0.0.0.0|"
 * 
 ** RETURN VALUE
 *    void
 *  
 ** SEE ALSO
 * ----------------------------------------------------------------------------------
 */      
void bsprintf(char* buf, unsigned int val)
{
   // bits = (num of bytes)*(bits of one bytes)
   unsigned int delimeter, buf_cnt, back = val, bits = sizeof(val)*8;

   // for loop control. if it is defined unsigned, loop does not stop
   int cnt;

   delimeter = 0, buf_cnt = 0;
   cnt = bits*2;

   for(; cnt > 0; cnt--, buf_cnt++)
   {
		val = back;

		if(!(cnt%2))
		{
           // it is ok unter vc env but vxworks is not.
           // ( (val>>(cnt/2-1))&1 ) ? buf[buf_cnt]='1' : buf[buf_cnt]='0';
           if((val>>(cnt/2-1))&1)
              *(buf+buf_cnt)='1';
           else
              *(buf+buf_cnt)='0';

		   delimeter++;
		}
		else if(!(delimeter%4))
			*(buf+buf_cnt) = '|';
		else
			*(buf+buf_cnt) = '.';
   }
}


/* ----------------------------------------------------------------------------------
 ** FUNCTION :: oob_npool_init 
 * ----------------------------------------------------------------------------------
 ** OVERVIEW
 *    Initialization of oob_dmx driver
 *   
 ** SYNTAX
 *   NET_POOL_ID 
 *    oob_npool_init(uint32 num_mblks, uint32 num_clblks, uint32 num_clusters, uint32 cluster_size)
 * 
 ** PROTOTYPE IN
 *    oob_dmx_util.h
 *                                                                    
 ** PARAMETERS
 *  @ {buf} is 
 *  @ {val} is 
 *     
 ** DESCRIPTION 
 *    Now this only supports unsigned int(4bytes) arg.
 *    buf output is 
 *     "1.1.0.0|1.0.0.0|1.1.1.1|0.0.0.0|1.0.0.1|1.1.0.1|0.0.0.0|0.0.0.0|"
 * 
 ** RETURN VALUE
 *    void
 *  
 ** SEE ALSO
 * ----------------------------------------------------------------------------------
 */      
NET_POOL_ID oob_npool_init(uint32 num_mblks, uint32 num_clblks, uint32 num_clusters, uint32 cluster_size)
{
   NET_POOL_ID p_oob_net_pool = (NET_POOL_ID)NULL;   
   M_CL_CONFIG *p_m_cl_config = (M_CL_CONFIG*)NULL;
   CL_DESC     *p_cl_desc     = (CL_DESC*)NULL;

   /* Allocate the Netpool configuration structure */ 
   p_oob_net_pool = (NET_POOL*)calloc(1, sizeof(NET_POOL));
   if(p_oob_net_pool == NULL)
   {
      return NULL;
   }
   
   /* Allocate the the clblk/mblk configuration structure */
   p_m_cl_config = (M_CL_CONFIG*)calloc(1, sizeof(M_CL_CONFIG));
   if (p_m_cl_config == NULL)
   {
      return NULL;
   }

   /* Compute clblk/mblk memory area from number of mBlk's & clBlk's */
   p_m_cl_config->mBlkNum = num_mblks;
   p_m_cl_config->clBlkNum= num_clblks;

   p_m_cl_config->memSize = (signed int)
           ((signed int) p_m_cl_config->mBlkNum  * (signed int) (M_BLK_SZ + (signed int)sizeof(long))) + 
           ((signed int) p_m_cl_config->clBlkNum * (signed int) CL_BLK_SZ);

   /* allocate the the clblk/mblk memory area - use noncacheable memory*/
   p_m_cl_config->memArea = mem_nc_malloc((unsigned int)p_m_cl_config->memSize);
   if (p_m_cl_config->memArea == NULL)
   {
      return NULL;
   }
                                               
   /* Load pointer to the cluster configuration structure and initialize */
   p_cl_desc = (CL_DESC*)calloc(1,sizeof(CL_DESC));
   if (p_cl_desc == NULL)
   {                             
      return NULL;
   }
   
   /* Compute cluster memory size */
   p_cl_desc->clSize     = cluster_size;
   p_cl_desc->clNum      = num_clusters;
   p_cl_desc->memSize    = (signed int)(p_cl_desc->clNum * (signed int)((signed int)p_cl_desc->clSize + (signed int)sizeof(long)));

   /* Allocate the cluster memory area - use noncacheable memory */
   p_cl_desc->memArea    = mem_nc_malloc((unsigned int)p_cl_desc->memSize);
   if (p_cl_desc->memArea == NULL)
   {
      return NULL;
   }
   
   /* allocate netpool */
   if(netPoolInit(p_oob_net_pool, p_m_cl_config, p_cl_desc, 1, NULL) == ERROR)
   {
      return NULL;
   }
   
   return p_oob_net_pool;
}

/* 
* Allocate a Buffer from memory pool. Start of data is 32-bit aligned.
*/    
uint8* oob_npool_get(NET_POOL_ID pool_id, uint8** pp_data, uint32 num_bytes)
{
   M_BLK *p_mblk; 

   if(pool_id == NULL)
      return NULL;

   if(pp_data == NULL)
	  return NULL;

   if ((p_mblk = netTupleGet(pool_id, num_bytes, M_DONTWAIT, MT_DATA, FALSE)) == NULL)
      return NULL;

   *pp_data = (u_int8 *)p_mblk;

   return p_mblk->mBlkHdr.mData;
}


/*
* Free buffer belonging to memPoolId (NET_POOL_ID) with the given pDataUnlcok (mBlk pointer)
* This function frees whole mblk-clblk-cluster chain!
*/
void oob_npool_free(NET_POOL_ID pool_id, uint8 *p_data)
{
   if(p_data == NULL)
      return;

   netMblkClChainFree((M_BLK_ID)p_data);   
   if((errno == S_netBufLib_MBLK_INVALID)||(errno == S_netBufLib_INVALID_ARGUMENT))
   {
      isr_trace_new( OOB_ERR, "oob_npool_free: Error in netMblkClChainFree() errno(%d)\n", errno,0);  
   }
}


/*
* Return number of free buffers in cluster pool. Returns
* the number of clusters in the first cluster pool (i.e. assumes there
* is only one size).
*/
int oob_npool_get_num_free_bufs(NET_POOL_ID memPoolId)
{
   if(memPoolId == NULL)
      return 0;

   return (memPoolId->clTbl[0]->clNumFree);
}


void print_section_header(bool skip, uint32 num, uint8* p_section_header, uint8* tid, uint8* section_number, uint8* last_section_number)
{
   uint32   first=0, second=0;
   
   first = *((u_int32*)p_section_header);
   second = *((u_int32*)p_section_header+1);
   
   first = BSWAP(first);
   second = BSWAP(second);
   
   if(((first>>24) & 0x0ff) == 0xD7 ||((first>>24) & 0x0ff) == 0xD6)
   {
      // is it first section?
      if(((second>>8) & 0x0ff)==0)
         printf("=========================================================\n");
      
      // is it false?
      if(!skip)
      {
         trace_now(WAR "\nprint_sec:\n{{\n" NOR
                     "\t-------------------------------------------\n"
                     "\ttid\t|len\t|tag\t|num\t|last sec\n"
                     "\t-------------------------------------------\n"
                     "\t%02X\t|%04ld\t|%02d\t|%02d\t|%02d\n"
                     ,(first>>24) & 0x0ff
                     ,(first>>8) &0x0fff
                     ,(second>>24) &0x0ff
                     ,(second>>8) & 0x0ff
                     ,(second) & 0x0ff
                     );
         
         trace_now("}}\n");
      }
      else
      {
         printf(WAR "print_sec:(%ld)\t:" NOR
                        "tid(%02lX)\t|len(%04ld)\t|tag(%02ld)\t|snum(%02ld)\t|lsnum(%02ld)\n"
                     ,num
                     ,(first>>24) & 0x0ff
                     ,(first>>8) &0x0fff
                     ,(second>>24) &0x0ff
                     ,(second>>8) & 0x0ff
                     ,(second) & 0x0ff
                     );      
      }
      
      *tid = (first>>24) & 0x0ff;
      *section_number = (second>>8) & 0x0ff;
      *last_section_number = (second) & 0x0ff;
   }
}


void print_ip_header(bool skip, const char* caller_name, const char* num_desc, uint32 num, uint32* p_ip_header)
{
   uint32   ip_header   = 0, ip_header_next = 0;

   if(!skip)
   {
      ip_header = BSWAP((u_int32) *p_ip_header);       
      trace_new(OOB_TL5, WAR "\nprint_ip_header: name(%s)\n" NOR
               "-------------------------------------------\n"
               "version(4bits)           : %d.\n"
               "header length(4bits)     : %d.\n"
               "type of service(8bits)   : 0x%X.\n"
               "total length(16bits)     : %d.\n"
               ,caller_name
               ,(ip_header >> 28 ) & 0x0f
               ,(ip_header >> 24 ) & 0x0f
               ,(ip_header >> 16) & 0xff
               ,(ip_header) & 0x0ffff
               );

      ip_header = BSWAP((u_int32) *(p_ip_header+1));
      trace_new(OOB_TL5, 
               "-------------------------------------------\n"
               "id(16bits)               : 0x%X.\n"
               "flags(3bits)             : 0x%03X.\n"
               "frag offset(13bits)      : %d.\n"
               ,(ip_header >> 16) & 0xffff
               ,(ip_header >> 13) & 0x07
               ,(ip_header) & 0x01fff
               );

      ip_header = BSWAP((u_int32) *(p_ip_header+2));
      trace_new( OOB_TL5,
               "-------------------------------------------\n"
               "TTL(8bits)               : %d.\n"
               "protocol(8bits)          : %d.\n"
               "header checksum(16bits)  : 0x%X.\n"
               ,(ip_header >> 24) & 0xff
               ,(ip_header >> 16) & 0xff
               ,(ip_header) & 0xffff
               );

      ip_header = BSWAP((u_int32) *(p_ip_header+3));
      trace_new(OOB_TL5, 
               "-------------------------------------------\n"
               "source ip addr           : %d.%d.%d.%d\n"
               ,(ip_header >> 24) & 0x0ff
               ,(ip_header >> 16) & 0x0ff
               ,(ip_header >> 8) & 0x0ff
               ,(ip_header) & 0x0ff
               );

      ip_header = BSWAP((u_int32) *(p_ip_header+4));
      trace_new(OOB_TL5, 
               "-------------------------------------------\n"
               "dest ip addr             : %d.%d.%d.%d\n\n"
               ,(ip_header >> 24) & 0x0ff
               ,(ip_header >> 16) & 0x0ff
               ,(ip_header >> 8) & 0x0ff
               ,(ip_header) & 0x0ff
               );
   }
   else
   {
      ip_header = BSWAP((u_int32) *p_ip_header);       
      ip_header_next = BSWAP((u_int32) *(p_ip_header+1));
      
      trace_now(WAR "\nprint_ip_header: %s\t: %s\t:(%ld)\n" NOR
               "{{\tlen(%d)\t|id(0x%X)\t|flag(0x%03X)\t|offset(%d) }}\n"
               ,caller_name
               ,num_desc
               ,num
               ,(ip_header) & 0x0ffff
               ,(ip_header_next >> 16) & 0xffff
               ,(ip_header_next >> 13) & 0x07
               ,(ip_header_next) & 0x01fff
               );
   }
}


void dump_data_as_byte_align(bool skip, const char* name, uint32 length, uint8* p_start )
{
   uint8    line[MAX_TRACEMSG_CHARS]={0};
   uint16   idx=0, pos=0, line_cnt = 0, skip_cnt=0;
   
   trace_now(WAR "\ndump_data_as_byte_align : skip(%d), name(%s), len(%ld)\n{{\n" NOR
                , skip, name, length ); 
   
   for( idx=0; idx < length; idx++ )
   {
      if( (idx != 0) && ((idx%15) == 0) )
      {
         *(line+pos) = '\0';
                  
         if(skip)
         {
            if(line_cnt==0)
               trace_now("\t%s\n",line);
            else
               skip_cnt++;
         }           
         else
            trace_now("\t%s\n",line);
         
         line_cnt++;

         memset(line, '\0', MAX_TRACEMSG_CHARS );
         pos = 0;
      }
   
      pos += sprintf(line+pos, "0x%02X, ", *(p_start+idx) );
   }
   
   if(skip&&(line_cnt>2))
      trace_now( "\t...(%d) skiped...\n\t%s\n" WAR "}}\n" NOR ,skip_cnt, line); 
   else
      trace_now( "\t%s\n" WAR "}}\n" NOR , line); 
}


{source-def}

/*================================================================================
 * Copyright 2001- by HUMAX Co., Ltd.
 * 
 * R&D Center 
 * Humax Venture Tower 271-2
 * Seohyeon-Dong, Bundang-Gu, Seongnam-Si,
 * Gyeonggi-Do, Korea(ROK)
 *
 * This source code is confidential, proprietary information of HUMAX and 
 * is an unpublished work of authorship protected by the copyright laws of 
 * the Korea(ROK). Unauthorized copying or use of this document or the program
 * contained herein, in original or modified form, is a violation of Korea law.
 *--------------------------------------------------------------------------------
 * {PROJECT}
 *--------------------------------------------------------------------------------
 * LINDEN
 *--------------------------------------------------------------------------------
 * {FILENAME}
 *--------------------------------------------------------------------------------
 * OOB_DMX_DEF.H
 *
 * $Id: oob_dmx_def.h,v 1.1.1.2 2003/05/20 07:22:25 ktpark Exp $
 *--------------------------------------------------------------------------------
 * {DESCRIPTION}
 *--------------------------------------------------------------------------------
 * This file contains definitions of the oob dmx fsm. 
 *--------------------------------------------------------------------------------
 * {INITIAL AUTHOR}
 *--------------------------------------------------------------------------------
 * Kyoung Taek, Park, Humax. Contacts at ktpark@humaxdigital.com
 *--------------------------------------------------------------------------------
 * {ANKNOWLEDGMENTS}
 *--------------------------------------------------------------------------------
 * 
 *--------------------------------------------------------------------------------
 * {REVISION HISTORY}
 *--------------------------------------------------------------------------------
 * $Log: oob_dmx_def.h,v $
 * Revision 1.1.1.2  2003/05/20 07:22:25  ktpark
 * -. mod for release build
 * -. mod for supporting control info, i.e. signal strength and bit error
 * -. add a ALIVE_MSG_DEBUG_ON define for testing proper cm_alive message flow
 * -. mod for comments
 *
 * Revision 1.1.1.1  2003/05/17 01:08:27  ktpark
 * initial check in
 *
 * 
 *================================================================================
 */
 
#ifndef __OOB_DMX_DEF_H__
#define __OOB_DMX_DEF_H__

#ifndef __CM_OOB_TYPES__
#error in oob_dmx_def.h, cm_oob_types.h should be included before
#endif

    
/* ----------------------------------------------------------------------------------
 * DATA_CALLBACK_DEBUG_ON
 * ----------------------------------------------------------------------------------
 * if it is defined as 0, it dumps data and ends data transfer.
 *
 * if it is defined as 1, debugging version is selcted. That performs ip reassembly and 
 * do not pump to the match task. So, all clusters will be freed.
 *
 * Otherwise, if it is 2,  it flows normal data transfer and pumps data.
 */

//#define DATA_CALLBACK_DEBUG_ON 0
//#define DATA_CALLBACK_DEBUG_ON 1
#define DATA_CALLBACK_DEBUG_ON 2


/* ----------------------------------------------------------------------------------
 * DATA_FLOW_DEBUG_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, data flow which transfer section is printed from data callback
 * to pump task. 
 */
//#define DATA_FLOW_DEBUG_ON


/* ----------------------------------------------------------------------------------
 * PUMP_TASK_DEBUG_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, trace message for pump task is on.
 */
//#define PUMP_TASK_DEBUG_ON


/* ----------------------------------------------------------------------------------
 * OOB_DMX_TRACE_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, it will turn on oob_dmx trace messages. Otherwise, all oob_dmx 
 * messages are turned off except error messages.
 */
//#define OOB_DMX_TRACE_ON 


/* ----------------------------------------------------------------------------------
 * OOB_DMX_COLOR_TRACE_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, it will turn on color trace messages. Otherwise, color of all 
 * oob_dmx messages are turned off.
 */
#define OOB_DMX_COLOR_TRACE_ON 

          
/* ----------------------------------------------------------------------------------
 * ALIVE_TIMER_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, alive timer will be on. Otherwise, it will be off.
 */
#define ALIVE_TIMER_ON 

             
/* ----------------------------------------------------------------------------------
 * CONTROL_INFO_TEST_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, control info routine will be on. Otherwise, it will be off.
 */
//#define CONTROL_INFO_TEST_ON


/* ----------------------------------------------------------------------------------
 * ALIVE_MSG_DEBUG_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, flow of normal cm_alive control message will be tested
 */
#define ALIVE_MSG_DEBUG_ON


/* ----------------------------------------------------------------------------------
 * FSM_TRACE_ON
 * ----------------------------------------------------------------------------------
 * if it is defined, control info routine will be on. Otherwise, it will be off.
 */
/* for fsm trace message */
//#define FSM_TRACE_ON

  
/* ----------------------------------------------------------------------------------
 * OOB_DMX_DEBUG
 * ----------------------------------------------------------------------------------
 * if it is defined, control info routine will be on. Otherwise, it will be off.
 */
/* for internal message(esp filter) */
//#define OOB_DMX_DEBUG


#define OOB_DMX_SEM_OPTIONS      SEM_Q_PRIORITY | SEM_DELETE_SAFE | SEM_INVERSION_SAFE


/* ----------------------------------------------------------------------------------
 * OOB_DMX_PUMP task
 * ----------------------------------------------------------------------------------
 */
#define OOB_DMX_PUMP_NAME         "oob_dmx_p"
#define OOB_DMX_PUMP_PRIORITY     175
#define OOB_DMX_PUMP_OPTIONS      0

/* from kal.h
#define DEFAULT_STACK_SIZE 5120                
*/
#define OOB_DMX_PUMP_STACK_SIZE   5120

#define OOB_DMX_PUMP_Q_MAX_MESG  600
#define OOB_DMX_PUMP_Q_LEN_MESG  20


/* ----------------------------------------------------------------------------------
 * OOB_DMX_MATCH task
 * ----------------------------------------------------------------------------------
 */
#define OOB_DMX_MATCH_NAME         "oob_dmx_m"
#define OOB_DMX_MATCH_PRIORITY     175
#define OOB_DMX_MATCH_OPTIONS      0
#define OOB_DMX_MATCH_STACK_SIZE   5120

#define OOB_DMX_MATCH_Q_MAX_MESG  600
#define OOB_DMX_MATCH_Q_LEN_MESG  20


/* ----------------------------------------------------------------------------------
 * OOB_MAX_CHANNELS_OPEN  16
 * ----------------------------------------------------------------------------------
 */
#define OOB_DMX_MAX_CHANNELS     OOB_MAX_CHANNELS_OPEN
#define OOB_DMX_MAX_FILTERS      32

#define OOB_DMX_IP_OFFSET        20
#define OOB_DMX_UDP_OFFSET       8
#define OOB_DMX_IP_UDP_OFFSET    (OOB_DMX_IP_OFFSET+OOB_DMX_UDP_OFFSET)


/* ----------------------------------------------------------------------------------
 * OOB_DMX_FILTER_SIZE
 * ----------------------------------------------------------------------------------
 */
#define OOB_DMX_FILTER_SIZE   8


/* ----------------------------------------------------------------------------------
 * OOB_DMX_SECTION_POOL FOR IP FRAGMENTATION
 * ----------------------------------------------------------------------------------
 - OOB_DMX_NUM_OF_CLUSTERS comes from RECV_NUMBER_OF_CLUSTERS_OOB in numClustersGet()
 - OOB_DMX_SIZE_OF_CLUSTERS comes from RECV_CLUSTER_SIZE_OOB in clusterSizeGet()
 */
#define OOB_DMX_NUM_OF_CLUSTERS  20
#define OOB_DMX_SIZE_OF_CLUSTER  4124


#ifndef BSWAP
#define BSWAP(x) (((x & 0xFF) << 24) |                         \
                  ((x & 0xFF00) << 8) |                        \
                  ((x & 0xFF0000) >> 8) |                      \
                  ((x & 0xFF000000) >> 24))
#endif                  

/* ----------------------------------------------------------------------------------
 * FOR TRACE
 * ----------------------------------------------------------------------------------
 */

#ifdef TRACE_FG_NORMAL
#undef TRACE_FG_NORMAL
#define TRACE_FG_NORMAL                "\033[0;37m"
#endif


#ifdef FSM_TRACE_ON
#define TRACE_FSM       TRACE_GEN 

#else
#define TRACE_FSM       0x00000000
#endif // FSM_TRACE_ON

#ifdef OOB_DMX_TRACE_ON 
#define TRACE_OOB_DMX   TRACE_GEN
#define TRACE_OOB_CNXT  TRACE_GEN

#else
#define TRACE_OOB_DMX   0x00000000
#define TRACE_OOB_CNXT  0x00000000
#endif // OOB_DMX_TRACE_ON


#ifdef OOB_DMX_COLOR_TRACE_ON     

#define ERR             TRACE_FG_LIGHT_RED "\a\a"
#define WAR             TRACE_FG_LIGHT_GREEN
#define POP             TRACE_FG_LIGHT_CYAN
#define NOR             TRACE_FG_NORMAL

#else

#define ERR             "\a\a"
#define WAR             ""
#define POP             ""
// #define WAR             TRACE_FG_NORMAL
#define NOR             TRACE_FG_NORMAL

#endif // OOB_DMX_COLOR_TRACE_ON


#define FSM_TL2   (TRACE_FSM|TRACE_LEVEL_2) 
#define FSM_TL3   (TRACE_FSM|TRACE_LEVEL_3)
#define FSM_TL4   (TRACE_FSM|TRACE_LEVEL_4)
#define FSM_TL5   (TRACE_FSM|TRACE_LEVEL_5)
#define FSM_TL6   (TRACE_FSM|TRACE_LEVEL_6)
#define FSM_ERR   (TRACE_GEN|TRACE_LEVEL_ALWAYS)

#define OOB_TL1   (TRACE_OOB_DMX|TRACE_LEVEL_1)                                                 
#define OOB_TL2   (TRACE_OOB_DMX|TRACE_LEVEL_2) 
#define OOB_TL3   (TRACE_OOB_DMX|TRACE_LEVEL_3)
#define OOB_TL4   (TRACE_OOB_DMX|TRACE_LEVEL_4)
#define OOB_TL5   (TRACE_OOB_DMX|TRACE_LEVEL_5)
#define OOB_TL6   (TRACE_OOB_DMX|TRACE_LEVEL_6)
#define OOB_ERR   (TRACE_GEN|TRACE_LEVEL_ALWAYS)

#endif /* __OOB_DMX_DEF_H__ */

{source-end}


={============================================================================
*kt_dev_code_003* static fsm demo in cpp

This uses namespace and const instead #define. However found that it is not a simple thing to make
all using namespace and const. For namespace, need to remove fsm_ prefix and for const, need to
change every function prototype and fsm defintions to use const. Seems to good to have const fsm
defintions and is a way to force user to use const. 


{source-fsm}

{source-} <fsm.h>

//
// System   Tizen
//
// Module   MHEG Application
//
// @file    Fsm.h
// @author  keitee.park  
// @date    
//
// @brief   
//
// Copyright (c) 2007-2009 Samsung Electronics Polska Sp. z o.o.
// Copyright (c) 2014 Samsung Electonics (UK) Ltd.
//
// All Rights Reserved.
//
// This  document  may  not, in  whole  or in  part, be  copied,  photocopied,
// reproduced,  translated,  or  reduced to any  electronic  medium or machine
// readable form without prior written consent from Samsung Electronics (UK) Ltd.
//

#ifndef __FSM_H__
#define __FSM_H__


//#ifdef __cplusplus
//extern "C"
//{
//#endif

namespace Fsm {

// =================================================================================
// C O N S T A N T S - M A C R O S
// =================================================================================
 
#ifndef NULL
#define NULL 0
#endif


#define FSM_LOG   fprintf
// assert: if expression evaluates to false, call assert
//#define FSM_ASSERT(expression) do{if(!(expression)){ \
//	FSM_LOG( stderr, "~~~~~~~~~~~~ FSM_ASSERT at file=<%s>, line=%d, failed on: " #expression,__FILE__,__LINE__); \
//	assert();}}while(0)


// =================================================================================
// D A T A T Y P E S
// =================================================================================
// enums and typdefs

#ifndef uint32
typedef unsigned int uint32;
#endif


typedef bool fsm_status_t;
#define FSM_ERR false
#define FSM_OK  true


typedef uint32 fsm_state_hdl;
typedef uint32 fsm_event_hdl;


struct fsm_instance;
struct fsm_event;
struct fsm_state;

// If want to make this as a const, it reqires many changes because there is no const to non-const
// conversion. That means need to change static fsm definitions and fsm functions to use it.
//
#define FSM_INVALID_STATE  NULL
const uint32 INVALID_EVENT_HDL = -1;
const uint32 INVALID_STATE_HDL = -1;

typedef void (*fsm_action_func_t)(fsm_instance*, fsm_event*);

typedef struct fsm_event {
  fsm_event_hdl   hdl;
  char*           name;
  void*           data;
} fsm_event_t;

typedef struct {
  fsm_event_hdl   event_hdl;
  fsm_state_hdl   state_hdl;
} fsm_transition_tbl_t;

typedef struct fsm_state {  
  fsm_state_hdl         hdl;

  // this 'char* name' causes following error in GCC(g++) but it was fine before in C.
  // main.cpp:53:74: warning: deprecated conversion from string constant to char* [-Wwrite-strings]
  // should consider using std::string name; instead?
  char*                 name;
  fsm_action_func_t     enter_action;
  fsm_transition_tbl_t* transition_tbl;
} fsm_state_t;

typedef struct fsm_instance {
   char*              name;
   fsm_state_t**      state_list;
   fsm_event_t*       event_list;
   fsm_state_t*       current_state;
   fsm_state_t*       previous_state;
} fsm_instance_t;


/* =================================================================================
 * I N T E R F A C E S
 * =================================================================================
 */  
fsm_status_t  fsm_create( fsm_instance_t* fsm, fsm_state_hdl init_state, fsm_event_hdl init_event, void* data );
fsm_status_t  fsm_post_event( fsm_instance_t* fsm, fsm_event_hdl post_event, void* data );
fsm_state_hdl fsm_get_current_state_hdl( fsm_instance_t* fsm );
fsm_state_hdl fsm_get_previous_state_hdl( fsm_instance_t* fsm );
char*         fsm_get_current_state_name( fsm_instance_t* fsm );
char*         fsm_get_event_name( fsm_instance_t* fsm, fsm_event_hdl event );
bool          fsm_check_input_event( fsm_instance_t* fsm, fsm_event_hdl event );

//#ifdef __cplusplus
//}
//#endif

}

#endif // __FSM_H__

{source-} <fsm.c>


//
// System   Tizen
//
// Module   MHEG Application
//
// @file    Fsm.cpp
// @author  keitee.park  
// @date    
//
// @brief   
//
// Copyright (c) 2007-2009 Samsung Electronics Polska Sp. z o.o.
// Copyright (c) 2014 Samsung Electonics (UK) Ltd.
//
// All Rights Reserved.
//
// This  document  may  not, in  whole  or in  part, be  copied,  photocopied,
// reproduced,  translated,  or  reduced to any  electronic  medium or machine
// readable form without prior written consent from Samsung Electronics (UK) Ltd.
//

#include <cstdio>
#include <cassert>
#include "Fsm.h"

namespace Fsm {

//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The function get_vaild_state is used to search a valid state in the state list.
//
// RETURN VALUE
//   FSM_OK
//   FSM_ERR
//----------------------------------------------------------------------------------
static fsm_state_t* get_vaild_state( fsm_instance_t* fsm, fsm_state_hdl state_hdl )
{
	uint32 idx=0;

	while( fsm->state_list[idx] != FSM_INVALID_STATE ) 
	{
		if( fsm->state_list[idx]->hdl == state_hdl )
			return fsm->state_list[idx];

		idx++;
	}
	
	FSM_LOG( stderr, "FSM: %s: get state: unsupported state handle(%d).\n", fsm->name, state_hdl );

	return NULL;
}

//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The function call_state_actions is used to call enter action of the state.
//
// RETURN VALUE
//   FSM_OK
//   FSM_ERR
//----------------------------------------------------------------------------------
static fsm_status_t call_state_actions( fsm_instance_t* fsm, fsm_event_hdl event, void* event_data )
{
  if( fsm->current_state->enter_action == NULL )
  {
    FSM_LOG( stderr, "FSM: %s: no eaf in state(%s).\n", fsm->name, fsm->current_state->name );
    return FSM_ERR;
  }

  /* in case there is enter function */
  if( fsm->current_state->enter_action ) 
  {
    fsm->event_list[event].data = (void*) event_data;
    fsm->current_state->enter_action( fsm, &(fsm->event_list[event]) );
    return FSM_OK;
  }

  return FSM_ERR;
}

//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The function fsm_create is called by a client in order to create fsm object
//   and should be called before calling any fsm interfaces. 
//
// RETURN VALUE
//   FSM_OK
//   FSM_ERR
//----------------------------------------------------------------------------------
//      
fsm_status_t fsm_create( fsm_instance_t* fsm, fsm_state_hdl init_state, fsm_event_hdl init_event, void* init_data )
{
  fsm_status_t stat = FSM_OK;
  fsm_state_t* pstate = NULL;

  if( fsm == NULL )
  {
    FSM_LOG( stderr, "FSM: fsm is null.\n" );
    stat = FSM_ERR;
  }

  if( stat && (pstate = get_vaild_state(fsm, init_state)) )
  {
    fsm->previous_state = fsm->current_state = pstate;
    if( pstate == NULL )
    {
      FSM_LOG( stderr, "FSM: fail to create(%s).\n", fsm->name);
      stat = FSM_ERR;
    }
  }

  // change state of fsm 
  if(stat)
    stat = call_state_actions( fsm, init_event, init_data );

  return stat;
}


//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The function fsm_post_event is used to post an event to specified fsm object.
//
// RETURN VALUE
//   FSM_OK
//   FSM_ERR
//----------------------------------------------------------------------------------
fsm_status_t fsm_post_event( fsm_instance_t* fsm, fsm_event_hdl post_event, void* event_data )
{
  uint32			idx=0;
  fsm_state_t*	next_state = NULL;

  if( fsm == NULL || fsm->current_state == NULL )
  {
    FSM_LOG( stderr, "FSM: %s is null.\n", fsm ? "current_state" : "fsm" );
    return FSM_ERR;
  }

  while ( fsm->current_state->transition_tbl[idx].event_hdl != INVALID_EVENT_HDL ) 
  {
    if( fsm->current_state->transition_tbl[idx].event_hdl == post_event ) 
    {
      next_state = get_vaild_state( fsm, fsm->current_state->transition_tbl[idx].state_hdl );

      fsm->previous_state = fsm->current_state;

      FSM_LOG( stderr, "FSM: ----- %s ----- event(%s) : state(%s)->state(%s).\n",
          fsm->name, fsm->event_list[post_event].name, fsm->current_state->name, next_state->name );

      fsm->current_state = next_state;

      call_state_actions( fsm, post_event, event_data );

      return FSM_OK;
    }

    idx++;
  }

  FSM_LOG( stderr, "FSM: %s: post: unsupported event(%s) in state(%s).\n",
      fsm->name, fsm->event_list[post_event].name, fsm->current_state->name );

  return FSM_ERR;
}


//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The utility function is used to get a handle of current state.
//
// RETURN VALUE
//
//----------------------------------------------------------------------------------
fsm_state_hdl fsm_get_current_state_hdl( fsm_instance_t* fsm )
{
  if( fsm == NULL || fsm->current_state == NULL )
  {
    FSM_LOG( stderr, "FSM: %s is null.\n", fsm ? "current_state" : "fsm" );
    return INVALID_STATE_HDL;
  }

  return fsm->current_state->hdl;
}

//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The utility function is used to get a handle of current state.
//
// RETURN VALUE
//
//----------------------------------------------------------------------------------
fsm_state_hdl fsm_get_previous_state_hdl( fsm_instance_t* fsm )
{
  if( fsm == NULL || fsm->previous_state == NULL )
  {
    FSM_LOG( stderr, "FSM: %s is null.\n", fsm ? "previous_state" : "fsm" );
    return INVALID_STATE_HDL;
  }

  return fsm->previous_state->hdl;
}


//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The utility function is used to get a name of current state.
//
// RETURN VALUE
//
//----------------------------------------------------------------------------------
char* fsm_get_current_state_name( fsm_instance_t* fsm )
{
  if( fsm == NULL )
  {
    FSM_LOG( stderr, "FSM: fsm is null.\n" );
    return NULL;
  }

  return fsm->current_state->name;
}

//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The utility function is used to get a name of event
//
// RETURN VALUE
//
//----------------------------------------------------------------------------------
char* fsm_get_event_name( fsm_instance_t* fsm, fsm_event_hdl event )
{
  if( fsm == NULL )
  {
    FSM_LOG( stderr, "FSM: fsm is null.\n" );
    return NULL;
  }

  return fsm->event_list[event].name;
}

//----------------------------------------------------------------------------------
// DESCRIPTION 
//   The utility function is used to check input event
//
// RETURN VALUE
//
//----------------------------------------------------------------------------------
fsm_status_t fsm_check_input_event( fsm_instance_t* fsm, fsm_event_hdl event )
{
  uint32			idx=0;

  if( fsm == NULL || fsm->previous_state == NULL )
  {
    FSM_LOG( stderr, "FSM: %s is null.\n", fsm ? "previous_state" : "fsm" );
    return FSM_ERR;
  }

  while ( fsm->previous_state->transition_tbl[idx].event_hdl != INVALID_EVENT_HDL ) 
  {
    if( fsm->previous_state->transition_tbl[idx].event_hdl == event ) 
      return FSM_OK;

    idx++;
  }

  FSM_LOG( stderr, "FSM: %s: post: unsupported event(%s) from prev state(%s).\n",
      fsm->name, fsm->event_list[event].name, fsm->previous_state->name );

  return FSM_ERR;
}

}


{souce-main}

{source-} <main.cpp>

#include <iostream>
#include "Fsm.h"

enum FSM_EV {
  E_INIT,
  E_ONE,
  E_TWO,
  E_END
};

enum FSM_ST {
  S_INIT,
  S_ONE,
  S_TWO,
  S_END
};

// eafs
static void eaf_int( Fsm::fsm_instance_t* fsm, Fsm::fsm_event_t* event)
{ std::cout << "eaf_int: " << std::endl; }
static void eaf_one( Fsm::fsm_instance_t* fsm, Fsm::fsm_event_t* event)
{ std::cout << "eaf_one: " << std::endl; }
static void eaf_two( Fsm::fsm_instance_t* fsm, Fsm::fsm_event_t* event)
{ std::cout << "eaf_two: " << std::endl; }
static void eaf_end( Fsm::fsm_instance_t* fsm, Fsm::fsm_event_t* event)
{ std::cout << "eaf_end: " << std::endl; }

// tbls. must have an end with invalid event
//
//             START
//               *
//      init   self  two        end
// ONE ----->  INIT -----> TWO -----> END
//     <-----       <-----     <-----
//      one          init       two
//
// where STATE and event which are 0, 1, 2, 3
//
static Fsm::fsm_transition_tbl_t init_table[] = {
  {E_INIT, S_INIT},
  {E_ONE, S_ONE},
  {E_TWO, S_TWO},
  {Fsm::INVALID_EVENT_HDL}
};

static Fsm::fsm_transition_tbl_t one_table[] = {
  {E_INIT, S_INIT},
  {Fsm::INVALID_EVENT_HDL}
};

static Fsm::fsm_transition_tbl_t two_table[] = {
  {E_INIT, S_INIT},
  {E_END, S_END},
  {Fsm::INVALID_EVENT_HDL}
};

static Fsm::fsm_transition_tbl_t end_table[] = {
  {E_TWO, S_TWO},
  {Fsm::INVALID_EVENT_HDL}
};

static Fsm::fsm_state_t init_state = { S_INIT, "INIT ST", eaf_int, init_table };
static Fsm::fsm_state_t one_state = { S_ONE, "ONE ST", eaf_one, one_table };
static Fsm::fsm_state_t two_state = { S_TWO, "TWO ST", eaf_two, two_table };
static Fsm::fsm_state_t end_state = { S_END, "END ST", eaf_end, end_table };

static Fsm::fsm_state_t* fsm_state_list[] = {
   &init_state,
   &one_state,
   &two_state,
   &end_state,
   FSM_INVALID_STATE
};

static Fsm::fsm_event_t fsm_event_list[] = {
   { E_INIT, "INIT EV" }, 
   { E_ONE, "ONE EV" },
   { E_TWO, "TWO EV" },
   { E_END, "END TV" }
};

{BP} Can use following style to lessen the burden to type event string.

#define FSM_E(x) {x,#x}

static Fsm::fsm_event_t bootEventList[] = {
   FSM_E( BOOT_EVENT_READY ),
   FSM_E( BOOT_EVENT_START )
};

static Fsm::fsm_instance_t demo_fsm = {
   "DEMO FSM", fsm_state_list, fsm_event_list, NULL
};

int main()
{
  Fsm::fsm_status_t stat;
  unsigned int input;

	std::cout << "--{" << std::endl << "main: " << std::endl;

  // {Q} Why does it work? No difference even when changed Fsm.c to Fsm.cpp
  stat = fsm_create( &demo_fsm, S_INIT, E_INIT, (void*) NULL );
  //stat = Fsm::fsm_create( &demo_fsm, S_INIT, E_INIT, (void*) NULL );

  while( std::cin >> input )
  {
    switch (input)
    {
      case E_END:
	      std::cout << "main: post E_END" << std::endl;
        fsm_post_event( &demo_fsm, E_END, NULL );
        break;
      case E_TWO:
	      std::cout << "main: post E_TWO" << std::endl;
        fsm_post_event( &demo_fsm, E_TWO, NULL );
        break;
      case E_ONE:
	      std::cout << "main: post E_ONE" << std::endl;
        fsm_post_event( &demo_fsm, E_ONE, NULL );
        break;
      case E_INIT:
	      std::cout << "main: post E_INIT" << std::endl;
        fsm_post_event( &demo_fsm, E_INIT, NULL );
        break;

      default:
	      std::cout << "main: unknown event: " << input << std::endl;
        break;
    }
  }

	std::cout << "--}" << std::endl << "main: " << std::endl;
}

{source-} <makefile>

# simple makefile from gmake

FILE = use-main.cpp
CC = g++ -std=c++0x -I.

main : main.o fsm.o
	echo '>> bulid main'
	$(CC) -o out main.o fsm.o

fsm.o : Fsm.c
	echo '>> build fsm.c'
	$(CC) -o fsm.o -c Fsm.c

main.o : main.cpp
	echo '>> build main.cpp'
	$(CC) -o main.o -c main.cpp

clean :
	rm main.o fsm.o

{source-end}


={============================================================================
*kt_dev_code_004* macro: wait on expression or timed out 

XXX_ASSERT_WITHIN_TIMEOUT( future.isComplete(), TEST_TIMEOUT);

/**
 * Unit test assertion macro to check that an expression becomes true in the
 * given time.
 *
 * It polls every 100ms
 */
#define ZINC_ASSERT_WITHIN_TIMEOUT(expression, timeoutms) \
    do { \
        bool success = false; \
        for (int _assert_within_timeout_i = 0; \
             _assert_within_timeout_i < (timeoutms+99)/100; \ // note
             ++_assert_within_timeout_i) { \
            if (expression) { \
                success = true; \
                break; \
            } \
            usleep(1000 * 100); \   // note: 100ms since us is 10-6
        } \
        CPPUNIT_ASSERT_MESSAGE( #expression " did not happen within " #timeoutms "ms", success); \
    } \
    while (0);

Why "(timeoutms+99)/100;"?

TEST_TIMEOUT: 1   10    100   101   102   199   200   201   
+99         : 100 109   199   200   201   298   299   300 
/100        : 1   1     1     2     2     2     2     3   

Since it polls at 100ms, to normalize inputs.


={============================================================================
*kt_dev_code_010* asyc: continuation

////////////////////////////////////////
#ifndef ZINC_CONTINUATION_H_
#define ZINC_CONTINUATION_H_

#include "../macros.h"
#include "Future.h"
#include "Promise.h"
#include <boost/noncopyable.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/enable_shared_from_this.hpp>


NS_ZINC_OPEN

/// A CancellationPolicy is a policy of the Continuation.  It controls what
/// happens when the Future produced by a Continuation is cancelled.  The
/// Policy must fulfil the type requirements:
///
/// template <typename Derived>
/// concept CancellationPolicy {
///     // Called when creating the promise.  Should return a functor that
///     // will be called when the promise is cancelled
///     boost::function<void ()> getCancellationCallback(const boost::shared_ptr<Derived>&);
///     // Will be called when any future is registered with the Continuation
///     // via c.continueOnSuccess() or c.continueOn().
///     template <typename FutureLike> void onAddFuture(const FutureLike&);
///     // Called when any of the futures added with onAddFuture completes
///     void onFutureComplete();
/// };
namespace CancellationPolicy {

/// Cancel all outstanding Futures
template <typename Derived> struct CancelOutstanding;
/// The derived class must define an onCancel functor which will be called
/// when the future is cancelled
template <typename Derived> struct UserProvided;
/// Do nothing.  This is the default and has the least overhead.
template <typename Derived> struct Ignore;

} // namespace CancellationPolicy

/// note: good background. asyc calls, asyc callbacks from a thread which can
/// be different for each call. that is, this provides series of calls and
/// sharing data between them (different thread)
///
/// A Continuation simplifies the code you have to write to perform a
/// series of asynchronous calls sequentially (maybe sharing data between the
/// callbacks for each asynchronous call).
///
/// To use, you create a class that performs all the asynchronous requests in
/// sequence. Each instance of your class will behave like a 'single' Future that
/// completes after all of your asynchronous operations have completed. Your
/// class must meet the following requirements:
//
/// note: acts like a sing future since be completed after all async have
/// completed.
//
/// * Inherit from Continuation, providing 2 type parameters:
///
/// ** The return type -- your class will behave like a Future, so if this is
///    string, your class will behave like a Future<string>.
/// ** The type of your class (i.e. you pass the derived type as a type
///    parameter to the base class, a pattern called CRTP).
///
///   note: CRTP?
//
/// * Use member variables to hold any data that needs to be shared between the
///   various asynchronous calls.
///
/// * Implement a "start" method with the following signature:
///     void start();
///
///   note: arguments of start() matches up with one of create() and create()
///   calls starts(). create is 'static' function.
///
///   "start" must kick off the first asynchronous call by calling
///   Continuation::continueOnSuccess, passing in a pointer-to-member to the
///   method that will handle the 'result' (let's call it "next"). "next" MUST
///   be a method belonging to this same class, taking a single parameter of
///   the raw type "T" returned by the asynchronous call (NOT a
///   FutureValue<T>). "next" will only be invoked if the asynchronous call was
///   successful. "next" will, in turn, kick off another asynchronous call by
///   calling Continuation::continueOnSuccess. See the example usage below.
///
/// * Implement an "onError" method with the following signature:
///     void onError(const ErrorCode& err);
///
///   This will be called if *any* of the asynchronous calls return an error.
///   Your implementation of this method can choose to end the whole future
///   sequence by returning an error:
///     promise.exception( ... );
///
///   note: means the derived use this protected member to end chain.
///
///   or it can carry on with an alternate asynchronous operation (just make
///   sure that onError won't cause an infinite loop if all asynchronous
///   operations continue to fail).
///
/// * Every callback (method of your class) that you register with
///   Continuation::continueOnSuccess MUST EITHER kick off another
///   asynchronous call (with another call to continueOnSuccess), OR call
///   promise.complete OR promise.error OR promise.exception.
///
/// The user of your class will call "create", which returns a Future. The
/// Promise tied to this Future is accessible to methods of your class, as the
/// protected member "promise".
///
/// == Guarantees: ==
///
/// As long as there is an outstanding callback (set with
/// Continuation::continueOnSuccess) to a method of your class, your class (and thus
/// all its data members) will be kept alive (it won't be destructed). You
/// don't need to hold a shared_ptr to the class yourself (in fact, it is
/// impossible to do so because the Continuation constructor is protected).
///
/// note: ?? shared ptr needs to construct T?
///
/// == CancellationPolicy: ==
///
/// A CancellationPolicy describes what will happen when cancel is called on
/// the future produced by the Continuation.  See
/// CancellationPolicy::CancelOutstanding, CancellationPolicy::Ignore and
/// CancellationPolicy::UserProvided for more information.
///
template <typename FutureT, typename Derived, 
         template<typename> class CancellationPolicyT = CancellationPolicy::Ignore >
class Continuation :
    boost::noncopyable,
    public boost::enable_shared_from_this<Derived>,
    public CancellationPolicyT<Derived>
{
public:
    // Implementation note on ownership:
    //
    // 'create' creates an object of the Derived type using 'make_shared', so
    // that subsequent calls to 'shared_from_this' are allowed. 'create' then
    // calls 'start', which must register a callback using
    // Continuation::continueOnSuccess. This creates a BoundCoroutine object
    // that holds a shared_ptr to the Derived object ('this'). A shared_ptr to
    // the BoundCoroutine object is held by the FutureDispatcher (because we
    // passed it to Future::continueOnSuccess).
    //
    // So by the time we return from 'create', the FutureDispatcher is
    // essentially holding a shared_ptr to 'this', ensuring 'this' isn't
    // destructed until after all outstanding callbacks have been run.
    //
    static Future<FutureT> create(FutureDispatcher& dispatcher);

    template <typename T1>
    static Future<FutureT> create(FutureDispatcher& dispatcher,
                                  const T1& val1);
    template <typename T1, typename T2>
    static Future<FutureT> create(FutureDispatcher& dispatcher,
                                  const T1& val1,
                                  const T2& val2);
    template <typename T1, typename T2, typename T3>
    static Future<FutureT> create(FutureDispatcher& dispatcher,
                                  const T1& val1,
                                  const T2& val2,
                                  const T3& val3);
    template <typename T1, typename T2, typename T3, typename T4>
    static Future<FutureT> create(FutureDispatcher& dispatcher,
                                  const T1& val1,
                                  const T2& val2,
                                  const T3& val3,
                                  const T4& val4);
    template <typename T1, typename T2, typename T3, typename T4, typename T5>
    static Future<FutureT> create(FutureDispatcher& dispatcher,
                                  const T1& val1,
                                  const T2& val2,
                                  const T3& val3,
                                  const T4& val4,
                                  const T5& val5);

    // TODO: Make this protected:
    void onErrorDefault(const ErrorCode& ec);
protected:
    Promise<FutureT> promise;

    typedef Continuation super;
    typedef Derived This;

    /// @param future tied to an asynchronous operation that has already been
    ///        kicked off
    ///
    /// @param callback to be called when the Future completes successfully.
    ///        It must have the signature:
    ///            void callback(Derived&, T)
    ///        or equivalent where T is the value_type of the passed in future.
    ///        Typically this should be a member function of the derived type.
    ///
    ///        If the Future completes with an error, by default the callback
    ///        will not be called, instead the promise that the continuation
    ///        represents be completed with that error (much like exception
    ///        propagation).
    ///
    ///        To customise the behaviour of the error case the user can define
    ///        a member in the derived class:
    ///            void onError(const ErrorCode&);
    ///        If finer grained control is required use Continuation::continueOn
    ///        rather than continueOnSuccess
    template <typename FutureLike, typename SuccessCallbackT>
    void continueOnSuccess(FutureLike& future, SuccessCallbackT callback);

    // Would really like C++0x support here for RValue references:
    template <typename FutureLike, typename SuccessCallbackT>
    void continueOnSuccess(const FutureLike& future, SuccessCallbackT callback);

    /// @param future tied to an asynchronous operation that has already been
    ///        kicked off
    ///
    /// @param callback to be called when the Future completes.
    ///        It must have the signature:
    ///            void callback(Derived&, FutureValue<T>)
    ///
    ///        This is distinct from continueOnSuccess above in that this is called
    ///        with a FutureValue<T> rather than just T, thus allowing finer
    ///        grained control of error conditions.
    template <typename FutureLike, typename CallbackT>
    void continueOn(FutureLike& future, CallbackT callback);

    // Would really like C++0x support here for RValue references:
    template <typename FutureLike, typename CallbackT>
    void continueOn(const FutureLike& future, CallbackT callback);

    /// Returns the dispatch used to initialise the promise.  Must not be used
    /// in the derived constructor as the internal reference will not be
    /// initialised
    FutureDispatcher& getDispatcher() const;

    explicit Continuation();
private:
    FutureDispatcher* dispatcher;
};

NS_ZINC_CLOSE

#include "detail/Continuation_Impl.h"

#endif // ZINC_CONTINUATION_H_


////////////////////////////////////////
#ifndef ZINC_SERIAL_FUTURE_GROUP_IMPL_H_
#define ZINC_SERIAL_FUTURE_GROUP_IMPL_H_

#include "ContinuationLike.h"
#include <functional>
#include <boost/foreach.hpp>
#include <boost/make_shared.hpp>
#include <deque>

NS_ZINC_OPEN

namespace {

// Convenience functor adapter for Continuations.
//
// Instead of setting a callback that handles a FutureValue<RawValue>,
// Continuations can use this to wrap a callback that handles a RawValue.
//
// The Continuations must implement the following method that will be called
// if the FutureValue returns an error:
//   void onError(const ErrorCode&);
//
// This object (let's call it f) holds a reference to the Continuation. Since f
// is itself a callback object, as long as a FutureDispatcher holds a reference
// to f as a registered callback, the Continuation won't be released.
//
template <typename ContinuationT, typename FutureT, typename CallbackT>
struct BoundCoroutine
{
    typedef void result_type;
    // CallbackT signature: void (ContinuationT*, FutureT);
    BoundCoroutine(boost::shared_ptr<ContinuationT> fg, CallbackT cb)
        : fg(fg), cb(cb)
    {}
    void operator()(FutureValue<FutureT>& val) {
        try {
            // So we can call ptr-to-member as if it were a functor
            boost::bind(cb, _1, _2)(*fg, val);
        }
        catch (std::exception& e) {
            detail::OnErrorHandler<ContinuationT>::call(*fg, copyException(e));
        }
    }
    void operator()(const FutureValue<FutureT>& val) {
        try {
            // So we can call ptr-to-member as if it were a functor
            boost::bind(cb, _1, _2)(*fg, val);
        }
        catch (std::exception& e) {
            detail::OnErrorHandler<ContinuationT>::call(*fg, copyException(e));
        }
    }
    boost::shared_ptr<ContinuationT> fg; // To keep it alive and to call onError.
    CallbackT cb;
};

} // unnamed namespace

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
Future<FutureT> Continuation<FutureT, Derived, CancellationPolicyT>::create(
    FutureDispatcher& dispatcher)
{
    // d must be created in a shared_ptr, so that shared_from_this() works
    // correctly. By the time we return, as long as "start" called
    // "continueOnSuccess" the FutureDispatcher will also hold a reference to d,
    // so d won't be destroyed until all Futures have completed.
    boost::shared_ptr<Derived> d = boost::make_shared<Derived>();
    Continuation<FutureT, Derived, CancellationPolicyT>* This = d.get();
    // Must set the cancellation handler
    This->dispatcher = &dispatcher;
    Promise<FutureT>(dispatcher, This->getCancellationCallback(d)).swap(This->promise);
    d->start();
    return This->promise.getFuture();
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename T1>
Future<FutureT> Continuation<FutureT, Derived, CancellationPolicyT>::create(
    FutureDispatcher& dispatcher,
    const T1& val1)
{
    boost::shared_ptr<Derived> d = boost::make_shared<Derived>();
    Continuation<FutureT, Derived, CancellationPolicyT>* This = d.get();
    // Must set the cancellation handler
    This->dispatcher = &dispatcher;
    Promise<FutureT>(dispatcher, This->getCancellationCallback(d)).swap(This->promise);
    d->start(val1);
    return This->promise.getFuture();
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename T1, typename T2>
Future<FutureT> Continuation<FutureT, Derived, CancellationPolicyT>::create(
    FutureDispatcher& dispatcher,
    const T1& val1,
    const T2& val2)
{
    boost::shared_ptr<Derived> d = boost::make_shared<Derived>();
    Continuation<FutureT, Derived, CancellationPolicyT>* This = d.get();
    // Must set the cancellation handler
    This->dispatcher = &dispatcher;
    Promise<FutureT>(dispatcher, This->getCancellationCallback(d)).swap(This->promise);
    d->start(val1, val2);
    return This->promise.getFuture();
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename T1, typename T2, typename T3>
Future<FutureT> Continuation<FutureT, Derived, CancellationPolicyT>::create(
    FutureDispatcher& dispatcher,
    const T1& val1,
    const T2& val2,
    const T3& val3)
{
    boost::shared_ptr<Derived> d = boost::make_shared<Derived>();
    Continuation<FutureT, Derived, CancellationPolicyT>* This = d.get();
    // Must set the cancellation handler
    This->dispatcher = &dispatcher;
    Promise<FutureT>(dispatcher, This->getCancellationCallback(d)).swap(This->promise);
    d->start(val1, val2, val3);
    return This->promise.getFuture();
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename T1, typename T2, typename T3, typename T4>
Future<FutureT> Continuation<FutureT, Derived, CancellationPolicyT>::create(
    FutureDispatcher& dispatcher,
    const T1& val1,
    const T2& val2,
    const T3& val3,
    const T4& val4)
{
    boost::shared_ptr<Derived> d = boost::make_shared<Derived>();
    Continuation<FutureT, Derived, CancellationPolicyT>* This = d.get();
    // Must set the cancellation handler
    This->dispatcher = &dispatcher;
    Promise<FutureT>(dispatcher, This->getCancellationCallback(d)).swap(This->promise);
    d->start(val1, val2, val3, val4);
    return This->promise.getFuture();
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename T1, typename T2, typename T3, typename T4, typename T5>
Future<FutureT> Continuation<FutureT, Derived, CancellationPolicyT>::create(
    FutureDispatcher& dispatcher,
    const T1& val1,
    const T2& val2,
    const T3& val3,
    const T4& val4,
    const T5& val5)
{
    boost::shared_ptr<Derived> d = boost::make_shared<Derived>();
    Continuation<FutureT, Derived, CancellationPolicyT>* This = d.get();
    // Must set the cancellation handler
    This->dispatcher = &dispatcher;
    Promise<FutureT>(dispatcher, This->getCancellationCallback(d)).swap(This->promise);
    d->start(val1, val2, val3, val4, val5);
    return This->promise.getFuture();
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename FutureLike, typename CallbackT>
void Continuation<FutureT, Derived, CancellationPolicyT>::continueOnSuccess(
    FutureLike& future, CallbackT callback)
{
    continueOn(future, detail::adaptForHappyPath(callback));
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename FutureLike, typename CallbackT>
void Continuation<FutureT, Derived, CancellationPolicyT>::continueOnSuccess(
    const FutureLike& future, CallbackT callback)
{
    continueOn(future, detail::adaptForHappyPath(callback));
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename FutureLike, typename CallbackT>
void Continuation<FutureT, Derived, CancellationPolicyT>::continueOn(
    FutureLike& future, CallbackT callback)
{
    future.setCallback(
        *dispatcher,
        BoundCoroutine<Derived, typename FutureLike::value_type, CallbackT>(
            boost::enable_shared_from_this<Derived>::shared_from_this(),
            callback));
    CancellationPolicyT<Derived>::onAddFuture(future);
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
template <typename FutureLike, typename CallbackT>
void Continuation<FutureT, Derived, CancellationPolicyT>::continueOn(
    const FutureLike& future, CallbackT callback)
{
    // Really it would be good if this took an RValue reference rather than
    // const ref but we just have to rely on it either being an LValue or
    // a copyable RValue :(
    FutureLike mutableCopy = future;
    continueOn(mutableCopy, callback);
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
Continuation<FutureT, Derived, CancellationPolicyT>::Continuation()
 : dispatcher(NULL)
{
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
void Continuation<FutureT, Derived, CancellationPolicyT>::onErrorDefault(const ErrorCode& ec)
{
    try {
        promise.error(ec);
    }
    catch (PromiseAlreadyCompleted&) {
    }
}

template <typename FutureT, typename Derived, template<typename> class CancellationPolicyT>
FutureDispatcher& Continuation<FutureT, Derived, CancellationPolicyT>::getDispatcher() const
{
    return *dispatcher;
}

namespace detail {

/// Functor adaptor holding a weak reference to the bound argument.  The
/// adapted functor will only be called if the argument is still alive. This
/// is used to implement CancellationFunctors where you don't want completed
/// futures keeping your continuation alive.
///
/// Use bindWeak(Functor, shared_ptr<T>) to use this class
template <typename Functor, typename T>
struct CallIfAlive {
    CallIfAlive(Functor f_, boost::weak_ptr<T> p_)
     : p(p_), f(f_) {
    }
    void operator()() {
        boost::shared_ptr<T> strong = p.lock();
        if (strong) {
            f(strong.get());
        }
    }
    boost::weak_ptr<T> p;
    Functor f;
};

template <typename T, typename Functor>
CallIfAlive<Functor, T> bindWeak(Functor f, boost::shared_ptr<T> p)
{
    return CallIfAlive<Functor, T>(f, p);
}

} // namespace detail

namespace CancellationPolicy {

template <typename Derived>
struct CancelOutstanding {
    static void callMostDerivedCancel(Derived* p) {
        p->onCancel();
    }
    CancelOutstanding(unsigned flags_ =
                                 cancel_flag::clear_callback |
                                 cancel_flag::deep |
                                 cancel_flag::immediately)
     : flags(flags_)
    {
    }
    boost::function<void ()> getCancellationCallback(const boost::shared_ptr<Derived>& derived) {
        boost::shared_ptr<Derived> weakThis(derived);
        return boost::function<void ()>(detail::bindWeak(callMostDerivedCancel, weakThis));
    }
    void onCancel() {
        std::deque<boost::function<void (unsigned flags)> > stackFutures;
        {
            boost::mutex::scoped_lock lock(m);
            stackFutures.swap(outstandingFutures);
        }
        BOOST_FOREACH(const boost::function<void (unsigned flags)>& fn, stackFutures) {
            fn(flags);
        }
        stackFutures.clear();
    }
    template <typename FutureLike>
    void onAddFuture(const FutureLike& f) {
        boost::mutex::scoped_lock lock(m);
        outstandingFutures.push_back(boost::bind(&FutureLike::cancel, f, _1));
    }
    void onFutureComplete() {
        boost::mutex::scoped_lock lock(m);
        if (outstandingFutures.size() == 1) {
            outstandingFutures.clear();
        }
    }
    boost::mutex m;
    std::deque<boost::function<void (unsigned flags)> > outstandingFutures;
    unsigned flags;
};

template <typename Derived>
struct UserProvided {
    boost::function<void ()> getCancellationCallback(const boost::shared_ptr<Derived>& derived) {
        return boost::function<void ()>(detail::bindWeak(std::mem_fun(&Derived::onCancel), derived));
    }
    template <typename FutureLike>
    void onAddFuture(const FutureLike&) {
    }
    void onFutureComplete() {
    }
};

template <typename Derived>
struct Ignore {
    boost::function<void ()> getCancellationCallback(const boost::shared_ptr<Derived>&) {
        // This is passed as the cancellationCallback parameter to the promises
        // created by Continuation.  This works by relying on an implementation
        // detail of Promise, namely that it will not call default initialised
        // boost functors.
        return boost::function<void ()>();
    }
    template <typename FutureLike>
    void onAddFuture(const FutureLike&) {
    }
    void onFutureComplete() {
    }
};

} // namespace CancellationPolicy

NS_ZINC_CLOSE

#endif // ZINC_SERIAL_FUTURE_GROUP_IMPL_H_


={============================================================================
*kt_dev_code_011* asyc: flow between future, promise, and io_service

Client

    ^
    |

class FutureValueBase
   + boost::intrusive_ptr<detail::FutureContextCommonImpl > context;

class FutureValue<T> : class FutureValueBase

    ^
    |

// Since Future is from Promise::getFuture, Future has FC from Promise.

class FutureBase
   + boost::intrusive_ptr<detail::FutureContextCommonImpl > context;

class Future<T> : public FutureBase
   + void setCallback(Dispatcher& dispatcher_, const Handler& fn);
   + FutureValue<T> getFutureValue();

    ^
    |

class FutureContextBase : noncopyable
   + FutureDispatcher* dispatcher;
   + void scheduleCallback()
   + virtual bool dispatchNextResult() = 0;

class FutureContextCommonImpl: class FutureContextBase 
   + void setCallbackHoisted(boost::function<void (FutureContextBase*)> fn, 
            FutureDispatcher* clientDispatcher_);

   + boost::function<void (FutureContextBase*)> completionHandler;

class FutureContext<T> : public FutureContextCommonImpl
   + T value
   + template <typename Handler>
      void setCallback(const Handler& fn, FutureDispatcher* clientDispatcher_);

    ^
    |

class PromiseBase : boost::noncopyable
   + boost::intrusive_ptr<detail::FutureContextCommonImpl> context;

class Promise<T> : public PromiseBase
   + Promise(); note create FutureContext<T>
   + Future<T> getFuture(); note create Future<T>(&FC);
   + void complete(typename const_param<T>::type);


<how-it-works>

1. when creates a promise, associated value, FC gets created with dispatcher

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_) :
   PromiseBase( new detail::FutureContext<T>(&dispatcher_) )
{
}


2. set a pointer in promise which links to FC.

PromiseBase::PromiseBase(detail::FutureContextCommonImpl* p)
 : context(p)
{
    if (context.get())
    {
        ++context->promiseCount;
    }
}


3. when complete() is called, calls set() on FC. see copy of value

template<typename T>
inline void Promise<T>::complete(typename const_param<T>::type value)
{
    getContext().set(value);
}


4. FC copy value from puture, call scheduleCallback().

/**
 * Type specific completion code called from Promise::complete()
 *
 * Take a copy of the result from the Promise and stash it in FutureContext,
 * complete() marks this FutureContext as completed, and post() hands
 * it over to the dispatcher
 *
 * @see FutureContextBase::complete()
 * @see FutureContextBase::post()
 */
void set(const T & result)
{
    boost::mutex::scoped_lock lock;
    if (runPreSetChecksAndLock(lock)) {
        value = result;
    }
    doPostSetActionsAndUnlock(lock);
}

void FutureContextCommonImpl::doPostSetActionsAndUnlock(boost::mutex::scoped_lock& lock)
{
    assert(lock.owns_lock());
    bool wasCompleted = completed;
    bool oldForDispatch = forDispatch;
    completed = true;
    lock.unlock();
    if (!wasCompleted) {
        cond.notify_all();
        if (oldForDispatch && clientDispatcher) {

            scheduleCallback();
        }
    }
}


5. post to dispatcher.

void FutureContextBase::scheduleCallback()
{
    assert(clientDispatcher);
    boost::intrusive_ptr<FutureContextBase> ip(this);
    clientDispatcher->post(boost::bind(&FutureContextBase::dispatchNextResult, ip));
    cond.notify_all();
}


6. call back from io_service?

bool FutureContextCommonImpl::dispatchNextResult()
{
    boost::mutex::scoped_lock lock(mutex);

    // NOTE: We always want to come into this method and null the callback when we're done,
    // even if canceled.

    if (completed && shouldCallCompletionHandler && completionHandler)
    {
        // Release the work object at the end of this scope
        Dispatcher::work w;
        w.swap(this->work);

        // Don't hold locks when calling user code
        boost::function<void (FutureContextBase*)> stackCompletionHandler;
        stackCompletionHandler.swap(completionHandler);
        lock.unlock();
        stackCompletionHandler(this);
    }

    return false;
}


={============================================================================
*kt_dev_code_012* asyc: future

 * FutureContextBase.h
 * FutureContextBase.cpp
 * FutureContext.h
 * FutureContext.cpp
 * Future_Decl.h
 * Future_Impl.h
 * FutureValues.h
 * FutureValue_Impl.h
 * FutureDispatcher.h


<future-dispatcher>
////////////////////////////////////////
/*
 * FutureDispatcher.h
 */
#ifndef ZINC_FUTUREDISPATCHER_H_
#define ZINC_FUTUREDISPATCHER_H_

#include "Dispatcher.h"

NS_ZINC_OPEN

// For backwards compatibility.
typedef Dispatcher FutureDispatcher;

NS_ZINC_CLOSE

#endif /* ZINC_FUTUREDISPATCHER_H_ */


<future-context>
////////////////////////////////////////
/*
 * FutureContextBase.h
 */
#ifndef ZINC_FUTURECONTEXTBASE_H_
#define ZINC_FUTURECONTEXTBASE_H_

#include "../macros.h"

#include "../error/Error.h"
#include "FutureDispatcher.h"
#include <boost/intrusive_ptr.hpp>
#include <boost/noncopyable.hpp>
#include <boost/smart_ptr/detail/atomic_count.hpp>
#include <boost/thread/mutex.hpp>
#include <boost/thread/condition.hpp>
#include <boost/function.hpp>
#include "../MonotonicClock.h"

NS_ZINC_OPEN

/**
 * This class provides context to a dispatcher about async function calls
 *
 * Intrusively reference counted by Futures, Promises, and FutureDispatchers
 * The intrusive_ptr implementation keeps the size of client facing objects
 * Future<T>, Promise<T>, FutureValue<T>, Chunk<T> small
 *
 */

// note:
// has pure virtual functions and template functions which has implementations.

class ZINC_EXPORT FutureContextBase : boost::noncopyable
{
public:

    virtual ~FutureContextBase();

    virtual bool dispatchNextResult() = 0;

    virtual void dispatchCancellation() = 0;

    /**
     * Wait for this async op to complete
     */
    void wait();

    /**
     * Wait for this async op to complete, with a time out
     * specified with a time duration
     *
     * @see Future<T>::wait_for()
     */
    template<typename duration_type>
        bool wait_for(const duration_type &rel_time)
        {
            monotonic_clock::time_point abs_time = monotonic_clock::now() + rel_time;
            return wait_until(abs_time);
        }

    /**
     * Wait for this async op to complete, with a time out
     * specified with a time point
     *
     * @see Future<T>::wait_until()
     */
    template<typename time_point_type>
        bool wait_until(const time_point_type &abs_time)
        {
            boost::mutex::scoped_lock lock(mutex);
            while (!completed)
            {
                const bool signalled = cond.wait_until(lock, abs_time);
                if (!signalled && !completed)
                    return false; // we timed out, without a completion and without a cancellation
            }
            return true;
        }

    /**
     * Does the moral equivalent to
     *     dispatcher.post(bind(FutureContextBase::dispatchNextResult, this));
     *
     * WARNING: dispatchNextResult may be called synchronously and
     *          re-entrantly by this function.
     */
    void scheduleCallback();

    void scheduleCancellationCallback();

protected:

    explicit FutureContextBase(NS_ZINC::FutureDispatcher* dispatcher_);

    /**
     * Mark this future as having a completion handler
     *
     * Must be called with the future locked
     */
    void markCallback();

public:
    boost::detail::atomic_count refCount;
    boost::detail::atomic_count promiseCount;
public:
    bool completed;
    FutureDispatcher* dispatcher;
    FutureDispatcher* clientDispatcher;
    static boost::condition_variable cond;
    static boost::mutex mutex;
private:
    FutureContextBase(); // forbid default construction
};

void intrusive_ptr_add_ref(NS_ZINC::FutureContextBase * p) ZINC_EXPORT;
void intrusive_ptr_release(NS_ZINC::FutureContextBase * p) ZINC_EXPORT;

NS_ZINC_CLOSE

#endif /* ZINC_FUTURECONTEXTBASE_H_ */


////////////////////////////////////////
/*
 * FutureContextBase.cpp
 */
#include "../../include/macros.h"
#include "../../include/async/FutureContextBase.h"
#include "../../include/async/FutureDispatcher.h"
#include "../../include/async/async-exceptions.h"
#include "../../include/async/cancel_flag.h"

#include <boost/bind.hpp>

NS_ZINC_OPEN

// note: Q: initialize public members outside of class?

boost::mutex FutureContextBase::mutex;
boost::condition_variable FutureContextBase::cond((zinc::monotonic_clock()));

FutureContextBase::FutureContextBase(NS_ZINC::FutureDispatcher* dispatcher_) :
    refCount(0),
    promiseCount(0),
    completed(false),
    dispatcher(dispatcher_),
    clientDispatcher(dispatcher_)
{}

FutureContextBase::~FutureContextBase()
{
    assert(refCount == 0);
    assert(promiseCount == 0);
}

/**
 * Block until this future is completed or it is cancelled
 */
void FutureContextBase::wait()
{
    boost::mutex::scoped_lock lock(mutex);
    while (!completed)
    {
        cond.wait(lock);
    }
}

// note: <set-callback>
void FutureContextBase::scheduleCallback()
{
    assert(clientDispatcher);
    boost::intrusive_ptr<FutureContextBase> ip(this);
    clientDispatcher->post(boost::bind(&FutureContextBase::dispatchNextResult, ip));
    cond.notify_all();
}

void FutureContextBase::scheduleCancellationCallback()
{
    assert(dispatcher);
    boost::intrusive_ptr<FutureContextBase> ip(this);
    dispatcher->post(boost::bind(&FutureContextBase::dispatchCancellation, ip));
}

// NOTE: These two functions are deliberately out-of-line, so they can be overridden
// by FutureMemoryTest
//
void intrusive_ptr_add_ref(NS_ZINC::FutureContextBase * p)
{
    ++p->refCount;
}

void intrusive_ptr_release(NS_ZINC::FutureContextBase * p)
{
    int c = --p->refCount;
    if (c == 0)
    {
        delete p;
    }
}

NS_ZINC_CLOSE


////////////////////////////////////////
/*
 * FutureContext.h
 */
#ifndef ZINC_FUTURECONTEXT_H_
#define ZINC_FUTURECONTEXT_H_

#include "../FutureContextBase.h"
#include "../FutureDispatcher.h"
#include "future_enums.h"
#include "../FutureDispatcher.h"

#include <boost/function.hpp>
#include <boost/bind.hpp>

NS_ZINC_OPEN

template <typename T> class FutureValue;

namespace detail {

template <typename T> class FutureContext;

class ZINC_EXPORT FutureContextCommonImpl : public NS_ZINC::FutureContextBase
{
public:
    ~FutureContextCommonImpl();

    explicit FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_);
    explicit FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_, 
            boost::function<void ()> cancellationCallback_);

    void cancel(unsigned flags);
    void completeError(const NS_ZINC::ErrorCode& error_);

protected:
    void setCallbackHoisted(boost::function<void (FutureContextBase*)> fn, 
            FutureDispatcher* clientDispatcher_);
    bool runPreSetChecksAndLock(boost::mutex::scoped_lock& lock);
    void doPostSetActionsAndUnlock(boost::mutex::scoped_lock& lock);

    void doPost();
public:
    /**
     * This gets called by the FutureDispatcher implementation
     *
     * @return true if there are more values to come, or false if there are no
     * more values
     */
    bool dispatchNextResult();

    void dispatchCancellation();

    bool forDispatch;
    Dispatcher::work work;

    // The state of the FutureValue is replicated here and in FutureValue
    // itself.  This is to keep FutureValues immutable, but allow cancel()
    // to override the value from calls to getFutureValue in the future.
    futurevalue_state::Enum futurevalueState;

    bool shouldCallCompletionHandler;

    // note: 
    boost::function<void (FutureContextBase*)> completionHandler;
    NS_ZINC::ErrorCode error;

    // The state of the promise and the future can evolve semi-independently
    promise_state::Enum promiseState;
    bool callCancellationCallback;
    boost::function<void ()> cancellationCallback;
};

/**
 * This class is responsible for allowing type erasing the precise type of the
 * callback passed to FutureContext<T>::setCallback such that it can be called
 * from the base class FutureContextCommonImpl.  It down-casts the provided
 * pointer from the base class to un-type-erase the hoisted base class.
 *
 * We don't want to bind a FutureValue into the callback when we get it as the
 * FutureValue holds a reference to the FutureContext, creating a circular
 * reference and thus memory leaks.  We use this wrapper to create the
 * FutureValue at invocation time.  This has the pleasant side-effect of being
 * more efficient also.
 */
template<typename T, typename Functor>
struct ZINC_LOCAL CallbackHoistingWrapper {
	typedef void result_type;
	CallbackHoistingWrapper(Functor f_)
	 : f(f_) {
	}
	void operator()(FutureContextBase* that) {
		// We must compare by name rather than using a dynamic_cast because
		// dynamic_cast can fail if the typeinfo for FutureContext<T> is in more
		// than one .so
		assert(std::strcmp(typeid(FutureContext<T>).name(), typeid(*that).name()) == 0);
		f(FutureValue<T>(static_cast<FutureContext<T>*>(that)));
	}
	Functor f;
};

template<typename T, typename Functor>
CallbackHoistingWrapper<T, Functor> makeCallbackHoistingWrapper(const Functor& f) {
	return CallbackHoistingWrapper<T, Functor>(f);
}

/**
 * A context object for Futures
 * FutureContext holds a single value passed from a providing Promise and the
 * client Future and (if set) a completionHandler that is called by the
 * dispatcher when the value is available
 */

template <typename T>
class FutureContext : public FutureContextCommonImpl
{
public:

    explicit FutureContext(NS_ZINC::FutureDispatcher* dispatcher_)
        : FutureContextCommonImpl(dispatcher_)
    {}

    explicit FutureContext(NS_ZINC::FutureDispatcher* dispatcher_, 
            boost::function<void ()> cancellationCallback_)
        : FutureContextCommonImpl(dispatcher_, cancellationCallback_)
    {}

    // note:
    
    /**
     * Type specific completion code called from Promise::complete()
     *
     * Take a copy of the result from the Promise and stash it in FutureContext,
     * complete() marks this FutureContext as completed, and post() hands
     * it over to the dispatcher
     *
     * @see FutureContextBase::complete()
     * @see FutureContextBase::post()
     */
    void set(const T & result)
    {
        boost::mutex::scoped_lock lock;
        if (runPreSetChecksAndLock(lock)) {
            value = result;
        }
        doPostSetActionsAndUnlock(lock);
    }

    // note: <set-callback>
    template <typename Handler>
        void setCallback(const Handler& fn, FutureDispatcher* clientDispatcher_) {
            setCallbackHoisted(boost::function<void (FutureContextBase*)>(
                        makeCallbackHoistingWrapper<T>(boost::bind<void>(fn, _1))),
                    clientDispatcher_
                    );
        }

    T value;
};


/**
 * A context object for Future<void> objects
 * FutureContext holds a single FutureValue<void> object containing any errors
 * passed from Promise and a completion handler to be called when the
 * asynchronous operation is complete No value is passed from Promise to
 * Future
 */

template <>
class FutureContext<void> : public FutureContextCommonImpl
{
public:

    explicit FutureContext(NS_ZINC::FutureDispatcher* dispatcher_) 
        : FutureContextCommonImpl(dispatcher_) {}

    explicit FutureContext(NS_ZINC::FutureDispatcher* dispatcher_, 
            boost::function<void ()> cancellationCallback_)
        : FutureContextCommonImpl(dispatcher_, cancellationCallback_)
    {}

    /**
     * Type specific completion code called from Promise::complete()
     *
     * complete() marks this FutureContext as completed, and post() hands
     * it over to the dispatcher
     *
     * @see FutureContextBase::complete()
     * @see FutureContextBase::post()
     */
    void set()
    {
        boost::mutex::scoped_lock lock;
        runPreSetChecksAndLock(lock);
        doPostSetActionsAndUnlock(lock);
    }

    template <typename Handler>
        void setCallback(const Handler& fn, FutureDispatcher* clientDispatcher_) {

            setCallbackHoisted(

                    boost::function<void (FutureContextBase*)>(
                        makeCallbackHoistingWrapper<void>(boost::bind<void>(fn, _1))
                        ),
                    clientDispatcher_
                    );
        }
};

} // namespace detail

NS_ZINC_CLOSE

#endif


////////////////////////////////////////
/*
 * FutureContext.cpp
 */
#include "../../include/macros.h"
#include "../../include/async/detail/FutureContext.h"
#include "../../include/async/Promise.h"
#include "../../include/async/cancel_flag.h"
#include "../../include/async/async-exceptions.h"
#include "../../include/async/FutureDispatcher.h"
#include "../../include/async/ChunkedFuture.h"

#include <boost/thread/mutex.hpp>
#include <cassert>

NS_ZINC_OPEN

// note:
PromiseBase::PromiseBase(detail::FutureContextCommonImpl* p)
 : context(p)
{
    if (context.get())
    {
        ++context->promiseCount;
    }
}

PromiseBase::PromiseBase(const PromiseBase& p)
: boost::noncopyable(), context(p.context)
{
    if (context.get())
    {
        ++context->promiseCount;
    }
}

PromiseBase::~PromiseBase()
{
	if (context.get() && --context->promiseCount == 0 && !context->completed)
	{
		// We have just dropped the last Promise
		error(ErrorCode(error::BrokenPromiseCode, "Promise never completed"));
	}
}


FutureValueBase::FutureValueBase(const boost::intrusive_ptr<detail::FutureContextCommonImpl> & context_) :
	context(context_),
	state(context_->futurevalueState)
{

}

FutureValueBase::~FutureValueBase() {

}


FutureBase::FutureBase(boost::intrusive_ptr<detail::FutureContextCommonImpl> context_) :
	context(context_)
{

}

FutureBase::FutureBase(const FutureBase& other) :
	context(other.context)
{

}

FutureBase::~FutureBase()
{

}



ChunkedFutureBase::ChunkedFutureBase(boost::intrusive_ptr<FutureContextBase> context_ ) :
	context(context_)
{
}

ChunkedFutureBase::~ChunkedFutureBase()
{
}

ChunkedFutureBase::ChunkedFutureBase(const ChunkedFutureBase& other) :
	context(other.context)
{
}


namespace detail {

FutureContextCommonImpl::FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_)
 : FutureContextBase(dispatcher_),
   forDispatch(false),
   futurevalueState(futurevalue_state::value_or_error),
   shouldCallCompletionHandler(true),
   promiseState(promise_state::incomplete),
   callCancellationCallback(true)
{
}

FutureContextCommonImpl::FutureContextCommonImpl(NS_ZINC::FutureDispatcher* dispatcher_, 
        boost::function<void ()> cancellationCallback_)
 : FutureContextBase(dispatcher_),
   forDispatch(false),
   futurevalueState(futurevalue_state::value_or_error),
   shouldCallCompletionHandler(true),
   promiseState(promise_state::incomplete),
   callCancellationCallback(true),
   cancellationCallback(cancellationCallback_)

{
}

FutureContextCommonImpl::~FutureContextCommonImpl()
{
}

void FutureContextCommonImpl::cancel(unsigned flags)
{
	bool shouldPost = false;
	bool shouldPostCancellation = false;

	boost::mutex::scoped_lock lock(this->mutex);
	callCancellationCallback = flags & cancel_flag::deep;
	if (flags & cancel_flag::clear_callback)
	{
		Dispatcher::work().swap(work);
		shouldCallCompletionHandler = false;
		completionHandler = 0;
	}

	// If there is a deep cancellation callback registered for this
	// async operation then post it to the dispatch queue.
	// Note it is possible that all promises have already gone out of scope
	shouldPostCancellation = cancellationCallback && callCancellationCallback;
	if (flags & cancel_flag::immediately)
	{
		futurevalueState = detail::futurevalue_state::cancelled;
		if (!completed)
		{
			completed = true;
			shouldPost = !!completionHandler;
		}
	}

	// Must not hold the lock when calling post()
	lock.unlock();

	cond.notify_all();

	if (shouldPostCancellation)
	{
		scheduleCancellationCallback();
	}

	if (shouldPost)
	{
		scheduleCallback();
	}
}

void FutureContextCommonImpl::completeError(const NS_ZINC::ErrorCode& error_)
{
	boost::mutex::scoped_lock lock;
	if (runPreSetChecksAndLock(lock)) {
		error = error_;
	}
	doPostSetActionsAndUnlock(lock);
}

// <set-callback>
void FutureContextCommonImpl::setCallbackHoisted(
        boost::function<void (FutureContextBase*)> fn, 
        FutureDispatcher* clientDispatcher_)
{
	// It is safe to read this->clientDispatcher without holding the lock because
	// it is word sized and will only be assigned to at initialisation time and
	// below (where it's guaranteed to be assigned to only once).
	FutureDispatcher* d = clientDispatcher_ ? clientDispatcher_ : this->clientDispatcher;
	if (!d) {
		throw CallbackSetWithoutDispatcherException();
	}
	Dispatcher::work tryWork(*d);

	boost::mutex::scoped_lock lock(this->mutex);

	if (!shouldCallCompletionHandler)
	{
		throw NS_ZINC::CancelledFuture();
	}
	if (forDispatch)
	{
		throw DuplicateFutureCallback();
	}
	// Client can choose an alternate dispatcher when they call setCallback()
	clientDispatcher = d;
	this->work.swap(tryWork);
	completionHandler = fn;
	forDispatch = true; // we are responsible for dispatching the completion handler
	bool oldCompleted = completed;
	lock.unlock();
	if (oldCompleted)
	{
		scheduleCallback();
	}
}

bool FutureContextCommonImpl::runPreSetChecksAndLock(boost::mutex::scoped_lock& lock)
{
	assert(!lock.owns_lock());
	boost::mutex::scoped_lock(this->mutex).swap(lock);
	if (promiseState == promise_state::completed)
	{
		throw PromiseAlreadyCompleted();
	}
	else
	{
		promiseState = promise_state::completed;
	}
	return !completed;
}

// note:
void FutureContextCommonImpl::doPostSetActionsAndUnlock(boost::mutex::scoped_lock& lock)
{
    assert(lock.owns_lock());
    bool wasCompleted = completed;
    bool oldForDispatch = forDispatch;
    completed = true;
    lock.unlock();
    if (!wasCompleted) {
        cond.notify_all();
        if (oldForDispatch && clientDispatcher) {

            scheduleCallback();
        }
    }
}


void FutureContextCommonImpl::dispatchCancellation()
{
	boost::mutex::scoped_lock lock(mutex);

	// NOTE: We always want to come into this method and null the callback when we're done,
	// even if canceled.

	boost::function<void ()> stackCancellationCallback;

	if (callCancellationCallback)
	{
		stackCancellationCallback.swap(cancellationCallback);
		callCancellationCallback = false;
	}

	lock.unlock();

	if (stackCancellationCallback)
	{
		stackCancellationCallback();
	}
}


// note: <set-callback>
bool FutureContextCommonImpl::dispatchNextResult()
{
    boost::mutex::scoped_lock lock(mutex);

    // NOTE: We always want to come into this method and null the callback when we're done,
    // even if canceled.

    if (completed && shouldCallCompletionHandler && completionHandler)
    {
        // Release the work object at the end of this scope
        Dispatcher::work w;
        w.swap(this->work);

        // Don't hold locks when calling user code
        boost::function<void (FutureContextBase*)> stackCompletionHandler;
        stackCompletionHandler.swap(completionHandler);
        lock.unlock();
        stackCompletionHandler(this);
    }

    return false;
}

} //namespace detail

NS_ZINC_CLOSE


////////////////////////////////////////
/*
 * Future_Decl.h
 */
#ifndef ZINC_FUTURE_H_
#define ZINC_FUTURE_H_

#include "../../macros.h"
#include "../cancel_flag.h"
#include "../FutureValue.h"
#include "../../type-traits/check_concept.h"
#include "../../type-traits/call-traits.h"

#include <boost/intrusive_ptr.hpp>
#include <boost/utility/result_of.hpp>

NS_ZINC_OPEN

template <typename T> class Promise;

namespace detail {
template <typename T> class FutureContext;
}

namespace internal {
class PolymorphicFuture;
}

class Dispatcher;

class FutureBase {

    friend class internal::PolymorphicFuture;

    public:

    /**
     * Cancel the Future.
     *
     * This merely prevents the Future ever being fulfilled. If a callback
     * has been set, and not called already, it will not be called.
     *
     * Cancellation may, or may not, cause the underlying asynchronous
     * operation to be canceled. The client should not assume this to be the
     * case.
     *
     * Cancellation may be modified with the flags argument.
     *  * future.cancel(clear_callback) just prevents the
     *    callback set with setCallback from being invoked.
     *  * future.cancel(deep) calls the onCancel handler that may have been
     *    provided promise-side
     *  * future.cancel(immediately) has behaviour equivalent to the Promise
     *    being immediately completed with a CancelledFuture exception.  If the
     *    promise has already been completed calling get() will still cause a
     *    CancelledFuture exception to be thrown.
     *  * future.cancel(0) does nothing.
     */
    void cancel(unsigned flags = cancel_flag::clear_callback |
            cancel_flag::deep |
            cancel_flag::immediately);

    /**
     * Synchronously wait for the value to become available.
     *
     * This will block the calling thread until either the value is available,
     * or an exception occurs.
     *
     * When the caller returns from this call, a subsequent call to get() will not
     * block.
     */
    void wait();

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as a relative time duration
     *
     * eg
     *		Future<int> f = fn_returning_a_future();
     *		f.wait_for(boost::posix_time::milliseconds(500));
     *
     * @param rel_time specifies the time duration to wait for completion
     * @return false if the given time period elapses without completion or cancellation
     * @see wait()
     */
    template<typename duration_type>
        bool wait_for(const duration_type &rel_time);

    /**
     * Synchronously wait for the value to become available, with a timeout
     * specified as an absolute time point
     *
     * Use wait_for() in preference
     *
     * @param abs_time specifies the time point to stop waiting
     * @return false if we reach the given time point without completion or cancellation
     *
     * @see wait()
     * @see wait_for()
     */
    template<typename time_point_type>
        bool wait_until(const time_point_type &abs_time);

    /**
     * Ask if the Future has been completed with a value provided by its Promise
     *
     * A positive response does not guarantee that the callback has yet been executed
     *
     * @return true if this Future has been completed
     */
    bool isComplete();

    /**
     * Has this Future been default constructed?  If so, then it is not useful
     *
     * @see Future<T>::swap
     * @see Promise<T>::getFuture
     *
     * @return false if this Future is valid
     */
    bool isEmpty();


protected:

    explicit FutureBase(boost::intrusive_ptr<detail::FutureContextCommonImpl> context) ZINC_EXPORT;

    FutureBase(const FutureBase& other) ZINC_EXPORT;

    FutureBase() {}

    ~FutureBase() ZINC_EXPORT;

    void baseSwap(FutureBase& other);

    // note:
    boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
};


/**
 * A Future is a token for some value that will be delivered asynchronously.
 *
 * // note:
 * The holder of the Future token may either wait for the value synchronously,
 * (blocking the executing thread), or set a callback method that will be invoked
 * either when the value becomes available, or will not become available due to
 * some exception.
 *
 * The Future holder also has the option to cancel the Future, which will prevent
 * the value from being delivered, assuming this hasn't happened already.
 */

// note: FutureBase is not template

template <typename T>
class Future : public FutureBase
{
  public:
    typedef T value_type;

    Future(const Future & other);

    Future & operator=(const Future & other);

    ~Future();

    /**
     * Provide a default constructor so we can put Futures in
     * STL containers
     *
     * A Future without a Promise is not much use to you,
     * so use Promise.getFuture() instead, or use swap(Future<T> & other)
     * to swap in a valid future
     *
     * @see Promise<T>::getFuture()
     * @see Future<T>::swap(Future<T> & other)
     */
    Future() {}

    /**
     * Set a callback method to be invoked when either the value becomes
     * available, or an exception occurs.
     *
     * The callback will be executed on the dispatcher that was provided to
     * the Promise constructor.
     *
     * @param fn A function that must accept a FutureValue<T> as it's single
     *           argument.
     *
     * @throws DuplicateFutureCallback if a callback has already been set on
     * this Future.
     * @throws CallbackSetWithoutDispatcherException if the corresponding
     *         wasn't initialized with a dispatcher.  Use the two argument
     *         setCallback instead
     */
    template <typename Handler>
      void setCallback(const Handler& fn) {
        // fn(x) must be valid where x is a FutureValue<T>
        ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
        static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, 0);
      }

    /**
     * Set a callback method to be invoked when either the value becomes
     * available, or an exception occurs.
     *
     * The callback will be executed on "the provided dispatcher", rather than the
     * dispatcher used by the Promise.
     *
     * // note: <set-callback>
     * Explicitly providing the dispatcher gives the caller more control over
     * which thread will execute their callback.
     *
     * @param dispatcher_ The dispatcher on which the callback should be executed.
     *
     * @param fn A function that must accept a FutureValue<T> as it's single
     *           argument.
     *
     * @throws DuplicateFutureCallback if a callback has already been set on
     * this Future.
     */
    template <typename Handler>
      void setCallback(Dispatcher& dispatcher_, const Handler& fn) {
        // fn(x) must be valid where x is a FutureValue<T>
        ZINC_CHECK_CONCEPT(LValue<Handler>()(RValue<FutureValue<T> >()));
        static_cast<detail::FutureContext<T>* >(context.get())->setCallback(fn, &dispatcher_);
      }

    /** <future-then>
     * then() allows specifying a Functor to be called once the Future is
     * completed. It is much like Future.setCallback() but for a Future<T>
     * if the functor has the form:
     *
     *     R Functor(FutureValue<T>)
     *
     * then then() will return a 'new' Future of type Future<R> which will
     * be completed when the original Future completes and the functor has
     * operated on the original value. The value/exception contained in the
     * new future will be that returned/thrown from the functor. This makes
     * then() very convenient for 'transforming' the value (and potentially
     * the type) contained within a `Future`.
     *
     * If a dispatcher is provided the functor will be executed on that
     * dispatcher. Otherwise it will be run inline at the point and in the
     * context in which the `Promise` is completed or the setCallback is set
     * (whichever comes later). As the environment in which the functor will
     * be run is unknown and even non-deterministic it is only safe to do
     * the simplest pure-functional transformations in these functors, e.g.
     * translating between exceptions/enum types, etc. Anything dependent on
     * some state may require locking a mutex of similar and to make it
     * deterministic, safe and to avoid unexpected failures as changes are
     * made to other parts of the code the callbacks should be run on a user
     * specified `Dispatcher`.
     *
     * `Future.then()` is a proposed addition to the C++14 standard[1].
     *
     * [1]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3558.pdf
     *
     * Usage Example:
     *
     * @code
     * string boolToYesNo(FutureValue<bool> b) {
     *     try {
     *         return (b.get()?"yes":"no");
     *     } catch (const std::exception& e) {
     *         // translating exception thrown from original future.
     *         throw MyNewException(e.what());
     *     }
     * }
     *
     * Future<bool> answer = isCool();
     *
     * // string boolToYesNo( FutureValue<bool> b)
     * // R      boolToYesNo( FutureValue<T> )
     *
     * Future<string> answerAsString = answer.then(&boolToYesNo);
     *
     * cout << "Cool? " << answerAsString.get() << endl;
     * @endcode
     */
    template<typename Functor>
      Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
          Dispatcher& dispatcher, Functor transformRtoT);
    template<typename Functor>
      Future<typename boost::result_of<Functor(FutureValue<T>)>::type> then(
          Functor transformRtoT);

    /**
     * Synchronously wait for and retrieve the value.
     *
     * This method may throw an exception of any type, in the event that the
     * value could not be retrieved due to an exception in the asynchronous
     * operation producing the value.
     *
     * Equivalent to f.getFutureValue().get();
     *
     * @return the value.
     */
    typename const_return<T>::type get();

    /**
     * Synchronously wait for and retrieve the value.
     *
     * Unlike get() this method does not throw if the promise has been completed
     * with an exception.  This can be used to deal with errors without a try
     * catch block.
     *
     * @return the value.
     */
    FutureValue<T> getFutureValue();

    /**
     * Swap this Future with the one provided
     */
    void swap(Future<T> & other);

  private:
    friend class Promise<T>; // only Promises can create a Future
    explicit Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ );
};

NS_ZINC_CLOSE

#endif /* ZINC_FUTURE_H_ */


////////////////////////////////////////
/*
 * Future_Impl.h
 */
#ifndef ZINC_FUTURE_INL
#define ZINC_FUTURE_INL

#include "FutureContext.h"
#include "../FutureValue.h"
#include "../Dispatcher.h"
#include "../Promise.h"
#include "../InlineDispatcher.h"

NS_ZINC_OPEN

inline void FutureBase::wait()
{
	context->wait();
}

template<typename duration_type>
inline bool FutureBase::wait_for(const duration_type &rel_time)
{
	return context->wait_for(rel_time);
}

template<typename time_point_type>
inline bool FutureBase::wait_until(const time_point_type &abs_time)
{
	return context->wait_until(abs_time);
}

inline bool FutureBase::isComplete()
{
	return context->completed;
}

inline bool FutureBase::isEmpty()
{
	return (context.get() == NULL);
}

inline void FutureBase::cancel(unsigned flags)
{
	context->cancel(flags);
}

inline void FutureBase::baseSwap(FutureBase& other)
{
	using std::swap;
	swap(context, other.context);
}


/**
 * Generic Future definitions
 */
// note: get-future
template<typename T>
inline Future<T>::Future(boost::intrusive_ptr<detail::FutureContext<T> > context_ ) 
    : FutureBase(boost::static_pointer_cast<detail::FutureContextCommonImpl>(context_)) {}

template<typename T>
inline Future<T>::Future(const Future<T>& other) : FutureBase(other) {}

template<typename T>
inline Future<T>::~Future() {}

template<typename T>
inline Future<T>& Future<T>::operator=(const Future<T>& other)
{
	Future<T>(other).swap(*this);
	return *this;
}

// note: get-future-value
template<typename T>
inline FutureValue<T> Future<T>::getFutureValue()
{
    wait();
    return FutureValue<T>(boost::static_pointer_cast<detail::FutureContext<T> >(context));
}

// note: get
template<typename T>
inline typename const_return<T>::type Future<T>::get()
{
   return getFutureValue().get();
}

template<typename T>
inline void Future<T>::swap(Future<T> & other)
{
	 baseSwap(other);
}

/**
 * Future<void> definitions
 */
template<>
inline void Future<void>::get()
{
	wait();
	// get() may throw
	FutureValue<void>(boost::static_pointer_cast<detail::FutureContext<void> >(context)).get();
}

namespace detail {

template<typename T, typename R, typename Functor>
struct DoTransformAndComplete {
    static inline void apply(Promise<R>& promise, Functor& transform, const FutureValue<T>& fv) {
        promise.complete(transform(fv));
    }
};

template<typename T, typename Functor>
struct DoTransformAndComplete<T, void, Functor> {
    static inline void apply(Promise<void>& promise, Functor& transform, const FutureValue<T>& fv) {
        transform(fv);
        promise.complete();
    }
};

template<typename T, typename Functor>
struct TransformAndComplete {

    typedef typename boost::result_of<Functor(FutureValue<T>)>::type R;

    TransformAndComplete(const Functor& f)
     : transform(f) {}

    void operator()(const FutureValue<T>& fv) {
        try {
            DoTransformAndComplete<T, R, Functor>::apply(promise, transform, fv);
        } catch (const std::exception& e) {
            promise.exception(e);
        } catch (...) {
            promise.exception(std::runtime_error("Unknown exception."));
        }
    }

    Promise<R> promise;
    Functor transform;
};

template<typename FutureLike, typename Functor>
Future<typename boost::result_of<Functor(FutureValue<typename FutureLike::value_type>)>::type> futureThen(
        FutureLike& future, Dispatcher& dispatcher, Functor transformTtoR) {

    detail::TransformAndComplete<typename FutureLike::value_type, Functor>
        transformAndComplete(transformTtoR);
    future.setCallback(dispatcher, transformAndComplete);
    return transformAndComplete.promise.getFuture();
}
} // namespace detail

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Dispatcher& dispatcher, Functor transformTtoR) {

    return detail::futureThen(*this, dispatcher, transformTtoR);
}

template<typename T>
template<typename Functor>
Future<typename boost::result_of<Functor(FutureValue<T>)>::type> Future<T>::then(
        Functor transformTtoR) {

    return then(InlineDispatcher::sharedInstance(), transformTtoR);
}

NS_ZINC_CLOSE

#endif


////////////////////////////////////////
/*
 * FutureValues.h
 */
#ifndef ZINC_FUTUREVALUE_H_
#define ZINC_FUTUREVALUE_H_

#include "../macros.h"
#include "detail/future_enums.h"
#include "../error/Error.h"
#include "../error/ExceptionConverter.h"
#include "../type-traits/call-traits.h"
#include "../type-traits/has_operator.h"
#include <boost/intrusive_ptr.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/noncopyable.hpp>

NS_ZINC_OPEN

namespace detail {

template <typename T> class FutureContext;
template<typename T, typename Functor> struct CallbackHoistingWrapper;
class FutureContextCommonImpl;

}

template <typename T> class Future;
template <typename T> class FutureValue;

template<typename T>
FutureValue<T> makeFutureValue(typename const_param<T>::type);

FutureValue<void> makeFutureValue();

template<typename T>
FutureValue<T> makeFutureValueError(const ErrorCode& val);

template<typename T, typename Exception>
FutureValue<T> makeFutureValueException(const Exception& exception);

namespace internal {
class PolymorphicFutureValue;
}

class FutureValueBase
{
    friend class internal::PolymorphicFutureValue;

    public:

    /**
     * Retrieve exception as an ErrorCode.
     *
     * In the success case, there will be no exception so this method will
     * return a default-constructed ErrorCode, where the not operator (!) will
     * return true.  So, you can test whether an error occurred by doing:
     *
     *     if (!futureValue.getError()) { // no error }
     *
     * @return an ErrorCode wrapper around the exception that occurred in the
     * asynchronous operation.
     */
    const ErrorCode& getError() const;

    protected:

    explicit FutureValueBase(
            const boost::intrusive_ptr<detail::FutureContextCommonImpl> & context) ZINC_EXPORT;

    ~FutureValueBase() ZINC_EXPORT;

    boost::intrusive_ptr<detail::FutureContextCommonImpl > context;
    detail::futurevalue_state::Enum state;
};

/**
 * This class is used with a Future/Promise pair.
 *
 * It is used to communicate a response value or exception to the 'caller' of
 * an asynchronous method.
 *
 * FutureValue is either unset, set with a valid value, or set with an error
 */
template <typename T>
class FutureValue : public FutureValueBase
{
    public:

        ~FutureValue() {}

        /**
         * Retrieve the value.
         *
         * This method may throw an exception of any type if there was an
         * exception in the underlying asynchronous operation.
         *
         * @return the held value.
         */
        typename const_return<T>::type get() const;

        /**
         * Steals the value.
         *
         * Prefer this method if T is expensive to copy and you don't intend to
         * reuse the FutureValue. The held value will be transferred into the
         * provided destination.
         *
         * WARNING: This is a destructive operation which should only be called
         * once.
         *
         * @param sv the destination.
         */
        void steal(T& sv);

    private:

        explicit FutureValue(detail::FutureContext<T> * context);
        explicit FutureValue(const boost::intrusive_ptr<detail::FutureContext<T> > & context);

        friend class Future<T>;
        friend class detail::FutureContextCommonImpl;
        friend class detail::FutureContext<T>;
        friend FutureValue<T> makeFutureValueError<T>(const ErrorCode& val);
        friend FutureValue<void> makeFutureValue();
        template<typename V, typename Functor> friend struct detail::CallbackHoistingWrapper;
        template<typename V> friend FutureValue<V> makeFutureValue(typename const_param<V>::type);
};


template<>
class FutureValue<void> : public FutureValueBase
{
    public:

        ~FutureValue() {}

        /**
         * Retrieve status of the operation.
         *
         * This method may throw an exception of any type if there was an exception
         * in the underlying asynchronous operation.
         *
         * @return the held value.
         */
        void get() const;

    private:

        explicit FutureValue(detail::FutureContext<void> * context);
        explicit FutureValue(const boost::intrusive_ptr<detail::FutureContext<void> > & context);

        friend class Future<void>;
        friend class detail::FutureContextCommonImpl;
        friend class detail::FutureContext<void>;
        friend FutureValue<void> makeFutureValueError<void>(const ErrorCode& val);
        friend FutureValue<void> makeFutureValue();
        template<typename V, typename Functor> friend struct detail::CallbackHoistingWrapper;
        template<typename V> friend FutureValue<V> makeFutureValue(typename const_param<V>::type);
};

template <typename T>
typename boost::enable_if<has_equals<T>, bool>::type operator==(const FutureValue<T>& a, const FutureValue<T>& b);

NS_ZINC_CLOSE;

#include "detail/FutureValue_Impl.h"

#endif /* ZINC_FUTUREVALUE_H_ */


////////////////////////////////////////
/*
 * FutureValue_Impl.h
 */
#ifndef ZINC_FUTUREVALUE_IMPL_H_
#define ZINC_FUTUREVALUE_IMPL_H_

#include "../../macros.h"
#include "../../type-traits/call-traits.h"
#include "FutureContext.h"
#include "../async-exceptions.h"
#include "../../error/ExceptionConverter.h"
#include "../FutureValue.h"

#include <algorithm> // for std::swap()

#ifndef NDEBUG
#include <ostream>
#endif // !NDEBUG

NS_ZINC_OPEN

inline const ErrorCode& FutureValueBase::getError() const
{
	if (state == detail::futurevalue_state::value_or_error)
	{
		return context->error;
	}
	else
	{
		static ErrorCode cancelledCode(error::CancelledFutureCode);
		return cancelledCode;
	}
}


template<typename T>
inline FutureValue<T>::FutureValue(detail::FutureContext<T> * context_)
	: FutureValueBase(context_)
{
}

inline FutureValue<void>::FutureValue(detail::FutureContext<void> * context_)
	: FutureValueBase(context_)
{
}


template<typename T>
inline FutureValue<T>::FutureValue(const boost::intrusive_ptr<detail::FutureContext<T> > & context_)
 :  FutureValueBase(context_)
{
}

inline FutureValue<void>::FutureValue(const boost::intrusive_ptr<detail::FutureContext<void> > & context_)
 :  FutureValueBase(context_)
{
}

template<typename T>
inline typename const_return<T>::type FutureValue<T>::get() const
{
	if (state == detail::futurevalue_state::cancelled)
	{
		throw CancelledFuture();
	}
	else if (context->error)
	{
		NS_ZINC::rethrowException(context->error);
		ZINC_UNREACHABLE;
	}
	else
	{
		return static_cast<detail::FutureContext<T>*>(context.get())->value;
	}
}

// void specialization

inline void FutureValue<void>::get() const
{
	if (state == detail::futurevalue_state::cancelled)
	{
		throw CancelledFuture();
	}
	else if (context->error)
	{
		NS_ZINC::rethrowException(context->error);
	}
}

template<typename T>
inline void FutureValue<T>::steal(T& sv) {

	if (state == detail::futurevalue_state::cancelled)
	{
		throw CancelledFuture();
	}
	else if (context->error)
	{
		NS_ZINC::rethrowException(context->error);
		ZINC_UNREACHABLE;
	}
	else
	{
		detail::FutureContext<T>* ctx = static_cast<detail::FutureContext<T>*>(context.get());

		// Note: we use swap() for now. Later we might use move.
		using std::swap;
		swap(sv, ctx->value);
		T tmp = T();
		swap(tmp, ctx->value);
	}
}

template<typename T>
FutureValue<T> makeFutureValue(typename const_param<T>::type val)
{
    detail::FutureContext<T>* fc = new detail::FutureContext<T>(NULL);
    FutureValue<T> f(fc);
    fc->set(val);
    return f;
}

inline FutureValue<void> makeFutureValue()
{
    detail::FutureContext<void>* fc = new detail::FutureContext<void>(NULL);
    FutureValue<void> f(fc);
    fc->set();
    return f;
}

template<typename T>
FutureValue<T> makeFutureValueError(const ErrorCode& val)
{
    detail::FutureContext<T>* fc = new detail::FutureContext<T>(NULL);
    FutureValue<T> f(fc);
    fc->completeError(val);
    return f;
}

template<typename T, typename Exception>
FutureValue<T> makeFutureValueException(const Exception& exception)
{
    return makeFutureValueError<T>(zinc::copyException(exception));
}

inline bool operator==(const FutureValue<void>& a, const FutureValue<void>& b)
{
    return a.getError() == b.getError();
}

inline bool operator!=(const FutureValue<void>& a, const FutureValue<void>& b)
{
    return !(a == b);
}

template <typename T>
typename boost::enable_if<has_equals<T>, bool>::type operator==(const FutureValue<T>& a, const FutureValue<T>& b)
{
    return (a.getError() || b.getError()) ? (a.getError() == b.getError()) : (a.get() == b.get());
}

template <typename T>
typename boost::enable_if<has_equals<T>, bool>::type operator!=(const FutureValue<T>& a, const FutureValue<T>& b)
{
    return !(a == b);
}

// Disabled becuase it was causing compliation failures due to
// problems with has_insertion_op<T>
#if 0
template <typename T>
inline typename boost::enable_if<has_insertion_op<T>, std::ostream&>::type
operator<<(std::ostream& os, const FutureValue<T>& fv) {
	os << "FutureValue<" << typeid(T).name() << ">(";
	if (fv.getError()) {
		os << "Error: " << fv.getError();
	}
	else {
		os << fv.get();
	}
	os << ")";
	return os;
}

inline std::ostream& operator<<(std::ostream& os, const FutureValue<void>& fv) {
	os << "FutureValue<void>(";
	if (fv.getError()) {
		os << "Error: " << fv.getError();
	}
	os << ")";
	return os;
}
#endif // !NDEBUG

NS_ZINC_CLOSE

#endif /* ZINC_FUTUREVALUE_IMPL_H_ */


={============================================================================
*kt_dev_code_013* asyc: future helper

note: future helpers for unit test

////////////////////////////////////////
/**
 * File:   FutureMockActions.h
 */
#ifndef ZINC_COMMON_FUTUREMOCKACTIONS_H
#define ZINC_COMMON_FUTUREMOCKACTIONS_H

#include "../async/Promise.h"
#include "../async/async-helpers.h"

#include <gmock/gmock.h>

NS_ZINC_OPEN

/**
 * These helper actions are for use with Google Mock objects.
 *
 * When returning a future from a mock object expectation, care is needed to
 * make sure a new future is created each time the expectation is matched.
 * This shows up as a problem when setCallback is called on the returned future.
 *
 * The problem is that when using something like:
 *
 * EXPECT_CALL( ... ).WillRepeatedly(Return(FunctionThatReturnsAFuture()));
 *
 * Google Mock will copy the future returned from `FunctionThatReturnsAFuture()`
 * and always return the same future. This doesn't work for instance if you ever
 * call setCallback() on that future, which will throw a
 * DuplicateFutureCallback error on subsequent calls.
 *
 * Even this doesn't work, surprisingly:
 *
 * EXPECT_CALL( ... ).WillOnce(Return(FunctionThatReturnsAFuture()))
 *                   .WillOnce(Return(FunctionThatReturnsAFuture()));
 *
 * Again, the same promise is returned. I'm not quite sure how that happens
 * though.
 *
 * This can be used like this:
 *
 * EXPECT_CALL( ... ).WillOnce(returnNewCompletedFuture(someValue))
 *
 */

ACTION(returnNewCompletedFuture) {
    return completedFuture();
}

ACTION_P(returnNewCompletedFuture, value) {
    return completedFuture<typename return_type::value_type>(value);
}

ACTION_P(returnNewExceptionalFuture, exception) {
    return exceptionalFuture<typename return_type::value_type>(exception);
}

NS_ZINC_CLOSE

#endif // ZINC_COMMON_FUTUREMOCKACTIONS_H


<complete-helpers>

////////////////////////////////////////
note: not a whole file. this simply complete a promise as if it's "really" completed.
/*
 * Zinc/Zinc.Common/include/async/detail/async-helpers_Impl.h
 */
#ifndef ZINC_COMMON_ASYNC_HELPERS_IMPL_H_
#define ZINC_COMMON_ASYNC_HELPERS_IMPL_H_

template<typename T>
Future<T> completedFuture(Dispatcher& dispatcher, const T& val) {

    Promise<T> p(dispatcher);
    p.complete(val);
    return p.getFuture();
}

template<typename T>
Future<T> completedFuture(const T& val) {

    Promise<T> p;
    p.complete(val);
    return p.getFuture();
}


////////////////////////////////////////
/*
 * async-helpers.cpp
 */

#include "../../include/async/async-helpers.h"

NS_ZINC_OPEN

Future<void> completedFuture(Dispatcher& dispatcher) {

    Promise<void> p(dispatcher);
    p.complete();
    return p.getFuture();
}

Future<void> completedFuture() {

    Promise<void> p;
    p.complete();
    return p.getFuture();
}

NS_ZINC_CLOSE


={============================================================================
*kt_dev_code_013* asyc: promise

 * Promise.h
 * Promise_Impl.h

<promise>
////////////////////////////////////////
/*
 * Promise.h
 */
#ifndef ZINC_PROMISE_H_
#define ZINC_PROMISE_H_

#include "../macros.h"

#include "detail/Future_Decl.h"
#include "FutureDispatcher.h"
#include "detail/FutureContext.h"
#include "async-exceptions.h"
#include "../type-traits/call-traits.h"

#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits/is_void.hpp>

NS_ZINC_OPEN

namespace internal{
class PolymorphicPromise;
}

/**
 * Base class for Promises which contain different types. This can be useful
 * when hoisting to reduce object code size.
 */
class PromiseBase : boost::noncopyable {
	friend class internal::PolymorphicPromise;
public:
	/**
	 * Complete this Promise with a zinc::ErrorCode
	 *
	 * @param error the error code value
	 *
	 * @throws PromiseAlreadyCompleted if this Promise has already been completed
	 */
	void error(const NS_ZINC::ErrorCode& error);

	/**
	 * Complete this Promise with an exception
	 *
	 * @param e the exception
	 *
	 * @throws PromiseAlreadyCompleted if this Promise has already been completed
	 */
	void exception(const std::exception& e);

	/**
	 * Ask if this async operation has been completed with a value
	 *
	 * @return true if the async operation associated with this Promise has been completed
	 */
	bool isComplete() const;

protected:
	// Destructor and Constructor are protected to prevent deletion through the
	// base class.  If you want to store a Promise polymorphically use
	// PolymorphicPromise.
	~PromiseBase() ZINC_EXPORT;
	explicit PromiseBase(detail::FutureContextCommonImpl*) ZINC_EXPORT;
	PromiseBase(const PromiseBase& other) ZINC_EXPORT;

   // note: context which is set:
   //
   // PromiseBase::PromiseBase(detail::FutureContextCommonImpl* p)
   //  : context(p)
   // {
   //     if (context.get())
   //     {
   //         ++context->promiseCount;
   //     }
   // }
	boost::intrusive_ptr<detail::FutureContextCommonImpl> context;
	void baseSwap(PromiseBase& other);
};

/**
 * A Promise provides the API to set the result of an asynchronous operation,
 * signal the caller, and trigger dispatch of any associated completion handlers
 */
template<typename T>
class Promise : public PromiseBase
{
public:
	/**
	 * Construct a Promise for an asynchronous operation.
	 *
	 * If a dispatcher is passed the deprecated single-argument
	 * Future::setCallback which does not take a Dispatcher may be used on the
	 * Future returned from getFuture().  In this case the callback will be
	 * executed on the Dispatcher passed here.  This is a deprecated mode of
	 * use.
	 *
	 * Using the default Promise constructor and the two argument Future
	 * setCallback is strongly recommended in new code. The single argument
	 * Promise constructor is likely to be deprecated in the future.
	 *
	 * If a cancellation callback is provided it will be executed on the
	 * dispatcher provided here.
	 */
	Promise();
	explicit Promise(Dispatcher& dispatcher_);
	explicit Promise(Dispatcher& dispatcher_,
	                 boost::function<void ()> cancelationCallback);

	Promise(const Promise<T> & other);

	Promise & operator=(const Promise<T> & other);

	/**
	 * Swap this promise with the one provided
	 */
	void swap(Promise<T> & other);

	/**
	 * Create a Future for this Promise.
	 *
	 * The created Future can be used to access the result of this Promise.
	 *
	 * @return A Future used to access the result of this Promise
	 */
	Future<T> getFuture();

	/**
	 * Complete this Promise with a value and deliver the result to
	 * all associated Futures
	 *
	 * @param value the result to be delivered
	 *
	 * @throws PromiseAlreadyCompleted if this Promise has already been completed
	 */
	void complete(typename const_param<T>::type);
private:
	detail::FutureContext<T>& getContext();
	// WARNING: DO NOT ADD MEMBERS HERE:
	//     PolymorphicPromise depends on Promise<T> having no additional members
	//     vs. PromiseBase
};


/**
 * A Promise<void> provides the API to signal the caller of an asynchronous operation,
 * and trigger dispatch of any associated completion handlers
 *
 * FIXME: It's a shame that we have to specialize the whole class for void, when complete()
 * is really the only method that is different. But, to use sub-classing to do this
 * would confuse the interface.
 */
template<>
class Promise<void> : public PromiseBase
{
public:

	/**
	 * Construct a Promise for an asynchronous operation.
	 *
	 * If a dispatcher is passed the deprecated single-argument
	 * Future::setCallback which does not take a Dispatcher may be used on the
	 * Future returned from getFuture().  In this case the callback will be
	 * executed on the Dispatcher passed here.  This is a deprecated mode of
	 * use.
	 *
	 * Using the default Promise constructor and the two argument Future
	 * setCallback is strongly recommended in new code.  The single argument
	 * Promise constructor is likely to be deprecated in the future.
	 *
	 * If a cancellation callback is provided it will be executed on the
	 * dispatcher provided here.
	 */
	Promise();
	explicit Promise(Dispatcher& dispatcher_);
	explicit Promise(Dispatcher& dispatcher_,
	                 boost::function<void ()> cancelationCallback);

	Promise(const Promise<void> &other);

	Promise & operator=(const Promise<void> & other);

	/**
	 * Swap this promise with the one provided
	 */
	void swap(Promise<void> & other);

	/**
	 * Create a Future for this Promise.
	 *
	 * The created Future can be used to synchronise on completion of this Promise,
	 * and retrieve any error conditions that may occur.
	 *
	 * @return A Future used to access the result of this Promise
	 */
	Future<void> getFuture();

	/**
	 * Complete this Promise and notify all associated Futures
	 *
	 * @throws PromiseAlreadyCompleted if this Promise has already been completed
	 */
	void complete();

private:
	detail::FutureContext<void>& getContext();
	// WARNING: DO NOT ADD MEMBERS HERE:
	//     PolymorphicPromise depends on Promise<T> having no additional members
	//     vs. PromiseBase
};

NS_ZINC_CLOSE

#include "detail/Promise_Impl.h"

#endif /* ZINC_PROMISE_H_ */


////////////////////////////////////////
/*
 * Promise_Impl.h
 */
note: PromiseBase::PromiseBase() is defined in FutureContext.cpp

#ifndef ZINC_PROMISE_IMPL_H_
#define ZINC_PROMISE_IMPL_H_

#include "../Future.h"
#include "../async-exceptions.h"

NS_ZINC_OPEN

inline void PromiseBase::baseSwap(PromiseBase& other)
{
	using std::swap;
	swap(context, other.context);
}

inline void PromiseBase::error(const NS_ZINC::ErrorCode& error)
{
	context->completeError(error);
}

inline void PromiseBase::exception(const std::exception& e)
{
	error(zinc::copyException(e));
}

inline bool PromiseBase::isComplete() const
{
	return context->completed;
}

// note: creates FC
template<typename T>
inline Promise<T>::Promise() :
   PromiseBase( new detail::FutureContext<T>(NULL) )
{
}

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_) :
   PromiseBase( new detail::FutureContext<T>(&dispatcher_) )
{
}

template<typename T>
inline Promise<T>::Promise(FutureDispatcher& dispatcher_, boost::function<void ()> cancellationCallback_) :
	PromiseBase( new detail::FutureContext<T>(&dispatcher_, cancellationCallback_ ) )
{
}

template<typename T>
Promise<T>::Promise(const Promise<T> &other)
 : PromiseBase(other.context.get())
{
}

template<typename T>
Promise<T>& Promise<T>::operator=(const Promise<T> & other)
{
	Promise<T>(other).swap(*this);
	return *this;
}

// note: get-future. create and return F<T>
template<typename T>
inline Future<T> Promise<T>::getFuture()
{
	return Future<T>(&getContext());
}

// note
template<typename T>
inline void Promise<T>::complete(typename const_param<T>::type value)
{
    getContext().set(value);
}

template<typename T>
inline void Promise<T>::swap(Promise<T> & other)
{
    baseSwap(other);
}

// note:
template<typename T>
inline detail::FutureContext<T>& Promise<T>::getContext()
{
   return *static_cast<detail::FutureContext<T>* >(context.get());
}

// ** void specialization **

// This is the only method that actually needs to be different.
inline void Promise<void>::complete()
{
	getContext().set();
}

// But we have to repeat all these, because whole class is specialized.

inline Promise<void>::Promise() :
	PromiseBase( new detail::FutureContext<void>(NULL) )
{
}

inline Promise<void>::Promise(FutureDispatcher& dispatcher_) :
	PromiseBase( new detail::FutureContext<void>(&dispatcher_) )
{
}

inline Promise<void>::Promise(FutureDispatcher & dispatcher_, boost::function<void ()> cancellationCallback_) :
	PromiseBase( new detail::FutureContext<void>(&dispatcher_, cancellationCallback_) )
{
}

inline Promise<void> & Promise<void>::operator=(const Promise<void> & other)
{
	Promise<void>(other).swap(*this);
	return *this;
}

inline Promise<void>::Promise(const Promise<void> & other)
 : PromiseBase(other.context.get())
{
}

inline Future<void> Promise<void>::getFuture()
{
	return Future<void>(&getContext());
}

inline void Promise<void>::swap(Promise<void> & other)
{
    baseSwap(other);
}

inline detail::FutureContext<void>& Promise<void>::getContext()
{
	return *static_cast<detail::FutureContext<void>* >(context.get());
}

NS_ZINC_CLOSE

#endif /* ZINC_PROMISE_IMPL_H_ */


={============================================================================
*kt_dev_code_014* asyc: future barrier

////////////////////////////////////////
#ifndef ZINC_FUTUREBARRIER_H_
#define ZINC_FUTUREBARRIER_H_

#include "../macros.h"
#include "FutureValue.h"
#include "async-exceptions.h"

#include "../type-traits/call-traits.h"
#include "../Utilities.h"

#include <boost/intrusive_ptr.hpp>
#include <boost/function.hpp>
#include <boost/bind.hpp>


NS_ZINC_OPEN

class Dispatcher;
typedef Dispatcher FutureDispatcher;

namespace detail {
    template <typename Functor> class BarrierWrapper;
    class FutureBarrierImpl;
}

/**
 * FutureBarrier is designed to aid synchronisation when making multiple
 * asynchronous calls simultaneously. FutureBarrier will call a given
 * callback asynchronously once all the futures added to it have
 * completed AND the FutureBarrier itself has gone out of scope.
 *
 * (NOTE: This means you must not keep a FutureBarrier alive after the method
 * creating it returns; for example you must not pass around a shared_ptr to a
 * FutureBarrier, and you must not make a FutureBarrier be a member of your
 * class.)
 *
 * FutureBarrier is "FutureLike" in that it defines the functions setCallback
 * and cancel() and thus can be used as an argument to
 * Continuation::setCallback();
 */
class FutureBarrier : boost::noncopyable {
public:
    typedef void value_type;

    /**
     * Constructor
     */
    explicit FutureBarrier(FutureDispatcher& dispatcher);
    ~FutureBarrier();

    /**
     * Add a Future to the barrier to delay the FutureBarrier from completing
     * until the Future has completed.
     *
     * @param f The future to add. This can be any "FutureLike" object, such
     *          as a Future, a Continuation, or even another FutureBarrier.
     *
     * @param c Callback to be called when the future "f" completes
     *          *successfully*. It must have the signature:
     *              void SuccessCallback(T);
     *          where T is the value_type of the future "f".
     *          Note that the parameter is T, not FutureValue<T>.
     *
     *          If the future "f" completes with an error, this callback will
     *          not be called; and the "final" callback (set with setCallback)
     *          will (eventually, once all other futures have completed) be
     *          called with an error.
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     *
     * Note: The FutureDispatcher you use should provide the guarantee that all
     * callbacks will be dispatched on the same thread (which may be a
     * different thread than the thread where you create the FutureBarrier and
     * call addWithSuccessCallback). This way, the various callbacks you set
     * with addWithSuccessCallback don't need to worry about synchronisation
     * issues.
     */
    template <class FutureLike, typename SuccessCallback>
    void addWithSuccessCallback(FutureLike f, SuccessCallback /* void (T) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * This is distinct from addWithSuccessCallback in that this is called with a
     * FutureValue<T> rather than just T, thus allowing finer grained control
     * of error conditions.
     *
     * @param f The future to add.
     *
     * @param c The function to call once the future "f" is complete.
     *          It must have the signature:
     *              void Callback(FutureValue<T>);
     *          where T is the value_type of the future "f".
     *
     * Note: It is guaranteed that the callback given here will be called
     * *before* the callback given in FutureBarrier::setCallback().
     */
    template <class FutureLike, typename Callback>
    void addWithCallback(FutureLike f, Callback /* void (FutureValue<T>) */ c);

    /**
     * Add a future to the barrier to delay the FutureBarrier callback until
     * after the future has completed.
     *
     * The value returned by the completed future is ignored, as long as it is
     * not an error. An error will cause this FutureBarrier to complete with
     * the error, just like addWithSuccessCallback.
     *
     * @param f The future to add.
     */
    template <class FutureLike>
    void add(FutureLike f);

    /**
     * Cancel the FutureBarrier.  The behaviour of this function depends on the
     * template parameter CancellationPolicy.
     */
    void cancel(unsigned flags);

    /**
     * Set the "final" callback method to be invoked after all of the barrier's
     * Futures have completed, successfully or otherwise.
     *
     * @param c The function to call once all the futures have completed.
     *          This function should have the signature:
     *              void (FutureValue<void>);
     *          In this way FutureBarrier is interface compatible with
     *          Future<void>.
     */
    template <typename Callback>
    void setCallback(Callback c) const;

    template <typename Callback>
    void setCallback(FutureDispatcher& dispatcher, Callback c);
private:
    template <typename Functor, typename ValueType> friend class detail::BarrierWrapper;
    detail::FutureBarrierImpl* impl;
};


NS_ZINC_CLOSE

#include "detail/FutureBarrier_Impl.h"

#endif /* ZINC_FUTUREBARRIER_H_ */


////////////////////////////////////////
#ifndef ZINC_FUTUREBARRIER_IMPL_H_
#define ZINC_FUTUREBARRIER_IMPL_H_

#include "../Promise.h"
#include "ContinuationLike.h"
#include "../../type-traits/check_concept.h"

NS_ZINC_OPEN

namespace detail {

// Model of ContinuationLike
class FutureBarrierImpl : boost::noncopyable {
public:
    template <class FutureLike, typename Callback>
    void continueOn(FutureLike f, Callback c);

    void onError(const ErrorCode& ec) {
        if (!error) {
            error = ec;
        }
    }
private:
    template<typename Functor> friend class BarrierWrapper;
    friend class NS_ZINC::FutureBarrier;

    struct ScopedRef {
        ScopedRef(FutureBarrierImpl* impl_) : impl(impl_) {}
        ~ScopedRef() { impl->dec(); }
        FutureBarrierImpl* impl;
    };
    explicit FutureBarrierImpl(FutureDispatcher& dispatcher_) 
     // Start with a reference count of 1.  We should be owned by the
     // FutureBarrier
     : cnt(1), dispatcher(dispatcher_), p(dispatcher)
    {
    }
    void inc() {
        __sync_fetch_and_add(&cnt, 1);
    }
    void dec() {
        if (__sync_add_and_fetch(&cnt, -1) == 0) {
            if (error) {
                p.error(error);
            }
            else {
                p.complete();
            }
            delete this;
        }
    }
    void onCancel() {
        // TODO: Propagate cancellation to "child" functors
        p.getFuture().cancel();
    }
    int cnt;
    FutureDispatcher& dispatcher;
    Promise<void> p;
    ErrorCode error;
};

template <typename Functor>
struct BarrierWrapper {
    typedef void result_type;
    BarrierWrapper(FutureBarrierImpl* impl_, Functor f_) : f(f_), impl(impl_) {}
    template <typename ValueType>
    void operator()(FutureValue<ValueType> vt) {
        FutureBarrierImpl::ScopedRef refCountGuard(impl);
        try {
            f(*impl, vt);
        }
        catch (std::exception& e) {
            impl->onError(copyException(e));
        }
    }
    Functor f;
    FutureBarrierImpl* impl;
};

template <typename Functor>
BarrierWrapper<Functor> barrierWrap(FutureBarrierImpl* impl, Functor f) {
    return BarrierWrapper<Functor>(impl, f);
};

// Callback is a functor with the signature:
//     void (FutureBarrierImpl&, FutureValue<T>);
template <class FutureLike, typename Callback>
void FutureBarrierImpl::continueOn(FutureLike f, Callback c) {
    typedef typename FutureLike::value_type T;
    // Concept check for nicer error messages:
    ZINC_CHECK_CONCEPT(( c(*this, LValue<FutureValue<T> >()) ));

    inc();
    // FIXME: if Callback copy constructor fails we leak
    f.setCallback(dispatcher, detail::barrierWrap(this, c));
}

struct noop {
    typedef void result_type;
    template <typename ContinuationLike, typename T>
    void operator()(ContinuationLike&, const T&) {
    }
    template <typename ContinuationLike>
    void operator()(ContinuationLike&) {
    }
};

} //namespace detail


// Callback is a functor with the signature:
//     void (FutureValue<T>);
template <class FutureLike, typename Callback>
inline void FutureBarrier::addWithCallback(FutureLike f, Callback c) {
    typedef typename FutureLike::value_type T;
    // Concept check for nicer error messages:
    ZINC_CHECK_CONCEPT(( c(LValue<FutureValue<T> >()) ));

    impl->continueOn(f, boost::bind(c, _2));
}

// Callback is a functor with the signature:
//     void (T);
template <class FutureLike, typename SuccessCallback>
inline void FutureBarrier::addWithSuccessCallback(FutureLike f, SuccessCallback c) {
    typedef typename FutureLike::value_type T;
    // Concept check for nicer error messages:
    ZINC_CHECK_CONCEPT(( c(LValue<T>()) ));

    impl->continueOn(f, detail::adaptForHappyPath(boost::bind(c, _2)));
}

template <class FutureLike>
inline void FutureBarrier::add(FutureLike f) {
    impl->continueOn(f, detail::adaptForHappyPath(detail::noop()));
}

template <typename Callback>
inline void FutureBarrier::setCallback(Callback c) const {
    impl->p.getFuture().setCallback(c);
}

template <typename Callback>
inline void FutureBarrier::setCallback(FutureDispatcher& dispatcher, Callback c) {
    impl->p.getFuture().setCallback(dispatcher, c);
}

inline FutureBarrier::FutureBarrier(FutureDispatcher& dispatcher)
 : impl(new detail::FutureBarrierImpl(dispatcher)) {
}

inline FutureBarrier::~FutureBarrier() {
    impl->dec();
}

inline void FutureBarrier::cancel(unsigned flags) {
    if (flags & cancel_flag::deep) {
        impl->onCancel();
    }
}

NS_ZINC_CLOSE

#endif /* ZINC_FUTUREBARRIER_IMPL_H_ */


={============================================================================
*kt_dev_code_015* asyc: dispatcher

DP <- STDP

////////////////////////////////////////
#ifndef ZINC_DISPATCHER_H_
#define ZINC_DISPATCHER_H_

#include "../macros.h"
#include <boost/function.hpp>
#include <boost/thread/locks.hpp>
#include <boost/utility.hpp>

NS_ZINC_OPEN

/*
 * Interface for general functor dispatcher.
 * Dispatchers are used to invoke callback functors (for events and futures for
 * example).
 */
struct ZINC_EXPORT Dispatcher : boost::noncopyable
{
    /**
     * Dispatcher::work is a RAII class.  An object of this type should exist
     * for as long as there is the possibility of you calling post.  This is
     * similar to an boost::io_service::work and will prevent the dispatcher
     * from running down.
     *
     * Example: A Future will hold a work object after setCallback is called
     *          as it knows it will be posting a functor at some point in the
     *          future (but doesn't know when).  After the callback is called
     *          the work object is destroyed so the dispatcher can run down.
     */
    typedef boost::unique_lock<Dispatcher> work;

    virtual ~Dispatcher();

    /**
     * Post the supplied completion handler to the dispatcher for execution.
     *
     * The Dispatcher will hold a reference to the suppled functor until the
     * it has been executed.
     *
     * @param handler the completion handler
     */
    virtual void post(boost::function<void ()> handler) = 0;

    private:
    /**
     * These methods are called when a Dispatcher::work object is
     * created/destroyed. Typically a dispatcher that is interested will treat
     * these functions like a ref count inc/dec.
     *
     * It is not necessary to implement these functions.  The default
     * implementations do nothing.
     */
    virtual void onWorkAdded() {};
    virtual void onWorkRemoved() {};

    private: // Lockable concept
    // Implement the "lockable" concept so we can use unique_lock as our RAII
    // "work" class
    friend class boost::unique_lock<Dispatcher>;
    void lock() ZINC_LOCAL { onWorkAdded(); };
    void unlock() ZINC_LOCAL { onWorkRemoved(); };
};

NS_ZINC_CLOSE

#endif /* ZINC_DISPATCHER_H_ */


////////////////////////////////////////
#ifndef ZINC_SINGLETHREADDISPATCHER_H_
#define ZINC_SINGLETHREADDISPATCHER_H_

#include "../macros.h"
#include "Dispatcher.h"

#include <boost/thread/thread.hpp>
#include <boost/asio/io_service.hpp>

NS_ZINC_OPEN

/*
 * A Dispatcher implementation that owns a single thread on which it executes
 * the functors posted to it. Functors are executed strictly in the order that
 * they are posted to the dispatcher.
 */
class ZINC_EXPORT SingleThreadDispatcher : public Dispatcher
{
    public:
        SingleThreadDispatcher();
        ~SingleThreadDispatcher();

    public: // from Dispatcher
        virtual void post(boost::function<void ()> handler);
        virtual int getPendingCount();

    private:
        boost::asio::io_service io;
        boost::thread thread;
};

NS_ZINC_CLOSE

#endif /* ZINC_SINGLETHREADDISPATCHER_H_ */


////////////////////////////////////////
#include "../../include/macros.h"
#include "../../include/WorkerFunction.h"
#include "../../include/async/Future.h"
#include "../../include/async/FutureContextBase.h"
#include "../../include/async/SequentialFutureDispatcher.h"
#include "../../include/MonotonicClock.h"
#include <boost/thread.hpp>

using namespace std;

NS_ZINC_OPEN

Dispatcher::~Dispatcher() {}

static void run(boost::asio::io_service* io) {

    // note: to keep io_service running
    boost::asio::io_service::work work(*io);

    while (1) {
        try {
            // because of the io_service::work above the only reason this
            // will return is if io.stop() is called from ~SingleThreadDispatcher()
            // destructor
            io->run();
            break;
        }
        catch (...) {
            // Exceptions thrown in functors posted to the io_service are
            // propogated up to the caller of run().  We wish to ignore them
        }
    }
}

// note: see binds uses global function and member data
SingleThreadDispatcher::SingleThreadDispatcher()
   : thread(makeWorkerFunction(boost::bind(&run, &io)))
{
}

SingleThreadDispatcher::~SingleThreadDispatcher()
{
    io.stop();
    thread.join();
}

/**
 * Post a functor to the dispatcher, and put it on the pending dispatch queue.
 */
void SingleThreadDispatcher::post(boost::function<void ()> handler)
{
    io.post(handler);
}

int SingleThreadDispatcher::getPendingCount()
{
    // This is not valid for SingleThreadDispatcher but is included
    // as a legacy as the tests demand it.
    //
    // TODO: Fix the tests to not rely on getPendingCount
    return 10000;
}

NS_ZINC_CLOSE


////////////////////////////////////////
#ifndef ZINC_WORKERFUNCTION_H_
#define ZINC_WORKERFUNCTION_H_

#include "macros.h"

NS_ZINC_OPEN

namespace detail {

void maskSignals() ZINC_EXPORT;

/**
 * This functor is used to wrap any functor (or plain function) that will
 * be executed by a worker thread. It's purpose is to ensure that the first
 * thing the thread does is to ignore all signals delivered to the process.
 *
 * This is important, since posix does not define *which* thread a will receive
 * a signal delivered to the process. It only says that the signal may be
 * delivered to any thread that does not mask it. So, if we wish to have a sane
 * signal handling strategy, then we should nominate a *single* specific thread
 * to deal with all signals (and perhaps propagate them to other threads, as
 * application events).
 *
 * Use this class like:
 *
 * boost::thread thread(WorkerFunction(myThreadFunctionOrFunctor));
 *
 */
template <class NullaryFunctor>
    class WorkerFunction {

        public:
            WorkerFunction(NullaryFunctor functor)
                : workerFunction(functor)
            {
            }

            void operator()() {
                maskSignals();
                workerFunction();
            }

        private:
            NullaryFunctor workerFunction;
    };

}

template <typename NullaryFunctor>
detail::WorkerFunction<NullaryFunctor> 
  makeWorkerFunction(NullaryFunctor fn)
{
    return detail::WorkerFunction<NullaryFunctor>(fn);
}

NS_ZINC_CLOSE

#endif /* WORKERFUNCTION_H_ */


////////////////////////////////////////
#include "../include/WorkerFunction.h"
#include <stdexcept>
#include <cstring>
#include <pthread.h>
#include <signal.h>

NS_ZINC_OPEN

namespace detail {

void maskSignals() {
    // Explicitly mask all signals. We don't want to be the thread
    // randomly selected for signal processing, thankyou.
    
    sigset_t sigs;
    sigfillset(&sigs);
    
    int error = pthread_sigmask(SIG_SETMASK, &sigs, 0);
    
    if (error) {
        throw std::runtime_error(std::strerror(error));
    }
}

}

NS_ZINC_CLOSE


////////////////////////////////////////
/*
 * InlineDispatcher.h
 */
#ifndef ZINC_INLINEDISPATCHER_H_
#define ZINC_INLINEDISPATCHER_H_

#include "../macros.h"

#include "Dispatcher.h"

#include <boost/thread/condition.hpp>
#include <boost/thread/mutex.hpp>


NS_ZINC_OPEN

/*
 * A dispatcher implementation that executes completion handlers
 * in the same thread that calls post().
 */
class ZINC_EXPORT InlineDispatcher : public Dispatcher
{
    public:
        InlineDispatcher();
        ~InlineDispatcher();

        /**
         * Since InlineDispatcher is stateless, it is convenient to reuse
         * a single instance of it.
         *
         * This does not mean that we must always use it as a singleton.
         *
         * @return an instance that may be shared.
         */
        static InlineDispatcher& sharedInstance();

    public: // from Dispatcher
        virtual void post(boost::function<void ()> handler);
        virtual int getPendingCount();
};

NS_ZINC_CLOSE

#endif /* ZINC_INLINEDISPATCHER_H_ */


/*
 * InlineDispatcher
 */
#include "../../include/macros.h"
#include "../../include/async/InlineDispatcher.h"

NS_ZINC_OPEN

InlineDispatcher::InlineDispatcher()
{}

InlineDispatcher::~InlineDispatcher() {}


void InlineDispatcher::post(boost::function<void ()> handler)
{
    try
    {
        handler();
    }
    catch (...)
    {
    }
}

int InlineDispatcher::getPendingCount()
{
    // With this type of dispatcher, Futures are either not notified,
    // or they are notified and the completionHandler is in the process
    // of being run
    return 0;
}

InlineDispatcher& InlineDispatcher::sharedInstance() {
    static InlineDispatcher instance;
    return instance;
}

NS_ZINC_CLOSE


////////////////////////////////////////
/*
 * MultipleListenerEventDispatcher.h
 */

typedef InlineDispatcher MultipleListenerEventDispatcher;


={============================================================================
*kt_dev_code_016* asyc: listener

// defines abstract interface to add/remove listener

class ZINC_EXPORT EventProducer<ListenerT> : virtual public Polymorphic 
   + typedef ListenerT listener_type;
   + virtual void addListener(boost::shared_ptr<ListenerT> listener) = 0;

class ZINC_LOCAL DispatchingEventProducer : virtual public EventProducer<T> 

   // implements produceEvent() by delegating events to an EventDispatcher
   // implementation.

   + mutable detail::DispatchingEventProducerHoisted impl;

   // It accepts a functor with the signature:
   //
   // void f(ListenerT*)

   + template <typename Functor>
        void produceEvent(Functor f) const {
            ZINC_CHECK_CONCEPT(f(static_cast<ListenerT*>(NULL)));
            impl.produceEvent(DowncastingCaller<Functor>(f));
        }

   + virtual void setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher);
         impl.setDispatcher(dispatcher);

// 1. have std::list<listener> which has entry:
//    listener_entry pair{wp<listener>, sp<event dispatcher>}
//
// 2. produceEvent calls user code(listener) with event using the dispatcher
// registered with the listener or default dispatcher.

class ZINC_EXPORT DispatchingEventProducerHoisted : boost::noncopyable 
   + void addListener(boost::shared_ptr<hoisted_event_listener> listener, 
         boost::shared_ptr<EventDispatcher> clientDispatcher=boost::shared_ptr<EventDispatcher>());
   + void setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher_);

   + void produceEvent(
       boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event);

// this defines APIs for application and also have 'producer' implementation
// by deriving from EventProducer.

class ZINC_EXPORT EventWindow : 
    virtual public NS_ZINC::DispatchingEventProducer<EventWindowEventListener> 

// SystemClientEventRepository::createEventWindow() creates SCEW and pass DD,
// inline diapatcher, to SystemClientEventWindow.
//
// SystemClientEventWindow->setDispatcher(DD);

<produce-event>
// creates functor and calls DispatchingEventProducerHoisted::produceEvent(f)

class ZINC_EXPORT SystemClientEventWindow : virtual public EventWindow 

   + template <typename Functor>
        void produceEvent(Functor f) const {
            impl.produceEvent(DowncastingCaller<Functor>(f));
        }


virtual void EventWindowChanged();

produceEvent(
    bind(&EventWindowEventListener::EventWindowChanged, _1)
    );

1. DowncastingCaller:
  operator() (boost::shared_ptr<detail::hoisted_event_listener> listener) 
  {
    f( static_cast<ListenerT*>(listener.get()) );
  }

2. DispatchingEventProducerHoisted:
  produceEvent(
      boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event
      ) 

3. makeWeakFunctor(event, localListeners[i].first));


<event-listener>
////////////////////////////////////////
/*
 * EventListener.h
 */
#ifndef ZINC_EVENTLISTENER_H_
#define ZINC_EVENTLISTENER_H_

#include "Polymorphic.h"

NS_ZINC_OPEN

/** Needed so that events can be handled polymorphically, such as by an
 * EventDispatcher.
 */
class ZINC_EXPORT EventListener : virtual public Polymorphic {

protected:
   EventListener() {}
   ~EventListener();
};

NS_ZINC_CLOSE

#endif /* ZINC_EVENTLISTENER_H_ */


////////////////////////////////////////
/*
 * EventWindowEventListener.h
 */
#ifndef URANIUM_METADATA_CLIENT_EVENTWINDOWEVENTLISTENER_H_
#define URANIUM_METADATA_CLIENT_EVENTWINDOWEVENTLISTENER_H_

#include "Event.h"

#include <zinc-common/EventListener.h>
#include <zinc-common/macros.h>

#include <boost/shared_ptr.hpp>
#include <vector>

NS_URANIUM_METADATA_CLIENT_OPEN

class ZINC_EXPORT EventWindowEventListener 
  : public NS_ZINC::EventListener
{
  public:

    virtual ~EventWindowEventListener();

    /**
     * Indicates the Event Window has changed substantially. 
     * To update the data call EventWindow::refresh.
     */
    virtual void EventWindowChanged() = 0;

    /**
     * Indicates that some of the events in the Event Window have changed.
     * @param events the list of events that changed
     */
    virtual void 
      EventsChanged(const std::vector<boost::shared_ptr<Event> > events) = 0;
};

NS_URANIUM_METADATA_CLIENT_CLOSE
#endif /* URANIUM_METADATA_CLIENT_EVENTWINDOWEVENTLISTENER_H_ */


<event-producer>
////////////////////////////////////////
/*
 * EventProducer.h
 */
#ifndef ZINC_EVENTPRODUCER_H_
#define ZINC_EVENTPRODUCER_H_

#include "Event.h" // for convenience in derived classes.
#include "Polymorphic.h"

#include <boost/shared_ptr.hpp>

NS_ZINC_OPEN

// I'm deliberately using int here, rather than int32.
// Want machine word size. I may change this type later, so don't rely on it.
typedef int EventProducerId;


/**
 * An abstract producer of events matching a particular specification.
 *
 * Concrete producers should subclass a specialisation of this base.
 *
 * Please note: Although this implementation looks like it does
 * not strictly need to be a template class, templating on the
 * event listener specification is both instructive of the type of
 * events produced, and is in fact required by the binding generator.
 */
template<class ListenerT>
class ZINC_EXPORT EventProducer : virtual public Polymorphic {

  public:
    typedef ListenerT listener_type;

    /**
     * Add an event listener.
     * The event listener methods will be invoked on the default dispatcher.
     *
     * @param listener the event listener.
     *
     * @throws std::invalid_argument if a <code>null</code> listener is given.
     *
     * @acl all
     */
    virtual void addListener(boost::shared_ptr<ListenerT> listener) = 0;

    /**
     * @acl all
     */
    virtual void removeListener(boost::shared_ptr<ListenerT> listener) = 0;
};

NS_ZINC_CLOSE

#endif /* ZINC_EVENTPRODUCER_H_ */


////////////////////////////////////////
/*
 * DispatchingEventProducer.h
 */
#ifndef ZINC_DISPATCHINGEVENTPRODUCER_H_
#define ZINC_DISPATCHINGEVENTPRODUCER_H_

#include "EventProducer.h"
#include "detail/DispatchingEventProducerHoisted.h"
#include "type-traits/check_concept.h"

#include <iostream>

NS_ZINC_OPEN

/**
 * EventProducer specialization that implements produceEvent() by delegating
 * events to an EventDispatcher implementation.
 */
template<class ListenerT>
class ZINC_LOCAL DispatchingEventProducer 
  : virtual public EventProducer<ListenerT> 
{
  public:

    DispatchingEventProducer() : impl(boost::shared_ptr<EventDispatcher>()) {}

    /**
     * Constructor
     *
     * @param dispatcher_ this dispatcher will be used to dispatch event
     * listener callback methods, unless clients explicitly provide an
     * alternative dispatcher in the call to addListener()
     */
    explicit DispatchingEventProducer(boost::shared_ptr<EventDispatcher>
        dispatcher_) : impl(dispatcher_) {}

    /**
     * Add an event listener.
     * The event listener methods will be invoked on the default dispatcher.
     *
     * @param listener the event listener.
     *
     * @throws std::invalid_argument if a <code>null</code> listener is given.
     *
     * @acl all
     */
    virtual void addListener(boost::shared_ptr<ListenerT> listener) {
      // Hoisting note: we cast to void* here, and cast back down in
      // DowncastingCaller so everything is lovely and symmetrical
      impl.addListener(listener);
    }

    /**
     * Add an event listener and specify the dispatcher on which the event
     * listener methods should be invoked.
     *
     * @param clientDispatcher the dispatcher on which the event listener
     * callbacks will be invoked. This overrides the default dispatcher.  
     *
     * @param listener the event listener.
     *
     * @throws std::invalid_argument if a <code>null</code> listener or
     * clientDispatcher is provided.
     *
     * @acl all
     */

    virtual void addListener(boost::shared_ptr<EventDispatcher> clientDispatcher, 
        boost::shared_ptr<ListenerT> listener) {

      if (!clientDispatcher) {
        throw std::invalid_argument("NULL dispatcher provided in call to addListener()!");
      }

      // Hoisting note: we cast to void* here, and cast back down in
      // DowncastingCaller so everything is lovely and symmetrical
      impl.addListener(listener, clientDispatcher);
    }

    /**
     * @acl all
     */
    virtual void removeListener(boost::shared_ptr<ListenerT> listener) {
      impl.removeListener(listener);
    }

    virtual void setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher) {
      impl.setDispatcher(dispatcher);
    }

    virtual boost::shared_ptr<EventDispatcher> getDispatcher() const {
      return impl.getDispatcher();
    }

    virtual size_t getListenerCount() const {
      return impl.getListenerCount();
    }

  protected:

    /**
     * Derived implementations can call this method to dispatch an event.
     *
     * NOTE: This overload is provided for backwards-compatibility only. New
     * code should use the templated version, below, which accepts a functor
     * directly, rather than requiring an intermediate BoundEvent object.
     *
     * @param event the event to be dispatched. This should be an instance of
     * BoundEvent<ListenerT>
     */
    void produceEvent(boost::shared_ptr<Event> event) const {

      // The vast majority of the time the actual derived type will be
      // BoundEvent<ListenerT> so we optimise for this case, reaching in and
      // pulling out the contained boost::function.
      boost::shared_ptr<BoundEvent<ListenerT> > e = boost::dynamic_pointer_cast<BoundEvent<ListenerT> >(event);
      if (e) {
        produceEvent(e->listenerMethod);
      }
      else {
        produceEvent(boost::bind(&Event::dispatchTo, event, _1));
      }
    }

    void produceEvent(boost::shared_ptr<BoundEvent<ListenerT> > event) const {
      produceEvent(static_cast<boost::shared_ptr<Event> >(event));
    }

    <produce-event>
      /**
       * Derived implementations should call this method to dispatch an event.
       *
       * NOTE: This overload is preferred to the one above, as it is more
       * efficient and offers greater clarity.
       *
       * It accepts a functor with the signature:
       *
       *     void f(ListenerT*)
       *
       * @param f a functor with the above signature, which can be a plain-old
       * function, member-function, boost::function, or bind expression.
       */
      template <typename Functor>
      void produceEvent(Functor f) const {

        ZINC_CHECK_CONCEPT(f(static_cast<ListenerT*>(NULL)));
        impl.produceEvent(DowncastingCaller<Functor>(f));
      }

  private:
    template <typename Functor>
      struct DowncastingCaller {
        explicit DowncastingCaller(Functor f_) : f(f_) {}

        void 
          operator()(boost::shared_ptr<detail::hoisted_event_listener> listener) {
          // We implicitly casted to void* in add/removeListener above so
          // this is safe.
          f(static_cast<ListenerT*>(listener.get()));
        }

        Functor f;
      };

    mutable detail::DispatchingEventProducerHoisted impl;
};

NS_ZINC_CLOSE

#endif /* ZINC_DISPATCHINGEVENTPRODUCER_H_ */


////////////////////////////////////////
/*
 * DispatchingEventProducerHoisted.h
 */
#ifndef ZINC_DISPATCHINGEVENTPRODUCERHOISTED_H_
#define ZINC_DISPATCHINGEVENTPRODUCERHOISTED_H_

#include "../EventDispatcher.h"

#include <boost/thread/mutex.hpp>
#include <boost/utility.hpp>
#include <boost/noncopyable.hpp>

#include <list>
#include <stdexcept>


NS_ZINC_OPEN

namespace detail {

// We are always careful to static_cast from the concrete ListenerT in
// DispatchingEventProducer such that we know that we can do the inverse

typedef void hoisted_event_listener;

class ZINC_EXPORT DispatchingEventProducerHoisted : boost::noncopyable 
{
public:

    explicit DispatchingEventProducerHoisted(boost::shared_ptr<EventDispatcher> dispatcher_);
    ~DispatchingEventProducerHoisted();

    void addListener(boost::shared_ptr<hoisted_event_listener> listener, 
         boost::shared_ptr<EventDispatcher> clientDispatcher=boost::shared_ptr<EventDispatcher>());

    void removeListener(boost::shared_ptr<hoisted_event_listener> listener);

    void setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher_);

    boost::shared_ptr<EventDispatcher> getDispatcher() const;

    void produceEvent(boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event);

    size_t getListenerCount() const;

private:

    typedef std::pair<boost::weak_ptr<hoisted_event_listener>, 
            boost::shared_ptr<EventDispatcher> > listener_entry;

    std::list<listener_entry> listeners;

    /**
     * This is the default dispatcher. Clients can provide their own in addListener().
     */
    boost::shared_ptr<EventDispatcher> dispatcher;

    mutable boost::mutex mutex;
};

}

NS_ZINC_CLOSE

#endif /* ZINC_DISPATCHINGEVENTPRODUCERHOISTED_H_ */


////////////////////////////////////////
/*
 * DispatchingEventProducer.cpp
 */
#include "../include/Event.h"
#include "../include/DispatchingEventProducer.h"
#include "../include/Logger.h"
#include "../include/WeakFunctor.h"

#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/foreach.hpp>

NS_ZINC_OPEN

namespace detail {

bool operator==(const boost::weak_ptr<hoisted_event_listener> l, const boost::weak_ptr<hoisted_event_listener> r) {
	return !(l < r || r < l);
}

DispatchingEventProducerHoisted::DispatchingEventProducerHoisted(boost::shared_ptr<EventDispatcher> dispatcher_) :
		dispatcher(dispatcher_) {
}

DispatchingEventProducerHoisted::~DispatchingEventProducerHoisted() {
	std::list<listener_entry> stackListeners;
	{
		boost::mutex::scoped_lock lock(mutex);
		listeners.swap(stackListeners);
	}
	BOOST_FOREACH(const listener_entry& entry, stackListeners) {
		// Call entry->second->onWorkRemoved()
		Dispatcher::work(*entry.second, boost::adopt_lock_t());
	}
}

void DispatchingEventProducerHoisted::addListener(
        boost::shared_ptr<hoisted_event_listener> listener, boost::shared_ptr<EventDispatcher> clientDispatcher) 
{
    if (!listener) {
        throw std::invalid_argument("NULL listener provided in call to addListener()!");
    }

    ZINC_COMMON_DEBUG(std::string(__func__)+" Dispatcher: "+boost::lexical_cast<std::string>(static_cast<const EventDispatcher*>(clientDispatcher.get()))+
            ", Producer: "+boost::lexical_cast<std::string>(this)+
            ", Listener: "+boost::lexical_cast<std::string>(listener.get())
            );

    bool duplicate = false;

    boost::mutex::scoped_lock lock(mutex);

    if (!clientDispatcher) {
        if (!dispatcher) {
            throw std::logic_error("addListener() called, but event producer has no dispatcher set.");
        }
        clientDispatcher = dispatcher;
    }
    // Call entry->second->onWorkAdded()
    Dispatcher::work work(*clientDispatcher);

    listener_entry newEntry(listener, clientDispatcher);

    BOOST_FOREACH(const listener_entry& entry, listeners) {

        if (entry.first == newEntry.first) {
            duplicate = true;
            break;
        }
    }

    if (!duplicate) {
        work.release();
        listeners.push_front(newEntry);
    }
}

void DispatchingEventProducerHoisted::removeListener(boost::shared_ptr<hoisted_event_listener> listener) {

	ZINC_COMMON_DEBUG(std::string(__func__)+
			" Producer: "+boost::lexical_cast<std::string>(this)+
			", Listener: "+boost::lexical_cast<std::string>(listener.get())
	);

	// This is for the comparisons below.
	// It's better to do this than to call lock() on each of the weak_ptrs as
	// doing this will fiddle with reference counts.
	//
	boost::weak_ptr<hoisted_event_listener> weak(listener);

	std::list<listener_entry> forRemoval;
	{
		boost::mutex::scoped_lock lock(mutex);

		// linear trawl to find listener, but n should be small.
		for (std::list<listener_entry>::iterator i = listeners.begin(); i != listeners.end(); ++i) {
			if (i->first == weak) {
				// Avoid calling dispatcher destructors while the mutex is locked.
				forRemoval.splice(forRemoval.end(), listeners, i);
				break;
			}
		}
	}
	BOOST_FOREACH(listener_entry& entry, forRemoval) {
		// Call entry->second->onWorkRemoved()
		Dispatcher::work(*entry.second, boost::adopt_lock_t());
	}
}

void 
DispatchingEventProducerHoisted::setDispatcher(boost::shared_ptr<EventDispatcher> dispatcher_) 
{
    boost::mutex::scoped_lock lock(mutex);
    dispatcher = dispatcher_;
}


boost::shared_ptr<EventDispatcher> 
DispatchingEventProducerHoisted::getDispatcher() const {
	boost::mutex::scoped_lock lock(mutex);
	return dispatcher;
}


// note:
// this is one called from future chain coming up from dbus such as
// notifyWindowChanged()
// 
// Takes functor, send aync post to all listeners which are not expired and
// registered before. dispatcher->post( functor, wp ). So uses dispatcher which
// is registered with listener.
//
// typedef void hoisted_event_listener;

void 
DispatchingEventProducerHoisted::produceEvent(
  boost::function<void (boost::shared_ptr<hoisted_event_listener>)> event) 
{
  boost::mutex::scoped_lock lock(mutex);

  size_t len = listeners.size();

  // We copy listeners to this stack allocated array before dispatch so we don't
  // have to hold the lock while calling user code.

  // note: array of listener_entry pair{wp<listener>, sp<event dispatcher>}

  listener_entry localListeners[len];
  listener_entry* next = localListeners;

  std::list<listener_entry>::iterator i = listeners.begin();

  std::list<listener_entry> forRemoval;

  // note: copies ones not expired to locak array and moves ones expired to a
  // remove list

  while (i != listeners.end()) {

    if (!i->first.expired()) {
      *next++ = *i;
      ++i;
    } else {
      // Listener or dispatcher instance may have been destroyed since it was registered.
      // Detect this, and remove from collection.
      // Avoid calling dispatcher destructors while the mutex is locked.
      forRemoval.splice(forRemoval.end(), listeners, i++);
      len--;
    }
  }

  // Don't hold locks while running user code:
  lock.unlock();

  BOOST_FOREACH(listener_entry& l, forRemoval) {
    // Call entry->second->onWorkRemoved()
    Dispatcher::work(*l.second, boost::adopt_lock_t());
  }
  forRemoval.clear();

  for (size_t i = 0; i < len; ++i) {

    // note: 
    // 1. As with asio.io.post, post accepts "viod f()"
    // 2. The makeWeakFunctor has () operator with no arg.
    // 3. When asio calls makeWeakFunctor instance(functor), this call leads
    // to "return f(wp<listener>)" 
    // 4. This is the same as bind.

    localListeners[i].second->post(
        makeWeakFunctor(event, localListeners[i].first));
  }
}

size_t DispatchingEventProducerHoisted::getListenerCount() const {

	boost::mutex::scoped_lock lock(mutex);
	return listeners.size();
}

}

NS_ZINC_CLOSE

////////////////////////////////////////
#ifndef ZINC_COMMON_WEAKFUNCTOR_H_
#define ZINC_COMMON_WEAKFUNCTOR_H_

#include "macros.h"

#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>
#include <boost/utility/result_of.hpp>

NS_ZINC_OPEN

/** WeakFunctor
 *
 * When a member function is bound to an object by shared_ptr, the object is
 * preserved for the lifetime of the returned functor.
 *
 * This is not always desirable, and WeakFunctor allows a bind to be made on
 * a object using weak_ptr semantics. If the weak_ptr has expired at functor
 * evaluation time, the WeakFunctor is a null function (ie: does nothing).
 *
 * WeakFunctors are intended to be passed by value.
 *
 * Typically it will be used like:
 *
 * makeWeakFunctor(bind(&Class::ObjectMethod, _1, methodParams...), objectWeakPtr)
 */
template<typename Functor, typename T, 
  typename ResultType = typename boost::result_of<Functor(boost::shared_ptr<T>)>::type>
class WeakFunctor
{
public:
    typedef ResultType result_type;

    explicit WeakFunctor(Functor f_, boost::weak_ptr<T> object_)
      : f(f_), object(object_) {}

    ~WeakFunctor() {}

    result_type operator() ()
    {
        boost::shared_ptr<T> o = object.lock();
        return o ? f(o) : result_type();
    }

private:
    const Functor f;
    const boost::weak_ptr<T> object;
};

/**
 * Specialisation of WeakFunctor for void because you can't return a void value
 * even in a statement in a function returning void, unfortunately.
 */
template<typename Functor, typename T>
class WeakFunctor<Functor, T, void>
{
public:
    typedef void result_type;

    explicit WeakFunctor(Functor f_, boost::weak_ptr<T> object_): f(f_), object(object_) {}

    ~WeakFunctor() {}

    void operator() ()
    {
        boost::shared_ptr<T> o = object.lock();
        if (o)
        {
            f(o);
        }
    }

private:
    const Functor f;
    const boost::weak_ptr<T> object;
};

/**
 * Make a WeakFunctor given a functor and a weak_ptr.
 */
template <typename Functor, typename T>
inline WeakFunctor<Functor,	T>
makeWeakFunctor(Functor f, boost::weak_ptr<T> object)
{
    return WeakFunctor<Functor, T>(f, object);
}

/**
 * Make a WeakFunctor given a functor and a shared_ptr.
 */
template <typename Functor, typename T>
inline WeakFunctor<Functor,	T>
makeWeakFunctor(Functor f, boost::shared_ptr<T> object)
{
    return WeakFunctor<Functor, T>(f, boost::weak_ptr<T>(object));
}

#define WEAK_FUNCTOR(f, p) WeakFunctor<typeof( ## f ## ), p::element_type>(f, p)

#define ZINC_WEAKFUNCTOR_DEFINED_

NS_ZINC_CLOSE

#endif /* ZINC_COMMON_WEAKFUNCTOR_H_ */


////////////////////////////////////////
#ifndef ZINC_EVENTDISPATCHER_H_
#define ZINC_EVENTDISPATCHER_H_

#include "macros.h"
#include "async/Dispatcher.h"

NS_ZINC_OPEN

typedef Dispatcher EventDispatcher;

NS_ZINC_CLOSE

#endif /* ZINC_EVENTDISPATCHER_H_ */


={============================================================================
*kt_dev_code_017* asyc: dispatcher use

<use-case>

1. APP calls SystemClientFactory
   - create a system client factory, DD(inline D) and FD(thread)

2. APP calls createEventRepository().
   - create SystemClientEventReposity and pass DD and FD to it.

3. APP calls  SCER->getEventWindow().
   - create SystemClientEventWindow and pass DD. return future to APP and calls
   getEventsFromSystemAPI.

4. getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
   - use FD, register handler to be notified when dbus calls completes using
   future barrier. 

5. FD calls SystemClientEventRepository::eventWindowDataRetrievalComplete(cmd)
   - this is a registered handler and use EventWindow in cmd

6.


<1> note: The application calls this API

SystemClientFactory() creates two dispatches:

   boost::shared_ptr<NS_ZINC::EventDispatcher> defaultDispatcher;
   boost::shared_ptr<NS_ZINC::FutureDispatcher> futureDispatcher;

   defaultDispatcher(boost::make_shared<InlineDispatcher>())

   // this is SingleThreadDispatcher
   futureDispatcher(boost::make_shared<SequentialFutureDispatcher>())


<2> The application calls this to have SCER:
boost::shared_ptr<NS_URANIUM_METADATA_CLIENT::EventRepository> createEventRepository() 
{
    // createConcreteEventRepository() create SCER 
    // set dispatchers to SCER

    // note: set DD
    concreteER->setDefaultDispatcher(getDefaultDispatcher());
    concreteER->setFutureDispatcher(futureDispatcher);

    return SCER;
}

So DD is inline dispatcher and FD is single threaded dispatcher.


<3> The application calls SCER->getEventWindow();

/*
 * DispatchingFutureProducer
 *
 * Provide an interface for injecting a future dispatcher
 */
class DispatchingFutureProducer : virtual public Polymorphic
{
public:
    virtual void setFutureDispatcher(boost::shared_ptr<FutureDispatcher> dispatcher)
    {
        boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
        this->dispatcher = dispatcher;
    }
    virtual void removeFutureDispatcher()
    {
        boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
        dispatcher.reset();
    }
    virtual boost::shared_ptr<FutureDispatcher> getFutureDispatcher() const
    {
        boost::recursive_mutex::scoped_lock lock(dispatcherMutex);
        return dispatcher;
    }
private:
    boost::shared_ptr<FutureDispatcher> dispatcher;
    mutable boost::recursive_mutex dispatcherMutex;
};

class ZINC_EXPORT SystemClientEventRepository : 
    public EventRepository,
    public NS_ZINC::DispatchingFutureProducer,
    public boost::enable_shared_from_this<SystemClientEventRepository>,
    public MetadataChangeListener
{
    boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher;

    // note: set DD
    void setDefaultDispatcher(boost::shared_ptr<NS_ZINC::EventDispatcher> dispatcher_)
    {
        dispatcher = dispatcher_;
    }

    /**
     * Creates event window from events passed in.
     * @note The method sanitizes the events, removes duplicates and joins
     * adjacent null events 
     * @note This method assumes that if there are duplicates inside events
     * passed in, they'll be identical.
     */
    boost::shared_ptr<SystemClientEventWindow> SystemClientEventRepository::createEventWindow(
            EventWindowCreateCommand& cmd,
            event_collection_ptr events, bool hasStaleData)
    {
        boost::shared_ptr<SystemClientEventWindow> ew = 
            boost::make_shared<SystemClientEventWindow>(cmd.location,
                    sanitizedEvents, serviceRepo, shared_from_this(),
                    (microsec_clock::universal_time() - cmd.dataRetrievalStartTime).total_milliseconds(),
                    cmd.hasDataFromAllSources(), hasStaleData);

        // note: pass DD to EventWindow
        ew->setDispatcher(dispatcher);

        metadataObserver->addListener(ew);
    }
};


// note: this means that client will get shared_ptr<EventWindow> when Future is
// ready.

Future<boost::shared_ptr<EventWindow> > SystemClientEventRepository::getEventWindow(
        uint32_t startingServiceRow, uint32_t serviceCount,
        boost::posix_time::ptime startTime, int32_t seconds,
        event_collection_ptr intersectingEvents, Bounds missing,
        bool isMovingForward)
{
    // note: create Promise(FD)
    NS_ZINC::Promise<boost::shared_ptr<EventWindow> > p(*getFutureDispatcher());

    // note: create a cmd and Promise is copied to cmd that has *SCEW, and promise
    EventWindowCreateCommand cmd( p, newWindowLocation, newWindowLocation,
            intersectingEvents, microsec_clock::universal_time(),
            serviceRepo);

    // create SCEW and set ED(DD)
    boost::shared_ptr<SystemClientEventWindow> ew = createEventWindow(cmd, newWindowEvents,
            hasStaleData);

    // note: this is to say that EW creation is done. so "promise" for EW creation.
    cmd.promise.complete(ew);
    cmd.promiseCompleted = true;

    getEventsFromSystemAPI(cmd);

    // return future to EPG
    return p.getFuture();
}


<4>
void SystemClientEventRepository::getEventsFromSystemAPI(EventWindowCreateCommand& cmd)
{
    // set future dispatcher to future barrier

    NS_ZINC::FutureBarrier bar(*getFutureDispatcher());

    // add {future, member function pointer} pair to future barrier and these
    // futures are futures associated to dbus call. suppose that future will be
    // set when dbus call succeeds and when it is set, member function gets
    // called.
    //
    // note: eventsReceived are overloaded
    //
    // therefore,
    //
    // fMASEvents -> SystemClientEventRepository::eventsReceived()
    // fDTTEvents -> SystemClientEventRepository::eventsReceived()

    void (SystemClientEventRepository::*masCallback)
        (boost::shared_ptr<EventWindowCreateCommand>,
         const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result > > &) =
        &SystemClientEventRepository::eventsReceived;

    void (SystemClientEventRepository::*dttCallback)
        (boost::shared_ptr<EventWindowCreateCommand>,
         const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > &) =
        &SystemClientEventRepository::eventsReceived;

    // note: dynamically created so that used later in bind object
    boost::shared_ptr<EventWindowCreateCommand> 
        sharedCmd = boost::make_shared<EventWindowCreateCommand>(cmd);

    // note:
    // add {future, callback} and callback gets called when future is ready. 
    //
    //   void Callback(FutureValue<T>);
    //   T is "vector < NS_COBALT_SYSTEM::Result>"
    //
    // The eventReceived is overloaded and see that it receives that &FV. When
    // one of eventsReceived is called, set a promise completed.
    //
    // void SystemClientEventRepository::eventsReceived(
    //   boost::shared_ptr<EventWindowCreateCommand> command,
    //   const NS_ZINC::FutureValue< std::vector<NS_COBALT_SYSTEM::Result> >& eventsFV)
    // {
    //     // get the returned data from eventsFV.get() and copy data to a vector.
    //     const std::vector<NS_COBALT_SYSTEM::Result>& systemEvents = eventsFV.get();
    //     event_collection_ptr  clientEvents = getClientEvents(systemEvents);
    //
    //     // this is a promise matches to future passed to application.
    //     // signal client(application) that data is ready by setting
    //     command->promise.complete(data);
    // };
    //

    Future < vector < NS_COBALT_SYSTEM::Result> > fMASEvents =
        metadataBroker->getEventSummariesByServices(recids, start, end);

    bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));

    //
    // void eventsReceived(
    //    boost::shared_ptr<EventWindowCreateCommand> command,
    //    const NS_ZINC::FutureValue< std::vector<NS_IRON_SYSTEM::Event> > & eventsFV)
    // {
    //    event_collection_ptr clientEvents = getClientEvents(systemEvents);
    // }  

    Future < vector < NS_IRON_SYSTEM::Event> > fDTTEvents =
            systemEventRepo->getScheduleEvents(locators, dttStart, end);

    bar.addWithCallback(fDTTEvents, boost::bind(dttCallback, this, sharedCmd, _1));

    // note: after all, eventWindowDataRetrievalComplete() has a notify chain up
    // to a client. 
    
    bar.setCallback(
          boost::bind
            (&SystemClientEventRepository::eventWindowDataRetrievalComplete, 
             shared_from_this(), sharedCmd)
          );
};

<5> goes up to a client via SystemClientEventWindow::produceEvent

void SystemClientEventRepository::eventWindowDataRetrievalComplete(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    notifyExistingWindowAboutNewData(command);
}

void SystemClientEventRepository::notifyExistingWindowAboutNewData(
        boost::shared_ptr<EventWindowCreateCommand> command)
{
    boost::shared_ptr<SystemClientEventWindow> w = command->newWindow.lock();
    w->ConfigChanged();
}


<6> here moves from SCER line to SCEW line

void SystemClientEventWindow::ConfigChanged()
{
    notifyWindowChanged();
}

void SystemClientEventWindow::notifyWindowChanged()
{
   produceEvent(bind(&EventWindowEventListener::EventWindowChanged, _1));
}


<7> The client which is a listener will get called. 

note: After all, client do not provide a dispatcher and will use the default
inline dispatcher and this leads to use future dispacther when future barrier is
completed.

class TextEPGEventWindowEventListener : public EventWindowEventListener
{
    virtual void EventWindowChanged()
    {
    	printDebug("EventWindowChanged.");
        actionProcessor->post(boost::bind(&doRefreshWindowAndPrintStats));
    }
};

// global
boost::shared_ptr<TextEPGEventWindowEventListener> listener = 
   boost::make_shared<TextEPGEventWindowEventListener>();

boost::shared_ptr<EventWindow>  createEventWindow(boost::shared_ptr<EventRepository> eventRepo)
{
    Future<boost::shared_ptr<EventWindow> > f = 
        eventRepo->getEventWindow(0, dimensions.numServices, start, dimensions.duration.total_seconds());

    // note: see what f.get returns
    boost::shared_ptr<EventWindow> newWindow = f.get();

    newWindow->addListener(listener);
    return newWindow;
}


={============================================================================
*kt_dev_code_017* asyc: dispatcher use

mutable boost::ptr_deque<AbstractDeferredCall> deferredCalls;

NS_ZINC::Future<std::map<std::string, std::string> >
GstMediaRouter::getSourceInformation() const
{
  return deferForwardOrDefault(
      boost::bind(&MediaRouter::getSourceInformation, _1),
      std::map< std::string, std::string >()
      );
}

// note:
// sourcing = true; when setSource() is called

template<typename Functor>
typename Functor::result_type ProxyMediaRouter::deferForwardOrDefault(
  Functor f,
  const typename returned_future_type<Functor>::type& defaultValue) const
{
  typedef typename returned_future_type<Functor>::type T;

  scoped_lock lock(mutex);

  if (sourcing) {
    return deferCall(f);
  }

  if (!isSourced())
  {
    return NS_ZINC::completedFuture<T>(*dispatcher, defaultValue);
  }

  return f(impl.get());
}

template<typename Functor>
typename Functor::result_type ProxyMediaRouter::deferCall(Functor f) const 
{
  typedef typename returned_future_type<Functor>::type T;

  std::auto_ptr<DeferredCall<Functor, T> > deferred(new DeferredCall<Functor, T>(dispatcher, f));
  NS_ZINC::Future<T> future(deferred->getFuture());

  deferredCalls.push_back(deferred);

  return future;
}

template<typename Functor, typename T>
class DeferredCall : public AbstractDeferredCall {

  public:

    DeferredCall(boost::shared_ptr<NS_ZINC::Dispatcher> dispatcher, Functor method_) :
      promise(*dispatcher),
      method(method_) {}

    NS_ZINC::Future<T> getFuture() {
      return promise.getFuture();
    }

    void operator()(const MediaRouter* mediaRouter) {
      method(const_cast<MediaRouter*>(mediaRouter))
        .then(boost::bind(&chainedComplete<T>, promise, _1));
    }

  private:
    NS_ZINC::Promise<T> promise;
    Functor method;
};


struct AbstractDeferredCall {

  virtual ~AbstractDeferredCall() {}

  virtual void operator()(const MediaRouter* mediaRouter) = 0;
};

/**
 * This is called by SetSourceContinuation::complete(). The idea is to contain all the
 * state manipulation in one place.
 */
void ProxyMediaRouter::setSourceComplete(
    const std::string& newSource, boost::shared_ptr<MediaRouter> newImpl, 
    boost::shared_ptr<MediaRouterFactory> newFactory) 
{
  scoped_lock lock(mutex);

  lastSource = newSource;
  impl = newImpl;

  if (newFactory) {
    lastFactory = newFactory;
  }

  properties = UnsourcedProperties();

  sourcing = false;

  // Some calls may have been deferred whilst we were setting the source.
  // process those now, but stop if one of them is a call to setSource().
  // FIXME Does not check for setSource() - should it?

  while (!deferredCalls.empty() && !sourcing) {
    deferredCalls.front()(this);
    deferredCalls.pop_front();
  }
}


# ============================================================================
#{
={============================================================================
*kt_dev_design_001* use state and if checks

{example-one}

This uses checks on stat to continue running next step and if it is not okay, stop and return at the
end. If fails in the first, then will run if for every remaining check? Guess not because compiler
will generate a code to jump to the end. Check in assembly code? 

Also this approach has only one housekeeping code at the end unlike an approach below. 

SYSTEM_STATUS PLAY_Start( const PLAY_PARAMS *p_play_params, PLAY_HANDLE *p_hPlay)
{
    SYSTEM_STATUS stat = PLAY_STATUS_OK;

    /* allocate a new playback - if playback already exists -  will return its play object */
    if (SYSTEM_STATUS_IS_OK (stat)) {
        stat = PlayAllocateNew (p_play_params, &pPlaySession);
    }

    /* send fsm input to start */
    if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
        stat = PlaySendFSMInput (pPlaySession, E_PLAY_INPUT_START, ASYNCHRONOUS);
    }

    if (!SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
        DummyStatus = PlayFree (pPlaySession);
    }

    /*  returned play handle */
    if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
        *p_hPlay = pPlaySession -> hPlay;
    }
    else {
        stat = PLAY_STATUS_FAILURE;
    }

    /* unlock the play module data */
    if (SYSTEM_STATUS_IS_OK(lock_stat)) {
        lock_stat = PlayUnlock ();
    }

    if (SYSTEM_STATUS_IS_OK (stat) && (pPlaySession != NULL)) {
        DIAG_LOG_RETURN (VRM_diag_segment_id, ("ended record_item_ID:0x%x, play handle:0x%x, stat:%s \n",
                    pPlaySession->record_item_ID, *p_hPlay, VRM_TYPE2STR_SystemStatus( stat )));
    }
    else {
        DIAG_LOG_ERROR (VRM_diag_segment_id, ("ended record_item_ID:0x%x, play handle:0x%x, stat:%s \n",
                    0, *p_hPlay, VRM_TYPE2STR_SystemStatus( stat )));
    }

    return stat;
}


{example-two}

Use return for each step.

bool X::t_Create(void)
{
    // Create options read/write mutex
    m_option_access_mtx = new PCMutex;
    if( m_option_access_mtx == NULL )
    {
        MHEGDebugFatal(eMHEGapp,
                       "Digital Text ReadWrite Mutex could not be instantiated!");
        return false;
    }

    m_option_access_mtx->Create();
    if( !m_option_access_mtx->FlagCreate() )
    {
        MHEGDebugFatal(eMHEGapp,
                       "Digital Text ReadWrite Mutex could not be created!");
        return false;
    }

    m_mheg_stop_mtx = new PCMutex();
    if( m_mheg_stop_mtx == NULL )
    {
        MHEGDebugFatal(eMHEGapp,
                       "MHEG Stop Mutex could not be instantiated!");
        return false;
    }

    m_mheg_stop_mtx->Create();
    if( !m_mheg_stop_mtx->FlagCreate() )
    {
        MHEGDebugFatal(eMHEGapp,
                       "MHEG Stop Mutex could not be created!");
        return false;
    }
}

Like this case, need to handle CS_DATA_END for every return.

bool oob_fsm_dmx_get( oob_dmx_instance_t* p_dmx )
{
   CS_DATA_BEGIN();

   if(!is_oob_fsm_initialized())
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmx_get: oob_fsm is not initialized.\n" NOR );
      CS_DATA_END();
      return FALSE;
   }

   if(!p_dmx)
   {
      trace_new(FSM_ERR, ERR "oob_fsm_dmx_get: invalid arg: p_dmx(0x%x).\n" NOR, p_dmx );
      CS_DATA_END();
      return FALSE;
   }

   trace_new(FSM_TL2, POP "oob_fsm_dmx_get: oob_dmx.avail_filters(%d)\n" NOR, oob_dmx.avail_filters );

   p_dmx->is_reset_raised     = oob_dmx.is_reset_raised;
   p_dmx->avail_channels      = oob_dmx.avail_channels;
   p_dmx->avail_filters       = oob_dmx.avail_filters;
   p_dmx->connection_notify   = oob_dmx.connection_notify;

   CS_DATA_END();

   return TRUE;
}


==============================================================================
vim:tw=100:ts=2:ft=help:norl:
