*kt_dev_05*                                                                tw=100

kt.dev.boot

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_boost_001| bind: to use member function

# ============================================================================
#{
={============================================================================
*kt_dev_boost_001* bind: to use member function

This is member function pointer declaration:

void (SystemClientEventRepository::*masCallback)
(boost::shared_ptr<X>, const FutureValue< std::vector<Y> > &) =
                &SystemClientEventRepository::eventsReceived;

This is the use of bind:

bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));

However, bind uses 3 arguments but the pointer declaration uses 2 arguments.  Why?


{from-boost-doc}
Using bind with pointers to members

Pointers to member functions and pointers to data members are 'not' function objects, because they
do not support operator(). For convenience, bind accepts member pointers as its first argument, and
the behavior is as if boost::mem_fn has been used to convert the member pointer into a function
object. In other words, the expression

bind(&X::f, args)

is equivalent to

bind<R>(mem_fn(&X::f), args)

where R is the return type of X::f (for member functions) or the type of the member (for data
        members.)

Example:

struct X
{
    bool f(int a);
};

X x;

shared_ptr<X> p(new X);

int i = 5;

bind(&X::f, ref(x), _1)(i);		// x.f(i)
bind(&X::f, &x, _1)(i);			//(&x)->f(i)
bind(&X::f, x, _1)(i);			// (internal copy of x).f(i)
bind(&X::f, p, _1)(i);			// (internal copy of p)->f(i)

The last two examples are interesting in that they produce "self-contained" function objects.
bind(&X::f, x, _1) stores a copy of x. bind(&X::f, p, _1) stores a copy of p, and since p is a
boost::shared_ptr, the function object retains a reference to its instance of X and will remain
valid even when p goes out of scope or is reset(). 

note:
This doc do not have more detail but the stackoverflow said

boost::function<void (int)> f2( boost::bind( &myclass::fun2, this, _1 ) );

to use member function and this seems to be the same with 

bind(&X::f, &x, _1)(i);			//(&x)->f(i)

So this binds to a particular object.


==============================================================================
Copyright: see |ktkb|                              vim:tw=100:ts=3:ft=help:norl:
