*kt_dev_06*                                                                tw=100

kt.dev.boost

/^[#=]{
Use #{ for a group and ={ for a item

|kt_dev_boost_000| install
|kt_dev_boost_001| bind: to use member function
|kt_dev_boost_002| program_options
|kt_dev_boost_003| posix_time
|kt_dev_boost_004| typeof
|kt_dev_boost_005| is_same
|kt_dev_boost_006| lexical_cast
|kt_dev_boost_007| filesystem

|kt_dev_boost_100| asio
|kt_dev_boost_101| asio: tutorial
|kt_dev_boost_102| asio: deadline_timer
|kt_dev_boost_103| asio: deadline_timer


# ============================================================================
#{
={============================================================================
*kt_dev_boost_000* install

http://www.boost.org/doc/libs/1_58_0/more/getting_started/unix-variants.html

1. download and untar
tar --bzip2 -xf /path/to/boost_1_58_0.tar.bz2

2. build and install
3. include in source:

#include <boost/typeof/typeof.hpp>

using namespace boost;

// don't need if installed with defaults.
// 4. specify include directory
// $ g++ -g -std=c++0x -I /usr/local/boost_1_58_0 tboost.cpp 


{build}
If you want to use any of the separately-compiled Boost libraries, you'll need to acquire library
binaries.

Issue the following commands in the shell (don't type $; that represents the shell's prompt):

$ cd path/to/boost_1_58_0
$ ./bootstrap.sh --help

Select your configuration options and invoke ./bootstrap.sh again without the --help option. Unless
you have write permission in your system's /usr/local/ directory, you'll probably want to at least
use

$ sudo ./bootstrap.sh --prefix=path/to/installation/prefix
$ sudo ./b2

to install somewhere else. Also, consider using the --show-libraries and
--with-libraries=library-name-list options to limit the long wait you'll experience if you build
everything. Finally,

$ ./b2 install


{build-error}
5.4   In Case of Build Errors

The only error messages you see when building Boost—if any—should be related to
the IOStreams library's support of zip and bzip2 formats as described here.
Install the relevant development packages for libz and libbz2 if you need those
features. Other errors when building Boost libraries are cause for concern.

Do install and run ./b2 again.

$ sudo apt-get install libbz2-dev


{link}
$ g++ -g t_asio_01.cpp

/usr/local/include/boost/asio/error.hpp:230: undefined reference to `boost::system::system_category()'
collect2: error: ld returned 1 exit status

To solve this since The boost library you are using depends on the boost_system
library. (Not all of them do.)

$ g++ -g -lboost_system t_asio_01.cpp


={============================================================================
*kt_dev_boost_001* bind: to use member function

This is member function pointer declaration:

void (SystemClientEventRepository::*masCallback)
(boost::shared_ptr<X>, const FutureValue< std::vector<Y> > &) =
                &SystemClientEventRepository::eventsReceived;

This is the use of bind:

bar.addWithCallback(fMASEvents, boost::bind(masCallback, this, sharedCmd, _1));

However, bind uses 3 arguments but the pointer declaration uses 2 arguments.  Why?


{from-boost-doc}
Using bind with pointers to members

Pointers to member functions and pointers to data members are 'not' function objects, because they
do not support operator(). For convenience, bind accepts member pointers as its first argument, and
the behavior is as if boost::mem_fn has been used to convert the member pointer into a function
object. In other words, the expression

bind(&X::f, args)

is equivalent to

bind<R>(mem_fn(&X::f), args)

where R is the return type of X::f (for member functions) or the type of the member (for data
        members.)

Example:

struct X
{
    bool f(int a);
};

X x;

shared_ptr<X> p(new X);

int i = 5;

bind(&X::f, ref(x), _1)(i);		// x.f(i)
bind(&X::f, &x, _1)(i);			//(&x)->f(i)
bind(&X::f, x, _1)(i);			// (internal copy of x).f(i)
bind(&X::f, p, _1)(i);			// (internal copy of p)->f(i)

The last two examples are interesting in that they produce "self-contained" function objects.
bind(&X::f, x, _1) stores a copy of x. bind(&X::f, p, _1) stores a copy of p, and since p is a
boost::shared_ptr, the function object retains a reference to its instance of X and will remain
valid even when p goes out of scope or is reset(). 

note:
This doc do not have more detail but the stackoverflow said

boost::function<void (int)> f2( boost::bind( &myclass::fun2, this, _1 ) );

to use member function and this seems to be the same with 

bind(&X::f, &x, _1)(i);			//(&x)->f(i)

So this binds to a particular object.


={============================================================================
*kt_dev_boost_002* program_options

#include <boost/program_options.hpp>
#include <boost/date_time.hpp>

void parseProgramOptions(int argc, char** argv)
{
    std::string output_filename;
    unsigned long timeout_seconds = 0;
    unsigned int window_size = 20;

    boost::program_options::options_description desc("\nWaits until the system becomes idle "
                                                     "and exits.\nOptions");
    desc.add_options()
            ("help,h", "Show this help")
            ("window_size,w", boost::program_options::value(&window_size),
                             "Size of moving-average window (in number of values)")
            ("sampling_period,s", boost::program_options::value(&sampling_period_ms),
                                 "Number of milliseconds between each sample")
            ("output,o", boost::program_options::value(&output_filename),
                                  "File name to print the values to (default=stdout)")
            ("exit_threshold,e", boost::program_options::value(&exit_threshold),
                                "If specified specified (in %) - program will exit if "
                                "CPU utilisation will fall below this value (default=1)")
            ("timeout,t", boost::program_options::value(&timeout_seconds),
                         "Timeout in seconds (default=infinite)")
            ;

    boost::program_options::variables_map vm;
    boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), vm);
    boost::program_options::notify(vm);
    if (vm.count("help"))
    {
        std::cout << desc << std::endl;
        exit(EXIT_SUCCESS);
    }

    // resize moving average window
    ma.resize(window_size);

    started_at = boost::posix_time::microsec_clock::local_time();
    if(timeout_seconds > 0)
    {
        stop_at = started_at + boost::posix_time::seconds(timeout_seconds);
    }

    if(vm.count("output"))
    {
        file.open(output_filename.c_str());
        os = &file;
    }

    *os << "started at     : " << started_at.time_of_day() << "\n";
    *os << "sampling period: " << sampling_period_ms << " ms\n";
}


={============================================================================
*kt_dev_boost_003* posix_time

#include <boost/date_time.hpp>


={============================================================================
*kt_dev_boost_004* typeof

http://www.boost.org/doc/libs/1_58_0/doc/html/typeof.html

Motivation

<object-generator>
Today many template libraries supply object generators to simplify object creation by utilizing the
C++ template argument deduction facility. Consider std::pair. In order to instantiate this class
template and create a temporary object of this instantiation, one has to supply template parameters,
as well as parameters to the constructor:

std::pair<int, double>(5, 3.14159);

To avoid this 'duplication', STL supplies the std::make_pair object generator. When it is used, the
    types of template parameters are deduced from supplied function arguments:

std::make_pair(5, 3.14159);

For the temporary objects it is enough. However, when a named object needs to be allocated, the
    problem appears again:

std::pair<int, double> p(5, 3.14159);

The object generator no longer helps:

std::pair<int, double> p = std::make_pair(5, 3.14159);

It would be nice to deduce the type of the object (on the left) from the expression it is
    initialized with (on the right), but the current C++ syntax does not allow for this.

note: l

The above example demonstrates the essence of the problem but does not demonstrate its scale. Many
libraries, especially expression template libraries, create objects of really complex types, and go
a long way to hide this complexity behind object generators. Consider a nit Boost.Lambda functor:

_1 > 15 && _2 < 20

If one wanted to allocate a named copy of such an innocently looking functor, she would have to
specify something like this:

lambda_functor<
    lambda_functor_base<
        logical_action<and_action>,
        tuple<
            lambda_functor<
                lambda_functor_base<
                    relational_action<greater_action>,
                    tuple<
                        lambda_functor<placeholder<1> >,
                        int const
                    >
                >
            >,
            lambda_functor<
                lambda_functor_base<
                    relational_action<less_action>,
                    tuple<
                        lambda_functor<placeholder<2> >,
                        int const
                    >
                >
            >
        >
    >
>
f = _1 > 15 && _2 < 20;

Not exactly elegant. To solve this problem (as well as some other problems), the C++ standard
    committee is considering a few additions to the standard language, such as typeof/decltype and
    auto (see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1607.pdf).

The typeof operator (or decltype, which is a slightly different flavor of typeof) allows one to
determine the type of an expression at compile time. Using typeof, the above example can be
simplified drastically:

typeof(_1 > 15 && _2 < 20) f = _1 > 15 && _2 < 20;

Much better, but some duplication still exists. The auto type solves the rest of the problem:

auto f = _1 > 15 && _2 < 20;

The purpose of the Boost.Typeof library is to provide a library-based solution, which could be used
    until the language-based facility is added to the Standard and becomes widely available. 


Tutorial

The above examples are possible because the Typeof Library knows about primitive types, such as int,
    double, char, etc. The Typeof Library also knows about most types and templates defined by the
        Standard C++ Library, but the appropriate headers need to be included to take advantage of
        this:


#include <boost/typeof/std/utility.hpp>

namespace ex3
{
    BOOST_AUTO(p, make_pair(1, 2));

    BOOST_STATIC_ASSERT((is_same<BOOST_TYPEOF(p), pair<int, int> >::value));
}

Here <boost/typeof/std/utility.hpp> includes <utility> and contains knowledge about templates
defined there. This naming convention applies in general, for example to let the Typeof Library
handle std::vector, include <boost/typeof/std/vector.hpp>, etc


={============================================================================
*kt_dev_boost_005* is_same

http://www.boost.org/doc/libs/1_50_0/libs/type_traits/doc/html/boost_typetraits/reference/is_same.html

is_same

template <class T, class U>
struct is_same : public true_type-or-false_type {};

Inherits: If T and U are the same types then inherits from true_type, otherwise inherits from
              false_type.

Header: #include <boost/type_traits/is_same.hpp> or #include <boost/type_traits.hpp>

Compiler Compatibility: If the compiler does not support partial-specialization of class templates,
         then this template can not be used with abstract, incomplete or function types.

Examples:

    is_same<int, int> inherits from true_type. 

    is_same<int, int>::type is the type true_type. 

    is_same<int, int>::value is an integral constant expression that evaluates to true. 

    is_same<int const, int>::value is an integral constant expression that evaluates to false. 

    is_same<int&, int>::value is an integral constant expression that evaluates to false. 

    is_same<T, T>::value_type is the type bool. 


#include <iostream>
#include <boost/typeof/typeof.hpp>

using namespace std;
using namespace boost;

int main(int argc, char** argv)
{
    int ival = 5;

    std::cout << "is the same type? " << is_same<decltype(ival), int>::value << std::endl;
}

$ g++ -g -std=c++0x -I /usr/local/boost_1_58_0 tboost.cpp 
$ ./a.out 
is the same type? 1


={============================================================================
*kt_dev_boost_006* lexical_cast

While we weren't looking Boost.Lexical_cast became "in most cases boost::lexical_cast is faster than
scanf, printf, std::stringstream".  Yay for upgrades - now there's no reason to use scanf for
performance reasons.

http://www.boost.org/doc/libs/1_58_0/doc/html/boost_lexical_cast/performance.html#boost_lexical_cast.performance.tests_description


#include "PerfCounter.h"

#include <iostream>
#include <sstream>
#include <boost/lexical_cast.hpp>

int main(int argc,char** argv)
{
    PerfCounter counter;
    
    for(int i=0;i<10000;++i)
    {
        int out;
        sscanf("42","%d",&out);
    }
    counter.snap("scanf int");

    for(int i=0;i<10000;++i)
    {
        int out;
        std::stringstream ss("42");
        ss >> out;
    }
    counter.snap("stringstream int");

    for(int i=0;i<10000;++i)
    {
        int out = boost::lexical_cast<int>("42");
    }
    counter.snap("boost::lexical_cast<int>");
    std::cout << counter.dump() << std::endl;
}

// from a run on debian

$ ./a.out 
Start -> scanf int took 2112us
scanf int -> stringstream int took 27859us
stringstream int -> boost::lexical_cast<int> took 910us
boost::lexical_cast<int> -> end took 0us


<question>
// about the above code

> you're transforming the same value on every iteration, source of which is a const - might this be
> a subject of some optimisation / cache related thing?

Yeah, I was just thinking the same thing. I wouldn't be too surprised if the compiler replaces the
lexical_cast call with a constant result. Try with a random number converted to a string.

<result>
Start -> scanf int took 22us
scanf int -> stringstream int took 45us
stringstream int -> boost::lexical_cast<int> took 3us
boost::lexical_cast<int> -> end took 0us

on the host and

Start -> scanf int took 46us
scanf int -> stringstream int took 392us
stringstream int -> boost::lexical_cast<int> took 11us
boost::lexical_cast<int> -> end took 4us

on the device.


={============================================================================
*kt_dev_boost_007* filesystem

// from code

// read all files from the given directory and populate those in vector
vector<boost::filesystem::path> configFiles(findMediaRouterPluginConfigFiles(configDir));

// "/opt/zinc-trunk/share/platform_data/mediarouter-plugin-config"
// /opt/zinc-trunk/share/platform_data/mediarouter-plugin-config/http-application%2Fdash%2Bxml.plugin-config
// /opt/zinc-trunk/share/platform_data/mediarouter-plugin-config/https-application%2Fdash%2Bxml.plugin-config

BOOST_FOREACH(const boost::filesystem::path& fullPath, configFiles)
{
    // "http-application%2Fdash%2Bxml"
    string fileStem = fullPath.stem();

    // fullPath.string() is:
    // "/opt/zinc-trunk/share/platform_data/mediarouter-plugin-config/http-application%2Fdash%2Bxml.plugin-config"
    //
}


={============================================================================
*kt_dev_boost_100* asio

http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio.html

{overview}

<basic>
Basic Boost.Asio Anatomy

<async>

      Your Program

I/O Object        Your Completion Handler
eg. socket


      io_service

      OS

When an asynchronous operation is used, a different sequence of events occurs. 

1. Your program initiates the connect operation by calling the I/O object:

socket.async_connect(server_endpoint, your_completion_handler);

where your_completion_handler is a function or function object with the
signature:

void your_completion_handler(const boost::system::error_code& ec);

The exact signature required depends on the asynchronous operation being
performed. The reference documentation indicates the appropriate form for each
operation.

2. The I/O object forwards the request to the io_service.

3. The io_service signals to the operating system that it should start an
asynchronous connect.

Time passes. In the synchronous case this wait would have been contained
entirely within the duration of the connect operation.


4. The operating system indicates that the connect operation has completed by
placing the result on a queue, ready to be picked up by the io_service.

5. Your program must make a call to io_service::run() or to one of the similar
io_service member functions in order for the result to be retrieved. 

A call to io_service::run() 'blocks' while there are unfinished asynchronous
operations, so you would typically call it as soon as you have started your
first asynchronous operation.

6. While inside the call to io_service::run(), the io_service dequeues the
result of the operation, translates it into an error_code, and then passes it
to your completion handler.

This is a simplified picture of how Boost.Asio operates. You will want to
delve further into the documentation if your needs are more advanced, such as
extending Boost.Asio to perform other types of asynchronous operations. 


<threads-and-boost-asio>
Threads and Boost.Asio

Thread Safety

In general, it is safe to make concurrent use of distinct objects, but unsafe
to make concurrent use of a single object. However, types such as io_service
provide a stronger guarantee that it is safe to use a single object
concurrently.


Thread Pools

Multiple threads may call io_service::run() to set up a pool of threads from
which completion handlers may be invoked. This approach may also be used with
io_service::post() to use a means to perform any computational tasks across a
thread pool.

Note that all threads that have joined an io_service's pool are considered
equivalent, and the io_service may distribute work across them in an arbitrary
fashion.  

Internal Threads

The implementation of this library for a particular platform may make use of
one or more internal threads to emulate asynchronicity. As far as possible,
    these threads must be invisible to the library user. In particular, the
    threads:

must not call the user's code directly; and
must block all signals.

This approach is complemented by the following guarantee:

Asynchronous completion handlers will only be called from threads that are
currently calling io_service::run(). 

Consequently, it is the library user's responsibility to create and manage all
threads to which the notifications will be delivered.

The reasons for this approach include:

By only calling io_service::run() from a single thread, the user's code can
avoid the development complexity associated with synchronisation. For example,
      a library user can implement scalable servers that are single-threaded
      (from the user's point of view).

A library user may need to perform initialisation in a thread shortly after
the thread starts and before any other application code is executed. For
example, users of Microsoft's COM must call CoInitializeEx before any other
COM operations can be called from that thread.

The library interface is decoupled from interfaces for thread creation and
management, and permits implementations on platforms where threads are not
available.


={============================================================================
*kt_dev_boost_101* asio: tutorial

<01> Timer.1 - Using a timer synchronously
#include <iostream>
#include <boost/asio.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

int main()
{
  boost::asio::io_service io;

  // Next we declare an object of type boost::asio::deadline_timer. The core
  // asio classes that provide I/O functionality (or as in this case timer
  // functionality) always take a reference to an io_service as their first
  // constructor argument. The second argument to the constructor sets the timer
  // to expire 5 seconds from now.

  boost::asio::deadline_timer t(io, boost::posix_time::seconds(5));

  // In this simple example we perform a blocking wait on the timer. That is,
  // the call to deadline_timer::wait() will not return until the timer has
  // expired, 5 seconds after it was created (i.e. not from when the wait
  // starts). 

  t.wait();

  std::cout << "Hello, world!" << std::endl;

  return 0;
}


<02> Timer.2 - Using a timer asynchronously

// This tutorial program demonstrates how to use asio's asynchronous callback
// functionality by modifying the program from tutorial Timer.1 to perform an
// asynchronous wait on the timer.

#include <iostream>
#include <boost/asio.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

// Using asio's asynchronous functionality 'means' having a callback function
// that will be called 'when' an asynchronous operation completes. In this
// program we define a function called print to be called when the asynchronous
// wait finishes.

void print(const boost::system::error_code& /*e*/)
{
  std::cout << "Hello, world!" << std::endl;
}

int main()
{
    boost::asio::io_service io;

    boost::asio::deadline_timer t(io, boost::posix_time::seconds(5));

    // Next, instead of doing a blocking wait as in tutorial Timer.1, we call
    // the deadline_timer::async_wait() function to perform an asynchronous
    // wait. When calling this function we pass the print callback handler that
    // was defined above.

    t.async_wait(&print);

    // Finally, we must call the io_service::run() member function on the
    // io_service object.

    // note: thread
    // The asio library provides a guarantee that callback handlers will only be
    // called from threads that are currently calling io_service::run().
    //
    // Therefore unless the io_service::run() function is called the callback
    // for the asynchronous wait completion will never be invoked.

    // note: run() continue to run
    // The io_service::run() function will also continue to run while there is
    // still "work" to do.  In this example, the work is the asynchronous wait
    // on the timer, so the call will not return until the timer has expired and
    // the callback has completed.

    // It is important to remember to give the io_service some work to do before
    // calling io_service::run(). For example, if we had omitted the above call
    // to deadline_timer::async_wait(), the io_service would not have had any
    // work to do, and consequently io_service::run() would have returned
    // immediately.

    io.run();

    return 0;
}

calls async wait...
calls io.run...

note: blocks on io.run() so wait for timer expired.

Hello, world!
ends...


<03> Timer.3 - Binding arguments to a handler
#include <iostream>
#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

// To implement a repeating timer using asio you need to change the timer's
// expiry time in your callback function, and to then start a new asynchronous
// wait. Obviously this means that the callback function will need to be able
// to access the timer object. To this end we add two new parameters to the
// print function:
//
// * A pointer to a timer object.  
// * A counter so that we can stop the program when the timer fires for the
// sixth time.
// 
// However you will observe that there is no explicit call to ask the
// io_service to stop. Recall that in tutorial Timer.2 we learnt that the
// io_service::run() function completes when there is no more "work" to do. By
// not starting a new asynchronous wait on the timer when count reaches 5, the
// io_service will run out of work and stop running. 

void print(const boost::system::error_code& /*e*/,
    boost::asio::deadline_timer* t, int* count)
{
  if (*count < 5)
  {
    std::cout << "callback: count: " << count << ", t: " << t << std::endl;
    std::cout << "callback: count: " << *count << std::endl;
    ++(*count);

    // Next we move the expiry time for the timer along by one second from the
    // previous expiry time. By calculating the new expiry time relative to
    // the old, we can ensure that the timer does not drift away from the
    // whole-second mark due to any delays in processing the handler.

    t->expires_at(t->expires_at() + boost::posix_time::seconds(1));

    // note: function object
    // Then we start a new asynchronous wait on the timer. As you can see, the
    // boost::bind() function is used to associate the extra parameters with
    // your callback handler. The deadline_timer::async_wait() function
    // expects a handler function (or function object) with the signature
    // void(const boost::system::error_code&). Binding the additional
    // parameters converts your print function into a function object that
    // matches the signature correctly.

    t->async_wait(boost::bind(print,
          boost::asio::placeholders::error, t, count));
  }
}

int main()
{
  boost::asio::io_service io;

  int count = 0;
  boost::asio::deadline_timer t(io, boost::posix_time::seconds(1));

  std::cout << "main: count: " << &count << ", t: " << &t << std::endl;

  // note: pass reference. is it okay when callback is called?

  t.async_wait(boost::bind(print,
        boost::asio::placeholders::error, &t, &count));

  std::cout << "main: calls run" << std::endl;
  io.run();

  std::cout << "main: final count is " << count << std::endl;

  return 0;
}

main: count: 0xbfcf0650, t: 0xbfcf062c
main: calls run
callback: count: 0xbfcf0650, t: 0xbfcf062c
callback: count: 0
callback: count: 0xbfcf0650, t: 0xbfcf062c
callback: count: 1
callback: count: 0xbfcf0650, t: 0xbfcf062c
callback: count: 2
callback: count: 0xbfcf0650, t: 0xbfcf062c
callback: count: 3
callback: count: 0xbfcf0650, t: 0xbfcf062c
callback: count: 4
main: final count is 5


<04> Timer.4 - Using a member function as a handler
#include <iostream>
#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

// The constructor of this class will take a reference to the io_service
// object and use it when initialising the timer_ member. The counter used to
// shut down the program is now also a member of the class. 

class printer
{
public:
  printer(boost::asio::io_service& io)
    : timer_(io, boost::posix_time::seconds(1)),         // note: interesting
      count_(0)
  {
    // The boost::bind() function works just as well with class member
    // functions as with free functions. Since all non-static class member
    // functions have an implicit this parameter, we need to bind this to the
    // function. As in tutorial Timer.3, boost::bind() converts our callback
    // handler (now a member function) into a function object that can be
    // invoked as though it has the signature void(const
    // boost::system::error_code&).

    // You will note that the boost::asio::placeholders::error placeholder is
    // not specified here, as the print member function does not accept an
    // error object as a parameter. 

    std::cout << "ctor: print: " << &printer::print << 
        ", this: " << this << std::endl;
    timer_.async_wait(boost::bind(&printer::print, this));
  }

  ~printer()
  {
    std::cout << "Final count is " << count_ << std::endl;
  }

  // The print member function is very similar to the print function from
  // tutorial Timer.3, except that it now operates on the class data members
  // instead of having the timer and counter passed in as parameters. 

  void print()
  {
    if (count_ < 5)
    {
      std::cout << "print: print: " << &printer::print << 
          ", this: " << this << std::endl;
      std::cout << "print: count: " << count_ << std::endl;
      ++count_;

      timer_.expires_at(timer_.expires_at() + boost::posix_time::seconds(1));
      timer_.async_wait(boost::bind(&printer::print, this));
    }
  }

private:
  boost::asio::deadline_timer timer_;
  int count_;
};

int main()
{
  boost::asio::io_service io;

  printer p1(io);
  printer p2(io);

  std::cout << "main: calls run" << std::endl;
  io.run();
  std::cout << "main: ends run" << std::endl;

  return 0;
}

ctor: print: 1, this: 0xbf956508
ctor: print: 1, this: 0xbf956530
main: calls run
print: print: 1, this: 0xbf956508
print: count: 0
print: print: 1, this: 0xbf956530
print: count: 0
print: print: 1, this: 0xbf956508
print: count: 1
print: print: 1, this: 0xbf956530
print: count: 1
print: print: 1, this: 0xbf956508
print: count: 2
print: print: 1, this: 0xbf956530
print: count: 2
print: print: 1, this: 0xbf956508
print: count: 3
print: print: 1, this: 0xbf956530
print: count: 3
print: print: 1, this: 0xbf956508
print: count: 4
print: print: 1, this: 0xbf956530
print: count: 4
main: ends run
dtor: final count is 5
dtor: final count is 5


<05> Timer.5 - Synchronising handlers in multithreaded programs

// This tutorial demonstrates the use of the boost::asio::strand class to
// synchronise callback handlers in a multithreaded program.

// The previous four tutorials avoided the issue of handler synchronisation by
// calling the io_service::run() function from one thread only. As you already
// know, the asio library provides a guarantee that callback handlers will
// only be called from threads that are currently calling io_service::run().
// Consequently, calling io_service::run() from only 'one' thread ensures that
// callback handlers cannot run concurrently.

// The single threaded approach is usually the best place to start when
// developing applications using asio. The downside is the limitations it
// places on programs, particularly servers, including:

// * Poor responsiveness when handlers can take a long time to complete.
// * An inability to scale on multiprocessor systems.

// If you find yourself running into these limitations, an alternative
// approach is to have a pool of threads 'calling' io_service::run(). However,
// as this allows handlers to execute concurrently, we need a method of
// synchronisation when handlers might be accessing a shared, thread-unsafe
// resource. 

#include <iostream>
#include <boost/asio.hpp>
#include <boost/thread/thread.hpp>
#include <boost/bind.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

// An boost::asio::strand guarantees that, for those handlers that are
// dispatched 'through' it, an executing handler will be allowed to complete
// before the next one is started. This is guaranteed irrespective of the
// number of threads that are calling io_service::run(). Of course, the
// handlers may still execute concurrently with other handlers that were 'not'
// dispatched through an boost::asio::strand, or were dispatched through a
// 'different' boost::asio::strand object. 

class printer
{
public:
  printer(boost::asio::io_service& io)
    : strand_(io),
      timer1_(io, boost::posix_time::seconds(1)),
      timer2_(io, boost::posix_time::seconds(1)),
      count_(0)
  {

    // When initiating the asynchronous operations, each callback handler is
    // "wrapped" using the boost::asio::strand object. The strand::wrap()
    // function returns a new handler that automatically dispatches its
    // contained handler through the boost::asio::strand object. By wrapping
    // the handlers using the same boost::asio::strand, we are ensuring that
    // they cannot execute concurrently.

    timer1_.async_wait(strand_.wrap(boost::bind(&printer::print1, this)));
    timer2_.async_wait(strand_.wrap(boost::bind(&printer::print2, this)));
  }

  ~printer()
  {
    std::cout << "Final count is " << count_ << std::endl;
  }

  // In a multithreaded program, the handlers for asynchronous operations
  // should be synchronised if they access shared resources. In this tutorial,
  // the shared resources used by the handlers (print1 and print2) are
  // std::'cout' and the count_ data member. 

  void print1()
  {
    if (count_ < 10)
    {
      std::cout << "Timer 1: " << count_ << std::endl;
      ++count_;

      timer1_.expires_at(timer1_.expires_at() + boost::posix_time::seconds(1));
      timer1_.async_wait(strand_.wrap(boost::bind(&printer::print1, this)));
    }
  }

  void print2()
  {
    if (count_ < 10)
    {
      std::cout << "Timer 2: " << count_ << std::endl;
      ++count_;

      timer2_.expires_at(timer2_.expires_at() + boost::posix_time::seconds(1));
      timer2_.async_wait(strand_.wrap(boost::bind(&printer::print2, this)));
    }
  }

private:
  boost::asio::io_service::strand strand_;
  boost::asio::deadline_timer timer1_;
  boost::asio::deadline_timer timer2_;
  int count_;
};

// The main function now causes io_service::run() to be called from 'two'
// threads: the main thread and one additional thread. This is accomplished
// using an boost::thread object.

// Just as it would with a call from a single thread, 'concurrent' calls to
// io_service::run() will continue to execute while there is "work" left to
// do. The background thread will not exit until all asynchronous operations
// have completed. 

// note: two threads uses the same io

int main()
{
  boost::asio::io_service io;
  printer p(io);
  boost::thread t(boost::bind(&boost::asio::io_service::run, &io));
  io.run();
  t.join();

  return 0;
}


={============================================================================
*kt_dev_boost_102* asio: deadline_timer

http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_deadline_timer.html

basic_deadline_timer::async_wait

Start an asynchronous wait on the timer.

template<typename WaitHandler>
void-or-deduced async_wait(WaitHandler handler);

This function may be used to initiate an asynchronous wait against the timer.
It always returns immediately.

For each call to async_wait(), the supplied handler will be called exactly
once. The handler will be called when:

The timer has expired.
The timer was cancelled, in which case the handler is passed the error code
boost::asio::error::operation_aborted.

Parameters

handler

The handler to be called when the timer expires. Copies will be made of the
handler as required. The function signature of the handler must be:

void handler(
      const boost::system::error_code& error // Result of operation.
);

Regardless of whether the asynchronous operation completes immediately or not,
the handler will not be invoked from within this function.

Invocation of the handler will be performed in a manner equivalent to using
boost::asio::io_service::post().


={============================================================================
*kt_dev_boost_102* asio: deadline_timer

<ref>
io_service::post

Request the io_service to invoke the given handler and return immediately.

template<typename CompletionHandler>
void-or-deduced post(CompletionHandler handler);

This function is used to ask the io_service to execute the given handler, but without allowing the
    io_service to call the handler from inside this function.

The io_service guarantees that the handler will only be called in a thread in which the run(),
    run_one(), poll() or poll_one() member functions is currently being invoked.  
        
Parameters

handler

The handler to be called. The io_service will make a copy of the handler object as required. The
function signature of the handler must be:

void handler();

Remarks

This function throws an exception only if:

the handler's asio_handler_allocate function; or
the handler's copy constructor

throws an exception. 

<work-class>
io_service::work

Class to inform the io_service when it has work to do.

Member Functions

Name Description

get_io_service Get the io_service associated with the work.

explicit work(boost::asio::io_service & io_service);
               Constructor notifies the io_service that work is starting.
               Copy constructor notifies the io_service that work is starting.

~work          Destructor notifies the io_service that the work is complete.

The work class is used to 'inform' the io_service when work starts and finishes. This ensures that the
io_service object's run() function will not exit while work is underway, and that it does exit when
there is no unfinished work remaining.

The work 'class' is copy-constructible so that it may be used as a data member in a handler class.
It is not assignable. 

<handler>
A free function as a completion handler:

void completion_handler()
{
  ...
}


={============================================================================
*kt_dev_boost_102* asio: code

// boost_1_58_0/boost/asio/detail/deadline_timer_service.hpp
//
  // Start an asynchronous wait on the timer.
  template <typename Handler>
  void async_wait(implementation_type& impl, Handler& handler)
  {
    // Allocate and construct an operation to wrap the handler.
    typedef wait_handler<Handler> op;
    typename op::ptr p = { boost::asio::detail::addressof(handler),
      boost_asio_handler_alloc_helpers::allocate(
        sizeof(op), handler), 0 };
    p.p = new (p.v) op(handler);

    impl.might_have_pending_waits = true;

    BOOST_ASIO_HANDLER_CREATION((p.p, "deadline_timer", &impl, "async_wait"));

    scheduler_.schedule_timer(timer_queue_, impl.expiry, impl.timer_data, p.p);
    p.v = p.p = 0;
  }

// boost_1_58_0/boost/asio/basic_deadline_timer.hpp
//
  template <typename WaitHandler>
  BOOST_ASIO_INITFN_RESULT_TYPE(WaitHandler,
      void (boost::system::error_code))
  async_wait(BOOST_ASIO_MOVE_ARG(WaitHandler) handler)
  {
    // If you get an error on the following line it means that your handler does
    // not meet the documented type requirements for a WaitHandler.
    BOOST_ASIO_WAIT_HANDLER_CHECK(WaitHandler, handler) type_check;

    return this->service.async_wait(this->implementation,
        BOOST_ASIO_MOVE_CAST(WaitHandler)(handler));
  }


==============================================================================
Copyright: see |ktkb|                              vim:tw=100:ts=3:ft=help:norl:
