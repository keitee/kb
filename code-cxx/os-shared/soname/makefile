# SYNOPSIS:
#
#   make [all]  - makes everything.
#   make clean  - removes all files generated by make.

# Where to find user code.
USER_DIR = .

CPPFLAGS += -isystem $(GTEST_DIR)/include -isystem $(GMOCK_DIR)/include 

# CXXFLAGS += -std=c++11 -g -Wall -Wextra -pthread -D_GLIBCXX_DEBUG
CXXFLAGS += -std=c++11 -g -Wall -Wextra -pthread -D_GLIBCXX_DEBUG

TESTS = test_soname_1 test_soname_2 test_soname_3

# TESTS = test_soname \
# 				$(TARGET2)_out \
# 				$(TARGET3)_out \
# 				$(TARGET4)_out \
# 				$(TARGET5)_out

# House-keeping build targets.
all : $(TESTS)

clean :
	rm -f $(TESTS) *.a *.o *.so

# 1
# when use so without soname
#
# $ readelf -d test_soname_1 | grep NEEDED
# 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]
# 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#
# $ readelf -d libfoo.so | grep SONAME
# $ ./test_soname_1
# ./test_soname_1: error while loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory
#
# $ LD_LIBRARY_PATH=. ./test_soname_1
# main: calls foo()...
# foo: this is foo...

libfoo1.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared foo.o -o libfoo1.so

test_soname_1 : libfoo1.so main.c
	gcc -g main.c libfoo1.so -o $@

# 2
# when use soname
#
# $ readelf -d test_soname_2 | grep NEEDED
#  0x0000000000000001 (NEEDED)             Shared library: [libbar.so]
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#
# $ readelf -d libfoo2.so | grep SONAME
#  0x000000000000000e (SONAME)             Library soname: [libbar.so]
#
# ./test_soname_2
# ./test_soname_2: error while loading shared libraries: libbar.so: cannot open shared object file: No such file or directory
#
# LD_LIBRARY_PATH=. ./test_soname_2
# ./test_soname_2: error while loading shared libraries: libbar.so: cannot open shared object file: No such file or directory
#
# ln -s libfoo2.so libbar.so
#
# ./test_soname_2
# ./test_soname_2: error while loading shared libraries: libbar.so: cannot open shared object file: No such file or directory
#
# LD_LIBRARY_PATH=. ./test_soname_2
# main: calls foo()...
# foo: this is foo...

# set soname in so
libfoo2.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared foo.o -o libfoo2.so -Wl,-soname,libbar.so

# when use, do not specify soname
test_soname_2 : libfoo2.so main.c
	gcc -g main.c libfoo2.so -o $@

# 3
# not use soname. what if set libbar.so in main and make a symlink? WORKS 
# readelf -d libfoo3.so | grep SONAME
# readelf -d test_soname_3 | grep NEEDED
#  0x0000000000000001 (NEEDED)             Shared library: [libbar.so]
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

libfoo3.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared foo.o -o libfoo3.so

# when use, do not specify soname
test_soname_3 : libfoo3.so main.c
	gcc -g main.c libbar.so -o $@
