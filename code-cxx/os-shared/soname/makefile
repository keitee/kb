# SYNOPSIS:
#
#   make [all]  - makes everything.
#   make clean  - removes all files generated by make.

# Where to find user code.
USER_DIR = .

CPPFLAGS += -isystem $(GTEST_DIR)/include -isystem $(GMOCK_DIR)/include 

# CXXFLAGS += -std=c++11 -g -Wall -Wextra -pthread -D_GLIBCXX_DEBUG
CXXFLAGS += -std=c++11 -g -Wall -Wextra -pthread -D_GLIBCXX_DEBUG

TESTS = test_soname_1 test_soname_2 test_soname_3 test_soname_4

# TESTS = test_soname \
# 				$(TARGET2)_out \
# 				$(TARGET3)_out \
# 				$(TARGET4)_out \
# 				$(TARGET5)_out

# House-keeping build targets.
all : $(TESTS)

clean :
	rm -f $(TESTS) *.a *.o *.so.*

# 1
# when use so without soname
#
# $ readelf -d test_soname_1 | grep NEEDED
# 0x0000000000000001 (NEEDED)             Shared library: [libfoo1.so]
# 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#
# $ readelf -d libfoo1.so | grep SONAME
# $ ./test_soname_1
# ./test_soname_1: error while loading shared libraries: libfoo1.so: cannot open shared object file: No such file or directory
#
# $ LD_LIBRARY_PATH=. ./test_soname_1
# main: calls foo()...
# foo: this is foo...

libfoo1.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared foo.o -o libfoo1.so

test_soname_1 : libfoo1.so main.c
	gcc -g main.c libfoo1.so -o $@

# 2
# when use soname
#
# $ readelf -d test_soname_2 | grep NEEDED
#  0x0000000000000001 (NEEDED)             Shared library: [libbar.so]
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#
# $ readelf -d libfoo2.so | grep SONAME
#  0x000000000000000e (SONAME)             Library soname: [libbar.so]
#
# ./test_soname_2
# ./test_soname_2: error while loading shared libraries: libbar.so: cannot open shared object file: No such file or directory
#
# LD_LIBRARY_PATH=. ./test_soname_2
# ./test_soname_2: error while loading shared libraries: libbar.so: cannot open shared object file: No such file or directory
#
# ln -s libfoo2.so libbar.so
#
# ./test_soname_2
# ./test_soname_2: error while loading shared libraries: libbar.so: cannot open shared object file: No such file or directory
#
# LD_LIBRARY_PATH=. ./test_soname_2
# main: calls foo()...
# foo: this is foo...

# set soname in so
libfoo2.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared foo.o -o libfoo2.so -Wl,-soname,libbar.so

# when use, do not specify soname
test_soname_2 : libfoo2.so main.c
	gcc -g main.c libfoo2.so -o $@

# 3
# not use soname. what if set libbar.so in main and make a symlink? WORKS 
# readelf -d libfoo3.so | grep SONAME
# readelf -d test_soname_3 | grep NEEDED
#  0x0000000000000001 (NEEDED)             Shared library: [libbar.so]
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

libfoo3.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared foo.o -o libfoo3.so
	ln -s libfoo3.so libbar.so

# when use, do not specify soname
test_soname_3 : libfoo3.so main.c
	gcc -g main.c libbar.so -o $@


# 4
# 
# Typically, the linker name is created in the same directory as the file to
# which it refers. It can be linked either to the real name or to the soname of
# the most recent major version of the library. Usually, a link to the soname is
# preferable, so that changes to the soname are automatically reflected in the
# linker name.
#
# the point of method 4 is:
# `The linker name allows us to construct version-independent link commands`
#
# libdemo.so (sym) -> libdemo.so.1 (sym) -> libdemo.so.1.0.1 (real, soname)
#
# ./test_soname_4
# ./test_soname_4: error while loading shared libraries: libfoo.so.1: cannot open shared object file: No such file or directory
#
# readelf -d test_soname_4 | ag NEEDED
#  0x0000000000000001 (NEEDED)             Shared library: [libfoo.so.1]
#  0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
#
# So this method is better since the method 2 which use soname only force the
# client speficy so file name in link command
#
# for example
#
# gcc -g main.c libfoo1.1.so -o $@
# 
# since a.out finds soname, libbar.1.so at runtime, real so file can be
# controlled by lib owner via symlink.
#
# libbar.1.so -> libfoo.1.1.so (under lib owner control)
# libbar.1.so -> libfoo.1.2.so (under lib owner control)
#
# libbar.2.so -> libfoo.2.1.so (under lib oweer control)

libfoo4.so : foo.c
	gcc -g -c -fpic foo.c
	gcc -g -shared -Wl,-soname,libfoo.so.1 foo.o -o libfoo.so.1.0.1
	ln -s libfoo.so.1.0.1 libfoo.so.1
	ln -s libfoo.so.1 libfoo.so

test_soname_4 : libfoo4.so main.c
	gcc -g main.c libfoo.so -o $@
